From fd181a7f795e4e0af29493d9b28189666d4cb960 Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Wed, 2 Jul 2014 16:20:41 -0400
Subject: [PATCH] ALL-New-NPCBots

---
 HowTo-Congrats-On-Level.txt                        |   38 +
 README.NPCTELEPORT                                 |   14 +
 cmake/compiler/msvc/settings.cmake                 |    2 +-
 doc/AuctionHouseBot.txt                            |  235 +
 npc-entry-list.txt                                 |    4 +
 sql/Bots/character_bots.sql                        |   26 +
 sql/Bots/world_bots.sql                            |  391 +
 sql/TrinityCore-Patches/All-In-One/auth_AIO.sql    |   11 +
 .../All-In-One/characters_AIO.sql                  |    1 +
 sql/TrinityCore-Patches/All-In-One/world_AIO.sql   |   31 +
 .../ArenaGambler/CharactersDB.sql                  |   59 +
 sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql   |  502 ++
 .../GuildLevelSystem/auth_guild_level_system.sql   |    7 +
 .../characters_guild_level_system.sql              |   55 +
 .../GuildLevelSystem/world_guild_level_system.sql  |    6 +
 .../auth_individuale_xp_raten.sql                  |    5 +
 .../world_individuale_xp_raten.sql                 |    8 +
 .../Reforging/char_db_reforges.sql                 |   11 +
 sql/TrinityCore-Patches/Reforging/reforger_npc.sql |    1 +
 .../SummonNPC/world.summonnpc-item.sql             |    3 +
 .../Transmogrification/characters.sql              |   23 +
 .../Transmogrification/updates/_README.txt         |    1 +
 .../updates/characters_update_2_1_to_2_2.sql       |   12 +
 .../updates/characters_update_2_2_to_3_0.sql       |    2 +
 .../updates/characters_update_4_x_to_5_0.sql       |   16 +
 .../updates/world_update_3_5_to_3_6.sql            |    1 +
 .../updates/world_update_4_x_to_5_0.sql            |   27 +
 .../updates/world_update_5_0_to_5_1.sql            |    6 +
 .../Transmogrification/world_NPC.sql               |    6 +
 .../Transmogrification/world_texts.sql             |   18 +
 .../TriniIRC/World_TrinityChat.sql                 |   81 +
 .../beastmaster/2014_04_12-world-beastmaster.sql   |   64 +
 sql/TrinityCore-Patches/enchant/world.enchant.sql  |    4 +
 .../characters-characters_fake-full.sql            |   35 +
 .../characters-characters_fake-structure.sql       |   31 +
 .../fake_players/characters_fake_readme.txt        |   18 +
 .../fake_players/trinity_string_fake_players.sql   |    8 +
 .../guildhouses/world_guildhouses.sql              |   67 +
 .../npc_buff/world_npc_buff.sql                    |   62 +
 .../profession_npc/world_professionnpc.sql         |    4 +
 sql/TrinityCore-Patches/world.npc_teleport.sql     |  119 +
 sql/anticheat.sql                                  |   30 +
 sql/custom/AVFix.sql                               |    3 +
 sql/tools/setup_ahbot.sql                          |   72 +
 src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp    |  121 +
 src/server/game/AI/NpcBots/bot_Events.h            |  133 +
 src/server/game/AI/NpcBots/bot_GridNotifiers.h     |  724 ++
 src/server/game/AI/NpcBots/bot_ai.cpp              | 8124 ++++++++++++++++++++
 src/server/game/AI/NpcBots/bot_ai.h                |  907 +++
 src/server/game/AI/NpcBots/bot_bm_ai.cpp           |  968 +++
 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp | 1622 ++++
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        | 1389 ++++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       | 1086 +++
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         |  910 +++
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      | 1173 +++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       | 1066 +++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |  828 ++
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       | 1340 ++++
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |  519 ++
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      | 1915 +++++
 src/server/game/AI/NpcBots/botcommands.cpp         |  937 +++
 src/server/game/AI/NpcBots/botmgr.cpp              |  823 ++
 src/server/game/AI/NpcBots/botmgr.h                |  109 +
 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp  |  380 +
 src/server/game/AI/ScriptedAI/sc_npc_teleport.h    |  151 +
 src/server/game/Accounts/RBAC.h                    |    6 +
 src/server/game/Anticheat/AnticheatData.cpp        |  118 +
 src/server/game/Anticheat/AnticheatData.h          |   63 +
 src/server/game/Anticheat/AnticheatMgr.cpp         |  434 ++
 src/server/game/Anticheat/AnticheatMgr.h           |   98 +
 src/server/game/Anticheat/AnticheatScripts.cpp     |   14 +
 src/server/game/Anticheat/AnticheatScripts.h       |   15 +
 .../AuctionHouseBot/AuctionHouseBot.cpp            | 1897 +++++
 .../AuctionHouse/AuctionHouseBot/AuctionHouseBot.h | 1249 +++
 src/server/game/AuctionHouse/AuctionHouseMgr.cpp   |   11 +-
 src/server/game/AuctionHouse/AuctionHouseMgr.h     |    2 +
 src/server/game/Battlegrounds/Battleground.cpp     |   47 +-
 src/server/game/Battlegrounds/Battleground.h       |    2 +-
 src/server/game/Battlegrounds/BattlegroundMgr.cpp  |    2 +-
 .../game/Battlegrounds/BattlegroundQueue.cpp       |   83 +-
 src/server/game/Battlegrounds/BattlegroundQueue.h  |   11 +-
 .../game/Battlegrounds/Zones/BattlegroundAB.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundAV.cpp    |   19 +-
 .../game/Battlegrounds/Zones/BattlegroundBE.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundDS.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundNA.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundRL.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundRV.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundWS.cpp    |    3 +-
 src/server/game/CMakeLists.txt                     |   12 +
 src/server/game/Cfbg/Cfbg.cpp                      |  325 +
 src/server/game/Cfbg/Cfbg.h                        |   35 +
 src/server/game/Chat/Channels/Channel.cpp          |    4 +
 src/server/game/Chat/Chat.cpp                      |   41 +
 src/server/game/Chat/Chat.h                        |    3 +
 src/server/game/Conditions/ConditionMgr.cpp        |   22 +
 src/server/game/Conditions/ConditionMgr.h          |    3 +-
 src/server/game/DataStores/DBCStores.cpp           |    4 +-
 src/server/game/DataStores/DBCStores.h             |    2 +-
 src/server/game/DataStores/DBCStructure.h          |    2 +-
 src/server/game/DataStores/DBCfmt.h                |    2 +-
 src/server/game/DungeonFinding/LFGMgr.cpp          |  159 +
 src/server/game/Entities/Creature/Creature.cpp     |  475 ++
 src/server/game/Entities/Creature/Creature.h       |   84 +
 .../game/Entities/Creature/TemporarySummon.cpp     |   10 +
 src/server/game/Entities/Item/ItemPrototype.h      |    9 +-
 src/server/game/Entities/Object/Object.cpp         |   16 +
 src/server/game/Entities/Player/Player.cpp         |  369 +-
 src/server/game/Entities/Player/Player.h           |   84 +-
 src/server/game/Entities/Totem/Totem.cpp           |    7 +
 src/server/game/Entities/Unit/StatSystem.cpp       |    4 +
 src/server/game/Entities/Unit/Unit.cpp             |  609 +-
 src/server/game/Entities/Unit/Unit.h               |   16 +-
 src/server/game/Events/GameEventMgr.cpp            |    8 +-
 src/server/game/Globals/ObjectMgr.cpp              |   76 +
 src/server/game/Globals/ObjectMgr.h                |   22 +
 src/server/game/Groups/Group.cpp                   |   22 +
 src/server/game/Groups/Group.h                     |    3 +
 src/server/game/Guilds/Guild.cpp                   |  144 +
 src/server/game/Guilds/Guild.h                     |   37 +
 src/server/game/Handlers/AuctionHouseHandler.cpp   |   10 +-
 src/server/game/Handlers/BattleGroundHandler.cpp   |    4 +-
 src/server/game/Handlers/CharacterHandler.cpp      |    3 +
 src/server/game/Handlers/ChatHandler.cpp           |   29 +-
 src/server/game/Handlers/LootHandler.cpp           |   11 +
 src/server/game/Handlers/MiscHandler.cpp           |   49 +-
 src/server/game/Handlers/MovementHandler.cpp       |    4 +
 src/server/game/Handlers/QueryHandler.cpp          |    2 +-
 src/server/game/Handlers/SpellHandler.cpp          |   38 +-
 src/server/game/Mails/Mail.cpp                     |    8 +
 src/server/game/Maps/Map.cpp                       |   27 +
 src/server/game/Maps/MapManager.cpp                |   80 +
 src/server/game/Miscellaneous/Formulas.h           |   16 +-
 src/server/game/Miscellaneous/Language.h           |   27 +-
 src/server/game/Movement/MotionMaster.cpp          |   14 +
 src/server/game/OutdoorPvP/OutdoorPvP.cpp          |   17 +
 src/server/game/Reputation/ReputationMgr.cpp       |   10 +
 src/server/game/Scripting/ScriptLoader.cpp         |   99 +-
 src/server/game/Scripting/ScriptMgr.cpp            |    3 +
 src/server/game/Server/WorldSession.cpp            |    4 +
 src/server/game/Spells/Spell.cpp                   |   20 +
 src/server/game/Spells/SpellEffects.cpp            |    1 +
 src/server/game/Spells/SpellInfo.cpp               |    5 +
 src/server/game/TriniChat/IRCClient.cpp            |  109 +
 src/server/game/TriniChat/IRCClient.h              |  253 +
 src/server/game/TriniChat/IRCCmd.cpp               |  930 +++
 src/server/game/TriniChat/IRCCmd.h                 |  141 +
 src/server/game/TriniChat/IRCCmde.cpp              | 2337 ++++++
 src/server/game/TriniChat/IRCFunc.h                |  278 +
 src/server/game/TriniChat/IRCIO.cpp                |  470 ++
 src/server/game/TriniChat/IRCLog.cpp               |   81 +
 src/server/game/TriniChat/IRCLog.h                 |   42 +
 src/server/game/TriniChat/IRCSock.cpp              |  166 +
 src/server/game/TriniChat/MCS_OnlinePlayers.cpp    |   98 +
 src/server/game/TriniChat/MCS_OnlinePlayers.h      |   38 +
 src/server/game/TriniChat/framework/CMakeLists.txt |   11 +
 .../TriniChat/framework/Dynamic/FactoryHolder.h    |   63 +
 .../TriniChat/framework/Dynamic/ObjectRegistry.h   |  111 +
 .../game/TriniChat/framework/GameSystem/Grid.h     |  143 +
 .../TriniChat/framework/GameSystem/GridLoader.h    |   79 +
 .../framework/GameSystem/GridRefManager.h          |   44 +
 .../TriniChat/framework/GameSystem/GridReference.h |   55 +
 .../game/TriniChat/framework/GameSystem/NGrid.h    |  189 +
 .../TriniChat/framework/GameSystem/TypeContainer.h |  126 +
 .../framework/GameSystem/TypeContainerFunctions.h  |  116 +
 .../GameSystem/TypeContainerFunctionsPtr.h         |  170 +
 .../framework/GameSystem/TypeContainerVisitor.h    |  119 +
 .../TriniChat/framework/Network/SocketDefines.h    |   49 +
 .../TriniChat/framework/Platform/CompilerDefs.h    |   64 +
 .../game/TriniChat/framework/Platform/Define.h     |   85 +
 .../TriniChat/framework/Policies/CreationPolicy.h  |  110 +
 .../framework/Policies/ObjectLifeTime.cpp          |   36 +
 .../TriniChat/framework/Policies/ObjectLifeTime.h  |   53 +
 .../game/TriniChat/framework/Policies/Singleton.h  |   65 +
 .../TriniChat/framework/Policies/SingletonImp.h    |   93 +
 .../TriniChat/framework/Policies/ThreadingModel.h  |  130 +
 .../TriniChat/framework/Utilities/ByteConverter.h  |   66 +
 .../game/TriniChat/framework/Utilities/Callback.h  |  386 +
 .../Utilities/CountedReference/Reference.h         |  100 +
 .../Utilities/CountedReference/ReferenceHolder.h   |   42 +
 .../Utilities/CountedReference/ReferenceImpl.h     |  133 +
 .../TriniChat/framework/Utilities/LinkedList.h     |  247 +
 .../Utilities/LinkedReference/RefManager.h         |   94 +
 .../Utilities/LinkedReference/Reference.h          |   58 +
 .../game/TriniChat/framework/Utilities/TypeList.h  |   46 +
 .../TriniChat/framework/Utilities/UnorderedMap.h   |   73 +
 src/server/game/World/World.cpp                    |  293 +
 src/server/game/World/World.h                      |   30 +
 src/server/scripts/CMakeLists.txt                  |    6 +
 src/server/scripts/Commands/cs_ah_bot.cpp          |  482 ++
 src/server/scripts/Commands/cs_anticheat.cpp       |  262 +
 src/server/scripts/Commands/cs_guild.cpp           |  133 +-
 src/server/scripts/Commands/cs_message.cpp         |   14 +
 src/server/scripts/Commands/cs_modify.cpp          |   64 +
 src/server/scripts/Custom/ArenaGambler.cpp         |  308 +
 src/server/scripts/Custom/ArenaGamblingSystem.cpp  |  723 ++
 src/server/scripts/Custom/ArenaGamblingSystem.h    |  443 ++
 src/server/scripts/Custom/CMakeLists.txt           |    4 +-
 src/server/scripts/Custom/Congrats_on_Level.cpp    |   90 +
 src/server/scripts/Custom/Reforging.cpp            |  548 ++
 src/server/scripts/Custom/Transmogrification.cpp   |  868 +++
 src/server/scripts/Custom/Transmogrification.h     |  170 +
 src/server/scripts/Custom/Transmogrifier.cpp       |  414 +
 src/server/scripts/Custom/all-in-one.cpp           | 1330 ++++
 src/server/scripts/Custom/beastmaster.cpp          |  385 +
 src/server/scripts/Custom/enchant.cpp              | 1621 ++++
 src/server/scripts/Custom/guildmaster.cpp          |  313 +
 src/server/scripts/Custom/killstreak.cpp           |   63 +
 src/server/scripts/Custom/levelnpc.cpp             |  192 +
 src/server/scripts/Custom/npc_teleport.cpp         |  222 +
 src/server/scripts/Custom/npcbuff.cpp              |  426 +
 src/server/scripts/Custom/professionnpc.cpp        |  396 +
 src/server/scripts/Custom/summon.cpp               |   46 +
 src/server/scripts/Spells/spell_generic.cpp        |   18 +-
 src/server/scripts/Spells/spell_paladin.cpp        |   41 +
 src/server/scripts/Spells/spell_priest.cpp         |    4 +
 .../Database/Implementation/CharacterDatabase.cpp  |   31 +
 .../Database/Implementation/CharacterDatabase.h    |   22 +
 .../Database/Implementation/WorldDatabase.cpp      |    5 +
 .../shared/Database/Implementation/WorldDatabase.h |    5 +
 src/server/worldserver/CMakeLists.txt              |    1 +
 src/server/worldserver/CommandLine/CliRunnable.cpp |    9 +
 src/server/worldserver/Main.cpp                    |    1 +
 src/server/worldserver/Master.cpp                  |   11 +-
 src/server/worldserver/worldserver.conf.dist       | 1030 +++
 225 files changed, 53509 insertions(+), 135 deletions(-)
 create mode 100644 HowTo-Congrats-On-Level.txt
 create mode 100644 README.NPCTELEPORT
 create mode 100644 doc/AuctionHouseBot.txt
 create mode 100644 npc-entry-list.txt
 create mode 100644 sql/Bots/character_bots.sql
 create mode 100644 sql/Bots/world_bots.sql
 create mode 100644 sql/TrinityCore-Patches/All-In-One/auth_AIO.sql
 create mode 100644 sql/TrinityCore-Patches/All-In-One/characters_AIO.sql
 create mode 100644 sql/TrinityCore-Patches/All-In-One/world_AIO.sql
 create mode 100644 sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
 create mode 100644 sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
 create mode 100644 sql/TrinityCore-Patches/GuildLevelSystem/auth_guild_level_system.sql
 create mode 100644 sql/TrinityCore-Patches/GuildLevelSystem/characters_guild_level_system.sql
 create mode 100644 sql/TrinityCore-Patches/GuildLevelSystem/world_guild_level_system.sql
 create mode 100644 sql/TrinityCore-Patches/Individuale_XP-Raten/auth_individuale_xp_raten.sql
 create mode 100644 sql/TrinityCore-Patches/Individuale_XP-Raten/world_individuale_xp_raten.sql
 create mode 100644 sql/TrinityCore-Patches/Reforging/char_db_reforges.sql
 create mode 100644 sql/TrinityCore-Patches/Reforging/reforger_npc.sql
 create mode 100644 sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/characters.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/_README.txt
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_1_to_2_2.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_2_to_3_0.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/characters_update_4_x_to_5_0.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/world_update_3_5_to_3_6.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/world_update_4_x_to_5_0.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/world_update_5_0_to_5_1.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/world_NPC.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/world_texts.sql
 create mode 100644 sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql
 create mode 100644 sql/TrinityCore-Patches/beastmaster/2014_04_12-world-beastmaster.sql
 create mode 100644 sql/TrinityCore-Patches/enchant/world.enchant.sql
 create mode 100644 sql/TrinityCore-Patches/fake_players/characters-characters_fake-full.sql
 create mode 100644 sql/TrinityCore-Patches/fake_players/characters-characters_fake-structure.sql
 create mode 100644 sql/TrinityCore-Patches/fake_players/characters_fake_readme.txt
 create mode 100644 sql/TrinityCore-Patches/fake_players/trinity_string_fake_players.sql
 create mode 100644 sql/TrinityCore-Patches/guildhouses/world_guildhouses.sql
 create mode 100644 sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql
 create mode 100644 sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql
 create mode 100644 sql/TrinityCore-Patches/world.npc_teleport.sql
 create mode 100644 sql/anticheat.sql
 create mode 100644 sql/custom/AVFix.sql
 create mode 100644 sql/tools/setup_ahbot.sql
 create mode 100644 src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_Events.h
 create mode 100644 src/server/game/AI/NpcBots/bot_GridNotifiers.h
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_bm_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/botmgr.cpp
 create mode 100644 src/server/game/AI/NpcBots/botmgr.h
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.h
 create mode 100644 src/server/game/Anticheat/AnticheatData.cpp
 create mode 100644 src/server/game/Anticheat/AnticheatData.h
 create mode 100644 src/server/game/Anticheat/AnticheatMgr.cpp
 create mode 100644 src/server/game/Anticheat/AnticheatMgr.h
 create mode 100644 src/server/game/Anticheat/AnticheatScripts.cpp
 create mode 100644 src/server/game/Anticheat/AnticheatScripts.h
 create mode 100644 src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
 create mode 100644 src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
 create mode 100644 src/server/game/Cfbg/Cfbg.cpp
 create mode 100644 src/server/game/Cfbg/Cfbg.h
 create mode 100644 src/server/game/TriniChat/IRCClient.cpp
 create mode 100644 src/server/game/TriniChat/IRCClient.h
 create mode 100644 src/server/game/TriniChat/IRCCmd.cpp
 create mode 100644 src/server/game/TriniChat/IRCCmd.h
 create mode 100644 src/server/game/TriniChat/IRCCmde.cpp
 create mode 100644 src/server/game/TriniChat/IRCFunc.h
 create mode 100644 src/server/game/TriniChat/IRCIO.cpp
 create mode 100644 src/server/game/TriniChat/IRCLog.cpp
 create mode 100644 src/server/game/TriniChat/IRCLog.h
 create mode 100644 src/server/game/TriniChat/IRCSock.cpp
 create mode 100644 src/server/game/TriniChat/MCS_OnlinePlayers.cpp
 create mode 100644 src/server/game/TriniChat/MCS_OnlinePlayers.h
 create mode 100644 src/server/game/TriniChat/framework/CMakeLists.txt
 create mode 100644 src/server/game/TriniChat/framework/Dynamic/FactoryHolder.h
 create mode 100644 src/server/game/TriniChat/framework/Dynamic/ObjectRegistry.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/Grid.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/GridLoader.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/GridRefManager.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/GridReference.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/NGrid.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/TypeContainer.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctions.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctionsPtr.h
 create mode 100644 src/server/game/TriniChat/framework/GameSystem/TypeContainerVisitor.h
 create mode 100644 src/server/game/TriniChat/framework/Network/SocketDefines.h
 create mode 100644 src/server/game/TriniChat/framework/Platform/CompilerDefs.h
 create mode 100644 src/server/game/TriniChat/framework/Platform/Define.h
 create mode 100644 src/server/game/TriniChat/framework/Policies/CreationPolicy.h
 create mode 100644 src/server/game/TriniChat/framework/Policies/ObjectLifeTime.cpp
 create mode 100644 src/server/game/TriniChat/framework/Policies/ObjectLifeTime.h
 create mode 100644 src/server/game/TriniChat/framework/Policies/Singleton.h
 create mode 100644 src/server/game/TriniChat/framework/Policies/SingletonImp.h
 create mode 100644 src/server/game/TriniChat/framework/Policies/ThreadingModel.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/ByteConverter.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/Callback.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/CountedReference/Reference.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceHolder.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceImpl.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/LinkedList.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/LinkedReference/RefManager.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/LinkedReference/Reference.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/TypeList.h
 create mode 100644 src/server/game/TriniChat/framework/Utilities/UnorderedMap.h
 create mode 100644 src/server/scripts/Commands/cs_ah_bot.cpp
 create mode 100644 src/server/scripts/Commands/cs_anticheat.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGambler.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGamblingSystem.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGamblingSystem.h
 create mode 100644 src/server/scripts/Custom/Congrats_on_Level.cpp
 create mode 100644 src/server/scripts/Custom/Reforging.cpp
 create mode 100644 src/server/scripts/Custom/Transmogrification.cpp
 create mode 100644 src/server/scripts/Custom/Transmogrification.h
 create mode 100644 src/server/scripts/Custom/Transmogrifier.cpp
 create mode 100644 src/server/scripts/Custom/all-in-one.cpp
 create mode 100644 src/server/scripts/Custom/beastmaster.cpp
 create mode 100644 src/server/scripts/Custom/enchant.cpp
 create mode 100644 src/server/scripts/Custom/guildmaster.cpp
 create mode 100644 src/server/scripts/Custom/killstreak.cpp
 create mode 100644 src/server/scripts/Custom/levelnpc.cpp
 create mode 100644 src/server/scripts/Custom/npc_teleport.cpp
 create mode 100644 src/server/scripts/Custom/npcbuff.cpp
 create mode 100644 src/server/scripts/Custom/professionnpc.cpp
 create mode 100644 src/server/scripts/Custom/summon.cpp

diff --git a/HowTo-Congrats-On-Level.txt b/HowTo-Congrats-On-Level.txt
new file mode 100644
index 0000000..4613d18
--- /dev/null
+++ b/HowTo-Congrats-On-Level.txt
@@ -0,0 +1,38 @@
+This small script allows for a reward to automatically go into the inventory of any player that makes it to a specific level.
+
+Make sure to modify this script before using. You must hard code in the money amounts, and item entry numbers, plus spell numbers.
+
+An example:
+
+This is the part of the cpp file you must edit. I will explain each part.
+
+            case 10:
+        money = 100;
+        item = ITEMID;
+        item2 = ITEMID2;
+        spell = SPELLID;
+        break;
+
+Here is the breakdown:
+
+            case 10: (10 = Level 10)
+        money = 100; (100 = 100 gold)
+        item = ITEMID; (Change ITEMID to the entry number of the item you want offered at this level)
+        item2 = ITEMID2; (Change ITEMID2 to the entry number of second item)
+        spell = SPELLID; (Change SPELLID to the spell id number)
+        break;
+
+So if you wanted to offer 100 gold, a pet cat (pet carrier, black tabby) and a pet cockroach, plus buff the player with Power Word: Fortitude, it would look like this:
+
+
+            case 10:
+        money = 100;
+        item = 8491;
+        item2 = 10393;
+        spell = 48161;
+        break;
+
+You must do this for each level you want to have give rewards. At this time, since items are automatically added, the player loses the reward(s) if
+their bags are full.
+
+DB Table version coming soon.
\ No newline at end of file
diff --git a/README.NPCTELEPORT b/README.NPCTELEPORT
new file mode 100644
index 0000000..015c9c2
--- /dev/null
+++ b/README.NPCTELEPORT
@@ -0,0 +1,14 @@
+NPC Teleport for Trinity
+
+Original author : Wilibald09
+
+Allows you to add a custom NPC for teleporting, using .npc add 100000.
+The default NPC is entry 100000.
+
+All settings are located in the DB, so you can customize and add destinations,
+set level restrictions and also charge the player for teleporting.
+
+Installation:
+
+Run the query setup_npc_teleport.sql located in the trinity sql directory on
+your world DB. This will setup the DB and you can customize from there.
diff --git a/cmake/compiler/msvc/settings.cmake b/cmake/compiler/msvc/settings.cmake
index 3194967..6aa603a 100644
--- a/cmake/compiler/msvc/settings.cmake
+++ b/cmake/compiler/msvc/settings.cmake
@@ -1,7 +1,7 @@
 # set up output paths for executable binaries (.exe-files, and .dll-files on DLL-capable platforms)
 set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
 
-set(MSVC_EXPECTED_VERSION 18.0)
+set(MSVC_EXPECTED_VERSION 16.0)
 
 if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS MSVC_EXPECTED_VERSION)
   message(FATAL_ERROR "MSVC: TrinityCore requires version ${MSVC_EXPECTED_VERSION} (MSVC 2013) to build but found ${CMAKE_CXX_COMPILER_VERSION}")
diff --git a/doc/AuctionHouseBot.txt b/doc/AuctionHouseBot.txt
new file mode 100644
index 0000000..8170bd2
--- /dev/null
+++ b/doc/AuctionHouseBot.txt
@@ -0,0 +1,235 @@
+Populates the auction houses with items. It can make the game feel a bit more
+like official on small servers. Items and prices are chosen randomly based on
+the parameters you define. If an auction expires, auctions are deleted quietly.
+AHBot will not buy it's own items, and will not receive mail from the AH
+or get returned mail.
+
+===============================================================================
+~~HOW TO CONFIGURE~~
+===============================================================================
+Step 1.) Create a character that you are going to use as the auction house bot
+         character. This character will be the auction's owner for all the
+         items created by the bot.
+Step 2.) Go into the realm database and note the account number for the
+         character.
+Step 3.) Go into the characters database and note the character's GUID.
+Step 4.) Log in at least once with this character.
+         (Do not change the configuration before this)
+Step 5.) Tune the configuration options in the configuration file and the
+         Database.
+
+#These are the settings in the configuration file:
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+AuctionHouseBot.DEBUG enables (1) or disables (0) Debug output
+AuctionHouseBot.EnableSeller enables (1) or disables (0) the Seller
+AuctionHouseBot.EnableBuyer enables (1) or disables (0) the Buyer
+AuctionHouseBot.UseBuyPriceForSeller Use SellPrice (0) or BuyPrice (1) for determining prices
+AuctionHouseBot.UseBuyPriceForBuyer Use SellPrice (0) or BuyPrice (1) for determining prices
+AuctionHouseBot.Account is the account number (in realmd->account table) of the player you want to run as the auction bot. Note: a value of 0 will disable the bot.
+AuctionHouseBot.GUID is the GUID (in characters->characters table) of the player you want to run as the auction bot. Note: a value of 0 will disable the bot.
+AuctionHouseBot.ItemsPerCycle determines how many items are added each time AHBot is run (once per minute, by default)
+
+#These are the Filters For filtering certain items/trade goods from the AH
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+
+AuctionHouseBot.VendorItems is a boolean value (0 or 1) that indicates whether to include Vendor only items
+AuctionHouseBot.VendorTradeGoods is a boolean value (0 or 1) that indicates whether to include Vendor only Trade Goods
+AuctionHouseBot.LootItems  is a boolean value (0 or 1) that indicates whether to include Loot/Fish/Skin/etc. only items
+AuctionHouseBot.LootTradeGoods  is a boolean value (0 or 1) that indicates whether to include Loot/Fish/Skin/etc. only Trade Goods
+AuctionHouseBot.OtherItems  is a boolean value (0 or 1) that indicates whether to include Other items not covered by the first 2
+AuctionHouseBot.OtherTradeGoods  is a boolean value (0 or 1) that indicates whether to include Other Trade Goods not covered by the first 2
+AuctionHouseBot.No_Bind is a boolean value (0 or 1) that indicates whether to include items with a bonding of 0
+AuctionHouseBot.Bind_When_Picked_Up = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 1
+AuctionHouseBot.Bind_When_Equipped = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 2
+AuctionHouseBot.Bind_When_Use = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 3
+AuctionHouseBot.Bind_Quest_Item = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 4
+AuctionHouseBot.DisabledItems is a list of item ids separated by space that will Disable certain items that are usually unavailable to Players
+AuctionHouseBot.DisablePermEnchant is a boolean value (0 or 1) that will Disable Items with a Permanent Enchantment
+AuctionHouseBot.DisableConjured is a boolean value (0 or 1) that will Disable Conjured Items
+AuctionHouseBot.DisableGems is a boolean value (0 or 1) that will Disable Gems
+AuctionHouseBot.DisableMoney is a boolean value (0 or 1) that will Disable Items that are used as money
+AuctionHouseBot.DisableMoneyLoot is a boolean value (0 or 1) that will Disable Items that have Money as a loot
+AuctionHouseBot.DisableLootable is a boolean value (0 or 1) that will Disable Items that have other items as loot
+AuctionHouseBot.DisableKeys is a boolean value (0 or 1) that will Disable Items that are keys
+AuctionHouseBot.DisableDuration is a boolean value (0 or 1) that will Disable Items with a duration
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel is a boolean value (0 or 1) that will Disable items that are BOP or Quest Item with a Required level that is less than the Item Level
+
+#These Filters are boolean (0 or 1) and will disable items that are
+#specifically meant for the Class named.
+#(UnusedClass is Class 10, which was skipped for some reason)
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+#These are the Filters For filtering certain items/trade goods from the AH
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
+#These are the settings in the Database:
+#Each Auctionhouse has it's own set of these
+
+MinItems = 0
+#The Minimum number of items you want to keep in the auction houses.
+#(default 0 - minimum will be the same as maximum).
+#If it is higher than the value of the corresponding maxItems setting,
+#it will be set down to match the maxItems setting.
+
+MaxItems = 0
+#The Maximum number of items you want to keep in the auction houses.
+
+#These must add up to 100 each one is the percentage
+#of the auction items that should be trade goods of
+#that quality. A value of 0 will disable.
+
+PercentGreyTradeGoods = 0
+PercentWhiteTradeGoods = 27
+PercentGreenTradeGoods = 12
+PercentBlueTradeGoods = 10
+PercentPurpleTradeGoods = 1
+PercentOrangeTradeGoods = 0
+PercentYellowTradeGoods = 0
+
+PercentGreyItems = 0
+PercentWhiteItems = 10
+PercentGreenItems = 30
+PercentBlueItems = 8
+PercentPurpleItems = 2
+PercentOrangeItems = 0
+PercentYellowItems = 0
+
+#MinPrice(Color)    is the minimum price adjustment for items. For example the default is 150, which means 150%. So if an item vendors for 1g it would go to auction for a minimum of 1.5g.
+#MaxPrice(Color)    is the maximum price adjustment for items.
+#MinBidPrice(Color) these two control the starting bid as a percent of the buyout price. For example, if MinBidPrice is 30 and MaxBidPrice is 80 the starting bid for the auction will randomly be between 30-80% of the randomly chosen buyout price.
+#MaxBidPrice(Color) these two control the starting bid as a percent of the buyout price. For example, if MinBidPrice is 30 and MaxBidPrice is 80 the starting bid for the auction will randomly be between 30-80% of the randomly chosen buyout price.
+#MaxStack(Color)    is maximum stack size to create for this quality type. A value of zero will disable the maximum stack size for this quality allowing the bot to create stacks (of random size) of items as big as the item type allows.
+
+MinPriceGrey = 100
+MaxPriceGrey = 150
+MinBidPriceGrey = 70
+MaxBidPriceGrey = 100
+MaxStackGrey = 0
+MinPriceWhite = 150
+MaxPriceWhite = 250
+MinBidPriceWhite = 70
+MaxBidPriceWhite = 100
+MaxStackWhite = 0
+MinPriceGreen = 800
+MaxPriceGreen = 1400
+MinBidPriceGreen = 80
+MaxBidPriceGreen = 100
+MaxStackGreen = 0
+MinPriceBlue = 1250
+MaxPriceBlue = 1750
+MinBidPriceBlue = 75
+MaxBidPriceBlue = 100
+MaxStackBlue = 0
+MinPricePurple = 2250
+MaxPricePurple = 4550
+MinBidPricePurple = 80
+MaxBidPricePurple = 100
+MaxStackPurple = 0
+MinPriceOrange = 4250
+MaxPriceOrange = 5550
+MinBidPriceOrange = 80
+MaxBidPriceOrange = 100
+MaxStackOrange = 0
+MinPriceYellow = 5250
+MaxPriceYellow = 6550
+MinBidPriceYellow = 80
+MaxBidPriceYellow = 100
+MaxStackYellow = 0
+
+#These are the multipliers that are applied to the vendor price for an item, that determines if AHBot will buy it or not.
+#1 means AHBot will pay the same as (or less than) a vendor would pay, 2 means up to twice as much, etc.
+
+BuyerPriceGrey = 1
+BuyerPriceWhite = 3
+BuyerPriceGreen = 5
+BuyerPriceBlue = 12
+BuyerPricePurple = 15
+BuyerPriceOrange = 20
+BuyerPriceYellow = 22
+
+#BuyerBiddingInterval is the time (in minutes) between bids.
+#BuyerBidsPerInterval is the number of bids the buyer will make in a cycle
+
+BuyerBiddingInterval = 1
+BuyerBidsPerInterval = 1
+
+
+
+How to use ahcommands from the console (CLI) or in game with GM level 3 players:
+ahbotoptions - will display usage instructions
+ahbotoptions help - will display the list of commands
+
+ahexpire - will expire all the auctions in the requested auction house that were created by AHBot.
+minitems - will set the minimum number of items in the AH before it starts being filled again.
+maxitems - will set the maximum number of items in the AH.
+percentages - will set the percentage of each quality in the AH
+minprice - will set the minimum price multiplier for auctions.
+maxprice - will set the maximum price multiplier for auctions.
+minbidprice - will set the minimum starting bid as a percent of the buyout price for auctions.
+maxbidprice - will set the maximum starting bid as a percent of the buyout price for auctions.
+maxstack - will set the maximum number of items in stacks for auctions. 0 will set the maximum to the maximum for that item type.
+buyerprice - will set the bid price multiplier for auctions.
+biddinginterval - will set the number of minutes between bids on auctions.
+bidsperinterval - will set the number of bids to enter per cycle.
+
+The auction house IDs are:
+2 - Alliance
+6 - Horde
+7 - Neutral
+
+
+AHBot Originally made by Chris K. Currently maintained by Paradox
+Much thanks to Chris K, grether and Dolomit6!
+AHBot Now includes AHBuyer created by Kerbe as a derivative of AHBot, and later modified by Paradox
diff --git a/npc-entry-list.txt b/npc-entry-list.txt
new file mode 100644
index 0000000..249da26
--- /dev/null
+++ b/npc-entry-list.txt
@@ -0,0 +1,4 @@
+This file will list the script, and the entry number of the npc used.
+
+Enchant:
+100067 - Young Woman
\ No newline at end of file
diff --git a/sql/Bots/character_bots.sql b/sql/Bots/character_bots.sql
new file mode 100644
index 0000000..026e420
--- /dev/null
+++ b/sql/Bots/character_bots.sql
@@ -0,0 +1,26 @@
+DROP TABLE IF EXISTS `characters_npcbot`;
+CREATE TABLE `characters_npcbot` (
+  `entry` int(10) unsigned NOT NULL COMMENT 'creature_template.entry',
+  `owner` int(10) unsigned NOT NULL DEFAULT '0' COMMENT 'characters.guid (lowguid)',
+  `roles` tinyint(3) unsigned NOT NULL COMMENT 'bitmask: tank(1),dps(2),heal(4),ranged(8)',
+  `faction` int(10) unsigned NOT NULL DEFAULT '14',
+  `equipMhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipOhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipRhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipHead` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipShoulders` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipChest` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipWaist` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipLegs` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFeet` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipWrist` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipHands` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipBack` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipBody` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFinger1` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFinger2` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipTrinket1` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipTrinket2` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipNeck` int(10) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/Bots/world_bots.sql b/sql/Bots/world_bots.sql
new file mode 100644
index 0000000..5b10f89
--- /dev/null
+++ b/sql/Bots/world_bots.sql
@@ -0,0 +1,391 @@
+
+-- GENERAL --
+
+SET @BOT_START = 70001;
+SET @BOT_END   = 71000;
+
+delete from `creature_template` where entry between @BOT_START and @BOT_END;
+
+insert into `creature_template`
+(`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`,
+`minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`,
+`rangeattacktime`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`,
+`type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`,
+`spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`,
+`questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`)
+values
+('70001','0','0','0','0','0','5001','0','5001','0','Khelden','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70002','0','0','0','0','0','1294','0','1294','0','Zaldimar','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70003','0','0','0','0','0','1484','0','1484','0','Maginor','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70004','0','0','0','0','0','3344','0','3344','0','Anetta','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70005','0','0','0','0','0','1495','0','1495','0','Laurena','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70006','0','0','0','0','0','1295','0','1295','0','Josetta','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70007','0','0','0','0','0','3345','0','3345','0','Drusilla','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70008','0','0','0','0','0','1930','0','1930','0','Alamar','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70009','0','0','0','0','0','1469','0','1469','0','Demisette','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70010','0','0','0','0','0','12749','0','12749','0','Nalesette','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','3','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70011','0','0','0','0','0','3401','0','3401','0','Branstock','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70012','0','0','0','0','0','3395','0','3395','0','Thorgas','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70013','0','0','0','0','0','3343','0','3343','0','Llane','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70014','0','0','0','0','0','3399','0','3399','0','Thran','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70015','0','0','0','0','0','1300','0','1300','0','Lyria','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70016','0','0','0','0','0','3351','0','3351','0','Jorik','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70017','0','0','0','0','0','3407','0','3407','0','Solm','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70018','0','0','0','0','0','1297','0','1297','0','Keryn','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70019','0','0','0','0','0','1507','0','1507','0','Osborne','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70020','0','0','0','0','0','3346','0','3346','0','Sammuel','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70021','0','0','0','0','0','3393','0','3393','0','Bob','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70022','0','0','0','0','0','1299','0','1299','0','Wilhelm','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70023','0','0','0','0','0','1499','0','1499','0','Brisombre','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70024','0','0','0','0','0','10216','0','10216','0','Marry','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70025','0','0','0','0','0','4552','0','4552','0','Haromm','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70026','0','0','0','0','0','4567','0','4567','0','Kartosh','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70027','0','0','0','0','0','3429','0','3429','0','MaxanAnvol','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70028','0','0','0','0','0','10215','0','10215','0','Magis','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70029','0','0','0','0','0','3431','0','3431','0','GranVivehache','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70030','0','0','0','0','0','1622','0','1622','0','Azar','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70031','0','0','0','0','0','3436','0','3436','0','Hogral','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70032','0','0','0','0','0','3053','0','3053','0','Kelstrum','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70033','0','0','0','0','0','1578','0','1578','0','Dannal','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70034','0','0','0','0','0','1579','0','1579','0','SombreDuesten','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70035','0','0','0','0','0','1592','0','1592','0','Isabella','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70036','0','0','0','0','0','1581','0','1581','0','Maximillion','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70037','0','0','0','0','0','1604','0','1604','0','Rupert','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70038','0','0','0','0','0','1600','0','1600','0','Cain','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70039','0','0','0','0','0','1602','0','1602','0','SombreBeryl','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+-- gap
+('70041','0','0','0','0','0','10548','0','10548','0','Milituus','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70042','0','0','0','0','0','2810','0','2810','0','Lexington','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70043','0','0','0','0','0','2123','0','2123','0','Siln','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70044','0','0','0','0','0','19598','0','19598','0','Umbrua','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70045','0','0','0','0','0','2102','0','2102','0','Tigor','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70046','0','0','0','0','0','2082','0','2082','0','Beram','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70047','0','0','0','0','0','2106','0','2106','0','Turak','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70048','0','0','0','0','0','2121','0','2121','0','Sheal','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70049','0','0','0','0','0','2115','0','2115','0','Kym','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70050','0','0','0','0','0','2112','0','2112','0','Kary','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70051','0','0','0','0','0','2087','0','2087','0','Holt','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70052','0','0','0','0','0','2105','0','2105','0','Urek','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70053','0','0','0','0','0','2103','0','2103','0','Torm','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70054','0','0','0','0','0','2096','0','2096','0','Sark','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70055','0','0','0','0','0','17211','0','17211','0','Kerra','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70056','0','0','0','0','0','2139','0','2139','0','Miles Welsh','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70057','0','0','0','0','0','2138','0','2138','0','Malakai','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70058','0','0','0','0','0','2137','0','2137','0','Cobb','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70059','0','0','0','0','0','2134','0','2134','0','Shymm','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','1','0','0','0','0','0','0','0','0','0','0','143','145','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70060','0','0','0','0','0','6058','0','6058','0','Ursyn','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70061','0','0','0','0','0','2135','0','2135','0','Thurston','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70062','0','0','0','0','0','3793','0','3793','0','Harutt','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70063','0','0','0','0','0','3819','0','3819','0','Gart','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','8','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70064','0','0','0','0','0','3810','0','3810','0','Lanka','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70065','0','0','0','0','0','10180','0','10180','0','Meela','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70066','0','0','0','0','0','3794','0','3794','0','Krang','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70067','0','0','0','0','0','10734','0','10734','0','Gennia','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70068','0','0','0','0','0','3811','0','3811','0','Yaw','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70069','0','0','0','0','0','3816','0','3816','0','Narm','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70070','0','0','0','0','0','1880','0','1880','0','Frang','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70071','0','0','0','0','0','1882','0','1882','0','Jenshan','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','8','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70072','0','0','0','0','0','1884','0','1884','0','Nartok','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70073','0','0','0','0','0','1878','0','1878','0','Shikrik','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70074','0','0','0','0','0','3743','0','3743','0','Tarshaw','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70075','0','0','0','0','0','3744','0','3744','0','Thotar','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','2','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70076','0','0','0','0','0','3745','0','3745','0','Dhugru','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70077','0','0','0','0','0','3746','0','3746','0','Swart','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70078','0','0','0','0','0','1324','0','1324','0','Groldar','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70079','0','0','0','0','0','1325','0','1325','0','Mirket','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70080','0','0','0','0','0','1326','0','1326','0','Zevrost','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70081','0','0','0','0','0','1360','0','1360','0','Kardris','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70082','0','0','0','0','0','1373','0','1373','0','Ormak','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','2','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70083','0','0','0','0','0','1374','0','1374','0','Grezz','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70084','0','0','0','0','0','1375','0','1375','0','Sorek','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70085','0','0','0','0','0','4231','0','4231','0','Siantsu','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70086','0','0','0','0','0','4239','0','4239','0','Xorjuul','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','2','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70087','0','0','0','0','0','4241','0','4241','0','Siandur','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','2','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70088','0','0','0','0','0','4242','0','4242','0','Zelmak','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70089','0','0','0','0','0','7915','0','7915','0','ClaudeErksine','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','3','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70090','0','0','0','0','0','1721','0','1721','0','Alyissia','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70091','0','0','0','0','0','1725','0','1725','0','FrahunMurmombre','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70092','0','0','0','0','0','1733','0','1733','0','Shanda','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70093','0','0','0','0','0','1732','0','1732','0','Mardant','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70094','0','0','0','0','0','1707','0','1707','0','Kyra','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70095','0','0','0','0','0','1704','0','1704','0','Jannok','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70096','0','0','0','0','0','1708','0','1708','0','Laurna','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70097','0','0','0','0','0','1706','0','1706','0','Kal','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70098','0','0','0','0','0','4296','0','4296','0','Harruk','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','3','0','3','2','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70099','0','0','0','0','0','4299','0','4299','0','Reban','Hunter bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','3','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70100','0','0','0','0','0','4304','0','4304','0','Bolyun','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','3','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70101','0','0','0','0','0','1897','0','1897','0','Taijin','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70102','0','0','0','0','0','4068','0','4068','0','Kenjai','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70103','0','0','0','0','0','2066','0','2066','0','Danlaar','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70104','0','0','0','0','0','2196','0','2196','0','Ariasta','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70105','0','0','0','0','0','2198','0','2198','0','Sildanair','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70106','0','0','0','0','0','2200','0','2200','0','Astarii','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70107','0','0','0','0','0','2201','0','2201','0','Jandria','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70108','0','0','0','0','0','2202','0','2202','0','Lariia','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70109','0','0','0','0','0','2231','0','2231','0','Syurna','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70110','0','0','0','0','0','7669','0','7669','0','Elissa','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70111','0','0','0','0','0','2252','0','2252','0','Erion','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70112','0','0','0','0','0','2243','0','2243','0','Anishar','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70113','0','0','0','0','0','2250','0','2250','0','Denatharion','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70114','0','0','0','0','0','2255','0','2255','0','Fylerian','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70115','0','0','0','0','0','2416','0','2416','0','Caelyb','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','3','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70116','0','0','0','0','0','2675','0','2675','0','Kaal','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70117','0','0','0','0','0','16800','0','16800','0','Lana','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70118','0','0','0','0','0','2646','0','2646','0','Richard','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70119','0','0','0','0','0','10214','0','10214','0','Kaelystia','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','6','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70120','0','0','0','0','0','2644','0','2644','0','Pierce','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70121','0','0','0','0','0','2657','0','2657','0','Anastasia','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70122','0','0','0','0','0','2620','0','2620','0','Chris','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70123','0','0','0','0','0','2658','0','2658','0','Angela','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70124','0','0','0','0','0','2614','0','2614','0','Baltus','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70125','0','0','0','0','0','3054','0','3054','0','Kelv','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70126','0','0','0','0','0','3055','0','3055','0','Bilban','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70127','0','0','0','0','0','3056','0','3056','0','Daera','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70128','0','0','0','0','0','3072','0','3072','0','Olmin','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70129','0','0','0','0','0','3073','0','3073','0','Regnus','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70130','0','0','0','0','0','3086','0','3086','0','Theodrus','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70131','0','0','0','0','0','3066','0','3066','0','Braenna','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70132','0','0','0','0','0','3085','0','3085','0','Toldren','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+-- gap
+('70134','0','0','0','0','0','3108','0','3108','0','Bink','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70135','0','0','0','0','0','10214','0','10214','0','Juli','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70136','0','0','0','0','0','3109','0','3109','0','Nittegousse','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70137','0','0','0','0','0','3089','0','3089','0','Valgar','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70138','0','0','0','0','0','3088','0','3088','0','Beldruk','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70139','0','0','0','0','0','3087','0','3087','0','Brandur','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70140','0','0','0','0','0','3101','0','3101','0','Hulfdan','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70141','0','0','0','0','0','3100','0','3100','0','Ormyr','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70142','0','0','0','0','0','3113','0','3113','0','Phenwick','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70143','0','0','0','0','0','3115','0','3115','0','Coeurdechardon','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70144','0','0','0','0','0','3116','0','3116','0','Eglantin','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70145','0','0','0','0','0','3122','0','3122','0','Alexander','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70146','0','0','0','0','0','3280','0','3280','0','Wu','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70147','0','0','0','0','0','3287','0','3287','0','Ilsa','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70148','0','0','0','0','0','3283','0','3283','0','Joshua','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70149','0','0','0','0','0','3284','0','3284','0','Arthur','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70150','0','0','0','0','0','3289','0','3289','0','Katherine','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70151','0','0','0','0','0','3291','0','3291','0','Deline','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70152','0','0','0','0','0','3286','0','3286','0','Sandahl','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70153','0','0','0','0','0','3292','0','3292','0','Jennea','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70154','0','0','0','0','0','19803','0','19803','0','Elsharin','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70155','0','0','0','0','0','3299','0','3299','0','Kaerbrus','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70156','0','0','0','0','0','3300','0','3300','0','Sheldras','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70157','0','0','0','0','0','3301','0','3301','0','Theridran','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70158','0','0','0','0','0','3312','0','3312','0','Einris','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70159','0','0','0','0','0','3309','0','3309','0','Ulfir','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70160','0','0','0','0','0','3310','0','3310','0','Thorfin','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70161','0','0','0','0','0','10171','0','10171','0','UnThuwa','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70162','0','0','0','0','0','4524','0','4524','0','Pephredo','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70163','0','0','0','0','0','4522','0','4522','0','Enyo','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70164','0','0','0','0','0','4526','0','4526','0','Mai','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70165','0','0','0','0','0','4523','0','4523','0','Deino','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70166','0','0','0','0','0','4665','0','4665','0','Birgitte','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70167','0','0','0','0','0','12849','0','12849','0','Thuul','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70168','0','0','0','0','0','4690','0','4690','0','Zayus','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70169','0','0','0','0','0','10473','0','10473','0','Xyera','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70170','0','0','0','0','0','4711','0','4711','0','Urkyo','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70171','0','0','0','0','0','6060','0','6060','0','Uthelnay','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70172','0','0','0','0','0','6072','0','6072','0','Dink','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70173','0','0','0','0','0','6071','0','6071','0','Darnath','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70174','0','0','0','0','0','7356','0','7356','0','Karman','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70175','0','0','0','0','0','11037','0','11037','0','Evencane','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70176','0','0','0','0','0','7357','0','7357','0','Jannos','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70177','0','0','0','0','0','7538','0','7538','0','Alenndaar','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','4','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70178','0','0','0','0','0','10738','0','10738','0','Golhine','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70179','0','0','0','0','0','9337','0','9337','0','Hesuwa','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','3','0','3','6','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70180','0','0','0','0','0','9336','0','9336','0','Xao\'tsu','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','3','0','3','2','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70181','0','0','0','0','0','9338','0','9338','0','Belia','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','3','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70182','0','0','0','0','0','10245','0','10245','0','Dargh','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','3','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70183','0','0','0','0','0','11044','0','11044','0','Meideros','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70184','0','0','0','0','0','11048','0','11048','0','Presse','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70185','0','0','0','0','0','11053','0','11053','0','Rohan','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70186','0','0','0','0','0','12053','0','12053','0','Loganaar','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70187','0','0','0','0','0','13171','0','13171','0','Romano','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70188','0','0','0','0','0','13341','0','13341','0','Sagorne','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70189','0','0','0','0','0','15522','0','15522','0','Julia','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70190','0','0','0','0','0','16811','0','16811','0','Ithelis','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70191','0','0','0','0','0','15524','0','15524','0','Invocateur','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70192','0','0','0','0','0','15518','0','15518','0','Matrone','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70193','0','0','0','0','0','2659','0','2659','0','Eclaireur','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70194','0','0','0','0','0','15520','0','15520','0','Sallina','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','10','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70195','0','0','0','0','0','16685','0','16685','0','Noellene','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70196','0','0','0','0','0','16707','0','16707','0','Ponaris','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70197','0','0','0','0','0','16222','0','16222','0','Keilnei','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','11','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70198','0','0','0','0','0','16223','0','16223','0','Valaatu','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70199','0','0','0','0','0','16224','0','16224','0','Aurelon','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70200','0','0','0','0','0','16225','0','16225','0','Zalduun','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70201','0','0','0','0','0','16226','0','16226','0','Kore','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70202','0','0','0','0','0','16787','0','16787','0','Alamma','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70203','0','0','0','0','0','16800','0','16800','0','Talionia','Warlock Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','8','0','16384','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warlock_bot','-1'),
+('70204','0','0','0','0','0','16831','0','16831','0','Zanien','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3500','2000','2','0','16384','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70205','0','0','0','0','0','16781','0','16781','0','Zaedana','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70206','0','0','0','0','0','16824','0','16824','0','Quithas','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70207','0','0','0','0','0','16739','0','16739','0','Harene','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70208','0','0','0','0','0','16778','0','16778','0','Tana','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','10','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70209','0','0','0','0','0','16816','0','16816','0','Oninath','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','10','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70210','0','0','0','0','0','16829','0','16829','0','Bachi','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70211','0','0','0','0','0','16767','0','16767','0','Zelanis','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70212','0','0','0','0','0','16798','0','16798','0','Elara','Rogue Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','1600','2000','4','0','16384','0','0','0','0','4','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','rogue_bot','-1'),
+('70213','0','0','0','0','0','16858','0','16858','0','Shalannius','Druid Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2200','2000','2','0','16384','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','druid_bot','-1'),
+('70214','0','0','0','0','0','17434','0','17434','0','Deremiis','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','11','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70215','0','0','0','0','0','17247','0','17247','0','Caedmos','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70216','0','0','0','0','0','17225','0','17225','0','Baatun','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70217','0','0','0','0','0','17212','0','17212','0','Ahonan','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70218','0','0','0','0','0','17598','0','17598','0','Firmanvaar','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70219','0','0','0','0','0','16860','0','16860','0','Actron','Hunter Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','11','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70220','0','0','0','0','0','17213','0','17213','0','Behomat','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70221','0','0','0','0','0','17600','0','17600','0','Nobundo','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70222','0','0','0','0','0','17599','0','17599','0','Tuluun','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70223','0','0','0','0','0','16914','0','16914','0','Sulaa','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70224','0','0','0','0','0','17215','0','17215','0','Ruada','Warrior Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3400','2000','1','0','16384','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','warrior_bot','-1'),
+('70225','0','0','0','0','0','17233','0','17233','0','Semid','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70226','0','0','0','0','0','17232','0','17232','0','Guvan','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70227','0','0','0','0','0','17234','0','17234','0','Tullas','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70228','0','0','0','0','0','17488','0','17488','0','Killac','Hunter bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','8','0','0','1','2800','2000','2','0','16384','0','0','0','0','3','11','2','8','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','hunter_bot','-1'),
+('70229','0','0','0','0','0','17226','0','17226','0','Jol','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70230','0','0','0','0','0','17248','0','17248','0','Fallat','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70231','0','0','0','0','0','17243','0','17243','0','Harnan','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70232','0','0','0','0','0','17241','0','17241','0','Bati','Mage Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3800','2000','8','0','16384','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','mage_bot','-1'),
+('70233','0','0','0','0','0','17792','0','17792','0','Hobahken','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70234','0','0','0','0','0','6820','0','6820','0','Gurrag','Shaman Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2600','2000','2','0','16384','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','shaman_bot','-1'),
+('70235','0','0','0','0','0','19596','0','19596','0','Auberose','Paladin Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','2300','2000','2','0','16384','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','paladin_bot','-1'),
+('70236','0','0','0','0','0','10335','10335','10335','10335','Afina','Priest Bot','','0','80','80','2','14','1','1.2','1.3','1','0','1','6','0','0','1','3600','2000','8','0','16384','0','0','0','0','5','1','0','0','0','7','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','priest_bot','-1'),
+('70237','0','0','0','0','0','26939','26939','26939','26939','Imhadria','Death Knight Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70238','0','0','0','0','0','28039','28039','28039','28039','Mynx','Death Knight Bot','','0','80','80','2','14','1','1.2','1.3','0.8','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70239','0','0','0','0','0','26688','26688','26688','26688','Lankral','Death Knight Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70240','0','0','0','0','0','26195','26195','26195','26195','Silver','Death Knight Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70241','0','0','0','0','0','27402','27402','27402','27402','Vereth','Death Knight Bot','','0','80','80','2','14','1','1.2','1.3','0.8','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70242','0','0','0','0','0','27189','27189','27189','27189','Arly','Death Knight Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70243','0','0','0','0','0','26217','26217','26217','26217','Setaal','Death Knight Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70244','0','0','0','0','0','28842','28842','28842','28842','Illyrie','Death Knight Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70245','0','0','0','0','0','28840','28840','28840','28840','Zor\'be','Death Knight Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70246','0','0','0','0','0','25512','25512','25512','25512','Datura','Death Knight Bot','','0','80','80','2','14','1','1.2','1.3','1','0','2','12','0','0','1','3300','2000','1','0','16384','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157552','death_knight_bot','-1'),
+('70247','0','0','0','0','0','1132','0','1132','0','Voidwalker','Warlock\'s Pet Bot',NULL,'0','80','80','2','14','0','1.2','1.3','1','0','2','3','0','0','1','2000','2000','2','0','0','0','16','0','0','0','0','0','0','0','3','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','voidwalker_bot','-1'),
+('70248','0','0','0','0','0','1105','0','0','0','Hunter\'s Pet',NULL,NULL,'0','80','80','0','14','0','1.1','1.14286','1','0','87','117','0','214','1','2000','0','1','0','0','0','7','0','0','0','0','61','90','21','1','1','0','0','0','0','0','0','0','0','0','5708','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','149','1','0','0','','-1'),
+-- 70249-70300 reserved for pet types
+('70301','0','0','0','0','0','17659','17659','17659','17659','Gorkramato','Ex. Blademaster','','0','81','81','2','14','1','1.2','1.3','1.05','4','2','24','0','0','1','2200','2000','1','0','16384','0','0','0','0','12','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','68157560','blademaster_bot','-1'),
+
+('71000','0','0','0','0','0','16853','16853','16853','16853','Airen','Priestess of Suffering',NULL,'0','95','95','1','14','1','1.2','1.3','1.173','4','850','1150','0','100','5','1500','0','1','898','49152','2','0','0','0','0','0','0','0','0','3','67110912','0','0','0','450','450','450','450','450','450','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1000','1','5','1','0','0','0','0','0','0','0','0','617299839','1048946','npc_Airen_qI','-213');
+
+
+-- EQUIPS --
+
+delete from `creature_equip_template` where entry between @BOT_START and @BOT_END;
+
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values
+('70001','1','18842','0','0'), ('70002','1','18842','0','0'), ('70003','1','18842','0','0'), ('70004','1','31289','0','0'), ('70005','1','31289','0','0'), ('70006','1','31289','0','0'), ('70007','1','31186','0','0'), ('70008','1','31186','0','0'), ('70009','1','31186','0','0'), ('70010','1','2291','0','2825'), ('70011','1','31289','0','0'), ('70012','1','2291','0','2825'), ('70013','1','18002','0','0'), ('70014','1','27903','0','0'), ('70015','1','7723','0','0'), ('70016','1','13984','6448','0'), ('70017','1','13984','6448','0'), ('70018','1','6633','820','0'), ('70019','1','13984','6448','0'), ('70020','1','12584','18825','0'), ('70021','1','18876','0','0'), ('70022','1','12584','18825','0'), ('70023','1','18876','0','0'), ('70024','1','18842','0','0'), ('70025','1','18203','18202','0'), ('70026','1','31186','0','0'), ('70027','1','31289','0','0'), ('70028','1','18842','0','0'), ('70029','1','28367','0','0'), ('70030','1','12584','18825','0'), ('70031','1','13984','6448','0'), ('70032','1','27903','0','0'), ('70033','1','18002','0','0'), ('70034','1','31289','0','0'), ('70035','1','18842','0','0'), ('70036','1','31186','0','0'), ('70037','1','31186','0','0'), ('70038','1','18842','0','0'), ('70039','1','31289','0','0'), ('70041','1','18842','0','0'), ('70042','1','18842','0','0'), ('70043','1','18203','18202','0'), ('70044','1','18203','18202','0'), ('70045','1','18203','18202','0'), ('70046','1','18203','18202','0'), ('70047','1','25622','0','0'), ('70048','1','25622','0','0'), ('70049','1','25622','0','0'),
+('70050','1','2291','0','2825'), ('70051','1','2291','0','2825'), ('70052','1','2291','0','2825'), ('70053','1','18002','0','0'), ('70054','1','27903','0','0'), ('70055','1','28367','0','0'), ('70056','1','31289','0','0'), ('70057','1','31289','0','0'), ('70058','1','31289','0','0'), ('70059','1','18842','0','0'), ('70060','1','18842','0','0'), ('70061','1','18842','0','0'), ('70062','1','28367','0','0'), ('70063','1','25622','0','0'), ('70064','1','2291','0','2825'), ('70065','1','18203','18202','0'), ('70066','1','18002','0','0'), ('70067','1','25622','0','0'), ('70068','1','2291','0','2825'), ('70069','1','18203','18202','0'), ('70070','1','27903','0','0'), ('70071','1','2291','0','2825'), ('70072','1','31186','0','0'), ('70073','1','18203','18202','0'), ('70074','1','18002','0','0'), ('70075','1','2291','0','2825'), ('70076','1','31186','0','0'), ('70077','1','18203','18202','0'), ('70078','1','31186','0','0'), ('70079','1','31186','0','0'), ('70080','1','31186','0','0'), ('70081','1','18203','18202','0'), ('70082','1','2291','0','2825'), ('70083','1','7723','0','0'), ('70084','1','18002','0','0'), ('70085','1','18203','18202','0'), ('70086','1','2291','0','2825'), ('70087','1','2291','0','2825'), ('70088','1','27903','0','0'), ('70089','1','2291','0','2825'), ('70090','1','28367','0','0'), ('70091','1','6633','820','0'), ('70092','1','31289','0','0'), ('70093','1','25622','0','0'), ('70094','1','18002','0','0'), ('70095','1','13984','6448','0'), ('70096','1','31289','0','0'), ('70097','1','25622','0','0'), ('70098','1','2291','0','2825'), ('70099','1','2291','0','2825'),
+('70100','1','2291','0','2825'), ('70101','1','31289','0','0'), ('70102','1','31289','0','0'), ('70103','1','2291','0','2825'), ('70104','1','7723','0','0'), ('70105','1','18002','0','0'), ('70106','1','31289','0','0'), ('70107','1','31289','0','0'), ('70108','1','31289','0','0'), ('70109','1','13984','6448','0'), ('70110','1','18842','0','0'), ('70111','1','6633','820','0'), ('70112','1','13984','6448','0'), ('70113','1','25622','0','0'), ('70114','1','25622','0','0'), ('70115','1','2291','0','2825'), ('70116','1','31186','0','0'), ('70117','1','31186','0','0'), ('70118','1','31186','0','0'), ('70119','1','18842','0','0'), ('70120','1','18842','0','0'), ('70121','1','18842','0','0'), ('70122','1','27903','0','0'), ('70123','1','18002','0','0'), ('70124','1','7723','0','0'), ('70125','1','18002','0','0'), ('70126','1','28367','0','0'), ('70127','1','2291','0','2825'), ('70128','1','2291','0','2825'), ('70129','1','2291','0','2825'), ('70130','1','31289','0','0'), ('70131','1','31289','0','0'), ('70132','1','31289','0','0'), ('70134','1','18842','0','0'), ('70135','1','18842','0','0'), ('70136','1','18842','0','0'), ('70137','1','18876','0','0'), ('70138','1','12584','18825','0'), ('70139','1','18876','0','0'), ('70140','1','6633','820','0'), ('70141','1','13984','6448','0'), ('70142','1','6633','820','0'), ('70143','1','31186','0','0'), ('70144','1','31186','0','0'), ('70145','1','31186','0','0'), ('70146','1','27903','0','0'), ('70147','1','18002','0','0'), ('70148','1','31289','0','0'), ('70149','1','12584','18825','0'), ('70150','1','18876','0','0'),
+('70151','1','31186','0','0'), ('70152','1','31186','0','0'), ('70153','1','18842','0','0'), ('70154','1','18842','0','0'), ('70155','1','2291','0','2825'), ('70156','1','25622','0','0'), ('70157','1','25622','0','0'), ('70158','1','2291','0','2825'), ('70159','1','2291','0','2825'), ('70160','1','2291','0','2825'), ('70161','1','18842','0','0'), ('70162','1','18842','0','0'), ('70163','1','18842','0','0'), ('70164','1','18842','0','0'), ('70165','1','18842','0','0'), ('70166','1','18842','0','0'), ('70167','1','18842','0','0'), ('70168','1','31289','0','0'), ('70169','1','31289','0','0'), ('70170','1','31289','0','0'), ('70171','1','18842','0','0'), ('70172','1','18842','0','0'), ('70173','1','28367','0','0'), ('70174','1','12584','18825','0'), ('70175','1','7723','0','0'), ('70176','1','25622','0','0'), ('70177','1','2291','0','2825'), ('70178','1','25622','0','0'), ('70179','1','2291','0','2825'), ('70180','1','2291','0','2825'), ('70181','1','2291','0','2825'), ('70182','1','2291','0','2825'), ('70183','1','31289','0','0'), ('70184','1','31289','0','0'), ('70185','1','31289','0','0'), ('70186','1','25622','0','0'), ('70187','1','13984','6448','0'), ('70188','1','18203','18202','0'), ('70189','1','18842','0','0'), ('70190','1','12584','18826','0'), ('70191','1','31186','0','0'), ('70192','1','31289','0','0'), ('70193','1','13984','6448','0'), ('70194','1','2291','0','2825'), ('70195','1','12584','18826','0'), ('70196','1','31289','0','0'), ('70197','1','2291','0','2825'), ('70198','1','18842','0','0'), ('70199','1','18876','0','0'), ('70200','1','31289','0','0'),
+('70201','1','27903','0','0'), ('70202','1','31186','0','0'), ('70203','1','31186','0','0'), ('70204','1','31186','0','0'), ('70205','1','18842','0','0'), ('70206','1','18842','0','0'), ('70207','1','25622','0','0'), ('70208','1','2291','0','2825'), ('70209','1','2291','0','2825'), ('70210','1','12584','18826','0'), ('70211','1','6633','820','0'), ('70212','1','13984','6448','0'), ('70213','1','25622','0','0'), ('70214','1','2291','0','2825'), ('70215','1','31289','0','0'), ('70216','1','18876','0','0'), ('70217','1','28367','0','0'), ('70218','1','18203','18202','0'), ('70219','1','2291','0','2825'), ('70220','1','18002','0','0'), ('70221','1','18203','18202','0'), ('70222','1','18203','18202','0'), ('70223','1','18203','18202','0'), ('70224','1','27903','0','0'), ('70225','1','18842','0','0'), ('70226','1','31289','0','0'), ('70227','1','12584','18825','0'), ('70228','1','2291','0','2825'), ('70229','1','18876','0','0'), ('70230','1','31289','0','0'), ('70231','1','18842','0','0'), ('70232','1','18842','0','0'), ('70233','1','18203','18202','0'), ('70234','1','18203','18202','0'), ('70235','1','29175','18826','0'), ('70236','1','31289','0','0'), ('70237','1','13505','0','0'), ('70238','1','12775','0','0'), ('70239','1','24044','0','0'), ('70240','1','43601','0','0'), ('70241','1','23499','0','0'), ('70242','1','38632','0','0'), ('70243','1','34891','0','0'), ('70244','1','38632','0','0'), ('70245','1','50798','0','0'), ('70246','1','12592','0','0'), ('70301','1','24044','0','0'),
+
+('71000','1','0','30902','0');
+
+-- -- -- Update 18.09.13 - Equips for shamans
+-- Orcs and Draenei. Mainhand: Cudgel of Furious Justice, Offhand: Azure-Shield of Coldarra
+UPDATE `creature_equip_template` SET `itemEntry1` = '50050', `itemEntry2` = '29266', `itemEntry3` = '0' WHERE `entry` IN (SELECT entry FROM `creature_template` WHERE (`entry` BETWEEN @BOT_START AND @BOT_END) AND `trainer_class` = '7' AND (`trainer_race` = '2' OR `trainer_race` = '11'));
+-- Taurens and some Draenei. De-Raged Waraxe (Two-Hand)
+UPDATE `creature_equip_template` SET `itemEntry1` = '41816', `itemEntry2` = '0', `itemEntry3` = '0' WHERE `entry` IN (SELECT entry FROM `creature_template` WHERE (`entry` BETWEEN @BOT_START AND @BOT_END) AND `trainer_class` = '7' AND (`trainer_race` = '6' OR `entry` IN (70218,70222,70223,70233)));
+
+
+-- GOSSIPS --
+delete from `npc_text` where ID between @BOT_START and @BOT_END;
+insert into `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`,
+`text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`)
+values
+('70001','I live only to serve the master.','','0','1','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','-213'),
+('70002','You need something?','','0','1','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','-213'),
+('70003','Mortals... usually I kill wretches like you at sight',NULL,'0','1','396','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0','-213');
+
+
+-- OUTFITS --
+-- Npc Dress mod by Rochet2
+CREATE TABLE IF NOT EXISTS `creature_template_outfits` (
+    `entry` INT(10) UNSIGNED NOT NULL,
+    `race` tinyint(3) UNSIGNED NOT NULL DEFAULT '1',
+    `gender` tinyint(3) UNSIGNED NOT NULL DEFAULT '0' COMMENT '0 for male, 1 for female',
+    `skin` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `face` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `hair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `haircolor` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `facialhair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `head` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `shoulders` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `body` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `chest` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `waist` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `legs` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `feet` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `wrists` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `hands` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `back` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `tabard` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    PRIMARY KEY  (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+-- End Npc Dress mod
+
+replace into `creature_template_outfits` (`entry`, `race`, `gender`, `skin`, `face`, `hair`, `haircolor`, `facialhair`, `head`, `shoulders`, `body`, `chest`, `waist`, `legs`, `feet`, `wrists`, `hands`, `back`, `tabard`)
+values
+('70301','2','0','0','14','9','7','5','0','0','0','0','59194','64674','0','36248','0','0','0'), -- Blademaster
+('71000','11','1','0','5','0','6','0','0','53903','21842','35049','35058','35051','35067','35044','0','0','0'); -- Airen
+
+
+-- Customize section
+-- You can create your own values to be in line with your own server if these are not acceptable.
+
+SET @CLASS_WARRIOR = 1;
+SET @CLASS_PALADIN = 2;
+SET @CLASS_HUNTER  = 3;
+SET @CLASS_ROGUE   = 4;
+SET @CLASS_PRIEST  = 5;
+SET @CLASS_DK      = 6;
+SET @CLASS_SHAMAN  = 7;
+SET @CLASS_MAGE    = 8;
+SET @CLASS_WARLOCK = 9;
+SET @CLASS_DRUID   = 11;
+SET @CLASS_BM      = 12;
+
+-- Add flags_extra
+-- -- -- Update 6.04.14 - extra flags for recognizing bots core-side - CREATURE_FLAG_EXTRA_NPCBOT
+
+SET @EX_NO_PARRY_HASTEN = 8; -- 0x00000008 - CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN
+SET @EX_NO_BLOCK = 16; -- 0x00000010 - CREATURE_FLAG_EXTRA_NO_BLOCK
+SET @EX_NO_CRUSH = 32; -- 0x00000020 - CREATURE_FLAG_EXTRA_NO_CRUSH
+SET @EX_NO_XP = 64; -- 0x00000040 - CREATURE_FLAG_EXTRA_NO_XP_AT_KILL
+SET @EX_DIMINISH = 1048576; -- 0x00100000 - CREATURE_FLAG_EXTRA_ALL_DIMINISH
+SET @EX_NPCBOT = 67108864; -- 0x04000000 - CREATURE_FLAG_EXTRA_NPCBOT - custom flag
+SET @FLAGS_EX = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT;
+SET @FLAGS_EXN = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT | @EX_NO_PARRY_HASTEN;
+SET @FLAGS_EX_PET = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH;
+
+-- Add extra 'unit_flags2' flags
+SET @U2_ENEMY_INTERRACT = 16384; -- 0x00004000 - UNIT_FLAG2_ALLOW_ENEMY_INTERACT
+SET @FLAGS_U2 = @U2_ENEMY_INTERRACT;
+
+-- minions
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=12, minlevel:=80, maxlevel:=80, baseattacktime:=3300, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX,     unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_DK;
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=8,  minlevel:=80, maxlevel:=80, baseattacktime:=2200, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX,     unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_DRUID;
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=8,  minlevel:=80, maxlevel:=80, baseattacktime:=2800, rangeattacktime:=2000, minrangedmg:=2, maxrangedmg:=8, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX,     unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_HUNTER;
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=6,  minlevel:=80, maxlevel:=80, baseattacktime:=3800, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX,     unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_MAGE;
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=12, minlevel:=80, maxlevel:=80, baseattacktime:=2300, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX,     unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_PALADIN;
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=6,  minlevel:=80, maxlevel:=80, baseattacktime:=3600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX,     unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_PRIEST;
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=12, minlevel:=80, maxlevel:=80, baseattacktime:=1600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX,     unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_ROGUE;
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=12, minlevel:=80, maxlevel:=80, baseattacktime:=2600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX,     unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_SHAMAN;
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=6,  minlevel:=80, maxlevel:=80, baseattacktime:=3500, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX,     unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_WARLOCK;
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=12, minlevel:=80, maxlevel:=80, baseattacktime:=3400, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX,     unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_WARRIOR;
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=24, minlevel:=81, maxlevel:=81, baseattacktime:=2200, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EXN,    unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_BM;
+
+-- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK
+-- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid
+-- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter
+-- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage
+-- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin
+-- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest
+-- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue
+-- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman
+-- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock
+-- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior
+-- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster
+
+-- pets
+UPDATE `creature_template` SET exp:=2, faction:=14, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=3,  minlevel:=80, maxlevel:=80, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX_PET,                                       AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and name='Voidwalker';
diff --git a/sql/TrinityCore-Patches/All-In-One/auth_AIO.sql b/sql/TrinityCore-Patches/All-In-One/auth_AIO.sql
new file mode 100644
index 0000000..ed0d7ea
--- /dev/null
+++ b/sql/TrinityCore-Patches/All-In-One/auth_AIO.sql
@@ -0,0 +1,11 @@
+CREATE TABLE `hacked` (
+ `charname` CHAR( 50) NOT NULL
+);
+
+CREATE TABLE `lagreports` (
+ `account` CHAR( 50) NOT NULL
+);
+
+CREATE TABLE `vipek2` (
+ `account` CHAR( 50) NOT NULL
+);
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/All-In-One/characters_AIO.sql b/sql/TrinityCore-Patches/All-In-One/characters_AIO.sql
new file mode 100644
index 0000000..f131461
--- /dev/null
+++ b/sql/TrinityCore-Patches/All-In-One/characters_AIO.sql
@@ -0,0 +1 @@
+REPLACE INTO `mail` (`id`, `messageType`, `stationery`, `mailTemplateId`, `sender`, `receiver`, `subject`, `has_items`, `expire_time`, `deliver_time`, `money`, `cod`, `checked`) VALUES (60003, 0, 41, 0, 0, 0, 'Money For You!', 0, 0, 0, 4294967295, 0, 1);
diff --git a/sql/TrinityCore-Patches/All-In-One/world_AIO.sql b/sql/TrinityCore-Patches/All-In-One/world_AIO.sql
new file mode 100644
index 0000000..7b65a66
--- /dev/null
+++ b/sql/TrinityCore-Patches/All-In-One/world_AIO.sql
@@ -0,0 +1,31 @@
+-- Updates
+-- WARNING! It's changes official blizz data!
+UPDATE `creature_template` SET `faction`=35 WHERE `entry` IN(28474, 914, 23128, 17204, 5115, 4584, 16655, 28958, 4090, 23534);
+
+-- Inserts
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80000, 'Sorry, you are not VIP member.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80001, 'Welcome Dear VIP.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80006, 'Your skills are set to max.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80007, 'It\'s Time To choose!', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80010, 'Donation help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80011, 'Normal help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80012, 'Ingame help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80013, 'You Don\'t have resurrection sickness!', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80014, 'You Don\'t have a pet!', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80016, 'Welcome! My Name is AIO. What can I help for you? Please choose one menu. Do not forget this script is made by Blue from the wowemuf.org', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (998, '|cffff0000<Announcer>: Join Warsong Guilch!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (999, '|cffff0000<Announcer>: Join Wintergrasp!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (997, '|cffff0000<Announcer>: Join Arathi Basin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (996, '|cffff0000<Announcer>: Join Eye of the Storm!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (995, '|cffff0000<Announcer>: Join Random Battleground!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (994, '|cffff0000<Announcer>: Join Arena 2v2!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (993, '|cffff0000<Announcer>: Join Arena 3v3!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (992, '|cffff0000<Announcer>: Join Arena 5v5!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (991, '|cffff0000<Announcer>: Join Alterac Valley!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (990, '|cffff0000<Announcer>: Join Strand of the Ancients!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+
+-- Creature_template entry. Make sure entry number does not conflict.
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES
+('80000','0','0','0','0','0','2591','0','0','0','Young Woman','You need it, I got it.','','0','80','80','0','35','1','1','1.14286','1','1','1755','1755','0','1504','1','1500','0','1','0','2048','0','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','EventAI','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','npc_all','0');
+-- end
diff --git a/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql b/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
new file mode 100644
index 0000000..ac486b2
--- /dev/null
+++ b/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
@@ -0,0 +1,59 @@
+/*
+ * Author: Xees
+ * Description: This file is used to apply the database tables needed for the ArenaGambler
+ * Version: 1.2
+*/
+create table `custom_duel_config` (
+    `optionIndex` int (10),
+    `optionName` varchar (60),
+    `optionValue` float
+);
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('0','MAP ID ','1');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('1','X CORDS','-7218.97');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('2','Y CORDS','982.622');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('3','Z CORDS','303.524');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('4','O CORDS','1.40677');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('5','MINIMUM LEVEL','60');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('6','LEVEL DIFF','3');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('7','REWARD ON FLED','1');
+
+create table `custom_duel_statistics` (
+    `playerGUID` int (11),
+    `duelsLost` int (10),
+    `duelsWon` int (10),
+    `duelsRefused` int (10),
+    `duelsTotal` int (10)
+);
+
+INSERT INTO `custom_duel_config`
+            (`optionIndex`,
+             `optionName`,
+             `optionValue`)
+VALUES ('12',
+        'ENABLE ONLY CURRENCY',
+        '0');
+INSERT INTO `custom_duel_config`
+            (`optionIndex`,
+             `optionName`,
+             `optionValue`)
+VALUES ('13',
+        'ENABLE EQUAL BETS',
+        '0');
+
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('11','ENABLE ITEM LIMITS','0');
+
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('8','MAXIMUM BET','1000');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('9','ENABLE GM DUEL','0');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('10','ENABLE SAMEIP DUEL','0');
+
+create table `custom_duel_storage` (
+    `matchId` int (10),
+    `challengerGUID` int (11),
+    `defenderGUID` int (11),
+    `challengerItemId` mediumint (8),
+    `challengerItemCount` int (11),
+    `defenderItemId` mediumint (8),
+    `defenderItemCount` int (11),
+    `matchDate` timestamp ,
+    `matchWinner` int (11)
+);
diff --git a/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql b/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
new file mode 100644
index 0000000..952985e
--- /dev/null
+++ b/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
@@ -0,0 +1,502 @@
+
+DELETE FROM `creature_template` WHERE (`entry`=908001);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES (908001, 0, 0, 0, 0, 0, 28122, 0, 28122, 0, 'The Lich King', '', '', 0, 83, 83, 0, 35, 1, 1.5, 2, 1.5, 3, 2150, 2618, 0, 1100, 1, 2000, 2250, 1, 0, 0, 0, 0, 0, 0, 0, 929.6, 1479.89, 4217, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 65, 'duel_system', 1);
+
+DELETE FROM `creature` WHERE (`guid`=1118308);
+INSERT INTO `creature` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `MovementType`, `npcflag`, `unit_flags`, `dynamicflags`, `VerifiedBuild`) VALUES (1118308, 908001, 1, 1, 1, 0, 0, -7207.9, 1056.01, 327.532, 4.59111, 300, 0, 0, 108000, 0, 2, 0, 0, 0, 0);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8021000);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8021000, 10, 8520, 'Arena Records', '', '', '', 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 'duel_records_system', 1);
+
+DELETE FROM `gameobject` WHERE (`guid`=9045336);
+INSERT INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (9045336, 8021000, 1, 1, 1, -7217.97, 1054.25, 331.856, 5.24803, 0, 0, 0.494776, -0.86902, 300, 0, 1);
+
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8010000);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8010000, 33, 9276, 'Arena 0', '', '', '', 0, 0, 1.4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE (`guid`=239650);
+INSERT INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (239650, 8010000, 1, 1, 1, -7218.95, 982.451, 299.273, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1);
+
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8010001);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8010001, 33, 9256, 'Arena 1', '', '', '', 0, 0, 1.4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE (`guid`=239651);
+INSERT INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (239651, 8010001, 1, 1, 1, -7218.95, 982.451, 299.273, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8010002);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8010002, 33, 9257, 'Arena 2', '', '', '', 0, 0, 1.4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+
+DELETE FROM `gameobject` WHERE (`guid`=239644);
+INSERT INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (239644, 8010002, 0, 1, 1, -8942.42, -4009.48, 331.64, 0.943155, 0, 0, 0.454292, 0.890853, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8010003);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8010003, 33, 9258, 'Arena 3', '', '', '', 0, 0, 1.4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+
+DELETE FROM `gameobject` WHERE (`guid`=239653);
+INSERT INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (239653, 8010003, 1, 1, 1, -7218.95, 982.451, 299.273, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1);
+
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8007862);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8007862, 5, 7862, 'Arena Bonfire', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=8007862;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(9044977, 8007862, 1, 1, 1, -7224.76, 1021.03, 303.523, 1.40272, 0, 0, 0.645258, 0.763965, 300, 0, 1),
+(9044978, 8007862, 1, 1, 1, -7201.21, 1017.04, 303.523, 1.40272, 0, 0, 0.645258, 0.763965, 300, 0, 1);
+
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8007658);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8007658, 5, 7658, 'Arena Earth Rune', '', '', '', 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE (`guid`=9044951);
+INSERT INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (9044951, 8007658, 1, 1, 1, -7207.87, 1056.14, 327.535, 4.52314, 0, 0, 0.770754, -0.637133, 300, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=800342);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (800342, 5, 342, 'Arena Wall Rune', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=800342;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(9046955, 800342, 1, 1, 1, -7212.74, 1056.6, 335.527, 4.59111, 0, 0, 0.748659, -0.662955, 300, 0, 1),
+(9046953, 800342, 1, 1, 1, -7202.82, 1055.39, 335.527, 4.59111, 0, 0, 0.748659, -0.662955, 300, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8008124);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8008124, 5, 8124, 'Arena Eye of Acherus', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE (`guid`=9044976);
+INSERT INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (9044976, 8008124, 1, 1, 1, -7207.83, 1055.98, 342.182, 1.41429, 0, 0, 0.649667, 0.760219, 300, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8008054);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8008054, 5, 8054, 'Arena Skull of Acherus', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=8008054;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(9055707, 8008054, 1, 1, 1, -7137.07, 970.488, 329.703, 1.51134, 0, 0, 0.685777, 0.727812, 300, 0, 1),
+(9044974, 8008054, 1, 1, 1, -7302.17, 994.336, 328.471, 4.55182, 0, 0, 0.761539, -0.648119, 300, 0, 1),
+(9044969, 8008054, 1, 1, 1, -7232.73, 900.85, 329.059, 6.09277, 0, 0, 0.0950627, -0.995471, 300, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8004714);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8004714, 5, 4714, 'Arena Light Powersource', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=8004714;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(9044979, 8004714, 1, 1, 1, -7280.03, 1002.39, 303.523, 6.13, 0, 0, 0.0765184, -0.997068, 300, 0, 1),
+(9044980, 8004714, 1, 1, 1, -7283.71, 978.588, 303.523, 6.13, 0, 0, 0.0765184, -0.997068, 300, 0, 1),
+(9044981, 8004714, 1, 1, 1, -7155.47, 985.314, 303.524, 6.13, 0, 0, 0.0765184, -0.997068, 300, 0, 1),
+(9044982, 8004714, 1, 1, 1, -7158.91, 962.114, 303.524, 6.13, 0, 0, 0.0765184, -0.997068, 300, 0, 1);
+
+
+DELETE FROM `gameobject` WHERE `id`=70264;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(240164, 70264, 1, 1, 1, -7211.89, 921.652, 307.653, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240166, 70264, 1, 1, 1, -7211.89, 921.652, 303.524, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240167, 70264, 1, 1, 1, -7211.64, 923.561, 304.714, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240168, 70264, 1, 1, 1, -7210.66, 920.395, 305.123, 3.10238, 0, 0, 0.999808, 0.0196051, 25, 0, 1),
+(240169, 70264, 1, 1, 1, -7210, 922.433, 304.547, 3.52728, 0, 0, 0.981463, -0.191651, 25, 0, 1),
+(240170, 70264, 1, 1, 1, -7211.74, 925.442, 305.599, 3.55012, 0, 0, 0.97921, -0.202848, 25, 0, 1),
+(240171, 70264, 1, 1, 1, -7211.08, 927.887, 303.524, 2.53696, 0, 0, 0.954649, 0.297734, 25, 0, 1),
+(240172, 70264, 1, 1, 1, -7210.16, 925.499, 303.523, 0.171338, 0, 0, 0.0855642, 0.996333, 25, 0, 1),
+(240174, 70264, 1, 1, 1, -7212.64, 918.485, 307.331, 2.88561, 0, 0, 0.99182, 0.127644, 25, 0, 1),
+(240175, 70264, 1, 1, 1, -7213.07, 916.643, 307.346, 4.4564, 0, 0, 0.791581, -0.611065, 25, 0, 1),
+(240176, 70264, 1, 1, 1, -7213.5, 915.324, 306.69, 4.4564, 0, 0, 0.791581, -0.611065, 25, 0, 1),
+(240177, 70264, 1, 1, 1, -7213.94, 913.631, 308.328, 2.57459, 0, 0, 0.960082, 0.27972, 25, 0, 1),
+(240178, 70264, 1, 1, 1, -7210.59, 918.498, 303.524, 2.23965, 0, 0, 0.900025, 0.435839, 25, 0, 1),
+(240179, 70264, 1, 1, 1, -7211, 916.593, 304.705, 2.5813, 0, 0, 0.961015, 0.276496, 25, 0, 1),
+(240180, 70264, 1, 1, 1, -7211.58, 914.537, 304.612, 5.18568, 0, 0, 0.521622, -0.853176, 25, 0, 1),
+(240181, 70264, 1, 1, 1, -7214.78, 911.262, 309.84, 2.45752, 0, 0, 0.942074, 0.335406, 25, 0, 1),
+(240182, 70264, 1, 1, 1, -7216.24, 912.227, 306.76, 5.43418, 0, 0, 0.411866, -0.911244, 25, 0, 1),
+(240183, 70264, 1, 1, 1, -7212.83, 912.539, 307.181, 2.37505, 0, 0, 0.927447, 0.373954, 25, 0, 1),
+(240184, 70264, 1, 1, 1, -7213.46, 909.984, 307.23, 0.549789, 0, 0, 0.271445, 0.962454, 25, 0, 1),
+(240194, 70264, 1, 1, 1, -7209.58, 914.14, 303.524, 3.51295, 0, 0, 0.982811, -0.184616, 25, 0, 1),
+(240195, 70264, 1, 1, 1, -7208.91, 916.507, 303.523, 3.29697, 0, 0, 0.996984, -0.0776098, 25, 0, 1),
+(240196, 70264, 1, 1, 1, -7208.91, 920.253, 303.524, 3.50117, 0, 0, 0.983881, -0.178823, 25, 0, 1),
+(240197, 70264, 1, 1, 1, -7211.93, 910.935, 303.523, 2.14636, 0, 0, 0.878724, 0.477331, 25, 0, 1),
+(240198, 70264, 1, 1, 1, -7211.66, 909.391, 304.125, 3.06528, 0, 0, 0.999272, 0.0381473, 25, 0, 1),
+(240199, 70264, 1, 1, 1, -7243.47, 918.183, 306.827, 2.88084, 0, 0, 0.991513, 0.130006, 25, 0, 1),
+(240200, 70264, 1, 1, 1, -7242.56, 920.043, 306.432, 6.18659, 0, 0, 0.0482802, -0.998834, 25, 0, 1),
+(240202, 70264, 1, 1, 1, -7242.34, 922.252, 307.37, 4.61579, 0, 0, 0.740422, -0.672143, 25, 0, 1),
+(240203, 70264, 1, 1, 1, -7241.58, 918.298, 307.496, 5.83709, 0, 0, 0.221202, -0.975228, 25, 0, 1),
+(240204, 70264, 1, 1, 1, -7242.13, 920.107, 308.89, 6.18659, 0, 0, 0.0482802, -0.998834, 25, 0, 1),
+(240205, 70264, 1, 1, 1, -7240.56, 920.002, 306.682, 3.3923, 0, 0, 0.992153, -0.125027, 25, 0, 1),
+(240206, 70264, 1, 1, 1, -7243.02, 924.059, 309.946, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240207, 70264, 1, 1, 1, -7243.01, 924.088, 305.274, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240208, 70264, 1, 1, 1, -7243.04, 924.253, 303.523, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240209, 70264, 1, 1, 1, -7241.35, 924.009, 307.062, 1.96681, 0, 0, 0.83239, 0.55419, 25, 0, 1),
+(240210, 70264, 1, 1, 1, -7241.94, 925.8, 305.81, 5.47362, 0, 0, 0.393821, -0.919187, 25, 0, 1),
+(240211, 70264, 1, 1, 1, -7241.6, 928.466, 303.523, 6.04382, 0, 0, 0.119399, -0.992846, 25, 0, 1),
+(240212, 70264, 1, 1, 1, -7241.24, 930.286, 305.206, 3.14491, 0, 0, 0.999999, -0.00165872, 25, 0, 1),
+(240213, 70264, 1, 1, 1, -7243.68, 926.66, 303.523, 5.75479, 0, 0, 0.261137, -0.965302, 25, 0, 1),
+(240214, 70264, 1, 1, 1, -7242.97, 929.298, 303.523, 5.94014, 0, 0, 0.170683, -0.985326, 25, 0, 1),
+(240215, 70264, 1, 1, 1, -7242.62, 931.894, 303.523, 0.27742, 0, 0, 0.138265, 0.990395, 25, 0, 1),
+(240216, 70264, 1, 1, 1, -7240.76, 933.186, 304.251, 4.5225, 0, 0, 0.770957, -0.636887, 25, 0, 1),
+(240217, 70264, 1, 1, 1, -7240.6, 934.86, 303.523, 1.03381, 0, 0, 0.494194, 0.869352, 25, 0, 1),
+(240218, 70264, 1, 1, 1, -7240.63, 927.437, 308.706, 3.04601, 0, 0, 0.998858, 0.0477748, 25, 0, 1),
+(240219, 70264, 1, 1, 1, -7239.85, 928.99, 306.613, 4.15651, 0, 0, 0.873982, -0.485958, 25, 0, 1),
+(240220, 70264, 1, 1, 1, -7239.49, 930.882, 305.622, 0.293923, 0, 0, 0.146433, 0.989221, 25, 0, 1),
+(240221, 70264, 1, 1, 1, -7243.6, 927.232, 307.087, 2.75142, 0, 0, 0.981031, 0.19385, 25, 0, 1),
+(240222, 70264, 1, 1, 1, -7243.98, 921.131, 303.523, 0.378774, 0, 0, 0.188257, 0.98212, 25, 0, 1),
+(240223, 70264, 1, 1, 1, -7245.03, 918.867, 303.523, 5.00398, 0, 0, 0.596875, -0.802334, 25, 0, 1),
+(240224, 70264, 1, 1, 1, -7243.15, 916.057, 303.523, 0.849226, 0, 0, 0.411968, 0.911198, 25, 0, 1),
+(240225, 70264, 1, 1, 1, -7240.85, 916.565, 303.523, 2.12943, 0, 0, 0.87465, 0.484755, 25, 0, 1),
+(240226, 70264, 1, 1, 1, -7245.19, 916.681, 303.523, 0.8453, 0, 0, 0.410179, 0.912005, 25, 0, 1);
+
+
+DELETE FROM `gameobject_template` WHERE (`entry`=8009248);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8009248, 5, 9248, 'Arena Flat Steel', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=8009248;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(240141, 8009248, 1, 1, 1, -7226.12, 929.725, 303.755, 0.169878, 0, 0, 0.0848367, 0.996395, 25, 0, 1),
+(9119088, 8009248, 1, 1, 1, -1823.82, -4584.27, -109.975, 5.70834, 0, 0, 0.283482, -0.958978, 300, 0, 1),
+(240149, 8009248, 1, 1, 1, -7227.33, 920.772, 306.682, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240147, 8009248, 1, 1, 1, -7226.91, 923.893, 305.622, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240144, 8009248, 1, 1, 1, -7226.49, 926.943, 304.55, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(9119083, 8009248, 1, 1, 1, -1823.47, -4583.57, -110.052, 4.20586, 0, 0, 0.861725, -0.507375, 300, 0, 1),
+(9347465, 8009248, 1, 1, 1, 6459.17, -4273.97, 667.048, 3.94114, 0, 0, 0.921148, -0.389212, 300, 0, 1),
+(9347468, 8009248, 1, 1, 1, 6474.25, -4258.45, 665.93, 3.94114, 0, 0, 0.921148, -0.389212, 300, 0, 1);
+
+
+DELETE FROM `gameobject_template` WHERE (`entry`=181640);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (181640, 7, 6690, 'Arena Throne', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=181640;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(240150, 181640, 1, 1, 1, -7228.43, 912.741, 306.682, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240152, 181640, 1, 1, 1, -7235.39, 917.648, 306.682, 0.438242, 0, 0, 0.217372, 0.976089, 25, 0, 1),
+(240153, 181640, 1, 1, 1, -7220.81, 916.125, 306.681, 2.44007, 0, 0, 0.939112, 0.343611, 25, 0, 1),
+(240155, 181640, 1, 1, 1, -7218.34, 922.78, 306.683, 2.96331, 0, 0, 0.99603, 0.0890233, 25, 0, 1),
+(240160, 181640, 1, 1, 1, -7236.27, 924.809, 306.682, 6.1303, 0, 0, 0.0763687, -0.99708, 25, 0, 1);
+
+
+DELETE FROM `gameobject_template` WHERE (`entry`=186393);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (186393, 5, 6725, 'Arena Bleachers', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=186393;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(9365229, 186393, 1, 1, 1, -3067.83, 2199.85, 43.8142, 1.85265, 0, 0, 0.799417, 0.600776, 300, 0, 1),
+(9365139, 186393, 1, 1, 1, -2789.46, 2291.79, 53.9035, 2.34029, 0, 0, 0.920808, 0.390016, 300, 0, 1),
+(240010, 186393, 1, 1, 1, -7162.65, 959.809, 303.523, 4.58374, 0, 0, 0.751097, -0.660192, 25, 0, 1),
+(240008, 186393, 1, 1, 1, -7158.73, 989.066, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239922, 186393, 1, 1, 1, -7279.56, 975.823, 303.523, 4.57633, 0, 0, 0.753539, -0.657403, 25, 0, 1),
+(239997, 186393, 1, 1, 1, -7159.63, 980.321, 306.361, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1),
+(239913, 186393, 1, 1, 1, -7275.58, 1004.97, 303.523, 1.43885, 0, 0, 0.658953, 0.752184, 25, 0, 1),
+(239923, 186393, 1, 1, 1, -7277.64, 990.373, 306.361, 6.1613, 0, 0, 0.0609072, -0.998143, 25, 0, 1),
+(239933, 186393, 1, 1, 1, -7278.38, 984.389, 306.36, 6.1613, 0, 0, 0.0609072, -0.998143, 25, 0, 1),
+(239934, 186393, 1, 1, 1, -7276.92, 996.3, 306.36, 6.1613, 0, 0, 0.0609072, -0.998143, 25, 0, 1),
+(240065, 186393, 1, 1, 1, -7248.77, 1032.2, 306.361, 3.77837, 0, 0, 0.949741, -0.313037, 25, 0, 1),
+(240080, 186393, 1, 1, 1, -7174.38, 1012.29, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240064, 186393, 1, 1, 1, -7259.13, 1024.25, 306.361, 0.640679, 0, 0, 0.314889, 0.949129, 25, 0, 1),
+(240100, 186393, 1, 1, 1, -7262.34, 949.284, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240128, 186393, 1, 1, 1, -7187.33, 939.703, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240024, 186393, 1, 1, 1, -7252.32, 1026.1, 303.524, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(239992, 186393, 1, 1, 1, -7160.45, 974.339, 306.361, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1),
+(239994, 186393, 1, 1, 1, -7161.27, 968.374, 306.362, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1),
+(240227, 186393, 1, 1, 1, -7176.13, 1019.19, 306.361, 5.36606, 0, 0, 0.442661, -0.896689, 25, 0, 1),
+(240228, 186393, 1, 1, 1, -7168.2, 1008.91, 306.36, 2.24018, 0, 0, 0.900139, 0.435603, 25, 0, 1),
+(240229, 186393, 1, 1, 1, -7260.57, 942.307, 306.36, 2.22945, 0, 0, 0.89779, 0.440424, 25, 0, 1),
+(240230, 186393, 1, 1, 1, -7268.58, 952.669, 306.36, 5.36319, 0, 0, 0.443945, -0.896054, 25, 0, 1),
+(240231, 186393, 1, 1, 1, -7180.39, 941.411, 306.36, 3.79612, 0, 0, 0.946925, -0.321454, 25, 0, 1),
+(240232, 186393, 1, 1, 1, -7190.67, 933.47, 306.36, 0.654529, 0, 0, 0.321454, 0.946925, 25, 0, 1),
+(9365230, 186393, 1, 1, 1, -3077.56, 2197.23, 42.7844, 1.83087, 0, 0, 0.792826, 0.609448, 300, 0, 1),
+(9365232, 186393, 1, 1, 1, -3504.66, 2071.59, 42.6084, 1.13352, 0, 0, 0.536904, 0.843644, 300, 0, 1),
+(9365244, 186393, 1, 1, 1, -4759.7, 1584.99, 84.6154, 0.124395, 0, 0, 0.0621572, 0.998066, 300, 0, 1),
+(9365245, 186393, 1, 1, 1, -4758.94, 1578.86, 85.7949, 0.124395, 0, 0, 0.0621572, 0.998066, 300, 0, 1),
+(9365246, 186393, 1, 1, 1, -4758.17, 1572.71, 87.2961, 0.124395, 0, 0, 0.0621572, 0.998066, 300, 0, 1),
+(9365247, 186393, 1, 1, 1, -4757.39, 1566.47, 87.6473, 0.124395, 0, 0, 0.0621572, 0.998066, 300, 0, 1);
+
+
+DELETE FROM `gameobject_template` WHERE (`entry`=188596);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (188596, 5, 7812, 'Arena Pedestal', '', '', '', 0, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=188596;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(60046, 188596, 571, 1, 1, 3404.73, -5394.46, 267.362, 1.18682, 0, 0, 0, 1, 300, 100, 0),
+(239948, 188596, 1, 1, 1, -7164.57, 975.06, 303.523, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239950, 188596, 1, 1, 1, -7163.66, 981.741, 303.523, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240026, 188596, 1, 1, 1, -7257.12, 1032.41, 303.524, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(240090, 188596, 1, 1, 1, -7268.73, 944.317, 303.523, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240015, 188596, 1, 1, 1, -7255.01, 1029.64, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240091, 188596, 1, 1, 1, -7270.72, 946.901, 303.523, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(239658, 188596, 1, 1, 1, -7276.42, 1000.47, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239657, 188596, 1, 1, 1, -7276.87, 997.127, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239656, 188596, 1, 1, 1, -7277.33, 993.788, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239655, 188596, 1, 1, 1, -7277.78, 990.448, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239669, 188596, 1, 1, 1, -7273.63, 989.883, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239661, 188596, 1, 1, 1, -7279.1, 980.338, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239670, 188596, 1, 1, 1, -7273.17, 993.224, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239672, 188596, 1, 1, 1, -7272.26, 999.903, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239659, 188596, 1, 1, 1, -7278.22, 987.078, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239660, 188596, 1, 1, 1, -7278.66, 983.707, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239671, 188596, 1, 1, 1, -7272.72, 996.564, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239673, 188596, 1, 1, 1, -7274.08, 986.518, 303.524, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239674, 188596, 1, 1, 1, -7274.54, 983.151, 303.524, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239675, 188596, 1, 1, 1, -7275, 979.786, 303.524, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239949, 188596, 1, 1, 1, -7164.12, 978.4, 303.523, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240077, 188596, 1, 1, 1, -7166.01, 1014.58, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(239960, 188596, 1, 1, 1, -7160.4, 974.416, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239951, 188596, 1, 1, 1, -7163.21, 985.081, 303.523, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240028, 188596, 1, 1, 1, -7259.67, 1030.47, 303.523, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(239958, 188596, 1, 1, 1, -7161.31, 967.734, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240068, 188596, 1, 1, 1, -7168.78, 1012.46, 303.524, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240069, 188596, 1, 1, 1, -7174.66, 1020.19, 303.524, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240072, 188596, 1, 1, 1, -7166.81, 1009.87, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240067, 188596, 1, 1, 1, -7170.75, 1015.05, 303.524, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240066, 188596, 1, 1, 1, -7172.72, 1017.64, 303.524, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(239961, 188596, 1, 1, 1, -7159.95, 977.758, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239955, 188596, 1, 1, 1, -7165.94, 964.962, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239957, 188596, 1, 1, 1, -7161.76, 964.393, 303.523, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240027, 188596, 1, 1, 1, -7254.53, 1034.39, 303.524, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(240075, 188596, 1, 1, 1, -7169.95, 1019.76, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(239966, 188596, 1, 1, 1, -7159.03, 984.508, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239962, 188596, 1, 1, 1, -7159.49, 981.1, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239952, 188596, 1, 1, 1, -7165.03, 971.695, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239959, 188596, 1, 1, 1, -7160.85, 971.074, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239954, 188596, 1, 1, 1, -7165.49, 968.329, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240124, 188596, 1, 1, 1, -7179.38, 939.825, 303.523, 1.78622, 0, 0, 0.779027, 0.626991, 25, 0, 1),
+(240125, 188596, 1, 1, 1, -7189.66, 932.069, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240092, 188596, 1, 1, 1, -7267.97, 949.005, 303.523, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240098, 188596, 1, 1, 1, -7262.1, 941.384, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240099, 188596, 1, 1, 1, -7259.35, 943.486, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240096, 188596, 1, 1, 1, -7266.02, 946.459, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240097, 188596, 1, 1, 1, -7264.05, 943.929, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240095, 188596, 1, 1, 1, -7266.78, 941.771, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240094, 188596, 1, 1, 1, -7267.21, 953.693, 303.523, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240121, 188596, 1, 1, 1, -7187.05, 934.013, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240093, 188596, 1, 1, 1, -7269.95, 951.589, 303.523, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240127, 188596, 1, 1, 1, -7181.46, 942.585, 303.523, 2.57948, 0, 0, 0.960763, 0.27737, 25, 0, 1),
+(240120, 188596, 1, 1, 1, -7184.97, 931.254, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240119, 188596, 1, 1, 1, -7179.81, 935.147, 303.524, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240123, 188596, 1, 1, 1, -7181.94, 937.892, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240126, 188596, 1, 1, 1, -7191.74, 934.827, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240118, 188596, 1, 1, 1, -7182.37, 933.215, 303.524, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240122, 188596, 1, 1, 1, -7184.5, 935.96, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240076, 188596, 1, 1, 1, -7167.98, 1017.17, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240017, 188596, 1, 1, 1, -7260.11, 1025.76, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240021, 188596, 1, 1, 1, -7247.73, 1030.83, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240020, 188596, 1, 1, 1, -7249.82, 1033.58, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240019, 188596, 1, 1, 1, -7252.42, 1031.61, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240023, 188596, 1, 1, 1, -7258.02, 1023.01, 303.523, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240016, 188596, 1, 1, 1, -7257.56, 1027.7, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240073, 188596, 1, 1, 1, -7169.55, 1007.76, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240074, 188596, 1, 1, 1, -7177.41, 1018.09, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=70264);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (70264, 5, 6752, 'Arena Ice Block', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+
+DELETE FROM `gameobject` WHERE `id`=70264;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(240193, 70264, 1, 1, 1, -7210.52, 912.412, 304.893, 2.5155, 0, 0, 0.9514, 0.307959, 25, 0, 1),
+(240164, 70264, 1, 1, 1, -7211.89, 921.652, 307.653, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240166, 70264, 1, 1, 1, -7211.89, 921.652, 303.524, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240167, 70264, 1, 1, 1, -7211.64, 923.561, 304.714, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240168, 70264, 1, 1, 1, -7210.66, 920.395, 305.123, 3.10238, 0, 0, 0.999808, 0.0196051, 25, 0, 1),
+(240169, 70264, 1, 1, 1, -7210, 922.433, 304.547, 3.52728, 0, 0, 0.981463, -0.191651, 25, 0, 1),
+(240170, 70264, 1, 1, 1, -7211.74, 925.442, 305.599, 3.55012, 0, 0, 0.97921, -0.202848, 25, 0, 1),
+(240171, 70264, 1, 1, 1, -7211.08, 927.887, 303.524, 2.53696, 0, 0, 0.954649, 0.297734, 25, 0, 1),
+(240172, 70264, 1, 1, 1, -7210.16, 925.499, 303.523, 0.171338, 0, 0, 0.0855642, 0.996333, 25, 0, 1),
+(240174, 70264, 1, 1, 1, -7212.64, 918.485, 307.331, 2.88561, 0, 0, 0.99182, 0.127644, 25, 0, 1),
+(240175, 70264, 1, 1, 1, -7213.07, 916.643, 307.346, 4.4564, 0, 0, 0.791581, -0.611065, 25, 0, 1),
+(240176, 70264, 1, 1, 1, -7213.5, 915.324, 306.69, 4.4564, 0, 0, 0.791581, -0.611065, 25, 0, 1),
+(240177, 70264, 1, 1, 1, -7213.94, 913.631, 308.328, 2.57459, 0, 0, 0.960082, 0.27972, 25, 0, 1),
+(240178, 70264, 1, 1, 1, -7210.59, 918.498, 303.524, 2.23965, 0, 0, 0.900025, 0.435839, 25, 0, 1),
+(240179, 70264, 1, 1, 1, -7211, 916.593, 304.705, 2.5813, 0, 0, 0.961015, 0.276496, 25, 0, 1),
+(240180, 70264, 1, 1, 1, -7211.58, 914.537, 304.612, 5.18568, 0, 0, 0.521622, -0.853176, 25, 0, 1),
+(240181, 70264, 1, 1, 1, -7214.78, 911.262, 309.84, 2.45752, 0, 0, 0.942074, 0.335406, 25, 0, 1),
+(240182, 70264, 1, 1, 1, -7216.24, 912.227, 306.76, 5.43418, 0, 0, 0.411866, -0.911244, 25, 0, 1),
+(240183, 70264, 1, 1, 1, -7212.83, 912.539, 307.181, 2.37505, 0, 0, 0.927447, 0.373954, 25, 0, 1),
+(240184, 70264, 1, 1, 1, -7213.46, 909.984, 307.23, 0.549789, 0, 0, 0.271445, 0.962454, 25, 0, 1),
+(240194, 70264, 1, 1, 1, -7209.58, 914.14, 303.524, 3.51295, 0, 0, 0.982811, -0.184616, 25, 0, 1),
+(240195, 70264, 1, 1, 1, -7208.91, 916.507, 303.523, 3.29697, 0, 0, 0.996984, -0.0776098, 25, 0, 1),
+(240196, 70264, 1, 1, 1, -7208.91, 920.253, 303.524, 3.50117, 0, 0, 0.983881, -0.178823, 25, 0, 1),
+(240197, 70264, 1, 1, 1, -7211.93, 910.935, 303.523, 2.14636, 0, 0, 0.878724, 0.477331, 25, 0, 1),
+(240198, 70264, 1, 1, 1, -7211.66, 909.391, 304.125, 3.06528, 0, 0, 0.999272, 0.0381473, 25, 0, 1),
+(240199, 70264, 1, 1, 1, -7243.47, 918.183, 306.827, 2.88084, 0, 0, 0.991513, 0.130006, 25, 0, 1),
+(240200, 70264, 1, 1, 1, -7242.56, 920.043, 306.432, 6.18659, 0, 0, 0.0482802, -0.998834, 25, 0, 1),
+(240202, 70264, 1, 1, 1, -7242.34, 922.252, 307.37, 4.61579, 0, 0, 0.740422, -0.672143, 25, 0, 1),
+(240203, 70264, 1, 1, 1, -7241.58, 918.298, 307.496, 5.83709, 0, 0, 0.221202, -0.975228, 25, 0, 1),
+(240204, 70264, 1, 1, 1, -7242.13, 920.107, 308.89, 6.18659, 0, 0, 0.0482802, -0.998834, 25, 0, 1),
+(240205, 70264, 1, 1, 1, -7240.56, 920.002, 306.682, 3.3923, 0, 0, 0.992153, -0.125027, 25, 0, 1),
+(240206, 70264, 1, 1, 1, -7243.02, 924.059, 309.946, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240207, 70264, 1, 1, 1, -7243.01, 924.088, 305.274, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240208, 70264, 1, 1, 1, -7243.04, 924.253, 303.523, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240209, 70264, 1, 1, 1, -7241.35, 924.009, 307.062, 1.96681, 0, 0, 0.83239, 0.55419, 25, 0, 1),
+(240210, 70264, 1, 1, 1, -7241.94, 925.8, 305.81, 5.47362, 0, 0, 0.393821, -0.919187, 25, 0, 1),
+(240211, 70264, 1, 1, 1, -7241.6, 928.466, 303.523, 6.04382, 0, 0, 0.119399, -0.992846, 25, 0, 1),
+(240212, 70264, 1, 1, 1, -7241.24, 930.286, 305.206, 3.14491, 0, 0, 0.999999, -0.00165872, 25, 0, 1),
+(240213, 70264, 1, 1, 1, -7243.68, 926.66, 303.523, 5.75479, 0, 0, 0.261137, -0.965302, 25, 0, 1),
+(240214, 70264, 1, 1, 1, -7242.97, 929.298, 303.523, 5.94014, 0, 0, 0.170683, -0.985326, 25, 0, 1),
+(240215, 70264, 1, 1, 1, -7242.62, 931.894, 303.523, 0.27742, 0, 0, 0.138265, 0.990395, 25, 0, 1),
+(240216, 70264, 1, 1, 1, -7240.76, 933.186, 304.251, 4.5225, 0, 0, 0.770957, -0.636887, 25, 0, 1),
+(240217, 70264, 1, 1, 1, -7240.6, 934.86, 303.523, 1.03381, 0, 0, 0.494194, 0.869352, 25, 0, 1),
+(240218, 70264, 1, 1, 1, -7240.63, 927.437, 308.706, 3.04601, 0, 0, 0.998858, 0.0477748, 25, 0, 1),
+(240219, 70264, 1, 1, 1, -7239.85, 928.99, 306.613, 4.15651, 0, 0, 0.873982, -0.485958, 25, 0, 1),
+(240220, 70264, 1, 1, 1, -7239.49, 930.882, 305.622, 0.293923, 0, 0, 0.146433, 0.989221, 25, 0, 1),
+(240221, 70264, 1, 1, 1, -7243.6, 927.232, 307.087, 2.75142, 0, 0, 0.981031, 0.19385, 25, 0, 1),
+(240222, 70264, 1, 1, 1, -7243.98, 921.131, 303.523, 0.378774, 0, 0, 0.188257, 0.98212, 25, 0, 1),
+(240223, 70264, 1, 1, 1, -7245.03, 918.867, 303.523, 5.00398, 0, 0, 0.596875, -0.802334, 25, 0, 1),
+(240224, 70264, 1, 1, 1, -7243.15, 916.057, 303.523, 0.849226, 0, 0, 0.411968, 0.911198, 25, 0, 1),
+(240225, 70264, 1, 1, 1, -7240.85, 916.565, 303.523, 2.12943, 0, 0, 0.87465, 0.484755, 25, 0, 1),
+(240226, 70264, 1, 1, 1, -7245.19, 916.681, 303.523, 0.8453, 0, 0, 0.410179, 0.912005, 25, 0, 1);
+
+DELETE FROM `creature_template` WHERE (`entry`=25266);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES (25266, 0, 0, 0, 0, 0, 24818, 3422, 24819, 24821, 'Arena Gambler', '', '', 0, 255, 255, 0, 35, 0, 1, 1.14286, 1, 0, 2, 2, 0, 24, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 5, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, '', 1);
+
+DELETE FROM `creature` WHERE `id`=25266;
+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`,`npcflag`,`unit_flags`,`dynamicflags`, `VerifiedBuild`) VALUES
+(1112166, 25266, 1, 1, 1, 0, 0, -7272.97, 986.543, 306.361, 6.18204, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112165, 25266, 1, 1, 1, 0, 0, -7272, 994.955, 306.361, 6.18204, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112163, 25266, 1, 1, 1, 0, 0, -7162.96, 966.158, 307.122, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112164, 25266, 1, 1, 1, 0, 0, -7273.19, 989.977, 306.361, 6.18204, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112162, 25266, 1, 1, 1, 0, 0, -7160.46, 971.542, 308.005, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112160, 25266, 1, 1, 1, 0, 0, -7166.61, 968.537, 306.36, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112161, 25266, 1, 1, 1, 0, 0, -7165.4, 978.728, 306.36, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112159, 25266, 1, 1, 1, 0, 0, -7166.34, 970.852, 306.36, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112158, 25266, 1, 1, 1, 0, 0, -7165.9, 974.529, 306.36, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112157, 25266, 1, 1, 1, 0, 0, -7162.03, 975.112, 306.944, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112145, 25266, 1, 1, 1, 0, 0, -7277.48, 986.356, 307.508, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112146, 25266, 1, 1, 1, 0, 0, -7277.03, 989.028, 307.5, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112156, 25266, 1, 1, 1, 0, 0, -7161.6, 978.72, 306.836, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112155, 25266, 1, 1, 1, 0, 0, -7159.16, 978.43, 308.144, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112152, 25266, 1, 1, 1, 0, 0, -7160.59, 981.296, 307.276, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112153, 25266, 1, 1, 1, 0, 0, -7158.82, 981.086, 308.239, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112150, 25266, 1, 1, 1, 0, 0, -7276.97, 995.476, 307.962, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112151, 25266, 1, 1, 1, 0, 0, -7275.67, 995.258, 307.121, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112149, 25266, 1, 1, 1, 0, 0, -7277.57, 991.893, 307.982, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112148, 25266, 1, 1, 1, 0, 0, -7275.89, 991.613, 307.009, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112144, 25266, 1, 1, 1, 0, 0, -7277.83, 984.264, 307.587, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=178764);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (178764, 5, 5453, 'Arena Rope Line', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=178764;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(239891, 178764, 1, 1, 1, -7272.6, 985.626, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239897, 178764, 1, 1, 1, -7270.77, 999.019, 306.36, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239896, 178764, 1, 1, 1, -7271.12, 996.481, 306.36, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239893, 178764, 1, 1, 1, -7272.26, 988.172, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239895, 178764, 1, 1, 1, -7271.48, 993.817, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239894, 178764, 1, 1, 1, -7271.88, 990.953, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239888, 178764, 1, 1, 1, -7273.33, 980.292, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239889, 178764, 1, 1, 1, -7272.95, 983.06, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239886, 178764, 1, 1, 1, -7273.7, 977.636, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239906, 178764, 1, 1, 1, -7276.49, 978.036, 306.361, 4.59361, 0, 0, 0.747829, -0.663891, 25, 0, 1),
+(239903, 178764, 1, 1, 1, -7270.44, 1001.47, 306.36, 1.43885, 0, 0, 0.658953, 0.752184, 25, 0, 1),
+(239946, 178764, 1, 1, 1, -7281.08, 978.658, 306.36, 6.14417, 0, 0, 0.0694537, -0.997585, 25, 0, 1),
+(239968, 178764, 1, 1, 1, -7164.82, 986.986, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239972, 178764, 1, 1, 1, -7165.9, 978.853, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239977, 178764, 1, 1, 1, -7167.68, 965.418, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239975, 178764, 1, 1, 1, -7166.97, 970.755, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(9051186, 178764, 1, 1, 1, -7168, 963.017, 306.36, 4.61838, 0, 0, 0.739552, -0.6731, 300, 0, 1),
+(239973, 178764, 1, 1, 1, -7166.25, 976.209, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239971, 178764, 1, 1, 1, -7165.54, 981.532, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239974, 178764, 1, 1, 1, -7166.62, 973.406, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239970, 178764, 1, 1, 1, -7165.18, 984.315, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239985, 178764, 1, 1, 1, -7161.79, 986.521, 306.361, 1.42079, 0, 0, 0.652132, 0.758105, 25, 0, 1),
+(239976, 178764, 1, 1, 1, -7167.32, 968.097, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=194593);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194593, 5, 8620, 'Ironforge Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=194593;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67907, 194593, 571, 1, 1, 8460.36, 927.153, 544.916, 3.14159, 0, 0, 0, 1, 180, 255, 1),
+(239944, 194593, 1, 1, 1, -7278.25, 996.463, 308.409, 6.1613, 0, 0, 0.0609072, -0.998143, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=194595);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194595, 5, 8616, 'Darnassus Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=194595;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67909, 194595, 571, 1, 1, 8459.95, 992.174, 544.922, -2.94959, 0, 0, 0, 1, 180, 255, 1),
+(239941, 194595, 1, 1, 1, -7279.28, 990.573, 308.462, 6.1613, 0, 0, 0.0609072, -0.998143, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=194589);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194589, 5, 8617, 'Exodar Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=194589;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67903, 194589, 571, 1, 1, 8439.42, 1010.37, 544.698, -1.50971, 0, 0, 0, 1, 180, 255, 1),
+(73361, 194589, 571, 1, 1, 8439.42, 1010.37, 544.698, -1.50971, 0, 0, 0, 0, 0, 0, 1),
+(9180728, 194589, 1, 1, 1, -7279.68, 984.602, 308.397, 6.1613, 0, 0, 0.0609048, -0.998144, 300, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=170592);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (170592, 7, 2810, 'Arena Throne', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=170592;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(223623, 170592, 1, 1, 1, -1824.72, -4583.54, -115.128, 4.53332, 0, 0, 0.767499, -0.64105, 25, 0, 1),
+(240063, 170592, 1, 1, 1, -7256.76, 1032, 307.052, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(240085, 170592, 1, 1, 1, -7168.76, 1016.56, 306.909, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240109, 170592, 1, 1, 1, -7268.44, 944.602, 307.092, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240133, 170592, 1, 1, 1, -7182.67, 933.532, 306.979, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(9092906, 170592, 1, 1, 1, -9781.68, -2860.63, 119.206, 0.279273, 0, 0, 0.139183, 0.990267, 300, 0, 1),
+(9092464, 170592, 1, 1, 1, -7310.55, 2233.88, 72.4531, 0.480897, 0, 0, 0.238138, 0.971231, 300, 0, 1),
+(9109862, 170592, 1, 1, 1, 5855.94, -1995.04, 689.745, 5.42784, 0, 0, 0.414754, -0.909934, 300, 0, 1),
+(9109906, 170592, 1, 1, 1, 5871.12, -2012.51, 689.701, 2.28655, 0, 0, 0.909997, 0.414615, 300, 0, 1),
+(9330403, 170592, 1, 1, 1, -5082.57, -1103.69, 87.1186, 0.534018, 0, 0, 0.263848, 0.964564, 300, 0, 1),
+(9330402, 170592, 1, 1, 1, -5060.65, -1089.75, 86.936, 3.74954, 0, 0, 0.954155, -0.299314, 300, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=194606);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194606, 5, 8615, 'Horde Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=194606;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67920, 194606, 571, 1, 1, 8307.43, 705.927, 553.644, 0.253072, 0, 0, 0, 1, 180, 255, 1),
+(240136, 194606, 1, 1, 1, -7272.44, 946.637, 306.36, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240137, 194606, 1, 1, 1, -7267.45, 940.127, 306.361, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=194594);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194594, 5, 8623, 'Alliance Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=194594;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67908, 194594, 571, 1, 1, 8460.08, 950.043, 545.051, -3.09792, 0, 0, 0, 1, 180, 255, 1),
+(9180720, 194594, 1, 1, 1, -7184.78, 929.577, 306.361, 2.21718, 0, 0, 0.895071, 0.445924, 300, 0, 1),
+(9180717, 194594, 1, 1, 1, -7178.15, 934.61, 306.362, 2.24088, 0, 0, 0.900292, 0.435286, 300, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=194607);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194607, 5, 8621, 'Orgrimmar Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+DELETE FROM `gameobject` WHERE `id`=194607;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67921, 194607, 571, 1, 1, 8338.74, 687.096, 553.701, 1.59698, 0, 0, 0, 1, 180, 255, 1),
+(240004, 194607, 1, 1, 1, -7159.92, 968.19, 308.414, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=194605);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194605, 5, 8622, 'Silvermoon City Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=194605;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67919, 194605, 571, 1, 1, 8319.33, 744.352, 553.701, -0.98611, 0, 0, 0, 1, 180, 255, 1),
+(240003, 194605, 1, 1, 1, -7158.89, 974.126, 308.49, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=194604);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194604, 5, 8624, 'Thunder Bluff Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=194604;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67918, 194604, 571, 1, 1, 8357.72, 744.694, 553.627, -2.30383, 0, 0, 0, 1, 180, 255, 1),
+(240005, 194604, 1, 1, 1, -7158.29, 979.98, 308.413, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=194592);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194592, 5, 8619, 'Gnomeregan Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=194592;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(72058, 194592, 571, 1, 1, 8458.11, 905.744, 546.489, 2.82392, 0, 0, 0.987412, 0.158169, 30, 0, 1),
+(72043, 194592, 571, 1, 1, 8670.57, 692.054, 547.522, 1.89567, 0, 0, 0.812154, 0.583443, 30, 0, 1),
+(67906, 194592, 571, 1, 1, 8459.21, 905.564, 545.516, 2.75761, 0, 0, 0, 1, 180, 255, 1),
+(240088, 194592, 1, 1, 1, -7164.78, 1014.48, 306.361, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240089, 194592, 1, 1, 1, -7169.75, 1021, 306.36, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1);
+
+DELETE FROM `gameobject_template` WHERE (`entry`=194608);
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194608, 5, 8618, 'Undercity Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+
+DELETE FROM `gameobject` WHERE `id`=194608;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(72037, 194608, 571, 1, 1, 8368.94, 708.93, 553.772, 2.93164, 0, 0, 0.994495, 0.104784, 30, 0, 1),
+(240087, 194608, 1, 1, 1, -7254.69, 1036.01, 306.361, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(240086, 194608, 1, 1, 1, -7261.24, 1031, 306.36, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1);
diff --git a/sql/TrinityCore-Patches/GuildLevelSystem/auth_guild_level_system.sql b/sql/TrinityCore-Patches/GuildLevelSystem/auth_guild_level_system.sql
new file mode 100644
index 0000000..598b496
--- /dev/null
+++ b/sql/TrinityCore-Patches/GuildLevelSystem/auth_guild_level_system.sql
@@ -0,0 +1,7 @@
+INSERT INTO `rbac_permissions` VALUES ('1000', 'Command: guild info');
+INSERT INTO `rbac_permissions` VALUES ('1001', 'Command: guild setlevel');
+INSERT INTO `rbac_permissions` VALUES ('1002', 'Command: guild givexp');
+
+INSERT INTO `rbac_linked_permissions` VALUES ('195', '1000');
+INSERT INTO `rbac_linked_permissions` VALUES ('192', '1001');
+INSERT INTO `rbac_linked_permissions` VALUES ('192', '1002');
diff --git a/sql/TrinityCore-Patches/GuildLevelSystem/characters_guild_level_system.sql b/sql/TrinityCore-Patches/GuildLevelSystem/characters_guild_level_system.sql
new file mode 100644
index 0000000..ae05ff6
--- /dev/null
+++ b/sql/TrinityCore-Patches/GuildLevelSystem/characters_guild_level_system.sql
@@ -0,0 +1,55 @@
+ALTER TABLE `guild` ADD `xp` INT(10) DEFAULT 0 NOT NULL AFTER `BankMoney`;
+ALTER TABLE `guild` ADD `level` TINYINT(3) DEFAULT 0 NOT NULL AFTER `xp`;
+
+SET FOREIGN_KEY_CHECKS=0;
+
+-- ----------------------------
+-- Table structure for `guild_bonus_config`
+-- ----------------------------
+DROP TABLE IF EXISTS `guild_bonus_config`;
+CREATE TABLE `guild_bonus_config` (
+  `BonusId` smallint(5) NOT NULL DEFAULT '0',
+  `RequiredGuildLevel` tinyint(3) NOT NULL DEFAULT '0',
+  `comment` longtext CHARACTER SET utf8
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of guild_bonus_config
+-- ----------------------------
+INSERT INTO `guild_bonus_config` VALUES ('1', '1', 'Goldbonus | 5% Bonus gold for the guild bank');
+INSERT INTO `guild_bonus_config` VALUES ('2', '1', 'XP-Bonus | +5% XP at the end of quest or kill monsters');
+INSERT INTO `guild_bonus_config` VALUES ('3', '2', 'Faster Spirit | Double movement speed as spirit');
+INSERT INTO `guild_bonus_config` VALUES ('4', '2', 'Cheap repair | -25% Repair costs');
+INSERT INTO `guild_bonus_config` VALUES ('5', '3', 'Goldbonus-2 | 10% Bonus gold for the guild bank');
+INSERT INTO `guild_bonus_config` VALUES ('6', '4', 'Riding Pace | +5% Riding pace (Except Battlegrounds and Arenas)');
+INSERT INTO `guild_bonus_config` VALUES ('7', '4', 'Good Relationships | +5% Reputation gain');
+INSERT INTO `guild_bonus_config` VALUES ('8', '5', 'XP-Bonus-2 | +10% XP at the end of quest or kill monsters');
+INSERT INTO `guild_bonus_config` VALUES ('9', '6', 'Cheap Repair-2 | -50% Repair costs');
+INSERT INTO `guild_bonus_config` VALUES ('10', '6', 'Riding Pace-2 | +10% Riding pace (Except Battlegrounds and Arenas)');
+INSERT INTO `guild_bonus_config` VALUES ('11', '7', 'Good Relationships-2 | +10% Reputation gain');
+INSERT INTO `guild_bonus_config` VALUES ('12', '5', 'Bonus Honor | +5% Honor');
+INSERT INTO `guild_bonus_config` VALUES ('13', '8', 'Bonus Honor-2 | +10% Honor');
+
+SET FOREIGN_KEY_CHECKS=0;
+
+-- ----------------------------
+-- Table structure for `guild_xp_for_next_level`
+-- ----------------------------
+DROP TABLE IF EXISTS `guild_xp_for_next_level`;
+CREATE TABLE `guild_xp_for_next_level` (
+  `level` tinyint(3) NOT NULL DEFAULT '0',
+  `xp_for_next_level` int(10) NOT NULL DEFAULT '0',
+  PRIMARY KEY (`level`)
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of guild_xp_for_next_level
+-- ----------------------------
+INSERT INTO `guild_xp_for_next_level` VALUES ('0', '8000000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('1', '12000000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('2', '18000000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('3', '27000000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('4', '40500000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('5', '60750000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('6', '91125000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('7', '136687500');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/GuildLevelSystem/world_guild_level_system.sql b/sql/TrinityCore-Patches/GuildLevelSystem/world_guild_level_system.sql
new file mode 100644
index 0000000..2c72414
--- /dev/null
+++ b/sql/TrinityCore-Patches/GuildLevelSystem/world_guild_level_system.sql
@@ -0,0 +1,6 @@
+INSERT INTO `trinity_string` VALUES ('13000', 'Guild Level: %u.', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('13001', 'Guild Experience: %u/%u.', null, null, null, null, null, null, null, null);
+
+INSERT INTO `command` VALUES ('guild info', '1000', 'Syntax: .guild info');
+INSERT INTO `command` VALUES ('guild setlevel', '1001', 'Syntax: .guild setlevel $GuildName $Level');
+INSERT INTO `command` VALUES ('guild givexp', '1002', 'Syntax: .guild givexp $GuildName $Xp');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Individuale_XP-Raten/auth_individuale_xp_raten.sql b/sql/TrinityCore-Patches/Individuale_XP-Raten/auth_individuale_xp_raten.sql
new file mode 100644
index 0000000..145342c
--- /dev/null
+++ b/sql/TrinityCore-Patches/Individuale_XP-Raten/auth_individuale_xp_raten.sql
@@ -0,0 +1,5 @@
+INSERT INTO `rbac_permissions` VALUES ('1010', 'Command: modify xpkill');
+INSERT INTO `rbac_permissions` VALUES ('1011', 'Command: modify xpquest');
+
+INSERT INTO `rbac_linked_permissions` VALUES ('195', '1010');
+INSERT INTO `rbac_linked_permissions` VALUES ('195', '1011');
diff --git a/sql/TrinityCore-Patches/Individuale_XP-Raten/world_individuale_xp_raten.sql b/sql/TrinityCore-Patches/Individuale_XP-Raten/world_individuale_xp_raten.sql
new file mode 100644
index 0000000..f310d3d
--- /dev/null
+++ b/sql/TrinityCore-Patches/Individuale_XP-Raten/world_individuale_xp_raten.sql
@@ -0,0 +1,8 @@
+INSERT INTO `trinity_string` VALUES ('15004', 'Current XpKill Rate: %f.$BCurrent XpQuest Rate: %f.', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('15003', 'The specified value is too low, it should be between 1 and 8.', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('15001', 'XpQuest Rate set to %f ', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('15002', 'The specified value is too high, it should be between 1 and 8.', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('15000', 'XpKill Rate set to %f ', null, null, null, null, null, null, null, null);
+
+INSERT INTO `command` VALUES ('modify xpkill', '1010', 'Syntax: .modify xpkill #wert');
+INSERT INTO `command` VALUES ('modify xpquest', '1011', 'Syntax: .modify xpquest #wert');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Reforging/char_db_reforges.sql b/sql/TrinityCore-Patches/Reforging/char_db_reforges.sql
new file mode 100644
index 0000000..0a7673f
--- /dev/null
+++ b/sql/TrinityCore-Patches/Reforging/char_db_reforges.sql
@@ -0,0 +1,11 @@
+CREATE TABLE `custom_reforges` (
+	`GUID` INT(10) UNSIGNED NOT NULL COMMENT 'item guid low',
+	`increase` INT(10) UNSIGNED NOT NULL COMMENT 'stat_type',
+	`decrease` INT(10) UNSIGNED NOT NULL COMMENT 'stat_type',
+	`stat_value` INT(10) NOT NULL DEFAULT '0',
+	PRIMARY KEY (`GUID`)
+)
+COMMENT='version 0.1'
+COLLATE='latin1_swedish_ci'
+ENGINE=InnoDB
+ROW_FORMAT=COMPACT;
diff --git a/sql/TrinityCore-Patches/Reforging/reforger_npc.sql b/sql/TrinityCore-Patches/Reforging/reforger_npc.sql
new file mode 100644
index 0000000..2c3a89b
--- /dev/null
+++ b/sql/TrinityCore-Patches/Reforging/reforger_npc.sql
@@ -0,0 +1 @@
+INSERT INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES (190011, 20988, 0, 0, 0, 'Thaumaturge Vashreen', 'Arcane Reforger', NULL, 0, 80, 80, 2, 35, 1, 1, 1.14286, 1, 0, 500, 500, 0, 350, 1, 2000, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 138936390, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 1, 1, 0, 0, 1, 0, 0, 'REFORGER_NPC', 0);
diff --git a/sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql b/sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql
new file mode 100644
index 0000000..885c104
--- /dev/null
+++ b/sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql
@@ -0,0 +1,3 @@
+-- Example item:
+insert into `item_template` (`entry`, `class`, `subclass`, `SoundOverrideSubclass`, `name`, `displayid`, `Quality`, `Flags`, `FlagsExtra`, `BuyCount`, `BuyPrice`, `SellPrice`, `InventoryType`, `AllowableClass`, `AllowableRace`, `ItemLevel`, `RequiredLevel`, `RequiredSkill`, `RequiredSkillRank`, `requiredspell`, `requiredhonorrank`, `RequiredCityRank`, `RequiredReputationFaction`, `RequiredReputationRank`, `maxcount`, `stackable`, `ContainerSlots`, `StatsCount`, `stat_type1`, `stat_value1`, `stat_type2`, `stat_value2`, `stat_type3`, `stat_value3`, `stat_type4`, `stat_value4`, `stat_type5`, `stat_value5`, `stat_type6`, `stat_value6`, `stat_type7`, `stat_value7`, `stat_type8`, `stat_value8`, `stat_type9`, `stat_value9`, `stat_type10`, `stat_value10`, `ScalingStatDistribution`, `ScalingStatValue`, `dmg_min1`, `dmg_max1`, `dmg_type1`, `dmg_min2`, `dmg_max2`, `dmg_type2`, `armor`, `holy_res`, `fire_res`, `nature_res`, `frost_res`, `shadow_res`, `arcane_res`, `delay`, `ammo_type`, `RangedModRange`, `spellid_1`, `spelltrigger_1`, `spellcharges_1`, `spellppmRate_1`, `spellcooldown_1`, `spellcategory_1`, `spellcategorycooldown_1`, `spellid_2`, `spelltrigger_2`, `spellcharges_2`, `spellppmRate_2`, `spellcooldown_2`, `spellcategory_2`, `spellcategorycooldown_2`, `spellid_3`, `spelltrigger_3`, `spellcharges_3`, `spellppmRate_3`, `spellcooldown_3`, `spellcategory_3`, `spellcategorycooldown_3`, `spellid_4`, `spelltrigger_4`, `spellcharges_4`, `spellppmRate_4`, `spellcooldown_4`, `spellcategory_4`, `spellcategorycooldown_4`, `spellid_5`, `spelltrigger_5`, `spellcharges_5`, `spellppmRate_5`, `spellcooldown_5`, `spellcategory_5`, `spellcategorycooldown_5`, `bonding`, `description`, `PageText`, `LanguageID`, `PageMaterial`, `startquest`, `lockid`, `Material`, `sheath`, `RandomProperty`, `RandomSuffix`, `block`, `itemset`, `MaxDurability`, `area`, `Map`, `BagFamily`, `TotemCategory`, `socketColor_1`, `socketContent_1`, `socketColor_2`, `socketContent_2`, `socketColor_3`, `socketContent_3`, `socketBonus`, `GemProperties`, `RequiredDisenchantSkill`, `ArmorDamageModifier`, `duration`, `ItemLimitCategory`, `HolidayId`, `ScriptName`, `DisenchantID`, `FoodType`, `minMoneyLoot`, `maxMoneyLoot`, `flagsCustom`, `VerifiedBuild`) values
+('100000','15','0','-1','Icerune','46787','4','72','0','1','0','0','0','-1','-1','1','1','0','0','0','0','0','0','6','1','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','18282','0','0','0','8000','0','-1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','|cff00FF00Use: Summons Lithathrad Teleporter.|r','0','0','0','0','0','3','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','-1','0','0','0','0','summon','0','0','0','0','0','-4');
diff --git a/sql/TrinityCore-Patches/Transmogrification/characters.sql b/sql/TrinityCore-Patches/Transmogrification/characters.sql
new file mode 100644
index 0000000..815c4d3
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/characters.sql
@@ -0,0 +1,23 @@
+/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+/*!40101 SET NAMES utf8 */;
+/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+
+CREATE TABLE `custom_transmogrification` (
+  `GUID` int(10) unsigned NOT NULL COMMENT 'Item guidLow',
+  `FakeEntry` int(10) unsigned NOT NULL COMMENT 'Item entry',
+  `Owner` int(10) unsigned NOT NULL COMMENT 'Player guidLow',
+  PRIMARY KEY (`GUID`)
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+CREATE TABLE `custom_transmogrification_sets` (
+  `Owner` int(10) unsigned NOT NULL COMMENT 'Player guidlow',
+  `PresetID` tinyint(3) unsigned NOT NULL COMMENT 'Preset identifier',
+  `SetName` text COMMENT 'SetName',
+  `SetData` text COMMENT 'Slot1 Entry1 Slot2 Entry2',
+  PRIMARY KEY (`Owner`,`PresetID`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
+/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
+/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/_README.txt b/sql/TrinityCore-Patches/Transmogrification/updates/_README.txt
new file mode 100644
index 0000000..2359ef8
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/_README.txt
@@ -0,0 +1 @@
+DO NOT RUN THE UPDATES WHEN MAKING A CLEAN INSTALL
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_1_to_2_2.sql b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_1_to_2_2.sql
new file mode 100644
index 0000000..ee57844
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_1_to_2_2.sql
@@ -0,0 +1,12 @@
+CREATE TABLE IF NOT EXISTS `custom_transmogrification` (
+	`GUID` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+	`FakeOwner` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+	`FakeEntry` INT(10) UNSIGNED NOT NULL DEFAULT '0'
+)
+COLLATE='latin1_swedish_ci'
+ENGINE=InnoDB;
+
+REPLACE INTO custom_transmogrification (GUID, FakeOwner, FakeEntry) SELECT guid, FakeOwner, FakeEntry FROM item_instance WHERE FakeOwner != 0 AND FakeEntry != 0;
+ALTER TABLE `item_instance`
+	DROP COLUMN `FakeEntry`,
+	DROP COLUMN `FakeOwner`;
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_2_to_3_0.sql b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_2_to_3_0.sql
new file mode 100644
index 0000000..63059ee
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_2_to_3_0.sql
@@ -0,0 +1,2 @@
+ALTER TABLE `custom_transmogrification`
+	DROP COLUMN `FakeOwner`;
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_4_x_to_5_0.sql b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_4_x_to_5_0.sql
new file mode 100644
index 0000000..89c91ac
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_4_x_to_5_0.sql
@@ -0,0 +1,16 @@
+/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+/*!40101 SET NAMES utf8 */;
+/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+
+CREATE TABLE `custom_transmogrification_sets` (
+  `Owner` int(10) unsigned NOT NULL COMMENT 'Player guidlow',
+  `PresetID` tinyint(3) unsigned NOT NULL COMMENT 'Preset identifier',
+  `SetName` text COMMENT 'SetName',
+  `SetData` text COMMENT 'Slot1 Entry1 Slot2 Entry2',
+  PRIMARY KEY (`Owner`,`PresetID`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
+/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
+/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/world_update_3_5_to_3_6.sql b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_3_5_to_3_6.sql
new file mode 100644
index 0000000..03cc6d2
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_3_5_to_3_6.sql
@@ -0,0 +1 @@
+REPLACE INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (11129, 'You don\'t have enough %ss', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/world_update_4_x_to_5_0.sql b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_4_x_to_5_0.sql
new file mode 100644
index 0000000..8723683
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_4_x_to_5_0.sql
@@ -0,0 +1,27 @@
+DELETE FROM `trinity_string` WHERE `entry` BETWEEN 11100 AND 11129;
+
+SET @TEXT_ID := 50000;
+INSERT INTO `npc_text` (`ID`, `text0_0`, `WDBVerified`) VALUES
+(@TEXT_ID, 'Transmogrification allows you to change how your items look like without changing the stats of the items.\r\nItems used in transmogrification are no longer refundable, tradeable and are bound to you.\r\nUpdating a menu updates the view and prices.\r\n\r\nNot everything can be transmogrified with eachother.\r\nRestrictions include but are not limited to:\r\nOnly armor and weapons can be transmogrified\r\nGuns, bows and crossbows can be transmogrified with eachother\r\nFishing poles can not be transmogrified\r\nYou must be able to equip both items used in the process.\r\n\r\nTransmogrifications stay on your items as long as you own them.\r\nIf you try to put the item in guild bank or mail it to someone else, the transmogrification is stripped.\r\n\r\nYou can also remove transmogrifications for free at the transmogrifier.', 1),
+(@TEXT_ID+1, 'You can save your own transmogrification sets.\r\n\r\nTo save, first you must transmogrify your equipped items.\r\nThen when you go to the set management menu and go to save set menu,\r\nall items you have transmogrified are displayed so you see what you are saving.\r\nIf you think the set is fine, you can click to save the set and name it as you wish.\r\n\r\nTo use a set you can click the saved set in the set management menu and then select use set.\r\nIf the set has a transmogrification for an item that is already transmogrified, the old transmogrification is lost.\r\nNote that same transmogrification restrictions apply when trying to use a set as in normal transmogrification.\r\n\r\nTo delete a set you can go to the set\'s menu and select delete set.', 1);
+
+SET @STRING_ENTRY := 11100;
+INSERT INTO `trinity_string` (`entry`, `content_default`) VALUES
+(@STRING_ENTRY+0, 'Item transmogrified'),
+(@STRING_ENTRY+1, 'Equipment slot is empty'),
+(@STRING_ENTRY+2, 'Invalid source item selected'),
+(@STRING_ENTRY+3, 'Source item does not exist'),
+(@STRING_ENTRY+4, 'Destination item does not exist'),
+(@STRING_ENTRY+5, 'Selected items are invalid'),
+(@STRING_ENTRY+6, 'Not enough money'),
+(@STRING_ENTRY+7, 'You don\'t have enough tokens'),
+(@STRING_ENTRY+8, 'Transmogrifications removed'),
+(@STRING_ENTRY+9, 'There are no transmogrifications'),
+(@STRING_ENTRY+10, 'Invalid name inserted');
+
+SET
+@Entry = 190010,
+@Name = "Warpweaver";
+
+REPLACE INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES
+(@Entry, 19646, 0, @Name, "Transmogrifier", NULL, 0, 80, 80, 2, 35, 35, 1, 1, 0, 500, 500, 0, 350, 1, 2000, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, '', 0, 3, 1, 1, 1, 1, 0, 0, 1, 0, 0, 'Creature_Transmogrify', 0);
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/world_update_5_0_to_5_1.sql b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_5_0_to_5_1.sql
new file mode 100644
index 0000000..2a5e854
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_5_0_to_5_1.sql
@@ -0,0 +1,6 @@
+SET
+@Entry = 190010,
+@Name = "Warpweaver";
+
+REPLACE INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES
+(@Entry, 19646, 0, @Name, "Transmogrifier", NULL, 0, 80, 80, 2, 35, 35, 1, 1, 0, 500, 500, 0, 350, 1, 2000, 0, 1, 0, 0, 0, 0, 7, 138936390, 0, 0, 0, '', 0, 3, 1, 1, 1, 1, 0, 0, 1, 0, 0, 'Creature_Transmogrify', 0);
diff --git a/sql/TrinityCore-Patches/Transmogrification/world_NPC.sql b/sql/TrinityCore-Patches/Transmogrification/world_NPC.sql
new file mode 100644
index 0000000..1cd32f6
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/world_NPC.sql
@@ -0,0 +1,6 @@
+SET
+@Entry = 190010,
+@Name = "Warpweaver";
+
+INSERT INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(@Entry, 19646, 0, @Name, "Transmogrifier", NULL, 0, 80, 80, 2, 35, 1, 1, 0, 500, 500, 0, 350, 1, 2000, 0, 1, 0, 0, 0, 0, 7, 138936390, 0, 0, 0, '', 0, 3, 1, 1, 1, 1, 0, 0, 1, 0, 0, 'Creature_Transmogrify');
diff --git a/sql/TrinityCore-Patches/Transmogrification/world_texts.sql b/sql/TrinityCore-Patches/Transmogrification/world_texts.sql
new file mode 100644
index 0000000..e0bdf56
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/world_texts.sql
@@ -0,0 +1,18 @@
+SET @TEXT_ID := 50000;
+INSERT INTO `npc_text` (`ID`, `text0_0`) VALUES
+(@TEXT_ID, 'Transmogrification allows you to change how your items look like without changing the stats of the items.\r\nItems used in transmogrification are no longer refundable, tradeable and are bound to you.\r\nUpdating a menu updates the view and prices.\r\n\r\nNot everything can be transmogrified with eachother.\r\nRestrictions include but are not limited to:\r\nOnly armor and weapons can be transmogrified\r\nGuns, bows and crossbows can be transmogrified with eachother\r\nFishing poles can not be transmogrified\r\nYou must be able to equip both items used in the process.\r\n\r\nTransmogrifications stay on your items as long as you own them.\r\nIf you try to put the item in guild bank or mail it to someone else, the transmogrification is stripped.\r\n\r\nYou can also remove transmogrifications for free at the transmogrifier.'),
+(@TEXT_ID+1, 'You can save your own transmogrification sets.\r\n\r\nTo save, first you must transmogrify your equipped items.\r\nThen when you go to the set management menu and go to save set menu,\r\nall items you have transmogrified are displayed so you see what you are saving.\r\nIf you think the set is fine, you can click to save the set and name it as you wish.\r\n\r\nTo use a set you can click the saved set in the set management menu and then select use set.\r\nIf the set has a transmogrification for an item that is already transmogrified, the old transmogrification is lost.\r\nNote that same transmogrification restrictions apply when trying to use a set as in normal transmogrification.\r\n\r\nTo delete a set you can go to the set\'s menu and select delete set.');
+
+SET @STRING_ENTRY := 11100;
+INSERT INTO `trinity_string` (`entry`, `content_default`) VALUES
+(@STRING_ENTRY+0, 'Item transmogrified'),
+(@STRING_ENTRY+1, 'Equipment slot is empty'),
+(@STRING_ENTRY+2, 'Invalid source item selected'),
+(@STRING_ENTRY+3, 'Source item does not exist'),
+(@STRING_ENTRY+4, 'Destination item does not exist'),
+(@STRING_ENTRY+5, 'Selected items are invalid'),
+(@STRING_ENTRY+6, 'Not enough money'),
+(@STRING_ENTRY+7, 'You don\'t have enough tokens'),
+(@STRING_ENTRY+8, 'Transmogrifications removed'),
+(@STRING_ENTRY+9, 'There are no transmogrifications'),
+(@STRING_ENTRY+10, 'Invalid name inserted');
diff --git a/sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql b/sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql
new file mode 100644
index 0000000..48dd18e
--- /dev/null
+++ b/sql/TrinityCore-Patches/TriniIRC/World_TrinityChat.sql
@@ -0,0 +1,81 @@
+/**
+* Table structure for irc_commands
+*/
+DROP TABLE IF EXISTS `irc_commands`;
+CREATE TABLE `irc_commands` (
+  `Command` varchar(10) NOT NULL default '',
+  `Description` varchar(350) default NULL,
+  `gmlevel` tinyint(3) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`Command`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='IRC Module System';
+
+/**
+* Records
+*/
+INSERT INTO `irc_commands` VALUES ('acct', '[acct <Player> <(un)lock/email/pass/rename/gmlevel>] : Perform Action To <Player> Account.', '3');
+INSERT INTO `irc_commands` VALUES ('ban', '[ban <Player/IP> <ip/acct/unban/reason>] : Ban/Unban <Player>', '3');
+INSERT INTO `irc_commands` VALUES ('chan', '[chan <op/deop/voice/devoice> <*IRC Nick*>] : Set Mode On Yourself, If <IRC Nick> Is Specified Then Set mode On Nick.', '3');
+INSERT INTO `irc_commands` VALUES ('char', '[char <Player> <mailcheat/taxicheat/maxskill/setskill/combatstop/quest/mod>] : Perform Action To Character.', '3');
+INSERT INTO `irc_commands` VALUES ('fun', '[fun <Player> <Sound/Say>] : Do Selected Fun Action To <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('help', '[help Command] : Use No Paramaters For List Of Available Commands.', '0');
+INSERT INTO `irc_commands` VALUES ('inchan', '[inchan <Channel>] : Display Users In Selected In Game <Channel>', '0');
+INSERT INTO `irc_commands` VALUES ('info', '[info] : Display Server Info. (Number Of Players Online/Max Since Last Restart/Uptime)', '0');
+INSERT INTO `irc_commands` VALUES ('item', '[item <Player> <add> <ItemID/[ItemName]> <Amount>] : Additem To <Player>, Use <ItemID> Or <[Exact Item Name]>.', '3');
+INSERT INTO `irc_commands` VALUES ('jail', '[jail <Player> <release/Reason>] : Jail Selected <Player> For <Reason>. Using release As <Reason> Releases Player.', '3');
+INSERT INTO `irc_commands` VALUES ('kick', '[kick <Player> <Reason>] : Kick <Player> For <Reason>.', '3');
+INSERT INTO `irc_commands` VALUES ('kill', '[kill <Player> <Reason>] : Kill <Player> For <Reason>.', '3');
+INSERT INTO `irc_commands` VALUES ('level', '[level <Player> <NewLevel>] : Level <Player> To <NewLevel>. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('login', '[login <UserName> <Password>] : Login To TriniChat Admin Mode.  (Must Be Done In A PM)', '0');
+INSERT INTO `irc_commands` VALUES ('logout', '[logout] : Logout Of TriniChat Admin Mode.', '0');
+INSERT INTO `irc_commands` VALUES ('lookup', '[lookup <acct/char/creature/faction/go/item/quest/skill/spell/tele> <ID/Name>] : ', '3');
+INSERT INTO `irc_commands` VALUES ('money', '[money <Player> <(-)Money>] : Give Money To <Player>, Use - To Take Money. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('mute', '[mute <Player> <release/TimeInMins> <Reason>] : Mute Player For Reason, For <TimeInMins>. Using release As Time Releases Player. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('online', '[online] : Display All Users Logged In Game.', '0');
+INSERT INTO `irc_commands` VALUES ('pm', '[pm <Player> <Message>] : Whisper <Player> In WoW <Message>.', '3');
+INSERT INTO `irc_commands` VALUES ('reload', '[reload] : Reload TriniChat Config Options And Security Level From DataBase.', '3');
+INSERT INTO `irc_commands` VALUES ('restart', '[restart] : Restart TriniChat, NOT Trinity Core World Server Itself. Forces Reconnection To IRC Server.', '3');
+INSERT INTO `irc_commands` VALUES ('revive', '[revive <Player>] : Revive <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('saveall', '[saveall] : Forces Trinity Core To Save All Players.', '3');
+INSERT INTO `irc_commands` VALUES ('server', '[server setmotd [<motd>]/flusharenapoints]', '3');
+INSERT INTO `irc_commands` VALUES ('shutdown', '[shutdown <TimeInSeconds>] : Shuts The Server Down In <TimeInSeconds>, Use 0 For Immediate Shut Down', '3');
+INSERT INTO `irc_commands` VALUES ('spell', '[spell <Player> <Cast/Learn/UnLearn> <SpellID>] : Make <Player> <Learn> Or <UnLearn> A Spell, Or <Cast> A Spell On A <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('sysmsg', '[sysmsg <a/n/e/add/del/list> <Message>] : Broadcasts A System Message. (a-Broadcast System Message)(n-Broadcast Notify Message)(e-Event Message)', '3');
+INSERT INTO `irc_commands` VALUES ('tele', '[tele <Player> <l/c/r/to/cr/go/homebind> <Loc.Name/MAPID X Y Z/Recall/Player/Creature GUID/Gameobject GUID>] : Teleport Player To Location, Coords, Recall Location, Another Player, Creature or Gameobject. (l-Location)(c-Coords)', '3');
+INSERT INTO `irc_commands` VALUES ('top', '[top <accttime/chartime/money> <limit>] : Display top stats for given option. Only GM Higher Than Config Option Can Use Limit.', '3');
+INSERT INTO `irc_commands` VALUES ('who', '[who] : Displays Users Currently Logged In To TriniChat.', '1');
+
+/**
+* Table structure for irc_inchan
+*/
+DROP TABLE IF EXISTS `irc_inchan`;
+CREATE TABLE `irc_inchan` (
+  `guid` int(11) unsigned NOT NULL default '0' COMMENT 'Global Unique Identifier',
+  `name` varchar(12) NOT NULL default '',
+  `channel` varchar(15) NOT NULL default '',
+  PRIMARY KEY  (`guid`,`channel`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='IRC Module System';
+
+/**
+* Records
+*/
+
+/**
+* Table structure for irc_autoannounce
+*/
+DROP TABLE IF EXISTS `irc_autoannounce`;
+CREATE TABLE `irc_autoannounce` (
+  `id` int(11) NOT NULL auto_increment,
+  `message` longtext NOT NULL,
+  `addedby` varchar(12) NOT NULL default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='IRC Module System';
+
+/**
+* Records
+*/
+INSERT INTO `irc_autoannounce` VALUES ('1', 'Welcome to IRC Channel', '');
+
+DELETE FROM `trinity_string` WHERE entry IN (6610,6611,6612);
+INSERT INTO `trinity_string` VALUES ('6610', '|cffff0000[System Message]: %s|r', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('6611', '|cffff0000[Server Event]: %s|r', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('6612', '|cffff0000[Automatic]: %s|r', null, null, null, null, null, null, null, null);
diff --git a/sql/TrinityCore-Patches/beastmaster/2014_04_12-world-beastmaster.sql b/sql/TrinityCore-Patches/beastmaster/2014_04_12-world-beastmaster.sql
new file mode 100644
index 0000000..58c2512
--- /dev/null
+++ b/sql/TrinityCore-Patches/beastmaster/2014_04_12-world-beastmaster.sql
@@ -0,0 +1,64 @@
+DROP TABLE IF EXISTS `beastmaster`;
+
+CREATE TABLE `beastmaster` (
+  `entry` INT(5) NOT NULL DEFAULT '0' COMMENT 'Pet entry number',
+  `cat_number` INT(5) NOT NULL DEFAULT '0' COMMENT '0-normal pet 1-exotic pet 2-pet spell',
+  `tokenOrGold` TINYINT(1) DEFAULT '0' COMMENT '0 = gold 1 = token',
+  `cost` INT(10) NOT NULL DEFAULT '0' COMMENT 'Amount in copper if tokenOrGold is 0 else number of tokens',
+  `token` INT(10) NOT NULL DEFAULT '0' COMMENT 'Token entry number (item_template.entry)',
+  `name` VARCHAR(255) DEFAULT NULL COMMENT 'Name of pet or name of pet spell',
+  `spell` INT(10) NOT NULL DEFAULT '0' COMMENT 'Spell entry number.',
+  PRIMARY KEY (`entry`)
+) ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT='Beastmaster System by LordPsyan';
+
+/*Data for the table `beastmaster` */
+
+INSERT INTO `beastmaster` (`entry`, `cat_number`, `tokenOrGold`, `cost`, `token`, `name`, `spell`) VALUES
+('1','0','1','1000','0','Spider','2349'),
+('2','0','0','1000','0','Bat','28233'),
+('3','0','0','1000','0','Bear','29319'),
+('4','0','0','1000','0','Boar','29996'),
+('5','0','0','1000','0','Cat','28097'),
+('6','0','0','1000','0','Carrion Bird','26838'),
+('7','0','0','1000','0','Crab','24478'),
+('8','0','0','1000','0','Crocolisk','1417'),
+('9','0','0','1000','0','Dragonhawk','27946'),
+('10','0','0','1000','0','Gorilla','28213'),
+('11','0','0','1000','0','Hyena','13036'),
+('12','0','0','1000','0','Moth','27421'),
+('13','0','0','1000','0','Owl','23136'),
+('14','0','0','1000','0','Raveger','17199'),
+('15','0','0','1000','0','Raptor','14821'),
+('16','0','0','1000','0','Serpent','28358'),
+('17','0','0','1000','0','Bug','28085'),
+('18','0','0','1000','0','Strider','22807'),
+('19','0','0','1000','0','Scorpid','9698'),
+('20','1','0','1000','0','Chimaera','21879'),
+('21','1','0','1000','0','Core Hound','21108'),
+('22','1','0','1000','0','Devilsaur','20931'),
+('23','1','0','1000','0','Rhino','30445'),
+('24','1','0','1000','0','Silithid','5460'),
+('25','1','0','1000','0','Worm','30148'),
+('26','1','0','1000','0','Loque\'nahak','32517'),
+('27','1','0','1000','0','Skoll','35189'),
+('28','1','0','1000','0','Gondria','33776'),
+('29','2','1','1000','0','Feed Pet','6991'),
+('30','2','0','1000','0','Call Pet','883'),
+('31','2','0','1000','0','Dismiss Pet','2641'),
+('32','2','0','1000','0','Mend Pet','136');
+
+-- Beastmaster NPC
+
+DELETE FROM `creature_template` WHERE `entry` = 99990;
+
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES
+('99990','0','0','0','0','0','26789','0','0','0','LordPsyan','Beastmaster Service','','0','80','80','0','35','129','1','1.14286','0.75','1','1755','1755','0','1504','1','1500','0','1','0','0','0','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','Npc_Beastmaster','0');
+
+-- Sample npc vendor data for beastmaster
+
+DELETE FROM `npc_vendor` WHERE `entry` = 99990;
+
+INSERT INTO `npc_vendor` (`entry`, `slot`, `item`, `maxcount`, `incrtime`, `ExtendedCost`) VALUES
+('99990','0','4540','0','0','0'),
+('99990','0','4541','0','0','0'),
+('99990','0','4542','0','0','0');
diff --git a/sql/TrinityCore-Patches/enchant/world.enchant.sql b/sql/TrinityCore-Patches/enchant/world.enchant.sql
new file mode 100644
index 0000000..bc63672
--- /dev/null
+++ b/sql/TrinityCore-Patches/enchant/world.enchant.sql
@@ -0,0 +1,4 @@
+-- Creature template. Young woman enchantress
+DELETE FROM `creature_template` WHERE `entry` = 100067;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('100067','0','0','0','0','0','2591','0','0','0','Young Woman','You need it, I got it.','','0','80','80','0','35','1','1','1.14286','1','1','1755','1755','0','1504','1','1500','0','1','0','2048','0','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','EventAI','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','npc_enchantment','0');
diff --git a/sql/TrinityCore-Patches/fake_players/characters-characters_fake-full.sql b/sql/TrinityCore-Patches/fake_players/characters-characters_fake-full.sql
new file mode 100644
index 0000000..9069f54
--- /dev/null
+++ b/sql/TrinityCore-Patches/fake_players/characters-characters_fake-full.sql
@@ -0,0 +1,35 @@
+/*
+SQLyog Enterprise - MySQL GUI v8.18
+MySQL - 5.5.31-0+wheezy1 : Database - fake_characters
+*********************************************************************
+*/
+
+/*!40101 SET NAMES utf8 */;
+
+/*!40101 SET SQL_MODE=''*/;
+
+/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
+/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
+/*Table structure for table `characters_fake` */
+
+DROP TABLE IF EXISTS `characters_fake`;
+
+CREATE TABLE `characters_fake` (
+  `name` varchar(36) NOT NULL,
+  `race` mediumint(3) NOT NULL DEFAULT '0',
+  `class` mediumint(3) NOT NULL DEFAULT '0',
+  `level` mediumint(3) NOT NULL DEFAULT '0',
+  `zone` mediumint(9) NOT NULL DEFAULT '0',
+  `gender` mediumint(3) NOT NULL DEFAULT '0'
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+/*Data for the table `characters_fake` */
+
+insert  into `characters_fake`(`name`,`race`,`class`,`level`,`zone`,`gender`) values ('Drikish',2,8,18,30,0),('Sovelis',1,1,71,38,0),('Cuddles',2,2,62,33,0),('Epiasdv',8,4,16,26,0),('Mac',5,4,51,34,0),('Tiesto',8,6,45,44,0),('Ihavfacebook',11,7,72,16,1),('Mimik',2,4,66,49,0),('Deadmau',5,4,31,33,0),('Smoosh',8,1,39,40,0),('Shadowcrest',4,4,17,38,1),('Lolol',4,5,49,4,1),('Prox',11,1,33,7,1),('Rovip',3,4,18,33,0),('Ryan',7,8,69,37,0),('Holysmite',1,2,48,21,0),('Airagon',6,2,33,41,0),('Fracture',5,1,22,42,0),('Supershen',3,2,11,36,1),('Jana',2,6,64,3,0),('Gamm',2,1,49,7,0),('Emoarchie',6,8,52,25,0),('Melia',1,2,33,4,1),('Balu',6,11,4,33,0),('Jabari',2,1,5,25,0),('Sinan',10,2,11,7,0),('Shisha',10,4,38,19,1),('Killbill',1,4,76,7,0),('Gaby',4,11,24,7,1),('Fallen',4,4,51,23,0),('Druidita',6,11,24,26,0),('Pigolo',6,11,46,10,0),('Saga',5,2,78,24,0),('Deadmask',10,2,9,40,0),('Assasincz',4,6,50,25,0),('Petracz',1,4,64,6,1),('Aleks',10,2,8,3,0),('Cazadormen',4,4,7,46,1),('Kireth',1,2,10,33,1),('Liesma',1,1,29,20,1),('Tyller',1,1,33,34,0),('Astrabutaz',1,2,77,8,0),('Carlita',7,8,44,37,1),('Beanie',10,2,70,13,0),('Nergal',10,3,55,1,0),('Smikis',10,5,63,18,0),('Peperoma',11,2,70,37,0),('May',1,2,5,30,1),('Keyadis',8,7,34,36,0),('Preatorian',10,2,5,42,0),('Mitza',1,9,81,50,0),('Keedor',10,2,69,24,0),('Kekw',4,3,22,33,1),('Wark',1,2,63,34,0),('Barrabus',10,2,7,5,0),('Malodetehepy',4,11,5,23,0),('Dranati',10,2,79,1,0),('Sorin',2,1,62,34,0),('Resan',4,4,73,18,0),('Silverhilt',1,1,15,38,1),('Chirica',10,2,18,36,0),('Trias',10,8,44,14,0),('Prdo',5,1,5,11,0),('Guten',8,7,49,12,0),('Sonsia',4,3,73,27,1),('Smikiss',10,4,54,49,0),('Ledy',4,1,50,13,1),('Rymar',5,6,8,17,0),('Rokass',5,1,50,45,0),('Waisha',10,3,64,24,1),('Xenon',4,1,8,34,0),('Palanoski',1,2,8,49,0),('Helona',6,11,13,41,1),('Skalons',2,1,42,10,0),('Zazlock',5,9,11,25,0),('Zazk',6,7,8,43,0),('Ezekiel',10,9,7,40,0),('Deiv',10,8,11,21,0),('Crashwar',5,1,30,33,0),('Bandaid',5,5,36,1,0),('Hunterherbie',4,3,10,7,0),('Cheesebeard',3,1,20,30,0),('Phin',7,6,68,31,0),('Prig',6,5,41,15,0),('Eraevel',6,5,78,32,1),('Bourne',5,4,28,12,0),('Twoogi',5,8,65,13,0),('Devon',5,6,5,27,0),('Ledystar',1,2,50,6,1),('Frostie',3,8,6,43,1),('Kie',5,4,38,33,0),('Reios',1,2,9,10,0),('Zero',4,4,13,6,0),('Wuk',2,1,38,47,0),('Sylvaediir',4,3,69,17,0),('Kansetsu',11,2,68,42,0),('Makura',11,2,52,10,1),('Demonia',11,2,55,24,1),('Stonebull',6,11,37,39,0),('Marianus',10,2,19,33,0);
+
+/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
+/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
+/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
+/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
diff --git a/sql/TrinityCore-Patches/fake_players/characters-characters_fake-structure.sql b/sql/TrinityCore-Patches/fake_players/characters-characters_fake-structure.sql
new file mode 100644
index 0000000..2cffde1
--- /dev/null
+++ b/sql/TrinityCore-Patches/fake_players/characters-characters_fake-structure.sql
@@ -0,0 +1,31 @@
+/*
+SQLyog Enterprise - MySQL GUI v8.18
+MySQL - 5.5.31-0+wheezy1 : Database - fake_characters
+*********************************************************************
+*/
+
+/*!40101 SET NAMES utf8 */;
+
+/*!40101 SET SQL_MODE=''*/;
+
+/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
+/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
+/*Table structure for table `characters_fake` */
+
+DROP TABLE IF EXISTS `characters_fake`;
+
+CREATE TABLE `characters_fake` (
+  `name` varchar(36) NOT NULL,
+  `race` mediumint(3) NOT NULL DEFAULT '0',
+  `class` mediumint(3) NOT NULL DEFAULT '0',
+  `level` mediumint(3) NOT NULL DEFAULT '0',
+  `zone` mediumint(9) NOT NULL DEFAULT '0',
+  `gender` mediumint(3) NOT NULL DEFAULT '0'
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
+/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
+/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
+/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
diff --git a/sql/TrinityCore-Patches/fake_players/characters_fake_readme.txt b/sql/TrinityCore-Patches/fake_players/characters_fake_readme.txt
new file mode 100644
index 0000000..c0d7d60
--- /dev/null
+++ b/sql/TrinityCore-Patches/fake_players/characters_fake_readme.txt
@@ -0,0 +1,18 @@
+Fake Characters instructions
+
+import either characters-characters_fake-structure.sql (for structure only. you will have to make fake players) or
+characters-characters_fake-full.sql (fake characters already created) into your characters database.
+
+Import trinity_string into your world database.
+
+world config file:
+
+#    Fake.WHO.List
+#        Add fake players to fill in WHO LIST (who is online list, "O" button) if there is less then
+#        49 real players online
+#        Default: 0 (disabled)
+#                 1 (enabled)
+
+Fake.Who.List = 0
+
+0 is default and is turned off. change to 1 if you want the fake players to appear in the who list.
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/fake_players/trinity_string_fake_players.sql b/sql/TrinityCore-Patches/fake_players/trinity_string_fake_players.sql
new file mode 100644
index 0000000..6a4927d
--- /dev/null
+++ b/sql/TrinityCore-Patches/fake_players/trinity_string_fake_players.sql
@@ -0,0 +1,8 @@
+/*
+SQLyog Enterprise - MySQL GUI v8.18
+MySQL - 5.5.31-0+wheezy1
+*********************************************************************
+*/
+/*!40101 SET NAMES utf8 */;
+
+insert into `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) values('12001','Player wishes to not be disturbed and cannot receive whisper messages.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
diff --git a/sql/TrinityCore-Patches/guildhouses/world_guildhouses.sql b/sql/TrinityCore-Patches/guildhouses/world_guildhouses.sql
new file mode 100644
index 0000000..13a034d
--- /dev/null
+++ b/sql/TrinityCore-Patches/guildhouses/world_guildhouses.sql
@@ -0,0 +1,67 @@
+-- ----------------------------
+-- Table structure for guildhouses
+-- ----------------------------
+
+DROP TABLE IF EXISTS `guildhouses`;
+
+CREATE TABLE `guildhouses` (
+  `id` int(8) unsigned NOT NULL auto_increment,
+  `guildId` bigint(20) NOT NULL default '0',
+  `x` double NOT NULL,
+  `y` double NOT NULL,
+  `z` double NOT NULL,
+  `map` int(11) NOT NULL,
+  `comment` varchar(255) NOT NULL default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=42 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
+
+-- ----------------------------
+-- Records
+-- ----------------------------
+INSERT INTO `guildhouses` VALUES
+('1', '0', '16222', '16266', '14.2', '1', 'GM Island'),
+('2', '0', '-10711', '2483', '8', '1', 'Tauren village at Veiled Sea (Silithus)'),
+('3', '0', '-8323', '-343', '146', '0', 'Fishing outside an Northshire Abbey (Elwynn Forest'),
+('4', '0', '7368', '-1560', '163', '1', 'Troll Village in mountains (Darkshore)'),
+('5', '0', '-4151', '-1400', '198', '0', 'Dwarven village outside Ironforge (Wetlands)'),
+('6', '0', '-1840', '-4233', '2.14', '0', 'Dwarven village (Arathi Highlands, Forbidding Sea)'),
+('8', '0', '-723', '-1076', '179', '1', 'Tauren camp (Mulgore, Red Rock)'),
+('9', '0', '-206', '1666', '80', '0', 'Shadowfang Keep an outside instance (Silverpine Forest)'),
+('10', '0', '-6374', '1262', '7', '0', 'Harbor house outside Stormwind (Elwynn Forest)'),
+('11', '0', '-8640', '580', '96', '0', 'Empty jail between canals (Stormwind) DELETE'),
+('12', '0', '-4844', '-1066', '502', '0', 'Old Ironforge'),
+('13', '0', '-4863', '-1658', '503.5', '0', 'Ironforge Airport'),
+('14', '0', '1146', '-165', '313', '37', 'Azshara Crater instance (Alliance entrance)'),
+('15', '0', '-123', '858', '298', '37', 'Azshara Crater instance (Horde entrance)'),
+('16', '0', '4303', '-2760', '16.8', '0', 'Quel\'Thalas Tower'),
+('17', '0', '-6161', '-790', '423', '0', 'Crashed gnome airplane (between Dun Morogh and Searing Gorge)'),
+('18', '0', '-11790', '-1640', '54.7', '0', 'Zul\'Gurub an outside instance (Stranglethorn Vale)'),
+('19', '0', '-11805', '-4754', '6', '1', 'Goblin village (Tanaris, South Seas)'),
+('20', '0', '-9296', '670', '132', '0', 'Villains camp outside an Stormwind (Elwynn Forest)'),
+('21', '0', '3414', '-3380', '142.2', '0', 'Stratholm an outside instance'),
+('22', '0', '4654', '-3772', '944', '1', 'Kalimdor Hyjal (Aka World Tree)'),
+('23', '0', '2176', '-4766', '55', '1', 'The Ring of Valor (Aka. Orgrimmar Arena)'),
+('24', '0', '1951.512085', '1530.475586', '247.288147', '1', 'Stonetalon Logging Camp'),
+('25', '0', '2813.660645', '2248.552979', '215.524643', '1', 'Stonetalon Ruins'),
+('28', '0', '9725.27', '-21.43', '20.03', '1', 'Teldrassil Furbold camp'),
+('29', '0', '-3855', '-3479', '579', '0', 'Wetlands mountain camp'),
+('30', '0', '-5362', '-2540', '485', '0', 'Ortell\'s Hideout'),
+('31', '0', '-12865', '-1396', '115', '0', 'Stranglethorn Secret Cave'),
+('32', '0', '-11073', '-1956', '39', '0', 'Karazhan Smiley'),
+('33', '0', '-11084', '-1801', '53', '0', 'Well of the Forgotten (Aka. Karazhan Crypt or Lower Karazhan)'),
+('34', '0', '1683.235474', '286.458801', '-45.451775', '0', 'Undercity Top Tier'),
+('35', '0', '-8521.3', '599.5', '101.399338', '0', 'Stormwind Cut-Throat Alley'),
+('36', '0', '-5933', '452', '509', '0', 'Forgotten gnome camp'),
+('37', '0', '-920.231323', '7096.489258', '170.35289', '530', 'Outland Nagrand : Newton\'s Remains'),
+('38', '0', '-2140.501953', '9142.6875', '137.041855', '530', 'Outland Nagrand : Tomb'),
+('39', '0', '-483.401794', '7461.944824', '186.120987', '530', 'Outland Nagrand: Challe\'s Home for Little Tykes'),
+('40', '0', '2387.753906', '3191.757324', '152.669388', '530', 'Outland Netherstorm: Nova\'s Shrine');
+
+-- *************************
+-- * NPC Guildhouse Keeper *
+-- *************************
+
+DELETE FROM creature_template WHERE `entry`=13;
+
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES
+('13','0','0','0','0','0','26789','0','0','0','Beltez','Guildhouse Keeper',NULL,'0','80','80','0','35','1','1','1.14286','0.75','0','181','189','0','158','1','1400','1900','1','0','0','8','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','3','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','guildmaster','12340');
diff --git a/sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql b/sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql
new file mode 100644
index 0000000..47da912
--- /dev/null
+++ b/sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql
@@ -0,0 +1,62 @@
+DROP TABLE IF EXISTS `npc_buff_spells`;
+
+CREATE TABLE `npc_buff_spells` (
+  `spell_id` int(5) NOT NULL default '0' COMMENT 'Spell entry number',
+  `cat_number` int(5) NOT NULL default '0' COMMENT '0-small buff 1-great buff 2-gm buff 3-player tools',
+  `cost` int(10) NOT NULL default '0' COMMENT 'cost amount in copper',
+  `name` text COMMENT 'Name of spell',
+  PRIMARY KEY  (`spell_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+/*Data for the table `npc_buff_spells` */
+
+INSERT INTO `npc_buff_spells` (`spell_id`, `cat_number`, `cost`, `name`) VALUES
+-- Small Buff
+(48469,1001,10000,"Mark of the Wild"),
+(53307,1002,10000,"Thorns"),
+(43017,1003,10000,"Amplify Magic"),
+(42995,1004,10000,"Arcane Intellect"),
+(61024,1005,10000,"Dalaran Intellect"),
+(43015,1006,10000,"Dampen Magic"),
+(20217,1007,10000,"Blessing of Kings"),
+(48932,1008,10000,"Blessing of Might"),
+(48936,1009,10000,"Blessing of Wisdom"),
+(48072,1010,10000,"Divine Spirit"),
+(48161,1011,10000,"Power Word: Fortitude"),
+(48169,1012,10000,"Shadow Protection"),
+-- Great Buff
+(48470,2001,100000,"Gift of the Wild"),
+(43002,2002,100000,"Arcane Brilliance"),
+(61316,2003,100000,"Dalaran Brilliance"),
+(25898,2004,100000,"Greater Blessing of Kings"),
+(48934,2005,100000,"Greater Blessing of Might"),
+(25899,2006,100000,"Greater Blessing of Sanctuary"),
+(48938,2007,100000,"Greater Blessing of Wisdom"),
+(48162,2008,100000,"Prayer of Fortitude"),
+(48170,2009,100000,"Prayer of Shadow Protection"),
+(48074,2010,100000,"Prayer of Spirit"),
+-- GM Buff
+(17013,3001,0,"Agamaggan's Agility"),
+(16612,3002,0,"Agamaggan's Strength"),
+(58453,3003,0,"Armor Magic"),
+(34106,3004,0,"Armor Penetration"),
+(25661,3005,0,"Increased Stamina"),
+(16610,3006,0,"Razorhide"),
+(10767,3007,0,"Rising Spirit"),
+(16618,3008,0,"Spirit of the Wind"),
+(7764,3009,0,"Wisdom of Agamaggan"),
+-- Player Tools
+(46642,4001,0,"Give me Gold"),
+(24827,4002,0,"Give me Soul Shards"),
+(38588,4003,0,"Heal me please"),
+(53251,4004,0,"Heal me and party members Please"),
+(42956,4005,0,"Conjure Refreshment"),
+(42985,4006,0,"Conjure Mana Gem");
+
+DELETE FROM `creature_template` WHERE `entry` = 60002;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES
+('60002', '0', '0', '0', '0', '0', '18', '0', '18', '0', 'LordPsyan', 'Buffs master', '', '0', '59', '61', '0', '35', '1', '1.48', '1.14286', '0.0', '0', '655.0', '663.0', '0', '158', '1.0', '1500', '1900', '1', '0', '0', '0', '0', '0', '0', '0', '0.0', '0.0', '100', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '', '1', '3', '1.0', '1.0', '1.0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', 'npc_buff', '1');
+
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100002, 'Choose your Buff Type.'),
+   (100003, 'Choose your Buff.');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql b/sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql
new file mode 100644
index 0000000..e8d0cf5
--- /dev/null
+++ b/sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql
@@ -0,0 +1,4 @@
+DELETE FROM `creature_template` WHERE `entry` = 60001;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES
+('60001', '0', '0', '0', '0', '0', '18', '0', '18', '0', 'Cyon', 'Profession master', '', '0', '59', '61', '0', '35', '1', '1.48', '1.14286', '0.0', '0', '655.0', '663.0', '0', '158', '1.0', '1500', '1900', '1', '0', '0', '0', '0', '0', '0', '0', '0.0', '0.0', '100', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '', '1', '3', '1.0', '1.0', '1.0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', 'professionnpc', '1');
+-- end
diff --git a/sql/TrinityCore-Patches/world.npc_teleport.sql b/sql/TrinityCore-Patches/world.npc_teleport.sql
new file mode 100644
index 0000000..52372d0
--- /dev/null
+++ b/sql/TrinityCore-Patches/world.npc_teleport.sql
@@ -0,0 +1,119 @@
+DROP TABLE IF EXISTS `custom_npc_tele_category`;
+CREATE TABLE `custom_npc_tele_category` (
+  `id` int(6) unsigned NOT NULL default '0',
+  `name` varchar(255) NOT NULL default '',
+  `flag` tinyint(3) unsigned NOT NULL default '0',
+  `data0` bigint(20) unsigned NOT NULL default '0',
+  `data1` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_destination`;
+CREATE TABLE `custom_npc_tele_destination` (
+  `id` int(6) unsigned NOT NULL auto_increment,
+  `name` char(100) NOT NULL default '',
+  `pos_X` float NOT NULL default '0',
+  `pos_Y` float NOT NULL default '0',
+  `pos_Z` float NOT NULL default '0',
+  `map` smallint(5) unsigned NOT NULL default '0',
+  `orientation` float NOT NULL default '0',
+  `level` tinyint(3) unsigned NOT NULL default '0',
+  `cost` int(10) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_association`;
+CREATE TABLE `custom_npc_tele_association` (
+  `cat_id` int(6) unsigned NOT NULL default '0',
+  `dest_id` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`cat_id`, `dest_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+TRUNCATE `custom_npc_tele_category`;
+INSERT INTO `custom_npc_tele_category`
+   (`id`, `name`, `flag`, `data0`, `data1`)
+VALUES
+   (1, 'Cities', 0, 1, 0),
+   (2, 'Cities', 0, 2, 0),
+   (3, 'Battlegrounds', 0, 1, 0),
+   (4, 'Battlegrounds', 0, 2, 0),
+   (5, 'Arenas', 0, 0, 0),
+   (6, '[Instances Lvl 1-60]', 0, 0, 0),
+   (7, '[Instances Lvl 60+]', 5, 60, 0),
+   (8, '[Instances Lvl 70+]', 5, 70, 0),
+   (9, 'Destinations MJ', 3, 0, 0);
+
+TRUNCATE `custom_npc_tele_destination`;
+INSERT INTO `custom_npc_tele_destination`
+   (`id`, `name`, `pos_X`, `pos_Y`, `pos_Z`, `map`, `orientation`, `level`, `cost`)
+VALUES
+   (1, 'Alterac Valley', 883.187, -489.375, 96.7618, 30, 3.06932, 0, 0),
+   (2, 'Alterac Valley', -818.155, -623.043, 54.0884, 30, 2.1, 0, 0),
+   (3, 'Arathi Basin', 686.053, 683.165, -12.9149, 529, 0.18, 0, 0),
+   (4, 'Arathi Basin', 1308.68, 1306.03, -9.0107, 529, 3.91285, 0, 0),
+   (5, 'Black Temple', -3610.72, 324.988, 37.4, 530, 3.28298, 0, 0),
+   (6, 'Blackfathom Deeps', 4254.58, 664.74, -29.04, 1, 1.97, 0, 0),
+   (7, 'Blackrock Depths', -7301.03, -913.19, 165.37, 0, 0.08, 0, 0),
+   (8, 'Blackrock Spire', -7535.43, -1212.04, 285.45, 0, 5.29, 0, 0),
+   (9, 'Blackwing Lair', -7665.55, -1102.49, 400.679, 469, 0, 0, 0),
+   (10, 'Caverns of Time', -8173.66, -4746.36, 33.8423, 1, 4.93989, 0, 0),
+   (11, 'Circle of Blood', 2839.44, 5930.17, 11.1002, 530, 3.16284, 0, 0),
+   (12, 'Coilfang Reservoir', 517.288, 6976.28, 32.0072, 530, 0, 0, 0),
+   (13, 'Darnassus', 9947.52, 2482.73, 1316.21, 1, 0, 0, 0),
+   (14, 'Dire Maul', -3982.47, 1127.79, 161.02, 1, 0.05, 0, 0),
+   (15, 'Exodar', -4073.03, -12020.4, -1.47, 530, 0, 0, 0),
+   (16, 'Eye of the Storm', 2487.72, 1609.12, 1224.64, 566, 3.35671, 0, 0),
+   (17, 'Eye of the Storm', 1843.73, 1529.77, 1224.43, 566, 0.297579, 0, 0),
+   (18, 'Goldshire', -9464, 62, 56, 0, 0, 0, 0),
+   (19, 'Gruul\'s Lair', 3539.01, 5082.36, 1.69107, 530, 0, 0, 0),
+   (20, 'Gurubashi', -13261.3, 168.294, 35.0792, 0, 1.00688, 0, 0),
+   (21, 'Hellfire Citadel', -305.816, 3056.4, -2.47318, 530, 2.01, 0, 0),
+   (22, 'Ironforge', -4924.07, -951.95, 501.55, 0, 5.4, 0, 0),
+   (23, 'Isle Of Quel\'Danas', 12947.4, -6893.31, 5.68398, 530, 3.09154, 0, 0),
+   (24, 'Karazhan', -11118.8, -2010.84, 47.0807, 0, 0, 0, 0),
+   (25, 'Maraudon', -1433.33, 2955.34, 96.21, 1, 4.82, 0, 0),
+   (26, 'Molten Core', 1121.45, -454.317, -101.33, 230, 3.5, 0, 0),
+   (27, 'Naxxramas', 3125.18, -3748.02, 136.049, 0, 0, 0, 0),
+   (28, 'Onyxia\'s Lair', -4707.44, -3726.82, 54.6723, 1, 3.8, 0, 0),
+   (29, 'Orgrimmar', 1552.5, -4420.66, 8.94802, 1, 0, 0, 0),
+   (30, 'Razor Hill', 315.721, -4743.4, 10.4867, 1, 0, 0, 0),
+   (31, 'Razorfen Downs', -4645.08, -2470.85, 85.53, 1, 4.39, 0, 0),
+   (32, 'Razorfen Kraul', -4484.04, -1739.4, 86.47, 1, 1.23, 0, 0),
+   (33, 'Ring of Trials', -1999.94, 6581.71, 11.32, 530, 2.3, 0, 0),
+   (34, 'Ruins of Ahn\'Qiraj', -8409.03, 1498.83, 27.3615, 1, 2.49757, 0, 0),
+   (35, 'Scholomance', 1219.01, -2604.66, 85.61, 0, 0.5, 0, 0),
+   (36, 'Shadowfang Keep', -254.47, 1524.68, 76.89, 0, 1.56, 0, 0),
+   (37, 'Shattrath City', -1850.21, 5435.82, -10.9614, 530, 3.40391, 0, 0),
+   (38, 'Silvermoon', 9338.74, -7277.27, 13.7895, 530, 0, 0, 0),
+   (39, 'Stormwind', -8960.14, 516.266, 96.3568, 0, 0, 0, 0),
+   (40, 'Stratholme', 3263.54, -3379.46, 143.59, 0, 0, 0, 0),
+   (41, 'Tempest Keep', 3089.58, 1399.05, 187.653, 530, 4.79407, 0, 0),
+   (42, 'Temple of Ahn\'Qiraj', -8245.84, 1983.74, 129.072, 1, 0.936195, 0, 0),
+   (43, 'The Deadmines', -11212, 1658.58, 25.67, 0, 1.45, 0, 0),
+   (44, 'The Maul', -3761.49, 1133.43, 132.083, 1, 4.57259, 0, 0),
+   (45, 'The Scarlet Monastery', 2843.89, -693.74, 139.32, 0, 5.11, 0, 0),
+   (46, 'The Sunken Temple', -10346.9, -3851.9, -43.41, 0, 6.09, 0, 0),
+   (47, 'The Wailing Caverns', -722.53, -2226.3, 16.94, 1, 2.71, 0, 0),
+   (48, 'Thunder Bluff', -1290, 147.034, 129.682, 1, 4.919, 0, 0),
+   (49, 'Uldaman', -6119.7, -2957.3, 204.11, 0, 0.03, 0, 0),
+   (50, 'Undercity', 1819.71, 238.79, 60.5321, 0, 0, 0, 0),
+   (51, 'Warsong Gulch', 930.851, 1431.57, 345.537, 489, 0.015704, 0, 0),
+   (52, 'Warsong Gulch', 1525.95, 1481.66, 352.001, 489, 3.20756, 0, 0),
+   (53, 'Zul\'Aman', 6846.95, -7954.5, 170.028, 530, 4.61501, 0, 0),
+   (54, 'Zul\'Farrak', -6839.39, -2911.03, 8.87, 1, 0.41, 0, 0),
+   (55, 'Zul\'Gurub', -11916.7, -1212.82, 92.2868, 0, 4.6095, 0, 0),
+   (56, 'Ile des MJ', 16254, 16276.9, 14.5082, 1, 1.70269, 0, 0);
+
+TRUNCATE `custom_npc_tele_association`;
+INSERT INTO `custom_npc_tele_association`
+  (`cat_id`, `dest_id`)
+VALUES
+  (1, 13), (1, 15), (1, 18), (1, 22), (1, 23), (1, 37), (1, 39), (2, 23), (2, 29), (2, 30), (2, 37), (2, 38), (2, 48), (2, 50), (3, 1), (3, 4), (3, 16), (3, 52), (4, 2), (4, 3), (4, 17), (4, 51), (5, 11), (5, 20), (5, 33), (5, 44), (6, 6), (6, 7), (6, 8), (6, 14), (6, 25), (6, 31), (6, 32), (6, 35), (6, 36), (6, 40), (6, 43), (6, 45), (6, 46), (6, 47), (6, 49), (6, 54), (7, 9), (7, 26), (7, 27), (7, 28), (7, 34), (7, 42), (7, 55), (8, 5), (8, 10), (8, 12), (8, 19), (8, 21), (8, 24), (8, 41), (8, 53), (9, 56);
+
+-- `npc_text`
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100000, 'Choose your Category.'),
+   (100001, 'Choose your Destination.');
+
+-- `creature_template`
+INSERT INTO `creature_template` VALUES (100000, 0, 0, 0, 0, 0, 26502, 0, 0, 0, 'Abisal Vortex', '', '', 0, 83, 83, 0, 35, 1, 1, 1.14286, 2, 1, 509, 683, 0, 805, 1, 0, 0, 1, 0, 2048, 0, 0, 0, 0, 0, 0, 371, 535, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 'npc_teleport', 1);
diff --git a/sql/anticheat.sql b/sql/anticheat.sql
new file mode 100644
index 0000000..3504594
--- /dev/null
+++ b/sql/anticheat.sql
@@ -0,0 +1,30 @@
+DROP TABLE IF EXISTS `players_reports_status`;
+
+CREATE TABLE `players_reports_status` (
+  `guid` int(10) unsigned NOT NULL DEFAULT '0',
+  `creation_time` int(10) unsigned NOT NULL DEFAULT '0',
+  `average` float NOT NULL DEFAULT '0',
+  `total_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `speed_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `fly_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `jump_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `waterwalk_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `teleportplane_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `climb_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`guid`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='';
+
+DROP TABLE IF EXISTS `daily_players_reports`;
+CREATE TABLE `daily_players_reports` (
+  `guid` int(10) unsigned NOT NULL DEFAULT '0',
+  `creation_time` int(10) unsigned NOT NULL DEFAULT '0',
+  `average` float NOT NULL DEFAULT '0',
+  `total_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `speed_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `fly_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `jump_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `waterwalk_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `teleportplane_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `climb_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`guid`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='';
\ No newline at end of file
diff --git a/sql/custom/AVFix.sql b/sql/custom/AVFix.sql
new file mode 100644
index 0000000..a0c7eb9
--- /dev/null
+++ b/sql/custom/AVFix.sql
@@ -0,0 +1,3 @@
+UPDATE creature_template SET faction = 1 WHERE entry IN (4255,4257,5134,5135,5139,11948,11949,11997,12050,12096,12127,13086,13096,13138,13216,13257,13296,13298,13299,13317,13318,13319,13320,13326,13327,13331,13422,13437,13438,13439,13442,13443,13447,13546,13576,13577,13598,13617,13797,14187,14188,14284,14762,14763,14765,14766,14768,14769,12047,13396,13358,13080,13078);
+
+UPDATE creature_template SET faction = 2 WHERE entry IN (2225,3343,3625,10364,10367,11946,11947,11998,12051,12052,12053,12097,12121,12122,13088,13089,13097,13137,13140,13143,13144,13145,13146,13147,13152,13153,13154,13176,13179,13180,13181,13218,13236,13284,13316,13359,13377,13397,13425,13428,13441,13448,13536,13539,13545,13597,13616,13618,13798,14185,14186,14282,14285,14772,14773,14774,14775,14776,14777,13332,13099,13079);
diff --git a/sql/tools/setup_ahbot.sql b/sql/tools/setup_ahbot.sql
new file mode 100644
index 0000000..767a01e
--- /dev/null
+++ b/sql/tools/setup_ahbot.sql
@@ -0,0 +1,72 @@
+CREATE TABLE `auctionhousebot` (
+    `auctionhouse` INT(11) NOT NULL DEFAULT '0' COMMENT 'mapID of the auctionhouse.',
+    `name` CHAR(25) NULL DEFAULT NULL COMMENT 'Text name of the auctionhouse.',
+    `minitems` INT(11) NULL DEFAULT '0' COMMENT 'This is the minimum number of items you want to keep in the auction house. a 0 here will make it the same as the maximum.',
+    `maxitems` INT(11) NULL DEFAULT '0' COMMENT 'This is the number of items you want to keep in the auction house.',
+    `percentgreytradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Grey Trade Goods auction items',
+    `percentwhitetradegoods` INT(11) NULL DEFAULT '27' COMMENT 'Sets the percentage of the White Trade Goods auction items',
+    `percentgreentradegoods` INT(11) NULL DEFAULT '12' COMMENT 'Sets the percentage of the Green Trade Goods auction items',
+    `percentbluetradegoods` INT(11) NULL DEFAULT '10' COMMENT 'Sets the percentage of the Blue Trade Goods auction items',
+    `percentpurpletradegoods` INT(11) NULL DEFAULT '1' COMMENT 'Sets the percentage of the Purple Trade Goods auction items',
+    `percentorangetradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Orange Trade Goods auction items',
+    `percentyellowtradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Yellow Trade Goods auction items',
+    `percentgreyitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Grey auction items',
+    `percentwhiteitems` INT(11) NULL DEFAULT '10' COMMENT 'Sets the percentage of the non trade White auction items',
+    `percentgreenitems` INT(11) NULL DEFAULT '30' COMMENT 'Sets the percentage of the non trade Green auction items',
+    `percentblueitems` INT(11) NULL DEFAULT '8' COMMENT 'Sets the percentage of the non trade Blue auction items',
+    `percentpurpleitems` INT(11) NULL DEFAULT '2' COMMENT 'Sets the percentage of the non trade Purple auction items',
+    `percentorangeitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Orange auction items',
+    `percentyellowitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Yellow auction items',
+    `minpricegrey` INT(11) NULL DEFAULT '100' COMMENT 'Minimum price of Grey items (percentage).',
+    `maxpricegrey` INT(11) NULL DEFAULT '150' COMMENT 'Maximum price of Grey items (percentage).',
+    `minpricewhite` INT(11) NULL DEFAULT '150' COMMENT 'Minimum price of White items (percentage).',
+    `maxpricewhite` INT(11) NULL DEFAULT '250' COMMENT 'Maximum price of White items (percentage).',
+    `minpricegreen` INT(11) NULL DEFAULT '800' COMMENT 'Minimum price of Green items (percentage).',
+    `maxpricegreen` INT(11) NULL DEFAULT '1400' COMMENT 'Maximum price of Green items (percentage).',
+    `minpriceblue` INT(11) NULL DEFAULT '1250' COMMENT 'Minimum price of Blue items (percentage).',
+    `maxpriceblue` INT(11) NULL DEFAULT '1750' COMMENT 'Maximum price of Blue items (percentage).',
+    `minpricepurple` INT(11) NULL DEFAULT '2250' COMMENT 'Minimum price of Purple items (percentage).',
+    `maxpricepurple` INT(11) NULL DEFAULT '4550' COMMENT 'Maximum price of Purple items (percentage).',
+    `minpriceorange` INT(11) NULL DEFAULT '3250' COMMENT 'Minimum price of Orange items (percentage).',
+    `maxpriceorange` INT(11) NULL DEFAULT '5550' COMMENT 'Maximum price of Orange items (percentage).',
+    `minpriceyellow` INT(11) NULL DEFAULT '5250' COMMENT 'Minimum price of Yellow items (percentage).',
+    `maxpriceyellow` INT(11) NULL DEFAULT '6550' COMMENT 'Maximum price of Yellow items (percentage).',
+    `minbidpricegrey` INT(11) NULL DEFAULT '70' COMMENT 'Starting bid price of Grey items as a percentage of the randomly chosen buyout price. Default: 70',
+    `maxbidpricegrey` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Grey items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricewhite` INT(11) NULL DEFAULT '70' COMMENT 'Starting bid price of White items as a percentage of the randomly chosen buyout price. Default: 70',
+    `maxbidpricewhite` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of White items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricegreen` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Green items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpricegreen` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Green items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceblue` INT(11) NULL DEFAULT '75' COMMENT 'Starting bid price of Blue items as a percentage of the randomly chosen buyout price. Default: 75',
+    `maxbidpriceblue` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Blue items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricepurple` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Purple items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpricepurple` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Purple items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceorange` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Orange items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpriceorange` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Orange items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceyellow` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Yellow items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpriceyellow` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Yellow items as a percentage of the randomly chosen buyout price. Default: 100',
+    `maxstackgrey` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackwhite` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackgreen` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackblue` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackpurple` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackorange` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackyellow` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `buyerpricegrey` INT(11) NULL DEFAULT '1' COMMENT 'Multiplier to vendorprice when buying grey items from auctionhouse',
+    `buyerpricewhite` INT(11) NULL DEFAULT '3' COMMENT 'Multiplier to vendorprice when buying white items from auctionhouse',
+    `buyerpricegreen` INT(11) NULL DEFAULT '5' COMMENT 'Multiplier to vendorprice when buying green items from auctionhouse',
+    `buyerpriceblue` INT(11) NULL DEFAULT '12' COMMENT 'Multiplier to vendorprice when buying blue items from auctionhouse',
+    `buyerpricepurple` INT(11) NULL DEFAULT '15' COMMENT 'Multiplier to vendorprice when buying purple items from auctionhouse',
+    `buyerpriceorange` INT(11) NULL DEFAULT '20' COMMENT 'Multiplier to vendorprice when buying orange items from auctionhouse',
+    `buyerpriceyellow` INT(11) NULL DEFAULT '22' COMMENT 'Multiplier to vendorprice when buying yellow items from auctionhouse',
+    `buyerbiddinginterval` INT(11) NULL DEFAULT '1' COMMENT 'Interval how frequently AHB bids on each AH. Time in minutes',
+    `buyerbidsperinterval` INT(11) NULL DEFAULT '1' COMMENT 'number of bids to put in per bidding interval',
+    PRIMARY KEY (`auctionhouse`)
+)
+ENGINE=InnoDB
+ROW_FORMAT=DEFAULT;
+
+insert  into `auctionhousebot`(`auctionhouse`,`name`,`minitems`,`maxitems`,`percentgreytradegoods`,`percentwhitetradegoods`,`percentgreentradegoods`,`percentbluetradegoods`,`percentpurpletradegoods`,`percentorangetradegoods`,`percentyellowtradegoods`,`percentgreyitems`,`percentwhiteitems`,`percentgreenitems`,`percentblueitems`,`percentpurpleitems`,`percentorangeitems`,`percentyellowitems`,`minpricegrey`,`maxpricegrey`,`minpricewhite`,`maxpricewhite`,`minpricegreen`,`maxpricegreen`,`minpriceblue`,`maxpriceblue`,`minpricepurple`,`maxpricepurple`,`minpriceorange`,`maxpriceorange`,`minpriceyellow`,`maxpriceyellow`,`minbidpricegrey`,`maxbidpricegrey`,`minbidpricewhite`,`maxbidpricewhite`,`minbidpricegreen`,`maxbidpricegreen`,`minbidpriceblue`,`maxbidpriceblue`,`minbidpricepurple`,`maxbidpricepurple`,`minbidpriceorange`,`maxbidpriceorange`,`minbidpriceyellow`,`maxbidpriceyellow`,`maxstackgrey`,`maxstackwhite`,`maxstackgreen`,`maxstackblue`,`maxstackpurple`,`maxstackorange`,`maxstackyellow`,`buyerpricegrey`,`buyerpricewhite`,`buyerpricegreen`,`buyerpriceblue`,`buyerpricepurple`,`buyerpriceorange`,`buyerpriceyellow`,`buyerbiddinginterval`,`buyerbidsperinterval`) values
+(2,'Alliance',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1),
+(6,'Horde',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1),
+(7,'Neutral',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1);
diff --git a/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp b/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
new file mode 100644
index 0000000..041834a
--- /dev/null
+++ b/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
@@ -0,0 +1,121 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Bot Quest npc Airen by Graff onlysuffering@gmail.com
+Complete - 0%
+TODO:
+*/
+#define ACT                 GOSSIP_ACTION_INFO_DEF
+
+class Airen_chapter1 : public CreatureScript
+{
+public:
+    Airen_chapter1() : CreatureScript("npc_Airen_qI") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new Airen_AI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, "nothing here", 6000, ACT + 1, "nothing here either", 0 * COPPER, true);
+        player->PlayerTalkClass->SendGossipMenu(GOSSIP_MURDER, creature->GetGUID());
+
+        std::ostringstream msg;
+        msg << "..." << player->GetName() << ", huh?";
+        bot_ai::BotSpeak(msg.str(), CHAT_MSG_WHISPER, LANG_UNIVERSAL, creature->GetGUID(), player->GetGUID());
+
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+
+        switch (sender)
+        {
+            case 6000:
+            {
+                if (action == ACT + 1)
+                {
+                    if (!player->HasEnoughMoney(1 * COPPER))
+                    {
+                        player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, 0, 0);
+                        break;
+                    }
+                    player->ModifyMoney(-(1 * COPPER));
+                }
+
+                break;
+            }
+            default:
+                break;
+        }
+
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        std::string answer = "asd";
+
+        switch (sender)
+        {
+            case 6000:
+            {
+                if (action == ACT + 1 && code == answer)
+                    bot_ai::BotSpeak("hehe", CHAT_MSG_YELL, LANG_UNIVERSAL, creature->GetGUID(), player->GetGUID());
+                break;
+            }
+        }
+
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct Airen_AI : public ScriptedAI
+    {
+        Airen_AI(Creature* creature) : ScriptedAI(creature) { }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { me->DisappearAndDie(); }
+
+        void UpdateAI(uint32 /*diff*/)
+        {
+        }
+
+        void Reset()
+        {
+            me->SetCreateHealth(213000213);
+            me->SetMaxHealth(me->GetCreateHealth());
+            me->SetFullHealth();
+
+            me->setPowerType(POWER_RAGE);
+            me->SetMaxPower(POWER_RAGE, 10000);
+            me->SetPower(POWER_RAGE, me->GetMaxPower(POWER_RAGE));
+        }
+
+        void DamageTaken(Unit* /*u*/, uint32& damage)
+        {
+            damage = me->GetHealth() > 1 ? 1 : 0;
+        }
+    };
+};
+
+void AddSC_BotQuests_chapter1()
+{
+    new Airen_chapter1();
+}
diff --git a/src/server/game/AI/NpcBots/bot_Events.h b/src/server/game/AI/NpcBots/bot_Events.h
new file mode 100644
index 0000000..d72af36
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_Events.h
@@ -0,0 +1,133 @@
+#ifndef _BOT_EVENTS_H
+#define _BOT_EVENTS_H
+
+//#include "Player.h"
+//#include "SpellAuras.h"
+//#include "bot_ai.h"
+#include "Creature.h"
+//#include "MapManager.h"
+/*
+Name: bot_Events
+%Complete: 1
+Comment: Custom event types for NPCBot system by Graff (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/events
+
+Notes:
+All events must be executed through botAI
+*/
+//DEPRECATED Visibility update: needed after near teleport
+//class VisibilityUpdateEvent : public BasicEvent
+//{
+//    friend class bot_minion_ai;
+//    protected:
+//        VisibilityUpdateEvent(uint64 botGuid, bool force = true) : _botGuid(botGuid), _force(force) { }
+//        ~VisibilityUpdateEvent() {}
+//
+//        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+//        {
+//            if (Creature* bot = ObjectAccessor::GetObjectInWorld(_botGuid, (Creature*)NULL))
+//            {
+//                bot->GetBotMinionAI()->UpdateBotVisibility(_force);
+//                return true;
+//            }
+//            return false;
+//        }
+//
+//    private:
+//        uint64 _botGuid;
+//        bool _force;
+//};
+//Teleport home: near or far, only used for free bots
+class TeleportHomeEvent : public BasicEvent
+{
+    friend class bot_minion_ai;
+    friend class bot_ai;
+    protected:
+        TeleportHomeEvent(bot_minion_ai* ai/*, uint64 botGuid*/) :
+             _ai(ai)/*, _botGuid(botGuid)*/
+             { }
+        ~TeleportHomeEvent() {}
+
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->TeleportHome();
+            return true;
+        }
+
+    private:
+        bot_minion_ai* _ai;
+        //uint64 _botGuid;
+};
+//DEPRECATEDEvade mode enable/disable: adds UNIT_STATE_EVADE
+//class EvadeEvent : public BasicEvent
+//{
+//    friend class bot_minion_ai;
+//    protected:
+//        EvadeEvent(uint64 botGuid, bool apply) : _botGuid(botGuid), _apply(apply) { }
+//        ~EvadeEvent() {}
+//
+//        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+//        {
+//            if (Creature* bot = ObjectAccessor::GetObjectInWorld(_botGuid, (Creature*)NULL))
+//            {
+//                bot->GetBotMinionAI()->SetEvade(_apply);
+//                return true;
+//            }
+//            return false;
+//        }
+//
+//    private:
+//        uint64 _botGuid;
+//        bool _apply;
+//};
+//Delayed teleport finish: adds bot back to world on new location
+class TeleportFinishEvent : public BasicEvent
+{
+    friend class bot_minion_ai;
+    friend class BotMgr;
+    protected:
+        TeleportFinishEvent(bot_minion_ai* ai/*, uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/) :
+             _ai(ai)//, _mapId(mapId), _instanceId(instanceId), _x(x), _y(y), _z(z), _o(o)
+             { }
+        ~TeleportFinishEvent() {}
+
+        //Execute is always called while creature is out of world so ai is never deleted
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->FinishTeleport(/*_mapId, _instanceId, _x, _y, _z, _o*/);
+            return true;
+        }
+
+    private:
+        bot_minion_ai* _ai;
+        //uint32 _mapId;
+        //uint32 _instanceId;
+        //float _x;
+        //float _y;
+        //float _z;
+        //float _o;
+};
+//DEPRECATED
+//class NearTeleportEvent : public BasicEvent
+//{
+//    friend class bot_ai;
+//    protected:
+//        NearTeleportEvent(uint64 botGuid, Position* pos) : _botGuid(botGuid), _pos(pos) { }
+//        ~NearTeleportEvent() {}
+//
+//        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+//        {
+//            if (Creature* bot = ObjectAccessor::GetObjectInWorld(_botGuid, (Creature*)NULL))
+//            {
+//                bot->Relocate(_pos);
+//                return true;
+//            }
+//            return false;
+//        }
+//
+//    private:
+//        uint64 _botGuid;
+//        Position* _pos;
+//};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_GridNotifiers.h b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
new file mode 100644
index 0000000..a53e73a
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
@@ -0,0 +1,724 @@
+#ifndef _BOT_GRIDNOTIFIERS_H
+#define _BOT_GRIDNOTIFIERS_H
+
+#include "Group.h"
+#include "Player.h"
+#include "SpellAuras.h"
+#include "bot_ai.h"
+/*
+Name: bot_GridNotifiers
+%Complete: 99+
+Comment: Custom grid notifiers for Bot system by Graff (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/grids
+*/
+
+extern bool _botPvP;
+
+class NearestHostileUnitCheck
+{
+    public:
+        explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const* m_ai, bool targetCCed = false) :
+        me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed)
+        { free = ai->IAmFree(); }
+        bool operator()(Unit const* u)
+        {
+            if (u == me)
+                return false;
+            if (!_botPvP && !free && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+                return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!ai->CanBotAttack(u, byspell))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (!AttackCCed && (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE)))
+                return false;//do not allow CCed units if checked
+            //if (u->HasUnitState(UNIT_STATE_CASTING) && (u->GetTypeId() == TYPEID_PLAYER || u->IsPet()))
+            //    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+            //        if (Spell* spell = u->GetCurrentSpell(i))
+            //            if (ai->IsInBotParty(spell->m_targets.GetUnitTarget()))
+            //                return true;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer() && !u->IsInCombat())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack())
+                    return false;
+            }
+
+            m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+            return true;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool byspell;
+        bot_ai const* ai;
+        bool AttackCCed;
+        bool free;
+        NearestHostileUnitCheck(NearestHostileUnitCheck const&);
+};
+
+class HostileDispelTargetCheck
+{
+    public:
+        explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const* m_ai = NULL) :
+        me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u->IsWithinDistInMap(me, m_range) &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack() &&
+                u->IsVisible() &&
+                u->GetReactionTo(me) <= REP_NEUTRAL &&
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (checksteal && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449))) return false;//immune to steal
+                if (!checksteal)
+                {
+                    if (me->getLevel() >= 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(32375))) return false;//immune to mass dispel
+                    if (me->getLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527))) return false;//immune to direct dispel
+                }
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                SpellInfo const* Info;
+                uint32 id;
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    Info = aura->GetSpellInfo();
+                    id = Info->Id;
+                    if (id == 20050 || id == 20052 || id == 20053 || //Vengeance
+                        id == 50447 || id == 50448 || id == 50449) //Bloody Vengeance
+                        continue;
+                    if (Info->Dispel != DISPEL_MAGIC) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (Info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                    AuraApplication const* aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+
+                    if (aurApp && aurApp->IsPositive())
+                        return true;
+                }
+            }
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool checksteal;
+        bot_ai const* ai;
+        HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+};
+
+class AffectedTargetCheck
+{
+    public:
+        explicit AffectedTargetCheck(uint64 casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) :
+        caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType)
+        { gr = NULL; if (checker->GetTypeId() != TYPEID_PLAYER) return; gr = checker->GetGroup(); }
+        bool operator()(Unit const* u) const
+        {
+            if (caster && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+                return false;
+            if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
+            if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
+            if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
+            if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
+
+            if (u->IsAlive() && checker->IsWithinDistInMap(u, m_range))
+            {
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    if (aura->GetId() == spell)
+                        if (caster == 0 || aura->GetCasterGUID() == caster)
+                            return true;
+                }
+            }
+            return false;
+        }
+    private:
+        uint64 const caster;
+        float m_range;
+        uint32 const spell;
+        Player const* checker;
+        uint8 needhostile;
+        Group const* gr;
+        AffectedTargetCheck(AffectedTargetCheck const&);
+};
+
+class PolyUnitCheck
+{
+    public:
+        explicit PolyUnitCheck(Unit const* unit, float dist, Unit const* currTarget) : me(unit), m_range(dist), mytar(currTarget) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (u == mytar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat() || !u->IsAlive() || !u->GetVictim())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID &&
+                u->GetCreatureType() != CREATURE_TYPE_BEAST)
+                return false;
+            if (me->GetDistance(u) < 6 || mytar->GetDistance(u) < 5 ||
+                (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE && u->GetHealthPct() < 70))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE ? !u->getAttackers().empty() : u->getAttackers().size() > 1)
+                return false;
+            if (!u->IsHostileTo(me))
+                return false;
+            if (u->IsPolymorphed() ||
+                u->isFrozen() ||
+                u->isInRoots() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(339)) || //entangling roots
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(16914)) || //hurricane
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(10)) || //blizzard
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(2121)) || //flamestrike
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(20116)) || //consecration
+                u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(118)))//Polymorph
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_SHAMAN && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(51514)))//Hex
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        Unit const* mytar;
+        PolyUnitCheck(PolyUnitCheck const&);
+};
+
+class FearUnitCheck
+{
+    public:
+        explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_BEAST &&
+                me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (u->getAttackers().size() > 1 && u->GetVictim() != me)
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->isFeared())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARLOCK &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782)))//fear rank1
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1513)))//scare beast rank1
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        FearUnitCheck(FearUnitCheck const&);
+};
+
+class StunUnitCheck
+{
+    public:
+        explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetVictim() == u)
+                return false;
+            if (me->GetTypeId() == TYPEID_UNIT)
+                if (Player* mymaster = me->ToCreature()->GetBotOwner())
+                    if (mymaster->GetVictim() == u)
+                        return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER && u->isFeared())
+                return false;
+            if (me->GetDistance(u) < 10)//do not allow close cast to prevent break due to AOE damage
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                u->HasAuraWithMechanic((1<<MECHANIC_SHACKLE)|(1<<MECHANIC_SLEEP)|(1<<MECHANIC_DISORIENTED)))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066)))//repentance
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(60210)))//freezing arrow effect
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19386)))//wyvern sting rank 1
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1991)))//scatter shot
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        StunUnitCheck(StunUnitCheck const&);
+};
+
+class UndeadCCUnitCheck
+{
+    public:
+        explicit UndeadCCUnitCheck(Unit const* unit, float dist = 30, uint32 spell = 0) : me(unit), m_range(dist), m_spellId(spell) { if (!spell) return; }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->GetVictim() == u && u->GetVictim() == me)
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            //most horrible hacks
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON &&
+                (m_spellId == 2812 || m_spellId == 10318 || //holy
+                m_spellId == 27139 || m_spellId == 48816 || //wra
+                m_spellId == 48817 ||                       //th or
+                m_spellId == 10326))                        //turn evil
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) &&
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        uint32 m_spellId;
+        UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+};
+
+class RootUnitCheck
+{
+    public:
+        explicit RootUnitCheck(Unit const* unit, Unit const* mytarget, float dist = 30, uint32 spell = 0) : me(unit), curtar(mytarget), m_range(dist), m_spellId(spell)
+        { if (!spell) return; }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (u == curtar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetDistance(u) < 8)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->isFrozen() || u->isInRoots())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackle undead*/)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        Unit const* curtar;
+        float m_range;
+        uint32 m_spellId;
+        RootUnitCheck(RootUnitCheck const&);
+};
+
+class CastingUnitCheck
+{
+    public:
+        explicit CastingUnitCheck(Unit const* unit, float mindist = 0.f, float maxdist = 30, bool friendly = false, uint32 spell = 0) :
+        me(unit), min_range(mindist), max_range(maxdist), m_friend(friendly), m_spell(spell) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!m_friend && !_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!m_friend && !u->isTargetableForAttack())
+                return false;
+            //if (!m_friend && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))//prevent double silence
+            //    return false;
+            if (!u->IsNonMeleeSpellCast(false))
+                return false;
+            if (m_friend == (u->GetReactionTo(me) < REP_FRIENDLY))
+                return false;
+            if (m_spell == 10326 && //turn evil
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                return false;
+            if (m_spell == 20066 && //repentance
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (!m_spell || !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spell)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bool m_friend;
+        uint32 m_spell;
+        CastingUnitCheck(CastingUnitCheck const&);
+};
+
+class SecondEnemyCheck
+{
+    public:
+        explicit SecondEnemyCheck(Unit const* unit, float dist, float splashdist, Unit const* currtarget, bot_ai const* m_ai) :
+        me(unit), m_range(dist), m_splashrange(splashdist), mytar(currtarget), ai(m_ai) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u == mytar)
+                return false;//We need to find SECONDARY target
+            if (!u->IsInCombat())
+                return false;
+            if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range + 1.f))//distance check
+                return false;
+            if (mytar->GetDistance(u) > m_splashrange)//not close enough to each other
+                return false;
+
+            if (ai->CanBotAttack(u))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range, m_splashrange;
+        Unit const* mytar;
+        bot_ai const* ai;
+        SecondEnemyCheck(SecondEnemyCheck const&);
+};
+
+class TranquilTargetCheck
+{
+    public:
+        explicit TranquilTargetCheck(Unit const* unit, float mindist, float maxdist, bot_ai const* m_ai) :
+        me(unit), min_range(mindist), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u != me->GetVictim() &&//check hunter_bot::hunter_botAI::CheckTranquil(uint32)
+                u->IsWithinDistInMap(me, max_range) &&
+                u->GetDistance(me) > min_range &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack() &&
+                u->IsVisible() &&
+                u->GetReactionTo(me) <= REP_NEUTRAL &&
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19801))) return false;//immune to tranquilizing shot
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    SpellInfo const* Info = itr->second->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC && Info->Dispel != DISPEL_ENRAGE) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (Info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bot_ai const* ai;
+        TranquilTargetCheck(TranquilTargetCheck const&);
+};
+
+class NearbyHostileUnitCheck
+{
+    public:
+        explicit NearbyHostileUnitCheck(Unit const* unit, float maxdist, float mindist, bot_ai const* m_ai, bool forCC) :
+        me(unit), max_range(maxdist), min_range(mindist), ai(m_ai), m_forCC(forCC)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+                return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!free && !ai->CanBotAttack(u))
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (m_forCC && u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack())
+                    return false;
+            }
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range, min_range;
+        bot_ai const* ai;
+        bool m_forCC;
+        bool free;
+        NearbyHostileUnitCheck(NearbyHostileUnitCheck const&);
+};
+
+class NearbyFriendlyUnitCheck
+{
+    public:
+        explicit NearbyFriendlyUnitCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) : me(unit), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            //if (!u->IsInCombat())
+            //    return false;
+            if (u->IsTotem() || u->IsSummon())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!me->CanSeeOrDetect(u))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (!ai->IsInBotParty(u))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        NearbyFriendlyUnitCheck(NearbyFriendlyUnitCheck const&);
+};
+
+class NearbyRezTargetCheck
+{
+    public:
+        explicit NearbyRezTargetCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) : me(unit), max_range(maxdist), ai(m_ai) { }
+        bool operator()(WorldObject const* u) const
+        {
+            if (u == me)
+                return false;
+            if (u->GetTypeId() != TYPEID_PLAYER && u->GetTypeId() != TYPEID_CORPSE)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (Player const* p = u->ToPlayer())
+            {
+                if (p->IsAlive())
+                    return false;
+                if (p->isResurrectRequested())
+                    return false;
+                if (!ai->IsInBotParty(p))
+                    return false;
+            }
+            if (!me->CanSeeOrDetect(u))
+                return false;
+            if (urand(0,100) > 20)
+                return false;
+            if (u->GetTypeId() == TYPEID_CORPSE && !sObjectAccessor->FindPlayer(u->ToCorpse()->GetOwnerGUID()))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        NearbyRezTargetCheck(NearbyRezTargetCheck const&);
+};
+
+template<class Check>
+struct UnitListSearcher
+{
+    uint32 i_phaseMask;
+    std::list<uint64> &i_objects;
+    Check& i_check;
+
+    UnitListSearcher(WorldObject const* searcher, std::list<uint64> &objects, Check &check)
+        : i_phaseMask(searcher->GetPhaseMask()), i_objects(objects), i_check(check) { }
+
+    void Visit(PlayerMapType &m)
+    {
+        for (PlayerMapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+            if (itr->GetSource()->InSamePhase(i_phaseMask))
+                if (i_check(itr->GetSource()))
+                    i_objects.push_back(itr->GetSource()->GetGUID());
+    }
+    void Visit(CreatureMapType &m)
+    {
+        for (CreatureMapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+            if (itr->GetSource()->InSamePhase(i_phaseMask))
+                if (i_check(itr->GetSource()))
+                    i_objects.push_back(itr->GetSource()->GetGUID());
+    }
+
+    template<class NOT_INTERESTED> void Visit(GridRefManager<NOT_INTERESTED> &) { }
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
new file mode 100644
index 0000000..403b2ca
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.cpp
@@ -0,0 +1,8124 @@
+#include "bot_ai.h"
+#include "bot_Events.h"
+#include "bot_GridNotifiers.h"
+#include "botmgr.h"
+#include "CellImpl.h"
+#include "Chat.h"
+#include "GameEventMgr.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "MapManager.h"
+#include "ScriptedGossip.h"
+#include "SpellAuraEffects.h"
+/*
+NpcBot System by Graff (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+TODO:
+Implement Racial Abilities
+Quests
+I NEED MORE
+*/
+const uint8 GroupIconsFlags[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+static std::set<uint32> BotCustomSpells;
+static bool SPELLS_DEFINED = false;
+
+extern bool _enableNpcBots;
+extern bool _botPvP;
+extern uint8 _maxClassNpcBots;
+extern uint8 _healTargetIconFlags;
+extern float _mult_dmg_melee;
+extern float _mult_dmg_spell;
+extern float _mult_healing;
+
+bot_minion_ai::bot_minion_ai(Creature* creature) : bot_ai(creature)
+{
+    Potion_cd = 0;
+    pvpTrinket_cd = 30000;
+    rezz_cd = 0;
+    myangle = 0.f;
+    mana_cd = 0;
+    health_cd = 0;
+    feast_health = false;
+    feast_mana = false;
+    _classinfo = new PlayerClassLevelInfo();
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        for (uint8 j = 0; j != MAX_BOT_ITEM_MOD; ++j)
+            _stats[i][j] = 0;
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        _equips[i] = NULL;
+
+    _reviveTimer = 0;
+    _saveTimer = 0;
+    _powersTimer = 0;
+    _chaseTimer = 0;
+
+    _jumpCount = 0;
+    _evadeCount = 0;
+
+    _lastTargetGuid = 0;
+}
+bot_minion_ai::~bot_minion_ai()
+{
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        if (_equips[i])
+            delete _equips[i];
+    delete _classinfo;
+}
+
+bot_pet_ai::bot_pet_ai(Creature* creature) : bot_ai(creature)
+{
+    m_creatureOwner = me->GetCreatureOwner();
+    basearmor = 0;
+}
+bot_pet_ai::~bot_pet_ai() { }
+
+bot_ai::bot_ai(Creature* creature) : ScriptedAI(creature)
+{
+    bot_ai::InitBotCustomSpells();
+
+    ResetBotAI(BOTAI_RESET_INIT);
+    m_botCommandState = COMMAND_FOLLOW;
+    checkMasterTimer = urand(5000, 15000);
+    needparty = false;
+    spawned = false;
+    firstspawn = true;
+    _evadeMode = false;
+    _atHome = true;
+    _temp = me->GetDBTableGUIDLow() ? false : true;
+    _roleMask = 0;
+    haste = 0;
+    blockvalue = 1;
+    hit = 0.f;
+    parry = 0.f;
+    dodge = 0.f;
+    block = 0.f;
+    crit = 0.f;
+    dmg_taken = 1.f;
+    expertise = 0;
+    spellpower = 0;
+    spellpen = 0;
+    regen_mp = 0;
+    regenTimer_hp = 0;
+    regenTimer_mp = 0;
+    m_botSpellInfo = NULL;
+    clear_cd = 2;
+    temptimer = 0;
+    wait = 15;
+    GC_Timer = 0;
+    lastdiff = 0;
+    _bootTimer = -1;
+    _updateTimerMedium = 0;
+    checkAurasTimer = 20;
+    roleTimer = 0;
+    cost = 0;
+    doHealth = false;
+    doMana = false;
+    //shouldUpdateStats = true;
+    pos.m_positionX = 0.f;
+    pos.m_positionY = 0.f;
+    pos.m_positionZ = 0.f;
+    aftercastTargetGuid = 0;
+    currentSpell = 0;
+
+    //visUpEvent = NULL;
+    teleHomeEvent = NULL;
+    //evadeEvent = NULL;
+    teleFinishEvent = NULL;
+}
+bot_ai::~bot_ai() { }
+
+uint16 bot_ai::Rand() const
+{
+    return IAmFree() ? urand(0, 100) : urand(0, 100 + (master->GetNpcBotsCount() - 1) * 10);
+}
+
+void bot_ai::BotSay(char const* text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->MonsterSay(text, LANG_UNIVERSAL, target);
+}
+void bot_ai::BotWhisper(char const* text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->MonsterWhisper(text, target);
+}
+void bot_ai::BotYell(char const* text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->MonsterYell(text, LANG_UNIVERSAL, target);
+}
+
+bool bot_ai::SetBotOwner(Player* newowner)
+{
+    ASSERT(newowner && "Trying to set NULL owner!!!");
+    ASSERT(IS_PLAYER_GUID(newowner->GetGUID()) && "Trying to set a non-player as owner!!!");
+    //ASSERT(master->GetGUID() == me->GetGUID());
+    //ASSERT(!IsMinionAI() || IAmFree());
+
+    //have master already
+    if (master->GetGUID() != me->GetGUID())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): bot %s (id: %u) has master %s while trying to set to %s...",
+            me->GetName().c_str(), me->GetEntry(), master->GetName().c_str(), newowner->GetName().c_str());
+        return false;
+    }
+    if (IsMinionAI() && !IAmFree())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): minion bot %s (id: %u) IS NOT FREE (has master %s) while trying to set to %s",
+            me->GetName().c_str(), me->GetEntry(), master->GetName().c_str(), newowner->GetName().c_str());
+        return false;
+    }
+
+    if (IsMinionAI())
+    {
+        BotMgr* mgr = newowner->GetBotMgr();
+        if (!mgr)
+            mgr = new BotMgr(newowner);
+
+        bool takeMoney = (_ownerGuid != newowner->GetGUIDLow());
+        if (mgr->AddBot(me, takeMoney) & BOT_ADD_FATAL)
+        {
+            //TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): player %s (%u) can't add bot %s (FATAL), removing...",
+            //    master->GetName().c_str(), master->GetGUIDLow(), me->GetName().c_str());
+            //failed to add bot
+            //if (_ownerGuid)
+            //{
+            //    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+            //    //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+            //    stmt->setUInt32(0, uint32(0));
+            //    stmt->setUInt32(1, me->GetEntry());
+            //    CharacterDatabase.Execute(stmt);
+            //}
+
+            if (_ownerGuid)
+            {
+                TC_LOG_ERROR("entities.player", "bot_ai::FindMaster(): %s's master %s (guid: %u) is found but bot failed to set owner (fatal)! Unbinding bot temporarily (until server restart)...",
+                    me->GetName().c_str(), newowner->GetName().c_str(), newowner->GetGUIDLow());
+                _ownerGuid = 0;
+            }
+
+            checkMasterTimer = 30000;
+            ResetBotAI(BOTAI_RESET_LOST);
+            return false;
+        }
+
+        (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 &= ~(UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+        me->SetUInt32Value(UNIT_FIELD_FLAGS_2, me->GetCreatureTemplate()->unit_flags2);
+    }
+
+    //recursive
+    if (master->GetGUID() == newowner->GetGUID())
+        return true;
+
+    master = newowner;
+    _ownerGuid = newowner->GetGUIDLow();
+    spawned = false;
+
+    ASSERT(me->IsInWorld());
+    AbortTeleport();
+    return true;
+}
+
+void bot_ai::ResetBotAI(uint8 resetType)
+{
+    //ASSERT(me->IsInWorld());
+
+    master = reinterpret_cast<Player*>(me);
+    if (resetType & BOTAI_RESET_ABANDON_MASTER)
+        _ownerGuid = 0;
+
+    (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 |= (UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+    me->SetUInt32Value(UNIT_FIELD_FLAGS_2, me->GetCreatureTemplate()->unit_flags2);
+
+    me->IsAIEnabled = true;
+    me->SetCanUpdate(true);
+
+    if (spawned)
+        ReturnHome();
+
+    if (!me->IsInWorld())
+    {
+        ASSERT(IsMinionAI());
+        AbortTeleport();
+
+        //if no master - will teleport to spawn position
+        //otherwise - will teleport to master
+        teleHomeEvent = new TeleportHomeEvent(ToMinionAI());
+        events.AddEvent(teleHomeEvent, events.CalculateTime(0)); //make sure event will be deleted
+        teleHomeEvent->to_Abort = true; //make sure event will not be executed twice
+        teleHomeEvent->Execute(0,0);
+    }
+    else
+    {
+        _atHome = false;
+        spawned = false;
+    }
+}
+
+SpellCastResult bot_ai::CheckBotCast(Unit* victim, uint32 spellId, uint8 botclass) const
+{
+    if (spellId == 0)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (victim->GetTypeId() == TYPEID_PLAYER && victim->ToPlayer()->IsGameMaster())
+        return SPELL_FAILED_BAD_TARGETS;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (me->IsMounted() && !(spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_MOUNTED))
+        return SPELL_FAILED_NOT_MOUNTED;
+
+    //if (Powers(spellInfo->PowerType) == me->getPowerType() &&
+    //    (int32)me->GetPower(me->getPowerType()) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+    //    return SPELL_FAILED_NO_POWER;
+
+    if ((int32)me->GetPower(Powers(spellInfo->PowerType)) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+        return SPELL_FAILED_NO_POWER;
+
+    if (victim->isType(TYPEMASK_UNIT) && InDuel(victim))
+        return SPELL_FAILED_BAD_TARGETS;
+
+    if (victim->isType(TYPEMASK_UNIT) && !spellInfo->IsPassive())
+    {
+        bool needRankSelection = false;
+        for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spellInfo->IsPositiveEffect(i) &&
+                (spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AURA ||
+                spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_PARTY ||
+                spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_RAID))
+            {
+                needRankSelection = true;
+                break;
+            }
+        }
+        if (needRankSelection && victim->getLevel() < spellInfo->GetFirstRankSpell()->BaseLevel)
+            return SPELL_FAILED_LOWLEVEL;
+    }
+
+    //disarmed
+    if (spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON)
+    {
+        if (spellInfo->EquippedItemInventoryTypeMask != 0)
+        {
+            if ((spellInfo->EquippedItemInventoryTypeMask & (1 << INVTYPE_WEAPONMAINHAND)) &&
+                !me->CanUseAttackType(BASE_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND;
+            if ((spellInfo->EquippedItemInventoryTypeMask & (1 << INVTYPE_WEAPONOFFHAND)) &&
+                !me->CanUseAttackType(OFF_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS_OFFHAND;
+            if ((spellInfo->EquippedItemInventoryTypeMask & ((1 << INVTYPE_RANGED) | (1 << INVTYPE_RANGEDRIGHT))) &&
+                !me->CanUseAttackType(RANGED_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+        }
+        else if (!me->CanUseAttackType(BASE_ATTACK))
+            return SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND;
+    }
+
+    if (victim->isType(TYPEMASK_UNIT) && !CheckImmunities(spellId, victim))
+        return SPELL_FAILED_BAD_TARGETS;
+
+    switch (botclass)
+    {
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_DRUID:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+            if (Feasting() && !master->IsInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_WARRIOR:
+            //BladeStorm
+            if (me->HasAura(46924/*67541*/))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_BM:
+            //BladeStorm PLACEHOLDER
+            if (me->HasAura(46924/*67541*/))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_DEATH_KNIGHT:
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "CheckBotCast(): Unknown bot class %u", botclass);
+            break;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, bool triggered, uint64 originalCaster)
+{
+    if (spellId == 0) return false;
+    if (IsCasting()) return false;
+    if (!victim || !victim->IsInWorld() || me->GetMap() != victim->FindMap()) return false;
+
+    m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!m_botSpellInfo)
+        return false;
+
+    //select aura level
+    if (victim->isType(TYPEMASK_UNIT))
+        if (SpellInfo const* actualSpellInfo = m_botSpellInfo->GetAuraRankForLevel(victim->getLevel()))
+            m_botSpellInfo = actualSpellInfo;
+
+    if (m_botSpellInfo->CalcCastTime() && JumpingFlyingOrFalling())
+        return false;
+
+    if (spellId == MANAPOTION)
+    {
+        value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+        me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+        return true;
+    }
+    else if (spellId == HEALINGPOTION)
+    {
+        value = urand(me->GetMaxHealth()/3, me->GetMaxHealth()/2);
+        me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+        return true;
+    }
+
+    //check cooldown
+    if (!IsSpellReady(m_botSpellInfo->GetFirstRankSpell()->Id, lastdiff, false))
+        return false;
+
+    //remove shapeshifts manually to restore powers/stats
+    if (me->GetShapeshiftForm() != FORM_NONE)
+    {
+        if (m_botSpellInfo->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
+            removeFeralForm(true);
+    }
+
+    if (!(m_botSpellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_SITTING))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (!IAmFree() && victim->isType(TYPEMASK_UNIT) && !victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+    {
+        //std::ostringstream msg;
+        //msg << "casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
+        //BotWhisper(msg.str().c_str(), master);
+        me->Relocate(victim);
+    }
+
+    if (me->isMoving() && m_botSpellInfo->CalcCastTime() > 0)
+        me->BotStopMovement();
+
+    TriggerCastFlags flags = triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE;
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+    Spell* spell = new Spell(me, m_botSpellInfo, flags, originalCaster);
+    spell->prepare(&targets); //sets current spell if succeed
+
+    bool casted = triggered; //triggered casts are casted immediately
+    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+    {
+        if (me->GetCurrentSpell(i) == spell)
+        {
+            casted = true;
+            break;
+        }
+    }
+
+    if (!casted)
+    {
+        //failed to cast
+        //delete spell; //crash due to invalid event added to master's eventmap
+        return false;
+    }
+
+    currentSpell = spellId;
+
+    float gcd;
+
+    if (_botclass == BOT_CLASS_ROGUE || GetBotStance() == DRUID_CAT_FORM || GetBotStance() == DEATH_KNIGHT_UNHOLY_PRESENCE)
+        gcd = 1000.f;
+    else
+        gcd = 1500.f;
+
+    ApplyBotSpellGlobalCooldownMods(m_botSpellInfo, gcd);
+
+    //Apply haste to cooldown
+    if (haste)
+        ApplyPercentModFloatVar(gcd, float(haste), false);
+    //global cd cannot be less than 500 ms
+    GC_Timer = std::max<int32>(gcd, 500);
+    //global cd cannot be greater than 1500 ms
+    GC_Timer = std::min<int32>(gcd, 1500);
+
+    return true;
+}
+//Follow point calculation
+void bot_minion_ai::_calculatePos(Position& pos)
+{
+    ASSERT(!IAmFree());
+
+    uint8 followdist = master->GetBotFollowDist();
+    float mydist, angle;
+
+    if (IsTank())
+    {
+        mydist = frand(1.5f, 4.5f); //stand a bit farther
+        angle = (M_PI/2.f) / 16.f * frand(-3.f, 3.f); //in front +-pi/5
+    }
+    else if (IsMelee())
+    {
+        mydist = frand(0.5f, 2.f);
+        angle = (M_PI/2.f) / 8.f * RAND(frand(5.f, 10.f), frand(-10.f, -5.f)); //to the sides +-(pi/3 to pi/1.6)
+    }
+    else
+    {
+        mydist = frand(0.15f, 0.8f);
+        angle = (M_PI/2.f) / 6.f * frand(10.5f, 13.5f); //behind pi+-pi/4.5
+    }
+    //myangle = angle used last time
+    //if difference between last angle and cur angle is too big, use new angle
+    //else use last angle (prevent constant struggling)
+    if (abs(abs(myangle) - abs(angle)) > M_PI/3.f)
+        myangle = angle;
+    else
+        angle = myangle;
+    mydist += std::max<float>(int8(followdist) - 30, 0) / 5.f; //0.f-9.f
+    //mydist += followdist > 10 ? float(followdist - 10)/4.f : 0.f; //distance from 10+ is reduced
+    //mydist = std::min<float>(mydist, 35.f); //do not spread bots too much
+    mydist = std::max<float>(mydist - 5.f, 0.0f); //get bots closer
+    angle += master->GetOrientation();
+    float x(0),y(0),z(0);
+    float size = me->GetObjectSize()/3.f;
+    bool over = false;
+    for (uint8 i = 0; i != 5 + over; ++i)
+    {
+        if (over)
+        {
+            mydist *= 0.2f;
+            break;
+        }
+        master->GetNearPoint(me, x, y, z, size, mydist, angle);
+        if (!master->IsWithinLOS(x,y,z)) //try to get much closer to master
+        {
+            mydist *= 0.4f - float(i*0.07f);
+            size *= 0.1f;
+            if (size < 0.1)
+                size = 0.f;
+            if (size == 0.f && me->GetPositionZ() < master->GetPositionZ())
+                z += 0.25f; //prevent going underground
+        }
+        else
+            over = true;
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+
+    //           TTT
+    //     m      T      m
+    //    mmmmmm MMM mmmmmm
+    //     m   ddddddd   m
+    //      ddddddddddddd
+    //        ddddddddd
+    //
+    //MMM - master
+    //T - bot tank (ROLE_TANK)
+    //m - melee (ROLE_MELEE)
+    //d - default
+}
+// Movement set
+void bot_minion_ai::SetBotCommandState(CommandStates st, bool force, Position* newpos)
+{
+    if (!me->IsAlive())
+        return;
+
+    if (JumpingFlyingOrFalling())
+        return;
+
+    if (st == COMMAND_FOLLOW && !IsChanneling() && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (!me->IsInMap(master)) return;
+        if (CCed(me, true)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
+        if (me->isMoving() && Rand() > 20) return;
+        if (!newpos)
+            _calculatePos(pos);
+        else
+        {
+            pos.m_positionX = newpos->m_positionX;
+            pos.m_positionY = newpos->m_positionY;
+            pos.m_positionZ = newpos->m_positionZ;
+        }
+        if (me->getStandState() == UNIT_STAND_STATE_SIT && !Feasting())
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+        me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
+        //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
+    }
+    else if (st == COMMAND_STAY)
+    {
+        me->BotStopMovement();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+    if (Creature* m_botsPet = me->GetBotsPet())
+        m_botsPet->SetBotCommandState(st, force);
+}
+
+void bot_pet_ai::SetBotCommandState(CommandStates st, bool force, Position* /*newpos*/)
+{
+    if (me->isDead() || IAmDead())
+        return;
+
+    if (JumpingFlyingOrFalling())
+        return;
+
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (!me->IsInMap(master)) return;
+        if (CCed(me, true)) return;
+        if (me->isMoving() && Rand() > 20) return;
+        Unit* followtarget = m_creatureOwner;
+        if (CCed(m_creatureOwner))
+            followtarget = master;
+        if (followtarget == m_creatureOwner)
+        {
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(master)*0.75f < me->GetDistance(m_creatureOwner))
+                me->GetMotionMaster()->MoveFollow(m_creatureOwner, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+        }
+        else
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(m_creatureOwner)*0.75f < me->GetDistance(master))
+                me->GetMotionMaster()->MoveFollow(master, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+    }
+    else if (st == COMMAND_STAY)//NUY
+    {
+        me->BotStopMovement();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+}
+// Buffs And Heal (really)
+void bot_minion_ai::BuffAndHealGroup(Player* gPlayer, uint32 diff)
+{
+    if (GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    if (IAmFree())
+    {
+        if (HealTarget(me, GetHealthPCT(me), diff))
+            return;
+        if (BuffTarget(me, diff))
+            return;
+        if (Creature* pet = me->GetBotsPet())
+        {
+            if (HealTarget(pet, GetHealthPCT(pet), diff))
+                return;
+            if (BuffTarget(pet, diff))
+                return;
+        }
+
+        if (me->HasAura(BERSERK))
+            return;
+
+        std::list<uint64> targets;
+        GetNearbyFriendlyTargetsList(targets, 30);
+        for (std::list<uint64>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+        {
+            if (Unit* u = sObjectAccessor->GetUnit(*me, *itr))
+            {
+                if (HealTarget(u, GetHealthPCT(u), diff))
+                    return;
+                if (BuffTarget(u, diff))
+                    return;
+            }
+        }
+
+        return;
+    }
+
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        if (!master->IsInWorld() || master->IsBeingTeleported())
+            return;
+        if (HasRole(BOT_ROLE_HEAL) && HealTarget(master, GetHealthPCT(master), diff))
+            return;
+        if (BuffTarget(master, diff))
+            return;
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+            if (HasRole(BOT_ROLE_HEAL) && HealTarget(u, GetHealthPCT(u), diff))
+                return;
+            if (Creature* cre = u->ToCreature())
+                if (cre->GetIAmABot() || cre->IsPet())
+                    if (BuffTarget(u, diff))
+                        return;
+        }
+        return;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        if (!tPlayer->m_Controlled.empty())
+            Bots = true;
+        if (!tPlayer->IsAlive()) continue;
+        if (HasRole(BOT_ROLE_HEAL) && HealTarget(tPlayer, GetHealthPCT(tPlayer), diff))
+            return;
+        if (BuffTarget(tPlayer, diff))
+            return;
+    }
+    if (Bots)
+    {
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || tPlayer->m_Controlled.empty()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+                if (HasRole(BOT_ROLE_HEAL) && HealTarget(u, GetHealthPCT(u), diff))
+                    return;
+                if (Creature* cre = u->ToCreature())
+                    if (cre->GetIAmABot() || cre->IsPet())
+                        if (BuffTarget(u, diff))
+                            return;
+            }
+        }
+    }
+    //check if we have pointed heal target
+    if (HasRole(BOT_ROLE_HEAL))
+    {
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (_healTargetIconFlags & GroupIconsFlags[i])
+            {
+                if (uint64 guid = pGroup->GetTargetIcons()[i])//check this one
+                {
+                    if (Unit* unit = sObjectAccessor->FindUnit(guid))
+                    {
+                        if (unit->IsAlive() && me->GetMap() == unit->FindMap() &&
+                            master->GetVictim() != unit && unit->GetVictim() != master &&
+                            unit->GetReactionTo(master) >= REP_NEUTRAL)
+                        {
+                            if (HealTarget(unit, GetHealthPCT(unit), diff))
+                                return;
+                            //if (CureTarget(unit, getCureSpell(), diff))
+                            //    return;
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+// Attempt to resurrect dead players using class spells
+// Target is either player or its corpse
+void bot_minion_ai::RezGroup(uint32 REZZ, Player* gPlayer)
+{
+    if (!REZZ || !gPlayer || me->IsMounted()) return;
+    if (rezz_cd > 0 || Rand() > 10) return;
+
+    if (IAmFree())
+    {
+        if (me->HasAura(BERSERK))
+            return;
+
+        WorldObject* playerOrCorpse = GetNearbyRezTarget(30);
+        if (!playerOrCorpse)
+            return;
+
+        if (!playerOrCorpse->IsWithinLOSInMap(me))
+            me->Relocate(*playerOrCorpse);
+
+        Unit* target = playerOrCorpse->GetTypeId() == TYPEID_PLAYER ? playerOrCorpse->ToUnit() : (Unit*)playerOrCorpse->ToCorpse();
+        if (doCast(target, REZZ)) //rezzing it
+        {
+            if (Player* player = playerOrCorpse->GetTypeId() == TYPEID_PLAYER ? playerOrCorpse->ToPlayer() : sObjectAccessor->FindPlayer(playerOrCorpse->ToCorpse()->GetOwnerGUID()))
+                BotWhisper("Rezzing You", player);
+            rezz_cd = 20;
+        }
+
+        return;
+    }
+
+    //TC_LOG_ERROR("entities.player", "RezGroup by %s", me->GetName().c_str());
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        Unit* target = master;
+        if (master->IsAlive()) return;
+        if (master->isResurrectRequested()) return; //resurrected
+        if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)master->GetCorpse();
+        if (!target || !target->IsInWorld()) return;
+        if (me->GetMap() != target->FindMap()) return;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            BotWhisper("Rezzing You", master);
+            rezz_cd = 60;
+        }
+        return;
+    }
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        Unit* target = tPlayer;
+        if (!tPlayer || tPlayer->IsAlive()) continue;
+        if (tPlayer->isResurrectRequested()) continue; //resurrected
+        if (Rand() > 5) continue;
+        if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)tPlayer->GetCorpse();
+        if (!target || !target->IsInWorld()) continue;
+        if (master->GetMap() != target->FindMap()) continue;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            BotWhisper("Rezzing You", tPlayer);
+            if (tPlayer != master)
+            {
+                std::string rezstr = "Rezzing ";
+                rezstr += tPlayer->GetName();
+                BotWhisper(rezstr.c_str(), master);
+            }
+            rezz_cd = 60;
+            return;
+        }
+    }
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_minion_ai::CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell || GC_Timer > diff) return;
+    if (me->getLevel() < 10 || pTarget->getLevel() < 10) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    if (IAmFree())
+    {
+        if (CureTarget(me, cureSpell, diff))
+            return;
+        if (Creature* pet = me->GetBotsPet())
+            if (CureTarget(pet, cureSpell, diff))
+                return;
+
+        if (me->HasAura(BERSERK))
+            return;
+
+        std::list<uint64> targets;
+        GetNearbyFriendlyTargetsList(targets, 38);
+        for (std::list<uint64>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+            if (Unit* u = sObjectAccessor->GetUnit(*me, *itr))
+                if (CureTarget(u, cureSpell, diff))
+                    return;
+
+        return;
+    }
+
+    if (!master->GetMap()->IsRaid() && Rand() > 75) return;
+    //TC_LOG_ERROR("entities.player", "%s: CureGroup() on %s", me->GetName().c_str(), pTarget->GetName().c_str());
+    Group* pGroup = pTarget->GetGroup();
+    if (!pGroup)
+    {
+        if (CureTarget(master, cureSpell, diff))
+            return;
+        BotMap const* map = master->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Creature* cre = itr->second;
+            if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+            if (CureTarget(cre, cureSpell, diff))
+                return;
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (me->GetDistance(tPlayer) > 30) continue;
+            if (CureTarget(tPlayer, cureSpell, diff))
+                return;
+        }
+        if (!Bots) return;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+            {
+                Creature* cre = it->second;
+                if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+                if (CureTarget(cre, cureSpell, diff))
+                    return;
+            }
+        }
+    }
+}
+
+bool bot_minion_ai::CureTarget(Unit* target, uint32 cureSpell, uint32 diff)
+{
+    return _canCureTarget(target, cureSpell, diff) ? doCast(target, cureSpell) : false;
+}
+// determines if unit has something to cure
+bool bot_minion_ai::_canCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const
+{
+    if (!cureSpell || GC_Timer > diff) return false;
+    if (!target || !target->IsAlive()) return false;
+    if (me->getLevel() < 10 || target->getLevel() < 10) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting() || Feasting()) return false;
+    if (me->GetDistance(target) > 30) return false;
+    if (!IsInBotParty(target)) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
+
+    if (dispelMask == 0)
+        return false;
+
+    DispelChargesList dispel_list;
+    _getBotDispellableAuraList(target, me, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_minion_ai::_getBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const
+{
+    if (dispelMask & (1 << DISPEL_DISEASE) && target->HasAura(50536))
+        dispelMask &= ~(1 << DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            //do not dispel positive auras from enemies and negative ones from friends
+            if (aurApp->IsPositive() == target->IsFriendlyTo(caster))
+                continue;
+
+            //skip Vampiric Touch to prevent being CCed just heal it out
+            if (aura->GetSpellInfo()->IsRankOf(sSpellMgr->GetSpellInfo(34914)))
+                continue;
+
+            uint8 charges = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                dispelList.push_back(std::make_pair(aura, charges));
+        }
+    }
+}
+//protected
+bool bot_ai::HasAuraName(Unit* unit, uint32 spellId, uint64 casterGuid, bool exclude) const
+{
+    ASSERT(spellId);
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::HasAuraName(uint32): no spellInfo found for spell %u!", spellId);
+        ASSERT(false);
+    }
+
+    uint8 loc = IAmFree() ? sWorld->GetDefaultDbcLocale() : master->GetSession()->GetSessionDbcLocale();
+    std::string const name = spellInfo->SpellName[loc];
+
+    return _hasAuraName(unit, name, casterGuid, exclude);
+}
+//private
+bool bot_ai::_hasAuraName(Unit* unit, std::string const spell, uint64 casterGuid, bool exclude) const
+{
+    ASSERT(unit);
+    ASSERT(spell.length() != 0);
+
+    uint8 loc = IAmFree() ? sWorld->GetDefaultDbcLocale() : master->GetSession()->GetSessionDbcLocale();
+
+    Unit::AuraMap const& vAuras = unit->GetOwnedAuras();
+    SpellInfo const* spellInfo;
+    std::string name;
+
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        spellInfo = itr->second->GetSpellInfo();
+        name = spellInfo->SpellName[loc];
+        if (spell == name)
+            if (casterGuid == 0 || (exclude == (casterGuid != itr->second->GetCasterGUID())))
+                return true;
+    }
+
+    return false;
+}
+//LIST AURAS
+// Debug: Returns bot's info to called player
+void bot_ai::_listAuras(Player* player, Unit* unit) const
+{
+    //if (player->GetSession()->GetSecurity() == SEC_PLAYER) return;
+    if (!player->IsGameMaster() && (IAmFree() || !IsInBotParty(player))) return;
+    if (!IsInBotParty(unit)) return;
+    ChatHandler ch(player->GetSession());
+    std::ostringstream botstring;
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+        botstring << "player";
+    else if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        if (unit->ToCreature()->GetIAmABot())
+        {
+            botstring << "minion bot, master: ";
+            Player* owner = unit->ToCreature()->GetBotAI()->GetBotOwner();
+            botstring << (owner != unit ? owner->GetName() : "none");
+        }
+        else if (unit->ToCreature()->GetIAmABotsPet())
+        {
+            Player* owner = unit->ToCreature()->GetBotAI()->GetBotOwner();
+            Creature* creowner = unit->ToCreature()->GetBotPetAI()->GetCreatureOwner();
+            std::string const& ownername = owner != unit ? owner->GetName() : "none";
+            std::string const& creownername = creowner ? creowner->GetName() : "none";
+            botstring << "pet bot, master: ";
+            botstring << ownername;
+            botstring << ", creature owner: ";
+            botstring << creownername;
+            if (creowner)
+                botstring << " (" << creowner->GetGUIDLow() << ')';
+        }
+    }
+    uint32 const bot_pet_player_class = unit->GetTypeId() == TYPEID_PLAYER ? unit->getClass() : unit->ToCreature()->GetBotAI()->GetBotClass();
+    ch.PSendSysMessage("ListAuras for %s (class: %u), %s", unit->GetName().c_str(), bot_pet_player_class, botstring.str().c_str());
+    uint8 locale = player->GetSession()->GetSessionDbcLocale();
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        if (!spellInfo)
+            continue;
+        uint32 id = spellInfo->Id;
+        SpellInfo const* learnSpellInfo = sSpellMgr->GetSpellInfo(spellInfo->Effects[0].TriggerSpell);
+        const std::string name = spellInfo->SpellName[locale];
+        std::ostringstream spellmsg;
+        spellmsg << id << " - |cffffffff|Hspell:" << id << "|h[" << name;
+        spellmsg << ' ' << localeNames[locale] << "]|h|r";
+        uint32 talentcost = GetTalentSpellCost(id);
+        uint32 rank = 0;
+        if (talentcost > 0 && spellInfo->GetNextRankSpell())
+            rank = talentcost;
+        else if (learnSpellInfo && learnSpellInfo->GetNextRankSpell())
+            rank = spellInfo->GetRank();
+        else if (spellInfo->GetNextRankSpell())
+            rank = spellInfo->GetRank();
+        if (rank > 0)
+            spellmsg << " Rank " << rank;
+        if (talentcost > 0)
+            spellmsg << " [talent]";
+        if (spellInfo->IsPassive())
+            spellmsg << " [passive]";
+        if ((spellInfo->Attributes & SPELL_ATTR0_HIDDEN_CLIENTSIDE) ||
+            (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR))
+            spellmsg << " [hidden]";
+        if (unit->GetTypeId() == TYPEID_PLAYER && unit->ToPlayer()->HasSpell(id))
+            spellmsg << " [known]";
+        else if (unit == me && GetSpell(spellInfo->GetFirstRankSpell()->Id))
+            spellmsg << " [known]";
+
+        ch.PSendSysMessage(spellmsg.str().c_str());
+    }
+    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+    {
+        std::string mystat;
+        switch (i)
+        {
+            case STAT_STRENGTH: mystat = "str"; break;
+            case STAT_AGILITY: mystat = "agi"; break;
+            case STAT_STAMINA: mystat = "sta"; break;
+            case STAT_INTELLECT: mystat = "int"; break;
+            case STAT_SPIRIT: mystat = "spi"; break;
+            default: mystat = "unk stat"; break;
+        }
+        float totalstat = unit->GetTotalStatValue(Stats(i));
+        if (unit == me && IsMinionAI())
+        {
+            int8 t = -1;
+            switch (i)
+            {
+                case STAT_STRENGTH:     t = BOT_ITEM_MOD_STRENGTH;  break;
+                case STAT_AGILITY:      t = BOT_ITEM_MOD_AGILITY;   break;
+                case STAT_STAMINA:      t = BOT_ITEM_MOD_STAMINA;   break;
+                case STAT_INTELLECT:    t = BOT_ITEM_MOD_INTELLECT; break;
+                case STAT_SPIRIT:       t = BOT_ITEM_MOD_SPIRIT;    break;
+                default:                                            break;
+            }
+
+            if (t >= BOT_ITEM_MOD_MANA)
+                totalstat += GetMinionAI()->GetTotalBotStat(t);
+        }
+        ch.PSendSysMessage("total %s: %.1f", mystat.c_str(), totalstat);
+    }
+    ch.PSendSysMessage("Melee AP: %.1f", unit->GetTotalAttackPowerValue(BASE_ATTACK));
+    ch.PSendSysMessage("Ranged AP: %.1f", unit->GetTotalAttackPowerValue(RANGED_ATTACK));
+    ch.PSendSysMessage("armor: %u", unit->GetArmor());
+    ch.PSendSysMessage("crit: %.2f pct", unit->GetUnitCriticalChance(BASE_ATTACK, me));
+    ch.PSendSysMessage("dodge: %.2f pct", unit->GetUnitDodgeChance());
+    ch.PSendSysMessage("parry: %.2f pct", unit->GetUnitParryChance());
+    ch.PSendSysMessage("block: %.2f pct", unit->GetUnitBlockChance());
+    ch.PSendSysMessage("block value: %u", unit->GetShieldBlockValue());
+    ch.PSendSysMessage("Damage taken melee: %.3f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL));
+    ch.PSendSysMessage("Damage taken spell: %.3f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC));
+    if (unit != me || ap_mod > 0.0f)
+    {
+        WeaponAttackType type = BASE_ATTACK;
+        float attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+        ch.PSendSysMessage("Damage range mainhand: min: %.0f, max: %.0f", unit->GetFloatValue(UNIT_FIELD_MINDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+        ch.PSendSysMessage("Damage mult mainhand: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+        ch.PSendSysMessage("Attack time mainhand: %.2f (%.1f DPS)", attSpeed,
+            ((unit->GetFloatValue(UNIT_FIELD_MINDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE)) / 2) * unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) * unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT) / attSpeed);
+        if (unit->haveOffhandWeapon())
+        {
+            type = OFF_ATTACK;
+            attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+            ch.PSendSysMessage("Damage range offhand: min: %.0f, max: %.0f", unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+            ch.PSendSysMessage("Damage mult offhand: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+            ch.PSendSysMessage("Attack time offhand: %.2f (%.1f DPS)", attSpeed,
+                ((unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE)) / 2) * unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT) * unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT) / attSpeed);
+        }
+        if (unit != me ||
+            (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2) &&
+            GetBotClass() != BOT_CLASS_PALADIN &&
+            GetBotClass() != BOT_CLASS_DEATH_KNIGHT &&
+            GetBotClass() != BOT_CLASS_DRUID &&
+            GetBotClass() != BOT_CLASS_SHAMAN))
+        {
+            type = RANGED_ATTACK;
+            attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+            ch.PSendSysMessage("Damage range ranged: min: %.1f, max: %.1f", unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+            ch.PSendSysMessage("Damage mult ranged: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+            ch.PSendSysMessage("Attack time ranged: %.2f (%.1f DPS)", attSpeed,
+                ((unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE)) / 2) * unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) * unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT) / attSpeed);
+        }
+    }
+    ch.PSendSysMessage("base hp: %u", unit->GetCreateHealth());
+    ch.PSendSysMessage("total hp: %u", unit->GetMaxHealth());
+    ch.PSendSysMessage("base mana: %u", unit->GetCreateMana());
+    ch.PSendSysMessage("total mana: %u", unit->GetMaxPower(POWER_MANA));
+    if (unit->GetShapeshiftForm() != FORM_NONE && unit->getPowerType() != POWER_MANA)
+        ch.PSendSysMessage("cur mana: %u", unit->GetPower(POWER_MANA));
+    //DEBUG1
+    //ch.PSendSysMessage("STATS: ");
+    //ch.PSendSysMessage("Health");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_PCT));
+    //ch.PSendSysMessage("Mana");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_PCT));
+    //ch.PSendSysMessage("Stamina");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT));
+    //ch.PSendSysMessage("Intellect");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT));
+    //ch.PSendSysMessage("Spirit");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_PCT));
+    //END DEBUG1
+    if (unit == me)
+    {
+        ch.PSendSysMessage("melee damage mult: %.3f", _mult_dmg_melee);
+        ch.PSendSysMessage("spell damage mult: %.3f", _mult_dmg_spell);
+        ch.PSendSysMessage("healing done mult: %.3f", _mult_healing);
+        ch.PSendSysMessage("spell power: %i", me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC));
+        ch.PSendSysMessage("mana regen: %.2f", float(regen_mp) + me->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER) * sWorld->getRate(RATE_POWER_MANA) * 0.001f);
+        ch.PSendSysMessage("haste: %s%.2f pct", (haste >= 0 ? "+" : ""), float(haste));
+        ch.PSendSysMessage("hit: +%.2f pct", hit);
+        ch.PSendSysMessage("expertise: %i (-%.2f pct)", expertise, float(expertise) * 0.25f);
+        ch.PSendSysMessage("spell penetration: %u", spellpen);
+
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            uint32 curresist = me->GetResistance(SpellSchools(i));
+
+            const char* resist = NULL;
+            switch (i)
+            {
+                case 1: resist = "holy";   break;
+                case 2: resist = "fire";   break;
+                case 3: resist = "nature"; break;
+                case 4: resist = "frost";  break;
+                case 5: resist = "shadow"; break;
+                case 6: resist = "arcane"; break;
+            }
+            ch.PSendSysMessage("Resistance %s: %u", resist, curresist);
+        }
+        ch.PSendSysMessage("BotCommandState: %s", m_botCommandState == COMMAND_FOLLOW ? "Follow" : m_botCommandState == COMMAND_ATTACK ? "Attack" : m_botCommandState == COMMAND_STAY ? "Stay" : m_botCommandState == COMMAND_ABANDON ? "Reset" : "none");
+        if (!IAmFree())
+            ch.PSendSysMessage("Follow distance: %u", master->GetBotFollowDist());
+
+        ch.PSendSysMessage("Boot timer: %i", _bootTimer);
+
+        //debug
+        //for (uint32 i = 0; i != 148; ++i)
+        //{
+        //    float val = me->GetFloatValue(i);
+        //    ch.PSendSysMessage("Float value at %u: %.9f", i, val);
+        //}
+
+        //ch.PSendSysMessage("healTargetIconFlags: %u", healTargetIconFlags);
+
+        //ch.PSendSysMessage("Roles:");
+        //for (uint8 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+        //{
+        //    if (_roleMask & i)
+        //    {
+        //        switch (i)
+        //        {
+        //            case BOT_ROLE_TANK:
+        //                ch.PSendSysMessage("BOT_ROLE_TANK");
+        //                break;
+        //            case BOT_ROLE_DPS:
+        //                ch.PSendSysMessage("BOT_ROLE_DPS");
+        //                break;
+        //            case BOT_ROLE_HEAL:
+        //                ch.PSendSysMessage("BOT_ROLE_HEAL");
+        //                break;
+        //            //case BOT_ROLE_MELEE:
+        //            //    ch.PSendSysMessage("BOT_ROLE_MELEE");
+        //            //    break;
+        //            case BOT_ROLE_RANGED:
+        //                ch.PSendSysMessage("BOT_ROLE_RANGED");
+        //                break;
+        //        }
+        //    }
+        //}
+
+        //ch.PSendSysMessage("Stat bonuses:");
+        //for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        //{
+        //    int32 val = 0;
+        //    uint32 const a = i;
+        //    for (uint8 j = 0; j != BOT_INVENTORY_SIZE; ++j)
+        //        val += static_cast<BotStat>(_stats[j])[a];
+
+        //    if (val != 0)
+        //        ch.PSendSysMessage("Item mod %u: bonus = %i", i, val);
+        //}
+    }
+}
+//SetStats
+// Health, Armor, Powers, Combat Ratings, and global update setup
+void bot_minion_ai::SetStats(bool force, bool shapeshift)
+{
+    uint8 myclass = _botclass;
+    uint8 mylevel = std::min<uint8>(master->getLevel(), 80);
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+    if (myclass != DRUID_BEAR_FORM && myclass != DRUID_CAT_FORM && (master->isDead() || (!shouldUpdateStats && !force)))
+        return;
+    /*TC_LOG_ERROR("entities.player", "*etStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
+        me->GetName().c_str(), myclass, myrace, mylevel, master->GetName().c_str());*/
+
+    switch (me->GetCreatureTemplate()->rank) //TODO: conditions
+    {
+        case CREATURE_ELITE_RARE:       mylevel += 1;   break;
+        case CREATURE_ELITE_ELITE:      mylevel += 2;   break;
+        case CREATURE_ELITE_RAREELITE:  mylevel += 3;   break;
+        default:                                        break;
+    }
+    mylevel = std::min<uint8>(mylevel, 83);
+
+    //Do not remove this code under any circumstances! You've been warned.
+    if (myclass == BOT_CLASS_DEATH_KNIGHT)
+        mylevel = std::max<uint8>(mylevel, 55);
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //reinit spells/passives/other
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells(); //this must stay before class passives
+        //ApplyPassives(_botclass);
+        ApplyClassPassives();
+    }
+
+    //PHASE
+    if (!IsTempBot() && master->GetPhaseMask() != me->GetPhaseMask())
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+
+    //INIT STATS
+    //partially receive master's stats and get base class stats, we'll need all this later
+    uint8 tempclass = myclass == uint8(DRUID_BEAR_FORM) || myclass == uint8(DRUID_CAT_FORM) ? uint8(BOT_CLASS_DRUID) : myclass;
+    if (myclass >= BOT_CLASS_NORMAL_END)
+        sObjectMgr->GetPlayerClassLevelInfo(GetPlayerClass(), std::min<uint8>(mylevel, 80), _classinfo);
+    else
+        sObjectMgr->GetPlayerClassLevelInfo(tempclass, std::min<uint8>(mylevel, 80), _classinfo);
+    const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->getClass()); //use creature class
+
+    if (force)
+    {
+        PlayerLevelInfo info;
+        sObjectMgr->GetPlayerLevelInfo(me->getRace(), GetPlayerClass(), std::min<uint8>(mylevel, 80), &info);
+        for (uint8 i = STAT_STRENGTH; i != MAX_STATS; i++)
+            me->SetCreateStat(Stats(i), info.stats[i]);
+    }
+
+    float value;
+    float tempval;
+
+    //INIT CLASS MODIFIERS
+    switch (myclass)
+    {
+        case BOT_CLASS_WARRIOR:      ap_mod = 1.0f; spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.9f;  dodge_mod = 0.8f; parry_mod = 1.1f;  break;
+        case BOT_CLASS_DEATH_KNIGHT: ap_mod = 1.1f; spp_mod = 0.0f; armor_mod = 1.05f; crit_mod = 0.9f; haste_mod = 1.0f;  dodge_mod = 0.7f; parry_mod = 1.25f; break;
+        case BOT_CLASS_PALADIN:      ap_mod = 1.3f; spp_mod = 1.2f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f; parry_mod = 1.0f;  break;
+        case BOT_CLASS_ROGUE:        ap_mod = 1.3f; spp_mod = 0.3f; armor_mod = 0.9f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f; parry_mod = 0.8f;  break;
+        case BOT_CLASS_HUNTER:       ap_mod = 1.4f; spp_mod = 0.5f; armor_mod = 1.2f;  crit_mod = 1.2f; haste_mod = 1.5f;  dodge_mod = 1.1f; parry_mod = 1.15f; break;
+        case BOT_CLASS_SHAMAN:       ap_mod = 1.0f; spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 1.0f; haste_mod = 1.3f;  dodge_mod = 1.0f; parry_mod = 0.8f;  break;
+        case BOT_CLASS_DRUID:        ap_mod = 0.0f; spp_mod = 1.3f; armor_mod = 0.9f;  crit_mod = 0.7f; haste_mod = 1.35f; dodge_mod = 0.5f; parry_mod = 0.0f;  break;
+        case BOT_CLASS_MAGE:         ap_mod = 0.0f; spp_mod = 0.9f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.45f; dodge_mod = 0.5f; parry_mod = 0.0f;  break;
+        case BOT_CLASS_PRIEST:       ap_mod = 0.0f; spp_mod = 1.2f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.45f; dodge_mod = 0.5f; parry_mod = 0.0f;  break;
+        case BOT_CLASS_WARLOCK:      ap_mod = 0.0f; spp_mod = 1.0f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.45f; dodge_mod = 0.5f; parry_mod = 0.0f;  break;
+        case DRUID_BEAR_FORM:        ap_mod = 1.2f; spp_mod = 1.0f; armor_mod = 1.85f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 1.6f; parry_mod = 0.0f;  break;
+        case DRUID_CAT_FORM:         ap_mod = 1.5f; spp_mod = 1.0f; armor_mod = 1.2f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.4f; parry_mod = 0.0f;  break;
+
+        case BOT_CLASS_BM:           ap_mod = 2.5f; spp_mod = 0.0f; armor_mod = 0.8f;  crit_mod = 0.0f; haste_mod = 2.50f; dodge_mod = 0.0f; parry_mod = 0.0f;  break;
+
+        default:
+            TC_LOG_ERROR("entities.player", "minion_ai: *etStats():Init - unknown bot class %u, real class: %u, _botclass: %u", myclass, GetPlayerClass(), _botclass);
+            ap_mod = 0.0f; spp_mod = 0.0f; armor_mod = 0.0f;  crit_mod = 0.0f; haste_mod = 0.0f; dodge_mod = 0.0f;  parry_mod = 0.0f;  break;
+    }
+
+    //DAMAGE
+    _OnMeleeDamageUpdate(myclass);
+
+    //ARMOR
+    value = IAmFree() ? classstats->BaseArmor : me->getLevel() * 25; //over9000/2000 at 80
+    value += 2.f * (me->GetTotalStatValue(STAT_AGILITY) - 18 + _getTotalBotStat(BOT_ITEM_MOD_AGILITY));
+    value += _getTotalBotStat(BOT_ITEM_MOD_ARMOR);
+
+    //class-specified
+    if (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE)
+        armor_mod += 0.6f;
+    if (GetPlayerClass() == BOT_CLASS_DRUID)
+    {
+        armor_mod += 0.1f;
+        if (myclass == DRUID_BEAR_FORM)
+            armor_mod += 0.33f;
+    }
+
+    value *= armor_mod;
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor(); //buffs will be took in consideration here
+
+    //RESISTANCES
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = IAmFree() ? mylevel + 40 : std::max<int8>(int8(mylevel) - 20, 0);
+        value += _getTotalBotStat(BOT_ITEM_MOD_RESIST_HOLY + (i - 1));
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, value);
+        me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    value = IAmFree() ? 0.65f : 1.f;
+    if (mylevel > 77)
+        value -= ((mylevel - 77) * 0.05f); // +15% dmg reduction at 80
+
+    //class-specified
+    //Protector of the Pack
+    if (mylevel >= 45 && myclass == DRUID_BEAR_FORM)
+        value -= 0.12f;
+
+    dmg_taken = value;
+
+    //HEALTH
+    _OnHealthUpdate();
+
+    //HASTE
+    if (haste)
+    {
+        //unapply old haste
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), false);
+        me->ApplyCastTimePercentMod(float(haste), false);
+    }
+
+    value = std::max<int32>(int32(mylevel) - (IAmFree() ? 60 : 75), 0); //+20%/+5% haste at 80
+
+    //25.5 HR = 1% haste at 80
+    tempval = _getTotalBotStat(BOT_ITEM_MOD_HASTE_MELEE_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HASTE_RANGED_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HASTE_SPELL_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HASTE_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_HASTE_MELEE) | (1 << CR_HASTE_RANGED) | (1 << CR_HASTE_SPELL));
+    value += tempval * (myclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_HASTE_RANGED) : std::max<float>(_getRatingMultiplier(CR_HASTE_MELEE), _getRatingMultiplier(CR_HASTE_SPELL)));
+    //value += (tempval / (25.5f * (mylevel < 11 ? 1.125f : mylevel - 5) / 75.f));
+    //value += (tempval / (25.5f * (float(mylevel - 5) / 75.f)));
+
+    value *= haste_mod;
+
+    if (myclass == DRUID_CAT_FORM) //give cat lots of haste
+        value += (mylevel/16) * 10.f; //or (mylevel/16) (+40...50% haste for cat);
+    if (myclass == CLASS_HUNTER)
+        value += 15.f; //ammo pouch haste bonus 15% for hunters (still applies to all haste types)
+
+    haste = int32(value);
+
+    if (haste)
+    {
+        //apply new haste
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), true);
+        me->ApplyCastTimePercentMod(float(haste), true);
+    }
+
+    //HIT
+    value = IAmFree() ? mylevel / 8 : mylevel / 16; // 10%/5% at 80
+
+    //32.5 HR = 1% hit at 80
+    tempval = _getTotalBotStat(BOT_ITEM_MOD_HIT_MELEE_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HIT_RANGED_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HIT_SPELL_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HIT_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_HIT_MELEE) | (1 << CR_HIT_RANGED) | (1 << CR_HIT_SPELL));
+    value += tempval * (myclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_HIT_RANGED) : std::max<float>(_getRatingMultiplier(CR_HIT_MELEE), _getRatingMultiplier(CR_HIT_SPELL)));
+    //value += (tempval / (32.5f * (mylevel < 11 ? 0.72f : mylevel - 8) / 72.f));
+    //value += (tempval / (32.5f * (float(mylevel - 5) / 75.f)));
+
+    hit = value;
+
+    //EXPERTISE
+    if (IsMelee())
+    {
+        value = IAmFree() ? mylevel / 2 : mylevel / 20; //-10%/-1% dodge/parry at 80
+
+        //~8.0 ER = 1 expertise at 80
+        tempval = _getTotalBotStat(BOT_ITEM_MOD_EXPERTISE_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_EXPERTISE));
+        value += tempval * _getRatingMultiplier(CR_EXPERTISE);
+        //value += (tempval / (8.0f * (mylevel < 11 ? 0.9f : mylevel - 8) / 72.f));
+        //value += (tempval / (8.0f * (float(mylevel - 5) / 75.f)));
+
+        expertise = value;
+    }
+
+    //CRIT
+    if (crit_mod > 0.0f)
+    {
+        value = IAmFree() ? mylevel / 4 : mylevel / 16; //+20%/+5% at 80
+
+        if (GtChanceToMeleeCritEntry const* critRatio = sGtChanceToMeleeCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1))
+            value += (me->GetTotalStatValue(STAT_AGILITY) - 18 + _getTotalBotStat(BOT_ITEM_MOD_AGILITY)) * critRatio->ratio * 100.0f;
+
+        //crit from intellect
+        if (GtChanceToSpellCritEntry const* critRatio = sGtChanceToSpellCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1))
+            value += (me->GetTotalStatValue(STAT_INTELLECT) - 18 + _getTotalBotStat(BOT_ITEM_MOD_INTELLECT)) * critRatio->ratio * 100.f;
+
+        //45 CR = 1% crit at 80
+        float tempval = _getTotalBotStat(BOT_ITEM_MOD_CRIT_MELEE_RATING) + _getTotalBotStat(BOT_ITEM_MOD_CRIT_RANGED_RATING) + _getTotalBotStat(BOT_ITEM_MOD_CRIT_SPELL_RATING) + _getTotalBotStat(BOT_ITEM_MOD_CRIT_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_CRIT_MELEE) | (1 << CR_CRIT_RANGED) | (1 << CR_CRIT_SPELL));
+        value += tempval * (myclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_CRIT_RANGED) : std::max<float>(_getRatingMultiplier(CR_CRIT_MELEE), _getRatingMultiplier(CR_CRIT_SPELL)));
+        //value += (tempval / (45.f * (mylevel < 11 ? 0.8f : mylevel - 8) / 72.f));
+        //value += (tempval / (45.f * (float(mylevel - 5) / 75.f)));
+
+        crit = value * crit_mod;
+    }
+
+    //PARRY
+    if (parry_mod > 0.0f)
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 8 : mylevel / 16); //+10%/+5% at 80
+
+        if (mylevel >= 10)
+        {
+            //67 PR = 1% parry at 80
+            float tempval = _getTotalBotStat(BOT_ITEM_MOD_PARRY_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_PARRY));
+            value += tempval * _getRatingMultiplier(CR_PARRY);
+            //value += (tempval / (67.f * (mylevel < 35 ? 5.5f : mylevel - 25) / 55.f));
+            //value += (tempval / (67.f * (float(mylevel - 5) / 75.f)));
+            //125 DR = 1% block/parry/dodge at 80
+            tempval = _getTotalBotStat(BOT_ITEM_MOD_DEFENSE_SKILL_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DEFENSE_SKILL));
+            value += tempval * _getRatingMultiplier(CR_DEFENSE_SKILL) * 0.04f;
+            value += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SKILL, SKILL_DEFENSE) * 0.04f;
+            //value += (tempval / (125.f * (mylevel < 35 ? 8.25f : mylevel - 25) / 55.f));
+            //value += (tempval / (125.f * (float(mylevel - 5) / 75.f)));
+        }
+
+        //if (IsTank()) //tanking bonus
+        //    value += 5.f;
+
+        //Forceful Deflection: 25% of strength goes to parry rating (~1% parry per 67 rating at 80)
+        if (myclass == BOT_CLASS_DEATH_KNIGHT/* && mylevel >= 55*/)
+            value += ((me->GetTotalStatValue(STAT_STRENGTH) - 18 + _getTotalBotStat(BOT_ITEM_MOD_STRENGTH)) / 4.f) / (float(mylevel) - (13.f / (float(mylevel - 40) / 40.f))); //~20 at 55, ~34 at 60 and 67 at 80
+
+        parry = value * parry_mod;
+    }
+
+    //DODGE
+    if (dodge_mod > 0.0f)
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 8 : mylevel / 16); //+10%/+5% at 80
+
+        if (GtChanceToMeleeCritEntry  const* dodgeRatio = sGtChanceToMeleeCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1))
+            value += (me->GetTotalStatValue(STAT_AGILITY) - 18 + _getTotalBotStat(BOT_ITEM_MOD_AGILITY)) * dodgeRatio->ratio * 100.0f;
+
+        if (mylevel >= 10)
+        {
+            //53 DR = 1% dodge at 80
+            float tempval = _getTotalBotStat(BOT_ITEM_MOD_DODGE_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DODGE));
+            value += tempval * _getRatingMultiplier(CR_DODGE);
+            //value += (tempval / (53.f * (mylevel < 35 ? 7.15f : mylevel - 25) / 55.f));
+            //value += (tempval / (53.f * (float(mylevel - 5) / 75.f)));
+            //125 DR = 1% block/parry/dodge at 80
+            tempval = _getTotalBotStat(BOT_ITEM_MOD_DEFENSE_SKILL_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DEFENSE_SKILL));
+            value += tempval * _getRatingMultiplier(CR_DEFENSE_SKILL) * 0.04f;
+            value += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SKILL, SKILL_DEFENSE) * 0.04f;
+            //value += (tempval / (125.f * (mylevel < 35 ? 8.25f : mylevel - 25) / 55.f));
+            //value += (tempval / (125.f * (float(mylevel - 5) / 75.f)));
+        }
+
+        //if (IsTank())
+        //    value += 5.f;
+
+        dodge = value * dodge_mod;
+    }
+
+    //BLOCK
+    if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 4 : mylevel/ 16); //+20%/+5% at 80
+
+        if (mylevel >= 10)
+        {
+            //16.5 BR = 1% block at 80
+            float tempval = _getTotalBotStat(BOT_ITEM_MOD_BLOCK_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_BLOCK));
+            value += tempval * _getRatingMultiplier(CR_BLOCK);
+            //value += (tempval / (16.5f * (mylevel < 35 ? 8.25f : mylevel - 25) / 55.f));
+            //value += (tempval / (16.5f * (float(mylevel - 5) / 75.f)));
+            //125 DR = 1% block/parry/dodge at 80
+            tempval = _getTotalBotStat(BOT_ITEM_MOD_DEFENSE_SKILL_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DEFENSE_SKILL));
+            value += tempval * _getRatingMultiplier(CR_DEFENSE_SKILL) * 0.04f;
+            value += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SKILL, SKILL_DEFENSE) * 0.04f;
+            //value += (tempval / (125.f * (mylevel < 35 ? 8.25f : mylevel - 25) / 55.f));
+            //value += (tempval / (125.f * (float(mylevel - 5) / 75.f)));
+
+            value += IsTank() * 10; //tank bonus
+        }
+
+        block = std::min<float>(value, 75.0f);
+
+        //BLOCK VALUE
+        value = float(mylevel + (mylevel >> 2)); //100 at 80
+        value += 0.5f * (me->GetTotalStatValue(STAT_STRENGTH) - 18);
+        value += 0.5f *_getTotalBotStat(BOT_ITEM_MOD_STRENGTH);
+        value += _getTotalBotStat(BOT_ITEM_MOD_BLOCK_VALUE);
+
+        //Shield Mastery
+        if (mylevel >= 20 && myclass == BOT_CLASS_WARRIOR)
+            value *= 1.3f;
+        //Redoubt
+        if (mylevel >= 45 && myclass == BOT_CLASS_PALADIN)
+            value *= 1.3f;
+
+        blockvalue = std::max<int32>(int32(value) - 10, 1);
+    }
+
+    //MANA
+    _OnManaUpdate(shapeshift);
+
+    //MANA REGEN
+    if (me->GetMaxPower(POWER_MANA) > 1)
+    {
+        value = IAmFree() ? mylevel * 5 : 0; //400/0 at 80
+        value += _getTotalBotStat(BOT_ITEM_MOD_MANA_REGENERATION);
+        //regen from spirit: 15 base, 1 per 5 spirit
+        value += 15.f + 0.2f * (me->GetTotalStatValue(STAT_SPIRIT) - 18 + _getTotalBotStat(BOT_ITEM_MOD_SPIRIT));
+        //hunters just spend all mana in no time
+        //if (myclass == BOT_CLASS_HUNTER && mylevel > 20)
+        //    value += float((mylevel - 20) * 5); //300
+        if (myclass >= BOT_CLASS_EX_START)
+        {
+            if (myclass == BOT_CLASS_BM)
+                value = std::max<float>(value / 20, 1); //0.2 per sec
+        }
+
+        //regen from intellect: 1 int = 0.01 mana per second = 0.05 mp5
+        value += 0.05f * (me->GetTotalStatValue(STAT_INTELLECT) - 18 + _getTotalBotStat(BOT_ITEM_MOD_INTELLECT));
+
+        regen_mp = uint32(value);
+    }
+
+    //SPELL PENETRATION
+    value = IAmFree() ? mylevel : std::max<int32>((int8(mylevel) - 20), 0) / 3; //80/20 at 80
+    //~1 SPPR = 1 spell penetration
+    value += _getTotalBotStat(BOT_ITEM_MOD_SPELL_PENETRATION);
+    spellpen = uint32(value);
+
+    //SPELL POWER
+    if (spp_mod > 0.f)
+    {
+        value = IAmFree() ? std::max<int32>((int8(mylevel) - 30) * 80, 0) : std::max<int32>((int8(mylevel) - 30) * 3, 0); //+4000spp/+150spp at 80
+        value += _getTotalBotStat(BOT_ITEM_MOD_SPELL_POWER);
+
+        //class-specified mods
+        if (myclass == BOT_CLASS_PALADIN && mylevel >= 50)
+        {
+            //Touched by the Light / Sheath of Light - 60% of strength (30% attack power) to spell power
+            if (HasRole(BOT_ROLE_TANK | BOT_ROLE_DPS))
+                value += 0.3f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+            //Holy Guidance - 20% Intellect to spell power
+            else if (HasRole(BOT_ROLE_HEAL))
+                value += 0.2f * me->GetTotalStatValue(STAT_INTELLECT);
+        }
+        if (myclass == BOT_CLASS_PRIEST && mylevel >= 55)
+        {
+            //Spiritual Guidance - 25% Spirit to spell power
+            if (HasRole(BOT_ROLE_HEAL))
+                value += 0.25f * me->GetTotalStatValue(STAT_SPIRIT);
+            //Twisted Faith - 20% Spirit to spell power
+            else if (HasRole(BOT_ROLE_DPS))
+                value += 0.2f * me->GetTotalStatValue(STAT_SPIRIT);
+        }
+        if (myclass == BOT_CLASS_SHAMAN && mylevel >= 50)
+        {
+            //Mental Quickness - 30% attack power to spell power (only enhancement)
+            if (HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_RANGED))
+                value += 0.3f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+        }
+        if (myclass == BOT_CLASS_DRUID && mylevel >= 30)
+        {
+            //Lunar Guidance - 12% Intellect to spell power (balance and resto possible)
+            if (HasRole(BOT_ROLE_DPS | BOT_ROLE_HEAL))
+                value += 0.12f * me->GetTotalStatValue(STAT_INTELLECT);
+        }
+        if (myclass == BOT_CLASS_MAGE && mylevel >= 45)
+        {
+            //Mind Mastery - 15% Intellect to spell power
+            //if (HasRole(BOT_ROLE_DPS))
+                value += 0.15f * me->GetTotalStatValue(STAT_INTELLECT);
+        }
+
+        spellpower = uint32(value * spp_mod);
+    }
+
+    //if init
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    //SetStats for pet
+    if (Creature* pet = me->GetBotsPet())
+        if (bot_pet_ai* petai = pet->GetBotPetAI())
+            petai->SetStats(force);
+
+    shouldUpdateStats = false;
+}
+
+void bot_pet_ai::SetStats(bool force, bool /*unk*/)
+{
+    uint8 mylevel = m_creatureOwner->getLevel();
+    uint8 petType = GetPetType(me);
+    if (petType == PET_TYPE_NONE || petType >= MAX_PET_TYPES) return;
+    if (!shouldUpdateStats && !force) return;
+    //TC_LOG_ERROR("entities.player", "*etStats(): Updating pet bot %s, type: %u, level %u, owner: %s, master: %s", me->GetName().c_str(), petType, mylevel, m_creatureOwner->GetName().c_str(), master->GetName().c_str());
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells();
+        //ApplyPassives(_botclass);
+        ApplyClassPassives();
+    }
+
+    //PHASE
+    if (master->GetPhaseMask() != me->GetPhaseMask())
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+
+    ////INIT STATS
+    if (force)
+        for (uint8 i = STAT_STRENGTH; i != MAX_STATS; i++)
+            me->SetCreateStat(Stats(i), 0.5f * m_creatureOwner->GetCreateStat(Stats(i)));
+
+    //INIT CLASS MODIFIERS
+    //STAT -- 'mod' -- used stat values to apply
+    //WARLOCK
+    //Stamina x0.3  -- health
+    //Armor   x0.35 -- armor
+    //Int     x0.3  -- crit/mana
+    //Spd     x0.15 -- spd (if has mana)
+    //AP      x0.57 -- attack power (if melee pet)
+    //Resist  x0.4  -- resistances
+    //MAGE
+    //
+    //SHAMAN
+    //
+    //HUNTER
+    //
+
+    switch (petType)
+    {
+        case PET_TYPE_VOIDWALKER:       ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;
+        //case PET_TYPE_FELHUNTER:        ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_FELGUARD:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_SUCCUBUS:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_IMP:              ap_mod = 0.f;   spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+
+        //case PET_TYPE_WATER_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_FIRE_ELEMENTAL:   ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+        //case PET_TYPE_EARTH_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_VULTURE:          ap_mod = 0.9f;  spp_mod = 1.0f; crit_mod = 1.2f; break;//NYI
+        default:
+            TC_LOG_ERROR("entities.player", "pet_ai: *etStats():Init - unknown pet type %u", petType);
+            ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;
+    }
+
+    //DAMAGE
+    if (ap_mod > 0.f)//do not bother casters
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                value = float(m_creatureOwner->GetBotAI()->GetBotSpellPower());
+                break;
+            case BOT_CLASS_DEATH_KNIGHT:
+                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+                break;
+            case BOT_CLASS_HUNTER:
+                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+                break;
+            default: //some weird class or NYI
+                TC_LOG_ERROR("entities.player", "*etStats():Damage - unknown bot owner class %u", uint8(m_creatureOwner->GetBotClass()));
+                value = 0.0f;
+                break;
+        }
+
+        me->SetModifierValue(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, me->GetCreateStat(STAT_STRENGTH) - 9.f);
+        atpower = (me->GetTotalAuraModValue(UNIT_MOD_STAT_STRENGTH) * 2.f + value) * ap_mod;
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage();
+    }
+
+    //ARMOR
+    value = float(basearmor);
+    //get minion's armor and give 35% to pet (just as for real pets)
+    value += m_creatureOwner->GetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE) * 0.35f;
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();
+
+    //RESISTANCES
+    //based on minion's resistances gain x0.4
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(m_creatureOwner->GetResistance(SpellSchools(i)));
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, 0.4f * value);
+        me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    dmg_taken = m_creatureOwner->GetBotAI()->GetBotDamageTakenMod();
+
+    //HEALTH
+    _OnHealthUpdate();
+
+    //HASTE
+    if (haste)
+    {
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), false);
+        me->ApplyCastTimePercentMod(float(haste), false);
+    }
+
+    haste = m_creatureOwner->GetBotAI()->GetHaste();
+
+    if (haste)
+    {
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), true);
+        me->ApplyCastTimePercentMod(float(haste), true);
+    }
+
+    //HIT
+    hit = m_creatureOwner->GetBotAI()->GetHitRating();
+
+    //CRIT
+    if (CanCrit())
+    {
+        value = m_creatureOwner->GetUnitCriticalChance((BASE_ATTACK), me);
+        crit = value * crit_mod;
+    }
+
+    //PARRY
+    if (CanParry())
+    {
+        value = m_creatureOwner->GetUnitParryChance();
+        parry = value;
+    }
+
+    //DODGE
+    if (CanDodge())
+    {
+        value = m_creatureOwner->GetUnitDodgeChance();
+        value += IsTank() * 10;
+        dodge = value;
+    }
+
+    //MANA
+    _OnManaUpdate(false);
+
+    //MANA REGEN
+    regen_mp = m_creatureOwner->GetBotAI()->GetManaRegen();
+
+    //SPELL PENETRATION
+    spellpen = m_creatureOwner->GetBotAI()->GetBotSpellPenetration();
+
+    //SPELL POWER
+    if (spp_mod > 0.f)
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                value = m_creatureOwner->GetBotAI()->GetBotSpellPower();
+                break;
+            case BOT_CLASS_DEATH_KNIGHT:
+                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+                break;
+            case BOT_CLASS_HUNTER:
+                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+                break;
+            default: //some weird class or NYI
+                TC_LOG_ERROR("entities.player", "*etStats():Spellpower - unknown bot owner class %u", uint8(m_creatureOwner->GetBotClass()));
+                value = 0.f;
+                break;
+        }
+
+        spellpower = uint32(value * spp_mod);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    shouldUpdateStats = false;
+}
+//Emotion-based action
+void bot_ai::ReceiveEmote(Player* player, uint32 emote)
+{
+    switch (emote)
+    {
+        case TEXT_EMOTE_BONK:
+            _listAuras(player, me);
+            break;
+        case TEXT_EMOTE_SALUTE:
+            _listAuras(player, player);
+            break;
+        case TEXT_EMOTE_STAND:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_STAY);
+            BotWhisper("Standing Still.", player);
+            break;
+        case TEXT_EMOTE_WAVE:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_FOLLOW, true);
+            BotWhisper("Following!", player);
+            break;
+        default:
+            break;
+    }
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_ai::IsInBotParty(Unit const* unit) const
+{
+    if (!unit) return false;
+    if (unit == me || unit == master) return true;
+
+    if (IAmFree())
+    {
+        if (unit == me->GetBotsPet())
+            return true;
+
+        Player const* owner = NULL;
+
+        Creature const* bot = unit->ToCreature();
+        if (bot)
+        {
+            //controlled bot case
+            if (bot->GetBotAI() && !bot->IsFreeBot())
+                owner = bot->GetBotOwner();
+
+            //free bot / neutral case
+            if (bot->getFaction() == me->getFaction())
+                return true;
+        }
+
+        if (!owner)
+            owner = unit->GetCharmerOrOwnerPlayerOrPlayerItself();
+        if (owner && (owner->getFaction() == me->getFaction() || me->GetReactionTo(owner) >= REP_FRIENDLY))
+            return true;
+
+        if (unit->GetCharmerOrOwnerGUID() == me->GetGUID())
+            return true;
+
+        return false;
+    }
+
+    //cheap check
+    if (Group* gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if (_healTargetIconFlags & GroupIconsFlags[i])
+                if (uint64 guid = gr->GetTargetIcons()[i])//check this one
+                    if (guid == unit->GetGUID())
+                        if (unit->GetReactionTo(master) >= REP_NEUTRAL &&
+                            master->GetVictim() != unit &&
+                            unit->GetVictim() != master)
+                            return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature const* cre = unit->ToCreature())
+    {
+        //npcbot/npcbot's pet case
+        if (Player* owner = cre->GetBotOwner())
+        {
+            if (owner == master)
+                return true;
+        }
+        //pets, minions, guardians etc.
+        else
+        {
+            uint64 ownerGuid = unit->GetOwnerGUID();
+            //controlled by group member
+            if (Group* gr = master->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+        }
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/reapplies aura stacks
+bool bot_ai::RefreshAura(uint32 spellId, int8 count) const
+{
+    if (!spellId)
+        return false;
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): Invalid spellInfo for spell %u! Bot - %s (botclass: %u, entry: %u)",
+            spellId, me->GetName().c_str(), _botclass, me->GetEntry());
+        return false;
+    }
+
+    if (me->HasAura(spellId))
+        me->RemoveAurasDueToSpell(spellId);
+
+    for (int8 i = 0; i < count; ++i)
+        me->AddAura(spellInfo, MAX_EFFECT_MASK, me);
+
+    return true;
+}
+//CHECKAURAS
+//Updates bot's condition once a while
+void bot_minion_ai::CheckAuras(bool force)
+{
+    opponent = me->GetVictim(); //safe
+
+    if (!force)
+    {
+        Regenerate();
+        _updateRations(); //safe
+    }
+
+    if (checkAurasTimer == 0)
+    {
+        checkAurasTimer = 10 + (IAmFree() ? 5 : master->GetNpcBotsCount() / 2);
+
+        if (needparty)
+        {
+            needparty = false;
+            if (!IAmFree()) //we could lose master
+                master->GetBotMgr()->AddBotToGroup(me);
+        }
+
+        if (_bootTimer == 0)
+        {
+            //timer will be cancelled at bot removal so we are always free here
+            //_bootTimer = -1; //Set in AbortTeleport()
+            master->m_Controlled.erase(me);
+            BotMgr::TeleportBot(me, master->GetMap(), master);
+            return;
+        }
+
+        if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY && opponent && !CCed(me, true))
+        {
+            if (IsMelee())
+            {
+                if (me->GetDistance(opponent) > 1.5f)
+                    GetInPosition(true);
+            }
+            else
+            {
+                CalculateAttackPos(opponent, attackpos);
+                if (me->GetDistance(attackpos) > 8)
+                    GetInPosition(true, opponent, &attackpos);
+            }
+        }
+        if (shouldUpdateStats && me->GetPhaseMask() == master->GetPhaseMask())
+            SetStats(false);
+        else if (!_powersTimer)
+        {
+            _powersTimer = 2000;
+            UpdateHealth();
+            UpdateMana();
+        }
+        if (rezz_cd > 0)
+            --rezz_cd;
+        if (clear_cd > 0)
+            --clear_cd;
+        else
+            clear_cd = 15;
+        if (_atHome && Rand() < 10)
+            _atHome = false;
+        return;
+    }
+    else if (force)
+    {
+        if (!opponent && !IAmFree())
+        {
+            if (master->isDead())
+            {
+                //If ghost move to corpse, else move to dead player
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                {
+                    Corpse* corpse = master->GetCorpse();
+                    if (corpse && me->GetMap() == corpse->FindMap() && !me->IsInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) && !IsCasting() && !CCed(me) && me->GetDistance(corpse) > 5)
+                        me->GetMotionMaster()->MovePoint(corpse->GetMapId(), *corpse);
+                }
+                else
+                {
+                    if (m_botCommandState != COMMAND_FOLLOW || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
+                        Follow(true);
+                }
+            }
+            else if (m_botCommandState != COMMAND_STAY && !IsCasting())
+            {
+                _calculatePos(pos);
+                uint8 followdist = master->GetBotFollowDist();
+                if (me->GetExactDist(&pos) > (followdist > 8 ? 4 + followdist/2*(!master->isMoving()) : 8))
+                    Follow(true, &pos); //check if doing nothing
+            }
+        }
+        if (!IsCasting())
+        {
+            if (me->IsInCombat() || !CanSheath())
+            {
+                if (!me->IsStandState())
+                {
+                    if (_botclass == BOT_CLASS_HUNTER)
+                    {
+                        if (me->GetSheath() != SHEATH_STATE_RANGED)
+                            me->SetSheath(SHEATH_STATE_RANGED);
+                    }
+                    else if (me->GetSheath() != SHEATH_STATE_MELEE)
+                        me->SetSheath(SHEATH_STATE_MELEE);
+                }
+            }
+            else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
+            {
+                me->SetSheath(SHEATH_STATE_UNARMED);
+                if (_botclass == BOT_CLASS_HUNTER)
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_CHEER);
+            }
+        }
+
+        _updateMountedState();
+        _updateStandState();
+
+        //update flags
+        if (!me->IsInCombat() && !_evadeMode && _atHome && !me->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP))
+            me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+    }
+}
+void bot_pet_ai::CheckAuras(bool /*force*/)
+{
+    Regenerate();
+
+    if (checkAurasTimer > 0) return;
+    checkAurasTimer = 10 + IAmFree() ? 5 : master->GetNpcBotsCount() / 2;
+
+    if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
+    {
+        opponent = me->GetVictim();
+        if (opponent)
+        {
+            switch (GetPetType(me))
+            {
+                case PET_TYPE_IMP:
+                    CalculateAttackPos(opponent, attackpos);
+                    if (me->GetDistance(attackpos) > 8)
+                        GetInPosition(true, opponent, &attackpos);
+                    break;
+                default:
+                    if (me->GetDistance(opponent) > 1.5f)
+                        GetInPosition(true);
+                    break;
+            }
+        }
+    }
+    if (clear_cd > 0)
+        --clear_cd;
+    else
+        clear_cd = 15;
+
+    return;
+}
+
+bool bot_ai::CanBotAttack(Unit const* target, int8 byspell) const
+{
+    if (!target)
+        return false;
+    if (!_botPvP && !IAmFree() && target->IsControlledByPlayer())
+        return false;
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    return
+       (target->IsAlive() &&
+       target->IsVisible() &&
+       //me->IsValidAttackTarget(target) &&
+       ((me->CanSeeOrDetect(target) && target->InSamePhase(me)) || CanSeeEveryone()) &&
+       //!target->HasStealthAura() && !target->HasInvisibilityAura() &&
+       (master->isDead() || target->GetTypeId() == TYPEID_PLAYER || target->IsPet() ||
+       (target->GetDistance(master) < foldist && me->GetDistance(master) < followdist)) &&//if master is killed pursue to the end
+        target->isTargetableForAttack() &&
+        !IsInBotParty(target) &&
+        (target->IsHostileTo(master) ||
+        (target->GetReactionTo(master) < REP_FRIENDLY/* && master->GetVictim() == target*/ && (master->IsInCombat() || target->IsInCombat())) ||//master has pointed this target
+        target->IsHostileTo(me)) &&//if master is controlled
+        //target->IsWithinLOSInMap(me) &&
+        (byspell == -1 || !target->IsImmunedToDamage(byspell ? SPELL_SCHOOL_MASK_MAGIC : SPELL_SCHOOL_MASK_NORMAL)));
+}
+//GETTARGET
+//Returns attack target or 'no target'
+Unit* bot_ai::_getTarget(bool byspell, bool ranged, bool &reset) const
+{
+    if (_evadeMode) //IAmFree() case only
+        return NULL;
+
+    Unit* u = master->GetVictim();
+    Unit* mytar = me->GetVictim();
+
+    //check if no need to change target
+    if (!mytar && IsMinionAI())
+        if (Creature* pet = me->GetBotsPet())
+            mytar = pet->GetVictim();
+    if (!mytar && IsPetAI())
+        mytar = me->GetBotPetAI()->GetCreatureOwner()->GetVictim();
+
+    //TC_LOG_ERROR("entities.player", "bot_ai::getTarget(): bot: %s, PvP = %u", me->GetName().c_str(), PvP);
+
+    if (u && u == mytar && !IAmFree())
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack common target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;//forced
+    }
+    //Follow if...
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if (!u && master->IsAlive() && (me->GetDistance(master) > foldist || (mytar && master->GetDistance(mytar) > foldist && me->GetDistance(master) > foldist)))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s cannot attack target %s, too far away", me->GetName().c_str(), mytar ? mytar->GetName().c_str() : "");
+        return NULL;
+    }
+
+    if (u && !IAmFree() && (master->IsInCombat() || u->IsInCombat()) && !InDuel(u) && !IsInBotParty(u) && !(!_botPvP && !IAmFree() && u->IsControlledByPlayer()))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s starts attack master's target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;
+    }
+
+    if (mytar && (!IAmFree() || me->GetDistance(mytar) < BOT_MAX_CHASE_RANGE) && CanBotAttack(mytar, byspell) && !InDuel(mytar))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack its target %s", me->GetName().c_str(), mytar->GetName().c_str());
+        if (me->GetDistance(mytar) > (ranged ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
+            reset = true;
+        return mytar;
+    }
+
+    if (followdist == 0 && master->IsAlive())
+        return NULL; //do not bother
+
+    //check group
+    if (!IAmFree())
+    {
+        Group* gr = master->GetGroup();
+        if (!gr)
+        {
+            BotMap const* map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                Creature* bot = itr->second;
+                if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                u = bot->GetVictim();
+                if (u && CanBotAttack(u, byspell) &&
+                    (bot->IsInCombat() || u->IsInCombat()) &&
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+                Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+                if (!pet || !pet->InSamePhase(me)) continue;
+                u = pet->GetVictim();
+                if (u && CanBotAttack(u, byspell) &&
+                    (pet->IsInCombat() || u->IsInCombat()) &&
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+            }
+        }
+        else
+        {
+            for (GroupReference* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+            {
+                Player* pl = ref->GetSource();
+                if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                u = pl->GetVictim();
+                if (u && pl != master && CanBotAttack(u, byspell) &&
+                    (pl->IsInCombat() || u->IsInCombat()) &&
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pl->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+                if (!pl->HaveBot()) continue;
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    Creature* bot = it->second;
+                    if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                    if (!bot->IsInWorld()) continue;
+                    if (me->GetMap() != bot->FindMap()) continue;
+                    u = bot->GetVictim();
+                    if (u && CanBotAttack(u, byspell) &&
+                        (bot->IsInCombat() || u->IsInCombat()) &&
+                        (master->isDead() || master->GetDistance(u) < foldist))
+                    {
+                        //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                        return u;
+                    }
+                    Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+                    if (!pet || !pet->InSamePhase(me)) continue;
+                    if (!pet->IsInWorld()) continue;
+                    if (me->GetMap() != pet->FindMap()) continue;
+                    u = pet->GetVictim();
+                    if (u && CanBotAttack(u, byspell) &&
+                        (pet->IsInCombat() || u->IsInCombat()) &&
+                        (master->isDead() || master->GetDistance(u) < foldist))
+                    {
+                        //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                        return u;
+                    }
+                }
+            }
+        }
+    }
+
+    //check targets around
+    Unit* t = NULL;
+    float maxdist = InitAttackRange(float(followdist), ranged);
+    //first cycle we search non-cced target, then, if not found, check all
+    for (uint8 i = 0; i != 2; ++i)
+    {
+        if (!t)
+        {
+            bool attackCC = i;
+
+            CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+            Cell cell(p);
+            cell.SetNoCreate();
+
+            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC);
+            Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(master, t, check);
+            me->VisitNearbyObject(maxdist, searcher);
+        }
+    }
+
+    if (t && opponent && t != opponent)
+        reset = true;
+
+    //if (t)
+    //    TC_LOG_ERROR("entities.player", "bot %s has Found new target %s", me->GetName().c_str(), t->GetName().c_str());
+
+    return t;
+}
+//'CanAttack' function
+bool bot_ai::CheckAttackTarget(uint8 botOrPetType)
+{
+    if (IsDuringTeleport()/* || _evadeMode*/)
+    {
+        //me->AttackStop(); //already in CombatStop()
+        me->CombatStop(true);
+        return false;
+    }
+
+    if (IAmFree() && Feasting())
+        return false;
+
+    bool byspell = false, ranged = false, reset = false;
+
+    if (IsMinionAI())
+    {
+        switch (botOrPetType)
+        {
+            case BOT_CLASS_DRUID:
+                byspell = me->GetShapeshiftForm() == FORM_NONE ||
+                    me->GetShapeshiftForm() == FORM_TREE ||
+                    me->GetShapeshiftForm() == FORM_MOONKIN;
+                ranged = byspell;
+                break;
+            case BOT_CLASS_PRIEST:
+            case BOT_CLASS_MAGE:
+            case BOT_CLASS_WARLOCK:
+            case BOT_CLASS_SHAMAN:
+                byspell = true;
+                break;
+            case BOT_CLASS_HUNTER:
+                ranged = true;
+                break;
+            case BOT_CLASS_DEATH_KNIGHT:
+            case BOT_CLASS_PALADIN:
+            case BOT_CLASS_WARRIOR:
+            case BOT_CLASS_ROGUE:
+            case BOT_CLASS_BM:
+                break;
+            default:
+                TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - unknown bot class %u", botOrPetType);
+                return false;
+        }
+    }
+    else
+    {
+        switch (botOrPetType)
+        {
+            case PET_TYPE_IMP:
+                byspell = true;
+                ranged = true;
+                break;
+            default:
+                TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - unknown pet type %u", botOrPetType);
+                return false;
+        }
+    }
+
+    opponent = _getTarget(byspell, ranged, reset);
+
+    if (!opponent)
+    {
+        //TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - bot %s lost target", me->GetName().c_str());
+        if (me->GetVictim() || me->IsInCombat()/* || !me->getThreatManager().isThreatListEmpty()*/)
+        {
+            //TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - bot %s Evades", me->GetName().c_str());
+            if (me->GetVictim())
+                me->AttackStop();
+            else if (me->IsInCombat())
+                Evade(true);
+        }
+
+        return false;
+    }
+
+    if (reset)
+        m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
+
+    if (opponent != me->GetVictim())
+        me->Attack(opponent, !ranged);
+
+    return true;
+}
+//POSITION
+void bot_ai::CalculateAttackPos(Unit* target, Position& pos) const
+{
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    float x(0),y(0),z(0),
+        dist = float(6 + urand(followdist/4, followdist/3)),
+        angle = target->GetAngle(me);
+    dist = std::min(dist, 20.f);
+    if (me->GetIAmABotsPet())
+        dist *= 0.5f;
+    float clockwise = RAND(1.f,-1.f);
+    for (uint8 i = 0; i != 5; ++i)
+    {
+        target->GetNearPoint(me, x, y, z, me->GetObjectSize()/2.f, dist, angle);
+        bool toofaraway = master->GetDistance(x,y,z) > (followdist > 28 ? 28.f : followdist < 20 ? 20.f : float(followdist));
+        bool outoflos = !target->IsWithinLOS(x,y,z);
+        if (toofaraway || outoflos)
+        {
+            if (toofaraway)
+                angle = target->GetAngle(master) + frand(0.f, M_PI*0.5f) * clockwise;
+            if (outoflos)
+                dist *= 0.5f;
+        }
+        else
+        {
+            dist *= 0.75f;
+            break;
+        }
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_ai::GetInPosition(bool force, Unit* newtarget, Position* mypos)
+{
+    if (CCed(me, true) || JumpingFlyingOrFalling())
+        return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || m_botCommandState == COMMAND_STAY) && !force)
+        return;
+    if (IsCasting())
+        return;
+    if (UpdateImpossibleChase(newtarget))
+        return;
+    bool ranged = !IsMelee();
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    if (ranged)
+    {
+        if (!force && newtarget->GetTypeId() == TYPEID_PLAYER &&
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3)) return;//do not allow constant runaway from player
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetDistance(attackpos) > (_botclass == BOT_CLASS_HUNTER ? 4 : 8))
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+    }
+    else if (!me->HasUnitState(UNIT_STATE_CHASE) || !me->HasUnitState(UNIT_STATE_CHASE_MOVE))
+        me->GetMotionMaster()->MoveChase(newtarget);
+
+    if (newtarget != me->GetVictim())
+        me->Attack(newtarget, !ranged);
+}
+
+void bot_ai::CheckAttackState()
+{
+    if (me->GetVictim())
+    {
+        if (HasRole(BOT_ROLE_DPS))
+            DoMeleeAttackIfReady();
+    }
+    else
+        Evade();
+}
+
+bool bot_ai::MoveBehind(Unit &target) const
+{
+    if (CCed(me, true)) return false;
+    if (JumpingFlyingOrFalling()) return false;
+    if (target.HasUnitState(UNIT_STATE_CASTING)) return false;
+    if (target.IsWithinCombatRange(me, ATTACK_DISTANCE) &&
+        target.HasInArc(M_PI, me)                       &&
+        !IsTank()                                       &&
+        (_botclass == BOT_CLASS_ROGUE ? target.GetVictim() != me || CCed(&target) : target.GetVictim() != me && !CCed(&target)))
+    {
+        float x(0),y(0),z(0);
+        target.GetNearPoint(me, x, y, z, me->GetObjectSize()/3, 0.1f, me->GetAngle(&target));
+        me->GetMotionMaster()->MovePoint(target.GetMapId(), x, y, z);
+        return true;
+    }
+    return false;
+}
+//MOUNT SUPPORT
+void bot_minion_ai::_updateMountedState()
+{
+    if (IAmFree())
+        return;
+    if (GetBotCommandState() != COMMAND_FOLLOW)
+        return;
+
+    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
+    bool mounted = me->IsMounted();
+
+    //allow dismount
+    if (!CanMount() && !aura && !mounted)
+        return;
+
+    if ((!master->IsMounted() || aura != mounted || (me->IsInCombat() && opponent)) && (aura || mounted))
+    {
+        const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType &= ~INHABIT_AIR;
+        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+        //me->RemoveUnitMovementFlag(MOVEMENTFLAG_HOVER);
+        me->SetCanFly(false);
+        me->SetDisableGravity(false);
+        me->RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING);
+        me->Dismount();
+        return;
+    }
+    if (me->IsInCombat() || IsCasting() || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING)) //IsInWater() is too much calculations
+        return;
+
+    if (master->IsMounted() && !me->IsMounted() && !master->IsInCombat() && !me->IsInCombat() && !me->GetVictim())
+    {
+        uint32 mount = 0;
+        Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        if (!mounts.empty())
+        {
+            //Winter Veil addition
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                mount = master->CanFly() ? REINDEER_FLY : REINDEER;
+            else
+                mount = mounts.front()->GetId();
+        }
+        if (mount)
+        {
+            if (me->HasAuraType(SPELL_AURA_MOUNTED))
+                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+            if (Feasting())
+            {
+                me->RemoveAurasDueToSpell(DRINK);
+                me->RemoveAurasDueToSpell(EAT);
+            }
+
+            if (!GetSpell(mount))
+                InitSpellMap(mount, true); //learn
+
+            if (doCast(me, mount))
+            {
+                return;
+            }
+        }
+    }
+}
+//STANDSTATE
+void bot_minion_ai::_updateStandState() const
+{
+    if (IAmFree())
+    {
+        //if (!(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED) && !me->IsStandState())
+        //    me->SetStandState(UNIT_STAND_STATE_STAND);
+        return;
+    }
+    if (master->getStandState() == UNIT_STAND_STATE_STAND &&
+        me->getStandState() == UNIT_STAND_STATE_SIT &&
+        !(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    if (CanSit() && !me->IsInCombat() && !me->isMoving() &&
+        (master->getStandState() == UNIT_STAND_STATE_SIT || (me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED) || Feasting()) &&
+        me->getStandState() == UNIT_STAND_STATE_STAND)
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+}
+//RATIONS
+void bot_minion_ai::_updateRations()
+{
+    bool noFeast = me->IsInCombat() || CCed(me);
+    if (noFeast || me->IsStandState())
+    {
+        if (feast_health)
+        {
+            feast_health = false;
+            me->RemoveAurasDueToSpell(EAT);
+        }
+        if (feast_mana)
+        {
+            feast_mana = false;
+            me->RemoveAurasDueToSpell(DRINK);
+        }
+
+        if (noFeast)
+            return;
+    }
+
+    //drink
+    if (!feast_mana && me->GetMaxPower(POWER_MANA) > 1 && !me->IsMounted() && !me->isMoving() && CanDrink() &&
+        !me->IsInCombat() && !IsCasting() && GetManaPCT(me) < 80 && urand(0, 100) < 20 &&
+        !me->HasAura(DRINK))
+    {
+        feast_mana = true;
+        mana_cd = 0;
+        me->CastSpell(me, DRINK);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (feast_mana)
+    {
+        mana_cd += lastdiff;
+        if (mana_cd >= RATIONS_CD && me->GetMaxPower(POWER_MANA) > 1 && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA) && me->HasAura(DRINK))
+        {
+            while (mana_cd >= RATIONS_CD)
+            {
+                mana_cd -= RATIONS_CD;
+                //25000 / 1000 = 25: 4%
+                //25000 / 2000 = 12: 8.5%
+                me->ModifyPower(POWER_MANA, me->GetMaxPower(POWER_MANA) / (25000 / RATIONS_CD)); //4% per second if 1000
+            }
+        }
+    }
+
+    //eat
+    if (!feast_health && !me->IsMounted() && !me->isMoving() && CanEat() &&
+        !me->IsInCombat() && !IsCasting() && GetHealthPCT(me) < 80 && urand(0, 100) < 20 &&
+        !me->HasAura(EAT))
+    {
+        feast_health = true;
+        health_cd = 0;
+        me->CastSpell(me, EAT);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (feast_health)
+    {
+        health_cd += lastdiff;
+        if (health_cd >= RATIONS_CD && me->GetHealth() < me->GetMaxHealth() && me->HasAura(EAT))
+        {
+            while (health_cd >= RATIONS_CD)
+            {
+                health_cd -= RATIONS_CD;
+                //20000 / 1000 = 20: 5%
+                //20000 / 2000 = 10: 10%
+                me->SetHealth(me->GetHealth() + me->GetMaxHealth() / (20000 / RATIONS_CD)); //5% per second if 1000
+            }
+        }
+    }
+
+    //check
+    if (feast_mana && me->GetMaxPower(POWER_MANA) > 1 && me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA))
+    {
+        feast_mana = false;
+        me->RemoveAurasDueToSpell(DRINK);
+    }
+    if (feast_health && me->GetHealth() >= me->GetMaxHealth())
+    {
+        feast_health = false;
+        me->RemoveAurasDueToSpell(EAT);
+    }
+}
+
+void bot_minion_ai::Regenerate()
+{
+    if ((!me->IsInCombat() || me->IsPolymorphed()) && me->GetHealth() < me->GetMaxHealth())
+    {
+        regenTimer_hp += lastdiff;
+        while (regenTimer_hp >= 2000)
+        {
+            regenTimer_hp -= 2000;
+            int32 add = me->IsPolymorphed() ? me->GetMaxHealth() / 3 : IAmFree() ? me->GetMaxHealth() / 5 : me->GetCreateHealth() / 50 + me->getLevel() / 3;
+            me->SetHealth(me->GetHealth() + add);
+        }
+    }
+
+    if (me->GetMaxPower(POWER_MANA) > 1 && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA))
+    {
+        regenTimer_mp += lastdiff;
+        while (regenTimer_mp >= 5000)
+        {
+            regenTimer_mp -= 5000;
+            int32 add = (!me->IsInCombat() && IAmFree()) ? me->GetMaxPower(POWER_MANA) / 5 : int32(regen_mp);
+            me->ModifyPower(POWER_MANA, add);
+        }
+    }
+}
+void bot_pet_ai::Regenerate()
+{
+    if (!regenTimer_hp && (!me->IsInCombat() || me->IsPolymorphed()) && me->GetHealth() < me->GetMaxHealth())
+    {
+        regenTimer_hp = 2000;
+        int32 add = me->IsPolymorphed() ? me->GetMaxHealth() / 3 : me->GetCreateHealth() / 33 + me->getLevel() / 3;
+        me->SetHealth(me->GetHealth() + add);
+    }
+
+    if (!regenTimer_mp && me->GetMaxPower(POWER_MANA) > 1 && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA))
+    {
+        regenTimer_mp = 5000;
+        me->ModifyPower(POWER_MANA, regen_mp); //mp5
+    }
+}
+//PASSIVES
+// Used to apply common passives (run once)
+void bot_ai::ApplyPassives() const
+{
+    //me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+    //me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+    ////DEPRECATEDmovement speed
+    //if (master->HasAuraType(SPELL_AURA_MOD_SPEED_ALWAYS) ||
+    //    master->HasAuraType(SPELL_AURA_MOD_SPEED_NOT_STACK) ||
+    //    master->HasAuraType(SPELL_AURA_MOD_INCREASE_SPEED))
+    //    RefreshAura(BOAR);
+
+    ////apply +healing taken
+    //RefreshAura(BOR, me->getLevel() >= 40 ? 1 : 0);//+40%
+
+    //if (IsTempBot())
+    //    return;
+
+    if (IsMinionAI())
+    {
+        //apply -threat mod
+        switch (_botclass)
+        {
+            case BOT_CLASS_WARRIOR:
+            case BOT_CLASS_DEATH_KNIGHT:
+                RefreshAura(RCP, 1 * !IsTank()); //-27%
+                break;
+            case BOT_CLASS_WARLOCK:
+            case BOT_CLASS_PRIEST:
+            case BOT_CLASS_MAGE:
+            case BOT_CLASS_ROGUE:
+            case BOT_CLASS_HUNTER:
+            case BOT_CLASS_SHAMAN:
+                RefreshAura(RCP, 3 * !IsTank()); //-87%
+                break;
+            case CLASS_PALADIN:
+            case CLASS_DRUID:
+            case BOT_CLASS_BM:
+                RefreshAura(RCP, 2 * !IsTank()); //-54%
+                break;
+            default:
+                TC_LOG_ERROR("entities.player", "bot_ai: ApplyPassives() - unknown bot class %u for bot %s (id: %u)",
+                    uint32(_botclass), me->GetName().c_str(), me->GetEntry());
+                break;
+        }
+        //apply +threat mods (1.43 * 1.45 = 2.0735; 1.0 + 0.43 + 0.45 = 1.88)
+        RefreshAura(THREAT, 1 * IsTank()); //+43%
+        RefreshAura(DEFENSIVE_STANCE_PASSIVE, 1 * IsTank()); //+45%
+    }
+    else
+    {
+        switch (bot_pet_ai::GetPetType(me))
+        {
+            case PET_TYPE_VOIDWALKER:
+                break;
+            default:
+                TC_LOG_ERROR("entities.player", "bot_ai: ApplyPassives() - unknown pet type %u for bot %s (id: %u)",
+                    uint32(bot_pet_ai::GetPetType(me)), me->GetName().c_str(), me->GetEntry());
+                break;
+        }
+
+        RefreshAura(THREAT, 1 * IsTank()); //+43%
+        RefreshAura(DEFENSIVE_STANCE_PASSIVE, 2 * IsTank()); //+90%/-20%
+    }
+}
+//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
+bool bot_ai::InDuel(Unit const* target) const
+{
+    if (!target) return false;
+    bool isbot = target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->GetBotAI();
+    Player const* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : isbot ? target->ToCreature()->GetBotOwner()->ToPlayer() : NULL;
+    if (!player)
+    {
+        if (!target->IsControlledByPlayer())
+            return false;
+        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
+    }
+
+    return (player && player->duel && (IsInBotParty(player) || IsInBotParty(player->duel->opponent)));
+}
+////////////////
+//GRID SEARCHERS
+////////////////
+//Finds player or it's corpse for resurrection returned as WorldObject*
+WorldObject* bot_minion_ai::GetNearbyRezTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    WorldObject* target = NULL;
+
+    NearbyRezTargetCheck check(me, dist, this);
+    Trinity::WorldObjectSearcher <NearbyRezTargetCheck> searcher(me, target, check);
+
+    TypeContainerVisitor<Trinity::WorldObjectSearcher <NearbyRezTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+
+    return target;
+}
+//Used to find target for priest's dispels, mage's spellsteal and shaman's purge
+//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
+Unit* bot_minion_ai::FindHostileDispelTarget(float dist, bool stealable) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    HostileDispelTargetCheck check(me, dist, stealable, this);
+    Trinity::UnitLastSearcher <HostileDispelTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds single target affected by given spell (and given caster if is)
+//Can check:
+//    hostile targets  (hostile = 0) <default>
+//    our party players (hostile = 1)
+//    our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any target in range  (hostile = any other value)
+Unit* bot_minion_ai::FindAffectedTarget(uint32 spellId, uint64 caster, float dist, uint8 hostile) const
+{
+    if (!spellId)
+        return NULL;
+    if ((hostile == 2 || hostile == 1) && IAmFree())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::FindAffectedTarget(): hostile = %u while bot is free! Setting to 3...", hostile);
+        hostile = 3;
+    }
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    CellCoord p(Trinity::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
+    Trinity::UnitLastSearcher <AffectedTargetCheck> searcher(master, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
+
+    return unit;
+}
+//Finds target for mage's polymorph or shaman's hex
+Unit* bot_minion_ai::FindPolyTarget(float dist, Unit* currTarget) const
+{
+    if (!currTarget)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    PolyUnitCheck check(me, dist, currTarget);
+    Trinity::UnitLastSearcher <PolyUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for direct fear (warlock)
+Unit* bot_minion_ai::FindFearTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    FearUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <FearUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for paladin's repentance
+Unit* bot_minion_ai::FindStunTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    StunUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <StunUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for priest's shackles
+Unit* bot_minion_ai::FindUndeadCCTarget(float dist, uint32 spellId/* = 0*/) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    UndeadCCUnitCheck check(me, dist, spellId);
+    Trinity::UnitLastSearcher <UndeadCCUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for druid's Entangling Roots
+Unit* bot_minion_ai::FindRootTarget(float dist, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    RootUnitCheck check(me, me->GetVictim(), dist, spellId);
+    Trinity::UnitLastSearcher <RootUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds casting target (friend or enemy)
+Unit* bot_minion_ai::FindCastingTarget(float maxdist, float mindist, bool isFriend, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    CastingUnitCheck check(me, mindist, maxdist, isFriend, spellId);
+    Trinity::UnitLastSearcher <CastingUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+
+    return unit;
+}
+// Returns target for AOE spell (blizzard, hurricane etc.) based on attackers count
+// Cycles through BotParty, first checks player and, if checked, npcbots
+// If checked, can return friendly target as target for AOE spell
+Unit* bot_minion_ai::FindAOETarget(float dist, bool checkbots, bool targetfriend) const
+{
+    if (IsCasting() || IAmFree())
+        return NULL;
+
+    Unit* unit = NULL;
+    Group* pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        AttackerSet m_attackers = master->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || !(*iter)->IsAlive()) continue;
+                if ((*iter)->isMoving()) continue;
+                if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                    continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = master->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = master;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (!checkbots)
+            return unit;
+        BotMap const* map = master->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Creature* bot = itr->second;
+            if (!bot || !bot->IsAlive() || !bot->IsInWorld() || me->GetDistance(bot) > dist) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || !(*iter)->IsAlive()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                        continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+            if (unit) return unit;
+        }//end for
+        return unit;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (!tPlayer) continue;
+        if (checkbots && tPlayer->HaveBot())
+            Bots = true;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
+        if (me->GetDistance(tPlayer) > 40) continue;
+
+        AttackerSet m_attackers = tPlayer->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || !(*iter)->IsAlive()) continue;
+                if ((*iter)->isMoving()) continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = tPlayer->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = tPlayer;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (unit) return unit;
+    }//end for
+    if (!Bots) return NULL;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+        {
+            Creature* bot = it->second;
+            if (!bot || !bot->IsAlive() || me->GetMap() != bot->FindMap()) continue;
+            if (!bot->IsInWorld()) continue;
+            if (me->GetDistance(bot) > 40) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || !(*iter)->IsAlive()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+        }//end for
+        if (unit) return unit;
+    }//end for
+    return unit;
+}
+// Finds secondary target for spells like Cleave, Swipe, Mind Sear etc.
+Unit* bot_minion_ai::FindSplashTarget(float dist, Unit* To, float splashdist) const
+{
+    if (!To)
+        To = me->GetVictim();
+    if (!To)
+        return NULL;
+
+    if (me->GetDistance(To) > dist)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    SecondEnemyCheck check(me, dist, splashdist, To, this);
+    Trinity::UnitLastSearcher <SecondEnemyCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for hunter's Tranquilizing Shot (has dispellable magic or enrage effect)
+Unit* bot_minion_ai::FindTranquilTarget(float mindist, float maxdist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    TranquilTargetCheck check(me, mindist, maxdist, this);
+    Trinity::UnitLastSearcher <TranquilTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <TranquilTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <TranquilTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+
+    return unit;
+}
+//Finds all targets within given range with option for not having CC breaking auras
+//used for finding targets for spells which need reasonable amount of targets (ex. Death Knight AOE spells)
+void bot_minion_ai::GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, float mindist, bool forCC) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    NearbyHostileUnitCheck check(me, maxdist, mindist, this, forCC);
+    Trinity::UnitListSearcher <NearbyHostileUnitCheck> searcher(me, targets, check);
+
+    TypeContainerVisitor<Trinity::UnitListSearcher <NearbyHostileUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitListSearcher <NearbyHostileUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+}
+//Finds all friendly targets within given range
+//used for finding targets to heal/buff for uncontrolled bots
+void bot_minion_ai::GetNearbyFriendlyTargetsList(std::list<uint64> &targets, float maxdist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    NearbyFriendlyUnitCheck check(me, maxdist, this);
+    UnitListSearcher <NearbyFriendlyUnitCheck> searcher(me, targets, check);
+
+    TypeContainerVisitor<UnitListSearcher <NearbyFriendlyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<UnitListSearcher <NearbyFriendlyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+}
+//////////
+//SPELLMAP
+//////////
+//Using first-rank spell as source, returns spell of max rank allowed for given caster
+uint32 bot_ai::InitSpell(Unit const* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "InitSpell(): No SpellInfo found for spell %u", spell);
+        return 0; //weird spell with no info, disable it
+    }
+
+    uint8 lvl = caster->getLevel();
+    if (lvl < info->BaseLevel) //only 1st rank spells check
+        return 0; //cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell; //cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id); //can use next rank, forward check
+    }
+
+    return spell; //max rank, use this
+}
+//Using first-rank spell as source, returns spell of max rank allowed for given caster in given spellmap
+void bot_ai::InitSpellMap(uint32 basespell, bool forceadd, bool forwardRank)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(basespell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "InitSpellMap(): No SpellInfo found for base spell %u", basespell);
+        return; //invalid spell id
+    }
+
+    uint8 lvl = me->getLevel();
+    uint32 spellId = 0;
+
+    while (info != NULL && forwardRank && (forceadd || lvl >= info->BaseLevel))
+    {
+        spellId = info->Id; //can use this spell
+        info = info->GetNextRankSpell(); //check next rank
+    }
+
+    BotSpell newSpell;
+    newSpell.first = spellId;
+    newSpell.second = GetSpellCooldown(basespell);
+    spells[basespell] = newSpell;
+}
+//Using first-rank spell as source, return current spell id
+uint32 bot_ai::GetSpell(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+    return itr != spells.end() ? itr->second.first : 0;
+}
+//Using first-rank spell as source, returns cooldown on current spell
+uint32 bot_ai::GetSpellCooldown(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+    return itr != spells.end() ? itr->second.second : 0;
+}
+bool bot_ai::IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD, uint32 forcedTime) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+
+    if (itr != spells.end())
+    {
+        return
+        (itr->second.first != 0 &&
+        (!checkGCD || GC_Timer <= diff) &&
+        itr->second.second <= (forcedTime ? forcedTime : diff));
+    }
+
+    return false;
+}
+//Using first-rank spell as source, sets cooldown for current spell
+void bot_ai::SetSpellCooldown(uint32 basespell, uint32 msCooldown)
+{
+    //if (!msCooldown)
+    //    return;
+
+    BotSpellMap::iterator itr = spells.find(basespell);
+    if (itr != spells.end())
+    {
+        itr->second.second = msCooldown;
+        return;
+    }
+
+    InitSpellMap(basespell, true, false);
+
+    if (!GetSpell(basespell))
+        return;
+
+    SetSpellCooldown(basespell, msCooldown);
+}
+//Using first-rank spell as source, sets cooldown for spells of that category
+void bot_ai::SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown)
+{
+    if (!msCooldown)
+        return;
+
+    uint32 category = spellInfo->GetCategory();
+    if (!category)
+        return;
+
+    SpellInfo const* info;
+    for (BotSpellMap::iterator itr = spells.begin(); itr != spells.end(); ++itr)
+    {
+        //skip spell which has triggered this category cooldown
+        if (itr->second.first == spellInfo->Id && itr->second.second >= msCooldown)
+            continue;
+
+        info = sSpellMgr->GetSpellInfo(itr->second.first);
+        if (info && info->GetCategory() == category && itr->second.second < msCooldown)
+            itr->second.second = msCooldown;
+    }
+}
+//Using first-rank spell as source, disables certain spell for this bot
+void bot_ai::RemoveSpell(uint32 basespell)
+{
+    BotSpellMap::iterator itr = spells.find(basespell);
+    if (itr != spells.end())
+    {
+        itr->second.first = 0;
+        itr->second.second = 0; //unneeded
+    }
+}
+//Look in Creature::Update() for common timers
+void bot_ai::SpellTimers(uint32 diff)
+{
+    // spell must be initialized!!!
+    for (BotSpellMap::iterator itr = spells.begin(); itr != spells.end(); ++itr)
+    {
+        if (itr->second.second > diff)
+            itr->second.second -= diff;
+        else if (itr->second.second > 0)
+            itr->second.second = 0;
+    }
+}
+//Health magement for minions
+//Including health calcs, set
+void bot_minion_ai::_OnHealthUpdate() const
+{
+    if (IsTempBot())
+        return;
+
+    uint8 myclass = _botclass;
+    uint8 mylevel = master->getLevel();
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+    //TC_LOG_ERROR("entities.player", "_OnHealthUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = me->GetHealthPct(); // needs for regeneration
+    uint32 m_basehp = _classinfo->basehealth;
+    //TC_LOG_ERROR("entities.player", "class base health: %u", m_basehp);
+    me->SetCreateHealth(m_basehp);
+
+    float stamValue = std::max(me->GetTotalStatValue(STAT_STAMINA) - 18.f, 1.f); //remove base stamina (not calculated into health)
+    stamValue += _getTotalBotStat(BOT_ITEM_MOD_STAMINA);
+
+    //class-specified
+    if (GetPlayerClass() == BOT_CLASS_DRUID && myclass == DRUID_BEAR_FORM)
+    {
+        //Heart of the Wild: 10% stam bonus for bear
+        if (mylevel >= 35)
+            stamValue *= 1.1f;
+    }
+
+    //TC_LOG_ERROR("entities.player", "bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
+    int32 hp_add = int32(stamValue) * 10;
+    hp_add += IAmFree() ? mylevel * 250.f : 0; //+20000/+0 hp at 80
+    hp_add += _getTotalBotStat(BOT_ITEM_MOD_HEALTH);
+    int32 miscVal = mylevel * 3 - 1;
+    hp_add += miscVal;
+    //TC_LOG_ERROR("entities.player", "health to add after slot mod: %i", hp_add);
+    uint32 m_totalhp = m_basehp + hp_add; //m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
+    //TC_LOG_ERROR("entities.player", "total base health: %u", m_totalhp);
+    uint8 bonuspct = 0;
+    //bonuspct += 35 * IsTank();
+    bonuspct += 8 * (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE);
+    if (bonuspct)
+        m_totalhp = (m_totalhp * (100 + bonuspct)) / 100;
+    m_totalhp = float(uint32(m_totalhp) + (10 - (uint32(m_totalhp) % 10)));
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp)); //replaces base hp at max lvl
+    me->UpdateMaxHealth(); //will use our values we just set (update base health and buffs)
+    //TC_LOG_ERROR("entities.player", "overall hp: %u", me->GetMaxHealth());
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+}
+//Mana management for minions
+//Including calcs and set
+void bot_minion_ai::_OnManaUpdate(bool /*shapeshift*/)
+{
+    if (me->GetMaxPower(POWER_MANA) <= 1)
+        return;
+
+    if (IsTempBot())
+        return;
+
+    uint8 myclass = _botclass;
+    uint8 mylevel = master->getLevel();
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+
+    //TC_LOG_ERROR("entities.player", "_OnManaUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = me->GetMaxPower(POWER_MANA) == 0 ? 100 : (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = _classinfo->basemana;
+    if (myclass == BOT_CLASS_BM)
+        m_basemana = std::max<int32>(240 + (int32(mylevel - 20) * 5) - 225, 255); // 240 at 1, 540 at 81
+    //TC_LOG_ERROR("entities.player", "classinfo base mana = %f", m_basemana);
+
+    //decrease base mana for bots (allows using more mana)
+    me->SetCreateMana(uint32(m_basemana * 0.667f)); //set base mana, critical
+
+    float intValue = me->GetTotalStatValue(STAT_INTELLECT) - 18.f; //remove base int (not calculated into mana)
+    intValue += _getTotalBotStat(BOT_ITEM_MOD_INTELLECT);
+    m_basemana += intValue * 15.0f;
+    m_basemana += IAmFree() ? mylevel * 125.f : 0; //+10000/+0 mana at 80
+    m_basemana += _getTotalBotStat(BOT_ITEM_MOD_MANA);
+    m_basemana = float(uint32(m_basemana) - (uint32(m_basemana) % 5));
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f)); //restore pct
+}
+//Melee damage for minions (melee classes only)
+//Calculation is based on master's attack power if melee/hunter or spellpower
+void bot_minion_ai::_OnMeleeDamageUpdate(uint8 myclass) const
+{
+    if (IsTempBot())
+        return;
+
+    if (ap_mod < 0.1f) return; //do not bother casters
+    //TC_LOG_ERROR("entities.player", "_OnMeleeDamageUpdate: Updating bot %s", me->GetName().c_str());
+
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+    {
+        float weap_damage_base = _getBotStat(i, BOT_ITEM_MOD_DAMAGE);
+        weap_damage_base += IAmFree() ? me->getLevel() * 3.75f : 0; //+300/+20 dam at 80
+        me->SetModifierValue(UnitMods(UNIT_MOD_DAMAGE_MAINHAND + i), BASE_VALUE, _getBotStat(i, BOT_ITEM_MOD_DAMAGE));
+    }
+
+    float atpower = IAmFree() ? me->getLevel() * 75.f : std::max(me->getLevel() - 40.f, 0.f) * 10.f; //+6000/+400 base ap at 80
+    atpower += _getTotalBotStat(BOT_ITEM_MOD_ATTACK_POWER) + _getTotalBotStat(BOT_ITEM_MOD_RANGED_ATTACK_POWER);
+    atpower += 2.f * ((me->GetTotalStatValue(STAT_STRENGTH) - 18) + (me->GetTotalStatValue(STAT_AGILITY) - 18));
+    atpower += 2.f * (_getTotalBotStat(BOT_ITEM_MOD_STRENGTH) + _getTotalBotStat(BOT_ITEM_MOD_AGILITY));
+
+    Unit::AuraEffectList const& mAPbyStat = me->GetAuraEffectsByType(SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT);
+    for (Unit::AuraEffectList::const_iterator i = mAPbyStat.begin(); i != mAPbyStat.end(); ++i)
+        atpower += CalculatePct(me->GetStat(Stats((*i)->GetMiscValue())), (*i)->GetAmount());
+
+    Unit::AuraEffectList const& mAPbyArmor = me->GetAuraEffectsByType(SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR);
+    for (Unit::AuraEffectList::const_iterator iter = mAPbyArmor.begin(); iter != mAPbyArmor.end(); ++iter)
+        atpower += int32(me->GetArmor() / (*iter)->GetAmount());
+
+    if (GetPlayerClass() == CLASS_DRUID && (GetBotStance() == DRUID_BEAR_FORM || GetBotStance() == DRUID_CAT_FORM))
+    {
+        atpower += _getTotalBotStat(BOT_ITEM_MOD_FERAL_ATTACK_POWER);
+        //Predatory Strikes
+        if (me->getLevel() >= 25)
+        {
+            atpower += me->getLevel() * 2 / 3;
+            atpower += 0.2f * (
+                _getBotStat(BOT_SLOT_MAINHAND, BOT_ITEM_MOD_FERAL_ATTACK_POWER)
+                + _getBotStat(BOT_SLOT_MAINHAND, BOT_ITEM_MOD_ATTACK_POWER)
+                + _getBotStat(BOT_SLOT_MAINHAND, BOT_ITEM_MOD_RANGED_ATTACK_POWER)
+                );
+        }
+    }
+
+    atpower *= ap_mod;
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+    me->UpdateAttackPowerAndDamage();
+    if (myclass == BOT_CLASS_HUNTER || myclass == BOT_CLASS_ROGUE)
+    {
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage(true);
+    }
+}
+//Health for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnHealthUpdate() const
+{
+    uint8 mylevel = master->getLevel();
+    float hp_mult;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:   hp_mult = 11.f; break;
+        default:                    hp_mult = 10.f; break;
+    }
+    float pct = me->GetHealthPct();
+    uint32 m_basehp = me->GetCreateHealth();
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA) - 18.f; //remove base stamina (not calculated into health)
+    uint32 hp_add = uint32(stamValue * hp_mult);
+    hp_add += (m_creatureOwner->GetMaxHealth() - m_creatureOwner->GetCreateHealth()) / 3;
+    uint8 miscVal = GetPetType(me) * mylevel;
+    hp_add += miscVal;
+    uint32 m_totalhp = m_basehp + hp_add;
+    if (IsTank())
+        m_totalhp = (m_totalhp * 135) / 100; //35% hp bonus for tanks
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));
+    me->UpdateMaxHealth(); //will use values set (update base health and buffs)
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+}
+//Mana for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnManaUpdate(bool /*shapeshift*/)
+{
+    if (me->GetMaxPower(POWER_MANA) <= 1)
+        return;
+
+    uint8 mylevel = m_creatureOwner->getLevel();
+    float mana_mult;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:   mana_mult = 11.5f;  break;
+        default:                    mana_mult = 15.f;   break;
+    }
+    float pct = me->GetMaxPower(POWER_MANA) == 0 ? 100 : (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = float(me->GetCreateMana());
+    m_basemana += me->GetTotalStatValue(STAT_INTELLECT) * mana_mult; //remove base stamina (not calculated into mana)
+    m_basemana += (m_creatureOwner->GetMaxPower(POWER_MANA) - m_creatureOwner->GetCreateMana()) / 3;
+    m_basemana += (GetPetType(me) * mylevel);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f));//restore pct
+}
+//Sends all master's bots a message to not try to evade for a certain period of time
+//void bot_ai::SendPartyEvadeAbort() const
+//{
+//    ASSERT(!IAmFree());
+//
+//    BotMap const* map = master->GetBotMgr()->GetBotMap();
+//    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+//        if (Creature* bot = itr->second)
+//            if (bot_minion_ai* ai = bot->GetBotMinionAI())
+//                ai->SetEvadeTimer(50);
+//}
+//Removes buggy bots' threat from party, so no 'stuck in combat' bugs form bot mod
+//optionally interrupts casted spell if target is dead for bot and it's pet
+void bot_minion_ai::Evade(bool force)
+{
+    if (me->HasUnitState(UNIT_STATE_CASTING))
+    {
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = me->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (!u->IsAlive() && !IsInBotParty(u))
+                            me->InterruptSpell(CurrentSpellTypes(i), false, false);
+    }
+
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet && m_botsPet->HasUnitState(UNIT_STATE_CASTING))
+    {
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = m_botsPet->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (!u->IsAlive() && !IsInBotParty(u))
+                            m_botsPet->InterruptSpell(CurrentSpellTypes(i), false, false);
+    }
+
+    if (CCed(me)) return;
+    if (!force && Rand() > 10) return;
+    EnterEvadeMode(force);
+    if (!force && !master->IsInCombat() && !me->IsInCombat() && (!m_botsPet || !m_botsPet->IsInCombat())) return;
+    if (!force && CheckAttackTarget(_botclass)) return;
+
+    if (master->IsInCombat() && !IAmFree())
+    {
+        if (!master->getHostileRefManager().isEmpty())
+        {
+            std::set<uint64> Set;
+            HostileReference* ref = master->getHostileRefManager().getFirst();
+            while (ref)
+            {
+                Set.insert(ref->GetSource()->GetOwner()->GetGUID());
+                Set.insert(ref->getUnitGuid());
+                ref = ref->next();
+            }
+            for (std::set<uint64>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+            {
+                Unit* unit = sObjectAccessor->FindUnit(*i);
+                if (unit && (unit->IsFriendlyTo(me) || IsInBotParty(unit) || !unit->IsInCombat()))
+                {
+                    master->getHostileRefManager().deleteReference(unit);
+                    //unit->getHostileRefManager().deleteReference(master);
+                }
+            }
+        }
+
+        return;
+    }
+
+    if (!master->IsInCombat() || IAmFree())
+    {
+        if (IAmFree())
+        {
+            //me->DeleteThreatList();
+            if (!me->getHostileRefManager().isEmpty())
+            {
+                std::set<uint64> Set;
+                HostileReference* ref = me->getHostileRefManager().getFirst();
+                while (ref)
+                {
+                    Set.insert(ref->GetSource()->GetOwner()->GetGUID());
+                    Set.insert(ref->getUnitGuid());
+                    ref = ref->next();
+                }
+                for (std::set<uint64>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                {
+                    Unit* unit = sObjectAccessor->FindUnit(*i);
+                    if (!unit || !unit->InSamePhase(me)) continue;
+                    if (unit->IsFriendlyTo(me) || IsInBotParty(unit) || !unit->IsInCombat())
+                    {
+                        me->getHostileRefManager().deleteReference(unit);
+                        //unit->getHostileRefManager().deleteReference(me);
+                    }
+                }
+            }
+            if (Creature* m_botsPet = me->GetBotsPet())
+            {
+                //m_botsPet->DeleteThreatList();
+                if (!m_botsPet->getHostileRefManager().isEmpty())
+                {
+                    std::set<uint64> Set;
+                    HostileReference* ref = m_botsPet->getHostileRefManager().getFirst();
+                    while (ref)
+                    {
+                        Set.insert(ref->GetSource()->GetOwner()->GetGUID());
+                        Set.insert(ref->getUnitGuid());
+                        ref = ref->next();
+                    }
+                    for (std::set<uint64>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                    {
+                        Unit* unit = sObjectAccessor->FindUnit(*i);
+                        if (!unit || !unit->InSamePhase(me)) continue;
+                        if (unit->IsFriendlyTo(me) || IsInBotParty(unit) || !unit->IsInCombat())
+                        {
+                            m_botsPet->getHostileRefManager().deleteReference(unit);
+                            //unit->getHostileRefManager().deleteReference(m_botsPet);
+                        }
+                    }
+                }
+            }
+
+            return;
+        }
+        //SendPartyEvadeAbort();
+        BotMap const* map = master->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+        {
+            Creature* cre = it->second;
+            if (!cre) continue;
+            if (cre->IsInCombat())
+            {
+                //cre->DeleteThreatList();
+                if (!cre->getHostileRefManager().isEmpty())
+                {
+                    std::set<uint64> Set;
+                    HostileReference* ref = cre->getHostileRefManager().getFirst();
+                    while (ref)
+                    {
+                        Set.insert(ref->GetSource()->GetOwner()->GetGUID());
+                        Set.insert(ref->getUnitGuid());
+                        ref = ref->next();
+                    }
+                    for (std::set<uint64>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                    {
+                        Unit* unit = sObjectAccessor->FindUnit(*i);
+                        if (!unit || !unit->InSamePhase(me)) continue;
+                        if (unit->IsFriendlyTo(me) || IsInBotParty(unit) || !unit->IsInCombat())
+                        {
+                            cre->getHostileRefManager().deleteReference(unit);
+                            //unit->getHostileRefManager().deleteReference(cre);
+                        }
+                    }
+                }
+            }
+
+            Creature* m_botsPet = cre->GetBotsPet();
+            if (!m_botsPet || !m_botsPet->IsInCombat()) continue;
+            //m_botsPet->DeleteThreatList();
+            if (!m_botsPet->getHostileRefManager().isEmpty())
+            {
+                std::set<uint64> Set;
+                HostileReference* ref = m_botsPet->getHostileRefManager().getFirst();
+                while (ref)
+                {
+                    Set.insert(ref->GetSource()->GetOwner()->GetGUID());
+                    Set.insert(ref->getUnitGuid());
+                    ref = ref->next();
+                }
+                for (std::set<uint64>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                {
+                    Unit* unit = sObjectAccessor->FindUnit(*i);
+                    if (!unit || !unit->InSamePhase(me)) continue;
+                    if (unit->IsFriendlyTo(me) || IsInBotParty(unit) || !unit->IsInCombat())
+                    {
+                        m_botsPet->getHostileRefManager().deleteReference(unit);
+                        //unit->getHostileRefManager().deleteReference(m_botsPet);
+                    }
+                }
+            }
+        }
+    }
+}
+//SpellHit()... OnSpellHit()
+void bot_ai::OnSpellHit(Unit* caster, SpellInfo const* spell)
+{
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 auraname = spell->Effects[i].ApplyAuraName;
+        //remove pet on mount
+        if (auraname == SPELL_AURA_MOUNTED)
+        {
+            me->SetBotsPetDied();
+            if (master->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED) ||
+                master->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+            {
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType |= INHABIT_AIR;
+                //me->AddUnitMovementFlag(MOVEMENTFLAG_HOVER);
+                me->SetCanFly(true);
+                me->SetDisableGravity(true);
+                me->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+                me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+            }
+            else
+                me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_RUN) * 1.25f);
+        }
+
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT || auraname == SPELL_AURA_MOD_PERCENT_STAT ||
+            auraname == SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE || auraname == SPELL_AURA_MOD_SKILL ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER || auraname == SPELL_AURA_MOD_ATTACK_POWER_PCT ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT || auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR ||
+            auraname == SPELL_AURA_MOD_RATING/* || auraname == SPELL_AURA_MOD_RATING_FROM_STAT*/) //NYI TODO:
+        {
+            shouldUpdateStats = true;
+        }
+        else
+        {
+            if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH ||
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 ||
+                auraname == SPELL_AURA_230 ||//SPELL_AURA_MOD_INCREASE_HEALTH_2
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+                doHealth = true;
+            else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY ||
+                auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+                doMana = true;
+        }
+    }
+
+    //TODO:
+    if (/*!(spell->AttributesEx & SPELL_ATTR1_NO_THREAT) &&
+        !(spell->AttributesEx3 & SPELL_ATTR3_NO_INITIAL_AGGRO) &&*/
+        IsMinionAI() && /*!CCed(me) && */(me->IsHostileTo(caster) || caster->IsHostileTo(me)))
+    {
+        //_atHome = false;
+        if (!me->CanSeeOrDetect(caster))
+        {
+            if (_evadeMode)
+                me->BotStopMovement();
+        }
+        else if (caster->IsInCombat() || me->IsInCombat())
+            this->OwnerAttackedBy(caster);
+        //if (_evadeMode == true && me->isMoving() && IAmFree())
+    }
+}
+//Messed up
+//Hp + Mana update
+//target update
+//returns fake wait time between overall AI updates (if it is even understandable)
+uint8 bot_ai::GetWait()
+{
+    if (doHealth)
+    {
+        doHealth = false;
+        _OnHealthUpdate();
+    }
+    if (doMana)
+    {
+        doMana = false;
+        _OnManaUpdate();
+    }
+    CheckAuras(true);
+    FindMaster();
+    //SavePosition();
+    //0 to 2 plus 1 for every 3 bots except first one
+    return IAmFree() ? 3 : (1 + (master->GetNpcBotsCount() - 1)/3 + (irand(0,100) <= 50)*int8(RAND(-1,1)));
+}
+//Damage/Healing Mods
+//1) Apply class-specified damage/healing/crit chance/crit damage/crit healing bonuses
+//2) Apply bot damage/healing multipliers
+//Bug with config reload (creatures do not update their damage on reload) is not bot-related but still annoying
+void bot_ai::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    //WHITE ATTACKS damage bonus
+    ApplyClassDamageMultiplierMelee(damage, damageinfo);
+    damage = uint32(damage * _mult_dmg_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    //MELEE ABILITIES damage/crit bonus
+    ApplyClassDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(damage * _mult_dmg_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    //DAMAGE SPELLS damage/crit bonus
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(damage * _mult_dmg_spell);
+}
+void bot_ai::ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+{
+    //HEALING SPELLS amount bonus
+    ApplyClassDamageMultiplierHeal(victim, heal, spellInfo, damagetype, stack);
+    heal = (heal * _mult_healing);
+}
+void bot_ai::ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    //ALL SPELLS crit base
+    //for base use bot_ai::crit, for healing spells crit bonus use class specified func
+    //bonuses for damage spells are handled in ApplyBotDamageMultiplierSpell()
+    ApplyClassCritMultiplierHeal(victim, crit_chance, spellInfo, schoolMask, attackType);
+    crit_chance += crit;
+}
+void bot_ai::ApplyBotSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+{
+    //ALL SPELLS power cost bonus
+    ApplyClassSpellCostMods(spellInfo, cost);
+}
+void bot_ai::ApplyBotSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+{
+    //ALL SPELLS cast time bonus
+    ApplyClassSpellCastTimeMods(spellInfo, casttime);
+}
+void bot_ai::ApplyBotSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+{
+    //ALL SPELLS cooldown bonus
+    ApplyClassSpellCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+{
+    //ALL SPELLS category cooldown bonus
+    ApplyClassSpellCategoryCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+{
+    //ALL SPELLS global cooldown bonus
+    ApplyClassSpellGlobalCooldownMods(spellInfo, cooldown);
+}
+//////////
+//GOSSIP//
+//////////
+//GossipHello (static)
+bool bot_minion_ai::OnGossipHello(Player* player, Creature* creature, uint32 /*option*/)
+{
+    ASSERT(player);
+    ASSERT(creature);
+
+    if (!_enableNpcBots || creature->IsInCombat() || bot_ai::CCed(creature) || creature->GetBotAI()->IsDuringTeleport())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    if (creature->GetBotAI()->IsTempBot()) //Blademaster illusion etc.
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    if (creature->isMoving())
+        creature->StopMoving();
+
+    uint32 gossipTextId = (player->GetGUIDLow() == creature->GetBotAI()->GetBotOwnerGuid() || !creature->GetBotAI()->IAmFree()) ? GOSSIP_SERVE_MASTER : GOSSIP_NEED_SMTH;
+
+    bool menus = false;
+
+    if (player->IsGameMaster() &&
+        (creature->IsFreeBot() || player->GetGUIDLow() != creature->GetBotAI()->GetBotOwnerGuid()))
+    {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Debug>", GOSSIP_SENDER_DEBUG, GOSSIP_ACTION_INFO_DEF + 1);
+        menus = true;
+    }
+
+    if (player->GetGUIDLow() != creature->GetBotAI()->GetBotOwnerGuid())
+    {
+        if (creature->IsFreeBot() && !player->IsGameMaster())
+        {
+            uint32 cost = BotMgr::GetNpcBotCost(player->getLevel(), creature);
+
+            int8 reason = 0;
+            if (creature->IsHostileTo(player) || player->IsHostileTo(creature) ||
+                creature->HasAura(BERSERK))
+                reason = -1;
+            if (!reason && creature->GetBotAI()->GetBotOwnerGuid())
+                reason = 1;
+            if (!reason && player->GetNpcBotsCount() >= BotMgr::GetMaxNpcBots())
+                reason = 2;
+            if (!reason && !player->HasEnoughMoney(cost))
+                reason = 3;
+
+            if (!reason && _maxClassNpcBots && player->HaveBot())
+            {
+                uint8 count = 0;
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    if (itr->second->GetBotClass() == creature->GetBotClass())
+                        ++count;
+
+                if (!reason && count >= _maxClassNpcBots)
+                    reason = 4;
+            }
+
+            if (!reason)
+            {
+                std::ostringstream message;
+                message << "Do you wish to hire " << creature->GetName() << '?';
+                player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TAXI, "Will you follow me?",
+                    GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF + 0, message.str().c_str(), cost, false);
+            }
+            else
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TAXI, "Will you follow me?", GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF + reason);
+
+            if (creature->GetBotClass() >= BOT_CLASS_EX_START)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "<Take a better look on this one>", GOSSIP_SENDER_SCAN, GOSSIP_ACTION_INFO_DEF + 1);
+
+            menus = true;
+        }
+    }
+
+    if (creature->GetBotAI()->GetBotOwnerGuid())
+    {
+        Group const* gr = player->GetGroup();
+
+        if (player == creature->GetBotOwner())
+        {
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage equipment...", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage roles...", GOSSIP_SENDER_ROLES, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage formation...", GOSSIP_SENDER_FORMATION, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Use ability...", GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
+            if (creature->GetBotClass() >= BOT_CLASS_EX_START)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Abilities status...", GOSSIP_SENDER_SCAN_OWNER, GOSSIP_ACTION_INFO_DEF + 1);
+
+            if (!gr)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Create group>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+            else if (!gr->IsMember(creature->GetGUID()))
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Add to group>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 2);
+            else
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Remove from group>", GOSSIP_SENDER_LEAVE_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+
+            menus = true;
+        }
+        if (player == creature->GetBotOwner() || (gr && gr->IsMember(creature->GetBotOwner()->GetGUID())))
+        {
+            switch (creature->GetBotClass())
+            {
+                case BOT_CLASS_MAGE:
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need food", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need drink", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                    menus = true;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        if (player == creature->GetBotOwner())
+        {
+            std::ostringstream astr;
+            astr << "Are you going to abandon " << creature->GetName() << "? You may regret it...";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TAXI, "You are dismissed",
+                GOSSIP_SENDER_DISMISS, GOSSIP_ACTION_INFO_DEF + 1, astr.str().c_str(), 0, false);
+
+            menus = true;
+        }
+    }
+
+    if (menus)
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Nevermind", 0, GOSSIP_ACTION_INFO_DEF + 1);
+
+    player->PlayerTalkClass->SendGossipMenu(gossipTextId, creature->GetGUID());
+    return true;
+}
+
+//GossipSelect
+bool bot_minion_ai::OnGossipSelect(Player* player, Creature* creature/* == me*/, uint32 sender, uint32 action)
+{
+    //if (!IsInBotParty(player))
+    //{
+    //    player->CLOSE_GOSSIP_MENU();
+    //    return true;
+    //}
+
+    if (!_enableNpcBots || CCed(me) || IsDuringTeleport())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    uint32 gossipTextId = (player->GetGUIDLow() == _ownerGuid || !IAmFree()) ? GOSSIP_SERVE_MASTER : GOSSIP_NEED_SMTH;
+
+    player->PlayerTalkClass->ClearMenus();
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case 0: //any kind of fail
+        {
+            BotSay("...", player);
+            break;
+        }
+        case 1: //return to main menu
+        {
+            return bot_minion_ai::OnGossipHello(player, creature, 0);
+        }
+        case GOSSIP_SENDER_CLASS: //food/drink (classes: MAGE)
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_MAGE:
+                {
+                    //Prevent high-leveled consumables for low-level characters
+                    Unit* checker;
+                    if (player->getLevel() < me->getLevel())
+                        checker = player;
+                    else
+                        checker = me;
+
+                    // Conjure Refreshment rank 1
+                    uint32 food = InitSpell(checker, 42955);
+                    bool iswater = (action == GOSSIP_ACTION_INFO_DEF + 2);
+                    if (!food)
+                    {
+                        if (!iswater)// Conjure Food rank 1
+                            food = InitSpell(checker, 587);
+                        else// Conjure Water rank 1
+                            food = InitSpell(checker, 5504);
+                    }
+                    if (!food)
+                    {
+                        std::string errorstr = "I can't conjure ";
+                        errorstr += iswater ? "water" : "food";
+                        errorstr += " yet";
+                        BotWhisper(errorstr.c_str(), player);
+                        //player->PlayerTalkClass->ClearMenus();
+                        //return OnGossipHello(player, me);
+                        break;
+                    }
+                    SpellInfo const* Info = sSpellMgr->GetSpellInfo(food);
+                    Spell* foodspell = new Spell(me, Info, TRIGGERED_NONE, player->GetGUID());
+                    SpellCastTargets targets;
+                    targets.SetUnitTarget(player);
+                    //TODO implement checkcast for bots
+                    SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : foodspell->CheckPetCast(player);
+                    if (result != SPELL_CAST_OK)
+                    {
+                        foodspell->finish(false);
+                        delete foodspell;
+                        BotWhisper("I can't do it right now", player);
+                    }
+                    else
+                    {
+                        aftercastTargetGuid = player->GetGUID();
+                        foodspell->prepare(&targets);
+                        BotWhisper("Here you go...", player);
+                    }
+                    break;
+                }
+                default:
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT: //equips change s1: send what slots we can use
+        {
+            subMenu = true;
+
+            //general
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Show me your inventory", GOSSIP_SENDER_EQUIPMENT_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //auto-equip
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Auto-equip...", GOSSIP_SENDER_EQUIP_AUTOEQUIP, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //weapons
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Main hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_MAINHAND);
+            if (_canUseOffHand())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Off-hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_OFFHAND);
+            if (_canUseRanged())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Ranged...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_RANGED);
+            else
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Relic...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_RANGED);
+
+            //armor
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Head...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HEAD);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Shoulders...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_SHOULDERS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Chest...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_CHEST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Waist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WAIST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Legs...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_LEGS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Feet...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FEET);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Wrist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WRIST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Hands...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HANDS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BACK);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Shirt...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BODY);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Finger1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Finger2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Trinket1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Trinket2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Neck...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_NECK);
+
+            //if (player->IsGameMaster())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Unequip all", GOSSIP_SENDER_UNEQUIP_ALL, GOSSIP_ACTION_INFO_DEF + 1);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_LIST: //list inventory
+        {
+            //if (action - GOSSIP_ACTION_INFO_DEF != BOT_SLOT_NONE)
+            //    break;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment list for bot with no equip info!");
+
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                Item* item = _equips[i];
+                if (!item) continue;
+                std::ostringstream msg;
+                _AddItemLink(player, item, msg);
+                msg << " in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ')';
+                if (i < BOT_SLOT_RANGED && einfo->ItemEntry[i] == item->GetEntry())
+                    msg << " |cffe6cc80|h[!standard item!]|h|r";
+                BotWhisper(msg.str().c_str(), player);
+            }
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_INFO: //request equip item info
+        {
+            //GOSSIP ITEMS RESTRICTED
+            //subMenu = true; //needed for return
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment info for bot with no equip info!");
+
+            uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
+            Item* item = _equips[slot];
+            ASSERT(item);
+
+            std::ostringstream msg;
+            _AddItemLink(player, item, msg);
+
+            if (slot < BOT_SLOT_RANGED && einfo->ItemEntry[slot] == item->GetEntry())
+                msg << " |cffe6cc80|h[!standard item!]|h|r";
+
+            BotWhisper(msg.str().c_str(), player);
+
+            //break; //no break here - return to menu
+        }
+        case GOSSIP_SENDER_EQUIPMENT_SHOW: //equips change s2: send list of equippable items
+        {
+            subMenu = true;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment show for bot with no equip info!");
+
+            std::set<uint32> itemList, idsList;
+
+            //s2.1: build list
+            //s2.1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    bool standard = false;
+                    for (uint8 j = 0; j != MAX_EQUIPMENT_ITEMS; ++j)
+                    {
+                        if (einfo->ItemEntry[j] == pItem->GetEntry())
+                        {
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+                    if (_canEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF, true) && itemList.find(pItem->GetGUIDLow()) == itemList.end() && idsList.find(pItem->GetEntry()) == idsList.end())
+                    {
+                        itemList.insert(pItem->GetGUIDLow());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //s2.1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+            {
+                if (Bag* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                    {
+                        if (Item* pItem = player->GetItemByPos(i, j))
+                        {
+                            bool standard = false;
+                            for (uint8 k = 0; k != MAX_EQUIPMENT_ITEMS; ++k)
+                            {
+                                if (einfo->ItemEntry[k] == pItem->GetEntry())
+                                {
+                                    standard = true;
+                                    break;
+                                }
+                            }
+                            if (standard)
+                                continue;
+                            if (_canEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF, true) && itemList.find(pItem->GetGUIDLow()) == itemList.end() && idsList.find(pItem->GetEntry()) == idsList.end())
+                            {
+                                itemList.insert(pItem->GetGUIDLow());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //s2.2: add gossips
+
+            //s2.2.0 add current item (with return)
+            uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
+            std::ostringstream str;
+            str << "Equipped: ";
+            if (Item* item = _equips[slot])
+            {
+                _AddItemLink(player, item, str);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_INFO, action);
+            }
+            else
+            {
+                str << "nothing";
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_SHOW, action);
+            }
+
+            //s2.2.1 add unequip option if have weapon (GMs only)
+            if (action - GOSSIP_ACTION_INFO_DEF <= BOT_SLOT_RANGED)
+                //if (player->IsGameMaster())
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Use your old equipment", GOSSIP_SENDER_EQUIP_RESET, action);
+
+            //s2.2.2 add unequip option for non-weapons
+            if (slot >= BOT_SLOT_RANGED && _equips[slot])
+                //if (player->IsGameMaster())
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Unequip it", GOSSIP_SENDER_UNEQUIP, action);
+
+            //s2.2.3a: add an empty submenu with info if no items are found
+            if (itemList.empty())
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Hm... I have nothing to give you", 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = GOSSIP_MAX_MENU_ITEMS - 4; //unequip, reset, current, back
+                uint32 slot = action - GOSSIP_ACTION_INFO_DEF;
+                Item* item;
+                //s2.2.3b: add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUIDLow() == (*itr))
+                        {
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + (slot - 1), GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                    {
+                        if (Bag* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUIDLow() == (*itr))
+                                {
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + (slot - 1), GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+
+            //TC_LOG_ERROR("entities.player", "OnGossipSelect(bot): added %u item(s) to list of %s (requester: %s)",
+            //    counter, me->GetName().c_str(), player->GetName().c_str());
+
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP: //equips change s3: Unequip DEPRECATED
+        {
+            if (_unequip(action - (GOSSIP_ACTION_INFO_DEF + 1)))
+                BotSay("Hm...", player);
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP_ALL:
+        {
+            bool suc = true;
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (!(i < BOT_SLOT_RANGED ? _resetEquipment(i) : _unequip(i)))
+                {
+                    suc = false;
+                    std::ostringstream estr;
+                    estr << "Cannot reset equipment in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ")!";
+                    BotWhisper(estr.str().c_str(), player);
+                }
+
+                if (suc)
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_CRY);
+            }
+            break;
+        }
+        //autoequips change s5b: AtoEquip item
+        //base is GOSSIP_SENDER_EQUIP_AUTOEQUIP + 0...1...2... etc.
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_MHAND:     //1 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_OHAND:     //2 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_RANGED:    //3 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_HEAD:      //4 - 1 head
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_SHOULDERS: //5 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_CHEST:     //6 - 1 chest
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_WAIST:     //7 - 1 waist
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_LEGS:      //8 - 1 legs
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FEET:      //9 - 1 feet
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_WRIST:     //10 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_HANDS:     //11 - 1 hands
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_BACK:      //12 - 1 back
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_BODY:      //13 - 1 body
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER1:   //14 - 1 finger
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER2:   //15 - 1 finger
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET1:  //16 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET2:  //17 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_NECK:      //18 - 1 neck
+        {
+            Item* item = NULL;
+            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+            bool found = false;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (item && item->GetGUIDLow() == guidLow)
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found)
+            {
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                {
+                    if (Bag* pBag = player->GetBagByPos(i))
+                    {
+                        for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                        {
+                            item = player->GetItemByPos(i, j);
+                            if (item && item->GetGUIDLow() == guidLow)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (found)
+                        break;
+                }
+            }
+
+            if (found && _equip(sender - GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP, item)){}
+
+            //break;
+        }
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP:
+        {
+            subMenu = true;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send auto-equip for bot with no equip info!");
+
+            std::set<uint32> itemList, idsList;
+
+            //1: build list
+            //1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    bool standard = false;
+                    for (uint8 j = 0; j != MAX_EQUIPMENT_ITEMS; ++j)
+                    {
+                        if (einfo->ItemEntry[j] == pItem->GetEntry())
+                        {
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+
+                    bool canEquip = false;
+
+                    for (uint8 k = 0; k != BOT_INVENTORY_SIZE; ++k)
+                    {
+                        if (_canEquip(pItem->GetTemplate(), k + 1))
+                        {
+                            canEquip = true;
+                            break;
+                        }
+                    }
+
+                    if (canEquip && itemList.find(pItem->GetGUIDLow()) == itemList.end() && idsList.find(pItem->GetEntry()) == idsList.end())
+                    {
+                        itemList.insert(pItem->GetGUIDLow());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+            {
+                if (Bag* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                    {
+                        if (Item* pItem = player->GetItemByPos(i, j))
+                        {
+                            bool standard = false;
+                            for (uint8 k = 0; k != MAX_EQUIPMENT_ITEMS; ++k)
+                            {
+                                if (einfo->ItemEntry[k] == pItem->GetEntry())
+                                {
+                                    standard = true;
+                                    break;
+                                }
+                            }
+                            if (standard)
+                                continue;
+
+                            bool canEquip = false;
+
+                            for (uint8 k = 0; k != BOT_INVENTORY_SIZE; ++k)
+                            {
+                                if (_canEquip(pItem->GetTemplate(), k + 1))
+                                {
+                                    canEquip = true;
+                                    break;
+                                }
+                            }
+
+                            if (canEquip && itemList.find(pItem->GetGUIDLow()) == itemList.end() && idsList.find(pItem->GetEntry()) == idsList.end())
+                            {
+                                itemList.insert(pItem->GetGUIDLow());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //2: add gossips
+
+            if (itemList.empty())
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Hm... I have nothing to give you", 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = GOSSIP_MAX_MENU_ITEMS - 1; // back
+                Item* item;
+                //add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUIDLow() == (*itr))
+                        {
+                            uint8 k = 0;
+                            for (; k != BOT_INVENTORY_SIZE; ++k)
+                                if (_canEquip(item->GetTemplate(), k + 1))
+                                    break;
+
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP + k, GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                    {
+                        if (Bag* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUIDLow() == (*itr))
+                                {
+                                    uint8 k = 0;
+                                    for (; k != BOT_INVENTORY_SIZE; ++k)
+                                        if (_canEquip(item->GetTemplate(), k + 1))
+                                            break;
+
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP + k, GOSSIP_ACTION_INFO_DEF + item->GetGUIDLow());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_EQUIP_RESET: //equips change s4a: reset equipment
+        {
+            if (_resetEquipment(action - (GOSSIP_ACTION_INFO_DEF + 1))){}
+            break;
+        }
+        //equips change s4b: Equip item
+        //base is GOSSIP_SENDER_EQUIP + 0...1...2... etc.
+        case GOSSIP_SENDER_EQUIP_MHAND:     //1 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_OHAND:     //2 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_RANGED:    //3 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_HEAD:      //4 - 1 head
+        case GOSSIP_SENDER_EQUIP_SHOULDERS: //5 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_CHEST:     //6 - 1 chest
+        case GOSSIP_SENDER_EQUIP_WAIST:     //7 - 1 waist
+        case GOSSIP_SENDER_EQUIP_LEGS:      //8 - 1 legs
+        case GOSSIP_SENDER_EQUIP_FEET:      //9 - 1 feet
+        case GOSSIP_SENDER_EQUIP_WRIST:     //10 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_HANDS:     //11 - 1 hands
+        case GOSSIP_SENDER_EQUIP_BACK:      //12 - 1 back
+        case GOSSIP_SENDER_EQUIP_BODY:      //13 - 1 body
+        case GOSSIP_SENDER_EQUIP_FINGER1:   //14 - 1 finger
+        case GOSSIP_SENDER_EQUIP_FINGER2:   //15 - 1 finger
+        case GOSSIP_SENDER_EQUIP_TRINKET1:  //16 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_TRINKET2:  //17 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_NECK:      //18 - 1 neck
+        {
+            Item* item = NULL;
+            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+            bool found = false;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (item && item->GetGUIDLow() == guidLow)
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found)
+            {
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                {
+                    if (Bag* pBag = player->GetBagByPos(i))
+                    {
+                        for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                        {
+                            item = player->GetItemByPos(i, j);
+                            if (item && item->GetGUIDLow() == guidLow)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (found)
+                        break;
+                }
+            }
+
+            if (found && _equip(sender - GOSSIP_SENDER_EQUIP, item)){}
+            break;
+        }
+        case GOSSIP_SENDER_ROLES_TOGGLE: //ROLES 2: set/unset
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF, false);
+
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES: //ROLES 1: list
+        {
+            subMenu = true;
+
+            uint8 role = BOT_ROLE_TANK;
+
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+            {
+                if (role == BOT_ROLE_PARTY) //hidden
+                    continue;
+                if (role == BOT_ROLE_HEAL && !CanHeal())
+                    continue;
+
+                player->ADD_GOSSIP_ITEM(_onOffIcon(role), GetRoleString(role), GOSSIP_SENDER_ROLES_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + role + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USE:
+        {
+            if (uint32 basespell = action - GOSSIP_ACTION_INFO_DEF)
+                //if (CheckBotCast(me, basespell, me->GetBotClass()) == SPELL_CAST_OK)
+                    if (IsSpellReady(basespell, lastdiff, true))
+                        doCast(player, GetSpell(basespell));
+
+            //break;
+        }
+        case GOSSIP_SENDER_ABILITIES:
+        {
+            subMenu = true;
+
+            uint32 basespell;
+            SpellInfo const* spellInfo;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                //if (currentSpell == itr->second.first) continue; //prevent spam
+                basespell = itr->first; //always valid
+                if (!CanUseManually(basespell)) continue;
+                if (!IsSpellReady(basespell, 0, false, 5000)) continue;
+                spellInfo = sSpellMgr->GetSpellInfo(basespell); //always valid
+
+                std::ostringstream name;
+                _AddSpellLink(player, spellInfo, name);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, name.str().c_str(), GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF + basespell);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update", GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 2);
+
+            break;
+        }
+        case GOSSIP_SENDER_HIRE:
+        {
+            int32 reason = action - GOSSIP_ACTION_INFO_DEF;
+            if (!reason)
+            {
+                if (_ownerGuid)
+                {
+                    std::ostringstream ostr;
+                    std::string name;
+                    ostr << "Go away. I serve my master ";
+                    if (sObjectMgr->GetPlayerNameByGUID(MAKE_NEW_GUID(_ownerGuid, 0, HIGHGUID_PLAYER), name))
+                        ostr << name;
+                    else
+                        ostr << "unknown (" << _ownerGuid << ')';
+                    BotSay(ostr.str().c_str(), player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until owner dismisses %s", me->GetName().c_str(), (me->getGender() == GENDER_MALE ? "him" : "her"));
+                    break;
+                }
+
+                if (SetBotOwner(player))
+                    BotWhisper("I am ready", player);
+                else
+                    BotSay("...", player);
+            }
+            else if (reason == -1)
+            {
+                me->setFaction(14);
+                if (Creature* pet = me->GetBotsPet())
+                    pet->setFaction(14);
+                BotYell("Die!", player);
+                me->Attack(player, IsMelee());
+                break;
+            }
+            else
+            {
+                ChatHandler ch(player->GetSession());
+                switch (reason)
+                {
+                    case 1: //has owner, unexpected
+                        ch.PSendSysMessage("%s will not join you, already has master: %s",
+                            me->GetName().c_str(), master->GetName().c_str());
+                        break;
+                    case 2: //max npcbots exceed
+                        ch.PSendSysMessage("You exceed max npcbots (%u)", BotMgr::GetMaxNpcBots());
+                        break;
+                    case 3: //not enough money
+                    {
+                        std::string str = "You don't have enough money (";
+                        str += BotMgr::GetNpcBotCostStr(player->getLevel(), me);
+                        str += ")!";
+                        ch.SendSysMessage(str.c_str());
+                        player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+                        break;
+                    }
+                    case 4: //class bots exceed
+                    {
+                        uint8 count = 0;
+                        BotMap const* map = player->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                            if (itr->second->GetBotClass() == GetBotClass())
+                                ++count;
+
+                        ch.PSendSysMessage("You cannot have more bots of that class! %u of %u",
+                            count, _maxClassNpcBots);
+                        break;
+                    }
+                    default:
+                        break;
+                }
+
+                BotSay("...", player);
+            }
+            break;
+        }
+        case GOSSIP_SENDER_DISMISS:
+        {
+            BotMgr* mgr = player->GetBotMgr();
+            ASSERT(mgr);
+
+            //send items to owner -- Unequip all
+            bool abort = false;
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (!(i < BOT_SLOT_RANGED ? _resetEquipment(i) : _unequip(i)))
+                {
+                    std::ostringstream estr;
+                    estr << "Cannot reset equipment in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ")! Cannot dismiss bot!";
+                    ChatHandler ch(player->GetSession());
+                    ch.SendSysMessage(estr.str().c_str());
+                    abort = true;
+                    break;
+                }
+            }
+
+            if (abort)
+                break;
+
+            mgr->RemoveBot(me->GetGUID(), BOT_REMOVE_DISMISS);
+            if (Aura* bers = me->AddAura(BERSERK, me))
+            {
+                uint32 dur = 1 * HOUR * IN_MILLISECONDS;
+                bers->SetDuration(dur);
+                bers->SetMaxDuration(dur);
+            }
+            if (urand(1,100) <= 25)
+            {
+                me->setFaction(14);
+                if (Creature* pet = me->GetBotsPet())
+                    pet->setFaction(14);
+                BotSay("Fool...", player);
+                me->Attack(player, IsMelee());
+            }
+            else
+                BotSay("...", player);
+
+            break;
+        }
+        case GOSSIP_SENDER_JOIN_GROUP:
+        {
+            player->GetBotMgr()->AddBotToGroup(me);
+            break;
+        }
+        case GOSSIP_SENDER_LEAVE_GROUP:
+        {
+            player->GetBotMgr()->RemoveBotFromGroup(me);
+            break;
+        }
+        case GOSSIP_SENDER_FORMATION:
+        {
+            subMenu = true;
+            std::ostringstream diststr;
+            diststr << "Set distance (current: " << uint32(player->GetBotFollowDist()) << ')';
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, diststr.str(),
+                GOSSIP_SENDER_FORMATION_DISTANCE, GOSSIP_ACTION_INFO_DEF + 1, "", 0, true);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_DEBUG_ACTION:
+        {
+            //!!! player != owner !!!
+            bool close = true;
+            switch (action - GOSSIP_ACTION_INFO_DEF)
+            {
+                case 1: //reset owner
+                    if (!IAmFree())
+                        master->GetBotMgr()->RemoveBot(me->GetGUID(), BOT_REMOVE_DISMISS);
+                    else
+                    {
+                        ResetBotAI(BOTAI_RESET_DISMISS);
+                        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+                        //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+                        stmt->setUInt32(0, uint32(0));
+                        stmt->setUInt32(1, me->GetEntry());
+                        CharacterDatabase.Execute(stmt);
+                    }
+                    break;
+                case 2: //reset stats
+                    spawned = false;
+                    DefaultInit();
+                    break;
+                case 3: //list stats
+                    close = false;
+                    ReceiveEmote(player, TEXT_EMOTE_BONK);
+                    break;
+                case 4: //list roles
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s's Roles:", me->GetName().c_str());
+                    for (uint8 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+                    {
+                        if (_roleMask & i)
+                        {
+                            switch (i)
+                            {
+                                case BOT_ROLE_TANK:
+                                    ch.PSendSysMessage("BOT_ROLE_TANK");
+                                    break;
+                                case BOT_ROLE_DPS:
+                                    ch.PSendSysMessage("BOT_ROLE_DPS");
+                                    break;
+                                case BOT_ROLE_HEAL:
+                                    ch.PSendSysMessage("BOT_ROLE_HEAL");
+                                    break;
+                                //case BOT_ROLE_MELEE:
+                                //    ch.PSendSysMessage("BOT_ROLE_MELEE");
+                                //    break;
+                                case BOT_ROLE_RANGED:
+                                    ch.PSendSysMessage("BOT_ROLE_RANGED");
+                                    break;
+                                case BOT_ROLE_PARTY:
+                                    ch.PSendSysMessage("BOT_ROLE_PARTY");
+                                    break;
+                            }
+                        }
+                    }
+                    break;
+                }
+                case 5: //list spells
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s's Spells:", me->GetName().c_str());
+                    uint32 counter = 0;
+                    SpellInfo const* spellInfo;
+                    BotSpellMap const& myspells = GetSpellMap();
+                    for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+                    {
+                        ++counter;
+                        std::ostringstream sstr;
+                        spellInfo = sSpellMgr->GetSpellInfo(itr->first); //always valid
+                        _AddSpellLink(player, spellInfo, sstr);
+                        sstr << " id: " <<  itr->second.first << ", base: " << itr->first
+                            << ", cd: " << itr->second.second << ", base: " << std::max<uint32>(spellInfo->RecoveryTime, spellInfo->CategoryRecoveryTime);
+                        ch.PSendSysMessage("%u) %s", counter, sstr.str().c_str());
+                    }
+                    break;
+                }
+                case 6: //reload config
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+
+                    TC_LOG_INFO("misc", "Re-Loading config settings...");
+                    sWorld->LoadConfigSettings(true);
+                    sMapMgr->InitializeVisibilityDistanceInfo();
+                    ch.SendGlobalGMSysMessage("World config settings reloaded.");
+                    BotMgr::ReloadConfig();
+                    ch.SendGlobalGMSysMessage("NpcBot config settings reloaded.");
+
+                    break;
+                }
+                default:
+                    close = false;
+                    break;
+            }
+
+            if (close)
+                break;
+        }
+        case GOSSIP_SENDER_DEBUG:
+        {
+            //!!! player != owner !!!
+            subMenu = true;
+
+            std::ostringstream ostr;
+            std::string name;
+            ostr << "Bot: " << me->GetName()
+                << " (Id: " << me->GetEntry()
+                << ", guidlow: " << me->GetGUIDLow()
+                << ", faction: " << me->getFaction()
+                << "). owner: ";
+            if (_ownerGuid && sObjectMgr->GetPlayerNameByGUID(MAKE_NEW_GUID(_ownerGuid, 0, HIGHGUID_PLAYER), name))
+                ostr << name << " (" << _ownerGuid << ')';
+            else
+                ostr << "none";
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ostr.str().c_str(), GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 0);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Reset Owner>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Reset Stats>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<List Stats>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 3);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<List Roles>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 4);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<List Spells>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 5);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Reload Config>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 6);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+            break;
+        }
+        case GOSSIP_SENDER_SCAN:
+        {
+            //!!! player != owner !!!
+            subMenu = true;
+
+            //ListAbilities(true);
+            switch (_botclass)
+            {
+                case BOT_CLASS_BM:
+                    gossipTextId = GOSSIP_CLASS_BM;
+                    break;
+                default:
+                    break;
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_SCAN_OWNER_ABILITY:
+        {
+            uint32 Id = action - GOSSIP_ACTION_INFO_DEF;
+            SpellInfo const* info = sSpellMgr->GetSpellInfo(Id);
+            ASSERT(info);
+
+            ChatHandler ch(player->GetSession());
+            std::ostringstream smsg1, smsg2;
+            switch (Id)
+            {
+                //Blademaster
+                case SPELL_NETHERWALK:
+                    _AddSpellLink(player, info, smsg1, false, "ffffff00"/*yellow*/);
+                    smsg2 << "    Invisibilty: |cff00ff00" << uint32(100 + (me->getLevel() * 5) / 2) << "|r, speed: +|cff00ff00" << uint32(10 + me->getLevel() / 2) << "|r%, |cff00ff00150|r% normal damage";
+                    ch.SendSysMessage(smsg1.str().c_str());
+                    ch.SendSysMessage("Allows Blademaster to become invisible, and move faster for a set amount of time. When the Blademaster attacks a unit to break invisibility, he will deal bonus damage.");
+                    ch.SendSysMessage(smsg2.str().c_str());
+                    break;
+                case SPELL_MIRROR_IMAGE_BM:
+                    _AddSpellLink(player, info, smsg1, false, "ffffff00"/*yellow*/);
+                    smsg2 << "    |cff00ff00" << uint32(GetSpellMiscValue(Id)) << "|r " << (GetSpellMiscValue(Id) == 1 ? "illusion" : "illusions");
+                    ch.SendSysMessage(smsg1.str().c_str());
+                    ch.SendSysMessage("Confuses the enemy by creating illusions of the Blademaster and dispelling all magic from the Blademaster.");
+                    ch.SendSysMessage(smsg2.str().c_str());
+                    break;
+                case SPELL_CRITICAL_STRIKE:
+                    _AddSpellLink(player, info, smsg1, false, "ffff0000"/*red*/);
+                    smsg1 << " |cffffff00(Passive)|r";
+                    smsg2 << "    |cff00ff0015|r% chance to deal |cff00ff00" << uint32(GetSpellMiscValue(Id)) << "|r times normal damage";
+                    ch.SendSysMessage(smsg1.str().c_str());
+                    ch.SendSysMessage("Gives a 15% chance that the Blademaster will do more damage on his attacks.");
+                    ch.SendSysMessage(smsg2.str().c_str());
+                    break;
+                //case SPELL_BLADESTORM_BM: TODO:
+                default:
+                    break;
+            }
+
+            //break;
+        }
+        case GOSSIP_SENDER_SCAN_OWNER:
+        {
+            subMenu = true;
+
+            std::ostringstream abmsg1, abmsg2, abmsg3/*, abmsg4*/;
+            switch (_botclass)
+            {
+                case BOT_CLASS_BM:
+                    if (me->getLevel() >= 10)
+                    {
+                        _AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_NETHERWALK), abmsg1);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg1.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_NETHERWALK);
+                    }
+                    if (me->getLevel() >= 20)
+                    {
+                        _AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_MIRROR_IMAGE_BM), abmsg2);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg2.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_MIRROR_IMAGE_BM);
+                    }
+                    if (me->getLevel() >= 10)
+                    {
+                        _AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_CRITICAL_STRIKE), abmsg3);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg3.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_CRITICAL_STRIKE);
+                    }
+                    //TODO:
+                    //_AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_CRITICAL_STRIKE), abmsg4);
+                    //player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg4.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_BLADESTORM_BM);
+                    break;
+                default:
+                    break;
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        default:
+            break;
+    }
+
+    //if we add submenus send them else we should return
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    else
+        player->CLOSE_GOSSIP_MENU();
+
+    return true;
+}
+
+//GossipSelectCode
+bool bot_minion_ai::OnGossipSelectCode(Player* player, Creature* creature/* == me*/, uint32 sender, uint32 action, char const* code)
+{
+    if (!*code)
+        return true;
+
+    if (!_enableNpcBots || CCed(me) || IsDuringTeleport())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    uint32 gossipTextId = (player->GetGUIDLow() == _ownerGuid || !IAmFree()) ? GOSSIP_SERVE_MASTER : GOSSIP_NEED_SMTH;
+
+    player->PlayerTalkClass->ClearMenus();
+
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case GOSSIP_SENDER_FORMATION_DISTANCE:
+        {
+            char* dist = strtok((char*)code, "");
+            int8 distance = std::min<uint8>((uint8)atoi(dist), 75);
+
+            player->SetBotFollowDist(distance);
+
+            player->CLOSE_GOSSIP_MENU();
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_FORMATION, action);
+        }
+        default:
+            break;
+    }
+
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    else
+        player->CLOSE_GOSSIP_MENU();
+    return true;
+}
+//Summons pet for bot
+void bot_minion_ai::SummonBotsPet(uint32 entry)
+{
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet)
+        me->SetBotsPetDied();
+
+    uint8 mylevel = std::min<uint8>(master->getLevel(), 80);
+    uint32 originalentry = bot_pet_ai::GetPetOriginalEntry(entry);
+    if (!originalentry)
+    {
+        //annoy master
+        if (!IAmFree())
+            BotWhisper("Why am I trying to summon unknown pet!?", master);
+        return;
+    }
+    float x(0),y(0),z(0);
+    me->GetClosePoint(x, y, z, me->GetObjectSize());
+    m_botsPet = me->SummonCreature(entry, x, y, z, 0, TEMPSUMMON_DEAD_DESPAWN);
+
+    if (!m_botsPet)
+    {
+        if (!IAmFree())
+            BotWhisper("Failed to summon pet!", master);
+        return;
+    }
+
+    //std::string name = sObjectMgr->GeneratePetName(originalentry);//voidwalker
+    //if (!name.empty())
+    //    m_botsPet->SetName(name);
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS);
+    stmt->setUInt32(0, originalentry);
+    stmt->setUInt8(1, mylevel);
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    //QueryResult result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi, sta, inte, spi FROM `pet_levelstats` WHERE `creature_entry` = '%u' AND `level` = '%u'", originalentry, mylevel);
+
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        uint32 hp = fields[0].GetUInt16();
+        uint32 mana = fields[1].GetUInt16();
+        //armor = fields[2].GetUInt32();
+        uint32 str = fields[3].GetUInt16();
+        uint32 agi = fields[4].GetUInt16();
+        uint32 sta = fields[5].GetUInt16();
+        uint32 inte = fields[6].GetUInt16();
+        uint32 spi = fields[7].GetUInt16();
+
+        m_botsPet->SetCreateHealth(hp);
+        m_botsPet->SetMaxHealth(hp);
+        m_botsPet->SetCreateMana(mana);
+        m_botsPet->SetMaxPower(POWER_MANA, mana);
+
+        m_botsPet->SetCreateStat(STAT_STRENGTH, str);
+        m_botsPet->SetCreateStat(STAT_AGILITY, agi);
+        m_botsPet->SetCreateStat(STAT_STAMINA, sta);
+        m_botsPet->SetCreateStat(STAT_INTELLECT, inte);
+        m_botsPet->SetCreateStat(STAT_SPIRIT, spi);
+    }
+
+    m_botsPet->SetBotOwner(master);
+    m_botsPet->SetCreatureOwner(me);
+    //m_botsPet->SetBotClass(bot_pet_ai::GetPetClass(m_botsPet));
+    master->SetMinion((Minion*)m_botsPet, true);
+    m_botsPet->SetUInt64Value(UNIT_FIELD_CREATEDBY, me->GetGUID());
+    //m_botsPet->DeleteThreatList();
+    m_botsPet->AddUnitTypeMask(UNIT_MASK_MINION);
+    //m_botsPet->SetLevel(master->getLevel());
+    m_botsPet->AIM_Initialize();
+    //m_botsPet->InitBotAI(true);
+    m_botsPet->setFaction(master->getFaction());
+    //bot_pet_ai* petai = m_botsPet->GetBotPetAI();
+    //petai->SetCreatureOwner(me);
+    //petai->SetBaseArmor(armor);
+    m_botsPet->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    me->SetBotsPet(m_botsPet);
+
+    m_botsPet->SendUpdateToPlayer(master);
+}
+
+//Returns pet type (maybe unneeded)
+uint8 bot_pet_ai::GetPetType(Creature* pet)
+{
+    switch (pet->GetEntry())
+    {
+        case PET_VOIDWALKER:
+            return PET_TYPE_VOIDWALKER;
+    }
+    return PET_TYPE_NONE;
+}
+//Returns pet's class
+uint8 bot_pet_ai::GetPetClass(Creature* pet)
+{
+    switch (GetPetType(pet))
+    {
+        case PET_TYPE_IMP:
+            return BOT_CLASS_MAGE;
+        default:
+            return BOT_CLASS_PALADIN;
+    }
+}
+//Return entry used to summon real pets
+uint32 bot_pet_ai::GetPetOriginalEntry(uint32 entry)
+{
+    switch (entry)
+    {
+        case PET_VOIDWALKER:
+            return ORIGINAL_ENTRY_VOIDWALKER;
+        default:
+            return 0;
+    }
+}
+//PvP trinket for minions
+void bot_minion_ai::BreakCC(uint32 diff)
+{
+    if (pvpTrinket_cd <= diff && CCed(me, true) && (me->GetVictim() || !me->getAttackers().empty()))
+    {
+        temptimer = GC_Timer;
+        if (doCast(me, PVPTRINKET))
+        {
+            pvpTrinket_cd = 120000; //2 minutes default pvp trinket CD
+            GC_Timer = temptimer;
+            return;
+        }
+    }
+}
+//Returns attack range based on given range
+//If mounted: 20%
+//If ranged: 125%
+//If master is dead: max range
+float bot_ai::InitAttackRange(float origRange, bool ranged) const
+{
+    if (me->IsMounted())
+        origRange *= 0.2f;
+    else
+    {
+        if (ranged)
+            origRange *= 1.25f;
+        if (master->isDead())
+            origRange += sWorld->GetMaxVisibleDistanceOnContinents();
+        else if (IAmFree())
+        {
+            origRange =
+                //me->GetMap()->IsBattlegroundOrArena() ? sWorld->GetMaxVisibleDistanceInBGArenas() :
+                //me->GetMap()->Instanceable() ? sWorld->GetMaxVisibleDistanceInInstances() :
+                sWorld->GetMaxVisibleDistanceOnContinents();
+        }
+    }
+    return origRange;
+}
+//Force bots to start attack anyone who tries to DAMAGE me or master
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_minion_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (me->GetVictim() && (!IAmFree() || me->GetDistance(me->GetVictim()) < me->GetDistance(attacker)))
+        return;
+    if (InDuel(attacker))
+        return;
+
+    bool byspell = false;
+    bool ranged = !IsMelee();
+    switch (_botclass)
+    {
+        case BOT_CLASS_DRUID:
+            byspell = GetBotStance() == BOT_STANCE_NONE || GetBotStance() == DRUID_MOONKIN_FORM;
+            break;
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+            byspell = true;
+            break;
+        default:
+            //TC_LOG_ERROR("entities.player", "minion_ai: OnOwnerDamagedBy() - unknown bot class %u", uint8(_botclass));
+            break;
+    }
+    float maxdist = InitAttackRange(float(IAmFree() ? 100 : master->GetBotFollowDist()), ranged); //use increased range
+    if (!attacker->IsWithinDist(me, maxdist))
+        return;
+    if (!CanBotAttack(attacker, byspell))
+        return;
+
+    m_botCommandState = COMMAND_ABANDON; //reset AttackStart()
+    me->Attack(attacker, !ranged);
+}
+
+bool bot_minion_ai::_canUseOffHand() const
+{
+    if (_botclass == BOT_CLASS_BM)
+        return false;
+
+    //warriot can wield any offhand with titan's grip
+    if (_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60)
+        return true;
+
+    //no offhand: check we are using one-handed weapon in main hand
+    if (!_equips[1])
+    {
+        ItemTemplate const* proto = _equips[0] ? _equips[0]->GetTemplate() : NULL;
+        //no mainhand weapon - can use offhand
+        //mainhand is an one-hand weapon
+        if (!proto)
+            return true;
+        else if (proto->Class == ITEM_CLASS_WEAPON &&
+            (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+            return true;
+    }
+    else if (ItemTemplate const* proto = _equips[1]->GetTemplate())
+    {
+        //Now we have something in off-hand
+        //1 check if it is one-handed weapon
+        if (proto->Class == ITEM_CLASS_WEAPON &&
+            (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+            return true;
+        //2 check of it is a shield
+        if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            return true;
+        //3 check of it is a 'held in off-hand' item
+        if (proto->InventoryType == INVTYPE_HOLDABLE)
+            return true;
+    }
+
+    //NO
+    return false;
+}
+
+bool bot_minion_ai::_canUseRanged() const
+{
+    return (_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+        _botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_PRIEST ||
+        _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK);
+}
+//slot = BotEquipSlot
+bool bot_minion_ai::_canEquip(ItemTemplate const* item, uint8 slot, bool ignoreItemLevel) const
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    if (Item* oldItem = _equips[slot - 1])
+    {
+        ItemTemplate const* oldProto = oldItem->GetTemplate();
+        //prevent reequipping same items
+        if (item->ItemId == oldProto->ItemId)
+            return false;
+        //prevent equipping worse items (only standard or not)
+        if (!ignoreItemLevel)
+            if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot - 1] != oldProto->ItemId)
+                if (IAmFree() || !master->IsGameMaster())
+                    if (oldProto->GetItemLevelIncludingQuality() > item->GetItemLevelIncludingQuality())
+                        return false;
+    }
+
+    //level requirements
+    if (me->getLevel() < item->RequiredLevel)
+        return false;
+
+    //class requirements
+    if (!(item->AllowableClass & (1<<(GetPlayerClass()-1))))
+        return false;
+
+    //skip race requirements
+    //Weapons requirements
+    if (item->Class == ITEM_CLASS_WEAPON)
+    {
+        if (slot > BOT_SLOT_RANGED)
+            return false;
+        //polearms cannot be equipped into offhand
+        if (slot == BOT_SLOT_OFFHAND && item->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+            return false;
+        //only some classes can use offhand
+        if (slot == BOT_SLOT_OFFHAND && _botclass != BOT_CLASS_WARRIOR &&
+            _botclass != BOT_CLASS_ROGUE && _botclass != BOT_CLASS_HUNTER &&
+            _botclass != BOT_CLASS_SHAMAN && _botclass != BOT_CLASS_DEATH_KNIGHT)
+            return false;
+        //bot rogues only use daggers in mainhand
+        if (slot == BOT_SLOT_MAINHAND && item->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+            _botclass == BOT_CLASS_ROGUE)
+            return false;
+        //simple check for ranged weapon
+        if (item->InventoryType == INVTYPE_THROWN ||
+            item->InventoryType == INVTYPE_RANGED ||
+            item->InventoryType == INVTYPE_RANGEDRIGHT)
+        {
+            if (slot != BOT_SLOT_RANGED || !_canUseRanged())
+                return false;
+
+            if (item->SubClass == ITEM_SUBCLASS_WEAPON_GUN ||
+                item->SubClass == ITEM_SUBCLASS_WEAPON_BOW ||
+                item->SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW)
+                return (_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+                    _botclass == BOT_CLASS_WARRIOR/* || _botclass == BOT_CLASS_PRIEST ||
+                    _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK*/);
+
+            if (item->SubClass == ITEM_SUBCLASS_WEAPON_THROWN)
+                return (/*_botclass == BOT_CLASS_HUNTER || */_botclass == BOT_CLASS_ROGUE ||
+                    _botclass == BOT_CLASS_WARRIOR/* || _botclass == BOT_CLASS_PRIEST ||
+                    _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK*/);
+
+            if (item->SubClass == ITEM_SUBCLASS_WEAPON_WAND)
+                return (/*_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+                    _botclass == BOT_CLASS_WARRIOR || */_botclass == BOT_CLASS_PRIEST ||
+                    _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK);
+        }
+        else if (item->InventoryType == INVTYPE_2HWEAPON)
+        {
+            //warriors can equip any 2H weapon in any hand
+            if (_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60 &&
+                (slot == BOT_SLOT_MAINHAND || slot == BOT_SLOT_OFFHAND))
+                return true;
+            //2H weapons for casters - only staves
+            if ((_botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_PRIEST ||
+                _botclass == BOT_CLASS_WARLOCK || _botclass == BOT_CLASS_DRUID) &&
+                item->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+                return false;
+            //can equip 2H only in mainhand
+            return (slot == BOT_SLOT_MAINHAND);
+        }
+        else if (item->InventoryType == INVTYPE_WEAPON ||
+            item->InventoryType == INVTYPE_WEAPONMAINHAND ||
+            item->InventoryType == INVTYPE_WEAPONOFFHAND)
+        {
+            //separate classes which can equip weapons or shields in offhand
+            return (slot == BOT_SLOT_MAINHAND ||
+                (slot == BOT_SLOT_OFFHAND/* && _botclass != BOT_CLASS_PALADIN*/ && _canUseOffHand()));
+        }
+    }
+    else if (item->Class == ITEM_CLASS_ARMOR)
+    {
+        //conditions for inventory slots
+        switch (item->InventoryType)
+        {
+            case INVTYPE_HEAD:
+                if (slot != BOT_SLOT_HEAD)
+                    return false;
+                break;
+            case INVTYPE_SHOULDERS:
+                if (slot != BOT_SLOT_SHOULDERS)
+                    return false;
+                break;
+            case INVTYPE_BODY:
+                if (slot != BOT_SLOT_BODY)
+                    return false;
+                break;
+            case INVTYPE_CHEST:
+            case INVTYPE_ROBE:
+                if (slot != BOT_SLOT_CHEST)
+                    return false;
+                break;
+            case INVTYPE_WAIST:
+                if (slot != BOT_SLOT_WAIST)
+                    return false;
+                break;
+            case INVTYPE_LEGS:
+                if (slot != BOT_SLOT_LEGS)
+                    return false;
+                break;
+            case INVTYPE_FEET:
+                if (slot != BOT_SLOT_FEET)
+                    return false;
+                break;
+            case INVTYPE_WRISTS:
+                if (slot != BOT_SLOT_WRIST)
+                    return false;
+                break;
+            case INVTYPE_HANDS:
+                if (slot != BOT_SLOT_HANDS)
+                    return false;
+                break;
+            case INVTYPE_FINGER:
+                if (slot != BOT_SLOT_FINGER1 && slot != BOT_SLOT_FINGER2)
+                    return false;
+                break;
+            case INVTYPE_TRINKET:
+                if (slot != BOT_SLOT_TRINKET1 && slot != BOT_SLOT_TRINKET2)
+                    return false;
+                break;
+            case INVTYPE_NECK:
+                if (slot != BOT_SLOT_NECK)
+                    return false;
+                break;
+            case INVTYPE_CLOAK:
+                if (slot != BOT_SLOT_BACK)
+                    return false;
+                break;
+            case INVTYPE_HOLDABLE:
+            case INVTYPE_SHIELD:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_RELIC:
+                if (slot != BOT_SLOT_RANGED)
+                    return false;
+                break;
+            default:
+                break;
+        }
+
+        //Shields
+        if (item->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        {
+            if (slot == BOT_SLOT_OFFHAND) //wtf? mainhand shield?
+            {
+                //Only classes which can use shield
+                return _canUseOffHand() &&
+                    (_botclass == BOT_CLASS_WARRIOR ||
+                    _botclass == BOT_CLASS_PALADIN ||
+                    _botclass == BOT_CLASS_SHAMAN);
+            }
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_PLATE)
+        {
+            //Plate wearers
+            return (me->getLevel() >= 40 &&
+                (_botclass == BOT_CLASS_WARRIOR ||
+                _botclass == BOT_CLASS_DEATH_KNIGHT ||
+                _botclass == BOT_CLASS_PALADIN ||
+                _botclass == BOT_CLASS_BM));
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_MAIL)
+        {
+            //has mail skill by default
+            if (_botclass == BOT_CLASS_WARRIOR ||
+                _botclass == BOT_CLASS_DEATH_KNIGHT ||
+                _botclass == BOT_CLASS_PALADIN ||
+                _botclass == BOT_CLASS_BM)
+                return true;
+            //Mail wearers
+            return (me->getLevel() >= 40 &&
+                (_botclass == BOT_CLASS_SHAMAN ||
+                _botclass == BOT_CLASS_HUNTER));
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_LEATHER)
+        {
+            //exclude classes which can never use leather
+            return (_botclass != BOT_CLASS_WARLOCK &&
+                _botclass != BOT_CLASS_MAGE &&
+                _botclass != BOT_CLASS_PRIEST);
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_CLOTH)
+        {
+            //All classes can wear cloth lol
+            return true;
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_MISC)
+        {
+            if (item->InventoryType == INVTYPE_FEET && slot == BOT_SLOT_FEET)
+                return true;
+            if (item->InventoryType == INVTYPE_BODY && slot == BOT_SLOT_BODY)
+                return true;
+            if (item->InventoryType == INVTYPE_FINGER &&
+                (slot == BOT_SLOT_FINGER1 || slot == BOT_SLOT_FINGER2))
+                return true;
+            if (item->InventoryType == INVTYPE_TRINKET &&
+                (slot == BOT_SLOT_TRINKET1 || slot == BOT_SLOT_TRINKET2))
+                return true;
+            if (item->InventoryType == INVTYPE_NECK && slot == BOT_SLOT_NECK)
+                return true;
+            if (item->InventoryType == INVTYPE_HOLDABLE && slot == BOT_SLOT_OFFHAND && _canUseOffHand())
+                return true;
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_LIBRAM)
+            return _botclass == BOT_CLASS_PALADIN && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_IDOL)
+            return _botclass == BOT_CLASS_DRUID && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_TOTEM)
+            return _botclass == BOT_CLASS_SHAMAN && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_SIGIL)
+            return _botclass == BOT_CLASS_DEATH_KNIGHT && slot == BOT_SLOT_RANGED;
+        //misc inv items TODO:
+    }
+
+    return false;
+}
+
+bool bot_minion_ai::_unequip(uint8 slot)
+{
+    ASSERT(!IAmFree());
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to unequip item for bot with no equip info!");
+
+    Item* item = _equips[slot];
+    if (!item)
+        return true; //already unequipped
+
+    uint32 itemId = item->GetEntry();
+
+    //hand old weapon to master
+    if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != itemId)
+    {
+        ItemPosCountVec dest;
+        uint32 no_space = 0;
+        InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
+        if (msg != EQUIP_ERR_OK)
+        {
+            std::ostringstream istr, iistr;
+            istr << "Cannot unequip ";
+            _AddItemLink(master, item, iistr);
+            istr << iistr.str() << " for some stupid reason! Sending through mail";
+            ChatHandler ch(master->GetSession());
+            ch.SendSysMessage(istr.str().c_str());
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            MailDraft(iistr.str(), "").AddItem(item).SendMailTo(trans, MailReceiver(master), MailSender(me));
+            CharacterDatabase.CommitTransaction(trans);
+
+            //master->SendEquipError(msg, NULL, NULL, itemId);
+            //return false;
+        }
+        else
+        {
+            Item* pItem = master->StoreItem(dest, item, true);
+            master->SendNewItem(pItem, 1, true, false, false);
+        }
+    }
+    else
+    {
+        //slot < BOT_SLOT_RANGED && einfo->ItemEntry[slot] == itemId
+        //we have our standard weapon which we should get rid of
+        //item->SetState(ITEM_REMOVED, master); //delete Item object
+        delete item; //!Invalidated!
+        //item = NULL; //already in "_updateEquips(slot, NULL);"
+    }
+
+    //only for non-standard items
+    if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != itemId)
+        RemoveItemBonuses(slot);
+
+    if (slot < BOT_SLOT_RANGED && CanChangeEquip(slot + 1)) //weapons
+    {
+        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, 0);
+        me->SetAttackTime(WeaponAttackType(slot), 2000); //without weapon
+    }
+
+    _updateEquips(slot, NULL);
+
+    //offhand check
+    if (slot + 1 == BOT_SLOT_OFFHAND)
+    {
+        if (me->CanDualWield())
+            me->SetCanDualWield(false);
+        if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+            const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra |= CREATURE_FLAG_EXTRA_NO_BLOCK;
+    }
+
+    return true;
+}
+
+bool bot_minion_ai::_equip(uint8 slot, Item* newItem)
+{
+    ASSERT(!IAmFree());
+
+    if (!newItem)
+        return true; //nothing to equip
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to equip item for bot with no equip info!");
+
+    ItemTemplate const* proto = newItem->GetTemplate();
+
+    if (newItem->GetState() == ITEM_REMOVED)
+    {
+        TC_LOG_ERROR("entities.player",
+            "minion_ai::_equip(): player %s (guidLow: %u) is trying to make bot %s (id: %u) equip item: %s (id: %u, guidLow: %u) which has state ITEM_REMOVED!",
+            master->GetName().c_str(), master->GetGUIDLow(), me->GetName().c_str(), me->GetEntry(), proto->Name1.c_str(), proto->ItemId, newItem->GetGUIDLow());
+        return false;
+    }
+
+    uint32 newItemId = newItem->GetEntry();
+
+    if (Item* oldItem = _equips[slot])
+    {
+        //same id
+        if (oldItem->GetEntry() == newItemId)
+            return false;
+    }
+
+    if (!_unequip(slot))
+    {
+        BotSay("You have no space for my current item", master);
+        return false;
+    }
+
+    if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != newItemId)
+    {
+        //cheating
+        if (newItem->GetOwnerGUID() != master->GetGUID() || !master->HasItemCount(newItemId, 1))
+        {
+            std::ostringstream msg;
+            msg << "Cannot find ";
+            _AddItemLink(master, newItem, msg);
+            msg << " (id: " << uint32(newItemId) << ")!";
+            BotWhisper(msg.str().c_str(), master);
+
+            TC_LOG_ERROR("entities.player",
+                "minion_ai::_equip(): player %s (guidLow: %u) is trying to make bot %s (id: %u) equip item: %s (id: %u, guidLow: %u) but either does not have this item or does not own it",
+                master->GetName().c_str(), master->GetGUIDLow(), me->GetName().c_str(), me->GetEntry(), proto->Name1.c_str(), proto->ItemId, newItem->GetGUIDLow());
+            return false;
+        }
+
+        master->MoveItemFromInventory(newItem->GetBagSlot(), newItem->GetSlot(), true);
+        //Item is removed from inventory table in _updateEquips(slot, newItem);
+        newItem->SetUInt64Value(ITEM_FIELD_OWNER, 0);
+    }
+
+    if (slot < BOT_SLOT_RANGED)
+    {
+        if (CanChangeEquip(slot + 1))
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, newItemId);
+        uint32 delay =
+            /*einfo->ItemEntry[slot] != newItemId || */!IgnoreEquipsAttackTime() || slot + 1 == BOT_SLOT_OFFHAND ? proto->Delay :
+            slot + 1 == BOT_SLOT_RANGED ? me->GetCreatureTemplate()->rangeattacktime : me->GetCreatureTemplate()->baseattacktime;
+        me->SetAttackTime(WeaponAttackType(slot), delay); //set attack speed
+    }
+
+    _updateEquips(slot, newItem);
+
+    //only for non-standard items
+    if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != newItemId)
+        ApplyItemBonuses(slot);
+
+    if (slot + 1 == BOT_SLOT_OFFHAND)
+    {
+        if (proto->Class == ITEM_CLASS_WEAPON)
+        {
+            if (!me->CanDualWield())
+                me->SetCanDualWield(true);
+        }
+        else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        {
+            if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+        }
+    }
+    else if (slot + 1 == BOT_SLOT_MAINHAND && proto->InventoryType == INVTYPE_2HWEAPON && !(_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60))
+    {
+        //if have incompatible offhand unequip it
+        if (_equips[BOT_SLOT_OFFHAND - 1] != NULL)
+            _unequip(BOT_SLOT_OFFHAND - 1);
+    }
+
+    return true;
+}
+
+void bot_minion_ai::_updateEquips(uint8 slot, Item* item)
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to update equips for bot with no equip info!");
+
+    _equips[slot] = item;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    //Commit to DB
+    PreparedStatement* bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_EQUIP);
+    //"UPDATE character_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?, equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE entry = ?", CONNECTION_ASYNC
+    PreparedStatement* stmt;
+    uint8 k;
+    for (k = 0; k != BOT_INVENTORY_SIZE; ++k)
+    {
+        if (Item* botitem = _equips[k])
+        {
+            bool standard = false;
+            for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+            {
+                if (einfo->ItemEntry[i] == botitem->GetEntry())
+                {
+                    bstmt->setUInt32(k, 0);
+                    standard = true;
+                    break;
+                }
+            }
+            if (standard)
+                continue;
+
+            uint8 index = 0;
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_ITEM_INSTANCE);
+            //REPLACE INTO item_instance (itemEntry, owner_guid, creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid)
+            //VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC : 0-13
+            stmt->setUInt32(  index, botitem->GetEntry());
+            stmt->setUInt32(++index, GUID_LOPART(botitem->GetOwnerGUID()));
+            stmt->setUInt32(++index, GUID_LOPART(botitem->GetUInt64Value(ITEM_FIELD_CREATOR)));
+            stmt->setUInt32(++index, GUID_LOPART(botitem->GetUInt64Value(ITEM_FIELD_GIFTCREATOR)));
+            stmt->setUInt32(++index, botitem->GetCount());
+            stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_DURATION));
+
+            std::ostringstream ssSpells;
+            for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                ssSpells << botitem->GetSpellCharges(i) << ' ';
+            stmt->setString(++index, ssSpells.str());
+
+            stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_FLAGS));
+
+            std::ostringstream ssEnchants;
+            for (uint8 i = 0; i < MAX_ENCHANTMENT_SLOT; ++i)
+            {
+                ssEnchants << botitem->GetEnchantmentId(EnchantmentSlot(i)) << ' ';
+                ssEnchants << botitem->GetEnchantmentDuration(EnchantmentSlot(i)) << ' ';
+                ssEnchants << botitem->GetEnchantmentCharges(EnchantmentSlot(i)) << ' ';
+            }
+            stmt->setString(++index, ssEnchants.str());
+
+            stmt->setInt16 (++index, botitem->GetItemRandomPropertyId());
+            stmt->setUInt16(++index, botitem->GetUInt32Value(ITEM_FIELD_DURABILITY));
+            stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME));
+            stmt->setString(++index, botitem->GetText());
+            stmt->setUInt32(++index, botitem->GetGUIDLow());
+
+            trans->Append(stmt);
+
+            botitem->DeleteFromInventoryDB(trans); //prevent duplicates
+
+            bstmt->setUInt32(k, botitem->GetGUIDLow());
+        }
+        else
+            bstmt->setUInt32(k, uint32(0));
+    }
+
+    bstmt->setUInt32(k, me->GetEntry());
+
+    trans->Append(bstmt);
+    CharacterDatabase.CommitTransaction(trans);
+}
+//Called from gossip menu only (applies only to weapons)
+bool bot_minion_ai::_resetEquipment(uint8 slot)
+{
+    ASSERT(!IAmFree());
+    ASSERT(slot < BOT_SLOT_RANGED);
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to reset equipment for bot with no equip info!");
+
+    uint32 itemId = einfo->ItemEntry[slot];
+    if (!itemId)
+        return _unequip(slot);
+    else if (Item* oldItem = _equips[slot])
+        if (oldItem->GetEntry() == itemId)
+            return true;
+
+    if (slot + 1 == BOT_SLOT_MAINHAND && !(_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60))
+    {
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            if (proto->Class == ITEM_CLASS_WEAPON &&
+                (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF || proto->SubClass == ITEM_SUBCLASS_WEAPON_SPEAR))
+            {
+                if (!_unequip(BOT_SLOT_OFFHAND - 1))
+                    return false;
+            }
+        }
+    }
+
+    //we have our standard weapon itemId which we should use to create new item
+    Item* stItem = Item::CreateItem(itemId, 1, NULL);
+    ASSERT(stItem && "Failed to create standard Item for bot!");
+
+    if (!_equip(slot, stItem))
+    {
+        TC_LOG_ERROR("entities.player", "minion_ai::_resetEquipment(): player %s (guidLow: %u) failed to reset equipment for bot %s (id: %u) in slot %u",
+                master->GetName().c_str(), master->GetGUIDLow(), me->GetName().c_str(), me->GetEntry(), slot);
+        return false;
+    }
+    return true;
+}
+
+void bot_minion_ai::ApplyItemBonuses(uint8 slot)
+{
+    //ensurance to set zeros
+    RemoveItemBonuses(slot);
+
+    Item* item = _equips[slot];
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return;
+
+    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : NULL;
+
+    uint32 ssd_level = me->getLevel();
+    if (ssd && ssd_level > ssd->MaxLevel)
+        ssd_level = ssd->MaxLevel;
+
+    ScalingStatValuesEntry const* ssv = proto->ScalingStatValue ? sScalingStatValuesStore.LookupEntry(ssd_level) : NULL;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_STATS; ++i)
+    {
+        uint32 statType = 0;
+        int32  val = 0;
+        if (ssd && ssv)
+        {
+            if (ssd->StatMod[i] < 0)
+                continue;
+            statType = ssd->StatMod[i];
+            val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Modifier[i]) / 10000;
+        }
+        else
+        {
+            if (i >= proto->StatsCount)
+                continue;
+            statType = proto->ItemStat[i].ItemStatType;
+            val = proto->ItemStat[i].ItemStatValue;
+        }
+
+        if (val == 0)
+            continue;
+
+        _stats[slot][statType] += val;
+    }
+
+    _stats[slot][BOT_ITEM_MOD_RESIST_HOLY] += proto->HolyRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FIRE] += proto->FireRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_NATURE] += proto->NatureRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FROST] += proto->FrostRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_SHADOW] += proto->ShadowRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_ARCANE] += proto->ArcaneRes;
+
+    _stats[slot][BOT_ITEM_MOD_DAMAGE] += (proto->Damage[0].DamageMin + proto->Damage[0].DamageMax) / 2;
+    _stats[slot][BOT_ITEM_MOD_ARMOR] += proto->Armor;
+    _stats[slot][BOT_ITEM_MOD_BLOCK_VALUE] += proto->Block;
+
+    if (GetPlayerClass() == BOT_CLASS_DRUID)
+    {
+        int32 dpsMod = 0;
+        int32 feral_bonus = 0;
+
+        if (ssv)
+        {
+            dpsMod = ssv->getDPSMod(proto->ScalingStatValue);
+            feral_bonus += ssv->getFeralBonus(proto->ScalingStatValue);
+        }
+
+        feral_bonus += proto->getFeralBonus(dpsMod);
+        if (feral_bonus)
+            _stats[slot][BOT_ITEM_MOD_FERAL_ATTACK_POWER] += feral_bonus;
+            //ApplyFeralAPBonus(feral_bonus, apply);
+    }
+
+    ApplyItemEnchantments(item, slot);
+    ApplyItemEquipSpell(item, true);
+
+    shouldUpdateStats = true;
+}
+
+void bot_minion_ai::RemoveItemBonuses(uint8 slot)
+{
+    Item* item = _equips[slot];
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        _stats[slot][i] = 0;
+
+    RemoveItemEnchantments(item, slot); //remove spells
+    ApplyItemEquipSpell(item, false);
+
+    shouldUpdateStats = true;
+}
+
+void bot_minion_ai::ApplyItemEnchantments(Item* item, uint8 slot)
+{
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+        ApplyItemEnchantment(item, EnchantmentSlot(i), slot);
+}
+
+void bot_minion_ai::ApplyItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot)
+{
+    uint32 enchant_id = item->GetEnchantmentId(eslot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    if (pEnchant->requiredLevel > me->getLevel())
+        return;
+
+    uint32 enchant_display_type;
+    uint32 enchant_amount;
+    uint32 enchant_spell_id;
+
+    for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+    {
+        enchant_display_type = pEnchant->type[s];
+        enchant_amount = pEnchant->amount[s];
+        enchant_spell_id = pEnchant->spellid[s];
+
+        switch (enchant_display_type)
+        {
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                _stats[slot][BOT_ITEM_MOD_DAMAGE] += enchant_amount;
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                {
+                    int32 basepoints = 0;
+                    // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+                    if (item->GetItemRandomPropertyId())
+                    {
+                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand)
+                        {
+                            // Search enchant_amount
+                            for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand->enchant_id[k] == enchant_id)
+                                {
+                                    basepoints = int32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    // Cast custom spell vs all equal basepoints got from enchant_amount
+                    if (basepoints)
+                        me->CastCustomSpell(me, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, item);
+                    else
+                        me->CastSpell(me, enchant_spell_id, true, item);
+                }
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand)
+                    {
+                        for (uint8 k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand->enchant_id[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+                _stats[slot][BOT_ITEM_MOD_RESISTANCE_START + enchant_spell_id] += enchant_amount;
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+            {
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand_suffix)
+                    {
+                        for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand_suffix->enchant_id[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand_suffix->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                switch (enchant_spell_id)
+                {
+                    case ITEM_MOD_MANA:
+                    case ITEM_MOD_HEALTH:
+                    case ITEM_MOD_AGILITY:
+                    case ITEM_MOD_STRENGTH:
+                    case ITEM_MOD_INTELLECT:
+                    case ITEM_MOD_SPIRIT:
+                    case ITEM_MOD_STAMINA:
+                    case ITEM_MOD_DEFENSE_SKILL_RATING:
+                    case ITEM_MOD_DODGE_RATING:
+                    case ITEM_MOD_PARRY_RATING:
+                    case ITEM_MOD_BLOCK_RATING:
+                    case ITEM_MOD_HIT_MELEE_RATING:
+                    case ITEM_MOD_HIT_RANGED_RATING:
+                    case ITEM_MOD_HIT_SPELL_RATING:
+                    case ITEM_MOD_CRIT_MELEE_RATING:
+                    case ITEM_MOD_CRIT_RANGED_RATING:
+                    case ITEM_MOD_CRIT_SPELL_RATING:
+                    case ITEM_MOD_HASTE_MELEE_RATING:
+                    case ITEM_MOD_HASTE_RANGED_RATING:
+                    case ITEM_MOD_HASTE_SPELL_RATING:
+                    case ITEM_MOD_HIT_RATING:
+                    case ITEM_MOD_CRIT_RATING:
+                    case ITEM_MOD_HASTE_RATING:
+                    case ITEM_MOD_RESILIENCE_RATING:
+                    case ITEM_MOD_EXPERTISE_RATING:
+                    case ITEM_MOD_ATTACK_POWER:
+                    case ITEM_MOD_RANGED_ATTACK_POWER:
+                    case ITEM_MOD_MANA_REGENERATION:
+                    case ITEM_MOD_ARMOR_PENETRATION_RATING:
+                    case ITEM_MOD_SPELL_POWER:
+                    case ITEM_MOD_SPELL_PENETRATION:
+                    case ITEM_MOD_BLOCK_VALUE:
+                    case ITEM_MOD_SPELL_HEALING_DONE:   // deprecated
+                    case ITEM_MOD_SPELL_DAMAGE_DONE:    // deprecated
+                        _stats[slot][enchant_spell_id] += enchant_amount;
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            }
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void bot_minion_ai::RemoveItemEnchantments(Item* item, uint8 slot)
+{
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+        RemoveItemEnchantment(item, EnchantmentSlot(i), slot);
+}
+
+void bot_minion_ai::RemoveItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 /*slot*/)
+{
+    uint32 enchant_id = item->GetEnchantmentId(eslot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    ////skip level reqs
+    //if (pEnchant->requiredLevel > me->getLevel())
+    //    return;
+
+    uint32 enchant_display_type;
+    //uint32 enchant_amount;
+    uint32 enchant_spell_id;
+
+    for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+    {
+        enchant_display_type = pEnchant->type[s];
+        //enchant_amount = pEnchant->amount[s];
+        enchant_spell_id = pEnchant->spellid[s];
+
+        switch (enchant_display_type)
+        {
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                    me->RemoveAurasDueToItemSpell(enchant_spell_id, item->GetGUID());
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void bot_minion_ai::ApplyItemEquipSpell(Item* item, bool apply)
+{
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+
+        if (!spellData.SpellId)
+            continue;
+
+        // wrong triggering type
+        if (apply && spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_EQUIP)
+            continue;
+
+        // check if it is valid spell
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellInfo)
+            continue;
+
+        //ApplyEquipSpell(spellproto, item, apply);
+
+        //if (apply)
+        //    me->AddAura(spellInfo->Id, me);
+        //else
+        //    me->RemoveAura(spellInfo->Id);
+
+        if (apply)
+            me->CastSpell(me, spellInfo, true, item);
+        else
+            me->RemoveAurasDueToItemSpell(spellInfo->Id, item->GetGUID());  // un-apply all spells, not only at-equipped
+    }
+}
+
+void bot_minion_ai::ApplyItemsSpells()
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    //only for non-standard items
+    for (uint8 slot = 0; slot != BOT_INVENTORY_SIZE; ++slot)
+        if (Item* item = _equips[slot])
+            if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != item->GetEntry())
+                ApplyItemEquipSpell(item, true);
+}
+
+inline float bot_minion_ai::_getBotStat(uint8 slot, uint8 stat) const
+{
+    return float(static_cast<BotStat>(_stats[slot])[stat]);
+}
+
+inline float bot_minion_ai::_getTotalBotStat(uint8 stat) const
+{
+    int32 value = 0;
+    for (uint8 slot = 0; slot != BOT_INVENTORY_SIZE; ++slot)
+        value += static_cast<BotStat>(_stats[slot])[stat];
+
+    return float(value);
+}
+
+inline float bot_minion_ai::_getRatingMultiplier(CombatRating cr) const
+{
+    GtCombatRatingsEntry const* Rating =
+        sGtCombatRatingsStore.LookupEntry(cr*GT_MAX_LEVEL + (me->getLevel()-1));
+    GtOCTClassCombatRatingScalarEntry const* classRating =
+        sGtOCTClassCombatRatingScalarStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_RATING + cr + 1);
+    if (!Rating || !classRating)
+        return 1.0f;
+
+    //bots gain 20% increased bonus from rating mods
+    return 1.2f * classRating->ratio / Rating->ratio;
+}
+
+char const* bot_minion_ai::_getNameForSlot(uint8 slot) const
+{
+    switch (slot)
+    {
+        case BOT_SLOT_MAINHAND:
+            return "Main Hand Weapon";
+        case BOT_SLOT_OFFHAND:
+            return "Offhand Weapon";
+        case BOT_SLOT_RANGED:
+            return "Ranged Weapon";
+        case BOT_SLOT_HEAD:
+            return "Head";
+        case BOT_SLOT_SHOULDERS:
+            return "Shoulders";
+        case BOT_SLOT_CHEST:
+            return "Chest";
+        case BOT_SLOT_WAIST:
+            return "Waist";
+        case BOT_SLOT_LEGS:
+            return "Legs";
+        case BOT_SLOT_FEET:
+            return "Feet";
+        case BOT_SLOT_WRIST:
+            return "Wrist";
+        case BOT_SLOT_HANDS:
+            return "Hands";
+        case BOT_SLOT_BACK:
+            return "Back";
+        case BOT_SLOT_BODY:
+            return "Body";
+        case BOT_SLOT_FINGER1:
+            return "Finger1";
+        case BOT_SLOT_FINGER2:
+            return "Finger2";
+        case BOT_SLOT_TRINKET1:
+            return "Trinket1";
+        case BOT_SLOT_TRINKET2:
+            return "Trinket2";
+        case BOT_SLOT_NECK:
+            return "Neck";
+        default:
+            return "Unknown";
+    }
+}
+
+uint8 bot_minion_ai::_onOffIcon(uint8 role) const
+{
+    return HasRole(role) ? BOT_ICON_ON : BOT_ICON_OFF;
+}
+
+bool bot_minion_ai::CanHeal() const
+{
+    return
+        (_botclass == BOT_CLASS_PRIEST || _botclass == BOT_CLASS_DRUID ||
+        _botclass == BOT_CLASS_SHAMAN || _botclass == BOT_CLASS_PALADIN);
+}
+
+char const* bot_ai::GetRoleString(uint8 role) const
+{
+    switch (role)
+    {
+        case BOT_ROLE_NONE:
+            return "???";
+        case BOT_ROLE_TANK:
+            return "Tanking";
+        case BOT_ROLE_DPS:
+            return "DPS";
+        case BOT_ROLE_HEAL:
+            return "Heal";
+        //case BOT_ROLE_MELEE:
+        //    return "Melee";
+        case BOT_ROLE_RANGED:
+            return "Ranged";
+        default:
+        {
+            std::ostringstream str;
+            str << "role " << uint32(role);
+            return str.str().c_str();
+        }
+    }
+}
+
+void bot_ai::DefaultInit()
+{
+    //only once
+    if (spawned) return;
+    spawned = true;
+
+    if (!firstspawn)
+    {
+        me->RemoveAllAuras();
+        if (IsMinionAI())
+            ToMinionAI()->ApplyItemsSpells();
+    }
+
+    //*etStats() has *pplyClassPassives() in it
+    //needed to be before InitEquips for some classes (warrior TG)
+    me->SetPvP(true);
+    InitRoles();
+    SetStats(true);
+    //InitPowers(); //already in *etStats();
+    ApplyPassives();
+
+    if (firstspawn)
+    {
+        firstspawn = false;
+        ASSERT(!me->GetBotAI());
+        me->SetBotAI(this);
+        InitFaction();
+        InitOwner();
+        InitEquips();
+
+        InitSpellMap(PVPTRINKET, true);
+    }
+}
+
+void bot_minion_ai::InitFaction()
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_FACTION);
+    //"SELECT faction FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    ASSERT(result);
+
+    Field* field = result->Fetch();
+    uint32 faction = field[0].GetUInt32();
+    me->setFaction(faction);
+    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->faction = faction;
+}
+
+void bot_minion_ai::InitOwner()
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_OWNER);
+    //"SELECT owner FROM character_npcbot WHERE entry = ?", CONNECTION_SYNCH
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    ASSERT(result);
+
+    Field* field = result->Fetch();
+    _ownerGuid = field[0].GetUInt32();
+}
+
+void bot_minion_ai::InitRoles()
+{
+    if (IAmFree())
+    {
+        //default roles
+        _roleMask = BOT_ROLE_DPS;
+        if (!IsMeleeClass(_botclass))
+            _roleMask |= BOT_ROLE_RANGED;
+        if (CanHeal())
+            _roleMask |= BOT_ROLE_HEAL;
+
+        return;
+    }
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_ROLES);
+    //"SELECT roles FROM character_npcbot WHERE entry = ?", CONNECTION_SYNC
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    if (!result)
+    {
+        //default roles
+        _roleMask = BOT_ROLE_DPS;
+        if (!IsMeleeClass(_botclass))
+            _roleMask |= BOT_ROLE_RANGED;
+        if (CanHeal())
+            _roleMask |= BOT_ROLE_HEAL;
+
+        return;
+    }
+
+    Field* field = result->Fetch();
+    _roleMask = field[0].GetInt8();
+}
+
+void bot_pet_ai::InitRoles()
+{
+    _roleMask = BOT_ROLE_DPS;
+    if (!IsMeleeClass(GetPetClass(me)))
+        _roleMask |= BOT_ROLE_RANGED;
+    if (CanHeal())
+        _roleMask |= BOT_ROLE_HEAL;
+}
+
+void bot_minion_ai::InitEquips()
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to spawn bot with no equip info!");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP);
+    //"SELECT equipMhEx, equipOhEx, equipRhEx, equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck
+    //FROM character_npcbot WHERE entry = ?", CONNECTION_SYNCH
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult cnresult = CharacterDatabase.Query(stmt);
+    if (!cnresult)
+    {
+        TC_LOG_ERROR("entities.player", "bot_minion_ai::InitEquips(): Failed to initialize equips for bot %s (id: %u, guidLow: %u), not found in `characters_npcbots table`!!!",
+            me->GetName().c_str(), me->GetEntry(), me->GetGUIDLow());
+        ASSERT(false);
+    }
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE);
+    //                    0                   1         2            3           4         5                6                    7              8             9        10       11            12             13
+    //SELECT ii.creatorGuid, ii.giftCreatorGuid, ii.count, ii.duration, ii.charges, ii.flags, ii.enchantments, ii.randomPropertyId, ii.durability, ii.playedTime, ii.text, ii.guid, ii.itemEntry, ii.owner_guid "
+    //  "FROM item_instance ii JOIN characters_npcbot cn ON ii.guid IN "
+    //  "(cn.equipMhEx, cn.equipOhEx, cn.equipRhEx, cn.equipHead, cn.equipShoulders, cn.equipChest, cn.equipWaist, cn.equipLegs, cn.equipFeet, cn.equipWrist, cn.equipHands, cn.equipBack, cn.equipBody, cn.equipFinger1, cn.equipFinger2, cn.equipTrinket1, cn.equipTrinket2, cn.equipNeck) "
+    //  "WHERE cn.entry = ?", CONNECTION_SYNCH
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult iiresult = CharacterDatabase.Query(stmt);
+
+    Field* fields1 = cnresult->Fetch();
+    Field* fields2;
+    uint32 itemId;
+    uint32 itemGuidLow;
+    Item* item;
+
+    if (!iiresult) //blank bot - fill with standard items
+    {
+        for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+        {
+            itemId = einfo->ItemEntry[i];
+            if (!itemId)
+                continue;
+
+            item = Item::CreateItem(itemId, 1, NULL);
+            ASSERT(item && "Failed to init standard Item for bot!");
+            _equips[i] = item;
+        }
+    }
+    else
+    {
+        do
+        {
+            fields2 = iiresult->Fetch();
+            itemGuidLow = fields2[11].GetUInt32();
+            itemId = fields2[12].GetUInt32();
+            item = new Item;
+            ASSERT(item->LoadFromDB(itemGuidLow, 0, fields2, itemId));
+            //gonna find where to store our new item
+            bool found = false;
+            uint8 i = 0;
+            for (; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (fields1[i].GetUInt32() == itemGuidLow && !_equips[i])
+                {
+                    _equips[i] = item;
+                    found = true;
+                    break;
+                }
+            }
+            ASSERT(found);
+            //ItemTemplate const* proto = item->GetTemplate();
+            //TC_LOG_ERROR("entities.player", "minion_ai::InitEquips(): bot %s (id: %u): found item: for slot %u: %s (id: %u, guidLow: %u)",
+            //    me->GetName().c_str(), me->GetEntry(), i, proto->Name1.c_str(), itemId, itemGuidLow);
+
+        } while (iiresult->NextRow());
+    }
+
+    //visualize
+    for (uint8 i = 0; i != BOT_SLOT_RANGED; ++i)
+    {
+        if (CanChangeEquip(i + 1) && _equips[i])
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, _equips[i]->GetEntry());
+        else if (einfo->ItemEntry[i])
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+    }
+
+    //apply weapons' parameters
+    if (Item* MH = _equips[0])
+    {
+        itemId = MH->GetEntry();
+        if (einfo->ItemEntry[0] != itemId)
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+            {
+                me->SetAttackTime(BASE_ATTACK, proto->Delay);
+                ApplyItemBonuses(0);
+            }
+        }
+    }
+    if (Item* OH = _equips[1])
+    {
+        itemId = OH->GetEntry();
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            if (einfo->ItemEntry[1] != itemId)
+                ApplyItemBonuses(1);
+
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                me->SetAttackTime(OFF_ATTACK, proto->Delay);
+                me->SetCanDualWield(true);
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+            }
+        }
+    }
+    if (Item* RH = _equips[2])
+    {
+        itemId = RH->GetEntry();
+        if (einfo->ItemEntry[2] != itemId)
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+            {
+                if (proto->Class == ITEM_CLASS_WEAPON)
+                    me->SetAttackTime(RANGED_ATTACK, proto->Delay);
+
+                ApplyItemBonuses(2);
+            }
+        }
+    }
+
+    for (uint8 i = 3; i != BOT_INVENTORY_SIZE; ++i)
+        ApplyItemBonuses(i);
+
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+    {
+        if (_equips[i] == NULL && einfo->ItemEntry[i] != 0)
+        {
+            if (i == 1 && !_canUseOffHand())
+                continue;
+
+            //if bot has no equips but equip template then write these to bot map
+            item = Item::CreateItem(einfo->ItemEntry[i], 1, NULL);
+            ASSERT(item && "Failed to init standard Item for bot point 2!");
+            _equips[i] = item;
+
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+            if (i == 1)
+            {
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[i]))
+                {
+                    if (proto->Class == ITEM_CLASS_WEAPON)
+                    {
+                        me->SetAttackTime(OFF_ATTACK, _botclass == BOT_CLASS_ROGUE ? 1400 : 1800);
+                        me->SetCanDualWield(true);
+                    }
+                    else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    {
+                        if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                            const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                    }
+                }
+            }
+        }
+    }
+}
+
+void bot_ai::ToggleRole(uint8 role, bool force)
+{
+    if (!force && roleTimer > 0)
+        return;
+
+    roleTimer = 350; //delay next attempt (prevent abuse)
+
+    HasRole(role) ? _roleMask &= ~role : _roleMask |= role;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_ROLES);
+    //"UPDATE character_npcbot SET roles = ? WHERE entry = ?", CONNECTION_ASYNC
+    stmt->setUInt8(0, _roleMask);
+    stmt->setUInt32(1, me->GetEntry());
+    CharacterDatabase.Execute(stmt);
+
+    //Update passives
+    ApplyPassives();
+    shouldUpdateStats = true;
+}
+
+bool bot_ai::IsTank(Unit* unit) const
+{
+    if (!unit)
+        unit = me;
+
+    if (unit == me)
+        return HasRole(BOT_ROLE_TANK);
+
+    if (Creature* bot = unit->ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            return bot->GetBotAI()->HasRole(BOT_ROLE_TANK);
+
+    if (Player* player = unit->ToPlayer())
+    {
+        if (Group* gr = player->GetGroup())
+        {
+            Group::MemberSlotList const& slots = gr->GetMemberSlots();
+            for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                if (itr->guid == player->GetGUID())
+                    return itr->flags & MEMBER_FLAG_MAINTANK;
+        }
+    }
+
+    return false;
+}
+
+void bot_ai::FindMaster(bool force)
+{
+    if (!force)
+    {
+        //totally free
+        if (!_ownerGuid)
+            return;
+        if (!_atHome || _evadeMode)
+            return;
+
+        //delay
+        if (checkMasterTimer > 0)
+            return;
+
+        checkMasterTimer = urand(5000, 15000);
+    }
+
+    //already have master
+    if (!IAmFree())
+        return;
+
+    if (Player* player = sObjectMgr->GetPlayerByLowGUID(_ownerGuid))
+    {
+        //prevent bot being screwed up because of wrong flags
+        if (player->IsGameMaster() || player->GetSession()->isLogingOut())
+            return;
+
+        SetBotOwner(player);
+
+        //fail
+        if (master != player)
+            return;
+
+        if (!IsTempBot())
+            BotWhisper("Hey...", master);
+        return;
+    }
+}
+
+bool bot_minion_ai::IAmFree() const
+{
+    if (!_ownerGuid)
+        return true;
+    if (_ownerGuid != master->GetGUID())
+        return true;
+    if (!me->HasUnitTypeMask(UNIT_MASK_MINION))
+        return true;
+
+    return false;
+    //return (!_ownerGuid || _ownerGuid != master->GetGUID() || !me->HasUnitTypeMask(UNIT_MASK_MINION));
+    //        //has owner   and   //owner is found          and        //bound to owner
+}
+
+void bot_minion_ai::SavePosition()
+{
+    if (_saveTimer > 0) return;
+    if (!me->IsPositionValid()) return;
+    if (me->IsInCombat() || !me->IsInWorld())
+    {
+        _saveTimer = 3000;
+        return;
+    }
+
+    _saveTimer = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);
+
+    uint16 mapid = me->GetMapId();
+    float x = me->GetPositionX();
+    float y = me->GetPositionY();
+    float z = me->GetPositionZ();
+    float o = me->GetOrientation();
+
+    if (CreatureData const* data = sObjectMgr->GetCreatureData(me->GetDBTableGUIDLow()))
+    {
+        const_cast<CreatureData*>(data)->mapid = mapid;
+        const_cast<CreatureData*>(data)->posX = x;
+        const_cast<CreatureData*>(data)->posY = y;
+        const_cast<CreatureData*>(data)->posZ = z;
+        const_cast<CreatureData*>(data)->orientation = o;
+    }
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_UPD_NPCBOT_POSITION);
+    //"UPDATE creature SET map = ?, position_x = ?, position_y = ?, position_z = ?, orientation = ? WHERE guid = ?", CONNECTION_ASYNC
+    stmt->setUInt16(0, mapid);
+    stmt->setFloat(1, x);
+    stmt->setFloat(2, y);
+    stmt->setFloat(3, z);
+    stmt->setFloat(4, o);
+    stmt->setUInt32(5, me->GetDBTableGUIDLow());
+
+    WorldDatabase.Execute(stmt);
+}
+
+//UTILITIES
+void bot_ai::_AddItemTemplateLink(Player* forPlayer, ItemTemplate const* item, std::ostringstream &str) const
+{
+    //color
+    str << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << uint32(item->ItemId) << ':';
+
+    //permanent enchantment, 3 gems, 4 unknowns, reporter_level (9)
+    str << "0:0:0:0:0:0:0:0:0";
+
+    //name
+    std::string name = item->Name1;
+    _LocalizeItem(forPlayer, name, item->ItemId);
+    str << "|h[" << name << "]|h|r";
+
+    //max in stack
+    if (item->BuyCount > 1)
+        str<< "|cff009900x" << item->BuyCount << ".|r";
+    else
+        str << "|cff009900.|r";
+}
+// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:random_property:0:reporter_level|h[name]|h|r
+// |cffa335ee|Hitem:812:0:0:0:0:0:0:0:70|h[Glowing Brightwood Staff]|h|r
+void bot_ai::_AddItemLink(Player* forPlayer, Item const* item, std::ostringstream &str) const
+{
+    ItemTemplate const* proto = item->GetTemplate();
+
+    //color
+    str << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << proto->ItemId << ':';
+
+    //gems (3)
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot != SOCK_ENCHANTMENT_SLOT + MAX_ITEM_PROTO_SOCKETS; ++slot)
+    {
+        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+
+// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:random_property:0:reporter_level|h[name]|h|r
+        switch (slot - SOCK_ENCHANTMENT_SLOT)
+        {
+            case 0: g1 = eId;   break;
+            case 1: g2 = eId;   break;
+            case 2: g3 = eId;   break;
+        }
+    }
+    //permanent enchantment
+    str << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ':';
+    //gems 3
+    str << g1 << ':' << g2 << ':' << g3 << ':';
+    //gems bonus - useless
+    //str << item->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT) << ':';
+    str << 0 << ':';
+    //random property
+    str << item-> GetItemRandomPropertyId() << ':';
+    //item suffix
+    //str << item->GetItemSuffixFactor() << ':';
+    //temp enchantment (i.e. windfury weapon)
+    //str << item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) << ':';
+    //str << 0 << ':';
+
+    ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+    uint32 bpoints = 0;
+    if (item_rand)
+    {
+        // Search enchant_amount
+        for (uint8 k = 0; k != 3; ++k)
+        {
+            if (item_rand->enchant_id[k])
+            {
+                uint32 basepoints = int32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                if (basepoints > bpoints)
+                    bpoints = basepoints;
+            }
+        }
+    }
+
+    str << bpoints << ':';
+
+    //reporter level
+    str << proto->RequiredLevel;
+
+    //name
+    std::string name = proto->Name1;
+    std::string suffix;
+    _LocalizeItem(forPlayer, name, suffix, item);
+
+    str << "|h[" << name << suffix << "]|h|r";
+
+    //quantity
+    if (item->GetCount() > 1)
+        str << "x" << item->GetCount() << ' ';
+}
+
+void bot_ai::_AddQuestLink(Player* forPlayer, Quest const* quest, std::ostringstream &str) const
+{
+    std::string questTitle = quest->GetTitle();
+    _LocalizeQuest(forPlayer, questTitle, quest->GetQuestId());
+    str << "|cFFEFFD00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+}
+
+void bot_ai::_AddWeaponSkillLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|cff00ffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << " : " << master->GetSkillValue(skillid) << " /" << master->GetMaxSkillValue(skillid) << "]|h|r";
+}
+//|cff71d5ff|Hspell:21563|h[Command]|h|r
+void bot_ai::_AddSpellLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, bool color/* = true*/, const std::string& colorstr/* = "ffffffff"*/) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|c";
+
+    if (color)
+    {
+        switch (GetFirstSchoolInMask(spellInfo->GetSchoolMask()))
+        {
+            case SPELL_SCHOOL_NORMAL:       str << "ffffff00"; break; //YELLOW
+            case SPELL_SCHOOL_HOLY:         str << "ffffe680"; break; //LIGHT YELLOW
+            case SPELL_SCHOOL_FIRE:         str << "ffff8000"; break; //ORANGE
+            case SPELL_SCHOOL_NATURE:       str << "ff4dff4d"; break; //GREEN
+            case SPELL_SCHOOL_FROST:        str << "ff80ffff"; break; //LIGHT BLUE
+            case SPELL_SCHOOL_SHADOW:       str << "ff8080ff"; break; //DARK BLUE
+            case SPELL_SCHOOL_ARCANE:       str << "ffff80ff"; break; //LIGHT PURPLE
+            default:                        str << "ffffffff"; break; //UNK WHITE
+        }
+    }
+    else
+        str << colorstr; //explicit color default white
+
+
+    str << "|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << "]|h|r";
+}
+
+void bot_ai::_AddProfessionLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const
+{
+    ASSERT(master->HasSkill(skillId));
+    // |cffffd000|Htrade:4037:1:150:1:6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA|h[Engineering]|h|r
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    SkillLineEntry const* skillInfo = sSkillLineStore.LookupEntry(skillId);
+    if (skillInfo)
+    {
+        uint32 curValue = master->GetPureSkillValue(skillId);
+        uint32 maxValue  = master->GetPureMaxSkillValue(skillId);
+        str << "|cffffd000|Htrade:" << spellInfo->Id << ':' << curValue << ':' << maxValue << ':' << master->GetGUIDLow() << ":6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA" << "|h[" << skillInfo->name[loc] << "]|h|r";
+    }
+}
+//Localization
+void bot_ai::_LocalizeItem(Player* forPlayer, std::string &itemName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(entry);
+    if (!itemInfo)
+        return;
+
+    if (itemInfo->Name.size() > loc && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+}
+
+void bot_ai::_LocalizeItem(Player* forPlayer, std::string &itemName, std::string &suffix, Item const* item) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(item->GetEntry());
+    if (!itemInfo)
+        return;
+
+    if (itemInfo->Name.size() > loc && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+
+    int32 randomPropId = item->GetItemRandomPropertyId();
+    if (!randomPropId)
+        return;
+
+    if (randomPropId > 0)
+    {
+        if (ItemRandomPropertiesEntry const* item_rand = sItemRandomPropertiesStore.LookupEntry(randomPropId))
+            suffix = item_rand->nameSuffix[loc];
+    }
+    else
+    {
+        if (ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(-randomPropId))
+             suffix = item_rand->nameSuffix[loc];
+    }
+}
+
+void bot_ai::_LocalizeQuest(Player* forPlayer, std::string &questTitle, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const* questInfo = sObjectMgr->GetQuestLocale(entry);
+    if (!questInfo)
+        return;
+
+    if (questInfo->Title.size() > loc && !questInfo->Title[loc].empty())
+    {
+        const std::string title = questInfo->Title[loc];
+        if (Utf8FitTo(title, wnamepart))
+            questTitle = title;
+    }
+}
+
+void bot_ai::_LocalizeCreature(Player* forPlayer, std::string &creatureName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const* creatureInfo = sObjectMgr->GetCreatureLocale(entry);
+    if (!creatureInfo)
+        return;
+
+    if (creatureInfo->Name.size() > loc && !creatureInfo->Name[loc].empty())
+    {
+        const std::string title = creatureInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            creatureName = title;
+    }
+}
+
+void bot_ai::_LocalizeGameObject(Player* forPlayer, std::string &gameobjectName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const* gameObjectInfo = sObjectMgr->GetGameObjectLocale(entry);
+    if (!gameObjectInfo)
+        return;
+
+    if (gameObjectInfo->Name.size() > loc && !gameObjectInfo->Name[loc].empty())
+    {
+        const std::string title = gameObjectInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            gameobjectName = title;
+    }
+}
+
+void bot_ai::BotSpeak(std::string const& text, uint8 msgtype, uint32 language, uint64 speaker, uint64 receiver)
+{
+    if (msgtype == CHAT_MSG_WHISPER)
+        language = LANG_UNIVERSAL;
+
+    std::string _text(text);
+    //sScriptMgr->OnPlayerChat(this, CHAT_MSG_SAY, language, _text);
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    //BuildPlayerChat(&data, msgType, _text, language);
+    data << uint8(msgtype);
+    data << uint32(language);
+    data << uint64(speaker);
+    data << uint32(0);                 // constant unknown time
+    data << uint64(speaker);
+    data << uint32(text.length() + 1);
+    data << text;
+    data << uint8(0);
+
+    if (msgtype == CHAT_MSG_WHISPER)
+    {
+        ASSERT(receiver && "BotSpeak(): no receiver for whisper!");
+        ASSERT(IS_PLAYER_GUID(receiver) && "BotSpeak(): whisper receiver is not a player!");
+
+        if (Player* res = ObjectAccessor::FindPlayer(receiver))
+            res->GetSession()->SendPacket(&data);
+    }
+    else
+    {
+        if (Unit* snd = ObjectAccessor::FindUnit(speaker))
+        {
+            float dist = std::max<float>(sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL) * 0.5f);
+            Trinity::MessageDistDeliverer notifier(snd, &data, dist, false);
+            snd->VisitNearbyWorldObject(dist, notifier);
+        }
+    }
+    //SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true);
+}
+
+void bot_minion_ai::BotJump(Position* pos)
+{
+    ++_jumpCount;
+
+    me->BotStopMovement();
+    me->GetMotionMaster()->MoveJump(*pos, me->GetExactDist2d(pos->m_positionX, pos->m_positionY), 10.0f);
+
+    //float dx = pos->m_positionX - me->m_positionX;
+    //float dy = pos->m_positionY - me->m_positionY;
+    //float fdx = fabs(dx); float fdy = fabs(dy);
+    //float divider = fdx > 400 || fdy > 400 ? 5.0f : fdx > 200 || fdy > 200 ? 3.0f : fdx > 100 || fdy > 100 ? 2.0f : 1.5f;
+    //dx = dx / divider + me->m_positionX;
+    //dy = dy / divider + me->m_positionY;
+    //float z = me->GetMap()->GetHeight(dx, dy, std::max<float>(me->m_positionZ, pos->m_positionZ));
+
+    //if (z > INVALID_HEIGHT)
+    //    me->GetMotionMaster()->MoveJump(dx, dy, z, me->GetExactDist2d(dx, dy), 10.0f);
+}
+
+bool bot_minion_ai::UpdateImpossibleChase(Unit* target)
+{
+    if (_chaseTimer || me->isMoving() || !IAmFree())
+        return false;
+
+    if (me->IsFalling() || JumpingFlyingOrFalling())
+        return false;
+
+    if (!me->IsWithinDist(target, IsMelee() ? 50 : 75) || (me->GetDistance(target) < (IsMelee() ? 5 : 25)))
+    {
+        ResetChaseTimer(target);
+        me->GetMotionMaster()->MovePoint(me->GetMapId(), *target, false);
+        return true;
+    }
+
+    if (_jumpCount >= 3)
+    {
+        me->AttackStop();
+        Evade(true);
+        return true;
+    }
+
+    ResetChaseTimer(target);
+    BotJump(target);
+    return true;
+}
+
+void bot_minion_ai::ResetChaseTimer(Position* /*pos*/)
+{
+    _chaseTimer = 10000;//std::max<uint32>(5000, me->GetDistance2d(pos->m_positionX, pos->m_positionY) * 400);
+    //me->GetDistance2d(pos->m_positionX, pos->m_positionY) * 1000 / me->GetSpeed(MOVE_WALK);
+}
+
+void bot_minion_ai::ResetChase(Position* pos)
+{
+    if (!IAmFree())
+        return;
+
+    ResetChaseTimer(pos);
+    _jumpCount = 0;
+}
+
+void bot_minion_ai::OnStartAttack(Unit* u)
+{
+    if (u->GetGUID() != _lastTargetGuid)
+    {
+        ResetChase(u);
+        _lastTargetGuid = u->GetGUID();
+    }
+}
+
+void bot_minion_ai::EnterCombat(Unit* u)
+{
+    _atHome = false;
+
+    //clear gossip during combat. See CheckAuras() for restore
+    if (me->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP))
+        me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+    //disable evade mode just in case
+    //me->ClearUnitState(UNIT_STATE_EVADE);
+    //if (Creature* pet = me->GetBotsPet())
+    //    pet->ClearUnitState(UNIT_STATE_EVADE);
+
+    if (!IAmFree())
+        return;
+
+    _evadeMode = false;
+    AbortTeleport();
+
+    ResetChase(u);
+}
+
+void bot_minion_ai::JustDied(Unit*)
+{
+    events.KillAllEvents(false);
+    _reviveTimer = IAmFree() ? 180000 : 30000; //3min/30sec
+    _atHome = false;
+    _evadeMode = false;
+    spawned = false;
+
+    if (IsTempBot())
+    {
+        //TC_LOG_ERROR("entities.player", "Unsummoning temp bot %s (guidLow: %u), owner: %s (guidLow: %u)...",
+        //    me->GetName().c_str(), me->GetGUIDLow(), master->GetName().c_str(), master->GetGUIDLow());
+
+        if (!IAmFree())
+            master->GetBotMgr()->RemoveBot(me->GetGUID(), BOT_REMOVE_UNSUMMON);
+
+        me->AddObjectToRemoveList();
+    }
+    else if (!IAmFree())
+    {
+        if (Group* gr = master->GetGroup())
+            if (gr->IsMember(me->GetGUID()))
+                gr->SendUpdate();
+    }
+}
+
+void bot_minion_ai::MoveInLineOfSight(Unit* /*u*/)
+{
+}
+
+void bot_ai::DamageDealt(Unit* victim, uint32& damage, DamageEffectType /*damageType*/)
+{
+    if (victim == me)
+        return;
+
+    if (damage)
+        if (Creature* cre = victim->ToCreature())
+            if (!cre->hasLootRecipient())
+                cre->SetLootRecipient(master);
+
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+        ResetChase(victim);
+}
+//This function is called after Spell::SendSpellCooldown() call for players
+void bot_ai::OnBotSpellGo(Spell const* spell)
+{
+    SpellInfo const* curInfo = spell->GetSpellInfo();
+    uint32 rec = curInfo->GetRecoveryTime();
+    uint32 catrec = curInfo->CategoryRecoveryTime;
+
+    if (rec > 0)
+        ApplyBotSpellCooldownMods(curInfo, rec);
+    if (catrec > 0 && !(curInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS))
+        ApplyBotSpellCategoryCooldownMods(curInfo, catrec);
+
+    //Set cooldown
+    SetSpellCooldown(curInfo->GetFirstRankSpell()->Id, rec);
+    SetSpellCategoryCooldown(curInfo->GetFirstRankSpell(), catrec);
+
+    OnClassSpellGo(curInfo);
+}
+
+void bot_ai::OnBotSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs)
+{
+    SpellInfo const* info;
+
+    for (BotSpellMap::iterator itr = spells.begin(); itr != spells.end(); ++itr)
+    {
+        info = sSpellMgr->GetSpellInfo(itr->second.first);
+        if (!info || !(info->GetSchoolMask() & schoolMask)) continue;
+        if (info->IsCooldownStartedOnEvent()) continue;
+        if (info->PreventionType != SPELL_PREVENTION_TYPE_SILENCE) continue;
+
+        itr->second.second += unTimeMs;
+        //TC_LOG_ERROR("entities.player", "OnBotSpellInterrupted(): Adding cooldown (%u, new: %u) to spell %s (id: %u, schoolmask: %u), reqSchoolMask = %u",
+        //    unTimeMs, itr->second.second, info->SpellName[0], info->Id, info->SchoolMask, schoolMask);
+    }
+}
+
+void bot_minion_ai::CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Spell const* spell/* = NULL*/)
+{
+    if (!target || !target->IsAlive() || target == me)
+        return;
+
+    if (!me->CanUseAttackType(attType))
+        return;
+
+    Item* item;
+    ItemTemplate const* proto;
+    uint8 slot;
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        item = _equips[i];
+        if (!item)
+            continue;
+
+        //skip standard items
+        if (i < BOT_SLOT_RANGED && einfo->ItemEntry[i] == item->GetEntry())
+            continue;
+
+        proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        // Additional check for weapons
+        if (proto->Class == ITEM_CLASS_WEAPON)
+        {
+            // offhand item cannot proc from main hand hit etc
+            switch (attType)
+            {
+                case BASE_ATTACK:   slot = BOT_SLOT_MAINHAND;   break;
+                case OFF_ATTACK:    slot = BOT_SLOT_OFFHAND;    break;
+                case RANGED_ATTACK: slot = BOT_SLOT_RANGED;     break;
+                default:            slot = BOT_MAX_SLOTS;       break;
+            }
+            if (slot - 1 != i)
+                continue;
+        }
+
+        CastBotItemCombatSpell(target, attType, procVictim, procEx, item, proto, spell);
+    }
+}
+
+void bot_minion_ai::CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto, Spell const* /*spell*//* = NULL*/)
+{
+    //TODO: custom spell triggers maybe?
+
+    // Can do effect if any damage done to target
+    if (procVictim & PROC_FLAG_TAKEN_DAMAGE)
+    {
+        for (uint8 i = 0; i != MAX_ITEM_SPELLS; ++i)
+        {
+            _Spell const& spellData = proto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            // wrong triggering type
+            if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+            if (!spellInfo)
+            {
+                //TC_LOG_ERROR("entities.player.items", "WORLD: unknown Item spellid %i", spellData.SpellId);
+                continue;
+            }
+
+            // not allow proc extra attack spell at extra attack
+            if (me->m_extraAttacks && spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
+                return;
+
+            float chance = float(spellInfo->ProcChance);
+
+            if (spellData.SpellPPMRate)
+            {
+                uint32 WeaponSpeed = me->GetAttackTime(attType);
+                chance = me->GetPPMProcChance(WeaponSpeed, spellData.SpellPPMRate, spellInfo);
+            }
+            else if (chance > 100.0f)
+                chance = me->GetWeaponProcChance();
+
+            if (roll_chance_f(chance))
+                me->CastSpell(target, spellInfo->Id, true, item);
+        }
+    }
+
+    // item combat enchantments
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            if (pEnchant->type[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
+                continue;
+
+            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);
+
+            if (entry && entry->procEx)
+            {
+                // Check hit/crit/dodge/parry requirement
+                if ((entry->procEx & procEx) == 0)
+                    continue;
+            }
+            else
+            {
+                // Can do effect if any damage done to target
+                if (!(procVictim & PROC_FLAG_TAKEN_DAMAGE))
+                    continue;
+            }
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->spellid[s]);
+            if (!spellInfo)
+            {
+                //TC_LOG_ERROR("entities.player.items", "Player::CastItemCombatSpell(GUID: %u, name: %s, enchant: %i): unknown spell %i is casted, ignoring...",
+                //    GetGUIDLow(), GetName().c_str(), pEnchant->ID, pEnchant->spellid[s]);
+                continue;
+            }
+
+            float chance = pEnchant->amount[s] != 0 ? float(pEnchant->amount[s]) : me->GetWeaponProcChance();
+
+            if (entry)
+            {
+                if (entry->PPMChance)
+                    chance = me->GetPPMProcChance(proto->Delay, entry->PPMChance, spellInfo);
+                else if (entry->customChance)
+                    chance = float(entry->customChance);
+            }
+
+            //// Apply spell mods
+            //ApplySpellMod(pEnchant->spellid[s], SPELLMOD_CHANCE_OF_SUCCESS, chance);
+
+            // Shiv has 100% chance to apply the poison
+            if (me->FindCurrentSpellBySpellId(5938) && e_slot == TEMP_ENCHANTMENT_SLOT)
+                chance = 100.0f;
+
+            if (roll_chance_f(chance))
+            {
+                if (spellInfo->IsPositive())
+                    me->CastSpell(me, spellInfo, true, item);
+                else
+                    me->CastSpell(target, spellInfo, true, item);
+            }
+        }
+    }
+}
+
+bool bot_minion_ai::GlobalUpdate(uint32 diff)
+{
+    lastdiff = diff;
+
+    if (_updateTimerMedium <= diff)
+    {
+        _updateTimerMedium = 500;
+
+        //Medium-timed updates
+
+        //send stats update for group frames
+        if (me->IsInWorld() && !IAmFree())
+        {
+            if (Group* gr = master->GetGroup())
+            {
+                if (gr->IsMember(me->GetGUID()))
+                {
+                    WorldPacket data;
+                    BuildGrouUpdatePacket(&data);
+
+                    Player* member;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        member = itr->GetSource();
+                        if (member/* && !member->IsWithinDist(me, member->GetSightRange(), false)*/)
+                            member->GetSession()->SendPacket(&data);
+                    }
+                }
+            }
+
+            //update pvp state
+            if (me->GetByteValue(UNIT_FIELD_BYTES_2, 1) != master->GetByteValue(UNIT_FIELD_BYTES_2, 1))
+                me->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+        }
+    }
+
+    if (!me->IsAlive())
+        return false;
+
+    return true;
+}
+
+void bot_minion_ai::CommonTimers(uint32 diff)
+{
+    events.Update(diff);
+    SpellTimers(diff);
+
+    if (Potion_cd > diff && (Potion_cd < POTION_CD || !me->IsInCombat()))
+        Potion_cd -= diff;
+
+    if (pvpTrinket_cd > diff)       pvpTrinket_cd -= diff;
+    if (GC_Timer > diff)            GC_Timer -= diff;
+    if (temptimer > diff)           temptimer -= diff;
+    if (checkAurasTimer != 0)       --checkAurasTimer;
+    if (wait != 0)                  --wait;
+
+    if (roleTimer > diff)           roleTimer -= diff;
+    else if (roleTimer > 0)         roleTimer = 0;
+
+    if (_saveTimer > diff)          _saveTimer -= diff;
+    else if (_saveTimer > 0)        _saveTimer = 0;
+
+    if (_powersTimer > diff)        _powersTimer -= diff;
+    else if (_powersTimer > 0)      _powersTimer = 0;
+
+    if (_chaseTimer > diff)         _chaseTimer -= diff;
+    else if (_chaseTimer > 0)       _chaseTimer = 0;
+
+    if (checkMasterTimer > diff)    checkMasterTimer -= diff;
+    else if (checkMasterTimer > 0)  checkMasterTimer = 0;
+
+    if (IAmFree())
+        UpdateReviveTimer(diff);
+
+    if (_bootTimer > int32(diff))   _bootTimer -= diff;
+    else if (_bootTimer > 0)        _bootTimer = 0;
+
+    if (_updateTimerMedium > diff)  _updateTimerMedium -= diff;
+}
+
+void bot_pet_ai::CommonTimers(uint32 diff)
+{
+    events.Update(diff);
+    SpellTimers(diff);
+
+    if (GC_Timer > diff)            GC_Timer -= diff;
+    if (temptimer > diff)           temptimer -= diff;
+    if (roleTimer > diff)           roleTimer -= diff;
+    if (checkAurasTimer != 0)       --checkAurasTimer;
+    if (wait != 0)                  --wait;
+
+    if (regenTimer_mp > diff)       regenTimer_mp -= diff;
+    else if (regenTimer_mp > 0)     regenTimer_mp = 0;
+    if (regenTimer_hp > diff)       regenTimer_hp -= diff;
+    else if (regenTimer_hp > 0)     regenTimer_hp = 0;
+}
+
+void bot_minion_ai::UpdateReviveTimer(uint32 diff)
+{
+    if (me->IsAlive())
+        return;
+
+    if (_reviveTimer > diff)        _reviveTimer -= diff;
+    else
+    {
+        if (IAmFree())
+            BotMgr::ReviveBot(me);
+        else
+            if (_reviveTimer > 0)   _reviveTimer = 0;
+    }
+}
+
+void bot_minion_ai::EnterEvadeMode(bool /*force*/)
+{
+    //if (me->IsInCombat())
+    //    return;
+    if (me->GetVictim())
+        return;
+    if (IsCasting())
+        return;
+    if (CCed(me, true))
+        return;
+
+    if (_atHome && !_evadeMode)
+        return;
+
+    _atHome = true;
+
+    if (!IAmFree())
+    {
+        _evadeMode = false;
+        return;
+    }
+
+    Creature* pet = me->GetBotsPet();
+
+    //me->CombatStop();
+    //if (pet)
+    //    pet->CombatStop();
+
+    //if (!_evadeMode)
+    //{
+    //    ASSERT(!evadeEvent);
+    //    evadeEvent = new EvadeEvent(me->GetGUID(), true);
+    //    events.AddEvent(evadeEvent, events.CalculateTime(0));
+    //    events.Update(0);
+    //}
+
+    uint16 mapid;
+    Position pos;
+    GetHomePosition(mapid, &pos);
+
+    if (mapid != me->GetMapId() || me->GetDistance(pos) > 2000.f || _evadeCount >= 3)
+    {
+        //TeleportHome();
+
+        if (!teleHomeEvent || teleHomeEvent->to_Abort)
+        {
+            teleHomeEvent = new TeleportHomeEvent(this);
+            events.AddEvent(teleHomeEvent, events.CalculateTime(5000));
+        }
+        _evadeMode = false;
+        return;
+    }
+
+    float dist = me->GetDistance(pos);
+    if (dist > 1.5f)
+    {
+        if (!_evadeMode)
+            ++_evadeCount;
+        else if (me->isMoving() && Rand() > 30)
+            return;
+
+        _evadeMode = true;
+
+        //me->AddUnitState(UNIT_STATE_EVADE);
+        //if (pet)
+        //    pet->AddUnitState(UNIT_STATE_EVADE);
+
+        me->BotStopMovement();
+        if (pet)
+            pet->BotStopMovement();
+
+        bool farpoint = true;
+        if (dist > 50)
+        {
+            float dx = pos.m_positionX - me->m_positionX;
+            float dy = pos.m_positionY - me->m_positionY;
+            float fdx = fabs(dx); float fdy = fabs(dy);
+            float divider =
+                fdx > 1800 || fdy > 1800 ? 120.0f :
+                fdx > 900  || fdy > 900  ?  60.0f :
+                fdx > 600  || fdy > 600  ?  30.0f :
+                fdx > 400  || fdy > 400  ?  20.0f :
+                fdx > 200  || fdy > 200  ?  10.0f :
+                fdx > 100  || fdy > 100  ?   7.0f : 3.0f;
+            dx = dx / divider + me->m_positionX;
+            dy = dy / divider + me->m_positionY;
+            float z = me->GetMap()->GetHeight(dx, dy, me->m_positionZ);
+
+            if (z > INVALID_HEIGHT && fabs(me->m_positionZ - z) > 0.05f)
+            {
+                me->GetMotionMaster()->MovePoint(mapid, dx, dy, z + 0.1f, true);
+                farpoint = false;
+            }
+        }
+
+        if (farpoint)
+        {
+            me->GetMotionMaster()->MovePoint(mapid, pos);
+            if (pet)
+                pet->SetBotCommandState(COMMAND_FOLLOW, true);
+        }
+
+        return;
+    }
+
+    if (me->isMoving())
+        return;
+
+    _evadeMode = false;
+    _evadeCount = 0;
+
+    me->SetFacingTo(pos.GetOrientation());
+    me->SetStandState(UNIT_STAND_STATE_SIT);
+
+    //if (evadeEvent)
+    //{
+    //    evadeEvent->to_Abort = true;
+    //    evadeEvent->Execute(evadeEvent->m_addTime, evadeEvent->m_execTime);
+    //}
+
+    //me->ClearUnitState(UNIT_STATE_EVADE);
+    //if (pet)
+    //    pet->ClearUnitState(UNIT_STATE_EVADE);
+
+    me->setFaction(me->GetCreatureTemplate()->faction);
+    if (pet)
+        pet->setFaction(pet->GetCreatureTemplate()->faction);
+
+    //RestorePositionMods();
+}
+//TeleportHome() ONLY CALLED THROUGH EVENTPROCESSOR
+void bot_minion_ai::TeleportHome()
+{
+    ASSERT(teleHomeEvent);
+    //ASSERT(IAmFree());
+
+    AbortTeleport();
+
+    uint16 mapid;
+    Position pos;
+    GetHomePosition(mapid, &pos);
+
+    Map* map = sMapMgr->CreateBaseMap(mapid);
+    ASSERT(map && !map->Instanceable());
+    BotMgr::TeleportBot(me, map, &pos);
+
+    spawned = false;
+    _evadeCount = 0;
+
+    //Reset();
+}
+//FinishTeleport(uint32, float, float, float, float) ONLY CALLED THROUGH EVENTPROCESSOR
+bool bot_minion_ai::FinishTeleport(/*uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/)
+{
+    ASSERT(teleFinishEvent);
+    //ASSERT(!IAmFree());
+    ASSERT(!me->IsInWorld());
+
+    AbortTeleport();
+
+    //1) Cannot teleport: master disappeared - return home
+    if (IAmFree()/* || master->GetSession()->isLogingOut()*/)
+    {
+        uint16 mapid;
+        Position pos;
+        GetHomePosition(mapid, &pos);
+
+        teleHomeEvent = new TeleportHomeEvent(this);
+        events.AddEvent(teleHomeEvent, events.CalculateTime(0)); //make sure event will be deleted
+        teleHomeEvent->to_Abort = true; //make sure event will not be executed twice
+        teleHomeEvent->Execute(0,0);
+        _evadeMode = false;
+
+        return false;
+    }
+
+    Map* map = master->FindMap();
+    //2) Cannot teleport: map not found or forbidden - delay teleport
+    if (!map || master->GetBotMgr()->RestrictBots(me, true))
+    {
+        //ChatHandler ch(master->GetSession());
+        //ch.PSendSysMessage("Your bot %s cannot teleport to you. Restricted bot access on this map...", me->GetName().c_str());
+        teleFinishEvent = new TeleportFinishEvent(this/*, master->GetMapId(), x, y, z, o*/);
+        events.AddEvent(teleFinishEvent, events.CalculateTime(5000));
+        return false;
+    }
+
+    me->SetMap(map);
+    me->Relocate(master);
+    map->AddToMap(me);
+    me->BotStopMovement();
+    //bot->SetAI(oldAI);
+    me->IsAIEnabled = true;
+
+    master->m_Controlled.insert(me);
+    me->CastSpell(me, COSMETIC_TELEPORT_EFFECT, true);
+
+    //update group member online state
+    if (Group* gr = master->GetGroup())
+        if (gr->IsMember(me->GetGUID()))
+            gr->SendUpdate();
+
+    return true;
+}
+
+void bot_minion_ai::AbortTeleport()
+{
+    if (teleHomeEvent)
+    {
+        teleHomeEvent->to_Abort = true;
+        teleHomeEvent = NULL;
+    }
+
+    if (teleFinishEvent)
+    {
+        teleFinishEvent->to_Abort = true;
+        teleFinishEvent = NULL;
+    }
+
+    CancelBoot();
+}
+
+void bot_ai::GetHomePosition(uint16& mapid, Position* pos)
+{
+    CreatureData const* data = me->GetCreatureData();
+    mapid = data->mapid;
+    pos->Relocate(data->posX, data->posY, data->posZ, data->orientation);
+}
+
+void bot_ai::KillEvents(bool force)
+{
+    events.KillAllEvents(force);
+}
+
+bool bot_ai::IsBotImmuneToSpell(SpellInfo const* spellInfo) const
+{
+    if (spellInfo->_IsPositiveSpell())
+        return false;
+
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        //bots of W3 classes will not be easily CCed
+        if (spellInfo->GetDuration() > 0 && spellInfo->GetDuration() <= 3000 &&
+            (spellInfo->HasAura(SPELL_AURA_MOD_STUN) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_CONFUSE) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_CHARM) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_FEAR) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_PACIFY) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_ROOT) ||
+            spellInfo->HasAura(SPELL_AURA_AOE_CHARM)))
+            return true;
+    }
+    return false;
+}
+
+MeleeHitOutcome bot_ai::BotRollCustomMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const
+{
+    if (GetNextAttackMeleeOutCome() != MELEE_HIT_CRUSHING)
+        return GetNextAttackMeleeOutCome();
+    return me->RollMeleeOutcomeAgainst(victim, attType);
+}
+
+void bot_ai::BotJumpInPlaceInFrontOf(Position* pos, float speedXY, float maxHeight)
+{
+    float sign = (me->GetPositionX() < pos->GetPositionX()) ? 1.f : -1.f;
+    float x = me->GetPositionX() + 0.14f * sign;
+    sign = (me->GetPositionY() < pos->GetPositionY()) ? 1.f : -1.f;
+    float y = me->GetPositionY() + 0.14f * sign;
+    float z = me->GetPositionZ() - 0.01f;
+    //float floorz = Map::GetHeight(x, y, z, true, 5.f);
+
+    //me->AttackStop();
+    me->BotStopMovement();
+    me->GetMotionMaster()->MoveJump(x, y, z, speedXY, maxHeight);
+}
+
+void bot_ai::BuildGrouUpdatePacket(WorldPacket* data)
+{
+    uint32 mask = GROUP_UPDATE_FULL;
+
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)                // if update power type, update current/max power also
+        mask |= (GROUP_UPDATE_FLAG_CUR_POWER | GROUP_UPDATE_FLAG_MAX_POWER);
+
+    if (mask & GROUP_UPDATE_FLAG_PET_POWER_TYPE)            // same for pets
+        mask |= (GROUP_UPDATE_FLAG_PET_CUR_POWER | GROUP_UPDATE_FLAG_PET_MAX_POWER);
+
+    uint32 byteCount = 0;
+    for (uint8 i = 1; i < GROUP_UPDATE_FLAGS_COUNT; ++i)
+        if (mask & (1 << i))
+            byteCount += GroupUpdateLength[i];
+
+    data->Initialize(SMSG_PARTY_MEMBER_STATS, 8 + 4 + byteCount);
+    data->append(me->GetPackGUID());
+    *data << uint32(mask);
+
+    if (mask & GROUP_UPDATE_FLAG_STATUS)
+    {
+        uint16 playerStatus = MEMBER_STATUS_ONLINE;
+        if (me->IsPvP())
+            playerStatus |= MEMBER_STATUS_PVP;
+
+        if (!me->IsAlive())
+            playerStatus |= MEMBER_STATUS_DEAD;
+
+        if (me->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            playerStatus |= MEMBER_STATUS_PVP_FFA;
+
+        *data << uint16(playerStatus);
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_HP)
+        *data << uint32(me->GetHealth());
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_HP)
+        *data << uint32(me->GetMaxHealth());
+
+    Powers powerType = me->getPowerType();
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)
+        *data << uint8(powerType);
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_POWER)
+        *data << uint16(me->GetPower(powerType));
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_POWER)
+        *data << uint16(me->GetMaxPower(powerType));
+
+    if (mask & GROUP_UPDATE_FLAG_LEVEL)
+        *data << uint16(me->getLevel());
+
+    if (mask & GROUP_UPDATE_FLAG_ZONE)
+        *data << uint16(me->GetZoneId());
+
+    if (mask & GROUP_UPDATE_FLAG_POSITION)
+    {
+        *data << uint16(me->GetPositionX());
+        *data << uint16(me->GetPositionY());
+    }
+
+    //TODO: ...?
+    //if (mask & GROUP_UPDATE_FLAG_AURAS)
+    //{
+    //    uint64 auramask = player->GetAuraUpdateMaskForRaid();
+    //    *data << uint64(auramask);
+    //    for (uint32 i = 0; i < MAX_AURAS; ++i)
+    //    {
+    //        if (auramask & (uint64(1) << i))
+    //        {
+    //            AuraApplication const* aurApp = player->GetVisibleAura(i);
+    //            *data << uint32(aurApp ? aurApp->GetBase()->GetId() : 0);
+    //            *data << uint8(1);
+    //        }
+    //    }
+    //}
+
+    //if (mask & GROUP_UPDATE_FLAG_VEHICLE_SEAT)
+    //{
+    //    if (Vehicle* veh = me->GetVehicle())
+    //        *data << uint32(veh->GetVehicleInfo()->m_seatID[me->m_movementInfo.transport.seat]);
+    //    else
+    //        *data << uint32(0);
+    //}
+}
+
+bool bot_ai::IsBotCustomSpell(uint32 spellId)
+{
+    return BotCustomSpells.find(spellId) != BotCustomSpells.end();
+}
+
+void bot_ai::InitBotCustomSpells()
+{
+    if (SPELLS_DEFINED)
+    {
+        //TC_LOG_ERROR("entities.player", "Bot custom spells initialization... fail...");
+        return;
+    }
+    //TC_LOG_ERROR("entities.player", "Bot custom spells initialization... success...");
+    SPELLS_DEFINED = true;
+
+    //see bot_ai.h::CommonValues::CUSTOM_SPELLS
+    //all ids must be here
+    //BotCustomSpells.insert(BLIZZARD_VISUAL_PERSISTENT_AURA);
+    //BotCustomSpells.insert(BLIZZARD_VISUAL_PROC);
+
+    //BotCustomSpells.insert(SPELL_COMBAT_SPECIAL_2H_ATTACK); //exclusive
+    BotCustomSpells.insert(SPELL_TRANSPARENCY_50);//3.1
+    BotCustomSpells.insert(SPELL_NETHERWALK);//3
+    BotCustomSpells.insert(SPELL_MIRROR_IMAGE_BM);//4
+
+    uint32 trig;
+    SpellInfo* trigInfo;
+    uint32 spellId;
+    SpellInfo* sinfo;
+
+    //1) BLIZZARD
+    //1.1) BLIZZARD PROC
+    //trig = BLIZZARD_VISUAL_PROC; //rain
+    //trigInfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(trig));
+
+    //trigInfo->Dispel = DISPEL_NONE;
+    //trigInfo->Mechanic = MECHANIC_NONE;
+    //trigInfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+
+    //trigInfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //1 - instant //3 - 0.5 sec
+    //trigInfo->ManaCost = 0;
+    //trigInfo->ManaCostPercentage = 0;
+    //trigInfo->ManaCostPerlevel = 0;
+
+    //trigInfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    //trigInfo->Effects[0].BasePoints = 1;
+    //trigInfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_CHANNEL_TARGET);
+    //trigInfo->Effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+    //trigInfo->Effects[0].ApplyAuraName = SPELL_AURA_NONE;
+    //trigInfo->Effects[0].Amplitude = 0;
+    //trigInfo->Effects[0].TriggerSpell = 0;
+    //trigInfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+    ////1.1) END BLIZZARD PROC
+
+    //spellId = BLIZZARD_VISUAL_PERSISTENT_AURA; //34167, 34183
+    //sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    //sinfo->Dispel = DISPEL_NONE;
+    //sinfo->Mechanic = MECHANIC_NONE;
+    //sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+
+    //sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //3 - 0.5 sec
+    //sinfo->DurationEntry = sSpellDurationStore.LookupEntry(1); //1 - 10 sec //32 - 6 seconds
+    //sinfo->ManaCost = 0;
+    //sinfo->ManaCostPercentage = 74;
+    //sinfo->ManaCostPerlevel = 0;
+    //sinfo->AttributesEx2 |= SPELL_ATTR2_UNK22;
+    //sinfo->AttributesEx5 |= SPELL_ATTR5_HASTE_AFFECT_DURATION;
+    //sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+    //sinfo->InterruptFlags = 0x0000000F; //15
+    //sinfo->ChannelInterruptFlags = 0x00007C3C; //31788
+
+    //sinfo->Effects[0].Effect = SPELL_EFFECT_PERSISTENT_AREA_AURA;
+    //sinfo->Effects[0].BasePoints = 1;
+    //sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_DYNOBJ_ENEMY);
+    //sinfo->Effects[0].TargetB = SpellImplicitTargetInfo(0);
+    //sinfo->Effects[0].ApplyAuraName = SPELL_AURA_DUMMY;
+    //sinfo->Effects[0].Amplitude = 0;
+    //sinfo->Effects[0].TriggerSpell = 0;
+    //sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+
+    //sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+    //sinfo->Effects[1].BasePoints = 1;
+    //sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    //sinfo->Effects[1].TargetB = SpellImplicitTargetInfo(0);
+    //sinfo->Effects[1].ApplyAuraName = SPELL_AURA_PERIODIC_TRIGGER_SPELL;
+    //sinfo->Effects[1].Amplitude = 2000;
+    //sinfo->Effects[1].TriggerSpell = trig;
+    //sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+    //1) END BLIZZARD
+    {}
+    //2) SPELL_COMBAT_SPECIAL_2H_ATTACK
+    spellId = SPELL_COMBAT_SPECIAL_2H_ATTACK; //1132
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+    sinfo->Attributes &= ~(SPELL_ATTR0_CANT_USED_IN_COMBAT);
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_DEAD;
+    //2) END SPELL_COMBAT_SPECIAL_2H_ATTACK
+
+    //3) WINDWALK
+    //3.1) TRANSPARENCY
+    trig = SPELL_TRANSPARENCY_50; //44816
+    trigInfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(trig));
+    trigInfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING);
+    trigInfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH);
+    trigInfo->AuraInterruptFlags =
+        AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+    trigInfo->CasterAuraStateNot = 0;
+    //3.1) END TRANSPARENCY
+
+
+    spellId = SPELL_NETHERWALK; //31599
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellLevel = 0;
+    sinfo->MaxLevel = 80;
+    sinfo->RecoveryTime = 5000;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->ManaCost = 75;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->Attributes &= ~(SPELL_ATTR0_UNK11);
+    sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY);
+    sinfo->AttributesEx &= ~SPELL_ATTR1_UNK11;
+    sinfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH | SPELL_ATTR1_NO_THREAT);
+    sinfo->AttributesEx2 |= SPELL_ATTR2_UNK1;
+    sinfo->AuraInterruptFlags =
+        AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+    sinfo->CasterAuraStateNot = 0;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[0].BasePoints = 100;
+    sinfo->Effects[0].RealPointsPerLevel = 2.5f;
+    sinfo->Effects[0].ValueMultiplier = 1.0f;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].ApplyAuraName = SPELL_AURA_MOD_INVISIBILITY;
+    sinfo->Effects[0].Amplitude = 0;
+    sinfo->Effects[0].TriggerSpell = 0;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+
+    sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[1].BasePoints = 10;
+    sinfo->Effects[1].RealPointsPerLevel = 0.5f;
+    sinfo->Effects[1].ValueMultiplier = 1.0f;
+    sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[1].TargetB = SpellImplicitTargetInfo(0);
+    sinfo->Effects[1].ApplyAuraName = SPELL_AURA_MOD_INCREASE_SPEED;
+    sinfo->Effects[1].Amplitude = 0;
+    sinfo->Effects[1].TriggerSpell = 0;
+    sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+
+    sinfo->Effects[2].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+    sinfo->Effects[2].BasePoints = 0;
+    sinfo->Effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[2].TargetB = SpellImplicitTargetInfo(0);
+    sinfo->Effects[2].ApplyAuraName = SPELL_AURA_NONE;
+    sinfo->Effects[2].Amplitude = 0;
+    sinfo->Effects[2].TriggerSpell = trig;
+    sinfo->Effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+    //3) END WINDWALK
+
+    //4) MIRROR IMAGE (BLADEMASTER)
+    spellId = SPELL_MIRROR_IMAGE_BM; //69936
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //1 - self only //6 - 100 yds
+    sinfo->DurationEntry = sSpellDurationStore.LookupEntry(566); //566 - 0 sec //3 - 60 sec //1 - 10 sec //32 - 6 seconds
+    sinfo->RecoveryTime = 8000;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->ManaCost = 125;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT/* | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY*/);
+    sinfo->AttributesEx2 &= ~(SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS);
+    sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].MiscValue = 0;
+    sinfo->Effects[0].MiscValueB = 0;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+    //4) END MIRROR IMAGE (BLADEMASTER)
+}
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
new file mode 100644
index 0000000..78c25e3
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.h
@@ -0,0 +1,907 @@
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#include "ScriptedCreature.h"
+/*
+NpcBot System by Graff (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+*/
+
+struct PlayerClassLevelInfo;
+
+//class VisibilityUpdateEvent;
+class TeleportHomeEvent;
+//class EvadeEvent;
+class TeleportFinishEvent;
+
+enum CommonValues
+{
+//MISC
+    BOT_ENTRY_BEGIN                     = 70001,
+    BOT_ENTRY_END                       = 71000,
+    BOT_ICON_ON                         = 9,    //GOSSIP_ICON_BATTLE,
+    BOT_ICON_OFF                        = 7,    //GOSSIP_ICON_TALK,
+    BOT_MAX_CHASE_RANGE                 = 120,  //yds
+    BOT_EVADE_TIME                      = 3000, //ms
+//COMMON SPELLS
+    MANAPOTION                          = 32453,//"Uses a Holy elixir to heal the caster for 32000"
+    HEALINGPOTION                       = 15504,//"Drinks Holy Elixir to heal the caster"
+    DRINK                               = 66041,//"Restores 4% mana per sec for 30 sec"
+    EAT                                 = 66478,//"Restores Health"
+    PVPTRINKET                          = 42292,//PvP Trinket no CD
+    BERSERK                             = 46587,//68378,//900%/150%
+//COMMON CDs
+    POTION_CD                           = 60000,//default 60sec potion cd
+    RATIONS_CD                          = 1000, //update rations every X milliseconds
+//COMMON PASSIVES
+  //1) DEPRECATED"Increase(d) @whatever"
+    //SPELL_BONUS_10                      = 33021,//10spp
+    //SPELL_BONUS_50                      = 45011,//50spp
+    //SPELL_BONUS_150                     = 28141,//150spp
+    //SPELL_BONUS_250                     = 69709,//250spp
+    //FIREDAM_86                          = 33816,//86 fire spp
+    //MANAREGEN45                         = 35867,//45 mp5
+    //MANAREGEN100                        = 45216,//100 mp5
+    //SPELL_PEN_5                         = 31921,//5 sppen
+    //SPELL_PEN_20                        = 26283,//20 sppen
+  //2) DEPRECATEDTalents
+    //HASTE    /*Gift of the EarthMother*/= 51183,//rank 5 10% spell haste
+    //HASTE2   /*Blood Frenzy - warrior*/ = 29859,//rank 2 10% melee haste, bonus for rend (warriors only)
+    //HASTE3   /*       "Haste"       */  = 29418,//rank 0 10% increased ranged attack speed
+    //CRITS    /*Thundering Strikes-sham*/= 16305,//rank 5 5% crit melee/spell
+    //HOLYCRIT /*Holy Spec - priest*/     = 15011,//rank 5 5% holy crit
+    //DODGE    /*Anticipation - paladin*/ = 20100,//rank 5 5% dodge
+    //PARRY    /*Deflection - warrior*/   = 16466,//rank 5 5% parry
+    //BLOCK/*zzOLD Shield Specialization*/= 16253,//rank 1 5% block 10% amount, 3.3.5 & 4.3.4 deprecated
+    //PRECISION /*Precision - rogue*/     = 13843,//rank 3 3% melee/spell hit
+    //PRECISION /*Precision - warrior*/   = 29592,//rank 3 3% melee hit
+    //PRECISION2/*Precision - mage*/      = 29440,//rank 3 3% spell hit, -3% mana cost
+    //DMG_TAKEN/*Deadened Nerves - rogue*/= 31383,//rank 3 6% reduced damage taken all
+    //EXPERTISE /*Weapon Expertise-rogue*/= 30919,//rank 1 5 expertise
+    //EXPERTISE2/*Weapon Expertise-rogue*/= 30920,//rank 2 10 expertise
+  //3) Pet/Special
+    THREAT   /****  (unused)  ****/     = 57339,//+43% threat generated
+    //BOR      /*Blood of Rhino - pet*/   = 53482,//rank 2 +40% healing taken
+    //BOAR     /*Boar's Speed - pet*/     = 19596,//rank 1 +30% movement speed
+    RCP      /*Rogue Class Passive*/    = 21184,//-27% threat caused
+    DEFENSIVE_STANCE_PASSIVE /*Warrior*/= 7376, //+45% threat -10% damage taken -5% damage done
+//COMMON GOSSIPS
+    GOSSIP_SERVE_MASTER                 = 70001, //"I live only to serve the master."
+    GOSSIP_NEED_SMTH                    = 70002, //"You need something?"
+    GOSSIP_MURDER                       = 70003,//"Mortals... usually I kill wretches like you at sight"
+    GOSSIP_CLASS_BM                     = 70004,
+    GOSSIP_SENDER_BEGIN                 = 6000,
+    GOSSIP_SENDER_CLASS,
+    GOSSIP_SENDER_EQUIPMENT,
+    GOSSIP_SENDER_EQUIPMENT_LIST,
+    GOSSIP_SENDER_EQUIPMENT_SHOW,
+    GOSSIP_SENDER_EQUIPMENT_INFO,
+    GOSSIP_SENDER_UNEQUIP,
+    GOSSIP_SENDER_UNEQUIP_ALL,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BEGIN           = GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_MHAND           = GOSSIP_SENDER_EQUIP_AUTOEQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_NECK,
+    GOSSIP_SENDER_EQUIP_RESET,
+    GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_BEGIN           = GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_MHAND           = GOSSIP_SENDER_EQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_NECK,
+    GOSSIP_SENDER_ROLES,
+    GOSSIP_SENDER_ROLES_TOGGLE,
+    GOSSIP_SENDER_ABILITIES,
+    GOSSIP_SENDER_ABILITIES_USE,
+    GOSSIP_SENDER_HIRE,
+    GOSSIP_SENDER_DISMISS,
+    GOSSIP_SENDER_JOIN_GROUP,
+    GOSSIP_SENDER_LEAVE_GROUP,
+    GOSSIP_SENDER_FORMATION,
+    GOSSIP_SENDER_FORMATION_DISTANCE,
+    GOSSIP_SENDER_SCAN,
+    GOSSIP_SENDER_SCAN_OWNER,
+    GOSSIP_SENDER_SCAN_OWNER_ABILITY,
+    GOSSIP_SENDER_DEBUG,
+    GOSSIP_SENDER_DEBUG_ACTION,
+//COMMON NPCS
+    NPC_WORLD_TRIGGER                   = 22515,
+//COMMON GAMEEVENTS
+    GAME_EVENT_WINTER_VEIL              = 2,
+//COMMON MOUNTS SPELLS
+    REINDEER                            = 25859,
+    REINDEER_FLY                        = 44827,
+//ADVANCED
+    COSMETIC_TELEPORT_EFFECT            = 52096,//visual instant cast omni
+    //COSMETIC_SMOKING_CORPSE_AURA        = 51201,//black model + fire step (permanent)
+
+
+////CUSTOM SPELLS
+//ARCHMAGE
+  //modify
+/**/BLIZZARD_VISUAL_PERSISTENT_AURA     = 34167,
+    BLIZZARD_VISUAL_PROC                = 29969,
+
+//BLADEMASTER
+/**/ //- used explicitly within the script
+  //SPELLS
+  //unmodify
+    SPELL_DEATH_GRIP_JUMP               = 49575,
+/**/SPELL_CRITICAL_STRIKE               = 1132,
+    SPELL_BURNING_BLADE_BLADEMASTER     = 32281,//horde flag visual
+    SPELL_POSESS                        = 17250,//immunity,invis,stun
+    //SPELL_SELFSTUN                      = 24883,//green smoke, transparency, stun
+    SPELL_STUN_FREEZE_ANIM              = 59123,//stun forever, full stop
+  //modify
+    SPELL_TRANSPARENCY_50               = 44816,
+/**/SPELL_NETHERWALK                    = 31599,
+/**/SPELL_MIRROR_IMAGE_BM               = 69936,//blank spell
+  //SOUNDS
+    SOUND_FREEZE_IMPACT_WINDWALK        = 29,
+    SOUND_AXE_2H_IMPACT_FLESH_CRIT      = 158,
+    SOUND_ABSORB_GET_HIT                = 3334,
+    SOUND_MISS_WHOOSH_2H                = 7081,
+
+//OTHER
+  //unmodify
+    SPELL_VERTEX_COLOR_BLACK            = 39662,//black color model full
+    //SPELL_NIGHTMARE_VULNERABILITY       = 54199,//100% dmg taken, 100% crit chance taken (x4 dmg taken)
+  //modify
+    SPELL_COMBAT_SPECIAL_2H_ATTACK      = 44079
+};
+
+enum BotClasses
+{
+    BOT_CLASS_NONE                      = CLASS_NONE,
+    BOT_CLASS_WARRIOR                   = CLASS_WARRIOR,
+    BOT_CLASS_PALADIN                   = CLASS_PALADIN,
+    BOT_CLASS_HUNTER                    = CLASS_HUNTER,
+    BOT_CLASS_ROGUE                     = CLASS_ROGUE,
+    BOT_CLASS_PRIEST                    = CLASS_PRIEST,
+    BOT_CLASS_DEATH_KNIGHT              = CLASS_DEATH_KNIGHT,
+    BOT_CLASS_SHAMAN                    = CLASS_SHAMAN,
+    BOT_CLASS_MAGE                      = CLASS_MAGE,
+    BOT_CLASS_WARLOCK                   = CLASS_WARLOCK,
+    BOT_CLASS_DRUID                     = CLASS_DRUID,
+
+    BOT_CLASS_BM,
+
+    BOT_CLASS_END,
+
+    BOT_CLASS_NORMAL_START              = BOT_CLASS_WARRIOR,
+    BOT_CLASS_NORMAL_END                = BOT_CLASS_BM,
+    BOT_CLASS_EX_START                  = BOT_CLASS_BM,
+    BOT_CLASS_EX_END
+};
+
+enum BotStances
+{
+    BOT_STANCE_NONE                     = 0,
+    WARRIOR_BATTLE_STANCE               = BOT_CLASS_EX_END,
+    WARRIOR_DEFENSIVE_STANCE,
+    WARRIOR_BERSERKER_STANCE,
+    DEATH_KNIGHT_BLOOD_PRESENCE,
+    DEATH_KNIGHT_FROST_PRESENCE,
+    DEATH_KNIGHT_UNHOLY_PRESENCE,
+    DRUID_BEAR_FORM,
+    DRUID_CAT_FORM,
+    //DRUID_TRAVEL_FORM,                //NYI
+    //DRUID_FLY_FORM,                   //NYI
+    DRUID_MOONKIN_FORM                  //NYI
+};
+
+enum BotRoles
+{
+    BOT_ROLE_NONE                       = 0x00,
+    BOT_ROLE_TANK                       = 0x01,
+    BOT_ROLE_DPS                        = 0x02,
+    BOT_ROLE_HEAL                       = 0x04,
+    BOT_ROLE_RANGED                     = 0x08,
+
+    BOT_ROLE_PARTY                      = 0x10, //hidden
+
+    //BOT_ROLE_TANK_MELEE                 = (BOT_ROLE_TANK | BOT_ROLE_DPS),
+    //BOT_ROLE_TANK_RANGED                = (BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_RANGED),
+
+    BOT_MAX_ROLE                        = 0x20
+};
+
+enum BotPetTypes
+{
+    PET_TYPE_NONE,
+//Warlock
+    PET_TYPE_IMP,
+    PET_TYPE_VOIDWALKER,
+    PET_TYPE_SUCCUBUS,
+    PET_TYPE_FELHUNTER,
+    PET_TYPE_FELGUARD,
+//Mage
+    PET_TYPE_WATER_ELEMENTAL,
+//Shaman
+    //PET_TYPE_GHOSTLY_WOLF,
+    PET_TYPE_FIRE_ELEMENTAL,
+    PET_TYPE_EARTH_ELEMENTAL,
+//Hunter
+    PET_TYPE_VULTURE,
+
+    MAX_PET_TYPES
+};
+
+enum WarlockBotPets
+{
+    //PET_IMP                     = ,
+    PET_VOIDWALKER              = 70247
+    //PET_SUCCUBUS                =
+};
+
+enum HunterBotPets
+{
+    PET_VULTURE                 = 70248
+};
+
+enum BotPetsOriginalEntries
+{
+    ORIGINAL_ENTRY_VOIDWALKER   = 1860
+};
+
+enum BotEquipSlot
+{
+    BOT_SLOT_NONE               = 0,
+    BOT_SLOT_MAINHAND           = 1,
+    BOT_SLOT_OFFHAND            = 2,
+    BOT_SLOT_RANGED             = 3,
+    BOT_SLOT_HEAD               = 4,
+    BOT_SLOT_SHOULDERS          = 5,
+    BOT_SLOT_CHEST              = 6,
+    BOT_SLOT_WAIST              = 7,
+    BOT_SLOT_LEGS               = 8,
+    BOT_SLOT_FEET               = 9,
+    BOT_SLOT_WRIST              = 10,
+    BOT_SLOT_HANDS              = 11,
+    BOT_SLOT_BACK               = 12,
+    BOT_SLOT_BODY               = 13,
+    BOT_SLOT_FINGER1            = 14,
+    BOT_SLOT_FINGER2            = 15,
+    BOT_SLOT_TRINKET1           = 16,
+    BOT_SLOT_TRINKET2           = 17,
+    BOT_SLOT_NECK               = 18,
+    BOT_MAX_SLOTS,
+    BOT_INVENTORY_SIZE = BOT_MAX_SLOTS - 1
+};
+
+enum BotItemStat
+{
+    //ItemProtoType.h
+    BOT_ITEM_MOD_MANA                       = 0,
+    BOT_ITEM_MOD_HEALTH                     = 1,
+    BOT_ITEM_MOD_AGILITY                    = 3,
+    BOT_ITEM_MOD_STRENGTH                   = 4,
+    BOT_ITEM_MOD_INTELLECT                  = 5,
+    BOT_ITEM_MOD_SPIRIT                     = 6,
+    BOT_ITEM_MOD_STAMINA                    = 7,
+    BOT_ITEM_MOD_DEFENSE_SKILL_RATING       = 12,
+    BOT_ITEM_MOD_DODGE_RATING               = 13,
+    BOT_ITEM_MOD_PARRY_RATING               = 14,
+    BOT_ITEM_MOD_BLOCK_RATING               = 15,
+    BOT_ITEM_MOD_HIT_MELEE_RATING           = 16,
+    BOT_ITEM_MOD_HIT_RANGED_RATING          = 17,
+    BOT_ITEM_MOD_HIT_SPELL_RATING           = 18,
+    BOT_ITEM_MOD_CRIT_MELEE_RATING          = 19,
+    BOT_ITEM_MOD_CRIT_RANGED_RATING         = 20,
+    BOT_ITEM_MOD_CRIT_SPELL_RATING          = 21,
+    BOT_ITEM_MOD_HIT_TAKEN_MELEE_RATING     = 22,
+    BOT_ITEM_MOD_HIT_TAKEN_RANGED_RATING    = 23,
+    BOT_ITEM_MOD_HIT_TAKEN_SPELL_RATING     = 24,
+    BOT_ITEM_MOD_CRIT_TAKEN_MELEE_RATING    = 25,
+    BOT_ITEM_MOD_CRIT_TAKEN_RANGED_RATING   = 26,
+    BOT_ITEM_MOD_CRIT_TAKEN_SPELL_RATING    = 27,
+    BOT_ITEM_MOD_HASTE_MELEE_RATING         = 28,
+    BOT_ITEM_MOD_HASTE_RANGED_RATING        = 29,
+    BOT_ITEM_MOD_HASTE_SPELL_RATING         = 30,
+    BOT_ITEM_MOD_HIT_RATING                 = 31,
+    BOT_ITEM_MOD_CRIT_RATING                = 32,
+    BOT_ITEM_MOD_HIT_TAKEN_RATING           = 33,
+    BOT_ITEM_MOD_CRIT_TAKEN_RATING          = 34,
+    BOT_ITEM_MOD_RESILIENCE_RATING          = 35,
+    BOT_ITEM_MOD_HASTE_RATING               = 36,
+    BOT_ITEM_MOD_EXPERTISE_RATING           = 37,
+    BOT_ITEM_MOD_ATTACK_POWER               = 38,
+    BOT_ITEM_MOD_RANGED_ATTACK_POWER        = 39,
+    BOT_ITEM_MOD_FERAL_ATTACK_POWER         = 40,
+    BOT_ITEM_MOD_SPELL_HEALING_DONE         = 41,                 // deprecated
+    BOT_ITEM_MOD_SPELL_DAMAGE_DONE          = 42,                 // deprecated
+    BOT_ITEM_MOD_MANA_REGENERATION          = 43,
+    BOT_ITEM_MOD_ARMOR_PENETRATION_RATING   = 44,
+    BOT_ITEM_MOD_SPELL_POWER                = 45,
+    BOT_ITEM_MOD_HEALTH_REGEN               = 46,
+    BOT_ITEM_MOD_SPELL_PENETRATION          = 47,
+    BOT_ITEM_MOD_BLOCK_VALUE                = 48,
+    //END ItemProtoType.h
+
+    BOT_ITEM_MOD_DAMAGE                     = MAX_ITEM_MOD,
+    BOT_ITEM_MOD_ARMOR,
+    BOT_ITEM_MOD_RESIST_HOLY,
+    BOT_ITEM_MOD_RESIST_FIRE,
+    BOT_ITEM_MOD_RESIST_NATURE,
+    BOT_ITEM_MOD_RESIST_FROST,
+    BOT_ITEM_MOD_RESIST_SHADOW,
+    BOT_ITEM_MOD_RESIST_ARCANE,
+    BOT_ITEM_MOD_EX,
+    MAX_BOT_ITEM_MOD,
+
+    BOT_ITEM_MOD_RESISTANCE_START = BOT_ITEM_MOD_ARMOR
+};
+
+enum BotAIResetType
+{
+    BOTAI_RESET_INIT                    = 0x01,
+    BOTAI_RESET_DISMISS                 = 0x02,
+    BOTAI_RESET_LOST                    = 0x04,
+    BOTAI_RESET_LOGOUT                  = 0x08, //NYI
+
+    BOTAI_RESET_ABANDON_MASTER          = (BOTAI_RESET_INIT | BOTAI_RESET_DISMISS)
+};
+
+class bot_ai : public ScriptedAI
+{
+    friend class BotMgr;
+    friend class script_bot_commands;
+    private:
+        void SetBotOwnerGUID(uint32 guidlow) { _ownerGuid = guidlow; }
+    public:
+        virtual ~bot_ai();
+        bot_ai(Creature* creature);
+        //void OnCharmed(bool /*apply*/) { }
+        EventProcessor* GetEvents() { return &events; }
+        uint32 GetBotOwnerGuid() const { return _ownerGuid; }
+        Player* GetBotOwner() const { return master; }
+        bool SetBotOwner(Player* newowner);
+        uint8 GetBotClass() const { return _botclass; }
+        uint32 GetLastDiff() const { return lastdiff; }
+        virtual void Reset() {}
+        virtual void EnterEvadeMode() {}
+        virtual void JustDied(Unit*) {}
+        virtual void EnterCombat(Unit*) {}
+        virtual void MoveInLineOfSight(Unit*) {}
+        virtual void ReturnHome() {}
+        virtual void CommonTimers(uint32 /*diff*/) = 0;
+        void ResetBotAI(uint8 resetType = BOTAI_RESET_INIT);
+        void KillEvents(bool force);
+        void FindMaster(bool force = false);
+        virtual bool IsMinionAI() const = 0;
+        virtual bool IsPetAI() const = 0;
+        virtual bool CanRespawn() = 0;
+        virtual void SetBotCommandState(CommandStates /*st*/, bool /*force*/ = false, Position* /*newpos*/ = NULL) = 0;
+        virtual const bot_minion_ai* GetMinionAI() const { return NULL; }
+        virtual const bot_pet_ai* GetPetAI() const { return NULL; }
+        bot_minion_ai const* ToMinionAI() const { return IsMinionAI() ? GetMinionAI() : NULL; }
+        bot_minion_ai* ToMinionAI() { return IsMinionAI() ? const_cast<bot_minion_ai*>(GetMinionAI()) : NULL; }
+        bot_pet_ai const* ToPetAI() const { return IsPetAI() ? GetPetAI() : NULL; }
+        bot_pet_ai* ToPetAI() { return IsPetAI() ? const_cast<bot_pet_ai*>(GetPetAI()) : NULL; }
+        bool IsInBotParty(Unit const* unit) const;
+        bool CanBotAttack(Unit const* target, int8 byspell = 0) const;
+        bool InDuel(Unit const* target) const;
+        CommandStates GetBotCommandState() const { return m_botCommandState; }
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const;
+        void ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const;
+        void ApplyBotSpellCostMods(SpellInfo const* spellInfo, int32& cost) const;
+        void ApplyBotSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const;
+        void ApplyBotSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const;
+        void ApplyBotSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const;
+        void ApplyBotSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const;
+        //inline void SendPartyEvadeAbort() const;
+        inline void SetNeedParty(bool need) { needparty = need; }
+        inline void SetShouldUpdateStats() { shouldUpdateStats = true; }
+        inline void UpdateHealth() { doHealth = true; }
+        inline void UpdateMana() { doMana = true; }
+        inline uint32 GetManaRegen() const { return regen_mp; }
+        inline float GetHitRating() const { return hit; }
+        inline int32 GetHaste() const { return haste; }
+        inline float GetShieldBlockValue() const { return blockvalue; }
+        virtual uint8 GetBotStance() const { return BOT_STANCE_NONE; }
+        inline uint8 GetBotRoles() const { return _roleMask; }
+        inline bool HasRole(uint8 role) const { return _roleMask & role; }
+        void ToggleRole(uint8 role, bool force);
+        char const* GetRoleString(uint8 role) const;
+
+        virtual void OnBotSummon(Creature* /*summon*/) {}
+        virtual void OnBotDespawn(Creature* /*summon*/) {}
+        virtual void UnsummonAll() {}
+
+        void ReceiveEmote(Player* player, uint32 emote);
+        void ApplyPassives() const;
+
+        virtual void RemoveItemBonuses(uint8 /*slot*/) {}
+        virtual void ApplyItemBonuses(uint8 /*slot*/) {}
+
+        static inline bool CCed(Unit* target, bool root = false)
+        {
+            return target ? target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && (target->HasUnitState(UNIT_STATE_ROOT) || target->isFrozen() || target->isInRoots())) : true;
+        }
+
+        //virtual bool CanUseOffHand() const { return false; }
+        //virtual bool CanUseRanged() const { return false; }
+        //virtual bool CanEquip(ItemTemplate const* /*item*/, uint8 /*slot*/) const { return false; }
+        //virtual bool Unequip(uint8 /*slot*/) { return false; }
+        //virtual bool Equip(uint8 /*slot*/, Item* /*item*/) { return false; }
+        //virtual bool ResetEquipment(uint8 /*slot*/) { return false; }
+
+        static void BotSpeak(std::string const& text, uint8 msgtype, uint32 language, uint64 sender, uint64 receiver);
+
+        virtual void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType);
+        virtual bool IAmFree() const { return false; }
+
+        virtual void SetStats(bool, bool = false) = 0;
+        void DefaultInit();
+
+        void GetHomePosition(uint16& mapid, Position* pos);
+
+        virtual bool UpdateImpossibleChase(Unit* /*target*/) { return false; }
+        virtual bool IsDuringTeleport() const { return false; }
+        virtual void AbortTeleport() {}
+        virtual void ResetChase(Position* /*pos*/) {}
+
+        virtual uint8 GetPlayerClass() const { ASSERT(_botclass < BOT_CLASS_EX_START); return _botclass; }
+
+        virtual float GetBotParryChance() const { return CanParry() ? parry : 0.0f; }
+        virtual bool CanParry() const = 0;
+        virtual float GetBotDodgeChance() const { return CanDodge() ? dodge : 0.0f; }
+        virtual bool CanDodge() const = 0;
+        virtual float GetBotBlockChance() const { return CanBlock() ? block : 0.0f; }
+        virtual bool CanBlock() const = 0;
+        virtual float GetBotCritChance() const { return CanCrit() ? crit : 0.0f; }
+        virtual bool CanCrit() const = 0;
+        virtual float GetBotMissChance() const { return -hit; }
+        virtual bool CanMiss() const = 0;
+        virtual float GetBotEvasion() const { return 0.0f; }
+        virtual float GetBotArmorPenetrationCoef() const { return 0.0f; }
+        virtual float GetSpellMiscValue(uint32 /*basespell*/, uint8 /*offset*/ = 0) const { return 0.0f; }
+        virtual float GetBotDamageTakenMod() const { return dmg_taken; }
+        virtual uint32 GetBotExpertise() const { return expertise; }
+        virtual uint32 GetBotSpellPenetration() const { return spellpen; }
+        virtual uint32 GetBotSpellPower() const { return spellpower; }
+
+        virtual bool IsBotImmuneToSpell(SpellInfo const* spellInfo) const;
+
+        MeleeHitOutcome BotRollCustomMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const;
+
+        virtual void CastBotItemCombatSpell(Unit* /*target*/, WeaponAttackType /*attType*/, uint32 /*procVictim*/, uint32 /*procEx*/, Spell const* /*spell = NULL*/) {}
+        virtual void OnBotSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs);
+        virtual void OnBotSpellGo(Spell const* spell);
+        virtual void OnClassSpellGo(SpellInfo const* /*spellInfo*/) {}
+
+        static void InitBotCustomSpells();
+        static bool IsBotCustomSpell(uint32 spellId);
+
+        bool IsTempBot() const { return _temp; }
+        void SetBotIsTemp() { _temp = true; }
+
+        void StartBoot() { _bootTimer = 60000; }
+        void CancelBoot() { _bootTimer = -1; }
+
+        bool IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD = true, uint32 forcedTime = 0) const;
+        void SetSpellCooldown(uint32 basespell, uint32 msCooldown);
+        void SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown);
+    protected:
+        static uint32 InitSpell(Unit const* caster, uint32 spell);
+        void InitSpellMap(uint32 basespell, bool forceadd = false, bool forwardRank = true);
+        uint32 GetSpell(uint32 basespell) const;
+        uint32 GetSpellCooldown(uint32 basespell) const;
+        void ResetSpellCooldown(uint32 basespell) { SetSpellCooldown(basespell, 0); }
+        void RemoveSpell(uint32 basespell);
+        void SpellTimers(uint32 diff);
+
+        virtual void InitRoles() = 0;
+        bool IsTank(Unit* unit = NULL) const;
+
+        bool HasAuraName(Unit* unit, uint32 spellId, uint64 casterGuid = 0, bool exclude = false) const;
+        bool RefreshAura(uint32 spellId, int8 count = 1) const;
+        bool CheckAttackTarget(uint8 botOrPetType);
+        bool MoveBehind(Unit &target) const;
+        bool CheckImmunities(uint32 spell, Unit* target = NULL) const { return (spell && target && !target->ToCorpse() && target->IsHostileTo(me) ? !target->IsImmunedToDamage(sSpellMgr->GetSpellInfo(spell)) : true); }
+
+        //everything cast-related
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false, uint64 originalCaster = 0);
+        SpellCastResult CheckBotCast(Unit* victim, uint32 spellId, uint8 botclass) const;
+        virtual void removeFeralForm(bool /*force*/ = false, bool /*init*/ = true, uint32 /*diff*/ = 0) {}
+
+        inline bool JumpingFlyingOrFalling() const { return me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_SPLINE_ELEVATION|MOVEMENTFLAG_FALLING_SLOW); }
+        inline bool Feasting() const { return (me->HasAura(EAT) || me->HasAura(DRINK)); }
+        inline bool IsMeleeClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT || m_class == BOT_CLASS_BM); }
+        inline bool IsTankingClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT); }
+        inline bool IsChanneling(Unit* u = NULL) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        inline bool IsCasting(Unit* u = NULL) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCast(false, false, true)); }
+
+        void GetInPosition(bool force = false, Unit* newtarget = NULL, Position* pos = NULL);
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+        void CalculateAttackPos(Unit* target, Position &pos) const;
+        virtual void CheckAttackState();
+        virtual void Evade(bool = false) {}
+        virtual void OnStartAttack(Unit* /*u*/) {}
+
+        virtual void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+        virtual void ApplyClassDamageMultiplierMelee(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& /*heal*/, SpellInfo const* /*spellInfo*/, DamageEffectType /*damagetype*/, uint32 /*stack*/) const {}
+        virtual void ApplyClassCritMultiplierHeal(Unit const* /*victim*/, float& /*crit_chance*/, SpellInfo const* /*spellInfo*/, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const {}
+        virtual void ApplyClassSpellCostMods(SpellInfo const* /*spellInfo*/, int32& /*cost*/) const {}
+        virtual void ApplyClassSpellCastTimeMods(SpellInfo const* /*spellInfo*/, int32& /*casttime*/) const {}
+        virtual void ApplyClassSpellCooldownMods(SpellInfo const* /*spellInfo*/, uint32& /*cooldown*/) const {}
+        virtual void ApplyClassSpellCategoryCooldownMods(SpellInfo const* /*spellInfo*/, uint32& /*cooldown*/) const {}
+        virtual void ApplyClassSpellGlobalCooldownMods(SpellInfo const* /*spellInfo*/, float& /*cooldown*/) const {}
+        virtual void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
+        virtual void CheckAuras(bool /*force*/ = false) {}
+        virtual void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        virtual void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        virtual void InitSpells() {}
+        virtual void InitPowers() {}
+        virtual void InitEquips() {}
+        virtual void InitOwner() {}
+        virtual void InitFaction() {}
+        virtual void SavePosition() {}
+        virtual void ApplyClassPassives() = 0;
+        virtual void _OnHealthUpdate() const = 0;
+        virtual void _OnManaUpdate(bool /*shapeshift*/ = false) = 0;
+        //virtual void _OnMeleeDamageUpdate(uint8 /*myclass*/) const = 0;
+        virtual void Regenerate() = 0;
+
+        //virtual void ReceiveEmote(Player* /*player*/, uint32 /*emote*/) {}
+        //virtual void CommonTimers(uint32 diff) = 0;
+
+        virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        virtual bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
+        virtual bool IsMelee() const { return HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_RANGED); }
+        virtual bool CanHeal() const { return false; }
+        virtual bool CanSheath() const { return true; }
+        virtual bool CanSit() const { return true; }
+        virtual bool CanDrink() const { return true; }
+        virtual bool CanEat() const { return true; }
+        virtual bool CanMount() const { return true; }
+        virtual bool CanChangeEquip(uint8 /*slot*/) const { return true; }
+        virtual bool IgnoreEquipsAttackTime() const { return false; }
+        virtual bool CanSeeEveryone() const { return false; }
+
+        uint8 GetWait();
+        inline float InitAttackRange(float origRange, bool ranged) const;
+        uint16 Rand() const;
+        static inline uint32 GetLostHP(Unit const* unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        static inline uint8 GetHealthPCT(Unit const* hTarget) { if (!hTarget || hTarget->isDead()) return 100; return (hTarget->GetHealth()*100/hTarget->GetMaxHealth()); }
+        static inline uint8 GetManaPCT(Unit const* hTarget) { if (!hTarget || hTarget->isDead() || hTarget->GetMaxPower(POWER_MANA) <= 1) return 100; return (hTarget->GetPower(POWER_MANA)*100/(hTarget->GetMaxPower(POWER_MANA))); }
+
+        typedef std::set<Unit*> AttackerSet;
+
+        virtual MeleeHitOutcome GetNextAttackMeleeOutCome() const { return MELEE_HIT_CRUSHING; }
+
+        //event helpers
+        void BotJumpInPlaceInFrontOf(Position* pos, float speedXY, float maxHeight);
+
+        //utilities
+        void _AddItemTemplateLink(Player* forPlayer, ItemTemplate const* item, std::ostringstream &str) const;
+        void _AddItemLink(Player* forPlayer, Item const* item, std::ostringstream &str) const;
+        void _AddQuestLink(Player* forPlayer, Quest const* quest, std::ostringstream &str) const;
+        void _AddWeaponSkillLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const;
+        void _AddSpellLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, bool color = true, const std::string& colorstr = "ffffffff") const;
+        void _AddProfessionLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const;
+        void _LocalizeItem(Player* forPlayer, std::string &itemName, uint32 entry) const;
+        void _LocalizeItem(Player* forPlayer, std::string &itemName, std::string &suffix, Item const* item) const;
+        void _LocalizeQuest(Player* forPlayer, std::string &questTitle, uint32 entry) const;
+        void _LocalizeCreature(Player* forPlayer, std::string &creatureName, uint32 entry) const;
+        void _LocalizeGameObject(Player* forPlayer, std::string &gameobjectName, uint32 entry) const;
+
+        void BuildGrouUpdatePacket(WorldPacket* data);
+
+        void BotSay(char const* text, Player const* target = NULL) const;
+        void BotWhisper(char const* text, Player const* target = NULL) const;
+        void BotYell(char const* text, Player const* target = NULL) const;
+
+        typedef std::pair<uint32 /*spellId*/, uint32 /*cooldown*/> BotSpell;
+        typedef std::unordered_map<uint32 /*spellId_1*/, BotSpell /*spell*/> BotSpellMap;
+
+        BotSpellMap const& GetSpellMap() const { return spells; }
+
+        Player* master;
+        Unit* opponent;
+        CommandStates m_botCommandState;
+        SpellInfo const* m_botSpellInfo;
+        Position pos, attackpos;
+        float atpower, maxdist, ap_mod, spp_mod, crit_mod;
+        uint64 aftercastTargetGuid;
+        int32 cost, value, sppower;
+        uint32 GC_Timer, temptimer, checkAurasTimer, checkMasterTimer, roleTimer, wait, regenTimer_hp, regenTimer_mp,
+            currentSpell;
+        uint8 clear_cd;
+        bool doHealth, doMana, shouldUpdateStats;
+
+        //stats
+        float hit, parry, dodge, block, blockvalue, crit, dmg_taken;
+        uint32 expertise, spellpower, spellpen, regen_hp, regen_mp;
+        int32 haste;
+        uint32 lastdiff;
+
+        uint8 _botclass;
+        uint8 _roleMask;
+        uint32 _ownerGuid;
+        bool needparty;
+        bool spawned;
+        bool firstspawn;
+        bool _evadeMode;
+        bool _atHome;
+
+        bool _temp;
+
+        int32 _bootTimer;
+        uint32 _updateTimerMedium;
+
+        EventProcessor events;
+
+        //VisibilityUpdateEvent* visUpEvent;
+        TeleportHomeEvent* teleHomeEvent;
+        //EvadeEvent* evadeEvent;
+        TeleportFinishEvent* teleFinishEvent;
+
+    private:
+        Unit* _getTarget(bool byspell, bool ranged, bool &reset) const;
+        bool _hasAuraName(Unit* unit, const std::string spell, uint64 casterGuid = 0, bool exclude = false) const;
+        void _listAuras(Player* player, Unit* unit) const;
+        static inline float _getAttackDistance(float distance) { return distance > 0.0f ? distance*0.72f : 0.0f; }
+
+        BotSpellMap spells;
+};
+
+class bot_minion_ai : public bot_ai
+{
+    public:
+        virtual ~bot_minion_ai();
+        bot_minion_ai(Creature* creature);
+        virtual void Reset() {}
+        virtual void EnterEvadeMode() { EnterEvadeMode(false); }
+        void EnterEvadeMode(bool force);
+        virtual void JustDied(Unit*);
+        virtual void EnterCombat(Unit* u);
+        virtual void MoveInLineOfSight(Unit* u);
+        virtual void ReturnHome() { _atHome = false; }
+        void CommonTimers(uint32 diff);
+        const bot_minion_ai* GetMinionAI() const { return this; }
+        bool IsMinionAI() const { return true; }
+        bool IsPetAI() const { return false; }
+        bool CanRespawn() { return IAmFree(); }
+        void SummonBotsPet(uint32 entry);
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        void CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff);
+        bool CureTarget(Unit* target, uint32 cureSpell, uint32 diff);
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void SetStats(bool force, bool shapeshift = false);
+
+        static bool OnGossipHello(Player* player, Creature* creature, uint32 option);
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
+        bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code);
+
+        void InitSpells() {}
+        void InitPowers() {}
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate(bool shapeshift = false);
+        void _OnMeleeDamageUpdate(uint8 myclass) const;
+        void Regenerate();
+
+        void RemoveItemBonuses(uint8 slot);
+        void ApplyItemBonuses(uint8 slot);
+        void RemoveItemEnchantments(Item* item, uint8 slot);
+        void RemoveItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot);
+        void ApplyItemEnchantments(Item* item, uint8 slot);
+        void ApplyItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot);
+        void ApplyItemEquipSpell(Item* item, bool apply);
+        void ApplyItemsSpells();
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        //inline void SetEvadeTimer(uint8 time) { evade_cd = time; }
+
+        bool CanHeal() const;
+
+        uint32 GetReviveTimer() const { return _reviveTimer; }
+        void SetReviveTimer(uint32 newtime) { _reviveTimer = newtime; }
+        void UpdateReviveTimer(uint32 diff);
+
+        bool IAmFree() const;
+        void SavePosition();
+        void TeleportHome();
+        bool FinishTeleport(/*uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/);
+
+        bool IsDuringTeleport() const { return teleFinishEvent || teleHomeEvent; }
+        void SetTeleportFinishEvent(TeleportFinishEvent* tfevent) { ASSERT(!teleFinishEvent); teleFinishEvent = tfevent; }
+        void AbortTeleport();
+
+        void ResetChase(Position* pos);
+        void ResetChaseTimer(Position* pos);
+        bool UpdateImpossibleChase(Unit* target);
+        void BotJump(Position* pos);
+
+        virtual bool CanParry() const { return me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0) != 0 && parry_mod > 0.0f && me->CanUseAttackType(BASE_ATTACK); }
+        virtual bool CanDodge() const { return dodge_mod > 0.0f; }
+        virtual bool CanBlock() const { return !(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK) && me->CanUseAttackType(OFF_ATTACK); }
+        virtual bool CanCrit() const { return crit_mod > 0.0f; }
+        virtual bool CanMiss() const { return true; }
+
+        void CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Spell const* spell = NULL);
+        void CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto, Spell const* spell = NULL);
+
+        float GetTotalBotStat(uint8 stat) const { return _getTotalBotStat(stat); }
+
+    protected:
+        bool GlobalUpdate(uint32 diff);
+
+        Item const* GetEquips(uint8 slot) const { return _equips[slot]; }
+
+        virtual bool CanUseManually(uint32 /*basespell*/) const { return false; }
+        void BuffAndHealGroup(Player* gPlayer, uint32 diff);
+        void RezGroup(uint32 REZZ, Player* gPlayer);
+
+        void Follow(bool force = false, Position* newpos = NULL)
+        {
+            if (force ||
+                (me->IsAlive() && (!me->IsInCombat() || !opponent) && m_botCommandState != COMMAND_STAY))
+                SetBotCommandState(COMMAND_FOLLOW, force, newpos);
+        }
+
+        //void CheckAttackState();
+        void Evade(bool force = false);
+        void OnStartAttack(Unit* u);
+
+        virtual void BreakCC(uint32 diff);
+
+        void InitRoles();
+        void InitEquips();
+        void InitOwner();
+        void InitFaction();
+
+        WorldObject* GetNearbyRezTarget(float dist = 30) const;
+        Unit* FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
+        Unit* FindAffectedTarget(uint32 spellId, uint64 caster = 0, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
+        Unit* FindPolyTarget(float dist = 30, Unit* currTarget = NULL) const;
+        Unit* FindFearTarget(float dist = 30) const;
+        Unit* FindStunTarget(float dist = 20) const;
+        Unit* FindUndeadCCTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindRootTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindCastingTarget(float maxdist = 10, float mindist = 0, bool isFriend = false, uint32 spellId = 0) const;
+        Unit* FindAOETarget(float dist = 30, bool checkbots = false, bool targetfriend = true) const;
+        Unit* FindSplashTarget(float dist = 5, Unit* To = NULL, float splashdist = 4) const;
+        Unit* FindTranquilTarget(float mindist = 5, float maxdist = 35) const;
+        void GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist = 10, float mindist = 0, bool forCC = false) const;
+        void GetNearbyFriendlyTargetsList(std::list<uint64> &targets, float maxdist = 30) const;
+
+        uint32 Potion_cd;
+
+    private:
+        bool _canCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const;
+        void _getBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const;
+        void _calculatePos(Position& pos);
+        void _updateMountedState();
+        void _updateStandState() const;
+        void _updateRations();
+        char const* _getNameForSlot(uint8 slot) const;
+        uint8 _onOffIcon(uint8 role) const;
+        void _updateEquips(uint8 slot, Item* item);
+
+        bool _canUseOffHand() const;
+        bool _canUseRanged() const;
+        bool _canEquip(ItemTemplate const* item, uint8 slot, bool ignoreItemLevel = false) const;
+        bool _unequip(uint8 slot);
+        bool _equip(uint8 slot, Item* newItem);
+        bool _resetEquipment(uint8 slot);
+
+        typedef std::unordered_map<uint32 /*stat*/, int32 /*statvalue*/> BotStat;
+        BotStat _stats[BOT_INVENTORY_SIZE];
+        float _getBotStat(uint8 slot, uint8 stat) const;
+        float _getTotalBotStat(uint8 stat) const;
+        float _getRatingMultiplier(CombatRating cr) const;
+
+        Item* _equips[BOT_INVENTORY_SIZE];
+        PlayerClassLevelInfo* _classinfo;
+        float myangle, armor_mod, haste_mod, dodge_mod, parry_mod;
+        uint32 mana_cd, health_cd, pvpTrinket_cd;
+        bool feast_health, feast_mana;
+        uint8 rezz_cd;
+        uint32 _reviveTimer, _saveTimer, _powersTimer, _chaseTimer;
+        uint8 _jumpCount;
+        uint8 _evadeCount;
+        uint64 _lastTargetGuid; //unused
+};
+
+class bot_pet_ai : public bot_ai
+{
+    public:
+        virtual ~bot_pet_ai();
+        bot_pet_ai(Creature* creature);
+        virtual void Reset() {}
+        const bot_pet_ai* GetPetAI() const { return this; }
+        Creature* GetCreatureOwner() const { return m_creatureOwner; }
+        bool IsMinionAI() const { return false; }
+        bool IsPetAI() const { return true; }
+        bool CanRespawn() { return false; }
+        void CommonTimers(uint32 diff);
+        inline bool IAmDead() const { return (!master || !m_creatureOwner || me->isDead()); }
+        //void SetCreatureOwner(Creature* newowner) { m_creatureOwner = newowner; }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        //void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        //void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        //void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
+        //bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void SetStats(bool force, bool = false);
+
+        static uint8 GetPetType(Creature* pet);
+        static uint8 GetPetClass(Creature* pet);
+        static uint32 GetPetOriginalEntry(uint32 entry);
+
+        //debug
+        //virtual void ListSpells(ChatHandler* /*handler*/) const {}
+
+        void InitSpells() {}
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate(bool shapeshift = false);
+        //void _OnMeleeDamageUpdate(uint8 /*myclass*/) const {}
+        void Regenerate();
+        void SetBaseArmor(uint32 armor) { basearmor = armor; }
+
+        virtual bool CanParry() const { return false; }
+        virtual bool CanDodge() const { return true; }
+        virtual bool CanBlock() const { return false; }
+        virtual bool CanCrit() const { return true; }
+        virtual bool CanMiss() const { return true; }
+
+    protected:
+        void InitRoles();
+
+        Creature* m_creatureOwner;
+    private:
+        uint32 basearmor;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_bm_ai.cpp b/src/server/game/AI/NpcBots/bot_bm_ai.cpp
new file mode 100644
index 0000000..1534d17
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_bm_ai.cpp
@@ -0,0 +1,968 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+//#include "WorldSession.h"
+/*
+Blademaster NpcBot (by Graff onlysuffering@gmail.com)
+Complete - Around 30%
+TODO: MIRROR IMAGE (ILLUSION), BLADESTORM
+*/
+
+#define MAX_ILLUSION_POSITIONS 4
+
+class blademaster_bot : public CreatureScript
+{
+public:
+    blademaster_bot() : CreatureScript("blademaster_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new blademaster_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct blademaster_botAI : public bot_minion_ai
+    {
+    private:
+        //DelayedMeleeDamageEvent - Blademaster
+        //deals critical damage, resets attack timer and sends fake log
+        class DelayedMeleeDamageEvent : public BasicEvent
+        {
+            public:
+                DelayedMeleeDamageEvent(uint64 botGuid, uint64 targetGuid, bool windwalk) :
+                  _botGuid(botGuid), _targetGuid(targetGuid), _windwalk(windwalk), _dinfo(NULL) { }
+                ~DelayedMeleeDamageEvent() { }
+
+                void SetDamageInfo(CalcDamageInfo* dinfo)
+                {
+                    _dinfo = dinfo;
+                }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    bool suc = false;
+                    if (Creature* bot = sObjectAccessor->GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                    {
+                        ASSERT(bot->GetBotClass() == BOT_CLASS_BM);
+                        (dynamic_cast<blademaster_bot::blademaster_botAI*>(bot->GetBotMinionAI()))->CriticalStrikeFinish(_targetGuid, _dinfo, _windwalk);
+                        suc = true;
+                    }
+
+                    delete _dinfo;
+                    return suc;
+                }
+
+            private:
+                uint64 _botGuid;
+                uint64 _targetGuid;
+                bool _windwalk;
+                CalcDamageInfo* _dinfo;
+                DelayedMeleeDamageEvent(DelayedMeleeDamageEvent const&);
+        };
+
+        class EventTerminateEvent : public BasicEvent
+        {
+            public:
+                EventTerminateEvent(uint64 botGuid) : _botGuid(botGuid) { }
+                ~EventTerminateEvent() { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    if (Creature* bot = sObjectAccessor->GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                    {
+                        (dynamic_cast<blademaster_bot::blademaster_botAI*>(bot->GetBotMinionAI()))->TerminateEvent();
+                        return true;
+                    }
+                    return false;
+                }
+
+            private:
+                uint64 _botGuid;
+                EventTerminateEvent(EventTerminateEvent const&);
+        };
+
+        class DelayedIllusionSummonEvent : public BasicEvent
+        {
+            public:
+                DelayedIllusionSummonEvent(uint64 botGuid) : _botGuid(botGuid) { }
+                ~DelayedIllusionSummonEvent() { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    if (Creature* bot = sObjectAccessor->GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                    {
+                        ASSERT(bot->GetBotClass() == BOT_CLASS_BM);
+                        (dynamic_cast<blademaster_bot::blademaster_botAI*>(bot->GetBotMinionAI()))->MirrorImageFinish();
+                        return true;
+                    }
+
+                    return false;
+                }
+
+            private:
+                uint64 _botGuid;
+                DelayedIllusionSummonEvent(DelayedIllusionSummonEvent const&);
+        };
+
+        class DisappearEvent : public BasicEvent
+        {
+            public:
+                DisappearEvent(uint64 botGuid) : _botGuid(botGuid) { }
+                ~DisappearEvent() { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    if (Creature* bot = sObjectAccessor->GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                    {
+                        ASSERT(bot->GetBotClass() == BOT_CLASS_BM);
+                        (dynamic_cast<blademaster_bot::blademaster_botAI*>(bot->GetBotMinionAI()))->MirrorImageMid();
+                        return true;
+                    }
+
+                    return false;
+                }
+
+            private:
+                uint64 _botGuid;
+                DisappearEvent(DisappearEvent const&);
+        };
+
+        void _calcIllusionPositions()
+        {
+            float x = me->m_positionX;
+            float y = me->m_positionY;
+            float o = me->m_orientation;
+
+            //X     X
+            //   C
+            //X     X
+            //
+            //C - caster (Blademaster)
+            //X - new positions (1-3 illusions + blademaster)
+
+            float dist = 2.f; //not too far - 2 for x and y seems to be way to go
+            for (uint8 i = 0; i != MAX_ILLUSION_POSITIONS; ++i)
+            {
+                _illusPos[i].m_positionX = x + ((i == 0 || i == 1) ? +dist : -dist); // +2+2-2-2
+                _illusPos[i].m_positionY = y + (!(i & 1) ? +dist : -dist);           // +2-2+2-2
+                _illusPos[i].m_orientation = o;
+            }
+        }
+
+    public:
+        blademaster_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_BM;
+            //Blademaster cannot be disarmed
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, SPELL_AURA_MOD_DISARM, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_BM) != SPELL_CAST_OK)
+                return false;
+
+            //custom
+            if (_dmdevent)
+                return false;
+            if (IsTempBot()) //Illusion etc.
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && me->GetPower(POWER_MANA) < 125)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            CheckWindWalk(diff);
+            CheckMirrorImage(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_BM))
+                return;
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* /*u*/) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+        uint8 GetPlayerClass() const { return BOT_CLASS_WARRIOR; }
+
+        bool CanSheath() const { return false; }
+        bool CanSit() const { return false; }
+        bool CanDrink() const { return false; }
+        bool CanEat() const { return Windwalk_Timer == 0 && !illusion_Fade; }
+        bool CanMount() const { return false; }
+        bool CanChangeEquip(uint8 slot) const { return slot > BOT_SLOT_RANGED; }
+        bool IgnoreEquipsAttackTime() const { return true; }
+        bool CanSeeEveryone() const { return Windwalk_Timer > 0; }
+        bool CanParry() const { return false; }
+        bool CanCrit() const { return false; }
+        bool CanDodge() const { return false; }
+        bool CanMiss() const { return false; }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (IsSpellReady(WINDWALK_1, diff) && !IsTank(me) && Rand() < 30 &&
+                    doCast(me, GetSpell(WINDWALK_1)))
+                    return;
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 /*diff*/)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            //float dist = me->GetExactDist(opponent);
+            //float meleedist = me->GetDistance(opponent);
+            ////charge + warbringer
+            //if (IsSpellReady(CHARGE_1, diff, false) && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+            //    (me->getLevel() >= 50 ||
+            //    (!me->IsInCombat() && (battleStance || stanceChange(diff, 1)))))
+            //{
+            //    temptimer = GC_Timer;
+            //    if (me->getLevel() >= 29)
+            //        me->RemoveMovementImpairingAuras();
+            //    if (doCast(opponent, GetSpell(CHARGE_1), me->IsInCombat()))
+            //    {
+            //        SetSpellCooldown(CHARGE_1, 12000);
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+            //}
+            ////OVERPOWER
+            //if (IsSpellReady(OVERPOWER_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50 && getrage() > 50 && meleedist <= 5 &&
+            //    (battleStance || stancetimer <= diff))
+            //{
+            //    if (me->HasAura(TASTE_FOR_BLOOD_BUFF))
+            //    {
+            //        if (battleStance || stanceChange(diff, 1))
+            //        {
+            //            if (doCast(opponent, GetSpell(OVERPOWER_1)))
+            //            {
+            //                me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+            //                return;
+            //            }
+            //        }
+            //    }
+            //}
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //////PLACEHOLDER - BLADESTORM
+            ////BLADESTORM
+            //if (IsSpellReady(BLADESTORM_1, diff) && HasRole(BOT_ROLE_DPS) &&
+            //   getrage() >= 250 && (Rand() < 20 || me->HasAura(RECKLESSNESS_1)) &&
+            //   (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()))
+            //{
+            //    if (doCast(me, GetSpell(BLADESTORM_1)))
+            //    {
+            //        SetSpellCooldown(BLADESTORM_1, 60000);
+            //        return;
+            //    }
+            //}
+            //////PLACEHOLDER - SPELLCAST INTERRUPT POSSIBLE
+            ////PUMMEL
+            //if (IsSpellReady(PUMMEL_1, diff, false) && Rand() < 80 && getrage() > 100 && meleedist <= 5 &&
+            //    opponent->IsNonMeleeSpellCast(false) &&
+            //    (berserkerStance || stancetimer <= diff))
+            //{
+            //    temptimer = GC_Timer;
+            //    if ((berserkerStance || stanceChange(diff, 3)) &&
+            //        doCast(opponent, GetSpell(PUMMEL_1)))
+            //    {
+            //        SetSpellCooldown(PUMMEL_1, 10000);
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+            //}
+        }
+
+        void DoBMMeleeAttackIfReady()
+        {
+            //Copied from UnitAI::DoMeleeAttackIfReady() with modifications
+            //cannot attack while casting or jumping
+            if (me->HasUnitState(UNIT_STATE_CASTING) || _dmdevent)
+                return;
+
+            Unit* victim = me->GetVictim();
+            //Make sure our attack is ready and we aren't currently casting before checking distance
+            if (me->isAttackReady() && me->IsWithinMeleeRange(victim))
+            {
+                if (!CCed(me, true) && !JumpingFlyingOrFalling())
+                {
+                    //Windwalk strike
+                    if (Windwalk_Timer)
+                    {
+                        CriticalStrike(victim, true);
+                        return;
+                    }
+
+                    //Critical Strike: 15% to deal x2,x3, etc... damage
+                    if (criticalStikeMult >= 2 && !CCed(me, true) && !JumpingFlyingOrFalling() &&
+                        roll_chance_f(15.f))
+                    {
+                        CriticalStrike(victim);
+                        return;
+                    }
+                }
+
+                me->AttackerStateUpdate(victim);
+                me->resetAttackTimer();
+                return;
+            }
+        }
+
+        void CheckAttackState()
+        {
+            if (me->GetVictim())
+            {
+                if (HasRole(BOT_ROLE_DPS))
+                    DoBMMeleeAttackIfReady();
+            }
+            else
+                Evade();
+        }
+
+        void CheckWindWalk(uint32 diff)
+        {
+            if (!IsSpellReady(WINDWALK_1, diff) || Windwalk_Timer || illusion_Fade || IsCasting() ||
+                Rand() > (10 + 20 * (me->IsInCombat() || master->IsInCombat())))
+                return;
+
+            if (!IAmFree() && master->isMoving())
+            {
+                if (me->GetDistance(master) > 30 &&
+                    doCast(me, GetSpell(WINDWALK_1)))
+                    return;
+
+                return;
+            }
+
+            if (!IsTank(me))
+            {
+                //unit to strike
+                Unit* u = IsMelee() ? me->GetVictim() : NULL;
+
+                if ((u && u->isMoving() && me->GetDistance(u) > 18 &&
+                    (u->GetVictim() != me || u->getAttackers().size() > uint8(u->IsControlledByPlayer() ? 0 : 1))) ||
+                    me->getAttackers().size() > 2)
+                {
+                    if (doCast(me, GetSpell(WINDWALK_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckMirrorImage(uint32 diff)
+        {
+            //only for controlled bot
+            if (IAmFree())
+                return;
+            if (!IsSpellReady(MIRROR_IMAGE_1, diff) || !me->IsInCombat() || !illusionsCount || illusion_Fade ||
+                IsCasting() || Rand() > 20)
+                return;
+
+            uint8 pct = GetHealthPCT(me);
+            uint8 size = uint8(me->getAttackers().size());
+            if (!size)
+                return;
+
+            if (pct > 25 && (size > 3 || pct < (80 + size * 5)))
+                if (doCast(me, GetSpell(MIRROR_IMAGE_1)))
+                    return;
+        }
+
+        void MirrorImageStart()
+        {
+            if (!illusionsCount)
+                return;
+
+            ASSERT(!illusion_Fade); //prevent double casts
+            illusion_Fade = true;
+
+            //OKAY
+
+            //there is a restiction for illusions count - cannot summon more than 3 of them
+            while (int8(_illusionGuids.size()) > (3 - illusionsCount))
+            {
+                std::list<uint64>::iterator itr = _illusionGuids.begin();
+                if (Creature* illusion = sObjectAccessor->GetObjectInWorld(*itr, (Creature*)NULL))
+                    if (!illusion->IsDuringRemoveFromWorld())
+                        illusion->ToCreature()->GetBotAI()->JustDied(NULL);
+
+                _illusionGuids.erase(itr);
+            }
+
+            //mirror image renders BM invulnerable for a short period of time,
+            //removing all auras. We exclude passive or invisible auras for they don't exist in W3
+            Unit::AuraMap const auras = me->GetOwnedAuras(); //copy
+            for (Unit::AuraMap::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
+            {
+                Aura* aura = iter->second;
+                if ((aura->GetSpellInfo()->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) ||
+                    (aura->GetSpellInfo()->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR))
+                    continue;
+                AuraApplication* aurApp = aura->GetApplicationOfTarget(me->GetGUID());
+                if (!aurApp)
+                    continue;
+                me->RemoveAura(aurApp, AURA_REMOVE_BY_DEFAULT);
+            }
+
+            me->BotStopMovement();
+            me->AttackStop();
+            me->HandleEmoteCommand(EMOTE_ONESHOT_NONE);
+            me->AddAura(BLACK_COLOR, me);//color
+            me->AddAura(STUN_FREEZE, me);//stop/immunity
+
+            //prepare to disappear
+            DisappearEvent* devent = new DisappearEvent(me->GetGUID());
+            events.AddEvent(devent, events.CalculateTime(300)); //immediatelly (almost)
+        }
+
+        void MirrorImageMid()
+        {
+            if (!me->IsInWorld() ||
+                !me->IsAlive()/* || CCed(me)*/) //this is just ensurance
+            {
+                me->RemoveAura(BLACK_COLOR);
+                me->RemoveAura(STUN_FREEZE);
+                illusion_Fade = false;
+                return;
+            }
+            //disappear
+            me->SetPhaseMask(0, true);
+
+            //INVISIBLE!
+            //EVENT
+            DelayedIllusionSummonEvent* disevent = new DelayedIllusionSummonEvent(me->GetGUID());
+            events.AddEvent(disevent, events.CalculateTime(1250)); //1000 ms disappear time + 250 ms buffer
+        }
+
+        void MirrorImageFinish()
+        {
+            illusion_Fade = false;
+            me->RemoveAura(BLACK_COLOR);
+            me->RemoveAura(STUN_FREEZE);
+            if (!me->IsInWorld() ||
+                !me->IsAlive()/* || CCed(me)*/) //this is just ensurance
+                return;
+
+            _calcIllusionPositions();
+
+            std::set<uint8> usedposs;
+
+            for (uint8 i = 0; i != illusionsCount; ++i)
+            {
+                Creature* illusion = master->SummonCreature(me->GetEntry(), *me, TEMPSUMMON_TIMED_DESPAWN, 1 * MINUTE * IN_MILLISECONDS);
+                if (!illusion)
+                    continue;
+
+                illusion->GetBotAI()->SetBotIsTemp();
+                illusion->GetBotAI()->FindMaster(true);
+                illusion->SetMaxHealth(me->GetMaxHealth());
+                illusion->SetHealth(me->GetHealth());
+                illusion->SetMaxPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+                illusion->SetPower(POWER_MANA, me->GetPower(POWER_MANA));
+                illusion->SetFloatValue(UNIT_FIELD_MINDAMAGE, me->GetFloatValue(UNIT_FIELD_MINDAMAGE));
+                illusion->SetFloatValue(UNIT_FIELD_MAXDAMAGE, me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+
+                illusion->BotStopMovement();
+                while (true)
+                {
+                    uint8 j = urand(0, MAX_ILLUSION_POSITIONS - 1);
+                    if (usedposs.find(j) == usedposs.end())
+                    {
+                        illusion->GetMotionMaster()->MovePoint(me->GetMapId(), _illusPos[j]);
+                        //illusion->Relocate(_illusPos[j]);
+                        usedposs.insert(j);
+                        break;
+                    }
+                }
+
+                illusion->SetBotCommandState(COMMAND_ABANDON);
+
+                _illusionGuids.push_back(illusion->GetGUID());
+            }
+
+            me->SetBotCommandState(COMMAND_ABANDON);
+
+            for (uint8 i = 0; i != MAX_ILLUSION_POSITIONS; ++i)
+            {
+                if (usedposs.find(i) == usedposs.end())
+                {
+                    me->BotStopMovement();
+                    me->GetMotionMaster()->MovePoint(me->GetMapId(), _illusPos[i]);
+                    //me->Relocate(_illusPos[i]);
+                    //usedposs.insert(i);
+                    break;
+                }
+            }
+
+            uint8 counter = 0;
+            uint8 r = urand(0, uint8(_illusionGuids.size() - 1));
+
+            for (std::list<uint64>::const_iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                if (Creature* illusion = sObjectAccessor->GetObjectInWorld(*itr, (Creature*)NULL))
+                    illusion->SetPhaseMask(master->GetPhaseMask(), true);
+
+                if (counter == r)
+                    me->SetPhaseMask(master->GetPhaseMask(), true);
+                else
+                    ++counter;
+            }
+
+            me->getHostileRefManager().deleteReferences();
+
+            if (me->GetPhaseMask() != master->GetPhaseMask())
+                me->SetPhaseMask(master->GetPhaseMask(), true);
+
+            //me->setAttackTimer(BASE_ATTACK, 3000);
+            wait = 18;
+            SetSpellCooldown(MIRROR_IMAGE_1, 8000);
+            Potion_cd = std::max<uint32>(Potion_cd, 10000);
+        }
+
+        void CriticalStrike(Unit* target, bool windwalk = false)
+        {
+            //Okay critical strike must have jump and strike animation, doing delayed damage
+            DelayedMeleeDamageEvent* dmdevent = new DelayedMeleeDamageEvent(me->GetGUID(), target->GetGUID(), windwalk);
+            SetDelayedMeleeDamageEvent(dmdevent);
+
+            //hack temp attack damage calc
+            float mindam = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            float maxdam = me->GetFloatValue(UNIT_FIELD_MAXDAMAGE);
+
+            if (windwalk)
+            {
+                me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam * 1.5f);
+                me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam * 1.5f);
+                me->RemoveAura(GetSpell(WINDWALK_1));
+                me->RemoveAura(TRANSPARENCY);
+            }
+            else
+            {
+                me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam * criticalStikeMult);
+                me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam * criticalStikeMult);
+            }
+
+            CalcDamageInfo* dinfo = new CalcDamageInfo();
+            me->CalculateMeleeDamage(target, 0, dinfo, BASE_ATTACK);
+
+            me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam);
+            me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam);
+
+            dmdevent->SetDamageInfo(dinfo);
+            events.AddEvent(dmdevent, events.CalculateTime(450));
+
+            BotJumpInPlaceInFrontOf(target, 0.32f, 4.1f); //jump - DO NOT CHANGE
+            me->CastSpell(target, SPELL_COMBAT_SPECIAL_2H_ATTACK, true); //strike anim
+            me->resetAttackTimer(BASE_ATTACK);
+        }
+
+        void CriticalStrikeFinish(uint64 targetGuid, CalcDamageInfo* dinfo, bool /*windwalk*/)
+        {
+            EventTerminateEvent* etevent = new EventTerminateEvent(me->GetGUID());
+            events.AddEvent(etevent, events.CalculateTime(750));
+
+            if (!me->IsInWorld() || !me->IsAlive() || CCed(me))
+            {
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            Unit* target = sObjectAccessor->GetUnit(*me, targetGuid);
+            if (!target || !target->IsAlive())
+            {
+                me->PlayDistanceSound(SOUND_MISS_WHOOSH_2H);
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            if (target->IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
+            {
+                //target became immune
+                me->SendSpellMiss(target, CRITICAL_STRIKE_1, SPELL_MISS_IMMUNE);
+                target->PlayDistanceSound(SOUND_ABSORB_GET_HIT);
+                Windwalk_Timer = 0;
+                return;
+            }
+            else if (!CanSeeEveryone() && !me->CanSeeOrDetect(target, false, false))
+            {
+                //target disappeared
+                me->SendSpellMiss(target, CRITICAL_STRIKE_1, SPELL_MISS_MISS/*SPELL_MISS_EVADE*/);
+                me->PlayDistanceSound(SOUND_MISS_WHOOSH_2H);
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            target->PlayDistanceSound(SOUND_AXE_2H_IMPACT_FLESH_CRIT);
+
+            me->SendSpellNonMeleeDamageLog(target, CRITICAL_STRIKE_1,
+                dinfo->damage + dinfo->absorb + dinfo->resist + dinfo->blocked_amount,
+                SPELL_SCHOOL_MASK_NORMAL, dinfo->absorb, dinfo->resist, true, dinfo->blocked_amount, true);
+            CleanDamage cl(0, 0, BASE_ATTACK, MELEE_HIT_CRIT);
+            me->DealDamage(target, dinfo->damage, &cl);
+            me->ProcDamageAndSpell(dinfo->target, dinfo->procAttacker, dinfo->procVictim, dinfo->procEx, dinfo->damage, dinfo->attackType);
+            me->CombatStart(target);
+
+            Windwalk_Timer = 0;
+        }
+
+        void SetDelayedMeleeDamageEvent(DelayedMeleeDamageEvent* dmdevent)
+        { _dmdevent = dmdevent; }
+
+        void TerminateEvent()
+        { _dmdevent = NULL; }
+
+        MeleeHitOutcome GetNextAttackMeleeOutCome() const
+        {
+            return _dmdevent ? MELEE_HIT_NORMAL : bot_ai::GetNextAttackMeleeOutCome();
+        }
+
+        bool IsBotImmuneToSpell(SpellInfo const* spellInfo) const
+        {
+            //PLACEHOLDER BLADESTORM
+            //return !spellInfo->HasEffect(SPELL_EFFECT_HEAL);
+            return bot_ai::IsBotImmuneToSpell(spellInfo);
+        }
+
+        float GetBotArmorPenetrationCoef() const
+        {
+            //return _dmdevent ? 0.5f : bot_ai::GetBotArmorPenetrationCoef();
+            return 0.5f;
+        }
+
+        float GetSpellMiscValue(uint32 basespell, uint8 offset) const
+        {
+            switch (basespell)
+            {
+                case CRITICAL_STRIKE_1:
+                    return offset == 0 ? criticalStikeMult : 0;
+                case MIRROR_IMAGE_1:
+                    return offset == 0 ? illusionsCount : 0;
+                default:
+                    return 0;
+            }
+        }
+
+        //void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        //{
+        //    uint32 spellId = spellInfo->Id;
+        //    uint8 lvl = me->getLevel();
+        //    float fdamage = float(damage);
+        //    //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+        //    if (!crit)
+        //    {
+        //        float aftercrit = 0.f;
+        //        ////Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+        //        //if (lvl >= 15 && spellId == GetSpell(CLEAVE_1) /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
+        //        //    aftercrit += 15.f;
+
+        //        //second roll (may be illogical)
+        //        if (aftercrit > 0.f)
+        //            crit = roll_chance_f(aftercrit);
+        //    }
+
+        //    //2) apply bonus damage mods
+        //    float pctbonus = 0.0f;
+        //    if (crit)
+        //    {
+        //        //!!!Melee spell damage is not yet critical, all reduced by half
+        //        //Impale: 20% crit damage bonus for all abilities
+        //        if (lvl >= 20)
+        //            pctbonus += 0.10f;
+        //    }
+
+        //    ////Improved Rend: 20% bonus damage for Rend
+        //    //if (spellId == GetSpell(REND_1))
+        //    //    pctbonus += 0.2f;
+
+        //    damage = int32(fdamage * (1.0f + pctbonus));
+        //}
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(WINDWALK_1))
+            {
+                Windwalk_Timer = 30000; //TODO:
+                me->RemoveMovementImpairingAuras();
+                me->PlayDistanceSound(SOUND_FREEZE_IMPACT_WINDWALK, !IAmFree() ? master : NULL);
+
+                uint32 dur = 30000;
+                if (Aura* aura = me->GetAura(spellId))
+                {
+                    aura->SetDuration(dur);
+                    aura->SetMaxDuration(dur);
+                }
+                if (Aura* aura = me->GetAura(TRANSPARENCY))
+                {
+                    aura->SetDuration(dur);
+                    aura->SetMaxDuration(dur);
+                }
+
+                if (GetHealthPCT(me) < 25 || !HasRole(BOT_ROLE_DPS))
+                    me->AttackStop();
+
+                //SpellEffectSanctuary
+                me->getHostileRefManager().UpdateVisibility();
+                AttackerSet attackers = me->getAttackers();
+                for (AttackerSet::const_iterator itr = attackers.begin(); itr != attackers.end();)
+                {
+                    if (!(*itr)->CanSeeOrDetect(me))
+                        (*(itr++))->AttackStop();
+                    else
+                        ++itr;
+                }
+
+                me->m_lastSanctuaryTime = getMSTime();
+            }
+
+            if (spellId == GetSpell(MIRROR_IMAGE_1))
+            {
+                MirrorImageStart();
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* /*target*/, SpellInfo const* /*spell*/) { }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            //Illusions deal no damage
+            if (IsTempBot())
+            {
+                //manually add threat as if damage was done
+                if (victim->GetTypeId() != TYPEID_PLAYER)
+                    victim->AddThreat(me, float(damage * 2));
+
+                damage = 0;
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage)
+        {
+            //illusions take twice damage
+            if (IsTempBot())
+            {
+                damage *= 2;
+                //return;
+            }
+            if (illusion_Fade)
+            {
+                damage = 0;
+                return;
+            }
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OnBotDespawn(Creature* /*summon*/)
+        {}
+
+        void UnsummonAll()
+        {
+            while (!_illusionGuids.empty())
+            {
+                std::list<uint64>::iterator itr = _illusionGuids.begin();
+                if (Creature* illusion = sObjectAccessor->GetObjectInWorld(*itr, (Creature*)NULL))
+                    if (illusion->GetBotAI())
+                        illusion->GetBotAI()->JustDied(NULL);
+
+                _illusionGuids.erase(itr);
+            }
+        }
+
+        void Reset()
+        {
+            _dmdevent = NULL;
+            Windwalk_Timer = 0;
+            criticalStikeMult = 1;
+            illusionsCount = 0;
+            illusion_Fade = false;
+
+            me->setPowerType(POWER_MANA);
+            me->SetMaxPower(POWER_MANA, 75);
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Windwalk_Timer > diff)          Windwalk_Timer -= diff;
+            else if (Windwalk_Timer > 0)        Windwalk_Timer = 0;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+
+ /*Special*/lvl >= 10 ? InitSpellMap(WINDWALK_1) : RemoveSpell(WINDWALK_1);
+ /*Special*/lvl >= 20 ? InitSpellMap(MIRROR_IMAGE_1) : RemoveSpell(MIRROR_IMAGE_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = me->getLevel();
+
+            RefreshAura(SPELL_BURNING_BLADE_BLADEMASTER);
+
+            criticalStikeMult =
+                level < 10 ? 1 :
+                level < 30 ? 2 :
+                level < 50 ? 3 :
+                level < 82 ? 4 : 5;
+
+            illusionsCount =
+                level < 20 ? 0 :
+                level < 40 ? 1 :
+                level < 70 ? 2 : 3;
+                //level < 83 ? 3 : 4;
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case WINDWALK_1:
+                case MIRROR_IMAGE_1:
+                    return true;
+                default:
+                    break;
+            }
+
+            return false;
+        }
+
+    private:
+        DelayedMeleeDamageEvent* _dmdevent;
+        std::list<uint64> _illusionGuids;
+        Position _illusPos[MAX_ILLUSION_POSITIONS];
+
+        uint32 Windwalk_Timer;
+        uint8 criticalStikeMult;
+        uint8 illusionsCount;
+        bool illusion_Fade;
+
+        enum BlademasterBaseSpells
+        {
+            WINDWALK_1                              = SPELL_NETHERWALK,
+            MIRROR_IMAGE_1                          = SPELL_MIRROR_IMAGE_BM,
+            CRITICAL_STRIKE_1                       = SPELL_CRITICAL_STRIKE
+        };
+        enum BlademasterPassives
+        {
+        //Talents
+        //other
+        };
+        enum BlademasterSpecial
+        {
+            TRANSPARENCY                            = SPELL_TRANSPARENCY_50,
+            BLACK_COLOR                             = SPELL_VERTEX_COLOR_BLACK,
+            STUN_FREEZE                             = SPELL_STUN_FREEZE_ANIM
+        };
+    };
+};
+
+void AddSC_blademaster_bot()
+{
+    new blademaster_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
new file mode 100644
index 0000000..11d11d7
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
@@ -0,0 +1,1622 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+/*
+Death Knight NpcBot by Graff onlysuffering@gmail.com
+Complete - around 55%
+Note: Rune system adapted from TC
+TODO: REMEMBER ALREADY DK HAS MINIMUM LEVEL 55!
+*/
+const RuneType runeSlotTypes[MAX_RUNES] =
+{
+    RUNE_BLOOD,
+    RUNE_BLOOD,
+    RUNE_UNHOLY,
+    RUNE_UNHOLY,
+    RUNE_FROST,
+    RUNE_FROST
+};
+struct BotRuneInfo
+{
+    uint8 BaseRune;
+    uint8 CurrentRune;
+    uint32 Cooldown;
+    //AuraEffect const* ConvertAura;
+};
+
+struct BotRunes
+{
+    BotRuneInfo runes[MAX_RUNES];
+    //uint8 runeState;          //UNUSED
+    //uint8 lastUsedRune;       //UNUSED
+
+    //void SetRuneState(uint8 index, bool set = true)
+    //{
+    //    if (set)
+    //        runeState |= (1 << index);    // usable
+    //    else
+    //        runeState &= ~(1 << index);   // on cooldown
+    //}
+};
+class death_knight_bot : public CreatureScript
+{
+public:
+    death_knight_bot() : CreatureScript("death_knight_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new death_knight_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct death_knight_botAI : public bot_minion_ai
+    {
+        death_knight_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_DEATH_KNIGHT;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_DEATH_KNIGHT) != SPELL_CAST_OK)
+                return false;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+            int32 runecost[NUM_RUNE_TYPES];
+            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+                runecost[i] = 0;
+
+            if (!triggered)
+            {
+                if (!HaveRunes(spellInfo, runecost))
+                    return false;
+            }
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result)
+            {
+                //std::ostringstream str;
+                //str << "Casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
+                //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
+                //Set cooldown for runes
+                if (!triggered)
+                {
+                    SpendRunes(runecost);
+                    ////debug
+                    //for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+                    //    if (runecost[i])
+                    //        TC_LOG_FATAL("entities.player", "doCast():: DK bot %s has casted spell %u (%s) without %u rune(s) (type %u)!",
+                    //            me->GetName().c_str(), spellId, spellInfo->SpellName[0], runecost[i], i);
+                }
+                //runic power gain: all dk spells are instant but some have no unit target so
+                //we gain runic power here instead of SpellHitTarget()
+                if (SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID))
+                    if (int32 rp = int32(src->runePowerGain * runicpowerIncomeMult))
+                        me->ModifyPower(POWER_RUNIC_POWER, int32(rp));
+            }
+
+            return result;
+        }
+
+        bool HaveRunes(SpellInfo const* spellInfo, int32 *runecost) const
+        {
+            if (spellInfo->PowerType != POWER_RUNE || !spellInfo->RuneCostID)
+                return true;
+
+            CalcRuneCost(spellInfo, runecost);
+
+            if (runecost[RUNE_DEATH] != 0 && runecost[RUNE_DEATH] > GetDeathRunesCount())
+                return false;
+
+            return true;
+        }
+
+        void CalcRuneCost(SpellInfo const* spellInfo, int32 *runecost) const
+        {
+            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
+            if (!src)
+                return;
+
+            if (src->NoRuneCost())
+                return;
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                runecost[i] = src->RuneCost[i];
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                uint8 rune = _runes.runes[i].BaseRune;
+                if (_runes.runes[i].CurrentRune == rune && _runes.runes[i].Cooldown == 0 && runecost[rune] > 0)
+                    runecost[rune]--;
+            }
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                if (runecost[i] > 0)
+                    runecost[RUNE_DEATH] += runecost[i];
+
+            ////restore cost to allow cooldown set
+            //for (uint8 i = 0; i != RUNE_DEATH; ++i)
+            //    runecost[i] = src->RuneCost[i];
+        }
+
+        int32 GetDeathRunesCount() const
+        {
+            int32 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes.runes[i].CurrentRune == RUNE_DEATH && _runes.runes[i].Cooldown == 0)
+                    ++count;
+
+            return count;
+        }
+
+        uint8 GetCooledRunesCount(uint8 runetype) const
+        {
+            uint8 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes.runes[i].BaseRune == runetype && _runes.runes[i].Cooldown > 0)
+                    ++count;
+
+            return count;
+        }
+
+        void SpendRunes(int32* runecost)
+        {
+            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+            {
+                if (runecost[i] <= 0)
+                    continue;
+
+                for (uint8 j = 0; j != MAX_RUNES && runecost[i] > 0; ++j)
+                {
+                    if (SpendRune(i))
+                        runecost[i]--;
+                }
+            }
+
+            if (GetCooledRunesCount(RUNE_BLOOD) > 1)
+            {
+                me->CastSpell(me, BLADE_BARRIER_AURA, true);
+            }
+        }
+
+        bool SpendRune(uint8 runetype)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes.runes[i].CurrentRune == runetype && _runes.runes[i].Cooldown == 0)
+                {
+                    _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
+                    //_runes.lastUsedRune = _runes.runes[i].CurrentRune;        //UNUSED
+                    //_runes.SetRuneState(i, false);                            //UNUSED
+                    //DK receives rune regen bonus from mana regen
+                    uint32 cooldown = RUNE_BASE_COOLDOWN - std::min<uint32>(uint32(GetManaRegen() * 10), RUNE_BASE_COOLDOWN);
+                    _runes.runes[i].Cooldown = cooldown;
+                    //std::ostringstream str;
+                    //str << "Spent rune " << uint32(i) << " (type: " << uint32(runetype) << ')';
+                    //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        bool HaveRune(uint8 runetype) const
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if ((_runes.runes[i].CurrentRune == runetype || _runes.runes[i].CurrentRune == RUNE_DEATH) &&
+                    _runes.runes[i].Cooldown == 0)
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        void ConvertRune(uint8 runetype, uint8 count)
+        {
+            if (runetype == RUNE_DEATH)
+                return;
+
+            uint8 failcount = 0;
+            for (uint8 i = 0; i != MAX_RUNES && count > 0; ++i)
+            {
+                if (_runes.runes[i].BaseRune == runetype)
+                {
+                    if (_runes.runes[i].CurrentRune == RUNE_DEATH)
+                    {
+                        ++failcount;
+                        continue;
+                    }
+
+                    if (_runes.runes[i].Cooldown > 3000)
+                        _runes.runes[i].Cooldown -= 3000;
+
+                    _runes.runes[i].CurrentRune = RUNE_DEATH;
+                    --count;
+                }
+            }
+
+            if (!count && !failcount)
+                return;
+
+            //std::ostringstream str;
+            //str << "Failed to convert rune of type: " << uint32(runetype) << ")!";
+            //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
+        }
+
+        void ActivateAllRunes()
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes.runes[i].Cooldown = 0;
+                //_runes.SetRuneState(i, true);       //UNUSED
+            }
+        }
+
+        void InitRunes()
+        {
+            //_runes.runeState = 0;                   //UNUSED
+            //_runes.lastUsedRune = RUNE_BLOOD;       //UNUSED
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes.runes[i].BaseRune = runeSlotTypes[i];
+                _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
+                _runes.runes[i].Cooldown = 0;
+                //_runes.runes[i].ConvertAura = NULL; //UNUSED
+                //_runes.SetRuneState(i, true);       //UNUSED
+            }
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void RuneTimers(uint32 diff)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes.runes[i].Cooldown <= diff)
+                {
+                    _runes.runes[i].Cooldown = 0;
+                    //_runes.SetRuneState(i, true);     //UNUSED
+                }
+                else
+                    _runes.runes[i].Cooldown -= diff;
+            }
+        }
+
+        void modpower(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && runicpower < uint32(abs(mod)))
+            {
+                //debug set runic power to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                runicpower = mod ? mod * 10 : 0;
+            else
+                runicpower += mod * 10;
+
+            me->SetPower(POWER_RUNIC_POWER, runicpower);
+        }
+
+        uint32 getpower()
+        {
+            runicpower = me->GetPower(POWER_RUNIC_POWER);
+            return runicpower;
+        }
+
+        uint8 GetBotStance() const { return Presence; }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+        void KilledUnit(Unit*) { }
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || IsCasting() || Feasting() || Rand() > 20)
+                return;
+
+            //PATH OF FROST
+            if (GetSpell(PATH_OF_FROST_1) && HaveRune(RUNE_FROST)/* && !me->IsMounted()*/) //works while mounted
+            {
+                if ((me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !me->HasAuraType(SPELL_AURA_WATER_WALK)) ||
+                    (master->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !master->HasAuraType(SPELL_AURA_WATER_WALK) && me->GetDistance(master) < 50))
+                {
+                    if (doCast(me, GetSpell(PATH_OF_FROST_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckHysteria(uint32 diff)
+        {
+            if (!IsSpellReady(HYSTERIA_1, diff) || IsCasting() || Rand() > 15)
+                return;
+
+            Unit* target = NULL;
+
+            if (master->IsAlive() && IsMeleeClass(master->getClass()) && master->IsInCombat() &&
+                GetHealthPCT(master) > 80 && me->GetDistance(master) < 30 &&
+                master->getAttackers().empty() && !CCed(master, true))
+            {
+                if (Unit* u = master->GetVictim())
+                    if (u->GetHealth() > me->GetMaxHealth() / 2)
+                        target = master;
+            }
+
+            if (!target && IsMeleeClass(_botclass) && GetHealthPCT(me) > 80 &&
+                me->getAttackers().empty() && !CCed(me, true))
+            {
+                if (Unit* u = me->GetVictim())
+                    if (u->GetHealth() > me->GetMaxHealth() / 2)
+                        target = me;
+            }
+
+            if (!target && !IAmFree())
+            {
+                Group* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == master) continue;
+                        if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
+                        if (!IsMeleeClass(tPlayer->getClass()) || !tPlayer->IsInCombat()) continue;
+                        if (GetHealthPCT(tPlayer) < 80 || me->GetDistance(tPlayer) > 30) continue;
+                        if (!tPlayer->getAttackers().empty() || CCed(tPlayer, true)) continue;
+                        if (Unit* u = tPlayer->GetVictim())
+                        {
+                            if (u->GetHealth() > (me->GetMaxHealth() * 2) / 3)
+                            {
+                                target = tPlayer;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (target && doCast(target, GetSpell(HYSTERIA_1)))
+            {
+                if (target->GetTypeId() == TYPEID_PLAYER)
+                    BotWhisper("Hysteria on You!", target->ToPlayer());
+
+                GC_Timer = 800;
+                return;
+            }
+
+            SetSpellCooldown(HYSTERIA_1, 2000); //fail
+        }
+
+        void CheckAntiMagicShell(uint32 diff)
+        {
+            if (!IsSpellReady(ANTI_MAGIC_SHELL_1, diff, false) || GetHealthPCT(me) > 55 ||
+                getpower() < 200 || IsCasting() || Rand() > 50)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+                return;
+
+            bool cast = false;
+            uint8 count = 0;
+
+            for (AttackerSet::const_iterator itr = b_attackers.begin(); itr != b_attackers.end(); ++itr)
+            {
+                if (!(*itr) || !(*itr)->IsAlive()) continue;
+                if (Spell* spell = (*itr)->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (spell->m_targets.GetUnitTargetGUID() == me->GetGUID())
+                    {
+                        if ((*itr)->ToCreature() && (*itr)->ToCreature()->isWorldBoss())
+                        {
+                            cast = true;
+                            break;
+                        }
+
+                        if (++count >= 3)
+                        {
+                            cast = true;
+                            break;
+                        }
+                    }
+                }
+            }
+
+            if (cast)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(ANTI_MAGIC_SHELL_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(ANTI_MAGIC_SHELL_1, 1500); //fail
+        }
+
+        void CheckPresence(uint32 diff)
+        {
+            if (presencetimer > diff || IsCasting() || Rand() > 30) //no GCD
+                return;
+
+            uint8 newpresence = IsTank() ? DEATH_KNIGHT_FROST_PRESENCE : DEATH_KNIGHT_BLOOD_PRESENCE;
+            if (Presence == newpresence)
+            {
+                presencetimer = 500;
+                return;
+            }
+
+            Presence = newpresence;
+
+            if (Presence == DEATH_KNIGHT_FROST_PRESENCE && HaveRune(RUNE_FROST))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, FROST_PRESENCE_1))
+                {
+                    GC_Timer = temptimer;
+                    presencetimer = 1000;
+                    return;
+                }
+            }
+            else if (Presence == DEATH_KNIGHT_BLOOD_PRESENCE && HaveRune(RUNE_BLOOD))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, BLOOD_PRESENCE_1))
+                {
+                    GC_Timer = temptimer;
+                    presencetimer = 1000;
+                    return;
+                }
+            }
+
+            presencetimer = 500; //fail
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (IsSpellReady(LICHBORNE_1, diff, false) &&/* Rand() < 75 &&*/
+                me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(LICHBORNE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+
+            if (me->getPowerType() != POWER_RUNIC_POWER)
+                InitPowers();
+
+            if (runicpowertimer <= diff)
+            {
+                if (!me->IsInCombat())
+                {
+                    if (getpower() > uint32(30 * runicpowerLossMult))
+                        me->SetPower(POWER_RUNIC_POWER, runicpower - uint32(30 * runicpowerLossMult)); //-3 runic power every 2 sec
+                    else
+                        me->SetPower(POWER_RUNIC_POWER, 0);
+                }
+                runicpowertimer = 2000;
+            }
+            if (runicpowertimer2 <= diff)
+            {
+                if (me->IsInCombat())
+                {
+                    if (getpower() < me->GetMaxPower(POWER_RUNIC_POWER))
+                        me->SetPower(POWER_RUNIC_POWER, runicpower + uint32(20 * runicpowerIncomeMult)); //+2 runic power every 5 sec
+                    else
+                        me->SetPower(POWER_RUNIC_POWER, me->GetMaxPower(POWER_RUNIC_POWER));
+                }
+                runicpowertimer2 = 5000;
+            }
+
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            CheckPresence(diff);
+
+            //HORN OF WINTER
+            if (IsSpellReady(HORN_OF_WINTER_1, diff, false, (me->IsInCombat() ? 45000 : 0)) && Rand() < 30 &&
+                (me->IsInCombat() || (me->GetDistance(master) < 28 && master->IsWithinLOSInMap(me))))
+            {
+                Aura* horn = master->GetAura(GetSpell(HORN_OF_WINTER_1));
+                if (!horn || horn->GetDuration() < 5000)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(HORN_OF_WINTER_1)))
+                    {
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+            //BONE SHIELD
+            if (IsSpellReady(BONE_SHIELD_1, diff) && HaveRune(RUNE_UNHOLY) && Rand() < 25)
+            {
+                Aura* bone = me->GetAura(GetSpell(BONE_SHIELD_1));
+                if (!bone || bone->GetCharges() < 2 || (!me->IsInCombat() && bone->GetDuration() < 60000))
+                {
+                    if (doCast(me, GetSpell(BONE_SHIELD_1)))
+                    {
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(BONE_SHIELD_1, 1000); //fail
+            }
+
+            if (me->IsInCombat())
+            {
+                //ICEBOUND FORTITUDE
+                if (IsSpellReady(ICEBOUND_FORTITUDE_1, diff, false) && getpower() >= 200 &&
+                    GetHealthPCT(me) < std::min<uint32>(85, 45 + uint8(me->getAttackers().size()) * 7) &&
+                    Rand() < 40 + IsTank() * 50)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(ICEBOUND_FORTITUDE_1)))
+                        GC_Timer = temptimer;
+                }
+
+                CheckAntiMagicShell(diff);
+                CheckHysteria(diff);
+            }
+
+            if (!CheckAttackTarget(BOT_CLASS_DEATH_KNIGHT))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            //SELFHEAL
+
+            //RUNE TAP
+            if (IsSpellReady(RUNE_TAP_1, diff) && GetHealthPCT(me) < 40 && Rand() < 50)
+            {
+                if (!HaveRune(RUNE_BLOOD) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                    {
+                        ActivateAllRunes();
+                        GC_Timer = temptimer;
+                    }
+                }
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(RUNE_TAP_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //VAMPIRIC BLOOD
+            if (IsSpellReady(VAMPIRIC_BLOOD_1, diff, false) && GetHealthPCT(me) < 26/* && Rand() < 75*/)
+            {
+                if (!HaveRune(RUNE_BLOOD) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false, 40000))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                    {
+                        ActivateAllRunes();
+                        GC_Timer = temptimer;
+                    }
+                }
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(VAMPIRIC_BLOOD_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //END SELFHEAL
+
+            //MARK OF BLOOD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(MARK_OF_BLOOD_1, diff) && HaveRune(RUNE_BLOOD) &&
+                u && GetHealthPCT(u) < 85 && opponent->GetHealth() > u->GetMaxHealth() / 3 &&
+                (IsTank(u) || u->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 35 && !opponent->HasAura(MARK_OF_BLOOD_1) && IsInBotParty(u))
+            {
+                if (doCast(opponent, GetSpell(MARK_OF_BLOOD_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //NON-DISEASE SECTION
+
+            //PLACEHOLDER: ARMY OF THE DEAD
+
+            //RANGED SECTION
+
+            //STRANGULATE
+            if (IsSpellReady(STRANGULATE_1, diff) && meleedist <= 30 && HaveRune(RUNE_BLOOD) &&
+                opponent->IsNonMeleeSpellCast(false) && Rand() < 40)
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                if (doCast(opponent, GetSpell(STRANGULATE_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+
+                SetSpellCooldown(STRANGULATE_1, 500); //fail
+            }
+
+            //DARK COMMAND
+            if (IsSpellReady(DARK_COMMAND_1, diff, false) && dist < 30 && IsTank() &&
+                opponent->GetVictim() != me && Rand() < 70)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(DARK_COMMAND_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            ////DEATH GRIP - DISABLED
+            //if (DEATH_GRIP && DeathGrip_cd <= diff && dist < 30 &&
+            //    (tank == me && opponent->GetVictim() != me) ||
+            //    (opponent->GetVictim() == me && opponent->ToPlayer() && opponent->IsNonMeleeSpellCast(false)) &&
+            //    Rand() < 75)
+            //{
+            //    temptimer = GC_Timer;
+            //    if (doCast(opponent, DEATH_GRIP))
+            //    {
+            //        DeathGrip_cd = 25000;
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+
+            //    DeathGrip_cd = 1000; //fail
+            //}
+            //CHAINS OF ICE
+            if (uint32 CHAINS_OF_ICE = GetSpell(CHAINS_OF_ICE_1))
+            {
+                if (GC_Timer <= diff && dist < 20 && HaveRune(RUNE_FROST) && opponent->isMoving() &&
+                    !CCed(opponent) && !IsTank(opponent->GetVictim()) && IsInBotParty(opponent->GetVictim()) && Rand() < 25)
+                {
+                    Aura* chains = opponent->GetAura(CHAINS_OF_ICE);
+                    if (!chains || chains->GetDuration() < chains->GetMaxDuration() / 4)
+                    {
+                        if (doCast(opponent, CHAINS_OF_ICE))
+                        {
+                            //Improved Chains of Ice: convert frost rune into death rune
+                            ConvertRune(RUNE_FROST, 1);
+                            return;
+                        }
+                    }
+                }
+            }
+
+            //AOE SECTION
+
+            //HOWLING BLAST
+            if (IsSpellReady(HOWLING_BLAST_1, diff) && IsTank() && meleedist < 8 && HasRole(BOT_ROLE_DPS) &&
+                me->getAttackers().size() > 2 && HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(HOWLING_BLAST_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+
+                SetSpellCooldown(HOWLING_BLAST_1, 500); //fail
+            }
+            //BLOOD BOIL
+            if (IsSpellReady(BLOOD_BOIL_1, diff) && HasRole(BOT_ROLE_DPS) && HaveRune(RUNE_BLOOD) && Rand() < (10 + 40 * IsTank()))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.5f);
+                if (targets.size() >= 5)
+                    if (doCast(me, GetSpell(BLOOD_BOIL_1)))
+                        return;
+            }
+            //DEATH AND DECAY
+            if (IsSpellReady(DEATH_AND_DECAY_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < (30 + 30 * IsTank()) &&
+                HaveRune(RUNE_BLOOD) && HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST))
+            {
+                if (Unit* target = FindAOETarget(30, true))
+                {
+                    if (doCast(target, GetSpell(DEATH_AND_DECAY_1)))
+                        return;
+                }
+
+                SetSpellCooldown(DEATH_AND_DECAY_1, 500); //fail
+            }
+
+            //END AOE SECTION
+
+            //ICY TOUCH
+            if (IsSpellReady(ICY_TOUCH_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && HaveRune(RUNE_FROST) && Rand() < 25 &&
+                !opponent->HasAura(FROST_FEVER_AURA, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(ICY_TOUCH_1)))
+                    return;
+            }
+            //DEATH COIL //custom cd condition
+            if (GetSpell(DEATH_COIL_1) && GC_Timer <= 600 && dist < 20 && HasRole(BOT_ROLE_DPS) &&
+                int32(getpower()) >= (400 + 200 * (GetSpell(RUNE_STRIKE_1) != 0 || GetSpell(MIND_FREEZE_1) != 0 || GetSpell(ANTI_MAGIC_SHELL_1) != 0) + 400 * (GetSpell(HUNGERING_COLD_1) != 0)) &&
+                Rand() < 60)
+            {
+                if (doCast(opponent, GetSpell(DEATH_COIL_1)))
+                    return;
+            }
+
+            //MELEE SECTION
+
+            //MIND FREEZE
+            if (IsSpellReady(MIND_FREEZE_1, diff, false) && meleedist <= 5 && getpower() >= 200 &&
+                opponent->IsNonMeleeSpellCast(false) && Rand() < 60)
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(MIND_FREEZE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HUNGERING COLD
+            if (IsSpellReady(HUNGERING_COLD_1, diff) && HasRole(BOT_ROLE_DPS) && getpower() >= 400 && Rand() < 20)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f, 0, true);
+                if (targets.size() >= 3)
+                {
+                    if (doCast(me, GetSpell(HUNGERING_COLD_1)))
+                        return;
+                }
+
+                SetSpellCooldown(HUNGERING_COLD_1, 500); //fail
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //RUNE STRIKE
+            if (IsSpellReady(RUNE_STRIKE_1, diff, false) && runestriketimer > me->getAttackTimer(BASE_ATTACK) &&
+                HasRole(BOT_ROLE_DPS) && meleedist <= 5 && getpower() >= 200/* && Rand() < 75*/)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(RUNE_STRIKE_1)))
+                {
+                    runestriketimer = 0; //do not remove aura, just disable ability
+                    GC_Timer = temptimer;
+                }
+            }
+            //PLAGUE STRIKE
+            if (IsSpellReady(PLAGUE_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && HaveRune(RUNE_UNHOLY) && Rand() < 35 &&
+                !opponent->HasAura(BLOOD_PLAGUE_AURA, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(PLAGUE_STRIKE_1)))
+                    return;
+            }
+
+            //DISEASE SECTION
+            uint32 diseases = opponent->GetDiseasesByCaster(me->GetGUID());
+
+            //PESTILENCE //custom cd condition
+            if (GetSpell(PESTILENCE_1) && pestilencetimer == 0 && HasRole(BOT_ROLE_DPS) && GC_Timer <= 600 &&
+                diseases > 1 && meleedist <= 5 &&
+                HaveRune(RUNE_BLOOD) && Rand() < 15)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f);
+                if (targets.size() > 2)
+                {
+                    if (doCast(opponent, GetSpell(PESTILENCE_1)))
+                    {
+                        pestilencetimer = 10000;
+                        return;
+                    }
+                }
+
+                pestilencetimer = 1000; //fail
+            }
+            //DEATH STRIKE
+            if (IsSpellReady(DEATH_STRIKE_1, diff) && diseases > 0 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) &&
+                GetHealthPCT(me) < (91 - 10 * diseases) && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(DEATH_STRIKE_1)))
+                    return;
+            }
+            //OBLITERATE
+            if (IsSpellReady(OBLITERATE_1, diff) && diseases > 2 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) && Rand() < 20)
+            {
+                if (doCast(opponent, GetSpell(OBLITERATE_1)))
+                    return;
+            }
+            //BLOOD STRIKE //custom
+            if (BLOOD_STRIKE && GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && diseases > 1 && meleedist <= 5 &&
+                HaveRune(RUNE_BLOOD) && Rand() < 25)
+            {
+                if (doCast(opponent, BLOOD_STRIKE))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+
+                //Increased Plague Strike Crit (id 60130): 10% additional critical chance for Plague Strike
+                if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                    aftercrit += 0.1f;
+                //Glyph of Rune Strike: 10% additional critical chance for Rune Strike
+                if (spellId == GetSpell(RUNE_STRIKE_1))
+                    aftercrit += 0.1f;
+                //Subversion: 9% additional critical chance for Blood Strike, Scourge Strike, Heart Strike and Obliterate
+                if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
+                    /*spellId == GetSpell(SCOURGE_STRIKE_1) || */spellId == GetSpell(OBLITERATE_1))
+                    aftercrit += 0.09f;
+                //Improved Death Strike (part 2): 6% additional critical chance for Death Strike
+                if (spellId == GetSpell(DEATH_STRIKE_1))
+                    aftercrit += 0.06f;
+                //Rime (part 1 melee): 15% additional critical chance for Obliterate
+                if (lvl >= 68 && spellId == GetSpell(OBLITERATE_1))
+                    aftercrit += 15.f;
+                //Vicious Strikes (part 1): 6% additional critical chance for Plague Strike and Scourge Strike
+                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
+                    aftercrit += 6.f;
+
+                //Annihilation: 3% additional critical chance for melee special abilities
+                if (lvl >= 57)
+                    aftercrit += 0.03f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+
+                //Might of Mograine: 45% crit damage bonus for Blood Boil, Blood Strike, Death Strike and Heart Strike
+                if (lvl >= 68 &&
+                    (spellId == GetSpell(BLOOD_BOIL_1) || spellId == BLOOD_STRIKE ||
+                    spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(HEART_STRIKE_1)))
+                    pctbonus += 0.45f / 2.f;
+                //Guile of Gorefiend (part 1 melee): 45% crit damage bonus for Blood Strike, Frost Strike and Obliterate
+                if (lvl >= 69 &&
+                    (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
+                    spellId == GetSpell(OBLITERATE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
+                    pctbonus += 0.45f / 2.f;
+                //Vicious Strikes (part 2): 30% crit damage bonus for Plague Strike and Scourge Strike
+                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
+                    pctbonus += 0.3f / 2.f;
+            }
+
+            //Glypg of Plague Strike: 20% bonus damage for Plague Strike
+            if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                pctbonus += 0.2f;
+            //Glyph of Blood Strike: 20% bonus damage for Blood Strike on snared targets (Heart Strike too for bots)
+            //warning unsafe
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+                if (damageinfo.target->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_SLOW_ATTACK)))
+                    pctbonus += 0.2f;
+            //Increased Blood Strike Damage: 90 bonus damage for Blood Strike and Heart Strike
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+                fdamage += 90.f;
+            //Glyph of Death Strike: 1% bonus damage for every runic power point (max 25) for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1) && me->GetPower(POWER_RUNIC_POWER) >= 10)
+            {
+                //10 to 250 * 0.001 = 10 to 250 / 1000 = 0.01 to 0.25
+                pctbonus += float(std::min<uint32>(me->GetPower(POWER_RUNIC_POWER), 250)) * 0.001f;
+            }
+            //Glyph of Obliterate: 25% bonus damage for Obliterate
+            if (spellId == GetSpell(OBLITERATE_1))
+                pctbonus += 0.25f;
+            //Bloody Strikes: 15% bonus damage for Blood Strike, 45% for Heart Strike and 30% for Blood Boil
+            if (lvl >= 60)
+            {
+                if (spellId == BLOOD_STRIKE)
+                    pctbonus += 0.15f;
+                else if (spellId == GetSpell(HEART_STRIKE_1))
+                    pctbonus += 0.45f;
+                else if (spellId == GetSpell(BLOOD_BOIL_1))
+                    pctbonus += 0.3f;
+            }
+            //Improved Death Strike (part 1): 30% bonus damage for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1))
+                pctbonus += 0.3f;
+            //Merciless Combat (melee): 12% bonus damage for Obliterate on targets with less than 35% hp
+            //warning unsafe
+            if (lvl >= 67 && spellId == GetSpell(OBLITERATE_1) && damageinfo.target->GetHealthPct() < 35)
+                pctbonus += 0.12f;
+            //Blood of the North (part 1): 10% bonus damage for Blood Strike and Frost Strike (make Heart strike too)
+            if (lvl >= 69 && (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
+                pctbonus += 0.1f;
+            //Tundra Stalker (melee): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
+            //warning unsafe
+            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
+                pctbonus += 0.2f;
+            //Outbreak: 30% bonus damage for Plague Strike and 20% for Scourge Strike
+            if (lvl >= 59)
+            {
+                if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                    pctbonus += 0.3f;
+                //else if (spellId == GetSpell(SCOURGE_STRIKE_1))
+                //    pctbonus += 0.2f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Rime (part 1 spell): 15% additional critical chance for Icy Touch
+                if (lvl >= 68 && spellId == GetSpell(ICY_TOUCH_1))
+                    aftercrit += 15.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+
+                //Guile of Gorefiend (part 1 spell): 45% crit damage bonus for Howling Blast
+                if (lvl >= 69 && spellId == GetSpell(HOWLING_BLAST_1))
+                    pctbonus += 0.45f / 1.5f;
+
+                //Runic Focus: 50% crit damage bonus for all spells
+                pctbonus += 0.5f / 1.5f;
+            }
+
+            //Improved Icy Touch: 15% bonus damage for Icy Touch
+            if (spellId == GetSpell(ICY_TOUCH_1))
+                pctbonus += 0.15f;
+            //Increased Icy Touch Damage (id 54800): 111 bonus damage for Icy Touch
+            if (spellId == GetSpell(ICY_TOUCH_1))
+                fdamage += 111.f;
+            //Increased Death Coil Damage (id 54807): 80 bonus damage for Death Coil
+            if (spellId == GetSpell(DEATH_COIL_1))
+                fdamage += 80.f;
+            //Black Ice: 10% bonus damage for all Shadow and Frost spells
+            if (lvl >= 58 &&
+                ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
+                (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
+                pctbonus += 0.1f;
+            //Glacier Rot: 20% bonus damage for Icy Touch, Howling Blast and Frost Strike
+            //warning unsafe
+            if (lvl >= 63 && (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
+                damageinfo.target->GetDiseasesByCaster(me->GetGUID()) > 0)
+                pctbonus += 0.2f;
+            //Merciless Combat (spell): 12% bonus damage for Icy Touch, Howling Blast and Frost Strike on targets with less than 35% hp
+            //warning unsafe
+            if (lvl >= 67 &&
+                (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
+                damageinfo.target->GetHealthPct() < 35)
+                pctbonus += 0.12f;
+            //Tundra Stalker (spell): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
+            //warning unsafe
+            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
+                pctbonus += 0.2f;
+            //Morbidity: 15% damage bonus for Death Coil
+            if (lvl >= 58 && spellId == GetSpell(DEATH_COIL_1))
+                pctbonus += 0.15f;
+
+            //temp
+            if (spellId == GetSpell(RUNE_TAP_1))
+                pctbonus += 1.f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float& value) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pct_mod = 1.f;
+
+            //Periodic damage bonuses
+            if (spellInfo->Effects[effect_index].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE)
+            {
+                //float ticksnum = float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+
+                //Increased Plague Strike DoT Damage (id 54802): increased DoT damage by 100
+                if (spellId == BLOOD_PLAGUE_AURA)
+                    value += 100.f;
+                //Glyph of Icy Touch: 20% bonus damage for Frost Fever
+                if (spellId == FROST_FEVER_AURA)
+                    pct_mod += 0.2f;
+                //Black Ice: 10% bonus damage for all Shadow and Frost spells
+                if (lvl >= 58 &&
+                    ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
+                    (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
+                    pct_mod += 0.1f;
+                //Glyph of Unholy Blight: 40% damage bonus for Unholy Blight (100% for bot)
+                if (spellId == UNHOLY_BLIGHT_AURA)
+                    pct_mod += 1.f;
+            }
+            //Heal bonuses
+            if (spellInfo->Effects[effect_index].Effect == SPELL_EFFECT_HEAL)
+            {
+                //Improved Rune Tap: 100% bonus healing from Rune Tap
+                if (spellId == GetSpell(RUNE_TAP_1))
+                    pct_mod += 1.f;
+            }
+
+            value *= pct_mod;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Glyph of Horn of Winter: 1 minute bonus duration (3 for bot)
+            if (spellId == GetSpell(HORN_OF_WINTER_1))
+            {
+                if (Aura* horn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = horn->GetDuration() + 180000;
+                    horn->SetDuration(dur);
+                    horn->SetMaxDuration(dur);
+                }
+
+                //Winter Veil addition
+                if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                    me->AddAura(44755, target); //snowflakes
+            }
+
+            if (target == me)
+                return;
+
+            //Epidemic: 10 sec bonus duration for all diseases
+            if (spellId == FROST_FEVER_AURA || spellId == BLOOD_PLAGUE_AURA ||
+                spellId == CRYPT_FEVER_AURA || spellId == EBON_PLAGUE_AURA)
+            {
+                if (Aura* fever = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = fever->GetDuration() + 10000;
+                    fever->SetDuration(dur);
+                    fever->SetMaxDuration(dur);
+                }
+            }
+            //Sudden Doom: 15% ctc Death Coil on Blood Strike or Heart Strike (up to 30% for bot)
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+            {
+                if (GetSpell(DEATH_COIL_1) && me->getLevel() >= 65 && irand(1,100) <= (me->getLevel() - 50))
+                {
+                    //debug: dk bot cannot cast without runic power even triggered spells
+                    modpower(40);
+                    me->CastSpell(target, GetSpell(DEATH_COIL_1), true);
+                }
+            }
+            //Rime (part 2): Obliterate has 15% chance to reset Howling Blast cooldown (25% for bot, screw runes part)
+            if (spellId == GetSpell(OBLITERATE_1))
+            {
+                if (me->getLevel() >= 67 && urand(1,100) <= 25)
+                    ResetSpellCooldown(HOWLING_BLAST_1);
+            }
+            //Chillblains Improved: increase duration by 10 sec (disable on players)
+            if (spellId == ICY_CLUTCH)
+            {
+                if (target->GetTypeId() != TYPEID_PLAYER)
+                {
+                    if (Aura* chill = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = chill->GetDuration() + 10000;
+                        chill->SetDuration(dur);
+                        chill->SetMaxDuration(dur);
+                    }
+                }
+            }
+            //Blood of the North (part 2): Blood Strike and Pestilence convert Blood Rune to Dark Rune (make Heart Strike too)
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) || GetSpell(spellId == PESTILENCE_1))
+            {
+                if (me->getLevel() >= 69)
+                    ConvertRune(RUNE_BLOOD, 1);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == RUNE_STRIKE_ACIVATION_AURA)
+            {
+                //Rune Strike activation and timer set
+                runestriketimer = 10000;
+            }
+            if (spellId == GetSpell(ANTI_MAGIC_SHELL_1))
+            {
+                //Glyph of Anti-Magic Shell: 2 sec increased duration (5 for bot)
+                if (Aura* shell = me->GetAura(spellId))
+                {
+                    uint32 dur = shell->GetDuration() + 5000;
+                    shell->SetDuration(dur);
+                    shell->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(VAMPIRIC_BLOOD_1))
+            {
+                //Glyph of Vampiric Blood: 5 sec increased duration
+                if (Aura* blood = me->GetAura(spellId))
+                {
+                    uint32 dur = blood->GetDuration() + 5000;
+                    blood->SetDuration(dur);
+                    blood->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(BONE_SHIELD_1))
+            {
+                //Glyph of Bone Shield: 1 bonus charge (2 for bot, 7 for tank)
+                if (Aura* bone = me->GetAura(spellId))
+                {
+                    bone->SetCharges(bone->GetCharges() + (IsTank() ? 3 : 1));
+                }
+            }
+            if (spellId == ICY_TALONS_AURA1 || spellId == ICY_TALONS_AURA2 ||
+                spellId == ICY_TALONS_AURA3 || spellId == ICY_TALONS_AURA4 || spellId == ICY_TALONS_AURA5)
+            {
+                //Icy Talons: Synchronize with Epidemic, add 10 sec duration
+                if (Aura* talons = me->GetAura(spellId))
+                {
+                    uint32 dur = talons->GetDuration() + 10000;
+                    talons->SetDuration(dur);
+                    talons->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(OBLITERATE_1))
+            {
+                //Death Rune Mastery: convert Unholy and Frost Runes into Death Runes
+                ConvertRune(RUNE_UNHOLY, 1);
+                ConvertRune(RUNE_FROST, 1);
+            }
+            if (spellId == GetSpell(ICEBOUND_FORTITUDE_1))
+            {
+                //Guile of Gorefiend (part 2): Icebound Fortitude 6 sec increased duration (18 for bot)
+                if (Aura* fort = me->GetAura(spellId))
+                {
+                    uint32 dur = fort->GetDuration() + 18000;
+                    fort->SetDuration(dur);
+                    fort->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                //Blood Presence Heal
+                if (me->HasAura(IMPROVED_BLOOD_PRESENCE_AURA))
+                {
+                    int32 bp0 = int32(damage / 25); //4%
+                    me->CastCustomSpell(me, BLOOD_PRESENCE_HEAL_EFFECT, &bp0, NULL, NULL, true);
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            presencetimer = 0;
+            runicpowertimer = 2000;
+            runicpowertimer2 = 5000;
+            runestriketimer = 0;
+            pestilencetimer = 0;
+
+            Presence = BOT_STANCE_NONE;
+
+            runicpowerIncomeMult = sWorld->getRate(RATE_POWER_RUNICPOWER_INCOME);
+            runicpowerLossMult = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
+            me->setPowerType(POWER_RUNIC_POWER);
+            me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
+
+            DefaultInit();
+            InitRunes();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            RuneTimers(diff);
+
+            if (presencetimer > diff)               presencetimer -= diff;
+            if (runicpowertimer > diff)             runicpowertimer -= diff;
+            if (runicpowertimer2 > diff)            runicpowertimer2 -= diff;
+
+            if (runestriketimer > diff)             runestriketimer -= diff;
+            else                                    runestriketimer = 0;
+            if (pestilencetimer > diff)             pestilencetimer -= diff;
+            else                                    pestilencetimer = 0;
+        }
+
+        void InitPowers()
+        {
+            if (master->getLevel() >= 70)
+                RefreshAura(RUNIC_POWER_MASTERY,5);
+            else if (master->getLevel() >= 58)
+                RefreshAura(RUNIC_POWER_MASTERY,4);
+            else
+            {
+                RefreshAura(RUNIC_POWER_MASTERY,0);
+                me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
+            }
+
+            if (runicpower)
+                me->SetPower(POWER_RUNIC_POWER, runicpower);
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            //InitSpellMap(BLOOD_STRIKE_1);
+            InitSpellMap(ICY_TOUCH_1);
+            InitSpellMap(PLAGUE_STRIKE_1);
+            InitSpellMap(DEATH_STRIKE_1);
+            InitSpellMap(OBLITERATE_1);
+            InitSpellMap(RUNE_STRIKE_1);
+  /*Talent*/InitSpellMap(HEART_STRIKE_1);
+
+            InitSpellMap(BLOOD_BOIL_1);
+            InitSpellMap(DEATH_AND_DECAY_1);
+  /*Talent*/lvl >= 63 ? InitSpellMap(HOWLING_BLAST_1) : RemoveSpell(HOWLING_BLAST_1);
+
+            InitSpellMap(DEATH_COIL_1);
+            InitSpellMap(DEATH_GRIP_1, true);
+            InitSpellMap(PESTILENCE_1);
+            InitSpellMap(MIND_FREEZE_1);
+            InitSpellMap(STRANGULATE_1);
+            InitSpellMap(CHAINS_OF_ICE_1);
+            InitSpellMap(ICEBOUND_FORTITUDE_1);
+            InitSpellMap(DARK_COMMAND_1);
+            InitSpellMap(ANTI_MAGIC_SHELL_1);
+            InitSpellMap(ARMY_OF_THE_DEAD_1);
+  /*Talent*/InitSpellMap(LICHBORNE_1, true);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HUNGERING_COLD_1) : RemoveSpell(HUNGERING_COLD_1);
+
+            InitSpellMap(PATH_OF_FROST_1);
+            InitSpellMap(HORN_OF_WINTER_1);
+  /*Talent*/InitSpellMap(RUNE_TAP_1, true);
+  /*Talent*/lvl >= 58 ? InitSpellMap(BONE_SHIELD_1) : RemoveSpell(BONE_SHIELD_1);
+            InitSpellMap(EMPOWER_RUNE_WEAPON_1);
+  /*Talent*/InitSpellMap(MARK_OF_BLOOD_1, true);
+  /*Talent*/InitSpellMap(VAMPIRIC_BLOOD_1, true);
+  /*Talent*/lvl >= 59 ? InitSpellMap(HYSTERIA_1) : RemoveSpell(HYSTERIA_1);
+
+            InitSpellMap(BLOOD_PRESENCE_1, true);
+            InitSpellMap(FROST_PRESENCE_1, true);
+            //InitSpellMap(UNHOLY_PRESENCE_1, true);
+
+  /*Custom*/BLOOD_STRIKE = lvl >= 65 ? GetSpell(HEART_STRIKE_1) : InitSpell(me, BLOOD_STRIKE_1);
+            InitSpellMap(BLOOD_STRIKE);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(GLYPH_OF_CHAINS_OF_ICE, level >= 58 ? 1 : 0);
+            RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH, level >= 80 ? 4 : level >= 77 ? 3 : level >= 68 ? 2 : level >= 58 ? 1 : 0);
+            RefreshAura(GLYPH_OF_HEART_STRIKE, level >= 65 ? 1 : 0);
+            RefreshAura(GLYPH_OF_RUNE_TAP, level >= 68 ? 2 : level >= 60 ? 1 : 0);
+            RefreshAura(GLYPH_OF_HOWLING_BLAST, level >= 63 ? 1 : 0);
+            RefreshAura(BUTCHERY, level >= 57 ? 1 : 0);
+            RefreshAura(SCENT_OF_BLOOD, level >= 58 ? 1 : 0);
+            RefreshAura(VENDETTA, level >= 59 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE3, level >= 65 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE2, level >= 60 && level < 65 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE1, level >= 57 && level < 60 ? 1 : 0);
+            RefreshAura(ABOMINATIONS_MIGHT, level >= 60 ? 1 : 0);
+            RefreshAura(IMPROVED_BLOOD_PRESENCE, level >= 67 ? 1 : 0);
+            RefreshAura(BLOODWORMS, level >= 65 ? 2 : 0);
+            //RefreshAura(IMPROVED_DEATH_STRIKE, level >= 66 ? 1 : 0);
+            RefreshAura(TOUGHNESS, level >= 57 ? 1 : 0);
+            RefreshAura(ANNIHILATION, level >= 57 ? 1 : 0);
+            RefreshAura(ICY_TALONS, level >= 60 ? 1 : 0);
+            RefreshAura(CHILL_OF_THE_GRAVE, level >= 68 ? 2 : level >= 58 ? 1 : 0);
+            RefreshAura(IMPROVED_ICY_TALONS, level >= 64 ? 1 : 0);
+            RefreshAura(CHILBLAINS, level >= 68 ? 1 : 0);
+            RefreshAura(ACCLIMATION, level >= 69 ? 1 : 0);
+            RefreshAura(NECROSIS5, level >= 63 ? 1 : 0);
+            RefreshAura(NECROSIS4, level >= 62 && level < 63 ? 1 : 0);
+            RefreshAura(NECROSIS3, level >= 61 && level < 62 ? 1 : 0);
+            RefreshAura(NECROSIS2, level >= 60 && level < 61 ? 1 : 0);
+            RefreshAura(NECROSIS1, level >= 59 && level < 60 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE3, level >= 65 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE2, level >= 62 && level < 65 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE1, level >= 60 && level < 62 ? 1 : 0);
+            RefreshAura(DIRGE, level >= 67 ? 2 : level >= 61 ? 1 : 0);
+            RefreshAura(UNHOLY_BLIGHT, level >= 61 ? 1 : 0);
+            RefreshAura(DESECRATION, level >= 62 ? 1 : 0);
+            RefreshAura(CRYPT_FEVER, level >= 64 ? 1 : 0);
+            RefreshAura(EBON_PLAGUEBRINGER, level >= 68 ? 1 : 0);
+            RefreshAura(WANDERING_PLAGUE, level >= 67 ? 1 : 0);
+
+            RefreshAura(FROST_FEVER);
+            RefreshAura(BLOOD_PLAGUE);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case LICHBORNE_1:
+                case PATH_OF_FROST_1:
+                case HORN_OF_WINTER_1:
+                case BONE_SHIELD_1:
+                case RUNE_TAP_1:
+                case EMPOWER_RUNE_WEAPON_1:
+                case VAMPIRIC_BLOOD_1:
+                case HYSTERIA_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 BLOOD_STRIKE;
+/*tmrs*/uint32 presencetimer, runicpowertimer, runicpowertimer2, runestriketimer, pestilencetimer;
+/*misc*/uint32 runicpower;
+/*misc*/float runicpowerIncomeMult, runicpowerLossMult;
+/*Chck*/uint8 Presence;
+
+        BotRunes _runes;
+
+        enum DeathKnightBaseSpells
+        {
+            BLOOD_STRIKE_1                      = 45902,
+            ICY_TOUCH_1                         = 45477,
+            PLAGUE_STRIKE_1                     = 45462,
+            DEATH_STRIKE_1                      = 49998,
+            OBLITERATE_1                        = 49020,
+            RUNE_STRIKE_1                       = 56815,
+            HEART_STRIKE_1                      = 55050,
+
+            BLOOD_BOIL_1                        = 48721,
+            DEATH_AND_DECAY_1                   = 43265,
+            HOWLING_BLAST_1                     = 49184,
+
+            DEATH_COIL_1                        = 47541,
+            DEATH_GRIP_1                        = 49576,
+            PESTILENCE_1                        = 50842,
+            MIND_FREEZE_1                       = 47528,
+            STRANGULATE_1                       = 47476,
+            CHAINS_OF_ICE_1                     = 45524,
+            ICEBOUND_FORTITUDE_1                = 48792,
+            DARK_COMMAND_1                      = 56222,
+            ANTI_MAGIC_SHELL_1                  = 48707,
+            ARMY_OF_THE_DEAD_1                  = 42650,
+            LICHBORNE_1                         = 49039,
+            HUNGERING_COLD_1                    = 49203,
+
+            PATH_OF_FROST_1                     = 3714,
+            HORN_OF_WINTER_1                    = 57330,
+            BONE_SHIELD_1                       = 49222,
+            RUNE_TAP_1                          = 48982,
+            EMPOWER_RUNE_WEAPON_1               = 47568,
+            MARK_OF_BLOOD_1                     = 49005,
+            VAMPIRIC_BLOOD_1                    = 55233,
+            HYSTERIA_1                          = 49016,
+
+            BLOOD_PRESENCE_1                    = 48266,
+            FROST_PRESENCE_1                    = 48263
+            //UNHOLY_PRESENCE_1                   = 48265
+        };
+        enum DeathKnightPassives
+        {
+        //Talents
+            BUTCHERY                            = 49483,//rank 2
+            SCENT_OF_BLOOD                      = 49509,//rank 3
+            VENDETTA                            = 55136,//rank 3
+            BLOODY_VENGEANCE1                   = 48988,
+            BLOODY_VENGEANCE2                   = 49503,
+            BLOODY_VENGEANCE3                   = 49504,
+            ABOMINATIONS_MIGHT                  = 53138,//rank 2
+            IMPROVED_BLOOD_PRESENCE             = 50371,//rank 2
+            BLOODWORMS                          = 49543,//rank 3
+            IMPROVED_DEATH_STRIKE               = 62908,//rank 2
+            TOUGHNESS                           = 49789,//rank 5
+            ANNIHILATION                        = 51473,//rank 3
+            ICY_TALONS                          = 50887,//rank 5
+            CHILL_OF_THE_GRAVE                  = 50115,//rank 2
+            IMPROVED_ICY_TALONS                 = 55610,
+            CHILBLAINS                          = 50043,//rank 3
+            ACCLIMATION                         = 50152,//rank 3
+            NECROSIS1                           = 51459,
+            NECROSIS2                           = 51462,
+            NECROSIS3                           = 51463,
+            NECROSIS4                           = 51464,
+            NECROSIS5                           = 51465,
+            BLOOD_CAKED_BLADE1                  = 49219,
+            BLOOD_CAKED_BLADE2                  = 49627,
+            BLOOD_CAKED_BLADE3                  = 49628,
+            DIRGE                               = 51206,//rank 2
+            UNHOLY_BLIGHT                       = 49194,
+            DESECRATION                         = 55667,//rank 2
+            CRYPT_FEVER                         = 49632,//rank 3
+            EBON_PLAGUEBRINGER                  = 51161,//rank 3
+            WANDERING_PLAGUE                    = 49655,//rank 3
+        //Special
+  /*Talent*/RUNIC_POWER_MASTERY                 = 50147,//rank 2
+            FROST_FEVER                         = 59921,
+            BLOOD_PLAGUE                        = 59879,
+        //Other
+            GLYPH_OF_CHAINS_OF_ICE              = 58620,//damage proc
+            CHAINS_OF_ICE_FROST_RUNE_REFRESH    = 62459,//5 runic power gain
+            GLYPH_OF_HEART_STRIKE               = 58616,//snare 50% for 10 sec
+            GLYPH_OF_RUNE_TAP                   = 59327,//10% heal for party
+            GLYPH_OF_HOWLING_BLAST              = 63335 //frost fever on targets
+        };
+        enum DeathKnightSpecial
+        {
+            FROST_FEVER_AURA                    = 55095,
+            BLOOD_PLAGUE_AURA                   = 55078,
+            CRYPT_FEVER_AURA                    = 50510,//rank 3
+            EBON_PLAGUE_AURA                    = 51735,//rank 3
+
+            RUNE_STRIKE_ACIVATION_AURA          = 56817,
+
+            IMPROVED_BLOOD_PRESENCE_AURA        = 63611,
+            BLOOD_PRESENCE_HEAL_EFFECT          = 50475,
+            BLADE_BARRIER_AURA                  = 64859,//rank 5
+            UNHOLY_BLIGHT_AURA                  = 50536,
+
+            ICY_TALONS_AURA1                    = 50882,//rank 1
+            ICY_TALONS_AURA2                    = 58575,//rank 2
+            ICY_TALONS_AURA3                    = 58576,//rank 3
+            ICY_TALONS_AURA4                    = 58577,//rank 4
+            ICY_TALONS_AURA5                    = 58578,//rank 5
+
+            DEATH_COIL_ENEMY                    = 47632,
+            ICY_CLUTCH                          = 50436 //rank 3 Chilblains proc
+        };
+        //enum RunePlacing
+        //{
+        //    RUNE_BLOOD_FIRST,
+        //    RUNE_BLOOD_SECOND,
+        //    RUNE_UNHOLY_FIRST,
+        //    RUNE_UNHOLY_SECOND,
+        //    RUNE_FROST_FIRST,
+        //    RUNE_FROST_SECOND,
+        //    NO_RUNE
+        //};
+    };
+};
+
+void AddSC_death_knight_bot()
+{
+    new death_knight_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
new file mode 100644
index 0000000..5802780
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
@@ -0,0 +1,1389 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+//#include "WorldSession.h"
+/*
+Druid NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Maybe 30%
+TODO: Feral Spells (from scratch), More Forms, Balance Spells + treants...
+*/
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new bot_druid_ai(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct bot_druid_ai : public bot_minion_ai
+    {
+        bot_druid_ai(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_DRUID;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_DRUID) != SPELL_CAST_OK)
+                return false;
+
+            m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (me->GetShapeshiftForm() == FORM_NONE && swiftness && m_botSpellInfo->CalcCastTime() > 0)
+            {
+                DoCast(victim, spellId, true);
+                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                me->RemoveAurasDueToSpell(CRIT_50, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                swiftness = false;
+                return true;
+            }
+            if (spellId == GetSpell(BEAR_FORM_1) || GetSpell(spellId == CAT_FORM_1))
+            {
+                //me->ModifyPower(POWER_MANA, - int32(m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask())));
+                if (me->GetVictim())
+                    GetInPosition(true);
+            }
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result &&
+                spellId != MANAPOTION && spellId != WARSTOMP_1 &&
+                me->HasAura(OMEN_OF_CLARITY_BUFF))
+            {
+                cost = m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask());
+                clearcast = true;
+                power = me->getPowerType();
+            }
+            return result;
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { removeFeralForm(true, false); bot_minion_ai::JustDied(u); }
+
+        uint8 GetBotStance() const
+        {
+            return Form;
+        }
+
+        void warstomp(uint32 diff)
+        {
+            if (me->getRace() != RACE_TAUREN) return;
+            if (!IsSpellReady(WARSTOMP_1, diff, false)) return;
+            if (me->GetShapeshiftForm() != FORM_NONE)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+            {
+                Unit* u = me->SelectNearestTarget(5);
+                if (u && u->IsInCombat() && u->isTargetableForAttack())
+                {
+                    if (doCast(me, WARSTOMP_1))
+                        return;
+                }
+            }
+            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if (!(*iter)->isTargetableForAttack()) continue;
+                if (me->GetDistance((*iter)) <= 5)
+                {
+                    if (doCast(me, WARSTOMP_1))
+                        return;
+                }
+            }
+        }
+
+        bool DamagePossible()
+        {
+            return true;
+            //return (GetManaPCT(me) < 30 || GetHealthPCT(master) < 50);
+            /*if (GetHealthPCT(master) < 75 || GetHealthPCT(me) < 75) return false;
+
+            if (Group* pGroup = master->GetGroup())
+            {
+                uint8 LHPcount = 0;
+                uint8 DIScount = 0;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
+                        ++LHPcount;
+                    Unit::AuraApplicationMap const& auras = tPlayer->GetAppliedAuras();
+                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                        if (itr->second->GetBase()->GetSpellInfo()->Dispel == DISPEL_POISON)
+                            ++DIScount;
+                }
+                uint8 members = master->GetGroup()->GetMembersCount();
+
+                if (members > 10)
+                {
+                    if (LHPcount > 1 || DIScount > 2) return false;
+                }
+                if (members > 4)
+                {
+                    if (LHPcount > 0 || DIScount > 1) return false;
+                }
+                if (members < 5)
+                {
+                    if (LHPcount > 0 || DIScount > 0) return false;
+                }
+            }//endif unitlist
+
+            Unit* u = master->GetVictim();
+            if (master->getAttackers().size() > 4 ||
+              (!master->getAttackers().empty() &&
+                u != NULL && u->GetHealth() > me->GetMaxHealth()*17))
+                return false;
+
+            return true;*/
+        }
+
+        void removeFeralForm(bool force = false, bool /*init*/ = true, uint32 diff = 0)
+        {
+            if (!force && formtimer > diff)
+                return;
+
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                    case FORM_DIREBEAR:
+                    case FORM_BEAR:
+                        me->RemoveAurasDueToSpell(GetSpell(BEAR_FORM_1));
+                        break;
+                    case FORM_CAT:
+                        me->RemoveAurasDueToSpell(GetSpell(CAT_FORM_1));
+                        me->RemoveAurasDueToSpell(ENERGIZE);
+                        break;
+                    default:
+                        break;
+                }
+
+                setStats(BOT_CLASS_DRUID);
+            }
+            else if (Form != BOT_STANCE_NONE)
+                Form = BOT_STANCE_NONE;
+        }
+
+        bool IsMelee() const
+        {
+            if (GetBotStance() == DRUID_BEAR_FORM || GetBotStance() == DRUID_CAT_FORM)
+                return true;
+
+            return bot_ai::IsMelee();
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void doBearActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_RAGE) return;
+
+            if (GetHealthPCT(me) < 75)
+                if (HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (IsSpellReady(MANGLE_BEAR_1, diff) && HasRole(BOT_ROLE_DPS) && rage >= 150 && Rand() < 35 &&
+                doCast(opponent, GetSpell(MANGLE_BEAR_1)))
+                return;
+
+            if (IsSpellReady(SWIPE_1, diff) && HasRole(BOT_ROLE_DPS) && rage >= 150 && Rand() < 75 &&
+                doCast(opponent, GetSpell(SWIPE_1)))
+                return;
+
+        }//end doBearActions
+
+        void doCatActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_ENERGY) return;
+
+            if (GetHealthPCT(me) < 75)
+                if (HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            uint32 energy = me->GetPower(POWER_ENERGY);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (IsSpellReady(MANGLE_CAT_1, diff) && energy > 45 && HasRole(BOT_ROLE_DPS) && Rand() < 35 &&
+                doCast(opponent, GetSpell(MANGLE_CAT_1)))
+                return;
+            if (IsSpellReady(RAKE_1, diff) && energy > 40 && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
+                doCast(opponent, GetSpell(RAKE_1)))
+                return;
+            if (IsSpellReady(SHRED_1, diff) && energy > 60 && HasRole(BOT_ROLE_DPS) && !opponent->HasInArc(M_PI, me) && Rand() < 50 &&
+                doCast(opponent, GetSpell(SHRED_1)))
+                return;
+            if (IsSpellReady(RIP_1, diff) && energy > 30 && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
+                doCast(opponent, GetSpell(RIP_1)))
+                return;
+            if (IsSpellReady(CLAW_1, diff) && energy > 45 && HasRole(BOT_ROLE_DPS) && Rand() < 80 &&
+                doCast(opponent, GetSpell(CLAW_1)))
+                return;
+        }//end doCatActions
+
+        void doBalanceActions(uint32 diff)
+        {
+            removeFeralForm(true, true);
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //range check to prevent fake casts
+            if (me->GetExactDist(opponent) > 30 || !DamagePossible()) return;
+
+            if (IsSpellReady(HURRICANE_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && Rand() < 35)
+            {
+                Unit* target = FindAOETarget(30, true);
+                if (target && doCast(target, GetSpell(HURRICANE_1)))
+                    return;
+                SetSpellCooldown(HURRICANE_1, 2000); //fail
+            }
+            if (uint32 FAERIE_FIRE = GetSpell(FAERIE_FIRE_1))
+            {
+                if (GC_Timer <= diff &&
+                    opponent->getAttackers().size() > 1 &&//check if faerie fire is not useless 50/50
+                    Rand() < 20 && !HasAuraName(opponent, FAERIE_FIRE_1))
+                {
+                    if (doCast(opponent, FAERIE_FIRE))
+                        return;
+                }
+            }
+            if (IsSpellReady(MOONFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 20 &&
+                !HasAuraName(opponent, MOONFIRE_1, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(MOONFIRE_1)))
+                    return;
+            }
+            if (IsSpellReady(STARFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(STARFIRE_1)))
+                    return;
+            }
+            if (IsSpellReady(WRATH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                if (doCast(opponent, GetSpell(WRATH_1)))
+                    return;
+            }
+        }
+
+        bool MassGroupHeal(Player* gPlayer, uint32 diff)
+        {
+            if (!gPlayer || GC_Timer > diff || IAmFree()) return false;
+            if (IsCasting()) return false; // if I'm already casting
+            bool tranq = IsSpellReady(TRANQUILITY_1, diff, false);
+            bool growt = IsSpellReady(WILD_GROWTH_1, diff, false);
+            if (!tranq && !growt) return false;
+            if (Rand() > 30) return false;
+            Group* pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            uint8 LHPcount = 0;
+            uint8 pct = 100;
+            Unit* healTarget = NULL;
+            for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->GetMapId() != me->GetMapId() ||
+                    (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 39) continue;
+                if (GetHealthPCT(tPlayer) < 80)
+                {
+                    if (GetHealthPCT(tPlayer) < pct)
+                    {
+                        pct = GetHealthPCT(tPlayer);
+                        healTarget = tPlayer;
+                    }
+                    ++LHPcount;
+                    if (LHPcount > 2) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && bot->GetExactDist(me) < 40 && GetHealthPCT(bot) < 80)
+                        {
+                            if (GetHealthPCT(bot) < pct)
+                            {
+                                pct = GetHealthPCT(bot);
+                                healTarget = bot;
+                            }
+                            ++LHPcount;
+                            if (LHPcount > 2) break;
+                        }
+                    }
+                }
+            }
+            if (LHPcount > 2 && tranq &&
+                doCast(me, GetSpell(TRANQUILITY_1)))
+                return true;
+            if (LHPcount > 0 && growt && healTarget &&
+                doCast(healTarget, GetSpell(WILD_GROWTH_1)))
+                return true;
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+
+            if (me->getPowerType() == POWER_RAGE)
+            {
+                rage = me->GetPower(POWER_RAGE);
+                if (ragetimer2 <= diff)
+                {
+                    if (me->IsInCombat() && me->getLevel() >= 30)
+                    {
+                        if (rage < 990)
+                            me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
+                        else
+                            me->SetPower(POWER_RAGE, 1000);
+                    }
+                    ragetimer2 = 2000;
+                }
+                if (ragetimer <= diff)
+                {
+                    if (!me->IsInCombat())
+                    {
+                        if (rage > 10.f*rageLossMult)
+                            me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult)); //-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0);
+                    }
+                    ragetimer = 1500;
+                    if (rage > 1000) me->SetPower(POWER_RAGE, 1000);
+                    if (rage < 10) me->SetPower(POWER_RAGE, 0);
+                }
+            }
+            if (clearcast && me->HasAura(OMEN_OF_CLARITY_BUFF) && !me->IsNonMeleeSpellCast(false))
+            {
+                me->ModifyPower(power, cost);
+                me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+            warstomp(diff);
+
+            if (Potion_cd <= diff && me->getPowerType() == POWER_MANA && GetManaPCT(me) < 20)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            //Heal master
+            if (GetHealthPCT(master) < 85)
+                HealTarget(master, GetHealthPCT(master), diff);
+            //Innervate
+            doInnervate(diff);
+
+            MassGroupHeal(master, diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                CheckBattleRez(diff);
+            BuffAndHealGroup(master, diff);
+            //CureTarget(master, GetSpell(CURE_POISON_1), diff);
+            CureGroup(master, GetSpell(CURE_POISON_1), diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_DRUID))
+                return;
+
+            //debug
+            opponent = me->GetVictim();
+
+            if (GetHealthPCT(me) < 75)
+            {
+                HealTarget(me, GetHealthPCT(me), diff);
+                return;
+            }
+
+            if (IsCasting())
+                return; //Casting heal or something
+
+            CheckRoots(diff);
+
+            if (DamagePossible() && opponent != NULL)
+            {
+                Unit* u = opponent->GetVictim();
+                //if the target is attacking us, we want to go bear
+                if (GetSpell(BEAR_FORM_1) && !CCed(opponent) &&
+                    ((u == me || (IsTank() && IsInBotParty(u))) ||
+                    (!me->getAttackers().empty() && (*me->getAttackers().begin()) == opponent && opponent->GetMaxHealth() > me->GetMaxHealth()*2)))
+                {
+                    //if we don't have bear yet
+                    if (me->GetShapeshiftForm() != FORM_DIREBEAR &&
+                        me->GetShapeshiftForm() != FORM_BEAR &&
+                        formtimer <= diff &&
+                        doCast(me, GetSpell(BEAR_FORM_1)))
+                    {
+                        formtimer = 1500;
+                    }
+                    if (me->GetShapeshiftForm() == FORM_DIREBEAR ||
+                        me->GetShapeshiftForm() == FORM_BEAR)
+                        doBearActions(diff);
+                }
+                else
+                if (GetSpell(CAT_FORM_1) && master->GetVictim() != opponent && u &&
+                    IsTank(u) && u != me &&
+                    opponent->GetMaxHealth() < u->GetMaxHealth()*3)
+                {
+                    //if we don't have cat yet
+                    if (me->GetShapeshiftForm() != FORM_CAT && formtimer <= diff)
+                    {
+                        if (doCast(me, GetSpell(CAT_FORM_1)))
+                        {
+                            formtimer = 1500;
+                        }
+                    }
+                    if (me->GetShapeshiftForm() == FORM_CAT)
+                        doCatActions(diff);
+                }
+                else if (!IsTank())
+                    doBalanceActions(diff);
+            }
+            else if (!IsTank())
+                doBalanceActions(diff);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (hp > 95) return false;
+            if (!target || target->isDead()) return false;
+            if (IsTank() && hp > 35) return false;
+            if (hp > 50 && me->GetShapeshiftForm() != FORM_NONE) return false; //do not waste heal if in feral or so
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid() - 50*me->GetShapeshiftForm()) return false;
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) &&
+                (hp < 15 || (hp < 35 && target->getAttackers().size() > 2)) &&
+                (target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)) && RefreshAura(CRIT_50, 2))
+                {
+                    swiftness = true;
+                    if (doCast(target, GetSpell(HEALING_TOUCH_1), true))
+                        Heal_Timer = 3000;
+                    return true;
+                }
+            }
+            if (IsSpellReady(SWIFTMEND_1, diff, false, 3000) &&
+                (hp < 25 || GetLostHP(target) > 5000) &&
+                (HasAuraName(target, REGROWTH_1) || HasAuraName(target, REJUVENATION_1)))
+            {
+                if (doCast(target, GetSpell(SWIFTMEND_1)))
+                {
+                    if (GetHealthPCT(target) > 75)
+                        return true;
+                    else if (!target->getAttackers().empty())
+                    {
+                        if (doCast(target, GetSpell(REGROWTH_1)))
+                        {
+                            GC_Timer = 300;
+                            return true;
+                        }
+                    }
+                }
+            }
+            if (hp > 35 && (hp < 75 || GetLostHP(target) > 3000) && Heal_Timer <= diff && GetSpell(NOURISH_1))
+            {
+                switch (urand(1,3))
+                {
+                    case 1:
+                    case 2:
+                        if (doCast(target, GetSpell(NOURISH_1)))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                    case 3:
+                        if (doCast(target, GetSpell(HEALING_TOUCH_1)))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                }
+            }
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = IsTank(target) && boss;
+            bool regrowth = IsSpellReady(REGROWTH_1, diff);
+            if ( ( (hp < 80 || GetLostHP(target) > 3500 || tanking) &&
+                regrowth && !HasAuraName(target, REGROWTH_1, me->GetGUID()) )
+                ||
+                (HasAuraName(target, REGROWTH_1, me->GetGUID()) && HasAuraName(target, REJUVENATION_1, me->GetGUID()) &&
+                (hp < 70 || GetLostHP(target) > 3000) && regrowth))
+            {
+                if (doCast(target, GetSpell(REGROWTH_1)))
+                    return true;
+            }
+            if (GetSpell(REJUVENATION_1) && GC_Timer <= diff && hp > 25 &&
+                (hp < 90 || GetLostHP(target) > 2000 || tanking) &&
+                !HasAuraName(target, REJUVENATION_1, me->GetGUID()))
+            {
+                if (doCast(target, GetSpell(REJUVENATION_1)))
+                {
+                    if (!target->getAttackers().empty() && (hp < 75 || GetLostHP(target) > 4000))
+                        if (IsSpellReady(SWIFTMEND_1, diff, false) && doCast(target, GetSpell(SWIFTMEND_1)))
+                        {}
+                    GC_Timer = 500;
+                    return true;
+                }
+            }
+            if (IsSpellReady(LIFEBLOOM_1, diff) &&
+                ((hp < 85 && hp > 40) || (hp > 70 && tanking) ||
+                (hp < 70 && hp > 25 && HasAuraName(target, REGROWTH_1) && HasAuraName(target, REJUVENATION_1)) ||
+                (GetLostHP(target) > 1500 && hp > 35)))
+            {
+                Aura* bloom = target->GetAura(GetSpell(LIFEBLOOM_1), me->GetGUID());
+                if ((!bloom || bloom->GetStackAmount() < 3) && doCast(target, GetSpell(LIFEBLOOM_1)))
+                    return true;
+            }
+            if (hp > 30 && (hp < 70 || GetLostHP(target) > 3000) && Heal_Timer <= diff &&
+                doCast(target, GetSpell(HEALING_TOUCH_1)))
+            {
+                Heal_Timer = 3000;
+                return true;
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 20) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (target && target->IsAlive() && me->GetExactDist(target) < 30)
+            {
+                if (uint32 MARK_OF_THE_WILD = GetSpell(MARK_OF_THE_WILD_1))
+                    if (!HasAuraName(target, MARK_OF_THE_WILD_1))
+                        if (doCast(target, MARK_OF_THE_WILD))
+                            return true;
+                if (uint32 THORNS = GetSpell(THORNS_1))
+                    if (!HasAuraName(target, THORNS_1))
+                        if (doCast(target, THORNS))
+                            return true;
+            }
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(REVIVE_1), master);
+
+            //if (Feasting()) return;
+
+            //if (BuffTarget(master, diff))
+            //{
+            //    /*GC_Timer = 800;*/
+            //    return;
+            //}
+            //if (BuffTarget(me, diff))
+            //{
+            //    /*GC_Timer = 800;*/
+            //    return;
+            //}
+        }
+
+        void doInnervate(uint32 diff, uint8 minmanaval = 30)
+        {
+            if (!IsSpellReady(INNERVATE_1, diff) || Rand() > 15)
+                return;
+            if (me->GetShapeshiftForm() != FORM_NONE && (IsTank() || me->getAttackers().size() > 3))
+                return;
+
+            uint32 INNERVATE = GetSpell(INNERVATE_1);
+            Unit* iTarget = NULL;
+
+            if (master->IsInCombat() && master->getPowerType() == POWER_MANA &&
+                GetManaPCT(master) < 20 && !master->HasAura(INNERVATE))
+                iTarget = master;
+            else if (me->IsInCombat() && me->getPowerType() == POWER_MANA &&
+                GetManaPCT(me) < 20 && !me->HasAura(INNERVATE))
+                iTarget = me;
+
+            if (!IAmFree())
+            {
+                Group* group = master->GetGroup();
+                if (!iTarget && !group) //first check master's bots
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        Creature* bot = itr->second;
+                        if (!bot || !bot->IsInCombat() || bot->isDead()) continue;
+                        if (me->GetExactDist(bot) > 30) continue;
+                        if (bot->getPowerType() != POWER_MANA) continue;
+                        if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                        {
+                            iTarget = bot;
+                            break;
+                        }
+                    }
+                }
+                if (!iTarget && group) //cycle through player members...
+                {
+                    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == NULL || !tPlayer->IsInWorld() || !tPlayer->IsInCombat() || tPlayer->isDead()) continue;
+                        if (me->GetExactDist(tPlayer) > 30) continue;
+                        if (tPlayer->getPowerType() != POWER_MANA) continue;
+                        if (GetManaPCT(tPlayer) < minmanaval && !tPlayer->HasAura(INNERVATE))
+                        {
+                            iTarget = tPlayer;
+                            break;
+                        }
+                        if (iTarget)
+                            break;
+                    }
+                }
+                if (!iTarget && group) //... and their bots.
+                {
+                    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (!bot || bot->isDead()) continue;
+                            if (me->GetExactDist(bot) > 30) continue;
+                            if (bot->getPowerType() != POWER_MANA) continue;
+                            if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                            {
+                                iTarget = bot;
+                                break;
+                            }
+                        }
+                        if (iTarget)
+                            break;
+                    }
+                }
+            }
+
+            if (iTarget && doCast(iTarget, INNERVATE))
+            {
+                if (iTarget->GetTypeId() == TYPEID_PLAYER)
+                    BotWhisper("Innervate on You!", iTarget->ToPlayer());
+                else if (!IAmFree())
+                {
+                    std::ostringstream msg;
+                    msg << "Innervate on " << (iTarget == me ? "myself" : iTarget->GetName()) << '!';
+                    BotWhisper(msg.str().c_str(), master);
+                }
+
+                return;
+            }
+
+            SetSpellCooldown(INNERVATE_1, 3000); //fail
+        }
+
+        void CheckRoots(uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 35) return;
+            if (me->GetShapeshiftForm() != FORM_NONE) return;
+            uint32 ENTANGLING_ROOTS = GetSpell(ENTANGLING_ROOTS_1);
+            if (!ENTANGLING_ROOTS) return;
+            if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60)) return;
+            if (Unit* target = FindRootTarget(30, ENTANGLING_ROOTS))
+                if (doCast(target, ENTANGLING_ROOTS))
+                    return;
+        }
+
+        void CheckBattleRez(uint32 diff)
+        {
+            if (!IsSpellReady(REBIRTH_1, diff, false) || IAmFree() || me->IsMounted() || IsCasting() || Rand() > 10) return;
+
+            Group* gr = master->GetGroup();
+            if (!gr)
+            {
+                Unit* target = master;
+                if (master->IsAlive()) return;
+                if (master->isResurrectRequested()) return; //ressurected
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)master->GetCorpse();
+                if (!target || !target->IsInWorld())
+                    return;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                    BotWhisper("Rezzing You", master);
+
+                return;
+            }
+            for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                Unit* target = tPlayer;
+                if (!tPlayer || tPlayer->IsAlive()) continue;
+                if (tPlayer->isResurrectRequested()) continue; //ressurected
+                if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)tPlayer->GetCorpse();
+                if (!target || !target->IsInWorld()) continue;
+                if (master->GetMap() != target->FindMap()) continue;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(target->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    BotWhisper("Rezzing You", tPlayer);
+                    return;
+                }
+            }
+        }
+
+        void setStats(uint8 form)
+        {
+            switch (form)
+            {
+                case DRUID_BEAR_FORM:
+                    Form = DRUID_BEAR_FORM;
+                    break;
+                case DRUID_CAT_FORM:
+                    Form = DRUID_CAT_FORM;
+                    RefreshAura(ENERGIZE, me->getLevel()/40);
+                    break;
+                case BOT_CLASS_DRUID:
+                    Form = BOT_STANCE_NONE;
+                    SetShouldUpdateStats();
+                    me->setPowerType(POWER_MANA);
+                    me->RemoveMovementImpairingAuras();
+                    break;
+                default:
+                    return;
+            }
+
+            SetStats(false);
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+        {
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+
+            if (damageinfo.hitOutCome == MELEE_HIT_CRIT)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Primal Fury (white attacks): 100% to gain 5 rage at crit in (Dire) Bear Form
+                if (lvl >= 25 && GetBotStance() == DRUID_BEAR_FORM)
+                    me->CastSpell(me, PRIMAL_FURY_EFFECT_ENERGIZE, true);
+                //Predatory Instincts (part 1): 10% additional crit damage bonus for melee attacks in Cat form
+                if (lvl >= 45 && GetBotStance() == DRUID_CAT_FORM)
+                    pctbonus += 0.05f;
+            }
+
+            //Naturalist: 10% bonus damage for all melee attacks
+            if (lvl >= 15)
+                pctbonus += 0.1f;
+
+            damage = damage * (1.0f + pctbonus);
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Rend and Tear (part 2): 25% additional critical chance on bleeding targets for Ferocious Bite
+                if (lvl >= 55 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_BLEEDING) && spellId == GetSpell(FEROCIOUS_BITE_1))
+                    aftercrit += 25.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                ////Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                //if (lvl >= 21)
+                //    pctbonus += 0.25f;
+            }
+
+            //Feral Instinct: 30% bonus damage for Swipe (Bear)
+            if (lvl >= 15 && spellId == GetSpell(SWIPE_1))
+                pctbonus += 0.3f;
+            //Savage Fury: 20% bonus damage for Claw, Rake, Mangle (Cat), Mangle (Bear) and Maul
+            if (lvl >= 15 &&
+                (spellId == GetSpell(CLAW_1) ||
+                spellId == GetSpell(RAKE_1) ||
+                spellId == GetSpell(MANGLE_CAT_1) ||
+                spellId == GetSpell(MANGLE_BEAR_1) ||
+                spellId == GetSpell(MAUL_1)))
+                pctbonus += 0.2f;
+            //Rend and Tear: 20% bonus damage on bleeding targets for Maul and Shred
+            if (lvl >= 55 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_BLEEDING) &&
+                (spellId == GetSpell(MAUL_1) || spellId == GetSpell(SHRED_1)))
+                pctbonus += 0.2f;
+            //Naturalist: 10% bonus damage for all melee attacks
+            if (lvl >= 15)
+                pctbonus += 0.1f;
+
+            //Primal Fury (yellow attacks): 100% to gain 5 rage at crit in (Dire) Bear Form
+            if (lvl >= 25 && crit && GetBotStance() == DRUID_BEAR_FORM)
+                me->CastSpell(me, PRIMAL_FURY_EFFECT_ENERGIZE, true);
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Improved Moonfire
+                if (lvl >= 15 && spellId == GetSpell(MOONFIRE_1))
+                    aftercrit += 10.f;
+                //Nature's Majesty: 4% additional critical chance for Wrath, Starfire and Starfall
+                if (lvl >= 15 &&
+                    (spellId == GetSpell(WRATH_1) ||
+                    spellId == GetSpell(STARFIRE_1)/* ||
+                    spellId == GetSpell(STARFALL_1)*/))
+                    aftercrit += 4.f;
+                //Eclipse (Lunar): 40% additional critical chance for Starfire
+                if (lvl >= 50 && spellId == GetSpell(STARFIRE_1) && me->HasAura(ECLIPSE_LUNAR_BUFF))
+                    aftercrit += 40.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Vengeance: 100% additional crit damage bonus for Starfire, Starfall, Moonfire and Wrath
+                if (lvl >= 25 &&
+                    (spellId == GetSpell(STARFIRE_1) ||
+                    //spellId == GetSpell(STARFALL_1) ||
+                    spellId == GetSpell(MOONFIRE_1) ||
+                    spellId == GetSpell(WRATH_1)))
+                    pctbonus += 0.333f;
+            }
+            //Brambles: 75% bonus damage for Throns and Entangling Roots
+            if (lvl >= 20 &&
+                (spellId == GetSpell(THORNS_1) ||
+                spellId == GetSpell(ENTANGLING_ROOTS_1)))
+                pctbonus += 0.75f;
+            //Moonfury: 10% bonus damage for Starfire, Moonfire and Wrath
+            if (lvl >= 35 &&
+                (spellId == GetSpell(STARFIRE_1) ||
+                spellId == GetSpell(MOONFIRE_1) ||
+                spellId == GetSpell(WRATH_1)))
+                pctbonus += 0.1f;
+            //Wrath of Cenarius: 20%/10% Increased spellpower bonus for Starfire/Wrath
+            if (lvl >= 45)
+            {
+                if (spellId == GetSpell(STARFIRE_1))
+                    fdamage += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * 1.88f * me->CalculateLevelPenalty(spellInfo);
+                if (spellId == GetSpell(WRATH_1))
+                    fdamage += spellpower * 0.1f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * 1.88f * me->CalculateLevelPenalty(spellInfo);
+            }
+            //Eclipse (Solar): 40% bonus damage for Wrath
+            if (lvl >= 50 && spellId == GetSpell(WRATH_1) && me->HasAura(ECLIPSE_SOLAR_BUFF))
+                pctbonus += 0.4f;
+            //Gale Winds: 30% bonus damage for Hurricane (no Typhon support yet)
+            if (lvl >= 50 && spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(HURRICANE_DAMAGE_1)))
+                pctbonus += 0.3f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Improved Rejuvenation: 15% bonus healing for Rejuvenation
+            if (lvl >= 25 && spellId == GetSpell(REJUVENATION_1))
+                pctbonus += 0.15f;
+            //Gift of Nature: 10% bonus healing for all spells
+            if (lvl >= 30)
+                pctbonus += 0.1f;
+            //Empowered Touch: 40% bonus (from spellpower) for Healing Touch and 20% bonus (from spellpower) for Nourish
+            if (lvl >= 35)
+            {
+                if (spellId == GetSpell(HEALING_TOUCH_1))
+                    flat_mod += spellpower * 0.4f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+                else if (spellId == GetSpell(NOURISH_1))
+                    flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            }
+            //Empowered Rejuvenation: 20% bonus healing for healing over time effects (20% increase in our case)
+            if (lvl >= 45 &&
+                (spellId == GetSpell(TRANQUILITY_1) ||
+                spellId == GetSpell(REJUVENATION_1) ||
+                spellId == GetSpell(REGROWTH_1) ||
+                spellId == GetSpell(LIFEBLOOM_1) ||
+                spellId == GetSpell(WILD_GROWTH_1) ||
+                spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(TRANQUILITY_HEAL_1))))
+                pctbonus += 0.2f;
+            //Empowered Touch: 15% bonus (from spirit) for healing spells (taking in consideration increased spirit (Living Spirit: 15%))
+            if (lvl >= 50)
+                flat_mod += me->GetTotalStatValue(STAT_SPIRIT) * 0.15f * 1.15f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassCritMultiplierHeal(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float aftercrit = 0.0f;
+
+            //Nature's bounty: 25% additional critical chance for Regrowth
+            if (lvl >= 35 && spellId == GetSpell(REGROWTH_1))
+                aftercrit += 25.f;
+
+            crit_chance += aftercrit;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Nature's Splendor: Increased duraion for
+            //Moonfire (3 sec), Rejuvenation (3 sec, let 6), Regrowth (6 sec, let 9),
+            //Insect Swarm (2 sec) and Lifebloom (2 sec, let 4)
+            if (spellId == GetSpell(MOONFIRE_1) || spellId == GetSpell(REJUVENATION_1) ||
+                spellId == GetSpell(REGROWTH_1)/* || spellId == GetSpell(INSECT_SWARM_1)*/ ||
+                spellId == GetSpell(LIFEBLOOM_1))
+            {
+                if (me->getLevel() >= 20)
+                {
+                    if (Aura* aur = target->GetAura(spellId))
+                    {
+                        uint32 dur = aur->GetDuration();
+
+                        switch (sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id)
+                        {
+                            case MOONFIRE_1:
+                                dur += 3000;
+                                break;
+                            case REJUVENATION_1:
+                                dur += 6000;
+                                break;
+                            case REGROWTH_1:
+                                dur += 9000;
+                                break;
+                            //case INSECT_SWARM_1:
+                            //    dur += 3000;
+                            //    break;
+                            case LIFEBLOOM_1:
+                                dur += 4000;
+                                break;
+                            default:
+                                break;
+                        }
+
+                        aur->SetDuration(dur);
+                        aur->SetMaxDuration(dur);
+                    }
+                }
+            }
+
+            if (spellId == GetSpell(THORNS_1))
+            {
+                //30 min duration for Thorns
+                if (Aura* thorn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 30 * MINUTE * IN_MILLISECONDS;
+                    thorn->SetDuration(dur);
+                    thorn->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(MARK_OF_THE_WILD_1))
+            {
+                //1 hour duration for Mark of the Wild
+                if (Aura* mark = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 1 * HOUR * IN_MILLISECONDS;
+                    mark->SetDuration(dur);
+                    mark->SetMaxDuration(dur);
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            //Eclipse (helper): cooldown
+            if (spellId == ECLIPSE_SOLAR_BUFF || spellId == ECLIPSE_LUNAR_BUFF)
+                SetSpellCooldown(spellId, 30000);
+            //Forms helper
+            if (spellId == GetSpell(CAT_FORM_1) || spellId == GetSpell(BEAR_FORM_1))
+            {
+                if (spellId == GetSpell(BEAR_FORM_1))
+                    setStats(DRUID_BEAR_FORM);
+                if (spellId == GetSpell(CAT_FORM_1))
+                    setStats(DRUID_CAT_FORM);
+
+                me->CastSpell(me, LEADER_OF_THE_PACK_BUFF, true);
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            formtimer = 0;
+            Form = BOT_STANCE_NONE;
+
+            clearcast = false;
+            swiftness = false;
+
+            power = POWER_MANA;
+
+            rage = 0;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+
+            ragetimer = 0;
+            ragetimer2 = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (formtimer > diff)                   formtimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+
+            InitSpellMap(WARSTOMP_1, true);
+
+            InitSpellMap(MARK_OF_THE_WILD_1);
+            InitSpellMap(THORNS_1);
+            InitSpellMap(HEALING_TOUCH_1);
+            InitSpellMap(REGROWTH_1);
+            InitSpellMap(REJUVENATION_1);
+            InitSpellMap(LIFEBLOOM_1);
+            InitSpellMap(NOURISH_1);
+     /*tal*/lvl >= 60 ? InitSpellMap(WILD_GROWTH_1) : RemoveSpell(WILD_GROWTH_1);
+     /*tal*/lvl >= 40 ? InitSpellMap(SWIFTMEND_1) : RemoveSpell(SWIFTMEND_1);
+            InitSpellMap(TRANQUILITY_1);
+            InitSpellMap(REVIVE_1);
+            InitSpellMap(REBIRTH_1);
+            InitSpellMap(BEAR_FORM_1);
+            InitSpellMap(SWIPE_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_BEAR_1) : RemoveSpell(MANGLE_BEAR_1);
+            InitSpellMap(BASH_1);
+            InitSpellMap(CAT_FORM_1);
+            InitSpellMap(CLAW_1);
+            InitSpellMap(RAKE_1);
+            InitSpellMap(SHRED_1);
+            InitSpellMap(RIP_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_CAT_1) : RemoveSpell(MANGLE_CAT_1);
+            InitSpellMap(MOONFIRE_1);
+            InitSpellMap(STARFIRE_1);
+            InitSpellMap(WRATH_1);
+            InitSpellMap(HURRICANE_1);
+            InitSpellMap(FAERIE_FIRE_1);
+            InitSpellMap(CURE_POISON_1);
+            InitSpellMap(INNERVATE_1);
+            InitSpellMap(ENTANGLING_ROOTS_1);
+     /*tal*/lvl >= 30 ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
+
+ /*SPECIAL*/InitSpellMap(ECLIPSE_SOLAR_BUFF, true);
+ /*SPECIAL*/InitSpellMap(ECLIPSE_LUNAR_BUFF, true);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            //RefreshAura(SPELLDMG2, level >= 78 ? 3 : level >= 65 ? 2 : level >= 50 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION3, level >= 45 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION2, level >= 43 && level < 45 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION1, level >= 41 && level < 43 ? 1 : 0);
+            RefreshAura(LIVING_SEED3, level >= 50 ? 1 : 0);
+            RefreshAura(LIVING_SEED2, level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(LIVING_SEED1, level >= 46 && level < 48 ? 1 : 0);
+            RefreshAura(REVITALIZE3, level >= 55 ? 3 : 0);
+            RefreshAura(REVITALIZE2, level >= 53 && level < 55 ? 2 : 0);
+            RefreshAura(REVITALIZE1, level >= 51 && level < 53 ? 2 : 0);
+            RefreshAura(GIFT_OF_THE_EARTHMOTHER, level >= 55 ? 1 : 0);
+            RefreshAura(OMEN_OF_CLARITY, level >= 70 ? 3 : level >= 40 ? 2 : level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_SWIFTMEND, level >= 45 ? 1 : 0);
+            RefreshAura(GLYPH_INNERVATE, level >= 40 ? 1 : 0);
+            RefreshAura(NATURESGRACE, level >= 20 ? 1 : 0);
+            RefreshAura(ECLIPSE, level >= 50 ? 1 : 0);
+            RefreshAura(EARTH_AND_MOON, level >= 55 ? 1 : 0);
+            RefreshAura(SURVIVAL_OF_THE_FITTEST, level >= 55 ? 1 : 0);
+            RefreshAura(HEART_OF_THE_WILD, level >= 35 ? 1 : 0);
+            RefreshAura(NATURAL_REACTION, level >= 35 ? 1 : 0);
+            RefreshAura(INFECTED_WOUNDS, level >= 45 ? 1 : 0);
+            RefreshAura(FUROR, level >= 10 ? 1 : 0);
+            RefreshAura(T9_RESTO_P4_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T8_RESTO_P4_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T9_BALANCE_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_BALANCE_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_BALANCE_P4_BONUS, level >= 78 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case MARK_OF_THE_WILD_1:
+                case THORNS_1:
+                case HEALING_TOUCH_1:
+                case REJUVENATION_1:
+                case LIFEBLOOM_1:
+                case REGROWTH_1:
+                case NOURISH_1:
+                case WILD_GROWTH_1:
+                case SWIFTMEND_1:
+                case TRANQUILITY_1:
+                case CURE_POISON_1:
+                case INNERVATE_1:
+                case BEAR_FORM_1:
+                case CAT_FORM_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Timers/other
+/*Heal*/uint32 Heal_Timer;
+/*Misc*/uint32 formtimer, ragetimer, ragetimer2;
+/*Form*/uint8 Form;
+/*Chck*/bool clearcast, swiftness;
+/*Misc*/Powers power; uint32 rage;
+/*Misc*/float rageIncomeMult, rageLossMult;
+
+        enum DruidBaseSpells
+        {
+            MARK_OF_THE_WILD_1                  = 1126,
+            THORNS_1                            = 467,
+            HEALING_TOUCH_1                     = 5185,
+            REGROWTH_1                          = 8936,
+            REJUVENATION_1                      = 774,
+            LIFEBLOOM_1                         = 33763,
+            NOURISH_1                           = 50464,
+     /*tal*/WILD_GROWTH_1                       = 48438,
+     /*tal*/SWIFTMEND_1                         = 18562,
+            TRANQUILITY_1                       = 740,
+            REVIVE_1                            = 50769,
+            REBIRTH_1                           = 20484,
+            BEAR_FORM_1                         = 5487,
+            SWIPE_1                             = 779,
+     /*tal*/MANGLE_BEAR_1                       = 33878,
+            BASH_1                              = 5211, //NYI
+            MAUL_1                              = 6807, //NYI
+            CAT_FORM_1                          = 768,
+            CLAW_1                              = 1082,
+            RAKE_1                              = 1822,
+            SHRED_1                             = 5221,
+            RIP_1                               = 1079,
+     /*tal*/MANGLE_CAT_1                        = 33876,
+            FEROCIOUS_BITE_1                    = 22568, //NYI
+            MOONFIRE_1                          = 8921,
+            STARFIRE_1                          = 2912,
+            WRATH_1                             = 5176,
+            HURRICANE_1                         = 16914,
+            FAERIE_FIRE_1                       = 770,
+            CURE_POISON_1                       = 8946,
+            INNERVATE_1                         = 29166,
+            ENTANGLING_ROOTS_1                  = 339,
+     /*tal*/NATURES_SWIFTNESS_1                 = 17116,
+            WARSTOMP_1                          = 20549
+        };
+        enum DruidPassives
+        {
+        //Talents
+            OMEN_OF_CLARITY                     = 16864,//clearcast
+            NATURESGRACE                        = 61346,//haste 20% for 3 sec
+            NATURAL_PERFECTION1                 = 33881,
+            NATURAL_PERFECTION2                 = 33882,
+            NATURAL_PERFECTION3                 = 33883,
+            LIVING_SEED1                        = 48496,//rank 1
+            LIVING_SEED2                        = 48499,//rank 2
+            LIVING_SEED3                        = 48500,//rank 3
+            REVITALIZE1                         = 48539,//rank 1
+            REVITALIZE2                         = 48544,//rank 2
+            REVITALIZE3                         = 48545,//rank 3
+            GIFT_OF_THE_EARTHMOTHER             = 51183,//rank 5
+            ECLIPSE                             = 48525,//rank 3
+            EARTH_AND_MOON                      = 48511,//rank 3
+            SURVIVAL_OF_THE_FITTEST             = 33856,//rank 3
+            HEART_OF_THE_WILD                   = 24894,//rank 5
+            FUROR                               = 17061,//rank 5
+            NATURAL_REACTION                    = 57881,//rank 3
+            INFECTED_WOUNDS                     = 48485,//rank 3
+        //Glyphs
+            GLYPH_SWIFTMEND                     = 54824,//no consumption
+            GLYPH_INNERVATE                     = 54832,//self regen
+        //other
+            T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
+            T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal
+            T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
+            T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
+            T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
+            //SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            //SPELLDMG2/*Earth and Moon - druid*/ = 48511,//rank3 6% dam
+            ENERGIZE                            = 27787,//Rogue Armor Energize (chance: +35 energy on hit)
+            CRIT_50                             = 23434 //50% spell crit
+        };
+        enum DruidSpecial
+        {
+            HURRICANE_DAMAGE_1                  = 42231,
+            TRANQUILITY_HEAL_1                  = 44203,
+  /*Talent*/LEADER_OF_THE_PACK_BUFF             = 24932,
+            //NATURESGRACEBUFF                    = 16886,
+            ECLIPSE_SOLAR_BUFF                  = 48517,// from Starfire to Wrath
+            ECLIPSE_LUNAR_BUFF                  = 48518,// from Wrath to Starfire
+            OMEN_OF_CLARITY_BUFF                = 16870,//434 deprecated
+
+            PRIMAL_FURY_EFFECT_ENERGIZE         = 16959 //5 rage
+        };
+    };
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..8b54d71
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
@@ -0,0 +1,1086 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+/*
+Hunter NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - around 35%
+TODO:
+*/
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new hunter_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct hunter_botAI : public bot_minion_ai
+    {
+        hunter_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_HUNTER;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_HUNTER) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = NULL;
+
+            if (IsSpellReady(SCATTER_SHOT_1, diff, false, 10000) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                target = FindCastingTarget(15, 0, false, GetSpell(SCATTER_SHOT_1));
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(SCATTER_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            if (!target && IsSpellReady(WYVERN_STING_1, diff, true, 10000) && HasRole(BOT_ROLE_DPS) && Rand() < 70)
+            {
+                target = FindCastingTarget(35, 5, false, GetSpell(WYVERN_STING_1));
+                if (target && doCast(target, GetSpell(WYVERN_STING_1)))
+                    return;
+            }
+            //if (!target && FREEZING_ARROW && Trap_cd <= 10000 && Rand() < 40)
+            //{
+            //    target = FindCastingTarget(40, 0, false, FREEZING_ARROW);
+            //    temptimer = GC_Timer;
+            //    if (target && doCast(target, FREEZING_ARROW))
+            //    {
+            //        Trap_cd = 20000;
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+            //}
+            if (!target && IsSpellReady(SCARE_BEAST_1, diff, true, 7500) && Rand() < 35)
+            {
+                target = FindCastingTarget(30, 0, false, GetSpell(SCARE_BEAST_1));
+                if (target && doCast(target, GetSpell(SCARE_BEAST_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if (!target && IsSpellReady(SILENCING_SHOT_1, diff, false, 7500) && Rand() < 30)
+            {
+                target = FindCastingTarget(35, 5, false, GetSpell(SILENCING_SHOT_1));
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void CheckScatter(uint32 diff)
+        {
+            if (!IsSpellReady(SCATTER_SHOT_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(15))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SCATTER_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SCATTER_SHOT_1, 1000); //fail
+        }
+
+        void CheckWyvernSting(uint32 diff)
+        {
+            if (!IsSpellReady(WYVERN_STING_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(35))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(WYVERN_STING_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(WYVERN_STING_1, 1000); //fail
+        }
+
+        void CheckFreezingArrow(uint32 diff)
+        {
+            //Freezing Trap shares cooldown with traps
+            if (!GetSpell(FREEZING_ARROW_1) || Trap_cd > diff || IsCasting() || Rand() > 75)
+                return;
+
+            if (Unit* target = FindStunTarget(40))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(FREEZING_ARROW_1)))
+                {
+                    GC_Timer = temptimer;
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+
+            Trap_cd = 1000; //fail
+        }
+
+        void CheckTraps(uint32 diff)
+        {
+            if (!GetSpell(FROST_TRAP_1) || Trap_cd > diff || IsCasting() || Rand() > 90)
+                return;
+
+            Unit* target = me->GetVictim();
+            if (!(target && me->GetDistance(target) < 6 && me->HasInArc(M_PI, target) &&
+                IsInBotParty(target->GetVictim())))
+                target = NULL;
+            if (!target)
+                target = FindAOETarget(3.f, true);
+
+            if (target)
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(FROST_TRAP_1)))
+                {
+                    GC_Timer = temptimer;
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+
+            Trap_cd = 500; //fail
+        }
+
+        void CheckScare(uint32 diff)
+        {
+            if (!IsSpellReady(SCARE_BEAST_1, diff) || IsCasting() || Rand() > 35)
+                return;
+
+            if (Unit* scareTarget = FindFearTarget())
+            {
+                if (doCast(scareTarget, GetSpell(SCARE_BEAST_1), true))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SCARE_BEAST_1, 1500); //fail
+        }
+
+        void CheckAspects(uint32 diff)
+        {
+            if (Aspect_Timer > diff || GC_Timer > diff || IsCasting() || Feasting() || Rand() > 35)
+                return;
+
+            uint32 ASPECT_OF_THE_VIPER = GetSpell(ASPECT_OF_THE_VIPER_1);
+            uint32 ASPECT_OF_THE_PACK = GetSpell(ASPECT_OF_THE_PACK_1);
+            if (!ASPECT_OF_THE_VIPER && !ASPECT_OF_THE_PACK)
+                return;
+
+            uint32 needaspect = 0;
+            uint8 pct = GetManaPCT(me);
+
+            if (ASPECT_OF_THE_VIPER && pct < 25)
+                needaspect = ASPECT_OF_THE_VIPER;
+            else if (ASPECT_OF_THE_PACK && (pct > 70 || !Aspect))
+                needaspect = ASPECT_OF_THE_PACK;
+
+            if (!needaspect || (needaspect == Aspect && HasAuraName(me, needaspect)))
+            {
+                Aspect_Timer = 2000;
+                return;
+            }
+
+            if (Aspect)
+                me->RemoveAurasDueToSpell(Aspect);
+
+            if (doCast(me, needaspect))
+            {
+                Aspect = needaspect;
+                GC_Timer = 800;
+                return;
+            }
+        }
+
+        void doDefend(uint32 diff)
+        {
+            //No GCD abilities
+            if (!IsSpellReady(FEIGN_DEATH_1, diff, false) && !IsSpellReady(DETERRENCE_1, diff, false))
+                return;
+            if (IsTank() || Rand() > 35)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+            bool cast = false;
+
+            if (b_attackers.size() == 1)
+            {
+                if (Creature* cre = (*b_attackers.begin())->ToCreature())
+                {
+                    if (cre->isWorldBoss() || cre->IsDungeonBoss() || cre->GetMaxHealth() > me->GetMaxHealth() * 10)
+                    {
+                        cast = true;
+                        //need feign death
+                        SetSpellCooldown(DETERRENCE_1, std::max<uint32>(GetSpellCooldown(DETERRENCE_1), diff + 500));
+                    }
+                }
+            }
+            else
+                cast = (uint8(b_attackers.size()) > (GetHealthPCT(me) > 20 ? 1 : 0));
+
+            if (!cast || b_attackers.empty())
+            {
+                //delay next try
+                SetSpellCooldown(FEIGN_DEATH_1, std::max<uint32>(GetSpellCooldown(FEIGN_DEATH_1), 1000));
+                SetSpellCooldown(DETERRENCE_1, std::max<uint32>(GetSpellCooldown(DETERRENCE_1), 1000));
+                return;
+            }
+
+            if (IsSpellReady(FEIGN_DEATH_1, diff, false) && (*b_attackers.begin())->getAttackers().size() > 1)
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(FEIGN_DEATH_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(DETERRENCE_1, diff, false))
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(DETERRENCE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void CheckAutoShot()
+        {
+            //Auto Shot is always present
+            //if (!AUTO_SHOT)
+            //    return;
+
+            Unit* target = me->GetVictim();
+            if (!target)
+                return;
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsCasting())
+                return;
+
+            if (Spell* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id != AUTO_SHOT_1)
+                {
+                    ////casting some other autorepeat spell, wtf?
+                    //TC_LOG_ERROR("entities.player", "CheckAutoShot(): Bot %s is casting autorepeatable spell %u (%s) during check!",
+                    //    me->GetName().c_str(), shot->GetSpellInfo()->Id, shot->GetSpellInfo()->SpellName[0]);
+                    return;
+                }
+                else if (shot->m_targets.GetUnitTarget() != target)
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+
+            float dist = me->GetExactDist(target);
+            if (dist < 5 || dist > 35)
+                return;
+
+            temptimer = GC_Timer;
+            if (doCast(target, AUTO_SHOT_1))
+            {
+                GC_Timer = temptimer;
+                return;
+            }
+        }
+
+        void CheckTranquil(uint32 diff)
+        {
+            if (!IsSpellReady(TRANQ_SHOT_1, diff, false) || Rand() > 35) //No GCD
+                return;
+
+            //First check current target
+            Unit* target = me->GetVictim();
+            if (target)
+            {
+                Unit::AuraMap const &auras = target->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                {
+                    SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+                    if (spellInfo->Dispel != DISPEL_MAGIC && spellInfo->Dispel != DISPEL_ENRAGE) continue;
+                    if (spellInfo->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(target->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        temptimer = GC_Timer;
+                        //me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                        if (doCast(target, GetSpell(TRANQ_SHOT_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+
+            target = FindTranquilTarget();
+            if (target)
+            {
+                temptimer = GC_Timer;
+                //me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                if (doCast(target, GetSpell(TRANQ_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(TRANQ_SHOT_1, 2000); //fail
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (!IsSpellReady(SILENCING_SHOT_1, diff, false) || IsCasting() || Rand() > 50) //No GCD
+                return;
+
+            Unit* target = me->GetVictim();
+            if (target && target->IsNonMeleeSpellCast(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    //return;
+                }
+
+                return; //succeed or failed, our hightest priority target casts spell and it must be interrupted above all else
+            }
+
+            target = FindCastingTarget(35, 5);
+            if (target)
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SILENCING_SHOT_1, 1000); //fail
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (Potion_cd <= diff && GetManaPCT(me) < 40)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            //Deterrence check
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
+            {
+                if (!me->isMoving())
+                    GetInPosition(true);
+                return;
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                doDefend(diff);
+
+            CheckAspects(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckTranquil(diff);
+                CheckSilence(diff);
+            }
+
+            if (!CheckAttackTarget(BOT_CLASS_HUNTER))
+            {
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                return;
+            }
+
+            DoRangedAttack(diff);
+        }
+
+        void DoRangedAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+
+            CheckAutoShot();
+            CheckScare(diff);
+            CheckScatter(diff);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            //float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //special
+            if (IsSpellReady(SCATTER_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS) && meleedist < 15 && Rand() < 60)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(SCATTER_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                    me->AttackStop();
+                    return;
+                }
+            }
+
+            //MELEE SECTION
+            if (!(meleedist > 5))
+            {
+                //TRAPS
+                CheckTraps(diff);
+
+                //RAPTOR STRIKE
+                if (IsSpellReady(RAPTOR_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(opponent, GetSpell(RAPTOR_STRIKE_1), true))
+                    {
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+                //WING CLIP
+                if (IsSpellReady(WING_CLIP_1, diff) && (!IsTank() || opponent->isMoving()) &&
+                    Rand() < 80 && !opponent->HasAuraWithMechanic(/*(1<<MECHANIC_SNARE)|*/(1<<MECHANIC_ROOT)))
+                {
+                    if (doCast(opponent, GetSpell(WING_CLIP_1)))
+                    {
+                        GC_Timer = 1000;
+                        return;
+                    }
+                }
+                //DISENGAGE
+                if (IsSpellReady(DISENGAGE_1, diff, false) && me->IsInCombat() && !IsTank() &&
+                    !me->getAttackers().empty() && me->HasInArc(M_PI, *me->getAttackers().begin()) && Rand() < 30)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(DISENGAGE_1)))
+                        GC_Timer = temptimer;
+                }
+
+                return; //don't try to do anything else in melee
+            }
+
+            //RANGED SECTION
+
+            //HUNTERS MARK
+            if (IsSpellReady(HUNTERS_MARK_1, diff, false) && Rand() < 25 &&
+                !HasAuraName(opponent, HUNTERS_MARK_1)) //100 yd range so don't check it
+            {
+                //Hunter's Mark has exclusive GCD
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(HUNTERS_MARK_1)))
+                {
+                    markTarget = opponent;
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+
+            //FREEZING ARROW
+            CheckFreezingArrow(diff);
+            CheckWyvernSting(diff);
+
+            //attack range check 1
+            if (!(meleedist < 45))
+                return;
+
+            //KILL SHOT //No GCD
+            if (IsSpellReady(KILL_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS) && GetHealthPCT(opponent) < 20 && Rand() < 95)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(KILL_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            //attack range check 2
+            if (!(meleedist < 35))
+                return;
+
+            //CONCUSSIVE SHOT
+            if (IsSpellReady(CONCUSSIVE_SHOT_1, diff) && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(CONCUSSIVE_SHOT_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            //DISTRACTING SHOT
+            if (Unit* u = opponent->GetVictim())
+            {
+                if (IsSpellReady(DISTRACTING_SHOT_1, diff, false) && IsTank() && u != me && !CCed(opponent) &&
+                    Rand() < 75 && IsInBotParty(u))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(opponent, GetSpell(DISTRACTING_SHOT_1)))
+                        GC_Timer = temptimer;
+                }
+            }
+            //BLACK ARROW //custom cd condition
+            //Black Arrow shares cooldown with traps, but we'll have it only partially
+            if (IsSpellReady(BLACK_ARROW_1, diff) && Trap_cd <= 10000 && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetMaxHealth()/3 && Rand() < 75)
+            {
+                if (doCast(opponent, GetSpell(BLACK_ARROW_1)))
+                {
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+            //RAPID FIRE
+            if (IsSpellReady(RAPID_FIRE_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetMaxHealth() / 2 && Rand() < 25)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(RAPID_FIRE_1)))
+                    GC_Timer = temptimer;
+            }
+            //EXPLOSIVE SHOT
+            if (IsSpellReady(EXPLOSIVE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(opponent, GetSpell(EXPLOSIVE_SHOT_1)))
+                    return;
+
+                SetSpellCooldown(EXPLOSIVE_SHOT_1, 500); //fail
+            }
+            //SCORPID STING //custom cd condition
+            if (uint32 SCORPID_STING = GetSpell(SCORPID_STING_1))
+            {
+                if (GC_Timer <= diff && (ScorpidSting_Timer <= diff || stingTargetGuid != opponent->GetGUID()))
+                {
+                    Aura* sSting = opponent->GetAura(SCORPID_STING);
+                    if (sSting && sSting->GetDuration() > 3000)
+                    {
+                        stingTargetGuid = opponent->GetGUID();
+                        SetSpellCooldown(SCORPID_STING_1, 2000);
+                    }
+                    else if (Rand() < 40 && doCast(opponent, SCORPID_STING))
+                    {
+                        stingTargetGuid = opponent->GetGUID();
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+            }
+            //CHIMERA SHOT TODO:
+            if (IsSpellReady(CHIMERA_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && stingTargetGuid == opponent->GetGUID() &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) && Rand() < 30)
+            {
+                if (doCast(opponent, GetSpell(CHIMERA_SHOT_1)))
+                    return;
+            }
+            //MULTI-SHOT
+            if (IsSpellReady(MULTISHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 60)
+            {
+                if (Unit* target = FindSplashTarget(35, opponent))
+                {
+                    if (doCast(target, GetSpell(MULTISHOT_1)))
+                    {
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(MULTISHOT_1, 1000); //fail
+            }
+            //VOLLEY
+            if (IsSpellReady(VOLLEY_1, diff) && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 25)
+            {
+                if (Unit* target = FindAOETarget(35, true, false))
+                {
+                    if (doCast(target, GetSpell(VOLLEY_1)))
+                        return;
+                }
+
+                SetSpellCooldown(VOLLEY_1, 1000); //fail
+            }
+            //AIMED SHOT
+            if (IsSpellReady(AIMED_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(AIMED_SHOT_1)))
+                    return;
+            }
+            //ARCANE SHOT
+            if (IsSpellReady(ARCANE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(ARCANE_SHOT_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+
+                //Glyph of TrueShot Aura (req lvl 40): 10% additional critical chance for Aimed Shot
+                if (lvl >= 40 && spellId == GetSpell(AIMED_SHOT_1))
+                    aftercrit += 10.f;
+                //Improved Barrage: 12% additional critical chance for Multi-Shot and Aimed Shot
+                if (lvl >= 40 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(MULTISHOT_1)))
+                    aftercrit += 12.f;
+                //Survival Instincts: 4% additional critical chance for Arcane Shot, Steady Shot and Explosive Shot
+                if (lvl >= 15 && (spellId == GetSpell(ARCANE_SHOT_1)/* || spellId == GetSpell(STEADY_SHOT_1)*/ || spellId == GetSpell(EXPLOSIVE_SHOT_1)))
+                    aftercrit += 4.f;
+                //Sniper Training (part 1): 15% additional critical chance for Kill Shot
+                if (lvl >= 50 && spellId == GetSpell(KILL_SHOT_1))
+                    aftercrit += 15.f;
+                //Point of No Escape: 6% additional critical chance on victims of any kind of frost trap (crew this condition)
+                if (lvl >= 50)
+                    aftercrit += 6.f;
+
+                //Savage Strikes: 20% additional critical chance for Raptor Strike, Mongoose Bite and Counterattack
+                if (lvl >= 10 && (spellId == GetSpell(RAPTOR_STRIKE_1)/* || spellId == GetSpell(MONGOOSE_BITE_1) || spellId == GetSpell(COUNTERATTACK_1)*/))
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Mortal Shots: 30% crit damage bonus for all ranged abilities
+                if (lvl >= 15 && attackType == RANGED_ATTACK)
+                    pctbonus += 0.15f;
+                //Marked for Death (part 2): 10% crit damage bonus for Aimed Shot, Arcane Shot, Steady Shot, Kill Shot and Chimera Shot
+                if (lvl >= 55 &&
+                    (spellId == GetSpell(AIMED_SHOT_1) ||
+                    spellId == GetSpell(ARCANE_SHOT_1) ||
+                    //spellId == GetSpell(STEADY_SHOT_1) ||
+                    spellId == GetSpell(KILL_SHOT_1) ||
+                    spellId == GetSpell(CHIMERA_SHOT_1)))
+                    pctbonus += 0.05f;
+            }
+
+            //Ranged Weapon Specialization: 5% bonus damage for ranged attacks
+            if (lvl >= 35 && attackType == RANGED_ATTACK)
+                pctbonus += 0.05f;
+            //Improved Arcane Shot: 15% bonus damage for Arcane Shot
+            if (lvl >= 20 && spellId == GetSpell(ARCANE_SHOT_1))
+                pctbonus += 0.15f;
+            //Rapid Killing (buff): 20% bonus damage for Aimed Shot, Arcane Shot or Chimera Shot (removed in SpellHitTarget())
+            if (lvl >= 20 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(ARCANE_SHOT_1) || spellId == GetSpell(CHIMERA_SHOT_1)) &&
+                me->HasAura(RAPID_KILLING_BUFF))
+                pctbonus += 0.2f;
+            //Barrage: 12% bonus damage for Aimed Shot, Multi-Shot or Volley (removed in SpellHitTarget())
+            if (lvl >= 30 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(MULTISHOT_1) ||
+                spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(VOLLEY_DAMAGE_1))))
+                pctbonus += 0.12f;
+            //Marked for Death (part 1): 5% bonus damage for all ranged shots on marked target
+            if (lvl >= 55 && attackType == RANGED_ATTACK && damageinfo.target == markTarget)
+                pctbonus += 0.05f;
+            //T.N.T: 6% bonus damage for Explosive Shot (handled here) and Black Arrow (can be handler in ApplyClassDamageMultiplierEffect())
+            if (lvl >= 25 && spellId == GetSpell(EXPLOSIVE_SHOT_1))
+                pctbonus += 0.06f;
+            //Sniper Training (part 2): 6% bonus damage for Steady Shot, Aimed Shot, Black Arrow and Explosive Shot (screw aura stuff, just increase)
+            if (lvl >= 50 &&
+                (spellId == GetSpell(AIMED_SHOT_1) ||
+                //spellId == GetSpell(STEADY_SHOT_1) ||
+                //spellId == GetSpell(BLACK_ARROW_1) ||//cannot be handled here
+                spellId == GetSpell(EXPLOSIVE_SHOT_1)))
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+
+            //Thrill of the Hunt additive (stage 1): store mana restore value (50%) while ability crits
+            if (lvl >= 40)
+                (static_cast<ManaRestoreList>(TotH))[spellId] = crit && attackType == RANGED_ATTACK ? spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()) / 2 : 0;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (target == me)
+                return;
+
+            uint32 spellId = spell->Id;
+
+            //Thrill of the Hunt additive (stage 1): store mana restore value while ability crits
+            if (me->getLevel() >= 40 && TotH[spellId] > 0 && uint32(TotH[spellId]) < me->GetMaxPower(POWER_MANA))
+            {
+                me->EnergizeBySpell(me, THRILL_OF_THE_HUNT_EFFECT, TotH[spellId], POWER_MANA);
+                TotH[spellId] = 0;
+            }
+
+            if (spellId == GetSpell(WING_CLIP_1))
+            {
+                //zzzOLD Improved Wing Clip (only on creatures): 30% to root target with Wing Clip
+                //normal creatures are rooted for 10 sec, elites+ for 6 sec
+                if (target->GetTypeId() == TYPEID_UNIT)
+                {
+                    if (urand(1,100) <= 30)
+                    {
+                        uint32 clip = target->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_NORMAL ? IMPROVED_WING_CLIP_NORMAL : IMPROVED_WING_CLIP_EX;
+                        me->CastSpell(target, clip, true);
+                    }
+                }
+            }
+            if (spellId == GetSpell(CONCUSSIVE_SHOT_1))
+            {
+                //Improved Concussion Shot rank 2: 2 sec increased daze duration
+                if (Aura* concus = target->GetAura(spellId, me->GetGUID()))
+                {
+                    int32 dur = concus->GetDuration() + 2000;
+                    concus->SetDuration(dur);
+                    concus->SetMaxDuration(dur);
+                }
+
+                //zzzOLD Improved Concussion Shot: chance to stun target for 3 sec
+                if (urand(1,100) <= 15)
+                {
+                    me->CastSpell(target, IMPROVED_CONCUSSION, true);
+                }
+            }
+
+            //Rapid Killing: use up buff manually
+            if (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(ARCANE_SHOT_1) || spellId == GetSpell(CHIMERA_SHOT_1))
+            {
+                if (me->HasAura(RAPID_KILLING_BUFF))
+                    me->RemoveAura(RAPID_KILLING_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(RAPID_FIRE_1))
+            {
+                //Rapid Fire (id 28755): 4 sec increased duration
+                if (Aura* rapid = me->GetAura(spellId))
+                {
+                    uint32 dur = rapid->GetDuration() + 4000;
+                    rapid->SetDuration(dur);
+                    rapid->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Trap_cd = 0;
+
+            ScorpidSting_Timer = 0;
+            Aspect_Timer = 0;
+
+            Aspect = 0;
+
+            stingTargetGuid = 0;
+
+            markTarget = NULL;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Trap_cd > diff)                     Trap_cd -= diff;
+
+            if (ScorpidSting_Timer > diff)          ScorpidSting_Timer -= diff;
+            if (Aspect_Timer > diff)                Aspect_Timer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(AUTO_SHOT_1, true);
+            InitSpellMap(TRANQ_SHOT_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(SILENCING_SHOT_1) : RemoveSpell(SILENCING_SHOT_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(CHIMERA_SHOT_1) : RemoveSpell(CHIMERA_SHOT_1);
+            InitSpellMap(ARCANE_SHOT_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(AIMED_SHOT_1) : RemoveSpell(AIMED_SHOT_1);
+            InitSpellMap(KILL_SHOT_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(EXPLOSIVE_SHOT_1) : RemoveSpell(EXPLOSIVE_SHOT_1);
+            InitSpellMap(MULTISHOT_1);
+            InitSpellMap(VOLLEY_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(SCATTER_SHOT_1) : RemoveSpell(SCATTER_SHOT_1);
+            InitSpellMap(CONCUSSIVE_SHOT_1);
+            InitSpellMap(DISTRACTING_SHOT_1);
+            InitSpellMap(SCORPID_STING_1);
+            //InitSpellMap(VIPER_STING_1);
+            InitSpellMap(RAPID_FIRE_1);
+            InitSpellMap(WING_CLIP_1);
+            InitSpellMap(RAPTOR_STRIKE_1);
+            InitSpellMap(DISENGAGE_1);
+            InitSpellMap(FROST_TRAP_1);
+            InitSpellMap(FREEZING_ARROW_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(WYVERN_STING_1) : RemoveSpell(WYVERN_STING_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(BLACK_ARROW_1) : RemoveSpell(BLACK_ARROW_1);
+            InitSpellMap(HUNTERS_MARK_1);
+            InitSpellMap(SCARE_BEAST_1);
+            InitSpellMap(FEIGN_DEATH_1);
+            InitSpellMap(DETERRENCE_1);
+            //InitSpellMap(ASPECT_OF_THE_VIPER_1);
+  /*Custom*///ASPECT_OF_THE_PACK                      = ASPECT_OF_THE_VIPER ? ASPECT_OF_THE_PACK_1 : 0;
+  /*Custom*/lvl >= 20 ? InitSpellMap(ASPECT_OF_THE_PACK_1, true) : RemoveSpell(ASPECT_OF_THE_PACK_1);
+            //InitSpellMap(ASPECT_OF_THE_DRAGONHAWK_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(RAPID_KILLING, level >= 20 ? 1 : 0);
+            RefreshAura(CONCUSSIVE_BARRAGE, level >= 30 ? 1 : 0);
+            RefreshAura(PIERCING_SHOTS, level >= 40 ? 1 : 0);
+            RefreshAura(TRUESHOT_AURA, level >= 40 ? 1 : 0);
+            RefreshAura(RAPID_RECUPERATION, level >= 45 ? 1 : 0);
+            RefreshAura(MASTER_MARKSMAN, level >= 45 ? 1 : 0);
+            RefreshAura(WILD_QUIVER, level >= 70 ? 3 : level >= 60 ? 2 : level >= 50 ? 1 : 0);
+            RefreshAura(SUREFOOTED, level >= 15 ? 1 : 0);
+            RefreshAura(ENTRAPMENT, level >= 15 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN5, level >= 67 ? 3 : level >= 58 ? 2 : level >= 50 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN4, level >= 49 && level < 50 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN3, level >= 48 && level < 49 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN2, level >= 47 && level < 48 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN1, level >= 46 && level < 47 ? 1 : 0);
+            RefreshAura(NOXIOUS_STINGS, level >= 45 ? 1 : 0);
+            RefreshAura(HUNTING_PARTY, level >= 55 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case RAPID_FIRE_1:
+                case FROST_TRAP_1:
+                case ASPECT_OF_THE_PACK_1:
+                case ASPECT_OF_THE_VIPER_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        typedef std::unordered_map<uint32 /*spellId*/, int32 /*manaCost*/> ManaRestoreList;
+        ManaRestoreList TotH;
+        uint32 Trap_cd;
+        uint32 ScorpidSting_Timer, Aspect_Timer;
+        uint32 Aspect;
+        uint64 stingTargetGuid;
+        Unit* markTarget;
+
+        enum HunterBaseSpells
+        {
+            AUTO_SHOT_1                         = 75,
+            TRANQ_SHOT_1                        = 19801,
+            SILENCING_SHOT_1                    = 34490,
+            CHIMERA_SHOT_1                      = 53209,
+            ARCANE_SHOT_1                       = 3044,
+            AIMED_SHOT_1                        = 19434,
+            KILL_SHOT_1                         = 53351,
+            EXPLOSIVE_SHOT_1                    = 53301,
+            MULTISHOT_1                         = 2643,
+            VOLLEY_1                            = 1510,
+            SCATTER_SHOT_1                      = 1991,
+            CONCUSSIVE_SHOT_1                   = 5116,
+            DISTRACTING_SHOT_1                  = 20736,
+            SCORPID_STING_1                     = 3043,
+            //VIPER_STING_1                       = 3034,
+            RAPID_FIRE_1                        = 3045,
+            WING_CLIP_1                         = 2974,
+            RAPTOR_STRIKE_1                     = 2973,
+            DISENGAGE_1                         = 781,
+            FROST_TRAP_1                        = 13809,
+            FREEZING_ARROW_1                    = 60192,
+            WYVERN_STING_1                      = 19386,
+            BLACK_ARROW_1                       = 3674,
+            HUNTERS_MARK_1                      = 1130,
+            SCARE_BEAST_1                       = 1513,
+            FEIGN_DEATH_1                       = 5384,
+            DETERRENCE_1                        = 19263,
+            ASPECT_OF_THE_PACK_1                = 36613,//Aspect of the Spirit Hunter
+            ASPECT_OF_THE_VIPER_1               = 34074
+            //ASPECT_OF_THE_DRAGONHAWK_1          = 61846
+        };
+
+        enum HunterPassives
+        {
+        //Talents
+            RAPID_KILLING                       = 34949,//rank 2
+            CONCUSSIVE_BARRAGE                  = 35102,//rank 2
+            PIERCING_SHOTS                      = 53238,//rank 3
+            TRUESHOT_AURA                       = 19506,
+            RAPID_RECUPERATION                  = 53232,//rank 2
+            MASTER_MARKSMAN                     = 34489,//rank 5
+            WILD_QUIVER                         = 53217,//rank 3
+            SUREFOOTED                          = 24283,//rank 3
+            ENTRAPMENT                          = 19388,//rank 3
+            MASTER_TACTICIAN1                   = 34506,
+            MASTER_TACTICIAN2                   = 34507,
+            MASTER_TACTICIAN3                   = 34508,
+            MASTER_TACTICIAN4                   = 34838,
+            MASTER_TACTICIAN5                   = 34839,
+            NOXIOUS_STINGS                      = 53297,//rank 3
+            HUNTING_PARTY                       = 53292 //rank 3
+        };
+
+        enum HunterSpecial
+        {
+            IMPROVED_CONCUSSION                 = 28445,
+            IMPROVED_WING_CLIP_NORMAL           = 47168,
+            IMPROVED_WING_CLIP_EX               = 35963,
+
+            RAPID_KILLING_BUFF                  = 35099,//rank 2
+            THRILL_OF_THE_HUNT_EFFECT           = 34720,
+            FROST_TRAP_AURA                     = 13810,
+            FREEZING_ARROW_EFFECT               = 60210,
+            //FREEZING_TRAP_EFFECT_1              = 3355,
+            //FREEZING_TRAP_EFFECT_2              = 14308,
+            //FREEZING_TRAP_EFFECT_3              = 14309,
+            VOLLEY_DAMAGE_1                     = 42243 //rank 1
+        };
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
new file mode 100644
index 0000000..26cc2c3
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
@@ -0,0 +1,910 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+//#include "WorldSession.h"
+/*
+Mage NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45%
+TODO: Ice Lance, Deep Freeze, Mana Gems, Pet etc...
+*/
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new mage_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct mage_botAI : public bot_minion_ai
+    {
+        mage_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_MAGE;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_MAGE) != SPELL_CAST_OK)
+                return false;
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result && spellId != MANAPOTION && me->HasAura(CLEARCASTBUFF))
+            {
+                cost = m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask());
+                if (cost)
+                    clearcast = true;
+            }
+
+            return result;
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void Counter()
+        {
+            Unit* u = me->GetVictim();
+            bool cSpell = IsSpellReady(COUNTERSPELL_1, 0, false, 5000);
+            bool blast = IsSpellReady(FIREBLAST_1, 0, false, 3000) && HasRole(BOT_ROLE_DPS) && !(u && u->ToCreature() && (u->ToCreature()->isWorldBoss() || u->ToCreature()->IsDungeonBoss())) && me->HasAura(IMPACT_BUFF);
+            if (!cSpell && !blast) return;
+            if (u && u->IsNonMeleeSpellCast(false) &&
+                ((cSpell && me->GetDistance(u) < 30) || (blast && me->GetDistance(u) < 30)))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (cSpell && doCast(u, GetSpell(COUNTERSPELL_1)))
+                {}
+                else if (blast && doCast(u, GetSpell(FIREBLAST_1)))
+                {}
+                GC_Timer = temptimer;
+            }
+            else if (cSpell)
+            {
+                if (Unit* target = FindCastingTarget(30))
+                {
+                    temptimer = GC_Timer;
+                    if (me->IsNonMeleeSpellCast(false))
+                        me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(COUNTERSPELL_1)))
+                        GC_Timer = temptimer;
+                }
+            }
+        }
+
+        void CheckSpellSteal(uint32 diff)
+        {
+            if (!IsSpellReady(SPELLSTEAL_1, diff) || IsCasting() || Rand() > 25) return;
+            Unit* target = FindHostileDispelTarget(30, true);
+            if (target && doCast(target, GetSpell(SPELLSTEAL_1)))
+                GC_Timer = 800;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || Feasting())
+                return;
+
+            if (uint32 DAMPENMAGIC = GetSpell(DAMPENMAGIC_1))
+            {
+                if (!HasAuraName(me, DAMPENMAGIC) &&
+                    doCast(me, DAMPENMAGIC))
+                    return;
+            }
+
+            if (ICEARMOR && !HasAuraName(me, ICEARMOR) &&
+                doCast(me, ICEARMOR))
+                return;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 20) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+
+            if (uint32 ARCANEINTELLECT = GetSpell(ARCANEINTELLECT_1))
+            {
+                if (target->getPowerType() == POWER_MANA && !HasAuraName(target, ARCANEINTELLECT) &&
+                    doCast(target, ARCANEINTELLECT))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            if (clearcast && me->HasAura(CLEARCASTBUFF) && !me->IsNonMeleeSpellCast(false))
+            {
+                me->ModifyPower(POWER_MANA, cost);
+                me->RemoveAurasDueToSpell(CLEARCASTBUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF1))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF2))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me) && (!GetSpell(ICEBLOCK_1) || !me->HasAura(GetSpell(ICEBLOCK_1)))) return; //TODO
+
+            CheckBlink(diff);
+            CheckPoly(diff);
+            CheckPots(diff);
+            CureGroup(master, GetSpell(REMOVE_CURSE_1), diff);
+
+            FocusMagic(diff);
+            BuffAndHealGroup(master, diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_MAGE))
+                return;
+
+            CheckPoly2();//this should go AFTER getting opponent
+
+            Counter();
+            CheckSpellSteal(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            Unit* u = me->SelectNearestTarget(20);
+            //ICE_BARRIER
+            uint32 ICE_BARRIER = GetSpell(ICE_BARRIER_1);
+            if (IsSpellReady(ICE_BARRIER_1, diff, false) && u && u->GetVictim() == me && u->GetDistance(me) < 8 &&
+                !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCast(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, ICE_BARRIER))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if (!IsSpellReady(ICE_BARRIER_1, diff, false) &&
+                IsSpellReady(BLINK_1, diff, false, 3000) && u && u->GetVictim() == me &&
+                u->GetDistance(me) < 6 && !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCast(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, GetSpell(BLINK_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            //ICEBLOCK
+            if (uint32 ICEBLOCK = GetSpell(ICEBLOCK_1))
+            {
+                if (IsSpellReady(ICEBLOCK_1, diff, false, 57000))
+                {
+                    if (((GetManaPCT(me) > 45 && GetHealthPCT(me) > 80) || b_attackers.empty()) &&
+                        me->HasAura(ICEBLOCK))
+                        me->RemoveAurasDueToSpell(ICEBLOCK);
+                }
+
+                if (IsSpellReady(ICEBLOCK_1, diff, false) && !b_attackers.empty() && Rand() < 50 &&
+                    (GetManaPCT(me) < 15 || GetHealthPCT(me) < 45 || b_attackers.size() > 4) &&
+                    !me->HasAura(ICEBLOCK))
+                {
+                    if (me->IsNonMeleeSpellCast(true))
+                        me->InterruptNonMeleeSpells(true);
+                    if (doCast(me, ICEBLOCK))
+                    {
+                        Nova_cd = 0; //Glyph of Iceblock
+                        return;
+                    }
+                }
+            }
+
+            if (IsCasting()) return;
+
+            float dist = me->GetExactDist(opponent);
+
+            uint32 FROSTBOLT = GetSpell(FROSTBOLT_1);
+            uint32 FIREBALL = GetSpell(FIREBALL_1);
+            uint32 BLASTWAVE = GetSpell(BLASTWAVE_1);
+            uint32 FROSTNOVA = GetSpell(FROSTNOVA_1);
+            BOLT = (CCed(opponent, true) || !FROSTBOLT) ? FIREBALL : FROSTBOLT;
+            NOVA = BOLT == FROSTBOLT && BLASTWAVE && dist > 5 ? BLASTWAVE : FROSTNOVA ? FROSTNOVA : 0;
+
+            if (IsSpellReady(COMBUSTION_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                (opponent->GetMaxHealth() > master->GetMaxHealth()*6 ||
+                m_attackers.size() > 1 || b_attackers.size() > 2) &&
+                Rand() < 15 && !HasAuraName(me, COMBUSTION_1))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(COMBUSTION_1)))
+                {
+                    GC_Timer = temptimer;
+                    //Reset timers for fun
+                    ResetSpellCooldown(FIREBLAST_1);
+                    ResetSpellCooldown(DRAGONBREATH_1);
+                    Nova_cd = 0;
+                }
+            }
+            //DAMAGE
+            //PYROBLAST
+            if (IsSpellReady(PYROBLAST_1, diff) && opponent->IsPolymorphed() && HasRole(BOT_ROLE_DPS) &&
+                (b_attackers.size() < 2 || (*b_attackers.begin()) == opponent) &&
+                dist < 35 && Rand() < 75 &&
+                doCast(opponent, GetSpell(PYROBLAST_1)))
+            {
+                SetSpellCooldown(PYROBLAST_1, 7500); //no initial cooldown
+                //debug
+                SetSpellCooldown(DRAGONBREATH_1, std::max<uint32>(GetSpellCooldown(DRAGONBREATH_1), uint32(float(sSpellMgr->GetSpellInfo(GetSpell(PYROBLAST_1))->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 400)));
+                Nova_cd = std::max<uint32>(Nova_cd, 450);
+                return;
+            }
+            //nova //TODO: SEPARATE
+            u = me->SelectNearestTarget(6.3f);
+            if (NOVA && Nova_cd <= diff && HasRole(BOT_ROLE_DPS) && u && Rand() < 75 && !CCed(u, true) && IsInBotParty(u->GetVictim()))
+            {
+                if (doCast(me, NOVA))
+                {
+                    Nova_cd = 15000;
+                    GetInPosition(true);
+                    return;
+                }
+            }
+            //living bomb
+            if (IsSpellReady(LIVINGBOMB_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 35 && opponent->GetHealth() > me->GetHealth()/2 &&
+                Rand() < 45 && !HasAuraName(opponent, LIVINGBOMB_1, me->GetGUID()) &&
+                doCast(opponent, GetSpell(LIVINGBOMB_1)))
+            {
+                GC_Timer = 500;
+                return;
+            }
+            //cone of cold
+            if (IsSpellReady(CONEOFCOLD_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 7 && Rand() < 50 &&
+                me->HasInArc(M_PI*0.75f, opponent) &&
+                doCast(opponent, GetSpell(CONEOFCOLD_1)))
+            {
+                GC_Timer = 500;
+                GetInPosition(true);
+                return;
+            }
+            //dragon's breath
+            if (IsSpellReady(DRAGONBREATH_1, diff) && HasRole(BOT_ROLE_DPS) && !CCed(opponent, true) &&
+                ((me->HasInArc(M_PI*0.75f, opponent) && dist < 7) ||
+                (u && u != opponent && me->HasInArc(M_PI*0.75f, u) && IsInBotParty(u->GetVictim()))) &&
+                doCast(me, GetSpell(DRAGONBREATH_1)))
+            {
+                GC_Timer = 800;
+                return;
+            }
+            /*//blast wave //TODO Separate again
+            u = me->SelectNearestTarget(8);
+            if (BLASTWAVE != 0 && u && isTimerReady(BlastWave_cd) &&
+                !HasAuraName(u, FROSTNOVA) && !HasAuraName(u, DRAGONBREATH) &&
+                doCast(me, BLASTWAVE))
+            {
+                BlastWave_cd = BLASTWAVE_CD;
+                GC_Timer = 800;
+            }*/
+            //fire blast
+            if (IsSpellReady(FIREBLAST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 &&
+                Rand() < 20 + 80*(!opponent->isFrozen() && !opponent->HasAuraType(SPELL_AURA_MOD_STUN) && me->HasAura(IMPACT_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(FIREBLAST_1)))
+                {
+                    GC_Timer = 500;
+                    return;
+                }
+            }
+            //flamestrike - use Improved Flamestrike for instant cast
+            if (IsSpellReady(FLAMESTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && me->HasAura(FIRESTARTERBUFF) && Rand() < 25)
+            {
+                Unit* FStarget = FindAOETarget(30, true, false);
+                if (FStarget && doCast(FStarget, GetSpell(FLAMESTRIKE_1), true))
+                {
+                    me->RemoveAurasDueToSpell(FIRESTARTERBUFF);
+                    GC_Timer = 300;
+                    return;
+                }
+            }
+            //blizzard
+            if (IsSpellReady(BLIZZARD_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, GetSpell(BLIZZARD_1)))
+                    return;
+                SetSpellCooldown(BLIZZARD_1, 1500); //fail
+            }
+            //Frost or Fire Bolt
+            if (BOLT && Bolt_cd <= diff && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 75 &&
+                doCast(opponent, BOLT))
+            {
+                Bolt_cd = uint32(float(sSpellMgr->GetSpellInfo(BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200);
+                //debug
+                SetSpellCooldown(DRAGONBREATH_1, std::max<uint32>(GetSpellCooldown(DRAGONBREATH_1), Bolt_cd + 200));
+                Nova_cd = std::max<uint32>(Nova_cd, 450);
+                return;
+            }
+            //Arcane Missiles
+            if (IsSpellReady(ARCANEMISSILES_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && Rand() < 15 &&
+                doCast(opponent, GetSpell(ARCANEMISSILES_1)))
+                return;
+        }
+
+        void CheckPoly(uint32 diff)
+        {
+            if (polyCheckTimer <= diff)
+            {
+                Polymorph = FindAffectedTarget(GetSpell(POLYMORPH_1), me->GetGUID());
+                polyCheckTimer = 2000;
+            }
+        }
+
+        void CheckPoly2()
+        {
+            if (Polymorph == false && GC_Timer < 500 && GetSpell(POLYMORPH_1))
+            {
+                if (Unit* target = FindPolyTarget(30, me->GetVictim()))
+                {
+                    if (doCast(target, GetSpell(POLYMORPH_1)))
+                    {
+                        Polymorph = true;
+                        polyCheckTimer += 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckPots(uint32 diff)
+        {
+            if (me->IsMounted() || IsCasting())
+                return;
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (GetManaPCT(me) < 35 && Rand() < 35)
+            {
+                if (IsSpellReady(EVOCATION_1, diff, false) && me->getAttackers().empty() &&
+                    doCast(me, GetSpell(EVOCATION_1)))
+                    return;
+                if (Potion_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, MANAPOTION))
+                    {
+                        Potion_cd = POTION_CD;
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void CheckBlink(uint32 diff)
+        {
+            if (GetBotCommandState() == COMMAND_STAY || me->IsMounted() || IAmFree()) return;
+            if (!IsSpellReady(BLINK_1, diff, false) || me->getLevel() < 20 || IsCasting()) return;
+
+            if (!me->IsInCombat() && me->GetExactDist2d(master) > std::max<uint8>(master->GetBotFollowDist(), 35) &&
+                me->HasInArc(M_PI*0.75f, master))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLINK_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            if (!me->getAttackers().empty() && me->GetExactDist2d(master) > 15)
+            {
+                if (Unit* op = me->SelectNearestTarget(7))
+                {
+                    if (op->GetVictim() == me)
+                    {
+                        me->SetFacingTo(me->GetAngle(master));
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(BLINK_1)))
+                            GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void FocusMagic(uint32 diff)
+        {
+            if (fmCheckTimer > diff || GC_Timer > diff || IAmFree() || me->getLevel() < 20 || IsCasting() || Rand() < 50)
+                return;
+
+            uint32 FOCUSMAGIC = GetSpell(FOCUSMAGIC_1);
+            if (!FOCUSMAGIC)
+                return;
+
+            if (Unit* target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 3))
+            {
+                fmCheckTimer = 15000;
+                return;
+            }
+            else
+            {
+                Group* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (master->getPowerType() == POWER_MANA && me->GetExactDist(master) < 30 &&
+                        !master->HasAura(FOCUSMAGIC))
+                        target = master;
+                }
+                else
+                {
+                    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || pPlayer->isDead()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (pPlayer->getPowerType() == POWER_MANA && me->GetExactDist(pPlayer) < 30 &&
+                            !pPlayer->HasAura(FOCUSMAGIC))
+                        {
+                            target = pPlayer;
+                            break;
+                        }
+                    }
+                    if (!target)
+                    {
+                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                            {
+                                Creature* cre = it->second;
+                                if (!cre || !cre->IsInWorld() || cre == me || cre->isDead()) continue;
+                                if (cre->getPowerType() == POWER_MANA && me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(FOCUSMAGIC))
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (target && doCast(target, FOCUSMAGIC))
+                {
+                    GC_Timer = 500;
+                    fmCheckTimer = 30000;
+                    return;
+                }
+            }
+
+            fmCheckTimer = 5000;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Combustion: 10% per stack
+                if (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask())
+                    if (Aura* combustion = me->GetAura(COMBUSTION_BUFF))
+                        aftercrit += float(combustion->GetStackAmount()*10);
+                //Incineration: 6% additional critical chance for Fire Blast, Scorch, Arcane Blast and Cone of Cold
+                if (lvl >= 10 &&
+                    (spellId == GetSpell(FIREBLAST_1) ||
+                    spellId == GetSpell(CONEOFCOLD_1)/* ||
+                    spellId == ARCANEBLAST ||
+                    spellId == SCORCH*/))
+                    aftercrit += 6.f;
+                //World In Flames: 6% additional critical chance for
+                //Flamestrike, Pyroblast, Blast Wave, Dragon's Breath, Living Bomb, Blizzard and Arcane Explosion
+                if (lvl >= 15 &&
+                    (spellId == GetSpell(FLAMESTRIKE_1) ||
+                    spellId == GetSpell(PYROBLAST_1) ||
+                    spellId == GetSpell(BLASTWAVE_1) ||
+                    spellId == GetSpell(DRAGONBREATH_1)/* ||
+                    spellId == ARCANEXPLOSION ||
+                    spellId == LIVINGBOMB ||    //cannot be handled here
+                    spellId == BLIZZARD*/))    //cannot be handled here
+                    aftercrit += 6.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Spell Power: 50% additional crit damage bonus for All spells
+                if (lvl >= 55)
+                    pctbonus += 0.333f;
+                //Ice Shards: 50% additional crit damage bonus for Frost spells
+                else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.333f;
+            }
+            //Improved Cone of Cold: 35% bonus damage for Cone of Cold
+            if (lvl >= 30 && spellId == GetSpell(CONEOFCOLD_1))
+                pctbonus += 0.35f;
+            //Fire Power: 10% bonus damage for Fire spells
+            if (lvl >= 35 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (aftercastTargetGuid != 0)
+            {
+                //only players for now
+                if (!IS_PLAYER_GUID(aftercastTargetGuid))
+                {
+                    aftercastTargetGuid = 0;
+                    return;
+                }
+
+                Player* pTarget = sObjectAccessor->FindPlayer(aftercastTargetGuid);
+                aftercastTargetGuid = 0;
+
+                if (!pTarget/* || me->GetDistance(pTarget) > 15*/)
+                    return;
+
+                //handle effects
+                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch (spell->Effects[i].Effect)
+                    {
+                        case SPELL_EFFECT_CREATE_ITEM:
+                        case SPELL_EFFECT_CREATE_ITEM_2:
+                        {
+                            uint32 newitemid = spell->Effects[i].ItemType;
+                            if (newitemid)
+                            {
+                                ItemPosCountVec dest;
+                                ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(newitemid);
+                                if (!pProto)
+                                    return;
+                                uint32 count = pProto->GetMaxStackSize();
+                                uint32 no_space = 0;
+                                InventoryResult msg = pTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, count, &no_space);
+                                if (msg != EQUIP_ERR_OK)
+                                {
+                                    if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
+                                        count -= no_space;
+                                    else
+                                    {
+                                        // if not created by another reason from full inventory or unique items amount limitation
+                                        pTarget->SendEquipError(msg, NULL, NULL, newitemid);
+                                        continue;
+                                    }
+                                }
+                                if (count)
+                                {
+                                    Item* pItem = pTarget->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
+                                    if (!pItem)
+                                    {
+                                        pTarget->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+                                        continue;
+                                    }
+                                    //unsafe possible
+                                    pItem->SetUInt32Value(ITEM_FIELD_CREATOR, me->GetGUIDLow());
+
+                                    pTarget->SendNewItem(pItem, count, true, false, true);
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+
+                return;
+            }
+
+            //Winter Veil addition
+            uint32 spellId = spell->Id;
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+            {
+                if (SPELL_SCHOOL_MASK_FROST & spell->GetSchoolMask())
+                    me->AddAura(44755, target); //snowflakes
+
+                if (spellId == GetSpell(FROSTBOLT_1) && urand(1,100) <= 10)
+                    me->CastSpell(target, 25686, true); //10% super snowball
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Bolt_cd = 0;
+            Nova_cd = 0;
+            polyCheckTimer = 0;
+            fmCheckTimer = 0;
+            Polymorph = false;
+            clearcast = false;
+            BOLT = 0;
+            NOVA = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Bolt_cd > diff)                     Bolt_cd -= diff;
+            if (Nova_cd > diff)                     Nova_cd -= diff;
+
+            if (polyCheckTimer > diff)              polyCheckTimer -= diff;
+            if (fmCheckTimer > diff)                fmCheckTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(DAMPENMAGIC_1);
+            InitSpellMap(ARCANEINTELLECT_1);
+            InitSpellMap(ARCANEMISSILES_1);
+            InitSpellMap(POLYMORPH_1);
+            InitSpellMap(COUNTERSPELL_1);
+            InitSpellMap(SPELLSTEAL_1);
+            InitSpellMap(EVOCATION_1);
+            InitSpellMap(BLINK_1);
+            InitSpellMap(REMOVE_CURSE_1);
+            //InitSpellMap(INVISIBILITY_1);
+            InitSpellMap(FIREBALL_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(BLASTWAVE_1) : RemoveSpell(BLASTWAVE_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(DRAGONBREATH_1) : RemoveSpell(DRAGONBREATH_1);
+            InitSpellMap(FIREBLAST_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(PYROBLAST_1) : RemoveSpell(PYROBLAST_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(LIVINGBOMB_1) : RemoveSpell(LIVINGBOMB_1);
+            InitSpellMap(DAMPENMAGIC_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(COMBUSTION_1) : RemoveSpell(COMBUSTION_1);
+            InitSpellMap(FROSTBOLT_1);
+            InitSpellMap(FROSTNOVA_1);
+            InitSpellMap(CONEOFCOLD_1);
+            InitSpellMap(BLIZZARD_1);
+ /*Special*/ICEARMOR = lvl >= 20 ? InitSpell(me, ICEARMOR_1) : InitSpell(me, FROSTARMOR_1);
+            InitSpellMap(ICEARMOR);
+  /*Talent*/lvl >= 40 ? InitSpellMap(ICE_BARRIER_1) : RemoveSpell(ICE_BARRIER_1);
+            InitSpellMap(ICEBLOCK_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(FOCUSMAGIC_1) : RemoveSpell(FOCUSMAGIC_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(ARCTIC_WINDS, level >= 35 ? 2 : level >= 10 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL3, level >= 30 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL2, level >= 25 && level < 30 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL1, level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(IMPROVED_BLIZZARD, level >= 45 ? 1 : 0);
+            RefreshAura(FROSTBITE3, level >= 80 ? level >= 60 ? 3 : level >= 30 ? 2 : level >= 10 ? 1 : 0 : 0);
+            RefreshAura(FROSTBITE2, level >= 50 && level < 80 ? level >= 60 ? 3 : level >= 30 ? 2 : level >= 10 ? 1 : 0 : 0);
+            RefreshAura(FROSTBITE1, level >= 10 && level < 50 ? level >= 60 ? 3 : level >= 30 ? 2 : level >= 10 ? 1 : 0 : 0);
+            RefreshAura(SHATTERED_BARRIER, level >= 45 ? 1 : 0);
+            RefreshAura(ARCANE_INSTABILITY, level >= 65 ? 4 : level >= 55 ? 3 : level >= 45 ? 2 : level >= 35 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION3, level >= 50 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION2, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION1, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(SHATTER3, level >= 35 ? 1 : 0);
+            RefreshAura(SHATTER2, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(SHATTER1, level >= 25 && level < 30 ? 1 : 0);
+            RefreshAura(CLEARCAST, level >= 75 ? 3 : level >= 40 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(FINGERS_OF_FROST, level >= 45 ? 1 : 0); //15%
+            RefreshAura(ARCANE_POTENCY2, level >= 40 ? 1 : 0);
+            RefreshAura(ARCANE_POTENCY1, level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(IGNITE, level >= 15 ? 1 : 0);
+            RefreshAura(IMPACT, level >= 60 ? 2 : level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_COUNTERSPELL2, level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_COUNTERSPELL1, level >= 25 && level < 35 ? 1 : 0);
+            RefreshAura(FIRESTARTER2, level >= 55 ? 1 : 0);
+            RefreshAura(FIRESTARTER1, level >= 45 && level < 55 ? 1 : 0);
+            RefreshAura(GLYPH_LIVING_BOMB, GetSpell(LIVINGBOMB_1) ? 1 : 0);
+            RefreshAura(GLYPH_POLYMORPH, GetSpell(POLYMORPH_1) ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case DAMPENMAGIC_1:
+                case ARCANEINTELLECT_1:
+                case EVOCATION_1:
+                case REMOVE_CURSE_1:
+                case FOCUSMAGIC_1:
+                case FROSTARMOR_1:
+                case ICEARMOR_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Spells
+/*frst*/uint32 ICEARMOR;
+/*exc.*/uint32 BOLT, NOVA;
+        //Timers
+/*exc.*/uint32 Bolt_cd, Nova_cd;
+/*exc.*/uint32 polyCheckTimer, fmCheckTimer;
+        //Check
+/*exc.*/bool Polymorph, clearcast;
+
+        enum MageBaseSpells
+        {
+            DAMPENMAGIC_1                       = 604,
+            ARCANEINTELLECT_1                   = 1459,
+            ARCANEMISSILES_1                    = 5143,
+            POLYMORPH_1                         = 118,
+            COUNTERSPELL_1                      = 2139,
+            SPELLSTEAL_1                        = 30449,
+            EVOCATION_1                         = 12051,
+            BLINK_1                             = 1953,
+            REMOVE_CURSE_1                      = 475,
+            //INVISIBILITY_1                      = 0,
+            FIREBALL_1                          = 133,
+            BLASTWAVE_1                         = 11113,
+            DRAGONBREATH_1                      = 31661,
+            FIREBLAST_1                         = 2136,
+            PYROBLAST_1                         = 11366,
+            LIVINGBOMB_1                        = 44457,
+            FLAMESTRIKE_1                       = 2120,
+            COMBUSTION_1                        = 11129,
+            FROSTBOLT_1                         = 116,
+            FROSTNOVA_1                         = 122,
+            CONEOFCOLD_1                        = 120,
+            BLIZZARD_1                          = 10,
+            FROSTARMOR_1                        = 168,
+            ICEARMOR_1                          = 7302,
+            ICE_BARRIER_1                       = 11426,
+            ICEBLOCK_1                          = 45438,
+            FOCUSMAGIC_1                        = 54646
+        };
+
+        enum MagePassives
+        {
+        //Talents
+            SHATTERED_BARRIER                   = 54787,//rank 2
+            ARCTIC_WINDS                        = 31678,//rank 5
+            WINTERS_CHILL1                      = 11180,
+            WINTERS_CHILL2                      = 28592,
+            WINTERS_CHILL3                      = 28593,
+            FROSTBITE1                          = 11071,
+            FROSTBITE2                          = 12496,
+            FROSTBITE3                          = 12497,
+            IMPROVED_BLIZZARD                   = 12488,//rank 3
+            CLEARCAST /*Arcane Concentration*/  = 12577,//rank 5
+            ARCANE_POTENCY1                     = 31571,
+            ARCANE_POTENCY2                     = 31572,
+            SHATTER1                            = 11170,
+            SHATTER2                            = 12982,
+            SHATTER3                            = 12983,
+            INCANTERS_ABSORPTION1               = 44394,
+            INCANTERS_ABSORPTION2               = 44395,
+            INCANTERS_ABSORPTION3               = 44396,
+            FINGERS_OF_FROST                    = 44545,//rank 2
+            ARCANE_INSTABILITY                  = 15060,//rank 3
+            IMPROVED_COUNTERSPELL1              = 11255,
+            IMPROVED_COUNTERSPELL2              = 12598,
+            IGNITE                              = 12848,
+            FIRESTARTER1                        = 44442,
+            FIRESTARTER2                        = 44443,
+            IMPACT                              = 12358,
+            GLYPH_LIVING_BOMB                   = 63091,
+        //Special
+            GLYPH_POLYMORPH                     = 56375
+        };
+        enum MageSpecial
+        {
+            CLEARCASTBUFF                       = 12536,
+            IMPACT_BUFF                         = 64343,
+            FIRESTARTERBUFF                     = 54741,
+            ARCANE_POTENCY_BUFF1                = 57529,
+            ARCANE_POTENCY_BUFF2                = 57531,
+            COMBUSTION_BUFF                     = 28682
+        };
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..c312215
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
@@ -0,0 +1,1173 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+//#include "WorldSession.h"
+/*
+Paladin NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45-50%
+TODO: Tanking, Shield Abilities, Auras
+*/
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new paladin_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct paladin_botAI : public bot_minion_ai
+    {
+        paladin_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_PALADIN;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_PALADIN) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void HOFGroup(Player* pTarget, uint32 diff)
+        {
+            if (!IsSpellReady(HOF_1, diff) || IAmFree() || IsCasting() || Rand() > 60)
+                return;
+
+            if (Group* pGroup = pTarget->GetGroup())
+            {
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer) continue;
+                    if (HOFTarget(tPlayer, diff))
+                        return;
+                }
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->HaveBot()) continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* cre = it->second;
+                        if (!cre || !cre->IsInWorld()) continue;
+                        if (HOFTarget(cre, diff))
+                            return;
+                    }
+                }
+            }
+        }
+
+        bool HOFTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOF_1, diff)) return false;
+            if (target->ToCreature() && Rand() > 25) return false;
+            if (me->GetExactDist(target) > 30) return false;//too far away
+            if (HasAuraName(target, HOF_1)) return false;     //Alredy has HOF
+
+            Unit::AuraMap const &auras = target->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            {
+                Aura* aura = i->second;
+                if (aura->IsPassive()) continue;//most
+                if (aura->GetDuration() < 2000) continue;
+                if (AuraApplication* app = aura->GetApplicationOfTarget(target->GetGUID()))
+                    if (app->IsPositive()) continue;
+                SpellInfo const* spellInfo = aura->GetSpellInfo();
+                if (spellInfo->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+                //if (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                if (me->getLevel() >= 40 && (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_STUN)))
+                {
+                    if (doCast(target, GetSpell(HOF_1)))
+                        return true;
+                }
+       /*else */if (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_SNARE) ||
+                    spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_ROOT))
+                {
+                    uint32 spell = GetSpell(CLEANSE_1) &&
+                        (spellInfo->Dispel == DISPEL_MAGIC ||
+                        spellInfo->Dispel == DISPEL_DISEASE ||
+                        spellInfo->Dispel == DISPEL_POISON) ? GetSpell(CLEANSE_1) : GetSpell(HOF_1);
+
+                    if (doCast(target, spell))
+                        return true;
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(Player* hTarget, uint32 diff)
+        {
+            if (!IsSpellReady(HOS_1, diff) || IAmFree() || IsCasting() || Rand() > 30)
+                return;
+
+            if (Group* pGroup = hTarget->GetGroup())
+            {
+                bool bots = false;
+                float threat;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* HOSPlayer = itr->GetSource();
+                    if (!HOSPlayer) continue;
+                    if (HOSPlayer->HaveBot())
+                        bots = true;
+                    if (HOSPlayer->isDead()) continue;
+                    if (IsTank(HOSPlayer)) continue; //tanks do not need it
+                    if (!HOSPlayer->IsInWorld() || master->GetMap() != HOSPlayer->FindMap() || me->GetExactDist(HOSPlayer) > 30) continue;
+                    if (HasAuraName(HOSPlayer, HOS_1)) continue;
+                    AttackerSet h_attackers = HOSPlayer->getAttackers();
+                    if (h_attackers.empty()) continue;
+                    for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        threat = (*iter)->getThreatManager().getThreat(HOSPlayer);
+                        if (threat < 25.f) continue;//too small threat
+                        if ((*iter)->getAttackers().size() < 2) continue;//would be useless
+                        if (HOSPlayer->GetDistance((*iter)) > 10) continue;
+                        if (HOSTarget(HOSPlayer, diff))
+                            return;
+                    }//end for
+                }//end for
+                if (!bots) return;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl) continue;
+                    if (!pl->HaveBot()) continue;
+                    if (master->GetMap() != pl->FindMap()) continue;
+                    if (!pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                    BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* cre = it->second;
+                        if (!cre || cre->isDead()) continue;
+                        if (IsTank(cre)) continue;
+                        if (me->GetExactDist(cre) > 30) continue;
+                        if (HasAuraName(cre, HOS_1)) continue; //Alredy has HOS
+                        AttackerSet h_attackers = cre->getAttackers();
+                        if (h_attackers.empty()) continue;
+                        for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                        {
+                            if (!(*iter)) continue;
+                            if ((*iter)->isDead()) continue;
+                            if (!(*iter)->CanHaveThreatList()) continue;
+                            threat = (*iter)->getThreatManager().getThreat(cre);
+                            if (threat < 25.f) continue;//too small threat
+                            if ((*iter)->getAttackers().size() < 2) continue;//would be useless
+                            if (cre->GetDistance((*iter)) > 10) continue;
+                            if (HOSTarget(cre, diff))
+                                return;
+                        }//end for
+                    }//end for
+                }//end for
+            }//end if
+        }
+
+        bool HOSTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOS_1, diff) || Rand() > 50) return false;
+            if (IsTank(target)) return false; //tanks do not need it
+            if (IsCasting()) return false; //I'm busy casting
+            if (me->GetExactDist(target) > 30) return false; //too far away
+            if (HasAuraName(target, HOS_1)) return false; //Alredy has HOS
+
+            AttackerSet h_attackers = target->getAttackers();
+            if (h_attackers.empty()) return false; //no aggro
+            float threat;
+            uint8 Tattackers = 0;
+            for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if ((*iter)->isDead()) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                threat = (*iter)->getThreatManager().getThreat(target);
+                if (threat < 25.f) continue; //too small threat
+                if ((*iter)->getAttackers().size() < 2) continue;//would be useless
+                if (target->GetDistance((*iter)) <= 10)
+                    Tattackers++;
+            }
+            if (Tattackers > 0 && doCast(target, GetSpell(HOS_1)))
+            {
+                for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    if ((*iter)->getThreatManager().getThreat(target) > 0.f)
+                        (*iter)->getThreatManager().modifyThreatPercent(target, -(30 + 50*(target->HasAura(586)))); //Fade
+                return true;
+            }
+            return false;
+        }
+        //Holy_Shock setup (Modify HERE)
+        bool HS(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOLY_SHOCK_1, diff)) return false;
+            if (IsCasting()) return false;
+            if (target->GetTypeId() == TYPEID_PLAYER && (target->IsCharmed() || target->isPossessed()))
+                return false; //do not damage friends under control
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (doCast(target, GetSpell(HOLY_SHOCK_1)))
+            {
+                if (urand(1,100) <= 20) //Daybreak: 20% to not trigger HS CD, only GCD
+                    ResetSpellCooldown(HOLY_SHOCK_1);
+                return true;
+            }
+            return false;
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (!target || target->isDead()) return false;
+            if (hp > 97) return false;
+            //sLog->outBasic("HealTarget() by %s on %s", me->GetName().c_str(), target->GetName().c_str());
+            if (Rand() > 40 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 35) return false;
+            if (IsCasting()) return false;
+            if (IsSpellReady(HAND_OF_PROTECTION_1, diff, false) && target->GetTypeId() == TYPEID_PLAYER &&
+                IsInBotParty(target) &&
+                ((hp < 30 && !target->getAttackers().empty()) || (hp < 50 && target->getAttackers().size() > 3)) &&
+                me->GetExactDist(target) < 30 &&
+                !HasAuraName(target, HAND_OF_PROTECTION_1) &&
+                !HasAuraName(target, FORBEARANCE_AURA))
+            {
+                if (doCast(target, GetSpell(HAND_OF_PROTECTION_1)))
+                {
+                    BotWhisper("BOP on you!", target->ToPlayer());
+
+                    //debug
+                    if (!HasAuraName(target, FORBEARANCE_AURA))
+                        me->AddAura(FORBEARANCE_AURA, target);
+                    if (HasAuraName(target, FORBEARANCE_AURA) && !HasAuraName(target, HAND_OF_PROTECTION_1))
+                        me->AddAura(GetSpell(HAND_OF_PROTECTION_1), target);
+                }
+                return true;
+            }
+            else if (hp < 20 && !HasAuraName(target, HAND_OF_PROTECTION_1))
+            {
+                // 20% to cast loh, else just do a Shock
+                switch (rand()%3)
+                {
+                    case 1:
+                        if (IsSpellReady(LAY_ON_HANDS_1, diff, false) && hp < 20 &&
+                            target->GetTypeId() == TYPEID_PLAYER &&
+                            (target->IsInCombat() || !target->getAttackers().empty()) &&
+                            !HasAuraName(target, FORBEARANCE_AURA))
+                        {
+                            if (doCast(target, GetSpell(LAY_ON_HANDS_1)))
+                            {
+                                BotWhisper("Lay of Hands on you!", target->ToPlayer());
+                                return true;
+                            }
+                        }
+                    case 2:
+                        if (GC_Timer > diff) return false;
+                        if (doCast(target, GetSpell(FLASH_OF_LIGHT_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                            return true;
+                    case 3:
+                        if (GC_Timer > diff) return false;
+                        if (HS(target, diff))
+                            return true;
+                }
+            }
+
+            Unit* u = target->GetVictim();
+            if (IsSpellReady(SACRED_SHIELD_1, diff) && !IAmFree() && target->GetTypeId() == TYPEID_PLAYER &&
+                (hp < 65 || target->getAttackers().size() > 1 || (u && u->GetMaxHealth() > target->GetMaxHealth()*10 && target->IsInCombat())) &&
+                !HasAuraName(target, SACRED_SHIELD_1) && IsInBotParty(target))
+            {
+                Unit* aff = FindAffectedTarget(GetSpell(SACRED_SHIELD_1), me->GetGUID(), 50, 1);//use players since we cast only on them
+                if ((!aff || (aff->getAttackers().empty() && !IsTank(aff))) &&
+                    doCast(target, GetSpell(SACRED_SHIELD_1)))
+                    return true;
+            }
+            if ((hp < 85 || GetLostHP(target) > 6000))
+                if (HS(target, diff))
+                    return true;
+            if ((hp > 35 && (hp < 75 || GetLostHP(target) > 8000)) || (!GetSpell(FLASH_OF_LIGHT_1) && hp < 85))
+                if (doCast(target, GetSpell(HOLY_LIGHT_1)))
+                    return true;
+            if ((hp < 90 || GetLostHP(target) > 1500))
+                if (doCast(target, GetSpell(FLASH_OF_LIGHT_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                    return true;
+            return false;
+        }//end HealTarget
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            //HOFTarget(me, diff);//self stun cure goes FIRST
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && GetManaPCT(me) < 30)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (GetManaPCT(me) < 40 && IsSpellReady(DIVINE_PLEA_1, diff, false))
+                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
+                    return;
+
+            CureTarget(me, GetSpell(CLEANSE_1), diff); //maybe unnecessary but this goes FIRST
+            HOFTarget(master, diff); //maybe unnecessary
+            CureTarget(master, GetSpell(CLEANSE_1), diff); //maybe unnecessary
+            BuffAndHealGroup(master, diff);
+            HOSTarget(master, diff);
+            CureGroup(master, GetSpell(CLEANSE_1), diff);
+            HOFGroup(master, diff);
+            HOSGroup(master, diff);
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff
+            if (IsSpellReady(SEAL_OF_COMMAND_1, diff, false) && Rand() < 20 && !HasAuraName(me, SEAL_OF_COMMAND_1) &&
+                doCast(me, GetSpell(SEAL_OF_COMMAND_1)))
+                GC_Timer = 500;
+
+            // Heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_PALADIN))
+                return;
+
+            Repentance(diff);
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(REDEMPTION_1), master);
+
+            if (Feasting())
+                return;
+
+            //aura
+            if (master->IsAlive() && me->GetExactDist(master) < 20)
+            {
+                uint8 myAura;
+                uint32 DEVOTION_AURA = GetSpell(DEVOTION_AURA_1);
+                uint32 CONCENTRATION_AURA = GetSpell(CONCENTRATION_AURA_1);
+
+                if (me->HasAura(DEVOTION_AURA, me->GetGUID()))
+                    myAura = DEVOTIONAURA;
+                else if (me->HasAura(CONCENTRATION_AURA, me->GetGUID()))
+                    myAura = CONCENTRATIONAURA;
+                else
+                    myAura = NOAURA;
+
+                if (myAura != NOAURA)
+                    return; //do not bother
+
+                Aura* concAura = master->GetAura(CONCENTRATION_AURA);
+                Aura* devAura = master->GetAura(DEVOTION_AURA);
+                if (devAura && concAura) return;
+                if (devAura && devAura->GetCasterGUID() == me->GetGUID()) return;
+                if (concAura && concAura->GetCasterGUID() == me->GetGUID()) return;
+
+                if ((master->getClass() == BOT_CLASS_MAGE ||
+                    master->getClass() == BOT_CLASS_PRIEST ||
+                    master->getClass() == BOT_CLASS_WARLOCK ||
+                    master->getClass() == BOT_CLASS_DRUID || devAura) &&
+                    !concAura &&
+                    doCast(me, CONCENTRATION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+                if (!devAura && doCast(me, DEVOTION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead() || GC_Timer > diff || Rand() > 30) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+            //if (HasAuraName(target, BLESSING_OF_WISDOM_1, me->GetGUID()) ||
+            //    HasAuraName(target, BLESSING_OF_KINGS_1, me->GetGUID()) ||
+            //    HasAuraName(target, BLESSING_OF_SANCTUARY_1, me->GetGUID()) ||
+            //    HasAuraName(target, BLESSING_OF_MIGHT_1, me->GetGUID()))
+            //    return false;
+            //if (HasAuraName(target, "Greater Blessing of Wisdom", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Might", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Kings", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Sanctuary", me->GetGUID()))
+            //    return false;
+
+            uint32 mask = GetBlessingsMask(target);
+
+            //already has my blessing
+            if (mask & SPECIFIC_BLESSING_MY_BLESSING)
+                return false;
+
+            uint32 BLESSING_OF_WISDOM = GetSpell(BLESSING_OF_WISDOM_1);
+            uint32 BLESSING_OF_KINGS = GetSpell(BLESSING_OF_KINGS_1);
+            uint32 BLESSING_OF_SANCTUARY = GetSpell(BLESSING_OF_SANCTUARY_1);
+            uint32 BLESSING_OF_MIGHT = GetSpell(BLESSING_OF_MIGHT_1);
+
+            bool wisdom = (mask & SPECIFIC_BLESSING_WISDOM);
+            bool kings = (mask & SPECIFIC_BLESSING_KINGS);
+            bool sanctuary = (mask & SPECIFIC_BLESSING_SANCTUARY);
+            bool might = (mask & SPECIFIC_BLESSING_MIGHT);
+
+            //bool wisdom = HasAuraName(target, BLESSING_OF_WISDOM_1) || HasAuraName(target, GREATER_BLESSING_OF_WISDOM_1);
+            //bool kings = HasAuraName(target, BLESSING_OF_KINGS_1) || HasAuraName(target, GREATER_BLESSING_OF_KINGS_1);
+            //bool sanctuary = HasAuraName(target, BLESSING_OF_SANCTUARY_1) || HasAuraName(target, GREATER_BLESSING_OF_SANCTUARY_1);
+            //bool might = (HasAuraName(target, BLESSING_OF_MIGHT_1) || HasAuraName(target, GREATER_BLESSING_OF_MIGHT_1) || HasAuraName(target, BATTLESHOUT_1));
+
+            uint8 Class = 0;
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                Class = target->getClass();
+            else if (Creature* cre = target->ToCreature())
+                Class = cre->GetBotAI() ? cre->GetBotAI()->GetPlayerClass() : cre->getClass();
+
+            switch (Class)
+            {
+                case BOT_CLASS_PRIEST:
+                    if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    break;
+                case BOT_CLASS_DEATH_KNIGHT:
+                case BOT_CLASS_WARRIOR:
+                case BOT_CLASS_PALADIN:
+                case BOT_CLASS_ROGUE:
+                case BOT_CLASS_HUNTER:
+                case BOT_CLASS_SHAMAN:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    break;
+                default:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    break;
+            }
+            return false;
+        }
+
+        void Repentance(uint32 diff, Unit* target = NULL)
+        {
+            temptimer = GC_Timer;
+            if (target)
+            {
+                if (IsSpellReady(REPENTANCE_1, diff, false, 25000) && doCast(target, GetSpell(REPENTANCE_1)))
+                {}
+            }
+            else if (IsSpellReady(REPENTANCE_1, diff, false))
+            {
+                Unit* u = FindStunTarget();
+                if (u && u->GetVictim() != me && doCast(u, GetSpell(REPENTANCE_1)))
+                {}
+            }
+            GC_Timer = temptimer;
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+            if (Rand() > 60)
+                return;
+
+            Unit* target = IsSpellReady(REPENTANCE_1, diff, false, 25000) ? FindCastingTarget(20, 0, false, REPENTANCE_1) : NULL;
+            if (target)
+                Repentance(diff, target); //first check repentance
+            else if (IsSpellReady(TURN_EVIL_1, diff, false, 1500))
+            {
+                target = FindCastingTarget(20, 0, false, TURN_EVIL_1);
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(TURN_EVIL_1), true))
+                    GC_Timer = temptimer;
+            }
+            else if (IsSpellReady(HOLY_WRATH_1, diff, false, 8000) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(8, 0, false, TURN_EVIL_1); //here we check target as with turn evil cuz of same requirements
+                temptimer = GC_Timer;
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                    GC_Timer = temptimer;
+            }
+            else if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff, /*true*/false, 7000))
+            {
+                target = FindCastingTarget(10);
+                if (target && doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                {}
+            }
+        }
+
+        void TurnEvil(uint32 diff)
+        {
+            if (!IsSpellReady(TURN_EVIL_1, diff) || IsCasting() || Rand() > 50 ||
+                FindAffectedTarget(GetSpell(TURN_EVIL_1), me->GetGUID(), 50))
+                return;
+            Unit* target = FindUndeadCCTarget(20, TURN_EVIL_1);
+            if (target &&
+                (target != me->GetVictim() || GetHealthPCT(me) < 70 || target->GetVictim() == master) &&
+                doCast(target, GetSpell(TURN_EVIL_1), true))
+                return;
+            else
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                !CCed(opponent) &&
+                opponent->GetVictim() && !IsTank(opponent->GetVictim()) && opponent->GetVictim() != me &&
+                GetHealthPCT(me) < 90 &&
+                doCast(opponent, GetSpell(TURN_EVIL_1), true))
+                return;
+        }
+
+        void Wrath(uint32 diff)
+        {
+            if (!IsSpellReady(HOLY_WRATH_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
+                return;
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                me->GetExactDist(opponent) <= 8 && doCast(me, GetSpell(HOLY_WRATH_1)))
+            {}
+            else
+            {
+                Unit* target = FindUndeadCCTarget(8, GetSpell(HOLY_WRATH_1));
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                {}
+            }
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+            TurnEvil(diff);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //HAMMER OF WRATH //custom GCD check
+            if (IsSpellReady(HOW_1, diff, false) && GC_Timer <= 300 && HasRole(BOT_ROLE_DPS) && Rand() < 30 && GetHealthPCT(opponent) < 19 &&
+                me->GetExactDist(opponent) < 30)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(HOW_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HAND OF RECKONING //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(HANDOFRECKONING_1, diff, false) && me->GetExactDist(opponent) < 30 &&
+                HasRole(BOT_ROLE_DPS) && u && u != me && !IsTank(u) && Rand() < 50 &&
+                (IsInBotParty(u) || IsTank()))
+            {
+                Creature* cre = opponent->ToCreature();
+                temptimer = GC_Timer;
+                if (((cre && cre->isWorldBoss() && !IsMeleeClass(u->getClass())) ||
+                    GetHealthPCT(u) < GetHealthPCT(me) - 5 || IsTank()) &&
+                    doCast(opponent, GetSpell(HANDOFRECKONING_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff) && !CCed(opponent) &&
+                me->GetExactDist(opponent) < 10 && Rand() < 20)
+            {
+                if (doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                    return;
+            }
+
+            if (IsSpellReady(JUDGEMENT_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 10 &&
+                Rand() < 50 && me->HasAura(GetSpell(SEAL_OF_COMMAND_1)))
+            {
+                if (doCast(opponent, GetSpell(JUDGEMENT_1)))
+                    return;
+            }
+
+            if (IsSpellReady(CONSECRATION_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetDistance(opponent) < 7 &&
+                !opponent->isMoving() && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(CONSECRATION_1)))
+                    return;
+            }
+
+            if (IsSpellReady(AVENGING_WRATH_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > (master->GetMaxHealth()*2)/3 && Rand() < 25)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(AVENGING_WRATH_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(CRUSADER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetDistance(opponent) < 5)
+            {
+                if (doCast(opponent, GetSpell(CRUSADER_STRIKE_1)))
+                    return;
+            }
+
+            if (IsSpellReady(EXORCISM_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 30 &&
+                (!IsTank() || opponent->GetVictim() == me || opponent->IsVehicle() || opponent->ToPlayer()))
+            {
+                if (doCast(opponent, GetSpell(EXORCISM_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                    return;
+            }
+
+            Wrath(diff);
+
+            if (IsSpellReady(DIVINE_STORM_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 7)
+            {
+                if (doCast(opponent, GetSpell(DIVINE_STORM_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Fanaticism: 18% additional critical chance for all Judgements (not shure which check is right)
+                if (lvl >= 45 && (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT || spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT))
+                    aftercrit += 18.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+            //Sanctity of Battle: 15% bonus damage for Exorcism and Crusader Strike
+            if (lvl >= 25 && spellId == GetSpell(EXORCISM_1))
+                pctbonus += 0.15f;
+            //The Art of War (damage part): 10% bonus damage for Judgements, Crusader Strike and Divine Storm
+            if (lvl >= 40 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT ||
+                spellId == GetSpell(CRUSADER_STRIKE_1) ||
+                spellId == GetSpell(DIVINE_STORM_1)))
+                pctbonus += 0.1f;
+            //Judgements of the Pure (damage part): 25% bonus damage for Judgements and Seals
+            if (lvl >= 50 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_SEAL ||
+                spellId == JUDGEMENT_OF_COMMAND_DAMAGE))
+                pctbonus += 0.25f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Sanctified Wrath: 50% additional critical chance for Hammer of Wrath
+                if (lvl >= 45 && spellId == GetSpell(HOW_1))
+                    aftercrit += 50.f;
+                //Holy Power: 5% additional critical chance for Holy spells
+                if (lvl >= 35 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_HOLY))
+                    aftercrit += 5.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+
+            //Judgements of the Pure (damage part): 25% bonus damage for Judgements and Seals
+            if (lvl >= 50 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_SEAL ||
+                spellId == JUDGEMENT_OF_COMMAND_DAMAGE))
+                pctbonus += 0.25f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType /*damagetype*/, uint32 /*stack*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Healing Light: 12% bonus healing for Holy Light, Flash of Light and Holy Shock
+            if (lvl >= 15 &&
+                (spellId == GetSpell(HOLY_LIGHT_1) ||
+                spellId == GetSpell(FLASH_OF_LIGHT_1) ||
+                spellId == GetSpell(HOLY_SHOCK_1)))
+                pctbonus += 0.12f;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassCritMultiplierHeal(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float aftercrit = 0.0f;
+
+            //Sanctified Light: 6% additional critical chance for Holy Light and Holy Shock
+            if (lvl >= 30 && (spellId == GetSpell(HOLY_LIGHT_1) || spellId == GetSpell(HOLY_SHOCK_1)))
+                aftercrit += 6.f;
+            //Holy Power: 5% additional critical chance for Holy spells
+            if (lvl >= 35 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                aftercrit += 5.f;
+
+            crit_chance += aftercrit;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if ((spellId == GetSpell(EXORCISM_1) || spellId == GetSpell(FLASH_OF_LIGHT_1)) &&
+                me->HasAura(THE_ART_OF_WAR_BUFF))
+            {
+                //Art of War: consume buff
+                me->RemoveAura(THE_ART_OF_WAR_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            if (spellId == GetSpell(HOF_1))
+            {
+                //Guardian's Favor part 2 (handled separately)
+                if (Aura* hof = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = hof->GetDuration() + 4000;
+                    hof->SetDuration(dur);
+                    hof->SetMaxDuration(dur);
+                }
+            }
+
+            //if (!IAmFree())
+            {
+                if (spellId == GetSpell(BLESSING_OF_KINGS_1) || spellId == GetSpell(BLESSING_OF_MIGHT_1) ||
+                    spellId == GetSpell(BLESSING_OF_WISDOM_1) || spellId == GetSpell(BLESSING_OF_SANCTUARY_1))
+                {
+                    //Blessings duration 1h
+                    if (Aura* bless = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = HOUR * IN_MILLISECONDS;
+                        bless->SetDuration(dur);
+                        bless->SetMaxDuration(dur);
+                    }
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            //Custom OnHit() handlers
+
+            if (damageType == DIRECT_DAMAGE)
+            {
+                //The Art of War: 20% on autoattack
+                if (me->getLevel() >= 33)
+                    if (urand(1,100) <= 20)
+                        me->CastSpell(me, THE_ART_OF_WAR_BUFF, true);
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void HealReceived(Unit* healer, uint32& heal)
+        {
+            //Spiritual Attunement
+            if (heal && me->getLevel() >= 40 && healer != me && HasRole(BOT_ROLE_TANK) && GetLostHP(me))
+            {
+                if (int32 basepoints = int32(CalculatePct(std::min<int32>(heal, GetLostHP(me)), 10)))
+                    me->CastCustomSpell(me, SPIRITUAL_ATTUNEMENT_ENERGIZE, &basepoints, NULL, NULL, true);
+            }
+
+            //bot_ai::HealReceived(healer, heal);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 /*diff*/)
+        {
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(FLASH_OF_LIGHT_1);
+            InitSpellMap(HOLY_LIGHT_1);
+            InitSpellMap(LAY_ON_HANDS_1);
+            InitSpellMap(SACRED_SHIELD_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(HOLY_SHOCK_1) : RemoveSpell(HOLY_SHOCK_1);
+            InitSpellMap(CLEANSE_1);
+            InitSpellMap(REDEMPTION_1);
+            InitSpellMap(HAMMER_OF_JUSTICE_1);
+  /*Talent*/lvl >= 45 ? InitSpellMap(REPENTANCE_1) : RemoveSpell(REPENTANCE_1);
+            InitSpellMap(TURN_EVIL_1);
+            InitSpellMap(HOLY_WRATH_1);
+            InitSpellMap(EXORCISM_1);
+  /*Talent*/lvl >= 25 ? InitSpellMap(SEAL_OF_COMMAND_1) : RemoveSpell(SEAL_OF_COMMAND_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(CRUSADER_STRIKE_1) : RemoveSpell(CRUSADER_STRIKE_1);
+            InitSpellMap(JUDGEMENT_1);
+            InitSpellMap(CONSECRATION_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DIVINE_STORM_1) : RemoveSpell(DIVINE_STORM_1);
+            InitSpellMap(HOW_1);
+            InitSpellMap(AVENGING_WRATH_1);
+            InitSpellMap(BLESSING_OF_MIGHT_1);
+            InitSpellMap(BLESSING_OF_WISDOM_1);
+            InitSpellMap(BLESSING_OF_KINGS_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(BLESSING_OF_SANCTUARY_1) : RemoveSpell(BLESSING_OF_SANCTUARY_1);
+            InitSpellMap(DEVOTION_AURA_1);
+            InitSpellMap(CONCENTRATION_AURA_1);
+            InitSpellMap(DIVINE_PLEA_1);
+            InitSpellMap(HAND_OF_PROTECTION_1);
+            InitSpellMap(HOF_1);
+            InitSpellMap(HOS_1);
+            InitSpellMap(HANDOFRECKONING_1);
+
+ /*SPECIAL*/InitSpellMap(ARDENT_DEFENDER_HEAL, true);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            //RefreshAura(SPELLDMG, /*level >= 78 ? 5 : level >= 75 ? 4 */level >= 55 ? 3 : level >= 35 ? 2 : level >= 15 ? 1 : 0);
+            //RefreshAura(SPELLDMG2, level >= 55 ? 3 : level >= 35 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(PURE, level >= 55 ? 1 : 0);
+            RefreshAura(WISE, level >= 35 ? 1 : 0);
+            RefreshAura(RECKONING5, level >= 50 ? 1 : 0);
+            RefreshAura(RECKONING4, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(RECKONING3, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(RECKONING2, level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(RECKONING1, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(VENGEANCE3, level >= 30 ? 1 : 0);
+            RefreshAura(VENGEANCE2, level >= 27 && level < 30 ? 1 : 0);
+            RefreshAura(VENGEANCE1, level >= 25 && level < 27 ? 1 : 0);
+            RefreshAura(SHOFL3, level >= 60 ? 1 : 0);
+            RefreshAura(SHOFL2, level >= 55 && level < 60 ? 1 : 0);
+            RefreshAura(SHOFL1, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(SACRED_CLEANSING, level >= 45 ? 1 : 0);
+            RefreshAura(DIVINE_PURPOSE, level >= 35 ? 1 : 0);
+            RefreshAura(VINDICATION2, level >= 25 ? 1 : 0);
+            RefreshAura(VINDICATION1, level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(LAYHANDS, level >= 30 ? 1 : 0);
+            RefreshAura(FANATICISM, level >= 20 ? 2 : 0);
+            RefreshAura(ARDENT_DEFENDER, level >= 40 ? 1 : 0);
+            RefreshAura(ILLUMINATION, level >= 20 ? 1 : 0);
+            RefreshAura(INFUSION_OF_LIGHT, level >= 55 ? 1 : 0); //NYI
+            RefreshAura(REDOUBT3, level >= 68 ? 2 : level >= 55 ? 1 : 0);
+            RefreshAura(REDOUBT2, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(REDOUBT1, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(GLYPH_HOLY_LIGHT, level >= 15 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case FLASH_OF_LIGHT_1:
+                case HOLY_LIGHT_1:
+                case LAY_ON_HANDS_1:
+                case HOF_1:
+                case SACRED_SHIELD_1:
+                case HOLY_SHOCK_1:
+                case CLEANSE_1:
+                case HAND_OF_PROTECTION_1:
+                case HOS_1:
+                case SEAL_OF_COMMAND_1:
+                case DIVINE_PLEA_1:
+                case AVENGING_WRATH_1:
+                case BLESSING_OF_MIGHT_1:
+                case BLESSING_OF_WISDOM_1:
+                case BLESSING_OF_KINGS_1:
+                case BLESSING_OF_SANCTUARY_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+
+        //uint32 GetBlessingsMask(Unit const*) const
+        //Scans target for auras which are related to paladin's blessings
+        //(even if aura is just incompatible with one)
+        //returns applied blessings mask
+        //used for finding out which blessings target lacks
+        uint32 GetBlessingsMask(Unit const* target) const
+        {
+            uint32 mask = 0;
+
+            bool blessing;
+            Unit::AuraApplicationMap const& aurapps = target->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                blessing = true;
+                switch (itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id)
+                {
+                    case BLESSING_OF_WISDOM_1:
+                    case GREATER_BLESSING_OF_WISDOM_1:
+                        mask |= SPECIFIC_BLESSING_WISDOM;
+                        break;
+                    case BLESSING_OF_KINGS_1:
+                    case GREATER_BLESSING_OF_KINGS_1:
+                        mask |= SPECIFIC_BLESSING_KINGS;
+                        break;
+                    case BLESSING_OF_SANCTUARY_1:
+                    case GREATER_BLESSING_OF_SANCTUARY_1:
+                        mask |= SPECIFIC_BLESSING_SANCTUARY;
+                        break;
+                    case BLESSING_OF_MIGHT_1:
+                    case GREATER_BLESSING_OF_MIGHT_1:
+                    case BATTLESHOUT_1:
+                        mask |= SPECIFIC_BLESSING_MIGHT;
+                        break;
+                    default:
+                        blessing = false; //next aura
+                        break;
+                }
+
+                if (blessing && itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                    mask |= SPECIFIC_BLESSING_MY_BLESSING;
+            }
+
+            return mask;
+        }
+
+        enum PaladinBaseSpells// all orignals
+        {
+            FLASH_OF_LIGHT_1                    = 19750,
+            HOLY_LIGHT_1                        = 635,
+            LAY_ON_HANDS_1                      = 633,
+            REDEMPTION_1                        = 7328,
+            HOF_1  /*Hand of Freedom*/          = 1044,
+            SACRED_SHIELD_1                     = 53601,
+            HOLY_SHOCK_1                        = 20473,
+            CLEANSE_1                           = 4987,
+            HAND_OF_PROTECTION_1                = 1022,
+            HOS_1 /*Hand of salvation*/         = 1038,
+            SEAL_OF_COMMAND_1                   = 20375,
+            HANDOFRECKONING_1                   = 62124,
+            DIVINE_PLEA_1                       = 54428,
+            REPENTANCE_1                        = 20066,
+            TURN_EVIL_1                         = 10326,
+            CRUSADER_STRIKE_1                   = 35395,
+            JUDGEMENT_1                         = 20271,
+            CONSECRATION_1                      = 26573,
+            HAMMER_OF_JUSTICE_1                 = 853,
+            DIVINE_STORM_1                      = 53385,
+            HOW_1   /*Hammer of Wrath*/         = 24275,
+            EXORCISM_1                          = 879,
+            HOLY_WRATH_1                        = 2812,
+            AVENGING_WRATH_1                    = 31884,
+            BLESSING_OF_MIGHT_1                 = 19740,
+            BLESSING_OF_WISDOM_1                = 19742,
+            BLESSING_OF_KINGS_1                 = 20217,
+            BLESSING_OF_SANCTUARY_1             = 20911,
+            DEVOTION_AURA_1                     = 465,
+            CONCENTRATION_AURA_1                = 19746
+        };
+        enum PaladinPassives
+        {
+        //Talents
+            DIVINE_PURPOSE                      = 31872,
+            PURE/*Judgements of the Pure*/      = 54155,
+            WISE/*Judgements of the Wise*/      = 31878,
+            SACRED_CLEANSING                    = 53553,//rank 3
+            RECKONING1                          = 20177,
+            RECKONING2                          = 20179,
+            RECKONING3                          = 20181,
+            RECKONING4                          = 20180,
+            RECKONING5                          = 20182,
+            VINDICATION1                        = 9452 ,//rank 1
+            VINDICATION2                        = 26016,//rank 2
+            LAYHANDS  /*Improved LOH rank 2*/   = 20235,
+            FANATICISM                          = 31881,//rank 3
+            //RIGHTEOUS_VENGEANCE1                = 53380,//rank 1
+            //RIGHTEOUS_VENGEANCE2                = 53381,//rank 2
+            //RIGHTEOUS_VENGEANCE3                = 53382,//rank 3
+            VENGEANCE1                          = 20049,//rank 1
+            VENGEANCE2                          = 20056,//rank 2
+            VENGEANCE3                          = 20057,//rank 3
+            SHOFL1      /*Sheath of Light*/     = 53501,//rank 1
+            SHOFL2                              = 53502,//rank 2
+            SHOFL3                              = 53503,//rank 3
+            ARDENT_DEFENDER                     = 31852,//rank 3
+            ILLUMINATION                        = 20215,//rank 5
+            INFUSION_OF_LIGHT                   = 53576,//rank 2
+            REDOUBT1                            = 20127,//rank 3
+            REDOUBT2                            = 20130,//rank 3
+            REDOUBT3                            = 20135,//rank 3
+        //Glyphs
+            GLYPH_HOLY_LIGHT                    = 54937
+        //other
+            //SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            //SPELLDMG2/*Earth and Moon - druid*/ = 48511 //rank3 6% dam
+        };
+
+        enum PaladinSpecial
+        {
+            NOAURA                              = 0,
+            DEVOTIONAURA                        = 1,
+            CONCENTRATIONAURA                   = 2,
+
+            THE_ART_OF_WAR_BUFF                 = 59578,
+            FORBEARANCE_AURA                    = 25771,
+
+            GREATER_BLESSING_OF_MIGHT_1         = 25782,
+            GREATER_BLESSING_OF_WISDOM_1        = 25894,
+            GREATER_BLESSING_OF_KINGS_1         = 25898,
+            GREATER_BLESSING_OF_SANCTUARY_1     = 25899,
+            BATTLESHOUT_1                       = 6673,
+
+            ARDENT_DEFENDER_HEAL                = 66235,
+            JUDGEMENT_OF_COMMAND_DAMAGE         = 20467,
+            SPIRITUAL_ATTUNEMENT_ENERGIZE       = 31786,
+
+            SPECIFIC_BLESSING_WISDOM            = 0x01,
+            SPECIFIC_BLESSING_KINGS             = 0x02,
+            SPECIFIC_BLESSING_SANCTUARY         = 0x04,
+            SPECIFIC_BLESSING_MIGHT             = 0x08,
+            SPECIFIC_BLESSING_MY_BLESSING       = 0x10
+        };
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
new file mode 100644
index 0000000..47cadc7
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
@@ -0,0 +1,1066 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+//#include "WorldSession.h"
+/*
+Priest NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 50%
+TODO: maybe remove Divine Spirit or so, too much buffs
+*/
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new priest_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct priest_botAI : public bot_minion_ai
+    {
+        priest_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_PRIEST;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_PRIEST) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        bool MassGroupHeal(Player* player, uint32 diff)
+        {
+            if (IAmFree() || !player->GetGroup()) return false;
+            if (IsCasting()) return false;
+            if (Rand() > 35) return false;
+
+            if (IsSpellReady(DIVINE_HYMN_1, diff, false))
+            {
+                Group* gr = player->GetGroup();
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->IsInWorld() || me->GetMap() != tPlayer->FindMap() ||
+                        tPlayer->IsBeingTeleported() || tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 35) continue;
+                        uint8 pct = 50 + tPlayer->getAttackers().size()*10;
+                        pct = pct < 80 ? pct : 80;
+                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
+                            ++LHPcount;
+                    }
+                    if (LHPcount > 1)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && GetHealthPCT(bot) < 40 && me->GetExactDist(bot) < 30)
+                            ++LHPcount;
+                        if (LHPcount > 1)
+                            break;
+                    }
+                }
+                if (LHPcount > 1 && doCast(me, GetSpell(DIVINE_HYMN_1)))
+                    return true;
+            }
+            if (GetSpell(PRAYER_OF_HEALING_1))
+            {
+                Group* gr = player->GetGroup();
+                Unit* castTarget = NULL;
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->IsInWorld() || me->GetMap() != tPlayer->GetMap() ||
+                        tPlayer->IsBeingTeleported() || tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 25) continue;
+                        if (GetHealthPCT(tPlayer) < 85)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(tPlayer) < lowestPCT)
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 2)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && GetHealthPCT(bot) < 70 && me->GetExactDist(bot) < 15)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            lowestPCT = GetHealthPCT(bot);
+                            castTarget = bot;
+                        }
+                        if (LHPcount > 2)
+                            break;
+                    }
+                }
+
+                if (LHPcount > 2 && castTarget && doCast(castTarget, GetSpell(PRAYER_OF_HEALING_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool ShieldTarget(Unit* target, uint32 diff)
+        {
+            if (!IsSpellReady(PW_SHIELD_1, diff, false) || IsCasting() || Rand() > 50)
+                return false;
+            if (me->GetExactDist(target) > 40)
+                return false;
+            if (target->getAttackers().empty() && GetHealthPCT(target) > 33 &&
+                !target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (target->HasAura(WEAKENED_SOUL_DEBUFF) || HasAuraName(target, PW_SHIELD_1))
+                return false;
+
+            if (doCast(target, GetSpell(PW_SHIELD_1)))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            Disperse(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+            DoDevCheck(diff);
+
+            if (Potion_cd <= diff && GetManaPCT(me) < 33)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            //check possible fear
+            doDefend(diff);
+            //buff and heal master's group
+            MassGroupHeal(master, diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, GetSpell(DISPEL_MAGIC_1), diff);
+            CureGroup(master, GetSpell(CURE_DISEASE_1), diff);
+            //ShieldGroup(master);
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckDispel(diff);
+                CheckSilence(diff);
+            }
+
+            if (me->IsInCombat())
+                CheckShackles(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_PRIEST))
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (GetHealthPCT(master) > 90 && GetManaPCT(me) > 35 && GetHealthPCT(me) > 90 &&
+                (m_attackers.size() < 4 || b_attackers.size() + m_attackers.size() < 3) &&
+                !IsCasting())
+                //general rule
+            {
+                opponent = me->GetVictim();
+                if (opponent)
+                {
+                    if (!IsCasting())
+                        StartAttack(opponent);
+                }
+                else
+                    return;
+                float dist = me->GetExactDist(opponent);
+                if (HasRole(BOT_ROLE_DPS) && dist < 30)
+                {
+                    if (IsSpellReady(SW_DEATH_1, diff, false) && Rand() < 50 &&
+                        (GetHealthPCT(opponent) < 15 || opponent->GetHealth() < me->GetMaxHealth()/6) &&
+                        doCast(opponent, GetSpell(SW_DEATH_1)))
+                        return;
+                    if (IsSpellReady(SW_PAIN_1, diff) && Rand() < 25 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/4 &&
+                        !HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(SW_PAIN_1)))
+                        return;
+                    if (IsSpellReady(VAMPIRIC_TOUCH_1, diff) && Rand() < 50 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/4 &&
+                        !HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(VAMPIRIC_TOUCH_1)))
+                        return;
+                    if (IsSpellReady(DEVOURING_PLAGUE_1, diff) && !Devcheck && Rand() < 30 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/3 &&
+                        !HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(DEVOURING_PLAGUE_1)))
+                        return;
+                    if (IsSpellReady(MIND_BLAST_1, diff) && Rand() < 35 &&
+                        (!GetSpell(VAMPIRIC_TOUCH_1) || HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID())) &&
+                        doCast(opponent, GetSpell(MIND_BLAST_1)))
+                        return;
+                    if (IsSpellReady(MIND_FLAY_1, diff, false) && Rand() < 20 &&
+                        (opponent->isMoving() || opponent->GetHealth() < me->GetMaxHealth()/5 ||
+                        (HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) && HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()))) &&
+                        doCast(opponent, GetSpell(MIND_FLAY_1)))
+                        return;
+                    if (IsSpellReady(MIND_SEAR_1, diff, false) && !opponent->isMoving() && dist < 35 && Rand() < 50 &&
+                        HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) &&
+                        HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()))
+                    {
+                        if (Unit* u = FindSplashTarget(30, opponent))
+                            if (doCast(u, GetSpell(MIND_SEAR_1)))
+                                return;
+                    }
+                }//endif opponent
+            }//endif damage
+            //check horror after dots/damage
+            if (IsSpellReady(PSYCHIC_HORROR_1, diff, false) &&
+                opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                opponent->GetHealth() > me->GetMaxHealth()/5 && !CCed(opponent) && Rand() < 30 &&
+                me->GetExactDist(opponent) < 30 && !HasAuraName(opponent, PSYCHIC_HORROR_1))
+            {
+                if (doCast(opponent, GetSpell(PSYCHIC_HORROR_1)))
+                    return;
+            }
+        }//end UpdateAI
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL))
+                return false;
+            if (hp > 98)
+                return false;
+            if (!target || !target->IsAlive() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid())
+                return false;
+
+            //GUARDIAN SPIRIT
+            if (IsSpellReady(GUARDIAN_SPIRIT_1, diff, false) && !IAmFree() && target->IsInCombat() &&
+                !target->getAttackers().empty() && hp < (5 + std::min(20, uint8(target->getAttackers().size())*5)) &&
+                IsInBotParty(target) &&
+                Rand() < 80 && !target->HasAura(GetSpell(GUARDIAN_SPIRIT_1)))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(GUARDIAN_SPIRIT_1)))
+                {
+                    GC_Timer = temptimer;
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Guardian Spirit on you!", target->ToPlayer());
+                    else if (!IAmFree())
+                    {
+                        std::ostringstream msg;
+                        msg << "Guardian Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
+                        BotWhisper(msg.str().c_str(), master);
+                    }
+
+                    return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            //PAIN SUPPRESSION
+            if (hp < 35 && IsSpellReady(PAIN_SUPPRESSION_1, diff, false) &&
+                (target->IsInCombat() || !target->getAttackers().empty()) && Rand() < 50 &&
+                !target->HasAura(GetSpell(PAIN_SUPPRESSION_1)))
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(PAIN_SUPPRESSION_1)))
+                {
+                    GC_Timer = temptimer;
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Pain Suppression on you!", target->ToPlayer());
+                    else if (!IAmFree())
+                    {
+                        std::ostringstream msg;
+                        msg << "Guardin Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
+                        BotWhisper(msg.str().c_str(), master);
+                    }
+
+                    return true;
+                }
+            }
+
+            //Now Heals Requires GCD
+            if ((hp < 80 || !target->getAttackers().empty()) &&
+                ShieldTarget(target, diff))
+                return true;
+
+            //PENANCE/Greater Heal
+            if (hp < 75 || GetLostHP(target) > 4000)
+            {
+                if (IsSpellReady(PENANCE_1, diff, false) && !me->isMoving() && Rand() < 80 &&
+                    (target->GetTypeId() != TYPEID_PLAYER ||
+                    !(target->ToPlayer()->IsCharmed() || target->ToPlayer()->isPossessed())) &&
+                    doCast(target, GetSpell(PENANCE_1)))
+                    return true;
+                else if (HEAL && Heal_Timer <= diff && GC_Timer <= diff && hp > 50 && Rand() < 70 &&
+                    doCast(target, HEAL))
+                {
+                    Heal_Timer = 2500;
+                    return true;
+                }
+            }
+            //Flash Heal
+            if (IsSpellReady(FLASH_HEAL_1, diff) &&
+                ((hp > 75 && hp < 90) || hp < 50 || GetLostHP(target) > 1500) &&
+                doCast(target, GetSpell(FLASH_HEAL_1)))
+                return true;
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = IsTank(target) && boss;
+            //Renew
+            if (IsSpellReady(RENEW_1, diff) &&
+                ((hp < 98 && hp > 70) || GetLostHP(target) > 500 || tanking) &&
+                !HasAuraName(target, RENEW_1, me->GetGUID()) &&
+                doCast(target, GetSpell(RENEW_1)))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!target || !target->IsInWorld() || target->isDead() ||
+                GC_Timer > diff || me->GetExactDist(target) > 30 || Rand() > 20)
+                return false;
+
+            if (IsSpellReady(FEAR_WARD_1, diff, false) &&
+                !target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, MECHANIC_FEAR) &&
+                doCast(target, GetSpell(FEAR_WARD_1)))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+
+            if (target == me)
+            {
+                uint32 INNER_FIRE = GetSpell(INNER_FIRE_1);
+                if (INNER_FIRE && !me->HasAura(INNER_FIRE) &&
+                    doCast(me, INNER_FIRE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+                uint32 VAMPIRIC_EMBRACE = GetSpell(VAMPIRIC_EMBRACE_1);
+                if (VAMPIRIC_EMBRACE && !me->HasAura(VAMPIRIC_EMBRACE) &&
+                    doCast(me, VAMPIRIC_EMBRACE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (uint32 PW_FORTITUDE = GetSpell(PW_FORTITUDE_1))
+            {
+                if (!HasAuraName(target, PW_FORTITUDE) &&
+                    doCast(target, PW_FORTITUDE))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+            if (uint32 SHADOW_PROTECTION = GetSpell(SHADOW_PROTECTION_1))
+            {
+                if (!HasAuraName(target, SHADOW_PROTECTION) &&
+                    doCast(target, SHADOW_PROTECTION))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+            if (uint32 DIVINE_SPIRIT = GetSpell(DIVINE_SPIRIT_1))
+            {
+                if (!HasAuraName(target, DIVINE_SPIRIT) &&
+                    doCast(target, DIVINE_SPIRIT))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(RESURRECTION_1), master);
+
+            //if (Feasting())
+            //    return;
+
+            //if (BuffTarget(master, diff))
+            //    return;
+            //if (BuffTarget(me, diff))
+            //    return;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (CheckDispelTimer > diff || Rand() > 25 || IsCasting())
+                return;
+
+            uint32 DM = GetSpell(DISPEL_MAGIC_1);
+            uint32 MD = GetSpell(MASS_DISPEL_1);
+
+            if (!DM && !MD)
+                return;
+
+            if (Unit* target = FindHostileDispelTarget())
+            {
+                uint32 dm = DM && !target->IsImmunedToSpell(sSpellMgr->GetSpellInfo(DM)) ? DM : MD;
+                if (target && doCast(target, dm))
+                {
+                    CheckDispelTimer = 1000;
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            CheckDispelTimer = 2000; //fail
+        }
+
+        void CheckShackles(uint32 diff)
+        {
+            if (!IsSpellReady(SHACKLE_UNDEAD_1, diff) || IsCasting() || Rand() > 50)
+                return;
+
+            uint32 SHACKLE_UNDEAD = GetSpell(SHACKLE_UNDEAD_1);
+            if (FindAffectedTarget(SHACKLE_UNDEAD, me->GetGUID()))
+            {
+                Shackle_Timer = 1500;
+                return;
+            }
+            Unit* target = FindUndeadCCTarget(30, SHACKLE_UNDEAD);
+            if (target && doCast(target, SHACKLE_UNDEAD))
+            {
+                Shackle_Timer = 3000;
+                GC_Timer = 800;
+            }
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (IsCasting()) return;
+            temptimer = GC_Timer;
+            if (IsSpellReady(SILENCE_1, diff, false))
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, GetSpell(SILENCE_1)))
+                    {}
+            }
+            else if (IsSpellReady(PSYCHIC_HORROR_1, diff, false, 20000))
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, GetSpell(PSYCHIC_HORROR_1)))
+                    {}
+            }
+            GC_Timer = temptimer;
+        }
+
+        void doDefend(uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //fear master's attackers
+            if (IsSpellReady(PSYCHIC_SCREAM_1, diff, false))
+            {
+                if (!m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75))
+                {
+                    uint8 tCount = 0;
+                    for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                        return;
+                }
+
+                // Defend myself (psychic horror)
+                if (!b_attackers.empty())
+                {
+                    uint8 tCount = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 0 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                        return;
+                }
+            }
+            // Heal myself
+            if (GetHealthPCT(me) < 98 && !b_attackers.empty())
+            {
+                if (ShieldTarget(me, diff)) return;
+
+                if (IsSpellReady(FADE_1, diff, false) && me->IsInCombat())
+                {
+                    if (b_attackers.empty()) return;
+                    uint8 Tattackers = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->ToCreature()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if (me->GetExactDist((*iter)) < 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(FADE_1)))
+                        {
+                            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                                if ((*iter)->getThreatManager().getThreat(me) > 0.f)
+                                    (*iter)->getThreatManager().modifyThreatPercent(me, -50);
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                if (GetHealthPCT(me) < 90 && HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            }
+        }
+
+        void DoDevCheck(uint32 diff)
+        {
+            if (DevcheckTimer <= diff)
+            {
+                Devcheck = FindAffectedTarget(GetSpell(DEVOURING_PLAGUE_1), me->GetGUID());
+                DevcheckTimer = 5000;
+            }
+        }
+
+        void Disperse(uint32 diff)
+        {
+            if (!IsSpellReady(DISPERSION_1, diff) || IsCasting() || Rand() > 60)
+                return;
+            if ((me->getAttackers().size() > 3 && !IsSpellReady(FADE_1, diff, false) && GetHealthPCT(me) < 90) ||
+                (GetHealthPCT(me) < 20 && me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                (GetManaPCT(me) < 30) ||
+                (me->getAttackers().size() > 1 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(DISPERSION_1)))
+                {}
+                GC_Timer = temptimer;
+                return;
+            }
+
+            SetSpellCooldown(DISPERSION_1, 2000); //fail
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //434 new
+                //Improved Fire Blast (part 1): 8% additional crit chance for Fire Blast
+                //if (lvl >= 11 && spellId == FLAMESTRIKE)
+                //    aftercrit += 8.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                ////!!!spell damage is not yet critical and will be multiplied by 1.5
+                ////so we should put here bonus damage mult /1.5
+                ////Ice Shards: 50% additional crit damage bonus for Frost spells
+                //else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                //    pctbonus += 0.333f;
+            }
+            //Focused Power: 4% bonus damage for all spells
+            if (lvl >= 35)
+                pctbonus += 0.04f;
+            //Darkness: 10% bonus damage for shadow spells
+            if (lvl >= 10 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus += 0.1f;
+            //Twin Disciplines (damage part): 5% bonus damage for instant spells
+            if (lvl >= 13 && !spellInfo->CalcCastTime())
+                pctbonus += 0.05f;
+            //Twisted Faith (part 1): 10% bonus damage for Mind Blast and Mind Flay if target is affected BY SW: Pain
+            if (lvl >= 55 && (spellId == GetSpell(SW_PAIN_1) || spellId == GetSpell(MIND_FLAY_1)) &&
+                damageinfo.target && damageinfo.target->HasAura(GetSpell(SW_PAIN_1), me->GetGUID()))
+                pctbonus += 0.1f;
+            //Mind Melt (part 1): 30% bonus damage for Shadow Word: Death
+            if (lvl >= 41 && spellId == GetSpell(SW_DEATH_1))
+                pctbonus += 0.3f;
+
+            //Glyph of Mind Flay: 10% damage bonus for Mind Flay
+            if (lvl >= 25 && spellId == GetSpell(MIND_FLAY_1))
+                pctbonus += 0.1f;
+
+            //other
+            if (spellId == SW_DEATH_BACKLASH)
+            {
+                ////T13 Shadow 2P Bonus (Shadow Word: Death), part 2
+                //if (lvl >= 60) //buffed
+                //    pctbonus -= 0.95f;
+                //Pain and Suffering (part 2): 40% reduced backlash damage
+                if (lvl >= 50)
+                    pctbonus -= 0.4f;
+
+                pctbonus = std::min<float>(pctbonus, 1.0f);
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Improved Renew: 15% bonus healing for Renew
+            if (lvl >= 10 && spellId == GetSpell(RENEW_1))
+                pctbonus += 0.15f;
+            //Spiritual Healing: 10% bonus healing for all spells
+            if (lvl >= 35)
+                pctbonus += 0.15f;
+            //Blessend Resilience: 3% bonus healing for all spells
+            if (lvl >= 40)
+                pctbonus += 0.03f;
+            //Empowered Healing: 40% bonus (from spellpower) for Greater Heal and 20% bonus (from spellpower) for Flash Heal
+            if (lvl >= 45)
+            {
+                if (spellId == HEAL)
+                    flat_mod += spellpower * 0.4f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+                else if (spellId == GetSpell(FLASH_HEAL_1))
+                    flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            }
+            //Impowered Renew (heal bonus part): 15% bonus healing for Renew
+            if (lvl >= 50 && spellId == GetSpell(RENEW_1))
+                flat_mod += spellpower *  0.15f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * int32(stack) * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            //Test of Faith: 12% bonus healing on targets at or below 50% health
+            if (lvl >= 50 && GetHealthPCT(victim) <= 50)
+                pctbonus += 0.12f;
+            //Test of Faith: 10 bonus healing for Circle of Healing, Binding Heal, Holy Nova, Prayer of Healing, Divine Hymn and Prayer of Mending
+            if (lvl >= 55 &&
+                (/*spellId == GetSpell(CIRCLE_OF_HEALING_1) || spellId == GetSpell(BINDING_HEAL_1) ||
+                spellId == GetSpell(HOLY_NOVA_1) || */spellId == GetSpell(PRAYER_OF_HEALING_1) ||
+                spellId == DIVINE_HYMN_HEAL/* || spellId == GetSpell(PRAYER_OF_MENDING_1)*/))
+                pctbonus += 0.12f;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassCritMultiplierHeal(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float aftercrit = 0.0f;
+
+            //Improved Flash Heal (part 2): 10% additional critical chance on targets at or below 50% hp for Flash Heal
+            if (lvl >= 40 && spellId == GetSpell(FLASH_HEAL_1) && GetHealthPCT(victim) <= 50)
+                aftercrit += 10.f;
+            //Holy Specialization: 5% additional critical chance for Holy spells
+            if (lvl >= 10 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                aftercrit += 5.f;
+
+            crit_chance += aftercrit;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            ////Strength of Soul: direct heals reduce Weakened Soul duration on target by 4 sec
+            //if (spellId == HEAL || spellId == GetSpell(FLASH_HEAL_1))
+            //{
+            //    if (me->getLevel() >= 51)
+            //    {
+            //        if (Aura* soul = target->GetAura(WEAKENED_SOUL_DEBUFF))
+            //        {
+            //            if (soul->GetDuration() > 4000)
+            //                soul->SetDuration(soul->GetDuration() - 4000);
+            //            else
+            //                target->RemoveAura(soul, AURA_REMOVE_BY_EXPIRE);
+            //        }
+            //    }
+            //}
+
+            //Weakened Soul Reduction (id: 33333 lol): -2 sec to Weakened Soul duration
+            if (spellId == WEAKENED_SOUL_DEBUFF)
+                if (me->getLevel() >= 51)
+                    if (Aura* soul = target->GetAura(WEAKENED_SOUL_DEBUFF))
+                        soul->SetDuration(soul->GetDuration() - 2000);
+
+            //Pain and Suffering (part 1, 335 version): 100% to refresh Shadow Word: Pain on target hit by Mind Flay
+            if (spellId == GetSpell(MIND_FLAY_1))
+                if (me->getLevel() >= 51)
+                    if (Aura* pain = target->GetAura(GetSpell(SW_PAIN_1), me->GetGUID()))
+                        pain->RefreshDuration();
+
+            if (spellId == GetSpell(FEAR_WARD_1))
+            {
+                //2 minutes bonus duration for Fear Ward
+                if (Aura* ward = target->GetAura(GetSpell(FEAR_WARD_1), me->GetGUID()))
+                {
+                    uint32 dur = ward->GetDuration() + 120000;
+                    ward->SetDuration(dur);
+                    ward->SetMaxDuration(dur);
+                }
+            }
+
+            if (spellId == GetSpell(INNER_FIRE_1) || spellId == GetSpell(VAMPIRIC_EMBRACE_1) || spellId == GetSpell(PW_FORTITUDE_1) ||
+                spellId == GetSpell(SHADOW_PROTECTION_1) || spellId == GetSpell(DIVINE_SPIRIT_1))
+            {
+                //1 hour duration for all buffs
+                if (Aura* buff = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    buff->SetDuration(dur);
+                    buff->SetMaxDuration(dur);
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Shackle_Timer = 0;
+
+            CheckDispelTimer = 0;
+            DevcheckTimer = 0;
+
+            Devcheck = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (Shackle_Timer > diff)               Shackle_Timer -= diff;
+
+            if (CheckDispelTimer > diff)            CheckDispelTimer -= diff;
+            if (DevcheckTimer > diff)               DevcheckTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(DISPEL_MAGIC_1);
+            InitSpellMap(MASS_DISPEL_1);
+            InitSpellMap(CURE_DISEASE_1);
+            InitSpellMap(FEAR_WARD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(PAIN_SUPPRESSION_1) : RemoveSpell(PAIN_SUPPRESSION_1);
+            InitSpellMap(PSYCHIC_SCREAM_1);
+            InitSpellMap(FADE_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(PSYCHIC_HORROR_1) : RemoveSpell(PSYCHIC_HORROR_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(SILENCE_1) : RemoveSpell(SILENCE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(PENANCE_1) : RemoveSpell(PENANCE_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(VAMPIRIC_EMBRACE_1) : RemoveSpell(VAMPIRIC_EMBRACE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DISPERSION_1) : RemoveSpell(DISPERSION_1);
+            InitSpellMap(MIND_SEAR_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(GUARDIAN_SPIRIT_1) : RemoveSpell(GUARDIAN_SPIRIT_1);
+            InitSpellMap(SHACKLE_UNDEAD_1);
+            InitSpellMap(GREATER_HEAL_1);
+            InitSpellMap(NORMAL_HEAL_1);
+            InitSpellMap(LESSER_HEAL_1);
+            InitSpellMap(RENEW_1);
+            InitSpellMap(FLASH_HEAL_1);
+            InitSpellMap(PRAYER_OF_HEALING_1);
+            InitSpellMap(DIVINE_HYMN_1);
+            InitSpellMap(RESURRECTION_1);
+            InitSpellMap(PW_SHIELD_1);
+            InitSpellMap(INNER_FIRE_1);
+            InitSpellMap(PW_FORTITUDE_1);
+            InitSpellMap(SHADOW_PROTECTION_1);
+            InitSpellMap(DIVINE_SPIRIT_1);
+            InitSpellMap(SW_PAIN_1);
+            InitSpellMap(MIND_BLAST_1);
+            InitSpellMap(SW_DEATH_1);
+            InitSpellMap(DEVOURING_PLAGUE_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(MIND_FLAY_1) : RemoveSpell(MIND_FLAY_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(VAMPIRIC_TOUCH_1) : RemoveSpell(VAMPIRIC_TOUCH_1);
+
+            HEAL = GetSpell(GREATER_HEAL_1) ? GetSpell(GREATER_HEAL_1) :
+                GetSpell(NORMAL_HEAL_1) ? GetSpell(NORMAL_HEAL_1) :
+                GetSpell(LESSER_HEAL_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(BORROWED_TIME, level >= 65 ? 1 : 0);
+            RefreshAura(DIVINE_AEGIS, level >= 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW3, level >= 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW2, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW1, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(BODY_AND_SOUL1, level >= 45 ? 1 : 0);
+            RefreshAura(RENEWED_HOPE, level >= 45 ? 1 : 0);
+            RefreshAura(PAINANDSUFFERING3, level >= 50 ? 1 : 0);
+            RefreshAura(PAINANDSUFFERING2, level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(PAINANDSUFFERING1, level >= 45 && level < 48 ? 1 : 0);
+            RefreshAura(MISERY3, level >= 50 ? 1 : 0);
+            RefreshAura(MISERY2, level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(MISERY1, level >= 45 && level < 48 ? 1 : 0);
+            RefreshAura(GRACE, level >= 25 ? 1 : 0);
+            RefreshAura(ENLIGHTENMENT, level >= 35 ? 1 : 0);
+            RefreshAura(RAPTURE, level >= 45 ? 1 : 0);
+            RefreshAura(IMPROVED_DEVOURING_PLAGUE, level >= 25 ? 1 : 0);
+            RefreshAura(INSPIRATION3, level >= 25 ? 1 : 0);
+            RefreshAura(INSPIRATION2, level >= 23 && level < 25 ? 1 : 0);
+            RefreshAura(INSPIRATION1, level >= 20 && level < 23 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING3, level >= 30 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING2, level >= 28 && level < 30 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING1, level >= 25 && level < 28 ? 1 : 0);
+            RefreshAura(GLYPH_SW_PAIN, level >= 15? 1 : 0);
+            RefreshAura(GLYPH_PW_SHIELD, level >= 15 ? 1 : 0);
+            RefreshAura(SHADOWFORM, level >= 40 ? 1 : 0);
+            RefreshAura(PRIEST_T10_2P_BONUS, level >= 70 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case DISPEL_MAGIC_1:
+                case MASS_DISPEL_1:
+                case CURE_DISEASE_1:
+                case FEAR_WARD_1:
+                case PAIN_SUPPRESSION_1:
+                case FADE_1:
+                case PENANCE_1:
+                case VAMPIRIC_EMBRACE_1:
+                case DISPERSION_1:
+                case GUARDIAN_SPIRIT_1:
+                case LESSER_HEAL_1:
+                case NORMAL_HEAL_1:
+                case GREATER_HEAL_1:
+                case RENEW_1:
+                case FLASH_HEAL_1:
+                case PRAYER_OF_HEALING_1:
+                case DIVINE_HYMN_1:
+                case PW_SHIELD_1:
+                case INNER_FIRE_1:
+                case PW_FORTITUDE_1:
+                case SHADOW_PROTECTION_1:
+                case DIVINE_SPIRIT_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 HEAL;
+        uint32 Heal_Timer, Shackle_Timer;
+/*Misc*/uint16 CheckDispelTimer, DevcheckTimer;
+/*Misc*/bool Devcheck;
+
+        enum PriestBaseSpells
+        {
+            DISPEL_MAGIC_1                      = 527,
+            MASS_DISPEL_1                       = 32375,
+            CURE_DISEASE_1                      = 528,
+            FEAR_WARD_1                         = 6346,
+  /*Talent*/PAIN_SUPPRESSION_1                  = 33206,
+            PSYCHIC_SCREAM_1                    = 8122,
+            FADE_1                              = 586,
+  /*Talent*/PSYCHIC_HORROR_1                    = 64044,
+  /*Talent*/SILENCE_1                           = 15487,
+  /*Talent*/PENANCE_1                           = 47540,
+  /*Talent*/VAMPIRIC_EMBRACE_1                  = 15286,
+  /*Talent*/DISPERSION_1                        = 47585,
+            MIND_SEAR_1                         = 48045,
+  /*Talent*/GUARDIAN_SPIRIT_1                   = 47788,
+            SHACKLE_UNDEAD_1                    = 9484,
+            LESSER_HEAL_1                       = 2050,
+            NORMAL_HEAL_1                       = 2054,
+            GREATER_HEAL_1                      = 2060,
+            RENEW_1                             = 139,
+            FLASH_HEAL_1                        = 2061,
+            PRAYER_OF_HEALING_1                 = 596,
+            DIVINE_HYMN_1                       = 64843,
+            RESURRECTION_1                      = 2006,
+            PW_SHIELD_1                         = 17,
+            INNER_FIRE_1                        = 588,
+            PW_FORTITUDE_1                      = 1243,
+            SHADOW_PROTECTION_1                 = 976,
+            DIVINE_SPIRIT_1                     = 14752,
+            SW_PAIN_1                           = 589,
+            MIND_BLAST_1                        = 8092,
+            SW_DEATH_1                          = 32379,
+            DEVOURING_PLAGUE_1                  = 2944,
+  /*Talent*/MIND_FLAY_1                         = 15407,
+  /*Talent*/VAMPIRIC_TOUCH_1                    = 34914
+        };
+        enum PriestPassives
+        {
+            SHADOWFORM  /*For DOT crits*/   = 49868,
+        //Talents
+            IMPROVED_DEVOURING_PLAGUE       = 63627,//rank 3
+            MISERY1                         = 33191,
+            MISERY2                         = 33192,
+            MISERY3                         = 33193,
+            PAINANDSUFFERING1               = 47580,
+            PAINANDSUFFERING2               = 47581,
+            PAINANDSUFFERING3               = 47582,
+            SHADOW_WEAVING1                 = 15257,
+            SHADOW_WEAVING2                 = 15331,
+            SHADOW_WEAVING3                 = 15332,
+            DIVINE_AEGIS                    = 47515,//rank 3
+            BORROWED_TIME                   = 52800,//rank 5
+            GRACE                           = 47517,//rank 2
+            EMPOWERED_RENEW1                = 63534,
+            EMPOWERED_RENEW2                = 63542,
+            EMPOWERED_RENEW3                = 63543,
+            INSPIRATION1                    = 14892,
+            INSPIRATION2                    = 15362,
+            INSPIRATION3                    = 15363,
+            BODY_AND_SOUL1                  = 64127,
+            RENEWED_HOPE                    = 57472,//rank 3
+            ENLIGHTENMENT                   = 34910,//rank 3
+            RAPTURE                         = 47537,//rank 3
+        //Glyphs
+            GLYPH_SW_PAIN                   = 55681,
+            GLYPH_PW_SHIELD                 = 55672,
+        //other
+            PRIEST_T10_2P_BONUS             = 70770 //33% renew
+        };
+        enum PriestSpecial
+        {
+            IMPROVED_DEVOURING_PLAGUE_DAMAGE= 63675,
+            MIND_SEAR_DAMAGE                = 49821,
+            SW_DEATH_BACKLASH               = 32409,
+            WEAKENED_SOUL_DEBUFF            = 6788,
+            DIVINE_HYMN_HEAL                = 64844
+        };
+    };
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..26f76bc
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
@@ -0,0 +1,828 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Rogue NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 25% maybe...
+TODO:
+*/
+#define DMGMIN              1
+#define DMGMAX              2
+#define MAX_COMBO_POINTS    5
+#define EVISCERATE_MAX_RANK 12
+const uint32 EVSCRDamage[EVISCERATE_MAX_RANK+1][MAX_COMBO_POINTS+1][DMGMAX+1] =
+{
+    { { 0,0,0 }, { 0,0,0 },     { 0,0,0 },      { 0,0,0 },       { 0,0,0 },       { 0,0,0 }       },
+    { { 0,0,0 }, { 0,6,11 },    { 0,12,16 },    { 0,17,22 },     { 0,22,28 },     { 0,28,34 }     },
+    { { 0,0,0 }, { 0,14,23 },   { 0,26,34 },    { 0,37,46 },     { 0,48,58 },     { 0,60,70 }     },
+    { { 0,0,0 }, { 0,25,49 },   { 0,45,59 },    { 0,64,79 },     { 0,83,99 },     { 0,103,119 }   },
+    { { 0,0,0 }, { 0,41,62 },   { 0,73,93 },    { 0,104,125 },   { 0,135,157 },   { 0,167,189 }   },
+    { { 0,0,0 }, { 0,60,91 },   { 0,106,136 },  { 0,151,182 },   { 0,196,228 },   { 0,242,274 }   },
+    { { 0,0,0 }, { 0,93,138 },  { 0,165,209 },  { 0,236,281 },   { 0,307,353 },   { 0,379,425 }   },
+    { { 0,0,0 }, { 0,144,213 }, { 0,255,323 },  { 0,365,434 },   { 0,475,545 },   { 0,586,656 }   },
+    { { 0,0,0 }, { 0,199,296 }, { 0,351,447 },  { 0,502,599 },   { 0,653,751 },   { 0,805,903 }   },
+    { { 0,0,0 }, { 0,224,333 }, { 0,395,503 },  { 0,565,674 },   { 0,735,845 },   { 0,906,1016 }  },
+    { { 0,0,0 }, { 0,245,366 }, { 0,431,551 },  { 0,616,737 },   { 0,801,923 },   { 0,987,1109 }  },
+    { { 0,0,0 }, { 0,405,614 }, { 0,707,915 },  { 0,1008,1217 }, { 0,1309,1519 }, { 0,1611,1821 } },
+    { { 0,0,0 }, { 0,497,752 }, { 0,868,1122 }, { 0,1238,1493 }, { 0,1608,1864 }, { 0,1979,2235 } }
+};
+#define RUPTURE_MAX_RANK    9
+const uint32 RuptureDamage[RUPTURE_MAX_RANK+1][MAX_COMBO_POINTS+1] =
+{
+    { 0, 0,   0,   0,    0,    0    },
+    { 0, 41,  61,  86,   114,  147  },
+    { 0, 61,  91,  128,  170,  219  },
+    { 0, 89,  131, 182,  240,  307  },
+    { 0, 129, 186, 254,  331,  419  },
+    { 0, 177, 256, 350,  457,  579  },
+    { 0, 273, 381, 506,  646,  803  },
+    { 0, 325, 461, 620,  800,  1003 },
+    { 0, 489, 686, 914,  1171, 1459 },
+    { 0, 581, 816, 1088, 1395, 1739 }
+};
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new rogue_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct rogue_botAI : public bot_minion_ai
+    {
+        rogue_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_ROGUE;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_ROGUE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { comboPoints = 0; tempComboPoints = 0; bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/)
+        {}
+
+        //This method should be used to emulate energy usage reduction
+        void modenergy(int32 mod, bool set = false)
+        {
+            //can't set enery to -x (2 cases)
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && energy < uint32(abs(mod)))
+            {
+                mod = 0;
+                set = true;
+            }
+
+            if (set)
+                energy = mod;
+            else
+                energy += mod;
+
+            energy = std::min<uint32>(energy, 100);
+            me->SetPower(POWER_ENERGY, energy);
+        }
+
+        uint32 getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+            return energy;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_ROGUE))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            comboPoints = std::min<uint8>(comboPoints, 5);
+            //AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //Blade Flurry (434 deprecated)
+            if (IsSpellReady(BLADE_FLURRY_1, diff, false) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                Rand() < 30 && getenergy() >= 25 && FindSplashTarget(7, opponent))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLADE_FLURRY_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //KICK
+            if (IsSpellReady(KICK_1, diff, false) && meleedist <= 5 && Rand() < 80 && getenergy() >= 25 &&
+                opponent->IsNonMeleeSpellCast(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(KICK_1)))
+                {
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //SHADOWSTEP
+            if (IsSpellReady(SHADOWSTEP_1, diff, false) && HasRole(BOT_ROLE_DPS) && dist < 25 &&
+                (opponent->GetVictim() != me || opponent->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 30 && getenergy() >= 10)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(SHADOWSTEP_1)))
+                {
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //BACKSTAB
+            if (IsSpellReady(BACKSTAB_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints < 4 &&
+                /*Rand() < 90 && */getenergy() >= 60 && !opponent->HasInArc(M_PI, me))
+            {
+                if (doCast(opponent, GetSpell(BACKSTAB_1)))
+                    return;
+            }
+            //SINISTER STRIKE
+            if (IsSpellReady(SINISTER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints < 5 &&
+                Rand() < 25 && getenergy() >= 45)
+            {
+                if (doCast(opponent, GetSpell(SINISTER_STRIKE_1)))
+                    return;
+            }
+            //SLICE AND DICE
+            if (IsSpellReady(SLICE_DICE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && comboPoints > 1 && getenergy() >= 25 &&
+                (b_attackers.size() <= 1 || !IsSpellReady(BLADE_FLURRY_1, diff)) && Rand() < 30)
+            {
+                if (doCast(opponent, GetSpell(SLICE_DICE_1)))
+                    return;
+            }
+            //KIDNEY SHOT
+            if (IsSpellReady(KIDNEY_SHOT_1, diff) && meleedist <= 5 && comboPoints > 0 &&
+                !CCed(opponent) && getenergy() >= 25 && ((Rand() < 15 + comboPoints*15 && opponent->GetVictim() == me && comboPoints > 2) || opponent->IsNonMeleeSpellCast(false)))
+            {
+                if (doCast(opponent, GetSpell(KIDNEY_SHOT_1)))
+                    return;
+            }
+            //EVISCERATE
+            if (IsSpellReady(EVISCERATE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints > 2 &&
+                getenergy() >= 35 && Rand() < comboPoints*15)
+            {
+                uint32 EVISCERATE = GetSpell(EVISCERATE_1);
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(EVISCERATE);
+                uint8 rank = spellInfo->GetRank();
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                float combo = float(comboPoints);
+                int32 damage = int32(urand(EVSCRDamage[rank][comboPoints][DMGMIN], EVSCRDamage[rank][comboPoints][DMGMAX]));//base damage
+                damage += irand(int32(ap*combo*0.03f), int32(ap*combo*0.07f));//ap bonus
+
+                currentSpell = EVISCERATE;
+                me->CastCustomSpell(opponent, EVISCERATE, &damage, NULL, NULL, false);
+                return;
+            }
+            //MUTILATE
+            //if (isTimerReady(Mutilate_Timer) && energy>60)
+            //{
+            //    // TODO: calculate correct dmg for mutilate (dont forget poison bonus)
+            //    // for now use same formula as evicerate
+            //    uint32 base_attPower = me->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+            //    //float minDmg = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            //    float minDmg = me->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+            //    int damage = irand(int32(base_attPower*7*0.03f),int32(base_attPower*7*0.08f))+minDmg+me->getLevel();
+
+            //    // compensate for lack of attack power
+            //    damage = damage*(rand()%4+1);
+
+            //    me->CastCustomSpell(opponent, MUTILATE, &damage, NULL, NULL, false, NULL, NULL);
+
+            //    //doCast (me, MUTILATE);
+            //    Mutilate_Timer = 10;
+            //    comboPoints+=3;
+            //    energy -= 60;
+            //}
+
+            //RUPTURE
+            if (IsSpellReady(RUPTURE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints > 3 && getenergy() >= 25 &&
+                opponent->GetHealth() > me->GetMaxHealth()/3 && Rand() < (50 + 70 * opponent->isMoving()))
+            {
+                uint32 RUPTURE = GetSpell(RUPTURE_1);
+                //no damage range for rupture
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(RUPTURE);
+                uint8 rank = spellInfo->GetRank();
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                float AP_per_combo[6] = {0.0f, 0.015f, 0.024f, 0.03f, 0.03428571f, 0.0375f};
+                float divider[6] = {0.0f, 4.f, 5.f, 6.f, 7.f, 8.f};//duration/2 = number of ticks
+                int32 damage = int32(RuptureDamage[rank][comboPoints]/divider[comboPoints]);//base damage
+                damage += int32(ap*AP_per_combo[comboPoints]);//ap bonus is strict - applied to every tick
+
+                currentSpell = RUPTURE;
+                me->CastCustomSpell(opponent, RUPTURE, &damage, NULL, NULL, false);
+                return;
+            }
+            //DISMANTLE
+            if (IsSpellReady(DISMANTLE_1, diff, false) && meleedist <= 5 && opponent->GetTypeId() == TYPEID_PLAYER &&
+                Rand() < 20 && getenergy() >= 25 && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) || opponent->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(DISMANTLE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Puncturing Wounds: 30% additional critical chance for Backstab
+                if (lvl >= 15 && spellId == GetSpell(BACKSTAB_1))
+                    aftercrit += 30.f;
+                //Puncturing Wounds: 15% additional critical chance for Mutilate
+                else if (spellId == GetSpell(MUTILATE_1))
+                    aftercrit += 15.f;
+                //Glyph of Eviscerate: 10% additional critical chance for Eviscerate
+                else if (spellId == GetSpell(EVISCERATE_1))
+                    aftercrit += 10.f;
+                //Improved Ambush: 60% additional critical chance for Ambush
+                //else if (spellId == AMBUSH)
+                //    crit_chance += 60.f;
+                if (lvl >= 50 && spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS) && me->HasAura(TURN_THE_TABLES_EFFECT))
+                    aftercrit += 6.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Lethality: 30% crit damage bonus for non-stealth combo-generating abilities (on 25 lvl)
+                if (lvl >= 25 && !(spellInfo->Attributes & SPELL_ATTR0_ONLY_STEALTHED) &&
+                    spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS))
+                    pctbonus += 0.15f;
+            }
+            //Shadowstep: 20% bonus damage to all abilities once
+            //if (shadowstep == true)
+            //{
+            //    shadowstep = false;
+            //    me->RemoveAurasDueToSpell(SHADOWSTEP_EFFECT_DAMAGE);
+            //    pctbonus += 0.2f;
+            //}
+            //Find Weakness: 6% bonus damage to all abilities
+            if (lvl >= 45)
+                pctbonus += 0.06f;
+            //DeathDealer set bonus: 15% damage bonus for Eviscerate
+            if (lvl >= 60 && spellId == GetSpell(EVISCERATE_1))
+                pctbonus += 0.15f;
+            //Imoroved Eviscerate: 20% damage bonus for Eviscerate
+            if (spellId == GetSpell(EVISCERATE_1))
+                pctbonus += 0.2f;
+            //Opportunity: 20% damage bonus for Backstab, Mutilate, Garrote and Ambush
+            if (spellId == GetSpell(BACKSTAB_1) || spellId == GetSpell(MUTILATE_1)/* ||
+                spellId == GARROTE || spellId == AMBUSH*/)
+                pctbonus += 0.2f;
+            //Aggression: 15% damage bonus for Sinister Strike, Backstab and Eviscerate
+            if (lvl >= 30 && (spellId == GetSpell(SINISTER_STRIKE_1) || spellId == GetSpell(BACKSTAB_1) || spellId == GetSpell(EVISCERATE_1)))
+                pctbonus += 0.15f;
+            //Blood Spatter: 30% bonus damage for Rupture and Garrote
+            if (lvl >= 15 && (spellId == GetSpell(RUPTURE_1)/* || spellId == GARROTE*/))
+                pctbonus += 0.3f;
+            //Serrated Blades: 30% bonus damage for Rupture
+            if (lvl >= 20 && spellId == GetSpell(RUPTURE_1))
+                pctbonus += 0.3f;
+            //Surprise Attacks: 10% bonus damage for Sinister Strike, Backstab, Shiv, Hemmorhage and Gouge
+            if (lvl >= 50 && (spellId == GetSpell(SINISTER_STRIKE_1) || spellId == GetSpell(BACKSTAB_1)/* ||
+                spellId == SHIV || spellId == HEMMORHAGE || spellId == GOUGE*/))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            uint32 WOUND_POISON = GetSpell(WOUND_POISON_1);
+            uint32 MIND_NUMBING_POISON = GetSpell(MIND_NUMBING_POISON_1);
+            if (!WOUND_POISON && !MIND_NUMBING_POISON)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                if (victim && me->GetExactDist(victim) <= 40)
+                {
+                    switch (rand()%2)
+                    {
+                        case 0:
+                            break;
+                        case 1:
+                        {
+                            switch (rand()%2)
+                            {
+                                case 0:
+                                    if (WOUND_POISON)
+                                    {
+                                        currentSpell = WOUND_POISON;
+                                        DoCast(victim, WOUND_POISON, true);
+                                    }
+                                    break;
+                                case 1:
+                                    if (MIND_NUMBING_POISON)
+                                    {
+                                        currentSpell = MIND_NUMBING_POISON;
+                                        DoCast(victim, MIND_NUMBING_POISON, true);
+                                    }
+                                    break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //combo points use up
+            if (spellId == GetSpell(SLICE_DICE_1))
+            {
+                SetSpellCooldown(SLICE_DICE_1, 15000 + (tempComboPoints-1)*4500); //no initial cooldown
+                GC_Timer = 800;
+
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    uint32 dur = dice->GetDuration();
+                    dur += tempComboPoints * 3000; //use cp
+                    dur += 6000; // Glyph of Slice and Dice
+                    dur = (dur * 3) / 2; //Improved Slice and Dice
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                }
+            }
+            else if (spellId == GetSpell(RUPTURE_1))
+            {
+                SetSpellCooldown(RUPTURE_1, 8000 + (tempComboPoints-1)*2000 + 4000); //no initial cooldown
+                GC_Timer = 800;
+
+                if (Aura* rupture = target->GetAura(GetSpell(RUPTURE_1), me->GetGUID()))
+                {
+                    uint32 dur = rupture->GetDuration() + tempComboPoints*2000; //use cp
+                    dur += 4000; //Glyph of Rupture
+                    rupture->SetDuration(dur);
+                    rupture->SetMaxDuration(dur);
+                }
+            }
+            else if (spellId == GetSpell(KIDNEY_SHOT_1))
+            {
+                if (Aura* kidney = target->GetAura(GetSpell(KIDNEY_SHOT_1), me->GetGUID()))
+                {
+                    uint32 dur = kidney->GetDuration() + tempComboPoints*1000;
+                    kidney->SetDuration(dur);
+                    kidney->SetMaxDuration(dur);
+                }
+            }
+
+            if (currentSpell == 0)
+                return;
+
+            //BONUS CP MANAGEMENT
+
+            //if (spellId == EVISCERATE || spellId == KIDNEY_SHOT || spellId == SLICE_DICE || spellId == RUPTURE/* || spellId == EXPOSE_ARMOR || spellId == ENVENOM*/)
+            //Relentless Strikes
+            if (spell->NeedsComboPoints())
+            {
+                //std::ostringstream msg;
+                //msg << "casting ";
+                //if (spellId == EVISCERATE)
+                //    msg << "Eviscerate, ";
+                //else if (spellId == RUPTURE)
+                //    msg << "Rupture, ";
+                //else if (spellId == SLICE_DICE)
+                //    msg << "Slice and Dice, ";
+                //else if (spellId == KIDNEY_SHOT)
+                //    msg << "Kidney Shot, ";
+                ////else if (spellId == EXPOSE_ARMOR)
+                ////    msg << "Expose Armor, ";
+                ////else if (spellId == ENVENOM)
+                ////    msg << "Envenom, ";
+                //msg << "combo points: " << uint32(std::min<uint32>(comboPoints,5));
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
+                {
+                    currentSpell = RELENTLESS_STRIKES_EFFECT;
+                    DoCast(me, RELENTLESS_STRIKES_EFFECT, true);
+                }
+                tempComboPoints = comboPoints;
+                //CP adding effects are handled before actual finisher so use temp value
+                //std::ostringstream msg2;
+                //msg2 << "cp set to 0";
+                if (tempAddCP)
+                {
+                    //msg2 << " + " << uint32(tempAddCP) << " (temp)";
+                    comboPoints = tempAddCP;
+                    tempAddCP = 0;
+                }
+                else
+                    comboPoints = 0;
+                //me->MonsterWhisper(msg2.str().c_str(), master->GetGUID());
+            }
+            else if (spellId == GetSpell(SINISTER_STRIKE_1) ||
+                spellId == GetSpell(BACKSTAB_1)/* ||
+                spellId == GOUGE ||
+                spellId == HEMORRHAGE*/)
+            {
+                ++comboPoints;
+                //std::ostringstream msg;
+                //msg << "1 cp generated ";
+                //if (spellId == SINISTER_STRIKE)
+                //    msg << "(Sinister Strike)";
+                //else if (spellId == BACKSTAB)
+                //    msg << "(Backstab)";
+                //msg << " set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == GetSpell(MUTILATE_1)/* ||
+                spellId == AMBUSH*/)
+            {
+                comboPoints += 2;
+                //std::ostringstream msg;
+                //msg << "2 cp generated (Mutilate), set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == SEAL_FATE_EFFECT || spellId == RUTHLESSNESS_EFFECT)
+            {
+                ++tempAddCP;
+                //std::ostringstream msg;
+                //msg << "1 temp cp generated ";
+                //if (spellId == SEAL_FATE_EFFECT)
+                //    msg << "(Seal Fate)";
+                //else if (spellId == RUTHLESSNESS_EFFECT)
+                //    msg << "(Ruthleness)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+            }
+
+            //Glyph of Sinister Strike (20% to add cp on hit)
+            //Seal Fate means crit so this glyph is enabled from lvl 35)
+            //as addition always add cp on ss crit
+            if (currentSpell == GetSpell(SINISTER_STRIKE_1) && (spellId == SEAL_FATE_EFFECT || urand(0,100) >= 20))
+            {
+                ++tempAddCP;
+                //me->MonsterWhisper("1 temp cp generated (glyph of SS)", master->GetGUID());
+            }
+
+            //ENERGY COST REDUCTION
+
+            if (spellId == GetSpell(SINISTER_STRIKE_1))
+            {
+                //Improved Sinister Strike
+                //instead of restoring energy we should override current value
+                if (me->getLevel() >= 10)
+                    modenergy(-40, true);//45 - 5
+            }
+            //Slaughter from the Shadows energy restore
+            //instead of restoring energy we should override current value
+            if (me->getLevel() >= 55)
+            {
+                if (spellId == GetSpell(BACKSTAB_1)/* || spellId == AMBUSH*/)
+                    modenergy(-40, true);
+                //else if (spellId == HEMORRHAGE)
+                //    modenergy(-30, true);
+            }
+
+            //OTHER
+
+            if (spellId == GetSpell(EVISCERATE_1))
+            {
+                //Eviscerate speedup
+                GC_Timer = 800;
+
+                //Serrated Blades: Eviscerate has 20% chance per cp to refresh Rupture
+                //getting cheaty - remove roll
+                //getting cheaty - increase duration
+                //if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
+                {
+                    if (Aura* rupture = target->GetAura(GetSpell(RUPTURE_1), me->GetGUID()))
+                    {
+                        int32 dur = rupture->GetMaxDuration() + 2000;
+                        dur = std::min<int32>(dur, 30000);
+                        rupture->SetDuration(dur);
+                        rupture->SetMaxDuration(dur);
+                        SetSpellCooldown(RUPTURE_1, dur - 2000); //no initial cooldown
+                    }
+                }
+            }
+
+            //Cut to the Chase: Eviscerate and Envenom will refresh Slice and Dice duration
+            //getting cheaty - increase duration
+            if (spellId == GetSpell(EVISCERATE_1)/* || spellId == ENVENOM*/)
+            {
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    int32 dur = dice->GetMaxDuration() + 2000;
+                    dur = std::min<int32>(dur, 59000);
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                    SetSpellCooldown(SLICE_DICE_1, dur - 2000); //no initial cooldown
+                }
+            }
+
+            //Murderous Intent: When Backstabbing enemy that is below 35% hp, instantly restoring 30 energy
+            if (spellId == GetSpell(BACKSTAB_1))
+            {
+                if (target->HealthBelowPct(35))
+                {
+                    //since talent doesn't work just restore energy manually
+                    //DoCast(me, MURDEROUS_INTENT_EFFECT, true);
+                    modenergy(30);
+                }
+            }
+
+            //Waylay
+            if ((spellId == GetSpell(BACKSTAB_1)/* || spellId == AMBUSH*/) &&
+                me->getLevel() >= 20)
+            {
+                DoCast(target, WAYLAY_EFFECT, true);
+            }
+
+            //if (spellId == SHADOWSTEP)
+            //{
+            //    Shadowstep_eff_Timer = 10000;
+            //    shadowstep = true;
+            //}
+
+            //move behind on Kidney Shot and Gouge (optionally)
+            if (spellId == GetSpell(KIDNEY_SHOT_1)/* || spellId == GOUGE*/)
+                if (MoveBehind(*target))
+                    wait = 3;
+
+            if (spellId == currentSpell)
+                currentSpell = 0;
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            comboPoints = 0;
+            tempComboPoints = 0;
+            tempAddCP = 0;
+
+            tempDICE = false;
+            //shadowstep = false;
+
+            me->setPowerType(POWER_ENERGY);
+            //10 energy gained per stack
+            DefaultInit();
+
+            RefreshAura(GLADIATOR_VIGOR, 10);
+
+            me->SetPower(POWER_ENERGY, me->GetMaxPower(POWER_ENERGY));
+        }
+
+        void ReduceCD(uint32 /*diff*/)
+        {
+            //if (Shadowstep_eff_Timer > diff)        Shadowstep_eff_Timer -= diff;
+            //else if (shadowstep)                    shadowstep = false;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(BACKSTAB_1);
+            InitSpellMap(SINISTER_STRIKE_1);
+            InitSpellMap(SLICE_DICE_1);
+            InitSpellMap(EVISCERATE_1);
+            InitSpellMap(KICK_1);
+            InitSpellMap(RUPTURE_1);
+            InitSpellMap(KIDNEY_SHOT_1);
+            lvl >= 50 ? InitSpellMap(MUTILATE_1) : RemoveSpell(MUTILATE_1);
+            lvl >= 50 ? InitSpellMap(SHADOWSTEP_1) : RemoveSpell(SHADOWSTEP_1);
+            InitSpellMap(DISMANTLE_1);
+            lvl >= 30 ? InitSpellMap(BLADE_FLURRY_1) : RemoveSpell(BLADE_FLURRY_1);
+
+            InitSpellMap(WOUND_POISON_1);
+            InitSpellMap(MIND_NUMBING_POISON_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(COMBAT_POTENCY5, level >= 70 ? 2 : level >= 55 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY4, level >= 52 && level < 55 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY3, level >= 49 && level < 52 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY2, level >= 47 && level < 49 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY1, level >= 45 && level < 47 ? 1 : 0);
+            RefreshAura(SEAL_FATE5, level >= 35 ? 1 : 0);
+            RefreshAura(SEAL_FATE4, level >= 32 && level < 35 ? 1 : 0);
+            RefreshAura(SEAL_FATE3, level >= 29 && level < 32 ? 1 : 0);
+            RefreshAura(SEAL_FATE2, level >= 27 && level < 29 ? 1 : 0);
+            RefreshAura(SEAL_FATE1, level >= 25 && level < 27 ? 1 : 0);
+            RefreshAura(VITALITY, level >= 70 ? 3 : level >= 55 ? 2 : level >= 40 ? 1 : 0);
+            RefreshAura(TURN_THE_TABLES, level >= 55 ? 1 : 0);
+            RefreshAura(DEADLY_BREW, level >= 40 ? 1 : 0);
+            RefreshAura(BLADE_TWISTING1, level >= 35 ? 1 : 0);
+            RefreshAura(QUICK_RECOVERY2, level >= 35 ? 1 : 0);
+            RefreshAura(QUICK_RECOVERY1, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(IMPROVED_KIDNEY_SHOT, level >= 30 ? 1 : 0);
+            RefreshAura(GLYPH_BACKSTAB, level >= 10 ? 1 : 0);
+            RefreshAura(SURPRISE_ATTACKS, level >= 10 ? 1 : 0);
+            RefreshAura(ROGUE_VIGOR, level >= 25 ? 2 : level >= 20 ? 1 : 0);
+        }
+
+    private:
+        uint32 energy;
+        uint8 comboPoints, tempComboPoints, tempAddCP;
+        bool tempDICE/*, shadowstep*/;
+
+        enum RogueBaseSpells
+        {
+            BACKSTAB_1                          = 53,
+            SINISTER_STRIKE_1                   = 1757,
+            SLICE_DICE_1                        = 5171,
+            EVISCERATE_1                        = 2098,
+            KICK_1                              = 1766,
+            RUPTURE_1                           = 1943,
+            KIDNEY_SHOT_1                       = 408,
+  /*Talent*/MUTILATE_1                          = 1329,
+  /*Talent*/SHADOWSTEP_1                        = 36554,
+            DISMANTLE_1                         = 51722,
+            BLADE_FLURRY_1                      = 13877,
+        //Special
+            WOUND_POISON_1                      = 13218,
+            MIND_NUMBING_POISON_1               = 5760
+        };
+
+        enum RoguePassives
+        {
+            //Talents
+            SEAL_FATE1                          = 14189,
+            SEAL_FATE2                          = 14190,
+            SEAL_FATE3                          = 14193,
+            SEAL_FATE4                          = 14194,
+            SEAL_FATE5                          = 14195,
+            COMBAT_POTENCY1                     = 35541,
+            COMBAT_POTENCY2                     = 35550,
+            COMBAT_POTENCY3                     = 35551,
+            COMBAT_POTENCY4                     = 35552,
+            COMBAT_POTENCY5                     = 35553,
+            QUICK_RECOVERY1                     = 31244,
+            QUICK_RECOVERY2                     = 31245,
+            BLADE_TWISTING1                     = 31124,
+            //BLADE_TWISTING2                     = 31126,
+            VITALITY                            = 61329,//rank 3
+            DEADLY_BREW                         = 51626,//rank 2
+            IMPROVED_KIDNEY_SHOT                = 14176,//rank 3
+            TURN_THE_TABLES                     = 51629,//rank 3
+            SURPRISE_ATTACKS                    = 32601,
+            ROGUE_VIGOR                         = 14983,
+            //Other
+            //ROGUE_ARMOR_ENERGIZE/*Deathmantle*/ = 27787,
+            GLADIATOR_VIGOR                     = 21975,
+            GLYPH_BACKSTAB                      = 56800
+        };
+
+        enum RogueSpecial
+        {
+            RELENTLESS_STRIKES_EFFECT           = 14181,
+            RUTHLESSNESS_EFFECT                 = 14157,
+            SEAL_FATE_EFFECT                    = 14189,
+            //SHADOWSTEP_EFFECT_DAMAGE            = 36563,
+            TURN_THE_TABLES_EFFECT              = 52910,//'rank 3'
+            WAYLAY_EFFECT                       = 51693,
+            //434
+            MURDEROUS_INTENT_EFFECT             = 79132
+        };
+    };
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..fa331a6
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
@@ -0,0 +1,1340 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "Totem.h"
+/*
+Shaman NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - around 30%
+TODO:
+*/
+enum TotemSlot
+{
+    T_FIRE  = 0,//m_SummonSlot[1]
+    T_EARTH = 1,//m_SummonSlot[2]
+    T_WATER = 2,//m_SummonSlot[3]
+    T_AIR   = 3,//m_SummonSlot[4]
+    MAX_TOTEMS
+};
+struct TotemParam
+{
+    TotemParam() : effradius(0.f) {}
+    Position pos;
+    float effradius;
+};
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new shaman_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct shaman_botAI : public bot_minion_ai
+    {
+        shaman_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_SHAMAN;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_SHAMAN) != SPELL_CAST_OK)
+                return false;
+
+            bool maelstrom = false;
+            if (!triggered)
+                maelstrom = (MaelstromCount >= 5 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) || spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(HEALING_WAVE_1) || spellId == GetSpell(LESSER_HEALING_WAVE_1) ||
+                spellId == GetSpell(CHAIN_HEAL_1) || spellId == GetSpell(HEX_1)));
+
+            triggered |= maelstrom;
+
+            bool result = bot_ai::doCast(victim, spellId, triggered, me->GetGUID());
+
+            if (result && maelstrom)
+            {
+                MaelstromCount = 0;
+                me->RemoveAurasDueToSpell(MAELSTROM_WEAPON_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            return result;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        bool Shielded(Unit* target) const
+        {
+            return
+                (HasAuraName(target, WATER_SHIELD_1) ||
+                HasAuraName(target, EARTH_SHIELD_1) ||
+                HasAuraName(target, LIGHTNING_SHIELD_1));
+        }
+
+        void CheckBloodlust(uint32 diff)
+        {
+            if (!IsSpellReady(BLOODLUST_1, diff, false) || me->GetDistance(master) > 18 || IsCasting() || Rand() > 15)
+                return;
+            if (!me->IsInCombat() || !master->IsInCombat())
+                return;
+
+            if (HasAuraName(master, BLOODLUST_1))
+            {
+                SetSpellCooldown(BLOODLUST_1, 3000); //fail
+                return;
+            }
+
+            if (Unit* u = me->GetVictim())
+            {
+                Creature* cre = u->ToCreature();
+                if (u->GetMaxHealth() > me->GetHealth() * 2 ||
+                    (cre && (cre->IsDungeonBoss() || cre->isWorldBoss())) ||
+                    me->getAttackers().size() + master->getAttackers().size() > 5)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(BLOODLUST_1)))
+                    {
+                        SetSpellCooldown(BLOODLUST_1, 300000); //5 minutes
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+
+            SetSpellCooldown(BLOODLUST_1, 2000); //fail
+        }
+
+        void CheckTotems(uint32 diff)
+        {
+            //update rate
+            if (Rand() > 25)
+                return;
+            //Unsummon
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0)
+                {
+                    if (master->GetDistance2d(_totems[i].second.pos.m_positionX, _totems[i].second.pos.m_positionY) > _totems[i].second.effradius &&
+                        me->GetDistance2d(_totems[i].second.pos.m_positionX, _totems[i].second.pos.m_positionY) > _totems[i].second.effradius)
+                    {
+                        Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
+                        if (!to)
+                        {
+                            _totems[i].first = 0;
+                            //TC_LOG_ERROR("entities.player", "%s has lost totem in slot %u! Despawned normally?", me->GetName().c_str(), i);
+                            continue;
+                        }
+
+                        to->ToTotem()->UnSummon();
+                    }
+                }
+            }
+            if (GC_Timer > diff || IsCasting() || me->GetDistance(master) > 15 || Feasting())
+                return;
+            //Summon
+            //TODO: role-based totems (attack/heal)
+            if (me->IsInCombat())
+            {
+                if (GetSpell(WINDFURY_TOTEM_1) && !_totems[T_AIR].first && !master->m_SummonSlot[T_AIR+1])
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(WINDFURY_TOTEM_1)))
+                    {
+                        if (me->getLevel() >= 57)
+                            GC_Timer = temptimer;
+                        return;
+                    }
+                }
+
+                if (!_totems[T_EARTH].first && !master->m_SummonSlot[T_EARTH+1])
+                {
+                    if (GetSpell(STRENGTH_OF_EARTH_TOTEM_1))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(STRENGTH_OF_EARTH_TOTEM_1)))
+                        {
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (GetSpell(STONESKIN_TOTEM_1))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(STONESKIN_TOTEM_1)))
+                        {
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+
+                if (!_totems[T_FIRE].first && !master->m_SummonSlot[T_FIRE+1])
+                {
+                    if (IsSpellReady(TOTEM_OF_WRATH_1, diff, false))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(TOTEM_OF_WRATH_1)))
+                        {
+                            //bot's poor AI cannot use totems wisely so just reduce CD on this
+                            //SetSpellCooldown(TOTEM_OF_WRATH_1, 30000); //30 sec, old 5 min
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (IsSpellReady(SEARING_TOTEM_1, diff, false))
+                    {
+                        if (Unit* u = me->GetVictim())
+                        {
+                            if (HasRole(BOT_ROLE_DPS) && me->GetExactDist(u) < (u->isMoving() ? 10 : 25))
+                            {
+                                temptimer = GC_Timer;
+                                if (doCast(me, GetSpell(SEARING_TOTEM_1)))
+                                {
+                                    if (me->getLevel() >= 57)
+                                        GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            if (!me->isMoving() && !master->isMoving())
+            {
+                if (!_totems[T_WATER].first && !master->m_SummonSlot[T_WATER+1])
+                {
+                    uint8 manapct = GetManaPCT(master);
+                    uint8 hppct = GetHealthPCT(master);
+                    if (GetSpell(HEALINGSTREAM_TOTEM_1) && hppct < 98 && master->getPowerType() != POWER_MANA &&
+                        (hppct < 25 || manapct > hppct))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(HEALINGSTREAM_TOTEM_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (GetSpell(MANASPRING_TOTEM_1) && (manapct < 97 || GetManaPCT(me) < 90))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(MANASPRING_TOTEM_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+        }
+
+        void CheckThunderStorm(uint32 diff)
+        {
+            if (!IsSpellReady(THUNDERSTORM_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 25)
+                return;
+
+            //case 1: low mana
+            if (GetManaPCT(me) < 15)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                    GC_Timer = temptimer;
+                return;
+            }
+
+            //case 2: knock attackers
+            if (IsTank()) //pretty stupid idea I think
+                return;
+
+            //AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            if (b_attackers.empty())
+                return;
+
+            uint8 tCount = 0;
+            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if (me->GetExactDist((*iter)) > 9) continue;
+                if (CCed(*iter)) continue;
+                if (me->IsValidAttackTarget(*iter))
+                {
+                    ++tCount;
+                    break;
+                }
+            }
+
+            if (tCount > 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                    GC_Timer = temptimer;
+                return;
+            }
+        }
+
+        void CheckManaTide(uint32 diff)
+        {
+            if (!IsSpellReady(MANA_TIDE_TOTEM_1, diff, false) || IAmFree() || IsCasting() || Rand() > 20)
+                return;
+
+            Group* group = master->GetGroup();
+            if (!group)
+                return;
+
+            uint8 LMPcount = 0;
+            uint8 members = group->GetMembersCount();
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->GetMapId() != me->GetMapId() ||
+                    (!tPlayer->IsAlive() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 20) continue;
+                if (tPlayer->getPowerType() != POWER_MANA) continue;
+                if (GetManaPCT(tPlayer) < 35)
+                {
+                    ++LMPcount;
+                    if (LMPcount > 3 || LMPcount > members / 3) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && bot->getPowerType() == POWER_MANA &&
+                            bot->GetExactDist(me) < 20 && GetManaPCT(bot) < 35)
+                        {
+                            ++LMPcount;
+                            if (LMPcount > 3 || LMPcount > members / 3) break;
+                        }
+                    }
+                }
+            }
+
+            if (LMPcount > 3 || LMPcount > members / 3)
+            {
+                if (_totems[T_WATER].first != 0)
+                {
+                    Unit* to = sObjectAccessor->FindUnit(_totems[T_WATER].first);
+                    if (!to)
+                        _totems[T_WATER].first = 0;
+                    else
+                        to->ToTotem()->UnSummon();
+                }
+                if (doCast(me, GetSpell(MANA_TIDE_TOTEM_1)))
+                    return;
+            }
+
+            SetSpellCooldown(MANA_TIDE_TOTEM_1, 3000); //fail
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckThunderStorm(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            CheckHexy(diff);
+            CheckEarthy(diff);
+
+            if (Potion_cd <= diff && GetManaPCT(me) < 30)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            CheckBloodlust(diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, CURE_TOXINS, diff);
+            CheckManaTide(diff);
+            CheckTotems(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+                CheckDispel(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff myself
+            if (GetSpell(LIGHTNING_SHIELD_1) && !IsTank() && !Shielded(me))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(LIGHTNING_SHIELD_1)))
+                    GC_Timer = temptimer;
+            }
+            //heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_SHAMAN))
+                return;
+
+            CheckHexy2(diff);
+
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!IsSpellReady(WIND_SHEAR_1, diff, false) || Rand() > 60)
+                return;
+
+            Unit* u = me->GetVictim();
+            if (u && u->IsNonMeleeSpellCast(false))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(u, GetSpell(WIND_SHEAR_1)))
+                {
+                    SetSpellCooldown(WIND_SHEAR_1, 5000); //improved
+                    GC_Timer = temptimer;
+                }
+            }
+            else if (Unit* target = FindCastingTarget(25))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(WIND_SHEAR_1)))
+                    GC_Timer = temptimer;
+            }
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            if (IsCasting()) return;
+
+            //STORMSTRIKE
+            if (IsSpellReady(STORMSTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && IsMelee() && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(STORMSTRIKE_1)))
+                    return;
+            }
+            //SHOCKS
+            if ((GetSpell(FLAME_SHOCK_1) || GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1)) &&
+                IsSpellReady(FLAME_SHOCK_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 && Rand() < 30)
+            {
+                temptimer = GC_Timer;
+
+                bool canFlameShock = (GetSpell(FLAME_SHOCK_1) != 0);
+                if (canFlameShock)
+                {
+                    if (Aura* fsh = opponent->GetAura(GetSpell(FLAME_SHOCK_1), me->GetGUID()))
+                        if (fsh->GetDuration() > 3000)
+                            canFlameShock = false;
+                }
+
+                if (canFlameShock)
+                {
+                    if (doCast(opponent, GetSpell(FLAME_SHOCK_1)))
+                    {
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+                else if (GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1))
+                {
+                    uint32 SHOCK = !GetSpell(FROST_SHOCK_1) ? GetSpell(EARTH_SHOCK_1) : RAND(GetSpell(EARTH_SHOCK_1), GetSpell(FROST_SHOCK_1));
+                    if (SHOCK && !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)) &&
+                        !opponent->HasAura(SHOCK))
+                    {
+                        if (doCast(opponent, SHOCK))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+            //LAVA BURST
+            if (IsSpellReady(LAVA_BURST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(LAVA_BURST_1)))
+                    return;
+            }
+
+            if (GetManaPCT(me) < 15 || (MaelstromCount < 5 && IsMelee()))
+                return;
+
+            //CHAIN LIGHTNING
+            if (IsSpellReady(CHAIN_LIGHTNING_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(CHAIN_LIGHTNING_1)))
+                    return;
+            }
+            //LIGHTNING BOLT
+            if (IsSpellReady(LIGHTNING_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30)
+            {
+                uint32 LIGHTNING_BOLT = GetSpell(LIGHTNING_BOLT_1);
+                if (doCast(opponent, LIGHTNING_BOLT))
+                    return;
+            }
+        }
+
+        void CheckHexy(uint32 diff)
+        {
+            if (HexyCheckTimer <= diff)
+            {
+                Hexy = FindAffectedTarget(GetSpell(HEX_1), me->GetGUID());
+                HexyCheckTimer = 2000;
+            }
+        }
+
+        void CheckHexy2(uint32 diff)
+        {
+            if (Hexy == false && me->GetVictim() && IsSpellReady(HEX_1, diff, false))
+            {
+                if (Unit* target = FindPolyTarget(20, me->GetVictim()))
+                {
+                    if (doCast(target, GetSpell(HEX_1)))
+                    {
+                        Hexy = true;
+                        HexyCheckTimer += 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckEarthy(uint32 diff)
+        {
+            if (EarthyCheckTimer <= diff)
+            {
+                Unit* u = FindAffectedTarget(GetSpell(EARTH_SHIELD_1), me->GetGUID(), 90.f, 3);
+                Earthy = (u && (IsTank(u) || u == master));
+                EarthyCheckTimer = 1000;
+            }
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(ANCESTRAL_SPIRIT_1), master);
+
+            if (Feasting()) return;
+
+            if (Shielded(me) && Rand() < 25)
+            {
+                Aura* shield = NULL;
+                uint32 SHIELD = HasRole(BOT_ROLE_DPS) ? GetSpell(LIGHTNING_SHIELD_1) : 0;
+                if (SHIELD)
+                    shield = me->GetAura(SHIELD);
+                if (!shield && IsTank() && GetSpell(EARTH_SHIELD_1))
+                {
+                    SHIELD = GetSpell(EARTH_SHIELD_1);
+                    shield = me->GetAura(SHIELD);
+                }
+                if (!shield && GetSpell(WATER_SHIELD_1))
+                {
+                    SHIELD = GetSpell(WATER_SHIELD_1);
+                    shield = me->GetAura(SHIELD);
+                }
+                if (shield && shield->GetCharges() < 5)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, SHIELD))
+                    {
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!GetSpell(WATER_WALKING_1) && !GetSpell(WATER_BREATHING_1) && !GetSpell(EARTH_SHIELD_1))
+                return false;
+
+            if (GC_Timer > diff || !target || !target->IsAlive() || Rand() > 40)
+                return false;
+
+            if (GetSpell(EARTH_SHIELD_1) && Earthy == false && (target == master || IsTank(target)) &&
+                (target->IsInCombat() || !target->isMoving()) &&
+                me->GetExactDist(target) < 40 && Rand() < 75)
+            {
+                bool cast = !Shielded(target);
+                if (!cast)
+                    if (Aura* eShield = target->GetAura(GetSpell(EARTH_SHIELD_1)))
+                        if (eShield->GetCharges() < 5)
+                            cast = true;
+                if (cast && doCast(target, GetSpell(EARTH_SHIELD_1)))
+                {
+                    Earthy = true;
+                    //GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->GetExactDist(target) > 30) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+            {
+                //bots don't need water breathing
+                if (GetSpell(WATER_BREATHING_1) && target->GetTypeId() == TYPEID_PLAYER &&
+                    !target->HasAuraType(SPELL_AURA_WATER_BREATHING) &&
+                    doCast(target, GetSpell(WATER_BREATHING_1)))
+                {
+                    //GC_Timer = 800;
+                    return true;
+                }
+                //water walking breaks on any damage
+                if (GetSpell(WATER_WALKING_1) && target->getAttackers().empty() &&
+                    !target->HasAuraType(SPELL_AURA_WATER_WALK) &&
+                    doCast(target, GetSpell(WATER_WALKING_1)))
+                {
+                    //GC_Timer = 800;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!IsSpellReady(PURGE_1, diff, false) || IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = FindHostileDispelTarget();
+            if (target && doCast(target, GetSpell(PURGE_1)))
+            {}
+
+            SetSpellCooldown(PURGE_1, 2000); //fail
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL))
+                return false;
+            if (hp > 97)
+                return false;
+            if (!target || !target->IsAlive() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid())
+                return false;
+
+            //PLACEHOLDER: Instant spell req. interrupt current spell
+
+            if (IsCasting()) return false;
+
+            if (IsSpellReady(LESSER_HEALING_WAVE_1, diff) &&
+                ((hp > 70 && hp < 85) || hp < 50 || GetLostHP(target) > 1800) && Rand() < 75)
+            {
+                if (doCast(target, GetSpell(LESSER_HEALING_WAVE_1)))
+                    return true;
+            }
+            if (IsSpellReady(HEALING_WAVE_1, diff) &&
+                hp > 40 && (hp < 75 || GetLostHP(target) > 4000) && Rand() < 65)
+            {
+                if (doCast(target, GetSpell(HEALING_WAVE_1)))
+                    return true;
+            }
+            if (IsSpellReady(CHAIN_HEAL_1, diff) &&
+                ((hp > 40 && hp < 90) || GetLostHP(target) > 1300) && Rand() < 120)
+            {
+                if (IsSpellReady(RIPTIDE_1, diff, false) && (hp < 85 || GetLostHP(target) > 2500) &&
+                    !target->HasAura(GetSpell(RIPTIDE_1)))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(target, GetSpell(RIPTIDE_1), true))
+                    {
+                        if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                }
+                else if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                ////Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+                //if (lvl >= 15 && spellId == CLEAVE /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
+                //    aftercrit += 15.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.25f;
+            }
+
+            //SHAMAN_T8_ENCHANCEMENT_2P_BONUS: 20% bonus damage for Lava Lash and Stormstrike
+            if (lvl >= 60 &&
+                (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND/* || spellId == LAVA_LASH*/))
+                pctbonus += 0.2f;
+
+            //custom bonus to make stormstrike useful
+            if (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND)
+                pctbonus += 1.0f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Call of Thunder: 5% additional critical chance for Lightning Bolt, Chain Lightning and Thunderstorm
+                if (lvl >= 30 &&
+                    (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                    spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                    spellId == GetSpell(THUNDERSTORM_1)))
+                    aftercrit += 5.f;
+                //Tidal Mastery (part 2): 5% additional critical chance for lightning spells
+                if (lvl >= 25 && (SPELL_SCHOOL_MASK_NATURE & spellInfo->GetSchoolMask()))
+                    aftercrit += 5.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.333f;
+                //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+                if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+                    pctbonus += 0.16f;
+            }
+            //Concussion: 5% bonus damage for Lightning Bolt, Chain Lightning, Thunderstorm, Lava Burst and Shocks
+            if (lvl >= 10 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(THUNDERSTORM_1) ||
+                spellId == GetSpell(LAVA_BURST_1) ||
+                spellId == GetSpell(EARTH_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1) ||
+                spellId == GetSpell(FLAME_SHOCK_1)))
+                pctbonus += 0.05f;
+            //Call of Flame (part 2): 6% bonus damage for Lava burst
+            if (lvl >= 15 && spellId == GetSpell(LAVA_BURST_1))
+                pctbonus += 0.06f;
+            //Storm, Earth and fire (part 3): 60% bonus damage for Flame Shock (periodic damage in fact but who cares?)
+            if (lvl >= 40 && spellId == GetSpell(FLAME_SHOCK_1))
+                pctbonus += 0.6f;
+            //Booming Echoes (part 2): 20% bonus damage for Flame Shock and Frost Shock (direct damage)
+            if (lvl >= 45 &&
+                (spellId == GetSpell(FLAME_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1)))
+                pctbonus += 0.2f;
+            //Improved Shields (part 1): 15% bonus damage for Lightning Shield orbs
+            if (lvl >= 15 && spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(LIGHTNING_SHIELD_DAMAGE_1)))
+                pctbonus += 0.15f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Healing Way: 25% bonus healing for Healing Wave
+            if (lvl >= 30 && spellId == GetSpell(HEALING_WAVE_1))
+                pctbonus += 0.25f;
+            //Purification: 10% bonus healing for all spells
+            if (lvl >= 35)
+                pctbonus += 0.1f;
+            //Nature's Blessing: 15% of Intellect to healing
+            if (lvl >= 45)
+                flat_mod += me->GetTotalStatValue(STAT_INTELLECT) * 1.0f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            //Improved Chain Heal: 20% bonus healing for Chain Heal
+            if (lvl >= 45 && spellId == GetSpell(CHAIN_HEAL_1))
+                pctbonus += 0.2f;
+            //Improved Earth Shield: 10% bonus healing for Earth Shield
+            //Glyph of Earth Shield: 20% bonus healing for Earth Shield
+            if (lvl >= 50 && spellId == EARTH_SHIELD_HEAL)
+                pctbonus += 0.1f + 0.2f;
+            //Improved Shields (part 3): 15% bonus healing for Earth Shield
+            if (lvl >= 15 && spellId == EARTH_SHIELD_HEAL)
+                pctbonus += 0.15f;
+            //Tidal Waves (part 2): 20% bonus (from spellpower) for Healing Wave and 10% bonus (from spellpower) for Lesser Healing Wave
+            if (lvl >= 55)
+            {
+                if (spellId == GetSpell(HEALING_WAVE_1))
+                    flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+                else if (spellId == GetSpell(LESSER_HEALING_WAVE_1))
+                    flat_mod += spellpower * 0.1f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            }
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassCritMultiplierHeal(Unit const* /*victim*/, float& crit_chance, SpellInfo const* /*spellInfo*/, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float aftercrit = 0.0f;
+
+            //Tidal Mastery (part 1): 5% additional critical chance for healing spells
+            if (lvl >= 25 && (schoolMask & SPELL_SCHOOL_MASK_NATURE))
+                aftercrit += 5.f;
+            //Blessing of the Eternals: 4% additional critical chance for all spells
+            if (lvl >= 45)
+                aftercrit += 4.f;
+
+            crit_chance += aftercrit;
+        }
+
+        void OnBotDespawn(Creature* summon)
+        {
+            if (!summon)
+            {
+                UnsummonAll();
+                return;
+            }
+
+            TempSummon* totem = summon->ToTempSummon();
+            if (!totem || !totem->ToTotem())
+            {
+                TC_LOG_ERROR("entities.player", "SummonedCreatureDespawn(): Shaman bot %s has despawned summon %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:
+                    slot = T_FIRE;
+                    break;
+                case SUMMON_TYPE_TOTEM_EARTH:
+                    slot = T_EARTH;
+                    break;
+                case SUMMON_TYPE_TOTEM_WATER:
+                    slot = T_WATER;
+                    break;
+                case SUMMON_TYPE_TOTEM_AIR:
+                    slot = T_AIR;
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "SummonedCreatureDespawn(): Shaman bot %s has despawned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
+                    return;
+            }
+
+            _totems[slot].first = 0;
+        }
+
+        void OnBotSummon(Creature* summon)
+        {
+            TempSummon* totem = summon->ToTempSummon();
+            if (!totem || !totem->ToTotem())
+            {
+                //TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned creature %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            totem->SetCreatorGUID(me->GetGUID());
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:
+                    slot = T_FIRE;
+                    break;
+                case SUMMON_TYPE_TOTEM_EARTH:
+                    slot = T_EARTH;
+                    break;
+                case SUMMON_TYPE_TOTEM_WATER:
+                    slot = T_WATER;
+                    break;
+                case SUMMON_TYPE_TOTEM_AIR:
+                    slot = T_AIR;
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
+                    return;
+            }
+
+            float radius = 0.f;
+            if (SpellInfo const* info = sSpellMgr->GetSpellInfo(summon->m_spells[0]))
+                if (SpellRadiusEntry const* entry = info->Effects[0].RadiusEntry)
+                    radius = entry->RadiusMax;
+
+            _totems[slot].first = summon->GetGUID();
+            _totems[slot].second.pos.Relocate(*summon);
+            _totems[slot].second.effradius = std::max<float>(radius, 20.f) + 5.f;
+
+            //TC_LOG_ERROR("entities.player", "shaman bot: summoned %s (type %u) at x='%f', y='%f', z='%f'",
+            //    summon->GetName().c_str(), slot, _totems[slot].second.GetPositionX(), _totems[slot].second.GetPositionY(), _totems[slot].second.GetPositionZ());
+
+            summon->SetDisplayId(me->GetModelForTotem(PlayerTotemType(totem->m_Properties->Id)));
+            master->m_SummonSlot[++slot] = 0;
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Maelstrom Weapon improved: 10% to gain full stack and 30% to add an extra stack
+            if (spellId == MAELSTROM_WEAPON_BUFF)
+            {
+                if (Aura* mwb = me->GetAura(MAELSTROM_WEAPON_BUFF))
+                {
+                    uint32 stacks = mwb->GetStackAmount();
+                    if (stacks < 5)
+                    {
+                        if (urand(1,100) <= 10)
+                            mwb->ModStackAmount(5);
+                        if (urand(1,100) <= 30)
+                            mwb->ModStackAmount(1);
+                    }
+
+                    MaelstromCount = mwb->GetStackAmount();
+                }
+
+                MaelstromTimer = 30000; //30 sec duration then reset
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            //Shields improvement, replaces Static Shock (part 2) and Improved Earth Shield (part 1)
+            if (spellId == GetSpell(LIGHTNING_SHIELD_1) ||
+                spellId == GetSpell(EARTH_SHIELD_1)/* ||
+                spellId == GetSpell(WATER_SHIELD_1)*/)
+            {
+                if (Aura* shield = target->GetAura(spellId, me->GetGUID()))
+                {
+                    shield->SetCharges(shield->GetCharges() + 12);
+                }
+            }
+            //Lightning Overload: 20% cast SAME spell with no mana! make sure this does not proc on itself!
+            if (me->getLevel() >= 40 && (spellId == GetSpell(LIGHTNING_SHIELD_1) || spellId == GetSpell(CHAIN_LIGHTNING_1)))
+            {
+                bool cast = (urand(1,100) <= 20);
+                if (spellId == GetSpell(LIGHTNING_BOLT_1))
+                {
+                    if (LOvBolt == false)
+                    {
+                        if (cast)
+                        {
+                            LOvBolt = true;
+                            me->CastSpell(target, spellId, true);
+                        }
+                    }
+                    else
+                        LOvBolt = false;
+                }
+                if (spellId == GetSpell(CHAIN_LIGHTNING_1))
+                {
+                    if (LOvChain == false)
+                    {
+                        if (cast)
+                        {
+                            LOvChain = true;
+                            me->CastSpell(target, spellId, true);
+                        }
+                    }
+                    else
+                        LOvChain = false;
+                }
+            }
+            if (spellId == GetSpell(STORMSTRIKE_1))
+            {
+                //Windfury: 10% chance
+                if (WindfuryTimer == 0 && me->getLevel() >= 30)
+                {
+                    if (urand(0,100) < 10)
+                        WindfuryTimer = 1000;
+
+                    if (WindfuryTimer > 0)
+                        me->CastSpell(target, WINDFURY_PROC, true);
+                }
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE)
+            {
+                //Windfury: 10% chance
+                if (WindfuryTimer == 0 && me->getLevel() >= 30)
+                {
+                    if (urand(0,100) < 10)
+                        WindfuryTimer = 1000;
+
+                    if (WindfuryTimer > 0)
+                        me->CastSpell(victim, WINDFURY_PROC, true);
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void UnsummonAll()
+        {
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0)
+                {
+                    Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
+                    if (!to)
+                    {
+                        //TC_LOG_ERROR("entities.player", "%s has no totem in slot %u during remove!", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+        }
+
+        void Reset()
+        {
+            HexyCheckTimer = 3000;
+            EarthyCheckTimer = 2000;
+            MaelstromTimer = 0;
+            WindfuryTimer = 0;
+
+            MaelstromCount = 0;
+
+            Hexy = false;
+            Earthy = false;
+            LOvBolt = false;
+            LOvChain = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (HexyCheckTimer > diff)          HexyCheckTimer -= diff;
+            if (EarthyCheckTimer > diff)        EarthyCheckTimer -= diff;
+
+            if (MaelstromTimer > diff)          MaelstromTimer -= diff;
+            else if (MaelstromCount > 0)        MaelstromCount = 0;
+
+            if (WindfuryTimer > diff)           WindfuryTimer -= diff;
+            else                                WindfuryTimer = 0;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(HEALING_WAVE_1);
+            InitSpellMap(CHAIN_HEAL_1);
+            InitSpellMap(LESSER_HEALING_WAVE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(RIPTIDE_1) : RemoveSpell(RIPTIDE_1);
+            InitSpellMap(ANCESTRAL_SPIRIT_1);
+            CURE_TOXINS = lvl >= 39 ? InitSpell(me, CLEANSE_SPIRIT_1) : InitSpell(me, CURE_TOXINS_1);
+            InitSpellMap(CURE_TOXINS);
+            InitSpellMap(FLAME_SHOCK_1);
+            InitSpellMap(EARTH_SHOCK_1);
+            InitSpellMap(FROST_SHOCK_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(STORMSTRIKE_1) : RemoveSpell(STORMSTRIKE_1);
+            InitSpellMap(LIGHTNING_BOLT_1);
+            InitSpellMap(CHAIN_LIGHTNING_1);
+            InitSpellMap(LAVA_BURST_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(THUNDERSTORM_1) : RemoveSpell(THUNDERSTORM_1);
+            InitSpellMap(LIGHTNING_SHIELD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(EARTH_SHIELD_1) : RemoveSpell(EARTH_SHIELD_1);
+     /*NYI*///InitSpellMap(WATER_SHIELD_1);
+            InitSpellMap(WATER_BREATHING_1);
+            InitSpellMap(WATER_WALKING_1);
+  /*CUSTOM*/lvl >= 60 ? InitSpellMap(BLOODLUST_1) : RemoveSpell(BLOODLUST_1);
+            InitSpellMap(PURGE_1);
+            InitSpellMap(WIND_SHEAR_1);
+            InitSpellMap(HEX_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(STONESKIN_TOTEM_1) : RemoveSpell(STONESKIN_TOTEM_1);
+            InitSpellMap(HEALINGSTREAM_TOTEM_1);
+            InitSpellMap(MANASPRING_TOTEM_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SEARING_TOTEM_1) : RemoveSpell(SEARING_TOTEM_1);
+            InitSpellMap(WINDFURY_TOTEM_1);
+            InitSpellMap(STRENGTH_OF_EARTH_TOTEM_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(TOTEM_OF_WRATH_1) : RemoveSpell(TOTEM_OF_WRATH_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(MANA_TIDE_TOTEM_1) : RemoveSpell(MANA_TIDE_TOTEM_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(ELEMENTAL_WARDING, level >= 58 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION3, level >= 18 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION2, level >= 15 && level < 18 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION1, level >= 12 && level < 15 ? 1 : 0);
+            RefreshAura(ANCESTRAL_KNOWLEDGE, level >= 30 ? 3 : level >= 20 ? 2 : level >= 10 ? 1 : 0);
+            RefreshAura(TOUGHNESS, level >= 25 ? 1 : 0);
+            RefreshAura(FLURRY5, level >= 29 ? 1 : 0);
+            RefreshAura(FLURRY4, level >= 28 && level < 29 ? 1 : 0);
+            RefreshAura(FLURRY3, level >= 27 && level < 28 ? 1 : 0);
+            RefreshAura(FLURRY2, level >= 26 && level < 27 ? 1 : 0);
+            RefreshAura(FLURRY1, level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(WEAPON_MASTERY, level >= 50 ? 3 : level >= 40 ? 2 : level >= 30 ? 1 : 0);
+            RefreshAura(STATIC_SHOCK, level >= 45 ? 2 : level >= 41 ? 1 : 0);
+            RefreshAura(ANCESTRAL_HEALING, level >= 20 ? 1 : 0);
+            RefreshAura(ANCESTRAL_AWAKENING, level >= 50 ? 1 : 0);
+            RefreshAura(SHAMAN_T10_RESTO_4P, level >= 70 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON5, level >= 70 ? 2 : level >= 60 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON4, level >= 55 && level < 60 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON3, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON2, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON1, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(UNLEASHED_RAGE, level >= 40 ? 1 : 0);
+            RefreshAura(IMPROVED_STORMSTRIKE, level >= 40 ? 1 : 0);
+            RefreshAura(ELEMENTAL_OATH, level >= 40 ? 1 : 0);
+            RefreshAura(EARTHLIVING_WEAPON_PASSIVE_6, level >= 70 ? 3 : 0);
+            RefreshAura(EARTHLIVING_WEAPON_PASSIVE_5, level >= 50 && level < 70 ? 3 : 0);
+            RefreshAura(EARTHLIVING_WEAPON_PASSIVE_4, level >= 30 && level < 50 ? 3 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case HEALING_WAVE_1:
+                case CHAIN_HEAL_1:
+                case LESSER_HEALING_WAVE_1:
+                case RIPTIDE_1:
+                case CURE_TOXINS_1:
+                case CLEANSE_SPIRIT_1:
+                case BLOODLUST_1:
+                case WATER_SHIELD_1:
+                case MANA_TIDE_TOTEM_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        typedef std::pair<uint64 /*guid*/, TotemParam /*param*/> BotTotem;
+        BotTotem _totems[MAX_TOTEMS];
+        uint32 CURE_TOXINS;
+        //Timers
+        uint32 HexyCheckTimer, EarthyCheckTimer, MaelstromTimer, WindfuryTimer;
+        uint8 MaelstromCount;
+        bool Hexy, Earthy, LOvChain, LOvBolt;
+
+        enum ShamanBaseSpells
+        {
+            HEALING_WAVE_1                      = 331,
+            CHAIN_HEAL_1                        = 1064,
+            LESSER_HEALING_WAVE_1               = 8004,
+            RIPTIDE_1                           = 61295,
+            ANCESTRAL_SPIRIT_1                  = 2008,
+            CURE_TOXINS_1                       = 526,
+            CLEANSE_SPIRIT_1                    = 51886,
+            FLAME_SHOCK_1                       = 8050,
+            EARTH_SHOCK_1                       = 8042,
+            FROST_SHOCK_1                       = 8056,
+            STORMSTRIKE_1                       = 17364,
+            LIGHTNING_BOLT_1                    = 403,
+            CHAIN_LIGHTNING_1                   = 421,
+            LAVA_BURST_1                        = 51505,
+            THUNDERSTORM_1                      = 51490,
+            LIGHTNING_SHIELD_1                  = 324,
+            EARTH_SHIELD_1                      = 974,
+            WATER_SHIELD_1                      = 52127,
+            WATER_BREATHING_1                   = 131,
+            WATER_WALKING_1                     = 546,
+            //BLOODLUST_1                         = 54516,//custom, moved to specials
+            PURGE_1                             = 370,
+            WIND_SHEAR_1                        = 57994,
+            HEX_1                               = 51514,
+            STONESKIN_TOTEM_1                   = 8071,
+            HEALINGSTREAM_TOTEM_1               = 5394,
+            MANASPRING_TOTEM_1                  = 5675,
+            SEARING_TOTEM_1                     = 3599,
+            WINDFURY_TOTEM_1                    = 8512,
+            STRENGTH_OF_EARTH_TOTEM_1           = 8075,
+            TOTEM_OF_WRATH_1                    = 30706,
+            MANA_TIDE_TOTEM_1                   = 16190
+        };
+
+        enum ShamanPassives
+        {
+            //Elemental
+            ELEMENTAL_DEVASTATION1              = 30160,
+            ELEMENTAL_DEVASTATION2              = 29179,
+            ELEMENTAL_DEVASTATION3              = 29180,
+            ELEMENTAL_WARDING                   = 28998,//rank 3
+            ELEMENTAL_OATH                      = 51470,//rank 2
+            //Enchancement
+            ANCESTRAL_KNOWLEDGE                 = 17489,//rank 5
+            TOUGHNESS                           = 16309,//rank 5
+            FLURRY1                             = 16256,
+            FLURRY2                             = 16281,
+            FLURRY3                             = 16282,
+            FLURRY4                             = 16283,
+            FLURRY5                             = 16284,
+            WEAPON_MASTERY                      = 29086,//rank 3
+            UNLEASHED_RAGE                      = 30809,//rank 3
+            STATIC_SHOCK                        = 51527,//rank 3
+            IMPROVED_STORMSTRIKE                = 51522,//rank 2
+            MAELSTROM_WEAPON1                   = 51528,
+            MAELSTROM_WEAPON2                   = 51529,
+            MAELSTROM_WEAPON3                   = 51530,
+            MAELSTROM_WEAPON4                   = 51531,
+            MAELSTROM_WEAPON5                   = 51532,
+            //Restoration
+            ANCESTRAL_HEALING                   = 16240,//rank 3
+            ANCESTRAL_AWAKENING                 = 51558,//rank 3
+            //Special
+            SHAMAN_T10_RESTO_4P                 = 70808 //Chain Heal HoT
+        };
+
+        enum ShamanSpecial
+        {
+            //2 extra white attacks
+            //100 yd
+            //"Increases attack power for 1.50 sec"
+            //Warning! can proc even from itself!
+            WINDFURY_PROC                       = 32910,
+            //"Increases melee,ranged and spell casting speed by 35%
+            //for all party members. Lasts 20 sec."
+            //250 mana, 20 yd
+            //affects raid
+            //no penalty
+            BLOODLUST_1                         = 54516,
+            //20% chance to put HoT on healed target over 12 sec
+            EARTHLIVING_WEAPON_PASSIVE_4        = 52005,//348 base hp
+            EARTHLIVING_WEAPON_PASSIVE_5        = 52007,//456 base hp
+            EARTHLIVING_WEAPON_PASSIVE_6        = 52008,//652 base hp
+
+            MAELSTROM_WEAPON_BUFF               = 53817,
+            STORMSTRIKE_DAMAGE                  = 32175,
+            STORMSTRIKE_DAMAGE_OFFHAND          = 32176,
+
+            LIGHTNING_SHIELD_DAMAGE_1           = 26364,
+            EARTH_SHIELD_HEAL                   = 379
+        };
+    };
+};
+
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..d5eac66
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
@@ -0,0 +1,519 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Warlock NpcBot (reworked by Graff onlysuffering@gmail.com)
+Voidwalker pet AI included
+Complete - 3%
+TODO:
+*/
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warlock_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct warlock_botAI : public bot_minion_ai
+    {
+        warlock_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_WARLOCK;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { me->SetBotsPetDied(); bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions() { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+            feartimer = std::max<uint32>(feartimer, 1000);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            ////if pet is dead or unreachable
+            //Creature* m_botsPet = me->GetBotsPet();
+            //if (!m_botsPet || m_botsPet->FindMap() != master->GetMap() || (me->GetDistance2d(m_botsPet) > sWorld->GetMaxVisibleDistanceOnContinents() - 20.f))
+            //    if (master->getLevel() >= 10 && !me->IsInCombat() && !IsCasting() && !me->IsMounted())
+            //        SummonBotsPet(PET_VOIDWALKER);
+
+            //TODO: implement healthstone
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (Potion_cd <= diff && GetManaPCT(me) < 50)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(BOT_CLASS_WARLOCK))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            //TODO: add more damage spells
+
+            if (feartimer <= diff && GC_Timer <= diff)
+            { CheckFear(); feartimer = 2000; }
+
+            if (IsSpellReady(RAIN_OF_FIRE_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && Rand() < 25)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, GetSpell(RAIN_OF_FIRE_1)))
+                    return;
+                SetSpellCooldown(RAIN_OF_FIRE_1, 2000);//fail
+            }
+
+            float dist = me->GetExactDist(opponent);
+
+            if (IsSpellReady(CURSE_OF_THE_ELEMENTS_1, diff) && dist < 30 && Rand() < 15 &&
+                !HasAuraName(opponent, CURSE_OF_THE_ELEMENTS_1) &&
+                doCast(opponent, GetSpell(CURSE_OF_THE_ELEMENTS_1)))
+            {
+                GC_Timer = 800;
+                return;
+            }
+
+            if (IsSpellReady(CORRUPTION_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 25 &&
+                !opponent->HasAura(GetSpell(CORRUPTION_1), me->GetGUID()) &&
+                doCast(opponent, GetSpell(CORRUPTION_1)))
+                return;
+
+            if (IsSpellReady(HAUNT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 25 &&
+                !opponent->HasAura(GetSpell(HAUNT_1), me->GetGUID()) &&
+                doCast(opponent, GetSpell(HAUNT_1)))
+                return;
+
+            if (GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 15 && !Afflicted(opponent))
+            {
+                if (GetSpellCooldown(CONFLAGRATE_1) <= 8000 && doCast(opponent, GetSpell(IMMOLATE_1)))
+                    return;
+                else if (doCast(opponent, GetSpell(UNSTABLE_AFFLICTION_1)))
+                    return;
+            }
+
+            if (IsSpellReady(CONFLAGRATE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 35 &&
+                HasAuraName(opponent, IMMOLATE_1) &&
+                doCast(opponent, GetSpell(CONFLAGRATE_1)))
+                return;
+
+            if (IsSpellReady(CHAOS_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 50 &&
+                doCast(opponent, GetSpell(CHAOS_BOLT_1)))
+                return;
+
+            if (IsSpellReady(SHADOW_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 &&
+                doCast(opponent, GetSpell(SHADOW_BOLT_1)))
+                return;
+        }
+
+        uint8 Afflicted(Unit* target)
+        {
+            if (!target || target->isDead()) return 0;
+            bool aff = HasAuraName(target, UNSTABLE_AFFLICTION_1, me->GetGUID());
+            bool imm = HasAuraName(target, IMMOLATE_1, me->GetGUID());
+            if (imm) return 1;
+            if (aff) return 2;
+            return 0;
+        }
+
+        void CheckFear()
+        {
+            uint32 FEAR = GetSpell(FEAR_1);
+            if (Unit* u = FindAffectedTarget(FEAR, me->GetGUID()))
+                if (Aura* aura = u->GetAura(FEAR, me->GetGUID()))
+                    if (aura->GetDuration() > 3000)
+                        return;
+            Unit* feartarget = FindFearTarget();
+            if (feartarget && doCast(feartarget, FEAR))
+                return;
+        }
+
+        //void SummonedCreatureDies(Creature* summon, Unit* /*killer*/)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPetDied();
+        //}
+
+        //void SummonedCreatureDespawn(Creature* summon)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPet(NULL);
+        //}
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                ////Shatter: frozen targets crit
+                //if (lvl >= 11 && damageinfo.target && damageinfo.target->isFrozen())
+                //    aftercrit *= 4.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                ////!!!spell damage is not yet critical and will be multiplied by 1.5
+                ////so we should put here bonus damage mult /1.5
+                ////Spell Power: 50% additional crit damage bonus for All spells
+                //if (lvl >= 55)
+                //    pctbonus += 0.333f;
+            }
+            //if (lvl >= 11 && spellId == FROSTBOLT && damageinfo.target && damageinfo.target->isFrozen())
+            //    pctbonus *= 0.2f;
+
+            ////Spellpower bonus damage (temp)
+            //if (m_spellpower > 0)
+            //{
+            //    if (spellId == SHADOW_BOLT)
+            //        fdamage += m_spellpower * 1.38f;
+            //    else if (spellId == IMMOLATE)
+            //        fdamage += m_spellpower * 0.75f; //guessed
+            //    else if (spellId == CONFLAGRATE)
+            //        fdamage += m_spellpower * 2.75f; //guessed
+            //    else if (spellId == CHAOS_BOLT)
+            //        fdamage += m_spellpower * 2.25f * 1.24f;
+            //    else if (spellId == RAIN_OF_FIRE || spellId == 42223)
+            //        fdamage += m_spellpower * 0.25f * 4.f;
+            //    else if (spellId == HAUNT)
+            //        fdamage += m_spellpower * 1.75f;
+            //}
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierEffect(SpellInfo const* /*spellInfo*/, uint8 /*effect_index*/, float& /*value*/) const
+        {
+            //uint32 spellId = spellInfo->Id;
+
+            //float pct_mod = 1.f;
+
+            //Spellpower bonus damage (temp)
+            //if (spellInfo->Effects[effect_index].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE)
+            //{
+            //    if (spellId == CORRUPTION)
+            //        value += m_spellpower * 1.35f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //    else if (spellId == IMMOLATE)
+            //        value += m_spellpower * 1.59f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //    else if (spellId == UNSTABLE_AFFLICTION)
+            //        value += m_spellpower * 1.68f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //}
+
+            //value *= pct_mod;
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            feartimer = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (feartimer > diff)                   feartimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(CURSE_OF_THE_ELEMENTS_1);
+            InitSpellMap(SHADOW_BOLT_1);
+            InitSpellMap(IMMOLATE_1);
+            lvl >= 40 ? InitSpellMap(CONFLAGRATE_1) : RemoveSpell(CONFLAGRATE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(CHAOS_BOLT_1) : RemoveSpell(CHAOS_BOLT_1);
+            InitSpellMap(RAIN_OF_FIRE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HAUNT_1) : RemoveSpell(HAUNT_1);
+            InitSpellMap(CORRUPTION_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(UNSTABLE_AFFLICTION_1) : RemoveSpell(UNSTABLE_AFFLICTION_1);
+            InitSpellMap(FEAR_1);
+        }
+
+        //TODO
+        void ApplyClassPassives() { }
+
+    private:
+        //Timers
+        uint32 feartimer;
+
+        enum WarlockBaseSpells
+        {
+            CURSE_OF_THE_ELEMENTS_1             = 1490,
+            SHADOW_BOLT_1                       = 686,
+            IMMOLATE_1                          = 348,
+            CONFLAGRATE_1                       = 17962,
+            CHAOS_BOLT_1                        = 50796,
+            RAIN_OF_FIRE_1                      = 5740,
+            HAUNT_1                             = 59164,
+            CORRUPTION_1                        = 172,
+            UNSTABLE_AFFLICTION_1               = 30404,
+            FEAR_1                              = 6215
+        };
+        enum WarlockPassives
+        {
+        };
+    };
+};
+
+class voidwalker_bot : public CreatureScript
+{
+public:
+    voidwalker_bot() : CreatureScript("voidwalker_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new voidwalker_botAI(creature);
+    }
+
+    struct voidwalker_botAI : public bot_pet_ai
+    {
+        voidwalker_botAI(Creature* creature) : bot_pet_ai(creature)
+        {
+            _botclass = BOT_CLASS_MAGE;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_NONE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { m_creatureOwner->SetBotsPetDied(); }
+        void DoNonCombatActions() { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            if (CCed(me)) return;
+
+            //TODO: add checks to help owner
+
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(PET_TYPE_VOIDWALKER))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //TORMENT
+            if (IsSpellReady(TORMENT_1, diff, false) && meleedist < 5 && !IsTank(opponent->GetVictim()))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(TORMENT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (m_creatureOwner->IsAIEnabled)
+                if (bot_minion_ai* ai = m_creatureOwner->GetBotMinionAI())
+                    ai->OnOwnerDamagedBy(u);
+        }
+
+        //debug
+        //void ListSpells(ChatHandler* ch) const
+        //{
+        //    ch->PSendSysMessage("Spells list:");
+        //    ch->PSendSysMessage("Torment: %u", TORMENT);
+        //    ch->PSendSysMessage("End of spells list.");
+        //}
+
+        void Reset()
+        {
+            if (master && m_creatureOwner)
+            {
+                DefaultInit();
+                SetBaseArmor(162 * master->getLevel());
+            }
+        }
+
+        void ReduceCD(uint32 /*diff*/)
+        {
+        }
+
+        void InitSpells()
+        {
+            InitSpellMap(TORMENT_1);
+        }
+
+        void ApplyClassPassives() { }
+
+    private:
+        //Timers
+
+        enum VoidwalkerBaseSpells
+        {
+            TORMENT_1                           = 3716
+        };
+        enum VoidwalkerPassives
+        {
+        };
+    };
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+    new voidwalker_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..f159dcc
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
@@ -0,0 +1,1915 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+//#include "WorldSession.h"
+/*
+Warrior NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 92-97%
+*/
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warrior_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct warrior_botAI : public bot_minion_ai
+    {
+        warrior_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_WARRIOR;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+
+            if (spellId == BATTLESTANCE_1 || spellId == DEFENSIVESTANCE_1 || spellId == BERSERKERSTANCE_1)
+                temptimer = GC_Timer;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        uint8 GetBotStance() const
+        {
+            if (battleStance)
+                return WARRIOR_BATTLE_STANCE;
+            else if (defensiveStance)
+                return WARRIOR_DEFENSIVE_STANCE;
+            else if (berserkerStance)
+                return WARRIOR_BERSERKER_STANCE;
+
+            return BOT_STANCE_NONE;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            getrage();
+            if (ragetimer2 <= diff)
+            {
+                if (me->IsInCombat() && me->getLevel() >= 20)
+                {
+                    if (me->GetPower(POWER_RAGE) < 990)
+                        me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) + uint32(10.f * rageIncomeMult)); //1 rage per 2 sec
+                    else
+                        me->SetPower(POWER_RAGE, 1000); //max
+                }
+                ragetimer2 = 2000;
+            }
+            if (ragetimer <= diff)
+            {
+                if (!me->IsInCombat() && !HasAuraName(me, BLOODRAGE_1))
+                {
+                    if (me->GetPower(POWER_RAGE) > uint32(10.f * rageLossMult))
+                        me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) - uint32(10.f * rageLossMult)); //-1 rage per 1.5 sec
+                    else
+                        me->SetPower(POWER_RAGE, 0); //min
+                }
+                ragetimer = 1500;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            CheckShouts(diff);
+            CheckVigilance(diff);
+            CheckIntervene(diff);
+            CheckSpellReflect(diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_WARRIOR))
+            {
+                if (!IsTank() && !me->IsInCombat() && battleStance != true && master->getAttackers().empty() &&
+                    stancetimer <= diff && Rand() < 25)
+                    stanceChange(diff, 1);
+                return;
+            }
+
+            if (IsSpellReady(BLOODRAGE_1, diff, false) && me->IsInCombat() && rage < 600 &&
+                Rand() < 20 && !me->HasAura(ENRAGED_REGENERATION_1))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLOODRAGE_1)))
+                {
+                    GC_Timer = temptimer;
+                    getrage();
+                }
+            }
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u)
+        {
+            //Victorious State spell
+            //only on targets which give xp or honor
+            if (me->getLevel() >= 5 && u->getLevel() + 9 >= me->getLevel())
+                me->CastSpell(me, VICTORIOUS_SPELL, true);
+        }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void modrage(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && rage < abs(mod))
+            {
+                //debug set rage to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                rage = mod ? mod*10 : 0;
+            else
+                rage += mod*10;
+
+            me->SetPower(POWER_RAGE, rage);
+        }
+
+        int32 getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            if (me->FindCurrentSpellBySpellId(GetSpell(CLEAVE_1)))
+                rage = std::max<int32>(rage - 200, 0);
+            else if (me->FindCurrentSpellBySpellId(GetSpell(HEROIC_STRIKE_1)))
+                rage = std::max<int32>(rage - 150, 0);
+
+            return rage;
+        }
+
+        int32 rcost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_DISORIENTED)))
+            {
+                if (IsSpellReady(BERSERKERRAGE_1, diff) && Rand() < 35 && !me->HasAura(ENRAGED_REGENERATION_1) &&
+                    doCast(me, GetSpell(BERSERKERRAGE_1)))
+                    return;
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            //Keep defensive stance if tank
+            if (IsTank() && defensiveStance != true && stancetimer <= diff)
+                stanceChange(diff, 2);
+            //SelfHeal
+            if (IsSpellReady(ENRAGED_REGENERATION_1, diff) && rage > rcost(ENRAGED_REGENERATION_1) &&
+                GetHealthPCT(me) < 40 && Rand() < 40 && me->HasAuraWithMechanic(uint32(1<<MECHANIC_ENRAGED)))
+            {
+                if (doCast(me, GetSpell(ENRAGED_REGENERATION_1)))
+                    return;
+            }
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+            //charge + warbringer
+            if (IsSpellReady(CHARGE_1, diff, false) && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+                (me->getLevel() >= 50 ||
+                (!me->IsInCombat() && (battleStance || stanceChange(diff, 1)))))
+            {
+                temptimer = GC_Timer;
+                if (me->getLevel() >= 29)
+                    me->RemoveMovementImpairingAuras();
+                if (doCast(opponent, GetSpell(CHARGE_1), me->IsInCombat()))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //intercept
+            if (IsSpellReady(INTERCEPT_1, diff, false) && !IsTank() &&
+                rage > rcost(INTERCEPT_1) && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+                !CCed(opponent) && (berserkerStance || stanceChange(diff, 3)))
+            {
+                if (doCast(opponent, GetSpell(INTERCEPT_1)))
+                    return;
+            }
+            //SelfHeal 2 - LAST STAND
+            if (IsSpellReady(LAST_STAND_1, diff, false) && IsTank() && Rand() < 67 &&
+                GetHealthPCT(me) < (30 + 20 * (b_attackers.size() > 1) + 10 * me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(LAST_STAND_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //FEAR
+            if (IsSpellReady(INTIMIDATING_SHOUT_1, diff) && Rand() < 70 && rage > rcost(INTIMIDATING_SHOUT_1))
+            {
+                if (opponent->IsNonMeleeSpellCast(false, false, true) && dist <= 8 &&
+                    !(opponent->ToCreature() && opponent->ToCreature()->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                {
+                    if (doCast(opponent, GetSpell(INTIMIDATING_SHOUT_1)))
+                        return;
+                }
+                Unit* fearTarget = NULL;
+                bool triggered = false;
+                uint8 tCount = 0;
+                //fear master's attackers
+                if (!m_attackers.empty() &&
+                    ((master->getClass() != BOT_CLASS_DEATH_KNIGHT &&
+                    master->getClass() != BOT_CLASS_WARRIOR &&
+                    master->getClass() != BOT_CLASS_PALADIN) ||
+                    GetHealthPCT(master) < 70))
+                {
+                    for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
+                        return;
+                }
+                //Defend myself
+                if (b_attackers.size() > 1)
+                {
+                    tCount = 0;
+                    fearTarget = NULL;
+                    triggered = false;
+                    for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
+                        return;
+                }
+            }//end FEAR
+            //TAUNT //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(TAUNT_1, diff, false) && u && u != me && !IsTank(u) && dist <= 30 &&
+                !CCed(opponent) && (!IsTankingClass(u->getClass()) || IsTank()) && IsInBotParty(u) &&
+                (defensiveStance || (stancetimer <= diff && stanceChange(diff, 2))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(TAUNT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //CHALLENGING SHOUT
+            if (IsSpellReady(CHALLENGING_SHOUT_1, diff))
+            {
+                u = opponent->GetVictim();
+                if (u && u != me && !IsTank(u) && !CCed(opponent) && dist <= 10 && rage > rcost(CHALLENGING_SHOUT_1) &&
+                    Rand() < 30 && (!IsTankingClass(u->getClass()) || IsTank()) && IsInBotParty(u))
+                {
+                    if (doCast(me, GetSpell(CHALLENGING_SHOUT_1)))
+                        return;
+                }
+                if (IsTank() && rage > rcost(CHALLENGING_SHOUT_1) && Rand() < 20)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets);
+                    if (int8(targets.size()) - int8(b_attackers.size()) >= 1)
+                        if (doCast(me, GetSpell(CHALLENGING_SHOUT_1)))
+                            return;
+                }
+            }
+            u = opponent->GetVictim();
+            //MOCKING BLOW
+            if (IsSpellReady(MOCKING_BLOW_1, diff) && HasRole(BOT_ROLE_DPS) && u && u != me && !IsTank(u) &&
+                meleedist <= 5 && rage > rcost(MOCKING_BLOW_1) &&
+                !CCed(opponent) && Rand() < 70 && (!IsTankingClass(u->getClass()) || IsTank()) && IsInBotParty(u) &&
+                (battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, GetSpell(MOCKING_BLOW_1)))
+                    return;
+            }
+            //SHIELD SLAM
+            if (IsSpellReady(SHIELD_SLAM_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                (battleStance || defensiveStance || stancetimer <= diff) &&
+                meleedist <= 5 && rage > rcost(SHIELD_SLAM_1) && CanBlock() &&
+                Rand() < (55 + 200*me->HasAura(SWORD_AND_BOARD_BUFF)))
+            {
+                //check Shield Block
+                if (IsSpellReady(SHIELD_BLOCK_1, diff, false) && (defensiveStance || stanceChange(diff, 2)))
+                {
+                    temptimer = GC_Timer;
+
+                    if (!doCast(me, GetSpell(SHIELD_BLOCK_1)))
+                        return;
+
+                    GC_Timer = temptimer;
+                }
+                if (battleStance || defensiveStance || stanceChange(diff, 4))
+                {
+                    if (doCast(opponent, GetSpell(SHIELD_SLAM_1)))
+                        return;
+                }
+            }
+            //SHIELD BLOCK
+            if (IsSpellReady(SHIELD_BLOCK_1, diff, false) && CanBlock() && IsTank() &&
+                ((u == me && meleedist <= 8) || (!b_attackers.empty() && me->GetDistance2d(*(b_attackers.begin())) <= 8)) &&
+                GetHealthPCT(me) < (65 + 8 * uint8(b_attackers.size())) && Rand() < 50 &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                temptimer = GC_Timer;
+                if ((defensiveStance || stanceChange(diff, 2)) &&
+                    doCast(me, GetSpell(SHIELD_BLOCK_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HEROIC THROW
+            if (IsSpellReady(HEROIC_THROW_1, diff) && HasRole(BOT_ROLE_DPS) && dist <= 30 &&
+                Rand() < (20 + 70 * opponent->IsNonMeleeSpellCast(false)))
+            {
+                if (doCast(opponent, GetSpell(HEROIC_THROW_1)))
+                    return;
+            }
+            //SHOCKWAVE - frontal cone
+            if (IsSpellReady(SHOCKWAVE_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() && dist <= 10 && !CCed(opponent) &&
+                rage > rcost(SHOCKWAVE_1) && Rand() < (30 + 50 * opponent->IsNonMeleeSpellCast(true)) &&
+                me->HasInArc(M_PI / 2.f, opponent) && opponent->IsWithinLOSInMap(me))
+            {
+                if (doCast(me, GetSpell(SHOCKWAVE_1)))
+                    return;
+            }
+            //OVERPOWER
+            if (IsSpellReady(OVERPOWER_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                meleedist <= 5 && rage > rcost(OVERPOWER_1) &&
+                (battleStance || stancetimer <= diff) &&/* Rand() < 80 &&*/
+                (me->HasReactive(REACTIVE_OVERPOWER) ||
+                (IsSpellReady(TASTE_FOR_BLOOD_BUFF, diff, false) && me->HasAura(TASTE_FOR_BLOOD_BUFF))))
+            {
+                if (battleStance || stanceChange(diff, 1))
+                {
+                    //custom
+                    me->CastSpell(opponent, GetSpell(OVERPOWER_1));
+                    return;
+                }
+            }
+            //THUNDER CLAP
+            if (IsSpellReady(THUNDER_CLAP_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                dist <= 8 && rage > rcost(THUNDER_CLAP_1) && Rand() < 20 &&
+                (battleStance || defensiveStance || stancetimer <= diff) &&
+                (IsTank() || !HasAuraName(opponent, THUNDER_CLAP_1)))
+            {
+                if (battleStance || defensiveStance || stanceChange(diff, 4))
+                {
+                    if (doCast(me, GetSpell(THUNDER_CLAP_1)))
+                        return;
+                }
+            }
+            //DEVASTATE - only with shield
+            if (IsSpellReady(DEVASTATE_1, diff) && HasRole(BOT_ROLE_DPS)/* && IsTank()*/ && CanBlock() &&
+                meleedist <= 5 && rage > rcost(DEVASTATE_1) && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(DEVASTATE_1)))
+                    return;
+            }
+            //REVENGE
+            if (IsSpellReady(REVENGE_1, diff) && me->HasAuraState(AURA_STATE_DEFENSE) && HasRole(BOT_ROLE_DPS) && IsTank() &&
+                meleedist <= 5 && rage > rcost(REVENGE_1) && Rand() < 30 &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                if (defensiveStance || stanceChange(diff, 2))
+                {
+                    if (doCast(opponent, GetSpell(REVENGE_1)))
+                    {
+                        //Improved Revenge (part 2): find second target
+                        if (me->getLevel() >= 25)
+                            if (Unit* u = FindSplashTarget(5, opponent))
+                                me->CastSpell(u, GetSpell(REVENGE_1), true);
+                        return;
+                    }
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 15;
+
+            //CONCUSSION_BLOW
+            if (IsSpellReady(CONCUSSION_BLOW_1, diff) && HasRole(BOT_ROLE_DPS) && IsTank() &&
+                meleedist <= 5 && rage > rcost(CONCUSSION_BLOW_1) && !CCed(opponent) &&
+                Rand() < (30 + 60 * opponent->IsNonMeleeSpellCast(false)))
+            {
+                if (doCast(opponent, GetSpell(CONCUSSION_BLOW_1)))
+                    return;
+            }
+            //HAMSTRING
+            if (IsSpellReady(HAMSTRING_1, diff) && (!GetSpell(PIERCING_HOWL_1) || opponent->GetTypeId() == TYPEID_PLAYER) &&
+                opponent->isMoving() && meleedist <= 5 && rage > rcost(HAMSTRING_1) &&
+                Rand() < 50 && (battleStance || berserkerStance || stancetimer <= diff) &&
+                !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (battleStance || berserkerStance || stanceChange(diff, 5))
+                    if (doCast(opponent, GetSpell(HAMSTRING_1)))
+                        return;
+            }
+            //PIERCING HOWL
+            if (IsSpellReady(PIERCING_HOWL_1, diff) && opponent->isMoving() && meleedist <= 9 && rage > rcost(PIERCING_HOWL_1) &&
+                Rand() < 70 && !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (doCast(me, GetSpell(PIERCING_HOWL_1)))
+                    return;
+            }
+            //DISARM
+            if (IsSpellReady(DISARM_1, diff) && meleedist <= 5 && rage > rcost(DISARM_1) && Rand() < 50 &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                //check weapons
+                bool hasWeapon = true;
+                if (opponent->GetTypeId() == TYPEID_UNIT && !opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID))
+                    hasWeapon = false;
+                else if (Player* pla = opponent->ToPlayer())
+                    if (!pla->GetWeaponForAttack(BASE_ATTACK) || !pla->IsUseEquipedWeapon(true))
+                        hasWeapon = false;
+
+                if (hasWeapon && (defensiveStance || stanceChange(diff, 2)) &&
+                    doCast(opponent, GetSpell(DISARM_1)))
+                    return;
+            }
+            //Victory Rush
+            if (IsSpellReady(VICTORY_RUSH_1, diff) && VICTORIOUS && HasRole(BOT_ROLE_DPS) && !IsTank() && meleedist <= 5/* &&
+                (b_attackers.size() <= 1 || (GetHealthPCT(me) < std::max<int32>(100 - b_attackers.size() * 10, 75)))*/ &&
+                (battleStance || berserkerStance || stancetimer <= diff))
+            {
+                if (battleStance || berserkerStance || stanceChange(diff, 5))
+                    if (doCast(opponent, GetSpell(VICTORY_RUSH_1)))
+                        return;
+            }
+            //UBERS
+            //Shield Wall
+            if (IsSpellReady(SHIELD_WALL_1, diff, false) && CanBlock() &&
+                GetHealthPCT(me) < (30 + 4 * b_attackers.size() + 10 * (opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss())) &&
+                Rand() < 70 &&
+                (defensiveStance || stanceChange(diff, 2)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(SHIELD_WALL_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //Retaliation
+            if (IsSpellReady(RETALIATION_1, diff) && HasRole(BOT_ROLE_DPS) && b_attackers.size() > 4 && Rand() < 30 &&
+                (battleStance || stanceChange(diff, 1)))
+            {
+                if (doCast(me, GetSpell(RETALIATION_1)))
+                    return;
+            }
+            //Recklessness
+            if (IsSpellReady(RECKLESSNESS_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                (m_attackers.size() > 3 || opponent->GetHealth() > me->GetHealth() * 10) && Rand() < 20 &&
+                (berserkerStance || stanceChange(diff, 3)))
+            {
+                if (doCast(me, GetSpell(RECKLESSNESS_1)))
+                    return;
+            }
+            //DEATHWISH
+            if (IsSpellReady(DEATHWISH_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && dist <= 20 && rage > rcost(DEATHWISH_1) &&
+                opponent->GetHealth() > me->GetHealth()/2 && Rand() < 20 &&
+                !me->HasAura(ENRAGED_REGENERATION_1))
+            {
+                if (doCast(me, GetSpell(DEATHWISH_1)))
+                    return;
+            }
+            //EXECUTE
+            if (IsSpellReady(EXECUTE_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                meleedist <= 5 && rage > rcost(EXECUTE_1) &&
+                opponent->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT) && Rand() < 70 &&
+                (battleStance || berserkerStance || (stancetimer <= diff && stanceChange(diff, 5))))
+            {
+                if (doCast(opponent, GetSpell(EXECUTE_1)))
+                {
+                    //sudden death
+                    if (me->getLevel() >= 50 && rage <= 400)
+                        modrage(10, true);
+                    else if (rage > 300)
+                        modrage(-30);
+                    else
+                        modrage(0, true);
+                    return;
+                }
+            }
+            //SUNDER ARMOR
+            if (IsSpellReady(SUNDER_1, diff) && !GetSpell(DEVASTATE_1) && IsTank() &&
+                meleedist <= 5 && rage > rcost(SUNDER_1) &&
+                opponent->GetHealth() > me->GetMaxHealth() && Rand() < 45)
+            {
+                Aura* sunder = opponent->GetAura(GetSpell(SUNDER_1), me->GetGUID());
+                if ((!sunder || sunder->GetStackAmount() < 5 || sunder->GetDuration() < 15000) &&
+                    doCast(opponent, GetSpell(SUNDER_1)))
+                    return;
+            }
+            //SS //no GCD //no rage (glyph)
+            if (IsSpellReady(SWEEPING_STRIKES_1, diff, false) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                dist <= 20 && rage > rcost(SWEEPING_STRIKES_1) &&
+                (battleStance || berserkerStance || stancetimer <= diff) && Rand() < 25 &&
+                (b_attackers.size() > 1 || FindSplashTarget(7, opponent)))
+            {
+                temptimer = GC_Timer;
+                if ((battleStance || berserkerStance || stanceChange(diff, 5)) &&
+                    doCast(me, GetSpell(SWEEPING_STRIKES_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //WHIRLWIND
+            if (IsSpellReady(WHIRLWIND_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                (berserkerStance || stancetimer <= diff) &&
+                dist <= 10 && rage > rcost(WHIRLWIND_1) && Rand() < 50 &&
+               ((rage > 800 && dist <= 7) || FindSplashTarget(7, opponent)))
+            {
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(me, GetSpell(WHIRLWIND_1)))
+                    return;
+            }
+            //BLADESTORM
+            if (IsSpellReady(BLADESTORM_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+               dist <= 10 && rage > rcost(BLADESTORM_1) &&
+               (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()) &&
+               (Rand() < 20 || me->HasAura(RECKLESSNESS_1)))
+            {
+                if (doCast(me, GetSpell(BLADESTORM_1)))
+                    return;
+            }
+            //Mortal Strike
+            if (IsSpellReady(MORTALSTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                meleedist <= 5 && rage > rcost(MORTALSTRIKE_1) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(MORTALSTRIKE_1)))
+                    return;
+            }
+            //Slam
+            if (IsSpellReady(SLAM_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && !opponent->isMoving() &&
+                meleedist <= 5 && rage > rcost(SLAM_1) && Rand() < (20 + 80 * me->HasAura(BLOODSURGE_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(SLAM_1)))
+                    return;
+            }
+            //SHIELD BASH - shared cd with pummel
+            if (IsSpellReady(SHIELD_BASH_1, diff, false) && CanBlock() &&
+                meleedist <= 5 && rage > rcost(SHIELD_BASH_1) && Rand() < 80 &&
+                opponent->IsNonMeleeSpellCast(false) &&
+                (battleStance || defensiveStance || stancetimer <= diff))
+            {
+                temptimer = GC_Timer;
+                if ((battleStance || defensiveStance || stanceChange(diff, 4)) &&
+                    doCast(opponent, GetSpell(SHIELD_BASH_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //PUMMEL - shared cd with shield bash
+            if (IsSpellReady(PUMMEL_1, diff, false) && !IsTank() &&
+                meleedist <= 5 && rage > rcost(PUMMEL_1) && Rand() < 80 &&
+                opponent->IsNonMeleeSpellCast(false) &&
+                (berserkerStance || stancetimer <= diff))
+            {
+                temptimer = GC_Timer;
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(opponent, GetSpell(PUMMEL_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //REND
+            if (IsSpellReady(REND_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                opponent->GetHealth() > me->GetMaxHealth()/2 && meleedist <= 5 && rage > rcost(REND_1) &&
+                Rand() < 50 && !opponent->HasAura(GetSpell(REND_1), me->GetGUID()) &&
+                (battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, GetSpell(REND_1)))
+                    return;
+            }
+
+            //skip if already have cleave of heroic strike casted
+            if (me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                return;
+
+            //CLEAVE //no GCD
+            if (IsSpellReady(CLEAVE_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                meleedist <= 5 && (!IsTank() || rage > 500) && rage > rcost(CLEAVE_1) && Rand() < 25)
+            {
+                temptimer = GC_Timer;
+                u = FindSplashTarget(5);
+                if (u && doCast(opponent, GetSpell(CLEAVE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HEROIC STRIKE
+            if (IsSpellReady(HEROIC_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && IsTank() &&
+                meleedist <= 5 && rage > rcost(HEROIC_STRIKE_1) && Rand() < (15 + rage / 10))
+            {
+                temptimer = GC_Timer;
+                if (u && doCast(opponent, GetSpell(HEROIC_STRIKE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }//end Attack
+
+        void CheckShouts(uint32 diff)
+        {
+            if (shoutCheckTimer > diff || GC_Timer > diff || me->IsMounted() || IsCasting() ||
+                /*rage < rcost(BATTLESHOUT_1) || */Rand() > 35)
+                return;
+
+            shoutCheckTimer = 3000;
+
+            if (IAmFree())
+            {
+                if (!HasAuraName(me, BATTLESHOUT_1, me->GetGUID()))
+                {
+                    if (rage < rcost(BATTLESHOUT_1) && IsSpellReady(BLOODRAGE_1, diff, false))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(BLOODRAGE_1)))
+                        {
+                            GC_Timer = temptimer;
+                            if (doCast(me, GetSpell(BATTLESHOUT_1)))
+                                return;
+                        }
+                    }
+                }
+
+                return;
+            }
+
+            bool hasBS = HasAuraName(me, BATTLESHOUT_1/*, me->GetGUID()*/);
+            bool hasCS = HasAuraName(me, COMMANDING_SHOUT_1/*, me->GetGUID()*/);
+            if (hasCS || hasBS)
+                return;
+
+            if (me->GetDistance2d(master) < 30/* && master->IsWithinLOSInMap(me)*/)
+            {
+                bool battleshout = !hasBS && (!IsTank(me) || !GetSpell(COMMANDING_SHOUT_1));
+                bool commandingshout = !hasCS && GetSpell(COMMANDING_SHOUT_1);
+
+                if (battleshout || commandingshout)
+                {
+                    if (rage < rcost(BATTLESHOUT_1) && IsSpellReady(BLOODRAGE_1, diff, false))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(BLOODRAGE_1)))
+                            GC_Timer = temptimer;
+                    }
+
+                    if ((battleshout && doCast(me, GetSpell(BATTLESHOUT_1))) ||
+                        (commandingshout && doCast(me, GetSpell(COMMANDING_SHOUT_1))))
+                    {
+                        shoutCheckTimer = 10000;
+                        return;
+                    }
+                }
+            }
+        }
+
+        void CheckVigilance(uint32 diff)
+        {
+            if (!IsSpellReady(VIGILANCE_1, diff) || me->IsInCombat() || me->IsMounted() || IsCasting() || Rand() > 50)
+                return;
+
+            uint32 VIGILANCE = GetSpell(VIGILANCE_1);
+
+            Unit* u = ObjectAccessor::FindUnit(vigilanceTargetGuid);
+
+            if (u)
+            {
+                if (!IsTank())
+                {
+                    u->RemoveAura(VIGILANCE, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                    vigilanceTargetGuid = 0;
+                }
+                if (IAmFree())
+                    return;
+            }
+            else if (IsTank())
+            {
+                Group* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (me->GetExactDist(master) < 30 && !master->HasAura(VIGILANCE))
+                        u = master;
+                }
+                else
+                {
+                    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || pPlayer->isDead()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (!IsTankingClass(pPlayer->getClass()) && me->GetExactDist(pPlayer) < 30 &&
+                            !pPlayer->HasAura(VIGILANCE))
+                        {
+                            u = pPlayer;
+                            break;
+                        }
+                    }
+                    if (!u)
+                    {
+                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                            {
+                                Creature* cre = it->second;
+                                if (!cre || !cre->IsInWorld() || cre == me || cre->isDead()) continue;
+                                if (!IsTankingClass(cre->GetBotClass()) && me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(VIGILANCE))
+                                {
+                                    u = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (u && doCast(u, VIGILANCE))
+                {
+                    vigilanceTargetGuid = u->GetGUID();
+                    return;
+                }
+            }
+
+            SetSpellCooldown(VIGILANCE_1, 10000); //fail
+        }
+
+        void CheckIntervene(uint32 diff)
+        {
+            if (IsSpellReady(INTERVENE_1, diff, false) && GetBotCommandState() != COMMAND_STAY &&
+                !me->IsMounted() && rage > rcost(INTERVENE_1) &&
+                !IAmFree() && !IsCasting() && Rand() < (IsTank() ? 80 : 30) &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                if (!master->IsInCombat() && master->getAttackers().empty() && master->isMoving())
+                {
+                    float mydist = me->GetExactDist(master);
+                    if (mydist < 24 && mydist > 19 && (defensiveStance || stanceChange(diff, 2)))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                        {
+                            GC_Timer = temptimer;
+                            Follow(true);
+                            return;
+                        }
+                    }
+                }
+                Group* gr = master->GetGroup();
+                if (!gr)
+                {
+                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() &&
+                        me->getAttackers().size() <= master->getAttackers().size())
+                    {
+                        float dist = me->GetExactDist(master);
+                        if (dist > 25 || dist < 10) return;
+                        if (!(defensiveStance || stanceChange(diff, 2))) return;
+                        temptimer = GC_Timer;
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                else
+                {
+                    bool Bots = false;
+                    float dist;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        if (tPlayer->HaveBot())
+                            Bots = true;
+                        if (tPlayer->isDead() || GetHealthPCT(tPlayer) > 90 || IsTank(tPlayer)) continue;
+                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
+                        dist = me->GetExactDist(tPlayer);
+                        if (dist > 24 || dist < 10) continue;
+                        if (defensiveStance || stanceChange(diff, 2))
+                        {
+                            temptimer = GC_Timer;
+                            if (doCast(tPlayer, GetSpell(INTERVENE_1)))
+                            {
+                                GC_Timer = temptimer;
+                                return;
+                            }
+                        }
+                    }
+                    if (!Bots) return;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || !tPlayer->HaveBot()) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInWorld() || bot == me || bot->isDead()) continue;
+                            if (GetHealthPCT(bot) > 90 || IsTank(bot)) continue;
+                            dist = me->GetExactDist(bot);
+                            if (dist > 25 || dist < 10) continue;
+                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
+                            if (defensiveStance || stanceChange(diff, 2))
+                            {
+                                temptimer = GC_Timer;
+                                if (doCast(bot, GetSpell(INTERVENE_1)))
+                                {
+                                    GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                SetSpellCooldown(INTERVENE_1, 2000); //fail
+            }
+        }
+
+        void CheckSpellReflect(uint32 diff)
+        {
+            if (!IsSpellReady(SPELL_REFLECTION_1, diff, false) || me->IsMounted() || IsCasting() ||
+                !CanBlock() || !(battleStance || defensiveStance || stancetimer <= diff) ||
+                rage < rcost(SPELL_REFLECTION_1) || Rand() > 35)
+                return;
+
+            //use simpliest finder - first match (covers most cases)
+            if (Unit* target = FindCastingTarget(70))
+            {
+                temptimer = GC_Timer;
+                for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                    if (Spell* spell = target->GetCurrentSpell(CurrentSpellTypes(i)))
+                        if (!spell->GetSpellInfo()->IsChanneled())
+                            if (spell->GetSpellInfo()->DmgClass == SPELL_DAMAGE_CLASS_MAGIC &&
+                                !(spell->GetSpellInfo()->Attributes & SPELL_ATTR0_ABILITY) &&
+                                !(spell->GetSpellInfo()->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+                                !(spell->GetSpellInfo()->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY) &&
+                                !spell->GetSpellInfo()->IsPassive() && !spell->GetSpellInfo()->IsPositive())
+                                if (Unit* u = spell->m_targets.GetUnitTarget())
+                                    if (u == me || (me->GetDistance(u) < 20 && !IAmFree() && IsInBotParty(u)))
+                                        if (doCast(me, GetSpell(SPELL_REFLECTION_1)))
+                                        {
+                                            GC_Timer = temptimer;
+                                            return;
+                                        }
+            }
+
+            SetSpellCooldown(SPELL_REFLECTION_1, 1000); //fail
+        }
+
+        bool stanceChange(uint32 diff, uint8 stance)
+        {
+            if (stancetimer > diff || !stance)
+                return false;
+
+            if (stance == 5)
+                stance = (me->getLevel() >= 30 && !IsTank() && urand(1,100) > 70) ? 3 : 1;
+            else if (stance == 4)
+                stance = (me->getLevel() >= 10 && (IsTank() || urand(1,100) > 50)) ? 2 : 1;
+
+            if (stance == 2 && me->getLevel() < 10)
+                return false;
+            if (stance == 3 && me->getLevel() < 30)
+                return false;
+
+            switch (stance)
+            {
+                case 1:
+                    if (doCast(me, GetSpell(BATTLESTANCE_1)))
+                    {
+                        if (me->HasAura(BATTLESTANCE_1))
+                        {
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 2:
+                    if (doCast(me, GetSpell(DEFENSIVESTANCE_1)))
+                    {
+                        if (me->HasAura(DEFENSIVESTANCE_1))
+                        {
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 3:
+                    if (doCast(me, GetSpell(BERSERKERSTANCE_1)))
+                    {
+                        if (me->HasAura(BERSERKERSTANCE_1))
+                        {
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+
+            GC_Timer = temptimer;
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+        {
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+
+            if (damageinfo.hitOutCome == MELEE_HIT_CRIT)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Poleaxe Specialization: 5% additional critical damage for all attacks
+                if (lvl >= 30)
+                    if (Item const* weap = GetEquips(damageinfo.attackType))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                pctbonus += 0.025f;
+            }
+
+            damage = damage * (1.0f + pctbonus);
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Poleaxe Specialization: 5% additional critical chance for all attacks
+                if (lvl >= 30)
+                    if (Item const* weap = GetEquips(attackType))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                aftercrit += 5.f;
+                //Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+                if (lvl >= 15 &&
+                    (spellId == GetSpell(CLEAVE_1) ||
+                    spellId == GetSpell(HEROIC_STRIKE_1) ||
+                    spellId == GetSpell(THUNDER_CLAP_1)))
+                    aftercrit += 15.f;
+                //Improved Overpower: 50% additional critical chance for Overpower
+                if (lvl >= 20 && spellId == GetSpell(OVERPOWER_1))
+                    aftercrit += 50.f;
+                //Critical Block: 15% additional critical chance for Shield Slam
+                if (lvl >= 50 && spellId == GetSpell(SHIELD_SLAM_1))
+                    aftercrit += 15.f;
+                //Sword and Board: 15% additional critical chance for Devastate
+                if (lvl >= 55 && spellId == GetSpell(DEVASTATE_1))
+                    aftercrit += 15.f;
+                //Warrior T8 Protection Bonus (id: 64933): 10% additional critical chance for Devastate (tanks only)
+                if (lvl >= 78 && IsTank() && spellId == GetSpell(DEVASTATE_1))
+                    aftercrit += 10.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Impale: 20% crit damage bonus for all abilities
+                if (lvl >= 20)
+                    pctbonus += 0.10f;
+                //Poleaxe Specialization: 5% additional critical damage for all attacks
+                if (lvl >= 30)
+                    if (Item const* weap = GetEquips(attackType))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                pctbonus += 0.025f;
+            }
+
+            //Improved Rend: 20% bonus damage for Rend
+            if (spellId == GetSpell(REND_1))
+                pctbonus += 0.2f;
+            //Improved Whirlwind: 20% bonus damage for Whirlwind
+            if (lvl >= 40 && spellId == GetSpell(WHIRLWIND_1))
+                pctbonus += 0.2f;
+            //Glyph of Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 40 && spellId == GetSpell(MORTALSTRIKE_1))
+                pctbonus += 0.1f;
+            //Unrelenting Assault (part 2): 20% bonus damage for Overpower and Revenge
+            if (lvl >= 45 && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+                pctbonus += 0.2f;
+            //Improved Mortal Strike (part 1): 10% bonus damage for Mortal Strike
+            if (lvl >= 45 && spellId == GetSpell(MORTALSTRIKE_1))
+                pctbonus += 0.1f;
+            //Undending Fury: 10% bonus damage for Whirlwind, Slam and Bloodthirst
+            if (lvl >= 55 && (spellId == GetSpell(WHIRLWIND_1) || spellId == GetSpell(SLAM_1) /*|| spellId == BLOODTHIRST*/))
+                pctbonus += 0.1f;
+            //Improved Thunder Clap (part 2): 30% bonus damage for Thunder Clap
+            if (lvl >= 15 && spellId == GetSpell(THUNDER_CLAP_1))
+                pctbonus += 0.3f;
+            ////Improved Revenge (part 1): 60% bonus damage for Revenge
+            //if (lvl >= 20 && spellId == GetSpell(REVENGE_1))
+            //    pctbonus += 0.6f;
+            //Gag Order (part 2): 10% bonus damage for Shield Slam
+            if (lvl >= 30 && spellId == GetSpell(SHIELD_SLAM_1))
+                pctbonus += 0.1f;
+            //Improved Shield Slam (id: 38407): 10% bonus damage for Shield Slam
+            if (lvl >= 50 && spellId == GetSpell(SHIELD_SLAM_1))
+                pctbonus += 0.1f;
+            //Shield Slam Damage Up (id: 60173): 10% bonus damage for Shield Slam
+            if (lvl >= 70 && spellId == GetSpell(SHIELD_SLAM_1))
+                pctbonus += 0.1f;
+            //Warrior T10 Protection 2P Bonus (id: 70843): 20% bonus damage for Shield Slam and Shockwave (tanks only)
+            if (lvl >= 78 && IsTank() && (spellId == GetSpell(SHIELD_SLAM_1) || spellId == GetSpell(SHOCKWAVE_1)))
+                pctbonus += 0.2f;
+            //One-Handed Weapon Specialization: 10% bonus damage with 1H weapons (for bot - Devastate only)
+            if (lvl >= 35 && spellId == GetSpell(DEVASTATE_1))
+                pctbonus += 0.1f;
+            //Warrior T9 Protection 2P Bonus (id: 67269): 5% bonus damage for Devastate
+            if (lvl >= 77 && spellId == GetSpell(DEVASTATE_1))
+                pctbonus += 0.05f;
+            //Glyph of Mocking Blow: 25% bonus damage for Mocking Blow
+            if (lvl >= 15 && spellId == GetSpell(MOCKING_BLOW_1))
+                pctbonus += 0.25f;
+
+            //Improved Cleave: 120% increased '!bonus damage!' done by Cleave (flat mod)
+            if (lvl >= 25 && spellId == GetSpell(CLEAVE_1))
+            {
+                float bp = spellInfo->Effects[EFFECT_0].BasePoints; //SPELL_EFFECT_WEAPON_DAMAGE (values: 15 - 222)
+                fdamage += bp * 1.2;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Glyph of Bloodrage: -100% health cost for Bloodrage
+            if (lvl >= 10 && spellId == GetSpell(BLOODRAGE_1))
+                pctbonus += 1.0f;
+            //Sword and Board: -100% rage cost for Shield Slam
+            if (lvl >= 55 && spellId == GetSpell(SHIELD_SLAM_1) && me->HasAura(SWORD_AND_BOARD_BUFF))
+                pctbonus += 1.0f;
+            //Glyph of Sweeping Strikes: -100% rage cost for Sweeping Strikes
+            if (lvl >= 30 && spellId == GetSpell(SWEEPING_STRIKES_1))
+                pctbonus += 1.0f;
+            //Glyph of Revenge: -100% rage cost for Heroic Strike
+            if (lvl >= 20 && spellId == GetSpell(HEROIC_STRIKE_1) && me->HasAura(GLYPH_OF_REVENGE_BUFF))
+                pctbonus += 1.0f;
+
+            //flat mods
+            //!1 rage = 10 pts!
+            //Improved Heroic Strike: -3 rage cost for Heroic Strike
+            if (lvl >= 10 && spellId == GetSpell(HEROIC_STRIKE_1))
+                flatbonus += 30;
+            //Bloodthirst and Mortal Strike Discount (id: 37535): -5 rage cost for Bloodthirst and Mortal Strike
+            if (lvl >= 40 && (/*spellId == GetSpell(BLOODTHIRST_1) || */spellId == GetSpell(MORTALSTRIKE_1)))
+                flatbonus += 50;
+            //Improved Execute: -5 rage cost for Execute
+            if (lvl >= 25 && spellId == GetSpell(EXECUTE_1))
+                flatbonus += 50;
+            //Improved Thunder Clap (part 1): -4 rage cost for Execute
+            if (lvl >= 15 && spellId == GetSpell(THUNDER_CLAP_1))
+                flatbonus += 40;
+            //Puncture: -3 rage cost for Sunder Armor and Devastate
+            if (lvl >= 25 && (spellId == GetSpell(SUNDER_1) || spellId == GetSpell(DEVASTATE_1)))
+                flatbonus += 30;
+            //Glyph of Shockwave: -3 rage cost for Shockwave
+            if (lvl >= 65 && spellId == GetSpell(SHOCKWAVE_1))
+                flatbonus += 30;
+            //Improved Hamstring (id: 24428): -2 rage cost for Hamstring (for bot Piercing Howl also)
+            if (lvl >= 25 && (spellId == GetSpell(HAMSTRING_1) || spellId == GetSpell(PIERCING_HOWL_1)))
+                flatbonus += 20;
+            //Focused Rage: -3 rage cost for all abilities (using rage)
+            if (lvl >= 40 && spellInfo->PowerType == POWER_RAGE)
+                flatbonus += 30;
+            //Glyph of Resonating Power: -5 rage cost for Thunder Clap
+            if (lvl >= 15 && spellId == GetSpell(THUNDER_CLAP_1))
+                flatbonus += 50;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+        {
+            //casttime is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Improved Slam: -100% sec cast time for Slam
+            if (lvl >= 40 && spellId == GetSpell(SLAM_1) && me->HasAura(BLOODSURGE_BUFF))
+                timebonus += casttime;
+
+            //flat mods
+            //Improved Slam: -1.0 sec cast time for Slam
+            if (lvl >= 40 && spellId == GetSpell(SLAM_1))
+                timebonus += 1000;
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            uint32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Intensify Rage: -33% cooldown for Bloodrage, Berserker Rage, Recklessness and Death Wish
+            if (lvl >= 40 &&
+                (spellId == GetSpell(BLOODRAGE_1) || spellId == GetSpell(BERSERKERRAGE_1) ||
+                spellId == GetSpell(RECKLESSNESS_1) || spellId == GetSpell(DEATHWISH_1)))
+                pctbonus += 0.33f;
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+                pctbonus += 0.07f;
+
+            //flat mods
+            //Improved Disciplines: -60 sec cooldown for Shield Wall, Retaliation and Recklessness
+            if (lvl >= 35 &&
+                (spellId == GetSpell(SHIELD_WALL_1) ||
+                spellId == GetSpell(RETALIATION_1) ||
+                spellId == GetSpell(RECKLESSNESS_1)))
+                timebonus += 60000;
+            //Unrelenting Assault (part 1): -4 sec cooldown for Overpower and Revenge (not for tanks)
+            if (lvl >= 50 && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+                timebonus += 4000;
+            //Improved Intercept: -10 sec cooldown for Intercept
+            if (lvl >= 30 && spellId == GetSpell(INTERCEPT_1))
+                timebonus += 10000;
+            //Shield Mastery (part 2): -20 sec cooldown for Shield Block
+            if (lvl >= 20 && spellId == GetSpell(SHIELD_BLOCK_1))
+                timebonus += 20000;
+            //Improved Disarm (part 1): -20 sec cooldown for Disarm
+            if (lvl >= 25 && spellId == GetSpell(DISARM_1))
+                timebonus += 20000;
+            //Improved Mortal Strike (part 2): -1 sec cooldown for Mortal Strike
+            if (lvl >= 25 && spellId == GetSpell(MORTALSTRIKE_1))
+                timebonus += 1000;
+            //Glyph of Bladestorm: -15 sec cooldown for Bladestorm
+            if (lvl >= 60 && spellId == GetSpell(BLADESTORM_1))
+                timebonus += 15000;
+            //Glyph of Last Stand: -1 min cooldown for Last Stand
+            if (lvl >= 20 && spellId == GetSpell(LAST_STAND_1))
+                timebonus += 60000;
+            //Glyph of Spell Reflection: -1 sec cooldown for Spell Reflection
+            if (lvl >= 65 && spellId == GetSpell(SPELL_REFLECTION_1))
+                timebonus += 60000;
+            //Glyph of Whirlwind: -2 sec cooldown for Whirlwind
+            if (lvl >= 36 && spellId == GetSpell(WHIRLWIND_1))
+                timebonus += 2000;
+            //Warrior T9 2P Bonus (id: 67269): -2 sec cooldown for Taunt (tanks only)
+            if (lvl >= 68 && IsTank() && spellId == GetSpell(TAUNT_1))
+                timebonus += 2000;
+            //Improved Challenging Shout (id: 12327): -2 min cooldown for Challenging Shout (tanks only)
+            if (lvl >= 30 && IsTank() && spellId == GetSpell(CHALLENGING_SHOUT_1))
+                timebonus += 120000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Unrelenting Assault (part 1): -4 sec cooldown for Overpower and Revenge (not for tanks)
+            if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+                timebonus += 4000;
+            //Improved Mortal Strike (part 2): -1 sec cooldown for Mortal Strike
+            if (lvl >= 25 && spellId == GetSpell(MORTALSTRIKE_1))
+                timebonus += 1000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+                timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            uint32 spellId = spellInfo->Id;
+
+            if (spellId == GetSpell(LAST_STAND_1))
+            {
+                BotWhisper("Last Stand used!");
+            }
+            if (spellId == GetSpell(SHIELD_WALL_1))
+            {
+                BotWhisper("Shield Wall used!");
+                //uint32 cd = 300000;
+                //ApplyBotSpellCooldownMods(sSpellMgr->GetSpellInfo(GetSpell(SHIELD_WALL_1)), cd);
+                SetSpellCooldown(RETALIATION_1, 12000);
+                //SetSpellCooldown(SHIELD_WALL_1, cd);
+                SetSpellCooldown(RECKLESSNESS_1, 12000);
+            }
+            if (spellId == GetSpell(RETALIATION_1))
+            {
+                //custom ability - no cooldown
+                uint32 cd = 300000;
+                ApplyBotSpellCooldownMods(sSpellMgr->GetSpellInfo(GetSpell(RETALIATION_1)), cd);
+                SetSpellCooldown(RETALIATION_1, cd);
+                SetSpellCooldown(SHIELD_WALL_1, 12000);
+                SetSpellCooldown(RECKLESSNESS_1, 12000);
+                return;
+            }
+            if (spellId == GetSpell(RECKLESSNESS_1))
+            {
+                //custom ability - no cooldown
+                uint32 cd = 300000;
+                ApplyBotSpellCooldownMods(sSpellMgr->GetSpellInfo(GetSpell(RECKLESSNESS_1)), cd);
+                SetSpellCooldown(RETALIATION_1, 12000);
+                SetSpellCooldown(SHIELD_WALL_1, 12000);
+                SetSpellCooldown(RECKLESSNESS_1, cd);
+                return;
+            }
+            if (spellId == GetSpell(OVERPOWER_1))
+            {
+                //suctom
+                float gcd = 1500.f;
+                ApplyBotSpellGlobalCooldownMods(spellInfo, gcd);
+                GC_Timer = uint32(gcd);
+            }
+            if (spellId == GetSpell(CLEAVE_1) || spellId == GetSpell(HEROIC_STRIKE_1) || spellId == GetSpell(SLAM_1))
+            {
+                //once per swing
+                SetSpellCooldown(spellId, me->getAttackTimer(BASE_ATTACK));
+            }
+            if (spellId == GetSpell(VIGILANCE_1))
+            {
+                SetSpellCooldown(VIGILANCE_1, 30000); //no initial cooldown
+            }
+            if (spellId == GetSpell(SLAM_1) && me->HasAura(BLOODSURGE_BUFF))
+            {
+                me->RemoveAura(BLOODSURGE_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            if (spellId == GetSpell(HEROIC_STRIKE_1) && me->HasAura(GLYPH_OF_REVENGE_BUFF))
+            {
+                me->RemoveAura(GLYPH_OF_REVENGE_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            if (spellId == GetSpell(SHIELD_SLAM_1) && me->HasAura(SWORD_AND_BOARD_BUFF))
+            {
+                me->RemoveAura(SWORD_AND_BOARD_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            if (spellId == GetSpell(OVERPOWER_1) && me->HasAura(TASTE_FOR_BLOOD_BUFF))
+            {
+                me->RemoveAura(TASTE_FOR_BLOOD_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            if (spellId == TASTE_FOR_BLOOD_BUFF)
+            {
+                SetSpellCooldown(TASTE_FOR_BLOOD_BUFF, 6000);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == BATTLESTANCE_1 || spellId == DEFENSIVESTANCE_1 || spellId == BERSERKERSTANCE_1)
+            {
+                //stance mastery impl
+                uint32 temprage = 0;
+                uint32 myrage = rage;
+                if (me->getLevel() >= 20)
+                    temprage = myrage > 250 ? 250 : myrage;
+                else if (me->getLevel() >= 15)
+                    temprage = myrage > 100 ? 100 : myrage;
+
+                battleStance = (spellId == BATTLESTANCE_1);
+                defensiveStance = (spellId == DEFENSIVESTANCE_1);
+                berserkerStance = (spellId == BERSERKERSTANCE_1);
+                me->SetPower(POWER_RAGE, temprage);
+                stancetimer = 2100 - me->getLevel() * 20; //500 on 80
+                GC_Timer = temptimer;
+            }
+            if (spellId == GetSpell(BERSERKERRAGE_1))
+            {
+                //Improved Berserker Rage: 20 rage bonus when used
+                if (me->getLevel() >= 35)
+                    me->CastSpell(me, BERSERKER_RAGE_EFFECT, true);
+            }
+            if (spellId == SWORD_AND_BOARD_BUFF)
+            {
+                //Sword And Board: remove Shield Slam cooldown
+                ResetSpellCooldown(SHIELD_SLAM_1);
+            }
+            if (spellId == VIGILANCE_PROC)
+            {
+                //Vigilance: remove Taunt cooldown
+                ResetSpellCooldown(TAUNT_1);
+            }
+            if (spellId == GetSpell(SHIELD_WALL_1))
+            {
+                //Shield Wall Duration (id: 60175): 3 sec increased Shield Wall duration
+                if (Aura* wall = me->GetAura(spellId))
+                {
+                    int32 dur = wall->GetDuration() + 3000;
+                    wall->SetDuration(dur);
+                    wall->SetMaxDuration(dur);
+                }
+            }
+
+            switch (spellId)
+            {
+                case VICTORIOUS_SPELL:
+                    VICTORIOUS = true;
+                    break;
+                default:
+                    break;
+            }
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(PIERCING_HOWL_1))
+            {
+                //Piercing Howl: 4 sec duraion increase (exclude players)
+                if (target->GetTypeId() != TYPEID_PLAYER)
+                {
+                    if (Aura* howl = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = howl->GetDuration() + 4000;
+                        howl->SetDuration(dur);
+                        howl->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if (spellId == GetSpell(BATTLESHOUT_1) || spellId == GetSpell(COMMANDING_SHOUT_1))
+            {
+                if (me->getLevel() >= 15)
+                {
+                    //Commanding Presence: +25% increased effect (melee AP / HP)
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                    {
+                        int32 amount = eff->GetAmount();
+                        amount = amount * 5 / 4;
+                        eff->ChangeAmount(amount);
+                    }
+                }
+            }
+            if (spellId == GetSpell(REVENGE_1))
+            {
+                //zzzOLD Revenge Stun (25% chance)
+                if (me->getLevel() >= 25 && urand(1,100) <= 25)
+                    me->CastSpell(target, REVENGE_STUN_SPELL, true);
+            }
+            if (spellId == GetSpell(THUNDER_CLAP_1))
+            {
+                //We make it tanking bonus only, to prevent imbalance
+                if (me->getLevel() >= 15 && IsTank())
+                {
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_1, me->GetGUID());
+                    if (eff)
+                    {
+                        int32 amount = eff->GetAmount();
+                        //Improved Thunder Clap (part 3): 10% extra slow
+                        amount += (-10);
+                        //Conqueror Thunder Clap Bonus: 50% increased effect
+                        if (me->getLevel() >= 60)
+                            amount = amount * 3 / 2;
+
+                        eff->ChangeAmount(amount);
+                    }
+                }
+            }
+            if (spellId == GetSpell(OVERPOWER_1))
+            {
+                me->ClearReactive(REACTIVE_OVERPOWER);
+                //Unrelenting Assault (part 3): reduce spells efficiency
+                if (UNRELENTING_ASSAULT && target->HasUnitState(UNIT_STATE_CASTING))
+                    target->CastSpell(target, UNRELENTING_ASSAULT_SPELL, true);
+            }
+            if (spellId == GetSpell(BATTLESHOUT_1) || spellId == GetSpell(COMMANDING_SHOUT_1))
+            {
+                //Glyph of Battle/Command + 2 min duration (8 for bots)
+                if (Aura* shout = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = shout->GetDuration() + 480000;
+                    shout->SetDuration(dur);
+                    shout->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(REND_1))
+            {
+                //Glyph of Rending + 6 sec duration
+                if (Aura* rend = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = rend->GetDuration() + 6000;
+                    rend->SetDuration(dur);
+                    rend->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(INTERVENE_1))
+            {
+                //Glyph of Intervene + 2 bonus charges
+                if (Aura* vene = target->GetAura(spellId, me->GetGUID()))
+                {
+                    vene->SetCharges(vene->GetCharges() + 2);
+                }
+            }
+            if (spellId == GetSpell(VICTORY_RUSH_1))
+            {
+                me->RemoveAura(VICTORIOUS_SPELL);
+                VICTORIOUS = false;
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            stancetimer = 0;
+            ragetimer = 1500;
+            ragetimer2 = 3000;
+            shoutCheckTimer = 5000;
+
+            vigilanceTargetGuid = 0;
+
+            battleStance = true;
+            defensiveStance = false;
+            berserkerStance = false;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            me->setPowerType(POWER_RAGE);
+            rage = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (stancetimer > diff)                 stancetimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+            if (shoutCheckTimer > diff)             shoutCheckTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(INTIMIDATING_SHOUT_1);
+            InitSpellMap(ENRAGED_REGENERATION_1);
+            InitSpellMap(CHARGE_1);
+            InitSpellMap(OVERPOWER_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(TAUNT_1) : RemoveSpell(TAUNT_1);
+            InitSpellMap(BLOODRAGE_1);
+            InitSpellMap(BERSERKERRAGE_1);
+            InitSpellMap(INTERCEPT_1);
+            InitSpellMap(CLEAVE_1);
+            InitSpellMap(HAMSTRING_1);
+            InitSpellMap(INTERVENE_1);
+            InitSpellMap(WHIRLWIND_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(BLADESTORM_1) : RemoveSpell(BLADESTORM_1);
+            InitSpellMap(BATTLESHOUT_1);
+            InitSpellMap(REND_1);
+            InitSpellMap(EXECUTE_1);
+            InitSpellMap(PUMMEL_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(MORTALSTRIKE_1) : RemoveSpell(MORTALSTRIKE_1);
+            InitSpellMap(SLAM_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SUNDER_1) : RemoveSpell(SUNDER_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(SWEEPING_STRIKES_1) : RemoveSpell(SWEEPING_STRIKES_1);
+            InitSpellMap(BATTLESTANCE_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(DEFENSIVESTANCE_1) : RemoveSpell(DEFENSIVESTANCE_1);
+   /*Quest*/lvl >= 30 ? InitSpellMap(BERSERKERSTANCE_1) : RemoveSpell(BERSERKERSTANCE_1);
+ /*Special*/lvl >= 50 ? InitSpellMap(RECKLESSNESS_1) : RemoveSpell(RECKLESSNESS_1);
+ /*Special*/lvl >= 20 ? InitSpellMap(RETALIATION_1) : RemoveSpell(RETALIATION_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(DEATHWISH_1) : RemoveSpell(DEATHWISH_1);
+            InitSpellMap(VICTORY_RUSH_1);
+            InitSpellMap(THUNDER_CLAP_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(LAST_STAND_1) : RemoveSpell(LAST_STAND_1);
+            InitSpellMap(REVENGE_1);
+            InitSpellMap(SHIELD_BLOCK_1);
+            InitSpellMap(SHIELD_SLAM_1);
+            InitSpellMap(SPELL_REFLECTION_1);
+            InitSpellMap(DISARM_1);
+            InitSpellMap(SHIELD_WALL_1);
+            InitSpellMap(SHIELD_BASH_1);
+            InitSpellMap(HEROIC_THROW_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(CONCUSSION_BLOW_1) : RemoveSpell(CONCUSSION_BLOW_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(VIGILANCE_1) : RemoveSpell(VIGILANCE_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(DEVASTATE_1) : RemoveSpell(DEVASTATE_1);
+            InitSpellMap(MOCKING_BLOW_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(SHOCKWAVE_1) : RemoveSpell(SHOCKWAVE_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(PIERCING_HOWL_1) : RemoveSpell(PIERCING_HOWL_1);
+            InitSpellMap(HEROIC_STRIKE_1);
+            InitSpellMap(CHALLENGING_SHOUT_1);
+            InitSpellMap(COMMANDING_SHOUT_1);
+
+ /*SPECIAL*/InitSpellMap(TASTE_FOR_BLOOD_BUFF, true);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            UNRELENTING_ASSAULT = (level >= 35);
+            RefreshAura(WC5, level >= 70 ? 1 : 0);
+            RefreshAura(WC4, level >= 68 && level < 70 ? 1 : 0);
+            RefreshAura(WC3, level >= 66 && level < 68 ? 1 : 0);
+            RefreshAura(WC2, level >= 64 && level < 66 ? 1 : 0);
+            RefreshAura(WC1, level >= 62 && level < 64 ? 1 : 0);
+            RefreshAura(FLURRY5, level >= 39 ? 1 : 0);
+            RefreshAura(FLURRY4, level >= 38 && level < 39 ? 1 : 0);
+            RefreshAura(FLURRY3, level >= 37 && level < 38 ? 1 : 0);
+            RefreshAura(FLURRY2, level >= 36 && level < 37 ? 1 : 0);
+            RefreshAura(FLURRY1, level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(SWORD_SPEC5, level >= 60 ? 2 : level >= 50 ? 1 : 0);
+            RefreshAura(SWORD_SPEC4, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(SWORD_SPEC3, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(SWORD_SPEC2, level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(SWORD_SPEC1, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(RAMPAGE, level >= 60 ? 1 : 0);
+            RefreshAura(TRAUMA2, level >= 55 ? 1 : 0);
+            RefreshAura(TRAUMA1, level >= 35 && level < 55 ? 1 : 0);
+            RefreshAura(BLOOD_FRENZY, level >= 45 ? 1 : 0);
+            RefreshAura(SECOND_WIND, level >= 40 ? 1 : 0);
+            RefreshAura(TOUGHNESS, level >= 40 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(IMP_HAMSTRING, level >= 40 ? 2 : level >= 35 ? 1 : 0);
+            RefreshAura(SHIELD_SPECIALIZATION, level >= 15 ? 1 : 0);
+            RefreshAura(GAG_ORDER, level >= 30 ? 1 : 0);
+            RefreshAura(IMPROVED_SPELL_REFLECTION, level >= 25 ? 1 : 0);
+            RefreshAura(IMPROVED_DISARM, level >= 25 ? 1 : 0);
+            RefreshAura(VITALITY, level >= 45 ? 1 : 0);
+            RefreshAura(CRITICAL_BLOCK, level >= 50 ? 1 : 0);
+            RefreshAura(SWORD_AND_BOARD, level >= 55 ? 1 : 0);
+            RefreshAura(ARMORED_TO_THE_TEETH, level >= 20 ? 1 : 0);
+            RefreshAura(ENDLESS_RAGE, level >= 55 ? 1 : 0);
+            RefreshAura(BLOODSURGE, level >= 50 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD3, level >= 30 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD2, level >= 28 && level < 30 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD1, level >= 25 && level < 28 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE3, level >= 30 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE2, level >= 25 && level < 30 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE1, level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(WARRIOR_T10_4P, level >= 60 ? 1 : 0);
+            RefreshAura(GLYPH_BLOCKING);
+            RefreshAura(GLYPH_DEVASTATE);
+            RefreshAura(GLYPH_EXECUTION);
+            RefreshAura(GLYPH_HEROIC_STRIKE);
+            RefreshAura(GLYPH_REVENGE);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case ENRAGED_REGENERATION_1:
+                case BLOODRAGE_1:
+                case BERSERKERRAGE_1:
+                case BATTLESHOUT_1:
+                case COMMANDING_SHOUT_1:
+                case DEATHWISH_1:
+                    return true;
+                case BATTLESTANCE_1:
+                    return !battleStance;
+                case DEFENSIVESTANCE_1:
+                    return !defensiveStance;
+                case BERSERKERSTANCE_1:
+                    return !berserkerStance;
+                case SWEEPING_STRIKES_1:
+                    return battleStance || berserkerStance;
+                //case RETALIATION_1:
+                //    return battleStance;
+                //case RECKLESSNESS_1:
+                //    return berserkerStance;
+                case SHIELD_WALL_1:
+                    return CanBlock() && defensiveStance;
+                case SHIELD_BLOCK_1:
+                    return CanBlock();
+                case LAST_STAND_1:
+                case VIGILANCE_1:
+                    return IsTank();
+                default:
+                    return false;
+            }
+        }
+
+        float GetBotArmorPenetrationCoef() const
+        {
+            float bonus = 0.0f;
+
+            if (battleStance)
+            {
+                bonus += 0.1f;
+                //Warrior T10 4P Bonus (part 1): 6% additional armor penetration in Battle Stance
+                if (me->getLevel() >= 75)
+                    bonus += 0.06f;
+            }
+
+            //Mace Specialization: 15% armor penetration
+            if (me->getLevel() >= 30)
+                if (Item const* weap = GetEquips(0))
+                    if (ItemTemplate const* proto = weap->GetTemplate())
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2)
+                            bonus += 0.15f;
+
+            return bonus;
+        }
+
+    private:
+/*tmrs*/uint32 stancetimer, ragetimer, ragetimer2, shoutCheckTimer;
+/*misc*/int32 rage;
+/*misc*/uint64 vigilanceTargetGuid;
+/*misc*/float rageIncomeMult, rageLossMult;
+/*Chck*/bool battleStance, defensiveStance, berserkerStance, UNRELENTING_ASSAULT, VICTORIOUS;
+
+        enum WarriorBaseSpells
+        {
+            INTIMIDATING_SHOUT_1                    = 5246,
+            ENRAGED_REGENERATION_1                  = 55694,
+            CHARGE_1                                = 11578,
+            OVERPOWER_1                             = 7384,
+            TAUNT_1                                 = 355,
+            BLOODRAGE_1                             = 2687,
+            BERSERKERRAGE_1                         = 18499,
+            INTERCEPT_1                             = 20252,
+            CLEAVE_1                                = 845,
+            HAMSTRING_1                             = 1715,
+            INTERVENE_1                             = 3411,
+            WHIRLWIND_1                             = 1680,
+            BLADESTORM_1                            = 46924,
+            BATTLESHOUT_1                           = 6673,
+            REND_1                                  = 772,
+            EXECUTE_1                               = 5308,
+            PUMMEL_1                                = 6552,
+  /*Talent*/MORTALSTRIKE_1                          = 12294,
+            SLAM_1                                  = 1464,
+            SUNDER_1                                = 7386,
+  /*Talent*/SWEEPING_STRIKES_1                      = 12328,
+            BATTLESTANCE_1                          = 2457,
+            DEFENSIVESTANCE_1                       = 71,
+            BERSERKERSTANCE_1                       = 2458,
+            RECKLESSNESS_1                          = 13847,//1719, original warrior spell
+            RETALIATION_1                           = 22857,//20230, original warrior spell
+  /*Talent*/DEATHWISH_1                             = 12292,
+            VICTORY_RUSH_1                          = 34428,
+            THUNDER_CLAP_1                          = 6343,
+  /*Talent*/LAST_STAND_1                            = 12975,
+            REVENGE_1                               = 6572,
+            SHIELD_BLOCK_1                          = 2565,
+            SHIELD_SLAM_1                           = 23922,
+            SPELL_REFLECTION_1                      = 23920,
+            DISARM_1                                = 676,
+            SHIELD_WALL_1                           = 871,
+            SHIELD_BASH_1                           = 72,
+            HEROIC_THROW_1                          = 57755,
+  /*Talent*/CONCUSSION_BLOW_1                       = 12809,
+  /*Talent*/VIGILANCE_1                             = 50720,
+  /*Talent*/DEVASTATE_1                             = 20243,
+            MOCKING_BLOW_1                          = 694,
+            SHOCKWAVE_1                             = 46968,
+            PIERCING_HOWL_1                         = 12323,
+            HEROIC_STRIKE_1                         = 78,
+            CHALLENGING_SHOUT_1                     = 1161,
+            COMMANDING_SHOUT_1                      = 469
+        };
+        enum WarriorPassives
+        {
+        //Talents
+            WC1  /*WRECKING CREW1*/                 = 46867,
+            WC2  /*WRECKING CREW2*/                 = 56611,
+            WC3  /*WRECKING CREW3*/                 = 56612,
+            WC4  /*WRECKING CREW4*/                 = 56613,
+            WC5  /*WRECKING CREW5*/                 = 56614,
+            FLURRY1                                 = 16256,
+            FLURRY2                                 = 16281,
+            FLURRY3                                 = 16282,
+            FLURRY4                                 = 16283,
+            FLURRY5                                 = 16284,
+            SWORD_SPEC1                             = 12281,
+            SWORD_SPEC2                             = 12812,
+            SWORD_SPEC3                             = 12813,
+            SWORD_SPEC4                             = 12814,
+            SWORD_SPEC5                             = 12815,
+            BLOOD_CRAZE1                            = 16487,
+            BLOOD_CRAZE2                            = 16489,
+            BLOOD_CRAZE3                            = 16492,
+            TASTE_FOR_BLOOD1                        = 56636,
+            TASTE_FOR_BLOOD2                        = 56637,
+            TASTE_FOR_BLOOD3                        = 56638,
+            UNRELENTING_ASSAULT1                    = 46859,
+            UNRELENTING_ASSAULT2                    = 46860,
+            TRAUMA1                                 = 46854,
+            TRAUMA2                                 = 46855,
+            BLOOD_FRENZY                            = 29859,
+            RAMPAGE                                 = 29801,
+            SECOND_WIND                             = 29838,//rank 2
+            TOUGHNESS                               = 12764,//rank 5
+            IMP_HAMSTRING                           = 23695,//rank 3
+            SHIELD_SPECIALIZATION                   = 12727,//rank 5
+            GAG_ORDER                               = 12958,//rank 2
+            IMPROVED_SPELL_REFLECTION               = 59089,//rank 2
+            IMPROVED_DISARM                         = 12804,//rank 2
+            VITALITY                                = 29144,//rank 3
+            CRITICAL_BLOCK                          = 47296,//rank 3
+            SWORD_AND_BOARD                         = 46953,//rank 3
+            ARMORED_TO_THE_TEETH                    = 61222,//rank 3
+            ENDLESS_RAGE                            = 29623,
+            BLOODSURGE                              = 46915,//rank 3
+        //other
+            WARRIOR_T10_4P                          = 70844,
+            GLYPH_BLOCKING                          = 58375,
+            GLYPH_DEVASTATE                         = 58388,
+            GLYPH_EXECUTION                         = 58367,
+            GLYPH_HEROIC_STRIKE                     = 58357,
+            GLYPH_REVENGE                           = 58364
+        };
+        enum WarriorSpecial
+        {
+            TASTE_FOR_BLOOD_BUFF                    = 60503,
+            //LAMBS_TO_THE_SLAUGHTER_BUFF             = 84586,
+            SWORD_AND_BOARD_BUFF                    = 50227,
+            BLOODSURGE_BUFF                         = 46916,//"Slam!"
+            GLYPH_OF_REVENGE_BUFF                   = 58363,
+            UNRELENTING_ASSAULT_SPELL               = 65925,//64849
+            VICTORIOUS_SPELL                        = 32216,
+            REVENGE_STUN_SPELL                      = 12798,
+            //COLOSSUS_SMASH_EFFECT                   = 108126,
+            //SWORD_SPECIALIZATION_TRIGGERED          = 16459,
+            VIGILANCE_PROC                          = 50725,
+            BERSERKER_RAGE_EFFECT                   = 23691,//rank 2
+
+            BLESSING_OF_MIGHT_1                     = 19740,
+            GREATER_BLESSING_OF_MIGHT_1             = 25782
+        };
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
new file mode 100644
index 0000000..badd170
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommands.cpp
@@ -0,0 +1,937 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Chat.h"
+//#include "Config.h"
+//#include "DBCStructure.h"
+#include "Group.h"
+#include "Language.h"
+#include "Player.h"
+//#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+//#include "Spell.h"
+#include "SpellInfo.h"
+/*
+Name: script_bot_commands
+%Complete: ???
+Comment: Npcbot related commands
+Category: commandscripts/custom/
+*/
+//RBAC_PERM_GM_COMMANDS = 197
+#define GM_COMMANDS rbac::RBACPermissions(197)
+
+class script_bot_commands : public CommandScript
+{
+private:
+    typedef std::pair<uint32 /*id*/, std::string /*name*/> BotPair;
+    static bool sortbots(BotPair p1, BotPair p2)
+    {
+        return p1.first < p2.first;
+    }
+
+public:
+    script_bot_commands() : CommandScript("script_bot_commands") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand npcbotSetCommandTable[] =
+        {
+            { "faction",    GM_COMMANDS,                        false, &HandleNpcSetFactionCommand,             "", NULL },
+            { "owner",      GM_COMMANDS,                        false, &HandleNpcSetOwnerCommand,               "", NULL },
+            { NULL,         0,                                  false, NULL,                                    "", NULL }
+        };
+
+        static ChatCommand npcbotCommandTable[] =
+        {
+            { "set",        GM_COMMANDS,                        false, NULL,                   "", npcbotSetCommandTable },
+            { "add",        GM_COMMANDS,                        false, &HandleNpcBotAddCommand,                 "", NULL },
+            { "remove",     GM_COMMANDS,                        false, &HandleNpcBotRemoveCommand,              "", NULL },
+            { "spawn",      GM_COMMANDS,                        false, &HandleNpcBotSpawnCommand,               "", NULL },
+            { "delete",     GM_COMMANDS,                        false, &HandleNpcBotDeleteCommand,              "", NULL },
+            { "lookup",     GM_COMMANDS,                        false, &HandleNpcBotLookupCommand,              "", NULL },
+            { "revive",     GM_COMMANDS,                        false, &HandleNpcBotReviveCommand,              "", NULL },
+            { "cast",       GM_COMMANDS,                        false, &HandleNpcBotCastCustomSpell,            "", NULL },
+            { NULL,         0,                                  false, NULL,                                    "", NULL }
+        };
+
+        static ChatCommand commandTable[] =
+        {
+            { "npcbot",     GM_COMMANDS,                        false, NULL,                      "", npcbotCommandTable },
+            { NULL,         0,                                  false, NULL,                                    "", NULL }
+        };
+        return commandTable;
+    }
+
+    static bool HandleNpcBotCastCustomSpell(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+        handler->SendSysMessage("This is a dev command. Do not use it.");
+
+        //uint32 trig = SPELL_TRANSPARENCY_50; //transpar
+        //SpellInfo* trigInfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(trig));
+
+        //trigInfo->Dispel = DISPEL_NONE;
+        //trigInfo->Mechanic = MECHANIC_NONE;
+        //trigInfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+
+        //trigInfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //1 - instant //3 - 0.5 sec
+        //trigInfo->DurationEntry = sSpellDurationStore.LookupEntry(1); //1 - 10 sec //32 - 6 seconds
+        //trigInfo->ManaCost = 0;
+        //trigInfo->ManaCostPercentage = 0;
+        //trigInfo->ManaCostPerlevel = 0;
+        //trigInfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING);
+        //trigInfo->AttributesEx &= ~SPELL_ATTR1_CANT_TARGET_SELF;
+        //trigInfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH);
+        //trigInfo->AttributesEx2 |= SPELL_ATTR2_UNK22;
+        //trigInfo->AttributesEx5 |= SPELL_ATTR5_HASTE_AFFECT_DURATION;
+        //trigInfo->Targets = TARGET_FLAG_DEST_LOCATION;
+        //trigInfo->AuraInterruptFlags =
+        //    AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        //    AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+        //trigInfo->ChannelInterruptFlags = 0x00007C3C; //31788
+        //trigInfo->CasterAuraStateNot = 0;
+
+        //trigInfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+        //trigInfo->Effects[0].BasePoints = 1;
+        ////trigInfo->Effects[0].ValueMultiplier = 0.0f;
+        //trigInfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_CHANNEL_TARGET);
+        //trigInfo->Effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+        //trigInfo->Effects[0].ApplyAuraName = SPELL_AURA_NONE;
+        //trigInfo->Effects[0].Amplitude = 0;
+        //trigInfo->Effects[0].TriggerSpell = 0;
+        //trigInfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+
+
+        uint32 spellId = SPELL_MIRROR_IMAGE_BM; //69936
+        SpellInfo* sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        //sinfo->SpellLevel = 0;
+        //sinfo->MaxLevel = 80;
+        //sinfo->Dispel = DISPEL_NONE;
+        //sinfo->Mechanic = MECHANIC_NONE;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //1 - self only //6 - 100 yds
+        //sinfo->Speed = 25.f;
+        //sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //1 - instant //3 - 0.5 sec
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(566); //566 - 0 sec //3 - 60 sec //1 - 10 sec //32 - 6 seconds
+        sinfo->RecoveryTime = 3000;
+        sinfo->PowerType = POWER_MANA;
+        sinfo->ManaCost = 125;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        //sinfo->DmgClass = SPELL_DAMAGE_CLASS_MELEE;
+        //sinfo->PreventionType = SPELL_PREVENTION_TYPE_PACIFY;
+        //sinfo->EquippedItemClass = ITEM_CLASS_WEAPON;
+        //sinfo->EquippedItemSubClassMask = 0x0002A5F3;
+
+        //sinfo->Attributes &= ~(SPELL_ATTR0_UNK11);
+        sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT/* | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY*/);
+        //sinfo->AttributesEx &= ~SPELL_ATTR1_UNK11;
+        //sinfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH | SPELL_ATTR1_NO_THREAT);
+        sinfo->AttributesEx2 &= ~(SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS);
+        sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+        //sinfo->AttributesEx5 |= SPELL_ATTR5_HIDE_DURATION;
+        //sinfo->AttributesEx7 &= ~SPELL_ATTR7_HAS_CHARGE_EFFECT;
+        //sinfo->Targets |= TARGET_FLAG_DEST_LOCATION;
+        //sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT_ENEMY;
+        //sinfo->InterruptFlags = 0x0000000F; //15
+        //sinfo->AuraInterruptFlags =
+        //    AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        //    AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+        //sinfo->ChannelInterruptFlags = 0x00007C3C; //31788
+        //sinfo->CasterAuraStateNot = 0;
+
+        sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+        //sinfo->Effects[0].BasePoints = 9999;
+        //sinfo->Effects[0].ValueMultiplier = 0.0f;
+        sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        //sinfo->Effects[0].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->Effects[0].MiscValue = 0;
+        sinfo->Effects[0].MiscValueB = 0;
+        //sinfo->Effects[0].ApplyAuraName = SPELL_AURA_MOD_INVISIBILITY;
+        //sinfo->Effects[0].Amplitude = 0;
+        //sinfo->Effects[0].TriggerSpell = 0;
+        sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+
+        //sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+        //sinfo->Effects[1].BasePoints = 10;
+        //sinfo->Effects[1].RealPointsPerLevel = 0.5f;
+        //sinfo->Effects[1].ValueMultiplier = 1.0f;
+        //sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        //sinfo->Effects[1].TargetB = SpellImplicitTargetInfo(0);
+        //sinfo->Effects[1].ApplyAuraName = SPELL_AURA_MOD_INCREASE_SPEED;
+        //sinfo->Effects[1].Amplitude = 0;
+        //sinfo->Effects[1].TriggerSpell = 0;
+        //sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+
+        //sinfo->Effects[2].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+        //sinfo->Effects[2].BasePoints = 0;
+        //sinfo->Effects[2].ValueMultiplier = 0.0f;
+        //sinfo->Effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        //sinfo->Effects[2].TargetB = SpellImplicitTargetInfo(0);
+        //sinfo->Effects[2].ApplyAuraName = SPELL_AURA_NONE;
+        //sinfo->Effects[2].Amplitude = 0;
+        //sinfo->Effects[2].TriggerSpell = trig;
+        //sinfo->Effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+
+
+        return true;
+    }
+
+    static bool HandleNpcSetFactionCommand(ChatHandler* handler, const char* args)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !*args)
+        {
+            handler->SendSysMessage(".npcbot set faction #faction");
+            handler->SendSysMessage("Sets faction for selected npcbot (saved in DB). Use 'a', 'h' or 'm' as argument to set faction to alliance, horde or monsters (hostile to all)");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->GetIAmABot() || !bot->IsFreeBot())
+        {
+            handler->SendSysMessage("You must select uncontrolled npcbot.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint32 factionId = 0;
+        const std::string facStr = args;
+        char const* factionChar = facStr.c_str();
+
+        if (factionChar[0] == 'a')
+            factionId = 1802; //Alliance
+        else if (factionChar[0] == 'h')
+            factionId = 1801; //Horde
+        else if (factionChar[0] == 'm')
+            factionId = 14; //Monsters
+
+        if (!factionId)
+        {
+            char* pfactionid = handler->extractKeyFromLink((char*)args, "Hfaction");
+            factionId = atoi(pfactionid);
+        }
+
+        if (!sFactionTemplateStore.LookupEntry(factionId))
+        {
+            handler->PSendSysMessage(LANG_WRONG_FACTION, factionId);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_FACTION);
+        //"UPDATE characters_npcbot SET faction = ? WHERE entry = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, factionId);
+        stmt->setUInt32(1, bot->GetEntry());
+        CharacterDatabase.DirectExecute(stmt);
+
+        handler->PSendSysMessage("%s's faction set to %u", bot->GetName().c_str(), factionId);
+        bot->GetBotAI()->InitFaction();
+        return true;
+    }
+
+    static bool HandleNpcSetOwnerCommand(ChatHandler* handler, const char* args)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !*args)
+        {
+            handler->SendSysMessage(".npcbot set owner #guid | #name");
+            handler->SendSysMessage("Binds selected npcbot to new player owner using guid or name and updates owner in DB");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->GetIAmABot() || bot->GetBotAI()->GetBotOwnerGuid())
+        {
+            handler->SendSysMessage("This npcbot already has owner");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* characterName_str = strtok((char*)args, " ");
+        if (!characterName_str)
+            return false;
+
+        std::string characterName = characterName_str;
+        uint32 guidlow = (uint32)atoi(characterName_str);
+
+        if (guidlow)
+            sObjectMgr->GetPlayerNameByGUID(MAKE_NEW_GUID(guidlow, 0, HIGHGUID_PLAYER), characterName);
+        else
+            guidlow = sObjectMgr->GetPlayerGUIDByName(characterName);
+
+        if (!guidlow || !normalizePlayerName(characterName))
+        {
+            handler->PSendSysMessage("Player %s not found", characterName.c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        bot->GetBotAI()->SetBotOwnerGUID(guidlow);
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+        //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+        stmt->setUInt32(0, guidlow);
+        stmt->setUInt32(1, bot->GetEntry());
+        CharacterDatabase.Execute(stmt);
+
+        handler->PSendSysMessage("%s's new owner is %s (guidlow: %u)", bot->GetName().c_str(), characterName.c_str(), guidlow);
+        return true;
+    }
+
+    static bool HandleNpcBotLookupCommand(ChatHandler* handler, const char* args)
+    {
+        //this is just a modified '.lookup creature' command
+        if (!*args)
+        {
+            handler->SendSysMessage(".npcbot lookup #class");
+            handler->SendSysMessage("Looks up npcbots by #class, and returns all matches with their creature ID's.");
+            handler->PSendSysMessage("BOT_CLASS_WARRIOR = %u", uint32(BOT_CLASS_WARRIOR));
+            handler->PSendSysMessage("BOT_CLASS_PALADIN = %u", uint32(BOT_CLASS_PALADIN));
+            handler->PSendSysMessage("BOT_CLASS_HUNTER = %u", uint32(BOT_CLASS_HUNTER));
+            handler->PSendSysMessage("BOT_CLASS_ROGUE = %u", uint32(BOT_CLASS_ROGUE));
+            handler->PSendSysMessage("BOT_CLASS_PRIEST = %u", uint32(BOT_CLASS_PRIEST));
+            handler->PSendSysMessage("BOT_CLASS_DEATH_KNIGHT = %u", uint32(BOT_CLASS_DEATH_KNIGHT));
+            handler->PSendSysMessage("BOT_CLASS_SHAMAN = %u", uint32(BOT_CLASS_SHAMAN));
+            handler->PSendSysMessage("BOT_CLASS_MAGE = %u", uint32(BOT_CLASS_MAGE));
+            handler->PSendSysMessage("BOT_CLASS_WARLOCK = %u", uint32(BOT_CLASS_WARLOCK));
+            handler->PSendSysMessage("BOT_CLASS_DRUID = %u", uint32(BOT_CLASS_DRUID));
+            handler->PSendSysMessage("BOT_CLASS_BM = %u", uint32(BOT_CLASS_BM));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* classstr = strtok((char*)args, " ");
+        uint8 botclass = BOT_CLASS_NONE;
+
+        if (classstr)
+            botclass = (uint8)atoi(classstr);
+
+        if (botclass == BOT_CLASS_NONE || botclass >= BOT_CLASS_END)
+        {
+            handler->PSendSysMessage("Unknown bot class %u", uint32(botclass));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Looking for bots of class %u...", uint32(botclass));
+
+        uint8 localeIndex = handler->GetSessionDbLocaleIndex();
+        CreatureTemplateContainer const* ctc = sObjectMgr->GetCreatureTemplates();
+        typedef std::list<BotPair> BotList;
+        BotList botlist;
+        for (CreatureTemplateContainer::const_iterator itr = ctc->begin(); itr != ctc->end(); ++itr)
+        {
+            uint32 id = itr->second.Entry;
+            if (id < BOT_ENTRY_BEGIN || id > BOT_ENTRY_END) continue;
+            uint32 trainer_class = itr->second.trainer_class;
+            if (trainer_class != botclass) continue;
+
+            if (CreatureLocale const* creatureLocale = sObjectMgr->GetCreatureLocale(id))
+            {
+                if (creatureLocale->Name.size() > localeIndex && !creatureLocale->Name[localeIndex].empty())
+                {
+                    botlist.push_back(BotPair(id, creatureLocale->Name[localeIndex]));
+                    continue;
+                }
+            }
+
+            std::string name = itr->second.Name;
+            if (name.empty())
+                continue;
+
+            botlist.push_back(BotPair(id, name));
+        }
+
+        if (botlist.empty())
+        {
+            handler->SendSysMessage(LANG_COMMAND_NOCREATUREFOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        botlist.sort(&script_bot_commands::sortbots);
+
+        for (BotList::const_iterator itr = botlist.begin(); itr != botlist.end(); ++itr)
+        {
+            uint32 id = itr->first;
+            char const* name = itr->second.c_str();
+            handler->PSendSysMessage(LANG_CREATURE_ENTRY_LIST_CHAT, id, id, name);
+        }
+
+        return true;
+    }
+
+    static bool HandleNpcBotDeleteCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot)
+        {
+            handler->SendSysMessage(".npcbot delete");
+            handler->SendSysMessage("Deletes selected npcbot spawn from world and DB");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot())
+        {
+            handler->SendSysMessage("No npcbot selected");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* botowner = bot->GetBotOwner()->ToPlayer())
+            botowner->GetBotMgr()->RemoveBot(bot->GetGUID(), BOT_REMOVE_DISMISS);
+
+        uint32 id = bot->GetEntry();
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP);
+        //"SELECT equipMhEx, equipOhEx, equipRhEx, equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck
+        //FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res = CharacterDatabase.Query(stmt);
+        ASSERT(res);
+
+        Field* fields = res->Fetch();
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            if (fields[i].GetUInt32())
+            {
+                handler->PSendSysMessage("%s still has eqipment assigned. Please remove equips before deleting bot!", bot->GetName().c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+        }
+
+        bot->CombatStop();
+        bot->DeleteFromDB();
+        bot->AddObjectToRemoveList();
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT);
+        //"DELETE FROM characters_npcbot WHERE entry = ?", CONNECTION_ASYNC
+        stmt->setUInt32(0, id);
+        CharacterDatabase.Execute(stmt);
+
+        handler->SendSysMessage("Npcbot successfully deleted.");
+        return true;
+    }
+
+    static bool HandleNpcBotSpawnCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+        {
+            handler->SendSysMessage(".npcbot spawn");
+            handler->SendSysMessage("Adds new npcbot spawn of given entry in world. You can shift-link the npc");
+            handler->SendSysMessage("Syntax: .npcbot spawn #entry");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* charID = handler->extractKeyFromLink((char*)args, "Hcreature_entry");
+        if (!charID)
+            return false;
+
+        uint32 id = atoi(charID);
+
+        CreatureTemplate const* creInfo = sObjectMgr->GetCreatureTemplate(id);
+
+        if (!creInfo)
+        {
+            handler->PSendSysMessage("creature %u does not exist!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!(creInfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT))
+        {
+            handler->PSendSysMessage("creature %u is not a npcbot!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_OWNER);
+        //"SELECT owner FROM character_npcbot WHERE entry = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res1 = CharacterDatabase.Query(stmt);
+        if (res1)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `characters_npcbot` table!", id);
+            handler->SendSysMessage("If you want to replace this bot to new location use '.npc move' command");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_CREATURE_BY_ID);
+        //"SELECT guid FROM creature WHERE id = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res2 = WorldDatabase.Query(stmt);
+        if (res2)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `creature` table!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* chr = handler->GetSession()->GetPlayer();
+
+        if (chr->GetTransport())
+        {
+            handler->SendSysMessage("Cannot spawn bots on transport!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        float x = chr->GetPositionX();
+        float y = chr->GetPositionY();
+        float z = chr->GetPositionZ();
+        float o = chr->GetOrientation();
+        Map* map = chr->GetMap();
+
+        if (map->Instanceable())
+        {
+            handler->SendSysMessage("Cannot spawn bots in instances!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* creature = new Creature();
+        if (!creature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), map, chr->GetPhaseMaskForSpawn(), id, x, y, z, o))
+        {
+            delete creature;
+            return false;
+        }
+
+        uint8 roleMask = BOT_ROLE_DPS;
+
+        uint8 m_class = creature->GetCreatureTemplate()->trainer_class;
+        if (!(m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE ||
+            m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT ||
+            m_class == CLASS_SHAMAN || m_class == BOT_CLASS_BM))
+            roleMask |= BOT_ROLE_RANGED;
+        if (m_class == CLASS_PRIEST || m_class == CLASS_DRUID ||
+            m_class == CLASS_SHAMAN || m_class == CLASS_PALADIN)
+            roleMask |= BOT_ROLE_HEAL;
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+        //"INSERT INTO characters_npcbot (entry, roles) VALUES (?, ?)", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        stmt->setUInt8(1, roleMask);
+        CharacterDatabase.DirectExecute(stmt);
+
+        creature->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), chr->GetPhaseMaskForSpawn());
+
+        uint32 db_guid = creature->GetDBTableGUIDLow();
+        if (!creature->LoadBotCreatureFromDB(db_guid, map))
+        {
+            handler->SendSysMessage("Cannot load npcbot from DB!");
+            handler->SetSentErrorMessage(true);
+            //return false;
+            delete creature;
+            return false;
+        }
+
+        sObjectMgr->AddCreatureToGrid(db_guid, sObjectMgr->GetCreatureData(db_guid));
+
+        handler->SendSysMessage("Npcbot successfully spawned.");
+        return true;
+    }
+
+    static bool HandleNpcBotJumpCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        uint64 sel = player->GetTarget();
+        if (!sel)
+            return false;
+
+        Creature* bot = ObjectAccessor::GetObjectInWorld(sel, (Creature*)NULL);
+        if (!bot/* || (!bot->GetIAmABot() && !bot->GetIAmABotsPet())*/)
+            return false;
+
+        float speedZ = 10.0f;
+        float dist = bot->GetExactDist2d(player->GetPositionX(), player->GetPositionY());
+        float speedXY = dist;
+
+        bot->StopMoving();
+        bot->GetMotionMaster()->Clear();
+        bot->GetMotionMaster()->MoveJump(*player, speedXY, speedZ);
+
+        return true;
+    }
+
+    static bool HandleNpcBotSummonCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+            return false;
+
+        char* guidLowstr = strtok((char*)args, " ");
+        uint32 guidLow = 0;
+
+        if (guidLowstr)
+            guidLow = (uint32)atoi(guidLowstr);
+
+        if (!guidLow)
+            return false;
+
+        QueryResult result = WorldDatabase.PQuery("SELECT id FROM creature WHERE guid = %u", guidLow);
+        if (!result)
+            return false;
+
+        Field* field = result->Fetch();
+        uint32 id = field[0].GetUInt32();
+
+        Player* player = handler->GetSession()->GetPlayer();
+
+        if (Creature* cre = ObjectAccessor::GetObjectInOrOutOfWorld(MAKE_NEW_GUID(guidLow, id, HIGHGUID_UNIT), (Creature*)NULL))
+        {
+            if (cre->GetIAmABot() && !cre->GetBotAI()->GetBotOwnerGuid())
+            {
+                BotMgr::TeleportBot(cre, player->GetMap(), player);
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    static bool HandleNpcBotInfoCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->GetTarget())
+        {
+            handler->PSendSysMessage(".npcbot info");
+            handler->PSendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your party members");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master || (owner->GetGroup() ? !owner->GetGroup()->IsMember(master->GetGUID()) : master->GetGUID() != owner->GetGUID()))
+        {
+            handler->PSendSysMessage("You should select self or one of your party members.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!master->HaveBot())
+        {
+            handler->PSendSysMessage("%s has no NpcBots!", master->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Listing NpcBots for %s", master->GetName().c_str());
+        handler->PSendSysMessage("Owned NpcBots: %u", master->GetNpcBotsCount());
+        for (uint8 i = BOT_CLASS_WARRIOR; i != BOT_CLASS_END; ++i)
+        {
+            uint8 count = 0;
+            uint8 alivecount = 0;
+            BotMap const* map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                if (Creature* cre = itr->second)
+                {
+                    if (cre->GetBotClass() == i)
+                    {
+                        ++count;
+                        if (cre->IsAlive())
+                            ++alivecount;
+                    }
+                }
+            }
+            if (count == 0)
+                continue;
+
+            char const* bclass;
+            if (i >= BOT_CLASS_EX_START)
+            {
+                ASSERT(count == 1);
+
+                switch (i)
+                {
+                    //|cffe6cc80|hxxx|h|r
+                    case BOT_CLASS_BM:              bclass = "|cff9d9d9d|hHas Blademaster!|h|r";    break;
+                    default:                        bclass = "wtf";                                 break;
+                }
+                handler->PSendSysMessage("%s (alive: %s)", bclass, (alivecount ? "yes" : "no"));
+            }
+            else
+            {
+                switch (i)
+                {
+                    case BOT_CLASS_WARRIOR:         bclass = "Warriors";        break;
+                    case BOT_CLASS_PALADIN:         bclass = "Paladins";        break;
+                    case BOT_CLASS_MAGE:            bclass = "Mages";           break;
+                    case BOT_CLASS_PRIEST:          bclass = "Priests";         break;
+                    case BOT_CLASS_WARLOCK:         bclass = "Warlocks";        break;
+                    case BOT_CLASS_DRUID:           bclass = "Druids";          break;
+                    case BOT_CLASS_DEATH_KNIGHT:    bclass = "Death Knights";   break;
+                    case BOT_CLASS_ROGUE:           bclass = "Rogues";          break;
+                    case BOT_CLASS_SHAMAN:          bclass = "Shamans";         break;
+                    case BOT_CLASS_HUNTER:          bclass = "Hunters";         break;
+                    default:                        bclass = "Unknown Class";   break;
+                }
+                handler->PSendSysMessage("%s: %u (alive: %u)", bclass, count, alivecount);
+            }
+        }
+        return true;
+    }
+
+    static bool HandleNpcBotDistanceCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            if (owner->HaveBot())
+            {
+                handler->PSendSysMessage("bot follow distance is %u", owner->GetBotFollowDist());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage(".npcbot distance");
+            handler->PSendSysMessage("Sets 'distance to target' at which bots will follow you");
+            handler->PSendSysMessage("if set to 0, bots will not attack anything unless you point them");
+            handler->PSendSysMessage("min: 0, max: 75");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* distance = strtok((char*)args, " ");
+        int8 dist = -1;
+
+        if (distance)
+            dist = (int8)atoi(distance);
+
+        if (dist >= 0 && dist <= 75)
+        {
+            owner->SetBotFollowDist(dist);
+            if (!owner->IsInCombat() && owner->HaveBot())
+                owner->GetBotMgr()->SendBotCommandState(COMMAND_FOLLOW);
+
+            Group* gr = owner->GetGroup();
+            if (gr && owner->GetMap()->Instanceable() && /*gr->isRaidGroup() &&*/ gr->IsLeader(owner->GetGUID()))
+            {
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (pl && pl->IsInWorld() && pl->GetMap() == owner->GetMap())
+                    {
+                        pl->SetBotFollowDist(dist);
+                        if (!pl->IsInCombat() && pl->HaveBot())
+                            pl->GetBotMgr()->SendBotCommandState(COMMAND_FOLLOW);
+                    }
+                }
+            }
+            handler->PSendSysMessage("bot follow distance set to %u", dist);
+            return true;
+        }
+        handler->SendSysMessage("follow distance should be between 0 and 75");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotCommandCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            handler->PSendSysMessage(".npcbot command <command>");
+            handler->PSendSysMessage("Forces npcbots to either follow you or hold position.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* command = strtok((char*)args, " ");
+        int8 state = -1;
+        if (!strncmp(command, "s", 2) || !strncmp(command, "st", 3) || !strncmp(command, "stay", 5) || !strncmp(command, "stand", 6))
+            state = COMMAND_STAY;
+        else if (!strncmp(command, "f", 2) || !strncmp(command, "follow", 7) || !strncmp(command, "fol", 4) || !strncmp(command, "fo", 3))
+            state = COMMAND_FOLLOW;
+        if (state >= 0 && owner->HaveBot())
+        {
+            owner->GetBotMgr()->SendBotCommandState(CommandStates(state));
+            return true;
+        }
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotRemoveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* u = owner->GetSelectedUnit();
+        if (!u)
+        {
+            handler->PSendSysMessage(".npcbot remove");
+            handler->PSendSysMessage("Frees selected npcbot from it's owner. Select player to remove all npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* master = u->ToPlayer();
+        if (master)
+        {
+            if (master->HaveBot())
+            {
+                master->RemoveAllBots(BOT_REMOVE_DISMISS);
+
+                if (!master->HaveBot())
+                {
+                    handler->PSendSysMessage("Npcbots were successfully removed");
+                    handler->SetSentErrorMessage(true);
+                    return true;
+                }
+                handler->PSendSysMessage("Some npcbots were not removed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage("Npcbots are not found!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* cre = u->ToCreature();
+        if (cre && cre->GetIAmABot() && !cre->IsFreeBot())
+        {
+            master = cre->GetBotOwner();
+            master->GetBotMgr()->RemoveBot(cre->GetGUID(), BOT_REMOVE_DISMISS);
+            if (master->GetBotMgr()->GetBot(cre->GetGUID()) == NULL)
+            {
+                handler->PSendSysMessage("NpcBot successfully removed");
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->PSendSysMessage("NpcBot was NOT removed for some stupid reason!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("You must select player or controlled npcbot");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotResetCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Player* master = NULL;
+        bool all = false;
+        uint64 guid = owner->GetTarget();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot reset");
+            handler->PSendSysMessage("Reset selected npcbot, or all npcbots if used on self");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (IS_PLAYER_GUID(guid))
+        {
+            master = owner;
+            all = true;
+        }
+        else if (IS_CREATURE_GUID(guid))
+        {
+            if (Creature* cre = ObjectAccessor::GetCreature(*owner, guid))
+                master = cre->GetBotOwner();
+        }
+        if (master && master->GetGUID() == owner->GetGUID())
+        {
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("Npcbots are not found!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            if (all)
+                master->RemoveAllBots(BOT_REMOVE_DISMISS);
+            else
+                master->GetBotMgr()->RemoveBot(guid, BOT_REMOVE_DISMISS);
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot reset");
+        handler->PSendSysMessage("Reset selected npcbot. Cannot be used in combat");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+    static bool HandleNpcBotReviveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* u = owner->GetSelectedUnit();
+        if (!u)
+        {
+            handler->SendSysMessage(".npcbot revive");
+            handler->SendSysMessage("Revives selected npcbot. If player is selected, revives all selected player's npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* master = u->ToPlayer())
+        {
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("%s has no npcbots!", master->GetName().c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+
+            master->GetBotMgr()->ReviveAllBots();
+            handler->SendSysMessage("Npcbots revived.");
+            return true;
+        }
+        else if (Creature* bot = u->ToCreature())
+        {
+            if (bot->GetBotAI())
+            {
+                BotMgr::ReviveBot(bot);
+                handler->PSendSysMessage("%s revived.", bot->GetName().c_str());
+                return true;
+            }
+        }
+
+        handler->SendSysMessage("You must select player or npcbot.");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotAddCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* cre = owner->GetSelectedUnit();
+
+        if (!cre || cre->GetTypeId() != TYPEID_UNIT)
+        {
+            handler->SendSysMessage(".npcbot add");
+            handler->SendSysMessage("Allows to hire selected uncontrolled bot, bypassing price condition");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = cre->ToCreature();
+        if (!bot || !bot->GetIAmABot() || bot->GetBotAI()->GetBotOwnerGuid())
+        {
+            handler->SendSysMessage("You must select uncontrolled npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotMgr* mgr = owner->GetBotMgr();
+        if (!mgr)
+            mgr = new BotMgr(owner);
+
+        if (mgr->AddBot(bot) == BOT_ADD_SUCCESS)
+        {
+            handler->PSendSysMessage("%s is now your npcbot", bot->GetName().c_str());
+            return true;
+        }
+
+        handler->PSendSysMessage("NpcBot is NOT created for some reason!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+};
+
+void AddSC_script_bot_commands()
+{
+    new script_bot_commands();
+}
diff --git a/src/server/game/AI/NpcBots/botmgr.cpp b/src/server/game/AI/NpcBots/botmgr.cpp
new file mode 100644
index 0000000..6fe9983
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botmgr.cpp
@@ -0,0 +1,823 @@
+#include "bot_ai.h"
+#include "bot_Events.h"
+#include "botmgr.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GroupMgr.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Language.h"
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "SpellAuras.h"
+/*
+Npc Bot Manager by Graff (onlysuffering@gmail.com)
+Player NpcBots management
+%Complete: ???
+*/
+
+//config
+int8 _basefollowdist;
+uint8 _maxNpcBots;
+uint8 _maxClassNpcBots;
+uint8 _xpReductionNpcBots;
+uint8 _healTargetIconFlags;
+uint32 _npcBotsCost;
+bool _enableNpcBots;
+bool _enableNpcBotsDungeons;
+bool _enableNpcBotsRaids;
+bool _enableNpcBotsBGs;
+bool _enableNpcBotsArenas;
+bool _enableDungeonFinder;
+bool _limitNpcBotsDungeons;
+bool _limitNpcBotsRaids;
+bool _botPvP;
+float _mult_dmg_melee;
+float _mult_dmg_spell;
+float _mult_healing;
+
+bool __firstload = true;
+
+BotMgr::BotMgr(Player* const master) : _owner(master)
+{
+    //LoadConfig(); already loaded (MapManager.cpp)
+    _followdist = _basefollowdist;
+
+    master->SetBotMgr(this);
+}
+BotMgr::~BotMgr() { }
+
+void BotMgr::LoadConfig(bool force)
+{
+    if (__firstload)
+        __firstload = false;
+    else if (!force)
+        return;
+
+    _enableNpcBots          = sConfigMgr->GetBoolDefault("NpcBot.Enable", true);
+    _maxNpcBots             = sConfigMgr->GetIntDefault("NpcBot.MaxBots", 1);
+    _maxClassNpcBots        = sConfigMgr->GetIntDefault("NpcBot.MaxBotsPerClass", 1);
+    _basefollowdist         = sConfigMgr->GetIntDefault("NpcBot.BaseFollowDistance", 30);
+    _xpReductionNpcBots     = sConfigMgr->GetIntDefault("NpcBot.XpReduction", 0);
+    _healTargetIconFlags    = sConfigMgr->GetIntDefault("NpcBot.HealTargetIconsMask", 0);
+    _mult_dmg_melee         = sConfigMgr->GetFloatDefault("NpcBot.Mult.Damage.Melee", 1.0);
+    _mult_dmg_spell         = sConfigMgr->GetFloatDefault("NpcBot.Mult.Damage.Spell", 1.0);
+    _mult_healing           = sConfigMgr->GetFloatDefault("NpcBot.Mult.Healing", 1.0);
+    _enableNpcBotsDungeons  = sConfigMgr->GetBoolDefault("NpcBot.Enable.Dungeon", true);
+    _enableNpcBotsRaids     = sConfigMgr->GetBoolDefault("NpcBot.Enable.Raid", false);
+    _enableNpcBotsBGs       = sConfigMgr->GetBoolDefault("NpcBot.Enable.BG", false);
+    _enableNpcBotsArenas    = sConfigMgr->GetBoolDefault("NpcBot.Enable.Arena", false);
+    _enableDungeonFinder    = sConfigMgr->GetBoolDefault("NpcBot.Enable.DungeonFinder", true);
+    _limitNpcBotsDungeons   = sConfigMgr->GetBoolDefault("NpcBot.Limit.Dungeon", true);
+    _limitNpcBotsRaids      = sConfigMgr->GetBoolDefault("NpcBot.Limit.Raid", true);
+    _npcBotsCost            = sConfigMgr->GetIntDefault("NpcBot.Cost", 1000000);
+    _botPvP                 = sConfigMgr->GetBoolDefault("NpcBot.PvP", true);
+
+    //limits
+    _mult_dmg_melee         = std::max(_mult_dmg_melee, 0.1f);
+    _mult_dmg_spell         = std::max(_mult_dmg_spell, 0.1f);
+    _mult_healing           = std::max(_mult_healing,   0.1f);
+    _mult_dmg_melee         = std::min(_mult_dmg_melee, 10.f);
+    _mult_dmg_spell         = std::min(_mult_dmg_spell, 10.f);
+    _mult_healing           = std::min(_mult_healing,   10.f);
+}
+
+uint8 BotMgr::GetNpcBotsCount(bool inWorldOnly) const
+{
+    if (!inWorldOnly)
+        return _bots.size();
+
+    //CRITICAL SECTION
+    //inWorldOnly is only for one-shot cases (opcodes, etc.)
+    uint8 count = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (ObjectAccessor::GetObjectInWorld(itr->first, (Creature*)NULL))
+            ++count;
+    return count;
+}
+
+bool BotMgr::IsNpcBotModEnabled()
+{
+    return _enableNpcBots;
+}
+
+bool BotMgr::IsNpcBotDungeonFinderEnabled()
+{
+    return _enableDungeonFinder;
+}
+
+uint8 BotMgr::GetNpcBotXpReduction()
+{
+    return _xpReductionNpcBots;
+}
+
+uint8 BotMgr::GetMaxNpcBots()
+{
+    return _maxNpcBots <= 4 ? _maxNpcBots : 4;
+}
+
+bool BotMgr::LimitBots(Map const* map)
+{
+    if (_limitNpcBotsDungeons && map->IsNonRaidDungeon())
+        return true;
+    if (_limitNpcBotsRaids && map->IsRaid())
+        return true;
+
+    return false;
+}
+
+void BotMgr::Update(uint32 diff)
+{
+    //remove temp bots from bot map before updating it
+    while (!_removeList.empty())
+    {
+        std::list<uint64>::iterator itr = _removeList.begin();
+
+        BotMap::iterator bitr = _bots.find(*itr);
+        ASSERT(bitr != _bots.end());
+        _bots.erase(bitr);
+
+        _removeList.erase(itr);
+        continue;
+    }
+
+    if (!HaveBot())
+        return;
+
+    //uint64 guid;
+    Creature* bot;
+    bot_minion_ai* ai;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        //guid = itr->first;
+        bot = itr->second;
+        ai = bot->GetBotMinionAI();
+
+        if (ai->IAmFree())
+            continue;
+
+        if (!bot->IsInWorld())
+        {
+            ai->CommonTimers(diff);
+            continue;
+        }
+
+        if (!_isPartyInCombat())
+            ai->UpdateReviveTimer(diff);
+
+        bot->SetCanUpdate(true);
+        bot->IsAIEnabled = true;
+
+        if (ai->GetReviveTimer() <= diff)
+        {
+            if (bot->isDead() && _owner->IsAlive() && !_owner->IsInCombat() && !_owner->IsBeingTeleported() && !_owner->InArena() &&
+                !_owner->IsInFlight() && !_owner->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) &&
+                !_owner->HasInvisibilityAura() && !_owner->HasStealthAura())
+            {
+                _reviveBot(bot);
+                continue;
+            }
+
+            ai->SetReviveTimer(urand(1000, 5000));
+        }
+
+        if (_owner->IsAlive() && bot->IsAlive() && !ai->IsTempBot() && !ai->IsDuringTeleport() &&
+            (RestrictBots(bot, false) ||
+            bot->GetMap() != _owner->GetMap() ||
+            (bot->GetBotCommandState() != COMMAND_STAY && _owner->GetDistance(bot) > SIZE_OF_GRIDS)))
+        {
+            _owner->m_Controlled.erase(bot);
+            TeleportBot(bot, _owner->GetMap(), _owner);
+            continue;
+        }
+
+        bot->Update(diff);
+        bot->SetCanUpdate(false);
+
+        if (Creature* pet = bot->GetBotsPet())
+        {
+            pet->SetCanUpdate(true);
+            pet->IsAIEnabled = true;
+            pet->Update(diff);
+            pet->SetCanUpdate(false);
+        }
+    }
+}
+
+bool BotMgr::RestrictBots(Creature const* bot, bool add) const
+{
+    if (!_owner->FindMap())
+        return true;
+
+    if (_owner->IsInFlight())
+        return true;
+
+    Map const* currMap = _owner->GetMap();
+
+    if ((!_enableNpcBotsBGs && currMap->IsBattleground()) ||
+        (!_enableNpcBotsArenas && currMap->IsBattleArena()) ||
+        (!_enableNpcBotsDungeons && currMap->IsNonRaidDungeon()) ||
+        (!_enableNpcBotsRaids && currMap->IsRaid()))
+        return true;
+
+    if (LimitBots(currMap))
+    {
+        //if bot is not in instance group - deny (only if trying to teleport to instance)
+        if (add)
+            if (!_owner->GetGroup() || !_owner->GetGroup()->IsMember(bot->GetGUID()))
+                return true;
+
+        InstanceMap const* map = currMap->ToInstanceMap();
+        uint32 count = map->GetPlayersCountExceptGMs();
+        if (count + uint8(add) > map->GetMaxPlayers())
+            return true;
+    }
+
+    return false;
+}
+
+void BotMgr::_reviveBot(Creature* bot)
+{
+    if (bot->IsAlive())
+        return;
+
+    if (!bot->GetBotAI()->IAmFree())
+        bot->Relocate(bot->GetBotOwner());
+
+    bot->SetUInt32Value(UNIT_NPC_FLAGS, bot->GetCreatureTemplate()->npcflag);
+    bot->ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
+    bot->setDeathState(ALIVE);
+    //bot->GetBotAI()->Reset();
+    bot->SetBotShouldUpdateStats();
+
+    bot->SetHealth(bot->GetMaxHealth() / 6); //~15% of max health
+    if (bot->getPowerType() == POWER_MANA)
+        bot->SetPower(POWER_MANA, bot->GetMaxPower(POWER_MANA) / 5); //20% of max mana
+
+    if (!bot->GetBotAI()->IAmFree())
+        bot->SetBotCommandState(COMMAND_FOLLOW, true);
+}
+
+Creature* BotMgr::GetBot(uint64 guid) const
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    return itr != _bots.end() ? itr->second : NULL;
+}
+
+bool BotMgr::_isPartyInCombat() const
+{
+    if (_owner->IsInCombat())
+        return true;
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (itr->second->IsInCombat())
+            return true;
+        if (Creature* pet = itr->second->GetBotsPet())
+            if (pet->IsInCombat())
+                return true;
+    }
+
+    return false;
+}
+
+void BotMgr::OnTeleportFar(uint32 mapId, float x, float y, float z, float ori)
+{
+    Map* newMap = sMapMgr->CreateBaseMap(mapId);
+    Creature* bot;
+    Position pos;
+    pos.Relocate(x, y, z, ori);
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        bot = itr->second;
+        ASSERT(bot && "BotMgr::OnTeleportFar(): bot does not exist!!!");
+
+        if (bot->IsTempBot())
+            continue;
+
+        _owner->m_Controlled.erase(bot);
+        TeleportBot(bot, newMap, &pos);
+    }
+}
+
+void BotMgr::_teleportBot(Creature* bot, Map* newMap, float x, float y, float z, float ori)
+{
+    ASSERT(bot->GetBotAI());
+    bot->GetBotAI()->AbortTeleport();
+
+    bot->SetBotsPetDied();
+    bot->GetBotAI()->UnsummonAll();
+    bot->KillEvents(true);
+
+    if (bot->IsInWorld())
+    {
+        //bot->MonsterWhisper("teleport...", bot->GetBotAI()->GetBotOwnerGuid());
+        bot->CastSpell(bot, COSMETIC_TELEPORT_EFFECT, true);
+    }
+
+    bot->IsAIEnabled = false;
+    //UnitAI* oldAI = bot->GetAI();
+    //bot->SetAI(NULL);
+
+    //if (bot->IsFreeBot() || bot->GetBotOwner()->GetSession()->isLogingOut())
+    //{
+    //    bot->FarTeleportTo(newMap, x, y, z, ori);
+
+    //    //bot->SetAI(oldAI);
+    //    bot->IsAIEnabled = true;
+    //    return;
+    //}
+
+    ////start Unit::CleanupBeforeRemoveFromMap()
+    if (bot->IsInWorld())
+        bot->RemoveFromWorld();
+
+    ASSERT(bot->GetGUID());
+
+    // A unit may be in removelist and not in world, but it is still in grid
+    // and may have some references during delete
+    //RemoveAllAuras();
+    bot->RemoveAllGameObjects();
+
+    //if (finalCleanup)
+    //    m_cleanupDone = true;
+
+    bot->m_Events.KillAllEvents(false);                      // non-delatable (currently casted spells) will not deleted now but it will deleted at call in Map::RemoveAllObjectsInRemoveList
+    bot->CombatStop();
+    bot->ClearComboPointHolders();
+    //bot->DeleteThreatList();
+    bot->getHostileRefManager().setOnlineOfflineState(false);
+    //bot->GetMotionMaster()->Clear(false);                    // remove different non-standard movement generators.
+    //end Unit::CleanupBeforeRemoveFromMap()
+
+    //bot->CleanupBeforeRemoveFromMap(false);
+
+    bot->BotStopMovement();
+
+    if (Map* mymap = bot->FindMap())
+        mymap->RemoveFromMap(bot, false);
+
+    if (bot->IsFreeBot()/* || bot->GetBotOwner()->GetSession()->isLogingOut()*/)
+    {
+        //bot->FarTeleportTo(newMap, x, y, z, ori);
+
+        //Creature::FarTeleportTo()
+        //{
+        //CleanupBeforeRemoveFromMap(false); //done above
+        //GetMap()->RemoveFromMap(this, false); //done above
+        //Relocate(X, Y, Z, O);
+        //SetMap(map);
+        //GetMap()->AddToMap(this);
+        //}
+        bot->Relocate(x, y, z, ori);
+        bot->SetMap(newMap);
+        bot->GetMap()->AddToMap(bot);
+        //end Creature::FarTeleportTo()
+
+        //bot->SetAI(oldAI);
+        bot->IsAIEnabled = true;
+        return;
+    }
+
+    //update group member online state
+    if (Group* gr = bot->GetBotOwner()->GetGroup())
+        if (gr->IsMember(bot->GetGUID()))
+            gr->SendUpdate();
+
+    //bot->Relocate(x, y, z);
+    TeleportFinishEvent* finishEvent = new TeleportFinishEvent(bot->GetBotMinionAI()/*, newMap->GetId(), newMap->GetInstanceId(), x, y, z, ori*/);
+    bot->GetBotAI()->GetEvents()->AddEvent(finishEvent, bot->GetBotAI()->GetEvents()->CalculateTime(urand(5000, 8000)));
+    bot->GetBotMinionAI()->SetTeleportFinishEvent(finishEvent);
+}
+
+void BotMgr::TeleportBot(Creature* bot, Map* newMap, Position* pos)
+{
+    _teleportBot(bot, newMap, pos->GetPositionX(), pos->GetPositionY(), pos->GetPositionZ(), pos->GetOrientation());
+}
+
+void BotMgr::CleanupsBeforeBotDelete(uint64 guid)
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    ASSERT(itr != _bots.end() && "Trying to remove bot which does not belong to this botmgr(b)!!");
+    ASSERT(_owner->IsInWorld() && "Trying to remove bot while not in world(b)!!");
+
+    Creature* bot = itr->second;
+
+    //don't allow removing bots while they are teleporting
+    if (!bot->IsInWorld())
+    {
+        bot->GetBotAI()->AbortTeleport();
+        //if (!bot->IsInWorld())
+        //{
+        //    TC_LOG_ERROR("entities.player", "BotMgr::CleanupsBeforeBotDelete(): Failed to abort %s's teleport! Still out of world!", bot->GetName().c_str());
+        //    ASSERT(false);
+        //}
+    }
+
+    //if player is logging out group will be disbanded (and bots removed) normal way
+    //WorldSession.cpp:: if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+    if (!_owner->GetSession()->PlayerLogout())
+        RemoveBotFromGroup(bot);
+
+    bot->SetBotsPetDied();
+    bot->OnBotDespawn(NULL);
+
+    //_owner->SetMinion((Minion*)bot->ToTempSummon(), false);
+    ASSERT(bot->GetOwnerGUID() == _owner->GetGUID());
+    bot->SetOwnerGUID(0);
+    _owner->m_Controlled.erase(bot);
+    bot->m_ControlledByPlayer = false;
+    bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+    bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);
+    bot->SetUInt64Value(UNIT_FIELD_CREATEDBY, 0);
+
+    bot->SetIAmABot(false);
+}
+
+void BotMgr::_addBotToRemoveList(uint64 guid)
+{
+    _removeList.push_back(guid);
+}
+
+void BotMgr::RemoveAllBots(uint8 removetype)
+{
+    while (!_bots.empty())
+        RemoveBot(_bots.begin()->first, removetype);
+}
+//Bot is being abandoned by player
+void BotMgr::RemoveBot(uint64 guid, uint8 removetype)
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    ASSERT(itr != _bots.end() && "Trying to remove bot which does not belong to this botmgr(a)!!");
+    ASSERT(_owner->IsInWorld() && "Trying to remove bot while not in world(a)!!");
+
+    //trying to remove temp bot second time means removing all bots
+    //just erase from bots because already cleaned up
+    for (std::list<uint64>::iterator it = _removeList.begin(); it != _removeList.end(); ++it)
+    {
+        if (*it == guid)
+        {
+            _removeList.erase(it);
+            _bots.erase(itr);
+            return;
+        }
+    }
+
+    Creature* bot = itr->second;
+    CleanupsBeforeBotDelete(guid);
+
+    ////remove control bar
+    //if (GetNpcBotsCount() <= 1 && !_owner->GetPetGUID() && _owner->m_Controlled.empty())
+    //    _owner->SendRemoveControlBar();
+
+    if (bot->GetBotAI()->IsTempBot())
+    {
+        bot->GetBotAI()->OnBotDespawn(bot); //send to self
+        _addBotToRemoveList(guid);
+        return;
+    }
+
+    _bots.erase(itr);
+
+    bot->GetBotAI()->ResetBotAI(removetype == BOT_REMOVE_DISMISS ? BOTAI_RESET_DISMISS : BOTAI_RESET_LOGOUT);
+
+    bot->setFaction(bot->GetCreatureTemplate()->faction);
+    bot->SetLevel(bot->GetCreatureTemplate()->minlevel);
+
+    if (removetype == BOT_REMOVE_DISMISS)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+        //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+        stmt->setUInt32(0, uint32(0));
+        stmt->setUInt32(1, bot->GetEntry());
+        CharacterDatabase.Execute(stmt);
+    }
+
+    bot->AI()->Reset();
+}
+
+BotAddResult BotMgr::AddBot(Creature* bot, bool takeMoney)
+{
+    ASSERT(bot->IsNPCBot());
+    ASSERT(bot->GetBotAI() != NULL);
+
+    bool temporary = bot->GetBotAI()->IsTempBot();
+
+    if (!_enableNpcBots)
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.SendSysMessage("NpcBot system is currently disabled. Please contact administration.");
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_DISABLED;
+    }
+    if (GetBot(bot->GetGUID()))
+        return BOT_ADD_ALREADY_HAVE; //Silent error, intended
+    if (!bot->GetBotAI()->IAmFree())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("%s will not join you, already has master: %s",
+            bot->GetName().c_str(), bot->GetBotOwner()->GetName().c_str());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_NOT_AVAILABLE;
+    }
+    if (bot->GetBotAI()->IsDuringTeleport())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("%s cannot join you while about to teleport", bot->GetName().c_str());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_BUSY;
+    }
+    if (!temporary && _owner->GetNpcBotsCount() >= GetMaxNpcBots())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("Youre exceed max npcbots (%u)", GetMaxNpcBots());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_MAX_EXCEED;
+    }
+    if (!temporary && HaveBot() && _maxClassNpcBots)
+    {
+        uint8 count = 0;
+        for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+            if (itr->second->GetBotClass() == bot->GetBotClass())
+                ++count;
+
+        if (count >= _maxClassNpcBots)
+        {
+            ChatHandler ch(_owner->GetSession());
+            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, _maxClassNpcBots);
+            //ch.SetSentErrorMessage(true);
+            return BOT_ADD_MAX_CLASS_EXCEED;
+        }
+    }
+    //Map* curMap = _owner->GetMap();
+    //if (!temporary && LimitBots(curMap))
+    //{
+    //    InstanceMap* map = curMap->ToInstanceMap();
+    //    uint32 count = map->GetPlayersCountExceptGMs();
+    //    if (count >= map->GetMaxPlayers())
+    //    {
+    //        ChatHandler ch(_owner->GetSession());
+    //        ch.PSendSysMessage("Instance players limit exceed (%u of %u)", count, map->GetMaxPlayers());
+    //        //ch.SetSentErrorMessage(true);
+    //        return BOT_ADD_INSTANCE_LIMIT;
+    //    }
+    //}
+    if (!temporary && takeMoney)
+    {
+        uint32 cost = GetNpcBotCost(_owner->getLevel(), bot);
+        if (!_owner->HasEnoughMoney(cost))
+        {
+            ChatHandler ch(_owner->GetSession());
+            std::string str = "You don't have enough money (";
+            str += GetNpcBotCostStr(_owner->getLevel(), bot);
+            str += ")!";
+            ch.SendSysMessage(str.c_str());
+            //ch.SetSentErrorMessage(true);
+            return BOT_ADD_CANT_AFFORD;
+        }
+
+        _owner->ModifyMoney(-(int32(cost)));
+    }
+
+    bot->SetBotsPetDied();
+    bot->GetBotAI()->UnsummonAll();
+
+    _bots[bot->GetGUID()] = bot;
+
+    bot->SetIAmABot(true);
+    bot->SetBotOwner(_owner);
+    bot->SetUInt64Value(UNIT_FIELD_CREATEDBY, _owner->GetGUID());
+
+    //_owner->SetMinion((Minion*)bot->ToTempSummon(), true);
+    ASSERT(!bot->GetOwnerGUID());
+    bot->SetOwnerGUID(_owner->GetGUID());
+    _owner->m_Controlled.insert(bot);
+    bot->m_ControlledByPlayer = true;
+    bot->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+    bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+    //bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
+    //bot->SetByteValue(UNIT_FIELD_BYTES_0, 0, botrace);
+    bot->setFaction(_owner->getFaction());
+    //bot->SetLevel(_owner->getLevel());
+    //bot->SetBotClass(botclass);
+    //bot->AIM_Initialize();
+    //bot->InitBotAI();
+    //AddBotToGroup(bot);
+    //InitBotEquips(m_bot);
+
+
+    //CharmInfo charmInfo(_owner); //owner to not set reaction and other stuff, just empty charm
+    //charmInfo.InitPetActionBar();
+
+    //uint8 addlist = 0;
+    //for (uint8 i = 0; i != MAX_SPELL_CHARM; ++i)
+    //    if (charmInfo.GetCharmSpell(i)->GetAction())
+    //        ++addlist;
+
+    //WorldPacket data(SMSG_PET_SPELLS, 8+2+4+4+4*MAX_UNIT_ACTION_BAR_INDEX+1+4*addlist+1);
+    //data << uint64(bot->GetGUID());
+    //data << uint16(0);
+    //data << uint32(0);
+
+    //data << uint8(bot->GetReactState()) << uint8(bot->GetBotCommandState()) << uint16(0);
+
+    //charmInfo.BuildActionBar(&data);
+
+    //data << uint8(addlist);
+
+    //if (addlist)
+    //{
+    //    for (uint8 i = 0; i != MAX_SPELL_CHARM; ++i)
+    //    {
+    //        CharmSpellInfo* cspell = charmInfo.GetCharmSpell(i);
+    //        if (cspell->GetAction())
+    //            data << uint32(cspell->packedData);
+    //    }
+    //}
+
+    //data << uint8(0); // cooldowns count
+
+    //_owner->GetSession()->SendPacket(&data);
+
+
+    bot->GetBotAI()->Reset();
+
+    if (!bot->GetBotAI()->IsTempBot())
+    {
+        bot->SetBotCommandState(COMMAND_FOLLOW, true);
+        if (bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+            AddBotToGroup(bot);
+    }
+
+    if (!temporary)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+        //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+        stmt->setUInt32(0, _owner->GetGUIDLow());
+        stmt->setUInt32(1, bot->GetEntry());
+        CharacterDatabase.Execute(stmt);
+    }
+
+    return BOT_ADD_SUCCESS;
+}
+
+bool BotMgr::AddBotToGroup(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    Group* gr = _owner->GetGroup();
+    if (gr)
+    {
+        if (gr->IsMember(bot->GetGUID()))
+            return true;
+
+        if (gr->IsFull())
+        {
+            if (!gr->isRaidGroup()) //non-raid group is full
+                gr->ConvertToRaid();
+            else
+                return false;
+        }
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(_owner))
+        {
+            delete gr;
+            return false;
+        }
+        sGroupMgr->AddGroup(gr);
+    }
+
+    if (gr->AddMember((Player*)bot))
+    {
+        if (!bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+            bot->GetBotAI()->ToggleRole(BOT_ROLE_PARTY, true);
+
+        bot->GetBotAI()->CancelBoot();
+        return true;
+    }
+
+    return false;
+}
+
+bool BotMgr::RemoveBotFromGroup(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    Group* gr = _owner->GetGroup();
+    if (!gr || !gr->IsMember(bot->GetGUID()))
+        return false;
+
+    gr->RemoveMember(bot->GetGUID());
+
+    if (bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+        bot->GetBotAI()->ToggleRole(BOT_ROLE_PARTY, true);
+
+    Map* map = _owner->FindMap();
+    gr = _owner->GetGroup(); //check if group has been deleted
+    if (map && map->IsDungeon() && (!gr || !gr->IsMember(bot->GetGUID()))) //make sure bot is removed from group
+    {
+        ChatHandler(_owner->GetSession()).PSendSysMessage("Your bot %s has been removed from your group and will be teleported out of the instance in 60 seconds if not invited back", bot->GetName().c_str());
+
+        if (gr && _owner->GetGUID() != gr->GetLeaderGUID())
+            if (Player* leader = ObjectAccessor::FindPlayer(gr->GetLeaderGUID()))
+                ChatHandler(leader->GetSession()).PSendSysMessage("Bot %s has been removed from your group and will be teleported out of the instance in 60 seconds if not invited back", bot->GetName().c_str());
+
+        bot->GetBotAI()->StartBoot();
+    }
+
+    return true;
+}
+
+bool BotMgr::RemoveAllBotsFromGroup(bool newGroup)
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        RemoveBotFromGroup(itr->second);
+        itr->second->GetBotAI()->SetNeedParty(newGroup);
+    }
+
+    return true;
+}
+
+uint32 BotMgr::GetNpcBotCost(uint8 level, Creature* creature)
+{
+    if (!creature || !creature->GetBotAI())
+        return (_npcBotsCost * level) / DEFAULT_MAX_LEVEL;
+
+    uint32 base;
+    switch (creature->GetBotAI()->GetBotClass())
+    {
+        case BOT_CLASS_BM:
+            //base = GetNpcBotCost(level, NULL) * 9;
+            //base = 100000; //10 gold
+            //break;
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_SHAMAN:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_DRUID:
+        default:
+            base = 0;
+            break;
+    }
+
+    return base + GetNpcBotCost(level, NULL);
+}
+
+std::string BotMgr::GetNpcBotCostStr(uint8 level, Creature* creature)
+{
+    std::ostringstream money;
+
+    if (uint32 cost = GetNpcBotCost(level, creature))
+    {
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold != 0)
+            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver != 0)
+            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        if (cost)
+            money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+    }
+
+    return money.str();
+}
+
+void BotMgr::ReviveAllBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        _reviveBot(itr->second);
+    }
+}
+
+void BotMgr::SendBotCommandState(CommandStates state)
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        itr->second->SetBotCommandState(state, true);
+    }
+}
+
+void BotMgr::SetBotsShouldUpdateStats()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        itr->second->SetBotShouldUpdateStats();
+    }
+}
diff --git a/src/server/game/AI/NpcBots/botmgr.h b/src/server/game/AI/NpcBots/botmgr.h
new file mode 100644
index 0000000..238b245
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botmgr.h
@@ -0,0 +1,109 @@
+#ifndef _BOTMGR_H
+#define _BOTMGR_H
+
+#include "Common.h"
+
+class Creature;
+class Map;
+class Player;
+
+struct Position;
+
+enum BotAddResult
+{
+    BOT_ADD_DISABLED                    = 0x001,
+    BOT_ADD_ALREADY_HAVE                = 0x002,
+    BOT_ADD_MAX_EXCEED                  = 0x004,
+    BOT_ADD_MAX_CLASS_EXCEED            = 0x008,
+    BOT_ADD_CANT_AFFORD                 = 0x010,
+    BOT_ADD_INSTANCE_LIMIT              = 0x020,
+    BOT_ADD_BUSY                        = 0x040,
+    BOT_ADD_NOT_AVAILABLE               = 0x080,
+
+    BOT_ADD_SUCCESS                     = 0x100,
+
+    BOT_ADD_ALL_MASK                    = 0xFFF,
+
+    BOT_ADD_FATAL                       = (BOT_ADD_DISABLED | BOT_ADD_CANT_AFFORD | BOT_ADD_MAX_EXCEED | BOT_ADD_MAX_CLASS_EXCEED)
+};
+
+enum BotRemoveType
+{
+    BOT_REMOVE_LOGOUT                   = 0,
+    BOT_REMOVE_DISMISS                  = 1,
+    BOT_REMOVE_HIDE                     = 2, //NYI
+    BOT_REMOVE_UNSUMMON                 = 3,
+    BOT_REMOVE_BY_DEFAULT               = BOT_REMOVE_LOGOUT
+};
+
+typedef std::unordered_map<uint64 /*guid*/, Creature* /*bot*/> BotMap;
+
+class BotMgr
+{
+    public:
+        BotMgr(Player* const master);
+        ~BotMgr();
+
+        Player* GetOwner() const { return _owner; }
+
+        BotMap const* GetBotMap() const { return &_bots; }
+        BotMap* GetBotMap() { return &_bots; }
+
+        static bool IsNpcBotModEnabled();
+        static bool IsNpcBotDungeonFinderEnabled();
+
+        static void ReloadConfig() { LoadConfig(true); }
+        static void LoadConfig(bool force = false);
+
+        void Update(uint32 diff);
+
+        Creature* GetBot(uint64 guid) const;
+        bool HaveBot() const { return !_bots.empty(); }
+        uint8 GetNpcBotsCount(bool inWorldOnly = false) const;
+        static uint8 GetMaxNpcBots();
+        static uint8 GetNpcBotXpReduction();
+        static bool LimitBots(Map const* map);
+        bool RestrictBots(Creature const* bot, bool add) const;
+
+        static uint32 GetNpcBotCost(uint8 level, Creature* creature);
+        static std::string GetNpcBotCostStr(uint8 level, Creature* creature);
+
+        void OnTeleportFar(uint32 mapId, float x, float y, float z, float ori = 0.f);
+        void ReviveAllBots();
+        void SendBotCommandState(CommandStates state);
+
+        void CleanupsBeforeBotDelete(uint64 guid);
+        void RemoveAllBots(uint8 removetype = BOT_REMOVE_LOGOUT);
+        void RemoveBot(uint64 guid, uint8 removetype = BOT_REMOVE_LOGOUT);
+        BotAddResult AddBot(Creature* bot, bool takeMoney = false);
+        bool AddBotToGroup(Creature* bot);
+        bool RemoveBotFromGroup(Creature* bot);
+        bool RemoveAllBotsFromGroup(bool newGroup);
+
+        uint8 GetBotFollowDist() const { return _followdist; }
+        void SetBotFollowDist(int8 dist) { _followdist = dist; }
+
+        void SetBotsShouldUpdateStats();
+
+        static void ReviveBot(Creature* bot) { _reviveBot(bot); }
+
+        //TELEPORT BETWEEN MAPS
+        //CONFIRMEND UNSAFE (charmer,owner)
+        static void TeleportBot(Creature* bot, Map* newMap, Position* pos);
+
+    private:
+        static void _teleportBot(Creature* bot, Map* newMap, float x, float y, float z, float ori = 0.f);
+
+        bool _isPartyInCombat() const;
+        static void _reviveBot(Creature* bot);
+
+        void _addBotToRemoveList(uint64 guid);
+
+        Player* const _owner;
+        BotMap _bots;
+        std::list<uint64> _removeList;
+
+        int8 _followdist;
+};
+
+#endif
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
new file mode 100644
index 0000000..3aed0f7
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
@@ -0,0 +1,380 @@
+/**
+ *
+ * @File : sc_npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 28/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+//#include "ProgressBar.h"
+
+#define TELE    nsNpcTel::CatDest
+#define PAGE    nsNpcTel::Page
+#define PAGEI   PAGE::Instance
+
+
+nsNpcTel::VCatDest nsNpcTel::TabCatDest;
+
+
+uint32 PAGE::operator [] (Player * const player) const
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i].GetPageId();
+    }
+    return 0;
+}
+
+PAGE::Instance & PAGE::operator () (Player * const player)
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i];
+    }
+    m_TabInstance.push_back(Instance(player));
+    return m_TabInstance.back();
+}
+
+PAGE::Instance & PAGEI::operator = (const uint32 &id)
+{
+    m_PageId = id;
+    return *this;
+}
+
+PAGE::Instance & PAGEI::operator ++ (void)
+{
+    ++m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator ++ (int32)
+{
+    Instance tmp (*this);
+    ++m_PageId;
+    return tmp;
+}
+
+PAGE::Instance & PAGEI::operator -- (void)
+{
+    --m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator -- (int32)
+{
+    Instance tmp (*this);
+    --m_PageId;
+    return tmp;
+}
+
+TELE::CatDest(const uint32 &id, const std::string &name,
+              const Flag &flag, const uint64 &data0, const uint32 &data1)
+    : m_id(id), m_name(name), m_flag(flag), m_data0(data0), m_data1(data1)
+{
+    m_TabDest.clear();
+}
+
+std::string TELE::GetName(const bool IsGM /* = false */) const
+{
+    if (!IsGM || m_flag != FLAG_TEAM)
+        return m_name;
+
+    switch (m_data0)
+    {
+      case TEAM_HORDE:      return std::string(m_name + " (H)");
+      case TEAM_ALLIANCE:   return std::string(m_name + " (A)");
+    }
+    return m_name;
+}
+
+bool TELE::IsAllowedToTeleport(Player * const player) const
+{
+    if (player->IsGameMaster())
+    {
+        if (m_flag == FLAG_GMLEVEL)
+            return player->GetSession()->GetSecurity() >= m_data0;
+        return true;
+    }
+
+    switch (m_flag)
+    {
+      case FLAG_TEAM:
+        switch (m_data0)
+        {
+          case TEAM_HORDE:      return player->GetTeam() == HORDE;
+          case TEAM_ALLIANCE:   return player->GetTeam() == ALLIANCE;
+          case TEAM_ALL:        return true;
+        }
+
+      case FLAG_GUILD:
+        return player->GetGuildId() == m_data0;
+
+      case FLAG_GMLEVEL:
+        return player->GetSession()->GetSecurity() >= m_data0;
+
+      case FLAG_ISGM:
+        return player->IsGameMaster();
+
+      case FLAG_ACCOUNT:
+        return player->GetSession()->GetAccountId() == m_data0;
+
+      case FLAG_LEVEL:
+        return player->getLevel() >= m_data0;
+
+      case FLAG_ITEM:
+        return player->HasItemCount(m_data0, m_data1, true);
+
+      case FLAG_QUEST:
+        if (m_data1 < MAX_QUEST_STATUS)
+            return player->GetQuestStatus(m_data0) == m_data1;
+        return player->GetQuestRewardStatus(m_data0);
+
+      case FLAG_GENDER:
+        return player->getGender() == m_data0;
+
+      case FLAG_RACE:
+        return player->getRace() == m_data0;
+
+      case FLAG_CLASS:
+        return player->getClass() == m_data0;
+
+      case FLAG_REPUTATION:
+        return player->GetReputationRank(m_data0) >= m_data1;
+
+      case FLAG_PLAYER:
+        return player->GetGUID() == m_data0;
+
+      default: TC_LOG_ERROR("misc", "Invalid flag (category: %u). Important problem...", GetCatID());
+    }
+
+    TC_LOG_ERROR("misc", "Invalid flag (category: %u). Important problem...", GetCatID());
+    return false;
+}
+
+uint32 TELE::CountOfCategoryAllowedBy(Player * const player)
+{
+    uint32 count (0);
+    for (VCatDest_t i(0); i < TabCatDest.size(); ++i)
+    {
+        if (TabCatDest[i].IsAllowedToTeleport(player))
+            ++count;
+    }
+    return count;
+}
+
+bool nsNpcTel::IsValidData(const uint32 &cat,   const Flag &flag,
+                           const uint64 &data0, const uint32 &data1)
+{
+    switch(flag)
+    {
+      case FLAG_TEAM:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0 < MAX_FLAG_TEAM)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Team) (category: %u).", cat);
+        return false;
+
+      case FLAG_GUILD:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (GuildID) (category: %u).", cat);
+        return false;
+
+      case FLAG_GMLEVEL:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (GmLevel) (category: %u).", cat);
+        return false;
+
+      case FLAG_ISGM:
+        if (data0)
+            TC_LOG_ERROR("misc", "Invalid data0 (category: %u).", cat);
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        return true;
+
+      case FLAG_ACCOUNT:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (AccountID) (category: %u).", cat);
+        return false;
+
+      case FLAG_LEVEL:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Level) (category: %u).", cat);
+        return false;
+
+      case FLAG_ITEM:
+        if (!data0)
+        {
+            TC_LOG_ERROR("misc", "Invalid data0 (ItemID) (category: %u).", cat);
+            return false;
+        }
+        if (data1)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data1 (Item Count) (category: %u).", cat);
+        return false;
+
+      case FLAG_QUEST:
+        if (!data0)
+        {
+            TC_LOG_ERROR("misc", "Invalid data0 (QuestID) (category: %u).", cat);
+            return false;
+        }
+        if (data1 < MAX_QUEST_STATUS + 1)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data1 (Quest Status) (category: %u).", cat);
+        return false;
+
+      case FLAG_GENDER:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0 < GENDER_NONE)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Gender) (category: %u).", cat);
+        return false;
+
+      case FLAG_RACE:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_RACES)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Race) (category: %u).", cat);
+        return false;
+
+      case FLAG_CLASS:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_CLASSES)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Class) (category: %u).", cat);
+        return false;
+
+      case FLAG_REPUTATION:
+        if (!data0)
+        {
+            TC_LOG_ERROR("misc", "Invalid data0 (Faction/Reputation) (category: %u).", cat);
+            return false;
+        }
+        if (data1 <= REP_EXALTED)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data1 (Faction/Reputation) (category: %u).", cat);
+        return false;
+
+      case FLAG_PLAYER:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (PlayerGuid) (category: %u).", cat);
+        return false;
+
+      default: TC_LOG_ERROR("misc", "Invalid flag (category: %u).", cat);
+    }
+
+    TC_LOG_ERROR("misc", "Invalid flag (category: %u).", cat);
+    return false;
+}
+
+void LoadNpcTele(void)
+{
+    const char *Table[] =
+    {
+        "custom_npc_tele_category",
+        "custom_npc_tele_destination",
+        "custom_npc_tele_association",
+    };
+
+
+    QueryResult result = WorldDatabase.PQuery(
+        "SELECT `flag`, `data0`, `data1`, `cat_id`, C.`name` `namecat`, D.`name` `namedest`, "
+        //      0        1        2        3                  4                   5
+               "`pos_X`, `pos_Y`, `pos_Z`, `orientation`, `map`, `level`, `cost` "
+        //      6        7        8        9              10     11       12
+        "FROM `%s` C, `%s` D, `%s` A "
+        "WHERE C.`id` = `cat_id` AND D.`id` = `dest_id` "
+        "ORDER BY `namecat`, `cat_id`, `namedest`", Table[0], Table[1], Table[2]);
+
+    nsNpcTel::TabCatDest.clear();
+
+    if (result)
+    {
+        TC_LOG_INFO("server.loading", "Loading %s, %s and %s...", Table[0], Table[1], Table[2]);
+        // barGoLink bar(result->GetRowCount());
+
+        uint32 catid = 0;
+        uint32 nbDest = 0;
+        bool IsValidCat = true;
+        bool FirstTime = true;
+
+        do
+        {
+            // bar.step();
+            Field *fields = result->Fetch();
+
+            if (!IsValidCat && catid == fields[3].GetUInt32() && !FirstTime)
+                continue;
+
+            IsValidCat = true;
+            FirstTime = false;
+
+            if (!nsNpcTel::IsValidData(fields[3].GetUInt32(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                       fields[1].GetUInt64(), fields[2].GetUInt32()))
+            {
+                IsValidCat = false;
+                catid = fields[3].GetUInt32();
+                continue;
+            }
+
+            if (catid != fields[3].GetUInt32())
+            {
+                catid = fields[3].GetUInt32();
+                nsNpcTel::CatDest categorie (catid, fields[4].GetString(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                             fields[1].GetUInt64(), fields[2].GetUInt32());
+                nsNpcTel::TabCatDest.push_back(categorie);
+            }
+
+            nsNpcTel::Dest item =
+            {
+                fields[5].GetString(),   // Name
+                fields[6].GetFloat(),       // X
+                fields[7].GetFloat(),       // Y
+                fields[8].GetFloat(),       // Z
+                fields[9].GetFloat(),       // Orientation
+                fields[10].GetUInt16(),     // Map
+                fields[11].GetUInt8(),      // Level
+                fields[12].GetUInt32(),     // Cost
+            };
+
+            nsNpcTel::TabCatDest.back().AddDest(item);
+            ++nbDest;
+        } while (result->NextRow());
+
+        TC_LOG_INFO("server.loading", " ");
+        TC_LOG_INFO("server.loading", "Loaded %u npc_teleport.", nbDest);
+    } else TC_LOG_ERROR("misc", "WARNING >> Loaded 0 npc_teleport.");
+}
+
+
+#undef TELE
+#undef PAGE
+#undef PAGEI
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.h b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
new file mode 100644
index 0000000..4830245
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
@@ -0,0 +1,151 @@
+/**
+ *
+ * @File : sc_npc_teleport.h
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#ifndef SC_NPC_TELEPORT_H
+#define SC_NPC_TELEPORT_H
+
+#include <vector>
+
+
+namespace nsNpcTel
+{
+    // Different types of permissions
+    enum Flag
+    {
+        FLAG_TEAM       = 0,
+        FLAG_GUILD      = 1,
+        FLAG_GMLEVEL    = 2,
+        FLAG_ISGM       = 3,
+        FLAG_ACCOUNT    = 4,
+        FLAG_LEVEL      = 5,
+        FLAG_ITEM       = 6,
+        FLAG_QUEST      = 7,
+        FLAG_GENDER     = 8,
+        FLAG_RACE       = 9,
+        FLAG_CLASS      = 10,
+        FLAG_REPUTATION = 11,
+        FLAG_PLAYER     = 12,
+        MAX_FLAG,
+    };
+
+    // Different parameters of FLAG_TEAM
+    enum
+    {
+        TEAM_ALL        = 0,
+        TEAM_ALLIANCE   = 1,
+        TEAM_HORDE      = 2,
+        MAX_FLAG_TEAM,
+    };
+
+    // Structure representing the destinations
+    struct Dest
+    {
+        std::string m_name;
+        float       m_X, m_Y, m_Z, m_orient;
+        uint16      m_map;
+        uint8       m_level;
+        uint32      m_cost;
+    };
+
+    // Class representing the categories of destinations
+    class CatDest
+    {
+      public:
+
+        typedef std::vector<Dest> VDest;
+        typedef VDest::size_type  VDest_t;
+
+        CatDest(const uint32 &id, const std::string &name,
+                const Flag &flag, const uint64 &data0, const uint32 &data1);
+
+        void   AddDest  (const Dest &item)       { m_TabDest.push_back(item); }
+        Dest   GetDest  (const uint32 &id) const { return m_TabDest[id]; }
+        uint32 GetCatID (void)             const { return m_id; }
+        uint32 size     (void)             const { return m_TabDest.size(); }
+
+        std::string GetName(const bool IsGM = false)    const;
+        bool IsAllowedToTeleport(Player * const player) const;
+
+        static uint32 CountOfCategoryAllowedBy(Player * const player);
+
+      private:
+
+        uint32      m_id;
+        std::string m_name;
+        Flag        m_flag;
+        uint64      m_data0;
+        uint32      m_data1;
+        VDest       m_TabDest;
+    };
+
+    // Class page for current player
+    class Page
+    {
+      protected:
+
+        // Class instance for current player
+        class Instance
+        {
+          public:
+
+            Instance(Player * const player, const uint32 &PageId = 0)
+                : m_player(player), m_PageId(PageId) {}
+
+            Instance & operator =  (const uint32 &id);
+            Instance & operator ++ (void);
+            Instance   operator ++ (int32);
+            Instance & operator -- (void);
+            Instance   operator -- (int32);
+
+            uint32   GetPageId(void) const { return m_PageId; }
+            Player * GetPlayer(void) const { return m_player; }
+
+          private:
+
+            Player *m_player;
+            uint32  m_PageId;
+        };
+
+
+      public:
+
+        typedef std::vector<Instance> VInst;
+        typedef VInst::size_type      VInst_t;
+
+        Page(void) { m_TabInstance.clear(); }
+
+        Instance &   operator () (Player * const player);
+        uint32 operator [] (Player * const player) const;
+
+
+      private:
+
+        VInst m_TabInstance;
+    };
+
+    typedef std::vector <CatDest> VCatDest;
+    typedef VCatDest::size_type   VCatDest_t;
+
+    // Verification of data integrity
+    bool IsValidData(const uint32 &cat,   const Flag &flag,
+                     const uint64 &data0, const uint32 &data1);
+
+    extern VCatDest TabCatDest;
+}
+
+// Loading contents of database
+void LoadNpcTele(void);
+
+extern WorldDatabaseWorkerPool WorldDatabase;
+
+#endif
diff --git a/src/server/game/Accounts/RBAC.h b/src/server/game/Accounts/RBAC.h
index 9ce1f9b..82a7978 100644
--- a/src/server/game/Accounts/RBAC.h
+++ b/src/server/game/Accounts/RBAC.h
@@ -683,6 +683,12 @@ enum RBACPermissions
     RBAC_PERM_COMMAND_MAILBOX                                = 777,
 
     // custom permissions 1000+
+
+    RBAC_PERM_COMMAND_GUILD_INFO                             = 1000,
+    RBAC_PERM_COMMAND_GUILD_SET_LEVEL                        = 1001,
+    RBAC_PERM_COMMAND_GUILD_GIVE_XP                          = 1002,
+    RBAC_PERM_COMMAND_MODIFY_XP_KILL                         = 1010,
+    RBAC_PERM_COMMAND_MODIFY_XP_QUEST                        = 1011,
     RBAC_PERM_MAX
 };
 
diff --git a/src/server/game/Anticheat/AnticheatData.cpp b/src/server/game/Anticheat/AnticheatData.cpp
new file mode 100644
index 0000000..8c69972
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatData.cpp
@@ -0,0 +1,118 @@
+#include "AnticheatData.h"
+
+AnticheatData::AnticheatData()
+{
+    lastOpcode = 0;
+    totalReports = 0;
+    for (uint8 i = 0; i < MAX_REPORT_TYPES; i++)
+    {
+        typeReports[i] = 0;
+        tempReports[i] = 0;
+        tempReportsTimer[i] = 0;
+    }
+    average = 0;
+    creationTime = 0;
+    hasDailyReport = false;
+}
+
+AnticheatData::~AnticheatData()
+{
+}
+
+void AnticheatData::SetDailyReportState(bool b)
+{
+    hasDailyReport = b;
+}
+
+bool AnticheatData::GetDailyReportState()
+{
+    return hasDailyReport;
+}
+
+void AnticheatData::SetLastOpcode(uint32 opcode)
+{
+    lastOpcode = opcode;
+}
+
+void AnticheatData::SetPosition(float x, float y, float z, float o)
+{
+    lastMovementInfo.pos.m_positionX = x;
+    lastMovementInfo.pos.m_positionY = y;
+    lastMovementInfo.pos.m_positionZ = z;
+    lastMovementInfo.pos.m_orientation = o;
+}
+
+uint32 AnticheatData::GetLastOpcode() const
+{
+    return lastOpcode;
+}
+
+const MovementInfo& AnticheatData::GetLastMovementInfo() const
+{
+    return lastMovementInfo;
+}
+
+void AnticheatData::SetLastMovementInfo(MovementInfo& moveInfo)
+{
+    lastMovementInfo = moveInfo;
+}
+
+uint32 AnticheatData::GetTotalReports() const
+{
+    return totalReports;
+}
+
+void AnticheatData::SetTotalReports(uint32 _totalReports)
+{
+    totalReports = _totalReports;
+}
+
+void AnticheatData::SetTypeReports(uint32 type, uint32 amount)
+{
+    typeReports[type] = amount;
+}
+
+uint32 AnticheatData::GetTypeReports(uint32 type) const
+{
+    return typeReports[type];
+}
+
+float AnticheatData::GetAverage() const
+{
+    return average;
+}
+
+void AnticheatData::SetAverage(float _average)
+{
+    average = _average;
+}
+
+uint32 AnticheatData::GetCreationTime() const
+{
+    return creationTime;
+}
+
+void AnticheatData::SetCreationTime(uint32 _creationTime)
+{
+    creationTime = _creationTime;
+}
+
+void AnticheatData::SetTempReports(uint32 amount, uint8 type)
+{
+    tempReports[type] = amount;
+}
+
+uint32 AnticheatData::GetTempReports(uint8 type)
+{
+    return tempReports[type];
+}
+
+void AnticheatData::SetTempReportsTimer(uint32 time, uint8 type)
+{
+    tempReportsTimer[type] = time;
+}
+
+uint32 AnticheatData::GetTempReportsTimer(uint8 type)
+{
+    return tempReportsTimer[type];
+}
diff --git a/src/server/game/Anticheat/AnticheatData.h b/src/server/game/Anticheat/AnticheatData.h
new file mode 100644
index 0000000..700ad2d
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatData.h
@@ -0,0 +1,63 @@
+#ifndef SC_ACDATA_H
+#define SC_ACDATA_H
+
+#include "AnticheatMgr.h"
+
+#define MAX_REPORT_TYPES 6
+
+class AnticheatData
+{
+public:
+    AnticheatData();
+    ~AnticheatData();
+
+    void SetLastOpcode(uint32 opcode);
+    uint32 GetLastOpcode() const;
+
+    const MovementInfo& GetLastMovementInfo() const;
+    void SetLastMovementInfo(MovementInfo& moveInfo);
+
+    void SetPosition(float x, float y, float z, float o);
+
+    /*
+    bool GetDisableACCheck() const;
+    void SetDisableACCheck(bool check);
+
+    uint32 GetDisableACTimer() const;
+    void SetDisableACTimer(uint32 timer);*/
+
+    uint32 GetTotalReports() const;
+    void SetTotalReports(uint32 _totalReports);
+
+    uint32 GetTypeReports(uint32 type) const;
+    void SetTypeReports(uint32 type, uint32 amount);
+
+    float GetAverage() const;
+    void SetAverage(float _average);
+
+    uint32 GetCreationTime() const;
+    void SetCreationTime(uint32 creationTime);
+
+    void SetTempReports(uint32 amount, uint8 type);
+    uint32 GetTempReports(uint8 type);
+
+    void SetTempReportsTimer(uint32 time, uint8 type);
+    uint32 GetTempReportsTimer(uint8 type);
+
+    void SetDailyReportState(bool b);
+    bool GetDailyReportState();
+private:
+    uint32 lastOpcode;
+    MovementInfo lastMovementInfo;
+    //bool disableACCheck;
+    //uint32 disableACCheckTimer;
+    uint32 totalReports;
+    uint32 typeReports[MAX_REPORT_TYPES];
+    float average;
+    uint32 creationTime;
+    uint32 tempReports[MAX_REPORT_TYPES];
+    uint32 tempReportsTimer[MAX_REPORT_TYPES];
+    bool hasDailyReport;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/Anticheat/AnticheatMgr.cpp b/src/server/game/Anticheat/AnticheatMgr.cpp
new file mode 100644
index 0000000..f409e93
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatMgr.cpp
@@ -0,0 +1,434 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "AnticheatMgr.h"
+#include "AnticheatScripts.h"
+#include "MapManager.h"
+
+#define CLIMB_ANGLE 1.9f
+
+AnticheatMgr::AnticheatMgr()
+{
+}
+
+AnticheatMgr::~AnticheatMgr()
+{
+    m_Players.clear();
+}
+
+void AnticheatMgr::JumpHackDetection(Player* player, MovementInfo /* movementInfo */,uint32 opcode)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & JUMP_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+
+    if (m_Players[key].GetLastOpcode() == MSG_MOVE_JUMP && opcode == MSG_MOVE_JUMP)
+    {
+        BuildReport(player,JUMP_HACK_REPORT);
+        TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Jump-Hack detected player GUID (low) %u",player->GetGUIDLow());
+    }
+}
+
+void AnticheatMgr::WalkOnWaterHackDetection(Player* player, MovementInfo /* movementInfo */)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & WALK_WATER_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+    if (!m_Players[key].GetLastMovementInfo().HasMovementFlag(MOVEMENTFLAG_WATERWALKING))
+        return;
+
+    // if we are a ghost we can walk on water
+    if (!player->IsAlive())
+        return;
+
+    if (player->HasAuraType(SPELL_AURA_FEATHER_FALL) ||
+        player->HasAuraType(SPELL_AURA_SAFE_FALL) ||
+        player->HasAuraType(SPELL_AURA_WATER_WALK))
+        return;
+
+    TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Walk on Water - Hack detected player GUID (low) %u",player->GetGUIDLow());
+    BuildReport(player,WALK_WATER_HACK_REPORT);
+
+}
+
+void AnticheatMgr::FlyHackDetection(Player* player, MovementInfo /* movementInfo */)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & FLY_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+    if (!m_Players[key].GetLastMovementInfo().HasMovementFlag(MOVEMENTFLAG_FLYING))
+        return;
+
+    if (player->HasAuraType(SPELL_AURA_FLY) ||
+        player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ||
+        player->HasAuraType(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED))
+        return;
+
+    TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Fly-Hack detected player GUID (low) %u",player->GetGUIDLow());
+    BuildReport(player,FLY_HACK_REPORT);
+}
+
+void AnticheatMgr::TeleportPlaneHackDetection(Player* player, MovementInfo movementInfo)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & TELEPORT_PLANE_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+
+    if (m_Players[key].GetLastMovementInfo().pos.GetPositionZ() != 0 ||
+        movementInfo.pos.GetPositionZ() != 0)
+        return;
+
+    if (movementInfo.HasMovementFlag(MOVEMENTFLAG_FALLING))
+        return;
+
+    //DEAD_FALLING was deprecated
+    //if (player->getDeathState() == DEAD_FALLING)
+    //    return;
+    float x, y, z;
+    player->GetPosition(x, y, z);
+    float ground_Z = player->GetMap()->GetHeight(x, y, z);
+    float z_diff = fabs(ground_Z - z);
+
+    // we are not really walking there
+    if (z_diff > 1.0f)
+    {
+        TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Teleport To Plane - Hack detected player GUID (low) %u",player->GetGUIDLow());
+        BuildReport(player,TELEPORT_PLANE_HACK_REPORT);
+    }
+}
+
+void AnticheatMgr::StartHackDetection(Player* player, MovementInfo movementInfo, uint32 opcode)
+{
+    if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+        return;
+
+    if (player->IsGameMaster())
+        return;
+
+    uint32 key = player->GetGUIDLow();
+
+    if (player->IsInFlight() || player->GetTransport() || player->GetVehicle())
+    {
+        m_Players[key].SetLastMovementInfo(movementInfo);
+        m_Players[key].SetLastOpcode(opcode);
+        return;
+    }
+
+    SpeedHackDetection(player,movementInfo);
+    FlyHackDetection(player,movementInfo);
+    WalkOnWaterHackDetection(player,movementInfo);
+    JumpHackDetection(player,movementInfo,opcode);
+    TeleportPlaneHackDetection(player, movementInfo);
+    ClimbHackDetection(player,movementInfo,opcode);
+
+    m_Players[key].SetLastMovementInfo(movementInfo);
+    m_Players[key].SetLastOpcode(opcode);
+}
+
+// basic detection
+void AnticheatMgr::ClimbHackDetection(Player *player, MovementInfo movementInfo, uint32 opcode)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & CLIMB_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+
+    if (opcode != MSG_MOVE_HEARTBEAT ||
+        m_Players[key].GetLastOpcode() != MSG_MOVE_HEARTBEAT)
+        return;
+
+    // in this case we don't care if they are "legal" flags, they are handled in another parts of the Anticheat Manager.
+    if (player->IsInWater() ||
+        player->IsFlying() ||
+        player->IsFalling())
+        return;
+
+    Position playerPos;
+    Position pos = player->GetPosition();
+
+    float deltaZ = fabs(playerPos.GetPositionZ() - movementInfo.pos.GetPositionZ());
+    float deltaXY = movementInfo.pos.GetExactDist2d(&playerPos);
+
+    float angle = Position::NormalizeOrientation(tan(deltaZ/deltaXY));
+
+    if (angle > CLIMB_ANGLE)
+    {
+        TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Climb-Hack detected player GUID (low) %u", player->GetGUIDLow());
+        BuildReport(player,CLIMB_HACK_REPORT);
+    }
+}
+
+void AnticheatMgr::SpeedHackDetection(Player* player,MovementInfo movementInfo)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & SPEED_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+
+    // We also must check the map because the movementFlag can be modified by the client.
+    // If we just check the flag, they could always add that flag and always skip the speed hacking detection.
+    // 369 == DEEPRUN TRAM
+    if (m_Players[key].GetLastMovementInfo().HasMovementFlag(MOVEMENTFLAG_ONTRANSPORT) && player->GetMapId() == 369)
+        return;
+
+    uint32 distance2D = (uint32)movementInfo.pos.GetExactDist2d(&m_Players[key].GetLastMovementInfo().pos);
+    uint8 moveType = 0;
+
+    // we need to know HOW is the player moving
+    // TO-DO: Should we check the incoming movement flags?
+    if (player->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+        moveType = MOVE_SWIM;
+    else if (player->IsFlying())
+        moveType = MOVE_FLIGHT;
+    else if (player->HasUnitMovementFlag(MOVEMENTFLAG_WALKING))
+        moveType = MOVE_WALK;
+    else
+        moveType = MOVE_RUN;
+
+    // how many yards the player can do in one sec.
+    uint32 speedRate = (uint32)(player->GetSpeed(UnitMoveType(moveType)) + movementInfo.jump.xyspeed);
+
+    // how long the player took to move to here.
+    uint32 timeDiff = getMSTimeDiff(m_Players[key].GetLastMovementInfo().time,movementInfo.time);
+
+    if (!timeDiff)
+        timeDiff = 1;
+
+    // this is the distance doable by the player in 1 sec, using the time done to move to this point.
+    uint32 clientSpeedRate = distance2D * 1000 / timeDiff;
+
+    // we did the (uint32) cast to accept a margin of tolerance
+    if (clientSpeedRate > speedRate)
+    {
+        BuildReport(player,SPEED_HACK_REPORT);
+        TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Speed-Hack detected player GUID (low) %u",player->GetGUIDLow());
+    }
+}
+
+void AnticheatMgr::StartScripts()
+{
+    new AnticheatScripts();
+}
+
+void AnticheatMgr::HandlePlayerLogin(Player* player)
+{
+    // we must delete this to prevent errors in case of crash
+    CharacterDatabase.PExecute("DELETE FROM players_reports_status WHERE guid=%u",player->GetGUIDLow());
+    // we initialize the pos of lastMovementPosition var.
+    m_Players[player->GetGUIDLow()].SetPosition(player->GetPositionX(),player->GetPositionY(),player->GetPositionZ(),player->GetOrientation());
+    QueryResult resultDB = CharacterDatabase.PQuery("SELECT * FROM daily_players_reports WHERE guid=%u;",player->GetGUIDLow());
+
+    if (resultDB)
+        m_Players[player->GetGUIDLow()].SetDailyReportState(true);
+}
+
+void AnticheatMgr::HandlePlayerLogout(Player* player)
+{
+    // TO-DO Make a table that stores the cheaters of the day, with more detailed information.
+
+    // We must also delete it at logout to prevent have data of offline players in the db when we query the database (IE: The GM Command)
+    CharacterDatabase.PExecute("DELETE FROM players_reports_status WHERE guid=%u",player->GetGUIDLow());
+    // Delete not needed data from the memory.
+    m_Players.erase(player->GetGUIDLow());
+}
+
+void AnticheatMgr::SavePlayerData(Player* player)
+{
+    CharacterDatabase.PExecute("REPLACE INTO players_reports_status (guid,average,total_reports,speed_reports,fly_reports,jump_reports,waterwalk_reports,teleportplane_reports,climb_reports,creation_time) VALUES (%u,%f,%u,%u,%u,%u,%u,%u,%u,%u);",player->GetGUIDLow(),m_Players[player->GetGUIDLow()].GetAverage(),m_Players[player->GetGUIDLow()].GetTotalReports(), m_Players[player->GetGUIDLow()].GetTypeReports(SPEED_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(FLY_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(JUMP_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(WALK_WATER_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(TELEPORT_PLANE_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(CLIMB_HACK_REPORT),m_Players[player->GetGUIDLow()].GetCreationTime());
+}
+
+uint32 AnticheatMgr::GetTotalReports(uint32 lowGUID)
+{
+    return m_Players[lowGUID].GetTotalReports();
+}
+
+float AnticheatMgr::GetAverage(uint32 lowGUID)
+{
+    return m_Players[lowGUID].GetAverage();
+}
+
+uint32 AnticheatMgr::GetTypeReports(uint32 lowGUID, uint8 type)
+{
+    return m_Players[lowGUID].GetTypeReports(type);
+}
+
+bool AnticheatMgr::MustCheckTempReports(uint8 type)
+{
+    if (type == JUMP_HACK_REPORT)
+        return false;
+
+    return true;
+}
+
+void AnticheatMgr::BuildReport(Player* player,uint8 reportType)
+{
+    uint32 key = player->GetGUIDLow();
+
+    if (MustCheckTempReports(reportType))
+    {
+        uint32 actualTime = getMSTime();
+
+        if (!m_Players[key].GetTempReportsTimer(reportType))
+            m_Players[key].SetTempReportsTimer(actualTime,reportType);
+
+        if (getMSTimeDiff(m_Players[key].GetTempReportsTimer(reportType),actualTime) < 3000)
+        {
+            m_Players[key].SetTempReports(m_Players[key].GetTempReports(reportType)+1,reportType);
+
+            if (m_Players[key].GetTempReports(reportType) < 3)
+                return;
+        } else
+        {
+            m_Players[key].SetTempReportsTimer(actualTime,reportType);
+            m_Players[key].SetTempReports(1,reportType);
+            return;
+        }
+    }
+
+    // generating creationTime for average calculation
+    if (!m_Players[key].GetTotalReports())
+        m_Players[key].SetCreationTime(getMSTime());
+
+    // increasing total_reports
+    m_Players[key].SetTotalReports(m_Players[key].GetTotalReports()+1);
+    // increasing specific cheat report
+    m_Players[key].SetTypeReports(reportType,m_Players[key].GetTypeReports(reportType)+1);
+
+    // diff time for average calculation
+    uint32 diffTime = getMSTimeDiff(m_Players[key].GetCreationTime(),getMSTime()) / IN_MILLISECONDS;
+
+    if (diffTime > 0)
+    {
+        // Average == Reports per second
+        float average = float(m_Players[key].GetTotalReports()) / float(diffTime);
+        m_Players[key].SetAverage(average);
+    }
+
+    if (sWorld->getIntConfig(CONFIG_ANTICHEAT_MAX_REPORTS_FOR_DAILY_REPORT) < m_Players[key].GetTotalReports())
+    {
+        if (!m_Players[key].GetDailyReportState())
+        {
+            CharacterDatabase.PExecute("REPLACE INTO daily_players_reports (guid,average,total_reports,speed_reports,fly_reports,jump_reports,waterwalk_reports,teleportplane_reports,climb_reports,creation_time) VALUES (%u,%f,%u,%u,%u,%u,%u,%u,%u,%u);",player->GetGUIDLow(),m_Players[player->GetGUIDLow()].GetAverage(),m_Players[player->GetGUIDLow()].GetTotalReports(), m_Players[player->GetGUIDLow()].GetTypeReports(SPEED_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(FLY_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(JUMP_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(WALK_WATER_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(TELEPORT_PLANE_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(CLIMB_HACK_REPORT),m_Players[player->GetGUIDLow()].GetCreationTime());
+            m_Players[key].SetDailyReportState(true);
+        }
+    }
+
+    if (m_Players[key].GetTotalReports() > sWorld->getIntConfig(CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION))
+    {
+        // display warning at the center of the screen, hacky way?
+        std::string str = "";
+        str = "|cFFFFFC00[AC]|cFF00FFFF[|cFF60FF00" + std::string(player->GetName().c_str()) + "|cFF00FFFF] Possible cheater!";
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalGMMessage(&data);
+    }
+}
+
+void AnticheatMgr::AnticheatGlobalCommand(ChatHandler* handler)
+{
+    // MySQL will sort all for us, anyway this is not the best way we must only save the anticheat data not whole player's data!.
+    sObjectAccessor->SaveAllPlayers();
+
+    QueryResult resultDB = CharacterDatabase.Query("SELECT guid,average,total_reports FROM players_reports_status WHERE total_reports != 0 ORDER BY average ASC LIMIT 3;");
+    if (!resultDB)
+    {
+        handler->PSendSysMessage("No players found.");
+        return;
+    } else
+    {
+        handler->SendSysMessage("=============================");
+        handler->PSendSysMessage("Players with the lowest averages:");
+        do
+        {
+            Field *fieldsDB = resultDB->Fetch();
+
+            uint32 guid = fieldsDB[0].GetUInt32();
+            float average = fieldsDB[1].GetFloat();
+            uint32 total_reports = fieldsDB[2].GetUInt32();
+
+            if (Player* player = sObjectMgr->GetPlayerByLowGUID(guid))
+                handler->PSendSysMessage("Player: %s Average: %f Total Reports: %u",player->GetName().c_str(),average,total_reports);
+
+        } while (resultDB->NextRow());
+    }
+
+    resultDB = CharacterDatabase.Query("SELECT guid,average,total_reports FROM players_reports_status WHERE total_reports != 0 ORDER BY total_reports DESC LIMIT 3;");
+
+    // this should never happen
+    if (!resultDB)
+    {
+        handler->PSendSysMessage("No players found.");
+        return;
+    } else
+    {
+        handler->SendSysMessage("=============================");
+        handler->PSendSysMessage("Players with the more reports:");
+        do
+        {
+            Field *fieldsDB = resultDB->Fetch();
+
+            uint32 guid = fieldsDB[0].GetUInt32();
+            float average = fieldsDB[1].GetFloat();
+            uint32 total_reports = fieldsDB[2].GetUInt32();
+
+            if (Player* player = sObjectMgr->GetPlayerByLowGUID(guid))
+                handler->PSendSysMessage("Player: %s Total Reports: %u Average: %f",player->GetName().c_str(),total_reports,average);
+
+        } while (resultDB->NextRow());
+    }
+}
+
+void AnticheatMgr::AnticheatDeleteCommand(uint32 guid)
+{
+    if (!guid)
+    {
+        for (AnticheatPlayersDataMap::iterator it = m_Players.begin(); it != m_Players.end(); ++it)
+        {
+            (*it).second.SetTotalReports(0);
+            (*it).second.SetAverage(0);
+            (*it).second.SetCreationTime(0);
+            for (uint8 i = 0; i < MAX_REPORT_TYPES; i++)
+            {
+                (*it).second.SetTempReports(0,i);
+                (*it).second.SetTempReportsTimer(0,i);
+                (*it).second.SetTypeReports(i,0);
+            }
+        }
+        CharacterDatabase.PExecute("DELETE FROM players_reports_status;");
+    }
+    else
+    {
+        m_Players[guid].SetTotalReports(0);
+        m_Players[guid].SetAverage(0);
+        m_Players[guid].SetCreationTime(0);
+        for (uint8 i = 0; i < MAX_REPORT_TYPES; i++)
+        {
+            m_Players[guid].SetTempReports(0,i);
+            m_Players[guid].SetTempReportsTimer(0,i);
+            m_Players[guid].SetTypeReports(i,0);
+        }
+        CharacterDatabase.PExecute("DELETE FROM players_reports_status WHERE guid=%u;",guid);
+    }
+}
+
+void AnticheatMgr::ResetDailyReportStates()
+{
+     for (AnticheatPlayersDataMap::iterator it = m_Players.begin(); it != m_Players.end(); ++it)
+         m_Players[(*it).first].SetDailyReportState(false);
+}
diff --git a/src/server/game/Anticheat/AnticheatMgr.h b/src/server/game/Anticheat/AnticheatMgr.h
new file mode 100644
index 0000000..870b3a8
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatMgr.h
@@ -0,0 +1,98 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef SC_ACMGR_H
+#define SC_ACMGR_H
+
+#include <ace/Singleton.h>
+#include "Common.h"
+#include "SharedDefines.h"
+#include "ScriptPCH.h"
+#include "AnticheatData.h"
+#include "Chat.h"
+
+class Player;
+class AnticheatData;
+
+enum ReportTypes
+{
+    SPEED_HACK_REPORT = 0,
+    FLY_HACK_REPORT,
+    WALK_WATER_HACK_REPORT,
+    JUMP_HACK_REPORT,
+    TELEPORT_PLANE_HACK_REPORT,
+    CLIMB_HACK_REPORT,
+
+   // MAX_REPORT_TYPES
+};
+
+enum DetectionTypes
+{
+    SPEED_HACK_DETECTION            = 1,
+    FLY_HACK_DETECTION              = 2,
+    WALK_WATER_HACK_DETECTION       = 4,
+    JUMP_HACK_DETECTION             = 8,
+    TELEPORT_PLANE_HACK_DETECTION   = 16,
+    CLIMB_HACK_DETECTION            = 32
+};
+
+// GUIDLow is the key.
+typedef std::map<uint32, AnticheatData> AnticheatPlayersDataMap;
+
+class AnticheatMgr
+{
+    friend class ACE_Singleton<AnticheatMgr, ACE_Null_Mutex>;
+    AnticheatMgr();
+    ~AnticheatMgr();
+
+    public:
+
+        void StartHackDetection(Player* player, MovementInfo movementInfo, uint32 opcode);
+        void DeletePlayerReport(Player* player, bool login);
+        void DeletePlayerData(Player* player);
+        void CreatePlayerData(Player* player);
+        void SavePlayerData(Player* player);
+
+        void StartScripts();
+
+        void HandlePlayerLogin(Player* player);
+        void HandlePlayerLogout(Player* player);
+
+        uint32 GetTotalReports(uint32 lowGUID);
+        float GetAverage(uint32 lowGUID);
+        uint32 GetTypeReports(uint32 lowGUID, uint8 type);
+
+        void AnticheatGlobalCommand(ChatHandler* handler);
+        void AnticheatDeleteCommand(uint32 guid);
+
+        void ResetDailyReportStates();
+    private:
+        void SpeedHackDetection(Player* player, MovementInfo movementInfo);
+        void FlyHackDetection(Player* player, MovementInfo movementInfo);
+        void WalkOnWaterHackDetection(Player* player, MovementInfo movementInfo);
+        void JumpHackDetection(Player* player, MovementInfo movementInfo,uint32 opcode);
+        void TeleportPlaneHackDetection(Player* player, MovementInfo);
+        void ClimbHackDetection(Player* player,MovementInfo movementInfo,uint32 opcode);
+
+        void BuildReport(Player* player,uint8 reportType);
+
+        bool MustCheckTempReports(uint8 type);
+
+        AnticheatPlayersDataMap m_Players;                        ///< Player data
+};
+
+#define sAnticheatMgr ACE_Singleton<AnticheatMgr, ACE_Null_Mutex>::instance()
+
+#endif
diff --git a/src/server/game/Anticheat/AnticheatScripts.cpp b/src/server/game/Anticheat/AnticheatScripts.cpp
new file mode 100644
index 0000000..340178d
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatScripts.cpp
@@ -0,0 +1,14 @@
+#include "AnticheatScripts.h"
+#include "AnticheatMgr.h"
+
+AnticheatScripts::AnticheatScripts(): PlayerScript("AnticheatScripts") {}
+
+void AnticheatScripts::OnLogout(Player* player)
+{
+    sAnticheatMgr->HandlePlayerLogout(player);
+}
+
+void AnticheatScripts::OnLogin(Player* player,bool)
+{
+    sAnticheatMgr->HandlePlayerLogin(player);
+}
diff --git a/src/server/game/Anticheat/AnticheatScripts.h b/src/server/game/Anticheat/AnticheatScripts.h
new file mode 100644
index 0000000..25d34d0
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatScripts.h
@@ -0,0 +1,15 @@
+#ifndef SC_ACSCRIPTS_H
+#define SC_ACSCRIPTS_H
+
+#include "ScriptPCH.h"
+
+class AnticheatScripts: public PlayerScript
+{
+    public:
+        AnticheatScripts();
+
+        void OnLogout(Player* player);
+        void OnLogin(Player* player,bool);
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
new file mode 100644
index 0000000..fb20d2f
--- /dev/null
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
@@ -0,0 +1,1897 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ObjectMgr.h"
+#include "AuctionHouseMgr.h"
+#include "AuctionHouseBot.h"
+#include "Player.h"
+#include "WorldSession.h"
+#include <vector>
+
+using namespace std;
+vector<uint32> npcItems;
+vector<uint32> lootItems;
+vector<uint32> greyTradeGoodsBin;
+vector<uint32> whiteTradeGoodsBin;
+vector<uint32> greenTradeGoodsBin;
+vector<uint32> blueTradeGoodsBin;
+vector<uint32> purpleTradeGoodsBin;
+vector<uint32> orangeTradeGoodsBin;
+vector<uint32> yellowTradeGoodsBin;
+vector<uint32> greyItemsBin;
+vector<uint32> whiteItemsBin;
+vector<uint32> greenItemsBin;
+vector<uint32> blueItemsBin;
+vector<uint32> purpleItemsBin;
+vector<uint32> orangeItemsBin;
+vector<uint32> yellowItemsBin;
+
+AuctionHouseBot::AuctionHouseBot()
+{
+    debug_Out = false;
+    debug_Out_Filters = false;
+    AHBSeller = false;
+    AHBBuyer = false;
+
+    //Begin Filters
+
+    Vendor_Items = false;
+    Loot_Items = false;
+    Other_Items = false;
+    Vendor_TGs = false;
+    Loot_TGs = false;
+    Other_TGs = false;
+
+    No_Bind = false;
+    Bind_When_Picked_Up = false;
+    Bind_When_Equipped = false;
+    Bind_When_Use = false;
+    Bind_Quest_Item = false;
+
+    DisablePermEnchant = false;
+    DisableConjured = false;
+    DisableGems = false;
+    DisableMoney = false;
+    DisableMoneyLoot = false;
+    DisableLootable = false;
+    DisableKeys = false;
+    DisableDuration = false;
+    DisableBOP_Or_Quest_NoReqLevel = false;
+
+    DisableWarriorItems = false;
+    DisablePaladinItems = false;
+    DisableHunterItems = false;
+    DisableRogueItems = false;
+    DisablePriestItems = false;
+    DisableDKItems = false;
+    DisableShamanItems = false;
+    DisableMageItems = false;
+    DisableWarlockItems = false;
+    DisableUnusedClassItems = false;
+    DisableDruidItems = false;
+
+    DisableItemsBelowLevel = 0;
+    DisableItemsAboveLevel = 0;
+    DisableTGsBelowLevel = 0;
+    DisableTGsAboveLevel = 0;
+    DisableItemsBelowGUID = 0;
+    DisableItemsAboveGUID = 0;
+    DisableTGsBelowGUID = 0;
+    DisableTGsAboveGUID = 0;
+    DisableItemsBelowReqLevel = 0;
+    DisableItemsAboveReqLevel = 0;
+    DisableTGsBelowReqLevel = 0;
+    DisableTGsAboveReqLevel = 0;
+    DisableItemsBelowReqSkillRank = 0;
+    DisableItemsAboveReqSkillRank = 0;
+    DisableTGsBelowReqSkillRank = 0;
+    DisableTGsAboveReqSkillRank = 0;
+
+    //End Filters
+
+    _lastrun_a = time(NULL);
+    _lastrun_h = time(NULL);
+    _lastrun_n = time(NULL);
+
+    AllianceConfig = AHBConfig(2);
+    HordeConfig = AHBConfig(6);
+    NeutralConfig = AHBConfig(7);
+}
+
+AuctionHouseBot::~AuctionHouseBot()
+{
+}
+
+void AuctionHouseBot::addNewAuctions(Player *AHBplayer, AHBConfig *config)
+{
+    if (!AHBSeller)
+    {
+        if (debug_Out) TC_LOG_INFO("misc", "AHSeller: Disabled");
+        return;
+    }
+
+    uint32 minItems = config->GetMinItems();
+    uint32 maxItems = config->GetMaxItems();
+
+    if (maxItems == 0)
+    {
+        //if (debug_Out) TC_LOG_INFO("misc", "AHSeller: Auctions disabled");
+        return;
+    }
+
+    AuctionHouseEntry const* ahEntry =  sAuctionMgr->GetAuctionHouseEntry(config->GetAHFID());
+    if (!ahEntry)
+    {
+        return;
+    }
+    AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+    if (!auctionHouse)
+    {
+        return;
+    }
+
+    uint32 auctions = auctionHouse->Getcount();
+
+    uint32 items = 0;
+
+    if (auctions >= minItems)
+    {
+        //if (debug_Out) TC_LOG_ERROR("misc", "AHSeller: Auctions above minimum");
+        return;
+    }
+
+    if (auctions >= maxItems)
+    {
+        //if (debug_Out) TC_LOG_ERROR("misc", "AHSeller: Auctions at or above maximum");
+        return;
+    }
+
+    if ((maxItems - auctions) >= ItemsPerCycle)
+        items = ItemsPerCycle;
+    else
+        items = (maxItems - auctions);
+
+    if (debug_Out) TC_LOG_INFO("misc", "AHSeller: Adding %u Auctions", items);
+
+    uint32 AuctioneerGUID = 0;
+
+    switch (config->GetAHID())
+    {
+    case 2:
+        AuctioneerGUID = 79707; //Human in stormwind.
+        break;
+    case 6:
+        AuctioneerGUID = 4656; //orc in Orgrimmar
+        break;
+    case 7:
+        AuctioneerGUID = 23442; //goblin in GZ
+        break;
+    default:
+        if (debug_Out) TC_LOG_ERROR("misc", "AHSeller: GetAHID() - Default switch reached");
+        AuctioneerGUID = 23442; //default to neutral 7
+        break;
+    }
+
+    if (debug_Out) TC_LOG_ERROR("misc", "AHSeller: Current Auctineer GUID is %u", AuctioneerGUID);
+
+    uint32 greyTGcount = config->GetPercents(AHB_GREY_TG);
+    uint32 whiteTGcount = config->GetPercents(AHB_WHITE_TG);
+    uint32 greenTGcount = config->GetPercents(AHB_GREEN_TG);
+    uint32 blueTGcount = config->GetPercents(AHB_BLUE_TG);
+    uint32 purpleTGcount = config->GetPercents(AHB_PURPLE_TG);
+    uint32 orangeTGcount = config->GetPercents(AHB_ORANGE_TG);
+    uint32 yellowTGcount = config->GetPercents(AHB_YELLOW_TG);
+    uint32 greyIcount = config->GetPercents(AHB_GREY_I);
+    uint32 whiteIcount = config->GetPercents(AHB_WHITE_I);
+    uint32 greenIcount = config->GetPercents(AHB_GREEN_I);
+    uint32 blueIcount = config->GetPercents(AHB_BLUE_I);
+    uint32 purpleIcount = config->GetPercents(AHB_PURPLE_I);
+    uint32 orangeIcount = config->GetPercents(AHB_ORANGE_I);
+    uint32 yellowIcount = config->GetPercents(AHB_YELLOW_I);
+/*    uint32 total = greyTGcount + whiteTGcount + greenTGcount + blueTGcount
+        + purpleTGcount + orangeTGcount + yellowTGcount
+        + whiteIcount + greenIcount + blueIcount + purpleIcount
+        + orangeIcount + yellowIcount;
+*/
+    uint32 greyTGoods = config->GetItemCounts(AHB_GREY_TG);
+    uint32 whiteTGoods = config->GetItemCounts(AHB_WHITE_TG);
+    uint32 greenTGoods = config->GetItemCounts(AHB_GREEN_TG);
+    uint32 blueTGoods = config->GetItemCounts(AHB_BLUE_TG);
+    uint32 purpleTGoods = config->GetItemCounts(AHB_PURPLE_TG);
+    uint32 orangeTGoods = config->GetItemCounts(AHB_ORANGE_TG);
+    uint32 yellowTGoods = config->GetItemCounts(AHB_YELLOW_TG);
+
+    uint32 greyItems = config->GetItemCounts(AHB_GREY_I);
+    uint32 whiteItems = config->GetItemCounts(AHB_WHITE_I);
+    uint32 greenItems = config->GetItemCounts(AHB_GREEN_I);
+    uint32 blueItems = config->GetItemCounts(AHB_BLUE_I);
+    uint32 purpleItems = config->GetItemCounts(AHB_PURPLE_I);
+    uint32 orangeItems = config->GetItemCounts(AHB_ORANGE_I);
+    uint32 yellowItems = config->GetItemCounts(AHB_YELLOW_I);
+    if (debug_Out) TC_LOG_ERROR("misc", "AHSeller: %u items", items);
+
+    // only insert a few at a time, so as not to peg the processor
+    for (uint32 cnt = 1; cnt <= items; cnt++)
+    {
+    if (debug_Out) TC_LOG_ERROR("misc", "AHSeller: %u count", cnt);
+        uint32 itemID = 0;
+        uint32 itemColor = 99;
+        uint32 loopbreaker = 0;
+        while (itemID == 0 && loopbreaker <= 50)
+        {
+            ++loopbreaker;
+            uint32 choice = urand(0, 13);
+            itemColor = choice;
+            switch (choice)
+            {
+            case 0:
+                {
+                    if ((greyItemsBin.size() > 0) && (greyItems < greyIcount))
+                        itemID = greyItemsBin[urand(0, greyItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 1:
+                {
+                    if ((whiteItemsBin.size() > 0) && (whiteItems < whiteIcount))
+                        itemID = whiteItemsBin[urand(0, whiteItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 2:
+                {
+                    if ((greenItemsBin.size() > 0) && (greenItems < greenIcount))
+                        itemID = greenItemsBin[urand(0, greenItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 3:
+                {
+                    if ((blueItemsBin.size() > 0) && (blueItems < blueIcount))
+                        itemID = blueItemsBin[urand(0, blueItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 4:
+                {
+                    if ((purpleItemsBin.size() > 0) && (purpleItems < purpleIcount))
+                        itemID = purpleItemsBin[urand(0, purpleItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 5:
+                {
+                    if ((orangeItemsBin.size() > 0) && (orangeItems < orangeIcount))
+                        itemID = orangeItemsBin[urand(0, orangeItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 6:
+                {
+                    if ((yellowItemsBin.size() > 0) && (yellowItems < yellowIcount))
+                        itemID = yellowItemsBin[urand(0, yellowItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 7:
+                {
+                    if ((greyTradeGoodsBin.size() > 0) && (greyTGoods < greyTGcount))
+                        itemID = greyTradeGoodsBin[urand(0, greyTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 8:
+                {
+                    if ((whiteTradeGoodsBin.size() > 0) && (whiteTGoods < whiteTGcount))
+                        itemID = whiteTradeGoodsBin[urand(0, whiteTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 9:
+                {
+                    if ((greenTradeGoodsBin.size() > 0) && (greenTGoods < greenTGcount))
+                        itemID = greenTradeGoodsBin[urand(0, greenTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 10:
+                {
+                    if ((blueTradeGoodsBin.size() > 0) && (blueTGoods < blueTGcount))
+                        itemID = blueTradeGoodsBin[urand(0, blueTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 11:
+                {
+                    if ((purpleTradeGoodsBin.size() > 0) && (purpleTGoods < purpleTGcount))
+                        itemID = purpleTradeGoodsBin[urand(0, purpleTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 12:
+                {
+                    if ((orangeTradeGoodsBin.size() > 0) && (orangeTGoods < orangeTGcount))
+                        itemID = orangeTradeGoodsBin[urand(0, orangeTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 13:
+                {
+                    if ((yellowTradeGoodsBin.size() > 0) && (yellowTGoods < yellowTGcount))
+                        itemID = yellowTradeGoodsBin[urand(0, yellowTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            default:
+                {
+                    if (debug_Out) TC_LOG_ERROR("misc", "AHSeller: itemID Switch - Default Reached");
+                    break;
+                }
+            }
+
+            if (itemID == 0)
+            {
+                if (debug_Out) TC_LOG_ERROR("misc", "AHSeller: Item::CreateItem() - ItemID is 0");
+                continue;
+            }
+
+            ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(itemID);
+            if (prototype == NULL)
+            {
+                if (debug_Out) TC_LOG_ERROR("misc", "AHSeller: Huh?!?! prototype == NULL");
+                continue;
+            }
+
+            Item* item = Item::CreateItem(itemID, 1, AHBplayer);
+            if (item == NULL)
+            {
+                if (debug_Out) TC_LOG_ERROR("misc", "AHSeller: Item::CreateItem() returned NULL");
+                break;
+            }
+            item->AddToUpdateQueueOf(AHBplayer);
+
+            uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(itemID);
+            if (randomPropertyId != 0)
+                item->SetItemRandomProperties(randomPropertyId);
+
+            uint64 buyoutPrice = 0;
+            uint64 bidPrice = 0;
+            uint32 stackCount = 1;
+
+            switch (SellMethod)
+            {
+            case 0:
+                buyoutPrice  = prototype->SellPrice;
+                break;
+            case 1:
+                buyoutPrice  = prototype->BuyPrice;
+                break;
+            }
+
+            if (prototype->Quality <= AHB_MAX_QUALITY)
+            {
+                if (config->GetMaxStack(prototype->Quality) > 1 && item->GetMaxStackCount() > 1)
+                    stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(prototype->Quality)));
+                else if (config->GetMaxStack(prototype->Quality) == 0 && item->GetMaxStackCount() > 1)
+                    stackCount = urand(1, item->GetMaxStackCount());
+                else
+                    stackCount = 1;
+                buyoutPrice *= urand(config->GetMinPrice(prototype->Quality), config->GetMaxPrice(prototype->Quality));
+                buyoutPrice /= 100;
+                bidPrice = buyoutPrice * urand(config->GetMinBidPrice(prototype->Quality), config->GetMaxBidPrice(prototype->Quality));
+                bidPrice /= 100;
+            }
+            else
+            {
+                // quality is something it shouldn't be, let's get out of here
+                if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: Quality %u not Supported", prototype->Quality);
+                item->RemoveFromUpdateQueueOf(AHBplayer);
+                continue;
+            }
+
+            uint32 etime = urand(1,3);
+            switch(etime)
+            {
+            case 1:
+                etime = 43200;
+                break;
+            case 2:
+                etime = 86400;
+                break;
+            case 3:
+                etime = 172800;
+                break;
+            default:
+                etime = 86400;
+                break;
+            }
+            item->SetCount(stackCount);
+
+            uint32 dep =  sAuctionMgr->GetAuctionDeposit(ahEntry, etime, item, stackCount);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            AuctionEntry* auctionEntry = new AuctionEntry();
+            auctionEntry->Id = sObjectMgr->GenerateAuctionID();
+            auctionEntry->auctioneer = AuctioneerGUID;
+            auctionEntry->itemGUIDLow = item->GetGUIDLow();
+            auctionEntry->itemEntry = item->GetEntry();
+            auctionEntry->itemCount = item->GetCount();
+            auctionEntry->owner = AHBplayer->GetGUIDLow();
+            auctionEntry->startbid = bidPrice * stackCount;
+            auctionEntry->buyout = buyoutPrice * stackCount;
+            auctionEntry->bidder = 0;
+            auctionEntry->bid = 0;
+            auctionEntry->deposit = dep;
+            auctionEntry->expire_time = (time_t) etime + time(NULL);
+            auctionEntry->auctionHouseEntry = ahEntry;
+            item->SaveToDB(trans);
+            item->RemoveFromUpdateQueueOf(AHBplayer);
+            sAuctionMgr->AddAItem(item);
+            auctionHouse->AddAuction(auctionEntry);
+            auctionEntry->SaveToDB(trans);
+            CharacterDatabase.CommitTransaction(trans);
+
+            switch(itemColor)
+            {
+            case 0:
+                ++greyItems;
+                break;
+            case 1:
+                ++whiteItems;
+                break;
+            case 2:
+                ++greenItems;
+                break;
+            case 3:
+                ++blueItems;
+                break;
+            case 4:
+                ++purpleItems;
+                break;
+            case 5:
+                ++orangeItems;
+                break;
+            case 6:
+                ++yellowItems;
+                break;
+            case 7:
+                ++greyTGoods;
+                break;
+            case 8:
+                ++whiteTGoods;
+                break;
+            case 9:
+                ++greenTGoods;
+                break;
+            case 10:
+                ++blueTGoods;
+                break;
+            case 11:
+                ++purpleTGoods;
+                break;
+            case 12:
+                ++orangeTGoods;
+                break;
+            case 13:
+                ++yellowTGoods;
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+void AuctionHouseBot::addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session)
+{
+    if (!AHBBuyer)
+    {
+        if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: Disabled");
+        return;
+    }
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT id FROM auctionhouse WHERE itemowner<>%u AND buyguid<>%u", AHBplayerGUID, AHBplayerGUID);
+
+    if (!result)
+        return;
+
+    if (result->GetRowCount() == 0)
+        return;
+
+    // Fetches content of selected AH
+    AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+    vector<uint32> possibleBids;
+
+    do
+    {
+        uint32 tmpdata = result->Fetch()->GetUInt32();
+        possibleBids.push_back(tmpdata);
+    }while (result->NextRow());
+
+    for (uint32 count = 1; count <= config->GetBidsPerInterval(); ++count)
+    {
+        // Do we have anything to bid? If not, stop here.
+        if (possibleBids.empty())
+        {
+            //if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: I have no items to bid on.");
+            count = config->GetBidsPerInterval();
+            continue;
+        }
+
+        // Choose random auction from possible auctions
+        uint32 vectorPos = urand(0, possibleBids.size() - 1);
+        vector<uint32>::iterator iter = possibleBids.begin();
+        advance(iter, vectorPos);
+
+        // from auctionhousehandler.cpp, creates auction pointer & player pointer
+        AuctionEntry* auction = auctionHouse->GetAuction(*iter);
+
+        // Erase the auction from the vector to prevent bidding on item in next iteration.
+        possibleBids.erase(iter);
+
+        if (!auction)
+            continue;
+
+        // get exact item information
+        Item *pItem =  sAuctionMgr->GetAItem(auction->itemGUIDLow);
+        if (!pItem)
+        {
+            if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: Item %u doesn't exist, perhaps bought already?", auction->itemGUIDLow);
+            continue;
+        }
+
+        // get item prototype
+        ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(auction->itemEntry);
+
+        // check which price we have to use, startbid or if it is bidded already
+        uint32 currentprice;
+        if (auction->bid)
+            currentprice = auction->bid;
+        else
+            currentprice = auction->startbid;
+
+        // Prepare portion from maximum bid
+        double bidrate = static_cast<double>(urand(1, 100)) / 100;
+        long double bidMax = 0;
+
+        // check that bid has acceptable value and take bid based on vendorprice, stacksize and quality
+        switch (BuyMethod)
+        {
+        case 0:
+            {
+                if (prototype->Quality <= AHB_MAX_QUALITY)
+                {
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality))
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality);
+                }
+                else
+                {
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: Quality %u not Supported", prototype->Quality);
+                    continue;
+                }
+                break;
+            }
+        case 1:
+            {
+                if (prototype->Quality <= AHB_MAX_QUALITY)
+                {
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality))
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality);
+                }
+                else
+                {
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: Quality %u not Supported", prototype->Quality);
+                    continue;
+                }
+                break;
+            }
+        }
+
+        // check some special items, and do recalculating to their prices
+        switch (prototype->Class)
+        {
+            // ammo
+        case 6:
+            bidMax = 0;
+            break;
+        default:
+            break;
+        }
+
+        if (bidMax == 0)
+        {
+            // quality check failed to get bidmax, let's get out of here
+            continue;
+        }
+
+        // Calculate our bid
+        long double bidvalue = currentprice + ((bidMax - currentprice) * bidrate);
+        // Convert to uint32
+        uint32 bidprice = static_cast<uint32>(bidvalue);
+
+        // Check our bid is high enough to be valid. If not, correct it to minimum.
+        if ((currentprice + auction->GetAuctionOutBid()) > bidprice)
+            bidprice = currentprice + auction->GetAuctionOutBid();
+
+        if (debug_Out)
+        {
+            TC_LOG_INFO("misc", "-------------------------------------------------");
+            TC_LOG_INFO("misc", "AHBuyer: Info for Auction #%u:", auction->Id);
+            TC_LOG_INFO("misc", "AHBuyer: AuctionHouse: %u", auction->GetHouseId());
+            TC_LOG_INFO("misc", "AHBuyer: Auctioneer: %u", auction->auctioneer);
+            TC_LOG_INFO("misc", "AHBuyer: Owner: %u", auction->owner);
+            TC_LOG_INFO("misc", "AHBuyer: Bidder: %u", auction->bidder);
+            TC_LOG_INFO("misc", "AHBuyer: Starting Bid: %u", auction->startbid);
+            TC_LOG_INFO("misc", "AHBuyer: Current Bid: %u", currentprice);
+            TC_LOG_INFO("misc", "AHBuyer: Buyout: %u", auction->buyout);
+            TC_LOG_INFO("misc", "AHBuyer: Deposit: %u", auction->deposit);
+            TC_LOG_INFO("misc", "AHBuyer: Expire Time: %u", uint32(auction->expire_time));
+            TC_LOG_INFO("misc", "AHBuyer: Bid Rate: %f", bidrate);
+            TC_LOG_INFO("misc", "AHBuyer: Bid Max: %Lf", bidMax);
+            TC_LOG_INFO("misc", "AHBuyer: Bid Value: %Lf", bidvalue);
+            TC_LOG_INFO("misc", "AHBuyer: Bid Price: %u", bidprice);
+            TC_LOG_INFO("misc", "AHBuyer: Item GUID: %u", auction->itemGUIDLow);
+            TC_LOG_INFO("misc", "AHBuyer: Item Template: %u", auction->itemEntry);
+            TC_LOG_INFO("misc", "AHBuyer: Item Info:");
+            TC_LOG_INFO("misc", "AHBuyer: Item ID: %u", prototype->ItemId);
+            TC_LOG_INFO("misc", "AHBuyer: Buy Price: %u", prototype->BuyPrice);
+            TC_LOG_INFO("misc", "AHBuyer: Sell Price: %u", prototype->SellPrice);
+            TC_LOG_INFO("misc", "AHBuyer: Bonding: %u", prototype->Bonding);
+            TC_LOG_INFO("misc", "AHBuyer: Quality: %u", prototype->Quality);
+            TC_LOG_INFO("misc", "AHBuyer: Item Level: %u", prototype->ItemLevel);
+            TC_LOG_INFO("misc", "AHBuyer: Ammo Type: %u", prototype->AmmoType);
+            TC_LOG_INFO("misc", "-------------------------------------------------");
+        }
+
+        // Check whether we do normal bid, or buyout
+        if ((bidprice < auction->buyout) || (auction->buyout == 0))
+        {
+
+            if (auction->bidder > 0)
+            {
+                if (auction->bidder == AHBplayer->GetGUIDLow())
+                {
+                    //pl->ModifyMoney(-int32(price - auction->bid));
+                }
+                else
+                {
+                    // mail to last bidder and return money
+                    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                    sAuctionMgr->SendAuctionOutbiddedMail(auction , bidprice, session->GetPlayer(), trans);
+                    CharacterDatabase.CommitTransaction(trans);
+                    //pl->ModifyMoney(-int32(price));
+                }
+           }
+
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = bidprice;
+
+            // Saving auction into database
+            CharacterDatabase.PExecute("UPDATE auctionhouse SET buyguid = '%u',lastbid = '%u' WHERE id = '%u'", auction->bidder, auction->bid, auction->Id);
+        }
+        else
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            //buyout
+            if ((auction->bidder) && (AHBplayer->GetGUIDLow() != auction->bidder))
+            {
+                sAuctionMgr->SendAuctionOutbiddedMail(auction, auction->buyout, session->GetPlayer(), trans);
+            }
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = auction->buyout;
+
+            // Send mails to buyer & seller
+            sAuctionMgr->SendAuctionSalePendingMail(auction, trans);
+            sAuctionMgr->SendAuctionSuccessfulMail(auction, trans);
+            sAuctionMgr->SendAuctionWonMail(auction, trans);
+            auction->DeleteFromDB( trans);
+            uint32 itemEntry = auction->itemEntry;
+            sAuctionMgr->RemoveAItem(auction->itemGUIDLow);
+            auctionHouse->RemoveAuction(auction, itemEntry);
+            CharacterDatabase.CommitTransaction(trans);
+        }
+    }
+}
+
+void AuctionHouseBot::Update()
+{
+    time_t _newrun = time(NULL);
+    if ((!AHBSeller) && (!AHBBuyer))
+        return;
+
+    WorldSession _session(AHBplayerAccount, NULL, SEC_PLAYER, true, 0, LOCALE_enUS, 0, 0);
+    Player _AHBplayer(&_session);
+    _AHBplayer.Initialize(AHBplayerGUID);
+    sObjectAccessor->AddObject(&_AHBplayer);
+
+    // Add New Bids
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        addNewAuctions(&_AHBplayer, &AllianceConfig);
+        if (((_newrun - _lastrun_a) >= (AllianceConfig.GetBiddingInterval() * MINUTE)) && (AllianceConfig.GetBidsPerInterval() > 0))
+        {
+            //if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_a));
+            //if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: Bidding on Alliance Auctions");
+            addNewAuctionBuyerBotBid(&_AHBplayer, &AllianceConfig, &_session);
+            _lastrun_a = _newrun;
+        }
+
+        addNewAuctions(&_AHBplayer, &HordeConfig);
+        if (((_newrun - _lastrun_h) >= (HordeConfig.GetBiddingInterval() * MINUTE)) && (HordeConfig.GetBidsPerInterval() > 0))
+        {
+            //if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_h));
+            //if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: Bidding on Horde Auctions");
+            addNewAuctionBuyerBotBid(&_AHBplayer, &HordeConfig, &_session);
+            _lastrun_h = _newrun;
+        }
+    }
+
+    addNewAuctions(&_AHBplayer, &NeutralConfig);
+    if (((_newrun - _lastrun_n) >= (NeutralConfig.GetBiddingInterval() * MINUTE)) && (NeutralConfig.GetBidsPerInterval() > 0))
+    {
+        //if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_n));
+        //if (debug_Out) TC_LOG_ERROR("misc", "AHBuyer: Bidding on Neutral Auctions");
+        addNewAuctionBuyerBotBid(&_AHBplayer, &NeutralConfig, &_session);
+        _lastrun_n = _newrun;
+    }
+    sObjectAccessor->RemoveObject(&_AHBplayer);
+}
+
+void AuctionHouseBot::Initialize()
+{
+    std::string disabledItems = sConfigMgr->GetStringDefault("AuctionHouseBot.DisabledItems", "");
+    DisableItemStore.clear();
+    Tokenizer tokens(disabledItems, ' ');
+    for (Tokenizer::const_iterator iter = tokens.begin(); iter != tokens.end(); ++iter)
+    {
+        uint32 id = uint32(atol(*iter));
+        DisableItemStore.insert(id);
+    }
+
+    //End Filters
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        LoadValues(&AllianceConfig);
+        LoadValues(&HordeConfig);
+    }
+    LoadValues(&NeutralConfig);
+
+    //
+    // check if the AHBot account/GUID in the config actually exists
+    //
+
+    if ((AHBplayerAccount != 0) || (AHBplayerGUID != 0))
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT 1 FROM characters WHERE account = %u AND guid = %u", AHBplayerAccount, AHBplayerGUID);
+        if (!result)
+       {
+           TC_LOG_ERROR("server.loading", "AuctionHouseBot: The account/GUID-information set for your AHBot is incorrect (account: %u guid: %u)", AHBplayerAccount, AHBplayerGUID);
+           return;
+        }
+    }
+
+    if (AHBSeller)
+    {
+        QueryResult results = QueryResult(NULL);
+        char npcQuery[] = "SELECT distinct item FROM npc_vendor";
+        results = WorldDatabase.Query(npcQuery);
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                npcItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+        }
+        else
+        {
+            if (debug_Out) TC_LOG_ERROR("misc", "AuctionHouseBot: \"%s\" failed", npcQuery);
+        }
+
+        char lootQuery[] = "SELECT item FROM creature_loot_template UNION "
+            "SELECT item FROM reference_loot_template UNION "
+            "SELECT item FROM disenchant_loot_template UNION "
+            "SELECT item FROM fishing_loot_template UNION "
+            "SELECT item FROM gameobject_loot_template UNION "
+            "SELECT item FROM item_loot_template UNION "
+            "SELECT item FROM milling_loot_template UNION "
+            "SELECT item FROM pickpocketing_loot_template UNION "
+            "SELECT item FROM prospecting_loot_template UNION "
+            "SELECT item FROM skinning_loot_template";
+
+        results = WorldDatabase.Query(lootQuery);
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                lootItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+        }
+        else
+        {
+            if (debug_Out) TC_LOG_ERROR("misc", "AuctionHouseBot: \"%s\" failed", lootQuery);
+        }
+
+        ItemTemplateContainer const* its = sObjectMgr->GetItemTemplateStore();
+        for (ItemTemplateContainer::const_iterator itr = its->begin(); itr != its->end(); ++itr)
+        {
+
+
+
+            switch (itr->second.Bonding)
+            {
+            case NO_BIND:
+                if (!No_Bind)
+                    continue;
+                break;
+            case BIND_WHEN_PICKED_UP:
+                if (!Bind_When_Picked_Up)
+                    continue;
+                break;
+            case BIND_WHEN_EQUIPED:
+                if (!Bind_When_Equipped)
+                    continue;
+                break;
+            case BIND_WHEN_USE:
+                if (!Bind_When_Use)
+                    continue;
+                break;
+            case BIND_QUEST_ITEM:
+                if (!Bind_Quest_Item)
+                    continue;
+                break;
+            default:
+                continue;
+                break;
+            }
+
+            switch (SellMethod)
+            {
+            case 0:
+                if (itr->second.SellPrice == 0)
+                    continue;
+                break;
+            case 1:
+                if (itr->second.BuyPrice == 0)
+                    continue;
+                break;
+            }
+
+            if (itr->second.Quality > 6)
+                continue;
+
+            if ((Vendor_Items == 0) && !(itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorItem = true;
+                }
+
+                if (isVendorItem)
+                    continue;
+            }
+
+            if ((Vendor_TGs == 0) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorTG = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorTG); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorTG = true;
+                }
+
+                if (isVendorTG)
+                    continue;
+            }
+
+            if ((Loot_Items == 0) && !(itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootItem = true;
+                }
+
+                if (isLootItem)
+                    continue;
+            }
+
+            if ((Loot_TGs == 0) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isLootTG = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootTG); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootTG = true;
+                }
+
+                if (isLootTG)
+                    continue;
+            }
+
+            if ((Other_Items == 0) && !(itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorItem = false;
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorItem = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootItem = true;
+                }
+                if ((!isLootItem) && (!isVendorItem))
+                    continue;
+            }
+
+            if ((Other_TGs == 0) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorTG = false;
+                bool isLootTG = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorTG); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorTG = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootTG); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootTG = true;
+                }
+                if ((!isLootTG) && (!isVendorTG))
+                    continue;
+            }
+
+            // Disable items by Id
+            if (DisableItemStore.find(itr->second.ItemId) != DisableItemStore.end())
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (PTR/Beta/Unused Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable permanent enchants items
+            if ((DisablePermEnchant) && (itr->second.Class == ITEM_CLASS_PERMANENT))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Permanent Enchant Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable conjured items
+            if ((DisableConjured) && (itr->second.IsConjuredConsumable()))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Conjured Consumable)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable gems
+            if ((DisableGems) && (itr->second.Class == ITEM_CLASS_GEM))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Gem)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable money
+            if ((DisableMoney) && (itr->second.Class == ITEM_CLASS_MONEY))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Money)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable moneyloot
+            if ((DisableMoneyLoot) && (itr->second.MinMoneyLoot > 0))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (MoneyLoot)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable lootable items
+            if ((DisableLootable) && (itr->second.Flags & 4))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Lootable Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable Keys
+            if ((DisableKeys) && (itr->second.Class == ITEM_CLASS_KEY))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Quest Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items with duration
+            if ((DisableDuration) && (itr->second.Duration > 0))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Has a Duration)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items which are BOP or Quest Items and have a required level lower than the item level
+            if ((DisableBOP_Or_Quest_NoReqLevel) && ((itr->second.Bonding == BIND_WHEN_PICKED_UP || itr->second.Bonding == BIND_QUEST_ITEM) && (itr->second.RequiredLevel < itr->second.ItemLevel)))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (BOP or BQI and Required Level is less than Item Level)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Warrior
+            if ((DisableWarriorItems) && (itr->second.AllowableClass == 1))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Warrior Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Paladin
+            if ((DisablePaladinItems) && (itr->second.AllowableClass == 2))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Paladin Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Hunter
+            if ((DisableHunterItems) && (itr->second.AllowableClass == 4))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Hunter Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Rogue
+            if ((DisableRogueItems) && (itr->second.AllowableClass == 8))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Rogue Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Priest
+            if ((DisablePriestItems) && (itr->second.AllowableClass == 16))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Priest Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for DK
+            if ((DisableDKItems) && (itr->second.AllowableClass == 32))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (DK Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Shaman
+            if ((DisableShamanItems) && (itr->second.AllowableClass == 64))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Shaman Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Mage
+            if ((DisableMageItems) && (itr->second.AllowableClass == 128))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Mage Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Warlock
+            if ((DisableWarlockItems) && (itr->second.AllowableClass == 256))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Warlock Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Unused Class
+            if ((DisableUnusedClassItems) && (itr->second.AllowableClass == 512))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Unused Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Druid
+            if ((DisableDruidItems) && (itr->second.AllowableClass == 1024))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Druid Item)", itr->second.ItemId);
+                continue;
+            }
+
+             // Disable Items below level X
+            if ((DisableItemsBelowLevel) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel < DisableItemsBelowLevel))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items above level X
+            if ((DisableItemsAboveLevel) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel > DisableItemsAboveLevel))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+           // Disable Trade Goods below level X
+            if ((DisableTGsBelowLevel) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel < DisableTGsBelowLevel))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Trade Good %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+           // Disable Trade Goods above level X
+            if ((DisableTGsAboveLevel) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel > DisableTGsAboveLevel))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Trade Good %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items below GUID X
+            if ((DisableItemsBelowGUID) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId < DisableItemsBelowGUID))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items above GUID X
+            if ((DisableItemsAboveGUID) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId > DisableItemsAboveGUID))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Trade Goods below GUID X
+            if ((DisableTGsBelowGUID) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId < DisableTGsBelowGUID))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Trade Goods above GUID X
+            if ((DisableTGsAboveGUID) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId > DisableTGsAboveGUID))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items for level lower than X
+            if ((DisableItemsBelowReqLevel) && (itr->second.RequiredLevel < DisableItemsBelowReqLevel))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Items for level higher than X
+            if ((DisableItemsAboveReqLevel) && (itr->second.RequiredLevel > DisableItemsAboveReqLevel))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Trade Goods for level lower than X
+            if ((DisableTGsBelowReqLevel) && (itr->second.RequiredLevel < DisableTGsBelowReqLevel))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Trade Good %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Trade Goods for level higher than X
+            if ((DisableTGsAboveReqLevel) && (itr->second.RequiredLevel > DisableTGsAboveReqLevel))
+            {
+                if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Trade Good %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Items that require skill lower than X
+            // if ((DisableItemsBelowReqSkillRank) && (itr->second.RequiredSkillRank < DisableItemsBelowReqSkillRank))
+            // {
+            //    if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+            //    continue;
+            // }
+
+            // Disable Items that require skill higher than X
+            // if ((DisableItemsAboveReqSkillRank) && (itr->second.RequiredSkillRank > DisableItemsAboveReqSkillRank))
+            // {
+            //    if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+            //    continue;
+            // }
+
+            // Disable Trade Goods that require skill lower than X
+            // if ((DisableTGsBelowReqSkillRank) && (itr->second.RequiredSkillRank < DisableTGsBelowReqSkillRank))
+            // {
+            //    if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+            //    continue;
+            // }
+
+            // Disable Trade Goods that require skill higher than X
+            // if ((DisableTGsAboveReqSkillRank) && (itr->second.?RequiredSkillRank > DisableTGsAboveReqSkillRank))
+            // {
+            //    if (debug_Out_Filters) TC_LOG_ERROR("misc", "AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+            //    continue;
+            // }
+
+            switch (itr->second.Quality)
+            {
+            case AHB_GREY:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    greyTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    greyItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_WHITE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    whiteTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    whiteItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_GREEN:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    greenTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    greenItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_BLUE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    blueTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    blueItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_PURPLE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    purpleTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    purpleItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_ORANGE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    orangeTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    orangeItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_YELLOW:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    yellowTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    yellowItemsBin.push_back(itr->second.ItemId);
+                break;
+            }
+        }
+
+        if ((greyTradeGoodsBin.size() == 0) &&
+            (whiteTradeGoodsBin.size() == 0) &&
+            (greenTradeGoodsBin.size() == 0) &&
+            (blueTradeGoodsBin.size() == 0) &&
+            (purpleTradeGoodsBin.size() == 0) &&
+            (orangeTradeGoodsBin.size() == 0) &&
+            (yellowTradeGoodsBin.size() == 0) &&
+            (greyItemsBin.size() == 0) &&
+            (whiteItemsBin.size() == 0) &&
+            (greenItemsBin.size() == 0) &&
+            (blueItemsBin.size() == 0) &&
+            (purpleItemsBin.size() == 0) &&
+            (orangeItemsBin.size() == 0) &&
+            (yellowItemsBin.size() == 0))
+        {
+            TC_LOG_ERROR("server.loading", "AuctionHouseBot: No items");
+            AHBSeller = 0;
+        }
+
+        TC_LOG_INFO("server.loading", "AuctionHouseBot:");
+        TC_LOG_INFO("server.loading", "loaded %u grey trade goods", uint32(greyTradeGoodsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u white trade goods", uint32(whiteTradeGoodsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u green trade goods", uint32(greenTradeGoodsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u blue trade goods", uint32(blueTradeGoodsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u purple trade goods", uint32(purpleTradeGoodsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u orange trade goods", uint32(orangeTradeGoodsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u yellow trade goods", uint32(yellowTradeGoodsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u grey items", uint32(greyItemsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u white items", uint32(whiteItemsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u green items", uint32(greenItemsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u blue items", uint32(blueItemsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u purple items", uint32(purpleItemsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u orange items", uint32(orangeItemsBin.size()));
+        TC_LOG_INFO("server.loading", "loaded %u yellow items", uint32(yellowItemsBin.size()));
+    }
+    TC_LOG_INFO("server.loading", "AuctionHouseBot and AuctionHouseBuyer have been loaded.");
+}
+
+void AuctionHouseBot::InitializeConfiguration()
+{
+    debug_Out = sConfigMgr->GetBoolDefault("AuctionHouseBot.DEBUG", false);
+    debug_Out_Filters = sConfigMgr->GetBoolDefault("AuctionHouseBot.DEBUG_FILTERS", false);
+
+    AHBSeller = sConfigMgr->GetBoolDefault("AuctionHouseBot.EnableSeller", false);
+    AHBBuyer = sConfigMgr->GetBoolDefault("AuctionHouseBot.EnableBuyer", false);
+    SellMethod = sConfigMgr->GetBoolDefault("AuctionHouseBot.UseBuyPriceForSeller", false);
+    BuyMethod = sConfigMgr->GetBoolDefault("AuctionHouseBot.UseBuyPriceForBuyer", false);
+
+    AHBplayerAccount = sConfigMgr->GetIntDefault("AuctionHouseBot.Account", 0);
+    AHBplayerGUID = sConfigMgr->GetIntDefault("AuctionHouseBot.GUID", 0);
+    ItemsPerCycle = sConfigMgr->GetIntDefault("AuctionHouseBot.ItemsPerCycle", 200);
+
+    //Begin Filters
+
+    Vendor_Items = sConfigMgr->GetBoolDefault("AuctionHouseBot.VendorItems", false);
+    Loot_Items = sConfigMgr->GetBoolDefault("AuctionHouseBot.LootItems", true);
+    Other_Items = sConfigMgr->GetBoolDefault("AuctionHouseBot.OtherItems", false);
+    Vendor_TGs = sConfigMgr->GetBoolDefault("AuctionHouseBot.VendorTradeGoods", false);
+    Loot_TGs = sConfigMgr->GetBoolDefault("AuctionHouseBot.LootTradeGoods", true);
+    Other_TGs = sConfigMgr->GetBoolDefault("AuctionHouseBot.OtherTradeGoods", false);
+
+    No_Bind = sConfigMgr->GetBoolDefault("AuctionHouseBot.No_Bind", true);
+    Bind_When_Picked_Up = sConfigMgr->GetBoolDefault("AuctionHouseBot.Bind_When_Picked_Up", false);
+    Bind_When_Equipped = sConfigMgr->GetBoolDefault("AuctionHouseBot.Bind_When_Equipped", true);
+    Bind_When_Use = sConfigMgr->GetBoolDefault("AuctionHouseBot.Bind_When_Use", true);
+    Bind_Quest_Item = sConfigMgr->GetBoolDefault("AuctionHouseBot.Bind_Quest_Item", false);
+
+    DisablePermEnchant = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisablePermEnchant", false);
+    DisableConjured = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableConjured", false);
+    DisableGems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableGems", false);
+    DisableMoney = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableMoney", false);
+    DisableMoneyLoot = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableMoneyLoot", false);
+    DisableLootable = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableLootable", false);
+    DisableKeys = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableKeys", false);
+    DisableDuration = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableDuration", false);
+    DisableBOP_Or_Quest_NoReqLevel = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel", false);
+
+    DisableWarriorItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableWarriorItems", false);
+    DisablePaladinItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisablePaladinItems", false);
+    DisableHunterItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableHunterItems", false);
+    DisableRogueItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableRogueItems", false);
+    DisablePriestItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisablePriestItems", false);
+    DisableDKItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableDKItems", false);
+    DisableShamanItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableShamanItems", false);
+    DisableMageItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableMageItems", false);
+    DisableWarlockItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableWarlockItems", false);
+    DisableUnusedClassItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableUnusedClassItems", false);
+    DisableDruidItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableDruidItems", false);
+
+    DisableItemsBelowLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsBelowLevel", 0);
+    DisableItemsAboveLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsAboveLevel", 0);
+    DisableTGsBelowLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsBelowLevel", 0);
+    DisableTGsAboveLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsAboveLevel", 0);
+    DisableItemsBelowGUID = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsBelowGUID", 0);
+    DisableItemsAboveGUID = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsAboveGUID", 0);
+    DisableTGsBelowGUID = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsBelowGUID", 0);
+    DisableTGsAboveGUID = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsAboveGUID", 0);
+    DisableItemsBelowReqLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsBelowReqLevel", 0);
+    DisableItemsAboveReqLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsAboveReqLevel", 0);
+    DisableTGsBelowReqLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsBelowReqLevel", 0);
+    DisableTGsAboveReqLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsAboveReqLevel", 0);
+    DisableItemsBelowReqSkillRank = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsBelowReqSkillRank", 0);
+    DisableItemsAboveReqSkillRank = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsAboveReqSkillRank", 0);
+    DisableTGsBelowReqSkillRank = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsBelowReqSkillRank", 0);
+    DisableTGsAboveReqSkillRank = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsAboveReqSkillRank", 0);
+}
+
+void AuctionHouseBot::IncrementItemCounts(AuctionEntry* ah)
+{
+    // from auctionhousehandler.cpp, creates auction pointer & player pointer
+
+    // get exact item information
+    Item *pItem =  sAuctionMgr->GetAItem(ah->itemGUIDLow);
+    if (!pItem)
+    {
+        if (debug_Out) TC_LOG_ERROR("misc", "AHBot: Item %u doesn't exist, perhaps bought already?", ah->itemGUIDLow);
+        return;
+    }
+
+    // get item prototype
+    ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(ah->itemEntry);
+
+    AHBConfig *config;
+
+    FactionTemplateEntry const* u_entry = sFactionTemplateStore.LookupEntry(ah->GetHouseFaction());
+    if (!u_entry)
+    {
+        if (debug_Out) TC_LOG_ERROR("misc", "AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_ALLIANCE)
+    {
+        if (debug_Out) TC_LOG_ERROR("misc", "AHBot: %u returned as House Faction. Alliance", ah->GetHouseFaction());
+        config = &AllianceConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_HORDE)
+    {
+        if (debug_Out) TC_LOG_ERROR("misc", "AHBot: %u returned as House Faction. Horde", ah->GetHouseFaction());
+        config = &HordeConfig;
+    }
+    else
+    {
+        if (debug_Out) TC_LOG_ERROR("misc", "AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+
+    config->IncItemCounts(prototype->Class, prototype->Quality);
+}
+
+void AuctionHouseBot::DecrementItemCounts(AuctionEntry* ah, uint32 itemEntry)
+{
+    // get item prototype
+    ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(itemEntry);
+
+    AHBConfig *config;
+
+    FactionTemplateEntry const* u_entry = sFactionTemplateStore.LookupEntry(ah->GetHouseFaction());
+    if (!u_entry)
+    {
+        if (debug_Out) TC_LOG_ERROR("misc", "AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_ALLIANCE)
+    {
+        if (debug_Out) TC_LOG_ERROR("misc", "AHBot: %u returned as House Faction. Alliance", ah->GetHouseFaction());
+        config = &AllianceConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_HORDE)
+    {
+        if (debug_Out) TC_LOG_ERROR("misc", "AHBot: %u returned as House Faction. Horde", ah->GetHouseFaction());
+        config = &HordeConfig;
+    }
+    else
+    {
+        if (debug_Out) TC_LOG_ERROR("misc", "AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+
+    config->DecItemCounts(prototype->Class, prototype->Quality);
+}
+
+void AuctionHouseBot::Commands(uint32 command, uint32 ahMapID, uint32 col, char* args)
+{
+    AHBConfig *config = NULL;
+    switch (ahMapID)
+    {
+    case 2:
+        config = &AllianceConfig;
+        break;
+    case 6:
+        config = &HordeConfig;
+        break;
+    case 7:
+        config = &NeutralConfig;
+        break;
+    }
+    std::string color;
+    switch (col)
+    {
+    case AHB_GREY:
+        color = "grey";
+        break;
+    case AHB_WHITE:
+        color = "white";
+        break;
+    case AHB_GREEN:
+        color = "green";
+        break;
+    case AHB_BLUE:
+        color = "blue";
+        break;
+    case AHB_PURPLE:
+        color = "purple";
+        break;
+    case AHB_ORANGE:
+        color = "orange";
+        break;
+    case AHB_YELLOW:
+        color = "yellow";
+        break;
+    default:
+        break;
+    }
+    switch (command)
+    {
+    case 0:     //ahexpire
+        {
+            AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+
+            AuctionHouseObject::AuctionEntryMap::iterator itr;
+            itr = auctionHouse->GetAuctionsBegin();
+
+            while (itr != auctionHouse->GetAuctionsEnd())
+            {
+                if (itr->second->owner == AHBplayerGUID)
+                {
+                    itr->second->expire_time = sWorld->GetGameTime();
+                    uint32 id = itr->second->Id;
+                    uint32 expire_time = itr->second->expire_time;
+                    CharacterDatabase.PExecute("UPDATE auctionhouse SET time = '%u' WHERE id = '%u'", expire_time, id);
+                }
+                ++itr;
+            }
+        }
+        break;
+    case 1:     //min items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minitems = '%u' WHERE auctionhouse = '%u'", minItems, ahMapID);
+            config->SetMinItems(minItems);
+        }
+        break;
+    case 2:     //max items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxitems = '%u' WHERE auctionhouse = '%u'", maxItems, ahMapID);
+            config->SetMaxItems(maxItems);
+            config->CalculatePercents();
+        }
+        break;
+    case 3:     //min time Deprecated (Place holder for future commands)
+        break;
+    case 4:     //max time Deprecated (Place holder for future commands)
+        break;
+    case 5:     //percentages
+        {
+            char * param1 = strtok(args, " ");
+            char * param2 = strtok(NULL, " ");
+            char * param3 = strtok(NULL, " ");
+            char * param4 = strtok(NULL, " ");
+            char * param5 = strtok(NULL, " ");
+            char * param6 = strtok(NULL, " ");
+            char * param7 = strtok(NULL, " ");
+            char * param8 = strtok(NULL, " ");
+            char * param9 = strtok(NULL, " ");
+            char * param10 = strtok(NULL, " ");
+            char * param11 = strtok(NULL, " ");
+            char * param12 = strtok(NULL, " ");
+            char * param13 = strtok(NULL, " ");
+            char * param14 = strtok(NULL, " ");
+            uint32 greytg = (uint32) strtoul(param1, NULL, 0);
+            uint32 whitetg = (uint32) strtoul(param2, NULL, 0);
+            uint32 greentg = (uint32) strtoul(param3, NULL, 0);
+            uint32 bluetg = (uint32) strtoul(param4, NULL, 0);
+            uint32 purpletg = (uint32) strtoul(param5, NULL, 0);
+            uint32 orangetg = (uint32) strtoul(param6, NULL, 0);
+            uint32 yellowtg = (uint32) strtoul(param7, NULL, 0);
+            uint32 greyi = (uint32) strtoul(param8, NULL, 0);
+            uint32 whitei = (uint32) strtoul(param9, NULL, 0);
+            uint32 greeni = (uint32) strtoul(param10, NULL, 0);
+            uint32 bluei = (uint32) strtoul(param11, NULL, 0);
+            uint32 purplei = (uint32) strtoul(param12, NULL, 0);
+            uint32 orangei = (uint32) strtoul(param13, NULL, 0);
+            uint32 yellowi = (uint32) strtoul(param14, NULL, 0);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            trans->PAppend("UPDATE auctionhousebot SET percentgreytradegoods = '%u' WHERE auctionhouse = '%u'", greytg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentwhitetradegoods = '%u' WHERE auctionhouse = '%u'", whitetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreentradegoods = '%u' WHERE auctionhouse = '%u'", greentg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentbluetradegoods = '%u' WHERE auctionhouse = '%u'", bluetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentpurpletradegoods = '%u' WHERE auctionhouse = '%u'", purpletg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentorangetradegoods = '%u' WHERE auctionhouse = '%u'", orangetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentyellowtradegoods = '%u' WHERE auctionhouse = '%u'", yellowtg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreyitems = '%u' WHERE auctionhouse = '%u'", greyi, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentwhiteitems = '%u' WHERE auctionhouse = '%u'", whitei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreenitems = '%u' WHERE auctionhouse = '%u'", greeni, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentblueitems = '%u' WHERE auctionhouse = '%u'", bluei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentpurpleitems = '%u' WHERE auctionhouse = '%u'", purplei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentorangeitems = '%u' WHERE auctionhouse = '%u'", orangei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentyellowitems = '%u' WHERE auctionhouse = '%u'", yellowi, ahMapID);
+            CharacterDatabase.CommitTransaction( trans);
+            config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        }
+        break;
+    case 6:     //min prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minPrice, ahMapID);
+            config->SetMinPrice(col, minPrice);
+        }
+        break;
+    case 7:     //max prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxPrice, ahMapID);
+            config->SetMaxPrice(col, maxPrice);
+        }
+        break;
+    case 8:     //min bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minBidPrice, ahMapID);
+            config->SetMinBidPrice(col, minBidPrice);
+        }
+        break;
+    case 9:     //max bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxBidPrice, ahMapID);
+            config->SetMaxBidPrice(col, maxBidPrice);
+        }
+        break;
+    case 10:        //max stacks
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxStack = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxstack%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxStack, ahMapID);
+            config->SetMaxStack(col, maxStack);
+        }
+        break;
+    case 11:        //buyer bid prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 buyerPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), buyerPrice, ahMapID);
+            config->SetBuyerPrice(col, buyerPrice);
+        }
+        break;
+    case 12:        //buyer bidding interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbiddinginterval = '%u' WHERE auctionhouse = '%u'", bidInterval, ahMapID);
+            config->SetBiddingInterval(bidInterval);
+        }
+        break;
+    case 13:        //buyer bids per interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidsPerInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbidsperinterval = '%u' WHERE auctionhouse = '%u'", bidsPerInterval, ahMapID);
+            config->SetBidsPerInterval(bidsPerInterval);
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+void AuctionHouseBot::LoadValues(AHBConfig *config)
+{
+    if (debug_Out)
+        TC_LOG_ERROR("misc", "Start Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u", config->GetAHID())->Fetch()->GetCString());
+    if (AHBSeller)
+    {
+        //load min and max items
+        config->SetMinItems(CharacterDatabase.PQuery("SELECT minitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxItems(CharacterDatabase.PQuery("SELECT maxitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load percentages
+        uint32 greytg = CharacterDatabase.PQuery("SELECT percentgreytradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitetg = CharacterDatabase.PQuery("SELECT percentwhitetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greentg = CharacterDatabase.PQuery("SELECT percentgreentradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluetg = CharacterDatabase.PQuery("SELECT percentbluetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purpletg = CharacterDatabase.PQuery("SELECT percentpurpletradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangetg = CharacterDatabase.PQuery("SELECT percentorangetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowtg = CharacterDatabase.PQuery("SELECT percentyellowtradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greyi = CharacterDatabase.PQuery("SELECT percentgreyitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitei = CharacterDatabase.PQuery("SELECT percentwhiteitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greeni = CharacterDatabase.PQuery("SELECT percentgreenitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluei = CharacterDatabase.PQuery("SELECT percentblueitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purplei = CharacterDatabase.PQuery("SELECT percentpurpleitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangei = CharacterDatabase.PQuery("SELECT percentorangeitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowi = CharacterDatabase.PQuery("SELECT percentyellowitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        //load min and max prices
+        config->SetMinPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load min and max bid prices
+        config->SetMinBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load max stacks
+        config->SetMaxStack(AHB_GREY, CharacterDatabase.PQuery("SELECT maxstackgrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxstackwhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxstackgreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxstackblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxstackpurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxstackorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxstackyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            TC_LOG_ERROR("misc", "minItems                = %u", config->GetMinItems());
+            TC_LOG_ERROR("misc", "maxItems                = %u", config->GetMaxItems());
+            TC_LOG_ERROR("misc", "percentGreyTradeGoods   = %u", config->GetPercentages(AHB_GREY_TG));
+            TC_LOG_ERROR("misc", "percentWhiteTradeGoods  = %u", config->GetPercentages(AHB_WHITE_TG));
+            TC_LOG_ERROR("misc", "percentGreenTradeGoods  = %u", config->GetPercentages(AHB_GREEN_TG));
+            TC_LOG_ERROR("misc", "percentBlueTradeGoods   = %u", config->GetPercentages(AHB_BLUE_TG));
+            TC_LOG_ERROR("misc", "percentPurpleTradeGoods = %u", config->GetPercentages(AHB_PURPLE_TG));
+            TC_LOG_ERROR("misc", "percentOrangeTradeGoods = %u", config->GetPercentages(AHB_ORANGE_TG));
+            TC_LOG_ERROR("misc", "percentYellowTradeGoods = %u", config->GetPercentages(AHB_YELLOW_TG));
+            TC_LOG_ERROR("misc", "percentGreyItems        = %u", config->GetPercentages(AHB_GREY_I));
+            TC_LOG_ERROR("misc", "percentWhiteItems       = %u", config->GetPercentages(AHB_WHITE_I));
+            TC_LOG_ERROR("misc", "percentGreenItems       = %u", config->GetPercentages(AHB_GREEN_I));
+            TC_LOG_ERROR("misc", "percentBlueItems        = %u", config->GetPercentages(AHB_BLUE_I));
+            TC_LOG_ERROR("misc", "percentPurpleItems      = %u", config->GetPercentages(AHB_PURPLE_I));
+            TC_LOG_ERROR("misc", "percentOrangeItems      = %u", config->GetPercentages(AHB_ORANGE_I));
+            TC_LOG_ERROR("misc", "percentYellowItems      = %u", config->GetPercentages(AHB_YELLOW_I));
+            TC_LOG_ERROR("misc", "minPriceGrey            = %u", config->GetMinPrice(AHB_GREY));
+            TC_LOG_ERROR("misc", "maxPriceGrey            = %u", config->GetMaxPrice(AHB_GREY));
+            TC_LOG_ERROR("misc", "minPriceWhite           = %u", config->GetMinPrice(AHB_WHITE));
+            TC_LOG_ERROR("misc", "maxPriceWhite           = %u", config->GetMaxPrice(AHB_WHITE));
+            TC_LOG_ERROR("misc", "minPriceGreen           = %u", config->GetMinPrice(AHB_GREEN));
+            TC_LOG_ERROR("misc", "maxPriceGreen           = %u", config->GetMaxPrice(AHB_GREEN));
+            TC_LOG_ERROR("misc", "minPriceBlue            = %u", config->GetMinPrice(AHB_BLUE));
+            TC_LOG_ERROR("misc", "maxPriceBlue            = %u", config->GetMaxPrice(AHB_BLUE));
+            TC_LOG_ERROR("misc", "minPricePurple          = %u", config->GetMinPrice(AHB_PURPLE));
+            TC_LOG_ERROR("misc", "maxPricePurple          = %u", config->GetMaxPrice(AHB_PURPLE));
+            TC_LOG_ERROR("misc", "minPriceOrange          = %u", config->GetMinPrice(AHB_ORANGE));
+            TC_LOG_ERROR("misc", "maxPriceOrange          = %u", config->GetMaxPrice(AHB_ORANGE));
+            TC_LOG_ERROR("misc", "minPriceYellow          = %u", config->GetMinPrice(AHB_YELLOW));
+            TC_LOG_ERROR("misc", "maxPriceYellow          = %u", config->GetMaxPrice(AHB_YELLOW));
+            TC_LOG_ERROR("misc", "minBidPriceGrey         = %u", config->GetMinBidPrice(AHB_GREY));
+            TC_LOG_ERROR("misc", "maxBidPriceGrey         = %u", config->GetMaxBidPrice(AHB_GREY));
+            TC_LOG_ERROR("misc", "minBidPriceWhite        = %u", config->GetMinBidPrice(AHB_WHITE));
+            TC_LOG_ERROR("misc", "maxBidPriceWhite        = %u", config->GetMaxBidPrice(AHB_WHITE));
+            TC_LOG_ERROR("misc", "minBidPriceGreen        = %u", config->GetMinBidPrice(AHB_GREEN));
+            TC_LOG_ERROR("misc", "maxBidPriceGreen        = %u", config->GetMaxBidPrice(AHB_GREEN));
+            TC_LOG_ERROR("misc", "minBidPriceBlue         = %u", config->GetMinBidPrice(AHB_BLUE));
+            TC_LOG_ERROR("misc", "maxBidPriceBlue         = %u", config->GetMinBidPrice(AHB_BLUE));
+            TC_LOG_ERROR("misc", "minBidPricePurple       = %u", config->GetMinBidPrice(AHB_PURPLE));
+            TC_LOG_ERROR("misc", "maxBidPricePurple       = %u", config->GetMaxBidPrice(AHB_PURPLE));
+            TC_LOG_ERROR("misc", "minBidPriceOrange       = %u", config->GetMinBidPrice(AHB_ORANGE));
+            TC_LOG_ERROR("misc", "maxBidPriceOrange       = %u", config->GetMaxBidPrice(AHB_ORANGE));
+            TC_LOG_ERROR("misc", "minBidPriceYellow       = %u", config->GetMinBidPrice(AHB_YELLOW));
+            TC_LOG_ERROR("misc", "maxBidPriceYellow       = %u", config->GetMaxBidPrice(AHB_YELLOW));
+            TC_LOG_ERROR("misc", "maxStackGrey            = %u", config->GetMaxStack(AHB_GREY));
+            TC_LOG_ERROR("misc", "maxStackWhite           = %u", config->GetMaxStack(AHB_WHITE));
+            TC_LOG_ERROR("misc", "maxStackGreen           = %u", config->GetMaxStack(AHB_GREEN));
+            TC_LOG_ERROR("misc", "maxStackBlue            = %u", config->GetMaxStack(AHB_BLUE));
+            TC_LOG_ERROR("misc", "maxStackPurple          = %u", config->GetMaxStack(AHB_PURPLE));
+            TC_LOG_ERROR("misc", "maxStackOrange          = %u", config->GetMaxStack(AHB_ORANGE));
+            TC_LOG_ERROR("misc", "maxStackYellow          = %u", config->GetMaxStack(AHB_YELLOW));
+        }
+        //AuctionHouseEntry const* ahEntry =  sAuctionMgr->GetAuctionHouseEntry(config->GetAHFID());
+        AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+
+        config->ResetItemCounts();
+        uint32 auctions = auctionHouse->Getcount();
+
+        if (auctions)
+        {
+            for (AuctionHouseObject::AuctionEntryMap::const_iterator itr = auctionHouse->GetAuctionsBegin(); itr != auctionHouse->GetAuctionsEnd(); ++itr)
+            {
+                AuctionEntry *Aentry = itr->second;
+                Item *item =  sAuctionMgr->GetAItem(Aentry->itemGUIDLow);
+                if (item)
+                {
+                    ItemTemplate const *prototype = item->GetTemplate();
+                    if (prototype)
+                    {
+                        switch (prototype->Quality)
+                        {
+                        case 0:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_GREY_TG);
+                            else
+                                config->IncItemCounts(AHB_GREY_I);
+                            break;
+                        case 1:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_WHITE_TG);
+                            else
+                                config->IncItemCounts(AHB_WHITE_I);
+                            break;
+                        case 2:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_GREEN_TG);
+                            else
+                                config->IncItemCounts(AHB_GREEN_I);
+                            break;
+                        case 3:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_BLUE_TG);
+                            else
+                                config->IncItemCounts(AHB_BLUE_I);
+                            break;
+                        case 4:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_PURPLE_TG);
+                            else
+                                config->IncItemCounts(AHB_PURPLE_I);
+                            break;
+                        case 5:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_ORANGE_TG);
+                            else
+                                config->IncItemCounts(AHB_ORANGE_I);
+                            break;
+                        case 6:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_YELLOW_TG);
+                            else
+                                config->IncItemCounts(AHB_YELLOW_I);
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        if (debug_Out)
+        {
+            TC_LOG_ERROR("misc", "Current Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetCString());
+            TC_LOG_ERROR("misc", "Grey Trade Goods\t%u\tGrey Items\t%u", config->GetItemCounts(AHB_GREY_TG), config->GetItemCounts(AHB_GREY_I));
+            TC_LOG_ERROR("misc", "White Trade Goods\t%u\tWhite Items\t%u", config->GetItemCounts(AHB_WHITE_TG), config->GetItemCounts(AHB_WHITE_I));
+            TC_LOG_ERROR("misc", "Green Trade Goods\t%u\tGreen Items\t%u", config->GetItemCounts(AHB_GREEN_TG), config->GetItemCounts(AHB_GREEN_I));
+            TC_LOG_ERROR("misc", "Blue Trade Goods\t%u\tBlue Items\t%u", config->GetItemCounts(AHB_BLUE_TG), config->GetItemCounts(AHB_BLUE_I));
+            TC_LOG_ERROR("misc", "Purple Trade Goods\t%u\tPurple Items\t%u", config->GetItemCounts(AHB_PURPLE_TG), config->GetItemCounts(AHB_PURPLE_I));
+            TC_LOG_ERROR("misc", "Orange Trade Goods\t%u\tOrange Items\t%u", config->GetItemCounts(AHB_ORANGE_TG), config->GetItemCounts(AHB_ORANGE_I));
+            TC_LOG_ERROR("misc", "Yellow Trade Goods\t%u\tYellow Items\t%u", config->GetItemCounts(AHB_YELLOW_TG), config->GetItemCounts(AHB_YELLOW_I));
+        }
+    }
+    if (AHBBuyer)
+    {
+        //load buyer bid prices
+        config->SetBuyerPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT buyerpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT buyerpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT buyerpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT buyerpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT buyerpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT buyerpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT buyerpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load bidding interval
+        config->SetBiddingInterval(CharacterDatabase.PQuery("SELECT buyerbiddinginterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load bids per interval
+        config->SetBidsPerInterval(CharacterDatabase.PQuery("SELECT buyerbidsperinterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            TC_LOG_ERROR("misc", "buyerPriceGrey          = %u", config->GetBuyerPrice(AHB_GREY));
+            TC_LOG_ERROR("misc", "buyerPriceWhite         = %u", config->GetBuyerPrice(AHB_WHITE));
+            TC_LOG_ERROR("misc", "buyerPriceGreen         = %u", config->GetBuyerPrice(AHB_GREEN));
+            TC_LOG_ERROR("misc", "buyerPriceBlue          = %u", config->GetBuyerPrice(AHB_BLUE));
+            TC_LOG_ERROR("misc", "buyerPricePurple        = %u", config->GetBuyerPrice(AHB_PURPLE));
+            TC_LOG_ERROR("misc", "buyerPriceOrange        = %u", config->GetBuyerPrice(AHB_ORANGE));
+            TC_LOG_ERROR("misc", "buyerPriceYellow        = %u", config->GetBuyerPrice(AHB_YELLOW));
+            TC_LOG_ERROR("misc", "buyerBiddingInterval    = %u", config->GetBiddingInterval());
+            TC_LOG_ERROR("misc", "buyerBidsPerInterval    = %u", config->GetBidsPerInterval());
+        }
+    }
+    if (debug_Out) TC_LOG_ERROR("misc", "End Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetCString());
+}
diff --git a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
new file mode 100644
index 0000000..1a207e6
--- /dev/null
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
@@ -0,0 +1,1249 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef AUCTION_HOUSE_BOT_H
+#define AUCTION_HOUSE_BOT_H
+
+#include "World.h"
+#include "Config.h"
+#include "ItemPrototype.h"
+
+#define AHB_GREY        0
+#define AHB_WHITE       1
+#define AHB_GREEN       2
+#define AHB_BLUE        3
+#define AHB_PURPLE      4
+#define AHB_ORANGE      5
+#define AHB_YELLOW      6
+#define AHB_MAX_QUALITY 6
+#define AHB_GREY_TG     0
+#define AHB_WHITE_TG    1
+#define AHB_GREEN_TG    2
+#define AHB_BLUE_TG     3
+#define AHB_PURPLE_TG   4
+#define AHB_ORANGE_TG   5
+#define AHB_YELLOW_TG   6
+#define AHB_GREY_I      7
+#define AHB_WHITE_I     8
+#define AHB_GREEN_I     9
+#define AHB_BLUE_I      10
+#define AHB_PURPLE_I    11
+#define AHB_ORANGE_I    12
+#define AHB_YELLOW_I    13
+
+class AHBConfig
+{
+private:
+    uint32 AHID;
+    uint32 AHFID;
+    uint32 minItems;
+    uint32 maxItems;
+    uint32 percentGreyTradeGoods;
+    uint32 percentWhiteTradeGoods;
+    uint32 percentGreenTradeGoods;
+    uint32 percentBlueTradeGoods;
+    uint32 percentPurpleTradeGoods;
+    uint32 percentOrangeTradeGoods;
+    uint32 percentYellowTradeGoods;
+    uint32 percentGreyItems;
+    uint32 percentWhiteItems;
+    uint32 percentGreenItems;
+    uint32 percentBlueItems;
+    uint32 percentPurpleItems;
+    uint32 percentOrangeItems;
+    uint32 percentYellowItems;
+    uint32 minPriceGrey;
+    uint32 maxPriceGrey;
+    uint32 minBidPriceGrey;
+    uint32 maxBidPriceGrey;
+    uint32 maxStackGrey;
+    uint32 minPriceWhite;
+    uint32 maxPriceWhite;
+    uint32 minBidPriceWhite;
+    uint32 maxBidPriceWhite;
+    uint32 maxStackWhite;
+    uint32 minPriceGreen;
+    uint32 maxPriceGreen;
+    uint32 minBidPriceGreen;
+    uint32 maxBidPriceGreen;
+    uint32 maxStackGreen;
+    uint32 minPriceBlue;
+    uint32 maxPriceBlue;
+    uint32 minBidPriceBlue;
+    uint32 maxBidPriceBlue;
+    uint32 maxStackBlue;
+    uint32 minPricePurple;
+    uint32 maxPricePurple;
+    uint32 minBidPricePurple;
+    uint32 maxBidPricePurple;
+    uint32 maxStackPurple;
+    uint32 minPriceOrange;
+    uint32 maxPriceOrange;
+    uint32 minBidPriceOrange;
+    uint32 maxBidPriceOrange;
+    uint32 maxStackOrange;
+    uint32 minPriceYellow;
+    uint32 maxPriceYellow;
+    uint32 minBidPriceYellow;
+    uint32 maxBidPriceYellow;
+    uint32 maxStackYellow;
+
+    uint32 buyerPriceGrey;
+    uint32 buyerPriceWhite;
+    uint32 buyerPriceGreen;
+    uint32 buyerPriceBlue;
+    uint32 buyerPricePurple;
+    uint32 buyerPriceOrange;
+    uint32 buyerPriceYellow;
+    uint32 buyerBiddingInterval;
+    uint32 buyerBidsPerInterval;
+
+    uint32 greytgp;
+    uint32 whitetgp;
+    uint32 greentgp;
+    uint32 bluetgp;
+    uint32 purpletgp;
+    uint32 orangetgp;
+    uint32 yellowtgp;
+    uint32 greyip;
+    uint32 whiteip;
+    uint32 greenip;
+    uint32 blueip;
+    uint32 purpleip;
+    uint32 orangeip;
+    uint32 yellowip;
+
+    uint32 greyTGoods;
+    uint32 whiteTGoods;
+    uint32 greenTGoods;
+    uint32 blueTGoods;
+    uint32 purpleTGoods;
+    uint32 orangeTGoods;
+    uint32 yellowTGoods;
+
+    uint32 greyItems;
+    uint32 whiteItems;
+    uint32 greenItems;
+    uint32 blueItems;
+    uint32 purpleItems;
+    uint32 orangeItems;
+    uint32 yellowItems;
+
+public:
+    AHBConfig(uint32 ahid)
+    {
+        AHID = ahid;
+        switch(ahid)
+        {
+        case 2:
+            AHFID = 55;
+            break;
+        case 6:
+            AHFID = 29;
+            break;
+        case 7:
+            AHFID = 120;
+            break;
+        default:
+            AHFID = 120;
+            break;
+        }
+    }
+    AHBConfig()
+    {
+    }
+    uint32 GetAHID()
+    {
+        return AHID;
+    }
+    uint32 GetAHFID()
+    {
+        return AHFID;
+    }
+    void SetMinItems(uint32 value)
+    {
+        minItems = value;
+    }
+    uint32 GetMinItems()
+    {
+        if ((minItems == 0) && (maxItems))
+            return maxItems;
+        else if ((maxItems) && (minItems > maxItems))
+            return maxItems;
+        else
+            return minItems;
+    }
+    void SetMaxItems(uint32 value)
+    {
+        maxItems = value;
+    // CalculatePercents() needs to be called, but only if
+    // SetPercentages() has been called at least once already.
+    }
+    uint32 GetMaxItems()
+    {
+        return maxItems;
+    }
+    void SetPercentages(uint32 greytg, uint32 whitetg, uint32 greentg, uint32 bluetg, uint32 purpletg, uint32 orangetg, uint32 yellowtg, uint32 greyi, uint32 whitei, uint32 greeni, uint32 bluei, uint32 purplei, uint32 orangei, uint32 yellowi)
+    {
+        uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+
+        if (totalPercent == 0)
+        {
+            maxItems = 0;
+        }
+        else if (totalPercent != 100)
+        {
+            greytg = 0;
+            whitetg = 27;
+            greentg = 12;
+            bluetg = 10;
+            purpletg = 1;
+            orangetg = 0;
+            yellowtg = 0;
+            greyi = 0;
+            whitei = 10;
+            greeni = 30;
+            bluei = 8;
+            purplei = 2;
+            orangei = 0;
+            yellowi = 0;
+        }
+        percentGreyTradeGoods = greytg;
+        percentWhiteTradeGoods = whitetg;
+        percentGreenTradeGoods = greentg;
+        percentBlueTradeGoods = bluetg;
+        percentPurpleTradeGoods = purpletg;
+        percentOrangeTradeGoods = orangetg;
+        percentYellowTradeGoods = yellowtg;
+        percentGreyItems = greyi;
+        percentWhiteItems = whitei;
+        percentGreenItems = greeni;
+        percentBlueItems = bluei;
+        percentPurpleItems = purplei;
+        percentOrangeItems = orangei;
+        percentYellowItems = yellowi;
+        CalculatePercents();
+    }
+    uint32 GetPercentages(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return percentGreyTradeGoods;
+            break;
+        case AHB_WHITE_TG:
+            return percentWhiteTradeGoods;
+            break;
+        case AHB_GREEN_TG:
+            return percentGreenTradeGoods;
+            break;
+        case AHB_BLUE_TG:
+            return percentBlueTradeGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return percentPurpleTradeGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return percentOrangeTradeGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return percentYellowTradeGoods;
+            break;
+        case AHB_GREY_I:
+            return percentGreyItems;
+            break;
+        case AHB_WHITE_I:
+            return percentWhiteItems;
+            break;
+        case AHB_GREEN_I:
+            return percentGreenItems;
+            break;
+        case AHB_BLUE_I:
+            return percentBlueItems;
+            break;
+        case AHB_PURPLE_I:
+            return percentPurpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return percentOrangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return percentYellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetMinPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minPriceGrey == 0)
+                    return 100;
+                else if (minPriceGrey > maxPriceGrey)
+                    return maxPriceGrey;
+                else
+                    return minPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minPriceWhite == 0)
+                    return 150;
+                else if (minPriceWhite > maxPriceWhite)
+                    return maxPriceWhite;
+                else
+                    return minPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minPriceGreen == 0)
+                    return 200;
+                else if (minPriceGreen > maxPriceGreen)
+                    return maxPriceGreen;
+                else
+                    return minPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minPriceBlue == 0)
+                    return 250;
+                else if (minPriceBlue > maxPriceBlue)
+                    return maxPriceBlue;
+                else
+                    return minPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minPricePurple == 0)
+                    return 300;
+                else if (minPricePurple > maxPricePurple)
+                    return maxPricePurple;
+                else
+                    return minPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minPriceOrange == 0)
+                    return 400;
+                else if (minPriceOrange > maxPriceOrange)
+                    return maxPriceOrange;
+                else
+                    return minPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minPriceYellow == 0)
+                    return 500;
+                else if (minPriceYellow > maxPriceYellow)
+                    return maxPriceYellow;
+                else
+                    return minPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxPriceGrey == 0)
+                    return 150;
+                else
+                    return maxPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxPriceWhite == 0)
+                    return 250;
+                else
+                    return maxPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxPriceGreen == 0)
+                    return 300;
+                else
+                    return maxPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxPriceBlue == 0)
+                    return 350;
+                else
+                    return maxPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxPricePurple == 0)
+                    return 450;
+                else
+                    return maxPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxPriceOrange == 0)
+                    return 550;
+                else
+                    return maxPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxPriceYellow == 0)
+                    return 650;
+                else
+                    return maxPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMinBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minBidPriceGrey > 100)
+                    return 100;
+                else
+                    return minBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minBidPriceWhite > 100)
+                    return 100;
+                else
+                    return minBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minBidPriceGreen > 100)
+                    return 100;
+                else
+                    return minBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minBidPriceBlue > 100)
+                    return 100;
+                else
+                    return minBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minBidPricePurple > 100)
+                    return 100;
+                else
+                    return minBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minBidPriceOrange > 100)
+                    return 100;
+                else
+                    return minBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minBidPriceYellow > 100)
+                    return 100;
+                else
+                    return minBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxBidPriceGrey > 100)
+                    return 100;
+                else
+                    return maxBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxBidPriceWhite > 100)
+                    return 100;
+                else
+                    return maxBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxBidPriceGreen > 100)
+                    return 100;
+                else
+                    return maxBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxBidPriceBlue > 100)
+                    return 100;
+                else
+                    return maxBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxBidPricePurple > 100)
+                    return 100;
+                else
+                    return maxBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxBidPriceOrange > 100)
+                    return 100;
+                else
+                    return maxBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxBidPriceYellow > 100)
+                    return 100;
+                else
+                    return maxBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxStack(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxStackGrey = value;
+            break;
+        case AHB_WHITE:
+            maxStackWhite = value;
+            break;
+        case AHB_GREEN:
+            maxStackGreen = value;
+            break;
+        case AHB_BLUE:
+            maxStackBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxStackPurple = value;
+            break;
+        case AHB_ORANGE:
+            maxStackOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxStackYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxStack(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                return maxStackGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                return maxStackWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                return maxStackGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                return maxStackBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                return maxStackPurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                return maxStackOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                return maxStackYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetBuyerPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            buyerPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            buyerPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            buyerPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            buyerPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            buyerPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            buyerPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            buyerPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetBuyerPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            return buyerPriceGrey;
+            break;
+        case AHB_WHITE:
+            return buyerPriceWhite;
+            break;
+        case AHB_GREEN:
+            return buyerPriceGreen;
+            break;
+        case AHB_BLUE:
+            return buyerPriceBlue;
+            break;
+        case AHB_PURPLE:
+            return buyerPricePurple;
+            break;
+        case AHB_ORANGE:
+            return buyerPriceOrange;
+            break;
+        case AHB_YELLOW:
+            return buyerPriceYellow;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBiddingInterval(uint32 value)
+    {
+        buyerBiddingInterval = value;
+    }
+    uint32 GetBiddingInterval()
+    {
+        return buyerBiddingInterval;
+    }
+    void CalculatePercents()
+    {
+        greytgp = (uint32) (((double)percentGreyTradeGoods / 100.0) * maxItems);
+        whitetgp = (uint32) (((double)percentWhiteTradeGoods / 100.0) * maxItems);
+        greentgp = (uint32) (((double)percentGreenTradeGoods / 100.0) * maxItems);
+        bluetgp = (uint32) (((double)percentBlueTradeGoods / 100.0) * maxItems);
+        purpletgp = (uint32) (((double)percentPurpleTradeGoods / 100.0) * maxItems);
+        orangetgp = (uint32) (((double)percentOrangeTradeGoods / 100.0) * maxItems);
+        yellowtgp = (uint32) (((double)percentYellowTradeGoods / 100.0) * maxItems);
+        greyip = (uint32) (((double)percentGreyItems / 100.0) * maxItems);
+        whiteip = (uint32) (((double)percentWhiteItems / 100.0) * maxItems);
+        greenip = (uint32) (((double)percentGreenItems / 100.0) * maxItems);
+        blueip = (uint32) (((double)percentBlueItems / 100.0) * maxItems);
+        purpleip = (uint32) (((double)percentPurpleItems / 100.0) * maxItems);
+        orangeip = (uint32) (((double)percentOrangeItems / 100.0) * maxItems);
+        yellowip = (uint32) (((double)percentYellowItems / 100.0) * maxItems);
+        uint32 total = greytgp + whitetgp + greentgp + bluetgp + purpletgp + orangetgp + yellowtgp + greyip + whiteip + greenip + blueip + purpleip + orangeip + yellowip;
+        int32 diff = (maxItems - total);
+        if (diff < 0)
+        {
+            if ((whiteip - diff) > 0)
+                whiteip -= diff;
+            else if ((greenip - diff) > 0)
+                greenip -= diff;
+        }
+        else if (diff < 0)
+        {
+            whiteip += diff;
+        }
+    }
+    uint32 GetPercents(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greytgp;
+            break;
+        case AHB_WHITE_TG:
+            return whitetgp;
+            break;
+        case AHB_GREEN_TG:
+            return greentgp;
+            break;
+        case AHB_BLUE_TG:
+            return bluetgp;
+            break;
+        case AHB_PURPLE_TG:
+            return purpletgp;
+            break;
+        case AHB_ORANGE_TG:
+            return orangetgp;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowtgp;
+            break;
+        case AHB_GREY_I:
+            return greyip;
+            break;
+        case AHB_WHITE_I:
+            return whiteip;
+            break;
+        case AHB_GREEN_I:
+            return greenip;
+            break;
+        case AHB_BLUE_I:
+            return blueip;
+            break;
+        case AHB_PURPLE_I:
+            return purpleip;
+            break;
+        case AHB_ORANGE_I:
+            return orangeip;
+            break;
+        case AHB_YELLOW_I:
+            return yellowip;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+
+    void DecItemCounts(uint32 Class, uint32 Quality)
+    {
+        switch(Class)
+        {
+        case ITEM_CLASS_TRADE_GOODS:
+            DecItemCounts(Quality);
+            break;
+        default:
+            DecItemCounts(Quality + 7);
+            break;
+        }
+    }
+
+    void DecItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            --greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            --whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            --greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            --blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            --purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            --orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            --yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            --greyItems;
+            break;
+        case AHB_WHITE_I:
+            --whiteItems;
+            break;
+        case AHB_GREEN_I:
+            --greenItems;
+            break;
+        case AHB_BLUE_I:
+            --blueItems;
+            break;
+        case AHB_PURPLE_I:
+            --purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            --orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            --yellowItems;
+            break;
+        default:
+            break;
+        }
+    }
+
+    void IncItemCounts(uint32 Class, uint32 Quality)
+    {
+        switch(Class)
+        {
+        case ITEM_CLASS_TRADE_GOODS:
+            IncItemCounts(Quality);
+            break;
+        default:
+            IncItemCounts(Quality + 7);
+            break;
+        }
+    }
+
+    void IncItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            ++greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            ++whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            ++greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            ++blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            ++purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            ++orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            ++yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            ++greyItems;
+            break;
+        case AHB_WHITE_I:
+            ++whiteItems;
+            break;
+        case AHB_GREEN_I:
+            ++greenItems;
+            break;
+        case AHB_BLUE_I:
+            ++blueItems;
+            break;
+        case AHB_PURPLE_I:
+            ++purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            ++orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            ++yellowItems;
+            break;
+        default:
+            break;
+        }
+    }
+
+    void ResetItemCounts()
+    {
+        greyTGoods = 0;
+        whiteTGoods = 0;
+        greenTGoods = 0;
+        blueTGoods = 0;
+        purpleTGoods = 0;
+        orangeTGoods = 0;
+        yellowTGoods = 0;
+
+        greyItems = 0;
+        whiteItems = 0;
+        greenItems = 0;
+        blueItems = 0;
+        purpleItems = 0;
+        orangeItems = 0;
+        yellowItems = 0;
+    }
+
+    uint32 TotalItemCounts()
+    {
+        return(
+        greyTGoods +
+        whiteTGoods +
+        greenTGoods +
+        blueTGoods +
+        purpleTGoods +
+        orangeTGoods +
+        yellowTGoods +
+
+        greyItems +
+        whiteItems +
+        greenItems +
+        blueItems +
+        purpleItems +
+        orangeItems +
+        yellowItems);
+    }
+
+    uint32 GetItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            return whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            return greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            return blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            return greyItems;
+            break;
+        case AHB_WHITE_I:
+            return whiteItems;
+            break;
+        case AHB_GREEN_I:
+            return greenItems;
+            break;
+        case AHB_BLUE_I:
+            return blueItems;
+            break;
+        case AHB_PURPLE_I:
+            return purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return yellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBidsPerInterval(uint32 value)
+    {
+        buyerBidsPerInterval = value;
+    }
+    uint32 GetBidsPerInterval()
+    {
+        return buyerBidsPerInterval;
+    }
+    ~AHBConfig()
+    {
+    }
+};
+class AuctionHouseBot
+{
+private:
+
+    bool debug_Out;
+    bool debug_Out_Filters;
+
+    bool AHBSeller;
+    bool AHBBuyer;
+    bool BuyMethod;
+    bool SellMethod;
+
+    uint32 AHBplayerAccount;
+    uint32 AHBplayerGUID;
+    uint32 ItemsPerCycle;
+
+    //Begin Filters
+
+    bool Vendor_Items;
+    bool Loot_Items;
+    bool Other_Items;
+    bool Vendor_TGs;
+    bool Loot_TGs;
+    bool Other_TGs;
+
+    bool No_Bind;
+    bool Bind_When_Picked_Up;
+    bool Bind_When_Equipped;
+    bool Bind_When_Use;
+    bool Bind_Quest_Item;
+
+    bool DisablePermEnchant;
+    bool DisableConjured;
+    bool DisableGems;
+    bool DisableMoney;
+    bool DisableMoneyLoot;
+    bool DisableLootable;
+    bool DisableKeys;
+    bool DisableDuration;
+    bool DisableBOP_Or_Quest_NoReqLevel;
+
+    bool DisableWarriorItems;
+    bool DisablePaladinItems;
+    bool DisableHunterItems;
+    bool DisableRogueItems;
+    bool DisablePriestItems;
+    bool DisableDKItems;
+    bool DisableShamanItems;
+    bool DisableMageItems;
+    bool DisableWarlockItems;
+    bool DisableUnusedClassItems;
+    bool DisableDruidItems;
+
+    uint32 DisableItemsBelowLevel;
+    uint32 DisableItemsAboveLevel;
+    uint32 DisableTGsBelowLevel;
+    uint32 DisableTGsAboveLevel;
+    uint32 DisableItemsBelowGUID;
+    uint32 DisableItemsAboveGUID;
+    uint32 DisableTGsBelowGUID;
+    uint32 DisableTGsAboveGUID;
+    uint32 DisableItemsBelowReqLevel;
+    uint32 DisableItemsAboveReqLevel;
+    uint32 DisableTGsBelowReqLevel;
+    uint32 DisableTGsAboveReqLevel;
+    uint32 DisableItemsBelowReqSkillRank;
+    uint32 DisableItemsAboveReqSkillRank;
+    uint32 DisableTGsBelowReqSkillRank;
+    uint32 DisableTGsAboveReqSkillRank;
+
+    std::set<uint32> DisableItemStore;
+
+    //End Filters
+
+    AHBConfig AllianceConfig;
+    AHBConfig HordeConfig;
+    AHBConfig NeutralConfig;
+
+    time_t _lastrun_a;
+    time_t _lastrun_h;
+    time_t _lastrun_n;
+
+    inline uint32 minValue(uint32 a, uint32 b) { return a <= b ? a : b; };
+    void addNewAuctions(Player *AHBplayer, AHBConfig *config);
+    void addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session);
+
+    friend class ACE_Singleton<AuctionHouseBot, ACE_Null_Mutex>;
+    AuctionHouseBot();
+
+public:
+    ~AuctionHouseBot();
+    void Update();
+    void Initialize();
+    void InitializeConfiguration();
+    void LoadValues(AHBConfig*);
+    void DecrementItemCounts(AuctionEntry* ah, uint32 itemEntry);
+    void IncrementItemCounts(AuctionEntry* ah);
+    void Commands(uint32, uint32, uint32, char*);
+    uint32 GetAHBplayerGUID() { return AHBplayerGUID; };
+};
+
+#define auctionbot (*ACE_Singleton<AuctionHouseBot, ACE_Null_Mutex>::instance())
+
+#endif
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index f4699f0..4dda7ec 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -171,7 +171,7 @@ void AuctionHouseMgr::SendAuctionSuccessfulMail(AuctionEntry* auction, SQLTransa
         uint32 profit = auction->bid + auction->deposit - auction->GetAuctionCut();
 
         //FIXME: what do if owner offline
-        if (owner)
+        if (owner && owner->GetGUIDLow() != auctionbot.GetAHBplayerGUID())
         {
             owner->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_EARNED_BY_AUCTIONS, profit);
             owner->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_AUCTION_SOLD, auction->bid);
@@ -199,7 +199,7 @@ void AuctionHouseMgr::SendAuctionExpiredMail(AuctionEntry* auction, SQLTransacti
     // owner exist
     if (owner || owner_accId)
     {
-        if (owner)
+        if (owner && owner->GetGUIDLow() != auctionbot.GetAHBplayerGUID())
             owner->GetSession()->SendAuctionOwnerNotification(auction);
 
         MailDraft(auction->BuildAuctionMailSubject(AUCTION_EXPIRED), AuctionEntry::BuildAuctionMailBody(0, 0, auction->buyout, auction->deposit, 0))
@@ -221,6 +221,9 @@ void AuctionHouseMgr::SendAuctionOutbiddedMail(AuctionEntry* auction, uint32 new
     // old bidder exist
     if (oldBidder || oldBidder_accId)
     {
+        if (oldBidder && !newBidder)
+            oldBidder->GetSession()->SendAuctionBidderNotification(auction->GetHouseId(), auction->Id, auctionbot.GetAHBplayerGUID(), newPrice, auction->GetAuctionOutBid(), auction->itemEntry);
+
         if (oldBidder && newBidder)
             oldBidder->GetSession()->SendAuctionBidderNotification(auction->GetHouseId(), auction->Id, newBidder->GetGUID(), newPrice, auction->GetAuctionOutBid(), auction->itemEntry);
 
@@ -412,10 +415,12 @@ void AuctionHouseObject::AddAuction(AuctionEntry* auction)
 
     AuctionsMap[auction->Id] = auction;
     sScriptMgr->OnAuctionAdd(this, auction);
+    auctionbot.IncrementItemCounts(auction);
 }
 
-bool AuctionHouseObject::RemoveAuction(AuctionEntry* auction, uint32 /*itemEntry*/)
+bool AuctionHouseObject::RemoveAuction(AuctionEntry* auction, uint32 itemEntry)
 {
+    auctionbot.DecrementItemCounts(auction, itemEntry);
     bool wasInMap = AuctionsMap.erase(auction->Id) ? true : false;
 
     sScriptMgr->OnAuctionRemove(this, auction);
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.h b/src/server/game/AuctionHouse/AuctionHouseMgr.h
index f45fc41..88cd0b5 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.h
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.h
@@ -25,6 +25,8 @@
 #include "DatabaseEnv.h"
 #include "DBCStructure.h"
 
+#include "AuctionHouseBot/AuctionHouseBot.h"
+
 class Item;
 class Player;
 class WorldPacket;
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index 4e07797..a22d62c 100644
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -305,7 +305,7 @@ inline void Battleground::_CheckSafePositions(uint32 diff)
             if (Player* player = ObjectAccessor::FindPlayer(itr->first))
             {
                 Position pos = player->GetPosition();
-                GetTeamStartLoc(player->GetBGTeam(), x, y, z, o);
+                GetTeamStartLoc(player->GetTeam(), x, y, z, o);
                 if (pos.GetExactDistSq(x, y, z) > maxDist)
                 {
                     TC_LOG_DEBUG("bg.battleground", "BATTLEGROUND: Sending %s back to start location (map: %u) (possible exploit)", player->GetName().c_str(), GetMapId());
@@ -511,7 +511,7 @@ inline void Battleground::_ProcessJoin(uint32 diff)
                     WorldPacket status;
                     BattlegroundQueueTypeId bgQueueTypeId = sBattlegroundMgr->BGQueueTypeId(m_TypeID, GetArenaType());
                     uint32 queueSlot = player->GetBattlegroundQueueIndex(bgQueueTypeId);
-                    sBattlegroundMgr->BuildBattlegroundStatusPacket(&status, this, queueSlot, STATUS_IN_PROGRESS, 0, GetStartTime(), GetArenaType(), player->GetBGTeam());
+                    sBattlegroundMgr->BuildBattlegroundStatusPacket(&status, this, queueSlot, STATUS_IN_PROGRESS, 0, GetStartTime(), GetArenaType(), player->GetTeam());
                     player->SendDirectMessage(&status);
 
                     player->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
@@ -697,12 +697,32 @@ void Battleground::RewardHonorToTeam(uint32 Honor, uint32 TeamID)
             UpdatePlayerScore(player, SCORE_BONUS_HONOR, Honor);
 }
 
-void Battleground::RewardReputationToTeam(uint32 faction_id, uint32 Reputation, uint32 TeamID)
+void Battleground::RewardReputationToTeam(uint32 a_faction_id, uint32 h_faction_id, uint32 Reputation, uint32 teamId)
 {
-    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction_id))
-        for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
-            if (Player* player = _GetPlayerForTeam(TeamID, itr, "RewardReputationToTeam"))
-                player->GetReputationMgr().ModifyReputation(factionEntry, Reputation);
+    FactionEntry const* a_factionEntry = sFactionStore.LookupEntry(a_faction_id);
+    FactionEntry const* h_factionEntry = sFactionStore.LookupEntry(h_faction_id);
+
+    if (!a_factionEntry || !h_factionEntry)
+        return;
+
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+    {
+        if (itr->second.OfflineRemoveTime)
+            continue;
+
+        Player* plr = ObjectAccessor::FindPlayer(itr->first);
+
+        if (!plr)
+        {
+            TC_LOG_ERROR("bg.battleground", "BattleGround:RewardReputationToTeam: %u not found!", itr->first);
+            continue;
+        }
+
+        uint32 team = plr->GetTeam();
+
+        if (team == teamId)
+            plr->GetReputationMgr().ModifyReputation(plr->GetOTeam() == ALLIANCE ? a_factionEntry : h_factionEntry, Reputation);
+    }
 }
 
 void Battleground::UpdateWorldState(uint32 Field, uint32 Value)
@@ -914,7 +934,7 @@ void Battleground::EndBattleground(uint32 winner)
         player->SendDirectMessage(&pvpLogData);
 
         WorldPacket data;
-        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime(), GetArenaType(), player->GetBGTeam());
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime(), GetArenaType(), player->GetTeam());
         player->SendDirectMessage(&data);
         player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_BATTLEGROUND, 1);
     }
@@ -1063,6 +1083,7 @@ void Battleground::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPac
 
     if (player)
     {
+        player->FitPlayerInTeam(false, this);
         // Do next only if found in battleground
         player->SetBattlegroundId(0, BATTLEGROUND_TYPE_NONE);  // We're not in BG.
         // reset destination bg team
@@ -1132,7 +1153,7 @@ void Battleground::AddPlayer(Player* player)
     // score struct must be created in inherited class
 
     uint64 guid = player->GetGUID();
-    uint32 team = player->GetBGTeam();
+    uint32 team = player->GetTeam();
 
     BattlegroundPlayer bp;
     bp.OfflineRemoveTime = 0;
@@ -1198,6 +1219,8 @@ void Battleground::AddPlayer(Player* player)
     // setup BG group membership
     PlayerAddedToBGCheckIfBGIsRunning(player);
     AddOrSetPlayerToCorrectBgGroup(player, team);
+
+    player->FitPlayerInTeam(true, this);
 }
 
 // this method adds player to his team's bg group, or sets his correct group if player is already in bg group
@@ -1267,8 +1290,8 @@ void Battleground::EventPlayerLoggedOut(Player* player)
 
         // 1 player is logging out, if it is the last, then end arena!
         if (isArena())
-            if (GetAlivePlayersCountByTeam(player->GetBGTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetBGTeam())))
-                EndBattleground(GetOtherTeam(player->GetBGTeam()));
+            if (GetAlivePlayersCountByTeam(player->GetTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetTeam())))
+                EndBattleground(GetOtherTeam(player->GetTeam()));
     }
 }
 
@@ -1876,7 +1899,7 @@ void Battleground::PlayerAddedToBGCheckIfBGIsRunning(Player* player)
     BuildPvPLogDataPacket(data);
     player->SendDirectMessage(&data);
 
-    sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, GetEndTime(), GetStartTime(), GetArenaType(), player->GetBGTeam());
+    sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, GetEndTime(), GetStartTime(), GetArenaType(), player->GetTeam());
     player->SendDirectMessage(&data);
 }
 
diff --git a/src/server/game/Battlegrounds/Battleground.h b/src/server/game/Battlegrounds/Battleground.h
index 2904ec1..bd98084 100644
--- a/src/server/game/Battlegrounds/Battleground.h
+++ b/src/server/game/Battlegrounds/Battleground.h
@@ -382,7 +382,7 @@ class Battleground
         void CastSpellOnTeam(uint32 SpellID, uint32 TeamID);
         void RemoveAuraOnTeam(uint32 SpellID, uint32 TeamID);
         void RewardHonorToTeam(uint32 Honor, uint32 TeamID);
-        void RewardReputationToTeam(uint32 faction_id, uint32 Reputation, uint32 TeamID);
+        void RewardReputationToTeam(uint32 a_faction_id, uint32 h_faction_id, uint32 Reputation, uint32 teamId);
         void UpdateWorldState(uint32 Field, uint32 Value);
         void UpdateWorldStateForPlayer(uint32 Field, uint32 Value, Player* player);
         void EndBattleground(uint32 winner);
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.cpp b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
index ef78594..4acf096 100644
--- a/src/server/game/Battlegrounds/BattlegroundMgr.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
@@ -724,7 +724,7 @@ void BattlegroundMgr::SendToBattleground(Player* player, uint32 instanceId, Batt
     {
         float x, y, z, O;
         uint32 mapid = bg->GetMapId();
-        uint32 team = player->GetBGTeam();
+        uint32 team = player->GetTeam();
         if (team == 0)
             team = player->GetTeam();
 
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.cpp b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
index 547d6e9..9418296 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
@@ -154,6 +154,10 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
         index += BG_TEAMS_COUNT;
     if (ginfo->Team == HORDE)
         index++;
+
+    if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) && ArenaType == 0)
+        index = BG_QUEUE_MIXED;                      // BG_QUEUE_*_* -> BG_QUEUE_MIXED
+
     TC_LOG_DEBUG("bg.battleground", "Adding Group to BattlegroundQueue bgTypeId : %u, bracket_id : %u, index : %u", BgTypeId, bracketId, index);
 
     uint32 lastOnlineTime = getMSTime();
@@ -199,31 +203,56 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
         {
             if (Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(ginfo->BgTypeId))
             {
-                char const* bgName = bg->GetName();
-                uint32 MinPlayers = bg->GetMinPlayersPerTeam();
-                uint32 qHorde = 0;
-                uint32 qAlliance = 0;
-                uint32 q_min_level = bracketEntry->minLevel;
-                uint32 q_max_level = bracketEntry->maxLevel;
-                GroupsQueueType::const_iterator itr;
-                for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].end(); ++itr)
-                    if (!(*itr)->IsInvitedToBGInstanceGUID)
-                        qAlliance += (*itr)->Players.size();
-                for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].end(); ++itr)
-                    if (!(*itr)->IsInvitedToBGInstanceGUID)
-                        qHorde += (*itr)->Players.size();
-
-                // Show queue status to player only (when joining queue)
-                if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED))
                 {
-                    ChatHandler(leader->GetSession()).PSendSysMessage(LANG_BG_QUEUE_ANNOUNCE_SELF, bgName, q_min_level, q_max_level,
-                        qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    char const* bgName = bg->GetName();
+                    uint32 MinPlayers = bg->GetMinPlayersPerTeam()*2;
+                    uint32 qPlayers = 0;
+                    uint32 q_min_level = bracketEntry->minLevel;
+                    uint32 q_max_level = bracketEntry->maxLevel;
+                    for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracketId][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_MIXED].end(); ++itr)
+                        if (!(*itr)->IsInvitedToBGInstanceGUID)
+                            qPlayers += (*itr)->Players.size();
+
+                    if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                    {
+                        ChatHandler(leader->GetSession()).PSendSysMessage("Queue status for %s (Lvl: %u to %u) Queued players: %u (Need at least %u more)", bgName, q_min_level, q_max_level, qPlayers, MinPlayers - qPlayers);
+                    }
+                    else
+                    {
+                        std::ostringstream ss;
+                        ss << "|cffff0000[BG Queue Announcer]:|r " << bgName << " -- [" << q_min_level << "-" << q_max_level << "] " << qPlayers << "/" << MinPlayers;
+                        sWorld->SendGlobalText(ss.str().c_str(), NULL);
+                    }
                 }
-                // System message
                 else
                 {
-                    sWorld->SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD, bgName, q_min_level, q_max_level,
-                        qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    char const* bgName = bg->GetName();
+                    uint32 MinPlayers = bg->GetMinPlayersPerTeam();
+                    uint32 qHorde = 0;
+                    uint32 qAlliance = 0;
+                    uint32 q_min_level = bracketEntry->minLevel;
+                    uint32 q_max_level = bracketEntry->maxLevel;
+                    GroupsQueueType::const_iterator itr;
+                    for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].end(); ++itr)
+                        if (!(*itr)->IsInvitedToBGInstanceGUID)
+                            qAlliance += (*itr)->Players.size();
+                    for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].end(); ++itr)
+                        if (!(*itr)->IsInvitedToBGInstanceGUID)
+                            qHorde += (*itr)->Players.size();
+
+                    // Show queue status to player only (when joining queue)
+                    if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                    {
+                        ChatHandler(leader->GetSession()).PSendSysMessage(LANG_BG_QUEUE_ANNOUNCE_SELF, bgName, q_min_level, q_max_level,
+                            qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    }
+                    // System message
+                    else
+                    {
+                        sWorld->SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD, bgName, q_min_level, q_max_level,
+                            qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    }
                 }
             }
         }
@@ -310,7 +339,7 @@ void BattlegroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
     {
         //we must check premade and normal team's queue - because when players from premade are joining bg,
         //they leave groupinfo so we can't use its players size to find out index
-        for (uint32 j = index; j < BG_QUEUE_GROUP_TYPES_COUNT; j += BG_TEAMS_COUNT)
+        for (uint8 j = 0; j < BG_QUEUE_GROUP_TYPES_COUNT; ++j)
         {
             GroupsQueueType::iterator k = m_QueuedGroups[bracket_id_tmp][j].begin();
             for (; k != m_QueuedGroups[bracket_id_tmp][j].end(); ++k)
@@ -499,6 +528,10 @@ void BattlegroundQueue::FillPlayersToBG(Battleground* bg, BattlegroundBracketId
     int32 hordeFree = bg->GetFreeSlotsForTeam(HORDE);
     int32 aliFree   = bg->GetFreeSlotsForTeam(ALLIANCE);
 
+    if (!bg->isArena())
+        if (FillXPlayersToBG(bracket_id, bg, false))
+            return;
+
     //iterator for iterating through bg queue
     GroupsQueueType::const_iterator Ali_itr = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].begin();
     //count of groups in queue - used to stop cycles
@@ -747,7 +780,8 @@ void BattlegroundQueue::BattlegroundQueueUpdate(uint32 /*diff*/, BattlegroundTyp
     if (m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].empty() &&
         m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].empty() &&
         m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].empty() &&
-        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].empty())
+        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].empty() &&
+        m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].empty())
         return;
 
     // battleground with free slot for player should be always in the beggining of the queue
@@ -838,7 +872,8 @@ void BattlegroundQueue::BattlegroundQueueUpdate(uint32 /*diff*/, BattlegroundTyp
     {
         // if there are enough players in pools, start new battleground or non rated arena
         if (CheckNormalMatch(bg_template, bracket_id, MinPlayersPerTeam, MaxPlayersPerTeam)
-            || (bg_template->isArena() && CheckSkirmishForSameFaction(bracket_id, MinPlayersPerTeam)))
+            || (bg_template->isArena() && CheckSkirmishForSameFaction(bracket_id, MinPlayersPerTeam))
+            || CheckCrossFactionMatch(bracket_id, bg_template))
         {
             // we successfully created a pool
             Battleground* bg2 = sBattlegroundMgr->CreateNewBattleground(bgTypeId, bracketEntry, arenaType, false);
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.h b/src/server/game/Battlegrounds/BattlegroundQueue.h
index af283cb..da808ef 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.h
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.h
@@ -42,6 +42,7 @@ struct GroupQueueInfo                                       // stores informatio
 {
     std::map<uint64, PlayerQueueInfo*> Players;             // player queue info map
     uint32  Team;                                           // Player team (ALLIANCE/HORDE)
+    uint32  OTeam;                                          // Player team (ALLIANCE/HORDE)
     BattlegroundTypeId BgTypeId;                            // battleground type id
     bool    IsRated;                                        // rated
     uint8   ArenaType;                                      // 2v2, 3v3, 5v5 or 0 when BG
@@ -60,9 +61,10 @@ enum BattlegroundQueueGroupTypes
     BG_QUEUE_PREMADE_ALLIANCE   = 0,
     BG_QUEUE_PREMADE_HORDE      = 1,
     BG_QUEUE_NORMAL_ALLIANCE    = 2,
-    BG_QUEUE_NORMAL_HORDE       = 3
+    BG_QUEUE_NORMAL_HORDE       = 3,
+    BG_QUEUE_MIXED              = 4
 };
-#define BG_QUEUE_GROUP_TYPES_COUNT 4
+#define BG_QUEUE_GROUP_TYPES_COUNT 5
 
 class Battleground;
 class BattlegroundQueue
@@ -74,6 +76,11 @@ class BattlegroundQueue
         void BattlegroundQueueUpdate(uint32 diff, BattlegroundTypeId bgTypeId, BattlegroundBracketId bracket_id, uint8 arenaType = 0, bool isRated = false, uint32 minRating = 0);
         void UpdateEvents(uint32 diff);
 
+        bool FillXPlayersToBG(BattlegroundBracketId bracket_id, Battleground* bg, bool start = false);
+        typedef std::multimap<int32, GroupQueueInfo*> QueuedGroupMap;
+        int32 PreAddPlayers(QueuedGroupMap m_PreGroupMap, int32 MaxAdd, uint32 MaxInTeam);
+        bool CheckCrossFactionMatch(BattlegroundBracketId bracket_id, Battleground* bg);
+
         void FillPlayersToBG(Battleground* bg, BattlegroundBracketId bracket_id);
         bool CheckPremadeMatch(BattlegroundBracketId bracket_id, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam);
         bool CheckNormalMatch(Battleground* bg_template, BattlegroundBracketId bracket_id, uint32 minPlayers, uint32 maxPlayers);
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
index 2622ab9..4438c56 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
@@ -141,7 +141,7 @@ void BattlegroundAB::PostUpdateImpl(uint32 diff)
 
                 if (m_ReputationScoreTics[team] >= m_ReputationTics)
                 {
-                    (team == TEAM_ALLIANCE) ? RewardReputationToTeam(509, 10, ALLIANCE) : RewardReputationToTeam(510, 10, HORDE);
+                    RewardReputationToTeam(509, 510, 10, team == ALLIANCE ? ALLIANCE : HORDE);
                     m_ReputationScoreTics[team] -= m_ReputationTics;
                 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
index eafb02f..9c374a4 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
@@ -88,7 +88,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
     if (entry == BG_AV_CreatureInfo[AV_NPC_A_BOSS][0])
     {
         CastSpellOnTeam(23658, HORDE); //this is a spell which finishes a quest where a player has to kill the boss
-        RewardReputationToTeam(729, BG_AV_REP_BOSS, HORDE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_BOSS, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_BOSS), HORDE);
         EndBattleground(HORDE);
         DelCreature(AV_CPLACE_TRIGGER17);
@@ -96,7 +96,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
     else if (entry == BG_AV_CreatureInfo[AV_NPC_H_BOSS][0])
     {
         CastSpellOnTeam(23658, ALLIANCE); //this is a spell which finishes a quest where a player has to kill the boss
-        RewardReputationToTeam(730, BG_AV_REP_BOSS, ALLIANCE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_BOSS, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_BOSS), ALLIANCE);
         EndBattleground(ALLIANCE);
         DelCreature(AV_CPLACE_TRIGGER19);
@@ -109,7 +109,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
             return;
         }
         m_CaptainAlive[0]=false;
-        RewardReputationToTeam(729, BG_AV_REP_CAPTAIN, HORDE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_CAPTAIN, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_CAPTAIN), HORDE);
         UpdateScore(ALLIANCE, (-1)*BG_AV_RES_CAPTAIN);
         //spawn destroyed aura
@@ -128,7 +128,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
             return;
         }
         m_CaptainAlive[1]=false;
-        RewardReputationToTeam(730, BG_AV_REP_CAPTAIN, ALLIANCE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_CAPTAIN, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_CAPTAIN), ALLIANCE);
         UpdateScore(HORDE, (-1)*BG_AV_RES_CAPTAIN);
         //spawn destroyed aura
@@ -150,6 +150,7 @@ void BattlegroundAV::HandleQuestComplete(uint32 questid, Player* player)
     if (GetStatus() != STATUS_IN_PROGRESS)
         return;//maybe we should log this, cause this must be a cheater or a big bug
     uint8 team = GetTeamIndexByTeamId(player->GetTeam());
+    uint8 oteam = GetTeamIndexByTeamId(GetOtherTeam(player->GetTeam()));
     /// @todo add reputation, events (including quest not available anymore, next quest availabe, go/npc de/spawning)and maybe honor
     TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed", questid);
     switch (questid)
@@ -174,21 +175,21 @@ void BattlegroundAV::HandleQuestComplete(uint32 questid, Player* player)
         case AV_QUEST_A_COMMANDER1:
         case AV_QUEST_H_COMMANDER1:
             m_Team_QuestStatus[team][1]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, oteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][1] == 30)
                 TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
         case AV_QUEST_A_COMMANDER2:
         case AV_QUEST_H_COMMANDER2:
             m_Team_QuestStatus[team][2]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, oteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][2] == 60)
                 TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
         case AV_QUEST_A_COMMANDER3:
         case AV_QUEST_H_COMMANDER3:
             m_Team_QuestStatus[team][3]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, oteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][3] == 120)
                 TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
@@ -472,7 +473,7 @@ void BattlegroundAV::EndBattleground(uint32 winner)
             rep[i]   += BG_AV_REP_SURVIVING_CAPTAIN;
         }
         if (rep[i] != 0)
-            RewardReputationToTeam(i == 0 ? 730 : 729, rep[i], i == 0 ? ALLIANCE : HORDE);
+            RewardReputationToTeam(729, 730, 10, i == ALLIANCE ? ALLIANCE : HORDE);
         if (kills[i] != 0)
             RewardHonorToTeam(GetBonusHonorFromKill(kills[i]), i == 0 ? ALLIANCE : HORDE);
     }
@@ -577,7 +578,7 @@ void BattlegroundAV::EventPlayerDestroyedPoint(BG_AV_Nodes node)
             SpawnBGObject(BG_AV_OBJECT_BURN_DUNBALDAR_SOUTH + i + (tmp * 10), RESPAWN_IMMEDIATELY);
 
         UpdateScore((owner == ALLIANCE) ? HORDE : ALLIANCE, -1 * BG_AV_RES_TOWER);
-        RewardReputationToTeam(owner == ALLIANCE ? 730 : 729, BG_AV_REP_TOWER, owner);
+        RewardReputationToTeam(729, 730, BG_AV_REP_TOWER, owner);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_TOWER), owner);
 
         SpawnBGObject(BG_AV_OBJECT_TAURA_A_DUNBALDAR_SOUTH+GetTeamIndexByTeamId(owner)+(2*tmp), RESPAWN_ONE_DAY);
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundBE.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundBE.cpp
index 548e0bf..0b1f7fd 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundBE.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundBE.cpp
@@ -65,7 +65,7 @@ void BattlegroundBE::StartingEventOpenDoors()
 void BattlegroundBE::AddPlayer(Player* player)
 {
     Battleground::AddPlayer(player);
-    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetBGTeam());
+    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetTeam());
     UpdateArenaWorldState();
 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
index 1d6970f..f670918 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
@@ -153,7 +153,7 @@ void BattlegroundDS::StartingEventOpenDoors()
 void BattlegroundDS::AddPlayer(Player* player)
 {
     Battleground::AddPlayer(player);
-    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetBGTeam());
+    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetTeam());
     UpdateArenaWorldState();
 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundNA.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundNA.cpp
index 82fcb2f..25d8916 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundNA.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundNA.cpp
@@ -62,7 +62,7 @@ void BattlegroundNA::StartingEventOpenDoors()
 void BattlegroundNA::AddPlayer(Player* player)
 {
     Battleground::AddPlayer(player);
-    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetBGTeam());
+    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetTeam());
     UpdateArenaWorldState();
 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundRL.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundRL.cpp
index 712d9a6..2bba821 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundRL.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundRL.cpp
@@ -62,7 +62,7 @@ void BattlegroundRL::StartingEventOpenDoors()
 void BattlegroundRL::AddPlayer(Player* player)
 {
     Battleground::AddPlayer(player);
-    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetBGTeam());
+    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetTeam());
     UpdateArenaWorldState();
 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp
index 1059124..c583d2d 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp
@@ -100,7 +100,7 @@ void BattlegroundRV::StartingEventOpenDoors()
 void BattlegroundRV::AddPlayer(Player* player)
 {
     Battleground::AddPlayer(player);
-    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetBGTeam());
+    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetTeam());
 
     UpdateWorldState(BG_RV_WORLD_STATE_A, GetAlivePlayersCountByTeam(ALLIANCE));
     UpdateWorldState(BG_RV_WORLD_STATE_H, GetAlivePlayersCountByTeam(HORDE));
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
index 1faa336..6dfebca 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
@@ -309,7 +309,6 @@ void BattlegroundWS::EventPlayerCapturedFlag(Player* player)
         if (GetTeamScore(TEAM_ALLIANCE) < BG_WS_MAX_TEAM_SCORE)
             AddPoint(ALLIANCE, 1);
         PlaySoundToAll(BG_WS_SOUND_FLAG_CAPTURED_ALLIANCE);
-        RewardReputationToTeam(890, m_ReputationCapture, ALLIANCE);
     }
     else
     {
@@ -328,8 +327,8 @@ void BattlegroundWS::EventPlayerCapturedFlag(Player* player)
         if (GetTeamScore(TEAM_HORDE) < BG_WS_MAX_TEAM_SCORE)
             AddPoint(HORDE, 1);
         PlaySoundToAll(BG_WS_SOUND_FLAG_CAPTURED_HORDE);
-        RewardReputationToTeam(889, m_ReputationCapture, HORDE);
     }
+    RewardReputationToTeam(890, 889, m_ReputationCapture, player->GetTeam());
     //for flag capture is reward 2 honorable kills
     RewardHonorToTeam(GetBonusHonorFromKill(2), player->GetTeam());
 
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 26fd081..57c5da4 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -9,10 +9,12 @@
 # implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
 file(GLOB_RECURSE sources_Accounts Accounts/*.cpp Accounts/*.h)
+file(GLOB_RECURSE sources_Anticheat Anticheat/*.cpp Anticheat/*.h)
 file(GLOB_RECURSE sources_Achievements Achievements/*.cpp Achievements/*.h)
 file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
 file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
 file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
+file(GLOB_RECURSE sources_AuctionHouseBot AuctionHouse/AuctionHouseBot/*.cpp AuctionHouse/AuctionHouseBot/*.h)
 file(GLOB_RECURSE sources_Battlefield Battlefield/*.cpp Battlefield/*.h)
 file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
 file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
@@ -43,11 +45,13 @@ file(GLOB_RECURSE sources_Server Server/*.cpp Server/*.h)
 file(GLOB_RECURSE sources_Skills Skills/*.cpp Skills/*.h)
 file(GLOB_RECURSE sources_Spells Spells/*.cpp Spells/*.h)
 file(GLOB_RECURSE sources_Texts Texts/*.cpp Texts/*.h)
+file(GLOB_RECURSE sources_TriniChat TriniChat/*.cpp Texts/*.h)
 file(GLOB_RECURSE sources_Tools Tools/*.cpp Tools/*.h)
 file(GLOB_RECURSE sources_Tickets Tickets/*.cpp Tickets/*.h)
 file(GLOB_RECURSE sources_Warden Warden/*.cpp Warden/*.h)
 file(GLOB_RECURSE sources_Weather Weather/*.cpp Weather/*.h)
 file(GLOB_RECURSE sources_World World/*.cpp World/*.h)
+file(GLOB_RECURSE sources_Cfbg Cfbg/*.cpp Cfbg/*.h)
 
 # Create game-libary
 
@@ -59,10 +63,12 @@ endif ()
 set(game_STAT_SRCS
   ${game_STAT_SRCS}
   ${sources_Accounts}
+  ${sources_Anticheat}
   ${sources_Achievements}
   ${sources_Addons}
   ${sources_AI}
   ${sources_AuctionHouse}
+  ${sources_AuctionHouseBot}
   ${sources_Battlefield}
   ${sources_Battlegrounds}
   ${sources_Calendar}
@@ -93,11 +99,13 @@ set(game_STAT_SRCS
   ${sources_Skills}
   ${sources_Spells}
   ${sources_Texts}
+  ${sources_TriniChat}
   ${sources_Tools}
   ${sources_Tickets}
   ${sources_Warden}
   ${sources_Weather}
   ${sources_World}
+  ${sources_Cfbg}
 )
 
 include_directories(
@@ -128,13 +136,16 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/Accounts
+  ${CMAKE_CURRENT_SOURCE_DIR}/Anticheat
   ${CMAKE_CURRENT_SOURCE_DIR}/Achievements
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/NpcBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
+  ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse/AuctionHouseBot
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield/Zones
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
@@ -190,6 +201,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Spells
   ${CMAKE_CURRENT_SOURCE_DIR}/Spells/Auras
   ${CMAKE_CURRENT_SOURCE_DIR}/Texts
+  ${CMAKE_CURRENT_SOURCE_DIR}/TriniChat
   ${CMAKE_CURRENT_SOURCE_DIR}/Tools
   ${CMAKE_CURRENT_SOURCE_DIR}/Tickets
   ${CMAKE_CURRENT_SOURCE_DIR}/Warden
diff --git a/src/server/game/Cfbg/Cfbg.cpp b/src/server/game/Cfbg/Cfbg.cpp
new file mode 100644
index 0000000..d0c9d3b
--- /dev/null
+++ b/src/server/game/Cfbg/Cfbg.cpp
@@ -0,0 +1,325 @@
+#include "Cfbg.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "Player.h"
+#include "Chat.h"
+#include "BattlegroundQueue.h"
+
+/*####################################################################################
+###############################CROSSFACTION BATTLEGROUNDS#############################
+####################################################################################*/
+
+uint8 Unit::getRace(bool forceoriginal) const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        Player* pPlayer = ((Player*)this);
+
+        if (forceoriginal)
+            return pPlayer->getORace();
+
+        if (pPlayer->InArena())
+            return GetByteValue(UNIT_FIELD_BYTES_0, 0);
+
+        if (!pPlayer->IsPlayingNative())
+            return pPlayer->getFRace();
+    }
+
+    return GetByteValue(UNIT_FIELD_BYTES_0, 0);
+}
+
+bool Player::SendRealNameQuery()
+{
+    if (IsPlayingNative())
+        return false;
+
+    WorldPacket data(SMSG_NAME_QUERY_RESPONSE, (8 + 1 + 1 + 1 + 1 + 1 + 10));
+    data.appendPackGUID(GetGUID());                             // player guid
+    data << uint8(0);                                       // added in 3.1; if > 1, then end of packet
+    data << GetName();                                   // played name
+    data << uint8(0);                                       // realm name for cross realm BG usage
+    data << uint8(getORace());
+    data << uint8(getGender());
+    data << uint8(getClass());
+    data << uint8(0);                                   // is not declined
+    GetSession()->SendPacket(&data);
+
+    return true;
+}
+
+void Player::SetFakeRaceAndMorph()
+{
+m_FakeRace = GetOTeam() == ALLIANCE ? RACE_BLOODELF : RACE_HUMAN;
+}
+
+bool Player::SendBattleGroundChat(uint32 msgtype, std::string message)
+{
+    // Select distance to broadcast to.
+    float distance = msgtype == CHAT_MSG_SAY ? sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY) : sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL);
+
+    if (Battleground* pBattleGround = GetBattleground())
+    {
+        if (pBattleGround->isArena()) // Only fake chat in BG's. CFBG should not interfere with arenas.
+            return false;
+
+        for (Battleground::BattlegroundPlayerMap::const_iterator itr = pBattleGround->GetPlayers().begin(); itr != pBattleGround->GetPlayers().end(); ++itr)
+        {
+            if (Player* pPlayer = ObjectAccessor::FindPlayer(itr->first))
+            {
+                if (GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) <= distance)
+                {
+                    WorldPacket data(SMSG_MESSAGECHAT, 200);
+
+                    if (GetTeam() == pPlayer->GetTeam())
+                        BuildPlayerChat(&data, msgtype, message, LANG_UNIVERSAL);
+                    else if (msgtype != CHAT_MSG_EMOTE)
+                       BuildPlayerChat(&data, msgtype, message, pPlayer->GetTeam() == ALLIANCE ? LANG_ORCISH : LANG_COMMON);
+
+                    pPlayer->GetSession()->SendPacket(&data);
+                }
+            }
+        }
+        return true;
+    }
+    else
+        return false;
+}
+
+void Player::MorphFit(bool value)
+{
+    if (!IsPlayingNative() && value)
+    {
+        if (GetOTeam() == HORDE)
+        {
+            if (getGender() == GENDER_MALE)
+            {
+                SetDisplayId(19723);
+                SetNativeDisplayId(19723);
+            }
+            else
+            {
+                SetDisplayId(19724);
+                SetNativeDisplayId(19724);
+            }
+        }
+        else
+        {
+            if (getGender() == GENDER_MALE)
+            {
+                SetDisplayId(20578);
+                SetNativeDisplayId(20578);
+            }
+            else
+            {
+                SetDisplayId(20579);
+                SetNativeDisplayId(20579);
+            }
+        }
+    }
+    else
+        InitDisplayIds();
+}
+
+void Player::FitPlayerInTeam(bool action, Battleground* pBattleGround)
+{
+    if (!pBattleGround)
+        pBattleGround = GetBattleground();
+
+    if ((!pBattleGround || pBattleGround->isArena()) && action)
+        return;
+
+    if(!IsPlayingNative() && action)
+        setFactionForRace(getRace());
+    else
+        setFactionForRace(getORace());
+
+    if (action)
+        SetForgetBGPlayers(true);
+    else
+        SetForgetInListPlayers(true);
+
+    MorphFit(action);
+
+    if (pBattleGround && action)
+        SendChatMessage("%sYou are playing for the %s%s in this %s", MSG_COLOR_WHITE, GetTeam() == ALLIANCE ? MSG_COLOR_DARKBLUE"alliance" : MSG_COLOR_RED"horde", MSG_COLOR_WHITE, pBattleGround->GetName());
+}
+
+void Player::DoForgetPlayersInList()
+{
+    // m_FakePlayers is filled from a vector within the battleground
+    // they were in previously so all players that have been in that BG will be invalidated.
+    for (FakePlayers::const_iterator itr = m_FakePlayers.begin(); itr != m_FakePlayers.end(); ++itr)
+    {
+        WorldPacket data(SMSG_INVALIDATE_PLAYER, 8);
+        data << *itr;
+        GetSession()->SendPacket(&data);
+        if (Player* pPlayer = ObjectAccessor::FindPlayer(*itr))
+            GetSession()->SendNameQueryOpcode(pPlayer->GetGUID());
+    }
+    m_FakePlayers.clear();
+}
+
+void Player::DoForgetPlayersInBG(Battleground* pBattleGround)
+{
+    for (Battleground::BattlegroundPlayerMap::const_iterator itr = pBattleGround->GetPlayers().begin(); itr != pBattleGround->GetPlayers().end(); ++itr)
+    {
+        // Here we invalidate players in the bg to the added player
+        WorldPacket data1(SMSG_INVALIDATE_PLAYER, 8);
+        data1 << itr->first;
+        GetSession()->SendPacket(&data1);
+
+        if (Player* pPlayer = ObjectAccessor::FindPlayer(itr->first))
+        {
+            GetSession()->SendNameQueryOpcode(pPlayer->GetGUID()); // Send namequery answer instantly if player is available
+            // Here we invalidate the player added to players in the bg
+            WorldPacket data2(SMSG_INVALIDATE_PLAYER, 8);
+            data2 << GetGUID();
+            pPlayer->GetSession()->SendPacket(&data2);
+            pPlayer->GetSession()->SendNameQueryOpcode(GetGUID());
+        }
+    }
+}
+
+bool BattlegroundQueue::CheckCrossFactionMatch(BattlegroundBracketId bracket_id, Battleground* bg)
+{
+    if (!sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) || bg->isArena())
+        return false; // Only do this if crossbg's are enabled.
+
+    // Here we will add all players to selectionpool, later we check if there are enough and launch a bg.
+    FillXPlayersToBG(bracket_id, bg, true);
+
+    if (sBattlegroundMgr->isTesting() && (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() || m_SelectionPools[TEAM_HORDE].GetPlayerCount()))
+        return true;
+
+    uint8 MPT = bg->GetMinPlayersPerTeam();
+    if (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() < MPT || m_SelectionPools[TEAM_HORDE].GetPlayerCount() < MPT)
+        return false;
+
+    return true;
+}
+
+// This function will invite players in the least populated faction, which makes battleground queues much faster.
+// This function will return true if cross faction battlegrounds are enabled, otherwise return false,
+// which is useful in FillPlayersToBG. Because then we can interrupt the regular invitation if cross faction bg's are enabled.
+bool BattlegroundQueue::FillXPlayersToBG(BattlegroundBracketId bracket_id, Battleground* bg, bool start)
+{
+    uint8 queuedPeople = 0;
+    for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].end(); ++itr)
+        if (!(*itr)->IsInvitedToBGInstanceGUID)
+            queuedPeople += (*itr)->Players.size();
+
+    if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) && (sBattlegroundMgr->isTesting() || queuedPeople >= bg->GetMinPlayersPerTeam()*2 || !start))
+    {
+        int32 aliFree   = start ? bg->GetMaxPlayersPerTeam() : bg->GetFreeSlotsForTeam(ALLIANCE);
+        int32 hordeFree = start ? bg->GetMaxPlayersPerTeam() : bg->GetFreeSlotsForTeam(HORDE);
+        // Empty selection pools. They will be refilled from queued groups.
+        m_SelectionPools[TEAM_ALLIANCE].Init();
+        m_SelectionPools[TEAM_HORDE].Init();
+        int32 valiFree = aliFree;
+        int32 vhordeFree = hordeFree;
+        int32 diff = 0;
+
+
+        // Add teams to their own factions as far as possible.
+        if (start)
+        {
+            QueuedGroupMap m_PreGroupMap_a, m_PreGroupMap_h;
+            int32 m_SmallestOfTeams = 0;
+            int32 queuedAlliance = 0;
+            int32 queuedHorde = 0;
+
+            for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].end(); ++itr)
+            {
+                if ((*itr)->IsInvitedToBGInstanceGUID)
+                    continue;
+
+                bool alliance = (*itr)->OTeam == ALLIANCE;
+
+                if (alliance)
+                {
+                    m_PreGroupMap_a.insert(std::make_pair((*itr)->Players.size(), *itr));
+                    queuedAlliance += (*itr)->Players.size();
+                }
+                else
+                {
+                    m_PreGroupMap_h.insert(std::make_pair((*itr)->Players.size(), *itr));
+                    queuedHorde += (*itr)->Players.size();
+                }
+            }
+
+            m_SmallestOfTeams = std::min(std::min(aliFree, queuedAlliance), std::min(hordeFree, queuedHorde));
+
+            valiFree -= PreAddPlayers(m_PreGroupMap_a, m_SmallestOfTeams, aliFree);
+            vhordeFree -= PreAddPlayers(m_PreGroupMap_h, m_SmallestOfTeams, hordeFree);
+        }
+
+        QueuedGroupMap m_QueuedGroupMap;
+
+        for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].end(); ++itr)
+            m_QueuedGroupMap.insert(std::make_pair((*itr)->Players.size(), *itr));
+
+        for (QueuedGroupMap::reverse_iterator itr = m_QueuedGroupMap.rbegin(); itr != m_QueuedGroupMap.rend(); ++itr)
+        {
+            GroupsQueueType allypool = m_SelectionPools[TEAM_ALLIANCE].SelectedGroups;
+            GroupsQueueType hordepool = m_SelectionPools[TEAM_HORDE].SelectedGroups;
+
+            GroupQueueInfo* ginfo = itr->second;
+
+            // If player already was invited via pre adding (add to own team first) or he was already invited to a bg, skip.
+            if (ginfo->IsInvitedToBGInstanceGUID ||
+                std::find(allypool.begin(), allypool.end(), ginfo) != allypool.end() ||
+                std::find(hordepool.begin(), hordepool.end(), ginfo) != hordepool.end() ||
+                (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() >= bg->GetMinPlayersPerTeam() &&
+                m_SelectionPools[TEAM_HORDE].GetPlayerCount() >= bg->GetMinPlayersPerTeam()))
+                continue;
+
+            diff = abs(valiFree - vhordeFree);
+            bool moreAli = valiFree < vhordeFree;
+
+            if (diff > 0)
+                ginfo->Team = moreAli ? HORDE : ALLIANCE;
+
+            bool alliance = ginfo->Team == ALLIANCE;
+
+            if (m_SelectionPools[alliance ? TEAM_ALLIANCE : TEAM_HORDE].AddGroup(ginfo, alliance ? aliFree : hordeFree))
+                alliance ? valiFree -= ginfo->Players.size() : vhordeFree -= ginfo->Players.size();
+        }
+
+        return true;
+    }
+    return false;
+}
+
+int32 BattlegroundQueue::PreAddPlayers(QueuedGroupMap m_PreGroupMap, int32 MaxAdd, uint32 MaxInTeam)
+{
+    int32 LeftToAdd = MaxAdd;
+    uint32 Added = 0;
+
+    for (QueuedGroupMap::reverse_iterator itr = m_PreGroupMap.rbegin(); itr != m_PreGroupMap.rend(); ++itr)
+    {
+        int32 PlayerSize = itr->first;
+        bool alliance = itr->second->OTeam == ALLIANCE;
+
+        if (PlayerSize <= LeftToAdd && m_SelectionPools[alliance ? TEAM_ALLIANCE : TEAM_HORDE].AddGroup(itr->second, MaxInTeam))
+            LeftToAdd -= PlayerSize, Added -= PlayerSize;
+    }
+
+    return LeftToAdd;
+}
+
+void Player::SendChatMessage(const char *format, ...)
+{
+    if (!IsInWorld())
+        return;
+
+    if (format)
+    {
+        va_list ap;
+        char str [2048];
+        va_start(ap, format);
+        vsnprintf(str, 2048, format, ap);
+        va_end(ap);
+
+        ChatHandler(GetSession()).SendSysMessage(str);
+    }
+}
diff --git a/src/server/game/Cfbg/Cfbg.h b/src/server/game/Cfbg/Cfbg.h
new file mode 100644
index 0000000..45567f8
--- /dev/null
+++ b/src/server/game/Cfbg/Cfbg.h
@@ -0,0 +1,35 @@
+#ifndef _CUSTOM_H
+#define _CUSTOM_H
+
+#define MSG_COLOR_LIGHTRED     "|cffff6060"
+#define MSG_COLOR_LIGHTBLUE    "|cff00ccff"
+#define MSG_COLOR_ANN_GREEN    "|c1f40af20"
+#define MSG_COLOR_RED          "|cffff0000"
+#define MSG_COLOR_GOLD         "|cffffcc00"
+#define MSG_COLOR_SUBWHITE     "|cffbbbbbb"
+#define MSG_COLOR_MAGENTA      "|cffff00ff"
+#define MSG_COLOR_YELLOW       "|cffffff00"
+#define MSG_COLOR_CYAN         "|cff00ffff"
+#define MSG_COLOR_DARKBLUE     "|cff0000ff"
+
+#define MSG_COLOR_GREY         "|cff9d9d9d"
+#define MSG_COLOR_WHITE        "|cffffffff"
+#define MSG_COLOR_GREEN        "|cff1eff00"
+#define MSG_COLOR_BLUE         "|cff0080ff"
+#define MSG_COLOR_PURPLE       "|cffb048f8"
+#define MSG_COLOR_ORANGE       "|cffff8000"
+
+#define MSG_COLOR_DRUID        "|cffff7d0a"
+#define MSG_COLOR_HUNTER       "|cffabd473"
+#define MSG_COLOR_MAGE         "|cff69ccf0"
+#define MSG_COLOR_PALADIN      "|cfff58cba"
+#define MSG_COLOR_PRIEST       "|cffffffff"
+#define MSG_COLOR_ROGUE        "|cfffff569"
+#define MSG_COLOR_SHAMAN       "|cff0070de"
+#define MSG_COLOR_WARLOCK      "|cff9482c9"
+#define MSG_COLOR_WARRIOR      "|cffc79c6e"
+#define MSG_COLOR_DEATH_KNIGHT "|cffc41f3b"
+#define MSG_COLOR_MONK         "|cff00ff96"
+
+#define LIMIT_UINT32 2147483647
+#endif
diff --git a/src/server/game/Chat/Channels/Channel.cpp b/src/server/game/Chat/Channels/Channel.cpp
index 3f6a40d..525d9fde 100644
--- a/src/server/game/Chat/Channels/Channel.cpp
+++ b/src/server/game/Chat/Channels/Channel.cpp
@@ -24,6 +24,7 @@
 #include "DatabaseEnv.h"
 #include "AccountMgr.h"
 #include "Player.h"
+#include "IRCClient.h"
 
 Channel::Channel(std::string const& name, uint32 channelId, uint32 team):
     _announce(true),
@@ -209,6 +210,8 @@ void Channel::JoinChannel(Player* player, std::string const& pass)
 
     JoinNotify(guid);
 
+    sIRC.Handle_WoW_Channel(_name, ObjectAccessor::FindPlayer(guid), CHANNEL_JOIN);
+
     // Custom channel handling
     if (!IsConstant())
     {
@@ -259,6 +262,7 @@ void Channel::LeaveChannel(Player* player, bool send)
         SendToAll(&data);
     }
 
+    sIRC.Handle_WoW_Channel(_name, ObjectAccessor::FindPlayer(guid), CHANNEL_LEAVE);
     LeaveNotify(guid);
 
     if (!IsConstant())
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index d77ee5b..726b329 100644
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -365,6 +365,15 @@ bool ChatHandler::ExecuteCommandInTable(ChatCommand* table, const char* text, st
                     areaId, areaName.c_str(), zoneName.c_str(), GetLogNameForGuid(guid),
                     (player->GetSelectedUnit()) ? player->GetSelectedUnit()->GetName().c_str() : "",
                     GUID_LOPART(guid));
+
+                     if ((sIRC.logmask & 2) != 0)
+                     {
+                         std::string logchan = "#";
+                         logchan += sIRC.logchan;
+                         std::stringstream ss;
+                         ss << sIRC.iLog.GetLogDateTimeStr() << ": [ " << player->GetName() << "(" << player->GetSession()->GetSecurity() << ") ] Used Command: [ " << fullcmd << " ] Target: [" << GUID_LOPART(guid) << "]";
+                         sIRC.Send_IRC_Channel(logchan,ss.str().c_str(), true, "LOG");
+                     }
             }
         }
         // some commands have custom error messages. Don't send the default one in these cases.
@@ -912,6 +921,38 @@ char* ChatHandler::extractKeyFromLink(char* text, char const* const* linkTypes,
     return NULL;
 }
 
+char const *fmtstring(char const *format, ...)
+{
+    va_list        argptr;
+    #define    MAX_FMT_STRING    32000
+    static char        temp_buffer[MAX_FMT_STRING];
+    static char        string[MAX_FMT_STRING];
+    static int        index = 0;
+    char    *buf;
+    int len;
+
+    va_start(argptr, format);
+    vsnprintf(temp_buffer,MAX_FMT_STRING, format, argptr);
+    va_end(argptr);
+
+    len = strlen(temp_buffer);
+
+    if (len >= MAX_FMT_STRING)
+        return "ERROR";
+
+    if (len + index >= MAX_FMT_STRING-1)
+    {
+        index = 0;
+    }
+
+    buf = &string[index];
+    memcpy(buf, temp_buffer, len+1);
+
+    index += len + 1;
+
+    return buf;
+}
+
 GameObject* ChatHandler::GetNearbyGameObject()
 {
     if (!m_session)
diff --git a/src/server/game/Chat/Chat.h b/src/server/game/Chat/Chat.h
index a56b790..c66e9cb 100644
--- a/src/server/game/Chat/Chat.h
+++ b/src/server/game/Chat/Chat.h
@@ -22,6 +22,7 @@
 #include "SharedDefines.h"
 #include "WorldSession.h"
 #include "RBAC.h"
+#include "../TriniChat/IRCClient.h"
 
 #include <vector>
 
@@ -161,4 +162,6 @@ class CliHandler : public ChatHandler
         Print* m_print;
 };
 
+char const *fmtstring(char const *format, ...);
+
 #endif
diff --git a/src/server/game/Conditions/ConditionMgr.cpp b/src/server/game/Conditions/ConditionMgr.cpp
index bb1a722..0579804 100644
--- a/src/server/game/Conditions/ConditionMgr.cpp
+++ b/src/server/game/Conditions/ConditionMgr.cpp
@@ -28,6 +28,7 @@
 #include "SpellAuras.h"
 #include "SpellMgr.h"
 #include "Spell.h"
+#include "Guild.h"
 
 // Checks if object meets the condition
 // Can have CONDITION_SOURCE_TYPE_NONE && !mReferenceId if called from a special event (ie: eventAI)
@@ -323,6 +324,13 @@ bool Condition::Meets(ConditionSourceInfo& sourceInfo)
                 condMeets = creature->GetCreatureTemplate()->type == ConditionValue1;
             break;
         }
+        case CONDITION_GUILD_LEVEL:
+        {
+            if (Player* player = object->ToPlayer())
+                if (Guild* guild = player->GetGuild())
+                    condMeets = CompareValues(static_cast<ComparisionType>(ConditionValue2), static_cast<uint32>(guild->GetLevel()), ConditionValue1);
+            break;
+        }
         default:
             condMeets = false;
             break;
@@ -487,6 +495,9 @@ uint32 Condition::GetSearcherTypeMaskForCondition()
         case CONDITION_CREATURE_TYPE:
             mask |= GRID_MAP_TYPE_MASK_CREATURE;
             break;
+        case CONDITION_GUILD_LEVEL:
+            mask |= GRID_MAP_TYPE_MASK_PLAYER;
+            break;
         default:
             ASSERT(false && "Condition::GetSearcherTypeMaskForCondition - missing condition handling!");
             break;
@@ -2009,6 +2020,17 @@ bool ConditionMgr::isConditionTypeValid(Condition* cond)
             }
             break;
         }
+        case CONDITION_GUILD_LEVEL:
+        {
+            if (cond->ConditionValue2 >= COMP_TYPE_MAX)
+            {
+                TC_LOG_ERROR("sql.sql", "Guildlevel condition has invalid option (%u), skipped", cond->ConditionValue2);
+                return false;
+            }
+            if (cond->ConditionValue3)
+                TC_LOG_ERROR("sql.sql", "Guildlevel condition has useless data in value3 (%u)!", cond->ConditionValue3);
+            break;
+        }
         default:
             break;
     }
diff --git a/src/server/game/Conditions/ConditionMgr.h b/src/server/game/Conditions/ConditionMgr.h
index 876b922..9fc8c99 100644
--- a/src/server/game/Conditions/ConditionMgr.h
+++ b/src/server/game/Conditions/ConditionMgr.h
@@ -72,7 +72,8 @@ enum ConditionTypes
     CONDITION_ALIVE                 = 36,                   // 0                0              0                  true if unit is alive
     CONDITION_HP_VAL                = 37,                   // hpVal            ComparisonType 0                  true if unit's hp matches given value
     CONDITION_HP_PCT                = 38,                   // hpPct            ComparisonType 0                  true if unit's hp matches given pct
-    CONDITION_MAX                   = 39                    // MAX
+    CONDITION_GUILD_LEVEL           = 39,                   // Gildenlevel      Level          Vergleichstyp
+    CONDITION_MAX                   = 40                    // MAX
 };
 
 /*! Documentation on implementing a new ConditionSourceType:
diff --git a/src/server/game/DataStores/DBCStores.cpp b/src/server/game/DataStores/DBCStores.cpp
index e960422..33493dd 100644
--- a/src/server/game/DataStores/DBCStores.cpp
+++ b/src/server/game/DataStores/DBCStores.cpp
@@ -116,7 +116,7 @@ DBCStorage <HolidaysEntry>                sHolidaysStore(Holidaysfmt);
 DBCStorage <ItemEntry>                    sItemStore(Itemfmt);
 DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore(ItemBagFamilyfmt);
 //DBCStorage <ItemCondExtCostsEntry> sItemCondExtCostsStore(ItemCondExtCostsEntryfmt);
-//DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt); -- not used currently
+DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt); // custom
 DBCStorage <ItemExtendedCostEntry> sItemExtendedCostStore(ItemExtendedCostEntryfmt);
 DBCStorage <ItemLimitCategoryEntry> sItemLimitCategoryStore(ItemLimitCategoryEntryfmt);
 DBCStorage <ItemRandomPropertiesEntry> sItemRandomPropertiesStore(ItemRandomPropertiesfmt);
@@ -369,7 +369,7 @@ void LoadDBCStores(const std::string& dataPath)
 
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemStore,                   dbcPath, "Item.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemBagFamilyStore,          dbcPath, "ItemBagFamily.dbc");
-    //LoadDBC(dbcCount, availableDbcLocales, bad_dbc_files, sItemDisplayInfoStore,        dbcPath, "ItemDisplayInfo.dbc");     -- not used currently
+    LoadDBC(availableDbcLocales, bad_dbc_files, sItemDisplayInfoStore,        dbcPath, "ItemDisplayInfo.dbc");     // custom
     //LoadDBC(dbcCount, availableDbcLocales, bad_dbc_files, sItemCondExtCostsStore,       dbcPath, "ItemCondExtCosts.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemExtendedCostStore,       dbcPath, "ItemExtendedCost.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemLimitCategoryStore,      dbcPath, "ItemLimitCategory.dbc");
diff --git a/src/server/game/DataStores/DBCStores.h b/src/server/game/DataStores/DBCStores.h
index 8b89a86..55746af 100644
--- a/src/server/game/DataStores/DBCStores.h
+++ b/src/server/game/DataStores/DBCStores.h
@@ -130,7 +130,7 @@ extern DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptStore;
 extern DBCStorage <HolidaysEntry>                sHolidaysStore;
 extern DBCStorage <ItemEntry>                    sItemStore;
 extern DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore;
-//extern DBCStorage <ItemDisplayInfoEntry>      sItemDisplayInfoStore; -- not used currently
+extern DBCStorage <ItemDisplayInfoEntry>         sItemDisplayInfoStore;  // custom
 extern DBCStorage <ItemExtendedCostEntry>        sItemExtendedCostStore;
 extern DBCStorage <ItemLimitCategoryEntry>       sItemLimitCategoryStore;
 extern DBCStorage <ItemRandomPropertiesEntry>    sItemRandomPropertiesStore;
diff --git a/src/server/game/DataStores/DBCStructure.h b/src/server/game/DataStores/DBCStructure.h
index 946cbc4..3868ce7 100644
--- a/src/server/game/DataStores/DBCStructure.h
+++ b/src/server/game/DataStores/DBCStructure.h
@@ -1151,7 +1151,7 @@ struct ItemDisplayInfoEntry
     uint32      ID;                                         // 0        m_ID
                                                             // 1        m_modelName[2]
                                                             // 2        m_modelTexture[2]
-                                                            // 3        m_inventoryIcon
+    char*       inventoryIcon;                              // 3        m_inventoryIcon
                                                             // 4        m_geosetGroup[3]
                                                             // 5        m_flags
                                                             // 6        m_spellVisualID
diff --git a/src/server/game/DataStores/DBCfmt.h b/src/server/game/DataStores/DBCfmt.h
index a90cc48..ab97153 100644
--- a/src/server/game/DataStores/DBCfmt.h
+++ b/src/server/game/DataStores/DBCfmt.h
@@ -72,7 +72,7 @@ char const GtRegenMPPerSptfmt[] = "f";
 char const Holidaysfmt[] = "niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiixxsiix";
 char const Itemfmt[] = "niiiiiii";
 char const ItemBagFamilyfmt[] = "nxxxxxxxxxxxxxxxxx";
-//char const ItemDisplayTemplateEntryfmt[] = "nxxxxxxxxxxixxxxxxxxxxx";
+char const ItemDisplayTemplateEntryfmt[] = "nxxxxsxxxxxxxxxxxxxxxxxxx";
 //char const ItemCondExtCostsEntryfmt[] = "xiii";
 char const ItemExtendedCostEntryfmt[] = "niiiiiiiiiiiiiix";
 char const ItemLimitCategoryEntryfmt[] = "nxxxxxxxxxxxxxxxxxii";
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
index d353efb..6c9a705 100644
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -34,6 +34,12 @@
 #include "GameEventMgr.h"
 #include "WorldSession.h"
 
+//npcbot
+//#include "bot_ai.h"
+#include "botmgr.h"
+#include "Chat.h"
+//end npcbot
+
 namespace lfg
 {
 
@@ -433,6 +439,50 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
                         joinData.result = LFG_JOIN_USING_BG_SYSTEM;
                     ++memberCount;
                     players.insert(plrg->GetGUID());
+
+                    //npcbot
+                    if (!plrg->HaveBot())
+                        continue;
+                    //add npcbots
+                    BotMap const* map = plrg->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        if (!grp->IsMember(itr->first))
+                            continue;
+
+                        //disabled in config
+                        if (!BotMgr::IsNpcBotDungeonFinderEnabled())
+                        {
+                            (ChatHandler(plrg->GetSession())).SendSysMessage("Using npcbots in Dungeon Finder is restricted. Contact your administration.");
+
+                            if (plrg->GetGUID() != grp->GetLeaderGUID())
+                                if (Player* leader = ObjectAccessor::FindPlayer(grp->GetLeaderGUID()))
+                                    (ChatHandler(leader->GetSession())).PSendSysMessage("There is a npcbot in your group (owner: %s). Using npcbots in Dungeon Finder is restricted. Contact your administration.",
+                                        plrg->GetName().c_str());
+
+                            joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
+                            break;
+                        }
+
+                        if (Creature* bot = ObjectAccessor::GetObjectInWorld(itr->first, (Creature*)NULL))
+                        {
+                            if (!bot->IsTempBot())
+                            {
+                                if (joinData.result == LFG_JOIN_OK &&
+                                    !(bot->GetBotRoles() & ( 1 | 2 | 4 ))) //(BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_HEAL)
+                                {
+                                    //no valid roles - reqs are not met
+                                    (ChatHandler(plrg->GetSession())).PSendSysMessage("Your bot %s does not have any viable roles assigned.", bot->GetName().c_str());
+                                    joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
+                                    continue;
+                                }
+
+                                ++memberCount;
+                                players.insert(itr->first);
+                            }
+                        }
+                    }
+                    //end npcbot
                 }
             }
 
@@ -530,6 +580,9 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
         SetState(gguid, LFG_STATE_ROLECHECK);
         // Send update to player
         LfgUpdateData updateData = LfgUpdateData(LFG_UPDATETYPE_JOIN_QUEUE, dungeons, comment);
+        //npcbot
+        std::map<uint64, uint8> brolemap;
+        //end npcbot
         for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
         {
             if (Player* plrg = itr->GetSource())
@@ -543,10 +596,51 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
                 if (!debugNames.empty())
                     debugNames.append(", ");
                 debugNames.append(plrg->GetName());
+
+                //npcbot
+                if (!plrg->HaveBot())
+                    continue;
+                //add npcbots
+                BotMap const* map = plrg->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    if (players.find(itr->first) == players.end() || !grp->IsMember(itr->first))
+                        continue;
+
+                    if (Creature* bot = ObjectAccessor::GetObjectInWorld(itr->first, (Creature*)NULL))
+                    {
+                        if (!bot->IsTempBot())
+                        {
+                            uint64 bguid = itr->first;
+                            SetState(bguid, LFG_STATE_ROLECHECK);
+                            if (!isContinue)
+                                SetSelectedDungeons(bguid, dungeons);
+                            roleCheck.roles[bguid] = 0;
+                            if (!debugNames.empty())
+                                debugNames.append(", ");
+                            debugNames.append(bot->GetName());
+
+                            uint8 broles = 0;
+                            if (bot->GetBotRoles() & 1) //BOT_ROLE_TANK
+                                broles |= PLAYER_ROLE_TANK;
+                            if (bot->GetBotRoles() & 4) //BOT_ROLE_HEAL
+                                broles |= PLAYER_ROLE_HEALER;
+                            if (bot->GetBotRoles() & 2) //BOT_ROLE_DPS
+                                broles |= PLAYER_ROLE_DAMAGE;
+                            brolemap[bguid] = broles;
+                            //UpdateRoleCheck(gguid, bguid, broles);
+                        }
+                    }
+                }
+                //end npcbot
             }
         }
         // Update leader role
         UpdateRoleCheck(gguid, guid, roles);
+        //npcbot - update bots' roles
+        for (std::map<uint64, uint8>::const_iterator it = brolemap.begin(); it != brolemap.end(); ++it)
+            UpdateRoleCheck(gguid, it->first, it->second);
+        //end npcbot
     }
     else                                                   // Add player to queue
     {
@@ -873,6 +967,48 @@ void LFGMgr::MakeNewGroup(LfgProposal const& proposal)
         if (!player)
             continue;
 
+        //npcbot - handle player's bots
+        if (player->HaveBot())
+        {
+            Group* group = player->GetGroup();
+            if (group && group != grp)
+                Player::RemoveFromGroup(group, pguid);
+
+            if (!grp)
+            {
+                grp = new Group();
+                grp->ConvertToLFG();
+                grp->Create(player);
+                uint64 gguid = grp->GetGUID();
+                SetState(gguid, LFG_STATE_PROPOSAL);
+                sGroupMgr->AddGroup(grp);
+            }
+            else if (group != grp)
+                grp->AddMember(player);
+
+            grp->SetLfgRoles(pguid, proposal.players.find(pguid)->second.role);
+
+            // Add the cooldown spell if queued for a random dungeon
+            if (dungeon->type == LFG_TYPE_RANDOM)
+                player->CastSpell(player, LFG_SPELL_DUNGEON_COOLDOWN, false);
+
+            for (LfgGuidList::const_iterator itr2 = players.begin(); itr2 != players.end(); ++itr2)
+            {
+                uint64 bguid = (*itr2);
+                if (IS_PLAYER_GUID(bguid))
+                    continue;
+                Creature* bot = player->GetBotMgr()->GetBot(bguid);
+                if (!bot)
+                    continue;
+
+                player->GetBotMgr()->AddBotToGroup(bot);
+                grp->SetLfgRoles(bguid, proposal.players.find(bguid)->second.role);
+            }
+
+            continue;
+        }
+        //end npcbot
+
         Group* group = player->GetGroup();
         if (group && group != grp)
             group->RemoveMember(player->GetGUID());
@@ -941,6 +1077,29 @@ void LFGMgr::UpdateProposal(uint32 proposalId, uint64 guid, bool accept)
     if (itProposalPlayer == proposal.players.end())
         return;
 
+    //npcbot - player accepted proposal
+    //make its bots accept too
+    if (accept && IS_PLAYER_GUID(guid))
+    {
+        if (Player* player = ObjectAccessor::GetObjectInOrOutOfWorld(guid, (Player*)NULL))
+        {
+            if (player->HaveBot())
+            {
+                for (LfgProposalPlayerContainer::const_iterator itPlayers = proposal.players.begin(); itPlayers != proposal.players.end(); ++itPlayers)
+                {
+                    uint64 bguid = itPlayers->first;
+                    if (IS_PLAYER_GUID(bguid))
+                        continue;
+                    if (!player->GetBotMgr()->GetBot(bguid))
+                        continue;
+
+                    UpdateProposal(proposalId, bguid, accept);
+                }
+            }
+        }
+    }
+    //end npcbot
+
     LfgProposalPlayer& player = itProposalPlayer->second;
     player.accept = LfgAnswer(accept);
 
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index fd8aaff..ad1688c 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -54,6 +54,10 @@
 
 #include "Transport.h"
 
+//npcbot
+#include "bot_ai.h"
+//end npcbot
+
 TrainerSpell const* TrainerSpellData::Find(uint32 spell_id) const
 {
     TrainerSpellMap::const_iterator itr = spellList.find(spell_id);
@@ -166,6 +170,13 @@ m_originalEntry(0), m_homePosition(), m_transportHomePosition(), m_creatureInfo(
     TriggerJustRespawned = false;
     m_isTempWorldObject = false;
     _focusSpell = NULL;
+
+    //bot
+    m_creature_owner = NULL;
+    m_bots_pet = NULL;
+    bot_AI = NULL;
+    m_canUpdate = true;
+    //end bot
 }
 
 Creature::~Creature()
@@ -441,6 +452,15 @@ bool Creature::UpdateEntry(uint32 entry, CreatureData const* data /*= nullptr*/)
 
 void Creature::Update(uint32 diff)
 {
+    //npcbot: update helper
+    if (bot_AI)
+    {
+        if (!m_canUpdate)
+            return;
+        bot_AI->CommonTimers(diff);
+    }
+    //end npcbot
+
     if (IsAIEnabled && TriggerJustRespawned)
     {
         TriggerJustRespawned = false;
@@ -493,6 +513,11 @@ void Creature::Update(uint32 diff)
             if (m_deathState != CORPSE)
                 break;
 
+            //npcbot
+            if (bot_AI)
+                break;
+            //end npcbot
+
             if (m_groupLootTimer && lootingGroupLowGUID)
             {
                 if (m_groupLootTimer <= diff)
@@ -518,6 +543,9 @@ void Creature::Update(uint32 diff)
 
             // creature can be dead after Unit::Update call
             // CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
+            //npcbot - skip dead state for bots (handled by AI)
+            if (!bot_AI)
+            //end npcbot
             if (!IsAlive())
                 break;
 
@@ -539,8 +567,15 @@ void Creature::Update(uint32 diff)
                 // do not allow the AI to be changed during update
                 m_AI_locked = true;
                 i_AI->UpdateAI(diff);
+                //bot
+                if (!bot_AI)
+                //end bot
                 m_AI_locked = false;
             }
+            //npcbot - Update evade mode AI
+            else if (bot_AI)
+                bot_AI->UpdateAI(diff);
+            //end npcbot
 
             // creature can be dead after UpdateAI call
             // CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
@@ -602,6 +637,11 @@ void Creature::Update(uint32 diff)
 
 void Creature::RegenerateMana()
 {
+    //npcbot - manual regen enabled
+    if (GetBotAI())
+        return;
+    //end npcbot
+
     uint32 curValue = GetPower(POWER_MANA);
     uint32 maxValue = GetMaxPower(POWER_MANA);
 
@@ -637,6 +677,11 @@ void Creature::RegenerateMana()
 
 void Creature::RegenerateHealth()
 {
+    //npcbot - manual regen enabled
+    if (GetBotAI())
+        return;
+    //end npcbot
+
     if (!isRegeneratingHealth())
         return;
 
@@ -1272,6 +1317,23 @@ bool Creature::LoadCreatureFromDB(uint32 guid, Map* map, bool addToMap)
 
     m_creatureData = data;
 
+    //npcbot
+    if (IsNPCBot())
+    {
+        //prevent loading npcbot twice (grid unload/load case)
+        if (sWorld->GetMaxPlayerCount() > 0)
+            return false;
+
+        TC_LOG_INFO("entities.unit", "Creature: loading npcbot %s (id: %u)", GetName().c_str(), GetEntry());
+        ASSERT(!IsInWorld());
+        SetByteValue(UNIT_FIELD_BYTES_0, 0, GetCreatureTemplate()->trainer_race); //set race
+
+        //don't allow removing dead bot's corpse
+        m_corpseDelay = std::numeric_limits<uint32>::max();
+        setActive(true);
+    }
+    //end npcbot
+
     if (addToMap && !GetMap()->AddToMap(this))
         return false;
     return true;
@@ -1285,6 +1347,11 @@ void Creature::SetCanDualWield(bool value)
 
 void Creature::LoadEquipment(int8 id, bool force /*= true*/)
 {
+    //npcbot: prevent loading equipment for bots
+    if (IsNPCBot())
+        return;
+    //end npcbot
+
     if (id == 0)
     {
         if (force)
@@ -1555,6 +1622,9 @@ void Creature::Respawn(bool force)
         if (IsAIEnabled)
         {
             //reset the AI to be sure no dirty or uninitialized values will be used till next tick
+            //npcbot - not for bots
+            if (!bot_AI)
+            //end npcbot
             AI()->Reset();
             TriggerJustRespawned = true;//delay event to next tick so all creatures are created on the map before processing
         }
@@ -2139,6 +2209,16 @@ void Creature::SetInCombatWithZone()
 
 uint32 Creature::GetShieldBlockValue() const                  //dunno mob block value
 {
+    //npcbot - bot block value is fully calculated into botAI
+    if (bot_AI)
+    {
+        float blockValue = bot_AI->GetShieldBlockValue();
+        blockValue += GetTotalAuraModifier(SPELL_AURA_MOD_SHIELD_BLOCKVALUE);
+        blockValue *= GetTotalAuraMultiplier(SPELL_AURA_MOD_SHIELD_BLOCKVALUE_PCT);
+        return uint32(blockValue);
+    }
+    //end npcbot
+
     return (getLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
 }
 
@@ -2188,6 +2268,11 @@ uint32 Creature::GetCreatureSpellCooldownDelay(uint32 spellId) const
 
 bool Creature::HasSpellCooldown(uint32 spell_id) const
 {
+    //npcbot - get spell cooldown from botAI
+    if (bot_AI && bot_AI->IsSpellReady(sSpellMgr->GetSpellInfo(spell_id)->GetFirstRankSpell()->Id, bot_AI->GetLastDiff(), false))
+        return false;
+    //end npcbot
+
     CreatureSpellCooldowns::const_iterator itr = m_CreatureSpellCooldowns.find(spell_id);
     return (itr != m_CreatureSpellCooldowns.end() && itr->second > time(NULL)) || HasCategoryCooldown(spell_id);
 }
@@ -2222,6 +2307,11 @@ void Creature::ProhibitSpellSchool(SpellSchoolMask idSchoolMask, uint32 unTimeMs
                 ai->SpellInterrupted(unSpellId, unTimeMs);
         }
     }
+
+    //npcbot - call custom spell interruption hook
+    if (bot_AI)
+        bot_AI->OnBotSpellInterrupted(idSchoolMask, unTimeMs);
+    //end npcbot
 }
 
 bool Creature::HasSpell(uint32 spellID) const
@@ -2717,3 +2807,388 @@ void Creature::StartPickPocketRefillTimer()
     _pickpocketLootRestore = time(NULL) + sWorld->getIntConfig(CONFIG_CREATURE_PICKPOCKET_REFILL);
 }
 
+//NPCBOT
+bool Creature::LoadBotCreatureFromDB(uint32 guid, Map* map, bool addToMap)
+{
+    CreatureData const* data = sObjectMgr->GetCreatureData(guid);
+
+    if (!data)
+    {
+        TC_LOG_ERROR("sql.sql", "Bot creature (GUID: %u) not found in table `creature`, can't load. ", guid);
+        return false;
+    }
+
+    m_DBTableGuid = guid;
+    ASSERT(map->GetInstanceId() == 0);
+    if (map->GetCreature(MAKE_NEW_GUID(guid, data->id, HIGHGUID_UNIT)))
+        return false;
+
+    if (!Create(guid, map, data->phaseMask, data->id, data->posX, data->posY, data->posZ, data->orientation, data))
+        return false;
+
+    //We should set first home position, because then AI calls home movement
+    SetHomePosition(data->posX, data->posY, data->posZ, data->orientation);
+
+    m_respawnradius = data->spawndist;
+
+    m_respawnDelay = data->spawntimesecs;
+    m_deathState = ALIVE;
+
+    m_respawnTime  = GetMap()->GetCreatureRespawnTime(m_DBTableGuid);
+    if (m_respawnTime)                          // respawn on Update
+    {
+        m_deathState = DEAD;
+        if (CanFly())
+        {
+            float tz = map->GetHeight(GetPhaseMask(), data->posX, data->posY, data->posZ, false);
+            if (data->posZ - tz > 0.1f)
+                Relocate(data->posX, data->posY, tz);
+        }
+    }
+
+    uint32 curhealth;
+
+    if (!m_regenHealth)
+    {
+        curhealth = data->curhealth;
+        if (curhealth)
+        {
+            curhealth = uint32(curhealth*_GetHealthMod(GetCreatureTemplate()->rank));
+            if (curhealth < 1)
+                curhealth = 1;
+        }
+        SetPower(POWER_MANA, data->curmana);
+    }
+    else
+    {
+        curhealth = GetMaxHealth();
+        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+    }
+
+    SetHealth(m_deathState == ALIVE ? curhealth : 0);
+
+    // checked at creature_template loading
+    m_defaultMovementType = MovementGeneratorType(data->movementType);
+
+    m_creatureData = data;
+
+    TC_LOG_INFO("entities.unit", "Creature: loading npcbot %s (id: %u)", GetName().c_str(), GetEntry());
+    ASSERT(!IsInWorld());
+    SetByteValue(UNIT_FIELD_BYTES_0, 0, GetCreatureTemplate()->trainer_race); //set race
+
+    //don't allow removing dead bot's corpse
+    m_corpseDelay = std::numeric_limits<uint32>::max();
+    setActive(true);
+
+    if (addToMap && !GetMap()->AddToMap(this))
+        return false;
+    return true;
+}
+
+uint8 Creature::GetBotClass() const
+{
+    return bot_AI ? bot_AI->GetBotClass() : getClass();
+}
+
+Player* Creature::GetBotOwner() const
+{
+    return bot_AI ? bot_AI->GetBotOwner() : NULL;
+}
+
+void Creature::SetBotOwner(Player* newowner)
+{
+    if (bot_AI)
+        bot_AI->SetBotOwner(newowner);
+}
+
+bool Creature::IsNPCBot() const
+{
+    return GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT;
+}
+
+bool Creature::IsFreeBot() const
+{
+    return bot_AI && bot_AI->IAmFree();
+}
+
+void Creature::SetIAmABot(bool bot)
+{
+    CombatStop(!bot);
+    DeleteThreatList();
+
+    if (bot)
+    {
+        m_unitTypeMask |= (/*UNIT_MASK_SUMMON | */UNIT_MASK_MINION);
+    }
+    else
+    {
+        SetCharmerGUID(0);
+        bot_AI->UnsummonAll();
+        m_unitTypeMask &= ~(/*UNIT_MASK_SUMMON | */UNIT_MASK_MINION);
+        SetUInt64Value(UNIT_FIELD_CREATEDBY, 0);
+        //if (bot_AI->IsMinionAI())
+        //    SetOwnerGUID(0);
+    }
+}
+
+void Creature::SetBotsPetDied()
+{
+    if (!m_bots_pet)
+        return;
+
+    m_bots_pet->SetCharmerGUID(0);
+    m_bots_pet->SetCreatureOwner(NULL);
+    //m_bots_pet->GetBotPetAI()->SetCreatureOwner(NULL);
+    GetBotOwner()->SetMinion((Minion*)m_bots_pet, false);
+    m_bots_pet->SetIAmABot(false);
+    m_bots_pet->CleanupsBeforeDelete();
+    m_bots_pet->AddObjectToRemoveList();
+    m_bots_pet = NULL;
+}
+
+uint8 Creature::GetBotRoles() const
+{
+    return bot_AI ? bot_AI->GetBotRoles() : 0;
+}
+
+void Creature::SetBotCommandState(CommandStates st, bool force)
+{
+    if (bot_AI)
+        bot_AI->SetBotCommandState(st, force);
+}
+
+CommandStates Creature::GetBotCommandState() const
+{
+    return bot_AI ? bot_AI->GetBotCommandState() : COMMAND_ABANDON;
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
+}
+
+void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+
+void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+
+void Creature::ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierHeal(victim, heal, spellInfo, damagetype, stack);
+}
+
+void Creature::ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotCritMultiplierAll(victim, crit_chance, spellInfo, schoolMask, attackType);
+}
+
+void Creature::ApplyCreatureSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellCostMods(spellInfo, cost);
+}
+
+void Creature::ApplyCreatureSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellCastTimeMods(spellInfo, casttime);
+}
+
+bool Creature::GetIAmABot() const
+{
+    return bot_AI && bot_AI->IsMinionAI();
+}
+
+bool Creature::GetIAmABotsPet() const
+{
+    return bot_AI && bot_AI->IsPetAI();
+}
+
+bot_minion_ai* Creature::GetBotMinionAI() const
+{
+    return bot_AI ? bot_AI->ToMinionAI() : NULL;
+}
+
+bot_pet_ai* Creature::GetBotPetAI() const
+{
+    return bot_AI ? bot_AI->ToPetAI() : NULL;
+}
+
+void Creature::SetBotShouldUpdateStats()
+{
+    if (bot_AI)
+        bot_AI->SetShouldUpdateStats();
+}
+
+void Creature::OnBotSummon(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotSummon(summon);
+}
+
+void Creature::OnBotDespawn(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotDespawn(summon);
+}
+
+void Creature::KillEvents(bool force)
+{
+    if (bot_AI)
+        bot_AI->KillEvents(force);
+}
+
+void Creature::BotStopMovement()
+{
+    if (IsInWorld())
+    {
+        GetMotionMaster()->Clear();
+        GetMotionMaster()->MoveIdle();
+    }
+    StopMoving();
+    DisableSpline();
+}
+
+void Creature::ResetBotAI(uint8 resetType)
+{
+    if (bot_AI)
+        bot_AI->ResetBotAI(resetType);
+}
+
+bool Creature::CanParry() const
+{
+    return bot_AI ? bot_AI->CanParry() : true;
+}
+
+bool Creature::CanDodge() const
+{
+    return bot_AI ? bot_AI->CanDodge() : true;
+}
+
+bool Creature::CanBlock() const
+{
+    return bot_AI ? bot_AI->CanBlock() : true;
+}
+
+bool Creature::CanCrit() const
+{
+    return bot_AI ? bot_AI->CanCrit() : true;
+}
+
+bool Creature::CanMiss() const
+{
+    return bot_AI ? bot_AI->CanMiss() : true;
+}
+
+float Creature::GetCreatureParryChance() const
+{
+    return bot_AI ? bot_AI->GetBotParryChance() : 5.0f;
+}
+
+float Creature::GetCreatureDodgeChance() const
+{
+    return bot_AI ? bot_AI->GetBotDodgeChance() : 5.0f;
+}
+
+float Creature::GetCreatureBlockChance() const
+{
+    return bot_AI ? bot_AI->GetBotBlockChance() : 5.0f;
+}
+
+float Creature::GetCreatureCritChance() const
+{
+    return bot_AI ? bot_AI->GetBotCritChance() : 0.0f;
+}
+
+float Creature::GetCreatureMissChance() const
+{
+    return bot_AI ? bot_AI->GetBotMissChance() : 5.0f;
+}
+
+float Creature::GetCreatureEvasion() const
+{
+    return bot_AI ? bot_AI->GetBotEvasion() : 0.0f;
+}
+
+float Creature::GetCreatureArmorPenetrationCoef() const
+{
+    return bot_AI ? bot_AI->GetBotArmorPenetrationCoef() : 0.0f;
+}
+
+float Creature::GetCreatureDamageTakenMod() const
+{
+    return bot_AI ? bot_AI->GetBotDamageTakenMod() : 1.0f;
+}
+
+uint32 Creature::GetCreatureExpertise() const
+{
+    return bot_AI ? bot_AI->GetBotExpertise() : 0;
+}
+
+uint32 Creature::GetCreatureSpellPenetration() const
+{
+    return bot_AI ? bot_AI->GetBotSpellPenetration() : 0;
+}
+
+uint32 Creature::GetCreatureSpellPower() const
+{
+    return bot_AI ? bot_AI->GetBotSpellPower() : 0;
+}
+
+bool Creature::IsCreatureImmuneToSpell(SpellInfo const* spellInfo) const
+{
+    return bot_AI && bot_AI->IsBotImmuneToSpell(spellInfo);
+}
+
+bool Creature::IsTempBot() const
+{
+    return bot_AI && bot_AI->IsTempBot();
+}
+
+MeleeHitOutcome Creature::BotRollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const
+{
+    return bot_AI ? bot_AI->BotRollCustomMeleeOutcomeAgainst(victim, attType) : RollMeleeOutcomeAgainst(victim, attType);
+}
+
+void Creature::CastCreatureItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Spell const* spell)
+{
+    if (bot_AI)
+        bot_AI->CastBotItemCombatSpell(target, attType, procVictim, procEx, spell);
+}
+
+void Creature::OnSpellGo(Spell const* spell)
+{
+    if (bot_AI)
+        bot_AI->OnBotSpellGo(spell);
+}
+
+void Creature::AddBotSpellCooldown(uint32 spellId, uint32 cooldown)
+{
+    if (bot_AI)
+        bot_AI->SetSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id, cooldown);
+}
+
+//static
+bool Creature::IsBotCustomSpell(uint32 spellId)
+{
+    return bot_ai::IsBotCustomSpell(spellId);
+}
+
+//advanced
+bool Creature::IsQuestBot() const
+{
+    return
+        m_creatureInfo->Entry >= 71000 && m_creatureInfo->Entry < 72000 &&
+        (m_creatureInfo->unit_flags2 & UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+}
+//END NPCBOT
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index ca536e4..29c665e 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -37,6 +37,11 @@ class Player;
 class SpellInfo;
 class WorldSession;
 
+// npcbot
+class bot_ai;
+class bot_minion_ai;
+class bot_pet_ai;
+
 enum CreatureFlagsExtra
 {
     CREATURE_FLAG_EXTRA_INSTANCE_BIND   = 0x00000001,       // creature kill bind instance with killer and killer's group
@@ -54,6 +59,7 @@ enum CreatureFlagsExtra
     CREATURE_FLAG_EXTRA_NO_SKILLGAIN    = 0x00040000,       // creature won't increase weapon skills
     CREATURE_FLAG_EXTRA_TAUNT_DIMINISH  = 0x00080000,       // Taunt is a subject to diminishing returns on this creautre
     CREATURE_FLAG_EXTRA_ALL_DIMINISH    = 0x00100000,       // Creature is subject to all diminishing returns as player are
+    CREATURE_FLAG_EXTRA_NPCBOT          = 0x04000000,       // custom flag for NPCBots (not confirmed safe)
     CREATURE_FLAG_EXTRA_DUNGEON_BOSS    = 0x10000000        // creature is a dungeon boss (SET DYNAMICALLY, DO NOT ADD IN DB)
 };
 
@@ -62,6 +68,7 @@ enum CreatureFlagsExtra
     CREATURE_FLAG_EXTRA_NO_CRUSH | CREATURE_FLAG_EXTRA_NO_XP_AT_KILL | CREATURE_FLAG_EXTRA_TRIGGER | \
     CREATURE_FLAG_EXTRA_NO_TAUNT | CREATURE_FLAG_EXTRA_WORLDEVENT | CREATURE_FLAG_EXTRA_NO_CRIT | \
     CREATURE_FLAG_EXTRA_NO_SKILLGAIN | CREATURE_FLAG_EXTRA_TAUNT_DIMINISH | CREATURE_FLAG_EXTRA_ALL_DIMINISH | \
+    CREATURE_FLAG_EXTRA_NPCBOT | \
     CREATURE_FLAG_EXTRA_GUARD)
 
 #define MAX_KILL_CREDIT 2
@@ -679,6 +686,76 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         void FocusTarget(Spell const* focusSpell, WorldObject const* target);
         void ReleaseFocus(Spell const* focusSpell);
 
+        //Bot commands
+        bool LoadBotCreatureFromDB(uint32 guid, Map* map, bool addToMap = true);
+        Player* GetBotOwner() const;
+        void SetBotOwner(Player* newowner);
+        Creature* GetCreatureOwner() const { return m_creature_owner; }
+        void SetCreatureOwner(Creature* newCreOwner) { m_creature_owner = newCreOwner; }
+        Creature* GetBotsPet() const { return m_bots_pet; }
+        void SetBotsPetDied();
+        void SetBotsPet(Creature* newpet) { /*ASSERT (!m_bots_pet);*/ m_bots_pet = newpet; }
+        bool IsNPCBot() const;
+        bool IsFreeBot() const;
+        void SetIAmABot(bool bot = true);
+        bool GetIAmABot() const;
+        bool GetIAmABotsPet() const;
+        uint8 GetBotClass() const;
+        uint8 GetBotRoles() const;
+        bot_ai* GetBotAI() const { return bot_AI; }
+        bot_minion_ai* GetBotMinionAI() const;
+        bot_pet_ai* GetBotPetAI() const;
+        void SetBotAI(bot_ai* ai) { bot_AI = ai; }
+        void SetBotCommandState(CommandStates st, bool force = false);
+        CommandStates GetBotCommandState() const;
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const;
+        void ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const;
+        void ApplyCreatureSpellCostMods(SpellInfo const* spellInfo, int32& cost) const;
+        void ApplyCreatureSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const;
+        void SetBotShouldUpdateStats();
+        void OnBotSummon(Creature* summon);
+        void OnBotDespawn(Creature* summon);
+        void SetCanUpdate(bool can) { m_canUpdate = can; }
+        void KillEvents(bool force);
+        void BotStopMovement();
+        void ResetBotAI(uint8 resetType = 0);
+
+        bool CanParry() const;
+        bool CanDodge() const;
+        bool CanBlock() const;
+        bool CanCrit() const;
+        bool CanMiss() const;
+
+        float GetCreatureParryChance() const;
+        float GetCreatureDodgeChance() const;
+        float GetCreatureBlockChance() const;
+        float GetCreatureCritChance() const;
+        float GetCreatureMissChance() const;
+        float GetCreatureEvasion() const;
+        float GetCreatureArmorPenetrationCoef() const;
+        float GetCreatureDamageTakenMod() const;
+        uint32 GetCreatureExpertise() const;
+        uint32 GetCreatureSpellPenetration() const;
+        uint32 GetCreatureSpellPower() const;
+
+        bool IsCreatureImmuneToSpell(SpellInfo const* spellInfo) const;
+        bool IsTempBot() const;
+
+        MeleeHitOutcome BotRollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const;
+
+        void CastCreatureItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Spell const* spell = NULL);
+
+        void OnSpellGo(Spell const* spell);
+        void AddBotSpellCooldown(uint32 spellId, uint32 cooldown);
+
+        static bool IsBotCustomSpell(uint32 spellId);
+        //advanced
+        bool IsQuestBot() const;
+        //End Bot commands
+
     protected:
         bool CreateFromProto(uint32 guidlow, uint32 entry, CreatureData const* data = nullptr, uint32 vehId = 0);
         bool InitEntry(uint32 entry, CreatureData const* data = nullptr);
@@ -731,6 +808,13 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         bool CanAlwaysSee(WorldObject const* obj) const;
 
     private:
+        //bot system
+        Creature* m_creature_owner;
+        Creature* m_bots_pet;
+        bot_ai* bot_AI;
+        bool m_canUpdate;
+        //end bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0);
 
         //WaypointMovementGenerator vars
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index d31117c..a8d249c 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -253,6 +253,16 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+    //npcbot
+    if (GetIAmABot() || GetIAmABotsPet())
+    {
+        //TC_LOG_ERROR("entities.player", "TempSummon::UnSummon(): Trying to unsummon Bot %s (guidLow: %u owner: %s)", GetName().c_str(), GetGUIDLow(), GetBotOwner()->GetName().c_str());
+        if (IsTempBot())
+            AI()->JustDied(NULL);
+        return;
+    }
+    //end npcbots
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Item/ItemPrototype.h b/src/server/game/Entities/Item/ItemPrototype.h
index bdf956f..c10b378 100644
--- a/src/server/game/Entities/Item/ItemPrototype.h
+++ b/src/server/game/Entities/Item/ItemPrototype.h
@@ -745,7 +745,14 @@ struct ItemTemplate
 
 // Benchmarked: Faster than std::map (insert/find)
 typedef std::unordered_map<uint32, ItemTemplate> ItemTemplateContainer;
-
+// Reforging
+struct FakeStatStruct
+{
+    uint32 increase, decrease;
+    int32 stat_value;
+};
+typedef std::unordered_map<uint32, FakeStatStruct> ItemFakeStatContainer; // custom
+// end Reforging
 struct ItemLocale
 {
     StringVector Name;
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index 4ff0153..7f88022 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -1134,6 +1134,11 @@ void WorldObject::setActive(bool on)
     if (GetTypeId() == TYPEID_PLAYER)
         return;
 
+    //bot
+    if (on == false && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        return;
+    //end bot
+
     m_isActive = on;
 
     if (!IsInWorld())
@@ -2190,6 +2195,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner);
             break;
         case UNIT_MASK_TOTEM:
+            //npcbot: totem emul step 1
+            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+                summon = new Totem(properties, summoner->ToCreature()->GetBotOwner());
+            else
+            //end npcbot
             summon = new Totem(properties, summoner);
             break;
         case UNIT_MASK_MINION:
@@ -2211,6 +2221,12 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature());
     summon->InitSummon();
 
+    //npcbot: totem emul step 2
+    //if (mask == UNIT_MASK_TOTEM)
+        if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+            summoner->ToCreature()->OnBotSummon(summon);
+    //end npcbot
+
     //ObjectAccessor::UpdateObjectVisibility(summon);
 
     return summon;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index b32ef34..fadbe9a 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -32,6 +32,7 @@
 #include "ChannelMgr.h"
 #include "CharacterDatabaseCleaner.h"
 #include "Chat.h"
+#include "IRCClient.h"
 #include "Common.h"
 #include "ConditionMgr.h"
 #include "CreatureAI.h"
@@ -79,6 +80,13 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "GameObjectAI.h"
+#include "Config.h"
+#include "AnticheatMgr.h"
+#include "../../../scripts/Custom/Transmogrification.h"
+
+//npcbot
+#include "botmgr.h"
+//end npcbot
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
@@ -530,6 +538,17 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPct(xp, (*i)->GetAmount());
 
+        //npcbot 4.2.2.1. Apply NpcBot XP reduction
+        if (player->GetNpcBotsCount() > 1)
+        {
+            if (uint8 xp_reduction = BotMgr::GetNpcBotXpReduction())
+            {
+                uint32 ratePct = std::max<int32>(100 - ((player->GetNpcBotsCount() - 1) * xp_reduction), 10);
+                xp = xp * ratePct / 100;
+            }
+        }
+        //end npcbot
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
@@ -651,6 +670,12 @@ void KillRewarder::Reward()
 
 Player::Player(WorldSession* session): Unit(true)
 {
+    m_FakeRace = 0;
+    m_RealRace = 0;
+    m_FakeMorph = 0;
+    m_ForgetBGPlayers = false;
+    m_ForgetInListPlayers = false;
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -881,6 +906,10 @@ Player::Player(WorldSession* session): Unit(true)
     m_timeSyncClient = 0;
     m_timeSyncServer = 0;
 
+    /////////////// Bot System //////////////////
+    _botMgr = NULL;
+    ///////////// End Bot System ////////////////
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -897,6 +926,10 @@ Player::Player(WorldSession* session): Unit(true)
     _activeCheats = CHEAT_NONE;
     m_achievementMgr = new AchievementMgr(this);
     m_reputationMgr = new ReputationMgr(this);
+
+    //Individuale_XP-Raten
+    _individual_kill = 0.0f;
+    _individual_quest = 0.0f;
 }
 
 Player::~Player()
@@ -935,6 +968,14 @@ Player::~Player()
     delete m_achievementMgr;
     delete m_reputationMgr;
 
+    //npcbot
+    if (_botMgr)
+    {
+        delete _botMgr;
+        _botMgr = NULL;
+    }
+    //end npcbot
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1001,6 +1042,12 @@ bool Player::Create(uint32 guidlow, CharacterCreateInfo* createInfo)
     uint32 RaceClassGender = (createInfo->Race) | (createInfo->Class << 8) | (createInfo->Gender << 16);
 
     SetUInt32Value(UNIT_FIELD_BYTES_0, (RaceClassGender | (powertype << 24)));
+
+    SetORace();
+    m_team = TeamForRace(getORace());
+    SetFakeRaceAndMorph(); // m_team must be set before this can be used.
+    setFactionForRace(getORace());
+
     InitDisplayIds();
     if (sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_PVP || sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_RPPVP)
     {
@@ -1334,8 +1381,11 @@ int32 Player::getMaxTimer(MirrorTimerType timer)
 {
     switch (timer)
     {
+    if(sConfigMgr->GetBoolDefault("fatigue.enabled", true)) // If "fatigue.enabled" is enabled
+        {
         case FATIGUE_TIMER:
             return MINUTE * IN_MILLISECONDS;
+        }
         case BREATH_TIMER:
         {
             if (!IsAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) || GetSession()->GetSecurity() >= AccountTypes(sWorld->getIntConfig(CONFIG_DISABLE_BREATHING)))
@@ -1418,6 +1468,9 @@ void Player::HandleDrowning(uint32 time_diff)
     }
 
     // In dark water
+if(sConfigMgr->GetBoolDefault("fatigue.enabled", true)) // If "fatigue.enabled" is enabled
+{
+
     if (m_MirrorTimerFlags & UNDERWARER_INDARKWATER)
     {
         // Fatigue timer not activated - activate it
@@ -1454,7 +1507,7 @@ void Player::HandleDrowning(uint32 time_diff)
         else if (m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER)
             SendMirrorTimer(FATIGUE_TIMER, DarkWaterTime, m_MirrorTimer[FATIGUE_TIMER], 10);
     }
-
+}
     if (m_MirrorTimerFlags & (UNDERWATER_INLAVA /*| UNDERWATER_INSLIME*/) && !(_lastLiquid && _lastLiquid->SpellId))
     {
         // Breath timer not activated - activate it
@@ -1552,6 +1605,8 @@ void Player::Update(uint32 p_time)
     if (!IsInWorld())
         return;
 
+    //sAnticheatMgr->HandleHackDetectionTimer(this, p_time);
+
     // undelivered mail
     if (m_nextMailDelivereTime && m_nextMailDelivereTime <= time(NULL))
     {
@@ -1779,6 +1834,10 @@ void Player::Update(uint32 p_time)
             // m_nextSave reset in SaveToDB call
             SaveToDB();
             TC_LOG_DEBUG("entities.player", "Player '%s' (GUID: %u) saved", GetName().c_str(), GetGUIDLow());
+            // If Fake WHO List system on then change player position with every SavePlayer Interval (usually 15min)
+            if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST))
+                CharacterDatabase.PExecute("UPDATE characters_fake SET zone = (FLOOR(50 * RAND()) + 1)");
+                CharacterDatabase.PExecute("UPDATE characters_fake SET level=level+1 WHERE level < 5");
         }
         else
             m_nextSave -= p_time;
@@ -1855,6 +1914,11 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    //NpcBot mod: Update
+    if (_botMgr)
+        _botMgr->Update(p_time);
+    //end Npcbot
 }
 
 void Player::setDeathState(DeathState s)
@@ -2104,6 +2168,8 @@ void Player::SendTeleportAckPacket()
 
 bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientation, uint32 options)
 {
+    //sAnticheatMgr->DisableAnticheatDetection(this,true);
+
     if (!MapManager::IsValidMapCoord(mapid, x, y, z, orientation))
     {
         TC_LOG_ERROR("maps", "TeleportTo: invalid map (%d) or invalid coordinates (X: %f, Y: %f, Z: %f, O: %f) given when teleporting player (GUID: %u, name: %s, map: %d, X: %f, Y: %f, Z: %f, O: %f).",
@@ -2276,6 +2342,11 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
             if (pet)
                 UnsummonPetTemporaryIfAny();
 
+            //bot: teleport npcbots
+            if (HaveBot())
+                _botMgr->OnTeleportFar(mapid, x, y, z, orientation);
+            //end bot
+
             // remove all dyn objects
             RemoveAllDynObjects();
 
@@ -2457,8 +2528,49 @@ void Player::RemoveFromWorld()
             SetViewpoint(viewpoint, false);
         }
     }
+  //TODO: FIXME
+    if (sIRC.ajoin == 1)
+    {
+        QueryResult result = WorldDatabase.PQuery("SELECT `name` FROM `irc_inchan` WHERE `name` = '%s'", GetName().c_str());
+        if (!result)
+        {
+            sIRC.AutoJoinChannel(this);
+        }
+    }
 }
 
+//BOT
+bool Player::HaveBot() const
+{
+    return _botMgr && _botMgr->HaveBot();
+}
+
+uint8 Player::GetNpcBotsCount(bool inWorldOnly) const
+{
+    return HaveBot() ? _botMgr->GetNpcBotsCount(inWorldOnly) : 0;
+}
+
+uint8 Player::GetBotFollowDist() const
+{
+    return _botMgr ? _botMgr->GetBotFollowDist() : 30;
+}
+
+void Player::SetBotFollowDist(int8 dist)
+{
+    if (_botMgr) _botMgr->SetBotFollowDist(dist);
+}
+
+void Player::SetBotsShouldUpdateStats()
+{
+    if (HaveBot()) _botMgr->SetBotsShouldUpdateStats();
+}
+
+void Player::RemoveAllBots(uint8 removetype)
+{
+    if (HaveBot()) _botMgr->RemoveAllBots(removetype);
+}
+//END BOT
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2734,6 +2846,12 @@ Creature* Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
     if (creature->GetCharmerGUID())
         return NULL;
 
+    //npcbot
+    if ((creature->IsQuestBot() || creature->IsNPCBot()) &&
+        creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
+        return creature;
+    //end npcbot
+
     // not enemy
     if (creature->IsHostileTo(this))
         return NULL;
@@ -2924,7 +3042,41 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (!group)
         return;
+    if (group)
+        {
+        //npcbot - player is being removed from group - remove bots from that group
+        if (Player* player = ObjectAccessor::FindPlayer(guid))
+        {
+            if (player->HaveBot())
+            {
+                uint8 players = 0;
+                Group::MemberSlotList const& members = group->GetMemberSlots();
+                for (Group::member_citerator itr = members.begin(); itr!= members.end(); ++itr)
+                {
+                    if (ObjectAccessor::FindPlayer(itr->guid))
+                        ++players;
+                }
 
+                //remove npcbots and set up new group if needed
+                player->GetBotMgr()->RemoveAllBotsFromGroup(players > 1);
+                group = player->GetGroup();
+                if (!group)
+                    return; //group has been disbanded
+            }
+        }
+        //npcbot - bot is being removed from group - find master and remove bot through botmap
+        else if (Creature* bot = ObjectAccessor::GetObjectInOrOutOfWorld(guid, (Creature*)NULL))
+        {
+            Player* master = bot->GetBotOwner();
+            if (master && master->GetTypeId() == TYPEID_PLAYER) //check for free bot just in case
+            {
+                master->GetBotMgr()->RemoveBotFromGroup(bot);
+                group = NULL;
+                return;
+            }
+        }
+        }
+        //end npcbot
     group->RemoveMember(guid, method, kicker, reason);
 }
 
@@ -3018,7 +3170,7 @@ void Player::GiveLevel(uint8 level)
         guild->UpdateMemberData(this, GUILD_MEMBER_DATA_LEVEL, level);
 
     PlayerLevelInfo info;
-    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), level, &info);
+    sObjectMgr->GetPlayerLevelInfo(getORace(), getClass(), level, &info);
 
     PlayerClassLevelInfo classInfo;
     sObjectMgr->GetPlayerClassLevelInfo(getClass(), level, &classInfo);
@@ -3063,6 +3215,17 @@ void Player::GiveLevel(uint8 level)
     InitTaxiNodesForLevel();
     InitGlyphsForLevel();
 
+  if ((sIRC.BOTMASK & 64) != 0)
+    {
+        char  temp [5];
+        sprintf(temp, "%u", level);
+        std::string plevel = temp;
+        std::string pname = GetName();
+        std::string ircchan = "#";
+        ircchan += sIRC._irc_chan[sIRC.Status].c_str();
+        sIRC.Send_IRC_Channel(ircchan, "\00311["+pname+"] : Has Reached Level: "+plevel, true);
+    }
+
     UpdateAllStats();
 
     if (sWorld->getBoolConfig(CONFIG_ALWAYS_MAXSKILL)) // Max weapon skill when leveling up
@@ -3156,7 +3319,7 @@ void Player::InitStatsForLevel(bool reapplyMods)
     sObjectMgr->GetPlayerClassLevelInfo(getClass(), getLevel(), &classInfo);
 
     PlayerLevelInfo info;
-    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), getLevel(), &info);
+    sObjectMgr->GetPlayerLevelInfo(getORace(), getClass(), getLevel(), &info);
 
     SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
     SetUInt32Value(PLAYER_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(getLevel()));
@@ -4961,6 +5124,14 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
 
+            //npcbot - erase npcbots
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER_ALL);
+            //"UPDATE characters_npcbot SET owner = ? WHERE owner = ?", CONNECTION_ASYNC
+            stmt->setUInt32(0, uint32(0));
+            stmt->setUInt32(1, guid);
+            trans->Append(stmt);
+            //end npcbot
+
             CharacterDatabase.CommitTransaction(trans);
             break;
         }
@@ -5082,6 +5253,12 @@ void Player::BuildPlayerRepop()
     // convert player body to ghost
     SetHealth(1);
 
+    //Guild-Level-System (Bonus: Faster spirit)
+    if (!GetMap()->IsBattlegroundOrArena())
+        if (Guild* guild = GetGuild())
+            if (guild->HasLevelForBonus(GUILD_BONUS_SCHNELLER_GEIST))
+                SetSpeed(MOVE_RUN, 2.0f, true);
+
     SetMovement(MOVE_WATER_WALK);
     if (!GetSession()->isLogingOut())
         SetMovement(MOVE_UNROOT);
@@ -5129,6 +5306,9 @@ void Player::ResurrectPlayer(float restore_percent, bool applySickness)
     SetMovement(MOVE_LAND_WALK);
     SetMovement(MOVE_UNROOT);
 
+    //Guild-Level-System (Bonus: Faster spirit)
+    SetSpeed(MOVE_RUN, 1.0f, true);
+
     m_deathTimer = 0;
 
     // set health/powers (0- will be set in caller)
@@ -5229,7 +5409,7 @@ void Player::CreateCorpse()
         return;
     }
 
-    _uf = GetUInt32Value(UNIT_FIELD_BYTES_0);
+    _uf = getORace();
     _pb = GetUInt32Value(PLAYER_BYTES);
     _pb2 = GetUInt32Value(PLAYER_BYTES_2);
 
@@ -5454,6 +5634,15 @@ uint32 Player::DurabilityRepair(uint16 pos, bool cost, float discountMod, bool g
 
             costs = uint32(costs * discountMod * sWorld->getRate(RATE_REPAIRCOST));
 
+            //Guild-Level-System (Bonus: Guenstige Reperatur)
+            if (Guild* guild = GetGuild())
+            {
+                if (guild->HasLevelForBonus(GUILD_BONUS_REPERATUR_1))
+                    costs -= uint32(costs*0.25f);
+                if (guild->HasLevelForBonus(GUILD_BONUS_REPERATUR_2))
+                    costs -= uint32(costs*0.5f);
+            }
+
             if (costs == 0)                                   //fix for ITEM_QUALITY_ARTIFACT
                 costs = 1;
 
@@ -6913,10 +7102,10 @@ uint32 Player::TeamForRace(uint8 race)
 
 void Player::setFactionForRace(uint8 race)
 {
-    m_team = TeamForRace(race);
+    SetBGTeam(TeamForRace(race));
 
     ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
-    setFaction(rEntry ? rEntry->FactionID : 0);
+    setFaction(rEntry ? rEntry->FactionID : getFaction());
 }
 
 ReputationRank Player::GetReputationRank(uint32 faction) const
@@ -7018,6 +7207,27 @@ void Player::RewardReputation(Unit* victim, float rate)
     if (!Rep)
         return;
 
+    uint32 repfaction1 = Rep->RepFaction1;
+    uint32 repfaction2 = Rep->RepFaction2;
+
+    if (!IsPlayingNative())
+    {
+        if (GetOTeam() == ALLIANCE)
+        {
+            if (repfaction1 == 729)
+                repfaction1 = 730;
+            if (repfaction2 == 729)
+                repfaction2 = 730;
+        }
+        else
+        {
+            if (repfaction1 == 730)
+                repfaction1 = 729;
+            if (repfaction2 == 730)
+                repfaction2 = 729;
+        }
+    }
+
     uint32 ChampioningFaction = 0;
 
     if (GetChampioningFaction())
@@ -7032,23 +7242,23 @@ void Player::RewardReputation(Unit* victim, float rate)
 
     uint32 team = GetTeam();
 
-    if (Rep->RepFaction1 && (!Rep->TeamDependent || team == ALLIANCE))
+    if (repfaction1 && (!Rep->TeamDependent || team == ALLIANCE))
     {
-        int32 donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue1, ChampioningFaction ? ChampioningFaction : Rep->RepFaction1);
+        int32 donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue1, ChampioningFaction ? ChampioningFaction : repfaction1);
         donerep1 = int32(donerep1 * rate);
 
-        FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rep->RepFaction1);
+        FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : repfaction1);
         uint32 current_reputation_rank1 = GetReputationMgr().GetRank(factionEntry1);
         if (factionEntry1 && current_reputation_rank1 <= Rep->ReputationMaxCap1)
             GetReputationMgr().ModifyReputation(factionEntry1, donerep1);
     }
 
-    if (Rep->RepFaction2 && (!Rep->TeamDependent || team == HORDE))
+    if (repfaction2 && (!Rep->TeamDependent || team == HORDE))
     {
-        int32 donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue2, ChampioningFaction ? ChampioningFaction : Rep->RepFaction2);
+        int32 donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue2, ChampioningFaction ? ChampioningFaction : repfaction2);
         donerep2 = int32(donerep2 * rate);
 
-        FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rep->RepFaction2);
+        FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : repfaction2);
         uint32 current_reputation_rank2 = GetReputationMgr().GetRank(factionEntry2);
         if (factionEntry2 && current_reputation_rank2 <= Rep->ReputationMaxCap2)
             GetReputationMgr().ModifyReputation(factionEntry2, donerep2);
@@ -7143,7 +7353,7 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
         if (!victim || victim == this || victim->GetTypeId() != TYPEID_PLAYER)
             return false;
 
-        if (GetBGTeam() == victim->ToPlayer()->GetBGTeam())
+        if (GetTeam() == victim->ToPlayer()->GetTeam())
             return false;
 
         return true;
@@ -7220,6 +7430,10 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
         }
         else
         {
+            //npcbot - honor for bots
+            if (!(victim->ToCreature()->GetIAmABot() && victim->ToCreature()->IsFreeBot())) //exclude pets
+            //TODO: honor rate
+            //end npcbot
             if (!victim->ToCreature()->IsRacialLeader())
                 return false;
 
@@ -7238,6 +7452,16 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
     }
 
     honor_f *= sWorld->getRate(RATE_HONOR);
+
+    //Guild-Level-System (Bonus: Ehre)
+    if (Guild* guild = GetGuild())
+    {
+        if (guild->HasLevelForBonus(GUILD_BONUS_EHRE_1))
+            honor_f *= 0.05f;
+        if (guild->HasLevelForBonus(GUILD_BONUS_EHRE_2))
+            honor_f *= 0.1f;
+    }
+
     // Back to int now
     honor = int32(honor_f);
     // honor - for show honor points in log
@@ -7467,7 +7691,7 @@ void Player::UpdateArea(uint32 newArea)
 
     // previously this was in UpdateZone (but after UpdateArea) so nothing will break
     pvpInfo.IsInNoPvPArea = false;
-    if (area && area->IsSanctuary())    // in sanctuary
+    if(area && area->IsSanctuary() || GetAreaId() == 4413)    // in sanctuary
     {
         SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
         pvpInfo.IsInNoPvPArea = true;
@@ -7808,6 +8032,20 @@ void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply
     if (only_level_scale && !ssv)
         return;
 
+    uint32 statcount = proto->StatsCount;
+    uint32 lowGUID = 0;
+    bool decreased = false;
+    if (statcount < MAX_ITEM_PROTO_STATS)
+    {
+        if (Item* invItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        {
+            if (sObjectMgr->_itemFakeStatStore.find(invItem->GetGUIDLow()) != sObjectMgr->_itemFakeStatStore.end())
+            {
+                lowGUID = invItem->GetGUIDLow();
+                statcount++;
+            }
+        }
+    }
     for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
     {
         uint32 statType = 0;
@@ -7822,10 +8060,24 @@ void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply
         }
         else
         {
-            if (i >= proto->StatsCount)
+            if (i >= statcount)
                 continue;
             statType = proto->ItemStat[i].ItemStatType;
             val = proto->ItemStat[i].ItemStatValue;
+
+            if (lowGUID)
+            {
+                if(i == statcount-1)
+                {
+                    statType = sObjectMgr->_itemFakeStatStore[lowGUID].increase;
+                    val = sObjectMgr->_itemFakeStatStore[lowGUID].stat_value;
+                }
+                else if(!decreased && sObjectMgr->_itemFakeStatStore[lowGUID].decrease == statType)
+                {
+                    val -= sObjectMgr->_itemFakeStatStore[lowGUID].stat_value;
+                    decreased = true;
+                }
+            }
         }
 
         if (val == 0)
@@ -11976,13 +12228,13 @@ InventoryResult Player::CanUseItem(ItemTemplate const* proto) const
 
     if (proto)
     {
-        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetTeam() != HORDE)
+        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetOTeam() != HORDE)
             return EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM;
 
-        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetTeam() != ALLIANCE)
+        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetOTeam() != ALLIANCE)
             return EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM;
 
-        if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
+        if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getORaceMask()) == 0)
             return EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM;
 
         if (proto->RequiredSkill != 0)
@@ -12470,7 +12722,10 @@ void Player::SetVisibleItemSlot(uint8 slot, Item* pItem)
 {
     if (pItem)
     {
-        SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), pItem->GetEntry());
+        if (uint32 entry = sTransmogrification->GetFakeEntry(pItem))
+            SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), entry);
+        else
+            SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), pItem->GetEntry());
         SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 0, pItem->GetEnchantmentId(PERM_ENCHANTMENT_SLOT));
         SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 1, pItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
     }
@@ -12596,6 +12851,7 @@ void Player::MoveItemFromInventory(uint8 bag, uint8 slot, bool update)
 {
     if (Item* it = GetItemByPos(bag, slot))
     {
+        sTransmogrification->DeleteFakeEntry(this, it);
         ItemRemovedQuestCheck(it->GetEntry(), it->GetCount());
         RemoveItem(bag, slot, update);
         it->SetNotRefundable(this, false);
@@ -15318,13 +15574,26 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     bool rewarded = (m_RewardedQuests.find(quest_id) != m_RewardedQuests.end());
 
     // Not give XP in case already completed once repeatable quest
-    uint32 XP = rewarded ? 0 : uint32(quest->XPValue(this)*sWorld->getRate(RATE_XP_QUEST));
+    uint32 XP = rewarded ? 0 : uint32(quest->XPValue(this)*(_individual_quest > 0 ? _individual_quest : sWorld->getRate(RATE_XP_QUEST)));
 
     // handle SPELL_AURA_MOD_XP_QUEST_PCT auras
     Unit::AuraEffectList const& ModXPPctAuras = GetAuraEffectsByType(SPELL_AURA_MOD_XP_QUEST_PCT);
     for (Unit::AuraEffectList::const_iterator i = ModXPPctAuras.begin(); i != ModXPPctAuras.end(); ++i)
         AddPct(XP, (*i)->GetAmount());
 
+    //Guild-Level-System (Bonus: QuestXP)
+    if (Guild* guild = GetGuild())
+    {
+        //QuestXP for the Guild
+        guild->GiveXp(50000);
+
+        //GuildXP-Bonus
+        if (guild->HasLevelForBonus(GUILD_BONUS_XP_1))
+            XP += uint32(XP*0.05f);
+        if (guild->HasLevelForBonus(GUILD_BONUS_XP_2))
+            XP += uint32(XP*0.1f);
+    }
+
     int32 moneyRew = 0;
     if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
         GiveXP(XP, NULL);
@@ -17220,6 +17489,11 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
         return false;
     }
 
+    SetORace();
+    m_team = TeamForRace(getORace());
+    SetFakeRaceAndMorph(); // m_team must be set before this can be used.
+    setFactionForRace(getORace());//Need to call it to initialize m_team (m_team can be calculated from race)
+
     SetUInt32Value(UNIT_FIELD_LEVEL, fields[6].GetUInt8());
     SetUInt32Value(PLAYER_XP, fields[7].GetUInt32());
 
@@ -17266,10 +17540,6 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
     TC_LOG_DEBUG("entities.player.loading", "Load Basic value of player %s is: ", m_name.c_str());
     outDebugValues();
 
-    //Need to call it to initialize m_team (m_team can be calculated from race)
-    //Other way is to saves m_team into characters table.
-    setFactionForRace(getRace());
-
     // load home bind and check in same time class/race pair, it used later for restore broken positions
     if (!_LoadHomeBind(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_HOME_BIND)))
         return false;
@@ -17536,7 +17806,7 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
 
     if (!map)
     {
-        PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+        PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getORace(), getClass());
         mapId = info->mapId;
         Relocate(info->positionX, info->positionY, info->positionZ, 0.0f);
         map = sMapMgr->CreateMap(mapId, this);
@@ -19187,7 +19457,7 @@ void Player::SaveToDB(bool create /*=false*/)
         stmt->setUInt32(index++, GetGUIDLow());
         stmt->setUInt32(index++, GetSession()->GetAccountId());
         stmt->setString(index++, GetName());
-        stmt->setUInt8(index++, getRace());
+        stmt->setUInt8(index++, getORace());
         stmt->setUInt8(index++, getClass());
         stmt->setUInt8(index++, getGender());
         stmt->setUInt8(index++, getLevel());
@@ -19292,7 +19562,7 @@ void Player::SaveToDB(bool create /*=false*/)
         // Update query
         stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER);
         stmt->setString(index++, GetName());
-        stmt->setUInt8(index++, getRace());
+        stmt->setUInt8(index++, getORace());
         stmt->setUInt8(index++, getClass());
         stmt->setUInt8(index++, getGender());
         stmt->setUInt8(index++, getLevel());
@@ -19446,6 +19716,12 @@ void Player::SaveToDB(bool create /*=false*/)
 
     CharacterDatabase.CommitTransaction(trans);
 
+    // we save the data here to prevent spamming
+    sAnticheatMgr->SavePlayerData(this);
+
+    // in this way we prevent to spam the db by each report made!
+    // sAnticheatMgr->SavePlayerData(this);
+
     // save pet (hunter pet level and experience and all type pets health/mana).
     if (Pet* pet = GetPet())
         pet->SavePetToDB(PET_SAVE_AS_CURRENT);
@@ -20531,6 +20807,19 @@ void Player::StopCastingCharm()
     }
 }
 
+void Player::BuildPlayerChat(WorldPacket* data, uint8 msgtype, const std::string& text, uint32 language) const
+{
+    *data << uint8(msgtype);
+    *data << uint32(language);
+    *data << uint64(GetGUID());
+    *data << uint32(0);                                      // constant unknown time
+    *data << uint64(GetGUID());
+    *data << uint32(text.length() + 1);
+    *data << text;
+    *data << uint8(GetChatTag());
+}
+
+
 void Player::Say(const std::string& text, const uint32 language)
 {
     std::string _text(text);
@@ -22316,11 +22605,6 @@ void Player::SetBGTeam(uint32 team)
     SetByteValue(PLAYER_BYTES_3, 3, uint8(team == ALLIANCE ? 1 : 0));
 }
 
-uint32 Player::GetBGTeam() const
-{
-    return m_bgData.bgTeam ? m_bgData.bgTeam : GetTeam();
-}
-
 void Player::LeaveBattleground(bool teleportToEntryPoint)
 {
     if (Battleground* bg = GetBattleground())
@@ -22396,7 +22680,7 @@ void Player::ReportedAfkBy(Player* reporter)
 
 WorldLocation Player::GetStartPosition() const
 {
-    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getORace(), getClass());
     uint32 mapId = info->mapId;
     if (getClass() == CLASS_DEATH_KNIGHT && HasSpell(50977))
         mapId = 0;
@@ -26804,3 +27088,22 @@ bool Player::IsLoading() const
 {
     return GetSession()->PlayerLoading();
 }
+
+//Individuale_XP-Raten
+void Player::SetIndividualRate(IndividualXpRate rate, float value)
+{
+    if (value < 1 || value > 8)
+        return;
+
+    switch (rate)
+    {
+        case INDIVIDUAL_XP_KILL:
+            _individual_kill = value;
+            break;
+        case INDIVIDUAL_XP_QUEST:
+            _individual_quest = value;
+        break;
+        default:
+            break;
+    }
+}
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 5f500b7..6432d9d 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -53,6 +53,10 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+// NpcBot mod
+class BotMgr;
+// end NpcBot mod
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -909,6 +913,13 @@ enum PlayerCommandStates
     CHEAT_WATERWALK = 0x10
 };
 
+//Individuale_XP-Raten
+enum IndividualXpRate
+{
+    INDIVIDUAL_XP_KILL  = 1,
+    INDIVIDUAL_XP_QUEST = 2,
+};
+
 class PlayerTaxi
 {
     public:
@@ -1079,6 +1090,37 @@ class Player : public Unit, public GridObject<Player>
     public:
         explicit Player(WorldSession* session);
         ~Player();
+        private:
+        bool m_ForgetBGPlayers;
+        bool m_ForgetInListPlayers;
+        uint8 m_FakeRace;
+        uint8 m_RealRace;
+        uint32 m_FakeMorph;
+    public:
+        typedef std::vector<uint64> FakePlayers;
+        void SendChatMessage(const char *format, ...);
+        void FitPlayerInTeam(bool action, Battleground* pBattleGround = NULL);
+        void DoForgetPlayersInList();
+        void DoForgetPlayersInBG(Battleground* pBattleGround);
+        uint8 getORace() const { return m_RealRace; }
+        void SetORace() { m_RealRace = GetByteValue(UNIT_FIELD_BYTES_0, 0); }; // SHOULD ONLY BE CALLED ON LOGIN
+        void SetFakeRace(); // SHOULD ONLY BE CALLED ON LOGIN
+        void SetFakeRaceAndMorph(); // SHOULD ONLY BE CALLED ON LOGIN
+        uint32 GetFakeMorph() { return m_FakeMorph; };
+        uint8 getFRace() const { return m_FakeRace; }
+        void SetForgetBGPlayers(bool value) { m_ForgetBGPlayers = value; }
+        bool ShouldForgetBGPlayers() { return m_ForgetBGPlayers; }
+        void SetForgetInListPlayers(bool value) { m_ForgetInListPlayers = value; }
+        bool ShouldForgetInListPlayers() { return m_ForgetInListPlayers; }
+        bool SendBattleGroundChat(uint32 msgtype, std::string message);
+        void MorphFit(bool value);
+        bool IsPlayingNative() const { return GetTeam() == m_team; }
+        uint32 GetOTeam() const { return m_team; }
+        uint32 GetTeam() const { return m_bgData.bgTeam && GetBattleground() ? m_bgData.bgTeam : m_team; }
+        bool SendRealNameQuery();
+        FakePlayers m_FakePlayers;
+
+        //AnticheatData anticheatData;
 
         void CleanupsBeforeDelete(bool finalCleanup = true);
 
@@ -1132,7 +1174,7 @@ class Player : public Unit, public GridObject<Player>
         PlayerSocial *GetSocial() { return m_social; }
 
         PlayerTaxi m_taxi;
-        void InitTaxiNodesForLevel() { m_taxi.InitTaxiNodesForLevel(getRace(), getClass(), getLevel()); }
+        void InitTaxiNodesForLevel() { m_taxi.InitTaxiNodesForLevel(getORace(), getClass(), getLevel()); }
         bool ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc = NULL, uint32 spellid = 0);
         bool ActivateTaxiPathTo(uint32 taxi_path_id, uint32 spellid = 0);
         void CleanupAfterTaxiFlight();
@@ -1200,6 +1242,8 @@ class Player : public Unit, public GridObject<Player>
         void TextEmote(std::string const& text);
         /// Handles whispers from Addons and players based on sender, receiver's guid and language.
         void Whisper(std::string const& text, const uint32 language, uint64 receiver);
+        /// Constructs the player Chat data for the specific functions to use
+        void BuildPlayerChat(WorldPacket* data, uint8 msgtype, std::string const& text, uint32 language) const;
 
         /*********************************************************/
         /***                    STORAGE SYSTEM                 ***/
@@ -1902,8 +1946,7 @@ class Player : public Unit, public GridObject<Player>
         void CheckAreaExploreAndOutdoor(void);
 
         static uint32 TeamForRace(uint8 race);
-        uint32 GetTeam() const { return m_team; }
-        TeamId GetTeamId() const { return m_team == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
+        TeamId GetTeamId() const { return GetTeam() == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
         void setFactionForRace(uint8 race);
 
         void InitDisplayIds();
@@ -2047,7 +2090,6 @@ class Player : public Unit, public GridObject<Player>
         void SetBattlegroundEntryPoint();
 
         void SetBGTeam(uint32 team);
-        uint32 GetBGTeam() const;
 
         void LeaveBattleground(bool teleportToEntryPoint = true);
         bool CanJoinToBattleground(Battleground const* bg) const;
@@ -2316,6 +2358,26 @@ class Player : public Unit, public GridObject<Player>
 
         bool IsLoading() const;
 
+        //Individuale_XP-Raten
+        void SetIndividualRate(IndividualXpRate rate, float value);
+        float GetIndividualXpKillRate() { return _individual_kill; };
+        float GetIndividualXpQuestRate() { return _individual_quest; };
+
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        void SetBotMgr(BotMgr* mgr) { ASSERT (!_botMgr); _botMgr = mgr; }
+        BotMgr* GetBotMgr() const { return _botMgr; }
+        bool HaveBot() const;
+        uint8 GetNpcBotsCount(bool inWorldOnly = false) const;
+        uint8 GetBotFollowDist() const;
+        void SetBotFollowDist(int8 dist);
+        void SetBotsShouldUpdateStats();
+        void RemoveAllBots(uint8 removetype = 0);
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         WhisperListContainer WhisperList;
@@ -2579,6 +2641,14 @@ class Player : public Unit, public GridObject<Player>
         bool m_needsZoneUpdate;
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        BotMgr* _botMgr;
+        /*********************************************************/
+        /***                END BOT SYSTEM                     ***/
+        /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
@@ -2644,6 +2714,12 @@ class Player : public Unit, public GridObject<Player>
         uint32 _pendingBindTimer;
 
         uint32 _activeCheats;
+
+        //Individual_XP-Rate
+        float _individual_kill;
+        float _individual_quest;
+    public :
+        QuestStatusSaveMap m_RewardedQuestsSave2;
 };
 
 void AddItemsSetItem(Player* player, Item* item);
diff --git a/src/server/game/Entities/Totem/Totem.cpp b/src/server/game/Entities/Totem/Totem.cpp
index b8f5fd1..8dcf817 100644
--- a/src/server/game/Entities/Totem/Totem.cpp
+++ b/src/server/game/Entities/Totem/Totem.cpp
@@ -143,6 +143,13 @@ void Totem::UnSummon(uint32 msTime)
         }
     }
 
+    //npcbot: send SummonedCreatureDespawn()
+    if (IS_CREATURE_GUID(GetCreatorGUID()))
+        if (Unit* bot = sObjectAccessor->FindUnit(GetCreatorGUID()))
+            if (bot->ToCreature()->GetIAmABot())
+                bot->ToCreature()->OnBotDespawn(this);
+    //end npcbot
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index 0413622..f507d74 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -217,6 +217,10 @@ bool Player::UpdateAllStats()
     RecalculateRating(CR_ARMOR_PENETRATION);
     UpdateAllResistances();
 
+    //npcbot - Player::UpdateAllStats() is called on level change - update bots
+    SetBotsShouldUpdateStats();
+    //end npcbot
+
     return true;
 }
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 72c1a07..353da62 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "AnticheatMgr.h"
 #include "Unit.h"
 #include "Common.h"
 #include "Battlefield.h"
@@ -61,6 +62,7 @@
 #include "World.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
+#include "Guild.h"
 
 #include <math.h>
 
@@ -254,6 +256,13 @@ Unit::Unit(bool isWorldObject) :
 
     _oldFactionId = 0;
     _isWalkingBeforeCharm = false;
+
+    //npcbot
+    _damageInfo.target = NULL;
+    _delayedTargetGuid = 0;
+    _swingDelayTimer = 0;
+    _swingLanded = true;
+    //end npcbot
 }
 
 ////////////////////////////////////////////////////////////
@@ -338,6 +347,28 @@ void Unit::Update(uint32 p_time)
                 m_CombatTimer -= p_time;
         }
     }
+    //npcbot: update combat timer also for npcbots
+    if (IsInCombat() && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI()/* && (!GetVictim() || ToCreature()->IsFreeBot())*/)
+    {
+        if (m_HostileRefManager.isEmpty())
+        {
+            if (m_CombatTimer <= p_time)
+                ClearInCombat();
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
+    //npcbot:
+    if (_delayedTargetGuid)
+    {
+        if (_swingLanded)
+            _delayedTargetGuid = 0;
+        else if (_swingDelayTimer >= p_time)
+            _swingDelayTimer -= p_time;
+        else
+            ExecuteDelayedSwingHit();
+    }
+    //end npcbot
 
     // not implemented before 3.0.2
     if (uint32 base_att = getAttackTimer(BASE_ATTACK))
@@ -575,6 +606,13 @@ uint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDam
         if (pet && pet->IsAlive())
             pet->AI()->OwnerAttackedBy(this);
 
+        // NpcBot mod: also signal owned npcbots
+        for (ControlList::const_iterator itr = victim->ToPlayer()->m_Controlled.begin(); itr != victim->ToPlayer()->m_Controlled.end(); ++itr)
+            if (Creature* cre = (*itr)->ToCreature())
+                if (cre->IsAIEnabled)
+                    cre->AI()->OwnerAttackedBy(this);
+        // End NpcBot
+
         if (victim->ToPlayer()->GetCommandStatus(CHEAT_GOD))
             return 0;
     }
@@ -839,6 +877,15 @@ void Unit::CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo
         return;
     }
 
+    //npcbot
+    if (Creature::IsBotCustomSpell(spellInfo->Id) && !(ToCreature() && ToCreature()->GetBotAI()))
+    {
+        TC_LOG_ERROR("entities.unit", "CastSpell: NpcBot system custom spell %u by caster: %s %u), aborted. Please report",
+            spellInfo->Id, (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+    //end npcbot
+
     /// @todo this is a workaround - not needed anymore, but required for some scripts :(
     if (!originalCaster && triggeredByAura)
         originalCaster = triggeredByAura->GetCasterGUID();
@@ -993,6 +1040,12 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_RANGED:
             case SPELL_DAMAGE_CLASS_MELEE:
             {
+                //Npcbot mod: apply bot damage mods
+                if (Creature* bot = ToCreature())
+                    if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                        bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+                // End NpcBot
+
                 // Physical Damage
                 if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
                 {
@@ -1050,6 +1103,12 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_NONE:
             case SPELL_DAMAGE_CLASS_MAGIC:
             {
+                //Npcbot mod: apply bot damage mods
+                if (Creature* bot = ToCreature())
+                    if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                        bot->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+                // End NpcBot
+
                 // If crit add critical bonus
                 if (crit)
                 {
@@ -1176,8 +1235,19 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     else
         damageInfo->damage = damage;
 
+    //NpcBot mod: check custom melee outcome
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        damageInfo->hitOutCome = ToCreature()->BotRollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
+    else
+    //End NpcBot
     damageInfo->hitOutCome = RollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
 
+    //NpcBot mod: apply bot damage mods
+    if (Creature* bot = ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo);
+    //End NpcBot
+
     switch (damageInfo->hitOutCome)
     {
         case MELEE_HIT_EVADE:
@@ -1326,6 +1396,9 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
         victim->HandleEmoteCommand(EMOTE_ONESHOT_PARRY_SHIELD);
 
     if (damageInfo->TargetState == VICTIMSTATE_PARRY)
+    //npcbot - implement CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN (TC sup)
+    if (!(GetTypeId() == TYPEID_UNIT && ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN))
+    //end npcbot
     {
         // Get attack timers
         float offtime  = float(victim->getAttackTimer(OFF_ATTACK));
@@ -1391,6 +1464,10 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
 
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->CastItemCombatSpell(victim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
+    //npcbot - CastItemCombatSpell for bots
+    else if (ToCreature()->GetBotAI())
+        ToCreature()->CastCreatureItemCombatSpell(victim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
+    //end npcbot
 
     // Do effect if any damage done to target
     if (damageInfo->damage)
@@ -1537,6 +1614,11 @@ uint32 Unit::CalcArmorReducedDamage(Unit* victim, const uint32 damage, SpellInfo
     if (armor < 0.0f)
         armor = 0.0f;
 
+    //npcbot custom armor penetration modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        armor *= std::max<float>(1.0f - ToCreature()->GetCreatureArmorPenetrationCoef(), 0.0f);
+    //end npcbot
+
     float levelModifier = getLevel();
     if (levelModifier > 59)
         levelModifier = levelModifier + 4.5f * (levelModifier - 59);
@@ -1577,6 +1659,10 @@ uint32 Unit::CalcSpellResistance(Unit* victim, SpellSchoolMask schoolMask, Spell
 
     if (Player const* player = ToPlayer())
         baseVictimResistance -= player->GetSpellPenetrationItemMod();
+    //npcbot - spell penetration for bots
+    else if (ToCreature()->GetBotAI())
+        baseVictimResistance -= ToCreature()->GetCreatureSpellPenetration();
+    //end npcbot
 
     // Resistance can't be lower then 0
     int32 victimResistance = std::max<int32>(baseVictimResistance, 0);
@@ -1918,6 +2004,38 @@ void Unit::CalcHealAbsorb(Unit* victim, SpellInfo const* healSpell, uint32 &heal
     healAmount = RemainingHeal;
 }
 
+//NpcBot mod
+void Unit::ExecuteDelayedSwingHit(bool extra)
+{
+    if (_swingLanded)
+        return;
+
+    _swingLanded = true;
+    if (!extra)
+        _damageInfo.target = ObjectAccessor::FindUnit(_delayedTargetGuid);
+
+    if (!_damageInfo.target)
+        return;
+
+    //TC_LOG_DEBUG(LOG_FILTER_UNITS, "Unit::ExecuteDelayedSwingHit() call for %s, victim = %s", GetName().c_str(), _damageInfo.target->GetName().c_str());
+
+    //TriggerAurasProcOnEvent(*_damageInfo);
+    DealMeleeDamage(&_damageInfo, true);
+
+    // Recursion warning here
+    ProcDamageAndSpell(_damageInfo.target, _damageInfo.procAttacker, _damageInfo.procVictim, _damageInfo.procEx, _damageInfo.damage, _damageInfo.attackType);
+}
+//NpcBot mod
+void Unit::SuspendDelayedSwing()
+{
+    if (_swingLanded)
+        return;
+
+    _swingLanded = true;
+    //TC_LOG_DEBUG(LOG_FILTER_UNITS, "Unit::SuspendDelayedSwing() call for %s, victim = %s", GetName().c_str(), _damageInfo.target ? _damageInfo.target->GetName().c_str() : "_removed_");
+}
+//End NpcBot mod
+
 void Unit::AttackerStateUpdate (Unit* victim, WeaponAttackType attType, bool extra)
 {
     if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
@@ -1929,6 +2047,48 @@ void Unit::AttackerStateUpdate (Unit* victim, WeaponAttackType attType, bool ext
     if ((attType == BASE_ATTACK || attType == OFF_ATTACK) && !IsWithinLOSInMap(victim))
         return;
 
+    //npcbot
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+    {
+        // if attack is executed before previous swing finished, finish it forcefully
+        ExecuteDelayedSwingHit();
+
+        CombatStart(victim);
+        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);
+
+        if (attType != BASE_ATTACK && attType != OFF_ATTACK)
+            return;                                             // ignore ranged case
+
+        // melee attack spell casted at main hand attack only - no normal melee dmg dealt
+        if (attType == BASE_ATTACK && m_currentSpells[CURRENT_MELEE_SPELL] && !extra)
+            m_currentSpells[CURRENT_MELEE_SPELL]->cast();
+        else
+        {
+            // attack can be redirected to another target
+            victim = GetMeleeHitRedirectTarget(victim);
+            CalculateMeleeDamage(victim, 0, &_damageInfo, attType);
+            DealDamageMods(victim, _damageInfo.damage, &_damageInfo.absorb);
+
+            // Send log damage message to client
+            SendAttackStateUpdate(&_damageInfo);
+
+            // If this swing is extra attack, execute it right now
+            // Else delay melee hit by melee swing animation time
+            _swingLanded = false;
+            _delayedTargetGuid = victim->GetGUID();
+            if (m_extraAttacks)
+                ExecuteDelayedSwingHit(true);
+            else
+                _swingDelayTimer = 450;
+
+            //TC_LOG_DEBUG("entities.unit", "AttackerStateUpdateBot: (NPCBot)    %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
+            //    GetGUIDLow(), victim->GetGUIDLow(), victim->GetTypeId(), _damageInfo.damage, _damageInfo.absorb, _damageInfo.blocked_amount, _damageInfo.resist);
+        }
+
+        return;
+    }
+    //end npcbot
+
     CombatStart(victim);
     RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);
 
@@ -2036,11 +2196,24 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackT
     {
         TC_LOG_DEBUG("entities.unit", "RollMeleeOutcomeAgainst: attack came from behind and victim was a player.");
     }
+    //npcbot - bots cannot dodge if attacker is behind
+    else if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->GetBotAI() && !victim->HasInArc(M_PI, this) && !victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    {
+        //TC_LOG_DEBUG("entities.unit", "RollMeleeOutcomeAgainst: attack came from behind and victim was a bot.");
+    }
+    //end npcbot
     else
     {
         // Reduce dodge chance by attacker expertise rating
         if (GetTypeId() == TYPEID_PLAYER)
             dodge_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);
+        //npcbot - manual expertise instead of auras
+        else if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        {
+            dodge_chance -= ToCreature()->GetCreatureExpertise() * 25;
+            dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+        }
+        //end npcbot
         else
             dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
 
@@ -2068,6 +2241,13 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackT
         // Reduce parry chance by attacker expertise rating
         if (GetTypeId() == TYPEID_PLAYER)
             parry_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);
+        //npcbot - manual expertise instead of auras
+        else if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        {
+            parry_chance -= ToCreature()->GetCreatureExpertise() * 25;
+            parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+        }
+        //end npcbot
         else
             parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
 
@@ -2682,6 +2862,14 @@ float Unit::GetUnitDodgeChance() const
         else
         {
             float dodge = 5.0f;
+            //npcbot - custom dodge chance instead of bunch of auras and remove base chance
+            if (ToCreature()->GetBotAI())
+            {
+                if (!ToCreature()->CanDodge())
+                    return 0.0f;
+                dodge = ToCreature()->GetCreatureDodgeChance();
+            }
+            //end npcbot
             dodge += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
             return dodge > 0.0f ? dodge : 0.0f;
         }
@@ -2711,6 +2899,15 @@ float Unit::GetUnitParryChance() const
     {
         if (GetCreatureType() == CREATURE_TYPE_HUMANOID)
         {
+            //npcbot - custom parry chance instead of bunch of auras
+            if (ToCreature()->GetBotAI())
+            {
+                if (!ToCreature()->CanParry())
+                    return 0.0f;
+                chance = ToCreature()->GetCreatureParryChance();
+            }
+            else
+            //end npcbot
             chance = 5.0f;
             chance += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
         }
@@ -2757,6 +2954,14 @@ float Unit::GetUnitBlockChance() const
         else
         {
             float block = 5.0f;
+            //npcbot - custom block chance instead of bunch of auras and remove base chance
+            if (ToCreature()->GetBotAI())
+            {
+                if (!ToCreature()->CanBlock())
+                    return 0.0f;
+                block = ToCreature()->GetCreatureBlockChance();
+            }
+            //end npcbot
             block += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
             return block > 0.0f ? block : 0.0f;
         }
@@ -2788,6 +2993,15 @@ float Unit::GetUnitCriticalChance(WeaponAttackType attackType, const Unit* victi
     }
     else
     {
+        //npcbot - custom crit chance instead of bunch of auras and remove base chance
+        if (ToCreature()->GetBotAI())
+        {
+            if (!ToCreature()->CanCrit())
+                return 0.0f;
+            crit = 5.0f + ToCreature()->GetCreatureCritChance();
+        }
+        else
+        //end npcbot
         crit = 5.0f;
         crit += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
         crit += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
@@ -6054,6 +6268,12 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                     // Check cooldown of heal spell cooldown
                     if (GetTypeId() == TYPEID_PLAYER && !ToPlayer()->HasSpellCooldown(34299))
                         CastCustomSpell(this, 68285, &basepoints1, 0, 0, true, 0, triggeredByAura);
+
+                    //npcbot - proc for bot
+                    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI() && !ToCreature()->HasSpellCooldown(34299))
+                        CastCustomSpell(this, 68285, &basepoints1, 0, 0, true, 0, triggeredByAura);
+                    //end npcbot
+
                     break;
                 }
                 // Healing Touch (Dreamwalker Raiment set)
@@ -6179,6 +6399,31 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                 triggered_spell_id = isWrathSpell ? 48518 : 48517;
                 break;
             }
+
+            //npcbot - Eclipse for bot
+            if (dummySpell->SpellIconID == 2856 && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+            {
+                if (!procSpell || effIndex != 0)
+                    return false;
+
+                bool isWrathSpell = (procSpell->SpellFamilyFlags[0] & 1);
+
+                if (!roll_chance_f(dummySpell->ProcChance * (isWrathSpell ? 0.6f : 1.0f)))
+                    return false;
+
+                target = this;
+                if (target->HasAura(isWrathSpell ? 48517 : 48518))
+                    return false;
+
+                triggered_spell_id = isWrathSpell ? 48518 : 48517;
+
+                if (ToCreature()->HasSpellCooldown(triggered_spell_id))
+                    return false;
+
+                break;
+            }
+            //end npcbot
+
             break;
         }
         case SPELLFAMILY_ROGUE:
@@ -8978,6 +9223,9 @@ bool Unit::Attack(Unit* victim, bool meleeAttack)
     //    ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());
 
     if (GetTypeId() == TYPEID_UNIT && !ToCreature()->IsPet())
+    //npcbot - not for npcbots either
+    if (!ToCreature()->GetBotAI())
+    //end npcbot
     {
         // should not let player enter combat by right clicking target - doesn't helps
         SetInCombatWith(victim);
@@ -9049,6 +9297,9 @@ void Unit::CombatStop(bool includingCast)
         InterruptNonMeleeSpells(false);
 
     AttackStop();
+    //npcbot
+    SuspendDelayedSwing();
+    //end npcbot
     RemoveAllAttackers();
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->SendAttackSwingCancelAttack();     // melee and ranged forced attack cancel
@@ -9086,6 +9337,9 @@ void Unit::RemoveAllAttackers()
     while (!m_attackers.empty())
     {
         AttackerSet::iterator iter = m_attackers.begin();
+        //npcbot
+        (*iter)->SuspendDelayedSwing();
+        //end npcbot
         if (!(*iter)->AttackStop())
         {
             TC_LOG_ERROR("entities.unit", "WORLD: Unit has an attacker that isn't attacking it!");
@@ -9667,12 +9921,25 @@ void Unit::RemoveAllControlled()
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->StopCastingCharm();
 
+    //npcbot - store bots for recontroll; bots are to be removed manually
+    std::list<Unit*> nBots;
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        if ((*itr)->GetTypeId() == TYPEID_UNIT && (*itr)->ToCreature()->GetBotAI())
+            nBots.push_back(*itr);
+    //end npcbot
+
     while (!m_Controlled.empty())
     {
         Unit* target = *m_Controlled.begin();
         m_Controlled.erase(m_Controlled.begin());
         if (target->GetCharmerGUID() == GetGUID())
             target->RemoveCharmAuras();
+        //npcbot - debug info
+        else if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->GetBotAI())
+        {
+            //TC_LOG_ERROR("entities.unit", "RemoveAllControlled(): Unit %u removing bot %s (%u)", GetGUIDLow(), target->GetName().c_str(), target->GetEntry());
+        }
+        //end npcbot
         else if (target->GetOwnerGUID() == GetGUID() && target->IsSummon())
             target->ToTempSummon()->UnSummon();
         else
@@ -9684,6 +9951,14 @@ void Unit::RemoveAllControlled()
         TC_LOG_FATAL("entities.unit", "Unit %u is not able to release its minion " UI64FMTD, GetEntry(), GetMinionGUID());
     if (GetCharmGUID())
         TC_LOG_FATAL("entities.unit", "Unit %u is not able to release its charm " UI64FMTD, GetEntry(), GetCharmGUID());
+
+    //npcbot - restore controlled bots
+    if (nBots.empty())
+        return;
+
+    for (std::list<Unit*>::const_iterator itr = nBots.begin(); itr != nBots.end(); ++itr)
+        m_Controlled.insert(*itr);
+    //end npcbot
 }
 
 bool Unit::isPossessedByPlayer() const
@@ -10306,6 +10581,11 @@ uint32 Unit::SpellDamageBonusTaken(Unit* caster, SpellInfo const* spellProto, ui
                 AddPct(TakenTotalMod, (*i)->GetAmount());
     }
 
+    //npcbot - damage taken modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        TakenTotalMod *= ToCreature()->GetCreatureDamageTakenMod();
+    //end npcbot
+
     //.. taken pct: dummy auras
     AuraEffectList const& mDummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
     for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
@@ -10396,6 +10676,11 @@ int32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask schoolMask) const
 {
     int32 DoneAdvertisedBenefit = 0;
 
+    //npcbot: apply bot spellpower
+    if (schoolMask && !(schoolMask & SPELL_SCHOOL_MASK_NORMAL) && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        DoneAdvertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     AuraEffectList const& mDamageDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
     for (AuraEffectList::const_iterator i = mDamageDone.begin(); i != mDamageDone.end(); ++i)
         if (((*i)->GetMiscValue() & schoolMask) != 0 &&
@@ -10453,6 +10738,9 @@ float Unit::GetUnitSpellCriticalChance(Unit* victim, SpellInfo const* spellProto
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
     if (IS_CRE_OR_VEH_GUID(GetGUID()) && !(IsTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438)
+        //npcbot - allow bots to crit
+        if (!ToCreature()->GetBotAI())
+        //end npcbot
         return 0.0f;
 
     // not critting spell
@@ -10644,6 +10932,12 @@ float Unit::GetUnitSpellCriticalChance(Unit* victim, SpellInfo const* spellProto
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRITICAL_CHANCE, crit_chance);
 
+    //npcbot - apply bot spell crit mods
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        ToCreature()->ApplyBotCritMultiplierAll(victim, crit_chance, spellProto, schoolMask, attackType);
+    //end npcbot
+
+
     return crit_chance > 0.0f ? crit_chance : 0.0f;
 }
 
@@ -10822,6 +11116,11 @@ uint32 Unit::SpellHealingBonusDone(Unit* victim, SpellInfo const* spellProto, ui
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
 
+    //npcbot - healing bonus done for bots
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        ToCreature()->ApplyBotDamageMultiplierHeal(victim, heal, spellProto, damagetype, stack);
+    //end npcbot
+
     return uint32(std::max(heal, 0.0f));
 }
 
@@ -11010,6 +11309,11 @@ int32 Unit::SpellBaseHealingBonusDone(SpellSchoolMask schoolMask) const
         if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)
             advertisedBenefit += (*i)->GetAmount();
 
+    //npcbot: apply bot spellpower to healing
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        advertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
     {
@@ -11101,6 +11405,11 @@ bool Unit::IsImmunedToSpell(SpellInfo const* spellInfo) const
     if (spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
         return false;
 
+    //npcbot - check 'magic immunity' state and other
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI() && ToCreature()->IsCreatureImmuneToSpell(spellInfo))
+        return true;
+    //end npcbot
+
     if (spellInfo->Dispel)
     {
         SpellImmuneList const& dispelList = m_spellImmune[IMMUNITY_DISPEL];
@@ -11399,6 +11708,11 @@ uint32 Unit::MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage, WeaponAttackT
     // ..taken
     TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, attacker->GetMeleeDamageSchoolMask());
 
+    //npcbot - damage taken modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        TakenTotalMod *= ToCreature()->GetCreatureDamageTakenMod();
+    //end npcbot
+
     // .. taken pct (special attacks)
     if (spellProto)
     {
@@ -11740,6 +12054,12 @@ void Unit::SetInCombatState(bool PvP, Unit* enemy)
     if (PvP)
         m_CombatTimer = 5000;
 
+    ////npcbot - if combat with npcbot or its pet set extended timer
+    //if (PvP &&((GetTypeId() == TYPEID_UNIT && ToCreature()->IsFreeBot()) ||
+    //    (enemy->GetTypeId() == TYPEID_UNIT && enemy->ToCreature()->IsFreeBot())))
+    //    m_CombatTimer += 5000;
+    ////end npcbot
+
     if (IsInCombat() || HasUnitState(UNIT_STATE_EVADE))
         return;
 
@@ -12159,6 +12479,12 @@ bool Unit::IsAlwaysVisibleFor(WorldObject const* seer) const
                 if (ownerPlayer->IsGroupVisibleFor(seerPlayer))
                     return true;
 
+    //npcbot - bots are always visible for owner
+    if (Creature const* bot = ToCreature())
+        if (bot->GetBotAI() && seer->GetGUID() == bot->GetBotOwner()->GetGUID())
+            return true;
+    //end npcbot
+
     return false;
 }
 
@@ -12190,10 +12516,30 @@ void Unit::SetVisible(bool x)
 
 void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
 {
+    //if (this->ToPlayer())
+    //    sAnticheatMgr->DisableAnticheatDetection(this->ToPlayer());
+
     int32 main_speed_mod  = 0;
     float stack_bonus     = 1.0f;
     float non_stack_bonus = 1.0f;
 
+    //Guild-Level-System (Bonus: Reittempo)
+    uint8 bonusSpeed = 0;
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        Player* player = ToPlayer();
+        if (Guild* guild = player->GetGuild())
+        {
+            if (!player->GetMap()->IsBattlegroundOrArena())
+            {
+                if (guild->HasLevelForBonus(GUILD_BONUS_REITTEMPO_1))
+                    bonusSpeed = 5;
+                if (guild->HasLevelForBonus(GUILD_BONUS_REITTEMPO_2))
+                    bonusSpeed = 10;
+            }
+        }
+    }
+
     switch (mtype)
     {
         // Only apply debuffs
@@ -12207,7 +12553,7 @@ void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
         {
             if (IsMounted()) // Use on mount auras
             {
-                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED);
+                main_speed_mod = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED) + bonusSpeed;
                 stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_SPEED_ALWAYS);
                 non_stack_bonus += GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK) / 100.0f;
             }
@@ -12241,7 +12587,7 @@ void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
             }
             else if (IsMounted())
             {
-                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+                main_speed_mod = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) + bonusSpeed;
                 stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS);
             }
             else             // Use not mount (shapeshift for example) auras (should stack)
@@ -12525,6 +12871,11 @@ bool Unit::CanHaveThreatList(bool skipAliveCheck) const
     if (HasUnitTypeMask(UNIT_MASK_MINION | UNIT_MASK_GUARDIAN | UNIT_MASK_CONTROLABLE_GUARDIAN) && IS_PLAYER_GUID(((Pet*)this)->GetOwnerGUID()))
         return false;
 
+    //npcbot - npcbots and their pets cannot have threatlist
+    if (ToCreature()->GetBotAI())
+        return false;
+    //end npcbot
+
     return true;
 }
 
@@ -12917,6 +13268,10 @@ void Unit::ModSpellCastTime(SpellInfo const* spellInfo, int32 & castTime, Spell*
     // called from caster
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CASTING_TIME, castTime, spell);
+    //npcbot - apply bot spell cast time mods
+    if (castTime > 0 && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        ToCreature()->ApplyCreatureSpellCastTimeMods(spellInfo, castTime);
+    //end npcbot
 
     if (!((spellInfo->Attributes & (SPELL_ATTR0_ABILITY | SPELL_ATTR0_TRADESPELL)) || (spellInfo->AttributesEx3 & SPELL_ATTR3_NO_DONE_BONUS)) &&
         ((GetTypeId() == TYPEID_PLAYER && spellInfo->SpellFamilyName) || GetTypeId() == TYPEID_UNIT))
@@ -14066,6 +14421,14 @@ void Unit::ProcDamageAndSpellFor(bool isVictim, Unit* target, uint32 procFlag, u
                     ToPlayer()->AddComboPoints(target, 1);
                     StartReactiveTimer(REACTIVE_OVERPOWER);
                 }
+
+                //npcbot - update reactives for bots
+                if ((procExtra & (PROC_EX_DODGE | PROC_EX_PARRY)) && GetTypeId() == TYPEID_UNIT &&
+                    ToCreature()->GetBotAI() && ToCreature()->GetBotClass() == CLASS_WARRIOR)
+                {
+                    StartReactiveTimer(REACTIVE_OVERPOWER);
+                }
+                //end npcbot
             }
         }
     }
@@ -14611,6 +14974,29 @@ void Unit::ClearComboPointHolders()
     }
 }
 
+//npcbot
+void Unit::ClearReactive(ReactiveType reactive)
+{
+    m_reactiveTimer[reactive] = 0;
+
+    switch (reactive)
+    {
+        case REACTIVE_DEFENSE:
+            if (HasAuraState(AURA_STATE_DEFENSE))
+                ModifyAuraState(AURA_STATE_DEFENSE, false);
+            break;
+        case REACTIVE_HUNTER_PARRY:
+            if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
+                ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
+            break;
+        case REACTIVE_OVERPOWER:
+            if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)
+                ToPlayer()->ClearComboPoints();
+            break;
+    }
+}
+//end npcbot
+
 void Unit::ClearAllReactives()
 {
     for (uint8 i = 0; i < MAX_REACTIVE; ++i)
@@ -14719,6 +15105,9 @@ uint32 Unit::GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectTyp
 {
     // Not apply this to creature cast spells with casttime == 0
     if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !ToCreature()->IsPet())
+        //npcbot - skip bots
+        if (!ToCreature()->GetBotAI())
+        //endnpcbot
         return 3500;
 
     if (CastingTime > 7000) CastingTime = 7000;
@@ -15364,6 +15753,9 @@ void Unit::Kill(Unit* victim, bool durabilityLoss)
 
         // only if not player and not controlled by player pet. And not at BG
         if ((durabilityLoss && !player && !victim->ToPlayer()->InBattleground()) || (player && sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP)))
+        //npcbot - bots should not cause durability loss unless rampaging around
+        if (player || !ToCreature()->GetBotAI() || ToCreature()->GetBotOwner()->GetGUIDLow() == GetGUIDLow())
+        //end npcbot
         {
             TC_LOG_DEBUG("entities.unit", "We are dead, losing %f percent durability", sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH));
             plrVictim->DurabilityLossAll(sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH), false);
@@ -15994,7 +16386,7 @@ void Unit::RemoveCharmedBy(Unit* charmer)
 void Unit::RestoreFaction()
 {
     if (GetTypeId() == TYPEID_PLAYER)
-        ToPlayer()->setFactionForRace(getRace());
+        ToPlayer()->setFactionForRace(ToPlayer()->getRace());
     else
     {
         if (HasUnitTypeMask(UNIT_MASK_MINION))
@@ -16302,6 +16694,21 @@ float Unit::MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, i
     //calculate miss chance
     float missChance = victim->GetUnitMissChance(attType);
 
+    //npcbot - custom miss chance instead of bunch of auras, extra miss chance against bots
+    //bot can have extra miss chance for attackers
+    //but if attacker is also a bot and cannot miss then return this extra miss chance
+    float evasion = 0.0f;
+
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->GetBotAI())
+        evasion = victim->ToCreature()->GetCreatureEvasion();
+    if (GetTypeId() == TYPEID_UNIT && !ToCreature()->CanMiss())
+        return evasion;
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        missChance += ToCreature()->GetCreatureMissChance();
+
+    missChance += evasion;
+    //end npcbot
+
     if (!spellId && haveOffhandWeapon())
         missChance += 19;
 
@@ -16330,6 +16737,11 @@ float Unit::MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, i
     else
         missChance -= m_modMeleeHitChance;
 
+    //npcbot - limit chance from 30% to 60% if evasion is here
+    if (evasion > 0.0f && missChance < evasion)
+        missChance = evasion;
+    //end npcbot
+
     // Limit miss chance from 0 to 60%
     if (missChance < 0.0f)
         return 0.0f;
@@ -16642,6 +17054,182 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form) const
                 break;
         }
     }
+    else if (ToCreature() && ToCreature()->GetBotOwner() && ToCreature()->GetBotOwner()->ToPlayer())
+    {
+        Player const* player = ToCreature()->GetBotOwner();
+        //let's make druids alike for each player
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on master's Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                // Based on master's Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male master
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female master
+                    else switch (skinColor)
+                    {
+                        case 10: // White
+                            return 29409;
+                        case 6: // Light Brown
+                        case 7:
+                            return 29410;
+                        case 4: // Brown
+                        case 5:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_DIREBEAR:
+            case FORM_BEAR:
+                // Based on Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                // Based on Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                            return 29418;
+                        case 2: // White
+                        case 3:
+                            return 29419;
+                        case 6: // Light Brown/Grey
+                        case 7:
+                        case 8:
+                        case 9:
+                            return 29420;
+                        case 10: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_FLIGHT:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 20857;
+                return 20872;
+            case FORM_FLIGHT_EPIC:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 21243;
+                return 21244;
+            default:
+                break;
+        }
+    }
 
     uint32 modelid = 0;
     SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);
@@ -16745,6 +17333,21 @@ uint32 Unit::GetModelForTotem(PlayerTotemType totemType)
             }
             break;
         }
+        default: // One standard for other races.
+        {        // THANKS L30m4nc3r for this
+            switch (totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    // fire
+                    return 4589;
+                case SUMMON_TYPE_TOTEM_EARTH:   // earth
+                    return 4588;
+                case SUMMON_TYPE_TOTEM_WATER:   // water
+                    return 4587;
+                case SUMMON_TYPE_TOTEM_AIR:     // air
+                    return 4590;
+            }
+            break;
+        }
     }
     return 0;
 }
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index 535d75a..df10297 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -1359,8 +1359,10 @@ class Unit : public WorldObject
         uint8 getLevel() const { return uint8(GetUInt32Value(UNIT_FIELD_LEVEL)); }
         uint8 getLevelForTarget(WorldObject const* /*target*/) const { return getLevel(); }
         void SetLevel(uint8 lvl);
-        uint8 getRace() const { return GetByteValue(UNIT_FIELD_BYTES_0, 0); }
+        uint8 getRace(bool forceoriginal = false) const;
+        uint8 getORace() { return getRace(true); }
         uint32 getRaceMask() const { return 1 << (getRace()-1); }
+        uint32 getORaceMask() const { return 1 << (getRace(true) - 1); }
         uint8 getClass() const { return GetByteValue(UNIT_FIELD_BYTES_0, 1); }
         uint32 getClassMask() const { return 1 << (getClass()-1); }
         uint8 getGender() const { return GetByteValue(UNIT_FIELD_BYTES_0, 2); }
@@ -2158,6 +2160,18 @@ class Unit : public WorldObject
         int32 GetHighestExclusiveSameEffectSpellGroupValue(AuraEffect const* aurEff, AuraType auraType, bool checkMiscValue = false, int32 miscValue = 0) const;
         bool IsHighestExclusiveAura(Aura const* aura, bool removeOtherAuraApplications = false);
 
+        //npcbot
+        bool HasReactive(ReactiveType reactive) const { return m_reactiveTimer[reactive] > 0; }
+        void ClearReactive(ReactiveType reactive);
+
+        void SuspendDelayedSwing();
+        void ExecuteDelayedSwingHit(bool extra = false);
+        CalcDamageInfo _damageInfo;
+        uint64 _delayedTargetGuid;
+        uint32 _swingDelayTimer;
+        bool _swingLanded;
+        //end npcbot
+
     protected:
         explicit Unit (bool isWorldObject);
 
diff --git a/src/server/game/Events/GameEventMgr.cpp b/src/server/game/Events/GameEventMgr.cpp
index e452253..158e96d 100644
--- a/src/server/game/Events/GameEventMgr.cpp
+++ b/src/server/game/Events/GameEventMgr.cpp
@@ -29,6 +29,7 @@
 #include "BattlegroundMgr.h"
 #include "UnitAI.h"
 #include "GameObjectAI.h"
+#include "IRCClient.h"
 
 bool GameEventMgr::CheckOneGameEvent(uint16 entry) const
 {
@@ -1088,7 +1089,12 @@ void GameEventMgr::ApplyNewEvent(uint16 event_id)
     uint8 announce = mGameEvent[event_id].announce;
     if (announce == 1 || (announce == 2 && sWorld->getBoolConfig(CONFIG_EVENT_ANNOUNCE)))
         sWorld->SendWorldText(LANG_EVENTMESSAGE, mGameEvent[event_id].description.c_str());
-
+       if ((sIRC.BOTMASK & 256) != 0)
+             {
+                 std::string ircchan = "#";
+                 ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+                 sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 Game Event \00304,08\037/!\\\037\017 %s", "%s", mGameEvent[event_id].description.c_str()), true);
+             }
     TC_LOG_INFO("gameevent", "GameEvent %u \"%s\" started.", event_id, mGameEvent[event_id].description.c_str());
 
     //! Run SAI scripts with SMART_EVENT_GAME_EVENT_END
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 278460e..00f69b9 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -7905,6 +7905,82 @@ SkillRangeType GetSkillRangeType(SkillRaceClassInfoEntry const* rcEntry)
     return SKILL_RANGE_LEVEL;
 }
 
+void ObjectMgr::LoadCreatureOutfits()
+{
+    uint32 oldMSTime = getMSTime();
+
+    _creatureOutfitStore.clear();                           // for reload case (test only)
+
+    //                                                 0     1      2      3     4     5       6           7
+    QueryResult result = WorldDatabase.Query("SELECT entry, race, gender, skin, face, hair, haircolor, facialhair, "
+        //8       9        10    11     12     13    14     15     16     17     18
+        "head, shoulders, body, chest, waist, legs, feet, wrists, hands, back, tabard FROM creature_template_outfits");
+
+    if (!result)
+    {
+        TC_LOG_ERROR("server.loading", ">> Loaded 0 creature outfits. DB table `creature_template_outfits` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 i = 0;
+        uint32 entry     = fields[i++].GetUInt32();
+
+        if (!GetCreatureTemplate(entry))
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits`, but not in `creature_template`!", entry);
+            continue;
+        }
+
+        CreatureOutfit co; // const, shouldnt be changed after saving
+        co.race          = fields[i++].GetUInt8();
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(co.race);
+        if (!rEntry)
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has incorrect race (%u).", entry, uint32(co.race));
+            continue;
+        }
+        co.gender        = fields[i++].GetUInt8();
+        // Set correct displayId
+        switch (co.gender)
+        {
+            case GENDER_FEMALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_f;
+                break;
+            case GENDER_MALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_m;
+                break;
+            default:
+                TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has invalid gender %u", entry, uint32(co.gender));
+                continue;
+        }
+        _creatureTemplateStore[entry].Modelid2 = 0;
+        _creatureTemplateStore[entry].Modelid3 = 0;
+        _creatureTemplateStore[entry].Modelid4 = 0;
+        _creatureTemplateStore[entry].unit_flags2 |= UNIT_FLAG2_MIRROR_IMAGE; // Needed so client requests mirror packet
+
+        co.skin          = fields[i++].GetUInt8();
+        co.face          = fields[i++].GetUInt8();
+        co.hair          = fields[i++].GetUInt8();
+        co.haircolor     = fields[i++].GetUInt8();
+        co.facialhair    = fields[i++].GetUInt8();
+        for (uint32 j = 0; j != MAX_CREATURE_OUTFIT_DISPLAYS; ++j)
+            co.outfit[j] = fields[i+j].GetUInt32();
+
+        _creatureOutfitStore[entry] = co;
+
+        ++count;
+    }
+    while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u creature outfits in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
 void ObjectMgr::LoadGameTele()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 3f8013b..448afa7 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -144,6 +144,21 @@ struct GameTele
 
 typedef std::unordered_map<uint32, GameTele > GameTeleContainer;
 
+#define MAX_CREATURE_OUTFIT_DISPLAYS 11
+struct CreatureOutfit
+{
+    uint8 race;
+    uint8 gender;
+    uint8 face;
+    uint8 skin;
+    uint8 hair;
+    uint8 facialhair;
+    uint8 haircolor;
+    uint32 outfit[MAX_CREATURE_OUTFIT_DISPLAYS];
+};
+
+typedef std::unordered_map<uint32, CreatureOutfit > CreatureOutfitContainer;
+
 enum ScriptsType
 {
     SCRIPTS_FIRST = 1,
@@ -1011,6 +1026,7 @@ class ObjectMgr
 
         void LoadNPCSpellClickSpells();
 
+        void LoadCreatureOutfits();
         void LoadGameTele();
 
         void LoadGossipMenu();
@@ -1219,6 +1235,8 @@ class ObjectMgr
         bool AddGameTele(GameTele& data);
         bool DeleteGameTele(std::string const& name);
 
+        CreatureOutfitContainer const& GetCreatureOutfitMap() const { return _creatureOutfitStore; }
+
         TrainerSpellData const* GetNpcTrainerSpells(uint32 entry) const
         {
             CacheTrainerSpellContainer::const_iterator  iter = _cacheTrainerSpellStore.find(entry);
@@ -1295,6 +1313,8 @@ class ObjectMgr
 
         bool IsTransportMap(uint32 mapId) const { return _transportMaps.count(mapId); }
 
+        ItemFakeStatContainer _itemFakeStatStore; // custom
+
     private:
         // first free id for selected id type
         uint32 _auctionId;
@@ -1365,6 +1385,8 @@ class ObjectMgr
         PageTextContainer _pageTextStore;
         InstanceTemplateContainer _instanceTemplateStore;
 
+        CreatureOutfitContainer _creatureOutfitStore;
+
     private:
         void LoadScripts(ScriptsType type);
         void CheckScripts(ScriptsType type, std::set<int32>& ids);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 45ecbf0..056a058 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -107,6 +107,11 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    //npcbot - set loot mode on create
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+        m_lootMethod = FREE_FOR_ALL;
+    else
+    //end npcbot
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -366,6 +371,10 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    //npcbot - check if trying to add bot
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
+    //end npcbot
     player->SetGroupInvite(NULL);
     if (player->GetGroup())
     {
@@ -381,6 +390,9 @@ bool Group::AddMember(Player* player)
     InstanceGroupBind* bind = GetBoundInstance(player);
     if (bind && bind->save->GetInstanceId() == player->GetInstanceId())
         player->m_InstanceValid = true;
+    //npcbot
+    }
+    //end npcbot
 
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
@@ -406,6 +418,10 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    //npcbot - check 2
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
+    //end npcbot
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -481,6 +497,9 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    //npcbot
+    }
+    //end npcbot
 
     return true;
 }
@@ -604,6 +623,9 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod& method /*= GROUP_REMOV
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot
+        if (GetMembersCount() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index f0061a7..6d28e40 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -309,6 +309,9 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //Bot
+        uint64 const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(uint64 guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Guilds/Guild.cpp b/src/server/game/Guilds/Guild.cpp
index db0a196..6cdc164 100644
--- a/src/server/game/Guilds/Guild.cpp
+++ b/src/server/game/Guilds/Guild.cpp
@@ -1206,6 +1206,9 @@ bool Guild::Create(Player* pLeader, std::string const& name)
     if (ret)
         sScriptMgr->OnGuildCreate(this, pLeader, name);
 
+    //Guild-Level-System
+    LoadLevelInfo();
+
     return ret;
 }
 
@@ -1957,6 +1960,10 @@ bool Guild::LoadFromDB(Field* fields)
         m_bankTabs[i] = new BankTab(m_id, i);
 
     _CreateLogHolders();
+
+    //Guild-Level-System
+    LoadLevelInfo();
+
     return true;
 }
 
@@ -2924,3 +2931,140 @@ void Guild::ResetTimes()
 
     _BroadcastEvent(GE_BANK_TAB_AND_MONEY_UPDATED, 0);
 }
+
+//Guild-Level-System [Start]
+void Guild::LoadLevelInfo()
+{
+    PreparedStatement* stmt;
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_LEVEL_INFO);
+    stmt->setUInt32(0, m_id);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+    {
+        m_current_guildXp = (*result)[0].GetUInt32();
+        m_guild_level = (*result)[1].GetUInt8();
+    }
+    else
+    {
+        m_current_guildXp = 0;
+        m_guild_level = 0;
+    }
+
+    if (m_guild_level < GUILD_MAX_LEVEL)
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_XP_FOR_NEXT_LEVEL);
+        stmt->setUInt32(0, m_guild_level);
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+        if (result)
+            m_xp_for_next_level = (*result)[0].GetUInt32();
+        else
+            m_xp_for_next_level = 0;
+    }
+}
+
+bool Guild::HasLevelForBonus(uint8 guildBonus)
+{
+    switch (guildBonus)
+    {
+    case GUILD_BONUS_GOLD_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_GOLD_1);
+        break;
+    case GUILD_BONUS_XP_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_XP_1);
+        break;
+    case GUILD_BONUS_SCHNELLER_GEIST:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_SCHNELLER_GEIST);
+        break;
+    case GUILD_BONUS_REPERATUR_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_REPERATUR_1);
+        break;
+    case GUILD_BONUS_GOLD_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_GOLD_2);
+        break;
+    case GUILD_BONUS_REITTEMPO_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_REITTEMPO_1);
+        break;
+    case GUILD_BONUS_RUF_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_RUF_1);
+        break;
+    case GUILD_BONUS_XP_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_XP_2);
+        break;
+    case GUILD_BONUS_REPERATUR_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_REPERATUR_2);
+        break;
+    case GUILD_BONUS_REITTEMPO_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_REITTEMPO_2);
+        break;
+    case GUILD_BONUS_RUF_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_RUF_2);
+        break;
+    case GUILD_BONUS_EHRE_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_EHRE_1);
+        break;
+    case GUILD_BONUS_EHRE_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_EHRE_2);
+        break;
+    default:
+        return false;
+        break;
+    }
+}
+
+void Guild::GiveXp(uint32 value)
+{
+    if (m_guild_level > GUILD_MAX_LEVEL)
+        return;
+
+    if ((m_current_guildXp + value) >= m_xp_for_next_level)
+    {
+        m_current_guildXp = ((m_current_guildXp + value) - m_xp_for_next_level);
+        SetLevel(m_guild_level + 1, false);
+    }
+    else
+        m_current_guildXp += value;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GUILD_XP);
+    stmt->setUInt32(0, value);
+    stmt->setUInt32(1, m_id);
+    CharacterDatabase.Execute(stmt);
+}
+
+void Guild::SetLevel(uint8 level, bool byCommand)
+{
+    if (level > GUILD_MAX_LEVEL)
+        return;
+
+    m_guild_level = level;
+
+    if (byCommand)
+    {
+        m_current_guildXp = 0;
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GUILD_XP);
+        stmt->setUInt8(0, m_current_guildXp);
+        stmt->setUInt32(1, m_id);
+        CharacterDatabase.Execute(stmt);
+    }
+
+    char worldMsg[250];
+    sprintf(worldMsg, "Die Gilde %s hat das Gildenlevel %d erreicht.", m_name.c_str(), level);
+    sWorld->SendWorldText(SERVER_MSG_STRING, worldMsg);
+
+    //Save to DB
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GUILD_LEVEL);
+    stmt->setUInt8(0, level);
+    stmt->setUInt32(1, m_id);
+    CharacterDatabase.Execute(stmt);
+
+    //reqXp fuers naechste Level laden
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_XP_FOR_NEXT_LEVEL);
+    stmt->setUInt32(0, level);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+        m_xp_for_next_level = (*result)[0].GetUInt32();
+}
+//Guild-Level-System [End]
diff --git a/src/server/game/Guilds/Guild.h b/src/server/game/Guilds/Guild.h
index ea0b2e4..d5f3d77 100644
--- a/src/server/game/Guilds/Guild.h
+++ b/src/server/game/Guilds/Guild.h
@@ -222,6 +222,29 @@ enum GuildMemberFlags
     GUILDMEMBER_STATUS_MOBILE           = 0x0008, // remote chat from mobile app
 };
 
+//Guild-Level-System [Start]
+enum GuildBonus
+{
+    GUILD_BONUS_GOLD_1 = 1,
+    GUILD_BONUS_XP_1 = 2,
+    GUILD_BONUS_SCHNELLER_GEIST = 3,
+    GUILD_BONUS_REPERATUR_1 = 4,
+    GUILD_BONUS_GOLD_2 = 5,
+    GUILD_BONUS_REITTEMPO_1 = 6,
+    GUILD_BONUS_RUF_1 = 7,
+    GUILD_BONUS_XP_2 = 8,
+    GUILD_BONUS_REPERATUR_2 = 9,
+    GUILD_BONUS_REITTEMPO_2 = 10,
+    GUILD_BONUS_RUF_2 = 11,
+    GUILD_BONUS_EHRE_1 = 12,
+    GUILD_BONUS_EHRE_2 = 13,
+
+    GUILD_BONUS_MAX = 14
+};
+
+#define GUILD_MAX_LEVEL 8
+//Guild-Level-System [End]
+
 // Emblem info
 class EmblemInfo
 {
@@ -740,6 +763,15 @@ public:
 
     void ResetTimes();
 
+    //Guild-Level-System
+    void LoadLevelInfo();
+    bool HasLevelForBonus(uint8 guildBonus);
+    void GiveXp(uint32 value);
+    void SetLevel(uint8 level, bool byCommand);
+    uint8 GetLevel() const { return m_guild_level; };
+    uint32 GetCurrentXP() const { return m_current_guildXp; };
+    uint32 GetXpForNextLevel() const { return m_xp_for_next_level; };
+
 protected:
     uint32 m_id;
     std::string m_name;
@@ -760,6 +792,11 @@ protected:
     LogHolder* m_eventLog;
     LogHolder* m_bankEventLog[GUILD_BANK_MAX_TABS + 1];
 
+    //Guild-Level-System
+    uint8 m_guild_level;
+    uint32 m_current_guildXp;
+    uint32 m_xp_for_next_level;
+
 private:
     inline uint8 _GetRanksSize() const { return uint8(m_ranks.size()); }
     inline const RankInfo* GetRankInfo(uint8 rankId) const { return rankId < _GetRanksSize() ? &m_ranks[rankId] : NULL; }
diff --git a/src/server/game/Handlers/AuctionHouseHandler.cpp b/src/server/game/Handlers/AuctionHouseHandler.cpp
index 86fa042..6346691 100644
--- a/src/server/game/Handlers/AuctionHouseHandler.cpp
+++ b/src/server/game/Handlers/AuctionHouseHandler.cpp
@@ -22,6 +22,7 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+#include "AuctionHouseBot.h"
 #include "AuctionHouseMgr.h"
 #include "Log.h"
 #include "Language.h"
@@ -29,6 +30,7 @@
 #include "UpdateMask.h"
 #include "Util.h"
 #include "AccountMgr.h"
+#include "IRCClient.h"
 
 //void called when player click on auctioneer npc
 void WorldSession::HandleAuctionHelloOpcode(WorldPacket& recvData)
@@ -574,10 +576,16 @@ void WorldSession::HandleAuctionRemoveItem(WorldPacket& recvData)
     SendAuctionCommandResult(auction->Id, AUCTION_CANCEL, ERR_AUCTION_OK);
 
     // Now remove the auction
-
+    uint32 item;
+    recvData >> item;
     player->SaveInventoryAndGoldToDB(trans);
     auction->DeleteFromDB(trans);
     CharacterDatabase.CommitTransaction(trans);
+  if ((sIRC.BOTMASK & 1024) != 0)
+  {
+  ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(item);
+    sIRC.AHFunc(auction->itemEntry, pProto->Name1, player->GetName(), auction->GetHouseId());
+  }
 
     uint32 itemEntry = auction->itemEntry;
     sAuctionMgr->RemoveAItem(auction->itemGUIDLow);
diff --git a/src/server/game/Handlers/BattleGroundHandler.cpp b/src/server/game/Handlers/BattleGroundHandler.cpp
index 7def6b0..caa424e 100644
--- a/src/server/game/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Handlers/BattleGroundHandler.cpp
@@ -35,6 +35,8 @@
 #include "DisableMgr.h"
 #include "Group.h"
 
+#include "Cfbg/Cfbg.h"
+
 void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket& recvData)
 {
     uint64 guid;
@@ -543,7 +545,7 @@ void WorldSession::HandleBattlefieldStatusOpcode(WorldPacket & /*recvData*/)
             {
                 // this line is checked, i only don't know if GetStartTime is changing itself after bg end!
                 // send status in Battleground
-                sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, i, STATUS_IN_PROGRESS, bg->GetEndTime(), bg->GetStartTime(), arenaType, _player->GetBGTeam());
+                sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, i, STATUS_IN_PROGRESS, bg->GetEndTime(), bg->GetStartTime(), arenaType, _player->GetTeam());
                 SendPacket(&data);
                 continue;
             }
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 9ad382b..bca9e7e 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -1043,6 +1043,9 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     sScriptMgr->OnPlayerLogin(pCurrChar, firstLogin);
 
     delete holder;
+
+    if (pCurrChar->GetTeam() != pCurrChar->GetOTeam())
+        pCurrChar->FitPlayerInTeam(pCurrChar->GetBattleground() && !pCurrChar->GetBattleground()->isArena() ? true : false, pCurrChar->GetBattleground());
 }
 
 void WorldSession::HandleSetFactionAtWar(WorldPacket& recvData)
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index eccf7a6..fab6e9f 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -39,6 +39,7 @@
 #include "Util.h"
 #include "ScriptMgr.h"
 #include "AccountMgr.h"
+#include "IRCClient.h"
 
 void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 {
@@ -48,6 +49,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
     recvData >> type;
     recvData >> lang;
 
+    if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) && lang != LANG_ADDON)
+    {
+        switch (type)
+        {
+        case CHAT_MSG_BATTLEGROUND:
+        case CHAT_MSG_BATTLEGROUND_LEADER:
+            lang = LANG_UNIVERSAL;
+        default:
+            break;
+        }
+    }
+
     if (type >= MAX_CHAT_MSG_TYPE)
     {
         TC_LOG_ERROR("network", "CHAT: Wrong message type received: %u", type);
@@ -55,7 +68,7 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
         return;
     }
 
-    if (lang == LANG_UNIVERSAL && type != CHAT_MSG_AFK && type != CHAT_MSG_DND)
+    if (lang == CHAT_MSG_AFK && type != CHAT_MSG_DND)
     {
         TC_LOG_ERROR("network", "CMSG_MESSAGECHAT: Possible hacking-attempt: %s tried to send a message in universal language", GetPlayerInfo().c_str());
         SendNotification(LANG_UNKNOWN_LANGUAGE);
@@ -253,6 +266,10 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
             }
 
+            if (!GetPlayer()->IsGameMaster())
+                if (GetPlayer()->SendBattleGroundChat(type, msg))
+                    return;
+
             if (type == CHAT_MSG_SAY)
                 sender->Say(msg, lang);
             else if (type == CHAT_MSG_EMOTE)
@@ -271,8 +288,17 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             Player* receiver = sObjectAccessor->FindPlayerByName(to);
             if (!receiver || (lang != LANG_ADDON && !receiver->isAcceptWhispers() && receiver->GetSession()->HasPermission(rbac::RBAC_PERM_CAN_FILTER_WHISPERS) && !receiver->IsInWhisperWhiteList(sender->GetGUID())))
             {
+                // If Fake WHO List system on then show player DND
+                if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST))
+                {
+                    ChatHandler(sender->GetSession()).PSendSysMessage(LANG_NOT_WHISPER);
+                    return;
+                }
+                else
+                {
                 SendPlayerNotFoundNotice(to);
                 return;
+                }
             }
             if (!sender->IsGameMaster() && sender->getLevel() < sWorld->getIntConfig(CONFIG_CHAT_WHISPER_LEVEL_REQ) && !receiver->IsInWhisperWhiteList(sender->GetGUID()))
             {
@@ -431,6 +457,7 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 
             if (ChannelMgr* cMgr = ChannelMgr::forTeam(sender->GetTeam()))
             {
+                sIRC.Send_WoW_IRC(sender, channel, msg);
                 if (Channel* chn = cMgr->GetChannel(channel, sender))
                 {
                     sScriptMgr->OnPlayerChat(sender, type, lang, msg, chn);
diff --git a/src/server/game/Handlers/LootHandler.cpp b/src/server/game/Handlers/LootHandler.cpp
index b9c6f34..8bc8798 100644
--- a/src/server/game/Handlers/LootHandler.cpp
+++ b/src/server/game/Handlers/LootHandler.cpp
@@ -30,6 +30,7 @@
 #include "World.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
+#include "Guild.h"
 
 void WorldSession::HandleAutostoreLootItemOpcode(WorldPacket& recvData)
 {
@@ -203,6 +204,16 @@ void WorldSession::HandleLootMoneyOpcode(WorldPacket& /*recvData*/)
             SendPacket(&data);
         }
 
+        //Guild-Level-System (Bonus: Gold)
+        if (Guild* guild = player->GetGuild())
+        {
+            //Extra Gold fuer die Gildenbank
+            if (guild->HasLevelForBonus(GUILD_BONUS_GOLD_1))
+                guild->HandleMemberDepositMoney(this, uint32(loot->gold*0.05f));
+            if (guild->HasLevelForBonus(GUILD_BONUS_GOLD_2))
+                guild->HandleMemberDepositMoney(this, uint32(loot->gold*0.1f));
+        }
+
         loot->gold = 0;
 
         // Delete the money loot record from the DB
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index c4ff258..b2ea41e 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -364,7 +364,39 @@ void WorldSession::HandleWhoOpcode(WorldPacket& recvData)
         ++displaycount;
     }
 
-    data.put(0, displaycount);                            // insert right count, count displayed
+    if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST) && displaycount < 49)
+    {
+        // Fake players on WHO LIST                            0,   1,    2,   3,    4,   5
+        QueryResult result = CharacterDatabase.Query("SELECT name,race,class,level,zone,gender FROM characters_fake WHERE level > 3");
+        if (result)
+        {
+            do
+            {
+                Field *fields = result->Fetch();
+
+                std::string pname = fields[0].GetString();    // player name
+                std::string gname;                                // guild name
+                uint32 lvl = fields[3].GetUInt32();                // player level
+                uint32 class_ = fields[2].GetUInt32();            // player class
+                uint32 race = fields[1].GetUInt32();            // player race
+                uint32 pzoneid = fields[4].GetUInt32();            // player zone id
+                uint8 gender = fields[5].GetUInt8();            // player gender
+
+                data << pname;                              // player name
+                data << gname;                              // guild name
+                data << uint32(lvl);                        // player level
+                data << uint32(class_);                     // player class
+                data << uint32(race);                       // player race
+                data << uint8(gender);                      // player gender
+                data << uint32(pzoneid);                    // player zone id
+
+                if ((++matchcount) == 49)
+                    break;
+            } while (result->NextRow());
+        }
+    }
+
+    data.put(0, matchcount);                            // insert right count, count displayed
     data.put(4, matchcount);                              // insert right count, count of matches
 
     SendPacket(&data);
@@ -1431,6 +1463,21 @@ void WorldSession::HandleSetTitleOpcode(WorldPacket& recvData)
 
 void WorldSession::HandleTimeSyncResp(WorldPacket& recvData)
 {
+    Battleground* bg = _player->GetBattleground();
+    if (bg)
+    {
+        if (_player->ShouldForgetBGPlayers() && bg)
+        {
+            _player->DoForgetPlayersInBG(bg);
+            _player->SetForgetBGPlayers(false);
+        }
+    }
+    else if (_player->ShouldForgetInListPlayers())
+    {
+        _player->DoForgetPlayersInList();
+        _player->SetForgetInListPlayers(false);
+    }
+
     TC_LOG_DEBUG("network", "CMSG_TIME_SYNC_RESP");
 
     uint32 counter, clientTicks;
diff --git a/src/server/game/Handlers/MovementHandler.cpp b/src/server/game/Handlers/MovementHandler.cpp
index 6fedc48..66a1fa6 100644
--- a/src/server/game/Handlers/MovementHandler.cpp
+++ b/src/server/game/Handlers/MovementHandler.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "AnticheatMgr.h"
 #include "Common.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
@@ -343,6 +344,9 @@ void WorldSession::HandleMovementOpcodes(WorldPacket& recvData)
         plrMover->SetInWater(!plrMover->IsInWater() || plrMover->GetBaseMap()->IsUnderWater(movementInfo.pos.GetPositionX(), movementInfo.pos.GetPositionY(), movementInfo.pos.GetPositionZ()));
     }
 
+    if (plrMover)
+        sAnticheatMgr->StartHackDetection(plrMover, movementInfo, opcode);
+
     uint32 mstime = getMSTime();
     /*----------------------*/
     if (m_clientTimeDelay == 0)
diff --git a/src/server/game/Handlers/QueryHandler.cpp b/src/server/game/Handlers/QueryHandler.cpp
index dbcfb1c..f3ff127 100644
--- a/src/server/game/Handlers/QueryHandler.cpp
+++ b/src/server/game/Handlers/QueryHandler.cpp
@@ -48,7 +48,7 @@ void WorldSession::SendNameQueryOpcode(uint64 guid)
     data << uint8(0);                               // name known
     data << nameData->m_name;                       // played name
     data << uint8(0);                               // realm name - only set for cross realm interaction (such as Battlegrounds)
-    data << uint8(nameData->m_race);
+    data << uint8(player ? player->getRace() : nameData->m_race);
     data << uint8(nameData->m_gender);
     data << uint8(nameData->m_class);
 
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index ba30803..f2f79df 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -33,6 +33,7 @@
 #include "GameObjectAI.h"
 #include "SpellAuraEffects.h"
 #include "Player.h"
+#include "../../scripts/Custom/Transmogrification.h"
 
 void WorldSession::HandleClientCastFlags(WorldPacket& recvPacket, uint8 castFlags, SpellCastTargets& targets)
 {
@@ -568,8 +569,38 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
     if (!unit)
         return;
 
+    //bot
+    if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        CreatureOutfitContainer const& outfits = sObjectMgr->GetCreatureOutfitMap();
+        CreatureOutfitContainer::const_iterator it = outfits.find(unit->GetEntry());
+        if (it != outfits.end())
+        {
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << uint64(guid);
+            data << uint32(unit->GetNativeDisplayId()); // displayId
+            data << uint8(it->second.race);             // race
+            data << uint8(it->second.gender);           // gender
+            data << uint8(unit->getClass());            // class
+            data << uint8(it->second.skin);             // skin
+            data << uint8(it->second.face);             // face
+            data << uint8(it->second.hair);             // hair
+            data << uint8(it->second.haircolor);        // haircolor
+            data << uint8(it->second.facialhair);       // facialhair
+            data << uint32(0);                          // guildId
+
+            // item displays
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+                data << uint32(it->second.outfit[i]);
+
+            SendPacket(&data);
+            return;
+        }
+    }
+
     if (!unit->HasAuraType(SPELL_AURA_CLONE_CASTER))
         return;
+    //end bot
 
     // Get creator of the unit (SPELL_AURA_CLONE_CASTER does not stack)
     Unit* creator = unit->GetAuraEffectsByType(SPELL_AURA_CLONE_CASTER).front()->GetCaster();
@@ -617,7 +648,12 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
             else if (*itr == EQUIPMENT_SLOT_BACK && player->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK))
                 data << uint32(0);
             else if (Item const* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, *itr))
-                data << uint32(item->GetTemplate()->DisplayInfoID);
+            {
+                if (uint32 entry = sTransmogrification->GetFakeEntry(item))
+                    data << uint32(sObjectMgr->GetItemTemplate(entry)->DisplayInfoID);
+                else
+                    data << uint32(item->GetTemplate()->DisplayInfoID);
+            }
             else
                 data << uint32(0);
         }
diff --git a/src/server/game/Mails/Mail.cpp b/src/server/game/Mails/Mail.cpp
index 2c65e36..283efa7 100644
--- a/src/server/game/Mails/Mail.cpp
+++ b/src/server/game/Mails/Mail.cpp
@@ -27,6 +27,7 @@
 #include "Item.h"
 #include "AuctionHouseMgr.h"
 #include "CalendarMgr.h"
+#include "AuctionHouseBot.h"
 
 MailSender::MailSender(Object* sender, MailStationery stationery) : m_stationery(stationery)
 {
@@ -180,6 +181,13 @@ void MailDraft::SendMailTo(SQLTransaction& trans, MailReceiver const& receiver,
 
     uint32 mailId = sObjectMgr->GenerateMailID();
 
+    if (receiver.GetPlayerGUIDLow() == auctionbot.GetAHBplayerGUID())
+    {
+        if (sender.GetMailMessageType() == MAIL_AUCTION)        // auction mail with items
+            deleteIncludedItems(trans, true);
+        return;
+    }
+
     time_t deliver_time = time(NULL) + deliver_delay;
 
     //expire time if COD 3 days, if no COD 30 days, if auction sale pending 1 hour
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 01e3af1..8fa51b3 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -36,6 +36,10 @@
 #include "Vehicle.h"
 #include "VMapFactory.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 u_map_magic MapMagic        = { {'M','A','P','S'} };
 u_map_magic MapVersionMagic = { {'v','1','.','3'} };
 u_map_magic MapAreaMagic    = { {'A','R','E','A'} };
@@ -2673,6 +2677,21 @@ uint32 Map::GetPlayersCountExceptGMs() const
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
         if (!itr->GetSource()->IsGameMaster())
+            //npcbot - count npcbots as group members (event if not in group)
+            if (itr->GetSource()->HaveBot() && BotMgr::LimitBots(this))
+            {
+                ++count;
+                BotMap const* botmap = itr->GetSource()->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = botmap->begin(); itr != botmap->end(); ++itr)
+                {
+                    Creature* cre = itr->second;
+                    if (!cre || !cre->IsInWorld() || cre->FindMap() != this)
+                        continue;
+                    ++count;
+                }
+            }
+            else
+            //end npcbot
             ++count;
     return count;
 }
@@ -2739,6 +2758,10 @@ void Map::AddToActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->incUnloadActiveLock();
+        //bot
+        else if (c->GetIAmABot())
+            EnsureGridLoadedForActiveObject(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())), c);
+        //end bot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
@@ -2770,6 +2793,10 @@ void Map::RemoveFromActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->decUnloadActiveLock();
+        //bot
+        else if (c->GetIAmABot())
+            EnsureGridLoaded(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())));
+        //end bot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
diff --git a/src/server/game/Maps/MapManager.cpp b/src/server/game/Maps/MapManager.cpp
index d8c8889..a83bab8 100644
--- a/src/server/game/Maps/MapManager.cpp
+++ b/src/server/game/Maps/MapManager.cpp
@@ -37,6 +37,10 @@
 #include "WorldSession.h"
 #include "Opcodes.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 MapManager::MapManager()
 {
     i_gridCleanUpDelay = sWorld->getIntConfig(CONFIG_INTERVAL_GRIDCLEAN);
@@ -54,6 +58,82 @@ void MapManager::Initialize()
     // Start mtmaps if needed.
     if (num_threads > 0 && m_updater.activate(num_threads) == -1)
         abort();
+
+    //npcbot - spawn bots
+    BotMgr::LoadConfig();
+
+    if (!BotMgr::IsNpcBotModEnabled())
+        return;
+
+    uint32 botoldMSTime = getMSTime();
+
+    TC_LOG_INFO("server.loading", "Starting NpcBot system...");
+    PreparedStatement* botstmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOTS);
+    //"SELECT entry FROM characters_npcbot", CONNECTION_SYNCH
+    PreparedQueryResult res = CharacterDatabase.Query(botstmt);
+    if (!res)
+    {
+        TC_LOG_INFO("server.loading", ">> Spawned 0 npcbots. Table `characters_npcbot` is empty!");
+        return;
+    }
+
+    PreparedQueryResult infores;
+    uint32 botcounter = 0;
+    Field* field;
+    std::list<uint32> botgrids;
+    do
+    {
+        field = res->Fetch();
+        uint32 entry = field[0].GetUInt32();
+        CreatureTemplate const* proto = sObjectMgr->GetCreatureTemplate(entry);
+        if (!proto)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot find creature_template entry for npcbot (id: %u)!", entry);
+            continue;
+        }
+
+        botstmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_INFO);
+        //"SELECT guid, map, position_x, position_y, position_z, orientation FROM creature WHERE id = ?", CONNECTION_SYNCH
+        botstmt->setUInt32(0, entry);
+        infores = WorldDatabase.Query(botstmt);
+        if (!infores)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot spawn npcbot %s (id: %u), not found in `creature` table!", proto->Name.c_str(), entry);
+            continue;
+        }
+
+        field = infores->Fetch();
+        uint32 tableGuid = field[0].GetUInt32();
+        uint32 mapId = uint32(field[1].GetUInt16());
+        float pos_x = field[2].GetFloat();
+        float pos_y = field[3].GetFloat();
+        //float pos_z = field[4].GetFloat();
+        //float ori = field[5].GetFloat();
+
+        CellCoord c = Trinity::ComputeCellCoord(pos_x, pos_y);
+        GridCoord g = Trinity::ComputeGridCoord(pos_x, pos_y);
+        ASSERT(c.IsCoordValid() && "Invalid Cell coord!");
+        ASSERT(g.IsCoordValid() && "Invalid Grid coord!");
+        Map* npcbotmap = sMapMgr->CreateBaseMap(mapId);
+        npcbotmap->LoadGrid(pos_x, pos_y);
+        Creature* bot = npcbotmap->GetCreature(MAKE_NEW_GUID(tableGuid, entry, HIGHGUID_UNIT));
+        ASSERT(bot);
+        //debug
+        if (!bot->IsAlive())
+        {
+            bot->Respawn();
+            bot->ResetBotAI(1);
+        }
+
+        TC_LOG_DEBUG("server.loading", ">> Spawned npcbot %s (id: %u, map: %u, grid: %u, cell: %u)", proto->Name.c_str(), entry, mapId, g.GetId(), c.GetId());
+        botgrids.push_back(g.GetId());
+        ++botcounter;
+
+    } while (res->NextRow());
+
+    botgrids.unique();
+    TC_LOG_INFO("server.loading", ">> Spawned %u npcbot(s) within %u grid(s) in %u ms", botcounter, botgrids.size(), GetMSTimeDiffToNow(botoldMSTime));
+    //end npcbot
 }
 
 void MapManager::InitializeVisibilityDistanceInfo()
diff --git a/src/server/game/Miscellaneous/Formulas.h b/src/server/game/Miscellaneous/Formulas.h
index 8d0e97d..34ffffe 100644
--- a/src/server/game/Miscellaneous/Formulas.h
+++ b/src/server/game/Miscellaneous/Formulas.h
@@ -23,6 +23,7 @@
 #include "SharedDefines.h"
 #include "ScriptMgr.h"
 #include "Player.h"
+#include "Guild.h"
 
 namespace Trinity
 {
@@ -180,7 +181,20 @@ namespace Trinity
                         gain *= 2;
                 }
 
-                gain = uint32(gain * sWorld->getRate(RATE_XP_KILL));
+                //Individuale_XP-Rate
+                float individualXpKill = player->GetIndividualXpKillRate();
+
+                gain = uint32(gain * (individualXpKill > 0 ? individualXpKill : sWorld->getRate(RATE_XP_KILL)));
+
+                //Guild-Level-System (Bonus: MonsterKillXp)
+                if (Guild* guild = player->GetGuild())
+                {
+                    // Guild XP-Bonus
+                    if (guild->HasLevelForBonus(GUILD_BONUS_XP_1))
+                        gain += uint32(gain*0.05f);
+                    if (guild->HasLevelForBonus(GUILD_BONUS_XP_2))
+                        gain += uint32(gain*0.1f);
+                }
             }
 
             sScriptMgr->OnGainCalculation(gain, player, u);
diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
index 3a680e3..f0eb40b 100644
--- a/src/server/game/Miscellaneous/Language.h
+++ b/src/server/game/Miscellaneous/Language.h
@@ -796,7 +796,18 @@ enum TrinityStrings
     LANG_NPCINFO_SPELLCLICK             = 840,
     LANG_NPCINFO_MAILBOX                = 841,
     LANG_NPCINFO_PLAYER_VEHICLE         = 842,
-
+// Start AIO by LordPsyan
+    LANG_SOTA                           = 990,
+    LANG_AV                             = 991,
+    LANG_ARENA_3                        = 992,
+    LANG_ARENA_2                        = 993,
+    LANG_ARENA_1                        = 994,
+    LANG_RANDOM                         = 995,
+    LANG_EOTS                           = 996,
+    LANG_AB                             = 997,
+    LANG_WSG                            = 998,
+    LANG_WG                             = 999,
+// End AIO
     // Pinfo commands
     LANG_PINFO_PLAYER                   = 453,
     LANG_PINFO_GM_ACTIVE                = 548,
@@ -1225,8 +1236,18 @@ enum TrinityStrings
     LANG_BAN_ACCOUNT_YOUPERMBANNEDMESSAGE_WORLD   = 11007,
 
     LANG_NPCINFO_INHABIT_TYPE                     = 11008,
-    LANG_NPCINFO_FLAGS_EXTRA                      = 11009
-
+    LANG_NPCINFO_FLAGS_EXTRA                      = 11009,
+    // Fake Players
+    LANG_NOT_WHISPER                              = 12001,
+    // Guild-Level-System
+    LANG_GUILDINFO_LEVEL                          = 13000,
+    LANG_GUILDINFO_XP_INFO                        = 13001,
+    // Individual XP-Rate
+    LANG_INDIVIDUAL_KILLRATE_SET                  = 15000,
+    LANG_INDIVIDUAL_QUESTRATE_SET                 = 15001,
+    LANG_INDIVIDUAL_RATE_TO_HIGH                  = 15002,
+    LANG_INDIVIDUAL_RATE_TO_LOW                   = 15003,
+    LANG_INDIVIDUAL_RATES_INFO                    = 15004
     // NOT RESERVED IDS                   12000-1999999999
     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
     // For other tables maybe             2000010000-2147483647 (max index)
diff --git a/src/server/game/Movement/MotionMaster.cpp b/src/server/game/Movement/MotionMaster.cpp
index 55f745d..43f75a5 100644
--- a/src/server/game/Movement/MotionMaster.cpp
+++ b/src/server/game/Movement/MotionMaster.cpp
@@ -364,6 +364,20 @@ void MotionMaster::MoveJumpTo(float angle, float speedXY, float speedZ)
 
     float x, y, z;
 
+    //npcbot
+    if (_owner->GetTypeId() == TYPEID_UNIT && _owner->ToCreature()->IsNPCBot())
+    {
+        Movement::MoveSplineInit init(_owner);
+        init.MoveTo(x, y, z);
+        init.SetParabolic(speedZ/*max_height*/, 0);
+        init.SetOrientationFixed(true);
+        init.SetVelocity(speedXY);
+        init.Launch();
+        Mutate(new EffectMovementGenerator(0), MOTION_SLOT_CONTROLLED);
+        return;
+    }
+    //end npcbot
+
     float moveTimeHalf = speedZ / Movement::gravity;
     float dist = 2 * moveTimeHalf * speedXY;
     _owner->GetClosePoint(x, y, z, _owner->GetObjectSize(), dist, angle);
diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.cpp b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
index cacec14..70d5f02 100644
--- a/src/server/game/OutdoorPvP/OutdoorPvP.cpp
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
@@ -308,6 +308,23 @@ bool OPvPCapturePoint::Update(uint32 diff)
     if (!fact_diff)
         return false;
 
+    //npcbots - count bots as players but 2 times less affect and only if there is a players difference
+    uint32 botsCount[2];
+
+    for (uint8 team = 0; team != 2; ++team)
+    {
+        botsCount[team] = 0;
+
+        for (PlayerSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        {
+            if (Player* player = ObjectAccessor::FindPlayer(*itr))
+                botsCount[team] += player->GetNpcBotsCount();
+        }
+    }
+
+    fact_diff += 0.5f * float(botsCount[0] - botsCount[1]) * diff / OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL;
+    //end npcbot
+
     uint32 Challenger = 0;
     float maxDiff = m_maxSpeed * diff;
 
diff --git a/src/server/game/Reputation/ReputationMgr.cpp b/src/server/game/Reputation/ReputationMgr.cpp
index 46b73e7..08d18a0 100644
--- a/src/server/game/Reputation/ReputationMgr.cpp
+++ b/src/server/game/Reputation/ReputationMgr.cpp
@@ -25,6 +25,7 @@
 #include "ObjectMgr.h"
 #include "ScriptMgr.h"
 #include "WorldSession.h"
+#include "Guild.h"
 
 const int32 ReputationMgr::PointsInRank[MAX_REPUTATION_RANK] = {36000, 3000, 3000, 3000, 6000, 12000, 21000, 1000};
 
@@ -367,6 +368,15 @@ bool ReputationMgr::SetOneFactionReputation(FactionEntry const* factionEntry, in
             standing += itr->second.Standing + BaseRep;
         }
 
+        //Guild-Level-System (Bonus: Ruf)
+        if (Guild* guild = _player->GetGuild())
+        {
+            if (guild->HasLevelForBonus(GUILD_BONUS_RUF_1))
+                standing += uint32(standing*0.05f);
+            if (guild->HasLevelForBonus(GUILD_BONUS_RUF_2))
+                standing += uint32(standing*0.1f);
+        }
+
         if (standing > Reputation_Cap)
             standing = Reputation_Cap;
         else if (standing < Reputation_Bottom)
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index f1359b7..b9b464a 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -17,6 +17,7 @@
 
 #include "ScriptLoader.h"
 #include "World.h"
+#include "AnticheatMgr.h"
 
 //examples
 void AddSC_example_creature();
@@ -45,9 +46,11 @@ void AddSC_holiday_spell_scripts();
 void AddSC_SmartScripts();
 
 //Commands
+void AddSC_anticheat_commandscript();
 void AddSC_account_commandscript();
 void AddSC_achievement_commandscript();
 void AddSC_arena_commandscript();
+void AddSC_ah_bot_commandscript();
 void AddSC_ban_commandscript();
 void AddSC_bf_commandscript();
 void AddSC_cast_commandscript();
@@ -698,7 +701,6 @@ void AddSC_outdoorpvp_zm();
 // player
 void AddSC_chat_log();
 void AddSC_action_ip_logger();
-
 #endif
 
 void AddScripts()
@@ -707,6 +709,7 @@ void AddScripts()
     AddSpellScripts();
     AddSC_SmartScripts();
     AddCommandScripts();
+    sAnticheatMgr->StartScripts();
 #ifdef SCRIPTS
     AddWorldScripts();
     AddEasternKingdomsScripts();
@@ -751,9 +754,11 @@ void AddSpellScripts()
 
 void AddCommandScripts()
 {
+    AddSC_anticheat_commandscript();
     AddSC_account_commandscript();
     AddSC_achievement_commandscript();
     AddSC_arena_commandscript();
+    AddSC_ah_bot_commandscript();
     AddSC_ban_commandscript();
     AddSC_bf_commandscript();
     AddSC_cast_commandscript();
@@ -1440,13 +1445,101 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
-
+// All In One NPC
+void AddSC_npc_all();
+// Arena Gambler
+void AddSC_ArenaGambler();
+// Beast Master
+void AddSC_Npc_Beastmaster();
+// Congrats on Level
+void AddSC_custom_CongratsOnLevel();
+// Guildhouse
+void AddSC_guildmaster();
+// Killstreak
+void AddSC_PvP_System();
+// Buff NPC
+void AddSC_Npc_Buff();
+// Level NPC
+void AddSC_levelnpc();
+// Enchant NPC
+void AddSC_npc_enchantment();
+// Profession NPC
+void AddSC_professionnpc();
+// Reforging
+void AddSC_REFORGER_NPC();
+// IceRune
+void AddSC_summon();
+// TeleNPC2
+void AddSC_npc_teleport();
+// Transmogrification
+void AddSC_PWS_Transmogrification();
+void AddSC_CS_Transmogrification();
+// Bots
+void AddSC_death_knight_bot();
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_blademaster_bot();
+void AddSC_script_bot_commands();
+// advanced (disabled)
+// void AddSC_BotQuests_chapter1();
+// end Bots
 #endif
 
 void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
-
+    // All In One NPC
+    AddSC_npc_all();
+    // Arena Gambler
+    AddSC_ArenaGambler();
+    // Beast Master
+    AddSC_Npc_Beastmaster();
+    // Congrats on Level
+    AddSC_custom_CongratsOnLevel();
+    // Guildhouse
+    AddSC_guildmaster();
+    // Killstreak
+    AddSC_PvP_System();
+    // Buff NPC
+    AddSC_Npc_Buff();
+    // Level NPC
+    AddSC_levelnpc();
+    // Enchant NPC
+    AddSC_npc_enchantment();
+    // Profession Npc
+    AddSC_professionnpc();
+    // Reforging
+    AddSC_REFORGER_NPC();
+    // IceRune
+    AddSC_summon();
+    // TeleNPC2
+    AddSC_npc_teleport();
+    // Transmogrification
+    AddSC_PWS_Transmogrification();
+    AddSC_CS_Transmogrification();
+    // Bots
+    AddSC_death_knight_bot();
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_blademaster_bot();
+    AddSC_script_bot_commands();
+    // advanced (disabled)
+    // AddSC_BotQuests_chapter1();
+    // end Bots
 #endif
 }
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index 83f401d..cac467b 100644
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -23,6 +23,7 @@
 #include "ObjectMgr.h"
 #include "OutdoorPvPMgr.h"
 #include "ScriptLoader.h"
+#include "sc_npc_teleport.h"
 #include "ScriptSystem.h"
 #include "Transport.h"
 #include "Vehicle.h"
@@ -185,6 +186,8 @@ void ScriptMgr::Initialize()
     uint32 oldMSTime = getMSTime();
 
     LoadDatabase();
+       // Load TeleNPC2 - maybe not the best place to load it ...
+       LoadNpcTele();
 
     TC_LOG_INFO("server.loading", "Loading C++ scripts");
 
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 9f8b378..24f78c8 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -447,6 +447,10 @@ void WorldSession::LogoutPlayer(bool save)
     m_playerLogout = true;
     m_playerSave = save;
 
+    //npcbot - free all bots and remove from botmap
+    _player->RemoveAllBots();
+    //end npcbots
+
     if (_player)
     {
         if (uint64 lguid = _player->GetLootGUID())
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index 9086a30..b3d2237 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -2395,6 +2395,13 @@ void Spell::DoAllEffectOnTarget(TargetInfo* target)
             if (caster->GetTypeId() == TYPEID_PLAYER && (m_spellInfo->Attributes & SPELL_ATTR0_STOP_ATTACK_TARGET) == 0 &&
                (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
                 caster->ToPlayer()->CastItemCombatSpell(unitTarget, m_attackType, procVictim, procEx);
+
+            //npcbot - CastItemCombatSpell for bots
+            if (caster->GetTypeId() == TYPEID_UNIT &&
+                caster->ToCreature()->GetBotAI() && !(m_spellInfo->Attributes & SPELL_ATTR0_STOP_ATTACK_TARGET) &&
+               (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
+               caster->ToCreature()->CastCreatureItemCombatSpell(unitTarget, m_attackType, procVictim, procEx, this);
+            //end npcbot
         }
 
 
@@ -3147,6 +3154,11 @@ void Spell::cast(bool skipCheck)
         return;
     }
 
+    //NpcBot: If we are applying crowd control aura execute caster's delayed attack immediately to prevent instant CC break
+    if (m_targets.GetUnitTarget() && (m_spellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE))
+        m_caster->ExecuteDelayedSwingHit();
+    //end NpcBot
+
     PrepareTriggersExecutedOnHit();
 
     CallScriptOnCastHandlers();
@@ -3604,6 +3616,9 @@ void Spell::finish(bool ok)
 
     // Stop Attack for some spells
     if (m_spellInfo->Attributes & SPELL_ATTR0_STOP_ATTACK_TARGET)
+    //npcbot - disable for npcbots
+    if (!(m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->GetBotAI()))
+    //end npcbot
         m_caster->AttackStop();
 }
 
@@ -3809,6 +3824,11 @@ void Spell::SendSpellStart()
 
 void Spell::SendSpellGo()
 {
+    //npcbot - hook for spellcast finish
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->GetBotAI())
+        m_caster->ToCreature()->OnSpellGo(this);
+    //end npcbot
+
     // not send invisible spell casting
     if (!IsNeedSendToClient())
         return;
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index 606851b..9d3b128 100644
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "AnticheatMgr.h"
 #include "Common.h"
 #include "DatabaseEnv.h"
 #include "WorldPacket.h"
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index 8034002..96fa800 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -2219,6 +2219,11 @@ int32 SpellInfo::CalcPowerCost(Unit const* caster, SpellSchoolMask schoolMask) c
         }
     }
 
+    //npcbot - apply bot spell cost mods
+    if (powerCost > 0 && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->GetBotAI())
+        caster->ToCreature()->ApplyCreatureSpellCostMods(this, powerCost);
+    //end npcbot
+
     // PCT mod from user auras by school
     powerCost = int32(powerCost * (1.0f + caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER + school)));
     if (powerCost < 0)
diff --git a/src/server/game/TriniChat/IRCClient.cpp b/src/server/game/TriniChat/IRCClient.cpp
new file mode 100644
index 0000000..df7208a
--- /dev/null
+++ b/src/server/game/TriniChat/IRCClient.cpp
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "MapManager.h"
+#include "Log.h"
+
+#include "framework/Policies/SingletonImp.h"
+INSTANTIATE_SINGLETON_1(IRCClient);
+
+#ifdef WIN32
+    #define Delay(x) Sleep(x)
+#else
+    #define Delay(x) sleep(x / 1000)
+#endif
+// IRCClient Constructor
+IRCClient::IRCClient()
+{
+    for (int i = 0;i > 5;i++)
+        sIRC.Script_Lock[i] = false;
+}
+// IRCClient Destructor
+IRCClient::~IRCClient(){}
+
+// ZThread Entry This function is called when the thread is created in Master.cpp (trinitycore)
+void IRCClient::run()
+{
+    sIRC.iLog.WriteLog(" %s : ****** Trinity Core With TriniChat Has Been Started ******", sIRC.iLog.GetLogDateTimeStr().c_str());
+
+    // before we begin we wait a few
+    // mangos is still starting up.
+    ACE_Based::Thread::Sleep(500);
+    TC_LOG_ERROR("misc" "\n%s\n%s\n%s\n%s",
+        "****************************************",
+        "**   TriniChat2 Threaded IRC Client   **",
+        "**     With Enhanced GM Control.      **",
+        "****************************************");
+    TC_LOG_ERROR("misc" "****** TriniChat: %s ********", sIRC._Mver.c_str());
+    int cCount = 1;
+    // Clean Up MySQL Tables
+    TC_LOG_ERROR("misc" "*** TriniChat: Cleaning Up Inchan Table*"," ");
+    WorldDatabase.PExecute("DELETE FROM `irc_inchan`");
+    sIRC._Max_Script_Inst = 0;
+    // Create a loop to keep the thread running untill active is set to false
+    while (sIRC.Active && !World::IsStopped())
+    {
+        // Initialize socket library
+        if (this->InitSock())
+        {
+            // Connect To The IRC Server
+            TC_LOG_ERROR("misc" "*** TriniChat: Connecting to %s Try # %d ******", sIRC._Host.c_str(), cCount);
+           if (this->Connect(sIRC._Host.c_str(), sIRC._Port))
+           {
+               // On connection success reset the connection counter
+               cCount = 0;
+               TC_LOG_ERROR("misc" "*** TriniChat: Connected And Logging In*"," ");
+                // Login to the IRC server
+                if (this->Login(sIRC._Nick, sIRC._User, sIRC._Pass))
+                {
+                    TC_LOG_ERROR("misc" "*** TriniChat: Logged In And Running!! *"," ");
+                    // While we are connected to the irc server keep listening for data on the socket
+                    while (sIRC.Connected && !World::IsStopped()){ sIRC.SockRecv(); }
+                }
+                TC_LOG_ERROR("misc" "*** TriniChat: Connection To IRC Server Lost! ***"," ");
+            }
+            // When an error occures or connection lost cleanup
+            Disconnect();
+            // Increase the connection counter
+            cCount++;
+            // if MAX_CONNECT_ATTEMPT is reached stop trying
+            if (sIRC._MCA != 0 && cCount == sIRC._MCA)
+                sIRC.Active = false;
+            // If we need to reattempt a connection wait WAIT_CONNECT_TIME milli seconds before we try again
+            if (sIRC.Active)
+                ACE_Based::Thread::Sleep(sIRC._wct);
+        }
+        else
+        {
+            // Socket could not initialize cancel
+            sIRC.Active = false;
+            TC_LOG_ERROR("misc" "** TriniChat: Could not initialize socket"," ");
+        }
+    }
+    while (!World::IsStopped()){};
+}
+
+std::string IRCClient::GetChatLine(int nItem)
+{
+    return sIRC.ILINES[nItem];
+}
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCClient.h b/src/server/game/TriniChat/IRCClient.h
new file mode 100644
index 0000000..ce912ab
--- /dev/null
+++ b/src/server/game/TriniChat/IRCClient.h
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_H
+#define _IRC_CLIENT_H
+
+#include "framework/Policies/SingletonImp.h"
+#include "Player.h"
+#include "IRCLog.h"
+#include "IRCCmd.h"
+
+using namespace std;
+// The maximum ammount of channels used, must be >= config option
+#define MAX_CONF_CHANNELS 10
+#define MAX_CHAT_LINES 10
+// time we need to wait before we try another connecton attempt
+// Default is 30 seconds
+#define MAX_SCRIPT_INST 10
+// CLINES is used for the default chatlines
+// By using the GetChatLine function its easier and faster
+// to receieve the line you need.
+enum CLINES
+{
+    IRC_WOW = 0,
+    WOW_IRC = 1,
+    JOIN_WOW = 2,
+    JOIN_IRC = 3,
+    LEAVE_WOW = 4,
+    LEAVE_IRC = 5,
+    CHANGE_NICK = 6
+};
+// CACTION is used by the Handle_WoW_Channel function
+// this function is called in channel.h when a player
+// joins or leave a channel inside the client.
+enum CACTION
+{
+    CHANNEL_JOIN,
+    CHANNEL_LEAVE,
+};
+
+enum script_Names
+{
+    MCS_Players_Online  = 0,
+};
+
+// IRCClient main class
+class IRCClient : public ACE_Based::Runnable
+{
+    public:
+        // IRCClient Constructor
+        IRCClient();
+        // IRCClient Destructor
+        ~IRCClient();
+        // ZThread Entry
+        void run();
+    public:
+        // AH Function
+        void AHFunc(uint64 itmid, std::string itmnme, std::string plname, uint32 faction);
+        //bool BeenToGMI(float posx, float posy, std::string player, std::string from);
+        // IRCClient active
+        bool    Active;
+        // Connected to IRC
+        bool    Connected;
+        // Socket indentifier
+        int     SOCKET;
+        fd_set  sfdset;
+        // Send data to IRC, in addition the endline is added \n
+        bool    SendIRC(std::string data);
+        // This function is called in ChatHandler.cpp and processes the chat from game to IRC
+        void    Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg);
+        // Sends a message to all players on the specified channel
+        void    Send_WoW_Channel(const char *channel, std::string chat);
+        // Send a system message to all players
+        void    Send_WoW_System(std::string Message);
+        // Send a message to the specified IRC channel
+        void    Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix = false, std::string nType = "PRIVMSG");
+        // Sends a message to all IRC Channels
+        void    Send_IRC_Channels(std::string sMsg);
+        std::string MakeMsg(std::string msg, std::string var, std::string val)
+        {
+            std::size_t start = msg.find(var);
+            if (start != std::string::npos)
+                msg.replace(start, var.length(), val);
+            return msg;
+        }
+        void    Send_WoW_Player(string sPlayer, string sMsg);
+        void    Send_WoW_Player(Player *plr, string sMsg);
+
+        // This function is called in Channel.cpp and processes Join/leave messages
+        void    Handle_WoW_Channel(std::string Channel, Player *plr, int nAction);
+        void    ResetIRC();
+    public:
+        void AutoJoinChannel(Player *plr);
+
+    public:
+        bool Script_Lock[5];
+        bool _AmiOp;
+
+    public:
+        string _Mver;
+        // IRC Server host
+        string  _Host;
+        // IRC Server Port
+        int _Port;
+        // IRC Username
+        string  _User;
+        // IRC Password
+        string  _Pass;
+        // IRC Nickname
+        string  _Nick;
+        //Password for in-game channel
+        std::string _irc_pass[MAX_CONF_CHANNELS];
+        // Authentication type
+        int _Auth;
+        string _Auth_Nick;
+        // IRC Connect code
+        string  _ICC;
+        // IRC Default channel
+        string  _defchan;
+        // IRC Leave Default channel
+        int _ldefc;
+        // Wait Connect Time
+        int _wct;
+        // BotMask Options
+        int Botmask;
+        // Status Channel
+        int Status;
+        // Announce Channel
+        int anchn;
+        int autoanc;
+        // IRC Channel count
+        int _chan_count;
+        // IRC Channel list
+        // Array to store our IRC channels
+        // each element will corrospond
+        // with _wow_chan array below.
+        std::string _irc_chan[MAX_CONF_CHANNELS];
+        // Game Channel list
+        std::string _wow_chan[MAX_CONF_CHANNELS];
+        // AutoJoin Options
+        int ajoin;
+        string ajchan;
+        // Online Command Max Results
+        int onlrslt;
+        // Channel OnJoin/Restart/Kick Messages
+        string  JoinMsg;
+        string  RstMsg;
+        string  kikmsg;
+        // Misc Options
+        string  ojGM1;
+        string  ojGM2;
+        string  ojGM3;
+        string  ojGM4;
+        string  ojGM5;
+        string  ojGM6;
+        string  ojGM7;
+        string  ojGM8;
+        string  logfile;
+        string  logchan;
+        string  logchanpw;
+        int     logmask;
+        int     games;
+        int     gmlog;
+        // IRC Commands Security Level
+        int     CACCT;
+        int     CBAN;
+        int     CCHAN;
+        int     CCHAR;
+        int     CFUN;
+        int     CHELP;
+        int     CINCHAN;
+        int     CINFO;
+        int     CITEM;
+        int     CJAIL;
+        int     CKICK;
+        int     _KILL;
+        int     CLEVEL;
+        int     CLOOKUP;
+        int     CMONEY;
+        int     CMUTE;
+        int     CONLINE;
+        int     CPM;
+        int     CRECONNECT;
+        int     CRELOAD;
+        int     CREVIVE;
+        int     CSAVEALL;
+        int     CSERVERCMD;
+        int     CSHUTDOWN;
+        int     CSPELL;
+        int     CSYSMSG;
+        int     CTELE;
+        int     CTOP;
+        int     CPLAYER;
+        int     CWHO;
+        // BotMask
+        int     BOTMASK;
+        // Max connect attempt
+        int     _MCA;
+        // Auto rejoin when kicked from irc
+        int     _autojoinkick;
+        // IRC Command prefix
+        string  _cmd_prefx;
+        int _op_gm;
+        int _op_gm_lev;
+        // Array that contains our chatlines from the conf file
+        // To increase this value change the MAX_CHAT_LINE define above
+        // Make sure the number of elements must match your items
+        // (remeber this starts at 0 so 0..9 is 10 items)
+        // and that you load the line in the LoadConfig function.
+        string  ILINES[MAX_CHAT_LINES];
+        string  GetChatLine(int nItem);
+
+        int _Max_Script_Inst;
+        // MAX_SCRIPT_INST
+
+        IRCLog iLog;
+
+private:
+        // Returns default chatline based on enum CLINES
+        // Initialize socket library
+        bool    InitSock();
+        // Connect to IRC Server
+        bool    Connect(const char *cHost, int nPort);
+        // Login to IRC Server
+        bool    Login(std::string sNick, std::string sUser, std::string sPass);
+        // Send raw data to IRC
+        bool    SendData(const char *data);
+        // Disconnect from IRC and cleanup socket
+        void    Disconnect();
+        // Processes the data receieved from IRC
+        void    Handle_IRC(std::string sData);
+        // Receieves data from the socket.
+        void    SockRecv();
+};
+#endif
+#define sIRC Trinity::Singleton<IRCClient>::Instance()
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCCmd.cpp b/src/server/game/TriniChat/IRCCmd.cpp
new file mode 100644
index 0000000..a71f90a
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmd.cpp
@@ -0,0 +1,930 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCCmd.h"
+#include "IRCClient.h"
+#include "Database/DatabaseEnv.h"
+#include "ObjectMgr.h"
+#include "AccountMgr.h"
+#include "MapManager.h"
+#include "World.h"
+// Constructor
+IRCCmd::IRCCmd(){}
+// Destructor
+IRCCmd::~IRCCmd(){}
+
+std::string IRCCmd::MakeUpper(std::string Channel)
+{
+    std::string tmpchan = Channel;
+    std::transform(tmpchan.begin(), tmpchan.end(), tmpchan.begin(), towupper);
+    return tmpchan;
+}
+bool IRCCmd::ParamsValid(_CDATA *CD, int pCnt)
+{
+    CD->PCOUNT = pCnt;
+    if (CD->PARAMS.size() == 0)
+        return false;
+    return ValidParams(CD->PARAMS, pCnt);
+}
+
+int IRCCmd::ParamsValid(_CDATA *CD, int pCnt, int rLev)
+{
+    //CD->PCOUNT = pCnt;
+    if (!CanUse(CD->USER, rLev))
+        return E_AUTH;
+    else if (pCnt == 0)
+        return E_OK;
+    else if (CD->PARAMS.size() == 0)
+        return E_SIZE;
+    else if (!ValidParams(CD->PARAMS, pCnt))
+        return E_SIZE;
+    return E_OK;
+}
+
+// This function checks if chat from irc is a command or not
+// return true on yes and false on no
+bool IRCCmd::IsValid(std::string USER, std::string FROM, std::string CHAT, std::string TYPE)
+{
+    // If the first line of our chat is the command prefix we have a command
+    if (CHAT.substr(0, 1) == sIRC._cmd_prefx && CHAT.size() > 1)
+    {
+        _CDATA CDATA;
+        bool cValid    = false;
+        bool AuthValid = true;
+        bool dontlog   = true;
+        std::string* _PARAMS = getArray(CHAT, 2);
+        CDATA.USER      = USER;
+        CDATA.FROM      = FROM;
+        CDATA.TYPE      = TYPE;
+        CDATA.PCOUNT    = 0;
+        CDATA.CMD       = MakeUpper(_PARAMS[0].substr(1, _PARAMS[0].size() - 1));
+        CDATA.PARAMS    = _PARAMS[1];
+        if (CDATA.CMD == "LOGIN")
+        {
+            if (FROM == sIRC._Nick)
+            {
+                if (ParamsValid(&CDATA, 2))
+                    Handle_Login(&CDATA);
+                else
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"login <Player> <Password>)", true, "ERROR");
+            }
+            else
+                sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Please Send A PM To Login!", true, "ERROR");
+            if (GetLevel(USER) >= sIRC.gmlog)
+                dontlog = false;
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LOGOUT")
+        {
+            if (FROM == sIRC._Nick)
+            {
+                Handle_Logout(&CDATA);
+            }
+            else
+                sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Please Send A PM To Logout!", true, "ERROR");
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ACCT")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CACCT))
+            {
+                case E_OK:
+                    Account_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"acct <Player> <(un)lock/email/pass/rename/gmlevel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "BAN")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CBAN))
+            {
+                case E_OK:
+                    Ban_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"ban <Player> <acct/ip>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "CHAN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC.CCHAN))
+            {
+                case E_OK:
+                    Chan_Control(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"chan <op> <IRC User>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "CHAR")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CCHAR))
+            {
+                case E_OK:
+                    Char_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"char <Player> <mailcheat/taxicheat/maxskill/setskill/quest/mod>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "FUN")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CFUN))
+            {
+                case E_OK:
+                    Fun_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"fun <Player> <Sound/Say>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "HELP")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CHELP))
+            {
+                case E_OK:
+                    Help_IRC(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"help <Command>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "INCHAN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC.CINCHAN))
+            {
+                case E_OK:
+                    Inchan_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"inchan <Channel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "INFO")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CINFO))
+            {
+                case E_OK:
+                    Info_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"info)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ITEM")
+        {
+            CDATA.PCOUNT = 3;
+            switch(ParamsValid(&CDATA, 2, sIRC.CITEM))
+            {
+                case E_OK:
+                    Item_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> <ItemID/[ItemName]> <Amount>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "JAIL")
+        {
+            CDATA.PCOUNT = 3;
+            switch(ParamsValid(&CDATA, 1, sIRC.CJAIL))
+            {
+                case E_OK:
+                    Jail_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"jail <Player> <release/Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "KICK")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC.CKICK))
+            {
+                case E_OK:
+                    Kick_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"kick <Player> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "KILL")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC._KILL))
+            {
+                case E_OK:
+                    Kill_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"kill <Player> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LEVEL")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CLEVEL))
+            {
+                case E_OK:
+                    Level_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"level <Player> <NewLevel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LOOKUP")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CLOOKUP))
+            {
+                case E_OK:
+                    Lookup_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"lookup <acct/char/creature/faction/go/item/quest/skill/spell/tele> <ID/Name>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "MONEY")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CMONEY))
+            {
+                case E_OK:
+                    Money_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"money <Player> <(-)Money>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "MUTE")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CMUTE))
+            {
+                case E_OK:
+                    Mute_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"mute <Player> <release/TimeInMins> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ONLINE")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CONLINE))
+            {
+                case E_OK:
+                    Online_Players(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"online)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "PM")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CPM))
+            {
+                case E_OK:
+                    PM_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"pm <Player> <Message>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RELOAD")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CRELOAD))
+            {
+                case E_OK:
+                    sIRC.Send_IRC_Channels("Reloading Configiguration Options.");
+                    sWorld->LoadConfigSettings(true);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RECONNECT")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CRECONNECT))
+            {
+                case E_OK:
+                    sIRC.Send_IRC_Channels(sIRC.RstMsg);
+                    sIRC.ResetIRC();
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RESTART")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CSHUTDOWN))
+            {
+                case E_OK:
+                    Restart_Trinity(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"server <setmotd/flusharenapoints/sec_number_for_restart>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "REVIVE")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC.CREVIVE))
+            {
+                case E_OK:
+                    Revive_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"revive <Player>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SAVEALL")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CSAVEALL))
+            {
+                case E_OK:
+                    Saveall_Player(&CDATA);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SERVER")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CSERVERCMD))
+            {
+                case E_OK:
+                    Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"server <setmotd/flusharenapoints>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SHUTDOWN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC.CSHUTDOWN))
+            {
+                case E_OK:
+                    Shutdown_Trinity(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"shutdown <TimeInSeconds>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SPELL")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CSPELL))
+            {
+                case E_OK:
+                    Spell_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"spell <Player> <Cast/Learn/UnLearn> <SpellID>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SYSMSG")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CSYSMSG))
+            {
+                case E_OK:
+                    Sysmsg_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"sysmsg <a/e/n/add/del/list> <Message>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "TELE")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CTELE))
+            {
+                case E_OK:
+                    Tele_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"tele <Player> <l/c/r/to/cr/go/homebind> <Loc.Name/MAPID X Y Z/Recall/Player/Creature GUID/GO GUID/Homebind>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "TOP")
+        {
+            CDATA.PCOUNT = 1;
+            switch(ParamsValid(&CDATA, 1, sIRC.CTOP))
+            {
+                case E_OK:
+                    Top_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"top <accttime/chartime/money> <limit>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "PLAYER")
+        {
+            CDATA.PCOUNT = 1;
+            switch(ParamsValid(&CDATA, 1, sIRC.CPLAYER))
+            {
+                case E_OK:
+                    Player_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"player <PLAYER>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "WHO")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CWHO))
+            {
+                case E_OK:
+                    Who_Logged(&CDATA);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        if (!AuthValid && IsLoggedIn(USER))
+            sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Access Denied! Your Security Level Is Too Low To Use This Command!", true, "ERROR");
+        if (cValid == false && (sIRC.BOTMASK & 4) != 0)
+            sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Unknown Command!", true, "ERROR");
+        if (cValid && dontlog)
+        {
+            sIRC.iLog.WriteLog(" %s : [ %s(%d) ] Used Command: [ %s ] With Parameters: [ %s ]", sIRC.iLog.GetLogDateTimeStr().c_str(), CDATA.USER.c_str(), GetLevel(USER), CDATA.CMD.c_str(), CDATA.PARAMS.c_str());
+            if ((sIRC.logmask & 1) != 0)
+            {
+                std::string logchan = "#";
+                logchan += sIRC.logchan;
+                std::stringstream ss;
+                ss << sIRC.iLog.GetLogDateTimeStr() << ": [ " << CDATA.USER << "(" << GetLevel(USER) << ") ] Used Command: [ " << CDATA.CMD << " ] With Parameters: [" << CDATA.PARAMS << " ]";
+                sIRC.Send_IRC_Channel(logchan, ss.str().c_str(), true);
+            }
+        }
+        return cValid;
+    }
+    return false;
+}
+
+bool IRCCmd::CanUse(std::string USER, int nLevel)
+{
+    if (IsLoggedIn(USER))
+    {
+        if (GetLevel(USER) >= nLevel)
+            return true;
+        else
+            return false;
+    }
+    else if (nLevel == 0)
+    {
+        return true;
+    }
+    else
+        sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : You Are Not Logged In!", true, "ERROR");
+    return false;
+}
+
+std::string IRCCmd::ChanOrPM(_CDATA *CD)
+{
+    if (CD->FROM == sIRC._Nick)
+        return CD->USER;
+    else
+        return CD->FROM;
+}
+
+Player *IRCCmd::GetPlayer(std::string WHO)
+{
+    normalizePlayerName(WHO);
+    return sObjectAccessor->FindPlayerByName(WHO.c_str());
+}
+
+_client *IRCCmd::GetClient(std::string cname)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == cname)
+            return (*i);
+    }
+    return (NULL);
+}
+
+bool IRCCmd::IsLoggedIn(std::string USER)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == USER)
+            return true;
+    }
+    return false;
+}
+
+bool IRCCmd::AcctIsLoggedIn(std::string USER)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if (MakeUpper((*i)->UName) == MakeUpper(USER))
+            return true;
+    }
+    return false;
+}
+
+std::string IRCCmd::AcctIsBanned(std::string ACCT)
+{
+    uint32 acctid = AccountMgr::GetId(ACCT);
+    std::string banned = "NOTBANNED";
+    QueryResult result = LoginDatabase.PQuery("SELECT banreason FROM ip_banned WHERE ip=(SELECT last_ip FROM account WHERE id = '%i')", acctid);
+    if (result)
+    {
+        banned = (*result)[0].GetCString();
+
+        return "IP Banned. Reason:" + banned;
+    }
+    QueryResult result2 = LoginDatabase.PQuery("SELECT banreason FROM account_banned WHERE id='%i'", acctid);
+    if (result2)
+    {
+        banned = (*result2)[0].GetCString();
+
+        return "Account Banned. Reason:" + banned;
+    }
+    return banned;
+}
+
+int IRCCmd::GetLevel(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+            return (*i)->GMLevel;
+    }
+    return 0;
+}
+
+int IRCCmd::AcctLevel(std::string plnme)
+{
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(plnme);
+    uint32 account_id = 0;
+    uint32 security = 0;
+    account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    security = AccountMgr::GetSecurity(account_id);
+    return security;
+}
+
+std::string IRCCmd::GetAccName(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+            return (*i)->UName;
+    }
+    return "";
+}
+
+std::string IRCCmd::GetNameFromAcct(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->UName == sName)
+            return (*i)->Name;
+    }
+    return "";
+}
+
+int IRCCmd::GetAcctIDFromName(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+        {
+            uint32 acct_id = 0;
+            acct_id = AccountMgr::GetId((*i)->UName.c_str());
+            return acct_id;
+        }
+    }
+    return 0;
+}
+
+std::string IRCCmd::GetAcctNameFromID(uint32 acctid)
+{
+    QueryResult result = LoginDatabase.PQuery("SELECT username FROM account WHERE id = '%d'", acctid);
+    if (result)
+    {
+        std::string name = (*result)[0].GetCString();
+
+        return name;
+    }
+
+    return "";
+}
+
+std::string IRCCmd::GetIPFromPlayer(std::string player)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE name = '%s'", player.c_str());
+    if (result)
+    {
+        std::string acctid = (*result)[0].GetCString();
+
+        QueryResult result2 = LoginDatabase.PQuery("SELECT last_ip FROM account WHERE id = '%s'", acctid.c_str());
+        if (result2)
+        {
+            std::string ip = (*result2)[0].GetCString();
+
+            return ip;
+        }
+    }
+
+    return "";
+}
+
+std::string IRCCmd::SecToDay(std::string secons)
+{
+    unsigned int seconds = atoi(secons.c_str());
+    unsigned int days = seconds / 86400;
+    unsigned int hours = seconds / 3600 % 24;
+    unsigned int mins = seconds / 60 % 60;
+    char tottime[1000];
+    sprintf(tottime, "%iDays:%iHours:%iMinutes", days, hours, mins);
+
+    return tottime;
+}
+
+bool IRCCmd::ValidParams(std::string PARAMS, int nCount)
+{
+    if (nCount == 1 && PARAMS.size() == 0)
+        return false;
+    int pcount = 0;
+    size_t p = -1;
+    for (int i = 0;i < nCount;i++)
+    {
+        p = PARAMS.find(" ", p + 1);
+        if (p == -1)
+            break;
+        else
+            pcount++;
+    }
+    nCount--;
+    if (pcount >= nCount)
+        return true;
+    else
+        return false;
+}
+
+std::string* IRCCmd::getArray(std::string PARAMS, int nCount)
+{
+    std::string *array = new std::string[nCount];
+    if (PARAMS.size() > 0)
+    {
+        int pcnt = 0;
+        size_t ps = 0;
+        size_t pc = -1;
+        for (int i = 0;i < nCount;i++)
+        {
+            pc = PARAMS.find(" ", pc + 1);
+            if (i + 1 == nCount && nCount != 1)
+            {
+                if (ps > 0 && pc > 0)
+                    array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+            }
+            else
+                array[i] = PARAMS.substr(ps, pc - ps);
+            ps = pc + 1;
+        }
+    }
+    return array;
+}
+
+std::string IRCCmd::MakeMsg(const char *sLine, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, sLine);
+    vsnprintf(tmpoutp, 1024, sLine, ap);
+    va_end(ap);
+    std::string outp = tmpoutp;
+    return outp;
+}
+
+void IRCClient::AHFunc(uint64 itmid, std::string itmnme, std::string plname, uint32 faction)
+{
+    IRCCmd Command;
+    Player* plr = Command.GetPlayer(plname);
+    if (plr)
+    {
+        std::string itemname = itmnme;
+
+        char  temp [7];
+        sprintf(temp, "%u", itmid);
+        std::string itemid = temp;
+
+        std::string wowname = "";
+        std::string ircname = "";
+        switch (plr->GetTeam())
+        {
+            case 67:wowname="|cffff0000"+plname+"|r";ircname="\0034"+plname;break;      //horde
+            case 469:wowname="|cff1589FF"+plname+"|r";ircname="\00312"+plname;break;    //alliance
+        }
+
+        std::string wowfact = "|cffFF8040[Auction House]:|r";
+        std::string ircfact = "\00304,08\037/!\\\037\017\00307 Auction House \00304,08\037/!\\\037\017";
+        switch(faction)
+        {
+            //neutral
+            case 7:wowfact="|cffff8040[Neutral Auction House]:|r";ircfact="\00304,08\037/!\\\037\017\00307 Neutral Auction House \00304,08\037/!\\\037\017";break;
+            //horde
+            case 6:wowfact="|cffff0000[Horde Auction House]:|r";ircfact="\00304,08\037/!\\\037\017\00304 Horde Auction House \00304,08\037/!\\\037\017";break;
+            //alliance
+            case 2:wowfact="|cff1589FF[Alliance Auction House]:|r";ircfact="\00304,08\037/!\\\037\017\00312 Alliance Auction House \00304,08\037/!\\\037\017";break;
+        }
+        std::string wowstr = Command.MakeMsg("%s A New Item Has Been Added |cffffffff|Hitem:%s:0:0:0:0:0:0:0|h[%s]|h|r. By: %s",wowfact.c_str(), itemid.c_str(), itemname.c_str(), wowname.c_str());
+        std::string ircstr = Command.MakeMsg("%s A New Item Has Been Added [%s]. By: %s", ircfact.c_str(), itemname.c_str(), ircname.c_str());
+
+        sIRC.Send_WoW_Channel(sIRC._wow_chan[sIRC.Status].c_str(), wowstr.c_str());
+        sIRC.Send_IRC_Channel(sIRC._irc_chan[sIRC.Status].c_str(), ircstr.c_str());
+    }
+}
+
+/* Disabled
+bool IRCClient::BeenToGMI(float posx, float posy, std::string player, std::string from)
+{
+    IRCCmd Command;
+    //std::transform(location.begin(), location.end(), location.begin(), towupper);
+    //sObjectMgr->GetAreaId
+    //if (location == "GMI" || location == "GMISLAND")
+    if (MapManager::Instance().GetZoneId(1,posx,posy) == 876)
+    {
+        QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT name FROM Hell_GMI WHERE name = '%s'",player.c_str());
+        if (result)
+        {
+
+            uint64 guid = sObjectMgr->GetPlayerGUIDByName(player);
+            Player* plr = sObjectMgr->GetPlayer(guid);
+
+            uint64 guid2 = sObjectMgr->GetPlayerGUIDByName(from);
+            Player* plr2 = sObjectMgr->GetPlayer(guid2);
+            if (plr) sIRC.Send_WoW_Player(plr, "You Have Already Had A Trip To GM Island. There Is Only One Tele To GM Island Per Player, Please Donate If You Would like The .tele Command.");
+            if (plr2) sIRC.Send_WoW_Player(plr2, "This Player Has Already Had Their Trip To GM Island. The Tele Has Been Canceled.");
+            else sIRC.Send_IRC_Channel(from.c_str(), MakeMsg(" \0034[ERROR] : $Player Has Already Had Their Trip To GMI! The Tele Has Been Canceled", "$Player", player.c_str()), true, "ERROR");
+            return true;
+        }
+        else
+        {
+            if (Command.AcctLevel(player) == 0)
+                WorldDatabase.PExecute("INSERT INTO `Hell_GMI` VALUES ('%s')", player.c_str());
+            return false;
+        }
+    }
+    return false;
+}*/
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCCmd.h b/src/server/game/TriniChat/IRCCmd.h
new file mode 100644
index 0000000..f26fb78
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmd.h
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CMD_H
+#define _IRC_CMD_H
+
+#define MAX_CLIENTS 50
+#include "Common.h"
+#include "Player.h"
+#include "ObjectAccessor.h"
+#include "BattlegroundMgr.h"
+
+struct ChannelUser
+{
+    int UserType;
+    std::string Name;
+    std::string UName;
+    int UserLevel;
+};
+
+struct _client
+{
+    bool        LoggedIn;
+    std::string Name;
+    std::string UName;
+    int         GMLevel;
+};
+struct _CDATA
+{
+    std::string CMD;
+    std::string USER;
+    std::string FROM;
+    std::string PARAMS;
+    std::string TYPE;
+    int PCOUNT;
+};
+enum APVERR
+{
+    E_OK,
+    E_SIZE,
+    E_AUTH,
+    E_IVALID,
+};
+enum ESOUNDS
+{
+    S_ENTERWORLD    = 602,
+    S_QUESTFAILED   = 847,
+    S_INVITE        = 880,
+    S_LEVELUP       = 888,
+    S_COINSOUND     = 895,
+    S_WHISPER       = 3081,
+    S_STEALTH       = 3325,
+};
+class IRCCmd
+{
+    public:
+        IRCCmd();
+        ~IRCCmd();
+
+        void    Handle_Logout(_CDATA *CD);
+        bool    IsLoggedIn(std::string USER);
+        bool    IsValid(std::string USER, std::string FROM, std::string CHAT, std::string TYPE);
+        bool    AcctIsLoggedIn(std::string USER);
+        _client *GetClient(std::string cname);
+
+    public:
+        static std::string MakeMsg(const char *sLine, ...);
+        static std::string ChanOrPM(_CDATA *CD);
+        int AcctLevel(std::string plnme);
+        int GetLevel(std::string sName);
+        std::string MakeUpper(std::string Channel);
+        std::string  AcctIsBanned(std::string ACCT);
+        std::list<_client*> _CLIENTS;
+        Player* GetPlayer(std::string WHO);
+
+    private:
+        // TriniChat Commands
+        void    Handle_Login(_CDATA *CD);
+        void    Account_Player(_CDATA *CD);
+        void    Ban_Player(_CDATA *CD);
+        void    Chan_Control(_CDATA *CD);
+        void    Char_Player(_CDATA *CD);
+        void    Fun_Player(_CDATA *CD);
+        void    Help_IRC(_CDATA *CD);
+        void    Inchan_Server(_CDATA *CD);
+        void    Info_Server(_CDATA *CD);
+        void    Item_Player(_CDATA *CD);
+        void    Jail_Player(_CDATA *CD);
+        void    Kick_Player(_CDATA *CD);
+        void    Kill_Player(_CDATA *CD);
+        void    Player_Player(_CDATA *CD);
+        void    Lookup_Player(_CDATA *CD);
+        void    Level_Player(_CDATA *CD);
+        void    Money_Player(_CDATA *CD);
+        void    Mute_Player(_CDATA *CD);
+        void    Online_Players(_CDATA *CD);
+        void    PM_Player(_CDATA *CD);
+        void    Restart_Trinity(_CDATA *CD);
+        void    Revive_Player(_CDATA *CD);
+        void    Saveall_Player(_CDATA *CD);
+        void    Server(_CDATA *CD);
+        void    Shutdown_Trinity(_CDATA *CD);
+        void    Spell_Player(_CDATA *CD);
+        void    Sysmsg_Server(_CDATA *CD);
+        void    Tele_Player(_CDATA *CD);
+        void    Top_Player(_CDATA *CD);
+        void    Who_Logged(_CDATA *CD);
+        bool    CanUse(std::string USER, int nLevel);
+        bool    ValidParams(std::string PARAMS, int nCount = 1);
+        bool    ParamsValid(_CDATA *CD, int pCnt);
+        int     ParamsValid(_CDATA *CD, int pCnt, int rLev);
+        std::string GetAccName(std::string sName);
+        std::string GetNameFromAcct(std::string sName);
+        std::string GetAcctNameFromID(uint32 acctid);
+        std::string GetIPFromPlayer(std::string player);
+        std::string SecToDay(std::string secons);
+        int GetAcctIDFromName(std::string sName);
+        std::string* getArray(std::string PARAMS, int nCount = 1);
+};
+inline void MakeLower(std::string& str)
+{
+    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
+}
+#endif
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCCmde.cpp b/src/server/game/TriniChat/IRCCmde.cpp
new file mode 100644
index 0000000..0b77802
--- /dev/null
+++ b/src/server/game/TriniChat/IRCCmde.cpp
@@ -0,0 +1,2337 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCCmd.h"
+#include "IRCClient.h"
+#include "MCS_OnlinePlayers.h"
+#include "WorldPacket.h"
+#include "Database/DatabaseEnv.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "World.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "AccountMgr.h"
+#include "Language.h"
+#include "SpellAuras.h"
+#include "SystemConfig.h"
+#include "Config.h"
+#include "ArenaTeamMgr.h"
+
+#pragma warning(disable:4018)
+#pragma warning(disable:4804)
+#pragma warning(disable:4700)
+
+#define Send_Player(p, m)           sIRC.Send_WoW_Player(p, m)
+#define Send_IRCA(c, m, b, t)       sIRC.Send_IRC_Channel(c, m, b, t)
+
+#ifdef WIN32
+#define Delay(x) Sleep(x)
+#else
+#define Delay(x) sleep(x / 1000)
+#endif
+
+void IRCCmd::Handle_Login(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    std::string isbanned = AcctIsBanned(_PARAMS[0]);
+    LoginDatabase.EscapeString(_PARAMS[0]);
+    LoginDatabase.EscapeString(_PARAMS[1]);
+    if (isbanned == "NOTBANNED")
+    {
+        if (!IsLoggedIn(CD->USER))
+        {
+            if (!AcctIsLoggedIn(_PARAMS[0].c_str()))
+            {
+                QueryResult result = LoginDatabase.PQuery("SELECT `gmlevel` FROM `account`, `account_access` WHERE `username`='%s' AND `account_access`.`id`=`account`.`id` AND `sha_pass_hash`=SHA1(CONCAT(UPPER(`username`),':',UPPER('%s')));", _PARAMS[0].c_str(), _PARAMS[1].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    int GMLevel = fields[0].GetInt16();
+                    if (GMLevel >= 0)
+                    {
+                        _client *NewClient = new _client();
+                         NewClient->Name     = CD->USER;
+                        NewClient->UName    = MakeUpper(_PARAMS[0]);
+                        NewClient->GMLevel  = fields[0].GetInt16();
+                        _CLIENTS.push_back(NewClient);
+                        Send_IRCA(CD->USER, MakeMsg("You Are Now Logged In As %s.", _PARAMS[0].c_str()), true, CD->TYPE);
+
+                        if (sIRC._op_gm == 1 && GMLevel >= sIRC._op_gm_lev)
+                        {
+                            for (int i=1;i < sIRC._chan_count + 1;i++)
+                            sIRC.SendIRC("MODE #"+sIRC._irc_chan[i]+" +o "+CD->USER);
+                        }
+                    }
+                }else
+                    Send_IRCA(CD->USER, "Sorry, Your Username Or Password Is Incorrect. Please Try Again. ", true, "ERROR");
+            }else
+                Send_IRCA(CD->USER, MakeMsg("%s Is Already Logged In With This Username. ", GetNameFromAcct(MakeUpper(_PARAMS[0])).c_str()), true, "ERROR");
+        }else
+            Send_IRCA(CD->USER, "You are already logged in as "+ _PARAMS[0], true, "ERROR");
+    }else
+         Send_IRCA(CD->USER, "Sorry, you are "+isbanned+" and can not log in.", true, "ERROR");
+}
+
+void IRCCmd::Handle_Logout(_CDATA *CD)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == CD->USER)
+        {
+            _CLIENTS.erase(i);
+            delete (*i);
+            Send_IRCA(CD->USER, "Successfully logged out", true, CD->TYPE);
+            return;
+        }
+    }
+    Send_IRCA(CD->USER, "Not logged in", true, "ERROR");
+}
+
+void IRCCmd::Account_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    uint32 account_id = 0;
+    account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    if (account_id)
+    {
+        if (account_id == GetAcctIDFromName(CD->USER) || GetLevel(CD->USER) >= sIRC._op_gm_lev)
+        {
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            if (_PARAMS[1] == "lock")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `locked` = '1' WHERE `id` = '%d'",account_id);
+                if (plr) Send_Player(plr, MakeMsg("Your Account Has Been Locked To Your Current IP By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Account Has Been Locked To Their Current IP Address.", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "unlock")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `locked` = '0' WHERE `id` = '%d'",account_id);
+                if (plr) Send_Player(plr, MakeMsg("Your Account Has Been UnLocked From The Associated IP By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Account Has Been UnLocked From The Associated IP Address.", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "email")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `email` = '%s' WHERE `id` = '%d'",_PARAMS[2].c_str() ,account_id);
+                if (plr) Send_Player(plr, MakeMsg("%s Has Changed Your EMail Adress To: %s", CD->USER.c_str(), _PARAMS[2].c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : EMail Address Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "pass")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `sha_pass_hash` = SHA1(CONCAT(UPPER(`username`),':',UPPER('%s'))) WHERE `id` = '%d'",_PARAMS[2].c_str() ,account_id);
+                if (plr) Send_Player(plr, MakeMsg("%s Has Changed Your Password To: %s", CD->USER.c_str(), _PARAMS[2].c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Password Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "rename")
+            {
+                if (plr)
+                {
+                    plr->SetAtLoginFlag(AT_LOGIN_RENAME);
+                    Send_Player(plr, MakeMsg("%s Has Requested You Change This Characters Name, Rename Will Be Forced On Next Login!", CD->USER.c_str()));
+                }
+                CharacterDatabase.PExecute("UPDATE `characters` SET `at_login` = `at_login` | '1' WHERE `guid` = '%u'", guid);
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Has Been Forced To Change Their Characters Name, Rename Will Be Forced On Next Login!", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "gmlevel")
+            {
+                const char *cgmlevel = _PARAMS[2].c_str();
+                if (GetLevel(CD->USER) >= atoi(cgmlevel))
+                {
+                    LoginDatabase.PExecute("UPDATE `account_access` SET `gmlevel` = '%s' WHERE `id` = '%d'", _PARAMS[2].c_str(), account_id);
+                    Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Has GM Level Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+                }
+                else
+                {
+                    Send_IRCA(CD->USER, "The Specified GM Level Is Higher Than Your GM Level.", true, "ERROR");
+                }
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "You Are Not A GM, You May Only Change Settings In Your Own Account.", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "No such player - account lookup failed", true, "ERROR");
+}
+
+void IRCCmd::Ban_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 4);
+    std::string duration = SecToDay (_PARAMS[3].c_str());
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (_PARAMS[1] == "ip")
+    {
+        std::string ip = GetIPFromPlayer(_PARAMS[0]);
+        if (_PARAMS[2] == "")
+            _PARAMS[2] = "No Reason";
+        if (ip != "")
+        {
+            sWorld->BanAccount(BAN_IP, ip.c_str(), _PARAMS[3].c_str(), _PARAMS[2], CD->USER);
+            if (Player* plr = GetPlayer(_PARAMS[0]))
+                plr->GetSession()->KickPlayer();
+            Send_IRCA(ChanOrPM(CD), MakeMsg("[%s] Has Had Their IP Address Banned. [%s] Reason: %s Duration: %s",_PARAMS[0].c_str() ,ip.c_str() , _PARAMS[2].c_str(), _PARAMS[3].c_str()), true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Can not locate IP-address for that charactername", true, "ERROR");
+    }
+    if (_PARAMS[1] == "acct")
+    {
+
+        if (_PARAMS[2] == "")
+            _PARAMS[2] = "No reason";
+        if (_PARAMS[3] == "")//set standard bantime to 1 day
+            _PARAMS[3] = "1d";
+        QueryResult result = LoginDatabase.PQuery("SELECT id FROM `account` WHERE username = '%s'", _PARAMS[0].c_str());
+        if (result)
+        {
+            sWorld->BanAccount(BAN_ACCOUNT, _PARAMS[0].c_str(), _PARAMS[3].c_str(), _PARAMS[2], CD->USER);
+            Send_IRCA(ChanOrPM(CD), MakeMsg("[%s] has been account-banned. Reason: %s Duration: %s",_PARAMS[0].c_str(), _PARAMS[2].c_str(), _PARAMS[3].c_str()),  true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Can not find any accounts for that accountname", true, "ERROR");
+
+    }
+    if (_PARAMS[1] == "unban")
+    {
+        std::string unbani = _PARAMS[0];
+        if (atoi(unbani.c_str()) > 0)
+        {
+            LoginDatabase.PExecute("DELETE FROM ip_banned WHERE ip = '%s'", _PARAMS[0].c_str());
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Removed From The IP Ban List.", _PARAMS[0].c_str()), true, CD->TYPE);
+        }
+        else
+        {
+            QueryResult result = LoginDatabase.PQuery("SELECT id FROM `account` WHERE username = '%s'", _PARAMS[0].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string id = fields[0].GetString();
+
+                LoginDatabase.PExecute("DELETE FROM account_banned WHERE id = %s", id.c_str());
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Removed From The Account Ban List.", _PARAMS[0].c_str()), true, CD->TYPE);
+
+            }
+            else
+                Send_IRCA(CD->USER, "I Cannot Locate An Account Or IP Address For The Paramaters Given.", true, "ERROR");
+        }
+    }
+}
+
+void IRCCmd::Char_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 5);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    Player* plr = ObjectAccessor::FindPlayer(guid);
+    if (plr)
+    {
+        if (_PARAMS[1] == "mapcheat")
+        {
+            bool explore = false;
+            if (_PARAMS[2] != "0")
+                explore = true;
+            for (uint8 i=0; i<64; i++)
+            {
+                if (_PARAMS[2] != "0")
+                    plr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0xFFFFFFFF);
+                else
+                    plr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0);
+            }
+            if (explore)
+            {
+                Send_Player(plr, MakeMsg("All Your Zones Have Been Set To Explored By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Now Explored All Zones.", true, CD->TYPE);
+            }
+            else
+            {
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Now Had All Zones Set To Un-Explored.", true, CD->TYPE);
+                Send_Player(plr, MakeMsg("All Your Zones Have Been Set To Un-Explored By: %s", CD->USER.c_str()));
+            }
+        }
+        if (_PARAMS[1] == "taxicheat")
+        {
+            if (_PARAMS[2] != "0")
+            {
+                plr->SetTaxiCheater(true);
+                Send_Player(plr, MakeMsg("Taxi Node Cheat Has Been Enabled By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Taxi Node Cheat Has Been Enabled.", true, CD->TYPE);
+            }
+            else
+            {
+                plr->SetTaxiCheater(false);
+                Send_Player(plr, MakeMsg("Taxi Node Cheat Has Been Disabled By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Taxi Node Cheat Has Been Disabled.", true, CD->TYPE);
+            }
+        }
+        if (_PARAMS[1] == "maxskill")
+        {
+            plr->UpdateSkillsToMaxSkillsForLevel();
+            Send_Player(plr, MakeMsg("Your Skills Have Been Maxed Out By: %s", CD->USER.c_str()));
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Skills Have Been Maxed Out.", true, CD->TYPE);
+        }
+        if (_PARAMS[1] == "setskill")
+        {
+            std::string* _PARAMSA = getArray(_PARAMS[2], 4);
+            uint32 skill = atoi(_PARAMS[2].c_str());
+            uint32 step = atoi(_PARAMS[3].c_str());
+            uint32 level = atol(_PARAMS[4].c_str());
+            int32 max   = _PARAMS[5].c_str() ? atol (_PARAMS[5].c_str()) : plr->GetPureMaxSkillValue(skill);
+            SkillLineEntry const* skilllookup = sSkillLineStore.LookupEntry(skill);
+            //if skillid entered is not a number and greater then 0 then the command is being used wrong
+            if (skill >= 0)
+            {
+                //does the skill even exist
+                if (skilllookup)
+                {
+                    //does player have the skill yet
+                    if (plr->GetSkillValue(skill))
+                    {
+                        plr->SetSkill(skill,step,level,max);
+                        Send_Player(plr, MakeMsg("Skill: %s Has Been Set To Level: %i Max: %i By: %s",skilllookup->name[0], level, max, CD->USER.c_str()));
+                        Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Had Skill: %s Set To Level: %d Max: %d",_PARAMS[0].c_str() , skilllookup->name[0], level, max), true, CD->TYPE);
+                    }
+                    else
+                        Send_IRCA(CD->USER, MakeMsg("Player Does Not Have The %s Skill Yet.", skilllookup->name[0]), true, "ERROR");
+                }
+                else
+                    Send_IRCA(CD->USER, "That Skill ID Does Not Exist.", true, "ERROR");
+            }
+            else
+                Send_IRCA(CD->USER, "The Skill ID Entered Is Invalid.", true, "ERROR");
+        }
+        if (_PARAMS[1] == "combatstop")
+        {
+            if (!plr->IsInCombat())
+            {
+                plr->CombatStop();
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Was Dropped From Combat",_PARAMS[0].c_str()), true, CD->TYPE);
+            }else
+            {
+                Send_IRCA(CD->USER, "Specified Player Is Not In Combat.", true, "ERROR");
+            }
+        }
+        if (_PARAMS[1] == "quest")
+        {
+            std::string s_param  = _PARAMS[3];
+            std::string QName = "";
+            char *args = (char*)s_param.c_str();
+            uint32 qId = 0;
+            if (args[0]=='[')
+            {
+                char* cQName = strtok((char*)args, "]");
+                if (cQName && cQName[0])
+                {
+                    QName = cQName+1;
+                    WorldDatabase.EscapeString(QName);
+                    QueryResult result = WorldDatabase.PQuery("SELECT entry FROM quest_template WHERE name = '%s'", QName.c_str());
+                    if (!result)
+                    {
+                        Send_IRCA(CD->USER, "Quest Not Found!", true, "ERROR");
+                        return;
+                    }
+                    qId = result->Fetch()->GetUInt16();
+
+                }
+            }
+            else
+            {
+                qId = atoi(args);
+                QueryResult result = WorldDatabase.PQuery("SELECT title FROM quest_template WHERE entry = '%d'", qId);
+                if (!result)
+                {
+                    Send_IRCA(CD->USER, "Quest Not Found!", true, "ERROR");
+                    return;
+                }
+                QName = result->Fetch()->GetString();
+
+            }
+            if (_PARAMS[2] == "add")
+            {
+                QueryResult item_max = WorldDatabase.PQuery("SELECT MAX(entry) FROM item_template");
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(qId);
+                for (uint32 id = 0; id < item_max; id++)
+                {
+                    ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(id);
+                    if (!pProto)
+                        continue;
+
+                    if (pProto->StartQuest == qId)
+                    {
+                        Send_IRCA(CD->USER, MakeMsg("This Quest Requires Activation By Item %d, Add It To The Player And Start Quest Manually.", pProto->ItemId),true, "ERROR");
+                    }
+                }
+
+                if (plr->CanAddQuest(pQuest, true))
+                {
+                    plr->AddQuest(pQuest, NULL);
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Had Quest [%s] Added To Quest Log.", _PARAMS[0].c_str(), QName.c_str()), true, "ERROR");
+                }
+                else
+                {
+                    Send_IRCA(CD->USER, "Cannot Add Quest To Player, He Either Has No Space Or He Already Has The Quest In His Quest Log.", true, "ERROR");
+                }
+            }
+            if (_PARAMS[2] == "complete")
+            {
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(qId);
+                if (plr->GetQuestStatus(qId) == QUEST_STATUS_NONE)
+                {
+                    Send_IRCA(CD->USER, "Player Does Not Have This Quest In Quest Log, Cannot Complete It.", true, "ERROR");
+                }
+                else
+                {
+                    for (uint8 x = 0; x < QUEST_OBJECTIVES_COUNT; ++x)
+                    {
+                        uint32 id = pQuest->RequiredItemId[x];
+                        uint32 count = pQuest->RequiredItemCount[x];
+                        if (!id || !count)
+                            continue;
+                        uint32 curItemCount = plr->GetItemCount(id,true);
+                        ItemPosCountVec dest;
+                        uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, id, count-curItemCount);
+                        if (msg == EQUIP_ERR_OK)
+                        {
+                            Item* item = plr->StoreNewItem(dest, id, true);
+                            plr->SendNewItem(item,count-curItemCount,true,false);
+                        }
+                    }
+
+                    for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+                    {
+                        uint32 creature = pQuest->RequiredNpcOrGo[i];
+                        uint32 creaturecount = pQuest->RequiredNpcOrGoCount[i];
+                        /*if (uint32 spell_id = pQuest->SourceSpellid[i])
+                        {
+                            for (uint16 z = 0; z < creaturecount; ++z)
+                                plr->KilledMonsterCredit(creature, spell_id);
+                        }
+                        else*/ if (creature > 0)
+                        {
+                            if (CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(creature))
+                                for (uint16 z = 0; z < creaturecount; ++z)
+                                    plr->KilledMonster(cInfo,0);
+                        }
+                        else if (creature < 0)
+                        {
+                            for (uint16 z = 0; z < creaturecount; ++z)
+                                plr->KilledMonsterCredit(creature, 0);
+                        }
+                    }
+
+                    /*if (uint32 repFaction = pQuest->GetRepObjectiveFaction())
+                    {
+                        uint32 repValue = pQuest->GetRepObjectiveValue();
+                        uint32 curRep = plr->GetReputationMgr().GetReputation(repFaction);
+                        if (curRep < repValue)
+                        {
+                            FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction);
+                            plr->GetReputationMgr().SetReputation(factionEntry,repValue);
+                        }
+                    }*/
+
+                    int32 ReqOrRewMoney = pQuest->GetRewOrReqMoney();
+                    if (ReqOrRewMoney < 0)
+                        plr->ModifyMoney(-ReqOrRewMoney);
+
+                    plr->CompleteQuest(qId);
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Quest [%s] Status Set To Complete.", _PARAMS[0].c_str(), QName.c_str()), true, CD->TYPE);
+                }
+            }
+        }
+        if (_PARAMS[1] == "mod")
+        {
+            /*if (_PARAMS[2] == "rep") TODO
+            {
+                uint32 factionId = atoi((char*)_PARAMS[3].c_str());
+                FactionEntry const *factionEntry = sFactionStore.LookupEntry(factionId);
+                if (!factionEntry)
+                {
+                    Send_IRCA(CD->USER, "No Faction With That Name Exists.", true, "ERROR");
+                }
+                else
+                {
+                    int32 amount = atol((char*)_PARAMS[4].c_str());
+                    if (amount > -39000 && amount < 43000)
+                    {
+                        plr->SetFactionReputation(factionId,amount);
+                        Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Reputation With Faction %s Set To %s.", _PARAMS[0].c_str(), _PARAMS[3].c_str(), _PARAMS[4].c_str()), true, CD->TYPE);
+                    }
+                    else
+                    {
+                        Send_IRCA(CD->USER, "Reputation Value Incorrect. Must Be Between -39000 and 43000.", true, "ERROR");
+                    }
+                }
+            }*/
+            if (_PARAMS[2] == "morph")
+            {
+                uint16 display_id = (uint16)atoi((char*)_PARAMS[3].c_str());
+                plr->SetDisplayId(display_id);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Morphed Into DisplayID: %s.", _PARAMS[0].c_str(), _PARAMS[3].c_str()), true, CD->TYPE);
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Valid Parameters Are: morph <displayid>, reputation <faction><value>.", true, "ERROR");
+            }
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "No Character With That Name Exists.", true, "ERROR");
+}
+
+void IRCCmd::Fun_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (_PARAMS[1] == "say")
+        {
+            plr->Say(_PARAMS[2], LANG_UNIVERSAL);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Was Forced To Say: "+_PARAMS[2]+".", true, CD->TYPE);
+        }
+        if (_PARAMS[1] == "sound")
+        {
+            uint32 sndid = atoi(_PARAMS[2].c_str());
+            plr->SendPlaySound(sndid ,true);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Just Heard Sound ID: "+_PARAMS[2]+".", true, CD->TYPE);
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Player Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Help_IRC(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    QueryResult result = WorldDatabase.PQuery("SELECT `Command`, `Description`, `gmlevel` FROM `irc_commands`");
+    if (result)
+    {
+        if (IsLoggedIn(CD->USER))
+        {
+            if (_PARAMS[0] == "")
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_commands` WHERE `gmlevel` <= %u ORDER BY `Command`", GetLevel(CD->USER));
+                if (result)
+                {
+                    std::string output = "\002TriniChat IRC Commands:\017 ";
+                    for (uint64 i=0; i < result->GetRowCount(); i++)
+                    {
+                        Field *fields = result->Fetch();
+                        output += fields[0].GetString() + ", ";
+                        result->NextRow();
+                    }
+
+                    Send_IRCA(CD->USER, output, true, CD->TYPE.c_str());
+                }
+            }
+            else
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `irc_commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    if (fields[1].GetUInt32() > GetLevel(CD->USER))
+                    {
+                        Send_IRCA(CD->USER, "You Do Not Have Access To That Command, So No Help Is Available.", true, CD->TYPE.c_str());
+                        return;
+                    }
+                    if (result)
+                    {
+                        std::string cmdhlp = fields[0].GetString();
+
+                        Send_IRCA(CD->USER, cmdhlp, true, CD->TYPE.c_str());
+                    }
+                }
+                else
+                    Send_IRCA(CD->USER, "No Such Command Exists, Please Check The Spelling And Try Again.", true, "ERROR");
+            }
+        }
+        else if (!IsLoggedIn(CD->USER))
+        {
+            if (_PARAMS[0] == "")
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_commands` WHERE `gmlevel` = 0 ORDER BY `Command`");
+                if (result)
+                {
+                    std::string output = "\002TriniChat IRC Commands:\017 ";
+                    for (uint64 i=0; i < result->GetRowCount(); i++)
+                    {
+                        Field *fields = result->Fetch();
+                        output += fields[0].GetString() + ", ";
+                        result->NextRow();
+                    }
+
+                    Send_IRCA(CD->USER, output, true, CD->TYPE.c_str());
+                    Send_IRCA(CD->USER, "You Are Currently Not Logged In, Please Login To See A Complete List Of Commands Available To You.", true, CD->TYPE.c_str());
+                }
+            }
+            else
+            {
+                QueryResult result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `irc_commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    if (fields[1].GetUInt32() > 0)
+                    {
+                        Send_IRCA(CD->USER, "You Do Not Have Access To That Command, So No Help Is Available.", true, CD->TYPE.c_str());
+                        return;
+                    }
+                    std::string cmdhlp = fields[0].GetString();
+
+                    Send_IRCA(CD->USER, cmdhlp, true, CD->TYPE.c_str());
+                }
+                else
+                    Send_IRCA(CD->USER, "No Such Command Exists, Please Check The Spelling And Try Again.", true, "ERROR");
+            }
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Database Error! Please Make Sure You Used irc_commands.sql, You Must Have A Table In Your World Database (irc_commands)!", true, "ERROR");
+}
+
+void IRCCmd::Inchan_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "")
+    {
+        Send_IRCA(CD->USER, "Syntax Error! ("+sIRC._cmd_prefx+"inchan <ChannelName>)", true, "ERROR");
+        return;
+    }
+    QueryResult result = WorldDatabase.PQuery("SELECT * FROM `irc_inchan` WHERE `channel` = '%s' ORDER BY `name`", _PARAMS[0].c_str());
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        std::string output = "\0031Players In The \xF["+fields[2].GetString()+"] \0031Channel:\017 ";
+        for (uint64 i=0; i < result->GetRowCount(); i++)
+        {
+            output += fields[1].GetString() + ", ";
+            result->NextRow();
+        }
+
+        Send_IRCA(ChanOrPM(CD), output, true, CD->TYPE);
+    }
+    else
+        Send_IRCA(ChanOrPM(CD), "\0031No Players Are Currently In \xF["+_PARAMS[0]+"] \0031Channel!", true, CD->TYPE.c_str());
+}
+
+void IRCCmd::Info_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    char clientsNum [50];
+    sprintf(clientsNum, "%u", sWorld->GetActiveSessionCount());
+    char maxClientsNum [50];
+    sprintf(maxClientsNum, "%u", sWorld->GetMaxActiveSessionCount());
+    char ircupdt [50];
+    sprintf(ircupdt, "%u", sWorld->GetUpdateTime());
+    std::string str = secsToTimeString(sWorld->GetUptime());
+    std::string svnrev = _FULLVERSION;
+
+    float rdm = (sConfigMgr->GetFloatDefault("Rate.Drop.Money", 1.0f));
+    float rxk = (sConfigMgr->GetFloatDefault("Rate.XP.Kill", 1.0f));
+    float rxq = (sConfigMgr->GetFloatDefault("Rate.XP.Quest", 1.0f));
+    Send_IRCA(ChanOrPM(CD), "\00310Number Of Players Online: \xF"+(std::string)clientsNum+" | \00310Max Since Last Restart: \xF"+(std::string)maxClientsNum+" |\00310 UpTime: \xF"+str, true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), "\00310Server: \xF"+svnrev+" |\00310 Update Time: \xF"+(std::string)ircupdt, true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Server Rates - \xF[Monster XP: %u][Quest XP: %u][Money Drop Rate: %u]", int(rxk), int(rxq), int(rdm)), true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), "\00310MotD: \xF"+(std::string)sWorld->GetMotd(), true, CD->TYPE);
+
+}
+
+void IRCCmd::Item_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+
+    normalizePlayerName(_PARAMS[0]);
+    Player *chr = GetPlayer(_PARAMS[0].c_str());
+    if (_PARAMS[1] == "add")
+    {
+        std::string s_param  = _PARAMS[2];
+
+        char *args = (char*)s_param.c_str();
+        uint32 itemId = 0;
+        if (args[0]=='[')
+        {
+            char* citemName = strtok((char*)args, "]");
+            if (citemName && citemName[0])
+            {
+                std::string itemName = citemName+1;
+                WorldDatabase.EscapeString(itemName);
+                QueryResult result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+                if (!result)
+                {
+                    Send_IRCA(CD->USER, "Item Not Found!", true, "ERROR");
+                    return;
+                }
+                itemId = result->Fetch()->GetUInt16();
+
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> [Exact Item Name] <Amount>)", true, "ERROR");
+                return;
+            }
+        }
+        else
+        {
+            std::string itemName = s_param;
+            WorldDatabase.EscapeString(itemName);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+            if (result)
+            {
+                itemId = result->Fetch()->GetUInt16();
+            }
+
+
+            char* cId = strtok(args, " ");
+            if (!cId)
+            {
+                Send_IRCA(CD->USER, "Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> <ItemID> <Amount>)", true, "ERROR");
+                return;
+            }
+            itemId = atol(cId);
+        }
+            char* ccount = strtok(NULL, " ");
+            int32 count = 1;
+            if (ccount) { count = atol(ccount); }
+            Player* plTarget = chr;
+        if (!plTarget)
+        {
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+            return;
+        }
+        ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(itemId);
+        //Subtract
+        if (count < 0)
+        {
+            plTarget->DestroyItemCount(itemId, -count, true, false);
+            char itemid2[255];
+            sprintf(itemid2,"%d",itemId);
+            std::string itake = " \00313["+ _PARAMS[0] +"] :\0031Has Had Item \xF" +itemid2+ " \0031Taken From Them!";
+            Send_IRCA(ChanOrPM(CD), itake, true, CD->TYPE);
+            return;
+        }
+        //Adding items
+        uint32 noSpaceForCount = 0;
+
+        // check space and find places
+        ItemPosCountVec dest;
+        uint8 msg = plTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &noSpaceForCount);
+        if (msg == EQUIP_ERR_INVENTORY_FULL)                   // convert to possibel store amount
+            count -= noSpaceForCount;
+        else if (msg != EQUIP_ERR_OK)                          // other error, can't add
+        {
+            char s_countForStore[255];
+            sprintf(s_countForStore,"%d",count);
+            std::string ierror = " \00313["+ _PARAMS[0] +"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+            Send_IRCA(ChanOrPM(CD), ierror, true, CD->TYPE);
+            return;
+        }
+        Item* item = plTarget->StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+        if (count > 0 && item)
+        {
+                plTarget->SendNewItem(item,count,true,false);
+                QueryResult result = WorldDatabase.PQuery("SELECT name FROM item_template WHERE entry = %d", itemId);
+                char* dbitemname = NULL;
+                if (result)
+                {
+                    dbitemname = (char*)result->Fetch()->GetCString();
+                }
+                std::string iinfo = " \00313[" + _PARAMS[0] + "] : Has Been Given Item "+dbitemname+". From: "+CD->USER.c_str()+".";
+                Send_IRCA(ChanOrPM(CD), iinfo, true, CD->TYPE);
+
+        }
+        if (noSpaceForCount > 0)
+        {
+            char s_countForStore[255];
+            sprintf(s_countForStore,"%d",noSpaceForCount);
+            std::string ierror = " \00313["+ _PARAMS[0] +"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+            Send_IRCA(ChanOrPM(CD), ierror, true, CD->TYPE);
+            return;
+        }
+    }
+    else
+    {
+        Send_IRCA(CD->USER, "Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> <ItemID> <Amount>)", true, "ERROR");
+        return;
+    }
+}
+
+void IRCCmd::Jail_Player(_CDATA *CD)
+{
+    if (ValidParams(CD->PARAMS, 1))
+    {
+        std::string* _PARAMS = getArray(CD->PARAMS, 2);
+        if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+        {
+            Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+            return;
+        }
+        if (Player *plr = GetPlayer(_PARAMS[0]))
+        {
+            std::string sReason = "";
+            if (_PARAMS[1] == "release")
+            {
+                float rposx, rposy, rposz, rposo = 0;
+                uint32 rmapid = 0;
+                CharacterDatabase.EscapeString(_PARAMS[0]);
+                QueryResult result = CharacterDatabase.PQuery("SELECT `map`, `position_x`, `position_y`, `position_z` FROM `character_homebind` WHERE `guid` = '" UI64FMTD "'", plr->GetGUID());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    rmapid = fields[0].GetUInt16();
+                    rposx = fields[1].GetFloat();
+                    rposy = fields[2].GetFloat();
+                    rposz = fields[3].GetFloat();
+
+                    plr->SetMovement(MOVE_UNROOT);
+                    plr->TeleportTo(rmapid, rposx, rposy, rposz, rposo);
+                    plr->RemoveAurasDueToSpell(42201);
+                    plr->RemoveAurasDueToSpell(23775);
+                    plr->RemoveAurasDueToSpell(9454);
+                    Send_Player(plr, MakeMsg("You Have Been Released By: %s.", CD->USER.c_str()));
+                    sReason = " \00313["+_PARAMS[0]+"] : Has Been Released By: "+CD->USER+".";
+                    Send_IRCA(ChanOrPM(CD), sReason, true, CD->TYPE);
+                }
+            }
+            else
+            {
+                if (_PARAMS[1] == "")
+                    _PARAMS[1] = "No Reason Given.";
+                plr->TeleportTo(13, 0, 0, 0, 0);
+                plr->SetMovement(MOVE_ROOT);
+                plr->CastSpell(plr, 42201, true);
+                plr->CastSpell(plr, 23775, true);
+                plr->CastSpell(plr, 9454, true);
+                Send_Player(plr, MakeMsg("You Have Been Jailed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+                sReason = " \00313["+_PARAMS[0]+"] : Has Been Jailed By: "+CD->USER+". Reason: "+_PARAMS[1]+".";
+                Send_IRCA(ChanOrPM(CD), sReason, true, CD->TYPE);
+            }
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+    }
+}
+
+void IRCCmd::Kick_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (_PARAMS[1] == "")
+        _PARAMS[1] = "No Reason Given.";
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        plr->GetSession()->KickPlayer();
+        Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been Kicked By: "+CD->USER+". Reason: "+_PARAMS[1]+".", true, CD->TYPE);
+        if (sWorld->getBoolConfig(CONFIG_SHOW_KICK_IN_WORLD))
+            sIRC.Send_WoW_System("Player|cffff0000 "+_PARAMS[0]+"|r kicked by|cffff0000 "+CD->USER+"|r. Reason:|cffff0000"+_PARAMS[1]+"|r.");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Kill_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->IsAlive())
+        {
+            plr->DealDamage(plr, plr->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            plr->SaveToDB();
+            if (_PARAMS[1] == "")
+                _PARAMS[1] = "No Reason Given.";
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Killed By: %s.", _PARAMS[0].c_str(), CD->USER.c_str()) +  +  + " Reason: "+_PARAMS[1]+".", true, CD->TYPE);
+            Send_Player(plr, MakeMsg("You Have Been Killed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Already Dead!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Player_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    uint32 plguid = atoi(_PARAMS[0].c_str());
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (sObjectMgr->GetPlayerGUIDByName(_PARAMS[0].c_str()))
+        plguid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0].c_str());
+    if (plguid > 0)
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, online, SUBSTRING_INDEX(SUBSTRING_INDEX(`level`, ' ' , 35), ' ' , -1) AS level,  SUBSTRING_INDEX(SUBSTRING_INDEX(`xp`, ' ' , 927), ' ' , -1) AS xp, SUBSTRING_INDEX(SUBSTRING_INDEX(money, ' ' , 1462), ' ' , -1) AS gold, SUBSTRING_INDEX(SUBSTRING_INDEX(`totalHonorPoints`, ' ' , 1454), ' ' , -1) AS Honor, totaltime FROM characters WHERE guid =%i", plguid);
+        uint32 latency = 0;
+        Player *chr = ObjectAccessor::FindPlayer(plguid);
+        if (chr)
+        {
+            latency = chr->GetSession()->GetLatency();
+        }
+        char templatency [100];
+        sprintf(templatency, "%ums", latency);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string pguid = fields[0].GetString();
+            std::string pacct = fields[1].GetString();
+            std::string pname = fields[2].GetString();
+            uint32 praceid = fields[3].GetUInt32();
+            uint32 pclassid = fields[4].GetUInt32();
+            std::string ponline = (fields[5].GetInt32() == 1 ? "\x3\x30\x33Online" : "\x3\x30\x34Offline\xF");
+            std::string plevel = fields[6].GetString();
+            std::string pxp = fields[7].GetString();
+            unsigned int money = fields[8].GetInt32();
+            std::string honor = fields[9].GetString();
+            std::string totaltim = SecToDay(fields[10].GetString());
+
+            std::string sqlquery = "SELECT `gmlevel` FROM `account_access` WHERE `id` = '" + pacct + "';";
+            QueryResult gmresult = LoginDatabase.Query(sqlquery.c_str());
+            std::string pgmlvl = "0";
+            if (gmresult)
+            {
+                Field *fields2 = gmresult->Fetch();
+                pgmlvl = fields2[0].GetString();
+            }
+
+            ChrRacesEntry const* prace = sChrRacesStore.LookupEntry(praceid);
+            ChrClassesEntry const* pclass = sChrClassesStore.LookupEntry(pclassid);
+
+            if (atoi(plevel.c_str()) < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+                plevel += " (" + pxp + ")";
+            unsigned int gold = money / 10000;
+            unsigned int silv = (money % 10000) / 100;
+            unsigned int cop = (money % 10000) % 100;
+            char tempgold [100];
+            sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+            if (ponline == "\x3\x30\x33Online")
+            {
+                Player * plr = sObjectAccessor->FindPlayerByName(pname.c_str());
+                if (plr)
+                {
+                    AreaTableEntry const* area = GetAreaEntryByAreaID(plr->GetAreaId());
+                    ponline += " in " + (std::string) area->area_name[sWorld->GetDefaultDbcLocale()];
+                    if (area->zone != 0)
+                    {
+                        AreaTableEntry const* zone = GetAreaEntryByAreaID(area->zone);
+                        ponline += " (" + (std::string)zone->area_name[sWorld->GetDefaultDbcLocale()] + ")";
+                    }
+                }
+            }
+            std::string pinfo  = "\00310About Player: \xF"+pname+" |\00310 GM Level: \xF"+pgmlvl+" |\00310 AcctID: \xF"+pacct+" |\00310 CharID: \xF"+pguid+" |\00310 Played Time: \xF"+totaltim.c_str()+" |\00310 Latency: \xF"+templatency;
+            std::string pinfo2 = "\00310Race: \xF"+(std::string)prace->name[sWorld->GetDefaultDbcLocale()]+" |\00310 Class: \xF"+(std::string)pclass->name[sWorld->GetDefaultDbcLocale()]+" |\00310 Level: \xF"+plevel+" |\00310 Money: \xF"+tempgold+"|\00310 Status: \xF"+ponline+" |\00310 Honor: \xF"+honor;
+            //        pinfo3 = " :" + " \x2Honor Kills:\x2\x3\x31\x30 " + hk;
+            Send_IRCA(ChanOrPM(CD),pinfo , true, CD->TYPE);
+            Send_IRCA(ChanOrPM(CD),pinfo2 , true, CD->TYPE);
+            //        Send_IRCA(ChanOrPM(CD),pinfo3 , true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Unknown Character ID. (GUID)" ,true, "ERROR");
+    }
+    else
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name FROM characters WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[0].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string items = "\x2 Character Search Results:\x3\x31\x30 ";
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string guid = fields[0].GetString();
+                std::string account = fields[1].GetString();
+                std::string name = fields[2].GetString();
+                MakeUpper(name);
+                items.append(name+"(Account:"+account+" - GUID:"+guid+")\0031 | \xF");
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Unknown Character. I Cant Find Any Characters With Those Search Terms." ,true, "ERROR");
+    }
+
+}
+
+void IRCCmd::Lookup_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (_PARAMS[0] == "acct")
+    {
+        uint32 acctid = atoi(_PARAMS[1].c_str());
+        if (AccountMgr::GetId(_PARAMS[1]))
+            acctid = AccountMgr::GetId(_PARAMS[1]);
+        if (acctid > 0)
+        {
+            std::string DateTime = "%a, %b %d, %Y - %h:%i%p";
+            QueryResult result = LoginDatabase.PQuery("SELECT `account`.`id`, username, last_ip, (SELECT banreason FROM account_banned WHERE `account`.`id` = id LIMIT 1) as banned, (SELECT banreason FROM ip_banned WHERE ip = last_ip) as bannedip,(SELECT active FROM account_banned WHERE `account`.`id` = id) as banactive, (SELECT( unbandate - unix_timestamp( now() ) ) FROM account_banned WHERE `account`.`id` = id) as remainingtime, DATE_FORMAT(last_login, '%s') FROM `account` WHERE `account`.`id` =%d" ,DateTime.c_str(), acctid);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 id = fields[0].GetUInt32();
+                std::string usrname = fields[1].GetString();
+                std::string lastip = fields[2].GetString();
+                std::string banreason = fields[3].GetString();
+                std::string banreasonip = fields[4].GetString();
+                uint32 banactive = (fields[5].GetInt32() == 1 ? 1 : 0);
+                std::string TimeLeft = SecToDay(fields[6].GetString());
+                std::string lastlogin = fields[7].GetString();
+
+                QueryResult chars = CharacterDatabase.PQuery("SELECT guid, name, (SELECT SUM(totaltime) FROM characters WHERE account = %d) AS tottime FROM characters WHERE account = %u", id, id);
+                std::string characters = "None";
+                std::string totaccttime = "Never Logged In";
+                if (chars)
+                {
+                    characters = "";
+                    Field *fields = chars->Fetch();
+                    totaccttime = SecToDay(fields[2].GetString());
+                    for (uint64 i=0; i < chars->GetRowCount(); i++)
+                    {
+                        std::string guid = fields[0].GetString();
+                        std::string charname = fields[1].GetString();
+                        characters.append(charname+"("+guid+"), ");
+                        chars->NextRow();
+                    }
+
+                }
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Username: \xF %s | \00310AccountID: \xF %d | \00310Last IP: \xF %s | \00310Last Login: \xF %s", usrname.c_str(), id, lastip.c_str(), lastlogin.c_str()), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00310Total play time: \xF %s | \00310Characters:  \xF %s ", totaccttime.c_str(), characters.c_str()), true, CD->TYPE);
+                if (banreason.length() > 1)
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\0035Account banned : \xF %s | \0035Ban Active: \xF %u | \0035Ban Time: \xF %s", banreason.c_str(), banactive, TimeLeft.c_str()), true, CD->TYPE);
+                if (banreasonip.length() > 1)
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\0034This User Has An IP Ban. Ban Reason: %s", banreasonip.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Account ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = LoginDatabase.PQuery("SELECT id, username FROM `account` WHERE username LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string accts = "\002Account Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string acctid = fields[0].GetString();
+                    std::string acctname = fields[1].GetString();
+                    accts.append(acctname+"("+acctid+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), accts, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Username. I Cant Find Any Users With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "char")
+    {
+        uint32 plguid = atoi(_PARAMS[1].c_str());
+        if (sObjectMgr->GetPlayerGUIDByName(_PARAMS[1].c_str()))
+            plguid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[1].c_str());
+        if (plguid > 0)
+        {
+            QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, online, SUBSTRING_INDEX(SUBSTRING_INDEX(`level`, ' ' , 35), ' ' , -1) AS level,  SUBSTRING_INDEX(SUBSTRING_INDEX(`xp`, ' ' , 927), ' ' , -1) AS xp, SUBSTRING_INDEX(SUBSTRING_INDEX(money, ' ' , 1462), ' ' , -1) AS gold, SUBSTRING_INDEX(SUBSTRING_INDEX(`totalHonorPoints`, ' ' , 1454), ' ' , -1) AS Honor, totaltime FROM characters WHERE guid =%i", plguid);
+            uint32 latency = 0;
+            Player *chr = ObjectAccessor::FindPlayer(plguid);
+            if (chr)
+            {
+                latency = chr->GetSession()->GetLatency();
+            }
+            char templatency [100];
+            sprintf(templatency, "%ums", latency);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string pguid = fields[0].GetString();
+                std::string pacct = fields[1].GetString();
+                std::string pname = fields[2].GetString();
+                uint32 praceid = fields[3].GetUInt32();
+                uint32 pclassid = fields[4].GetUInt32();
+                std::string ponline = (fields[5].GetInt32() == 1 ? "\x3\x30\x33Online" : "\x3\x30\x34Offline\xF");
+                std::string plevel = fields[6].GetString();
+                std::string pxp = fields[7].GetString();
+                unsigned int money = fields[8].GetInt32();
+                std::string honor = fields[9].GetString();
+                std::string totaltim = SecToDay(fields[10].GetString());
+
+                std::string sqlquery = "SELECT `gmlevel` FROM `account_access` WHERE `id` = '" + pacct + "';";
+                QueryResult gmresult = LoginDatabase.Query(sqlquery.c_str());
+                std::string pgmlvl = "0";
+                if (gmresult)
+                {
+                    Field *fields = result->Fetch();
+                    pgmlvl = fields[0].GetString();
+                }
+
+                ChrRacesEntry const* prace = sChrRacesStore.LookupEntry(praceid);
+                ChrClassesEntry const* pclass = sChrClassesStore.LookupEntry(pclassid);
+
+                if (atoi(plevel.c_str()) < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+                    plevel += " (" + pxp + ")";
+                unsigned int gold = money / 10000;
+                unsigned int silv = (money % 10000) / 100;
+                unsigned int cop = (money % 10000) % 100;
+                char tempgold [100];
+                sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+                if (ponline == "\x3\x30\x33Online")
+                {
+                    Player * plr = sObjectAccessor->FindPlayerByName(pname.c_str());
+                    if (plr)
+                    {
+                        AreaTableEntry const* area = GetAreaEntryByAreaID(plr->GetAreaId());
+                        ponline += " in " + (std::string) area->area_name[sWorld->GetDefaultDbcLocale()];
+                        if (area->zone != 0)
+                        {
+                            AreaTableEntry const* zone = GetAreaEntryByAreaID(area->zone);
+                            ponline += " (" + (std::string)zone->area_name[sWorld->GetDefaultDbcLocale()] + ")";
+                        }
+                    }
+                }
+                std::string pinfo  = "\x2 About Player:\x3\x31\x30 " +pname+ "\xF |\x2 GM Level:\x3\x31\x30 " +pgmlvl+ "\xF |\x2 AcctID:\x3\x31\x30 " +pacct+ "\xF |\x2 CharID:\x3\x31\x30 " +pguid+ " \xF |\x2 Played Time:\x2\x3\x31\x30 " +totaltim.c_str()+" \xF |\x2 Latency:\x2\x3\x31\x30 "+templatency;
+                std::string pinfo2 = "\x2 Race:\x2\x3\x31\x30 " + (std::string)prace->name[sWorld->GetDefaultDbcLocale()] + "\xF |\x2 Class:\x2\x3\x31\x30 " + (std::string)pclass->name[sWorld->GetDefaultDbcLocale()] + "\xF |\x2 Level:\x2\x3\x31\x30 " + plevel + "\xF |\x2 Money:\x2 " + tempgold + "\xF |\x2 Status:\x2 " + ponline;
+                //        pinfo3 = " :" + " \x2Honor Kills:\x2\x3\x31\x30 " + hk;
+                Send_IRCA(ChanOrPM(CD),pinfo , true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD),pinfo2 , true, CD->TYPE);
+                //        Send_IRCA(ChanOrPM(CD),pinfo3 , true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Character ID. (GUID)" ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = CharacterDatabase.PQuery("SELECT guid, account, name FROM characters WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\x2 Character Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string guid = fields[0].GetString();
+                    std::string account = fields[1].GetString();
+                    std::string name = fields[2].GetString();
+                    MakeUpper(name);
+                    items.append(name+"(Account:"+account+" - GUID:"+guid+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Character. I Cant Find Any Characters With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "creature")
+    {
+        std::string creature = _PARAMS[1];
+        if (atoi(creature.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name, minlevel,maxlevel, faction_A,  (SELECT count(guid) FROM creature WHERE id = '%s') as spawns FROM creature_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 entry = fields[0].GetUInt32();
+                std::string name = fields[1].GetString();
+                uint32 minlevel = fields[2].GetUInt32();
+                uint32 maxlevel = fields[3].GetUInt32();
+                uint32 faction = fields[4].GetUInt32();
+                uint32 spawns = fields[5].GetUInt32();
+
+
+               Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Name:\x3\x31\x30 %s \xF|\x2 CreatureID:\x3\x31\x30 %d", name.c_str(), entry), true, CD->TYPE);
+               Send_IRCA(ChanOrPM(CD), MakeMsg("\x2minlevel:\x3\x31\x30 %d \xF|\x2 maxlevel:\x3\x31\x30 %d \xF|\x2 Faction:\x3\x31\x30 %d \xF|\x2 Spawns:\x3\x31\x30 %d", minlevel, maxlevel, faction, spawns), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Creature ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM creature_template WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\002Creature Search Results:\x3\x31\x30 ";
+                //Send_IRCA(ChanOrPM(CD), "", true, CD->TYPE);
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string CreatureID = fields[0].GetString();
+                    std::string Name = fields[1].GetString();
+                    items.append(Name+"("+CreatureID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Creature. I Cant Find Any Creatures With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "faction")
+    {
+        std::string faction = _PARAMS[1];
+        if (atoi(faction.c_str()) > 0)
+        {
+            FactionEntry const *factionEntry = sFactionStore.LookupEntry(atoi(faction.c_str()));
+            if (factionEntry)
+            {
+                std::string name = factionEntry->name[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2 Faction:\x3\x31\x30 %s \xF|\x2 FactionID:\x3\x31\x30 %s",name.c_str(), faction.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown FactionID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string factions = "\002Faction Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sFactionStore.GetNumRows(); id++)
+            {
+                FactionEntry const *factionEntry = sFactionStore.LookupEntry(id);
+                if (factionEntry)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = factionEntry->name[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char factionid[100];
+                        sprintf(factionid, "%d", id);
+                        factions.append(name+"("+factionid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                factions.append("No Factions Found.");
+            Send_IRCA(ChanOrPM(CD), factions, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "go")
+    {
+        std::string gobject = _PARAMS[1];
+        if (atoi(gobject.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, type, displayId, name, faction, (SELECT count(*) FROM gameobject WHERE id = '%s') as spawns FROM gameobject_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 entry = fields[0].GetUInt32();
+                uint32 type = fields[1].GetUInt32();
+                uint32 modelid = fields[2].GetUInt32();
+                std::string name = fields[3].GetString();
+                uint32 faction = fields[4].GetUInt32();
+                uint32 spawns = fields[5].GetUInt32();
+
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2GO Name:\x3\x31\x30 %s \xF|\x2 GameobjectID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Spawns:\x3\x31\x30 %d", name.c_str(), entry, modelid, spawns), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Type:\x3\x31\x30 %d \xF|\x2 Faction:\x3\x31\x30 %d", type, faction), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown GameObject ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM gameobject_template WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string gos = "\002Gameobject Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string GOID = fields[0].GetString();
+                    std::string GoName = fields[1].GetString();
+                    gos.append(GoName+"("+GOID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), gos, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Game Object. I Cant Find Any Game Object's With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "item")
+    {
+        std::string item = _PARAMS[1];
+        if (atoi(item.c_str()) > 0)
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name, displayid, (SELECT count(*) FROM creature_loot_template WHERE item = '%s') as loot FROM `item_template` WHERE entry = %s", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                QueryResult result2 = CharacterDatabase.PQuery("SELECT count(*) FROM `character_inventory` WHERE item_template = %s", _PARAMS[1].c_str());
+                Field *fields2 = result2->Fetch();
+                uint32 charcnt = fields2[0].GetUInt32();
+
+
+                uint32 ItemID = fields[0].GetUInt32();
+                std::string ItmName = fields[1].GetString();
+                uint32 DisplayID = fields[2].GetUInt32();
+                uint32 loots = 0;
+                loots = fields[3].GetUInt32();
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Item:\x3\x31\x30 %s \xF|\x2 ItemID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Owned By:\x3\x31\x30 %d players \xF|\x2 Dropped By:\x3\x31\x30 %d creatures", ItmName.c_str(), ItemID, DisplayID, charcnt, loots), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown ItemID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, name FROM `item_template` WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\002Item Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string ItemID = fields[0].GetString();
+                    std::string ItemName = fields[1].GetString();
+                    items.append(ItemName+"("+ItemID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Item. I Cant Find Any Items With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "quest")
+    {
+        std::string quest = _PARAMS[1];
+        if (atoi(quest.c_str()) > 0)
+        {
+            WorldDatabase.EscapeString(_PARAMS[1]);
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, Title FROM quest_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                QueryResult result2 = CharacterDatabase.PQuery("SELECT count(*) FROM character_queststatus WHERE quest = '%s' AND status = '1';", _PARAMS[1].c_str());
+                Field *fields2 = result2->Fetch();
+                uint32 status = fields2[0].GetUInt32();
+
+
+                Field *fields = result->Fetch();
+                uint32 entry = fields[0].GetUInt32();
+                std::string name = fields[1].GetString();
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Quest Name:\x3\x31\x30 %s \xF|\x2 QuestID:\x3\x31\x30 %d \xF|\x2 Completed:\x3\x31\x30 %d times", name.c_str(), entry, status), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Quest ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT entry, Title FROM quest_template WHERE Title LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string quests = "\002Quest Search Results:\x3\x31\x30 ";
+                //Send_IRCA(ChanOrPM(CD), "", true, CD->TYPE);
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string QuestID = fields[0].GetString();
+                    std::string QuestName = fields[1].GetString();
+                    quests.append(QuestName+"("+QuestID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+
+                Send_IRCA(ChanOrPM(CD), quests, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Quest. I Cant Find Any Quest's With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "skill")
+    {
+        std::string skill = _PARAMS[1];
+        if (atoi(skill.c_str()) > 0)
+        {
+            SkillLineEntry const *skillInfo = sSkillLineStore.LookupEntry(atoi(skill.c_str()));
+            if (skillInfo)
+            {
+                std::string name = skillInfo->name[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Skill:\x3\x31\x30 %s \xF|\x2 SkillID:\x3\x31\x30 %s",name.c_str(), skill.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown SkillID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string skills = "\002Skill Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sSkillLineStore.GetNumRows(); id++)
+            {
+                SkillLineEntry const *skillInfo = sSkillLineStore.LookupEntry(id);
+                if (skillInfo)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = skillInfo->name[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char skillid[100];
+                        sprintf(skillid, "%d", id);
+                        skills.append(name+"("+skillid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                skills.append("No Skills Found.");
+            Send_IRCA(ChanOrPM(CD), skills, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "spell")
+    {
+        std::string spell = _PARAMS[1];
+        if (atoi(spell.c_str()) > 0)
+        {
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(atoi(spell.c_str()));
+            if (spellInfo)
+            {
+                std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Spell:\x3\x31\x30 %s \xF|\x2 SpellID:\x3\x31\x30 %s",name.c_str(), spell.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown SpellID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string spells = "\002Spell Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sSpellStore.GetNumRows(); id++)
+            {
+                SpellEntry const *spellInfo = sSpellStore.LookupEntry(id);
+                if (spellInfo)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char itemid[100];
+                        sprintf(itemid, "%d", id);
+                        spells.append(name+"("+itemid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                spells.append("No Spells Found.");
+            Send_IRCA(ChanOrPM(CD), spells, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "tele")
+    {
+        std::string tele = _PARAMS[1];
+        if (atoi(tele.c_str()) > 0)
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT * FROM `game_tele` WHERE id = %s", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 teleid = fields[0].GetUInt32();
+                uint32 pos_x = fields[1].GetUInt32();
+                uint32 pos_y = fields[2].GetUInt32();
+                uint32 pos_z = fields[3].GetUInt32();
+                uint32 oriet = fields[4].GetUInt32();
+                uint32 map = fields[5].GetUInt32();
+                std::string telname = fields[6].GetString();
+
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Tele Name:\x3\x31\x30 %s \xF|\x2 TeleID:\x3\x31\x30 %d \xF|\x2 Coordinates:\x3\x31\x30 [X: %d, Y: %d, Z: %d, MAP: %d, Orientation: %d]", telname.c_str(), teleid, pos_x, pos_y, pos_z, map, oriet), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Teleport Location ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult result = WorldDatabase.PQuery("SELECT id, name FROM `game_tele` WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string teles = "\002Tele Location Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string TeleID = fields[0].GetString();
+                    std::string TeleName = fields[1].GetString();
+                    teles.append(TeleName+"("+TeleID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                Send_IRCA(ChanOrPM(CD), teles, true, CD->TYPE);
+
+            }
+            else
+                Send_IRCA(CD->USER, "Unknown Item. I Cant Find Any Items With Those Search Terms." ,true, "ERROR");
+        }
+    }
+}
+
+void IRCCmd::Level_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(player.c_str());
+    std::string s_newlevel  = _PARAMS[1];
+    uint8 i_newlvl = atoi(s_newlevel.c_str());
+    if (!guid)
+    {
+        Send_IRCA(CD->USER, "Player Not Found!", true, "ERROR");
+        return;
+    } else if (i_newlvl < 1 || i_newlvl > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+    {
+        Send_IRCA(CD->USER, MakeMsg("Level Must Be Between 1 And %i!",sConfigMgr->GetIntDefault("MaxPlayerLevel", 70)), true, "ERROR");
+        return;
+    } else
+    {
+        Player *chr = ObjectAccessor::FindPlayer(guid);
+        uint64 level;
+        int32 i_oldlvl = chr ? chr->getLevel() : Player::GetLevelFromDB(level);
+        Player* plTarget = chr;
+        if (!plTarget)
+        {
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+            return;
+        }
+
+        if (chr)
+        {
+            chr->GiveLevel(i_newlvl);
+            chr->InitTalentForLevel();
+            chr->SetUInt32Value(PLAYER_XP,0);
+            WorldPacket data;
+            ChatHandler CH(chr->GetSession());
+            if (i_oldlvl == i_newlvl)
+                CH.SendSysMessage("Your level progress has been reset.");
+            else
+            if (i_oldlvl < i_newlvl)
+                CH.SendSysMessage(fmtstring("You have been leveled up (%i)",i_newlvl-i_oldlvl));
+            else
+            if (i_oldlvl > i_newlvl)
+                CH.SendSysMessage(fmtstring("You have been leveled down (%i)",i_newlvl-i_oldlvl));
+            chr->GetSession()->SendPacket(&data);
+        }
+        else
+        {
+            Player::GetLevelFromDB(guid);
+            uint64 player_guid;
+            CharacterDatabase.PExecute("UPDATE characters SET level = '%u', xp = 0 WHERE guid = '%u'", i_newlvl, GUID_LOPART(player_guid));
+        }
+    }
+    Send_IRCA(ChanOrPM(CD), "\00313[" + _PARAMS[0]+ "] : Has Been Leveled To " + _PARAMS[1] + ". By: "+CD->USER+".", true, CD->TYPE);
+}
+
+void IRCCmd::Money_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(player.c_str());
+    Player *chr = ObjectAccessor::FindPlayer(guid);
+
+    std::string s_money  = _PARAMS[1];
+    int32 money = atoi(s_money.c_str());
+    unsigned int gold = money / 10000;
+    unsigned int silv = (money % 10000) / 100;
+    unsigned int cop = (money % 10000) % 100;
+    char tempgold [100];
+    sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+    if (!guid)
+    {
+        Send_IRCA(CD->USER, "Player Not Found!", true, "ERROR");
+        return;
+    }
+    else
+    {
+        Player *chr = ObjectAccessor::FindPlayer(guid);
+        uint32 moneyuser = 0;
+        if (chr)
+            moneyuser = chr->GetMoney();
+        else {
+        CharacterDatabase.EscapeString(player);
+        std::string sqlquery = "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(money, ' ' , 1462), ' ' , -1) AS `gold` FROM `characters` WHERE `name` = '"+player+"';";
+        QueryResult result = CharacterDatabase.Query(sqlquery.c_str());
+            Field *fields = result->Fetch();
+            moneyuser = fields[0].GetInt32();
+
+        }
+            int32 addmoney = money;
+            int32 newmoney = moneyuser + addmoney;
+            char s_newmoney[255];
+            sprintf(s_newmoney,"%d",newmoney);
+            if (addmoney < 0)
+            {
+                TC_LOG_ERROR("misc", "USER1: %i, ADD: %i, DIF: %i\\n", moneyuser, addmoney, newmoney);
+                if (newmoney <= 0)
+                {
+                    Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Had All Money Taken By: "+CD->USER.c_str()+".", true, CD->TYPE);
+                    if (chr)
+                    {
+                        chr->SetMoney(0);
+                        Send_Player(chr, MakeMsg("You Have Been Liquidated By: %s. Total Money Is Now 0.", CD->USER.c_str()));
+                    }
+                    else
+                        CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+                }
+                else
+                {
+                    Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Had ("+s_money+"\00313) Taken From Them By: "+CD->USER.c_str()+".", true, CD->TYPE);
+                    if (chr)
+                    {
+                        chr->SetMoney(newmoney);
+                        Send_Player(chr, MakeMsg("You Have Had %s Copper Taken From You By: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+                    }
+                    else
+                        CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+                }
+            }
+            else
+            {
+                Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Been Given ("+tempgold+"\00313) From: "+CD->USER.c_str()+".", true, CD->TYPE);
+                if (chr)
+                {
+                    chr->ModifyMoney(addmoney);
+                    Send_Player(chr, MakeMsg("You Have Been Given %s Copper. From: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+                }
+                else
+                    CharacterDatabase.PExecute("UPDATE `characters` SET money=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+            }
+    }
+}
+
+void IRCCmd::Mute_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+    if (guid)
+    {
+        if (_PARAMS[1] == "release")
+        {
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            uint32 account_id = 0;
+            account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+            LoginDatabase.PExecute("UPDATE `account` SET `mutetime` = '0' WHERE `id` = '%u'", account_id);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been UnMuted By: "+CD->USER+"." , true, CD->TYPE);
+            if (plr)
+            {
+                plr->GetSession()->m_muteTime = 0;
+                Send_Player(plr, MakeMsg("You Have Been UnMuted By: %s.", CD->USER.c_str()));
+            }
+        }
+        else
+        {
+            if (_PARAMS[2] == "")
+                _PARAMS[2] = "No Reason Given";
+            Player* plr = ObjectAccessor::FindPlayer(guid);
+            time_t mutetime = time(NULL) + atoi(_PARAMS[1].c_str())*60;
+            uint32 account_id = 0;
+            account_id = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+            if (plr)
+                plr->GetSession()->m_muteTime = mutetime;
+            LoginDatabase.PExecute("UPDATE `account` SET `mutetime` = " UI64FMTD " WHERE `id` = '%u'",uint64(mutetime), account_id);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been Muted By: "+CD->USER+". For: "+_PARAMS[1]+" Minutes. Reason: "+_PARAMS[2] , true, CD->TYPE);
+            if (plr)
+                Send_Player(plr, MakeMsg("You Have Been Muted By: %s. For: %s Minutes. Reason: %s", CD->USER.c_str(), _PARAMS[1].c_str(), _PARAMS[2].c_str()));
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "Player Does Not Exist!", true, "ERROR");
+}
+
+void IRCCmd::Online_Players(_CDATA *CD)
+{
+        sIRC.Script_Lock[MCS_Players_Online] = true;
+        ACE_Based::Thread script(new mcs_OnlinePlayers(CD));
+}
+
+void IRCCmd::PM_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isAcceptWhispers())
+        {
+            std::string sMsg = MakeMsg("|cffFE87FD[<IRC>%s] Whispers: %s|r", CD->USER.c_str(), _PARAMS[1].c_str());
+            WorldPacket data(SMSG_MESSAGECHAT, 200);
+            data << (uint8)CHAT_MSG_SYSTEM;
+            data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)plr->GetGUID();
+            data << (uint32)0;
+            data << (uint64)plr->GetGUID();
+            data << (uint32)(sMsg.length()+1);
+            data << sMsg;
+            data << (uint8)0;
+            plr->GetSession()->SendPacket(&data);
+            plr->SendPlaySound(3081, true);
+            Send_IRCA(ChanOrPM(CD), "\00313To ["+_PARAMS[0]+"] : "+_PARAMS[1]+".", true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "Is Not Accepting Private Messages!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Player not online!", true, "ERROR");
+}
+
+void IRCCmd::Restart_Trinity(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "cancel")
+    {
+        sWorld->ShutdownCancel();
+        Send_IRCA(ChanOrPM(CD), "\0034Server Restart Has Been Cancelled.", true, CD->TYPE);
+    }
+
+    int32 i_time = atoi(_PARAMS[0].c_str());
+    if (i_time < 0)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Please Enter A Number! And No Negative Numbers! "+_PARAMS[0]+" Seconds!?", true, CD->TYPE);
+        return;
+    }
+    if (i_time >= 1)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Requested Server To Restart In "+_PARAMS[0]+" Seconds!", true, CD->TYPE);
+        sWorld->ShutdownServ(i_time,SHUTDOWN_MASK_RESTART, RESTART_EXIT_CODE);
+        Delay(i_time*1000);
+        Send_IRCA(ChanOrPM(CD), "\0034Server Will Now Restart.. Be Back In A Flash!", true, CD->TYPE);
+    }
+}
+
+void IRCCmd::Revive_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isDead())
+        {
+            plr->ResurrectPlayer(0.5f);
+            plr->SpawnCorpseBones();
+            plr->SaveToDB();
+            sIRC.Send_IRC_Channel(ChanOrPM(CD), " \00313["+_PARAMS[0]+"] : Has Been Revived By: " + CD->USER, true, CD->TYPE);
+            Send_Player(plr, MakeMsg("You Have Been Revived By: %s.", CD->USER.c_str()));
+        }
+        else
+            Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Dead!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, ""+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Saveall_Player(_CDATA *CD)
+{
+    sObjectAccessor->SaveAllPlayers();
+    Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Saved All Players!", true, CD->TYPE);
+}
+
+void IRCCmd::Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (_PARAMS[0] == "setmotd")
+    {
+        sWorld->SetMotd(_PARAMS[1]);
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Set New Message Of The Day To: "+_PARAMS[1], true, CD->TYPE);
+    }
+    if (_PARAMS[0] == "flusharenapoints")
+    {
+        sArenaTeamMgr->DistributeArenaPoints();
+    }
+}
+
+void IRCCmd::Shutdown_Trinity(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "cancel")
+    {
+        sWorld->ShutdownCancel();
+        Send_IRCA(ChanOrPM(CD), "\0034Server Shutdown Has Been Cancelled.", true, CD->TYPE);
+    }
+
+    int32 i_time = atoi(_PARAMS[0].c_str());
+    if (i_time < 0)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Please Enter A Number! And No Negative Numbers! "+_PARAMS[0]+" Seconds!?", true, CD->TYPE);
+        return;
+    }
+    if (i_time >= 1)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Requested Server To Be Shut Down In "+_PARAMS[0]+" Seconds!", true, CD->TYPE);
+        sWorld->ShutdownServ(i_time, SHUTDOWN_MASK_IDLE , SHUTDOWN_EXIT_CODE);
+        Delay(i_time*1000);
+        Send_IRCA(ChanOrPM(CD), "\0034Server Will Now Shut Down.. Good Bye!", true, CD->TYPE);
+    }
+}
+
+void IRCCmd::Spell_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    uint32 spell = atoi(_PARAMS[2].c_str());
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (spellInfo)
+        {
+            std::string name = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+            if (_PARAMS[1] == "cast")
+            {
+                plr->CastSpell(plr, spell, true);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Had Spell "+name+" Casted On Them.", true, CD->TYPE);
+            }
+            if (_PARAMS[1] == "learn")
+            {
+                plr->learnSpell(spell, true);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Learned Spell "+name+".", true, CD->TYPE);
+            }
+            if (_PARAMS[1] == "unlearn")
+            {
+                plr->removeSpell(spell);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Unlearned Spell "+name+".", true, CD->TYPE);
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "Incorrect Spell ID!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Player Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Sysmsg_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    std::string ircchan = "#";
+    ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+    if (_PARAMS[0] == "a")
+    {
+        std::string str = _PARAMS[1];
+        std::string ancmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 System Message \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        sWorld->SendWorldText(6610,str.c_str());
+        sIRC.Send_IRC_Channel(ircchan, ancmsg, true);
+    }
+    else if (_PARAMS[0] == "e")
+    {
+        std::string str = _PARAMS[1];
+        std::string notstr = "[Server Event]: " + _PARAMS[1];
+        std::string notmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Server Event \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        WorldPacket data(SMSG_NOTIFICATION, (notstr.size()+1));
+        data << notstr;
+        WorldPacket data2(SMSG_PLAY_SOUND,32);
+        data2 << (uint32)1400;
+        sWorld->SendGlobalMessage(&data2);
+        sWorld->SendGlobalMessage(&data);
+        sWorld->SendWorldText(6611,str.c_str());
+        sIRC.Send_IRC_Channel(ircchan, notmsg, true);
+    }
+    else if (_PARAMS[0] == "n")
+    {
+        std::string str = "Global notify: " + _PARAMS[1];
+        std::string notmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Global Notify \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalMessage(&data);
+        sIRC.Send_IRC_Channel(ircchan, notmsg, true);
+    }
+    else if (_PARAMS[0] == "gm")
+    {
+        std::string str = "GM Announcement: " + _PARAMS[1];
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalGMMessage(&data);
+
+    }
+    else if (_PARAMS[0] == "add")
+    {
+        WorldDatabase.PExecute("INSERT INTO irc_autoannounce (message, addedby) VALUES ('%s', '%s')", _PARAMS[1].c_str(), CD->USER.c_str());
+        std::string str = _PARAMS[1];
+        std::string ancmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Automatic System Message \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        sWorld->SendWorldText(6612,str.c_str());
+        sIRC.Send_IRC_Channel(ircchan, ancmsg, true);
+    }
+    else if (_PARAMS[0] == "del")
+    {
+        WorldDatabase.PExecute("DELETE FROM irc_autoannounce WHERE id = %s", _PARAMS[1].c_str());
+        Send_IRCA(ChanOrPM(CD), MakeMsg("Deleted Automatic Announcement Message ID: %s", _PARAMS[1].c_str()), true, CD->TYPE);
+    }
+    else if (_PARAMS[0] == "list")
+    {
+        QueryResult result = WorldDatabase.PQuery("SELECT * FROM irc_autoannounce LIMIT 5;", _PARAMS[1].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string id = fields[0].GetString();
+                std::string message = fields[1].GetString();
+                std::string addedby = fields[2].GetString();
+                Send_IRCA(ChanOrPM(CD), MakeMsg("ID: %s - Added By: %s - Message: %s", id.c_str(), addedby.c_str(), message.c_str()), true, CD->TYPE);
+                result->NextRow();
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "No Auto Announce Messages Are In The Database.", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Please Use (a-Announce)(n-Notify)(e-Event) As Second Parameter!", true, "ERROR");
+}
+
+void IRCCmd::Tele_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 4);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("You do not have access to do this to a higher ranked GM [%i]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    bool DoTeleport = false;
+    float pX, pY, pZ, pO = 0;
+    uint32 mapid = 0;
+    std::string rMsg = " Teleport Failed!";
+    std::string wMsg = "Invalid Tele Location";
+    Player* plr = GetPlayer(_PARAMS[0]);
+    if (plr)
+    {
+        if (plr->IsInFlight() || plr->IsInCombat())
+        {
+            Send_IRCA(CD->USER, MakeMsg("%s Is Busy And Cannot Be Teleported! They Could Be In Combat, Or Flying.",_PARAMS[0].c_str()), true, "ERROR");
+            return;
+        }
+    }
+    if (_PARAMS[1] == "l" || _PARAMS[1].size() > 2)
+    {
+        if (_PARAMS[1].size() > 1)
+            _PARAMS[2] = _PARAMS[1];
+        WorldDatabase.EscapeString(_PARAMS[2]);
+        QueryResult result = WorldDatabase.PQuery("SELECT position_x, position_y, position_z, orientation, map FROM game_tele WHERE name='%s';", _PARAMS[2].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            pX = fields[0].GetFloat();
+            pY = fields[1].GetFloat();
+            pZ = fields[2].GetFloat();
+            pO = fields[3].GetFloat();
+            mapid = fields[4].GetUInt16();
+
+            rMsg = MakeMsg(" \00313[%s] : Teleported To %s! By: %s.",
+                _PARAMS[0].c_str(),
+                _PARAMS[2].c_str(),
+                CD->USER.c_str());
+            wMsg = MakeMsg("You Have Been Teleported To %s By: %s.",
+                _PARAMS[2].c_str(),
+                CD->USER.c_str());
+            DoTeleport = true;
+        }
+        else
+        {
+            WorldDatabase.EscapeString(_PARAMS[2]);
+            QueryResult result = WorldDatabase.PQuery("SELECT name FROM game_tele WHERE name LIKE '%%%s%%' LIMIT 7;", _PARAMS[2].c_str());
+            if (result)
+            {
+                std::string telename = "<> ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    Field *fields = result->Fetch();
+                    telename.append(fields[0].GetString());
+                    result->NextRow();
+                    telename.append(" <> ");
+                }
+
+                Send_IRCA(CD->USER, "I Cannot Find Location: "+_PARAMS[2]+" . Perhaps One Of These Will Work For You.", true, "ERROR");
+                Send_IRCA(CD->USER, telename, true, "ERROR");
+                return;
+            }
+            else
+                Send_IRCA(CD->USER, "Location Not Found! Nothing Even Close Found!", true, "ERROR");
+                return;
+        }
+    }
+    else if (_PARAMS[1] == "c")
+    {
+        std::string* _PARAMSA = getArray(_PARAMS[2], 4);
+        pX = atof(_PARAMSA[1].c_str());
+        pY = atof(_PARAMSA[2].c_str());
+        pZ = atof(_PARAMSA[3].c_str());
+        mapid = atoi(_PARAMSA[0].c_str());
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMSA[0].c_str(),
+            _PARAMSA[1].c_str(),
+            _PARAMSA[2].c_str(),
+            _PARAMSA[3].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Have Been Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+            _PARAMSA[0].c_str(),
+            _PARAMSA[1].c_str(),
+            _PARAMSA[2].c_str(),
+            _PARAMSA[3].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+    }
+    else if (_PARAMS[1] == "r")
+    {
+        if (plr)
+        {
+            pX = plr->m_recallX;
+            pY = plr->m_recallY;
+            pZ = plr->m_recallZ;
+            pO = plr->m_recallO;
+            mapid = plr->m_recallMap;
+            rMsg = MakeMsg(" \00313[%s] : Has Been Recalled To Their Previous Location.",
+                _PARAMS[0].c_str());
+            wMsg = MakeMsg("You Have Been Recalled To Your Previous Location. By: %s",
+                CD->USER.c_str());
+            DoTeleport = true;
+        }
+        else
+        {
+            Send_IRCA(CD->USER, MakeMsg("\00313[%s] : Cannot Be Recalled, They Are Not Online.", _PARAMS[0].c_str()), true, "ERROR");
+            return;
+        }
+
+    }
+    else if (_PARAMS[1] == "to")
+    {
+        Player* plr2 = GetPlayer(_PARAMS[2]);
+        if (plr2)
+        {
+            plr2->GetContactPoint(plr, pX, pY, pZ);
+            mapid = plr2->GetMapId();
+        }
+        else
+        {
+            if (uint64 guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[2].c_str()))
+            {
+                bool in_flight;
+                Player::LoadPositionFromDB(mapid, pX, pY, pZ, pO, in_flight, guid);
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "Second Player Not Found!", true, "ERROR");
+                return;
+            }
+        }
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Player: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+    }
+    else if (_PARAMS[1] == "cr")
+    {
+      QueryResult result = WorldDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map FROM creature WHERE guid ='%s' LIMIT 1", _PARAMS[2].c_str());
+      if (!result)
+      {
+          Send_IRCA(CD->USER, "Creature GUID not found", true, "ERROR");
+      }
+      else
+      {
+        Field *fields = result->Fetch();
+        pX = fields[0].GetFloat();
+        pY = fields[1].GetFloat();
+        pZ = fields[2].GetFloat();
+        pO = fields[3].GetFloat();
+        mapid = fields[4].GetUInt16();
+
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Creature: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+
+      }
+    }
+    else if (_PARAMS[1] == "go")
+    {
+      QueryResult result = WorldDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map FROM gameobject WHERE guid ='%s' LIMIT 1", _PARAMS[2].c_str());
+      if (!result)
+      {
+          Send_IRCA(CD->USER, "GO GUID not found", true, "ERROR");
+      }
+      else
+      {
+        Field *fields = result->Fetch();
+        pX = fields[0].GetFloat();
+        pY = fields[1].GetFloat();
+        pZ = fields[2].GetFloat();
+        pO = fields[3].GetFloat();
+        mapid = fields[4].GetUInt16();
+
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Gameobject: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+
+      }
+    }
+    else if (_PARAMS[1] == "homebind")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT position_x,position_y,position_z,map FROM `character_homebind` WHERE guid = '%d'", plr->GetGUID());
+        if (!result)
+        {
+          Send_IRCA(CD->USER, "Unexpected Error Loading Homebind Location", true, "ERROR");
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            pX = fields[0].GetFloat();
+            pY = fields[1].GetFloat();
+            pZ = fields[2].GetFloat();
+            pO = 1;
+            mapid = fields[3].GetUInt16();
+
+            rMsg = MakeMsg(" \00313[%s] : Teleported To Homebind Location By: %s.",
+                _PARAMS[0].c_str(),
+                CD->USER.c_str());
+            wMsg = MakeMsg("You Are Being Teleported To Your Homebind Location By: %s.",
+            CD->USER.c_str());
+            DoTeleport = true;
+
+        }
+
+    }
+    if (DoTeleport)
+    {
+        if (MapManager::IsValidMapCoord(mapid, pX ,pY ,pZ))
+        {
+            //if (!sIRC.BeenToGMI(pX, pY, _PARAMS[0], CD->USER))
+            //{
+                //if player is online teleport them in real time, if not set the DB to our coordinates.
+                if (plr)
+                {
+                    plr->SaveRecallPosition();
+                    plr->TeleportTo(mapid, pX, pY, pZ, pO);
+                    sIRC.Send_IRC_Channel(ChanOrPM(CD), rMsg, true, CD->TYPE);
+                    Send_Player(plr, wMsg);
+                }
+                else
+                {
+                    uint64 guid = sObjectMgr->GetPlayerGUIDByName(_PARAMS[0]);
+                    Player::SavePositionInDB(mapid,pX,pY,pZ,pO,sMapMgr->GetZoneId(mapid,pX,pY,pZ),guid);
+                    sIRC.Send_IRC_Channel(ChanOrPM(CD), rMsg + " \0034*Offline Tele.* ", true, CD->TYPE);
+                }
+            //}
+        }
+        else
+            Send_IRCA(CD->USER, "Invalid Location!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "Invalid Paramaters, Please Try Again [ "+sIRC._cmd_prefx+"help tele ] For More Information. ", true, "ERROR");
+}
+
+void IRCCmd::Top_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    uint32 limitr = 10;
+    if (atoi(_PARAMS[1].c_str()) > 0 && GetLevel(CD->USER) >= sIRC._op_gm_lev)
+        limitr = atoi(_PARAMS[1].c_str());
+    if (_PARAMS[0] == "accttime")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT account, name, (SUM(totaltime)) AS combinetime FROM characters GROUP BY account ORDER BY combinetime DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Accounts By Played Time:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                uint32 account = fields[0].GetUInt32();
+                std::string PlName = GetAcctNameFromID(account);
+                std::string Time = SecToDay(fields[2].GetString());
+                uint32 rank = i+1;
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, PlName.c_str(), Time.c_str()));
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Accounts Returned." ,true, "ERROR");
+    }
+    if (_PARAMS[0] == "chartime")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT name, totaltime FROM characters ORDER BY totaltime DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Characters By Played Time:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string Name = fields[0].GetString();
+                std::string Time = SecToDay(fields[1].GetString());
+                uint32 rank = i+1;
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, Name.c_str(), Time.c_str()));
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Characters Returned." ,true, "ERROR");
+    }
+    if (_PARAMS[0] == "money")
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT name, money FROM characters ORDER BY money DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Characters By Money:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string Name = fields[0].GetString();
+                unsigned int money = fields[1].GetInt32();
+
+                uint32 rank = i+1;
+
+                unsigned int gold = money / 10000;
+                unsigned int silv = (money % 10000) / 100;
+                unsigned int cop = (money % 10000) % 100;
+                char tempgold [100];
+                sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, Name.c_str(), tempgold));
+                result->NextRow();
+            }
+
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "No Characters Returned." ,true, "ERROR");
+    }
+
+}
+
+void IRCCmd::Chan_Control(_CDATA *CD)
+{
+
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+
+    if (CD->FROM == sIRC._Nick)
+    {
+        Send_IRCA(CD->USER, "\0034[ERROR] : You Cannot Use This Command Through A PM Yet.", true, "ERROR");
+        return;
+    }
+
+    if (_PARAMS[0] == "op")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" +o "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" +o "+CD->USER);
+    }
+
+    if (_PARAMS[0] == "deop")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" -o "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" -o "+CD->USER);
+    }
+
+    if (_PARAMS[0] == "voice")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" +v "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" +v "+CD->USER);
+    }
+    if (_PARAMS[0] == "devoice")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" -v "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" -v "+CD->USER);
+    }
+};
+void IRCCmd::Who_Logged(_CDATA *CD)
+{
+    std::string OPS = "";
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        OPS.append(MakeMsg(" \002[GM:%d IRC: %s - WoW: %s]\002 ", (*i)->GMLevel, (*i)->Name.c_str(), (*i)->UName.c_str()));
+    }
+    Send_IRCA(ChanOrPM(CD), OPS, true, CD->TYPE);
+}
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCFunc.h b/src/server/game/TriniChat/IRCFunc.h
new file mode 100644
index 0000000..d6c4114
--- /dev/null
+++ b/src/server/game/TriniChat/IRCFunc.h
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_FUNC
+#define _IRC_CLIENT_FUNC
+
+std::string GetUser(std::string szU)
+{
+    int pos = szU.find("!");
+    return szU.substr(0, pos);
+}
+// Delink will remove anything considered "non chat" from a string
+std::string Delink(std::string msg)
+{
+    std::size_t pos;
+
+        while((pos = msg.find("|Htrade")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hglyph")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hitem")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Henchant")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+        //msg.replace(find2, 2, "\x2");
+    }
+    while((pos = msg.find("|Hquest")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hspell")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Htalent")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hachievement")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Htrade")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    return msg;
+}
+
+// This function converts the characters used by the client to identify colour to IRC format.
+std::string WoWcol2IRC(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[17][6] = { "\xF", "\xF", "\x3\x31\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x34", "\x3\x31\x34", "\x3\x31\x32", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x31\x32", "\x3\x30\x37"};
+    char WoWCol[17][12] = { "|r", "|cffffffff", "|cff9d9d9d", "|cff1eff00", "|cff0070dd", "|cffa335ee", "|cffff8000", "|cffe6cc80", "|cffffd000", "|cff808080", "|cff71d5ff", "|cffffff00", "|cffff2020", "|cff40c040", "|cff4e96f7", "|cff71d5ff", "|cffff8040"};
+    for (int i=0; i<=15; i++)
+    {
+        while ((pos = msg.find(WoWCol[i])) != std::string::npos)
+        {
+            if (i == 0)
+                msg.replace(pos, 2, IRCCol[i]);
+            else
+                msg.replace(pos, 11, IRCCol[i]);
+        }
+    }
+    return msg;
+}
+
+// This function converts the characters used by IRC to identify colour to a format the client can understand.
+std::string IRCcol2WoW(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[18][4] = { "\x3\x30", "\x3\x31", "\x3\x32", "\x3\x33", "\x3\x34", "\x3\x35", "\x3\x36", "\x3\x37", "\x3\x38", "\x3\x39", "\x3\x31\x30", "\x3\x31\x31", "\x3\x31\x32", "\x3\x31\x33", "\x3\x31\x34", "\x3\x31\x35", "\x3\x30\x37", "\x3\x30\x37"};
+    char IRCCol2[10][4] = { "\x3\x30\x30", "\x3\x30\x31", "\x3\x30\x32", "\x3\x30\x33", "\x3\x30\x34", "\x3\x30\x35", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x38", "\x3\x30\x39"};
+    char WoWcol[18][12] = { "|cffffffff", "|cff000000", "|cff00007f", "|cff009300", "|cffff0000", "|cff7f0000", "|cff9c009c", "|cfffc9300", "|cffffff00", "|cff00fc00", "|cff009393", "|cff00ffff", "|cff0000fc", "|cffff00ff", "|cff7f7f7f", "|cffd2d2d2", "|cff808080", "|cff71d5ff"};
+    for (int i=15; i>=0; i--)
+    {
+        if (i<10)
+        {
+            while ((pos = msg.find(IRCCol2[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 2, WoWcol[i]);
+            }
+
+        }
+        else
+        {
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+        }
+
+        // Remove Bold, Reverse, Underline from IRC
+        char Checker[3][3] = {"\x2","\x16","\x1F"}; // This is the Hex part not Dec. In Decimal its (2,22,31)
+        for (int I=0; I < 3; I++)
+        {
+            while ((pos = msg.find(Checker[I])) != std::string::npos)
+            {
+                msg.replace(pos, 1, "");
+            }
+        }
+        // Finished Removing !
+
+    }
+
+    while ((pos = msg.find("\x3")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+    while ((pos = msg.find("\xF")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+
+    return msg;
+}
+
+// This function compares 2 strings
+int nocase_cmp(const string & s1, const string& s2)
+{
+    string::const_iterator it1=s1.begin();
+    string::const_iterator it2=s2.begin();
+
+    //stop when either string's end has been reached
+    while ((it1!=s1.end()) && (it2!=s2.end()))
+    {
+        if (::toupper(*it1) != ::toupper(*it2))              //letters differ?
+            // return -1 to indicate smaller than, 1 otherwise
+            return (::toupper(*it1)  < ::toupper(*it2)) ? -1 : 1;
+        //proceed to the next character in each string
+        ++it1;
+        ++it2;
+    }
+    size_t size1=s1.size(), size2=s2.size();                // cache lengths
+    //return -1,0 or 1 according to strings' lengths
+    if (size1==size2)
+        return 0;
+    return (size1<size2) ? -1 : 1;
+}
+
+std::string MakeMsgA(const char *sLine, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, sLine);
+    vsnprintf(tmpoutp, 1024, sLine, ap);
+    va_end(ap);
+    std::string outp = tmpoutp;
+    return outp;
+}
+
+std::string MakeMsgP(int CLINE, std::string Msg, Player *plr)
+{
+    std::string sMsg = sIRC.MakeMsg(sIRC.GetChatLine(CLINE), "$Msg", Msg);
+    if (plr->GetTeam() == 67)
+        sMsg = sIRC.MakeMsg(sMsg, "$Name", MakeMsgA("\0034%s\003", plr->GetName().c_str()));
+    else if (plr->GetTeam() == 469)
+        sMsg = sIRC.MakeMsg(sMsg, "$Name", MakeMsgA("\00312%s\003", plr->GetName().c_str()));
+    if (plr->isAFK())
+        sMsg = sIRC.MakeMsg(sMsg, "$Tag", "<AFK>");
+    else if (plr->isDND())
+        sMsg = sIRC.MakeMsg(sMsg, "$Tag", "<DND>");
+    else
+        sMsg = sIRC.MakeMsg(sMsg, "$Tag", "");
+    sMsg = sIRC.MakeMsg(sMsg, "$Level", MakeMsgA("%d", plr->getLevel()));
+    sMsg = Delink(sMsg);
+    sMsg = WoWcol2IRC(sMsg);
+    return sMsg;
+}
+
+// This function checks if a channel exists in out configuration
+// TriniChat supports as many channels as you like
+bool Channel_Valid(std::string Channel)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+    {
+        if (nocase_cmp(sIRC._wow_chan[i], Channel)==0)
+            return true;
+    }
+    return false;
+}
+
+std::string GetWoWChannel(std::string Channel)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+    {
+        if ("#" + sIRC._irc_chan[i] == Channel)
+            return sIRC._wow_chan[i];
+    }
+    return "";
+}
+
+std::string GetIRCChannel(std::string Channel)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+    {
+        if (sIRC._wow_chan[i] == Channel)
+            return sIRC._irc_chan[i];
+    }
+    return "";
+}
+
+std::string* getArray(std::string PARAMS, int nCount, std::string)
+{
+    std::string *array = new std::string[nCount];
+    if (PARAMS.size() > 0)
+    {
+        int pcnt = 0;
+        size_t ps = 0;
+        size_t pc = -1;
+        for (int i = 0;i < nCount;i++)
+        {
+            pc = PARAMS.find(" ", pc + 1);
+            if (i + 1 == nCount && nCount != 1)
+            {
+                if (ps > 0 && pc > 0)
+                    array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+            }
+            else
+                array[i] = PARAMS.substr(ps, pc - ps);
+            ps = pc + 1;
+        }
+    }
+    return array;
+}
+#endif
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCIO.cpp b/src/server/game/TriniChat/IRCIO.cpp
new file mode 100644
index 0000000..ad91dfe
--- /dev/null
+++ b/src/server/game/TriniChat/IRCIO.cpp
@@ -0,0 +1,470 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#include "IRCCmd.h"
+#include "IRCFunc.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "ChannelMgr.h"
+#include "Config.h"
+#include "Channel.h"
+#include "World.h"
+
+IRCCmd Command;
+void IRCClient::Handle_IRC(std::string sData)
+{
+    //sLog->outDebug(sData.c_str());
+    // If first 5 chars are ERROR then something is wrong
+    // either link is being closed, nickserv ghost command, etc...
+    if (sData.substr(0, 5) == "ERROR")
+    {
+        Disconnect();
+        return;
+    }
+    if (sData.substr(0, 4) == "PING")
+    {
+        // if the first 4 characters contain PING
+        // the server is checking if we are still alive
+        // sen back PONG back plus whatever the server send with it
+        SendIRC("PONG " + sData.substr(4, sData.size() - 4));
+    }
+    else
+    {
+        // if the first line contains : its an irc message
+        // such as private messages channel join etc.
+        if (sData.substr(0, 1) == ":")
+        {
+            // find the spaces in the receieved line
+            size_t p1 = sData.find(" ");
+            size_t p2 = sData.find(" ", p1 + 1);
+            // because the irc protocol uses simple spaces
+            // to seperate data we can easy pick them out
+            // since we know the position of the spaces
+            std::string USR = sData.substr(1, p1 - 1);
+            std::string CMD = sData.substr(p1 + 1, p2 - p1 - 1);
+            // trasform the commands to lowercase to make sure they always match
+            std::transform(CMD.begin(), CMD.end(), CMD.begin(), towlower);
+            // Extract the username from the first part
+            std::string szUser = GetUser(USR);
+            // if we receieved the internet connect code
+            // we know for sure that were in and we can
+            // authenticate ourself.
+            if (CMD == sIRC._ICC)
+            {
+                // _Auth is defined in trinitycore.conf (irc.auth)
+                // 0 do not authenticate
+                // 1 use nickserv
+                // 2 use quakenet
+                // aditionally you can provide you own authentication method here
+                switch(sIRC._Auth)
+                {
+                    case 1:
+                        SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC._Pass);
+                        break;
+                    case 2:
+                        SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC._Auth_Nick + " " + sIRC._Pass);
+                        break;
+                    case 3:
+                        SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC._Nick + " " + sIRC._Pass);
+                        break;
+                    case 4:
+                        SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC._Auth_Nick + " " + sIRC._Pass);
+                        break;
+                }
+                // if we join a default channel leave this now.
+                if (sIRC._ldefc==1)
+                    SendIRC("PART #" + sIRC._defchan);
+                // Loop thru the channel array and send a command to join them on IRC.
+                for (int i=1;i < sIRC._chan_count + 1;i++)
+                {
+                        if (sIRC._irc_pass[i].size() > 0)
+                                SendIRC("JOIN #" + sIRC._irc_chan[i] + " " + sIRC._irc_pass[i]);
+                        else
+                        SendIRC("JOIN #" + sIRC._irc_chan[i]);
+                }
+                // See if there's a logchannel available, if so: join it.
+                if (sIRC.logchan.size() > 0)
+                {
+                    if (sIRC.logchanpw.size() > 0)
+                        SendIRC("JOIN #" + sIRC.logchan + " " + sIRC.logchanpw);
+                    else
+                        SendIRC("JOIN #" + sIRC.logchan);
+                }
+            }
+            // someone joined the channel this could be the bot or another user
+            if (CMD == "join")
+            {
+                size_t p = sData.find(":", p1);
+                std::string CHAN = sData.substr(p + 1, sData.size() - p - 2);
+                // if the user is us it means we join the channel
+                if ((szUser == sIRC._Nick))
+                {
+                    // its us that joined the channel
+                    Send_IRC_Channel(CHAN, MakeMsg(MakeMsg(sIRC.JoinMsg, "$Ver", sIRC._Mver.c_str()), "$Trigger", sIRC._cmd_prefx.c_str()), true);
+                }
+                else
+                {
+                    // if the user is not us its someone else that joins
+                    // so we construct a message and send this to the clients.
+                    // TriniChat now uses Send_WoW_Channel to send to the client
+                    // this makes TriniChat handle the packets instead of previously the world.
+                    if ((sIRC.BOTMASK & 2) != 0)
+                        Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(JOIN_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+                }
+            }
+            // someone on irc left or quit the channel
+            if (CMD == "part" || CMD == "quit")
+            {
+                size_t p3 = sData.find(" ", p2 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                // Logout IRC Nick From TriniChat If User Leaves Or Quits IRC.
+                if (Command.IsLoggedIn(szUser))
+                {
+                    _CDATA CDATA;
+                    CDATA.USER      = szUser;
+                    Command.Handle_Logout(&CDATA);
+                }
+                // Construct a message and inform the clients on the same channel.
+                if ((sIRC.BOTMASK & 2) != 0)
+                    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(LEAVE_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+            }
+            // someone changed their nick
+            if (CMD == "nick" && (sIRC.BOTMASK & 128) != 0)
+            {
+                MakeMsg(MakeMsg(GetChatLine(CHANGE_NICK), "$Name", szUser), "$NewName", sData.substr(sData.find(":", p2) + 1));
+                // If the user is logged in and changes their nick
+                // then we want to either log them out or update
+                // their nick in the bot. I chose to update the bots user list.
+                if (Command.IsLoggedIn(szUser))
+                {
+                    std::string NewNick = sData.substr(sData.find(":", p2) + 1);
+                    // On freenode I noticed the server sends an extra character
+                    // at the end of the string, so we need to erase the last
+                    // character of the string. if you have a problem with getting
+                    // the last letter of your nick erased, then remove the - 1.
+                    NewNick.erase(NewNick.length() - 1, 1);
+
+                    for (std::list<_client*>::iterator i=Command._CLIENTS.begin(); i!=Command._CLIENTS.end();i++)
+                    {
+                        if ((*i)->Name == szUser)
+                        {
+                            (*i)->Name     = NewNick;
+                            sIRC.Send_IRC_Channel(NewNick.c_str(), "I Noticed You Changed Your Nick, I Have Updated My Internal Database Accordingly.", true, "NOTICE");
+
+                            // Figure why not output to the logfile, makes tracing problems easier.
+                            sIRC.iLog.WriteLog(" %s : %s Changed Nick To: %s", sIRC.iLog.GetLogDateTimeStr().c_str(), szUser.c_str(), NewNick.c_str());
+                        }
+                    }
+                }
+
+            }
+            // someone was kicked from irc
+            if (CMD == "kick")
+            {
+                // extract the details
+                size_t p3 = sData.find(" ", p2 + 1);
+                size_t p4 = sData.find(" ", p3 + 1);
+                size_t p5 = sData.find(":", p4);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                std::string WHO = sData.substr(p3 + 1, p4 - p3 - 1);
+                std::string BY = sData.substr(p4 + 1, sData.size() - p4 - 1);
+                // if the one kicked was us
+                if (WHO == sIRC._Nick)
+                {
+                    // and autojoin is enabled
+                    // return to the channel
+                    if (sIRC._autojoinkick == 1)
+                    {
+                        SendIRC("JOIN " + CHAN);
+                        Send_IRC_Channel(CHAN, sIRC.kikmsg, true);
+                    }
+                }
+                else
+                {
+                    // if it is not us who was kicked we need to inform the clients someone
+                    // was removed from the channel
+                    // construct a message and send it to the players.
+                    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), "<IRC>[" + WHO + "]: Was Kicked From " + CHAN + " By: " + szUser);
+                }
+            }
+            // a private chat message was receieved.
+            if (CMD == "privmsg" || CMD == "notice")
+            {
+                // extract the values
+                size_t p = sData.find(" ", p2 + 1);
+                std::string FROM = sData.substr(p2 + 1, p - p2 - 1);
+                std::string CHAT = sData.substr(p + 2, sData.size() - p - 3);
+                // if this is our username it means we recieved a PM
+                if (FROM == sIRC._Nick)
+                {
+                    if (CHAT.find("\001VERSION\001") < CHAT.size())
+                    {
+                        Send_IRC_Channel(szUser, MakeMsg("\001VERSION TriniChat %s 2008-2009 |Death|, Cybrax, Machiavelli\001", "%s" , sIRC._Mver.c_str()), true, "PRIVMSG");
+                    }
+                    // a pm is required for certain commands
+                    // such as login. to validate the command
+                    // we send it to the command class wich handles
+                    // evrything else.
+                    Command.IsValid(szUser, FROM, CHAT, CMD);
+                }
+                else
+                {
+                    // if our name is not in it, it means we receieved chat on one of the channels
+                    // magchat is in. the first thing we do is check if it is a command or not
+                    if (!Command.IsValid(szUser, FROM, CHAT, CMD))
+                    {
+                        Send_WoW_Channel(GetWoWChannel(FROM).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(IRC_WOW), "$Name", szUser), "$Msg", CHAT)));
+                    }
+                    // if we indeed receieved a command we do not want to display this to the players
+                    // so only incanse the isvalid command returns false it will be sent to all player.
+                    // the isvalid function will automaitcly process the command on true.
+                }
+            }
+            if (CMD == "mode")
+            {
+                // extract the mode details
+                size_t p3 = sData.find(" ", p2 + 1);
+                size_t p4 = sData.find(" ", p3 + 1);
+                size_t p5 = sData.find(" ", p4 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                std::string MODE = sData.substr(p3 + 1, p4 - p3 - 1);
+                std::string NICK = sData.substr(p4 + 1, p5 - p4 - 1);
+                bool _AmiOp;
+                _AmiOp = false;
+                //A mode was changed on us
+                if (NICK.c_str() == sIRC._Nick)
+                    _AmiOp = true;
+
+            }
+        }
+    }
+}
+
+// This function is called in Channel.h
+// based on nAction it will inform the people on
+// irc when someone leaves one of the game channels.
+// nAction is based on the struct CACTION
+void IRCClient::Handle_WoW_Channel(std::string Channel, Player *plr, int nAction)
+{
+    // make sure that we are connected
+    if (sIRC.Connected && (sIRC.BOTMASK & 1)!= 0)
+    {
+        if (Channel_Valid(Channel))
+        {
+            std::string GMRank = "";
+            std::string pname = plr->GetName();
+            bool DoGMAnnounce = false;
+            if (plr->GetSession()->GetSecurity() > 0 && (sIRC.BOTMASK & 8)!= 0)
+                DoGMAnnounce = true;
+            if (plr->IsGameMaster() && (sIRC.BOTMASK & 16)!= 0)
+                DoGMAnnounce = true;
+            if (DoGMAnnounce)
+            {
+                switch(plr->GetSession()->GetSecurity())    //switch case to determine what rank the "gm" is
+                {
+                    case 0: GMRank = "";break;
+                    case 1: GMRank = "\0037"+sIRC.ojGM1;break;
+                    case 2: GMRank = "\0037"+sIRC.ojGM2;break;
+                    case 3: GMRank = "\0037"+sIRC.ojGM3;break;
+                    case 4: GMRank = "\0037"+sIRC.ojGM4;break;
+                    case 5: GMRank = "\0037"+sIRC.ojGM5;break;
+                    case 6: GMRank = "\0037"+sIRC.ojGM6;break;
+                    case 7: GMRank = "\0037"+sIRC.ojGM7;break;
+                    case 8: GMRank = "\0037"+sIRC.ojGM8;break;
+                }
+            }
+            std::string ChatTag = "";
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("\0034");break;      //horde
+                case 469:ChatTag.append("\00312");break;    //alliance
+            }
+            std::string query = "INSERT INTO `irc_inchan` VALUES (%d,'"+pname+"','"+Channel+"')";
+            std::string lchan = "DELETE FROM `irc_inchan` WHERE `guid` = %d AND `channel` = '"+Channel+"'";
+            switch(nAction)
+            {
+                case CHANNEL_JOIN:
+                    Send_IRC_Channel(GetIRCChannel(Channel), MakeMsg(MakeMsg(MakeMsg(GetChatLine(JOIN_WOW), "$Name", ChatTag + plr->GetName()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+                    WorldDatabase.PExecute(query.c_str(), plr->GetGUID());
+                    break;
+                case CHANNEL_LEAVE:
+                    Send_IRC_Channel(GetIRCChannel(Channel), MakeMsg(MakeMsg(MakeMsg(GetChatLine(LEAVE_WOW), "$Name", ChatTag + plr->GetName()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+                    break;
+            }
+        }
+    }
+}
+
+// This function sends chat to a irc channel or user
+// to prevent the # beeing appended to send a msg to a user
+// set the NoPrefix to true
+void IRCClient::Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix, std::string nType)
+{
+    std::string mType = "PRIVMSG";
+    if (Command.MakeUpper(nType.c_str()) == "NOTICE")
+        mType = "NOTICE";
+    if (Command.MakeUpper(nType.c_str()) == "ERROR" && (sIRC.BOTMASK & 32)!= 0)
+        mType = "NOTICE";
+    if (sIRC.Connected)
+    {
+        if (NoPrefix)
+            SendIRC(mType + " " + sChannel + " :" + sMsg);
+        else
+            SendIRC(mType + " #" + sChannel + " :" + sMsg);
+    }
+}
+
+// This function sends a message to all irc channels
+// that TriniChat has in its configuration
+void IRCClient::Send_IRC_Channels(std::string sMsg)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+        Send_IRC_Channel(sIRC._irc_chan[i], sMsg);
+}
+
+// This function is called in ChatHandler.cpp, any channel chat from wow will come
+// to this function, validates the channel and constructs a message that is send to IRC
+void IRCClient::Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg)
+{
+    // Check if the channel exist in our configuration
+    if (Channel_Valid(Channel) && Msg.substr(0, 1) != ".")
+        Send_IRC_Channel(GetIRCChannel(Channel), MakeMsgP(WOW_IRC, Msg, plr));
+}
+
+void IRCClient::Send_WoW_Player(std::string sPlayer, std::string sMsg)
+{
+    normalizePlayerName(sPlayer);
+    if (Player* plr = sObjectAccessor->FindPlayerByName(sPlayer.c_str()))
+        Send_WoW_Player(plr, sMsg);
+}
+
+void IRCClient::Send_WoW_Player(Player *plr, string sMsg)
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    data << (uint8)CHAT_MSG_SYSTEM;
+    data << (uint32)LANG_UNIVERSAL;
+    data << (uint64)plr->GetGUID();
+    data << (uint32)0;
+    data << (uint64)plr->GetGUID();
+    data << (uint32)(sMsg.length()+1);
+    data << sMsg;
+    data << (uint8)0;
+    plr->GetSession()->SendPacket(&data);
+}
+
+// This function will construct and send a packet to all players
+// on the given channel ingame. (previuosly found in world.cpp)
+// it loops thru all sessions and checks if they are on the channel
+// if so construct a packet and send it.
+void IRCClient::Send_WoW_Channel(const char *channel, std::string chat)
+{
+    if (!(strlen(channel) > 0))
+        return;
+
+    #ifdef USE_UTF8
+        std::string chat2 = chat;
+        if (ConvertUTF8(chat2.c_str(), chat2))
+            chat = chat2;
+    #endif
+
+    HashMapHolder<Player>::MapType const& m = sObjectAccessor->GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            if (ChannelMgr* cMgr = ChannelMgr::forTeam(itr->second->GetSession()->GetPlayer()->GetTeam()))
+            {
+                if (Channel *chn = cMgr->GetChannel(channel, itr->second->GetSession()->GetPlayer()))
+                {
+                    WorldPacket data;
+                    data.Initialize(SMSG_MESSAGECHAT);
+                    data << (uint8)CHAT_MSG_CHANNEL;
+                    data << (uint32)LANG_UNIVERSAL;
+                    data << (uint64)0;
+                    data << (uint32)0;
+                    data << channel;
+                    data << (uint64)0;
+                    data << (uint32) (strlen(chat.c_str()) + 1);
+                    data << IRCcol2WoW(chat.c_str());
+                    data << (uint8)0;
+                    itr->second->GetSession()->SendPacket(&data);
+                }
+            }
+        }
+    }
+}
+
+void IRCClient::Send_WoW_System(std::string Message)
+{
+    HashMapHolder<Player>::MapType const& m = sObjectAccessor->GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            WorldPacket data;
+            data.Initialize(CHAT_MSG_SYSTEM);
+            data << (uint8)CHAT_MSG_SYSTEM;
+            data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)0;
+            data << (uint32)0;
+            data << (uint64)0;
+            data << (uint32) (strlen(Message.c_str()) + 1);
+            data << Message.c_str();
+            data << (uint8)0;
+            itr->second->GetSession()->SendPacket(&data);
+        }
+    }
+}
+void IRCClient::ResetIRC()
+{
+    SendData("QUIT");
+    Disconnect();
+}
+
+#define CHAT_INVITE_NOTICE 0x18
+
+// this function should be called on player login Player::AddToWorld
+void IRCClient::AutoJoinChannel(Player *plr)
+{
+    //this will work if at least 1 player is logged in regrdless if he is on the channel or not
+    // the first person that login empty server is the one with bad luck and wont be invited,
+    // if at least 1 player is online the player will be inited to the chanel
+
+    std::string m_name = sIRC.ajchan;
+    WorldPacket data;
+    data.Initialize(SMSG_CHANNEL_NOTIFY, 1+m_name.size()+1);
+    data << uint8(CHAT_INVITE_NOTICE);
+    data << m_name.c_str();
+
+    HashMapHolder<Player>::MapType const& m = sObjectAccessor->GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            data << uint64(itr->second->GetGUID());
+            break;
+        }
+    }
+    plr->GetSession()->SendPacket(&data);
+}
diff --git a/src/server/game/TriniChat/IRCLog.cpp b/src/server/game/TriniChat/IRCLog.cpp
new file mode 100644
index 0000000..50fc6f4
--- /dev/null
+++ b/src/server/game/TriniChat/IRCLog.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCLog.h"
+#include "Config.h"
+#include "IRCClient.h"
+#include <stdarg.h>
+#include "World.h"
+
+IRCLog::IRCLog()
+{
+    std::string logsDir = sConfigMgr->GetStringDefault("LogsDir","");
+    std::string ircLogName = logsDir + "/IRC_";
+    std::string ircLogTimestamp = GetLogDateStr();
+        ircLogName += ircLogTimestamp +".log";
+    ircLogfile.open (ircLogName.c_str(), std::ios::app);
+}
+
+IRCLog::~IRCLog()
+{
+    ircLogfile.close();
+}
+// Was added because using the time for logs is very annoying... one log per day.. much cleaner looking..
+std::string IRCLog::GetLogDateStr() const
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[20];
+    snprintf(buf,20,"%04d-%02d-%02d",aTm->tm_year+1900,aTm->tm_mon+1,aTm->tm_mday);
+    return std::string(buf);
+}
+
+std::string IRCLog::GetLogDateTimeStr() const
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[30];
+    snprintf(buf,30,"[ %04d-%02d-%02d ] [ %02d:%02d:%02d ]",aTm->tm_year+1900,aTm->tm_mon+1,aTm->tm_mday,aTm->tm_hour,aTm->tm_min,aTm->tm_sec);
+    return std::string(buf);
+}
+
+void IRCLog::WriteLog(const char *what, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, what);
+    vsnprintf(tmpoutp, 1024, what, ap);
+    va_end(ap);
+    ircLogfile << tmpoutp;
+    ircLogfile << "\n";
+    ircLogfile.flush();
+}
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCLog.h b/src/server/game/TriniChat/IRCLog.h
new file mode 100644
index 0000000..426ff4e
--- /dev/null
+++ b/src/server/game/TriniChat/IRCLog.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_LOG_H
+#define _IRC_LOG_H
+
+#include "Common.h"
+#include <fstream>
+
+class IRCLog
+{
+    public:
+        IRCLog();
+        ~IRCLog();
+
+    public:
+        void WriteLog(const char *what, ...);
+        std::string GetLogDateStr() const;
+        std::string GetLogDateTimeStr() const;
+    private:
+        std::ofstream ircLogfile;
+};
+
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/TriniChat/IRCSock.cpp b/src/server/game/TriniChat/IRCSock.cpp
new file mode 100644
index 0000000..a63f5c2
--- /dev/null
+++ b/src/server/game/TriniChat/IRCSock.cpp
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#define MAXDATASIZE 512
+#include <fcntl.h>
+
+#include <stdio.h>
+#include <sys/types.h>
+
+
+#define _UNICODE
+
+#ifdef _MBCS
+#undef _MBCS
+#endif
+
+bool IRCClient::InitSock()
+{
+    #ifdef _WIN32
+    WSADATA wsaData;                                        //WSAData
+    if (WSAStartup(MAKEWORD(2,0),&wsaData) != 0)
+    {
+        TC_LOG_ERROR("misc" "IRC Error: Winsock Initialization Error"," ");
+        return false;
+    }
+    #endif
+    if ((sIRC.SOCKET = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
+    {
+        TC_LOG_ERROR("misc" "IRC Error: Socket Error"," ");
+        return false;
+    }
+    int on = 1;
+    if (setsockopt (sIRC.SOCKET, SOL_SOCKET, SO_REUSEADDR, (const char*) &on, sizeof (on)) == -1)
+    {
+        TC_LOG_ERROR("misc" "IRC Error: Invalid Socket"," ");
+        return false;
+    }
+    #ifdef _WIN32
+    u_long iMode = 0;
+    ioctlsocket(sIRC.SOCKET, FIONBIO, &iMode);
+    #else
+    fcntl(sIRC.SOCKET, F_SETFL, O_NONBLOCK);                // set to non-blocking
+    fcntl(sIRC.SOCKET, F_SETFL, O_ASYNC);                   // set to asynchronous I/O
+    #endif
+    return true;
+}
+
+bool IRCClient::Connect(const char *cHost, int nPort)
+{
+    sIRC.Connected = false;
+    struct hostent *he;
+    if ((he=gethostbyname(cHost)) == NULL)
+    {
+        TC_LOG_ERROR("misc" "IRCLIENT: Could not resolve host: %s", cHost);
+        return false;
+    }
+    struct sockaddr_in their_addr;
+    their_addr.sin_family = AF_INET;
+    their_addr.sin_port = htons(nPort);
+    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+    memset(&(their_addr.sin_zero), '\0', 8);
+    if (::connect(sIRC.SOCKET, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == -1)
+    {
+        TC_LOG_ERROR("misc" "IRCLIENT: Cannot connect to %s", cHost);
+        return false;
+    }
+    //FD_ZERO(&sIRC.sfdset);
+    //FD_SET(sIRC.SOCKET,&sIRC.sfdset);
+    sIRC.Connected = true;
+    return true;
+}
+
+bool IRCClient::Login(std::string sNick, std::string sUser, std::string sPass)
+{
+    char hostname[128];
+    gethostname(hostname, sizeof(hostname));
+    if (SendIRC("HELLO"))
+        if (SendIRC("PASS " + sPass))
+            if (SendIRC("NICK " + sNick))
+                if (SendIRC("USER " + sUser + " " + (std::string)hostname + " TriniChat :TriniChat "+sIRC._Mver.c_str()))
+                    return true;
+    return false;
+}
+
+bool IRCClient::SendData(const char *data)
+{
+    if (sIRC.Connected)
+    {
+        if (send(sIRC.SOCKET, data, strlen(data), 0) == -1)
+        {
+            TC_LOG_ERROR("misc" "IRC Error: Socket Receieve ** \n"," ");
+            //Disconnect();
+            return false;
+        }
+    }
+    return true;
+}
+
+bool IRCClient::SendIRC(std::string data)
+{
+    std::string RealData = data + "\n";
+    return SendData(RealData.c_str());
+}
+
+void IRCClient::Disconnect()
+{
+    if (sIRC.SOCKET)
+    {
+        #ifdef _WIN32
+        closesocket(sIRC.SOCKET);
+        //WSACleanup();
+        #else
+        close(sIRC.SOCKET);
+        #endif
+    }
+}
+
+void IRCClient::SockRecv()
+{
+//    wchar_t bufferdata;
+
+    char szBuffer[MAXDATASIZE];
+
+    memset(szBuffer, 0, MAXDATASIZE);
+
+    int nBytesRecv = ::recv(sIRC.SOCKET, szBuffer, MAXDATASIZE - 1, 0);
+    if (nBytesRecv == -1)
+    {
+        TC_LOG_ERROR("misc" "Connection lost."," ");
+        sIRC.Connected = false;
+    }
+    else
+    {
+        if (-1 == nBytesRecv)
+        {
+            TC_LOG_ERROR("misc" "Error occurred while receiving from socket."," ");
+        }
+        else
+        {
+            std::string reply;
+            std::istringstream iss(szBuffer);
+            while (getline(iss, reply))
+            {
+                Handle_IRC(reply);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/server/game/TriniChat/MCS_OnlinePlayers.cpp b/src/server/game/TriniChat/MCS_OnlinePlayers.cpp
new file mode 100644
index 0000000..16297ad
--- /dev/null
+++ b/src/server/game/TriniChat/MCS_OnlinePlayers.cpp
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "MCS_OnlinePlayers.h"
+
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "Config.h"
+#include "WorldSession.h"
+
+mcs_OnlinePlayers::mcs_OnlinePlayers() { CD = NULL; }
+
+mcs_OnlinePlayers::mcs_OnlinePlayers(_CDATA *_CD)
+{
+    //create a new instance of data struct and copy its data
+    CD = new _CDATA();
+    CD->CMD = _CD->CMD;
+    CD->FROM = _CD->FROM;
+    CD->PARAMS = _CD->PARAMS;
+    CD->PCOUNT = _CD->PCOUNT;
+    CD->USER = _CD->USER;
+    CD->TYPE = _CD->TYPE;
+}
+
+mcs_OnlinePlayers::~mcs_OnlinePlayers()
+{
+    if (CD)
+        delete CD;
+}
+
+void mcs_OnlinePlayers::run()
+{
+    int OnlineCount = 0;
+    std::string IRCOut = "";
+    HashMapHolder<Player>::MapType const& m = sObjectAccessor->GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            OnlineCount++;
+            Player *plr = itr->second->GetSession()->GetPlayer();
+            std::string ChatTag = " ";
+            switch(plr->GetSession()->GetSecurity())
+            {
+                  case 0: ChatTag.append("");break;
+                  case 1: ChatTag.append("\0037"+sIRC.ojGM1);break;
+                  case 2: ChatTag.append("\0037"+sIRC.ojGM2);break;
+                  case 3: ChatTag.append("\0037"+sIRC.ojGM3);break;
+                  case 4: ChatTag.append("\0037"+sIRC.ojGM4);break;
+                  case 5: ChatTag.append("\0037"+sIRC.ojGM5);break;
+           case 6: ChatTag.append("\0037"+sIRC.ojGM6);break;
+           case 7: ChatTag.append("\0037"+sIRC.ojGM7);break;
+           case 8: ChatTag.append("\0037"+sIRC.ojGM8);break;
+            }
+            if (plr->isAFK())
+                ChatTag.append("\002\0037<AFK>\003\002");
+            else if (plr->isDND())
+                ChatTag.append("\002\0037<DND>\003\002");
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("\0034");break;      //horde
+                case 469:ChatTag.append("\00312");break;    //alliance
+            }
+
+            IRCOut.append(IRCCmd::MakeMsg("%s\002%s\003\017\002(%d)\002\017", ChatTag.c_str(), plr->GetName().c_str(), plr->getLevel()));
+
+            // after XX players have been added to the string
+            // output to irc and reset for the next XX
+            if (OnlineCount % sIRC.onlrslt == 0)
+            {
+                sIRC.Send_IRC_Channel(IRCCmd::ChanOrPM(CD), IRCCmd::MakeMsg("\002 %s", IRCOut.c_str()), true, CD->TYPE.c_str());
+                IRCOut = "";
+                ACE_Based::Thread::Sleep(1000);
+            }
+        }
+    }
+    // Remainder in IRCOUT && Total plyersonline
+    sIRC.Send_IRC_Channel(IRCCmd::ChanOrPM(CD), IRCCmd::MakeMsg("\002Players Online(%d):\017 %s", OnlineCount, IRCOut.c_str()), true, CD->TYPE);
+
+    sIRC.Script_Lock[MCS_Players_Online] = false;
+}
\ No newline at end of file
diff --git a/src/server/game/TriniChat/MCS_OnlinePlayers.h b/src/server/game/TriniChat/MCS_OnlinePlayers.h
new file mode 100644
index 0000000..9e4276b
--- /dev/null
+++ b/src/server/game/TriniChat/MCS_OnlinePlayers.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_ONLINE
+#define _IRC_CLIENT_ONLINE
+
+#include "IRCClient.h"
+#include "IRCCmd.h"
+
+class mcs_OnlinePlayers : public ACE_Based::Runnable
+{
+    public:
+        mcs_OnlinePlayers();
+        mcs_OnlinePlayers(_CDATA *_CD);
+        ~mcs_OnlinePlayers();
+        void run();
+    public:
+        _CDATA *CD;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/TriniChat/framework/CMakeLists.txt b/src/server/game/TriniChat/framework/CMakeLists.txt
new file mode 100644
index 0000000..bcf3603
--- /dev/null
+++ b/src/server/game/TriniChat/framework/CMakeLists.txt
@@ -0,0 +1,11 @@
+SET(trinityframework_STAT_SRCS
+   Policies/ObjectLifeTime.cpp
+   Utilities/EventProcessor.cpp
+)
+
+include_directories(
+  ${ACE_INCLUDE_DIR}
+  ${CMAKE_SOURCE_DIR}/src/framework
+)
+
+add_library(trinityframework STATIC ${trinityframework_STAT_SRCS})
diff --git a/src/server/game/TriniChat/framework/Dynamic/FactoryHolder.h b/src/server/game/TriniChat/framework/Dynamic/FactoryHolder.h
new file mode 100644
index 0000000..37b0b42
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Dynamic/FactoryHolder.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_FACTORY_HOLDER
+#define TRINITY_FACTORY_HOLDER
+
+#include "Platform/Define.h"
+#include "Utilities/TypeList.h"
+#include "ObjectRegistry.h"
+#include "Policies/SingletonImp.h"
+
+/** FactoryHolder holds a factory object of a specific type
+ */
+template<class T, class Key = std::string>
+class FactoryHolder
+{
+    public:
+        typedef ObjectRegistry<FactoryHolder<T, Key >, Key > FactoryHolderRegistry;
+        typedef Trinity::Singleton<FactoryHolderRegistry > FactoryHolderRepository;
+
+        FactoryHolder(Key k) : i_key(k) {}
+        virtual ~FactoryHolder() {}
+        inline Key key() const { return i_key; }
+
+        void RegisterSelf(void) { FactoryHolderRepository::Instance().InsertItem(this, i_key); }
+        void DeregisterSelf(void) { FactoryHolderRepository::Instance().RemoveItem(this, false); }
+
+        /// Abstract Factory create method
+        virtual T* Create(void *data = NULL) const = 0;
+    private:
+        Key i_key;
+};
+
+/** Permissible is a classic way of letting the object decide
+ * whether how good they handle things.  This is not retricted
+ * to factory selectors.
+ */
+template<class T>
+class Permissible
+{
+    public:
+        virtual ~Permissible() {}
+        virtual int Permit(const T *) const = 0;
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Dynamic/ObjectRegistry.h b/src/server/game/TriniChat/framework/Dynamic/ObjectRegistry.h
new file mode 100644
index 0000000..61a54db
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Dynamic/ObjectRegistry.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_OBJECTREGISTRY_H
+#define TRINITY_OBJECTREGISTRY_H
+
+#include "Platform/Define.h"
+#include "Utilities/UnorderedMap.h"
+#include "Policies/Singleton.h"
+
+#include <string>
+#include <vector>
+#include <map>
+
+/** ObjectRegistry holds all registry item of the same type
+ */
+template<class T, class Key = std::string>
+class ObjectRegistry
+{
+    public:
+        typedef std::map<Key, T *> RegistryMapType;
+
+        /// Returns a registry item
+        const T* GetRegistryItem(Key key) const
+        {
+            typename RegistryMapType::const_iterator iter = i_registeredObjects.find(key);
+            return( iter == i_registeredObjects.end() ? NULL : iter->second );
+        }
+
+        /// Inserts a registry item
+        bool InsertItem(T *obj, Key key, bool override = false)
+        {
+            typename RegistryMapType::iterator iter = i_registeredObjects.find(key);
+            if( iter != i_registeredObjects.end() )
+            {
+                if( !override )
+                    return false;
+                delete iter->second;
+                i_registeredObjects.erase(iter);
+            }
+
+            i_registeredObjects[key] = obj;
+            return true;
+        }
+
+        /// Removes a registry item
+        void RemoveItem(Key key, bool delete_object = true)
+        {
+            typename RegistryMapType::iterator iter = i_registeredObjects.find(key);
+            if( iter != i_registeredObjects.end() )
+            {
+                if( delete_object )
+                    delete iter->second;
+                i_registeredObjects.erase(iter);
+            }
+        }
+
+        /// Returns true if registry contains an item
+        bool HasItem(Key key) const
+        {
+            return (i_registeredObjects.find(key) != i_registeredObjects.end());
+        }
+
+        /// Inefficiently return a vector of registered items
+        unsigned int GetRegisteredItems(std::vector<Key> &l) const
+        {
+            unsigned int sz = l.size();
+            l.resize(sz + i_registeredObjects.size());
+            for (typename RegistryMapType::const_iterator iter = i_registeredObjects.begin(); iter != i_registeredObjects.end(); ++iter)
+                l[sz++] = iter->first;
+            return i_registeredObjects.size();
+        }
+
+        /// Return the map of registered items
+        RegistryMapType const &GetRegisteredItems() const
+        {
+            return i_registeredObjects;
+        }
+
+    private:
+        RegistryMapType i_registeredObjects;
+        friend class Trinity::OperatorNew<ObjectRegistry<T, Key> >;
+
+        // protected for friend use since it should be a singleton
+        ObjectRegistry() {}
+        ~ObjectRegistry()
+        {
+            for (typename RegistryMapType::iterator iter=i_registeredObjects.begin(); iter != i_registeredObjects.end(); ++iter)
+                delete iter->second;
+            i_registeredObjects.clear();
+        }
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/GameSystem/Grid.h b/src/server/game/TriniChat/framework/GameSystem/Grid.h
new file mode 100644
index 0000000..c54d96c
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/Grid.h
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_GRID_H
+#define TRINITY_GRID_H
+
+/*
+  @class Grid
+  Grid is a logical segment of the game world represented inside TrinIty.
+  Grid is bind at compile time to a particular type of object which
+  we call it the object of interested.  There are many types of loader,
+  specially, dynamic loader, static loader, or on-demand loader.  There's
+  a subtle difference between dynamic loader and on-demand loader but
+  this is implementation specific to the loader class.  From the
+  Grid's perspective, the loader meets its API requirement is suffice.
+*/
+
+#include "Platform/Define.h"
+#include "Policies/ThreadingModel.h"
+#include "TypeContainer.h"
+#include "TypeContainerVisitor.h"
+
+// forward declaration
+template<class A, class T, class O> class GridLoader;
+
+template
+<
+class ACTIVE_OBJECT,
+class WORLD_OBJECT_TYPES,
+class GRID_OBJECT_TYPES,
+class ThreadModel = Trinity::SingleThreaded<ACTIVE_OBJECT>
+>
+class Grid
+{
+    // allows the GridLoader to access its internals
+    template<class A, class T, class O> friend class GridLoader;
+    public:
+
+        /** destructor to clean up its resources. This includes unloading the
+        grid if it has not been unload.
+        */
+        ~Grid() {}
+
+        /** an object of interested enters the grid
+         */
+        template<class SPECIFIC_OBJECT> void AddWorldObject(SPECIFIC_OBJECT *obj)
+        {
+            if(!i_objects.template insert<SPECIFIC_OBJECT>(obj))
+                assert(false);
+        }
+
+        /** an object of interested exits the grid
+         */
+        template<class SPECIFIC_OBJECT> void RemoveWorldObject(SPECIFIC_OBJECT *obj)
+        {
+            if(!i_objects.template remove<SPECIFIC_OBJECT>(obj))
+                assert(false);
+        }
+
+        /** Refreshes/update the grid. This required for remote grids.
+         */
+        void RefreshGrid(void) { /* TBI */}
+
+        /** Locks a grid.  Any object enters must wait until the grid is unlock.
+         */
+        void LockGrid(void) { /* TBI */ }
+
+        /** Unlocks the grid.
+         */
+        void UnlockGrid(void) { /* TBI */ }
+
+        /** Grid visitor for grid objects
+         */
+        template<class T> void Visit(TypeContainerVisitor<T, TypeMapContainer<GRID_OBJECT_TYPES> > &visitor)
+        {
+            visitor.Visit(i_container);
+        }
+
+        /** Grid visitor for world objects
+         */
+        template<class T> void Visit(TypeContainerVisitor<T, TypeMapContainer<WORLD_OBJECT_TYPES> > &visitor)
+        {
+            visitor.Visit(i_objects);
+        }
+
+        /** Returns the number of object within the grid.
+         */
+        unsigned int ActiveObjectsInGrid(void) const { return /*m_activeGridObjects.size()+*/i_objects.template Count<ACTIVE_OBJECT>(); }
+
+        /** Inserts a container type object into the grid.
+         */
+        template<class SPECIFIC_OBJECT> void AddGridObject(SPECIFIC_OBJECT *obj)
+        {
+            if(!i_container.template insert<SPECIFIC_OBJECT>(obj))
+                assert(false);
+        }
+
+        /** Removes a containter type object from the grid
+         */
+        template<class SPECIFIC_OBJECT> void RemoveGridObject(SPECIFIC_OBJECT *obj)
+        {
+            if(!i_container.template remove<SPECIFIC_OBJECT>(obj))
+                assert(false);
+        }
+
+        /*bool NoWorldObjectInGrid() const
+        {
+            return i_objects.GetElements().isEmpty();
+        }
+
+        bool NoGridObjectInGrid() const
+        {
+            return i_container.GetElements().isEmpty();
+        }*/
+    private:
+
+        typedef typename ThreadModel::Lock Guard;
+        typedef typename ThreadModel::VolatileType VolatileType;
+
+        TypeMapContainer<GRID_OBJECT_TYPES> i_container;
+        TypeMapContainer<WORLD_OBJECT_TYPES> i_objects;
+        //typedef std::set<void*> ActiveGridObjects;
+        //ActiveGridObjects m_activeGridObjects;
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/GameSystem/GridLoader.h b/src/server/game/TriniChat/framework/GameSystem/GridLoader.h
new file mode 100644
index 0000000..f1a1a52
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/GridLoader.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_GRIDLOADER_H
+#define TRINITY_GRIDLOADER_H
+
+/**
+  @class GridLoader
+  The GridLoader is working in conjuction with the Grid and responsible
+  for loading and unloading object-types (one or more) when objects
+  enters a grid.  Unloading is scheduled and might be canceled if
+  an interested object re-enters.  GridLoader does not do the actuall
+  loading and unloading but implements as a template pattern that
+  delicate its loading and unloading for the actualy loader and unloader.
+  GridLoader manages the grid (both local and remote).
+ */
+
+#include "Platform/Define.h"
+#include "Grid.h"
+#include "TypeContainerVisitor.h"
+
+template
+<
+class ACTIVE_OBJECT,
+class WORLD_OBJECT_TYPES,
+class GRID_OBJECT_TYPES
+>
+class GridLoader
+{
+    public:
+
+        /** Loads the grid
+         */
+        template<class LOADER>
+            void Load(Grid<ACTIVE_OBJECT,WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES> &grid, LOADER &loader)
+        {
+            grid.LockGrid();
+            loader.Load(grid);
+            grid.UnlockGrid();
+        }
+
+        /** Stop the grid
+         */
+        template<class STOPER>
+            void Stop(Grid<ACTIVE_OBJECT,WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES> &grid, STOPER &stoper)
+        {
+            grid.LockGrid();
+            stoper.Stop(grid);
+            grid.UnlockGrid();
+        }
+        /** Unloads the grid
+         */
+        template<class UNLOADER>
+            void Unload(Grid<ACTIVE_OBJECT,WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES> &grid, UNLOADER &unloader)
+        {
+            grid.LockGrid();
+            unloader.Unload(grid);
+            grid.UnlockGrid();
+        }
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/GameSystem/GridRefManager.h b/src/server/game/TriniChat/framework/GameSystem/GridRefManager.h
new file mode 100644
index 0000000..ea2d672
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/GridRefManager.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _GRIDREFMANAGER
+#define _GRIDREFMANAGER
+
+#include "Utilities/LinkedReference/RefManager.h"
+
+template<class OBJECT>
+class GridReference;
+
+template<class OBJECT>
+class GridRefManager : public RefManager<GridRefManager<OBJECT>, OBJECT>
+{
+    public:
+        typedef LinkedListHead::Iterator< GridReference<OBJECT> > iterator;
+
+        GridReference<OBJECT>* getFirst() { return (GridReference<OBJECT>*)RefManager<GridRefManager<OBJECT>, OBJECT>::getFirst(); }
+        GridReference<OBJECT>* getLast() { return (GridReference<OBJECT>*)RefManager<GridRefManager<OBJECT>, OBJECT>::getLast(); }
+
+        iterator begin() { return iterator(getFirst()); }
+        iterator end() { return iterator(NULL); }
+        iterator rbegin() { return iterator(getLast()); }
+        iterator rend() { return iterator(NULL); }
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/GameSystem/GridReference.h b/src/server/game/TriniChat/framework/GameSystem/GridReference.h
new file mode 100644
index 0000000..0da9635
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/GridReference.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _GRIDREFERENCE_H
+#define _GRIDREFERENCE_H
+
+#include "Utilities/LinkedReference/Reference.h"
+
+template<class OBJECT>
+class GridRefManager;
+
+template<class OBJECT>
+class GridReference : public Reference<GridRefManager<OBJECT>, OBJECT>
+{
+    protected:
+        void targetObjectBuildLink()
+        {
+            // called from link()
+            this->getTarget()->insertFirst(this);
+            this->getTarget()->incSize();
+        }
+        void targetObjectDestroyLink()
+        {
+            // called from unlink()
+            if(this->isValid()) this->getTarget()->decSize();
+        }
+        void sourceObjectDestroyLink()
+        {
+            // called from invalidate()
+            this->getTarget()->decSize();
+        }
+    public:
+        GridReference() : Reference<GridRefManager<OBJECT>, OBJECT>() {}
+        ~GridReference() { this->unlink(); }
+        GridReference *next() { return (GridReference*)Reference<GridRefManager<OBJECT>, OBJECT>::next(); }
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/GameSystem/NGrid.h b/src/server/game/TriniChat/framework/GameSystem/NGrid.h
new file mode 100644
index 0000000..819a6f4
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/NGrid.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_NGRID_H
+#define TRINITY_NGRID_H
+
+/** NGrid is nothing more than a wrapper of the Grid with an NxN cells
+ */
+
+#include "GameSystem/Grid.h"
+#include "GameSystem/GridReference.h"
+#include "Timer.h"
+#include "Util.h"
+
+#define DEFAULT_VISIBILITY_NOTIFY_PERIOD      1000
+
+class GridInfo
+{
+public:
+    GridInfo()
+        : i_timer(0), i_unloadActiveLockCount(0), i_unloadExplicitLock(false), i_unloadReferenceLock(false),
+          vis_Update(0, irand(0,DEFAULT_VISIBILITY_NOTIFY_PERIOD)) {}
+    GridInfo(time_t expiry, bool unload = true )
+        : i_timer(expiry), i_unloadActiveLockCount(0), i_unloadExplicitLock(!unload), i_unloadReferenceLock(false),
+          vis_Update(0, irand(0,DEFAULT_VISIBILITY_NOTIFY_PERIOD)) {}
+    const TimeTracker& getTimeTracker() const { return i_timer; }
+    bool getUnloadLock() const { return i_unloadActiveLockCount || i_unloadExplicitLock || i_unloadReferenceLock; }
+    void setUnloadExplicitLock( bool on ) { i_unloadExplicitLock = on; }
+    void setUnloadReferenceLock( bool on ) { i_unloadReferenceLock = on; }
+    void incUnloadActiveLock() { ++i_unloadActiveLockCount; }
+    void decUnloadActiveLock() { if(i_unloadActiveLockCount) --i_unloadActiveLockCount; }
+
+    void setTimer(const TimeTracker& pTimer) { i_timer = pTimer; }
+    void ResetTimeTracker(time_t interval) { i_timer.Reset(interval); }
+    void UpdateTimeTracker(time_t diff) { i_timer.Update(diff); }
+    PeriodicTimer& getRelocationTimer() { return vis_Update; }
+private:
+    TimeTracker i_timer;
+    PeriodicTimer vis_Update;
+
+    uint16 i_unloadActiveLockCount : 16;                    // lock from active object spawn points (prevent clone loading)
+    bool   i_unloadExplicitLock    : 1;                     // explicit manual lock or config setting
+    bool   i_unloadReferenceLock   : 1;                     // lock from instance map copy
+};
+
+typedef enum
+{
+    GRID_STATE_INVALID = 0,
+    GRID_STATE_ACTIVE = 1,
+    GRID_STATE_IDLE = 2,
+    GRID_STATE_REMOVAL= 3,
+    MAX_GRID_STATE = 4
+} grid_state_t;
+
+template
+<
+unsigned int N,
+class ACTIVE_OBJECT,
+class WORLD_OBJECT_TYPES,
+class GRID_OBJECT_TYPES,
+class ThreadModel = Trinity::SingleThreaded<ACTIVE_OBJECT>
+>
+class NGrid
+{
+    public:
+
+        typedef Grid<ACTIVE_OBJECT, WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES, ThreadModel> GridType;
+        NGrid(uint32 id, int32 x, int32 y, time_t expiry, bool unload = true)
+            : i_gridId(id), i_x(x), i_y(y), i_cellstate(GRID_STATE_INVALID), i_GridObjectDataLoaded(false)
+        {
+            i_GridInfo = GridInfo(expiry, unload);
+        }
+
+        const GridType& operator()(unsigned short x, unsigned short y) const
+        {
+            ASSERT(x < N);
+            ASSERT(y < N);
+            return i_cells[x][y];
+        }
+
+        GridType& operator()(unsigned short x, unsigned short y)
+        {
+            ASSERT(x < N);
+            ASSERT(y < N);
+            return i_cells[x][y];
+        }
+
+        const uint32& GetGridId(void) const { return i_gridId; }
+        void SetGridId(const uint32 id) const { i_gridId = id; }
+        grid_state_t GetGridState(void) const { return i_cellstate; }
+        void SetGridState(grid_state_t s) { i_cellstate = s; }
+        int32 getX() const { return i_x; }
+        int32 getY() const { return i_y; }
+
+        void link(GridRefManager<NGrid<N, ACTIVE_OBJECT, WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES, ThreadModel> >* pTo)
+        {
+            i_Reference.link(pTo, this);
+        }
+        bool isGridObjectDataLoaded() const { return i_GridObjectDataLoaded; }
+        void setGridObjectDataLoaded(bool pLoaded) { i_GridObjectDataLoaded = pLoaded; }
+
+        GridInfo* getGridInfoRef() { return &i_GridInfo; }
+        const TimeTracker& getTimeTracker() const { return i_GridInfo.getTimeTracker(); }
+        bool getUnloadLock() const { return i_GridInfo.getUnloadLock(); }
+        void setUnloadExplicitLock( bool on ) { i_GridInfo.setUnloadExplicitLock(on); }
+        void setUnloadReferenceLock( bool on ) { i_GridInfo.setUnloadReferenceLock(on); }
+        void incUnloadActiveLock() { i_GridInfo.incUnloadActiveLock(); }
+        void decUnloadActiveLock() { i_GridInfo.decUnloadActiveLock(); }
+        void ResetTimeTracker(time_t interval) { i_GridInfo.ResetTimeTracker(interval); }
+        void UpdateTimeTracker(time_t diff) { i_GridInfo.UpdateTimeTracker(diff); }
+
+        template<class SPECIFIC_OBJECT> void AddWorldObject(const uint32 x, const uint32 y, SPECIFIC_OBJECT *obj)
+        {
+            getGridType(x, y).AddWorldObject(obj);
+        }
+
+        template<class SPECIFIC_OBJECT> void RemoveWorldObject(const uint32 x, const uint32 y, SPECIFIC_OBJECT *obj)
+        {
+            getGridType(x, y).RemoveWorldObject(obj);
+        }
+
+        template<class T, class TT> void Visit(TypeContainerVisitor<T, TypeMapContainer<TT> > &visitor)
+        {
+            for (unsigned int x=0; x < N; ++x)
+                for (unsigned int y=0; y < N; ++y)
+                    getGridType(x, y).Visit(visitor);
+        }
+
+        template<class T, class TT> void Visit(const uint32 &x, const uint32 &y, TypeContainerVisitor<T, TypeMapContainer<TT> > &visitor)
+        {
+            getGridType(x, y).Visit(visitor);
+        }
+
+        unsigned int ActiveObjectsInGrid(void) const
+        {
+            unsigned int count=0;
+            for (unsigned int x=0; x < N; ++x)
+                for (unsigned int y=0; y < N; ++y)
+                    count += i_cells[x][y].ActiveObjectsInGrid();
+            return count;
+        }
+
+        template<class SPECIFIC_OBJECT> bool AddGridObject(const uint32 x, const uint32 y, SPECIFIC_OBJECT *obj)
+        {
+            return getGridType(x, y).AddGridObject(obj);
+        }
+
+        template<class SPECIFIC_OBJECT> bool RemoveGridObject(const uint32 x, const uint32 y, SPECIFIC_OBJECT *obj)
+        {
+            return getGridType(x, y).RemoveGridObject(obj);
+        }
+
+    private:
+
+        GridType& getGridType(const uint32& x, const uint32& y)
+        {
+            ASSERT(x < N);
+            ASSERT(y < N);
+            return i_cells[x][y];
+        }
+
+        uint32 i_gridId;
+        GridInfo i_GridInfo;
+        GridReference<NGrid<N, ACTIVE_OBJECT, WORLD_OBJECT_TYPES, GRID_OBJECT_TYPES, ThreadModel> > i_Reference;
+        int32 i_x;
+        int32 i_y;
+        grid_state_t i_cellstate;
+        GridType i_cells[N][N];
+        bool i_GridObjectDataLoaded;
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/GameSystem/TypeContainer.h b/src/server/game/TriniChat/framework/GameSystem/TypeContainer.h
new file mode 100644
index 0000000..48cd6f4
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/TypeContainer.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_TYPECONTAINER_H
+#define TRINITY_TYPECONTAINER_H
+
+/*
+ * Here, you'll find a series of containers that allow you to hold multiple
+ * types of object at the same time.
+ */
+
+#include <map>
+#include <vector>
+#include "Platform/Define.h"
+#include "Utilities/TypeList.h"
+#include "GameSystem/GridRefManager.h"
+
+/*
+ * @class ContainerMapList is a mulit-type container for map elements
+ * By itself its meaningless but collaborate along with TypeContainers,
+ * it become the most powerfully container in the whole system.
+ */
+template<class OBJECT> struct ContainerMapList
+{
+    //std::map<OBJECT_HANDLE, OBJECT *> _element;
+    GridRefManager<OBJECT> _element;
+};
+
+template<> struct ContainerMapList<TypeNull>                /* nothing is in type null */
+{
+};
+template<class H, class T> struct ContainerMapList<TypeList<H, T> >
+{
+    ContainerMapList<H> _elements;
+    ContainerMapList<T> _TailElements;
+};
+
+/*
+ * @class ContaierArrayList is a multi-type container for
+ * array of elements.
+ */
+template<class OBJECT> struct ContainerArrayList
+{
+    std::vector<OBJECT> _element;
+};
+
+// termination condition
+template<> struct ContainerArrayList<TypeNull> {};
+// recursion
+template<class H, class T> struct ContainerArrayList<TypeList<H, T> >
+{
+    ContainerArrayList<H> _elements;
+    ContainerArrayList<T> _TailElements;
+};
+
+/*
+ * @class ContainerList is a simple list of different types of elements
+ *
+ */
+template<class OBJECT> struct ContainerList
+{
+    OBJECT _element;
+};
+
+/* TypeNull is underfined */
+template<> struct ContainerList<TypeNull> {};
+template<class H, class T> struct ContainerList<TypeList<H, T> >
+{
+    ContainerList<H> _elements;
+    ContainerMapList<T> _TailElements;
+};
+
+#include "TypeContainerFunctions.h"
+
+/*
+ * @class TypeMapContainer contains a fixed number of types and is
+ * determined at compile time.  This is probably the most complicated
+ * class and do its simplest thing, that is, holds objects
+ * of different types.
+ */
+
+template<class OBJECT_TYPES>
+class TypeMapContainer
+{
+    public:
+        template<class SPECIFIC_TYPE> size_t Count() const { return Trinity::Count(i_elements, (SPECIFIC_TYPE*)NULL); }
+
+        /// inserts a specific object into the container
+        template<class SPECIFIC_TYPE> bool insert(SPECIFIC_TYPE *obj)
+        {
+            SPECIFIC_TYPE* t = Trinity::Insert(i_elements, obj);
+            return (t != NULL);
+        }
+
+        ///  Removes the object from the container, and returns the removed object
+        template<class SPECIFIC_TYPE> bool remove(SPECIFIC_TYPE* obj)
+        {
+            SPECIFIC_TYPE* t = Trinity::Remove(i_elements, obj);
+            return (t != NULL);
+        }
+
+        ContainerMapList<OBJECT_TYPES> & GetElements(void) { return i_elements; }
+        const ContainerMapList<OBJECT_TYPES> & GetElements(void) const { return i_elements;}
+
+    private:
+        ContainerMapList<OBJECT_TYPES> i_elements;
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctions.h b/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctions.h
new file mode 100644
index 0000000..d356fa0
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctions.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TYPECONTAINER_FUNCTIONS_H
+#define TYPECONTAINER_FUNCTIONS_H
+
+/*
+ * Here you'll find a list of helper functions to make
+ * the TypeContainer usefull.  Without it, its hard
+ * to access or mutate the container.
+ */
+
+#include "Platform/Define.h"
+#include "Utilities/TypeList.h"
+#include <map>
+
+namespace Trinity
+{
+    /* ContainerMapList Helpers */
+    // count functions
+    template<class SPECIFIC_TYPE> size_t Count(const ContainerMapList<SPECIFIC_TYPE> &elements, SPECIFIC_TYPE* /*fake*/)
+    {
+        return elements._element.getSize();
+    };
+
+    template<class SPECIFIC_TYPE> size_t Count(const ContainerMapList<TypeNull> &/*elements*/, SPECIFIC_TYPE* /*fake*/)
+    {
+        return 0;
+    }
+
+    template<class SPECIFIC_TYPE, class T> size_t Count(const ContainerMapList<T> &/*elements*/, SPECIFIC_TYPE* /*fake*/)
+    {
+        return 0;
+    }
+
+    template<class SPECIFIC_TYPE, class T> size_t Count(const ContainerMapList<TypeList<SPECIFIC_TYPE, T> >&elements, SPECIFIC_TYPE* fake)
+    {
+        return Count(elements._elements,fake);
+    }
+
+    template<class SPECIFIC_TYPE, class H, class T> size_t Count(const ContainerMapList<TypeList<H, T> >&elements, SPECIFIC_TYPE* fake)
+    {
+        return Count(elements._TailElements, fake);
+    }
+
+    // non-const insert functions
+    template<class SPECIFIC_TYPE> SPECIFIC_TYPE* Insert(ContainerMapList<SPECIFIC_TYPE> &elements, SPECIFIC_TYPE *obj)
+    {
+        //elements._element[hdl] = obj;
+        obj->GetGridRef().link(&elements._element, obj);
+        return obj;
+    };
+
+    template<class SPECIFIC_TYPE> SPECIFIC_TYPE* Insert(ContainerMapList<TypeNull> &/*elements*/, SPECIFIC_TYPE * /*obj*/)
+    {
+        return NULL;
+    }
+
+    // this is a missed
+    template<class SPECIFIC_TYPE, class T> SPECIFIC_TYPE* Insert(ContainerMapList<T> &/*elements*/, SPECIFIC_TYPE * /*obj*/)
+    {
+        return NULL;                                        // a missed
+    }
+
+    // Recursion
+    template<class SPECIFIC_TYPE, class H, class T> SPECIFIC_TYPE* Insert(ContainerMapList<TypeList<H, T> >&elements, SPECIFIC_TYPE *obj)
+    {
+        SPECIFIC_TYPE* t= Insert(elements._elements, obj);
+        return (t != NULL ? t : Insert(elements._TailElements, obj));
+    }
+
+    // non-const remove method
+    template<class SPECIFIC_TYPE> SPECIFIC_TYPE* Remove(ContainerMapList<SPECIFIC_TYPE> & /*elements*/, SPECIFIC_TYPE *obj)
+    {
+        obj->GetGridRef().unlink();
+        return obj;
+    }
+
+    template<class SPECIFIC_TYPE> SPECIFIC_TYPE* Remove(ContainerMapList<TypeNull> &/*elements*/, SPECIFIC_TYPE * /*obj*/)
+    {
+        return NULL;
+    }
+
+    // this is a missed
+    template<class SPECIFIC_TYPE, class T> SPECIFIC_TYPE* Remove(ContainerMapList<T> &/*elements*/, SPECIFIC_TYPE * /*obj*/)
+    {
+        return NULL;                                        // a missed
+    }
+
+    template<class SPECIFIC_TYPE, class T, class H> SPECIFIC_TYPE* Remove(ContainerMapList<TypeList<H, T> > &elements, SPECIFIC_TYPE *obj)
+    {
+        // The head element is bad
+        SPECIFIC_TYPE* t = Remove(elements._elements, obj);
+        return ( t != NULL ? t : Remove(elements._TailElements, obj) );
+    }
+
+}
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctionsPtr.h b/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctionsPtr.h
new file mode 100644
index 0000000..358d095
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/TypeContainerFunctionsPtr.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TYPECONTAINER_FUNCTIONS_PTR_H
+#define TYPECONTAINER_FUNCTIONS_PTR_H
+
+/*
+ * Here you'll find a list of helper functions to make
+ * the TypeContainer usefull.  Without it, its hard
+ * to access or mutate the container.
+ */
+
+#include "Platform/Define.h"
+#include "Utilities/TypeList.h"
+#include <map>
+
+namespace Trinity
+{
+    /* ContainerMapList Helpers */
+    // count functions
+    //    template<class SPECIFIC_TYPE> size_t Count(const ContainerMapList<SPECIFIC_TYPE> &elements, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    //    {
+    //        return elements._element.size();
+    //    };
+    //
+    //    template<class SPECIFIC_TYPE> size_t Count(const ContainerMapList<TypeNull> &elements, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    //    {
+    //        return 0;
+    //    }
+    //
+    //    template<class SPECIFIC_TYPE, class T> size_t Count(const ContainerMapList<T> &elements, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    //    {
+    //        return 0;
+    //    }
+    //
+    //    template<class SPECIFIC_TYPE, class T> size_t Count(const ContainerMapList<TypeList<SPECIFIC_TYPE, T> >&elements, SPECIFIC_TYPE* fake)
+    //    {
+    //        return Count(elements._elements,fake);
+    //    }
+    //
+    //    template<class SPECIFIC_TYPE, class H, class T> size_t Count(const ContainerMapList<TypeList<H, T> >&elements, SPECIFIC_TYPE* fake)
+    //    {
+    //        return Count(elements._TailElements, fake);
+    //    }
+
+    // non-const find functions
+    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<SPECIFIC_TYPE> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        typename std::map<OBJECT_HANDLE, CountedPtr<SPECIFIC_TYPE> >::iterator iter = elements._element.find(hdl);
+        return (iter == elements._element.end() ? NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL) : iter->second);
+    };
+
+    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<TypeNull> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);// terminate recursion
+    }
+
+    template<class SPECIFIC_TYPE, class T> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<T> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);// this is a missed
+    }
+
+    template<class SPECIFIC_TYPE, class H, class T> CountedPtr<SPECIFIC_TYPE>& Find(ContainerMapList<TypeList<H, T> >&elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* fake)
+    {
+        CountedPtr<SPECIFIC_TYPE> &t = Find(elements._elements, hdl,fake);
+        return (!t ? Find(elements._TailElements, hdl,fake) : t);
+    }
+
+    // const find functions
+    template<class SPECIFIC_TYPE> const CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<SPECIFIC_TYPE> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        typename CountedPtr<SPECIFIC_TYPE>::iterator iter = elements._element.find(hdl);
+        return (iter == elements._element.end() ? NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL) : iter->second);
+    };
+
+    template<class SPECIFIC_TYPE> const CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<TypeNull> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);
+    }
+
+    template<class SPECIFIC_TYPE, class T> const CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<T> &elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* /*fake*/)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);
+    }
+
+    template<class SPECIFIC_TYPE, class H, class T> CountedPtr<SPECIFIC_TYPE>& Find(const ContainerMapList<TypeList<H, T> >&elements, OBJECT_HANDLE hdl, CountedPtr<SPECIFIC_TYPE>* fake)
+    {
+        CountedPtr<SPECIFIC_TYPE> &t = Find(elements._elements, hdl,fake);
+        if(!t)
+            t = Find(elements._TailElement, hdl,fake);
+
+        return t;
+    }
+
+    // non-const insert functions
+    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<SPECIFIC_TYPE> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        elements._element[hdl] = obj;
+        return obj;
+    };
+
+    template<class SPECIFIC_TYPE> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<TypeNull> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);
+    }
+
+    // this is a missed
+    template<class SPECIFIC_TYPE, class T> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<T> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        return NullPtr<SPECIFIC_TYPE>((SPECIFIC_TYPE*)NULL);// a missed
+    }
+
+    // Recursion
+    template<class SPECIFIC_TYPE, class H, class T> CountedPtr<SPECIFIC_TYPE>& Insert(ContainerMapList<TypeList<H, T> >&elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        CountedPtr<SPECIFIC_TYPE> &t= Insert(elements._elements, obj, hdl);
+        return (!t ? Insert(elements._TailElements, obj, hdl) : t);
+    }
+
+    // non-const remove method
+    template<class SPECIFIC_TYPE> bool Remove(ContainerMapList<SPECIFIC_TYPE> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        typename std::map<OBJECT_HANDLE, CountedPtr<SPECIFIC_TYPE> >::iterator iter = elements._element.find(hdl);
+        if( iter != elements._element.end() )
+        {
+            elements._element.erase(iter);
+            return true;
+        }
+
+        return false;                                       // found... terminate the search
+    }
+
+    template<class SPECIFIC_TYPE> bool Remove(ContainerMapList<TypeNull> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        return false;
+    }
+
+    // this is a missed
+    template<class SPECIFIC_TYPE, class T> bool Remove(ContainerMapList<T> &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        return false;
+    }
+
+    template<class SPECIFIC_TYPE, class T, class H> bool Remove(ContainerMapList<TypeList<H, T> > &elements, CountedPtr<SPECIFIC_TYPE> &obj, OBJECT_HANDLE hdl)
+    {
+        // The head element is bad
+        bool t = Remove(elements._elements, obj, hdl);
+        return ( !t ? Remove(elements._TailElements, obj, hdl) : t );
+    }
+
+}
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/GameSystem/TypeContainerVisitor.h b/src/server/game/TriniChat/framework/GameSystem/TypeContainerVisitor.h
new file mode 100644
index 0000000..04d632e
--- /dev/null
+++ b/src/server/game/TriniChat/framework/GameSystem/TypeContainerVisitor.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_TYPECONTAINERVISITOR_H
+#define TRINITY_TYPECONTAINERVISITOR_H
+
+/*
+ * @class TypeContainerVisitor is implemented as a visitor pattern.  It is
+ * a visitor to the TypeContainerList or TypeContainerMapList.  The visitor has
+ * to overload its types as a visit method is called.
+ */
+
+#include "Platform/Define.h"
+#include "TypeContainer.h"
+
+// forward declaration
+template<class T, class Y> class TypeContainerVisitor;
+
+// visitor helper
+template<class VISITOR, class TYPE_CONTAINER> void VisitorHelper(VISITOR &v, TYPE_CONTAINER &c)
+{
+    v.Visit(c);
+};
+
+// terminate condition for container list
+template<class VISITOR> void VisitorHelper(VISITOR &v, ContainerList<TypeNull> &c)
+{
+}
+
+template<class VISITOR, class T> void VisitorHelper(VISITOR &v, ContainerList<T> &c)
+{
+    v.Visit(c._element);
+}
+
+// recursion for container list
+template<class VISITOR, class H, class T> void VisitorHelper(VISITOR &v, ContainerList<TypeList<H, T> > &c)
+{
+    VisitorHelper(v, c._elements);
+    VisitorHelper(v, c._TailElements);
+}
+
+// terminate condition container map list
+template<class VISITOR> void VisitorHelper(VISITOR &/*v*/, ContainerMapList<TypeNull> &/*c*/)
+{
+}
+
+template<class VISITOR, class T> void VisitorHelper(VISITOR &v, ContainerMapList<T> &c)
+{
+    v.Visit(c._element);
+}
+
+// recursion container map list
+template<class VISITOR, class H, class T> void VisitorHelper(VISITOR &v, ContainerMapList<TypeList<H, T> > &c)
+{
+    VisitorHelper(v, c._elements);
+    VisitorHelper(v, c._TailElements);
+}
+
+// array list
+template<class VISITOR, class T> void VisitorHelper(VISITOR &v, ContainerArrayList<T> &c)
+{
+    v.Visit(c._element);
+}
+
+template<class VISITOR> void VisitorHelper(VISITOR &/*v*/, ContainerArrayList<TypeNull> &/*c*/)
+{
+}
+
+// recursion
+template<class VISITOR, class H, class T> void VisitorHelper(VISITOR &v, ContainerArrayList<TypeList<H, T> > &c)
+{
+    VisitorHelper(v, c._elements);
+    VisitorHelper(v, c._TailElements);
+}
+
+// for TypeMapContainer
+template<class VISITOR, class OBJECT_TYPES> void VisitorHelper(VISITOR &v, TypeMapContainer<OBJECT_TYPES> &c)
+{
+    VisitorHelper(v, c.GetElements());
+}
+
+template<class VISITOR, class TYPE_CONTAINER>
+class TypeContainerVisitor
+{
+    public:
+        TypeContainerVisitor(VISITOR &v) : i_visitor(v) {}
+
+        void Visit(TYPE_CONTAINER &c)
+        {
+            VisitorHelper(i_visitor, c);
+        }
+
+        void Visit(const TYPE_CONTAINER &c) const
+        {
+            VisitorHelper(i_visitor, c);
+        }
+
+    private:
+        VISITOR &i_visitor;
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Network/SocketDefines.h b/src/server/game/TriniChat/framework/Network/SocketDefines.h
new file mode 100644
index 0000000..36c8f24
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Network/SocketDefines.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_SOCKETDEFINES_H
+#define TRINITY_SOCKETDEFINES_H
+
+#ifdef WIN32
+
+/* Windows socket definitions
+ */
+#define FD_SETSIZE 1024
+#include <winsock2.h>
+#include <Ws2tcpip.h>
+
+typedef SOCKET SocketHandle;
+typedef fd_set SelectSet;
+
+#else
+
+/* The unix socket definitions
+ */
+#include <sys/socket.h>
+#include <netinet/in.h>
+#ifdef __APPLE_CC__
+#include <sys/select.h>
+#endif
+
+typedef int SocketHandle;
+typedef fd_set SelectSet;
+#endif
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Platform/CompilerDefs.h b/src/server/game/TriniChat/framework/Platform/CompilerDefs.h
new file mode 100644
index 0000000..3e3e2e4
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Platform/CompilerDefs.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_COMPILERDEFS_H
+#define TRINITY_COMPILERDEFS_H
+
+#define PLATFORM_WINDOWS 0
+#define PLATFORM_UNIX    1
+#define PLATFORM_APPLE   2
+#define PLATFORM_INTEL   3
+
+// must be first (win 64 also define WIN32)
+#if defined( _WIN64 )
+#  define PLATFORM PLATFORM_WINDOWS
+#elif defined( __WIN32__ ) || defined( WIN32 ) || defined( _WIN32 )
+#  define PLATFORM PLATFORM_WINDOWS
+#elif defined( __APPLE_CC__ )
+#  define PLATFORM PLATFORM_APPLE
+#elif defined( __INTEL_COMPILER )
+#  define PLATFORM PLATFORM_INTEL
+#else
+#  define PLATFORM PLATFORM_UNIX
+#endif
+
+#define COMPILER_MICROSOFT 0
+#define COMPILER_GNU       1
+#define COMPILER_BORLAND   2
+#define COMPILER_INTEL     3
+
+#ifdef _MSC_VER
+#  define COMPILER COMPILER_MICROSOFT
+#elif defined( __BORLANDC__ )
+#  define COMPILER COMPILER_BORLAND
+#elif defined( __INTEL_COMPILER )
+#  define COMPILER COMPILER_INTEL
+#elif defined( __GNUC__ )
+#  define COMPILER COMPILER_GNU
+#else
+#  pragma error "FATAL ERROR: Unknown compiler."
+#endif
+
+#if COMPILER == COMPILER_MICROSOFT
+#  pragma warning( disable : 4267 )                         // conversion from 'size_t' to 'int', possible loss of data
+#  pragma warning( disable : 4786 )                         // identifier was truncated to '255' characters in the debug information
+#endif
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Platform/Define.h b/src/server/game/TriniChat/framework/Platform/Define.h
new file mode 100644
index 0000000..9285bf2
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Platform/Define.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef TRINITY_DEFINE_H
+#define TRINITY_DEFINE_H
+
+#include <sys/types.h>
+
+#include <ace/Basic_Types.h>
+#include <ace/ACE_export.h>
+
+#include "Platform/CompilerDefs.h"
+
+#define TRINITY_LITTLEENDIAN 0
+#define TRINITY_BIGENDIAN    1
+
+#if !defined(TRINITY_ENDIAN)
+#  if defined (ACE_BIG_ENDIAN)
+#    define TRINITY_ENDIAN TRINITY_BIGENDIAN
+#  else //ACE_BYTE_ORDER != ACE_BIG_ENDIAN
+#    define TRINITY_ENDIAN TRINITY_LITTLEENDIAN
+#  endif //ACE_BYTE_ORDER
+#endif //TRINITY_ENDIAN
+
+#if PLATFORM == PLATFORM_WINDOWS
+#  define TRINITY_PATH_MAX MAX_PATH
+#  ifndef DECLSPEC_NORETURN
+#    define DECLSPEC_NORETURN __declspec(noreturn)
+#  endif //DECLSPEC_NORETURN
+#else //PLATFORM != PLATFORM_WINDOWS
+#  define TRINITY_PATH_MAX PATH_MAX
+#  define DECLSPEC_NORETURN
+#endif //PLATFORM
+
+#if !defined(DEBUG)
+#  define TRINITY_INLINE inline
+#else //DEBUG
+#  if !defined(TRINITY_DEBUG)
+#    define TRINITY_DEBUG
+#  endif //TRINITY_DEBUG
+#  define TRINITY_INLINE
+#endif //!DEBUG
+
+#if COMPILER == COMPILER_GNU
+#  define ATTR_NORETURN __attribute__((noreturn))
+#  define ATTR_PRINTF(F,V) __attribute__ ((format (printf, F, V)))
+#else //COMPILER != COMPILER_GNU
+#  define ATTR_NORETURN
+#  define ATTR_PRINTF(F,V)
+#endif //COMPILER == COMPILER_GNU
+
+typedef ACE_INT64 int64;
+typedef ACE_INT32 int32;
+typedef ACE_INT16 int16;
+typedef ACE_INT8 int8;
+typedef ACE_UINT64 uint64;
+typedef ACE_UINT32 uint32;
+typedef ACE_UINT16 uint16;
+typedef ACE_UINT8 uint8;
+
+#if COMPILER != COMPILER_MICROSOFT
+typedef uint16      WORD;
+typedef uint32      DWORD;
+#endif //COMPILER
+
+typedef uint64 OBJECT_HANDLE;
+
+#endif //TRINITY_DEFINE_H
diff --git a/src/server/game/TriniChat/framework/Policies/CreationPolicy.h b/src/server/game/TriniChat/framework/Policies/CreationPolicy.h
new file mode 100644
index 0000000..007ed6d
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/CreationPolicy.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_CREATIONPOLICY_H
+#define TRINITY_CREATIONPOLICY_H
+
+#include <stdlib.h>
+#include "../Platform/Define.h"
+
+namespace Trinity
+{
+    /**
+     * OperatorNew policy creates an object on the heap using new.
+     */
+    template <class T>
+        class OperatorNew
+    {
+        public:
+            static T* Create(void) { return (new T); }
+            static void Destroy(T *obj) { delete obj; }
+    };
+
+    /**
+     * LocalStaticCreation policy creates an object on the stack
+     * the first time call Create.
+     */
+    template <class T>
+        class LocalStaticCreation
+    {
+        union MaxAlign
+        {
+            char t_[sizeof(T)];
+            short int shortInt_;
+            int int_;
+            long int longInt_;
+            float float_;
+            double double_;
+            long double longDouble_;
+            struct Test;
+            int Test::* pMember_;
+            int (Test::*pMemberFn_)(int);
+        };
+        public:
+            static T* Create(void)
+            {
+                static MaxAlign si_localStatic;
+                return new(&si_localStatic) T;
+            }
+
+            static void Destroy(T *obj) { obj->~T(); }
+    };
+
+    /**
+     * CreateUsingMalloc by pass the memory manger.
+     */
+    template<class T>
+        class CreateUsingMalloc
+    {
+        public:
+            static T* Create()
+            {
+                void* p = ::malloc(sizeof(T));
+                if (!p) return 0;
+                return new(p) T;
+            }
+
+            static void Destroy(T* p)
+            {
+                p->~T();
+                ::free(p);
+            }
+    };
+
+    /**
+     * CreateOnCallBack creates the object base on the call back.
+     */
+    template<class T, class CALL_BACK>
+        class CreateOnCallBack
+    {
+        public:
+            static T* Create()
+            {
+                return CALL_BACK::createCallBack();
+            }
+
+            static void Destroy(T *p)
+            {
+                CALL_BACK::destroyCallBack(p);
+            }
+    };
+}
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.cpp b/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.cpp
new file mode 100644
index 0000000..7d31352
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.cpp
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <cstdlib>
+#include "ObjectLifeTime.h"
+
+namespace Trinity
+{
+    extern "C" void external_wrapper(void *p)
+    {
+        std::atexit( (void (*)())p );
+    }
+
+    void at_exit( void (*func)() )
+    {
+        external_wrapper((void*)func);
+    }
+}
+// end
diff --git a/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.h b/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.h
new file mode 100644
index 0000000..34d75bd
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/ObjectLifeTime.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_OBJECTLIFETIME_H
+#define TRINITY_OBJECTLIFETIME_H
+
+#include <stdexcept>
+#include "../Platform/Define.h"
+
+typedef void (* Destroyer)(void);
+
+namespace Trinity
+{
+    void at_exit( void (*func)() );
+
+    template <class T>
+        class ObjectLifeTime
+    {
+        public:
+            static void ScheduleCall(void (*destroyer)() )
+            {
+                at_exit( destroyer );
+            }
+
+            DECLSPEC_NORETURN static void OnDeadReference(void) ATTR_NORETURN;
+
+    };
+
+    template <class T>
+        void ObjectLifeTime<T>::OnDeadReference(void)       // We don't handle Dead Reference for now
+    {
+        throw std::runtime_error("Dead Reference");
+    }
+}
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Policies/Singleton.h b/src/server/game/TriniChat/framework/Policies/Singleton.h
new file mode 100644
index 0000000..dc691e9
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/Singleton.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_SINGLETON_H
+#define TRINITY_SINGLETON_H
+
+/**
+ * @brief class Singleton
+ */
+
+#include "CreationPolicy.h"
+#include "ThreadingModel.h"
+#include "ObjectLifeTime.h"
+
+namespace Trinity
+{
+    template
+        <
+        typename T,
+        class ThreadingModel = Trinity::SingleThreaded<T>,
+        class CreatePolicy = Trinity::OperatorNew<T>,
+        class LifeTimePolicy = Trinity::ObjectLifeTime<T>
+        >
+        class Singleton
+    {
+        public:
+            static T& Instance();
+
+        protected:
+            Singleton() {};
+
+        private:
+
+            // Prohibited actions...this does not prevent hijacking.
+            Singleton(const Singleton &);
+            Singleton& operator=(const Singleton &);
+
+            // Singleton Helpers
+            static void DestroySingleton();
+
+            // data structure
+            typedef typename ThreadingModel::Lock Guard;
+            static T *si_instance;
+            static bool si_destroyed;
+    };
+}
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Policies/SingletonImp.h b/src/server/game/TriniChat/framework/Policies/SingletonImp.h
new file mode 100644
index 0000000..2a309fe
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/SingletonImp.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_SINGLETONIMPL_H
+#define TRINITY_SINGLETONIMPL_H
+
+#include "Singleton.h"
+
+// avoid the using namespace here cuz
+// its a .h file afterall
+
+template
+<
+typename T,
+class ThreadingModel,
+class CreatePolicy,
+class LifeTimePolicy
+>
+T&
+Trinity::Singleton<T, ThreadingModel, CreatePolicy, LifeTimePolicy >::Instance()
+{
+    if( !si_instance )
+    {
+        // double-checked Locking pattern
+        Guard();
+        if( !si_instance )
+        {
+            if( si_destroyed )
+            {
+                si_destroyed = false;
+                LifeTimePolicy::OnDeadReference();
+            }
+            si_instance = CreatePolicy::Create();
+            LifeTimePolicy::ScheduleCall(&DestroySingleton);
+        }
+    }
+
+    return *si_instance;
+}
+
+template
+<
+typename T,
+class ThreadingModel,
+class CreatePolicy,
+class LifeTimePolicy
+>
+void
+Trinity::Singleton<T, ThreadingModel, CreatePolicy, LifeTimePolicy>::DestroySingleton()
+{
+    CreatePolicy::Destroy(si_instance);
+    si_instance = NULL;
+    si_destroyed = true;
+}
+
+#define INSTANTIATE_SINGLETON_1(TYPE) \
+    template class Trinity::Singleton<TYPE, Trinity::SingleThreaded<TYPE>, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >; \
+    template<> TYPE* Trinity::Singleton<TYPE, Trinity::SingleThreaded<TYPE>, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >::si_instance = 0; \
+    template<> bool Trinity::Singleton<TYPE, Trinity::SingleThreaded<TYPE>, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >::si_destroyed = false
+
+#define INSTANTIATE_SINGLETON_2(TYPE, THREADINGMODEL) \
+    template class Trinity::Singleton<TYPE, THREADINGMODEL, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >; \
+    template<> TYPE* Trinity::Singleton<TYPE, THREADINGMODEL, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >::si_instance = 0; \
+    template<> bool Trinity::Singleton<TYPE, THREADINGMODEL, Trinity::OperatorNew<TYPE>, Trinity::ObjectLifeTime<TYPE> >::si_destroyed = false
+
+#define INSTANTIATE_SINGLETON_3(TYPE, THREADINGMODEL, CREATIONPOLICY ) \
+    template class Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, Trinity::ObjectLifeTime<TYPE> >; \
+    template<> TYPE* Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, Trinity::ObjectLifeTime<TYPE> >::si_instance = 0; \
+    template<> bool Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, Trinity::ObjectLifeType<TYPE> >::si_destroyed = false
+
+#define INSTANTIATE_SINGLETON_4(TYPE, THREADINGMODEL, CREATIONPOLICY, OBJECTLIFETIME) \
+    template class Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, OBJECTLIFETIME >; \
+    template<> TYPE* Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, OBJECTLIFETIME >::si_instance = 0; \
+    template<> bool Trinity::Singleton<TYPE, THREADINGMODEL, CREATIONPOLICY, OBJECTLIFETIME >::si_destroyed = false
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Policies/ThreadingModel.h b/src/server/game/TriniChat/framework/Policies/ThreadingModel.h
new file mode 100644
index 0000000..9defe52
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Policies/ThreadingModel.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_THREADINGMODEL_H
+#define TRINITY_THREADINGMODEL_H
+
+/**
+ * @class ThreadingModel<T>
+ *
+ */
+
+#include "../Platform/Define.h"
+
+namespace Trinity
+{
+    inline void Guard(void *) {}
+
+    template<typename MUTEX> class GeneralLock
+    {
+        public:
+            GeneralLock(MUTEX &m) : i_mutex(m)
+            {
+                i_mutex.acquire();
+            }
+
+            ~GeneralLock()
+            {
+                i_mutex.release();
+            }
+        private:
+            GeneralLock(const GeneralLock &);
+            GeneralLock& operator=(const GeneralLock &);
+            MUTEX &i_mutex;
+    };
+
+    template <class T>
+        class SingleThreaded
+    {
+        public:
+
+            struct Lock                                     // empty object
+            {
+                Lock() {}
+                Lock(const T &) {}
+                Lock(const SingleThreaded<T> &)             // for single threaded we ignore this
+                {
+                }
+            };
+
+            typedef T VolatileType;
+    };
+
+    // object level lockable
+    template<class T, class MUTEX>
+        class ObjectLevelLockable
+    {
+        public:
+            ObjectLevelLockable() : i_mtx() {}
+
+            friend class Lock;
+
+            class Lock
+            {
+                public:
+                    Lock(ObjectLevelLockable<T, MUTEX> &host) : i_lock(host.i_mtx)
+                    {
+                    }
+
+                private:
+                    GeneralLock<MUTEX> i_lock;
+            };
+
+            typedef volatile T VolatileType;
+
+        private:
+            // prevent the compiler creating a copy construct
+            ObjectLevelLockable(const ObjectLevelLockable<T, MUTEX> &);
+            ObjectLevelLockable<T, MUTEX>& operator=(const ObjectLevelLockable<T, MUTEX> &);
+
+            MUTEX i_mtx;
+    };
+
+    template<class T, class MUTEX>
+        class ClassLevelLockable
+    {
+        public:
+            class Lock;
+            friend class Lock;
+            typedef volatile T VolatileType;
+
+            ClassLevelLockable() {}
+
+            class Lock
+            {
+                public:
+                    Lock(T& /*host*/) { ClassLevelLockable<T, MUTEX>::si_mtx.acquire(); }
+                    Lock(ClassLevelLockable<T, MUTEX> &) { ClassLevelLockable<T, MUTEX>::si_mtx.acquire(); }
+                    Lock() { ClassLevelLockable<T, MUTEX>::si_mtx.acquire(); }
+                    ~Lock() { ClassLevelLockable<T, MUTEX>::si_mtx.release(); }
+            };
+
+        private:
+            static MUTEX si_mtx;
+    };
+
+}
+
+template<class T, class MUTEX> MUTEX Trinity::ClassLevelLockable<T, MUTEX>::si_mtx;
+
+#define INSTANTIATE_CLASS_MUTEX(CTYPE,MUTEX) \
+    template class Trinity::ClassLevelLockable<CTYPE, MUTEX >
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Utilities/ByteConverter.h b/src/server/game/TriniChat/framework/Utilities/ByteConverter.h
new file mode 100644
index 0000000..665d29f
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/ByteConverter.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef TRINITY_BYTECONVERTER_H
+#define TRINITY_BYTECONVERTER_H
+
+/** ByteConverter reverse your byte order.  This is use
+    for cross platform where they have different endians.
+ */
+
+#include<Platform/Define.h>
+#include<algorithm>
+
+namespace ByteConverter
+{
+    template<size_t T>
+        inline void convert(char *val)
+    {
+        std::swap(*val, *(val + T - 1));
+        convert<T - 2>(val + 1);
+    }
+
+    template<> inline void convert<0>(char *) {}
+    template<> inline void convert<1>(char *) {}            // ignore central byte
+
+    template<typename T> inline void apply(T *val)
+    {
+        convert<sizeof(T)>((char *)(val));
+    }
+}
+
+#if TRINITY_ENDIAN == TRINITY_BIGENDIAN
+template<typename T> inline void EndianConvert(T& val) { ByteConverter::apply<T>(&val); }
+template<typename T> inline void EndianConvertReverse(T&) { }
+#else
+template<typename T> inline void EndianConvert(T&) { }
+template<typename T> inline void EndianConvertReverse(T& val) { ByteConverter::apply<T>(&val); }
+#endif
+
+template<typename T> void EndianConvert(T*);         // will generate link error
+template<typename T> void EndianConvertReverse(T*);  // will generate link error
+
+inline void EndianConvert(uint8&) { }
+inline void EndianConvert( int8&) { }
+inline void EndianConvertReverse(uint8&) { }
+inline void EndianConvertReverse( int8&) { }
+
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Utilities/Callback.h b/src/server/game/TriniChat/framework/Utilities/Callback.h
new file mode 100644
index 0000000..fef00e3
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/Callback.h
@@ -0,0 +1,386 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_CALLBACK_H
+#define TRINITY_CALLBACK_H
+
+/// ------------ BASE CLASSES ------------
+
+namespace Trinity
+{
+    template < class Class, typename ParamType1 = void, typename ParamType2 = void, typename ParamType3 = void, typename ParamType4 = void >
+    class _Callback
+    {
+        protected:
+            typedef void (Class::*Method)(ParamType1, ParamType2, ParamType3, ParamType4);
+            Class *m_object;
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            ParamType3 m_param3;
+            ParamType4 m_param4;
+            void _Execute() { (m_object->*m_method)(m_param1, m_param2, m_param3, m_param4); }
+        public:
+            _Callback(Class *object, Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3, ParamType4 param4)
+                : m_object(object), m_method(method), m_param1(param1), m_param2(param2), m_param3(param3), m_param4(param4) {}
+            _Callback(_Callback < Class, ParamType1, ParamType2, ParamType3, ParamType4> const& cb)
+                : m_object(cb.object), m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2), m_param3(cb.m_param3), m_param4(cb.m_param4) {}
+    };
+
+    template < class Class, typename ParamType1, typename ParamType2, typename ParamType3 >
+    class _Callback < Class, ParamType1, ParamType2, ParamType3 >
+    {
+        protected:
+            typedef void (Class::*Method)(ParamType1, ParamType2, ParamType3);
+            Class *m_object;
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            ParamType3 m_param3;
+            void _Execute() { (m_object->*m_method)(m_param1, m_param2, m_param3); }
+        public:
+            _Callback(Class *object, Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3)
+                : m_object(object), m_method(method), m_param1(param1), m_param2(param2) {}
+            _Callback(_Callback < Class, ParamType1, ParamType2, ParamType3 > const& cb)
+                : m_object(cb.object), m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2), m_param3(cb.m_param3) {}
+    };
+
+    template < class Class, typename ParamType1, typename ParamType2 >
+    class _Callback < Class, ParamType1, ParamType2 >
+    {
+        protected:
+            typedef void (Class::*Method)(ParamType1, ParamType2);
+            Class *m_object;
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            void _Execute() { (m_object->*m_method)(m_param1, m_param2); }
+        public:
+            _Callback(Class *object, Method method, ParamType1 param1, ParamType2 param2)
+                : m_object(object), m_method(method), m_param1(param1), m_param2(param2) {}
+            _Callback(_Callback < Class, ParamType1, ParamType2 > const& cb)
+                : m_object(cb.m_object), m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2) {}
+    };
+
+    template < class Class, typename ParamType1 >
+    class _Callback < Class, ParamType1 >
+    {
+        protected:
+            typedef void (Class::*Method)(ParamType1);
+            Class *m_object;
+            Method m_method;
+            ParamType1 m_param1;
+            void _Execute() { (m_object->*m_method)(m_param1); }
+        public:
+            _Callback(Class *object, Method method, ParamType1 param1)
+                : m_object(object), m_method(method), m_param1(param1) {}
+            _Callback(_Callback < Class, ParamType1 > const& cb)
+                : m_object(cb.m_object), m_method(cb.m_method), m_param1(cb.m_param1) {}
+    };
+
+    template < class Class >
+    class _Callback < Class >
+    {
+        protected:
+            typedef void (Class::*Method)();
+            Class *m_object;
+            Method m_method;
+            void _Execute() { (m_object->*m_method)(); }
+        public:
+            _Callback(Class *object, Method method)
+                : m_object(object), m_method(method) {}
+            _Callback(_Callback < Class > const& cb)
+                : m_object(cb.m_object), m_method(cb.m_method) {}
+    };
+
+    /// ---- Statics ----
+
+    template < typename ParamType1 = void, typename ParamType2 = void, typename ParamType3 = void, typename ParamType4 = void >
+    class _SCallback
+    {
+        protected:
+            typedef void (*Method)(ParamType1, ParamType2, ParamType3, ParamType4);
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            ParamType3 m_param3;
+            ParamType4 m_param4;
+            void _Execute() { (*m_method)(m_param1, m_param2, m_param3, m_param4); }
+        public:
+            _SCallback(Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3, ParamType4 param4)
+                : m_method(method), m_param1(param1), m_param2(param2), m_param3(param3), m_param4(param4) {}
+            _SCallback(_SCallback < ParamType1, ParamType2, ParamType3, ParamType4> const& cb)
+                : m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2), m_param3(cb.m_param3), m_param4(cb.m_param4) {}
+    };
+
+    template < typename ParamType1, typename ParamType2, typename ParamType3 >
+    class _SCallback < ParamType1, ParamType2, ParamType3 >
+    {
+        protected:
+            typedef void (*Method)(ParamType1, ParamType2, ParamType3);
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            ParamType3 m_param3;
+            void _Execute() { (*m_method)(m_param1, m_param2, m_param3); }
+        public:
+            _SCallback(Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3)
+                : m_method(method), m_param1(param1), m_param2(param2), m_param3(param3) {}
+            _SCallback(_SCallback < ParamType1, ParamType2, ParamType3 > const& cb)
+                : m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2), m_param3(cb.m_param3) {}
+    };
+
+    template < typename ParamType1, typename ParamType2 >
+    class _SCallback < ParamType1, ParamType2 >
+    {
+        protected:
+            typedef void (*Method)(ParamType1, ParamType2);
+            Method m_method;
+            ParamType1 m_param1;
+            ParamType2 m_param2;
+            void _Execute() { (*m_method)(m_param1, m_param2); }
+        public:
+            _SCallback(Method method, ParamType1 param1, ParamType2 param2)
+                : m_method(method), m_param1(param1), m_param2(param2) {}
+            _SCallback(_SCallback < ParamType1, ParamType2 > const& cb)
+                : m_method(cb.m_method), m_param1(cb.m_param1), m_param2(cb.m_param2) {}
+    };
+
+    template < typename ParamType1 >
+    class _SCallback < ParamType1 >
+    {
+        protected:
+            typedef void (*Method)(ParamType1);
+            Method m_method;
+            ParamType1 m_param1;
+            void _Execute() { (*m_method)(m_param1); }
+        public:
+            _SCallback(Method method, ParamType1 param1)
+                : m_method(method), m_param1(param1) {}
+            _SCallback(_SCallback < ParamType1 > const& cb)
+                : m_method(cb.m_method), m_param1(cb.m_param1) {}
+    };
+
+    template < >
+    class _SCallback < >
+    {
+        protected:
+            typedef void (*Method)();
+            Method m_method;
+            void _Execute() { (*m_method)(); }
+        public:
+            _SCallback(Method method)
+                : m_method(method) {}
+            _SCallback(_SCallback <> const& cb)
+                : m_method(cb.m_method) {}
+    };
+}
+
+/// --------- GENERIC CALLBACKS ----------
+
+namespace Trinity
+{
+    class ICallback
+    {
+        public:
+            virtual void Execute() = 0;
+            virtual ~ICallback() {}
+    };
+
+    template < class CB >
+    class _ICallback : public CB, public ICallback
+    {
+        public:
+            _ICallback(CB const& cb) : CB(cb) {}
+            void Execute() { CB::_Execute(); }
+    };
+
+    template < class Class, typename ParamType1 = void, typename ParamType2 = void, typename ParamType3 = void, typename ParamType4 = void >
+    class Callback :
+        public _ICallback< _Callback < Class, ParamType1, ParamType2, ParamType3, ParamType4 > >
+    {
+        private:
+            typedef _Callback < Class, ParamType1, ParamType2, ParamType3, ParamType4 > C4;
+        public:
+            Callback(Class *object, typename C4::Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3, ParamType4 param4)
+                : _ICallback< C4 >(C4(object, method, param1, param2, param3, param4)) {}
+    };
+
+    template < class Class, typename ParamType1, typename ParamType2, typename ParamType3 >
+    class Callback < Class, ParamType1, ParamType2, ParamType3 > :
+        public _ICallback< _Callback < Class, ParamType1, ParamType2, ParamType3 > >
+    {
+        private:
+            typedef _Callback < Class, ParamType1, ParamType2, ParamType3 > C3;
+        public:
+            Callback(Class *object, typename C3::Method method, ParamType1 param1, ParamType2 param2, ParamType3 param3)
+                : _ICallback< C3 >(C3(object, method, param1, param2, param3)) {}
+    };
+
+    template < class Class, typename ParamType1, typename ParamType2 >
+    class Callback < Class, ParamType1, ParamType2 > :
+        public _ICallback< _Callback < Class, ParamType1, ParamType2 > >
+    {
+        private:
+            typedef _Callback < Class, ParamType1, ParamType2 > C2;
+        public:
+            Callback(Class *object, typename C2::Method method, ParamType1 param1, ParamType2 param2)
+                : _ICallback< C2 >(C2(object, method, param1, param2)) {}
+    };
+
+    template < class Class, typename ParamType1 >
+    class Callback < Class, ParamType1 > :
+        public _ICallback< _Callback < Class, ParamType1 > >
+    {
+        private:
+            typedef _Callback < Class, ParamType1 > C1;
+        public:
+            Callback(Class *object, typename C1::Method method, ParamType1 param1)
+                : _ICallback< C1 >(C1(object, method, param1)) {}
+    };
+
+    template < class Class >
+    class Callback < Class > : public _ICallback< _Callback < Class > >
+    {
+        private:
+            typedef _Callback < Class > C0;
+        public:
+            Callback(Class *object, typename C0::Method method)
+                : _ICallback< C0 >(C0(object, method)) {}
+    };
+}
+
+/// ---------- QUERY CALLBACKS -----------
+
+#include "QueryResult.h"
+class QueryResult;
+
+namespace Trinity
+{
+    class IQueryCallback
+    {
+        public:
+            virtual void Execute() = 0;
+            virtual ~IQueryCallback() {}
+            virtual void SetResult(QueryResult_AutoPtr result) = 0;
+            virtual QueryResult_AutoPtr GetResult() = 0;
+    };
+
+    template < class CB >
+    class _IQueryCallback : public CB, public IQueryCallback
+    {
+        public:
+            _IQueryCallback(CB const& cb) : CB(cb) {}
+            void Execute() { CB::_Execute(); }
+            void SetResult(QueryResult_AutoPtr result) { CB::m_param1 = result; }
+            QueryResult_AutoPtr GetResult() { return CB::m_param1; }
+    };
+
+    template < class Class, typename ParamType1 = void, typename ParamType2 = void, typename ParamType3 = void >
+    class QueryCallback :
+        public _IQueryCallback< _Callback < Class, QueryResult_AutoPtr, ParamType1, ParamType2, ParamType3 > >
+    {
+        private:
+            typedef _Callback < Class, QueryResult_AutoPtr, ParamType1, ParamType2, ParamType3 > QC3;
+        public:
+            QueryCallback(Class *object, typename QC3::Method method, QueryResult_AutoPtr result, ParamType1 param1, ParamType2 param2, ParamType3 param3)
+                : _IQueryCallback< QC3 >(QC3(object, method, result, param1, param2, param3)) {}
+    };
+
+    template < class Class, typename ParamType1, typename ParamType2 >
+    class QueryCallback < Class, ParamType1, ParamType2 > :
+        public _IQueryCallback< _Callback < Class, QueryResult_AutoPtr, ParamType1, ParamType2 > >
+    {
+        private:
+            typedef _Callback < Class, QueryResult_AutoPtr, ParamType1, ParamType2 > QC2;
+        public:
+            QueryCallback(Class *object, typename QC2::Method method, QueryResult_AutoPtr result, ParamType1 param1, ParamType2 param2)
+                : _IQueryCallback< QC2 >(QC2(object, method, result, param1, param2)) {}
+    };
+
+    template < class Class, typename ParamType1 >
+    class QueryCallback < Class, ParamType1 > :
+        public _IQueryCallback< _Callback < Class, QueryResult_AutoPtr, ParamType1 > >
+    {
+        private:
+            typedef _Callback < Class, QueryResult_AutoPtr, ParamType1 > QC1;
+        public:
+            QueryCallback(Class *object, typename QC1::Method method, QueryResult_AutoPtr result, ParamType1 param1)
+                : _IQueryCallback< QC1 >(QC1(object, method, result, param1)) {}
+    };
+
+    template < class Class >
+    class QueryCallback < Class > : public _IQueryCallback< _Callback < Class, QueryResult_AutoPtr > >
+    {
+        private:
+            typedef _Callback < Class, QueryResult_AutoPtr > QC0;
+        public:
+            QueryCallback(Class *object, typename QC0::Method method, QueryResult_AutoPtr result)
+                : _IQueryCallback< QC0 >(QC0(object, method, result)) {}
+    };
+
+    /// ---- Statics ----
+
+    template < typename ParamType1 = void, typename ParamType2 = void, typename ParamType3 = void >
+    class SQueryCallback :
+        public _IQueryCallback< _SCallback < QueryResult_AutoPtr, ParamType1, ParamType2, ParamType3 > >
+    {
+        private:
+            typedef _SCallback < QueryResult_AutoPtr, ParamType1, ParamType2, ParamType3 > QC3;
+        public:
+            SQueryCallback(typename QC3::Method method, QueryResult_AutoPtr result, ParamType1 param1, ParamType2 param2, ParamType3 param3)
+                : _IQueryCallback< QC3 >(QC3(method, result, param1, param2, param3)) {}
+    };
+
+    template < typename ParamType1, typename ParamType2 >
+    class SQueryCallback < ParamType1, ParamType2 > :
+        public _IQueryCallback< _SCallback < QueryResult_AutoPtr, ParamType1, ParamType2 > >
+    {
+        private:
+            typedef _SCallback < QueryResult_AutoPtr, ParamType1, ParamType2 > QC2;
+        public:
+            SQueryCallback(typename QC2::Method method, QueryResult_AutoPtr result, ParamType1 param1, ParamType2 param2)
+                : _IQueryCallback< QC2 >(QC2(method, result, param1, param2)) {}
+    };
+
+    template < typename ParamType1 >
+    class SQueryCallback < ParamType1 > :
+        public _IQueryCallback< _SCallback < QueryResult_AutoPtr, ParamType1 > >
+    {
+        private:
+            typedef _SCallback < QueryResult_AutoPtr, ParamType1 > QC1;
+        public:
+            SQueryCallback(typename QC1::Method method, QueryResult_AutoPtr result, ParamType1 param1)
+                : _IQueryCallback< QC1 >(QC1(method, result, param1)) {}
+    };
+
+    template < >
+    class SQueryCallback < > : public _IQueryCallback< _SCallback < QueryResult_AutoPtr > >
+    {
+        private:
+            typedef _SCallback < QueryResult_AutoPtr > QC0;
+        public:
+            SQueryCallback(QC0::Method method, QueryResult_AutoPtr result)
+                : _IQueryCallback< QC0 >(QC0(method, result)) {}
+    };
+}
+
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Utilities/CountedReference/Reference.h b/src/server/game/TriniChat/framework/Utilities/CountedReference/Reference.h
new file mode 100644
index 0000000..5e6e96e
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/CountedReference/Reference.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef  TRINITY_REFERENCE_H
+#define  TRINITY_REFERENCE_H
+
+/**
+ * Referencer<T>
+ * Referencer is an object that holds a reference holder that  hold a reference
+ * counted object.  When an object's reference count drop to zero, it removes
+ * the object.  This is a non intrusive mechanism and any object at any point
+ * in time can be referenced.  When and object is reference counted, do not
+ * pass the object directly to other methods but rather, pass its
+ * reference around.  Objects can be reference counted in both single threaded
+ * model and multi-threaded model
+ */
+
+#include <stdexcept>
+#include "Platform/Define.h"
+#include "Policies/ThreadingModel.h"
+#include "ReferenceHolder.h"
+
+template
+<
+typename T,
+class THREADING_MODEL = Trinity::SingleThreaded<T>
+>
+class Referencer
+{
+    typedef typename THREADING_MODEL::Lock Lock;
+    typedef ReferenceHolder<T, THREADING_MODEL> ReferenceeHolder;
+    public:
+
+        /// Constructs a referencer.
+        Referencer(T *ref = NULL);
+
+        /// Copy constructor
+        Referencer(const Referencer &obj) : i_holder(NULL) { *this = obj; }
+
+        /// Destructor
+        ~Referencer();
+
+        /// Referencee accessor
+        T* referencee(void) { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+        const T* referencee(void) const { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+
+        //T& referencee(void){ return _referencee(); }
+        //const T& referencee(void) const { return const_cast<Referencer *>(this)->_referencee(); }
+        operator T&(void) { return _referencee(); }
+        operator const T&(void) const { return *const_cast<Referencer *>(this)->_referencee(); }
+
+        /// cast operators
+        T* operator*() { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+        T const * operator*() const { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+
+        /// overload operators
+        T* operator->() { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+        const T * operator->() const { return (i_holder == NULL ? NULL : i_holder->i_referencee); }
+
+        /// operator =
+        Referencer& operator=(const Referencer &obj);
+        Referencer& operator=(T *);
+
+        /// returns true if i_referencee is null
+        bool isNull(void) const { return i_holder == NULL; }
+
+    private:
+
+        T& _referencee(void)
+        {
+            if( i_holder == NULL )
+                throw std::runtime_error("Invalid access to null pointer");
+            return *i_holder->i_referencee;
+        }
+
+        void deReference(ReferenceeHolder *);
+        void addReference(ReferenceeHolder *);
+
+        // private data
+        ReferenceeHolder *i_holder;
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceHolder.h b/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceHolder.h
new file mode 100644
index 0000000..46b6dac
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceHolder.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_REFERENCEHOLDER_H
+#define TRINITY_REFERENCEHOLDER_H
+
+/** ReferenceHolder holds the actualy referenced obejct as well the refence
+    count.  The ReferenecHolder implements as a policy base object and
+    will decided by the Reference class to be consnsitent.
+ */
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+struct ReferenceHolder : public THREADING_MODEL
+{
+    explicit ReferenceHolder(T *ref) : i_referencee(ref), i_referenceCount(0) {}
+    T *i_referencee;
+    unsigned int i_referenceCount;
+    typedef typename THREADING_MODEL::Lock Lock;
+};
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceImpl.h b/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceImpl.h
new file mode 100644
index 0000000..5a2defa
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/CountedReference/ReferenceImpl.h
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_REFERENCEIMPL_H
+#define TRINITY_REFERENCEIMPL_H
+
+#include "Reference.h"
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+Referencer<T, THREADING_MODEL>::Referencer(T *ref)
+: i_holder(NULL)
+{
+    if( ref != NULL )
+    {
+        i_holder = new ReferenceeHolder(ref);
+        ++i_holder->i_referenceCount;
+    }
+}
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+Referencer<T, THREADING_MODEL>::~Referencer()
+{
+    if( i_holder != NULL )
+        deReference(i_holder);
+    i_holder = NULL;
+}
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+Referencer<T, THREADING_MODEL>&
+Referencer<T, THREADING_MODEL>::operator=(const Referencer<T, THREADING_MODEL> &obj)
+{
+    if( i_holder != NULL )
+        deReference(i_holder);
+    if( obj.i_holder != NULL )
+        addReference(obj.i_holder);
+    i_holder = obj.i_holder;
+    return *this;
+}
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+Referencer<T, THREADING_MODEL>&
+Referencer<T, THREADING_MODEL>::operator=(T *ref)
+{
+    if( i_holder != NULL )
+        deReference(i_holder);
+    i_holder = NULL;
+    if( ref != NULL )
+    {
+        i_holder = new ReferenceeHolder(ref);
+        ++i_holder->i_referenceCount;
+    }
+
+    return *this;
+}
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+void
+Referencer<T, THREADING_MODEL>::deReference(ReferenceHolder<T, THREADING_MODEL> *holder)
+{
+    assert( holder != NULL && holder->i_referenceCount > 0);
+    bool delete_object = false;
+
+    {
+        // The guard is within the scope due to the guard
+        // must release earlier than expected.
+        Lock guard(*holder);
+        Guard(&guard);
+
+        --holder->i_referenceCount;
+        if( holder->i_referenceCount == 0 )
+            delete_object = true;
+    }
+
+    if( delete_object )
+    {
+        delete holder->i_referencee;
+        delete holder;
+    }
+}
+
+template
+<
+typename T,
+class THREADING_MODEL
+>
+void
+Referencer<T, THREADING_MODEL>::addReference(ReferenceHolder<T, THREADING_MODEL> *holder)
+{
+    assert( i_holder != NULL );
+    Lock guard(*holder);
+    Guard(&guard);
+
+    ++holder->i_referenceCount;
+}
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Utilities/LinkedList.h b/src/server/game/TriniChat/framework/Utilities/LinkedList.h
new file mode 100644
index 0000000..3772cb3
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/LinkedList.h
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _LINKEDLIST
+#define _LINKEDLIST
+
+#include "Common.h"
+
+//============================================
+class LinkedListHead;
+
+class LinkedListElement
+{
+    private:
+        friend class LinkedListHead;
+
+        LinkedListElement* iNext;
+        LinkedListElement* iPrev;
+    public:
+        LinkedListElement() { iNext = NULL; iPrev = NULL; }
+        ~LinkedListElement() { delink(); }
+
+        bool hasNext() const { return(iNext && iNext->iNext != NULL); }
+        bool hasPrev() const { return(iPrev && iPrev->iPrev != NULL); }
+        bool isInList() const { return(iNext != NULL && iPrev != NULL); }
+
+        LinkedListElement      * next()       { return hasNext() ? iNext : NULL; }
+        LinkedListElement const* next() const { return hasNext() ? iNext : NULL; }
+        LinkedListElement      * prev()       { return hasPrev() ? iPrev : NULL; }
+        LinkedListElement const* prev() const { return hasPrev() ? iPrev : NULL; }
+
+        LinkedListElement      * nocheck_next()       { return iNext; }
+        LinkedListElement const* nocheck_next() const { return iNext; }
+        LinkedListElement      * nocheck_prev()       { return iPrev; }
+        LinkedListElement const* nocheck_prev() const { return iPrev; }
+
+        void delink()
+        {
+            if(isInList())
+            {
+                iNext->iPrev = iPrev; iPrev->iNext = iNext; iNext = NULL; iPrev = NULL;
+            }
+        }
+
+        void insertBefore(LinkedListElement* pElem)
+        {
+            pElem->iNext = this;
+            pElem->iPrev = iPrev;
+            iPrev->iNext = pElem;
+            iPrev = pElem;
+        }
+
+        void insertAfter(LinkedListElement* pElem)
+        {
+            pElem->iPrev = this;
+            pElem->iNext = iNext;
+            iNext->iPrev = pElem;
+            iNext = pElem;
+        }
+};
+
+//============================================
+
+class LinkedListHead
+{
+    private:
+        LinkedListElement iFirst;
+        LinkedListElement iLast;
+        uint32 iSize;
+    public:
+        LinkedListHead()
+        {
+            // create empty list
+
+            iFirst.iNext = &iLast;
+            iLast.iPrev = &iFirst;
+            iSize = 0;
+        }
+
+        bool isEmpty() const { return(!iFirst.iNext->isInList()); }
+
+        LinkedListElement      * getFirst()       { return(isEmpty() ? NULL : iFirst.iNext); }
+        LinkedListElement const* getFirst() const { return(isEmpty() ? NULL : iFirst.iNext); }
+
+        LinkedListElement      * getLast() { return(isEmpty() ? NULL : iLast.iPrev); }
+        LinkedListElement const* getLast() const  { return(isEmpty() ? NULL : iLast.iPrev); }
+
+        void insertFirst(LinkedListElement* pElem)
+        {
+            iFirst.insertAfter(pElem);
+        }
+
+        void insertLast(LinkedListElement* pElem)
+        {
+            iLast.insertBefore(pElem);
+        }
+
+        uint32 getSize() const
+        {
+            if(!iSize)
+            {
+                uint32 result = 0;
+                LinkedListElement const* e = getFirst();
+                while(e)
+                {
+                    ++result;
+                    e = e->next();
+                }
+                return result;
+            }
+            else
+                return iSize;
+        }
+
+        void incSize() { ++iSize; }
+        void decSize() { --iSize; }
+
+        template<class _Ty>
+            class Iterator
+        {
+            public:
+                typedef std::bidirectional_iterator_tag     iterator_category;
+                typedef _Ty                                 value_type;
+                typedef ptrdiff_t                           difference_type;
+                typedef ptrdiff_t                           distance_type;
+                typedef _Ty*                                pointer;
+                typedef _Ty const*                          const_pointer;
+                typedef _Ty&                                reference;
+                typedef _Ty const &                         const_reference;
+
+                Iterator() : _Ptr(0)
+                {                                           // construct with null node pointer
+                }
+
+                Iterator(pointer _Pnode) : _Ptr(_Pnode)
+                {                                           // construct with node pointer _Pnode
+                }
+
+                Iterator& operator=(Iterator const &_Right)
+                {
+                    return (*this) = _Right._Ptr;
+                }
+
+                Iterator& operator=(const_pointer const &_Right)
+                {
+                    _Ptr = (pointer)_Right;
+                    return (*this);
+                }
+
+                reference operator*()
+                {                                           // return designated value
+                    return *_Ptr;
+                }
+
+                pointer operator->()
+                {                                           // return pointer to class object
+                    return _Ptr;
+                }
+
+                Iterator& operator++()
+                {                                           // preincrement
+                    _Ptr = _Ptr->next();
+                    return (*this);
+                }
+
+                Iterator operator++(int)
+                {                                           // postincrement
+                    iterator _Tmp = *this;
+                    ++*this;
+                    return (_Tmp);
+                }
+
+                Iterator& operator--()
+                {                                           // predecrement
+                    _Ptr = _Ptr->prev();
+                    return (*this);
+                }
+
+                Iterator operator--(int)
+                {                                           // postdecrement
+                    iterator _Tmp = *this;
+                    --*this;
+                    return (_Tmp);
+                }
+
+                bool operator==(Iterator const &_Right) const
+                {                                           // test for iterator equality
+                    return (_Ptr == _Right._Ptr);
+                }
+
+                bool operator!=(Iterator const &_Right) const
+                {                                           // test for iterator inequality
+                    return (!(*this == _Right));
+                }
+
+                bool operator==(pointer const &_Right) const
+                {                                           // test for pointer equality
+                    return (_Ptr != _Right);
+                }
+
+                bool operator!=(pointer const &_Right) const
+                {                                           // test for pointer equality
+                    return (!(*this == _Right));
+                }
+
+                bool operator==(const_reference _Right) const
+                {                                           // test for reference equality
+                    return (_Ptr == &_Right);
+                }
+
+                bool operator!=(const_reference _Right) const
+                {                                           // test for reference equality
+                    return (_Ptr != &_Right);
+                }
+
+                pointer _Mynode()
+                {                                           // return node pointer
+                    return (_Ptr);
+                }
+
+            protected:
+                pointer _Ptr;                               // pointer to node
+        };
+
+        typedef Iterator<LinkedListElement> iterator;
+};
+
+//============================================
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Utilities/LinkedReference/RefManager.h b/src/server/game/TriniChat/framework/Utilities/LinkedReference/RefManager.h
new file mode 100644
index 0000000..39afa2b
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/LinkedReference/RefManager.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _REFERENCE_H
+#define _REFERENCE_H
+
+#include "Utilities/LinkedList.h"
+
+//=====================================================
+
+template <class TO, class FROM> class Reference : public LinkedListElement
+{
+    private:
+        TO* iRefTo;
+        FROM* iRefFrom;
+    protected:
+        // Tell our refTo (target) object that we have a link
+        virtual void targetObjectBuildLink() = 0;
+
+        // Tell our refTo (taget) object, that the link is cut
+        virtual void targetObjectDestroyLink() = 0;
+
+        // Tell our refFrom (source) object, that the link is cut (Target destroyed)
+        virtual void sourceObjectDestroyLink() = 0;
+    public:
+        Reference() { iRefTo = NULL; iRefFrom = NULL; }
+        virtual ~Reference() {}
+
+        // Create new link
+        void link(TO* toObj, FROM* fromObj)
+        {
+            assert(fromObj);                                // fromObj MUST not be NULL
+            if(isValid())
+                unlink();
+            if(toObj != NULL)
+            {
+                iRefTo = toObj;
+                iRefFrom = fromObj;
+                targetObjectBuildLink();
+            }
+        }
+
+        // We don't need the reference anymore. Call comes from the refFrom object
+        // Tell our refTo object, that the link is cut
+        void unlink() { targetObjectDestroyLink(); delink(); iRefTo = NULL; iRefFrom = NULL; }
+
+        // Link is invalid due to destruction of referenced target object. Call comes from the refTo object
+        // Tell our refFrom object, that the link is cut
+        void invalidate()                                   // the iRefFrom MUST remain!!
+        {
+            sourceObjectDestroyLink(); delink(); iRefTo = NULL;
+        }
+
+        bool isValid() const                                // Only check the iRefTo
+        {
+            return iRefTo != NULL;
+        }
+
+        Reference<TO,FROM>       * next()       { return((Reference<TO,FROM>       *) LinkedListElement::next()); }
+        Reference<TO,FROM> const * next() const { return((Reference<TO,FROM> const *) LinkedListElement::next()); }
+        Reference<TO,FROM>       * prev()       { return((Reference<TO,FROM>       *) LinkedListElement::prev()); }
+        Reference<TO,FROM> const * prev() const { return((Reference<TO,FROM> const *) LinkedListElement::prev()); }
+
+        Reference<TO,FROM>       * nocheck_next()       { return((Reference<TO,FROM>       *) LinkedListElement::nocheck_next()); }
+        Reference<TO,FROM> const * nocheck_next() const { return((Reference<TO,FROM> const *) LinkedListElement::nocheck_next()); }
+        Reference<TO,FROM>       * nocheck_prev()       { return((Reference<TO,FROM>       *) LinkedListElement::nocheck_prev()); }
+        Reference<TO,FROM> const * nocheck_prev() const { return((Reference<TO,FROM> const *) LinkedListElement::nocheck_prev()); }
+
+        TO* operator ->() const { return iRefTo; }
+        TO* getTarget() const { return iRefTo; }
+
+        FROM* getSource() const { return iRefFrom; }
+};
+
+//=====================================================
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Utilities/LinkedReference/Reference.h b/src/server/game/TriniChat/framework/Utilities/LinkedReference/Reference.h
new file mode 100644
index 0000000..334a256
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/LinkedReference/Reference.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _REFMANAGER_H
+#define _REFMANAGER_H
+//=====================================================
+
+#include "Utilities/LinkedList.h"
+#include "Utilities/LinkedReference/Reference.h"
+
+template <class TO, class FROM> class RefManager : public LinkedListHead
+{
+    public:
+        typedef LinkedListHead::Iterator< Reference<TO, FROM> > iterator;
+        RefManager() { }
+        virtual ~RefManager() { clearReferences(); }
+
+        Reference<TO, FROM>* getFirst() { return ((Reference<TO, FROM>*) LinkedListHead::getFirst()); }
+        Reference<TO, FROM> const* getFirst() const { return ((Reference<TO, FROM> const*) LinkedListHead::getFirst()); }
+        Reference<TO, FROM>* getLast() { return ((Reference<TO, FROM>*) LinkedListHead::getLast()); }
+        Reference<TO, FROM> const* getLast() const { return ((Reference<TO, FROM> const*) LinkedListHead::getLast()); }
+
+        iterator begin() { return iterator(getFirst()); }
+        iterator end() { return iterator(NULL); }
+        iterator rbegin() { return iterator(getLast()); }
+        iterator rend() { return iterator(NULL); }
+
+        void clearReferences()
+        {
+            LinkedListElement* ref;
+            while((ref = getFirst()) != NULL)
+            {
+                ((Reference<TO, FROM>*) ref)->invalidate();
+                ref->delink();                              // the delink might be already done by invalidate(), but doing it here again does not hurt and insures an empty list
+            }
+        }
+};
+
+//=====================================================
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Utilities/TypeList.h b/src/server/game/TriniChat/framework/Utilities/TypeList.h
new file mode 100644
index 0000000..f77580d
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/TypeList.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_TYPELIST_H
+#define TRINITY_TYPELIST_H
+
+/*
+  @struct TypeList
+  TypeList is the most simple but yet the most powerfull class of all.  It holds
+  at compile time the different type of objects in a linked list.
+ */
+
+class TypeNull;
+
+template<typename HEAD, typename TAIL>
+struct TypeList
+{
+    typedef HEAD Head;
+    typedef TAIL Tail;
+};
+
+// enough for now.. can be expand at any point in time as needed
+#define TYPELIST_1(T1)                  TypeList<T1,TypeNull>
+#define TYPELIST_2(T1, T2)              TypeList<T1, TYPELIST_1(T2) >
+#define TYPELIST_3(T1, T2, T3)          TypeList<T1, TYPELIST_2(T2, T3) >
+#define TYPELIST_4(T1, T2, T3, T4)      TypeList<T1, TYPELIST_3(T2, T3, T4) >
+#define TYPELIST_5(T1, T2, T3, T4, T5)  TypeList<T1, TYPELIST_4(T2, T3, T4, T5) >
+#endif
+// end
diff --git a/src/server/game/TriniChat/framework/Utilities/UnorderedMap.h b/src/server/game/TriniChat/framework/Utilities/UnorderedMap.h
new file mode 100644
index 0000000..2171e4d
--- /dev/null
+++ b/src/server/game/TriniChat/framework/Utilities/UnorderedMap.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef TRINITY_UNORDERED_MAP_H
+#define TRINITY_UNORDERED_MAP_H
+
+#include "Platform/CompilerDefs.h"
+#include "Platform/Define.h"
+
+#if COMPILER == COMPILER_INTEL
+#include <ext/hash_map>
+#elif COMPILER == COMPILER_GNU && (__GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 3)
+#include <tr1/unordered_map>
+#elif COMPILER == COMPILER_GNU && __GNUC__ >= 3
+#include <ext/hash_map>
+#elif COMPILER == COMPILER_MICROSOFT && _MSC_VER >= 1500 && _HAS_TR1    // VC9.0 and later
+#include <unordered_map>
+#else
+#include <hash_map>
+#endif
+
+#ifdef _STLPORT_VERSION
+#define UNORDERED_MAP std::hash_map
+using std::hash_map;
+#elif COMPILER == COMPILER_MICROSOFT && _MSC_VER >= 1500 && _HAS_TR1
+#define UNORDERED_MAP std::tr1::unordered_map
+#elif COMPILER == COMPILER_MICROSOFT && _MSC_VER >= 1300
+#define UNORDERED_MAP stdext::hash_map
+using stdext::hash_map;
+#elif COMPILER == COMPILER_INTEL
+#define UNORDERED_MAP std::hash_map
+using std::hash_map;
+#elif COMPILER == COMPILER_GNU && (__GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 3)
+#define UNORDERED_MAP std::tr1::unordered_map
+#elif COMPILER == COMPILER_GNU && __GNUC__ >= 3
+#define UNORDERED_MAP __gnu_cxx::hash_map
+
+namespace __gnu_cxx
+{
+    template<> struct hash<unsigned long long>
+    {
+        size_t operator()(const unsigned long long &__x) const { return (size_t)__x; }
+    };
+    template<typename T> struct hash<T *>
+    {
+        size_t operator()(T * const &__x) const { return (size_t)__x; }
+    };
+
+};
+
+#else
+#define UNORDERED_MAP std::hash_map
+using std::hash_map;
+#endif
+#endif
+// end
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 78470d4..74eaafa 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -72,14 +72,17 @@
 #include "CharacterDatabaseCleaner.h"
 #include "ScriptMgr.h"
 #include "WeatherMgr.h"
+#include "AuctionHouseBot.h"
 #include "CreatureTextMgr.h"
 #include "SmartAI.h"
 #include "Channel.h"
+#include "AnticheatMgr.h"
 #include "WardenCheckMgr.h"
 #include "Warden.h"
 #include "CalendarMgr.h"
 #include "BattlefieldMgr.h"
 #include "TransportMgr.h"
+#include "IRCClient.h"
 
 ACE_Atomic_Op<ACE_Thread_Mutex, bool> World::m_stopEvent = false;
 uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
@@ -669,6 +672,7 @@ void World::LoadConfigSettings(bool reload)
     m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD]   = sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Guild", false);
     m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION] = sConfigMgr->GetBoolDefault("AllowTwoSide.Interaction.Auction", false);
     m_bool_configs[CONFIG_ALLOW_TWO_SIDE_TRADE]               = sConfigMgr->GetBoolDefault("AllowTwoSide.trade", false);
+    m_bool_configs[CONFIG_FAKE_WHO_LIST]                      = sConfigMgr->GetBoolDefault("Fake.WHO.List", false);
     m_int_configs[CONFIG_STRICT_PLAYER_NAMES]                 = sConfigMgr->GetIntDefault ("StrictPlayerNames",  0);
     m_int_configs[CONFIG_STRICT_CHARTER_NAMES]                = sConfigMgr->GetIntDefault ("StrictCharterNames", 0);
     m_int_configs[CONFIG_STRICT_PET_NAMES]                    = sConfigMgr->GetIntDefault ("StrictPetNames",     0);
@@ -1046,6 +1050,8 @@ void World::LoadConfigSettings(bool reload)
 
     m_int_configs[CONFIG_CREATURE_PICKPOCKET_REFILL] = sConfigMgr->GetIntDefault("Creature.PickPocketRefillDelay", 10 * MINUTE);
 
+    m_bool_configs[BATTLEGROUND_CROSSFACTION_ENABLED]                = sConfigMgr->GetBoolDefault("CrossfactionBG.enable", true);
+
     if (int32 clientCacheId = sConfigMgr->GetIntDefault("ClientCacheVersion", 0))
     {
         // overwrite DB/old value
@@ -1229,6 +1235,11 @@ void World::LoadConfigSettings(bool reload)
     m_bool_configs[CONFIG_PDUMP_NO_OVERWRITE] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowOverwrite", true);
     m_bool_configs[CONFIG_UI_QUESTLEVELS_IN_DIALOGS] = sConfigMgr->GetBoolDefault("UI.ShowQuestLevelsInDialogs", false);
 
+    m_bool_configs[CONFIG_ANTICHEAT_ENABLE] = sConfigMgr->GetBoolDefault("Anticheat.Enable", true);
+    m_int_configs[CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION] = sConfigMgr->GetIntDefault("Anticheat.ReportsForIngameWarnings", 70);
+    m_int_configs[CONFIG_ANTICHEAT_DETECTIONS_ENABLED] = sConfigMgr->GetIntDefault("Anticheat.DetectionsEnabled",31);
+    m_int_configs[CONFIG_ANTICHEAT_MAX_REPORTS_FOR_DAILY_REPORT] = sConfigMgr->GetIntDefault("Anticheat.MaxReportsForDailyReport",70);
+
     // Wintergrasp battlefield
     m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfigMgr->GetBoolDefault("Wintergrasp.Enable", false);
     m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMax", 100);
@@ -1259,9 +1270,169 @@ void World::LoadConfigSettings(bool reload)
 
     m_bool_configs[CONFIG_IP_BASED_LOGIN_LOGGING] = sConfigMgr->GetBoolDefault("Wrong.Password.Login.Logging", false);
 
+    //Guild-Level-System
+    LoadGuildBonusInfo();
+
     // call ScriptMgr if we're reloading the configuration
     if (reload)
         sScriptMgr->OnConfigLoad(reload);
+    sScriptMgr->OnConfigLoad(reload);
+
+    // IRC Configurations.
+    int ConfCnt = 0;
+    sIRC._chan_count = 0;
+    if (sConfigMgr->GetIntDefault("irc.active", 1) == 1)
+        sIRC.Active = true;
+    else
+        sIRC.Active = false;
+
+    sIRC._Host = sConfigMgr->GetStringDefault("irc.host", "irc.freenode.net");
+    if (sIRC._Host.size() > 0)
+        ConfCnt++;
+    sIRC._Mver = "Version 3.0.0";
+    sIRC._Port = sConfigMgr->GetIntDefault("irc.port", 6667);
+    sIRC._User = sConfigMgr->GetStringDefault("irc.user", "TriniChat");
+    sIRC._Pass = sConfigMgr->GetStringDefault("irc.pass", "Services Password");
+    sIRC._Nick = sConfigMgr->GetStringDefault("irc.nick", "TriniChat");
+    sIRC._Auth = sConfigMgr->GetIntDefault("irc.auth", 0);
+    sIRC._Auth_Nick = sConfigMgr->GetStringDefault("irc.auth.nick", "AuthNick");
+    sIRC._ICC = sConfigMgr->GetStringDefault("irc.icc", "001");
+    sIRC._defchan = sConfigMgr->GetStringDefault("irc.defchan", "lobby");
+    sIRC._ldefc = sConfigMgr->GetIntDefault("irc.ldef", 0);
+    sIRC._wct = sConfigMgr->GetIntDefault("irc.wct", 30000);
+    sIRC.ajoin = sConfigMgr->GetIntDefault("irc.ajoin", 1);
+    sIRC.ajchan = sConfigMgr->GetStringDefault("irc.ajchan", "world");
+    sIRC.onlrslt = sConfigMgr->GetIntDefault("irc.online.result", 10);
+    sIRC.BOTMASK = sConfigMgr->GetIntDefault("Botmask", 0);
+    sIRC.logfile = sConfigMgr->GetStringDefault("irc.logfile.prefix", "IRC_");
+    sIRC.logmask = sConfigMgr->GetIntDefault("irc.logmask", 0);
+    sIRC.logchan = sConfigMgr->GetStringDefault("irc.logchannel","");
+    sIRC.logchanpw = sConfigMgr->GetStringDefault("irc.logchannelpassword","");
+    for (int i = 1; i < MAX_CONF_CHANNELS;i++)
+    {
+        std::ostringstream ss;
+        ss << i;
+        std::string ci = "irc.chan_" + ss.str();
+        std::string pw = "irc.pass_" + ss.str();
+        std::string t_chan = sConfigMgr->GetStringDefault(ci.c_str(), "");
+        if (t_chan.size() > 0)
+        {
+            sIRC._chan_count++;
+            sIRC._irc_chan[sIRC._chan_count] = t_chan;
+            sIRC._irc_pass[sIRC._chan_count] = sConfigMgr->GetStringDefault(pw.c_str(), t_chan.c_str());
+            ci = "wow.chan_" + ss.str();
+            sIRC._wow_chan[sIRC._chan_count] = sConfigMgr->GetStringDefault(ci.c_str(), t_chan.c_str());
+        }
+    }
+    sIRC.JoinMsg = sConfigMgr->GetStringDefault("irc.joinmsg", "TriniChat2 $Ver for Trinitycore 3.3.5a Maintained by LordPsyan of Infinitycore http://www.infinitycore.org/");
+    sIRC.RstMsg  = sConfigMgr->GetStringDefault("irc.rstmsg", "TriniChat Is Restarting, I Will Be Right Back!");
+    sIRC.kikmsg = sConfigMgr->GetStringDefault("irc.kickmsg", "Do Not Kick Me Again, Severe Actions Will Be Taken!");
+    // IRC LINES
+    sIRC.ILINES[WOW_IRC] = sConfigMgr->GetStringDefault("chat.wow_irc", "\003<WoW>[\002$Name($Level)\002\003] $Msg");
+    sIRC.ILINES[IRC_WOW] = sConfigMgr->GetStringDefault("chat.irc_wow", "\003<IRC>[$Name]: $Msg");
+    sIRC.ILINES[JOIN_WOW] = sConfigMgr->GetStringDefault("chat.join_wow", "\00312>>\00304 $Name \003Joined The Channel!");
+    sIRC.ILINES[JOIN_IRC] = sConfigMgr->GetStringDefault("chat.join_irc", "\003[$Name]: Has Joined IRC!");
+    sIRC.ILINES[LEAVE_WOW] = sConfigMgr->GetStringDefault("chat.leave_wow", "\00312<<\00304 $Name \003Left The Channel!");
+    sIRC.ILINES[LEAVE_IRC] = sConfigMgr->GetStringDefault("chat.leave_irc", "\003[$Name]: Has Left IRC!");
+    sIRC.ILINES[CHANGE_NICK] = sConfigMgr->GetStringDefault("chat.change_nick", "\003<> $Name Is Now Known As $NewName!");
+    // TriniChat Options
+    sIRC._MCA = sConfigMgr->GetIntDefault("irc.maxattempt", 10);
+    sIRC._autojoinkick = sConfigMgr->GetIntDefault("irc.autojoin_kick", 1);
+    sIRC._cmd_prefx = sConfigMgr->GetStringDefault("irc.command_prefix", ".");
+
+    sIRC._op_gm = sConfigMgr->GetIntDefault("irc.op_gm_login", 0);
+    sIRC._op_gm_lev = sConfigMgr->GetIntDefault("irc.op_gm_level", 3);
+
+    // Misc Options
+    sIRC.games = sConfigMgr->GetIntDefault("irc.fun.games", 0);
+    sIRC.gmlog = sConfigMgr->GetIntDefault("irc.gmlog", 1);
+    sIRC.BOTMASK = sConfigMgr->GetIntDefault("BotMask", 0);
+    sIRC.Status = sConfigMgr->GetIntDefault("irc.StatusChannel", 1);
+    sIRC.anchn = sConfigMgr->GetIntDefault("irc.AnnounceChannel", 1);
+    sIRC.autoanc = sConfigMgr->GetIntDefault("irc.auto.announce", 30);
+    sIRC.ojGM1 = sConfigMgr->GetStringDefault("irc.gm1", "[VIP]");
+    sIRC.ojGM2 = sConfigMgr->GetStringDefault("irc.gm2", "[Donator]");
+    sIRC.ojGM3 = sConfigMgr->GetStringDefault("irc.gm3", "[Bug Tracker]");
+    sIRC.ojGM4 = sConfigMgr->GetStringDefault("irc.gm4", "[Moderator]");
+    sIRC.ojGM5 = sConfigMgr->GetStringDefault("irc.gm5", "[Game Master]");
+    sIRC.ojGM6 = sConfigMgr->GetStringDefault("irc.gm6", "[Admin]");
+    sIRC.ojGM7 = sConfigMgr->GetStringDefault("irc.gm7", "[Developer]");
+    sIRC.ojGM8 = sConfigMgr->GetStringDefault("irc.gm8", "[Owner]");
+    // REQUIRED GM LEVEL
+    QueryResult result = WorldDatabase.PQuery("SELECT `Command`, `gmlevel` FROM `irc_commands` ORDER BY `Command`");
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        for (uint64 i=0; i < result->GetRowCount(); i++)
+        {
+            //TODO: ELSEIF? STRCMP?
+            std::string command = fields[0].GetCString();
+            uint32 gmlvl = fields[1].GetUInt32();
+            if (command == "acct") sIRC.CACCT = gmlvl;
+            if (command == "ban") sIRC.CBAN = gmlvl;
+            if (command == "char") sIRC.CCHAN = gmlvl;
+            if (command == "char") sIRC.CCHAR = gmlvl;
+            if (command == "fun") sIRC.CFUN = gmlvl;
+            if (command == "help") sIRC.CHELP = gmlvl;
+            if (command == "inchan") sIRC.CINCHAN = gmlvl;
+            if (command == "info") sIRC.CINFO = gmlvl;
+            if (command == "item") sIRC.CITEM = gmlvl;
+            if (command == "jail") sIRC.CJAIL = gmlvl;
+            if (command == "kick") sIRC.CKICK = gmlvl;
+            if (command == "kill") sIRC._KILL = gmlvl;
+            if (command == "level") sIRC.CLEVEL = gmlvl;
+            if (command == "lookup") sIRC.CLOOKUP = gmlvl;
+            if (command == "money") sIRC.CMONEY = gmlvl;
+            if (command == "mute") sIRC.CMUTE = gmlvl;
+            if (command == "online") sIRC.CONLINE = gmlvl;
+            if (command == "pm") sIRC.CPM = gmlvl;
+            if (command == "reconnect") sIRC.CRECONNECT = gmlvl;
+            if (command == "reload") sIRC.CRELOAD = gmlvl;
+            if (command == "restart") sIRC.CSHUTDOWN = gmlvl;
+            if (command == "revive") sIRC.CREVIVE = gmlvl;
+            if (command == "saveall") sIRC.CSAVEALL = gmlvl;
+            if (command == "server") sIRC.CSERVERCMD = gmlvl;
+            if (command == "shutdown") sIRC.CSHUTDOWN = gmlvl;
+            if (command == "spell") sIRC.CSPELL = gmlvl;
+            if (command == "sysmsg") sIRC.CSYSMSG = gmlvl;
+            if (command == "tele") sIRC.CTELE = gmlvl;
+            if (command == "top") sIRC.CTOP = gmlvl;
+            if (command == "who") sIRC.CWHO = gmlvl;
+            result->NextRow();
+        }
+    }
+    else
+    {
+        sIRC.CACCT     = 3;
+        sIRC.CBAN      = 3;
+        sIRC.CCHAN     = 3;
+        sIRC.CCHAR     = 3;
+        sIRC.CFUN      = 3;
+        sIRC.CHELP     = 3;
+        sIRC.CINCHAN   = 3;
+        sIRC.CINFO     = 3;
+        sIRC.CITEM     = 3;
+        sIRC.CJAIL     = 3;
+        sIRC.CKICK     = 3;
+        sIRC._KILL     = 3;
+        sIRC.CLEVEL    = 3;
+        sIRC.CLOOKUP   = 3;
+        sIRC.CMONEY    = 3;
+        sIRC.CMUTE     = 3;
+        sIRC.CONLINE   = 3;
+        sIRC.CPM       = 3;
+        sIRC.CRECONNECT= 3;
+        sIRC.CRELOAD   = 3;
+        sIRC.CREVIVE   = 3;
+        sIRC.CSAVEALL  = 3;
+        sIRC.CSERVERCMD= 3;
+        sIRC.CSHUTDOWN = 3;
+        sIRC.CSPELL    = 3;
+        sIRC.CSYSMSG   = 3;
+        sIRC.CTELE     = 3;
+        sIRC.CTOP      = 3;
+        sIRC.CWHO      = 3;
+    }
 }
 
 extern void LoadGameObjectModelList();
@@ -1280,6 +1451,7 @@ void World::SetInitialWorldSettings()
 
     ///- Initialize config settings
     LoadConfigSettings();
+    TC_LOG_ERROR("misc" "Loading TrinityCore configuration settings...","");
 
     ///- Initialize Allowed Security Level
     LoadDBAllowedSecurityLevel();
@@ -1443,6 +1615,9 @@ void World::SetInitialWorldSettings()
     TC_LOG_INFO("server.loading", "Loading Creature templates...");
     sObjectMgr->LoadCreatureTemplates();
 
+    TC_LOG_INFO("server.loading", "Loading Creature template outfits...");     // must be after LoadCreatureTemplates
+    sObjectMgr->LoadCreatureOutfits();
+
     TC_LOG_INFO("server.loading", "Loading Equipment templates...");           // must be after LoadCreatureTemplates
     sObjectMgr->LoadEquipmentTemplates();
 
@@ -1605,6 +1780,9 @@ void World::SetInitialWorldSettings()
     TC_LOG_INFO("server.loading", "Loading Completed Achievements...");
     sAchievementMgr->LoadCompletedAchievements();
 
+    // Initialize AHBot settings before deleting expired auctions due to AHBot hooks
+    auctionbot.InitializeConfiguration();
+
     // Delete expired auctions before loading
     TC_LOG_INFO("server.loading", "Deleting expired auctions...");
     sAuctionMgr->DeleteExpiredAuctionsAtStartup();
@@ -1733,6 +1911,9 @@ void World::SetInitialWorldSettings()
     LoginDatabase.PExecute("INSERT INTO uptime (realmid, starttime, uptime, revision) VALUES(%u, %u, 0, '%s')",
                             realmID, uint32(m_startTime), _FULLVERSION);       // One-time query
 
+    static uint32 autoanc = 1;
+    autoanc = sIRC.autoanc;
+
     m_timers[WUPDATE_WEATHERS].SetInterval(1*IN_MILLISECONDS);
     m_timers[WUPDATE_AUCTIONS].SetInterval(MINUTE*IN_MILLISECONDS);
     m_timers[WUPDATE_UPTIME].SetInterval(m_int_configs[CONFIG_UPTIME_UPDATE]*MINUTE*IN_MILLISECONDS);
@@ -1746,6 +1927,8 @@ void World::SetInitialWorldSettings()
 
     m_timers[WUPDATE_PINGDB].SetInterval(getIntConfig(CONFIG_DB_PING_INTERVAL)*MINUTE*IN_MILLISECONDS);    // Mysql ping time in minutes
 
+    m_timers[WUPDATE_AUTOANC].SetInterval(autoanc*MINUTE*1000);
+
     //to set mailtimer to return mails every day between 4 and 5 am
     //mailtimer is increased when updating auctions
     //one second is 1000 -(tested on win system)
@@ -1822,6 +2005,9 @@ void World::SetInitialWorldSettings()
 
     LoadCharacterNameData();
 
+    TC_LOG_INFO("server.loading", "Initialize AuctionHouseBot...");
+    auctionbot.Initialize();
+
     uint32 startupDuration = GetMSTimeDiffToNow(startupBegin);
 
     TC_LOG_INFO("server.worldserver", "World initialized in %u minutes %u seconds", (startupDuration / 60000), ((startupDuration % 60000) / 1000));
@@ -1989,6 +2175,7 @@ void World::Update(uint32 diff)
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
+        auctionbot.Update();
         m_timers[WUPDATE_AUCTIONS].Reset();
 
         ///- Update mails (return old mails with item, or delete them)
@@ -2113,6 +2300,12 @@ void World::Update(uint32 diff)
         WorldDatabase.KeepAlive();
     }
 
+    if (m_timers[WUPDATE_AUTOANC].Passed())
+    {
+        m_timers[WUPDATE_AUTOANC].Reset();
+        SendRNDBroadcastIRC();
+    }
+
     // update the instance reset times
     sInstanceSaveMgr->Update();
 
@@ -2728,6 +2921,20 @@ void World::SendAutoBroadcast()
     TC_LOG_DEBUG("misc", "AutoBroadcast: '%s'", msg.c_str());
 }
 
+void World::SendRNDBroadcastIRC()
+{
+    std::string msg;
+    QueryResult result = WorldDatabase.PQuery("SELECT `message` FROM `irc_autoannounce` ORDER BY RAND() LIMIT 1");
+    if (!result)
+        return;
+    msg = result->Fetch()[0].GetString();
+
+    sWorld->SendWorldText(6612,msg.c_str());
+    std::string ircchan = "#";
+    ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+    sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 Automatic System Message \00304,08\037/!\\\037\017 %s", "%s", msg.c_str()), true);
+}
+
 void World::UpdateRealmCharCount(uint32 accountId)
 {
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_COUNT);
@@ -2875,6 +3082,8 @@ void World::ResetDailyQuests()
 
     // change available dailies
     sPoolMgr->ChangeDailyQuests();
+
+    sAnticheatMgr->ResetDailyReportStates();
 }
 
 void World::LoadDBAllowedSecurityLevel()
@@ -3206,3 +3415,87 @@ void World::ReloadRBAC()
         if (WorldSession* session = itr->second)
             session->InvalidateRBACData();
 }
+
+//Guild-Level-System [Start]
+void World::LoadGuildBonusInfo()
+{
+    //Moechte keinen riesigen Abschnitt in die Worldconf hinzufuegen, deswegen
+    //soll das ganze ueber eine Tabelle in der CharDB geregelt werden.
+    //Hier werden die benoetigten Daten geladen.
+    m_req_guildLevel_gold_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_GOLD_1);
+    m_req_guildLevel_xp_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_XP_1);
+    m_req_guildLevel_schneller_geist = SelectReqGuildLevelForBonus(GUILD_BONUS_SCHNELLER_GEIST);
+    m_req_guildLevel_reperatur_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_REPERATUR_1);
+    m_req_guildLevel_gold_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_GOLD_2);
+    m_req_guildLevel_reittempo_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_REITTEMPO_1);
+    m_req_guildLevel_reputation_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_RUF_1);
+    m_req_guildLevel_xp_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_XP_2);
+    m_req_guildLevel_reperatur_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_REPERATUR_2);
+    m_req_guildLevel_reittempo_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_REITTEMPO_2);
+    m_req_guildLevel_reputation_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_RUF_2);
+    m_req_guildLevel_honor_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_EHRE_1);
+    m_req_guildLevel_honor_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_EHRE_2);
+}
+
+uint8 World::SelectReqGuildLevelForBonus(uint8 guildBonus)
+{
+    PreparedStatement* stmt;
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_BONUS_INFO);
+    stmt->setUInt8(0, guildBonus);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+        return (*result)[0].GetUInt8();
+    else
+        return 0;
+}
+
+uint8 World::GetReqGuildLevelForBonus(uint8 guildBonus)
+{
+    switch (guildBonus)
+    {
+    case GUILD_BONUS_GOLD_1:
+        return m_req_guildLevel_gold_1;
+        break;
+    case GUILD_BONUS_GOLD_2:
+        return m_req_guildLevel_gold_2;
+        break;
+    case GUILD_BONUS_EHRE_1:
+        return m_req_guildLevel_honor_1;
+        break;
+    case GUILD_BONUS_EHRE_2:
+        return m_req_guildLevel_honor_2;
+        break;
+    case GUILD_BONUS_REITTEMPO_1:
+        return m_req_guildLevel_reittempo_1;
+        break;
+    case GUILD_BONUS_REITTEMPO_2:
+        return m_req_guildLevel_reittempo_2;
+        break;
+    case GUILD_BONUS_REPERATUR_1:
+        return m_req_guildLevel_reperatur_1;
+        break;
+    case GUILD_BONUS_REPERATUR_2:
+        return m_req_guildLevel_reperatur_2;
+        break;
+    case GUILD_BONUS_RUF_1:
+        return m_req_guildLevel_reputation_1;
+        break;
+    case GUILD_BONUS_RUF_2:
+        return m_req_guildLevel_reputation_2;
+        break;
+    case GUILD_BONUS_SCHNELLER_GEIST:
+        return m_req_guildLevel_schneller_geist;
+        break;
+    case GUILD_BONUS_XP_1:
+        return m_req_guildLevel_xp_1;
+        break;
+    case GUILD_BONUS_XP_2:
+        return m_req_guildLevel_xp_2;
+        break;
+    default:
+        return 0;
+        break;
+    }
+}
+//Guild-Level-System [End]
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 61acdc3..217e26a 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -75,6 +75,7 @@ enum WorldTimers
     WUPDATE_EVENTS,
     WUPDATE_CLEANDB,
     WUPDATE_AUTOBROADCAST,
+    WUPDATE_AUTOANC,
     WUPDATE_MAILBOXQUEUE,
     WUPDATE_DELETECHARS,
     WUPDATE_PINGDB,
@@ -85,6 +86,7 @@ enum WorldTimers
 enum WorldBoolConfigs
 {
     CONFIG_DURABILITY_LOSS_IN_PVP = 0,
+    BATTLEGROUND_CROSSFACTION_ENABLED,
     CONFIG_ADDON_CHANNEL,
     CONFIG_ALLOW_PLAYER_COMMANDS,
     CONFIG_CLEAN_CHARACTER_DB,
@@ -96,6 +98,7 @@ enum WorldBoolConfigs
     CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD,
     CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION,
     CONFIG_ALLOW_TWO_SIDE_TRADE,
+    CONFIG_FAKE_WHO_LIST,
     CONFIG_ALL_TAXI_PATHS,
     CONFIG_INSTANT_TAXI,
     CONFIG_INSTANCE_IGNORE_LEVEL,
@@ -143,6 +146,7 @@ enum WorldBoolConfigs
     CONFIG_ALLOW_TICKETS,
     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
     CONFIG_PRESERVE_CUSTOM_CHANNELS,
+    CONFIG_ANTICHEAT_ENABLE,
     CONFIG_PDUMP_NO_PATHS,
     CONFIG_PDUMP_NO_OVERWRITE,
     CONFIG_QUEST_IGNORE_AUTO_ACCEPT,
@@ -309,7 +313,10 @@ enum WorldIntConfigs
     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
     CONFIG_LFG_OPTIONSMASK,
+    CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION,
+    CONFIG_ANTICHEAT_MAX_REPORTS_FOR_DAILY_REPORT,
     CONFIG_MAX_INSTANCES_PER_HOUR,
+    CONFIG_ANTICHEAT_DETECTIONS_ENABLED,
     CONFIG_WARDEN_CLIENT_RESPONSE_DELAY,
     CONFIG_WARDEN_CLIENT_CHECK_HOLDOFF,
     CONFIG_WARDEN_CLIENT_FAIL_ACTION,
@@ -529,6 +536,9 @@ class World
         void AddSession(WorldSession* s);
         void SendAutoBroadcast();
         bool RemoveSession(uint32 id);
+
+        void SendRNDBroadcastIRC();
+
         /// Get the number of current active sessions
         void UpdateMaxSessionCounters();
         const SessionMap& GetAllSessions() const { return m_sessions; }
@@ -742,6 +752,11 @@ class World
 
         void ReloadRBAC();
 
+        //Guild-Level-System
+        void LoadGuildBonusInfo();
+        uint8 GetReqGuildLevelForBonus(uint8 guildBonus);
+        uint8 SelectReqGuildLevelForBonus(uint8 guildBonus);
+
     protected:
         void _UpdateGameTime();
         // callback for UpdateRealmCharacters
@@ -841,6 +856,21 @@ class World
 
         void ProcessQueryCallbacks();
         ACE_Future_Set<PreparedQueryResult> m_realmCharCallbacks;
+
+        //Guild-Level-System
+        uint8 m_req_guildLevel_gold_1;
+        uint8 m_req_guildLevel_xp_1;
+        uint8 m_req_guildLevel_schneller_geist;
+        uint8 m_req_guildLevel_reperatur_1;
+        uint8 m_req_guildLevel_gold_2;
+        uint8 m_req_guildLevel_reittempo_1;
+        uint8 m_req_guildLevel_reputation_1;
+        uint8 m_req_guildLevel_xp_2;
+        uint8 m_req_guildLevel_reperatur_2;
+        uint8 m_req_guildLevel_reittempo_2;
+        uint8 m_req_guildLevel_reputation_2;
+        uint8 m_req_guildLevel_honor_1;
+        uint8 m_req_guildLevel_honor_2;
 };
 
 extern uint32 realmID;
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index 9385202..2c84839 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -24,6 +24,9 @@ include(Examples/CMakeLists.txt)
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.h
   ../game/AI/ScriptedAI/ScriptedEscortAI.cpp
   ../game/AI/ScriptedAI/ScriptedCreature.cpp
   ../game/AI/ScriptedAI/ScriptedFollowerAI.cpp
@@ -71,6 +74,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Database
   ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Anticheat
   ${CMAKE_SOURCE_DIR}/src/server/game/Achievements
   ${CMAKE_SOURCE_DIR}/src/server/game/Addons
   ${CMAKE_SOURCE_DIR}/src/server/game/AI
@@ -78,6 +82,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse/AuctionHouseBot
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
@@ -134,6 +139,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
   ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/TriniChat
   ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
   ${CMAKE_SOURCE_DIR}/src/server/game/Tools
   ${CMAKE_SOURCE_DIR}/src/server/game/Warden
diff --git a/src/server/scripts/Commands/cs_ah_bot.cpp b/src/server/scripts/Commands/cs_ah_bot.cpp
new file mode 100644
index 0000000..2a96cb0
--- /dev/null
+++ b/src/server/scripts/Commands/cs_ah_bot.cpp
@@ -0,0 +1,482 @@
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* ScriptData
+Name: ah_bot_commandscript
+%Complete: 100
+Comment: All ah_bot related commands
+Category: commandscripts
+EndScriptData */
+
+#include "ScriptMgr.h"
+#include "Chat.h"
+#include "AuctionHouseBot.h"
+
+class ah_bot_commandscript : public CommandScript
+{
+public:
+    ah_bot_commandscript() : CommandScript("ah_bot_commandscript") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand commandTable[] =
+        {
+            { "ahbotoptions",   SEC_GAMEMASTER,     true,   &HandleAHBotOptionsCommand,     "", NULL },
+            { NULL,             0,                  false,  NULL,                           "", NULL }
+        };
+        return commandTable;
+    }
+
+    static bool HandleAHBotOptionsCommand(ChatHandler* handler, const char*args)
+    {
+        uint32 ahMapID = 0;
+        char* opt = strtok((char*)args, " ");
+        char* ahMapIdStr = strtok(NULL, " ");
+
+        if (ahMapIdStr)
+        {
+            ahMapID = uint32(strtoul(ahMapIdStr, NULL, 0));
+            switch (ahMapID)
+            {
+                case 2:
+                case 6:
+                case 7:
+                    break;
+                default:
+                    opt = NULL;
+                    break;
+            }
+        }
+
+        if (!opt)
+        {
+            handler->PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+            handler->PSendSysMessage("Try ahbotoptions help to see a list of options.");
+            return false;
+        }
+
+        int l = strlen(opt);
+
+        if (strncmp(opt, "help", l) == 0)
+        {
+            handler->PSendSysMessage("AHBot commands:");
+            handler->PSendSysMessage("ahexpire");
+            handler->PSendSysMessage("minitems");
+            handler->PSendSysMessage("maxitems");
+            //handler->PSendSysMessage("");
+            //handler->PSendSysMessage("");
+            handler->PSendSysMessage("percentages");
+            handler->PSendSysMessage("minprice");
+            handler->PSendSysMessage("maxprice");
+            handler->PSendSysMessage("minbidprice");
+            handler->PSendSysMessage("maxbidprice");
+            handler->PSendSysMessage("maxstack");
+            handler->PSendSysMessage("buyerprice");
+            handler->PSendSysMessage("bidinterval");
+            handler->PSendSysMessage("bidsperinterval");
+            return true;
+        }
+        else if (strncmp(opt, "ahexpire", l) == 0)
+        {
+            if (!ahMapIdStr)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions ahexpire $ahMapID (2, 6 or 7)");
+                return false;
+            }
+
+            auctionbot.Commands(0, ahMapID, NULL, NULL);
+        }
+        else if (strncmp(opt, "minitems", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            if (!ahMapIdStr || !param1)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions minitems $ahMapID (2, 6 or 7) $minItems");
+                return false;
+            }
+
+            auctionbot.Commands(1, ahMapID, NULL, param1);
+        }
+        else if (strncmp(opt, "maxitems", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            if (!ahMapIdStr || !param1)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxitems $ahMapID (2, 6 or 7) $maxItems");
+                return false;
+            }
+
+            auctionbot.Commands(2, ahMapID, NULL, param1);
+        }
+        else if (strncmp(opt, "mintime", l) == 0)
+        {
+            handler->PSendSysMessage("ahbotoptions mintime has been deprecated");
+            return false;
+            /*
+            char* param1 = strtok(NULL, " ");
+            if (!ahMapIdStr || !param1)
+            {
+                PSendSysMessage("Syntax is: ahbotoptions mintime $ahMapID (2, 6 or 7) $mintime");
+                return false;
+            }
+
+            auctionbot.Commands(3, ahMapID, NULL, param1);
+            */
+        }
+        else if (strncmp(opt, "maxtime", l) == 0)
+        {
+            handler->PSendSysMessage("ahbotoptions maxtime has been deprecated");
+            return false;
+            /*
+            char* param1 = strtok(NULL, " ");
+            if (!ahMapIdStr || !param1)
+            {
+                PSendSysMessage("Syntax is: ahbotoptions maxtime $ahMapID (2, 6 or 7) $maxtime");
+                return false;
+            }
+
+            auctionbot.Commands(4, ahMapID, NULL, param1);
+            */
+        }
+        else if (strncmp(opt, "percentages", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+            char* param3 = strtok(NULL, " ");
+            char* param4 = strtok(NULL, " ");
+            char* param5 = strtok(NULL, " ");
+            char* param6 = strtok(NULL, " ");
+            char* param7 = strtok(NULL, " ");
+            char* param8 = strtok(NULL, " ");
+            char* param9 = strtok(NULL, " ");
+            char* param10 = strtok(NULL, " ");
+            char* param11 = strtok(NULL, " ");
+            char* param12 = strtok(NULL, " ");
+            char* param13 = strtok(NULL, " ");
+            char* param14 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param14)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+                handler->PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+                handler->PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+                handler->PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+                handler->PSendSysMessage("The total must add up to 100%%");
+                return false;
+            }
+
+            uint32 greytg = uint32(strtoul(param1, NULL, 0));
+            uint32 whitetg = uint32(strtoul(param2, NULL, 0));
+            uint32 greentg = uint32(strtoul(param3, NULL, 0));
+            uint32 bluetg = uint32(strtoul(param3, NULL, 0));
+            uint32 purpletg = uint32(strtoul(param5, NULL, 0));
+            uint32 orangetg = uint32(strtoul(param6, NULL, 0));
+            uint32 yellowtg = uint32(strtoul(param7, NULL, 0));
+            uint32 greyi = uint32(strtoul(param8, NULL, 0));
+            uint32 whitei = uint32(strtoul(param9, NULL, 0));
+            uint32 greeni = uint32(strtoul(param10, NULL, 0));
+            uint32 bluei = uint32(strtoul(param11, NULL, 0));
+            uint32 purplei = uint32(strtoul(param12, NULL, 0));
+            uint32 orangei = uint32(strtoul(param13, NULL, 0));
+            uint32 yellowi = uint32(strtoul(param14, NULL, 0));
+            uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+
+            if (totalPercent == 0 || totalPercent != 100)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+                handler->PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+                handler->PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+                handler->PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+                handler->PSendSysMessage("The total must add up to 100%%");
+                return false;
+            }
+
+            char param[100];
+            param[0] = '\0';
+            strcat(param, param1);
+            strcat(param, " ");
+            strcat(param, param2);
+            strcat(param, " ");
+            strcat(param, param3);
+            strcat(param, " ");
+            strcat(param, param4);
+            strcat(param, " ");
+            strcat(param, param5);
+            strcat(param, " ");
+            strcat(param, param6);
+            strcat(param, " ");
+            strcat(param, param7);
+            strcat(param, " ");
+            strcat(param, param8);
+            strcat(param, " ");
+            strcat(param, param9);
+            strcat(param, " ");
+            strcat(param, param10);
+            strcat(param, " ");
+            strcat(param, param11);
+            strcat(param, " ");
+            strcat(param, param12);
+            strcat(param, " ");
+            strcat(param, param13);
+            strcat(param, " ");
+            strcat(param, param14);
+            auctionbot.Commands(5, ahMapID, NULL, param);
+        }
+        else if (strncmp(opt, "minprice", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+
+            if (strncmp(param1, "grey", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, "orange", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "maxprice", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+            if (!ahMapIdStr || !param1 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+            if (strncmp(param1, "grey", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, "orange",l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "minbidprice", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param2 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+
+            uint32 minBidPrice = uint32(strtoul(param2, NULL, 0));
+            if (minBidPrice < 1 || minBidPrice > 100)
+            {
+                handler->PSendSysMessage("The min bid price multiplier must be between 1 and 100");
+                return false;
+            }
+
+            if (strncmp(param1, "grey", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, "orange", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "maxbidprice", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+
+            uint32 maxBidPrice = uint32(strtoul(param2, NULL, 0));
+            if (maxBidPrice < 1 || maxBidPrice > 100)
+            {
+                handler->PSendSysMessage("The max bid price multiplier must be between 1 and 100");
+                return false;
+            }
+
+            if (strncmp(param1, "grey", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, " orange", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions max bidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "maxstack",l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+                return false;
+            }
+
+            // uint32 maxStack = uint32(strtoul(param2, NULL, 0));
+            // if (maxStack < 0)
+            // {
+            //     handler->PSendSysMessage("maxstack can't be a negative number.");
+            //    return false;
+            // }
+
+            if (strncmp(param1, "grey",l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, "orange", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "buyerprice", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+                return false;
+            }
+
+            if (strncmp(param1, "grey", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, "orange", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "bidinterval", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions bidinterval $ahMapID (2, 6 or 7) $interval(in minutes)");
+                return false;
+            }
+
+            auctionbot.Commands(12, ahMapID, NULL, param1);
+        }
+        else if (strncmp(opt, "bidsperinterval", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions bidsperinterval $ahMapID (2, 6 or 7) $bids");
+                return false;
+            }
+
+            auctionbot.Commands(13, ahMapID, NULL, param1);
+        }
+        else
+        {
+            handler->PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+            handler->PSendSysMessage("Try ahbotoptions help to see a list of options.");
+            return false;
+        }
+
+        return true;
+    }
+};
+
+void AddSC_ah_bot_commandscript()
+{
+    new ah_bot_commandscript();
+}
diff --git a/src/server/scripts/Commands/cs_anticheat.cpp b/src/server/scripts/Commands/cs_anticheat.cpp
new file mode 100644
index 0000000..3cc6784
--- /dev/null
+++ b/src/server/scripts/Commands/cs_anticheat.cpp
@@ -0,0 +1,262 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+#include "Language.h"
+#include "ScriptMgr.h"
+#include "ObjectMgr.h"
+#include "Chat.h"
+#include "AnticheatMgr.h"
+
+class anticheat_commandscript : public CommandScript
+{
+public:
+    anticheat_commandscript() : CommandScript("anticheat_commandscript") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand anticheatCommandTable[] =
+        {
+            { "global",         SEC_GAMEMASTER,     true,  &HandleAntiCheatGlobalCommand,         "", NULL },
+            { "player",         SEC_GAMEMASTER,     true,  &HandleAntiCheatPlayerCommand,         "", NULL },
+            { "delete",         SEC_ADMINISTRATOR,  true,  &HandleAntiCheatDeleteCommand,         "", NULL },
+            { "handle",         SEC_ADMINISTRATOR,  true,  &HandleAntiCheatHandleCommand,         "", NULL },
+            { "jail",           SEC_GAMEMASTER,     true,  &HandleAnticheatJailCommand,         "", NULL },
+            { "warn",           SEC_GAMEMASTER,     true,  &HandleAnticheatWarnCommand,         "", NULL },
+            { NULL,             0,                     false, NULL,                                           "", NULL }
+        };
+
+        static ChatCommand commandTable[] =
+        {
+            { "anticheat",      SEC_GAMEMASTER,     true, NULL,                     "",  anticheatCommandTable},
+            { NULL,             0,                  false, NULL,                               "", NULL }
+        };
+
+        return commandTable;
+    }
+
+    static bool HandleAnticheatWarnCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        Player* pTarget = NULL;
+
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        if (command)
+        {
+            strCommand = command;
+            normalizePlayerName(strCommand);
+
+            pTarget = sObjectAccessor->FindPlayerByName(strCommand.c_str()); //get player by name
+        }else
+            pTarget = handler->getSelectedPlayer();
+
+        if (!pTarget)
+            return false;
+
+        WorldPacket data;
+
+        // need copy to prevent corruption by strtok call in LineFromMessage original string
+        char* buf = strdup("The anticheat system has reported several times that you may be cheating. You will be monitored to confirm if this is accurate.");
+        char* pos = buf;
+
+        while (char* line = handler->LineFromMessage(pos))
+        {
+            handler->BuildChatPacket(data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, line);
+            pTarget->GetSession()->SendPacket(&data);
+        }
+
+        free(buf);
+        return true;
+    }
+
+    static bool HandleAnticheatJailCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        Player* pTarget = NULL;
+
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        if (command)
+        {
+            strCommand = command;
+            normalizePlayerName(strCommand);
+
+            pTarget = sObjectAccessor->FindPlayerByName(strCommand.c_str()); //get player by name
+        }else
+            pTarget = handler->getSelectedPlayer();
+
+        if (!pTarget)
+        {
+            handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (pTarget == handler->GetSession()->GetPlayer())
+            return false;
+
+        // teleport both to jail.
+        pTarget->TeleportTo(1,16226.5f,16403.6f,-64.5f,3.2f);
+        handler->GetSession()->GetPlayer()->TeleportTo(1,16226.5f,16403.6f,-64.5f,3.2f);
+
+        WorldLocation loc;
+
+        // the player should be already there, but no :(
+        // pTarget->GetPosition(&loc);
+
+        loc.m_mapId = 1;
+        loc.m_positionX = 16226.5f;
+        loc.m_positionY = 16403.6f;
+        loc.m_positionZ = -64.5f;
+        loc.m_orientation = 3.2f;
+
+        pTarget->SetHomebind(loc,876);
+        return true;
+    }
+
+    static bool HandleAntiCheatDeleteCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " "); //get entered name
+
+        if (!command)
+            return true;
+
+        strCommand = command;
+
+        if (strCommand.compare("deleteall") == 0)
+            sAnticheatMgr->AnticheatDeleteCommand(0);
+        else
+        {
+            normalizePlayerName(strCommand);
+            Player* player = sObjectAccessor->FindPlayerByName(strCommand.c_str()); //get player by name
+            if (!player)
+                handler->PSendSysMessage("Player doesn't exist");
+            else
+                sAnticheatMgr->AnticheatDeleteCommand(player->GetGUIDLow());
+        }
+
+        return true;
+    }
+
+    static bool HandleAntiCheatPlayerCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        uint32 guid = 0;
+        Player* player = NULL;
+
+        if (command)
+        {
+            strCommand = command;
+
+            normalizePlayerName(strCommand);
+            player = sObjectAccessor->FindPlayerByName(strCommand.c_str()); //get player by name
+
+            if (player)
+                guid = player->GetGUIDLow();
+        }else
+        {
+            player = handler->getSelectedPlayer();
+            if (player)
+                guid = player->GetGUIDLow();
+        }
+
+        if (!guid)
+        {
+            handler->PSendSysMessage("There is no player.");
+            return true;
+        }
+
+        float average = sAnticheatMgr->GetAverage(guid);
+        uint32 total_reports = sAnticheatMgr->GetTotalReports(guid);
+        uint32 speed_reports = sAnticheatMgr->GetTypeReports(guid,0);
+        uint32 fly_reports = sAnticheatMgr->GetTypeReports(guid,1);
+        uint32 jump_reports = sAnticheatMgr->GetTypeReports(guid,3);
+        uint32 waterwalk_reports = sAnticheatMgr->GetTypeReports(guid,2);
+        uint32 teleportplane_reports = sAnticheatMgr->GetTypeReports(guid,4);
+        uint32 climb_reports = sAnticheatMgr->GetTypeReports(guid,5);
+
+        handler->PSendSysMessage("Information about player %s",player->GetName().c_str());
+        handler->PSendSysMessage("Average: %f || Total Reports: %u ",average,total_reports);
+        handler->PSendSysMessage("Speed Reports: %u || Fly Reports: %u || Jump Reports: %u ",speed_reports,fly_reports,jump_reports);
+        handler->PSendSysMessage("Walk On Water Reports: %u  || Teleport To Plane Reports: %u",waterwalk_reports,teleportplane_reports);
+        handler->PSendSysMessage("Climb Reports: %u", climb_reports);
+
+        return true;
+    }
+
+    static bool HandleAntiCheatHandleCommand(ChatHandler* handler, const char* args)
+    {
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        if (!command)
+            return true;
+
+        if (!handler->GetSession()->GetPlayer())
+            return true;
+
+        strCommand = command;
+
+        if (strCommand.compare("on") == 0)
+        {
+            sWorld->setBoolConfig(CONFIG_ANTICHEAT_ENABLE,true);
+            handler->SendSysMessage("The Anticheat System is now: Enabled!");
+        }
+        else if (strCommand.compare("off") == 0)
+        {
+            sWorld->setBoolConfig(CONFIG_ANTICHEAT_ENABLE,false);
+            handler->SendSysMessage("The Anticheat System is now: Disabled!");
+        }
+
+        return true;
+    }
+
+    static bool HandleAntiCheatGlobalCommand(ChatHandler* handler, const char* /* args */)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+        {
+            handler->PSendSysMessage("The Anticheat System is disabled.");
+            return true;
+        }
+
+        sAnticheatMgr->AnticheatGlobalCommand(handler);
+
+        return true;
+    }
+};
+
+void AddSC_anticheat_commandscript()
+{
+    new anticheat_commandscript();
+}
diff --git a/src/server/scripts/Commands/cs_guild.cpp b/src/server/scripts/Commands/cs_guild.cpp
index 4627f6b..deaf21f 100644
--- a/src/server/scripts/Commands/cs_guild.cpp
+++ b/src/server/scripts/Commands/cs_guild.cpp
@@ -38,12 +38,15 @@ public:
     {
         static ChatCommand guildCommandTable[] =
         {
-            { "create",   rbac::RBAC_PERM_COMMAND_GUILD_CREATE,   true, &HandleGuildCreateCommand,           "", NULL },
-            { "delete",   rbac::RBAC_PERM_COMMAND_GUILD_DELETE,   true, &HandleGuildDeleteCommand,           "", NULL },
-            { "invite",   rbac::RBAC_PERM_COMMAND_GUILD_INVITE,   true, &HandleGuildInviteCommand,           "", NULL },
-            { "uninvite", rbac::RBAC_PERM_COMMAND_GUILD_UNINVITE, true, &HandleGuildUninviteCommand,         "", NULL },
-            { "rank",     rbac::RBAC_PERM_COMMAND_GUILD_RANK,     true, &HandleGuildRankCommand,             "", NULL },
-            { "rename",   rbac::RBAC_PERM_COMMAND_GUILD_RENAME,   true, &HandleGuildRenameCommand,           "", NULL },
+            { "create",   rbac::RBAC_PERM_COMMAND_GUILD_CREATE,    true, &HandleGuildCreateCommand,           "", NULL },
+            { "delete",   rbac::RBAC_PERM_COMMAND_GUILD_DELETE,    true, &HandleGuildDeleteCommand,           "", NULL },
+            { "invite",   rbac::RBAC_PERM_COMMAND_GUILD_INVITE,    true, &HandleGuildInviteCommand,           "", NULL },
+            { "uninvite", rbac::RBAC_PERM_COMMAND_GUILD_UNINVITE,  true, &HandleGuildUninviteCommand,         "", NULL },
+            { "rank",     rbac::RBAC_PERM_COMMAND_GUILD_RANK,      true, &HandleGuildRankCommand,             "", NULL },
+            { "rename",   rbac::RBAC_PERM_COMMAND_GUILD_RENAME,    true, &HandleGuildRenameCommand,           "", NULL },
+            { "info",     rbac::RBAC_PERM_COMMAND_GUILD_INFO,      true, &HandleGuildInfoCommand,             "", NULL },
+            { "setlevel", rbac::RBAC_PERM_COMMAND_GUILD_SET_LEVEL, true, &HandleGuildSetLevelCommand,         "", NULL },
+            { "givexp",   rbac::RBAC_PERM_COMMAND_GUILD_GIVE_XP,   true, &HandleGuildGiveXpCommand,           "", NULL },
             { NULL,       0,                               false, NULL,                                "", NULL }
         };
         static ChatCommand commandTable[] =
@@ -243,6 +246,124 @@ public:
         handler->PSendSysMessage(LANG_GUILD_RENAME_DONE, oldGuildStr, newGuildStr);
         return true;
     }
+
+    //Guild-Level-System
+    static bool HandleGuildInfoCommand(ChatHandler* handler, char const* /*args*/)
+    {
+        Guild* guild = handler->GetSession()->GetPlayer()->GetGuild();
+
+        if (guild)
+        {
+            handler->PSendSysMessage(LANG_GUILDINFO_LEVEL, guild->GetLevel());
+
+            if (guild->GetLevel() >= GUILD_MAX_LEVEL)
+                handler->PSendSysMessage(LANG_GUILDINFO_XP_INFO, 0, 0);
+            else
+                handler->PSendSysMessage(LANG_GUILDINFO_XP_INFO, guild->GetCurrentXP(), guild->GetXpForNextLevel());
+
+            handler->PSendSysMessage("Aktive Gildenboni:");
+
+            if (guild->GetLevel() > 0)
+            {
+                if (guild->HasLevelForBonus(GUILD_BONUS_GOLD_1))
+                    handler->PSendSysMessage("Goldbonus [Rang 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_XP_1))
+                    handler->PSendSysMessage("Erfahrungszuwachs [Rang 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_SCHNELLER_GEIST))
+                    handler->PSendSysMessage("Schneller Geist");
+                if (guild->HasLevelForBonus(GUILD_BONUS_REPERATUR_1))
+                    handler->PSendSysMessage("G\303\274nstige Reperatur [Rang 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_GOLD_2))
+                    handler->PSendSysMessage("Goldbonus [Rang 2]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_REITTEMPO_1))
+                    handler->PSendSysMessage("Reittempo [Rang 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_RUF_1))
+                    handler->PSendSysMessage("Rufzuwachs [Rang 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_XP_2))
+                    handler->PSendSysMessage("Erfahrungszuwachs [Rang 2]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_REPERATUR_2))
+                    handler->PSendSysMessage("G\303\274nstige Reperatur [Rang 2]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_REITTEMPO_2))
+                    handler->PSendSysMessage("Reittempo [Rang 2]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_REPERATUR_2))
+                    handler->PSendSysMessage("Rufzuwachs [Rang 2]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_EHRE_1))
+                    handler->PSendSysMessage("Ehrezuwachs [Rang 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_EHRE_2))
+                    handler->PSendSysMessage("Ehrezuwachs [Rang 2]");
+            }
+            else
+                handler->PSendSysMessage("Keine");
+
+            return true;
+        }
+        else
+        {
+            handler->PSendSysMessage("Du bist in keiner Gilde.");
+            return false;
+        }
+    }
+
+    static bool HandleGuildSetLevelCommand(ChatHandler* handler, char const* args)
+    {
+        if (!*args)
+            return false;
+
+        char* guildNameStr;
+        char* levelStr;
+        handler->extractOptFirstArg((char*)args, &guildNameStr, &levelStr);
+
+        if (!levelStr)
+            return false;
+
+        uint8 newLevel = uint8(atoi(levelStr));
+        Guild* guild = sGuildMgr->GetGuildByName(guildNameStr);
+
+        if (guild)
+        {
+            if (newLevel > GUILD_MAX_LEVEL)
+            {
+                handler->PSendSysMessage("Das angegebene Level ist zu hoch.");
+                return false;
+            }
+            else
+                guild->SetLevel(newLevel, true);
+        }
+        else
+        {
+            handler->PSendSysMessage("Es konnte keine Gilde mit den Namen [%s] gefunden werden.", guildNameStr);
+            return false;
+        }
+
+        return true;
+    }
+
+    static bool HandleGuildGiveXpCommand(ChatHandler* handler, char const* args)
+    {
+        if (!*args)
+            return false;
+
+        char* guildNameStr;
+        char* xpStr;
+        handler->extractOptFirstArg((char*)args, &guildNameStr, &xpStr);
+
+        if (!xpStr)
+            return false;
+
+        uint32 value = uint32(atoi(xpStr));
+
+        Guild* guild = sGuildMgr->GetGuildByName(guildNameStr);
+
+        if (guild)
+            guild->GiveXp(value);
+        else
+        {
+            handler->PSendSysMessage("There was no guild with the name [%s] be found.", guildNameStr);
+            return false;
+        }
+
+        return true;
+    }
 };
 
 void AddSC_guild_commandscript()
diff --git a/src/server/scripts/Commands/cs_message.cpp b/src/server/scripts/Commands/cs_message.cpp
index dd1366a..ca351fe 100644
--- a/src/server/scripts/Commands/cs_message.cpp
+++ b/src/server/scripts/Commands/cs_message.cpp
@@ -28,6 +28,7 @@ EndScriptData */
 #include "Language.h"
 #include "Player.h"
 #include "ObjectMgr.h"
+#include "IRCClient.h"
 
 class message_commandscript : public CommandScript
 {
@@ -134,6 +135,13 @@ public:
         if (!*args)
             return false;
 
+        if ((sIRC.BOTMASK & 256) != 0)
+        {
+            std::string ircchan = "#";
+            ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+            sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 System Message \00304,08\037/!\\\037\017 %s", "%s", args), true);
+        }
+
         char buff[2048];
         sprintf(buff, handler->GetTrinityString(LANG_SYSTEMMESSAGE), args);
         sWorld->SendServerMessage(SERVER_MSG_STRING, buff);
@@ -153,6 +161,12 @@ public:
     {
         if (!*args)
             return false;
+        if ((sIRC.BOTMASK & 256) != 0)
+            {
+                std::string ircchan = "#";
+                ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+                sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 Global Notify \00304,08\037/!\\\037\017 %s", "%s", args), true);
+            }
 
         std::string str = handler->GetTrinityString(LANG_GLOBAL_NOTIFY);
         str += args;
diff --git a/src/server/scripts/Commands/cs_modify.cpp b/src/server/scripts/Commands/cs_modify.cpp
index 5dbe95b..e2c592b 100644
--- a/src/server/scripts/Commands/cs_modify.cpp
+++ b/src/server/scripts/Commands/cs_modify.cpp
@@ -70,6 +70,8 @@ public:
             { "spell",        rbac::RBAC_PERM_COMMAND_MODIFY_SPELL,        false, &HandleModifySpellCommand,         "", NULL },
             { "standstate",   rbac::RBAC_PERM_COMMAND_MODIFY_STANDSTATE,   false, &HandleModifyStandStateCommand,    "", NULL },
             { "talentpoints", rbac::RBAC_PERM_COMMAND_MODIFY_TALENTPOINTS, false, &HandleModifyTalentCommand,        "", NULL },
+            { "xpkill",       rbac::RBAC_PERM_COMMAND_MODIFY_XP_KILL,      false, &HandleModifyXpKillCommand, "", NULL },
+            { "xpquest",      rbac::RBAC_PERM_COMMAND_MODIFY_XP_QUEST,     false, &HandleModifyXpQuestCommand, "", NULL },
             { NULL,           0,                                     false, NULL,                              "", NULL }
         };
         static ChatCommand commandTable[] =
@@ -1393,6 +1395,68 @@ public:
 
         return true;
     }
+
+    static bool HandleModifyXpKillCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+            return false;
+
+        float killRate = (float)atof((char*)args);
+
+        if (killRate < 1)
+        {
+            handler->SendSysMessage(LANG_INDIVIDUAL_RATE_TO_LOW);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (killRate > 8)
+        {
+            handler->SendSysMessage(LANG_INDIVIDUAL_RATE_TO_HIGH);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* player = handler->GetSession()->GetPlayer())
+        {
+            player->SetIndividualRate(INDIVIDUAL_XP_KILL, killRate);
+            handler->PSendSysMessage(LANG_INDIVIDUAL_KILLRATE_SET, killRate);
+            return true;
+        }
+
+        return true;
+    }
+
+    static bool HandleModifyXpQuestCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+            return false;
+
+        float questRate = (float)atof((char*)args);
+
+        if (questRate < 1)
+        {
+            handler->SendSysMessage(LANG_INDIVIDUAL_RATE_TO_LOW);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (questRate > 8)
+        {
+            handler->SendSysMessage(LANG_INDIVIDUAL_RATE_TO_HIGH);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* player = handler->GetSession()->GetPlayer())
+        {
+            player->SetIndividualRate(INDIVIDUAL_XP_QUEST, questRate);
+            handler->PSendSysMessage(LANG_INDIVIDUAL_QUESTRATE_SET, questRate);
+            return true;
+        }
+
+        return true;
+    }
 };
 
 void AddSC_modify_commandscript()
diff --git a/src/server/scripts/Custom/ArenaGambler.cpp b/src/server/scripts/Custom/ArenaGambler.cpp
new file mode 100644
index 0000000..bf6e664
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGambler.cpp
@@ -0,0 +1,308 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGambler.cpp
+ * Description: This file is used to script the npc for the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+#include "ScriptPCH.h"
+#include "ArenaGamblingSystem.h"
+#include "ScriptMgr.h"
+#include "Player.h"
+
+class ArenaGambler : public CreatureScript
+{
+    public:
+        ArenaGambler() : CreatureScript(ARENA_GAMBLER_SCRIPT_NAME) {}
+        bool OnGossipHello(Player *pPlayer, Creature *pCreature)
+        {
+            switch (urand(0,6))
+            {
+                case 0: pCreature->MonsterSay("|cffbbbbbbWelcome ye great warrior , fight to the last for the Lich King!",0,pPlayer); break;
+                case 1: pCreature->MonsterSay("|cffbbbbbbOnly great warriors are welcome!",0,pPlayer); break;
+                case 2: pCreature->MonsterSay("|cffbbbbbbMere mortals cannot be gods!",0,pPlayer); break;
+                case 3: pCreature->MonsterSay("|cffbbbbbbGreat warrior , you seek to duel!",0,pPlayer); break;
+                case 4: pCreature->MonsterSay("|cffbbbbbbDeath and glory await!",0,pPlayer); break;
+                case 5: pCreature->MonsterSay("|cffbbbbbbBegone, weaklings are unwelcome!",0,pPlayer); break;
+                case 6: pCreature->MonsterSay("|cffbbbbbbDeath and honor!",0,pPlayer); break;
+            }
+                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_ITEM, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+
+            return true;
+        }
+
+        bool OnGossipSelect(Player *pPlayer, Creature *pCreature, uint32 sender, uint32 action)
+        {
+            pPlayer->PlayerTalkClass->ClearMenus();
+            switch(sender)
+            {
+                case ARENA_GAMBLER_MENU_MAIN:
+                {
+                    if(GamblerMatchData *matchData = sGamblingSystem.GetMatchDataBy(pPlayer))
+                    {
+                            if(matchData->MatchStarted())
+                                return true;
+                            if(matchData->GetItemIdBy(pPlayer) == 0) // if there is match data, but no item was bet
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM,    ARENA_GAMBLER_TEXT_BET_ITEM,            ARENA_GAMBLER_MENU_BET_ITEM,            GOSSIP_ACTION_INFO_DEF + 1, ARENA_GAMBLER_TEXT_BET_ITEM_CODE_TEXT, 0, true);
+                            if(matchData->GetItemIdBy(pPlayer) != 0 && matchData->GetItemCountBy(pPlayer) == 0) // if there is match data and an item, but no amount was entered
+                            pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM,    ARENA_GAMBLER_TEXT_BET_ITEM_AMOUNT,    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            if(matchData->GetChallengerItemId() && matchData->GetDefenderItemId() && matchData->GetItemCountBy(pPlayer) != 0 &&  matchData->HasSetReady(pPlayer) == false) // if everything checks out, but player is not yet ready.
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_ACCEPT,    ARENA_GAMBLER_TEXT_ACCEPT_CHALLENGE,    ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            if(matchData->GetChallengerGUID() == pPlayer->GetGUIDLow())
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_CANCEL,    ARENA_GAMBLER_TEXT_CANCEL_CHALLENGE,    ARENA_GAMBLER_MENU_CANCEL_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            else
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_DECLINE,    ARENA_GAMBLER_TEXT_DECLINE_CHALLENGE,    ARENA_GAMBLER_MENU_DECLINE_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                        }
+                        else // if no match data was found
+                        {
+                            pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_CHALLENGE, ARENA_GAMBLER_TEXT_CHALLENGE, ARENA_GAMBLER_MENU_CHALLENGE_PLAYER, GOSSIP_ACTION_INFO_DEF + 1, ARENA_GAMBLER_TEXT_CHALLENGE_CODE_TEXT, 0, true);
+                        }
+                        pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_EXIT, ARENA_GAMBLER_TEXT_EXIT, ARENA_GAMBLER_MENU_EXIT, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT:
+                {
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_1, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_10, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_20, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_30, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_40, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_50, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_100, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_200, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_300, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_500, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_1000, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_EXIT, ARENA_GAMBLER_TEXT_EXIT, ARENA_GAMBLER_MENU_EXIT, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+                }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1:
+                    {
+                        if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 1) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10:
+                    {
+                        if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 10) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20:
+                    {
+                        if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 20) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30:
+                    {
+                        if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 30) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40:
+                    {
+                        if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 40) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50:
+                {
+                    if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 50) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100:
+                {
+                    if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 100) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200:
+                {
+                    if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 200) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300:
+                {
+                    if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 300) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500:
+                {
+                    if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 500) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000:
+                {
+                    if(sGamblingSystem.AddItemAmountForMatch(pPlayer, 1000) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE:
+                    {
+                        sGamblingSystem.AcceptChallenge(pPlayer);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                case ARENA_GAMBLER_MENU_CANCEL_CHALLENGE:
+                case ARENA_GAMBLER_MENU_DECLINE_CHALLENGE:
+                    {
+                    sGamblingSystem.CancelChallenge(pPlayer);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                case ARENA_GAMBLER_MENU_EXIT:{
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+            }
+
+            return true;
+        }
+
+        bool OnGossipSelectCode(Player *pPlayer, Creature *pCreature, uint32 sender, uint32 action, const char *pCode)
+        {
+            switch(sender)
+            {
+                case ARENA_GAMBLER_MENU_CHALLENGE_PLAYER:
+                {
+                    if(Player* pDefender = sObjectAccessor->FindPlayerByName(pCode))
+                    {
+                        if(sGamblingSystem.CanHaveMatch(pPlayer, pDefender) == false)
+                        {
+                            // General Error Message: Match not possible because:
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_MATCH_NOT_POSSIBLE);
+                            // Reason is: no gamemasters
+                            if(pPlayer->GetSession()->GetSecurity() > 0 || pDefender->GetSession()->GetSecurity() > 0)
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_NO_GMS_ALLOWED);
+                            }
+                            // Reason is: you cannot duel your self!
+                            if(pPlayer->GetSession()->GetAccountId() == pDefender->GetSession()->GetAccountId())
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_SAME_ACC_ID);
+                            }
+                            // Reason is: multiboxing is not allowed, or players have the same ip.
+                            if(pPlayer->GetSession()->GetRemoteAddress().compare(pDefender->GetSession()->GetRemoteAddress()) == 0)
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_MULTI_BOX);
+                            }
+                            // Reason is: your level is smaller than the minimum level required
+                            uint32 m_minRequiredLevel = 0;
+                            if(pPlayer->getLevel() <= m_minRequiredLevel || pDefender->getLevel() <= m_minRequiredLevel )
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_LOW_LEVEL);
+                            }
+                            // Reason is: you are requesting a duel from someone who already is in a duel.
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_LOW_LEVEL);
+                            // Reason is: level diffrance is too high
+                            uint32 levelDiff = 0;
+                            if(pPlayer->getLevel() > pDefender->getLevel())
+                            {
+                                levelDiff = pPlayer->getLevel() - pDefender->getLevel();
+                            }
+                            else
+                            {
+                                levelDiff = pDefender->getLevel() - pPlayer->getLevel();
+                            }
+                            return true;
+                        }
+                        sGamblingSystem.SetupMatch(pPlayer, pDefender);
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_CHALLENGE_ISSUED, pDefender);
+                        ChatHandler(pDefender->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_CHALLENGED, pPlayer);
+                        OnGossipSelect(pPlayer, pCreature, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_PLAYER_NOT_FOUND);
+                }break;
+
+                case ARENA_GAMBLER_MENU_BET_ITEM:
+                {
+                    if(sGamblingSystem.AddItemForMatch(pPlayer, pCode) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_ADD_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_ADD_SUCCESS);
+                    OnGossipSelect(pPlayer, pCreature, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                }break;
+            }
+            return true;
+        }
+};
+
+// Arena Records GameObject
+class ArenaRecords : public GameObjectScript
+{ public:
+    ArenaRecords() : GameObjectScript(ARENA_RECORDS_SCRIPT_NAME) { }
+    bool OnGossipHello(Player* pPlayer, GameObject* pGo)
+    {
+        if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT `playerGUID`,`duelsLost`,`duelsWon`,`duelsRefused`,`duelsTotal` FROM `custom_duel_statistics` WHERE `playerGUID` = '%u'", pPlayer->GetGUIDLow()))
+        {
+            uint32 playerGUID = queryResult->Fetch()[0].GetUInt32();
+            uint32 duelsLost = queryResult->Fetch()[1].GetUInt32();
+            uint32 duelsWon = queryResult->Fetch()[2].GetUInt32();
+            uint32 duelsRefused = queryResult->Fetch()[3].GetUInt32();
+            uint32 duelsTotal = queryResult->Fetch()[4].GetUInt32();
+
+            std::ostringstream Lost;
+            std::ostringstream Won;
+            std::ostringstream Refused;
+            std::ostringstream Total;
+
+            Lost << MSG_COLOR_SUBWHITE << "You have Lost : " << MSG_COLOR_LIGHTBLUE <<  duelsLost << " Duel(s)." ;
+            Won << MSG_COLOR_SUBWHITE << "You have Won : " << MSG_COLOR_LIGHTBLUE <<  duelsWon << " Duel(s)." ;
+            Refused << MSG_COLOR_SUBWHITE << "You have Refused : " << MSG_COLOR_LIGHTBLUE <<  duelsRefused << " Duel(s)." ;
+            Total << MSG_COLOR_SUBWHITE << "You have Fought : " << MSG_COLOR_LIGHTBLUE <<  duelsTotal << " Duel(s)." ;
+
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Lost.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Won.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Refused.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Total.str( ).c_str( ));
+        }
+        else
+        {
+            switch (urand(0,5))
+            {
+            case 0: pPlayer->MonsterSay("I never fought once , i should be ashamed.",0,pPlayer);break;
+            case 1: pPlayer->MonsterSay("This book does not hold any records of me!",0,pPlayer);break;
+            case 2: pPlayer->MonsterSay("i have never challenged anyone here!",0,pPlayer);break;
+            case 3: pPlayer->MonsterSay("I should first challenge someone!",0,pPlayer);break;
+            case 4: pPlayer->MonsterSay("No Wins, No losses",0,pPlayer);break;
+            case 5: pPlayer->MonsterSay("I should hide in a cave, i don't deserve to be here!",0,pPlayer);break;
+            }
+        }
+        return true;
+    }
+};
+
+void AddSC_ArenaGambler()
+{
+    sGamblingSystem.Initalize();
+    new ArenaGambler();
+    new ArenaRecords();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ArenaGamblingSystem.cpp b/src/server/scripts/Custom/ArenaGamblingSystem.cpp
new file mode 100644
index 0000000..b1f9917
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGamblingSystem.cpp
@@ -0,0 +1,723 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGamblingSystem.cpp
+ * Description: This file is used to script the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+#include "ScriptPCH.h"
+#include "ArenaGamblingSystem.h"
+
+using namespace std;
+
+const char *GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_MAX] =
+{
+    "playerGUID",
+    "duelsLost",
+    "duelsWon",
+    "duelsRefused",
+    "duelsTotal"
+};
+
+GamblingSystem::GamblingSystem() : WorldScript(GAMBLER_SYSTEM_SCRIPT_NAME)
+{
+    m_checkMatches.SetInterval(GAMBLER_SYSTEM_INTERVAL_TELE_CHECK);
+}
+
+GamblingSystem::~GamblingSystem()
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+        delete Itr->second;
+    m_matchStorage.clear();
+    ReleaseMatchLock();
+}
+
+// Creation
+void GamblingSystem::Initalize()
+{
+    LoadConfigData();
+    _loadPastMatches();
+    new GamblerDuelScript();
+}
+
+// Events
+// Called on every world tick (don't execute too heavy code here).
+void GamblingSystem::OnUpdate(uint32 diff)
+{
+    if(m_checkMatches.GetCurrent() >= 0)
+        m_checkMatches.Update(diff);
+    else
+        m_checkMatches.SetCurrent(0);
+    if(m_checkMatches.Passed())
+        m_checkMatches.Reset();
+
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetMatchStatus() != GAMBLER_MATCH_STATUS_TELEPORT)
+            continue;
+
+        Player *pChallenger = ObjectAccessor::FindPlayer(Itr->second->GetChallengerGUID());
+        Player *pDefender    = ObjectAccessor::FindPlayer(Itr->second->GetDefenderGUID());
+
+        if(pChallenger == NULL || pDefender == NULL)
+            continue;
+        if(pChallenger->IsBeingTeleported() || pChallenger->isBeingLoaded() || pDefender->IsBeingTeleported() || pDefender->isBeingLoaded())
+            continue;
+
+        pChallenger->CastSpell(pDefender, 7266, true);
+        Itr->second->SetMatchStatus(GAMBLER_MATCH_STATUS_RUNNING);
+    }
+    ReleaseMatchLock();
+}
+
+// Database Interaction
+void GamblingSystem::LoadConfigData()
+{
+    m_minRequiredLevel = 255;
+    m_maxLevelDiff       = 5;
+    m_maxBet           = 100;
+    m_awardFled           = false;
+    m_enableGM           = false;
+    m_enableSameip       = false;
+    m_enableLimits       = false;
+    m_onlyCurrency       = false;
+    m_equalDuels       = false;
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT `optionIndex`, `optionValue` FROM `custom_duel_config`"))
+    {
+        do
+        {
+            Field *Fields = queryResult->Fetch();
+            switch(Fields[0].GetUInt32())
+            {
+                case GAMBLER_CONFIG_OPTION_MAPID:                m_arenaCoords.m_mapId        = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_COORDSX:                m_arenaCoords.m_positionX    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSY:                m_arenaCoords.m_positionY    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSZ:                m_arenaCoords.m_positionZ    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSO:                m_arenaCoords.m_orientation    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_MIN_REQUIREDLEVEL:    m_minRequiredLevel            = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_MAX_LEVELDIFF:        m_maxLevelDiff                = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_AWARD_FLED:            m_awardFled                    = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_MAX_BET:
+                    m_maxBet                    = Fields[1].GetUInt32();
+                    if(m_maxBet > GAMBLER_SYSTEM_TOTAL_MAX_BET){
+                        m_maxBet = GAMBLER_SYSTEM_TOTAL_MAX_BET;
+                    }
+                break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_GM:            m_enableGM                    = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_SAMEIP:        m_enableSameip                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_LIMITS:        m_enableLimits                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ONLY_CURRENCY:        m_onlyCurrency                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_EQUAL_DUELS:            m_equalDuels                = Fields[1].GetBool();        break;
+            }
+        }while(queryResult->NextRow());
+    }
+    else
+        TC_LOG_ERROR("Arena", "GamblingSystem: Unable to load duel_config, result was not returned");
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT MAX(`matchId`) FROM `custom_duel_storage`"))
+        m_highMatchId = queryResult->Fetch()[0].GetUInt32();
+    else
+        m_highMatchId = 0;
+}
+
+void GamblingSystem::_loadPastMatches()
+{
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT * FROM `custom_duel_storage`"))
+    {
+        do
+        {
+            GamblerMatchData *matchData = new GamblerMatchData(queryResult->Fetch());
+            if(matchData->GetMatchWinner() == 0)
+            {
+                _createItemAndMailToPlayer(NULL, matchData->GetChallengerGUID(), matchData->GetChallengerItemId(), matchData->GetChallengerItemCount(), GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                _createItemAndMailToPlayer(NULL, matchData->GetDefenderGUID(), matchData->GetDefenderItemId(), matchData->GetDefenderItemCount(), GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                continue;
+            }
+            AcquireMatchLock();
+            m_matchStorage.insert(make_pair(matchData->GetMatchId(), matchData));
+            ReleaseMatchLock();
+        }while(queryResult->NextRow());
+    }
+    CharacterDatabase.PExecute("DELETE FROM `custom_duel_storage` WHERE `matchWinner` = '0'");
+}
+
+void GamblingSystem::_saveCurrentMatchProgress(GamblerMatchData *matchData)
+{
+    if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT * FROM `custom_duel_storage` WHERE `matchId` = '%u'", matchData->GetMatchId()))
+        CharacterDatabase.PExecute("UPDATE `custom_duel_storage` SET `matchWinner` = '%u'", matchData->GetMatchWinner());
+    else
+        CharacterDatabase.PExecute("INSERT INTO `custom_duel_storage` VALUES ('%u', '%u', '%u', '%u', '%u', '%u', '%u', NOW(), '%u')", matchData->GetMatchId(), matchData->GetChallengerGUID(), matchData->GetDefenderGUID(), matchData->GetChallengerItemId(),matchData->GetChallengerItemCount(), matchData->GetDefenderItemId(),matchData->GetDefenderItemCount(), matchData->GetMatchWinner());
+}
+
+void GamblingSystem::_updatePlayerStats(uint32 playerGUID, GamblerPlayerStatIndex statIndex, uint32 statIncreaseValue)
+{
+    if(statIndex > GAMBLER_PLAYER_STAT_MAX)
+    {
+        TC_LOG_ERROR("Arena", "GamblingSystem: _updatePlayerStats statIndex out of range");
+        return;
+    }
+    if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT `%s` FROM `custom_duel_statistics` WHERE `%s` = '%u'", GamblerPlayerStatFields[statIndex], GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], playerGUID))
+        CharacterDatabase.PExecute("UPDATE `custom_duel_statistics` SET `%s` = '%u' WHERE `%s` = '%u'", GamblerPlayerStatFields[statIndex], queryResult->Fetch()[0].GetUInt32()+statIncreaseValue, GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], playerGUID);
+    else
+        CharacterDatabase.PExecute("INSERT INTO `custom_duel_statistics` (`%s`,`%s`) VALUES('%u', '%u')", GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], GamblerPlayerStatFields[statIndex], playerGUID, statIncreaseValue);
+}
+
+// Match Data Retrieval
+GamblerMatchData *GamblingSystem::GetMatchDataBy(Player *pPlayer)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetChallengerGUID() == pPlayer->GetGUIDLow() || Itr->second->GetDefenderGUID() == pPlayer->GetGUIDLow())
+        {
+            // Match is over, old data
+            if(Itr->second->GetMatchWinner())
+                continue;
+            ReleaseMatchLock();
+            return Itr->second;
+        }
+    }
+    ReleaseMatchLock();
+    return NULL;
+}
+
+// Match Requirements Checking
+bool GamblingSystem::CanHaveMatch(Player *pChallenger, Player *pDefender)
+{
+    // if same ip dueling is enabled in configuration
+    if(m_enableSameip == 1){
+        // no multibox or dueling with same ip
+        if(pChallenger->GetSession()->GetRemoteAddress().compare(pDefender->GetSession()->GetRemoteAddress()) == 0)
+            return false;
+    }
+
+    // if gm dueling is enabled in configuration
+    if(m_enableGM == 1){
+        // No gamemasters
+         if(pChallenger->GetSession()->GetSecurity() > 0 || pDefender->GetSession()->GetSecurity() > 0)
+            return false;
+    }
+
+    // no dueling on the same account
+    if(pChallenger->GetSession()->GetAccountId() == pDefender->GetSession()->GetAccountId())
+        return false;
+
+    // no dueling if any of the players are logging out!
+    if(pChallenger->GetSession()->isLogingOut() || pDefender->GetSession()->isLogingOut())
+        return false;
+
+    // No dueling if player already has a duel record in progress
+    if(GetMatchDataBy(pChallenger) || GetMatchDataBy(pDefender))
+        return false;
+
+    // No dueling if you don't meet the level requirement in the database
+    uint32 m_minRequiredLevel = 0;
+    if(pChallenger->getLevel() <= m_minRequiredLevel || pDefender->getLevel() <= m_minRequiredLevel)
+        return false;
+
+    // No dueling if your level differance is bigger than specified in the database
+    uint32 levelDiff = 0;
+    if(pChallenger->getLevel() > pDefender->getLevel())
+        levelDiff = pChallenger->getLevel() - pDefender->getLevel();
+    else
+        levelDiff = pDefender->getLevel() - pChallenger->getLevel();
+    if(levelDiff > m_maxLevelDiff)
+        return false;
+
+    return true;
+}
+
+// Match Setup
+void GamblingSystem::SetupMatch(Player *pChallenger, Player *pDefender)
+{
+    GamblerMatchData *matchData = new GamblerMatchData(_generateMatchId(), pChallenger->GetGUIDLow(), pDefender->GetGUIDLow());
+    AcquireMatchLock();
+    m_matchStorage.insert(make_pair(matchData->GetMatchId(), matchData));
+    ReleaseMatchLock();
+}
+
+std::string GamblingSystem::GetQualityColor(int32 qualityType) const
+{
+    switch(qualityType)
+    {
+        case ITEM_QUALITY_POOR:
+        {
+            return QUALITY_POOR;
+        }break;
+        case ITEM_QUALITY_NORMAL:
+        {
+            return QUALITY_NORMAL;
+        }break;
+        case ITEM_QUALITY_UNCOMMON:
+        {
+            return QUALITY_UNCOMMON;
+        }break;
+        case ITEM_QUALITY_RARE:
+        {
+            return QUALITY_RARE;
+        }break;
+        case ITEM_QUALITY_EPIC:
+        {
+            return QUALITY_EPIC;
+        }break;
+        case ITEM_QUALITY_LEGENDARY:
+        {
+            return QUALITY_LEGENDARY;
+        }break;
+        case ITEM_QUALITY_ARTIFACT:
+        {
+            return QUALITY_ARTIFACT;
+        }break;
+        case ITEM_QUALITY_HEIRLOOM:
+        {
+            return QUALITY_HEIRLOOM;
+        }break;
+    }
+    return false;
+}
+
+bool GamblingSystem::AddItemForMatch(Player *pPlayer, std::string itemName)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return false;
+
+    WorldDatabase.EscapeString(itemName);
+    if(QueryResult queryResult = WorldDatabase.PQuery("SELECT `entry` FROM `item_template` WHERE `name` = '%s'", itemName.c_str()))
+    {
+        uint32 itemId = queryResult->Fetch()[0].GetUInt32();
+
+        ItemTemplate const *itemProto = sObjectMgr->GetItemTemplate(itemId);
+        if(Item *pItem = pPlayer->GetItemByEntry(itemId))
+        {
+            // if its currency
+            if(itemProto->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS)
+            {
+                if(pItem == NULL)
+                    return false;
+            }else{ // if its a normal item, check if its valid.
+                if(_checkItemValidity(pItem) == false)
+                    return false;
+            }
+
+            if(m_enableLimits == 1){ // if item limits are enabled, check them.
+                if(_checkWithinLimits(pItem) == false)
+                    return false;
+            }
+
+            if(m_onlyCurrency == 1){ // if only currency is allowed, check the item proto, temporary.
+                if(itemProto->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS){}else{return false;}
+            }
+
+            if(matchData->IsChallenger(pPlayer)){
+                matchData->SetChallengerItemId(itemId);
+            }
+            else{
+                matchData->SetDefenderItemId(itemId);
+            }
+            return true;
+        }
+    }
+    return false;
+}
+
+bool GamblingSystem::AddItemAmountForMatch(Player *pPlayer, uint32 amount)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return false;
+
+    uint32 itemId = matchData->GetItemIdBy(pPlayer);
+    ItemTemplate const *itemProto = sObjectMgr->GetItemTemplate(itemId);
+
+    if(Item *pItem = pPlayer->GetItemByEntry(itemId))
+    {
+        // if duels must be equal, then challenger item count must equal defender item count.
+        if(m_equalDuels == 1){
+            // if the player is challenger and his amount is not equal to the defender's item count, return false.
+            if(matchData->IsChallenger(pPlayer) && matchData->GetDefenderItemCount() != 0 && amount != matchData->GetDefenderItemCount())
+                return false;
+            // if the player is defender and his amount is not equal to challenger's item count, return false.
+            else if(matchData->IsDefender(pPlayer)  && matchData->GetChallengerItemCount() != 0 && amount != matchData->GetChallengerItemCount())
+                return false;
+        }
+
+        if(amount > m_maxBet)
+            return false;
+
+        if(!pPlayer->HasItemCount(itemId,amount))
+            return false;
+
+        if(matchData->IsChallenger(pPlayer)){
+            matchData->SetChallengerItemCount(amount);
+        }
+        else{
+            matchData->SetDefenderItemCount(amount);
+        }
+
+        Player *secondPlayer = NULL;
+        if(matchData->IsChallenger(pPlayer))
+            secondPlayer = ObjectAccessor::FindPlayer(matchData->GetDefenderGUID());
+        else
+            secondPlayer = ObjectAccessor::FindPlayer(matchData->GetChallengerGUID());
+        if(secondPlayer)
+            ChatHandler(secondPlayer->GetSession()).PSendSysMessage("|cffffffffThe player |cff00ccff%s |cffffffffhas bet |cff00ccff%u|cffffffffx of the item |%s|Hitem:%u:0:0:0:0:0:0:0:%u|h[%s]|h|r", pPlayer, amount, GetQualityColor(itemProto->Quality).c_str(),  pItem->GetEntry(), pPlayer->getLevel(),  itemProto->Name1.c_str());
+        return true;
+    }
+    return false;
+}
+
+void GamblingSystem::AcceptChallenge(Player *pPlayer)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return;
+    if(matchData->IsChallenger(pPlayer))
+        matchData->SetChallengerReady(true);
+    else
+        matchData->SetDefenderReady(true);
+    if(matchData->GetChallengerReady() && matchData->GetDefenderReady())
+    {
+        Player *secondPlayer = NULL;
+
+        if(matchData->IsChallenger(pPlayer)){
+            secondPlayer = ObjectAccessor::FindPlayer(matchData->GetDefenderGUID());}
+        else{
+            secondPlayer = ObjectAccessor::FindPlayer(matchData->GetChallengerGUID());}
+
+        // Don't start the duel if there is no second player
+        if(secondPlayer == NULL)
+        {
+            ChatHandler(pPlayer->GetSession()).PSendSysMessage(GAMBLER_SYSTEM_MSG_CANT_LOCATE_PLAYER);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if they are already in a duel
+        if(secondPlayer->duel || pPlayer->duel)
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_DUEL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if they are already InCombat
+        if(secondPlayer->IsInCombat() || pPlayer->IsInCombat())
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_DUEL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if the players are logging out
+        if(secondPlayer->GetSession()->isLogingOut() || pPlayer->GetSession()->isLogingOut())
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_LOGGING);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        uint32 itemId1 = matchData->IsChallenger(pPlayer) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+        uint32 itemId2 = matchData->IsChallenger(secondPlayer) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+
+        uint32 amount1 = matchData->IsChallenger(pPlayer) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+        uint32 amount2 = matchData->IsChallenger(secondPlayer) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+
+        ItemTemplate const *Proto1 = sObjectMgr->GetItemTemplate(itemId1);
+        ItemTemplate const *Proto2 = sObjectMgr->GetItemTemplate(itemId2);
+
+        if(Proto1->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS || Proto2->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS){
+            // Missing data here, not important.
+        }else if(_checkItemValidity(pPlayer->GetItemByEntry(itemId1)) == false || _checkItemValidity(secondPlayer->GetItemByEntry(itemId2)) == false){
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ITEM_VALIDATE_FAIL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players don't have the item in inventory
+        if(pPlayer->GetItemCount(itemId1) == 0 || secondPlayer->GetItemCount(itemId2) == 0)
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ITEM_NO_INV);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players don't have the amount of items betted
+        if(!pPlayer->GetItemCount(itemId1, amount1)  || !secondPlayer->GetItemCount(itemId2, amount2))
+        {
+            SendMessageToPlayers(matchData, ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players have betted more than the maximum specified in configuration
+        if(pPlayer->GetItemCount(amount1) > m_maxBet || secondPlayer->GetItemCount(amount2) > m_maxBet)
+        {
+            SendMessageToPlayers(matchData, ARENA_GAMBLER_MSG_BET_ADD_FAILED, m_maxBet);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        _saveCurrentMatchProgress(matchData);
+        _updatePlayerStats(pPlayer->GetGUIDLow(), GAMBLER_PLAYER_STAT_DUELS_TOTAL, 1);
+        _updatePlayerStats(secondPlayer->GetGUIDLow(), GAMBLER_PLAYER_STAT_DUELS_TOTAL, 1);
+
+        pPlayer->DestroyItemCount(itemId1, amount1, true, true);
+        secondPlayer->DestroyItemCount(itemId2, amount2, true, true);
+
+        pPlayer->SaveToDB();
+        secondPlayer->SaveToDB();
+
+        SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_MATCH_STARTING);
+
+        pPlayer->SetBattlegroundEntryPoint();
+        secondPlayer->SetBattlegroundEntryPoint();
+        pPlayer->TeleportTo(m_arenaCoords.GetMapId(), m_arenaCoords.GetPositionX(), m_arenaCoords.GetPositionY(), m_arenaCoords.GetPositionZ(), m_arenaCoords.GetOrientation());
+        secondPlayer->TeleportTo(m_arenaCoords.GetMapId(), m_arenaCoords.GetPositionX(), m_arenaCoords.GetPositionY(), m_arenaCoords.GetPositionZ(), m_arenaCoords.GetOrientation());
+        matchData->SetMatchStatus(GAMBLER_MATCH_STATUS_TELEPORT);
+    }
+    else
+        SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ACCEPTED_CHALLENGE, pPlayer);
+}
+
+void GamblingSystem::CancelChallenge(Player *pPlayer)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return;
+    SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANCELED, pPlayer, matchData->GetChallengerGUID() == pPlayer->GetGUIDLow() ? GAMBLER_SYSTEM_MSG_CANCELED_1 : GAMBLER_SYSTEM_MSG_CANCELED_2);
+    if(matchData->IsDefender(pPlayer))
+        _updatePlayerStats(pPlayer->GetGUIDLow(), GAMBLER_PLAYER_STAT_DUELS_REFUSED, 1);
+    _deleteMatchData(matchData->GetMatchId());
+}
+
+// Match Completion
+void GamblingSystem::HandleMatchComplete(Player *pWinner, Player *pLoser, GamblerMatchData *matchData, DuelCompleteType completeType)
+{
+    uint32 itemId1 = matchData->IsChallenger(pWinner) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+    uint32 itemId2 = matchData->IsChallenger(pLoser) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+    uint32 amount1 = matchData->IsChallenger(pWinner) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+    uint32 amount2 = matchData->IsChallenger(pLoser) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+    switch(completeType)
+    {
+        case DUEL_INTERRUPTED:
+        {
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+            _createItemAndMailToPlayer(pLoser, pLoser->GetGUIDLow(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_INTERRUPTED);
+        }break;
+        case DUEL_WON:
+        {
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_WON, pWinner);
+        }break;
+        case DUEL_FLED:
+        {
+            if(m_awardFled)
+            {
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+                SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_WON, pWinner);
+
+            }else{
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                _createItemAndMailToPlayer(pLoser, pLoser->GetGUIDLow(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_FLED_NON_AWARD);
+            }
+        }break;
+    }
+    _updatePlayerStats(pWinner->GetGUIDLow(), GAMBLER_PLAYER_STAT_DUELS_WON, 1);
+    _updatePlayerStats(pLoser->GetGUIDLow(), GAMBLER_PLAYER_STAT_DUELS_LOST, 1);
+    matchData->SetMatchWinner(pWinner->GetGUIDLow());
+    _saveCurrentMatchProgress(matchData);
+    _deleteMatchData(matchData->GetMatchId());
+    pWinner->TeleportToBGEntryPoint();
+    pLoser->TeleportToBGEntryPoint();
+}
+
+// Match Data
+void GamblingSystem::_deleteMatchData(Player *pPlayer)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetChallengerGUID() == pPlayer->GetGUIDLow() || Itr->second->GetDefenderGUID() == pPlayer->GetGUIDLow())
+        {
+            delete Itr->second;
+            m_matchStorage.erase(Itr);
+            break;
+        }
+    }
+    ReleaseMatchLock();
+}
+
+bool GamblingSystem::_checkItemValidity(Item *pItem)
+{
+    if(pItem == NULL || pItem->IsSoulBound() || pItem->IsBoundAccountWide() || pItem->IsBoundByEnchant())
+        return false;
+    return true;
+}
+
+bool GamblingSystem::_checkWithinLimits(Item *pItem)
+{
+    /*
+    * Here you can add your items that you want players to be able to use in the system. this is temporary.
+    * uint32 GAMBLER_SYSTEM_ITEM_LIMITS [] = {ITEMID1,ITEMID2,ITEMID3};
+    */
+    uint32 GAMBLER_SYSTEM_ITEM_LIMITS [] = {20559};
+    for (uint32 i = 0; i < sizeof(GAMBLER_SYSTEM_ITEM_LIMITS)/sizeof(uint32); ++i){
+        if (pItem->GetEntry() == GAMBLER_SYSTEM_ITEM_LIMITS[i])
+            return true;
+    }
+    return false;
+}
+
+void GamblingSystem::_deleteMatchData(uint32 matchId)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr = m_matchStorage.find(matchId);
+    if(Itr != m_matchStorage.end())
+        m_matchStorage.erase(Itr);
+    ReleaseMatchLock();
+}
+
+uint32 GamblingSystem::_generateMatchId()
+{
+    m_highMatchId++;
+    return m_highMatchId;
+}
+
+// Messaging
+void GamblingSystem::SendMessageToPlayers(GamblerMatchData *matchData, const char *msgToSend, ...)
+{
+    Player *pChallenger = ObjectAccessor::FindPlayer(matchData->GetChallengerGUID());
+    Player *pDefender    = ObjectAccessor::FindPlayer(matchData->GetDefenderGUID());
+
+    char Result[1024];
+    va_list List;
+    va_start(List, msgToSend);
+    vsnprintf(Result, 1024, msgToSend, List);
+    va_end(List);
+
+    if(pChallenger)
+        ChatHandler(pChallenger->GetSession()).PSendSysMessage(Result);
+    if(pDefender)
+        ChatHandler(pDefender->GetSession()).PSendSysMessage(Result);
+}
+
+// Mail System
+void GamblingSystem::_createItemAndMailToPlayer(Player *pPlayer, uint32 playerGUID, uint32 itemId, uint32 amount, std::string mailMessage)
+{
+    MailSender toSend(MAIL_NORMAL, playerGUID, GAMBLER_SYSTEM_MAIL_TYPE);
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    MailDraft mailDraft(GAMBLER_SYSTEM_MSG_MAIL_SUBJECT, mailMessage.c_str());
+
+    // extract items
+    typedef std::pair<uint32, uint32> ItemPair;
+    typedef std::list< ItemPair > ItemPairs;
+    ItemPairs items;
+    ItemTemplate const* item_proto = sObjectMgr->GetItemTemplate(itemId);
+    while (amount > item_proto->GetMaxStackSize())
+    {
+        items.push_back(ItemPair(itemId, item_proto->GetMaxStackSize()));
+        amount -= item_proto->GetMaxStackSize();
+    }
+    items.push_back(ItemPair(itemId, amount));
+
+    // TODO: items to be send is higher than the maximum items that a mail can hold!, security measure.
+    if (items.size() > MAX_MAIL_ITEMS){}
+
+    for(ItemPairs::const_iterator itr = items.begin(); itr != items.end(); ++itr)
+    {
+        if (Item* pItem = Item::CreateItem(itr->first, itr->second,pPlayer))
+        {
+           pItem->SaveToDB(trans);   // save for prevent lost at next mail load, if send fail then item will deleted
+           mailDraft.AddItem(pItem);
+        }
+    }
+
+    if(pPlayer){
+        mailDraft.SendMailTo(trans, MailReceiver(pPlayer), toSend);
+    }
+    else{
+        mailDraft.SendMailTo(trans, MailReceiver(playerGUID), toSend);
+    }
+    CharacterDatabase.CommitTransaction(trans);
+}
+
+// Called when a duel begins, check if both players have match data with each other
+void GamblerDuelScript::OnDuelRequest(Player *pDefender, Player *pChallenger)
+{
+    // To make sure we have the players and bug reporting
+    if(pDefender == NULL || pChallenger == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnDuelEnd pDefender or pChallenger is NULL!");
+        return;}
+
+    GamblerMatchData *ChallengerMatchData = sGamblingSystem.GetMatchDataBy(pChallenger);
+    GamblerMatchData *DefenderMatchData = sGamblingSystem.GetMatchDataBy(pDefender);
+
+    // if challenger or defender has no existing match data, return.
+    if(ChallengerMatchData == NULL || DefenderMatchData == NULL){
+        return;
+    }// if challenger or defender has match data existing
+    else{
+        // if challenger's match id is not the same as the defender, and they both have match data.
+        // then challenger has requested duel from someone else with match data.
+        if(ChallengerMatchData->GetMatchId() != DefenderMatchData->GetMatchId()){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NOT_SAME_PLAYER);
+            sGamblingSystem.CancelChallenge(pChallenger);
+        }
+        // if the challenger has not set ready, or the defender has not set ready!
+        if(ChallengerMatchData->HasSetReady(pChallenger) == false || ChallengerMatchData->HasSetReady(pDefender) == false){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NOT_READY);
+            sGamblingSystem.CancelChallenge(pChallenger);
+        }
+        // if challenger has no item id set, or defender has no item id set!
+        if(ChallengerMatchData->GetChallengerItemId() == NULL || ChallengerMatchData->GetDefenderItemId() == NULL){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NO_ITEM);
+            sGamblingSystem.CancelChallenge(pChallenger);
+        }
+        // if challenger has not set item count yet, or defender has not set item count yet!
+        if(ChallengerMatchData->GetChallengerItemCount() == NULL || ChallengerMatchData->GetDefenderItemCount() == NULL){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NO_AMOUNT);
+            sGamblingSystem.CancelChallenge(pChallenger);
+        }
+
+    }
+}
+
+// Called when a duel ends, check if there is a match running or not.
+void GamblerDuelScript::OnDuelEnd(Player *pWinner, Player *pLoser, DuelCompleteType type)
+{
+    // To make sure we have the players and bug reporting
+    if(pWinner == NULL || pLoser == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnDuelEnd pWinner or pLoser is NULL!");
+        return;}
+
+    GamblerMatchData *WinnerData = sGamblingSystem.GetMatchDataBy(pWinner);
+    GamblerMatchData *LoserData = sGamblingSystem.GetMatchDataBy(pLoser);
+
+    if(WinnerData == NULL || LoserData == NULL){
+        return;}
+    else if(WinnerData->GetMatchId() == LoserData->GetMatchId()){
+    sGamblingSystem.HandleMatchComplete(pWinner, pLoser, WinnerData, type);
+    }
+}
+
+// Called when a player logsout, if a player exists, check match data, if it started, if yes then complete the duel
+void GamblerDuelScript::OnLogout(Player *pPlayer)
+{
+    // To make sure we have the player and bug reporting
+    if(pPlayer == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnLogout pPlayer is NULL!");
+        return;}
+
+    GamblerMatchData *matchData = sGamblingSystem.GetMatchDataBy(pPlayer);
+    if(matchData == NULL){
+        return;}
+    else if(matchData->MatchStarted() && (matchData->GetChallengerGUID() == pPlayer->GetGUIDLow() || matchData->GetDefenderGUID() == pPlayer->GetGUIDLow()))
+            pPlayer->DuelComplete(DUEL_FLED);
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ArenaGamblingSystem.h b/src/server/scripts/Custom/ArenaGamblingSystem.h
new file mode 100644
index 0000000..5ed39bd
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGamblingSystem.h
@@ -0,0 +1,443 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGamblingSystem.h
+ * Description: This file is used for definitions and requirements of the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+#ifndef ArenaGambler_H
+#define ArenaGambler_H
+
+// scriptName
+#define GAMBLER_SYSTEM_SCRIPT_NAME "custom_gambling_system_script"
+#define GAMBLER_SYSTEM_DUEL_SCRIPT_NAME "custom_gambler_duel_script"
+
+#define ARENA_GAMBLER_SCRIPT_NAME "duel_system"
+#define ARENA_RECORDS_SCRIPT_NAME "duel_records_system"
+
+enum ARENA_GAMBLER_MENUS
+{
+    ARENA_GAMBLER_MENU_MAIN    = 1,
+    ARENA_GAMBLER_MENU_CHALLENGE_PLAYER,
+    ARENA_GAMBLER_MENU_BET_ITEM,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000,
+    ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE,
+    ARENA_GAMBLER_MENU_CANCEL_CHALLENGE,
+    ARENA_GAMBLER_MENU_DECLINE_CHALLENGE,
+    ARENA_GAMBLER_MENU_EXIT
+};
+
+enum ARENA_GAMBLER_MENU_ICONS
+{
+    ARENA_GAMBLER_ICON_CHALLENGE    = GOSSIP_ICON_BATTLE,            // ARENA_GAMBLER_MENU_CHALLENGE_PLAYER
+    ARENA_GAMBLER_ICON_BET_ITEM        = GOSSIP_ICON_MONEY_BAG,        // ARENA_GAMBLER_MENU_BET_ITEM
+    ARENA_GAMBLER_ICON_ACCEPT        = GOSSIP_ICON_BATTLE,            // ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE
+    ARENA_GAMBLER_ICON_CANCEL        = GOSSIP_ICON_DOT,                // ARENA_GAMBLER_MENU_CANCEL_CHALLENGE
+    ARENA_GAMBLER_ICON_DECLINE        = GOSSIP_ICON_TAXI,                // ARENA_GAMBLER_MENU_DECLINE_CHALLENGE
+    ARENA_GAMBLER_ICON_EXIT            = GOSSIP_ICON_TABARD,            // ARENA_GAMBLER_MENU_EXIT
+};
+
+// Menu Texts
+#define ARENA_GAMBLER_TEXT_CHALLENGE "I would like to Challenge a player to a duel!"
+#define ARENA_GAMBLER_TEXT_CHALLENGE_CODE_TEXT "Enter the name of a player you wish to challenge. (Case Sensitive)"
+#define ARENA_GAMBLER_TEXT_BET_ITEM "I would like to Bet an item"
+#define ARENA_GAMBLER_TEXT_BET_ITEM_CODE_TEXT "Enter the name of the item you wish to bet"
+#define ARENA_GAMBLER_TEXT_BET_ITEM_AMOUNT "I would like to enter the amount"
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_TEXT "Select the amount of items you wish to bet"
+#define ARENA_GAMBLER_TEXT_ACCEPT_CHALLENGE "I accept the challenge!"
+#define ARENA_GAMBLER_TEXT_CANCEL_CHALLENGE "I do not want to this challenge!"
+#define ARENA_GAMBLER_TEXT_DECLINE_CHALLENGE "I do not accept this challenge!"
+#define ARENA_GAMBLER_TEXT_EXIT "Nevermind"
+
+// Amount of bets Menu text -- TODO: write a more efficient way to override Opcode OnGossipSelectWithCode string restrictions
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_1 "1 item."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_10 "10 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_20 "20 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_30 "30 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_40 "40 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_50 "50 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_100 "100 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_200 "200 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_300 "300 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_500 "500 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_1000 "1000 items."
+
+// Mail System Defines
+#define GAMBLER_SYSTEM_MSG_MAIL_SUBJECT "The Judgment Arena : Rewards !"
+#define GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE "Your item is being returned as the result of an incomplete match"
+#define GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON "You've won the match!"
+#define GAMBLER_SYSTEM_MAIL_TYPE MAIL_STATIONERY_GM
+
+// Messages
+#define GAMBLER_SYSTEM_MSG_ACCEPTED_CHALLENGE "%s has accepted the challenge!" // %s = accepters name
+#define GAMBLER_SYSTEM_MSG_ITEM_BET_PLACED "%s has placed item %s up for bet!" // %s1 = players name %s2 = items name
+#define GAMBLER_SYSTEM_MSG_CANCELED "%s has %s the match!" // the first %s will utilize one of the below defines considering the player is either, the challenger canceling the match, or the defender canceling the match
+#define GAMBLER_SYSTEM_MSG_CANCELED_1 "Canceled"
+#define GAMBLER_SYSTEM_MSG_CANCELED_2 "Forfeit"
+#define GAMBLER_SYSTEM_MSG_CANT_LOCATE_PLAYER "Could not locate the second player, match aborted!"
+#define GAMBLER_SYSTEM_MSG_CANT_START_DUEL "Cannot start match while currently in a duel, or in combat."
+#define GAMBLER_SYSTEM_MSG_CANT_START_LOGGING "Cannot start the match while one fo the players is logging out!"
+#define GAMBLER_SYSTEM_MSG_MATCH_STARTING "The match is now underway!"
+#define GAMBLER_SYSTEM_MSG_DUEL_INTERRUPTED "The duel has been interrupted, items have been mailed back to their original owners"
+#define GAMBLER_SYSTEM_MSG_DUEL_FLED_NON_AWARD "items have been mailed to their original owners"
+#define GAMBLER_SYSTEM_MSG_DUEL_WON "%s has been mailed his match winnings!" // %s = winnerName
+#define GAMBLER_SYSTEM_MSG_ITEM_VALIDATE_FAIL "An invalid item has caused the match to be stopped!"
+#define GAMBLER_SYSTEM_MSG_ITEM_NO_INV "The amount of items you can bet is invalid!"
+#define ARENA_GAMBLER_MSG_NOT_SAME_PLAYER "That is not the same person i requested the duel with!"
+#define ARENA_GAMBLER_MSG_PLAYER_NOT_FOUND "The player might be offline or away at the moment , i was not able to locate the player."
+#define ARENA_GAMBLER_MSG_MATCH_NOT_POSSIBLE "Duel is not accepted because of the following: "
+#define ARENA_GAMBLER_MSG_NO_GMS_ALLOWED "Game Masters are not allowed to duel!"
+#define ARENA_GAMBLER_MSG_SAME_ACC_ID "You cannot duel your self!"
+#define ARENA_GAMBLER_MSG_NOT_READY "You or your opponent has not set ready for the duel!"
+#define ARENA_GAMBLER_MSG_NO_ITEM "You or your opponent did not specify an item id!"
+#define ARENA_GAMBLER_MSG_NO_AMOUNT "You or your opponent did not specify an item amount!"
+#define ARENA_GAMBLER_MSG_MULTI_BOX "You cannot duel anyone with the same ip address!"
+#define ARENA_GAMBLER_MSG_LOW_LEVEL "Your level is too low to duel"
+#define ARENA_GAMBLER_MSG_MATCH_DATA "You have requested a duel from someone who already is in a duel."
+#define ARENA_GAMBLER_MSG_DIFF_NOT_MET "Your level is too high or too low to duel this player."
+#define ARENA_GAMBLER_MSG_CHALLENGE_ISSUED "You have challenged %s to a duel!"    // %s = defenders name
+#define ARENA_GAMBLER_MSG_CHALLENGED "%s wants to challenge you to a duel!"        // %s = challengers name
+#define ARENA_GAMBLER_MSG_ITEM_ADD_FAILED "You may not have the item, or the item could be soulbound, or you are not allowed to bet that item."
+#define ARENA_GAMBLER_MSG_BET_ADD_FAILED "The maximum amount of items you can bet is %u" // %u = maximum bet
+#define ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED "You may not have the item, or your bet is not the same as your opponent, or you have chosen a higher bet that allowed, your not allowed to duel this item."
+#define ARENA_GAMBLER_MSG_BET_AMOUNT_TOO_HIGH "The maximum number of items the player can recieve is lower than the amount betted."
+#define ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS "Your bet amount was entered successfully, please accept or reject the duel!"
+#define ARENA_GAMBLER_MSG_ITEM_ADD_SUCCESS "Your item was selected successfully, now select the amount you would like to bet!"
+
+// Intervals
+#define GAMBLER_SYSTEM_INTERVAL_TELE_CHECK 10000
+
+// Vars
+#define GAMBLER_SYSTEM_TOTAL_MAX_BET 1000
+
+#define MSG_COLOR_LIGHTRED      "|cffff6060"
+#define MSG_COLOR_LIGHTBLUE     "|cff00ccff"
+#define MSG_COLOR_BLUE          "|cff0000ff"
+#define MSG_COLOR_GREEN         "|cff00ff00"
+#define MSG_COLOR_RED           "|cffff0000"
+#define MSG_COLOR_GOLD          "|cffffcc00"
+#define MSG_COLOR_GREY          "|cff888888"
+#define MSG_COLOR_WHITE         "|cffffffff"
+#define MSG_COLOR_SUBWHITE      "|cffbbbbbb"
+#define MSG_COLOR_MAGENTA       "|cffff00ff"
+#define MSG_COLOR_YELLOW        "|cffffff00"
+#define MSG_COLOR_CYAN          "|cff00ffff"
+#define MSG_COLOR_ORANGE        "|cffff9900"
+
+#define QUALITY_POOR                 "cff9d9d9d"              //GREY
+#define QUALITY_NORMAL               "cffffffff"             //WHITE
+#define QUALITY_UNCOMMON             "cff1eff00"             //GREEN
+#define QUALITY_RARE                 "cff0070dd"             //BLUE
+#define QUALITY_EPIC                 "cffa335ee"             //PURPLE
+#define QUALITY_LEGENDARY            "cffff8000"             //ORANGE
+#define QUALITY_ARTIFACT             "cffe6cc80"             //LIGHT YELLOW
+#define QUALITY_HEIRLOOM             "cffe6cc80"              //LIGHT YELLOW
+
+enum MatchParticipants
+{
+    GAMBLER_CHALLENGER,
+    GAMBLER_DEFENDER,
+    GAMBLER_WINNER,
+    GAMBLER_MAX_MEMBERS,
+};
+
+enum GamberSystemConfigIndex
+{
+    GAMBLER_CONFIG_OPTION_MAPID,
+    GAMBLER_CONFIG_OPTION_COORDSX,
+    GAMBLER_CONFIG_OPTION_COORDSY,
+    GAMBLER_CONFIG_OPTION_COORDSZ,
+    GAMBLER_CONFIG_OPTION_COORDSO,
+    GAMBLER_CONFIG_OPTION_MIN_REQUIREDLEVEL,
+    GAMBLER_CONFIG_OPTION_MAX_LEVELDIFF,
+    GAMBLER_CONFIG_OPTION_AWARD_FLED,
+    GAMBLER_CONFIG_OPTION_MAX_BET,
+    GAMBLER_CONFIG_OPTION_ENABLE_GM,
+    GAMBLER_CONFIG_OPTION_ENABLE_SAMEIP,
+    GAMBLER_CONFIG_OPTION_ENABLE_LIMITS,
+    GAMBLER_CONFIG_OPTION_ONLY_CURRENCY,
+    GAMBLER_CONFIG_OPTION_EQUAL_DUELS
+};
+
+enum GamblerPlayerStatIndex
+{
+    GAMBLER_PLAYER_STAT_GUID,
+    GAMBLER_PLAYER_STAT_DUELS_LOST,
+    GAMBLER_PLAYER_STAT_DUELS_WON,
+    GAMBLER_PLAYER_STAT_DUELS_REFUSED,
+    GAMBLER_PLAYER_STAT_DUELS_TOTAL,
+    GAMBLER_PLAYER_STAT_MAX
+};
+
+enum GamblerMatchStatus
+{
+    GAMBLER_MATCH_STATUS_SETUP,
+    GAMBLER_MATCH_STATUS_TELEPORT,
+    GAMBLER_MATCH_STATUS_RUNNING,
+};
+
+struct GamblerMatchData
+{
+    public:
+        GamblerMatchData(uint32 Id, uint32 challengerGUID, uint32 defenderGUID)
+        {
+            SetMatchStatus(GAMBLER_MATCH_STATUS_SETUP);
+            SetChallengerGUID(challengerGUID);
+            SetDefenderGUID(defenderGUID);
+            SetChallengerReady(false);
+            SetDefenderReady(false);
+            SetMatchWinner(0);
+            matchId = Id;
+
+            for(uint8 i = 0; i < GAMBLER_MAX_MEMBERS-1; i++)
+                itemStorage[i] = 0;
+
+            for(uint8 i = 0; i < GAMBLER_MAX_MEMBERS-1; i++)
+                CountStorage[i] = 0;
+        }
+
+        GamblerMatchData(Field *pFields)
+        {
+            SetMatchStatus(GAMBLER_MATCH_STATUS_SETUP);
+            matchId    = pFields[0].GetUInt32();
+            SetChallengerGUID(pFields[1].GetUInt32());
+            SetDefenderGUID(pFields[2].GetUInt32());
+            SetChallengerItemId(pFields[3].GetUInt32());
+            SetChallengerItemCount(pFields[4].GetUInt32());
+            SetDefenderItemId(pFields[5].GetUInt32());
+            SetDefenderItemCount(pFields[6].GetUInt32());
+            SetMatchDate(pFields[7].GetString());
+            SetMatchWinner(pFields[8].GetUInt32());
+            SetChallengerReady(false);
+            SetDefenderReady(false);
+        }
+
+        // External Assignment Functions
+        void SetChallengerGUID(uint32 challengerGUID)    { _setMemberGUID(GAMBLER_CHALLENGER,    challengerGUID);    }
+        void SetDefenderGUID(uint32 defenderGUID)        { _setMemberGUID(GAMBLER_DEFENDER,        defenderGUID);        }
+        void SetChallengerItemId(uint32 itemId)            { _setMemberItemId(GAMBLER_CHALLENGER,    itemId);            }
+        void SetDefenderItemId(uint32 itemId)            { _setMemberItemId(GAMBLER_DEFENDER,    itemId);            }
+        void SetChallengerItemCount(uint32 amount)        { _setMemberItemCount(GAMBLER_CHALLENGER,    amount);        }
+        void SetDefenderItemCount(uint32 amount)        { _setMemberItemCount(GAMBLER_DEFENDER,    amount);            }
+        void SetChallengerReady(bool isReady)            { _setMemberReady(GAMBLER_CHALLENGER,    isReady);            }
+        void SetDefenderReady(bool isReady)                { _setMemberReady(GAMBLER_DEFENDER,        isReady);            }
+        void SetMatchWinner(uint32 winnerGUID)            { _setMemberGUID(GAMBLER_WINNER,        winnerGUID);        }
+        void SetMatchDate(std::string matchTime)        { matchDate = matchTime;                                    }
+        void SetMatchStatus(GamblerMatchStatus status)    { matchStatus = status;                                        }
+
+        // External Retrieval Functions
+        uint32 GetChallengerGUID()                        { return _getMemberGUID(GAMBLER_CHALLENGER);                }
+        uint32 GetDefenderGUID()                        { return _getMemberGUID(GAMBLER_DEFENDER);                    }
+        uint32 GetChallengerItemId()                    { return _getMemberItemId(GAMBLER_CHALLENGER);                }
+        uint32 GetDefenderItemId()                        { return _getMemberItemId(GAMBLER_DEFENDER);                }
+        uint32 GetChallengerItemCount()                    { return _getMemberItemCount(GAMBLER_CHALLENGER);            }
+        uint32 GetDefenderItemCount()                    { return _getMemberItemCount(GAMBLER_DEFENDER);                }
+        uint32 GetMatchWinner()                            { return _getMemberGUID(GAMBLER_WINNER);                    }
+        uint32 GetMatchId()                                { return matchId;                                            }
+        uint8 GetMatchStatus()                            { return matchStatus;                                        }
+        bool GetChallengerReady()                        { return _getMemberReadyStatus(GAMBLER_CHALLENGER);            }
+        bool GetDefenderReady()                            { return _getMemberReadyStatus(GAMBLER_DEFENDER);            }
+        std::string GetMatchDate()                        { return matchDate;                                            }
+
+        bool MatchStarted()
+        {
+            if(GetMatchStatus() >= GAMBLER_MATCH_STATUS_TELEPORT)
+                return true;
+            return false;
+        }
+
+        bool HasSetReady(Player *pPlayer)
+        {
+            if(IsChallenger(pPlayer))
+                return GetChallengerReady();
+            else
+                return GetDefenderReady();
+        }
+
+        uint32 GetItemIdBy(Player *pPlayer)
+        {
+            if(pPlayer->GetGUIDLow() == GetChallengerGUID())
+                return GetChallengerItemId();
+            else
+                return GetDefenderItemId();
+        }
+
+        uint32 GetItemCountBy(Player *pPlayer)
+        {
+            if(pPlayer->GetGUIDLow() == GetChallengerGUID())
+                return GetChallengerItemCount();
+            else
+                return GetDefenderItemCount();
+        }
+
+        // Misc Functions
+        bool IsChallenger(Player *pPlayer)
+        {
+            if(pPlayer->GetGUIDLow() == GetChallengerGUID())
+                return true;
+            return false;
+        }
+
+        bool IsDefender(Player *pPlayer) { return !IsChallenger(pPlayer); }
+
+    private:
+        // Internal Assignment Functions
+        void _setMemberGUID(MatchParticipants matchMember, uint32 memberGUID) { guidStorage[matchMember] = memberGUID; }
+        void _setMemberItemId(MatchParticipants matchMember, uint32 itemId)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            itemStorage[matchMember] = itemId;
+        }
+        void _setMemberItemCount(MatchParticipants matchMember, uint32 amount)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            CountStorage[matchMember] = amount;
+        }
+
+        void _setMemberReady(MatchParticipants matchMember, bool isReady)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            readyStatus[matchMember] = isReady;
+        }
+
+        // Internal Retrieval Functions
+        uint32 _getMemberGUID(MatchParticipants matchMember) { return guidStorage[matchMember]; }
+        uint32 _getMemberItemId(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return 0;
+            return itemStorage[matchMember];
+        }
+        uint32 _getMemberItemCount(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return 0;
+            return CountStorage[matchMember];
+        }
+
+        bool _getMemberReadyStatus(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return false;
+            return readyStatus[matchMember];
+        }
+
+    protected:
+        uint32 guidStorage[GAMBLER_MAX_MEMBERS];
+        uint32 itemStorage[GAMBLER_MAX_MEMBERS-1];
+        uint32 CountStorage[GAMBLER_MAX_MEMBERS-1];
+        uint32 matchId;
+        GamblerMatchStatus matchStatus;
+        bool readyStatus[GAMBLER_MAX_MEMBERS-1];
+        std::string matchDate;
+};
+
+typedef std::map<uint32, GamblerMatchData*> GamblerMatchMap;
+class GamblingSystem : public WorldScript
+{
+    public:
+        GamblingSystem();
+        ~GamblingSystem();
+
+        // Creation
+        void Initalize();
+
+        // Events
+        // Called on every world tick (don't execute too heavy code here).
+        void OnUpdate(uint32 diff);
+
+        // Database Interaction
+        void LoadConfigData();
+
+        // Match Data Retrieval
+        GamblerMatchData *GetMatchDataBy(Player *pPlayer);
+
+        // Match Requirements Checking
+        bool CanHaveMatch(Player *pChallenger, Player *pDefender);
+
+        // Match Setup
+        void SetupMatch(Player *pChallenger, Player *pDefender);
+        bool AddItemForMatch(Player *pPlayer, std::string itemName);
+        bool AddItemAmountForMatch(Player *pPlayer, uint32 amount);
+        void AcceptChallenge(Player *pPlayer);
+        void CancelChallenge(Player *pPlayer);
+
+        std::string GetQualityColor(int32 qualityType) const;
+
+        // Match Completion
+        void HandleMatchComplete(Player *pWinner, Player *pLoser, GamblerMatchData *matchData, DuelCompleteType completeType);
+
+        // Messaging
+        void SendMessageToPlayers(GamblerMatchData *matchData, const char *msgToSend, ...);
+
+
+    private:
+        // Database Interaction
+        void _loadPastMatches();
+        void _saveCurrentMatchProgress(GamblerMatchData *matchData);
+        void _updatePlayerStats(uint32 playerGUID, GamblerPlayerStatIndex statIndex, uint32 statIncreaseValue);
+
+        // Mail System
+        void _createItemAndMailToPlayer(Player *pPlayer, uint32 playerGUID, uint32 itemId, uint32 amount, std::string mailMessage);
+
+        // Mutex Wrappers
+        void AcquireMatchLock() { m_matchLock.acquire(); }
+        void ReleaseMatchLock() { m_matchLock.release(); }
+
+        // Match Data
+        bool _checkItemValidity(Item *pItem);
+        bool _checkItemValidity(uint32 itemId);
+        bool _checkWithinLimits(Item *pItem);
+        void _deleteMatchData(Player *pPlayer);
+        void _deleteMatchData(uint32 matchId);
+        uint32 _generateMatchId();
+    protected:
+
+        // Matches
+        ACE_Thread_Mutex m_matchLock;
+        GamblerMatchMap m_matchStorage;
+        IntervalTimer m_checkMatches;
+
+        // Config Data
+        WorldLocation m_arenaCoords;
+        uint32 m_minRequiredLevel;
+        uint8 m_maxLevelDiff;
+        uint32 m_highMatchId;
+        bool m_awardFled;
+        uint32 m_maxBet;
+        bool m_enableGM;
+        bool m_enableSameip;
+        bool m_enableLimits;
+        bool m_onlyCurrency;
+        bool m_equalDuels;
+};
+
+class GamblerDuelScript : PlayerScript
+{
+    public:
+    GamblerDuelScript() : PlayerScript(GAMBLER_SYSTEM_DUEL_SCRIPT_NAME) {}
+
+     // Called when a duel is requested
+    void OnDuelRequest(Player *pDefender, Player *pChallenger);
+    // Called when a duel ends
+    void OnDuelEnd(Player *pWinner, Player *pLoser, DuelCompleteType type);
+    // Called when a player logsout
+    void OnLogout(Player *pPlayer);
+};
+
+#define sGamblingSystem (*ACE_Singleton<GamblingSystem, ACE_Null_Mutex>::instance())
+#endif // ArenaGambler_H
\ No newline at end of file
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 80ebe36..20c2bc9 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -8,11 +8,11 @@
 # WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
 # implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
-# file(GLOB_RECURSE sources_Custom Custom/*.cpp Custom/*.h)
+file(GLOB_RECURSE sources_Custom Custom/*.cpp Custom/*.h)
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
-#  ${sources_Custom}
+  ${sources_Custom}
 )
 
 message("  -> Prepared: Custom")
diff --git a/src/server/scripts/Custom/Congrats_on_Level.cpp b/src/server/scripts/Custom/Congrats_on_Level.cpp
new file mode 100644
index 0000000..a509586
--- /dev/null
+++ b/src/server/scripts/Custom/Congrats_on_Level.cpp
@@ -0,0 +1,90 @@
+/*
+Idea and base script by Vextah.
+Help and fixes on original script by: Core surgeon & (cant remember other who initially helped but kudos)
+Modified by LordPsyan
+*/
+
+#include "ScriptMgr.h"
+
+class custom_CongratsOnLevel : public PlayerScript
+{
+public:
+    custom_CongratsOnLevel() : PlayerScript("custom_CongratsOnLevel") { }
+
+    void OnLevelChanged(Player* player, uint8 newLevel)
+    {
+        uint32 money, item, item2, spell;
+
+        switch(++newLevel)
+        {
+            case 10:
+        money = 100;
+        item = 8491;
+        item2 = 10393;
+        spell = 48161;
+        break;
+            case 20:
+        money = 150;
+        item = 8491;
+        item2 = 10393;
+        spell = 48161;
+        break;
+            case 30:
+        money = 200;
+        item = 8491;
+        item2 = 10393;
+        spell = 48161;
+        break;
+            case 40:
+        money = 250;
+        item = 8491;
+        item2 = 10393;
+        spell = 48161;
+        break;
+            case 50:
+        money = 350;
+        item = 8491;
+        item2 = 10393;
+        spell = 48161;
+        break;
+            case 60:
+        money = 450;
+        item = 8491;
+        item2 = 10393;
+        spell = 48161;
+        break;
+            case 70:
+        money = 500;
+        item = 8491;
+        item2 = 10393;
+        spell = 48161;
+        break;
+            case 80:
+        money = 1000;
+        item = 8491;
+        item2 = 10393;
+        spell = 48161;
+        break;
+            default:
+        return;
+        }
+
+        std::ostringstream ss;
+        ss << "|cffFF0000[Faction Gaming]|r Congrats to " << player->GetName() << " on reaching level " << (uint32)newLevel;
+        sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+
+        std::ostringstream ss2;
+        ss2 << "For your hard work and dedication you have been awarded " << money << " gold and a special item!";
+        player->GetSession()->SendNotification(ss2.str().c_str());
+
+        player->ModifyMoney(money*GOLD);
+    player->AddItem(item, 1);
+        player->AddItem(item2, 1);
+    player->learnSpell(spell, false);
+    }
+};
+
+void AddSC_custom_CongratsOnLevel()
+{
+    new custom_CongratsOnLevel();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Reforging.cpp b/src/server/scripts/Custom/Reforging.cpp
new file mode 100644
index 0000000..fcd2bbd
--- /dev/null
+++ b/src/server/scripts/Custom/Reforging.cpp
@@ -0,0 +1,548 @@
+#include "ScriptPCH.h"
+
+static const bool send_cache_packets = true;    // change player cache?
+
+// Remember to add to GetStatName too
+static const uint32 statTypes[] = { ITEM_MOD_SPIRIT, ITEM_MOD_DODGE_RATING, ITEM_MOD_PARRY_RATING, ITEM_MOD_HIT_RATING, ITEM_MOD_CRIT_RATING, ITEM_MOD_HASTE_RATING, ITEM_MOD_EXPERTISE_RATING };
+static const uint32 stat_type_max = sizeof(statTypes) / sizeof(*statTypes);
+
+typedef std::map<uint32, uint32> itemGuidMap;
+typedef std::unordered_map<uint32, itemGuidMap> playerItemMap;
+static playerItemMap playerItems; // playerItems[plrguid][itemguid] = entry;
+
+namespace
+{
+    static const char* GetStatName(uint32 ItemStatType)
+    {
+        switch(ItemStatType)
+        {
+        case ITEM_MOD_SPIRIT                   	: return "Spirit"; break;
+        case ITEM_MOD_DODGE_RATING             	: return "Dodge rating"; break;
+        case ITEM_MOD_PARRY_RATING             	: return "Parry rating"; break;
+        case ITEM_MOD_HIT_RATING               	: return "Hit rating"; break;
+        case ITEM_MOD_CRIT_RATING              	: return "Crit rating"; break;
+        case ITEM_MOD_HASTE_RATING             	: return "Haste rating"; break;
+        case ITEM_MOD_EXPERTISE_RATING         	: return "Expertise rating"; break;
+        default: return NULL;
+        }
+    }
+
+    static const char* GetSlotName(uint8 slot, WorldSession* session)
+    {
+        switch (slot)
+        {
+        case EQUIPMENT_SLOT_HEAD      : return "Head";
+        case EQUIPMENT_SLOT_SHOULDERS : return "Shoulders";
+        case EQUIPMENT_SLOT_CHEST     : return "Chest";
+        case EQUIPMENT_SLOT_WAIST     : return "Waist";
+        case EQUIPMENT_SLOT_LEGS      : return "Legs";
+        case EQUIPMENT_SLOT_FEET      : return "Feet";
+        case EQUIPMENT_SLOT_WRISTS    : return "Wrists";
+        case EQUIPMENT_SLOT_HANDS     : return "Hands";
+        case EQUIPMENT_SLOT_BACK      : return "Back";
+        case EQUIPMENT_SLOT_MAINHAND  : return "Main hand";
+        case EQUIPMENT_SLOT_OFFHAND   : return "Off hand";
+        case EQUIPMENT_SLOT_RANGED    : return "Ranged";
+        default: return NULL;
+        }
+    }
+
+    static Item* GetEquippedItem(Player* player, uint32 guidlow)
+    {
+        for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+            if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                if (pItem->GetGUIDLow() == guidlow)
+                    return pItem;
+        return NULL;
+    }
+
+    static void RemoveReforgeSave(Player* player, uint32 itemguid, bool update, bool database);
+    static void SendReforgePacket(Player* player, uint32 entry, uint32 lowguid = 0)
+    {
+        ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
+        FakeStatStruct* reforge = NULL;
+        if (lowguid)
+        {
+            if (sObjectMgr->_itemFakeStatStore.find(lowguid) != sObjectMgr->_itemFakeStatStore.end())
+                reforge = &sObjectMgr->_itemFakeStatStore[lowguid];
+            else
+                RemoveReforgeSave(player, lowguid, false, true);
+        }
+
+        // Update player cache (self only) pure visual.
+        // HandleItemQuerySingleOpcode copy paste
+        std::string Name        = pProto->Name1;
+        std::string Description = pProto->Description;
+        int loc_idx = player->GetSession()->GetSessionDbLocaleIndex();
+        if (loc_idx >= 0)
+        {
+            if (ItemLocale const* il = sObjectMgr->GetItemLocale(pProto->ItemId))
+            {
+                ObjectMgr::GetLocaleString(il->Name, loc_idx, Name);
+                ObjectMgr::GetLocaleString(il->Description, loc_idx, Description);
+            }
+        }
+        WorldPacket data(SMSG_ITEM_QUERY_SINGLE_RESPONSE, 600);
+        data << pProto->ItemId;
+        data << pProto->Class;
+        data << pProto->SubClass;
+        data << pProto->SoundOverrideSubclass;
+        data << Name;
+        data << uint8(0x00);                                //pProto->Name2; // blizz not send name there, just uint8(0x00); <-- \0 = empty string = empty name...
+        data << uint8(0x00);                                //pProto->Name3; // blizz not send name there, just uint8(0x00);
+        data << uint8(0x00);                                //pProto->Name4; // blizz not send name there, just uint8(0x00);
+        data << pProto->DisplayInfoID;
+        data << pProto->Quality;
+        data << pProto->Flags;
+        data << pProto->Flags2;
+        data << pProto->BuyPrice;
+        data << pProto->SellPrice;
+        data << pProto->InventoryType;
+        data << pProto->AllowableClass;
+        data << pProto->AllowableRace;
+        data << pProto->ItemLevel;
+        data << pProto->RequiredLevel;
+        data << pProto->RequiredSkill;
+        data << pProto->RequiredSkillRank;
+        data << pProto->RequiredSpell;
+        data << pProto->RequiredHonorRank;
+        data << pProto->RequiredCityRank;
+        data << pProto->RequiredReputationFaction;
+        data << pProto->RequiredReputationRank;
+        data << int32(pProto->MaxCount);
+        data << int32(pProto->Stackable);
+        data << pProto->ContainerSlots;
+        data << pProto->StatsCount + (reforge ? 1 : 0); // increase stat count by 1
+        bool decreased = false;
+        for (uint32 i = 0; i < pProto->StatsCount; ++i)
+        {
+            data << pProto->ItemStat[i].ItemStatType;
+            if (reforge && !decreased && pProto->ItemStat[i].ItemStatType == reforge->decrease)
+            {
+                data << pProto->ItemStat[i].ItemStatValue-reforge->stat_value;
+                decreased = true;
+            }
+            else
+                data << pProto->ItemStat[i].ItemStatValue;
+        }
+        if (reforge)
+        {
+            data << reforge->increase;      // set new stat type
+            data << reforge->stat_value;    // and value
+        }
+        data << pProto->ScalingStatDistribution;            // scaling stats distribution
+        data << pProto->ScalingStatValue;                   // some kind of flags used to determine stat values column
+        for (int i = 0; i < MAX_ITEM_PROTO_DAMAGES; ++i)
+        {
+            data << pProto->Damage[i].DamageMin;
+            data << pProto->Damage[i].DamageMax;
+            data << pProto->Damage[i].DamageType;
+        }
+
+        // resistances (7)
+        data << pProto->Armor;
+        data << pProto->HolyRes;
+        data << pProto->FireRes;
+        data << pProto->NatureRes;
+        data << pProto->FrostRes;
+        data << pProto->ShadowRes;
+        data << pProto->ArcaneRes;
+
+        data << pProto->Delay;
+        data << pProto->AmmoType;
+        data << pProto->RangedModRange;
+
+        for (int s = 0; s < MAX_ITEM_PROTO_SPELLS; ++s)
+        {
+            // send DBC data for cooldowns in same way as it used in Spell::SendSpellCooldown
+            // use `item_template` or if not set then only use spell cooldowns
+            SpellInfo const* spell = sSpellMgr->GetSpellInfo(pProto->Spells[s].SpellId);
+            if (spell)
+            {
+                bool db_data = pProto->Spells[s].SpellCooldown >= 0 || pProto->Spells[s].SpellCategoryCooldown >= 0;
+
+                data << pProto->Spells[s].SpellId;
+                data << pProto->Spells[s].SpellTrigger;
+                data << uint32(-abs(pProto->Spells[s].SpellCharges));
+
+                if (db_data)
+                {
+                    data << uint32(pProto->Spells[s].SpellCooldown);
+                    data << uint32(pProto->Spells[s].SpellCategory);
+                    data << uint32(pProto->Spells[s].SpellCategoryCooldown);
+                }
+                else
+                {
+                    data << uint32(spell->RecoveryTime);
+                    data << uint32(spell->GetCategory());
+                    data << uint32(spell->CategoryRecoveryTime);
+                }
+            }
+            else
+            {
+                data << uint32(0);
+                data << uint32(0);
+                data << uint32(0);
+                data << uint32(-1);
+                data << uint32(0);
+                data << uint32(-1);
+            }
+        }
+        data << pProto->Bonding;
+        data << Description;
+        data << pProto->PageText;
+        data << pProto->LanguageID;
+        data << pProto->PageMaterial;
+        data << pProto->StartQuest;
+        data << pProto->LockID;
+        data << int32(pProto->Material);
+        data << pProto->Sheath;
+        data << pProto->RandomProperty;
+        data << pProto->RandomSuffix;
+        data << pProto->Block;
+        data << pProto->ItemSet;
+        data << pProto->MaxDurability;
+        data << pProto->Area;
+        data << pProto->Map;                                // Added in 1.12.x & 2.0.1 client branch
+        data << pProto->BagFamily;
+        data << pProto->TotemCategory;
+        for (int s = 0; s < MAX_ITEM_PROTO_SOCKETS; ++s)
+        {
+            data << pProto->Socket[s].Color;
+            data << pProto->Socket[s].Content;
+        }
+        data << pProto->socketBonus;
+        data << pProto->GemProperties;
+        data << pProto->RequiredDisenchantSkill;
+        data << pProto->ArmorDamageModifier;
+        data << pProto->Duration;                           // added in 2.4.2.8209, duration (seconds)
+        data << pProto->ItemLimitCategory;                  // WotLK, ItemLimitCategory
+        data << pProto->HolidayId;                          // Holiday.dbc?
+        player->GetSession()->SendPacket(&data);
+    }
+
+    static void SendReforgePackets(Player* player)
+    {
+        if (!send_cache_packets)
+            return;
+        if (playerItems.find(player->GetGUIDLow()) == playerItems.end())
+            return;
+        for (itemGuidMap::const_iterator it = playerItems[player->GetGUIDLow()].begin(); it != playerItems[player->GetGUIDLow()].end();)
+        {
+            itemGuidMap::const_iterator old_it = it++;
+            SendReforgePacket(player, old_it->second, old_it->first);
+        }
+    }
+
+    static void RemoveReforgeSave(Player* player, uint32 itemguid, bool update, bool database)
+    {
+        uint32 lowguid = player->GetGUIDLow();
+        Item* invItem = update ? player->GetItemByGuid(MAKE_NEW_GUID(itemguid, 0, HIGHGUID_ITEM)) : NULL;
+        if (invItem)
+            player->_ApplyItemMods(invItem, invItem->GetSlot(), false);
+        if (playerItems.find(lowguid) != playerItems.end())
+            playerItems[lowguid].erase(itemguid);
+        sObjectMgr->_itemFakeStatStore.erase(itemguid);
+        if (invItem)
+            player->_ApplyItemMods(invItem, invItem->GetSlot(), true);
+
+        if (!database)
+            return;
+        CharacterDatabase.PExecute("DELETE FROM `custom_reforges` WHERE `GUID` = %u", itemguid);
+        if (invItem)
+            SendReforgePacket(player, invItem->GetEntry());
+        player->SaveToDB();
+    }
+
+    static bool IsReforgable(Item* invItem, Player* player)
+    {
+        /*if (!invItem->IsEquipped())
+        return false;*/
+        if (invItem->GetOwnerGUID() != player->GetGUID())
+            return false;
+        const ItemTemplate* pProto = invItem->GetTemplate();
+        //if (pProto->ItemLevel < 200) // WOTLK items have less itemlevel than CATA
+        //    return false;
+        if (pProto->Quality == ITEM_QUALITY_HEIRLOOM) // block heirlooms necessary? probably.
+            return false;
+        if (!pProto->StatsCount || pProto->StatsCount >= MAX_ITEM_PROTO_STATS)
+            return false;
+        if (sObjectMgr->_itemFakeStatStore.find(invItem->GetGUIDLow()) != sObjectMgr->_itemFakeStatStore.end())
+            return false;
+        for (uint32 i = 0; i < pProto->StatsCount; ++i)
+        {
+            if (!GetStatName(pProto->ItemStat[i].ItemStatType))
+                continue;
+            if (((int32)floorf((float)pProto->ItemStat[i].ItemStatValue * 0.4f)) > 1)
+                return true;
+        }
+        return false;
+    }
+
+    static void UpdatePlayerReforgeStats(Item* invItem, Player* player, uint32 decrease, uint32 increase) // stat types
+    {
+        const ItemTemplate* pProto = invItem->GetTemplate();
+
+        int32 stat_diff = 0;
+        for (uint32 i = 0; i < pProto->StatsCount; i++)
+        {
+            if (pProto->ItemStat[i].ItemStatType == increase)
+                return; // Should not have the increased stat already
+            if (pProto->ItemStat[i].ItemStatType == decrease)
+                stat_diff = (int32)floorf((float)pProto->ItemStat[i].ItemStatValue * 0.4f);
+        }
+        if (stat_diff <= 0)
+            return; // Should have some kind of diff
+
+        // Update player stats
+        player->_ApplyItemMods(invItem, invItem->GetSlot(), false);
+        uint32 guidlow = invItem->GetGUIDLow();
+        sObjectMgr->_itemFakeStatStore[guidlow].increase = increase;
+        sObjectMgr->_itemFakeStatStore[guidlow].decrease = decrease;
+        sObjectMgr->_itemFakeStatStore[guidlow].stat_value = stat_diff;
+        player->_ApplyItemMods(invItem, invItem->GetSlot(), true);
+        CharacterDatabase.PExecute("REPLACE INTO `custom_reforges` (`GUID`, `increase`, `decrease`, `stat_value`) VALUES (%u, %u, %u, %i)", guidlow, increase, decrease, stat_diff);
+        player->ModifyMoney(pProto->SellPrice < (10*GOLD) ? (-10*GOLD) : -(int32)pProto->SellPrice);
+        SendReforgePacket(player, invItem->GetEntry(), guidlow);
+        player->SaveToDB();
+    }
+}
+
+class REFORGE_PLAYER : public PlayerScript
+{
+public:
+    REFORGE_PLAYER() : PlayerScript("REFORGE_PLAYER")
+    {
+        CharacterDatabase.Execute("DELETE FROM `custom_reforges` WHERE NOT EXISTS (SELECT 1 FROM `item_instance` WHERE `item_instance`.`guid` = `custom_reforges`.`GUID`)");
+    }
+
+    class SendRefPackLogin : public BasicEvent
+    {
+    public:
+        SendRefPackLogin(Player* _player) : player(_player)
+        {
+            _player->m_Events.AddEvent(this, _player->m_Events.CalculateTime(1000));
+        }
+
+        bool Execute(uint64, uint32)
+        {
+            SendReforgePackets(player);
+            return true;
+        }
+        Player* player;
+    };
+
+    void OnLogin(Player* player)
+    {
+        uint32 playerGUID = player->GetGUIDLow();
+        QueryResult result = CharacterDatabase.PQuery("SELECT custom_reforges.`GUID`, `increase`, `decrease`, `stat_value`, item_instance.itementry FROM `custom_reforges`, item_instance WHERE item_instance.`owner_guid` = %u and item_instance.`guid` = custom_reforges.GUID", playerGUID);
+        if (result)
+        {
+            do
+            {
+                uint32 lowGUID = (*result)[0].GetUInt32();
+                uint32 entry = (*result)[4].GetUInt32();
+                Item* invItem = player->GetItemByGuid(MAKE_NEW_GUID(lowGUID, 0, HIGHGUID_ITEM));
+                if (invItem)
+                    player->_ApplyItemMods(invItem, invItem->GetSlot(), false);
+                sObjectMgr->_itemFakeStatStore[lowGUID].increase = (*result)[1].GetUInt32();
+                sObjectMgr->_itemFakeStatStore[lowGUID].decrease = (*result)[2].GetUInt32();
+                sObjectMgr->_itemFakeStatStore[lowGUID].stat_value = (*result)[3].GetInt32();
+                playerItems[playerGUID][lowGUID] = entry;
+                if (invItem)
+                    player->_ApplyItemMods(invItem, invItem->GetSlot(), true);
+                // SendReforgePacket(player, entry, lowGUID);
+            } while (result->NextRow());
+
+            // SendReforgePackets(player);
+            new SendRefPackLogin(player);
+        }
+    }
+
+    void OnLogout(Player* player)
+    {
+        if (playerItems.find(player->GetGUIDLow()) == playerItems.end())
+            return;
+        for (itemGuidMap::const_iterator it = playerItems[player->GetGUIDLow()].begin(); it != playerItems[player->GetGUIDLow()].end();)
+        {
+            itemGuidMap::const_iterator old_it = it++;
+            RemoveReforgeSave(player, old_it->first, false, false);
+        }
+    }
+};
+
+class REFORGER_NPC : public CreatureScript
+{
+public:
+    REFORGER_NPC() : CreatureScript("REFORGER_NPC") { }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        selectedItem.erase(player->GetGUIDLow());
+
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Select slot of the item to reforge:", MAIN_MENU, 0);
+        for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+        {
+            if (Item* invItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                if (IsReforgable(invItem, player))
+                    if (const char* slotname = GetSlotName(slot, player->GetSession()))
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, slotname, SELECT_STAT_REDUCE, slot);
+        }
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, "Remove reforges", SELECT_RESTORE, 0);
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update menu", MAIN_MENU, 0);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        switch(sender)
+        {
+        case MAIN_MENU: OnGossipHello(player, creature); break;
+        case SELECT_STAT_REDUCE:
+            // action = slot
+            if (Item* invItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, action))
+            {
+                if (IsReforgable(invItem, player))
+                {
+                    selectedItem[player->GetGUIDLow()] = invItem->GetGUIDLow();
+                    const ItemTemplate* pProto = invItem->GetTemplate();
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Stat to decrease:", sender, action);
+                    for (uint32 i = 0; i < pProto->StatsCount; ++i)
+                    {
+                        int32 stat_diff = ((int32)floorf((float)pProto->ItemStat[i].ItemStatValue * 0.4f));
+                        if (stat_diff > 1)
+                            if (const char* stat_name = GetStatName(pProto->ItemStat[i].ItemStatType))
+                            {
+                                std::ostringstream oss;
+                                oss << stat_name << " (" << pProto->ItemStat[i].ItemStatValue << " |cFFDB2222-" << stat_diff << "|r)";
+                                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, oss.str(), SELECT_STAT_INCREASE, i);
+                            }
+                    }
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", MAIN_MENU, 0);
+                    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+                }
+                else
+                {
+                    player->GetSession()->SendNotification("Invalid item selected");
+                    OnGossipHello(player, creature);
+                }
+            }
+            else
+            {
+                player->GetSession()->SendNotification("Invalid item selected");
+                OnGossipHello(player, creature);
+            }
+            break;
+        case SELECT_STAT_INCREASE:
+            // action = StatsCount id
+            {
+                Item* invItem = GetEquippedItem(player, selectedItem[player->GetGUIDLow()]);
+                if (invItem)
+                {
+                    const ItemTemplate* pProto = invItem->GetTemplate();
+                    int32 stat_diff = ((int32)floorf((float)pProto->ItemStat[action].ItemStatValue * 0.4f));
+
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Stat to increase:", sender, action);
+                    for (uint32 i = 0; i < stat_type_max; ++i)
+                    {
+                        bool cont = false;
+                        for (uint32 j = 0; j < pProto->StatsCount; ++j)
+                        {
+                            if (statTypes[i] == pProto->ItemStat[j].ItemStatType) // skip existing stats on item
+                            {
+                                cont = true;
+                                break;
+                            }
+                        }
+                        if (cont)
+                            continue;
+                        if (const char* stat_name = GetStatName(statTypes[i]))
+                        {
+                            std::ostringstream oss;
+                            oss << stat_name << " |cFF3ECB3C+" << stat_diff << "|r";
+                            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_INTERACT_1, oss.str(), pProto->ItemStat[action].ItemStatType, statTypes[i], "Are you sure you want to reforge\n\n"+pProto->Name1, (pProto->SellPrice < (10*GOLD) ? (10*GOLD) : pProto->SellPrice), false);
+                        }
+                    }
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", SELECT_STAT_REDUCE, invItem->GetSlot());
+                    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+                }
+                else
+                {
+                    player->GetSession()->SendNotification("Invalid item selected");
+                    OnGossipHello(player, creature);
+                }
+            }
+            break;
+        case SELECT_RESTORE:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Select slot to remove reforge from:", sender, action);
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+                {
+                    if (Item* invItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                        if (sObjectMgr->_itemFakeStatStore.find(invItem->GetGUIDLow()) != sObjectMgr->_itemFakeStatStore.end())
+                            if (const char* slotname = GetSlotName(slot, player->GetSession()))
+                                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_INTERACT_1, slotname, RESTORE, slot, "Really remove reforge from\n\n"+std::string(slotname), 0, false);
+                }
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update menu", sender, action);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", MAIN_MENU, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            }
+            break;
+        case RESTORE:
+            // action = slot
+            {
+                if (Item* invItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, action))
+                {
+                    if (sObjectMgr->_itemFakeStatStore.find(invItem->GetGUIDLow()) != sObjectMgr->_itemFakeStatStore.end())
+                        RemoveReforgeSave(player, invItem->GetGUIDLow(), true, true);
+                }
+                OnGossipHello(player, creature);
+            }
+            break;
+        default: // Reforge
+            // sender = stat type to decrease, action = stat type to increase
+            {
+                Item* invItem = GetEquippedItem(player, selectedItem[player->GetGUIDLow()]);
+                if (invItem && IsReforgable(invItem, player))
+                {
+                    if (player->HasEnoughMoney(invItem->GetTemplate()->SellPrice < (10*GOLD) ? (10*GOLD) : invItem->GetTemplate()->SellPrice))
+                    {
+                        // int32 stat_diff = ((int32)floorf((float)invItem->GetTemplate()->ItemStat[action].ItemStatValue * 0.4f));
+                        UpdatePlayerReforgeStats(invItem, player, sender, action); // rewrite this function
+                    }
+                    else
+                        player->GetSession()->SendNotification("Not enough money");
+                }
+                else
+                    player->GetSession()->SendNotification("Invalid item selected");
+                OnGossipHello(player, creature);
+            }
+        }
+        return true;
+    }
+
+    enum Senders
+    {
+        MAIN_MENU = 100,
+        SELECT_ITEM,
+        SELECT_STAT_REDUCE,
+        SELECT_STAT_INCREASE,
+        SELECT_RESTORE,
+        RESTORE,
+        REFORGE,
+    };
+
+private:
+
+    std::unordered_map<uint32, uint32> selectedItem;
+};
+
+void AddSC_REFORGER_NPC()
+{
+    new REFORGER_NPC;
+    new REFORGE_PLAYER;
+}
+
+#undef FOR_REFORGE_ITEMS
diff --git a/src/server/scripts/Custom/Transmogrification.cpp b/src/server/scripts/Custom/Transmogrification.cpp
new file mode 100644
index 0000000..fffad65
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrification.cpp
@@ -0,0 +1,868 @@
+#include "ScriptPCH.h"
+#include "Config.h"
+#include "Language.h"
+#include "Transmogrification.h"
+
+#ifdef PRESETS
+void Transmogrification::PresetTransmog(Player* player, Item* itemTransmogrified, uint32 fakeEntry, uint8 slot)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::PresetTransmog");
+
+    if (!EnableSets)
+        return;
+    if (!player || !itemTransmogrified)
+        return;
+    if (slot >= EQUIPMENT_SLOT_END)
+        return;
+    if (!CanTransmogrifyItemWithItem(player, itemTransmogrified->GetTemplate(), sObjectMgr->GetItemTemplate(fakeEntry)))
+        return;
+
+    SetFakeEntry(player, itemTransmogrified, fakeEntry);
+
+    itemTransmogrified->UpdatePlayedTime(player);
+
+    itemTransmogrified->SetOwnerGUID(player->GetGUID());
+    itemTransmogrified->SetNotRefundable(player);
+    itemTransmogrified->ClearSoulboundTradeable(player);
+}
+
+void Transmogrification::LoadPlayerSets(uint64 pGUID)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::LoadPlayerSets");
+
+    presetMap.Remove(pGUID);
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT `PresetID`, `SetName`, `SetData` FROM `custom_transmogrification_sets` WHERE Owner = %u", GUID_LOPART(pGUID));
+    if (!result)
+        return;
+
+    // Locklessly store the presets for loading and then in the end push them all to store with lock.
+    presetIdMap presets;
+
+    do
+    {
+        Field* field = result->Fetch();
+        uint8 PresetID = field[0].GetUInt8();
+        std::string SetName = field[1].GetString();
+        std::istringstream SetData(field[2].GetString());
+
+        presets[PresetID].name = SetName;
+
+        while (SetData.good())
+        {
+            uint32 slot;
+            uint32 entry;
+            SetData >> slot >> entry;
+            if (SetData.fail())
+                break;
+            if (slot >= EQUIPMENT_SLOT_END)
+            {
+                TC_LOG_ERROR("custom.transmog", "Item entry (FakeEntry: %u, playerGUID: %u, slot: %u, presetId: %u) has invalid slot, ignoring.", entry, GUID_LOPART(pGUID), uint32(slot), uint32(PresetID));
+                continue;
+            }
+            if (sObjectMgr->GetItemTemplate(entry))
+            {
+                presets[PresetID].slotMap[slot] = entry;
+            }
+            else
+                TC_LOG_ERROR("custom.transmog", "Item entry (FakeEntry: %u, playerGUID: %u, slot: %u, presetId: %u) does not exist, ignoring.", entry, GUID_LOPART(pGUID), uint32(slot), uint32(PresetID));
+        }
+
+        if (presets[PresetID].slotMap.empty())
+        {
+            // Should never happen
+            presets.erase(PresetID);
+            CharacterDatabase.PExecute("DELETE FROM `custom_transmogrification_sets` WHERE Owner = %u AND PresetID = %u", GUID_LOPART(pGUID), uint32(PresetID));
+            return;
+        }
+
+    } while (result->NextRow());
+
+    // locked insert
+    presetMap.Insert(pGUID, presets);
+}
+
+void Transmogrification::UnloadPlayerSets(uint64 pGUID)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::UnloadPlayerSets");
+    // underlying maps and structs should be automatically erased
+    presetMap.Remove(pGUID);
+}
+#endif
+
+const char* Transmogrification::GetSlotName(uint8 slot, WorldSession* session) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetSlotName");
+
+    switch (slot)
+    {
+    case EQUIPMENT_SLOT_HEAD: return  "Head";// session->GetTrinityString(LANG_SLOT_NAME_HEAD);
+    case EQUIPMENT_SLOT_SHOULDERS: return  "Shoulders";// session->GetTrinityString(LANG_SLOT_NAME_SHOULDERS);
+    case EQUIPMENT_SLOT_BODY: return  "Shirt";// session->GetTrinityString(LANG_SLOT_NAME_BODY);
+    case EQUIPMENT_SLOT_CHEST: return  "Chest";// session->GetTrinityString(LANG_SLOT_NAME_CHEST);
+    case EQUIPMENT_SLOT_WAIST: return  "Waist";// session->GetTrinityString(LANG_SLOT_NAME_WAIST);
+    case EQUIPMENT_SLOT_LEGS: return  "Legs";// session->GetTrinityString(LANG_SLOT_NAME_LEGS);
+    case EQUIPMENT_SLOT_FEET: return  "Feet";// session->GetTrinityString(LANG_SLOT_NAME_FEET);
+    case EQUIPMENT_SLOT_WRISTS: return  "Wrists";// session->GetTrinityString(LANG_SLOT_NAME_WRISTS);
+    case EQUIPMENT_SLOT_HANDS: return  "Hands";// session->GetTrinityString(LANG_SLOT_NAME_HANDS);
+    case EQUIPMENT_SLOT_BACK: return  "Back";// session->GetTrinityString(LANG_SLOT_NAME_BACK);
+    case EQUIPMENT_SLOT_MAINHAND: return  "Main hand";// session->GetTrinityString(LANG_SLOT_NAME_MAINHAND);
+    case EQUIPMENT_SLOT_OFFHAND: return  "Off hand";// session->GetTrinityString(LANG_SLOT_NAME_OFFHAND);
+    case EQUIPMENT_SLOT_RANGED: return  "Ranged";// session->GetTrinityString(LANG_SLOT_NAME_RANGED);
+    case EQUIPMENT_SLOT_TABARD: return  "Tabard";// session->GetTrinityString(LANG_SLOT_NAME_TABARD);
+    default: return NULL;
+    }
+}
+
+std::string Transmogrification::GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetItemIcon");
+
+    std::ostringstream ss;
+    ss << "|TInterface";
+    const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+    const ItemDisplayInfoEntry* dispInfo = NULL;
+    if (temp)
+    {
+        dispInfo = sItemDisplayInfoStore.LookupEntry(temp->DisplayInfoID);
+        if (dispInfo)
+            ss << "/ICONS/" << dispInfo->inventoryIcon;
+    }
+    if (!dispInfo)
+        ss << "/InventoryItems/WoWUnknownItem01";
+    ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+    return ss.str();
+}
+
+std::string Transmogrification::GetSlotIcon(uint8 slot, uint32 width, uint32 height, int x, int y) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetSlotIcon");
+
+    std::ostringstream ss;
+    ss << "|TInterface/PaperDoll/";
+    switch (slot)
+    {
+    case EQUIPMENT_SLOT_HEAD: ss << "UI-PaperDoll-Slot-Head"; break;
+    case EQUIPMENT_SLOT_SHOULDERS: ss << "UI-PaperDoll-Slot-Shoulder"; break;
+    case EQUIPMENT_SLOT_BODY: ss << "UI-PaperDoll-Slot-Shirt"; break;
+    case EQUIPMENT_SLOT_CHEST: ss << "UI-PaperDoll-Slot-Chest"; break;
+    case EQUIPMENT_SLOT_WAIST: ss << "UI-PaperDoll-Slot-Waist"; break;
+    case EQUIPMENT_SLOT_LEGS: ss << "UI-PaperDoll-Slot-Legs"; break;
+    case EQUIPMENT_SLOT_FEET: ss << "UI-PaperDoll-Slot-Feet"; break;
+    case EQUIPMENT_SLOT_WRISTS: ss << "UI-PaperDoll-Slot-Wrists"; break;
+    case EQUIPMENT_SLOT_HANDS: ss << "UI-PaperDoll-Slot-Hands"; break;
+    case EQUIPMENT_SLOT_BACK: ss << "UI-PaperDoll-Slot-Chest"; break;
+    case EQUIPMENT_SLOT_MAINHAND: ss << "UI-PaperDoll-Slot-MainHand"; break;
+    case EQUIPMENT_SLOT_OFFHAND: ss << "UI-PaperDoll-Slot-SecondaryHand"; break;
+    case EQUIPMENT_SLOT_RANGED: ss << "UI-PaperDoll-Slot-Ranged"; break;
+    case EQUIPMENT_SLOT_TABARD: ss << "UI-PaperDoll-Slot-Tabard"; break;
+    default: ss << "UI-Backpack-EmptySlot";
+    }
+    ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+    return ss.str();
+}
+
+std::string Transmogrification::GetItemLink(Item* item, WorldSession* session) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetItemLink");
+
+    int loc_idx = session->GetSessionDbLocaleIndex();
+    const ItemTemplate* temp = item->GetTemplate();
+    std::string name = temp->Name1;
+    if (ItemLocale const* il = sObjectMgr->GetItemLocale(temp->ItemId))
+        ObjectMgr::GetLocaleString(il->Name, loc_idx, name);
+
+    if (int32 itemRandPropId = item->GetItemRandomPropertyId())
+    {
+        char* const* suffix = NULL;
+        if (itemRandPropId < 0)
+        {
+            const ItemRandomSuffixEntry* itemRandEntry = sItemRandomSuffixStore.LookupEntry(-item->GetItemRandomPropertyId());
+            if (itemRandEntry)
+                suffix = itemRandEntry->nameSuffix;
+        }
+        else
+        {
+            const ItemRandomPropertiesEntry* itemRandEntry = sItemRandomPropertiesStore.LookupEntry(item->GetItemRandomPropertyId());
+            if (itemRandEntry)
+                suffix = itemRandEntry->nameSuffix;
+        }
+        if (suffix)
+        {
+            std::string test(suffix[(name != temp->Name1) ? loc_idx : DEFAULT_LOCALE]);
+            if (!test.empty())
+            {
+                name += ' ';
+                name += test;
+            }
+        }
+    }
+
+    std::ostringstream oss;
+    oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+        "|Hitem:" << temp->ItemId << ":" <<
+        item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3) << ":" <<
+        item->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT) << ":" <<
+        item->GetItemRandomPropertyId() << ":" << item->GetItemSuffixFactor() << ":" <<
+        (uint32)item->GetOwner()->getLevel() << "|h[" << name << "]|h|r";
+
+    return oss.str();
+}
+
+std::string Transmogrification::GetItemLink(uint32 entry, WorldSession* session) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetItemLink");
+
+    const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+    int loc_idx = session->GetSessionDbLocaleIndex();
+    std::string name = temp->Name1;
+    if (ItemLocale const* il = sObjectMgr->GetItemLocale(entry))
+        ObjectMgr::GetLocaleString(il->Name, loc_idx, name);
+
+    std::ostringstream oss;
+    oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+        "|Hitem:" << entry << ":0:0:0:0:0:0:0:0:0|h[" << name << "]|h|r";
+
+    return oss.str();
+}
+
+uint32 Transmogrification::GetFakeEntry(const Item* item)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetFakeEntry");
+
+    TRINITY_READ_GUARD(transmogMap::LockType, entryMap.GetLock());
+    transmogMap::MapType& data = entryMap.GetContainer();
+    transmogMap::MapType::const_iterator itr = data.find(item->GetOwnerGUID());
+    if (itr == data.end()) return 0;
+    transmogData::const_iterator itr2 = itr->second.find(item->GetGUID());
+    if (itr2 == itr->second.end()) return 0;
+    return itr2->second;
+}
+
+void Transmogrification::UpdateItem(Player* player, Item* item) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::UpdateItem");
+
+    if (item->IsEquipped())
+    {
+        player->SetVisibleItemSlot(item->GetSlot(), item);
+        if (player->IsInWorld())
+            item->SendUpdateToPlayer(player);
+    }
+}
+
+void Transmogrification::DeleteFakeEntry(Player* player, Item* item)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::DeleteFakeEntry");
+
+    {
+        TRINITY_WRITE_GUARD(transmogMap::LockType, entryMap.GetLock());
+        transmogMap::MapType& data = entryMap.GetContainer();
+        transmogMap::MapType::iterator itr = data.find(player->GetGUID());
+        if (itr != data.end())
+        {
+            itr->second.erase(item->GetGUID());
+            if (itr->second.empty())
+                data.erase(player->GetGUID());
+        }
+    }
+
+    UpdateItem(player, item);
+}
+
+void Transmogrification::SetFakeEntry(Player* player, Item* item, uint32 entry)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::SetFakeEntry");
+
+    {
+        TRINITY_WRITE_GUARD(transmogMap::LockType, entryMap.GetLock());
+        entryMap.GetContainer()[player->GetGUID()][item->GetGUID()] = entry;
+    }
+
+    UpdateItem(player, item);
+}
+
+TransmogTrinityStrings Transmogrification::Transmogrify(Player* player, uint64 itemGUID, uint8 slot, bool no_cost)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify");
+
+    // slot of the transmogrified item
+    if (slot >= EQUIPMENT_SLOT_END)
+    {
+        TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - Player (GUID: %u, name: %s) tried to transmogrify an item (lowguid: %u) with a wrong slot (%u) when transmogrifying items.", player->GetGUIDLow(), player->GetName().c_str(), GUID_LOPART(itemGUID), slot);
+        return LANG_ERR_TRANSMOG_INVALID_SLOT;
+    }
+
+    Item* itemTransmogrifier = NULL;
+    // guid of the transmogrifier item, if it's not 0
+    if (itemGUID)
+    {
+        itemTransmogrifier = player->GetItemByGuid(itemGUID);
+        if (!itemTransmogrifier)
+        {
+            TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - Player (GUID: %u, name: %s) tried to transmogrify with an invalid item (lowguid: %u).", player->GetGUIDLow(), player->GetName().c_str(), GUID_LOPART(itemGUID));
+            return LANG_ERR_TRANSMOG_MISSING_SRC_ITEM;
+        }
+    }
+
+    // transmogrified item
+    Item* itemTransmogrified = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+    if (!itemTransmogrified)
+    {
+        TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - Player (GUID: %u, name: %s) tried to transmogrify an invalid item in a valid slot (slot: %u).", player->GetGUIDLow(), player->GetName().c_str(), slot);
+        return LANG_ERR_TRANSMOG_MISSING_DEST_ITEM;
+    }
+
+    if (!itemTransmogrifier) // reset look newEntry
+    {
+        DeleteFakeEntry(player, itemTransmogrified);
+    }
+    else
+    {
+        if (!CanTransmogrifyItemWithItem(player, itemTransmogrified->GetTemplate(), itemTransmogrifier->GetTemplate()))
+        {
+            TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - Player (GUID: %u, name: %s) failed CanTransmogrifyItemWithItem (%u with %u).", player->GetGUIDLow(), player->GetName().c_str(), itemTransmogrified->GetEntry(), itemTransmogrifier->GetEntry());
+            return LANG_ERR_TRANSMOG_INVALID_ITEMS;
+        }
+
+        if (!no_cost)
+        {
+            if (RequireToken)
+            {
+                if (player->HasItemCount(TokenEntry, TokenAmount))
+                    player->DestroyItemCount(TokenEntry, TokenAmount, true);
+                else
+                    return LANG_ERR_TRANSMOG_NOT_ENOUGH_TOKENS;
+            }
+
+            int32 cost = 0;
+            cost = GetSpecialPrice(itemTransmogrified->GetTemplate());
+            cost *= ScaledCostModifier;
+            cost += CopperCost;
+
+            if (cost) // 0 cost if reverting look
+            {
+                if (cost < 0)
+                    TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - Player (GUID: %u, name: %s) transmogrification invalid cost (non negative, amount %i). Transmogrified %u with %u", player->GetGUIDLow(), player->GetName().c_str(), -cost, itemTransmogrified->GetEntry(), itemTransmogrifier->GetEntry());
+                else
+                {
+                    if (!player->HasEnoughMoney(cost))
+                        return LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY;
+                    player->ModifyMoney(-cost, false);
+                }
+            }
+        }
+
+        SetFakeEntry(player, itemTransmogrified, itemTransmogrifier->GetEntry());
+
+        itemTransmogrified->UpdatePlayedTime(player);
+
+        itemTransmogrified->SetOwnerGUID(player->GetGUID());
+        itemTransmogrified->SetNotRefundable(player);
+        itemTransmogrified->ClearSoulboundTradeable(player);
+
+        if (itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_USE)
+            itemTransmogrifier->SetBinding(true);
+
+        itemTransmogrifier->SetOwnerGUID(player->GetGUID());
+        itemTransmogrifier->SetNotRefundable(player);
+        itemTransmogrifier->ClearSoulboundTradeable(player);
+    }
+
+    return LANG_ERR_TRANSMOG_OK;
+}
+
+bool Transmogrification::CanTransmogrifyItemWithItem(Player* player, ItemTemplate const* target, ItemTemplate const* source) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::CanTransmogrifyItemWithItem");
+
+    if (!target || !source)
+        return false;
+
+    if (source->ItemId == target->ItemId)
+        return false;
+
+    if (!SuitableForTransmogrification(player, target) || !SuitableForTransmogrification(player, source)) // if (!transmogrified->CanTransmogrify() || !transmogrifier->CanBeTransmogrified())
+        return false;
+
+    if (source->InventoryType == INVTYPE_BAG ||
+        source->InventoryType == INVTYPE_RELIC ||
+        // source->InventoryType == INVTYPE_BODY ||
+        source->InventoryType == INVTYPE_FINGER ||
+        source->InventoryType == INVTYPE_TRINKET ||
+        source->InventoryType == INVTYPE_AMMO ||
+        source->InventoryType == INVTYPE_QUIVER)
+        return false;
+
+    // TC doesnt check this? Checked by Inventory type check.
+    if (source->Class != target->Class)
+        return false;
+
+    if (source->SubClass != target->SubClass && !IsRangedWeapon(target->Class, target->SubClass))
+    {
+        if (source->Class == ITEM_CLASS_ARMOR && !AllowMixedArmorTypes)
+            return false;
+        if (source->Class == ITEM_CLASS_WEAPON && !AllowMixedWeaponTypes)
+            return false;
+    }
+
+    if (source->InventoryType != target->InventoryType)
+    {
+        if (source->Class == ITEM_CLASS_WEAPON &&
+            (IsRangedWeapon(target->Class, target->SubClass) != IsRangedWeapon(source->Class, source->SubClass) ||
+            source->InventoryType == INVTYPE_WEAPONMAINHAND ||
+            source->InventoryType == INVTYPE_WEAPONOFFHAND))
+            return false;
+        if (source->Class == ITEM_CLASS_ARMOR &&
+            !(source->InventoryType == INVTYPE_CHEST && target->InventoryType == INVTYPE_ROBE ||
+            source->InventoryType == INVTYPE_ROBE && target->InventoryType == INVTYPE_CHEST))
+            return false;
+    }
+
+    return true;
+}
+
+bool Transmogrification::SuitableForTransmogrification(Player* player, ItemTemplate const* proto) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::SuitableForTransmogrification");
+
+    // ItemTemplate const* proto = item->GetTemplate();
+    if (!player || !proto)
+        return false;
+
+    if (proto->Class != ITEM_CLASS_ARMOR &&
+        proto->Class != ITEM_CLASS_WEAPON)
+        return false;
+
+    // Skip all checks for allowed items
+    if (IsAllowed(proto->ItemId))
+        return true;
+
+    if (IsNotAllowed(proto->ItemId))
+        return false;
+
+    if (!AllowFishingPoles && proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+        return false;
+
+    if (!IsAllowedQuality(proto->Quality)) // (proto->Quality == ITEM_QUALITY_LEGENDARY)
+        return false;
+
+    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && player->GetTeam() != HORDE)
+        return false;
+
+    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && player->GetTeam() != ALLIANCE)
+        return false;
+
+    if (!IgnoreReqClass && (proto->AllowableClass & player->getClassMask()) == 0)
+        return false;
+
+    if (!IgnoreReqRace && (proto->AllowableRace & player->getRaceMask()) == 0)
+        return false;
+
+    if (!IgnoreReqSkill && proto->RequiredSkill != 0)
+    {
+        if (player->GetSkillValue(proto->RequiredSkill) == 0)
+            return false;
+        else if (player->GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
+            return false;
+    }
+
+    if (!IgnoreReqSpell && proto->RequiredSpell != 0 && !player->HasSpell(proto->RequiredSpell))
+        return false;
+
+    if (!IgnoreReqLevel && player->getLevel() < proto->RequiredLevel)
+        return false;
+
+    // If World Event is not active, prevent using event dependant items
+    if (!IgnoreReqEvent && proto->HolidayId && !IsHolidayActive((HolidayIds)proto->HolidayId))
+        return false;
+
+    if (!IgnoreReqStats)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+            if (proto->ItemStat[i].ItemStatValue != 0)
+                return true;
+    }
+    else
+        return true;
+
+    return false;
+}
+
+/*
+bool Transmogrification::CanTransmogrify(Item const* item)
+{
+ItemTemplate const* proto = item->GetTemplate();
+
+if (!proto)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CANNOT_TRANSMOG)
+return false;
+
+if (proto->Quality == ITEM_QUALITY_LEGENDARY)
+return false;
+
+if (proto->Class != ITEM_CLASS_ARMOR &&
+proto->Class != ITEM_CLASS_WEAPON)
+return false;
+
+if (proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CAN_TRANSMOG)
+return true;
+
+if (item->GetItemRandomPropertyId() == 0)
+return false;
+
+for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+if (proto->ItemStat[i].ItemStatValue != 0)
+return true;
+
+return false;
+}
+bool Transmogrification::CanBeTransmogrified(Item const* item)
+{
+ItemTemplate const* proto = item->GetTemplate();
+
+if (!proto)
+return false;
+
+if (proto->Quality == ITEM_QUALITY_LEGENDARY)
+return false;
+
+if (proto->Class != ITEM_CLASS_ARMOR &&
+proto->Class != ITEM_CLASS_WEAPON)
+return false;
+
+if (proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CANNOT_BE_TRANSMOG)
+return false;
+
+if (item->GetItemRandomPropertyId() == 0)
+return false;
+
+for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+if (proto->ItemStat[i].ItemStatValue != 0)
+return true;
+
+return false;
+}
+*/
+
+uint32 Transmogrification::GetSpecialPrice(ItemTemplate const* proto) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetSpecialPrice");
+
+    uint32 cost = proto->SellPrice < 10000 ? 10000 : proto->SellPrice;
+    return cost;
+}
+
+bool Transmogrification::IsRangedWeapon(uint32 Class, uint32 SubClass) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsRangedWeapon");
+
+    return Class == ITEM_CLASS_WEAPON && (
+        SubClass == ITEM_SUBCLASS_WEAPON_BOW ||
+        SubClass == ITEM_SUBCLASS_WEAPON_GUN ||
+        SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW);
+}
+
+bool Transmogrification::IsAllowed(uint32 entry) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsAllowed");
+
+    return Allowed.find(entry) != Allowed.end();
+}
+
+bool Transmogrification::IsNotAllowed(uint32 entry) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsNotAllowed");
+
+    return NotAllowed.find(entry) != NotAllowed.end();
+}
+
+bool Transmogrification::IsAllowedQuality(uint32 quality) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsAllowedQuality");
+
+    switch (quality)
+    {
+    case ITEM_QUALITY_POOR: return AllowPoor;
+    case ITEM_QUALITY_NORMAL: return AllowCommon;
+    case ITEM_QUALITY_UNCOMMON: return AllowUncommon;
+    case ITEM_QUALITY_RARE: return AllowRare;
+    case ITEM_QUALITY_EPIC: return AllowEpic;
+    case ITEM_QUALITY_LEGENDARY: return AllowLegendary;
+    case ITEM_QUALITY_ARTIFACT: return AllowArtifact;
+    case ITEM_QUALITY_HEIRLOOM: return AllowHeirloom;
+    default: return false;
+    }
+}
+
+void Transmogrification::LoadConfig(bool reload)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::LoadConfig");
+
+#ifdef PRESETS
+    EnableSetInfo = sConfigMgr->GetBoolDefault("Transmogrification.EnableSetInfo", true);
+    SetNpcText = uint32(sConfigMgr->GetIntDefault("Transmogrification.SetNpcText", 50001));
+
+    EnableSets = sConfigMgr->GetBoolDefault("Transmogrification.EnableSets", true);
+    MaxSets = (uint8)sConfigMgr->GetIntDefault("Transmogrification.MaxSets", 10);
+    SetCostModifier = sConfigMgr->GetFloatDefault("Transmogrification.SetCostModifier", 3.0f);
+    SetCopperCost = sConfigMgr->GetIntDefault("Transmogrification.SetCopperCost", 0);
+
+    if (MaxSets > MAX_OPTIONS)
+        MaxSets = MAX_OPTIONS;
+
+    if (reload) // dont store presets for nothing
+    {
+        // this should be thread safe as long as LoadConfig is triggered on thread safe env
+        SessionMap const& sessions = sWorld->GetAllSessions();
+        for (SessionMap::const_iterator it = sessions.begin(); it != sessions.end(); ++it)
+        {
+            if (Player* player = it->second->GetPlayer())
+            {
+                // skipping session check
+                UnloadPlayerSets(player->GetGUID());
+                if (EnableSets)
+                    LoadPlayerSets(player->GetGUID());
+            }
+        }
+    }
+#endif
+
+    EnableTransmogInfo = sConfigMgr->GetBoolDefault("Transmogrification.EnableTransmogInfo", true);
+    TransmogNpcText = uint32(sConfigMgr->GetIntDefault("Transmogrification.TransmogNpcText", 50000));
+
+    std::istringstream issAllowed(sConfigMgr->GetStringDefault("Transmogrification.Allowed", ""));
+    std::istringstream issNotAllowed(sConfigMgr->GetStringDefault("Transmogrification.NotAllowed", ""));
+    while (issAllowed.good())
+    {
+        uint32 entry;
+        issAllowed >> entry;
+        if (issAllowed.fail())
+            break;
+        Allowed.insert(entry);
+    }
+    while (issNotAllowed.good())
+    {
+        uint32 entry;
+        issNotAllowed >> entry;
+        if (issNotAllowed.fail())
+            break;
+        NotAllowed.insert(entry);
+    }
+
+    ScaledCostModifier = sConfigMgr->GetFloatDefault("Transmogrification.ScaledCostModifier", 1.0f);
+    CopperCost = sConfigMgr->GetIntDefault("Transmogrification.CopperCost", 0);
+
+    RequireToken = sConfigMgr->GetBoolDefault("Transmogrification.RequireToken", false);
+    TokenEntry = uint32(sConfigMgr->GetIntDefault("Transmogrification.TokenEntry", 49426));
+    TokenAmount = uint32(sConfigMgr->GetIntDefault("Transmogrification.TokenAmount", 1));
+
+    AllowPoor = sConfigMgr->GetBoolDefault("Transmogrification.AllowPoor", false);
+    AllowCommon = sConfigMgr->GetBoolDefault("Transmogrification.AllowCommon", false);
+    AllowUncommon = sConfigMgr->GetBoolDefault("Transmogrification.AllowUncommon", true);
+    AllowRare = sConfigMgr->GetBoolDefault("Transmogrification.AllowRare", true);
+    AllowEpic = sConfigMgr->GetBoolDefault("Transmogrification.AllowEpic", true);
+    AllowLegendary = sConfigMgr->GetBoolDefault("Transmogrification.AllowLegendary", false);
+    AllowArtifact = sConfigMgr->GetBoolDefault("Transmogrification.AllowArtifact", false);
+    AllowHeirloom = sConfigMgr->GetBoolDefault("Transmogrification.AllowHeirloom", true);
+
+    AllowMixedArmorTypes = sConfigMgr->GetBoolDefault("Transmogrification.AllowMixedArmorTypes", false);
+    AllowMixedWeaponTypes = sConfigMgr->GetBoolDefault("Transmogrification.AllowMixedWeaponTypes", false);
+    AllowFishingPoles = sConfigMgr->GetBoolDefault("Transmogrification.AllowFishingPoles", false);
+
+    IgnoreReqRace = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqRace", false);
+    IgnoreReqClass = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqClass", false);
+    IgnoreReqSkill = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqSkill", false);
+    IgnoreReqSpell = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqSpell", false);
+    IgnoreReqLevel = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqLevel", false);
+    IgnoreReqEvent = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqEvent", false);
+    IgnoreReqStats = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqStats", false);
+
+    if (!sObjectMgr->GetItemTemplate(TokenEntry))
+    {
+        TC_LOG_INFO("custom.transmog", "Transmogrification.TokenEntry (%u) does not exist. Using default (%u).", TokenEntry, 49426);
+        TokenEntry = 49426;
+    }
+}
+
+std::vector<uint64> Transmogrification::GetItemList(const Player* player) const
+{
+    std::vector<uint64> itemlist;
+
+    // Copy paste from Player::GetItemByGuid(guid)
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem->GetGUID());
+
+    for (uint8 i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem->GetGUID());
+
+    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem->GetGUID());
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = player->GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    itemlist.push_back(pItem->GetGUID());
+
+    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Bag* pBag = player->GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    itemlist.push_back(pItem->GetGUID());
+
+    return itemlist;
+}
+
+namespace
+{
+    class PS_Transmogrification : public PlayerScript
+    {
+    public:
+        PS_Transmogrification(): PlayerScript("PS_Transmogrification") {}
+
+        void OnSave(Player* player) override
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+            trans->PAppend("DELETE FROM `custom_transmogrification` WHERE `Owner` = %u", player->GetGUIDLow());
+
+            ACE_Auto_Ptr<Transmogrification::transmogData> transmog(sTransmogrification->entryMap.GetCopy(player->GetGUID()));
+            if (transmog.get())
+            {
+                // Only save items that are in inventory / bank / etc
+                std::vector<uint64> items = sTransmogrification->GetItemList(player);
+                for (std::vector<uint64>::const_iterator it = items.begin(); it != items.end(); ++it)
+                {
+                    Transmogrification::transmogData::const_iterator it2 = transmog->find(*it);
+                    if (it2 == transmog->end())
+                        continue;
+
+                    trans->PAppend("REPLACE INTO custom_transmogrification (GUID, FakeEntry, Owner) VALUES (%u, %u, %u)", GUID_LOPART(it2->first), it2->second, player->GetGUIDLow());
+                }
+            }
+
+#ifdef PRESETS
+            trans->PAppend("DELETE FROM `custom_transmogrification_sets` WHERE `Owner` = %u", player->GetGUIDLow());
+            ACE_Auto_Ptr<Transmogrification::presetIdMap> preset(sTransmogrification->presetMap.GetCopy(player->GetGUID()));
+            if (preset.get())
+            {
+                for (Transmogrification::presetIdMap::const_iterator it = preset->begin(); it != preset->end(); ++it)
+                {
+                    std::ostringstream ss;
+                    for (Transmogrification::presetslotMap::const_iterator it2 = it->second.slotMap.begin(); it2 != it->second.slotMap.end(); ++it2)
+                        ss << uint32(it2->first) << ' ' << it2->second << ' ';
+                    trans->PAppend("REPLACE INTO `custom_transmogrification_sets` (`Owner`, `PresetID`, `SetName`, `SetData`) VALUES (%u, %u, \"%s\", \"%s\")", player->GetGUIDLow(), uint32(it->first), it->second.name.c_str(), ss.str().c_str());
+                }
+            }
+#endif
+
+            if (trans->GetSize()) // basically never false
+                CharacterDatabase.CommitTransaction(trans);
+        }
+
+        void OnLogin(Player* player, bool /*firstLogin*/) override
+        {
+            uint64 playerGUID = player->GetGUID();
+            sTransmogrification->entryMap.Remove(playerGUID);
+            QueryResult result = CharacterDatabase.PQuery("SELECT GUID, FakeEntry FROM custom_transmogrification WHERE Owner = %u", player->GetGUIDLow());
+
+            if (result)
+            {
+                Transmogrification::transmogData data;
+                do
+                {
+                    Field* field = result->Fetch();
+                    uint64 itemGUID = MAKE_NEW_GUID(field[0].GetUInt32(), 0, HIGHGUID_ITEM);
+                    uint32 fakeEntry = field[1].GetUInt32();
+                    // Only load items that are in inventory / bank / etc
+                    if (sObjectMgr->GetItemTemplate(fakeEntry) && player->GetItemByGuid(itemGUID))
+                    {
+                        data[itemGUID] = fakeEntry;
+                    }
+                    else
+                    {
+                        // Ignore, will be erased on next save.
+                        // Additionally this can happen if an item was deleted from DB but still exists for the player
+                        // TC_LOG_ERROR("custom.transmog", "Item entry (Entry: %u, itemGUID: %u, playerGUID: %u) does not exist, ignoring.", fakeEntry, GUID_LOPART(itemGUID), player->GetGUIDLow());
+                        // CharacterDatabase.PExecute("DELETE FROM custom_transmogrification WHERE FakeEntry = %u", fakeEntry);
+                    }
+                } while (result->NextRow());
+
+                sTransmogrification->entryMap.Insert(playerGUID, data);
+
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                {
+                    if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        player->SetVisibleItemSlot(slot, item);
+                        if (player->IsInWorld())
+                            item->SendUpdateToPlayer(player);
+                    }
+                }
+            }
+
+#ifdef PRESETS
+            if (sTransmogrification->EnableSets)
+                sTransmogrification->LoadPlayerSets(playerGUID);
+#endif
+        }
+
+        void OnLogout(Player* player) override
+        {
+            // always unload all items
+            uint64 pGUID = player->GetGUID();
+            sTransmogrification->entryMap.Remove(pGUID);
+
+#ifdef PRESETS
+            if (sTransmogrification->EnableSets)
+                sTransmogrification->UnloadPlayerSets(pGUID);
+#endif
+        }
+    };
+
+    class WS_Transmogrification : public WorldScript
+    {
+    public:
+        WS_Transmogrification(): WorldScript("WS_Transmogrification") {}
+
+        void OnConfigLoad(bool reload) override
+        {
+            sTransmogrification->LoadConfig(reload);
+        }
+
+        void OnStartup() override
+        {
+            TC_LOG_INFO("custom.transmog", "Deleting non-existing transmogrification entries...");
+            CharacterDatabase.DirectExecute("DELETE FROM custom_transmogrification WHERE NOT EXISTS (SELECT 1 FROM item_instance WHERE item_instance.guid = custom_transmogrification.GUID)");
+
+#ifdef PRESETS
+            // Clean even if disabled
+            // Dont delete even if player has more presets than should
+            CharacterDatabase.DirectExecute("DELETE FROM `custom_transmogrification_sets` WHERE NOT EXISTS(SELECT 1 FROM characters WHERE characters.guid = custom_transmogrification_sets.Owner)");
+#endif
+            sTransmogrification->LoadConfig(false);
+        }
+    };
+}
+
+void AddSC_PWS_Transmogrification()
+{
+    new WS_Transmogrification();
+    new PS_Transmogrification();
+}
diff --git a/src/server/scripts/Custom/Transmogrification.h b/src/server/scripts/Custom/Transmogrification.h
new file mode 100644
index 0000000..9016d1b
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrification.h
@@ -0,0 +1,170 @@
+#ifndef DEF_TRANSMOGRIFICATION_H
+#define DEF_TRANSMOGRIFICATION_H
+
+#define PRESETS // comment this line to disable preset feature totally
+#define MAX_OPTIONS 25 // do not alter
+
+class Item;
+class Player;
+class WorldSession;
+struct ItemTemplate;
+
+enum TransmogTrinityStrings // Language.h might have same entries, appears when executing SQL, change if needed
+{
+    LANG_ERR_TRANSMOG_OK = 11100, // change this
+    LANG_ERR_TRANSMOG_INVALID_SLOT,
+    LANG_ERR_TRANSMOG_INVALID_SRC_ENTRY,
+    LANG_ERR_TRANSMOG_MISSING_SRC_ITEM,
+    LANG_ERR_TRANSMOG_MISSING_DEST_ITEM,
+    LANG_ERR_TRANSMOG_INVALID_ITEMS,
+    LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY,
+    LANG_ERR_TRANSMOG_NOT_ENOUGH_TOKENS,
+
+    LANG_ERR_UNTRANSMOG_OK,
+    LANG_ERR_UNTRANSMOG_NO_TRANSMOGS,
+
+#ifdef PRESETS
+    LANG_PRESET_ERR_INVALID_NAME,
+#endif
+};
+
+class Transmogrification
+{
+public:
+    template <typename K, typename V>
+    class KVRWHashMap
+    {
+    public:
+        typedef std::unordered_map<K, V> MapType;
+        typedef ACE_RW_Thread_Mutex LockType;
+
+        void Insert(K k, V v)
+        {
+            TRINITY_WRITE_GUARD(LockType, i_lock);
+            m_hashMap[k] = v;
+        }
+
+        void Remove(K k)
+        {
+            TRINITY_WRITE_GUARD(LockType, i_lock);
+            m_hashMap.erase(k);
+        }
+
+        // Note, returns a pointer to a copy of the value
+        // You MUST manually delete it to avoid mem leaks
+        // use ACE_Auto_Ptr<K>
+        V* GetCopy(K k)
+        {
+            TRINITY_READ_GUARD(LockType, i_lock);
+            typename MapType::iterator itr = m_hashMap.find(k);
+            if (itr != m_hashMap.end())
+                return new V(itr->second);
+            else
+                return NULL;
+        }
+
+        MapType& GetContainer() { return m_hashMap; }
+
+        LockType& GetLock() { return i_lock; }
+
+    private:
+
+        LockType i_lock;
+        MapType m_hashMap;
+    };
+
+#ifdef PRESETS
+    typedef std::map<uint8, uint32> presetslotMap;
+    struct presetData
+    {
+        std::string name;
+        presetslotMap slotMap;
+    };
+    typedef std::map<uint8, presetData> presetIdMap; // remember to lock
+    typedef KVRWHashMap<uint64, presetIdMap> presetPlayers;
+    presetPlayers presetMap; // presetByName[pGUID][presetID] = presetData
+
+    bool EnableSetInfo;
+    uint32 SetNpcText;
+
+    bool EnableSets;
+    uint8 MaxSets;
+    float SetCostModifier;
+    int32 SetCopperCost;
+
+    void LoadPlayerSets(uint64 pGUID);
+    void UnloadPlayerSets(uint64 pGUID);
+
+    void PresetTransmog(Player* player, Item* itemTransmogrified, uint32 fakeEntry, uint8 slot);
+#endif
+
+    typedef std::unordered_map<uint64, uint32> transmogData; // remember to lock
+    typedef KVRWHashMap<uint64, transmogData> transmogMap;
+    // typedef KVRWHashMap<uint64, uint64> transmogPlayers;
+    transmogMap entryMap; // entryMap[pGUID][iGUID] = entry
+    // transmogPlayers playerMap; // dataMap[iGUID] = pGUID
+
+    bool EnableTransmogInfo;
+    uint32 TransmogNpcText;
+
+    // Use IsAllowed() and IsNotAllowed()
+    // these are thread unsafe, but assumed to be static data so it should be safe
+    std::set<uint32> Allowed;
+    std::set<uint32> NotAllowed;
+
+    float ScaledCostModifier;
+    int32 CopperCost;
+
+    bool RequireToken;
+    uint32 TokenEntry;
+    uint32 TokenAmount;
+
+    bool AllowPoor;
+    bool AllowCommon;
+    bool AllowUncommon;
+    bool AllowRare;
+    bool AllowEpic;
+    bool AllowLegendary;
+    bool AllowArtifact;
+    bool AllowHeirloom;
+
+    bool AllowMixedArmorTypes;
+    bool AllowMixedWeaponTypes;
+    bool AllowFishingPoles;
+
+    bool IgnoreReqRace;
+    bool IgnoreReqClass;
+    bool IgnoreReqSkill;
+    bool IgnoreReqSpell;
+    bool IgnoreReqLevel;
+    bool IgnoreReqEvent;
+    bool IgnoreReqStats;
+
+    bool IsAllowed(uint32 entry) const;
+    bool IsNotAllowed(uint32 entry) const;
+    bool IsAllowedQuality(uint32 quality) const;
+    bool IsRangedWeapon(uint32 Class, uint32 SubClass) const;
+
+    void LoadConfig(bool reload); // thread unsafe
+
+    std::string GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y) const;
+    std::string GetSlotIcon(uint8 slot, uint32 width, uint32 height, int x, int y) const;
+    const char * GetSlotName(uint8 slot, WorldSession* session) const;
+    std::string GetItemLink(Item* item, WorldSession* session) const;
+    std::string GetItemLink(uint32 entry, WorldSession* session) const;
+    uint32 GetFakeEntry(const Item* item);
+    void UpdateItem(Player* player, Item* item) const;
+    void DeleteFakeEntry(Player* player, Item* item);
+    void SetFakeEntry(Player* player, Item* item, uint32 entry);
+
+    TransmogTrinityStrings Transmogrify(Player* player, uint64 itemGUID, uint8 slot, bool no_cost = false);
+    bool CanTransmogrifyItemWithItem(Player* player, ItemTemplate const* destination, ItemTemplate const* source) const;
+    bool SuitableForTransmogrification(Player* player, ItemTemplate const* proto) const;
+    // bool CanBeTransmogrified(Item const* item);
+    // bool CanTransmogrify(Item const* item);
+    uint32 GetSpecialPrice(ItemTemplate const* proto) const;
+    std::vector<uint64> GetItemList(const Player* player) const;
+};
+#define sTransmogrification ACE_Singleton<Transmogrification, ACE_Null_Mutex>::instance()
+
+#endif
diff --git a/src/server/scripts/Custom/Transmogrifier.cpp b/src/server/scripts/Custom/Transmogrifier.cpp
new file mode 100644
index 0000000..b13e57a
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrifier.cpp
@@ -0,0 +1,414 @@
+/*
+5.5
+Transmogrification 3.3.5a - Gossip menu
+By Rochet2
+
+ScriptName for NPC:
+Creature_Transmogrify
+
+TODO:
+Fix the cost formula
+-- Too much data handling, use default costs
+
+Are the qualities right?
+Blizzard might have changed the quality requirements.
+(TC handles it with stat checks)
+
+Cant transmogrify rediculus items // Foereaper: would be fun to stab people with a fish
+-- Cant think of any good way to handle this easily, could rip flagged items from cata DB
+*/
+
+#include "ScriptPCH.h"
+#include "Config.h"
+#include "Language.h"
+#include "Transmogrification.h"
+
+#define GTS session->GetTrinityString
+
+namespace
+{
+    class CS_Transmogrification : public CreatureScript
+    {
+    public:
+        CS_Transmogrification(): CreatureScript("Creature_Transmogrify") {}
+
+        bool OnGossipHello(Player* player, Creature* creature) override
+        {
+            WorldSession* session = player->GetSession();
+            if (sTransmogrification->EnableTransmogInfo)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Book_11:30:30:-18:0|tHow transmogrification works", EQUIPMENT_SLOT_END + 9, 0);
+            for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+            {
+                if (const char* slotName = sTransmogrification->GetSlotName(slot, session))
+                {
+                    Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    uint32 entry = newItem ? sTransmogrification->GetFakeEntry(newItem) : 0;
+                    std::string icon = entry ? sTransmogrification->GetItemIcon(entry, 30, 30, -18, 0) : sTransmogrification->GetSlotIcon(slot, 30, 30, -18, 0);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, icon + std::string(slotName), EQUIPMENT_SLOT_END, slot);
+                }
+            }
+#ifdef PRESETS
+            if (sTransmogrification->EnableSets)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/RAIDFRAME/UI-RAIDFRAME-MAINASSIST:30:30:-18:0|tManage sets", EQUIPMENT_SLOT_END + 4, 0);
+#endif
+            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Enchant_Disenchant:30:30:-18:0|tRemove all transmogrifications", EQUIPMENT_SLOT_END + 2, 0, "Remove transmogrifications from all equipped items?", 0, false);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|tUpdate menu", EQUIPMENT_SLOT_END + 1, 0);
+            player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+        {
+            player->PlayerTalkClass->ClearMenus();
+            WorldSession* session = player->GetSession();
+            switch (sender)
+            {
+            case EQUIPMENT_SLOT_END: // Show items you can use
+                ShowTransmogItems(player, creature, action);
+                break;
+            case EQUIPMENT_SLOT_END + 1: // Main menu
+                OnGossipHello(player, creature);
+                break;
+            case EQUIPMENT_SLOT_END + 2: // Remove Transmogrifications
+            {
+                bool removed = false;
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                {
+                    if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        if (!sTransmogrification->GetFakeEntry(newItem))
+                            continue;
+                        sTransmogrification->DeleteFakeEntry(player, newItem);
+                        removed = true;
+                    }
+                }
+                if (removed)
+                    session->SendAreaTriggerMessage(GTS(LANG_ERR_UNTRANSMOG_OK));
+                else
+                    session->SendNotification(LANG_ERR_UNTRANSMOG_NO_TRANSMOGS);
+                OnGossipHello(player, creature);
+            } break;
+            case EQUIPMENT_SLOT_END + 3: // Remove Transmogrification from single item
+            {
+                if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, action))
+                {
+                    if (sTransmogrification->GetFakeEntry(newItem))
+                    {
+                        sTransmogrification->DeleteFakeEntry(player, newItem);
+                        session->SendAreaTriggerMessage(GTS(LANG_ERR_UNTRANSMOG_OK));
+                    }
+                    else
+                        session->SendNotification(LANG_ERR_UNTRANSMOG_NO_TRANSMOGS);
+                }
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END, action);
+            } break;
+#ifdef PRESETS
+            case EQUIPMENT_SLOT_END + 4: // Presets menu
+            {
+                if (!sTransmogrification->EnableSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                if (sTransmogrification->EnableSetInfo)
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Book_11:30:30:-18:0|tHow sets work", EQUIPMENT_SLOT_END + 10, 0);
+
+                ACE_Auto_Ptr<Transmogrification::presetIdMap> data(sTransmogrification->presetMap.GetCopy(player->GetGUID()));
+                if (data.get())
+                {
+                    for (Transmogrification::presetIdMap::const_iterator it = data->begin(); it != data->end(); ++it)
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Statue_02:30:30:-18:0|t" + it->second.name, EQUIPMENT_SLOT_END + 6, it->first);
+
+                    if (data->size() < sTransmogrification->MaxSets)
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|tSave set", EQUIPMENT_SLOT_END + 8, 0);
+                }
+                else
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|tSave set", EQUIPMENT_SLOT_END + 8, 0);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 1, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+            case EQUIPMENT_SLOT_END + 5: // Use preset
+            {
+                if (!sTransmogrification->EnableSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // action = presetID
+                ACE_Auto_Ptr<Transmogrification::presetIdMap> data(sTransmogrification->presetMap.GetCopy(player->GetGUID()));
+                if (data.get())
+                {
+                    Transmogrification::presetIdMap::const_iterator it = data->find(action);
+                    if (it != data->end())
+                    {
+                        for (Transmogrification::presetslotMap::const_iterator it2 = it->second.slotMap.begin(); it2 != it->second.slotMap.end(); ++it2)
+                            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, it2->first))
+                                sTransmogrification->PresetTransmog(player, item, it2->second, it2->first);
+                    }
+                }
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 6, action);
+            } break;
+            case EQUIPMENT_SLOT_END + 6: // view preset
+            {
+                if (!sTransmogrification->EnableSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // action = presetID
+                ACE_Auto_Ptr<Transmogrification::presetIdMap> data(sTransmogrification->presetMap.GetCopy(player->GetGUID()));
+                if (!data.get())
+                {
+                    OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+                    return true;
+                }
+                Transmogrification::presetIdMap::const_iterator it = data->find(action);
+                if (it == data->end())
+                {
+                    OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+                    return true;
+                }
+
+                for (Transmogrification::presetslotMap::const_iterator it2 = it->second.slotMap.begin(); it2 != it->second.slotMap.end(); ++it2)
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(it2->second, 30, 30, -18, 0) + sTransmogrification->GetItemLink(it2->second, session), sender, action);
+
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Statue_02:30:30:-18:0|tUse set", EQUIPMENT_SLOT_END + 5, action, "Using this set for transmogrify will bind transmogrified items to you and make them non-refundable and non-tradeable.\nDo you wish to continue?\n\n" + it->second.name, 0, false);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-LeaveItem-Opaque:30:30:-18:0|tDelete set", EQUIPMENT_SLOT_END + 7, action, "Are you sure you want to delete " + it->second.name + "?", 0, false);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 4, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+            case EQUIPMENT_SLOT_END + 7: // Delete preset
+            {
+                if (!sTransmogrification->EnableSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // action = presetID
+            {
+                TRINITY_WRITE_GUARD(Transmogrification::presetPlayers::LockType, sTransmogrification->presetMap.GetLock());
+                Transmogrification::presetPlayers::MapType& data = sTransmogrification->presetMap.GetContainer();
+                Transmogrification::presetPlayers::MapType::iterator it = data.find(player->GetGUID());
+                if (it != data.end())
+                {
+                    it->second.erase(action);
+                }
+            }
+
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+            } break;
+            case EQUIPMENT_SLOT_END + 8: // Save preset
+            {
+                if (!sTransmogrification->EnableSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                ACE_Auto_Ptr<Transmogrification::presetIdMap> data(sTransmogrification->presetMap.GetCopy(player->GetGUID()));
+                if (data.get() && data->size() >= sTransmogrification->MaxSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                uint32 cost = 0;
+                bool canSave = false;
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                {
+                    if (!sTransmogrification->GetSlotName(slot, session))
+                        continue;
+                    if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        uint32 entry = sTransmogrification->GetFakeEntry(newItem);
+                        if (!entry)
+                            continue;
+                        const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+                        if (!temp)
+                            continue;
+                        if (!sTransmogrification->SuitableForTransmogrification(player, temp)) // no need to check?
+                            continue;
+                        cost += sTransmogrification->GetSpecialPrice(temp);
+                        canSave = true;
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(entry, 30, 30, -18, 0) + sTransmogrification->GetItemLink(entry, session), EQUIPMENT_SLOT_END + 8, 0);
+                    }
+                }
+                if (canSave)
+                    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|tSave set", 0, 0, "Insert set name", cost*sTransmogrification->SetCostModifier + sTransmogrification->SetCopperCost, true);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|tUpdate menu", sender, action);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 4, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+            case EQUIPMENT_SLOT_END + 10: // Set info
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 4, 0);
+                player->SEND_GOSSIP_MENU(sTransmogrification->SetNpcText, creature->GetGUID());
+            } break;
+#endif
+            case EQUIPMENT_SLOT_END + 9: // Transmog info
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 1, 0);
+                player->SEND_GOSSIP_MENU(sTransmogrification->TransmogNpcText, creature->GetGUID());
+            } break;
+            default: // Transmogrify
+            {
+                if (!sender && !action)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // sender = slot, action = display
+                TransmogTrinityStrings res = sTransmogrification->Transmogrify(player, MAKE_NEW_GUID(action, 0, HIGHGUID_ITEM), sender);
+                if (res == LANG_ERR_TRANSMOG_OK)
+                    session->SendAreaTriggerMessage(GTS(LANG_ERR_TRANSMOG_OK));
+                else
+                    session->SendNotification(res);
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END, sender);
+            } break;
+            }
+            return true;
+        }
+
+#ifdef PRESETS
+        bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code) override
+        {
+            player->PlayerTalkClass->ClearMenus();
+            if (sender || action)
+                return true; // should never happen
+            if (!sTransmogrification->EnableSets)
+            {
+                OnGossipHello(player, creature);
+                return true;
+            }
+            std::string name(code);
+            if (name.find('"') != std::string::npos || name.find('\\') != std::string::npos)
+                player->GetSession()->SendNotification(LANG_PRESET_ERR_INVALID_NAME);
+            else
+            {
+                int32 cost = 0;
+                Transmogrification::presetslotMap items;
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                {
+                    if (!sTransmogrification->GetSlotName(slot, player->GetSession()))
+                        continue;
+                    if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        uint32 entry = sTransmogrification->GetFakeEntry(newItem);
+                        if (!entry)
+                            continue;
+                        const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+                        if (!temp)
+                            continue;
+                        if (!sTransmogrification->SuitableForTransmogrification(player, temp))
+                            continue;
+                        cost += sTransmogrification->GetSpecialPrice(temp);
+                        items[slot] = entry;
+                    }
+                }
+                if (!items.empty())
+                {
+                    // transmogrified items were found to be saved
+                    cost *= sTransmogrification->SetCostModifier;
+                    cost += sTransmogrification->SetCopperCost;
+
+                    if (!player->HasEnoughMoney(cost))
+                    {
+                        player->GetSession()->SendNotification(LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY);
+                    }
+                    else
+                    {
+                        TRINITY_WRITE_GUARD(Transmogrification::presetPlayers::LockType, sTransmogrification->presetMap.GetLock());
+
+                        uint8 presetID = 0;
+                        Transmogrification::presetPlayers::MapType& data = sTransmogrification->presetMap.GetContainer();
+                        Transmogrification::presetPlayers::MapType::const_iterator it = data.find(player->GetGUID());
+                        if (it != data.end())
+                        {
+                            for (; presetID < sTransmogrification->MaxSets; ++presetID) // should never reach over max
+                            {
+                                if (it->second.find(presetID) == it->second.end())
+                                    break; // trying to find free preset
+                            }
+                        }
+
+                        if (presetID < sTransmogrification->MaxSets)
+                        {
+                            // Make sure code doesnt mess up SQL!
+                            data[player->GetGUID()][presetID].name = name;
+                            data[player->GetGUID()][presetID].slotMap = items;
+
+                            if (cost)
+                                player->ModifyMoney(-cost);
+                        }
+                    }
+                }
+            }
+            OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+            return true;
+        }
+#endif
+
+        void ShowTransmogItems(Player* player, Creature* creature, uint8 slot) // Only checks bags while can use an item from anywhere in inventory
+        {
+            WorldSession* session = player->GetSession();
+            Item* oldItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+            if (oldItem)
+            {
+                uint32 limit = 0;
+                uint32 price = sTransmogrification->GetSpecialPrice(oldItem->GetTemplate());
+                price *= sTransmogrification->ScaledCostModifier;
+                price += sTransmogrification->CopperCost;
+                std::ostringstream ss;
+                ss << std::endl;
+                if (sTransmogrification->RequireToken)
+                    ss << std::endl << std::endl << sTransmogrification->TokenAmount << " x " << sTransmogrification->GetItemLink(sTransmogrification->TokenEntry, session);
+
+                for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+                {
+                    if (limit >= MAX_OPTIONS)
+                        break;
+                    Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                    if (!newItem)
+                        continue;
+                    if (!sTransmogrification->CanTransmogrifyItemWithItem(player, oldItem->GetTemplate(), newItem->GetTemplate()))
+                        continue;
+                    if (sTransmogrification->GetFakeEntry(oldItem) == newItem->GetEntry())
+                        continue;
+                    ++limit;
+                    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(newItem->GetEntry(), 30, 30, -18, 0) + sTransmogrification->GetItemLink(newItem, session), slot, newItem->GetGUIDLow(), "Using this item for transmogrify will bind it to you and make it non-refundable and non-tradeable.\nDo you wish to continue?\n\n" + sTransmogrification->GetItemIcon(newItem->GetEntry(), 40, 40, -15, -10) + sTransmogrification->GetItemLink(newItem, session) + ss.str(), price, false);
+                }
+
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+                {
+                    Bag* bag = player->GetBagByPos(i);
+                    if (!bag)
+                        continue;
+                    for (uint32 j = 0; j < bag->GetBagSize(); ++j)
+                    {
+                        if (limit >= MAX_OPTIONS)
+                            break;
+                        Item* newItem = player->GetItemByPos(i, j);
+                        if (!newItem)
+                            continue;
+                        if (!sTransmogrification->CanTransmogrifyItemWithItem(player, oldItem->GetTemplate(), newItem->GetTemplate()))
+                            continue;
+                        if (sTransmogrification->GetFakeEntry(oldItem) == newItem->GetEntry())
+                            continue;
+                        ++limit;
+                        player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(newItem->GetEntry(), 30, 30, -18, 0) + sTransmogrification->GetItemLink(newItem, session), slot, newItem->GetGUIDLow(), "Using this item for transmogrify will bind it to you and make it non-refundable and non-tradeable.\nDo you wish to continue?\n\n" + sTransmogrification->GetItemIcon(newItem->GetEntry(), 40, 40, -15, -10) + sTransmogrification->GetItemLink(newItem, session) + ss.str(), price, false);
+                    }
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Enchant_Disenchant:30:30:-18:0|tRemove transmogrification", EQUIPMENT_SLOT_END + 3, slot, "Remove transmogrification from the slot?", 0, false);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|tUpdate menu", EQUIPMENT_SLOT_END, slot);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 1, 0);
+            player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+        }
+    };
+}
+
+void AddSC_CS_Transmogrification()
+{
+    new CS_Transmogrification();
+}
+
+#undef GTS
diff --git a/src/server/scripts/Custom/all-in-one.cpp b/src/server/scripts/Custom/all-in-one.cpp
new file mode 100644
index 0000000..227487f
--- /dev/null
+++ b/src/server/scripts/Custom/all-in-one.cpp
@@ -0,0 +1,1330 @@
+/*
+
+
+Full NPC with lots of menus, and options.
+By: Blue
+Rewritten by: LordPsyan http://www.flaminglegion.net
+Version: 4.0a // Will be updated
+
+/*-------------------------------------
+*
+*
+        DEFINES
+*
+//------------------------------------*/
+#include "ScriptPCH.h"
+#include "Language.h"
+
+// Whisps
+#define notvip "You are not a VIP Member. Check website for details."
+#define yesvip "Welcome honored VIP Member"
+#define skillsmaxed "You skills are now maxed"
+#define votewhisper "Time to vote"
+#define donationhelp "Please donate to help the realm"
+#define normalhelp "If you need help, ask."
+#define ingamehelp "If you need help ingame, contact a GM"
+#define nosickness "You do not have Ressurection Sickness"
+#define nopet "You do not have a pet"
+#define welcome "Greetings Traveler. How can I help you?"
+
+// TOKEN ------------------------
+#define tokenbuy "I want to buy a %Servername% token."
+#define tokenchange "I want to change a %tokenname% to a %tokenname2%."
+
+// mails
+#define moneymail 60003
+
+// items
+#define token1 99999 // Token1 entry number (swap).
+#define token2 99998 // Token2 entry number (receive).
+#define vasarolhatotoken 100000 // Available as token -.-
+
+// Trainers
+#define dk        28474
+#define wari    914
+#define pala    23128
+#define sami    17204
+#define hunta    5115
+#define rogue    4584
+#define dudu    16655
+#define mage    28958
+#define priest    4090
+#define lock    23534
+
+//Teleport
+#define HMX -1854.022095f
+#define HMY -5412.382324f
+#define HMZ -12.428071f
+#define HMM 530
+
+#define AMX -1854.022095f
+#define AMY -5412.382324f
+#define AMZ -12.428071f
+#define AMM 530
+
+//Levelroad Teleport
+#define HLX 4613.816406f
+#define HLY -3589.231689f
+#define HLZ 994.164185f
+#define HLM 1
+
+#define ALX 6899.129883f
+#define ALY -2298.679932f
+#define ALZ 588.010986f
+#define ALM 1
+// DO NOT EDIT HERE //
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+
+
+
+class npc_all : public CreatureScript
+{
+public:
+    npc_all() : CreatureScript("npc_all") { }
+
+        //struct npc_allAI : public ScriptedAI
+        //{
+
+bool OnGossipHello(Player *player, Creature *_Creature)
+
+{
+    _Creature->MonsterWhisper(welcome, player);
+
+
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Morph", GOSSIP_SENDER_MAIN, 100);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Teleport", GOSSIP_SENDER_MAIN, 101); // 1.1
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Set My Skills to Maximum", GOSSIP_SENDER_MAIN, 102);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Trainers", GOSSIP_SENDER_MAIN, 103); // 1.2
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Server Menus", GOSSIP_SENDER_MAIN, 104);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Funny Things", GOSSIP_SENDER_MAIN, 105);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Announcer", GOSSIP_SENDER_MAIN, 106);
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Token Buy", GOSSIP_SENDER_MAIN, 107); // Not configured
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Token Change", GOSSIP_SENDER_MAIN, 108); // Not Configured
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Vote", GOSSIP_SENDER_MAIN, 113); // Not Configured
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Remove Sickness", GOSSIP_SENDER_MAIN, 120);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Reset Talent Points", GOSSIP_SENDER_MAIN, 121);
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Reputations", GOSSIP_SENDER_MAIN, 123); // Not Configured. No Data.
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Titles", GOSSIP_SENDER_MAIN, 124); // No Data for adding titles.
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Buffs", GOSSIP_SENDER_MAIN, 125);
+
+
+        if (player->GetSession()->GetSecurity() >= 1)
+        {
+        _Creature->MonsterWhisper(yesvip, player);
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Battleground Control", GOSSIP_SENDER_MAIN, 109);
+        //player->ADD_GOSSIP_ITEM(0, "[Menu]Vip functions", GOSSIP_SENDER_MAIN, 110);// No Data.
+        } else { _Creature->MonsterWhisper(notvip, player); }
+
+
+    player->SEND_GOSSIP_MENU(1, _Creature->GetGUID());
+    return true;
+}
+
+void SendDefaultMenu(Player *player, Creature *_Creature, uint32 action)
+{
+
+// Not allow in combat
+if (player->IsInCombat())
+{
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+    switch(action)
+
+    {
+
+        //////////////// MAIN MENUS -> Normal Menus //////////////////
+    case 100: // Morphs
+        player->ADD_GOSSIP_ITEM(0, "Illidan", GOSSIP_SENDER_MAIN, 500);
+        player->ADD_GOSSIP_ITEM(0, "Kil'jaeden", GOSSIP_SENDER_MAIN, 501);
+        player->ADD_GOSSIP_ITEM(0, "Akama", GOSSIP_SENDER_MAIN, 502);
+        player->ADD_GOSSIP_ITEM(0, "Deathknight", GOSSIP_SENDER_MAIN, 503);
+        player->ADD_GOSSIP_ITEM(0, "Tauren", GOSSIP_SENDER_MAIN, 504);
+        player->ADD_GOSSIP_ITEM(0, "Undead", GOSSIP_SENDER_MAIN, 505);
+        player->ADD_GOSSIP_ITEM(0, "Human", GOSSIP_SENDER_MAIN, 506);
+        player->ADD_GOSSIP_ITEM(0, "Lich King", GOSSIP_SENDER_MAIN, 507);
+        player->ADD_GOSSIP_ITEM(0, "Tirion", GOSSIP_SENDER_MAIN, 508);
+        player->ADD_GOSSIP_ITEM(0, "Uther Lightbringer", GOSSIP_SENDER_MAIN, 509);
+        player->ADD_GOSSIP_ITEM(0, "Arthas", GOSSIP_SENDER_MAIN, 510);
+        ///////////// From SPGM
+        player->ADD_GOSSIP_ITEM(4, "Algalon", GOSSIP_SENDER_MAIN, 711);
+        player->ADD_GOSSIP_ITEM(4, "Doomwalker", GOSSIP_SENDER_MAIN, 712);
+        player->ADD_GOSSIP_ITEM(4, "Doomlord kazzak", GOSSIP_SENDER_MAIN, 713);
+        player->ADD_GOSSIP_ITEM(4, "Onyxia", GOSSIP_SENDER_MAIN, 714);
+        player->ADD_GOSSIP_ITEM(4, "Thaddius", GOSSIP_SENDER_MAIN, 715);
+        player->ADD_GOSSIP_ITEM(4, "Gluth", GOSSIP_SENDER_MAIN, 716);
+        player->ADD_GOSSIP_ITEM(4, "Maexxna", GOSSIP_SENDER_MAIN, 717);
+        player->ADD_GOSSIP_ITEM(4, "Sapphiron", GOSSIP_SENDER_MAIN, 718);
+        player->ADD_GOSSIP_ITEM(4, "Noth The Plaguebringer", GOSSIP_SENDER_MAIN, 719);
+        player->ADD_GOSSIP_ITEM(4, "Kel'Thuzad", GOSSIP_SENDER_MAIN, 720);
+        player->ADD_GOSSIP_ITEM(4, "Kael'thas Sunstrider", GOSSIP_SENDER_MAIN, 721);
+        player->ADD_GOSSIP_ITEM(4, "C'thun", GOSSIP_SENDER_MAIN, 722);
+        player->ADD_GOSSIP_ITEM(4, "Thrall", GOSSIP_SENDER_MAIN, 723);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+    break;
+
+
+    case 101: // Teleport
+        player->ADD_GOSSIP_ITEM(1, "Raids/Dungeons", GOSSIP_SENDER_MAIN, 600);
+        player->ADD_GOSSIP_ITEM(1, "Cities", GOSSIP_SENDER_MAIN, 601);
+        //player->ADD_GOSSIP_ITEM(1, "Fun places", GOSSIP_SENDER_MAIN, 602); // Only For Funservers. Not Configured
+        //player->ADD_GOSSIP_ITEM(1, "Events", GOSSIP_SENDER_MAIN, 603); // Funservers. Not Configured
+        player->ADD_GOSSIP_ITEM(1, "Areas", GOSSIP_SENDER_MAIN, 604);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 102: // Skill maxer
+        player->CLOSE_GOSSIP_MENU();
+        player->UpdateSkillsToMaxSkillsForLevel();
+        _Creature->MonsterWhisper(skillsmaxed, player);
+        break;
+
+    case 103: // Trainers
+
+        player->ADD_GOSSIP_ITEM(1, "Prof Trainer", GOSSIP_SENDER_MAIN, 800);
+        player->ADD_GOSSIP_ITEM(1, "Class Trainer", GOSSIP_SENDER_MAIN, 801);
+        //player->ADD_GOSSIP_ITEM(1, "Weapon Trainer", GOSSIP_SENDER_MAIN, 802); // Not Configured.
+        player->ADD_GOSSIP_ITEM(1, "Mount Trainer", GOSSIP_SENDER_MAIN, 803);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 104: // Server Menus
+        player->ADD_GOSSIP_ITEM(1, "Help! I've got hacked (Lock Account)", GOSSIP_SENDER_MAIN, 900);
+        player->ADD_GOSSIP_ITEM(0, "Report Lagg", GOSSIP_SENDER_MAIN, 901);
+        player->ADD_GOSSIP_ITEM(0, "Help", GOSSIP_SENDER_MAIN, 903);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 105: // Funny Things, Need some more
+        player->ADD_GOSSIP_ITEM(0, "Money", GOSSIP_SENDER_MAIN, 1000); // DELETE THIS IF YOU DONT WANT PLAYERS TO GET MONEY
+        player->ADD_GOSSIP_ITEM(0, "Drunk", GOSSIP_SENDER_MAIN, 1001);
+        player->ADD_GOSSIP_ITEM(0, "Sober", GOSSIP_SENDER_MAIN, 1002);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 106: // Announcer Part
+        player->ADD_GOSSIP_ITEM(0, "Join Warsong Guilch!", GOSSIP_SENDER_MAIN, 1100);
+        player->ADD_GOSSIP_ITEM(0, "Join Arathi Basin!", GOSSIP_SENDER_MAIN, 1101);
+        player->ADD_GOSSIP_ITEM(0, "Join Wintergrasp!", GOSSIP_SENDER_MAIN, 1102);
+        player->ADD_GOSSIP_ITEM(0, "Join Strand of the ancients!", GOSSIP_SENDER_MAIN, 1103);
+        player->ADD_GOSSIP_ITEM(0, "Join Alterac Valley!", GOSSIP_SENDER_MAIN, 1104);
+        player->ADD_GOSSIP_ITEM(0, "Join Random Battleground!", GOSSIP_SENDER_MAIN, 1105);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 2v2!", GOSSIP_SENDER_MAIN, 1106);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 3v3!", GOSSIP_SENDER_MAIN, 1107);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 5v5!", GOSSIP_SENDER_MAIN, 1108);
+        player->ADD_GOSSIP_ITEM(0, "Join Eye of the Storm!", GOSSIP_SENDER_MAIN, 1109);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+    case 107: // Token -> BUY
+        player->ADD_GOSSIP_ITEM(0, tokenbuy, GOSSIP_SENDER_MAIN, 1200);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 108: // Token ->Change
+        player->ADD_GOSSIP_ITEM(0, tokenchange, GOSSIP_SENDER_MAIN, 1300);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 109: // Battleground function
+        player->ADD_GOSSIP_ITEM(0, "WSG 100%", GOSSIP_SENDER_MAIN, 1400);
+        player->ADD_GOSSIP_ITEM(0, "EOTS 100%", GOSSIP_SENDER_MAIN, 1401);
+        player->ADD_GOSSIP_ITEM(0, "AB 100%", GOSSIP_SENDER_MAIN, 1402);
+        player->ADD_GOSSIP_ITEM(0, "SOTA 100%", GOSSIP_SENDER_MAIN, 1403);
+        player->ADD_GOSSIP_ITEM(0, "AV 100%", GOSSIP_SENDER_MAIN, 1404); // LOL!
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 110: // VIP Functions, from another script(by me :D)
+        player->ADD_GOSSIP_ITEM(0, "Repair", GOSSIP_SENDER_MAIN, 1500);
+        player->ADD_GOSSIP_ITEM(0, "Nyugit szeretnk", GOSSIP_SENDER_MAIN, 1501);
+        player->ADD_GOSSIP_ITEM(0, "Surgery", GOSSIP_SENDER_MAIN, 1502);
+        player->ADD_GOSSIP_ITEM(0, "Faction change", GOSSIP_SENDER_MAIN, 1503);
+        player->ADD_GOSSIP_ITEM(0, "Race Change", GOSSIP_SENDER_MAIN, 1504);
+        //player->ADD_GOSSIP_ITEM(0, "Move?", GOSSIP_SENDER_MAIN, 1505); Not yet implemented
+        player->ADD_GOSSIP_ITEM(0, "Name Change", GOSSIP_SENDER_MAIN, 1506);
+        player->ADD_GOSSIP_ITEM(0, "Save Character", GOSSIP_SENDER_MAIN, 1507);
+        player->ADD_GOSSIP_ITEM(0, "Mailbox", GOSSIP_SENDER_MAIN, 1508);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 111: // VOte
+        _Creature->MonsterWhisper(votewhisper, player);
+        player->ADD_GOSSIP_ITEM(0, "1 - %VOTE1%", GOSSIP_SENDER_MAIN, 1600);
+        player->ADD_GOSSIP_ITEM(0, "2 - %VOTE2%", GOSSIP_SENDER_MAIN, 1601);
+        player->ADD_GOSSIP_ITEM(0, "3 - %VOTE3%", GOSSIP_SENDER_MAIN, 1602);
+        player->ADD_GOSSIP_ITEM(0, "4 - %VOTE4%", GOSSIP_SENDER_MAIN, 1603);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 124: // Titles, Not Ready Yet!
+        player->ADD_GOSSIP_ITEM(0, "Jenkins", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM(0, "Loremaster", GOSSIP_SENDER_MAIN, 3001);
+        player->ADD_GOSSIP_ITEM(0, "the Seeker", GOSSIP_SENDER_MAIN, 3002);
+        player->ADD_GOSSIP_ITEM(0, "the Argent Defender", GOSSIP_SENDER_MAIN, 3003);
+        player->ADD_GOSSIP_ITEM(0, "Bane of the Fallen King", GOSSIP_SENDER_MAIN, 3004);
+        player->ADD_GOSSIP_ITEM(0, "Champion of the Frozen Wastes", GOSSIP_SENDER_MAIN, 3005);
+        player->ADD_GOSSIP_ITEM(0, "Champion of the Naaru", GOSSIP_SENDER_MAIN, 3006);
+        player->ADD_GOSSIP_ITEM(0, "Conqueror of Naxxramas", GOSSIP_SENDER_MAIN, 3007);
+        player->ADD_GOSSIP_ITEM(0, "Conqueror of Ulduar", GOSSIP_SENDER_MAIN, 3008);
+        player->ADD_GOSSIP_ITEM(0, "Hand of A'dal", GOSSIP_SENDER_MAIN, 3009);
+        player->ADD_GOSSIP_ITEM(0, "the Immortal", GOSSIP_SENDER_MAIN, 3010);
+        player->ADD_GOSSIP_ITEM(0, "the Patient", GOSSIP_SENDER_MAIN, 3011);
+        player->ADD_GOSSIP_ITEM(0, "the Undying", GOSSIP_SENDER_MAIN, 3012);
+        player->ADD_GOSSIP_ITEM(0, "Ambassador", GOSSIP_SENDER_MAIN, 3013);
+        player->ADD_GOSSIP_ITEM(0, "Bloodsail Admiral", GOSSIP_SENDER_MAIN, 3014);
+        player->ADD_GOSSIP_ITEM(0, "Crusader", GOSSIP_SENDER_MAIN, 3015);
+        player->ADD_GOSSIP_ITEM(0, "the Diplomat", GOSSIP_SENDER_MAIN, 3016);
+        player->ADD_GOSSIP_ITEM(0, "the Exalted", GOSSIP_SENDER_MAIN, 3017);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+        /// Buffer part
+    case 125: // buffer
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Power Word: Fortitude, Rank 8", GOSSIP_SENDER_MAIN, 4000);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Blessing of Kings", GOSSIP_SENDER_MAIN, 4001);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Bleesing of Mights", GOSSIP_SENDER_MAIN,4002);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Blessing of Wisdom", GOSSIP_SENDER_MAIN, 4003);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Mark of the Wild, Rank 9", GOSSIP_SENDER_MAIN, 4004);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Arcane Intellect, Rank 7", GOSSIP_SENDER_MAIN, 4005);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Soul Stone", GOSSIP_SENDER_MAIN, 4006);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Thorns, Rank 8", GOSSIP_SENDER_MAIN, 4007);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Divine Spirit, Rank 8", GOSSIP_SENDER_MAIN, 4008);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Shadow Protection, Rank 5", GOSSIP_SENDER_MAIN, 4009);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+         break;
+
+    case 4000:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48161, false); // target, spellid, triggered-e
+        break;
+
+        case 4001:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 25898, false);
+        break;
+
+        case 4002:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48934, false);
+        break;
+
+        case 4003:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48938, false);
+        break;
+
+        case 4004:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48469, false);
+        break;
+
+        case 4005:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 42995, false);
+        break;
+
+        case 4006:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 47883, false);
+        break;
+
+        case 4007:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 53307, false);
+        break;
+
+        case 4008:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48073, false);
+        break;
+
+        case 4009:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48169, false);
+        break;
+
+
+        /////////// NORMAL MENUS -> ACTION OR MENU
+
+
+
+        ///-- Server Menus part start --///
+        case 900: // Hacked
+        // Closes the account
+        LoginDatabase.PQuery("UPDATE `account` SET `locked`=1 WHERE `id`='%s'", player->GetSession()->GetAccountId());
+        LoginDatabase.PQuery("INSERT INTO `hacked` (`charname`) VALUES ('%s'", player); // Report it to the DB.
+        break;
+
+        case 901: // Report lagg
+        /*player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper(('%s', player->GetSession()->GetAccountId()), player);
+        LoginDatabase.PExecute("INSERT INTO `lagreports` (`account`) VALUES ('%s'", player->GetSession()->GetAccountId());
+        _Creature->MonsterWhisper("Lagg report done.", player);*/
+        break;
+
+        case 902: // Help
+        player->ADD_GOSSIP_ITEM(0, "Donation Help", GOSSIP_SENDER_MAIN, 1700);
+        player->ADD_GOSSIP_ITEM(0, "Ingame Help", GOSSIP_SENDER_MAIN, 1701);
+        player->ADD_GOSSIP_ITEM(0, "Normal Help", GOSSIP_SENDER_MAIN, 1702);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 1700: // Donation Help
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper("Donations can be done on www.flaminglegion.net", player);
+        break;
+
+        case 1701: // INGAME HELP
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper("Contact a GM for help", player);
+        break;
+
+        case 1702: // Normal Help
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper("Helpful information can be found on www.flaminglegion.net", player);
+        break;
+        /// -- Server Menus part End -- ///
+
+        /// -- Funny Things Menu Start -- /// money drunk sober
+
+        case 1000: // Money
+        player->CLOSE_GOSSIP_MENU();
+        player->GetMail(moneymail);
+        _Creature->MonsterWhisper("Check your mailbox.", player);
+        break;
+
+        case 1001: // Drunk
+        player->CLOSE_GOSSIP_MENU();
+        player->CastSpell(player, 46876, false);
+        break;
+
+        case 1002: // Sober
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDrunkValue(0, 9);
+        break;
+        /// -- Funny Things Menu End -- ///
+
+        /// -- Announcer Part Start -- ///
+
+        case 1100:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).PSendSysMessage(LANG_WSG);
+        break;
+
+        case 1101:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_AB);
+        break;
+
+        case 1102:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_WG);
+        break;
+
+        case 1103:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_SOTA);
+        break;
+
+        case 1104:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_AV);
+        break;
+
+        case 1105:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_RANDOM);
+        break;
+
+        case 1106:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_ARENA_1);
+        break;
+
+        case 1107:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_ARENA_2);
+        break;
+
+        case 1108:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_ARENA_3);
+        break;
+
+        case 1109:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_EOTS);
+        break;
+
+        /// -- Announcer part end -- ///
+
+        /////////////////////////////////
+        //        BREAK           //
+        //////////////////////////////////
+        //////////////////////////////////
+
+    /*************************************************************************/
+
+        /// -- Morph Part Start -- ///
+
+               case 500:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(21135);
+        break;
+
+        case 501:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(23200);
+        break;
+
+        case 502:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(20681);
+        break;
+
+        case 503:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16508);
+        break;
+
+        case 504:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(17332);
+        break;
+
+        case 505:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(2789);
+        break;
+
+        case 506:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16280);
+        break;
+
+        case 507:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(24191);
+        break;
+
+        case 508:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(22209);
+        break;
+
+        case 509:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(23889);
+        break;
+
+        case 510:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(24949);
+        break;
+
+        case 711: // Algalon
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(28641);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 712: // Doomwalker
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16630);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 713: // Doomlord kazzak
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(17887);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.10f);
+        break;
+
+        case 714: // Onyxia
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(8570);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 715: // Thaddius
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16137);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 716: // Gluth
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16064);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 717: // Maexxna
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15928);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.15f);
+        break;
+
+        case 718: // Sapphiron
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16033);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 719: // Noth The Plaguebringer
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16590);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.7f);
+        break;
+
+        case 720: // Kel'Thuzad
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15945);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 721: // Kael'thas Sunstrider
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(20023);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.5f);
+        break;
+
+        case 722: // C'thun
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15786);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 723: // Thrall
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(4527);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+
+/// -- Morph Part End -- ///
+
+
+
+
+
+
+
+/// -- Teleport Part Start -- ///
+        case 600: // Raid dungeon , cities
+        player->ADD_GOSSIP_ITEM(0, "ICC", GOSSIP_SENDER_MAIN, 1900);
+        player->ADD_GOSSIP_ITEM(0, "Naxxramas", GOSSIP_SENDER_MAIN, 1901);
+        player->ADD_GOSSIP_ITEM(0, "Ulduar", GOSSIP_SENDER_MAIN, 1902);
+        player->ADD_GOSSIP_ITEM(0, "Nexus", GOSSIP_SENDER_MAIN, 1903);
+        player->ADD_GOSSIP_ITEM(0, "Argent Tournament Grounds", GOSSIP_SENDER_MAIN, 1904);
+        player->ADD_GOSSIP_ITEM(0, "Azjol-Nerub", GOSSIP_SENDER_MAIN, 1905);
+        player->ADD_GOSSIP_ITEM(0, "Drak' Tharon Keep", GOSSIP_SENDER_MAIN, 1906);
+        player->ADD_GOSSIP_ITEM(0, "Gundrak", GOSSIP_SENDER_MAIN, 1907);
+        player->ADD_GOSSIP_ITEM(0, "Utgarde Keep", GOSSIP_SENDER_MAIN, 1908);
+        player->ADD_GOSSIP_ITEM(0, "Utgarde Pinnacle", GOSSIP_SENDER_MAIN, 1909);
+        player->ADD_GOSSIP_ITEM(0, "Vault of Archavon", GOSSIP_SENDER_MAIN, 1910);
+        player->ADD_GOSSIP_ITEM(0, "Violet Hold", GOSSIP_SENDER_MAIN, 1911);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 601: // Cities
+
+        player->ADD_GOSSIP_ITEM(0, "Teleport Stormwind", GOSSIP_SENDER_MAIN, 1800);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Ironforge", GOSSIP_SENDER_MAIN, 1801);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Darnassus", GOSSIP_SENDER_MAIN, 1802);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Exodar", GOSSIP_SENDER_MAIN, 1803);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Shattrath", GOSSIP_SENDER_MAIN, 1804);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Dalaran", GOSSIP_SENDER_MAIN, 1805);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Gurubashi Arena", GOSSIP_SENDER_MAIN, 1806);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Orgrimmar", GOSSIP_SENDER_MAIN, 1807);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Undercity", GOSSIP_SENDER_MAIN, 1808);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Silvermoon", GOSSIP_SENDER_MAIN, 1809);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Thunder Bluff", GOSSIP_SENDER_MAIN, 1810);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Alliance Mall", GOSSIP_SENDER_MAIN, 5000);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Alliance LevelRoad", GOSSIP_SENDER_MAIN, 9998);
+
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 604: // areas
+        player->ADD_GOSSIP_ITEM(0, "Azuremyst Isle", GOSSIP_SENDER_MAIN, 1850);
+        player->ADD_GOSSIP_ITEM(0, "Teldrassil", GOSSIP_SENDER_MAIN, 1851);
+        player->ADD_GOSSIP_ITEM(0, "Elwynn Forest", GOSSIP_SENDER_MAIN, 1852);
+        player->ADD_GOSSIP_ITEM(0, "Dun Morogh", GOSSIP_SENDER_MAIN, 1853);
+        player->ADD_GOSSIP_ITEM(0, "Durotar", GOSSIP_SENDER_MAIN, 1854);
+        player->ADD_GOSSIP_ITEM(0, "Mulgore", GOSSIP_SENDER_MAIN, 1855);
+        player->ADD_GOSSIP_ITEM(0, "Tirisfal Glades", GOSSIP_SENDER_MAIN, 1856);
+        player->ADD_GOSSIP_ITEM(0, "Eversong Woods", GOSSIP_SENDER_MAIN, 1857);
+        player->ADD_GOSSIP_ITEM(0, "Darkshore", GOSSIP_SENDER_MAIN, 1858);
+        player->ADD_GOSSIP_ITEM(0, "Loch Modan", GOSSIP_SENDER_MAIN, 1859);
+        player->ADD_GOSSIP_ITEM(0, "Redridge Mountains", GOSSIP_SENDER_MAIN, 1860);
+        player->ADD_GOSSIP_ITEM(0, "Barrens", GOSSIP_SENDER_MAIN, 1861);
+        player->ADD_GOSSIP_ITEM(0, "Stonetalon Mountains", GOSSIP_SENDER_MAIN, 1862);
+        player->ADD_GOSSIP_ITEM(0, "Ashenvale", GOSSIP_SENDER_MAIN, 1863);
+        player->ADD_GOSSIP_ITEM(0, "Wetlands", GOSSIP_SENDER_MAIN, 1864);
+        player->ADD_GOSSIP_ITEM(0, "Thousand Needles", GOSSIP_SENDER_MAIN, 1865);
+        player->ADD_GOSSIP_ITEM(0, "Hillsbrad Foothills", GOSSIP_SENDER_MAIN, 1866);
+        player->ADD_GOSSIP_ITEM(0, "Arathi Highlands", GOSSIP_SENDER_MAIN, 1867);
+        player->ADD_GOSSIP_ITEM(0, "Desolace", GOSSIP_SENDER_MAIN, 1868);
+        player->ADD_GOSSIP_ITEM(0, "Stranglethorn Vale", GOSSIP_SENDER_MAIN, 1869);
+        player->ADD_GOSSIP_ITEM(0, "Badlands", GOSSIP_SENDER_MAIN, 1870);
+        player->ADD_GOSSIP_ITEM(0, "Swamp of Sorrows", GOSSIP_SENDER_MAIN, 1871);
+        player->ADD_GOSSIP_ITEM(0, "The Hinterlands", GOSSIP_SENDER_MAIN, 1872);
+        player->ADD_GOSSIP_ITEM(0, "Tanaris", GOSSIP_SENDER_MAIN, 1873);
+        player->ADD_GOSSIP_ITEM(0, "Blasted Lands", GOSSIP_SENDER_MAIN, 1874);
+        player->ADD_GOSSIP_ITEM(0, "Searing Gorge", GOSSIP_SENDER_MAIN, 1875);
+        player->ADD_GOSSIP_ITEM(0, "Un Goro Crater", GOSSIP_SENDER_MAIN, 1876);
+        player->ADD_GOSSIP_ITEM(0, "Azshara", GOSSIP_SENDER_MAIN, 1877);
+        player->ADD_GOSSIP_ITEM(0, "Felwood", GOSSIP_SENDER_MAIN, 1878);
+        player->ADD_GOSSIP_ITEM(0, "Winterspring", GOSSIP_SENDER_MAIN, 1879);
+        player->ADD_GOSSIP_ITEM(0, "Silithus", GOSSIP_SENDER_MAIN, 1880);
+        player->ADD_GOSSIP_ITEM(0, "Western Plaguelands", GOSSIP_SENDER_MAIN, 1881);
+        player->ADD_GOSSIP_ITEM(0, "Burning Steppes", GOSSIP_SENDER_MAIN, 1882);
+        player->ADD_GOSSIP_ITEM(0, "Hellfire Peninsula", GOSSIP_SENDER_MAIN, 1883);
+        player->ADD_GOSSIP_ITEM(0, "Zangarmarsh", GOSSIP_SENDER_MAIN, 1884);
+        player->ADD_GOSSIP_ITEM(0, "Terokkar Forest", GOSSIP_SENDER_MAIN, 1885);
+        player->ADD_GOSSIP_ITEM(0, "Nagrand", GOSSIP_SENDER_MAIN, 1886);
+        player->ADD_GOSSIP_ITEM(0, "Blades Edge Mountain", GOSSIP_SENDER_MAIN, 1887);
+        player->ADD_GOSSIP_ITEM(0, "Netherstorm", GOSSIP_SENDER_MAIN, 1888);
+        player->ADD_GOSSIP_ITEM(0, "Shadowmoon Valley", GOSSIP_SENDER_MAIN, 1889);
+        player->ADD_GOSSIP_ITEM(0, "Borean Tundra", GOSSIP_SENDER_MAIN, 1890);
+        player->ADD_GOSSIP_ITEM(0, "Dragonblight", GOSSIP_SENDER_MAIN, 1891);
+        player->ADD_GOSSIP_ITEM(0, "Grizzly Hills", GOSSIP_SENDER_MAIN, 1892);
+        player->ADD_GOSSIP_ITEM(0, "Zul'Drak", GOSSIP_SENDER_MAIN, 1893);
+        player->ADD_GOSSIP_ITEM(0, "Sholazar Basin", GOSSIP_SENDER_MAIN, 1894);
+        player->ADD_GOSSIP_ITEM(0, "The Storm Peaks", GOSSIP_SENDER_MAIN, 1895);
+        player->ADD_GOSSIP_ITEM(0, "Howling Fjord", GOSSIP_SENDER_MAIN, 1896);
+        player->ADD_GOSSIP_ITEM(0, "Icecrown", GOSSIP_SENDER_MAIN, 1897);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        /// tele loactions
+
+        // RAIDS & Dungeons
+
+        case 1900: // icc
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 5873.819824f, 2110.979980f, 636.010986f, 0.0f);
+            break;
+
+        case 1901: // Naxxramas
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 3665.904053f, -1267.064575f, 243.512207f, 0.0f);
+            break;
+
+        case 1902: // Ulduar
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 8948.200165f, -1268.270020f, 1025.500000f, 0.0f);
+            break;
+        case 1903: // Nexus
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 3785.800049f, 6944.919922f, 104.620003f, 0.0f);
+            break;
+        case 1904: // Argent tournement
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 8513.266602f, 638.120728f, 547.324890f, 0.0f);
+            break;
+        case 1905: // Azjol-Nerub
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 3707.86f, 2150.23f, 36.7568f, 0.0f);
+            break;
+        case 1906: // Drak' Tharon Keep
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 4774.6f, -2032.92f, 229.145f, 0.0f);
+            break;
+        case 1907: // Gundrak
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 6910.8f, -4603.23f, 450.61f, 0.0f);
+            break;
+        case 1908: // Utgarde Keep
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 1219.72f, -4865.28f, 41.2479f, 0.0f);
+            break;
+        case 1909: // Utgarde Pinnacle
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 1259.33f, -4852.02f, 215.763f, 0.0f);
+            break;
+        case 1910: // Vault of Archavon
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 5453.72f, 2840.79f, 421.277f, 0.0f);
+            break;
+        case 1911: // Violet Hold
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 5689.03f, 508.278f, 652.763f, 0.0f);
+            break;
+
+/////// cities
+
+        case 1800: // Stormwind
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -8960.14f, 516.266f, 96.3568f, 0.0f); // Teleport(location)
+        break;
+
+        case 1801: // Ironforge
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -4924.07f, -951.95f, 501.55f, 5.40f);
+        break;
+
+        case 1802: // Darnassus
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 9947.52f, 2482.73f, 1316.21f, 0.0f);
+        break;
+
+        case 1803: // Exodar
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -3954.20f, -11656.54f, -138.69f, 0.0f);
+        break;
+
+        case 1804: // Shattrath
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -1850.209961f, 5435.821777f, -10.961435f, 3.403913f);
+        break;
+
+        case 1805: // Dalaran
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5819.08f, 643.99f, 647.80f, 3.32f);
+        break;
+
+        case 1806: // Gurubashi Arena
+        player->CLOSE_GOSSIP_MENU();
+
+        player->TeleportTo(0,  -13277.4f, 127.372f, 26.1418f, 1.0f);
+        break;
+
+        case 1807: // Orgrimmar
+         player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1552.5f, -4420.66f, 8.94802f, 0.0f);
+        break;
+
+        case 1808: // Undercity
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 1819.71f, 238.79f, 60.5321f, 0.0f);
+
+        break;
+
+        case 1809: // Silvermoon
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 9338.74f, -7277.27f, 13.7895f, 0.0f);
+        break;
+
+        case 1810: // Thunder Bluff
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -1290.0f, 147.033997f, 129.682007f, 4.919000f);
+        break;
+
+        case 5001: // Horde Mall
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(HMM, HMX, HMY, HMZ, 0.0f);
+        break;
+
+        case 5000: // Alliance Mall
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(AMM, AMX, AMY, AMZ, 0.0f);
+        break;
+
+// Leveling Roads
+        case 9999:    // horde level road
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(HLM, HLX, HLY, HLZ, 0.0f);
+        break;
+
+        case 9998:    //alliance level road
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(ALM, ALX, ALY, ALZ, 0.0f);
+        break;
+// Zones
+        case 1850:  // Azuremyst Isle
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -4216.870117f, -12336.900391f, 4.340638f, 0.0f);
+        break;
+        case 1851:  // Teldrassil
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 10111.299805f, 1557.729980f, 1324.329956f, 0.0f);
+        break;
+        case 1852:  // Elwynn Forest
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -9617.059570f, -288.949005f, 57.305149f, 0.0f);
+        break;
+        case 1853:  // Dun Morogh
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -5451.549805f, -656.992004f, 392.674988f, 0.0f);
+        break;
+        case 1854:  // Durotar
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1007.780029f, -446.220215f, 11.202200f, 0.0f);
+        break;
+        case 1855:  // Mulgore
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -2192.620117f, -736.317017f, -13.327400f, 0.0f);
+        break;
+        case 1856:  // Tirisfal Glades
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 2036.020020f, 161.330994f, 33.867401f, 0.0f);
+        break;
+        case 1857:  // Eversong Woods
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 9079.919922f, -7193.229980f, 55.601299f, 0.0f);
+        break;
+        case 1858:  // Darkshore
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 5756.250000f, 298.505005f, 20.604900f, 0.0f);
+        break;
+        case 1859:  // Loch Modan
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -5202.939941f, -2855.179932f, 335.953827f, 0.0f);
+        break;
+        case 1860:  // Redridge Mountains
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -9551.809570f, -2204.729980f, 93.473000f, 0.0f);
+        break;
+        case 1861:  // The Barrens
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 884.539978f, -3548.449951f, 91.853165f, 0.0f);
+        break;
+        case 1862:  // Stonetalon Mountains
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1570.920044f, 1031.520020f, 137.959000f, 0.0f);
+        break;
+        case 1863:  // Ashenvale
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1928.339966f, -2165.949951f, 93.789597f, 0.0f);
+        break;
+        case 1864:  // Wetlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -3242.810059f, -2469.040039f, 15.922600f, 0.0f);
+        break;
+        case 1865:  // Thousand Needles
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -4969.020020f, -1726.890015f, -62.126911f, 0.0f);
+        break;
+        case 1866:  // Hillsbrad Foothills
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -436.657013f, -581.254028f, 53.594398f, 0.0f);
+        break;
+        case 1867:  // Arathi Highlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -1508.510010f, -2732.060059f, 32.498600f, 0.0f);
+        break;
+        case 1868:  // Desolace
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -606.395020f, 2211.750000f, 92.981796f, 0.0f);
+        break;
+        case 1869:  // Stranglethorn Vale
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -12644.299805f, -377.411011f, 10.102062f, 0.0f);
+        break;
+        case 1870:  // Badlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -6779.200195f, -3423.639893f, 241.667007f, 0.0f);
+        break;
+        case 1871:  // Spawm of Sorrows
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -10345.400391f, -2773.419922f, 21.990000f, 0.0f);
+        break;
+        case 1872:  // The Hinterlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 119.387001f, -3190.370117f, 117.330994f, 0.0f);
+        break;
+        case 1873:  // Tanaris
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7931.200195f, -3414.280029f, 80.736496f, 0.0f);
+        break;
+        case 1874:  // Blasted Lands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -11182.500000f, -3016.669922f, 7.422350f, 0.0f);
+        break;
+        case 1875:  // Searing Gorge
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -7012.470215f, -1065.130005f, 241.785995f, 0.0f);
+        break;
+        case 1876:  // Un Goro Crater
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7943.220215f, -2119.090088f, -218.344589f, 0.0f);
+        break;
+        case 1877:  // Azshara
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 3341.360107f, -4603.790039f, 92.502701f, 0.0f);
+        break;
+        case 1878:  // Felwood
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 4102.250000f, -1006.789978f, 272.717010f, 0.0f);
+        break;
+        case 1879:  // Winterspring
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 6759.180176f, -4419.629883f, 763.213989f, 0.0f);
+        break;
+        case 1880:  // Silithus
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7426.870117f, 1005.309998f, 1.133590f, 0.0f);
+        break;
+        case 1881:  // Western Plaguelands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 1728.650024f, -1602.250000f, 63.428963f, 0.0f);
+        break;
+        case 1882:  // Burning Steppes
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -8118.540039f, -1633.829956f, 132.996002f, 0.0f);
+        break;
+        case 1883:  // Hellfire Peninsula
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -211.237000f, 4278.540039f, 86.567802f, 0.0f);
+        break;
+        case 1884:  // Zangarmarsh
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -54.862099f, 5813.439941f, 20.605900f, 0.0f);
+        break;
+        case 1885:  // Terokkar Forest
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -2000.469971f, 4451.540039f, 8.369170f, 0.0f);
+        break;
+        case 1886:  // Nagrand
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -1145.949951f, 8182.350098f, 3.602490f, 0.0f);
+        break;
+        case 1887:  // Blades Edge Mountain
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3037.669922f, 5962.859863f, 130.774002f, 0.0f);
+        break;
+        case 1888:  // Netherstorm
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3830.229980f, 3426.500000f, 88.614502f, 0.0f);
+        break;
+        case 1889:  // Shadowmoon Valley
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -3077.271973f, 2878.689209f, 82.129242f, 0.0f);
+        break;
+        case 1890:  // Borean Tundra
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 3256.570068f, 5278.229980f, 40.804588f, 0.0f);
+        break;
+        case 1891:  // Dragonblight
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 4103.359863f, 264.477997f, 50.501900f, 0.0f);
+        break;
+        case 1892:  // Grizzly Hills
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 4391.729980f, -3587.919922f, 238.531006f, 0.0f);
+        break;
+        case 1893:  // Zul' Drak
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5560.229980f, -3211.659912f, 371.709015f, 0.0f);
+        break;
+        case 1894:  // Sholazar Basin
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5323.000000f, 4942.000000f, -133.558670f, 0.0f);
+        break;
+        case 1895:  // The Storm Peaks
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 7527.140137f, -1260.890015f, 919.049011f, 0.0f);
+        break;
+        case 1896:  // Howling Fjord
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 1902.150024f, -4883.910156f, 161.363007f, 0.0f);
+        break;
+        case 1897:  // Icecrown
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 7253.640137f, 1644.780029f, 433.679993f, 0.0f);
+        break;
+
+
+        /// -- Tele part stop -- ///
+
+    /// -- Dungeons, Raids -- ///
+
+
+        /// -- BG Control Part Start -- ///
+    /*        player->ADD_GOSSIP_ITEM(0, "WSG 100%", GOSSIP_SENDER_MAIN, 1400);
+        player->ADD_GOSSIP_ITEM(0, "EOTS 100%", GOSSIP_SENDER_MAIN, 1401);
+        player->ADD_GOSSIP_ITEM(0, "AB 100%", GOSSIP_SENDER_MAIN, 1402);
+        player->ADD_GOSSIP_ITEM(0, "SOTA 100%", GOSSIP_SENDER_MAIN, 1403);
+        player->ADD_GOSSIP_ITEM(0, "AV 100%", GOSSIP_SENDER_MAIN, 1404); // LOL!*/
+
+        case 1400: // WSG 100%
+        /* Comment: IDS:
+        SOTA - 9
+        AV - 1
+        WSG - 2
+        AB - 3
+        EOTS - 7*/
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=2");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1401: // EOTS 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 2, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=7");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1402: // AB 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 2, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=3");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1403: // Sota 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 7, 2)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=9");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1404: // AV 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(2, 3, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=1");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        /// -- BG Modify Part End -- ///
+
+        /* Break */
+
+
+
+
+
+        /// -- Token Part Start -- ///
+
+        /*
+            case 107: // Token -> BUY
+        player->ADD_GOSSIP_ITEM(0, tokenbuy, GOSSIP_SENDER_MAIN, 1200);
+        break;
+
+        case 108: // Token ->Change
+        player->ADD_GOSSIP_ITEM(0, tokenchange, GOSSIP_SENDER_MAIN, 1300);
+        break;
+        */
+
+        case 1201: // Token change
+        if(player->HasItemCount(token1, 1, false))
+        {
+        player->ItemRemovedQuestCheck(token1, 1);
+        player->AddItem(token2, 1);
+        } else {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "You don't have got enough token.", GOSSIP_SENDER_MAIN, 12345);
+        break;
+        }
+
+        case 1200:
+        player->ADD_GOSSIP_ITEM_EXTENDED(0, tokenbuy, GOSSIP_SENDER_MAIN, 2000, "Are you sure you want to buy a token?", -10000, 0);
+        break;
+        case 2000:
+        player->AddItem(vasarolhatotoken, 1);
+        break;
+
+        ///-- Token Part End --///
+
+        ///-- Trainers Part Start --///
+        /*
+        player->ADD_GOSSIP_ITEM(1, "Prof Trainer", GOSSIP_SENDER_MAIN, 800);
+        player->ADD_GOSSIP_ITEM(1, "Class Trainer", GOSSIP_SENDER_MAIN, 801);
+        player->ADD_GOSSIP_ITEM(1, "Weapon Trainer", GOSSIP_SENDER_MAIN, 802);
+        player->ADD_GOSSIP_ITEM(1, "Mount Trainer", GOSSIP_SENDER_MAIN, 803);
+        */
+
+        case 803: // Mount Trainer
+        {
+        player->CLOSE_GOSSIP_MENU();
+        player->learnSpell(33388, false);
+        player->learnSpell(33391, false);
+        player->learnSpell(34090, false);
+        player->learnSpell(34091, false);
+        player->learnSpell(54197, false);
+        }
+
+        case 800: // profs
+        // SPGM
+        player->ADD_GOSSIP_ITEM(3, "Alchemy"                     , GOSSIP_SENDER_MAIN, 2100);
+        player->ADD_GOSSIP_ITEM(3, "Blacksmithing"           , GOSSIP_SENDER_MAIN, 2101);
+        player->ADD_GOSSIP_ITEM(3, "Enchanter"        , GOSSIP_SENDER_MAIN, 2102);
+        player->ADD_GOSSIP_ITEM(3, "Engineering"              , GOSSIP_SENDER_MAIN, 2103);
+        player->ADD_GOSSIP_ITEM(3, "Herbalism"            , GOSSIP_SENDER_MAIN, 2104);
+        player->ADD_GOSSIP_ITEM(3, "Inscription"        , GOSSIP_SENDER_MAIN, 2105);
+        player->ADD_GOSSIP_ITEM(3, "Jewelcrafting"           , GOSSIP_SENDER_MAIN, 2106);
+        player->ADD_GOSSIP_ITEM(3, "Leatherworking"           , GOSSIP_SENDER_MAIN, 2107);
+        player->ADD_GOSSIP_ITEM(3, "Mining"                , GOSSIP_SENDER_MAIN, 2108);
+        player->ADD_GOSSIP_ITEM(3, "Skinning"        , GOSSIP_SENDER_MAIN, 2109);
+        player->ADD_GOSSIP_ITEM(3, "Tailoring"                  , GOSSIP_SENDER_MAIN, 2110);
+        player->ADD_GOSSIP_ITEM(3, "Cooking"              , GOSSIP_SENDER_MAIN, 2111);
+        player->ADD_GOSSIP_ITEM(3, "First Aid"            , GOSSIP_SENDER_MAIN, 2112);
+        player->ADD_GOSSIP_ITEM(3, "Fishing"              , GOSSIP_SENDER_MAIN, 2113);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+        case 801: // Class Trainers
+
+        player->ADD_GOSSIP_ITEM(3, "Death Knight"          , GOSSIP_SENDER_MAIN, 2200);
+        player->ADD_GOSSIP_ITEM(3, "Druid"               , GOSSIP_SENDER_MAIN, 2201);
+        player->ADD_GOSSIP_ITEM(3, "Hunter"            , GOSSIP_SENDER_MAIN, 2202);
+        player->ADD_GOSSIP_ITEM(3, "Mage"            , GOSSIP_SENDER_MAIN, 2203);
+        player->ADD_GOSSIP_ITEM(3, "Paladin"             , GOSSIP_SENDER_MAIN, 2204);
+        player->ADD_GOSSIP_ITEM(3, "Priest"                , GOSSIP_SENDER_MAIN, 2205);
+        player->ADD_GOSSIP_ITEM(3, "Rogue"                       , GOSSIP_SENDER_MAIN, 2206);
+        player->ADD_GOSSIP_ITEM(3, "Shaman"               , GOSSIP_SENDER_MAIN, 2207);
+        player->ADD_GOSSIP_ITEM(3, "Warlock"        , GOSSIP_SENDER_MAIN, 2208);
+        player->ADD_GOSSIP_ITEM(3, "Warrior"                 , GOSSIP_SENDER_MAIN, 2209);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 2200:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(dk,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2201:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(dudu,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2202:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(hunta,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2203:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(mage,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2204:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(pala,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2205:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(priest,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2206:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(rogue,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2207:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(sami,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2208:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(lock,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2209:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(wari,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        //Sickness,Reset Talent Start//
+        case 121: // Reset Talent Pont
+        player->CLOSE_GOSSIP_MENU();
+        player->SendTalentWipeConfirm(_Creature->GetGUID());
+        break;
+
+        case 120: //Sickness leszedse
+        if(!player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0))
+        {
+            _Creature->MonsterWhisper(nosickness, player);
+        }
+        else
+        {
+        _Creature->CastSpell(player,38588,false); // Flash Heal
+        player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+        player->CLOSE_GOSSIP_MENU();
+        break;
+        //Sickness,Reset Talent End//
+        ////// Prof trainers
+
+        case 2100: // Alchemy
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(33630,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        player->SummonCreature(28703,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2101: // Blacksmithing
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(28694,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+case 2102: // Enchanting
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28693,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+    player->SummonCreature(33633,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+        case 2103: // Engineering
+   player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28697,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2104: // Herbalism
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28704,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+case 2105: // Inscription
+ player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28702,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2106: // Jewelcrafting
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28701,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2107: // Leatherworking
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28700,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2108: // Mining
+    player->CLOSE_GOSSIP_MENU();    player->SummonCreature(28698,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2109: // Skinning
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28696,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2110: // Tailoring
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28699,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2111: // Cooking
+   player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28705,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2112: // First Aid
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28706,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+        case 2113: // Fishing
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28742,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+}
+//return true;
+    }
+
+bool OnGossipSelect(Player* player, Creature* _Creature, uint32 sender, uint32 action)
+{
+    // Main menu
+    player->PlayerTalkClass->ClearMenus();
+    if (sender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(player, _Creature, action);
+
+return true;
+}
+};
+
+void AddSC_npc_all()
+{
+    new npc_all();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/beastmaster.cpp b/src/server/scripts/Custom/beastmaster.cpp
new file mode 100644
index 0000000..1261411
--- /dev/null
+++ b/src/server/scripts/Custom/beastmaster.cpp
@@ -0,0 +1,385 @@
+//Modified by Marcus rewritten by LordPsyan
+//original script created by ??
+#include "ScriptPCH.h"
+#include "Config.h"
+#include "Pet.h"
+#include "SystemConfig.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define MSG_TYPE                100004
+#define MSG_PET                 100005
+#define MAIN_MENU               "<= [Main Menu]"
+
+class Npc_Beastmaster : public CreatureScript
+{
+public:
+        Npc_Beastmaster() : CreatureScript("Npc_Beastmaster") { }
+
+void CreatePet(Player *player, Creature * m_creature, uint32 entry) {
+
+    if(sConfigMgr->GetBoolDefault("BeastMaster.OnlyHunter", false)) // Checks to see if Only Hunters can have pets.
+     {
+        if(player->getClass() != CLASS_HUNTER) {
+            m_creature->MonsterWhisper("You are not a Hunter!", player);
+            return;
+        }
+     }
+
+    if(player->GetPet()) {
+        m_creature->MonsterWhisper("First you must abandon your Pet!", player);
+        return;
+    }
+
+    Creature *creatureTarget = m_creature->SummonCreature(entry, player->GetPositionX(), player->GetPositionY()+2, player->GetPositionZ(), player->GetOrientation(), TEMPSUMMON_CORPSE_TIMED_DESPAWN, 500);
+    if(!creatureTarget) return;
+
+    Pet* pet = player->CreateTamedPetFrom(creatureTarget, 0);
+
+    if(!pet) return;
+
+        // kill original creature
+    creatureTarget->setDeathState(JUST_DIED);
+    creatureTarget->RemoveCorpse();
+    creatureTarget->SetHealth(0);                       // just for nice GM-mode view
+
+    pet->SetPower(POWER_HAPPINESS, 1048000);
+
+    // prepare visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, player->getLevel() - 1);
+    pet->GetMap()->AddToMap((Creature*)pet);
+        // visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, player->getLevel());
+
+    if(!pet->InitStatsForLevel(player->getLevel()))
+        TC_LOG_ERROR("scripts", "Pet Create fail: no init stats for entry %u", entry);
+        pet->UpdateAllStats();
+
+    // caster have pet now
+        player->SetMinion(pet, true);
+
+        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+        pet->InitTalentForLevel();
+        player->PetSpellInitialize();
+    //end
+        player->CLOSE_GOSSIP_MENU();
+        m_creature->MonsterWhisper("Pet added. You might want to feed it and name it somehow.", player);
+        return;
+    }
+
+bool OnGossipHello(Player* player, Creature* m_creature)
+{
+    bool EnableNormalPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableNormalPet", true);
+    bool EnableExoticPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableExoticPet", true);
+
+    // Main Menu
+
+    // Check config if "Normal Pet " is enabled or not
+    if(EnableNormalPet)
+        player->ADD_GOSSIP_ITEM( 7, "Normal Pets ->"              , GOSSIP_SENDER_MAIN, 1000);
+    // Check if player can have an exotic pet, and check config if "Exotic" is enabled or not
+    if(player->CanTameExoticPets() && EnableExoticPet)
+        player->ADD_GOSSIP_ITEM( 7, "Exotic Pets ->"              , GOSSIP_SENDER_MAIN, 2000);
+    // Now to add the spells, vendor, and stable stuffs
+    player->ADD_GOSSIP_ITEM(4, "Teach Me Pet spells ->"      , GOSSIP_SENDER_MAIN, 3000);
+    player->ADD_GOSSIP_ITEM(2, "Take me to the Stable.", GOSSIP_SENDER_MAIN, 6006);
+    player->ADD_GOSSIP_ITEM(6, "Sell me some Food for my Pet.", GOSSIP_SENDER_MAIN, 6007);
+    player->SEND_GOSSIP_MENU(MSG_TYPE, m_creature->GetGUID());
+return true;
+}
+
+bool showNormalPet(Player *player, Creature *m_creature, uint32 showFromId = 0)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `entry`, `name` FROM `beastmaster` WHERE `cat_number` = 0 ORDER BY `entry` ASC");
+
+ if (result)
+ {
+ uint32 entryNum = 0;
+ std::string petName = "";
+ uint8 tokenOrGold = 0;
+ uint32 price = 0;
+ uint32 nToken = 0;
+
+  do
+ {
+ Field *fields = result->Fetch();
+ entryNum = fields[0].GetInt32();
+ petName = fields[1].GetString();
+
+    player->ADD_GOSSIP_ITEM(9, petName, GOSSIP_SENDER_MAIN, entryNum);
+}
+ while (result->NextRow());
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ m_creature->MonsterWhisper("You don't have enough money.", player);
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showNormalPet(player, m_creature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showExoticPet(Player *player, Creature *m_creature, uint32 showFromId = 0)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `entry`, `name` FROM `beastmaster` WHERE `cat_number` = 1 ORDER BY `entry` ASC");
+
+ if (result)
+ {
+ uint32 entryNum = 0;
+ std::string petName = "";
+  do
+ {
+ Field *fields = result->Fetch();
+ entryNum = fields[0].GetInt32();
+ petName = fields[1].GetString();
+
+    player->ADD_GOSSIP_ITEM(9, petName, GOSSIP_SENDER_MAIN, entryNum);
+}
+ while (result->NextRow());
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ //m_creature->MonsterWhisper("You don't have enough money.", player);
+ //player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showExoticPet(player, m_creature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showPetSpells(Player *player, Creature *m_creature, uint32 showFromId = 0)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `entry`, `name` FROM `beastmaster` WHERE `cat_number` = 2 ORDER BY `entry` ASC");
+
+ if (result)
+ {
+ uint32 entryNum = 0;
+ std::string petName = "";
+ uint8 tokenOrGold = 0;
+ uint32 price = 0;
+ uint32 nToken = 0;
+
+  do
+ {
+ Field *fields = result->Fetch();
+ entryNum = fields[0].GetInt32();
+ petName = fields[1].GetString();
+
+    player->ADD_GOSSIP_ITEM(9, petName, GOSSIP_SENDER_MAIN, entryNum);
+}
+ while (result->NextRow());
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ m_creature->MonsterWhisper("You don't have enough money.", player);
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showPetSpells(player, m_creature, 0);
+ }
+ }
+
+ return false;
+}
+
+void SendDefaultMenu(Player* player, Creature* m_creature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (player->IsInCombat())
+{
+    player->CLOSE_GOSSIP_MENU();
+    m_creature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+    bool EnableNormalPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableNormalPet", true);
+    bool EnableExoticPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableExoticPet", true);
+
+  // send name as gossip item
+       QueryResult result;
+        uint32 spellId = 0;
+        uint32 catNumber = 0;
+        uint32 cost = 0;
+        std::string spellName = "";
+        uint32 token = 0;
+        bool tokenOrGold = true;
+
+        result = WorldDatabase.PQuery("SELECT * FROM `beastmaster` WHERE `entry` = %u LIMIT 1", uiAction);
+
+if (result)
+{
+    do {
+        Field *fields = result->Fetch();
+        catNumber = fields[1].GetInt32();
+        tokenOrGold = fields[2].GetBool();
+        cost = fields[3].GetInt32();
+        token = fields[4].GetInt32();
+        spellName = fields[5].GetString();
+        spellId = fields[6].GetInt32();
+
+        if (tokenOrGold)
+        {
+            if (!player->HasItemCount(token, cost))
+                {
+                    m_creature->MonsterWhisper("You ain't gots no darn chips.", player);
+                    player->CLOSE_GOSSIP_MENU();
+                    return;
+                }
+            else if (uiAction != 1000 && uiAction != 2000 && uiAction != 3000 && catNumber != 2)
+            {
+    player->CLOSE_GOSSIP_MENU();
+    CreatePet(player, m_creature, spellId);
+    player->DestroyItemCount(token, cost, true);
+            }
+            else if (catNumber = 2)
+            {
+            if (player->HasSpell(spellId))
+            {
+                m_creature->MonsterWhisper("You already know this spell.", player);
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            } else {
+    player->CLOSE_GOSSIP_MENU();
+    player->learnSpell(spellId, false);
+    player->DestroyItemCount(token, cost, true);
+            }
+        }
+
+        } else {
+            if (player->GetMoney() < cost)
+            {
+                m_creature->MonsterWhisper("You dont have enough money!", player);
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            }
+        else if (uiAction != 1000 && uiAction != 2000 && uiAction != 3000 && catNumber != 2)
+        {
+    player->CLOSE_GOSSIP_MENU();
+    CreatePet(player, m_creature, spellId);
+    player->ModifyMoney(-int(cost));
+        }
+        else if (catNumber = 2)
+        {
+            if (player->HasSpell(spellId))
+            {
+                m_creature->MonsterWhisper("You already know this spell.", player);
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            } else {
+    player->CLOSE_GOSSIP_MENU();
+    player->learnSpell(spellId, false);
+    player->ModifyMoney(-int(cost));
+            }
+        }
+    }
+} while (result->NextRow());
+} else {
+//player->ADD_GOSSIP_ITEM( 7, MAIN_MENU, GOSSIP_SENDER_MAIN, 5005);
+}
+
+ switch(uiAction)
+{
+
+case 1000: //Normal Pet
+        showNormalPet(player, m_creature, 0);
+        player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+break;
+
+case 2000: //Exotic Pet
+        showExoticPet(player, m_creature, 0);
+        player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+break;
+
+case 3000: //Pet Spells
+        showPetSpells(player, m_creature, 0);
+        player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+break;
+
+case 5005: //Back To Main Menu
+    // Main Menu
+    // Check config if "Normal Pet " is enabled or not
+    if(EnableNormalPet)
+        player->ADD_GOSSIP_ITEM( 7, "Normal Pets ->"              , GOSSIP_SENDER_MAIN, 1000);
+    // Check if player can have an exotic pet, and check config if "Exotic" is enabled or not
+    if(player->CanTameExoticPets() && EnableExoticPet)
+        player->ADD_GOSSIP_ITEM( 7, "Exotic Pets ->"              , GOSSIP_SENDER_MAIN, 2000);
+    // Now to add the spells, vendor, and stable stuffs
+    player->ADD_GOSSIP_ITEM(4, "Teach Me Pet spells ->"      , GOSSIP_SENDER_MAIN, 3000);
+    player->ADD_GOSSIP_ITEM(2, "Take me to the Stable.", GOSSIP_SENDER_MAIN, 6006);
+    player->ADD_GOSSIP_ITEM(6, "Sell me some Food for my Pet.", GOSSIP_SENDER_MAIN, 6007);
+    player->SEND_GOSSIP_MENU(MSG_TYPE, m_creature->GetGUID());
+break;
+
+case 6006:
+    player->GetSession()->SendStablePet(m_creature->GetGUID());
+    player->CLOSE_GOSSIP_MENU();
+    break;
+
+case 6007:
+    player->GetSession()->SendListInventory(m_creature->GetGUID());
+    player->CLOSE_GOSSIP_MENU();
+    break;
+
+ player->CLOSE_GOSSIP_MENU();
+ }
+
+} //end of function
+
+bool OnGossipSelect(Player* player, Creature* m_creature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    player->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(player, m_creature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_Npc_Beastmaster()
+{
+    new Npc_Beastmaster();
+}
diff --git a/src/server/scripts/Custom/enchant.cpp b/src/server/scripts/Custom/enchant.cpp
new file mode 100644
index 0000000..c6a7fdc
--- /dev/null
+++ b/src/server/scripts/Custom/enchant.cpp
@@ -0,0 +1,1621 @@
+enum Enchants
+{
+    ENCHANT_WEP_BERSERKING              = 3789,
+    ENCHANT_WEP_BLADE_WARD              = 3869,
+    ENCHANT_WEP_BLOOD_DRAINING          = 3870,
+    ENCHANT_WEP_ACCURACY                = 3788,
+    ENCHANT_WEP_AGILITY_1H              = 1103,
+    ENCHANT_WEP_SPIRIT                  = 3844,
+    ENCHANT_WEP_BATTLEMASTER            = 2675,
+    ENCHANT_WEP_BLACK_MAGIC             = 3790,
+    ENCHANT_WEP_ICEBREAKER              = 3239,
+    ENCHANT_WEP_LIFEWARD                = 3241,
+    ENCHANT_WEP_MIGHTY_SPELL_POWER      = 3834, // One-hand
+    ENCHANT_WEP_EXECUTIONER             = 3225,
+    ENCHANT_WEP_POTENCY                 = 3833,
+    ENCHANT_WEP_TITANGUARD              = 3851,
+    ENCHANT_2WEP_MASSACRE               = 3827,
+    ENCHANT_2WEP_SCOURGEBANE            = 3247,
+    ENCHANT_2WEP_GIANT_SLAYER            = 3251,
+    ENCHANT_2WEP_GREATER_SPELL_POWER    = 3854,
+    ENCHANT_2WEP_AGILITY                = 2670,
+    ENCHANT_2WEP_MONGOOSE               = 2673,
+
+    ENCHANT_SHIELD_DEFENSE              = 1952,
+    ENCHANT_SHIELD_INTELLECT            = 1128,
+    ENCHANT_SHIELD_RESILIENCE           = 3229,
+    ENCHANT_SHIELD_BLOCK                = 2655,
+    ENCHANT_SHIELD_STAMINA                = 1071,
+    ENCHANT_SHIELD_TOUGHSHIELD            = 2653,
+    ENCHANT_SHIELD_TITANIUM_PLATING     = 3849,
+
+    ENCHANT_HEAD_BLISSFUL_MENDING       = 3819,
+    ENCHANT_HEAD_BURNING_MYSTERIES      = 3820,
+    ENCHANT_HEAD_DOMINANCE              = 3796,
+    ENCHANT_HEAD_SAVAGE_GLADIATOR       = 3842,
+    ENCHANT_HEAD_STALWART_PROTECTOR     = 3818,
+    ENCHANT_HEAD_TORMENT                = 3817,
+    ENCHANT_HEAD_TRIUMPH                = 3795,
+    ENCHANT_HEAD_ECLIPSED_MOON            = 3815,
+    ENCHANT_HEAD_FLAME_SOUL                = 3816,
+    ENCHANT_HEAD_FLEEING_SHADOW            = 3814,
+    ENCHANT_HEAD_FROSTY_SOUL            = 3812,
+    ENCHANT_HEAD_TOXIC_WARDING            = 3813,
+
+    ENCHANT_SHOULDER_MASTERS_AXE        = 3835,
+    ENCHANT_SHOULDER_MASTERS_CRAG       = 3836,
+    ENCHANT_SHOULDER_MASTERS_PINNACLE   = 3837,
+    ENCHANT_SHOULDER_MASTERS_STORM      = 3838,
+    ENCHANT_SHOULDER_GREATER_AXE        = 3808,
+    ENCHANT_SHOULDER_GREATER_CRAG       = 3809,
+    ENCHANT_SHOULDER_GREATER_GLADIATOR  = 3852,
+    ENCHANT_SHOULDER_GREATER_PINNACLE   = 3811,
+    ENCHANT_SHOULDER_GREATER_STORM      = 3810,
+    ENCHANT_SHOULDER_DOMINANCE          = 3794,
+    ENCHANT_SHOULDER_TRIUMPH            = 3793,
+
+    ENCHANT_CLOAK_DARKGLOW_EMBROIDERY   = 3728,
+    ENCHANT_CLOAK_SWORDGUARD_EMBROIDERY = 3730,
+    ENCHANT_CLOAK_LIGHTWEAVE_EMBROIDERY = 3722,
+    ENCHANT_CLOAK_SPRINGY_ARACHNOWEAVE  = 3859,
+    ENCHANT_CLOAK_WISDOM                = 3296,
+    ENCHANT_CLOAK_TITANWEAVE            = 1951,
+    ENCHANT_CLOAK_SPELL_PIERCING        = 3243,
+    ENCHANT_CLOAK_SHADOW_ARMOR          = 3256,
+    ENCHANT_CLOAK_MIGHTY_ARMOR          = 3294,
+    ENCHANT_CLOAK_MAJOR_AGILITY         = 1099,
+    ENCHANT_CLOAK_GREATER_SPEED         = 3831,
+
+    ENCHANT_LEG_EARTHEN                    = 3853,
+    ENCHANT_LEG_FROSTHIDE                = 3822,
+    ENCHANT_LEG_ICESCALE                = 3823,
+    ENCHANT_LEG_BRILLIANT_SPELLTHREAD    = 3719,
+    ENCHANT_LEG_SAPPHIRE_SPELLTHREAD    = 3721,
+    ENCHANT_LEG_DRAGONSCALE                = 3331,
+    ENCHANT_LEG_WYRMSCALE                = 3332,
+
+    ENCHANT_GLOVES_GREATER_BLASTING        = 3249,
+    ENCHANT_GLOVES_ARMSMAN                = 3253,
+    ENCHANT_GLOVES_CRUSHER                = 1603,
+    ENCHANT_GLOVES_AGILITY                = 3222,
+    ENCHANT_GLOVES_PRECISION            = 3234,
+    ENCHANT_GLOVES_EXPERTISE            = 3231,
+
+    ENCHANT_BRACERS_MAJOR_STAMINA        = 3850,
+    ENCHANT_BRACERS_SUPERIOR_SP            = 2332,
+    ENCHANT_BRACERS_GREATER_ASSUALT        = 3845,
+    ENCHANT_BRACERS_MAJOR_SPIRT            = 1147,
+    ENCHANT_BRACERS_EXPERTISE            = 3231,
+    ENCHANT_BRACERS_GREATER_STATS        = 2661,
+    ENCHANT_BRACERS_INTELLECT            = 1119,
+    ENCHANT_BRACERS_FURL_ARCANE            = 3763,
+    ENCHANT_BRACERS_FURL_FIRE            = 3759,
+    ENCHANT_BRACERS_FURL_FROST            = 3760,
+    ENCHANT_BRACERS_FURL_NATURE            = 3762,
+    ENCHANT_BRACERS_FURL_SHADOW            = 3761,
+    ENCHANT_BRACERS_FURL_ATTACK            = 3756,
+    ENCHANT_BRACERS_FURL_STAMINA        = 3757,
+    ENCHANT_BRACERS_FURL_SPELLPOWER        = 3758,
+
+    ENCHANT_CHEST_POWERFUL_STATS        = 3832,
+    ENCHANT_CHEST_SUPER_HEALTH            = 3297,
+    ENCHANT_CHEST_GREATER_MAINA_REST        = 2381,
+    ENCHANT_CHEST_EXCEPTIONAL_RESIL        = 3245,
+    ENCHANT_CHEST_GREATER_DEFENSE        = 1953,
+
+    ENCHANT_BOOTS_GREATER_ASSULT        = 1597,
+    ENCHANT_BOOTS_TUSKARS_VITLIATY        = 3232,
+    ENCHANT_BOOTS_SUPERIOR_AGILITY        = 983,
+    ENCHANT_BOOTS_GREATER_SPIRIT        = 1147,
+    ENCHANT_BOOTS_GREATER_VITALITY        = 3244,
+    ENCHANT_BOOTS_ICEWALKER                = 3826,
+    ENCHANT_BOOTS_GREATER_FORTITUDE        = 1075,
+    ENCHANT_BOOTS_NITRO_BOOTS            = 3606,
+    ENCHANT_BOOTS_PYRO_ROCKET            = 3603,
+    ENCHANT_BOOTS_HYPERSPEED            = 3604,
+    ENCHANT_BOOTS_ARMOR_WEBBING            = 3860,
+
+    ENCHANT_RING_ASSULT                    = 3839,
+    ENCHANT_RING_GREATER_SP                = 3840,
+    ENCHANT_RING_STAMINA                = 3791,
+};
+
+#include "ScriptPCH.h"
+
+void Enchant(Player* player, Item* item, uint32 enchantid)
+{
+    if (!item)
+    {
+        player->GetSession()->SendNotification("You must first equip the item you are trying to enchant in order to enchant it!");
+        return;
+    }
+
+
+
+    item->ClearEnchantment(PERM_ENCHANTMENT_SLOT);
+    item->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchantid, 0, 0);
+    player->GetSession()->SendNotification("|cff800080%s |cffFF0000succesfully enchanted!", item->GetTemplate()->Name1.c_str());
+}
+
+void RemoveEnchant(Player* player, Item* item)
+{
+    if (!item)
+    {
+        player->GetSession()->SendNotification("You don't have the item equipped?");
+        return;
+    }
+
+    item->ClearEnchantment(PERM_ENCHANTMENT_SLOT);
+    player->GetSession()->SendNotification("|cff800080%s's |cffFF0000enchant has successfully been removed!", item->GetTemplate()->Name1.c_str());
+}
+
+class npc_enchantment : public CreatureScript
+{
+public:
+    npc_enchantment() : CreatureScript("npc_enchantment") { }
+
+        bool OnGossipHello(Player* player, Creature* creature)
+        {
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Weapon-]", GOSSIP_SENDER_MAIN, 1);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Off-Hand Weapon-]", GOSSIP_SENDER_MAIN, 13);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant 2H Weapon-]", GOSSIP_SENDER_MAIN, 2);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Shield-]", GOSSIP_SENDER_MAIN, 3);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Head-]", GOSSIP_SENDER_MAIN, 4);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Shoulders-]", GOSSIP_SENDER_MAIN, 5);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Cloak-]", GOSSIP_SENDER_MAIN, 6);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Chest-]", GOSSIP_SENDER_MAIN, 7);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Bracers-]", GOSSIP_SENDER_MAIN, 8);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Gloves-]", GOSSIP_SENDER_MAIN, 9);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Legs-]", GOSSIP_SENDER_MAIN, 10);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Feet-]", GOSSIP_SENDER_MAIN, 11);
+
+            if (player->HasSkill(SKILL_ENCHANTING) && player->GetSkillValue(SKILL_ENCHANTING) == 450)
+            {
+                player->ADD_GOSSIP_ITEM(1, "[-Enchant Rings-]", GOSSIP_SENDER_MAIN, 12);
+            }
+            player->ADD_GOSSIP_ITEM(1, "[-I wish to remove my enchant-]", GOSSIP_SENDER_MAIN, 14);
+
+            player->PlayerTalkClass->SendGossipMenu(100001, creature->GetGUID());
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action)
+        {
+            player->PlayerTalkClass->ClearMenus();
+            Item * item;
+
+            switch (action)
+            {
+
+                case 1: // Enchant Weapon
+                    if (player->HasSkill(SKILL_ENCHANTING) && player->GetSkillValue(SKILL_ENCHANTING) == 450)
+                    {
+                        player->ADD_GOSSIP_ITEM(1, "Blade Ward", GOSSIP_SENDER_MAIN, 102);
+                        player->ADD_GOSSIP_ITEM(1, "Blood Draining", GOSSIP_SENDER_MAIN, 103);
+                    }
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Agility", GOSSIP_SENDER_MAIN, 100);
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Spirit", GOSSIP_SENDER_MAIN, 101);
+                    player->ADD_GOSSIP_ITEM(1, "Berserking", GOSSIP_SENDER_MAIN, 104);
+                    player->ADD_GOSSIP_ITEM(1, "Accuracy", GOSSIP_SENDER_MAIN, 105);
+                    player->ADD_GOSSIP_ITEM(1, "Black Magic", GOSSIP_SENDER_MAIN, 106);
+                    player->ADD_GOSSIP_ITEM(1, "Battlemaster", GOSSIP_SENDER_MAIN, 107);
+                    player->ADD_GOSSIP_ITEM(1, "Icebreaker", GOSSIP_SENDER_MAIN, 108);
+                    player->ADD_GOSSIP_ITEM(1, "Lifeward", GOSSIP_SENDER_MAIN, 109);
+                    player->ADD_GOSSIP_ITEM(1, "Titanguard", GOSSIP_SENDER_MAIN, 110);
+                    player->ADD_GOSSIP_ITEM(1, "Superior Potency", GOSSIP_SENDER_MAIN, 111);
+                    player->ADD_GOSSIP_ITEM(1, "Mighty Spellpower", GOSSIP_SENDER_MAIN, 112);
+                    player->ADD_GOSSIP_ITEM(1, "Mongoose", GOSSIP_SENDER_MAIN, 113);
+                    player->ADD_GOSSIP_ITEM(1, "Executioner", GOSSIP_SENDER_MAIN, 114);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100002, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 2: // Enchant 2H Weapon
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendNotification("You must equip a Two-Handed weapon first.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "Berserking", GOSSIP_SENDER_MAIN, 104);
+                            player->ADD_GOSSIP_ITEM(1, "Greater Spellpower", GOSSIP_SENDER_MAIN, 115);
+                            player->ADD_GOSSIP_ITEM(1, "Major Agility", GOSSIP_SENDER_MAIN, 116);
+                            player->ADD_GOSSIP_ITEM(1, "Massacre", GOSSIP_SENDER_MAIN, 117);
+                            player->ADD_GOSSIP_ITEM(1, "Mongoose", GOSSIP_SENDER_MAIN, 113);
+                            player->ADD_GOSSIP_ITEM(1, "Executioner", GOSSIP_SENDER_MAIN, 114);
+                            player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                            player->PlayerTalkClass->SendGossipMenu(100003, creature->GetGUID());
+                            return true;
+                        }
+                        else
+                        {
+                            player->GetSession()->SendNotification("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 3: // Enchant Shield
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendNotification("You must equip a shield first.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "Defense", GOSSIP_SENDER_MAIN, 118);
+                            player->ADD_GOSSIP_ITEM(1, "Greater Intellect", GOSSIP_SENDER_MAIN, 119);
+                            player->ADD_GOSSIP_ITEM(1, "Resilience", GOSSIP_SENDER_MAIN, 120);
+                            player->ADD_GOSSIP_ITEM(1, "Titanium Plating", GOSSIP_SENDER_MAIN, 121);
+                            player->ADD_GOSSIP_ITEM(1, "Major Stamina", GOSSIP_SENDER_MAIN, 122);
+                            player->ADD_GOSSIP_ITEM(1, "Tough Shield", GOSSIP_SENDER_MAIN, 123);
+                            player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                            player->PlayerTalkClass->SendGossipMenu(100004, creature->GetGUID());
+                            return true;
+                        }
+                        else
+                        {
+                            player->GetSession()->SendNotification("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 4: // Enchant Head
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Blissful Mending", GOSSIP_SENDER_MAIN, 124);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Burning Mysteries", GOSSIP_SENDER_MAIN, 125);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Dominance", GOSSIP_SENDER_MAIN, 126);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of The Savage Gladiator", GOSSIP_SENDER_MAIN, 127);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of The Stalwart Protector", GOSSIP_SENDER_MAIN, 128);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Torment", GOSSIP_SENDER_MAIN, 129);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Triumph", GOSSIP_SENDER_MAIN, 130);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Eclipsed Moon", GOSSIP_SENDER_MAIN, 131);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of the Flame's Soul", GOSSIP_SENDER_MAIN, 132);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of the Fleeing Shadow", GOSSIP_SENDER_MAIN, 133);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of the Frosty Soul", GOSSIP_SENDER_MAIN, 134);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Toxic Warding", GOSSIP_SENDER_MAIN, 135);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100005, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 5: // Enchant Shoulders
+                    if (player->HasSkill(SKILL_INSCRIPTION) && player->GetSkillValue(SKILL_INSCRIPTION) == 450)
+                    {
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Axe", GOSSIP_SENDER_MAIN, 136);
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Crag", GOSSIP_SENDER_MAIN, 137);
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Pinnacle", GOSSIP_SENDER_MAIN, 138);
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Storm", GOSSIP_SENDER_MAIN, 139);
+                    }
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Axe", GOSSIP_SENDER_MAIN, 140);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Crag", GOSSIP_SENDER_MAIN, 141);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Pinnacle", GOSSIP_SENDER_MAIN, 142);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Gladiator", GOSSIP_SENDER_MAIN, 143);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Storm", GOSSIP_SENDER_MAIN, 144);
+                    player->ADD_GOSSIP_ITEM(1, "Inscription of Dominance", GOSSIP_SENDER_MAIN, 145);
+                    player->ADD_GOSSIP_ITEM(1, "Inscription of Triumph", GOSSIP_SENDER_MAIN, 146);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100006, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 6: // Enchant Cloak
+                    player->ADD_GOSSIP_ITEM(1, "Springy Arachnoweave", GOSSIP_SENDER_MAIN, 147);
+                    player->ADD_GOSSIP_ITEM(1, "Shadow Armor", GOSSIP_SENDER_MAIN, 148);
+                    player->ADD_GOSSIP_ITEM(1, "Darkglow Embroidery", GOSSIP_SENDER_MAIN, 149);
+                    player->ADD_GOSSIP_ITEM(1, "Lightweave Embroidery", GOSSIP_SENDER_MAIN, 150);
+                    player->ADD_GOSSIP_ITEM(1, "Swordguard Embroidery", GOSSIP_SENDER_MAIN, 151);
+                    player->ADD_GOSSIP_ITEM(1, "Wisdom", GOSSIP_SENDER_MAIN, 152);
+                    player->ADD_GOSSIP_ITEM(1, "Titanweave", GOSSIP_SENDER_MAIN, 153);
+                    player->ADD_GOSSIP_ITEM(1, "Spell Piercing", GOSSIP_SENDER_MAIN, 154);
+                    player->ADD_GOSSIP_ITEM(1, "Mighty Armor", GOSSIP_SENDER_MAIN, 155);
+                    player->ADD_GOSSIP_ITEM(1, "Major Agility", GOSSIP_SENDER_MAIN, 156);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Speed", GOSSIP_SENDER_MAIN, 157);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100007, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 7: //Enchant chest
+                    player->ADD_GOSSIP_ITEM(1, "Powerful Stats", GOSSIP_SENDER_MAIN, 158);
+                    player->ADD_GOSSIP_ITEM(1, "Super Health", GOSSIP_SENDER_MAIN, 159);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Mana Restoration", GOSSIP_SENDER_MAIN, 160);
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Resilience", GOSSIP_SENDER_MAIN, 161);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Defense", GOSSIP_SENDER_MAIN, 162);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100008, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 8: //Enchant Bracers
+                    player->ADD_GOSSIP_ITEM(1, "Major Stamina", GOSSIP_SENDER_MAIN, 163);
+                    player->ADD_GOSSIP_ITEM(1, "Superior Spell Power", GOSSIP_SENDER_MAIN, 164);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Assult", GOSSIP_SENDER_MAIN, 165);
+                    player->ADD_GOSSIP_ITEM(1, "Major Spirit", GOSSIP_SENDER_MAIN, 166);
+                    player->ADD_GOSSIP_ITEM(1, "Expertise", GOSSIP_SENDER_MAIN, 167);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Stats", GOSSIP_SENDER_MAIN, 168);
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Intellect", GOSSIP_SENDER_MAIN, 169);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Arcane Resist", GOSSIP_SENDER_MAIN, 170);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Fire Resist", GOSSIP_SENDER_MAIN, 171);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Frost Resist", GOSSIP_SENDER_MAIN, 172);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Nature Resist", GOSSIP_SENDER_MAIN, 173);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Shadow Resist", GOSSIP_SENDER_MAIN, 174);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Attack power", GOSSIP_SENDER_MAIN, 175);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Stamina", GOSSIP_SENDER_MAIN, 176);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Spellpower", GOSSIP_SENDER_MAIN, 177);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100009, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 9: //Enchant Gloves
+                    player->ADD_GOSSIP_ITEM(1, "Greater Blasting", GOSSIP_SENDER_MAIN, 178);
+                    player->ADD_GOSSIP_ITEM(1, "Armsman", GOSSIP_SENDER_MAIN, 179);
+                    player->ADD_GOSSIP_ITEM(1, "Crusher", GOSSIP_SENDER_MAIN, 180);
+                    player->ADD_GOSSIP_ITEM(1, "Agility", GOSSIP_SENDER_MAIN, 181);
+                    player->ADD_GOSSIP_ITEM(1, "Precision", GOSSIP_SENDER_MAIN, 182);
+                    player->ADD_GOSSIP_ITEM(1, "Expertise", GOSSIP_SENDER_MAIN, 183);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100010, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 10: //Enchant legs
+                    player->ADD_GOSSIP_ITEM(1, "Earthen Leg Armor", GOSSIP_SENDER_MAIN, 184);
+                    player->ADD_GOSSIP_ITEM(1, "Frosthide Leg Armor", GOSSIP_SENDER_MAIN, 185);
+                    player->ADD_GOSSIP_ITEM(1, "Icescale Leg Armor", GOSSIP_SENDER_MAIN, 186);
+                    player->ADD_GOSSIP_ITEM(1, "Brilliant Spellthread", GOSSIP_SENDER_MAIN, 187);
+                    player->ADD_GOSSIP_ITEM(1, "Sapphire Spellthread", GOSSIP_SENDER_MAIN, 188);
+                    player->ADD_GOSSIP_ITEM(1, "Dragonscale Leg Armor", GOSSIP_SENDER_MAIN, 189);
+                    player->ADD_GOSSIP_ITEM(1, "Wyrmscale Leg Armor", GOSSIP_SENDER_MAIN, 190);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100011, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 11: //Enchant feet
+                    player->ADD_GOSSIP_ITEM(1, "Greater Assult", GOSSIP_SENDER_MAIN, 191);
+                    player->ADD_GOSSIP_ITEM(1, "Tuskars Vitliaty", GOSSIP_SENDER_MAIN, 192);
+                    player->ADD_GOSSIP_ITEM(1, "Superior Agility", GOSSIP_SENDER_MAIN, 193);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Spirit", GOSSIP_SENDER_MAIN, 194);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Vitality", GOSSIP_SENDER_MAIN, 195);
+                    player->ADD_GOSSIP_ITEM(1, "Icewalker", GOSSIP_SENDER_MAIN, 196);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Fortitude", GOSSIP_SENDER_MAIN, 197);
+                    player->ADD_GOSSIP_ITEM(1, "Nitro Boots", GOSSIP_SENDER_MAIN, 198);
+                    player->ADD_GOSSIP_ITEM(1, "Hand-Mounted Pyro Rocket", GOSSIP_SENDER_MAIN, 199);
+                    player->ADD_GOSSIP_ITEM(1, "Hyperspeed Accedlerators", GOSSIP_SENDER_MAIN, 200);
+                    player->ADD_GOSSIP_ITEM(1, "Reticulated Armor Webbing", GOSSIP_SENDER_MAIN, 201);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100012, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 12: //Enchant rings
+                    player->ADD_GOSSIP_ITEM(1, "Assult", GOSSIP_SENDER_MAIN, 202);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Spell Power", GOSSIP_SENDER_MAIN, 203);
+                    player->ADD_GOSSIP_ITEM(1, "Stamina", GOSSIP_SENDER_MAIN, 204);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100013, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 13: //Enchant Off-Hand weapons
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendNotification("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "Blade Ward", GOSSIP_SENDER_MAIN, 205);
+                            player->ADD_GOSSIP_ITEM(1, "Blood Draining", GOSSIP_SENDER_MAIN, 219);
+                            player->ADD_GOSSIP_ITEM(1, "Exceptional Agility", GOSSIP_SENDER_MAIN, 206);
+                            player->ADD_GOSSIP_ITEM(1, "Exceptional Spirit", GOSSIP_SENDER_MAIN, 207);
+                            player->ADD_GOSSIP_ITEM(1, "Berserking", GOSSIP_SENDER_MAIN, 208);
+                            player->ADD_GOSSIP_ITEM(1, "Accuracy", GOSSIP_SENDER_MAIN, 209);
+                            player->ADD_GOSSIP_ITEM(1, "Black Magic", GOSSIP_SENDER_MAIN, 210);
+                            player->ADD_GOSSIP_ITEM(1, "Battlemaster", GOSSIP_SENDER_MAIN, 211);
+                            player->ADD_GOSSIP_ITEM(1, "Icebreaker", GOSSIP_SENDER_MAIN, 212);
+                            player->ADD_GOSSIP_ITEM(1, "Lifeward", GOSSIP_SENDER_MAIN, 213);
+                            player->ADD_GOSSIP_ITEM(1, "Titanguard", GOSSIP_SENDER_MAIN, 214);
+                            player->ADD_GOSSIP_ITEM(1, "Superior Potency", GOSSIP_SENDER_MAIN, 215);
+                            player->ADD_GOSSIP_ITEM(1, "Mighty Spellpower", GOSSIP_SENDER_MAIN, 216);
+                            player->ADD_GOSSIP_ITEM(1, "Mongoose", GOSSIP_SENDER_MAIN, 217);
+                            player->ADD_GOSSIP_ITEM(1, "Executioner", GOSSIP_SENDER_MAIN, 218);
+                            player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                            player->PlayerTalkClass->SendGossipMenu(100002, creature->GetGUID());
+                            return true;
+                        }
+                        else
+                        {
+                            player->GetSession()->SendNotification("Your Off-Hand is not a weapon.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 14: //Remove enchant menu
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Main-hand", GOSSIP_SENDER_MAIN, 400);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Off-hand", GOSSIP_SENDER_MAIN, 401);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Head", GOSSIP_SENDER_MAIN, 402);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Shoulders", GOSSIP_SENDER_MAIN, 403);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Cloak", GOSSIP_SENDER_MAIN, 404);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Chest", GOSSIP_SENDER_MAIN, 405);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Bracers", GOSSIP_SENDER_MAIN, 406);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Gloves", GOSSIP_SENDER_MAIN, 407);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Legs", GOSSIP_SENDER_MAIN, 408);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Feet", GOSSIP_SENDER_MAIN, 409);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Rings", GOSSIP_SENDER_MAIN, 409);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100014, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 100:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_AGILITY_1H);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 101:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_SPIRIT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 102:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BLADE_WARD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 103:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BLOOD_DRAINING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 104:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BERSERKING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 105:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_ACCURACY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 106:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BLACK_MAGIC);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 107:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BATTLEMASTER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 108:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_ICEBREAKER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 109:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_LIFEWARD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 110:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_TITANGUARD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 111:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_POTENCY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 112:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_MIGHTY_SPELL_POWER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 113:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_MONGOOSE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 114:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_EXECUTIONER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 115:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a 2H weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_GREATER_SPELL_POWER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 116:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a 2H weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_AGILITY);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 117:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a 2H weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_MASSACRE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 118:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_DEFENSE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 119:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_INTELLECT);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 120:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_RESILIENCE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 121:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_TITANIUM_PLATING);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 122:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_STAMINA);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 123:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_TOUGHSHIELD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 124:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_BLISSFUL_MENDING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 125:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_BURNING_MYSTERIES);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 126:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_DOMINANCE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 127:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_SAVAGE_GLADIATOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 128:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_STALWART_PROTECTOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 129:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_TORMENT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 130:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_TRIUMPH);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 131:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_ECLIPSED_MOON);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 132:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_FLAME_SOUL);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 133:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_FLEEING_SHADOW);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 134:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_FROSTY_SOUL);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 135:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_TOXIC_WARDING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 136:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_AXE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 137:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_CRAG);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 138:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_PINNACLE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 139:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_STORM);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 140:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_AXE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 141:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_CRAG);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 142:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_GLADIATOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 143:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_PINNACLE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 144:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_STORM);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 145:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_DOMINANCE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 146:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_TRIUMPH);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 147:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SPRINGY_ARACHNOWEAVE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 148:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SHADOW_ARMOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 149:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_DARKGLOW_EMBROIDERY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 150:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_LIGHTWEAVE_EMBROIDERY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 151:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SWORDGUARD_EMBROIDERY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 152:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_WISDOM);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 153:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_TITANWEAVE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 154:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SPELL_PIERCING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 155:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_MIGHTY_ARMOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 156:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_MAJOR_AGILITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 157:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_GREATER_SPEED);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 158:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_POWERFUL_STATS);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 159:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_SUPER_HEALTH);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 160:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_GREATER_MAINA_REST);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 161:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_EXCEPTIONAL_RESIL);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 162:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_GREATER_DEFENSE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 163:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_MAJOR_STAMINA);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 164:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_SUPERIOR_SP);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 165:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_GREATER_ASSUALT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 166:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_MAJOR_SPIRT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 167:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_EXPERTISE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 168:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_GREATER_STATS);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 169:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_INTELLECT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 170:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_ARCANE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 171:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_FIRE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 172:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_FROST);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 173:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_NATURE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 174:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_SHADOW);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 175:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_ATTACK);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 176:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_STAMINA);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 177:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_SPELLPOWER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 178:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_GREATER_BLASTING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 179:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_ARMSMAN);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 180:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_CRUSHER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 181:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_AGILITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 182:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_PRECISION);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 183:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_EXPERTISE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 184:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_EARTHEN);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 185:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_FROSTHIDE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 186:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_ICESCALE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 187:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_BRILLIANT_SPELLTHREAD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 188:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_SAPPHIRE_SPELLTHREAD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 189:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_DRAGONSCALE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 190:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_WYRMSCALE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 191:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_ASSULT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 192:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_TUSKARS_VITLIATY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 193:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_SUPERIOR_AGILITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 194:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_SPIRIT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 195:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_VITALITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 196:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_ICEWALKER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 197:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_FORTITUDE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 198:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_NITRO_BOOTS);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 199:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_PYRO_ROCKET);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 200:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_HYPERSPEED);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 201:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_ARMOR_WEBBING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 202:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1), ENCHANT_RING_ASSULT);
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2), ENCHANT_RING_ASSULT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 203:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1), ENCHANT_RING_GREATER_SP);
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2), ENCHANT_RING_GREATER_SP);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 204:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1), ENCHANT_RING_STAMINA);
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2), ENCHANT_RING_STAMINA);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 205:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BLADE_WARD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 206:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_AGILITY_1H);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 207:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_SPIRIT);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 208:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BERSERKING);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 209:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_ACCURACY);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 210:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BLACK_MAGIC);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 211:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BATTLEMASTER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 212:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_ICEBREAKER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 213:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_LIFEWARD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 214:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_TITANGUARD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 215:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_POTENCY);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 216:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_MIGHTY_SPELL_POWER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 217:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_2WEP_MONGOOSE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 218:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_EXECUTIONER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 219:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BLOOD_DRAINING);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 300: //<-Back menu
+                    {
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Weapon-]", GOSSIP_SENDER_MAIN, 1);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Off-Hand Weapon-]", GOSSIP_SENDER_MAIN, 13);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant 2H Weapon-]", GOSSIP_SENDER_MAIN, 2);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Shield-]", GOSSIP_SENDER_MAIN, 3);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Head-]", GOSSIP_SENDER_MAIN, 4);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Shoulders-]", GOSSIP_SENDER_MAIN, 5);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Cloak-]", GOSSIP_SENDER_MAIN, 6);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Chest-]", GOSSIP_SENDER_MAIN, 7);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Bracers-]", GOSSIP_SENDER_MAIN, 8);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Gloves-]", GOSSIP_SENDER_MAIN, 9);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Legs-]", GOSSIP_SENDER_MAIN, 10);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Feet-]", GOSSIP_SENDER_MAIN, 11);
+
+                        if (player->HasSkill(SKILL_ENCHANTING) && player->GetSkillValue(SKILL_ENCHANTING) == 450)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "[-Enchant Rings-]", GOSSIP_SENDER_MAIN, 12);
+                        }
+                        player->ADD_GOSSIP_ITEM(1, "[-I wish to remove my enchant-]", GOSSIP_SENDER_MAIN, 14);
+
+                        player->PlayerTalkClass->SendGossipMenu(100001, creature->GetGUID());
+                        return true;
+                    }
+                        break;
+
+                case 400: //Remove enchant for mainhand
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 401: //Remove enchant for offhand
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 402: //Remove enchant for head
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 403: //Remove enchant for shoulders
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 404: //remove enchant for cloak
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 405: //remove enchant for chest
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 406: //remove enchant for bracers
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 407: //remove enchant for gloves
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 408: //remove enchant for legs
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 409: //remove enchant for feet
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 410:
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1));
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                }
+            return true;
+        }
+    };
+
+
+void AddSC_npc_enchantment()
+{
+  new npc_enchantment();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/guildmaster.cpp b/src/server/scripts/Custom/guildmaster.cpp
new file mode 100644
index 0000000..4a8b012
--- /dev/null
+++ b/src/server/scripts/Custom/guildmaster.cpp
@@ -0,0 +1,313 @@
+#include "ScriptPCH.h"
+#include "Config.h"
+
+//extern DatabaseMysql SD2Database;
+
+//extern WorldDatabaseWorkerPool WorldDatabase;
+
+#define MSG_GOSSIP_TELE          "Teleport to GuildHouse"
+#define MSG_GOSSIP_BUY           "Buy GuildHouse"
+#define MSG_GOSSIP_SELL          "Sell GuildHouse"
+#define MSG_GOSSIP_NEXTPAGE      "Next -->"
+#define MSG_INCOMBAT             "You are in combat and cannot be teleported to your GuildHouse."
+#define MSG_NOGUILDHOUSE         "Your guild currently does not own a GuildHouse."
+#define MSG_NOFREEGH             "Unfortunately, all GuildHouses are in use."
+#define MSG_ALREADYHAVEGH        "Sorry, but you already own a GuildHouse (%s)."
+#define MSG_NOTENOUGHMONEY       "You do not have the %u gold required to purchase a GuildHouse."
+#define MSG_GHOCCUPIED           "This GuildHouse is unavailable for purchase as it is currently in use."
+#define MSG_CONGRATULATIONS      "Congratulations! You have successfully purchased a GuildHouse."
+#define MSG_SOLD                 "You have sold your GuildHouse and have received %u gold."
+#define MSG_NOTINGUILD           "You need to be in a guild before you can use a GuildHouse."
+#define MSG_SELL_CONFIRM         "Are you sure you want to sell your guildhouse for half the buy price?"
+
+#define OFFSET_GH_ID_TO_ACTION 1500
+#define OFFSET_SHOWBUY_FROM 10000
+
+#define ACTION_TELE 1001
+#define ACTION_SHOW_BUYLIST 1002 //deprecated. Use (OFFSET_SHOWBUY_FROM + 0) instead
+#define ACTION_SELL_GUILDHOUSE 1003
+
+#define ICON_GOSSIP_BALOON 0
+#define ICON_GOSSIP_WING 2
+#define ICON_GOSSIP_BOOK 3
+#define ICON_GOSSIP_WHEEL1 4
+#define ICON_GOSSIP_WHEEL2 5
+#define ICON_GOSSIP_GOLD 6
+#define ICON_GOSSIP_BALOONDOTS 7
+#define ICON_GOSSIP_TABARD 8
+#define ICON_GOSSIP_XSWORDS 9
+
+#define COST_GH_BUY 10000000 //1000 g.
+#define COST_GH_SELL 5000000 //500 g.
+
+#define GOSSIP_COUNT_MAX 10
+
+class guildmaster : public CreatureScript
+{
+ public:
+ guildmaster() : CreatureScript("guildmaster") { }
+
+bool isPlayerGuildLeader(Player *player)
+{
+ return (player->GetRank() == 0) && (player->GetGuildId() != 0);
+}
+
+bool getGuildHouseCoords(uint32 guildId, float &x, float &y, float &z, uint32 &map)
+{
+ if (guildId == 0)
+ {
+ //if player has no guild
+ return false;
+ }
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `x`, `y`, `z`, `map` FROM `guildhouses` WHERE `guildId` = %u", guildId);
+ if (result)
+ {
+ Field *fields = result->Fetch();
+ x = fields[0].GetFloat();
+ y = fields[1].GetFloat();
+ z = fields[2].GetFloat();
+ map = fields[3].GetUInt32();
+ return true;
+ }
+
+ return false;
+}
+
+void teleportPlayerToGuildHouse(Player *player, Creature *_creature)
+{
+ if (player->GetGuildId() == 0)
+ {
+ //if player has no guild
+ _creature->MonsterWhisper(MSG_NOTINGUILD, player);
+ return;
+ }
+
+ if (!player->getAttackers().empty())
+ {
+ //if player in combat
+ _creature->MonsterSay(MSG_INCOMBAT, LANG_UNIVERSAL, player);
+ return;
+ }
+
+ float x, y, z;
+ uint32 map;
+
+ if (getGuildHouseCoords(player->GetGuildId(), x, y, z, map))
+ {
+ //teleport player to the specified location
+ player->TeleportTo(map, x, y, z, 0.0f);
+ }
+ else
+ _creature->MonsterWhisper(MSG_NOGUILDHOUSE, player);
+}
+
+bool showBuyList(Player *player, Creature *_creature, uint32 showFromId = 0)
+{
+ //show not occupied guildhouses
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `id`, `comment` FROM `guildhouses` WHERE `guildId` = 0 AND `id` > %u ORDER BY `id` ASC LIMIT %u",
+ showFromId, GOSSIP_COUNT_MAX);
+
+ if (result)
+ {
+ uint32 guildhouseId = 0;
+ std::string comment = "";
+ do
+ {
+ Field *fields = result->Fetch();
+ guildhouseId = fields[0].GetInt32();
+ comment = fields[1].GetString();
+
+ //send comment as a gossip item
+ //transmit guildhouseId in Action variable
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_TABARD, comment, GOSSIP_SENDER_MAIN,
+ guildhouseId + OFFSET_GH_ID_TO_ACTION);
+ }
+ while (result->NextRow());
+
+ if (result->GetRowCount() == GOSSIP_COUNT_MAX)
+ {
+ //assume that we have additional page
+ //add link to next GOSSIP_COUNT_MAX items
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOONDOTS, MSG_GOSSIP_NEXTPAGE, GOSSIP_SENDER_MAIN,
+ guildhouseId + OFFSET_SHOWBUY_FROM);
+ }
+
+ player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+
+ return true;
+ }
+ else if (!result)
+ {
+ //all guildhouses are occupied
+ _creature->MonsterWhisper(MSG_NOFREEGH, player);
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+ //this condition occurs when COUNT(guildhouses) % GOSSIP_COUNT_MAX == 0
+ //just show GHs from beginning
+ showBuyList(player, _creature, 0);
+ }
+
+ return false;
+}
+
+bool isPlayerHasGuildhouse(Player *player, Creature *_creature, bool whisper = false)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `comment` FROM `guildhouses` WHERE `guildId` = %u",
+ player->GetGuildId());
+
+ if (result)
+ {
+ if (whisper)
+ {
+ //whisper to player "already have etc..."
+ Field *fields = result->Fetch();
+ char msg[100];
+ sprintf(msg, MSG_ALREADYHAVEGH, fields[0].GetCString());
+ _creature->MonsterWhisper(msg, player);
+ }
+
+ return true;
+ }
+
+ return false;
+}
+
+void buyGuildhouse(Player *player, Creature *_creature, uint32 guildhouseId)
+{
+
+ bool token = sConfigMgr->GetBoolDefault("GuildHouse.TokenOrGold", false);
+ int cost = sConfigMgr->GetBoolDefault("GuildHouse.Cost", false);
+
+ if (player->GetMoney() < COST_GH_BUY)
+ {
+ //show how much money player need to buy GH (in gold)
+ char msg[100];
+ sprintf(msg, MSG_NOTENOUGHMONEY, COST_GH_BUY - sConfigMgr->GetBoolDefault("GuildHouse.Cost", false));
+ _creature->MonsterWhisper(msg, player);
+ return;
+ }
+
+ if (isPlayerHasGuildhouse(player, _creature, true))
+ {
+ //player already have GH
+ return;
+ }
+
+ QueryResult result;
+
+ //check if somebody already occupied this GH
+ result = WorldDatabase.PQuery("SELECT `id` FROM `guildhouses` WHERE `id` = %u AND `guildId` <> 0", guildhouseId);
+
+ if (result)
+ {
+ _creature->MonsterWhisper(MSG_GHOCCUPIED, player);
+ return;
+ }
+
+ //update DB
+ result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = %u WHERE `id` = %u",
+ player->GetGuildId(), guildhouseId);
+
+
+ player->ModifyMoney(-sConfigMgr->GetIntDefault("GuildHouse.BuyCost", false) * 10000);
+
+ //player->DestroyItemCount(token, cost, true);
+ _creature->MonsterSay(MSG_CONGRATULATIONS, LANG_UNIVERSAL, player);
+
+}
+
+void sellGuildhouse(Player *player, Creature *_creature)
+{
+ if (isPlayerHasGuildhouse(player, _creature))
+ {
+ QueryResult result;
+ result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = 0 WHERE `guildId` = %u",
+ player->GetGuildId());
+
+ player->ModifyMoney(sConfigMgr->GetIntDefault("GuildHouse.SellCost", false) * 10000);
+
+ //display message e.g. "here your money etc."
+ char msg[100];
+ sprintf(msg, MSG_SOLD, sConfigMgr->GetIntDefault("GuildHouse.SellCost", false));
+ _creature->MonsterWhisper(msg, player);
+ }
+}
+
+ bool OnGossipSelect(Player *player, Creature *_creature, uint32 sender, uint32 action)
+ {
+ player->PlayerTalkClass->ClearMenus();
+ if (sender != GOSSIP_SENDER_MAIN)
+ return false;
+
+ switch (action)
+ {
+ case ACTION_TELE:
+ //teleport player to GH
+ player->CLOSE_GOSSIP_MENU();
+ teleportPlayerToGuildHouse(player, _creature);
+ break;
+ case ACTION_SHOW_BUYLIST:
+ //show list of GHs which currently not occupied
+ showBuyList(player, _creature);
+ break;
+ case ACTION_SELL_GUILDHOUSE:
+  sellGuildhouse(player, _creature);
+  player->CLOSE_GOSSIP_MENU();
+ break;
+ default:
+ if (action > OFFSET_SHOWBUY_FROM)
+ {
+ showBuyList(player, _creature, action - OFFSET_SHOWBUY_FROM);
+ }
+ else if (action > OFFSET_GH_ID_TO_ACTION)
+ {
+ //player clicked on buy list
+ player->CLOSE_GOSSIP_MENU();
+
+ //get guildhouseId from action
+ //guildhouseId = action - OFFSET_GH_ID_TO_ACTION
+ buyGuildhouse(player, _creature, action - OFFSET_GH_ID_TO_ACTION);
+ }
+ break;
+ }
+
+ return true;
+ }
+
+
+ bool OnGossipHello(Player *player, Creature *_creature)
+ {
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOON, MSG_GOSSIP_TELE, GOSSIP_SENDER_MAIN, ACTION_TELE);
+
+ if (isPlayerGuildLeader(player))
+ {
+ if (isPlayerHasGuildhouse(player, _creature))
+ {
+ //and additional for guildhouse owner (Removed :
+ player->ADD_GOSSIP_ITEM_EXTENDED(ICON_GOSSIP_GOLD, MSG_GOSSIP_SELL, GOSSIP_SENDER_MAIN, ACTION_SELL_GUILDHOUSE, MSG_SELL_CONFIRM, 0, false);
+
+ }
+ else
+ {
+ //show additional menu for guild leader
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_GOLD, MSG_GOSSIP_BUY, GOSSIP_SENDER_MAIN, ACTION_SHOW_BUYLIST);
+ }
+ }
+
+ player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+ return true;
+ }
+
+
+};
+void AddSC_guildmaster()
+{
+ new guildmaster();
+}
diff --git a/src/server/scripts/Custom/killstreak.cpp b/src/server/scripts/Custom/killstreak.cpp
new file mode 100644
index 0000000..b0cad26
--- /dev/null
+++ b/src/server/scripts/Custom/killstreak.cpp
@@ -0,0 +1,63 @@
+/*
+Originally by Kjanko
+Edited by Tommy
+Edited by Rochet2 ~ Made dynamic
+Last Edit By Estorn
+Change : Fix For Last Rev
+*/
+
+#include "ScriptPCH.h"
+
+class System_OnKill : public PlayerScript
+{
+public:
+    System_OnKill() : PlayerScript("System_OnKill") {}
+
+    void OnPVPKill(Player * Killer, Player * Victim)
+    {
+        uint32 KillerGUID = Killer->GetGUIDLow();
+        uint32 VictimGUID = Victim->GetGUIDLow();
+
+        struct KillStreak_Info
+        {
+            uint32 killstreak;
+            uint32 lastkill;
+        };
+
+        static std::map<uint32, KillStreak_Info> KillStreakData;
+
+        if (KillerGUID == VictimGUID || KillStreakData[KillerGUID].lastkill == VictimGUID)
+            return;
+
+        if (KillStreakData[VictimGUID].killstreak >= 3)
+        {
+            std::ostringstream ss;
+            ss << "|cFF81CF42" << Killer->GetName() << "|r Server Killer Has Ended |cFFFFFFFF" << Victim->GetName() << " !!!! ";
+            sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+        }
+
+        ++KillStreakData[KillerGUID].killstreak;
+        KillStreakData[KillerGUID].lastkill = VictimGUID;
+        KillStreakData[VictimGUID].killstreak = 0;
+        KillStreakData[VictimGUID].lastkill = 0;
+
+        if (KillStreakData[KillerGUID].killstreak % 10 == 0) // send killstreak message every 10 kills
+        {
+            std::ostringstream ss;
+            ss << "|cFF81CF42" << Killer->GetName() << "|r Server Killer Has A KillStreak Of |cFF42A0CF" << KillStreakData[KillerGUID].killstreak << "|r!!!!!";
+            sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+        }
+        else if (KillStreakData[KillerGUID].killstreak == 3)
+        {
+            std::ostringstream ss;
+            ss << "|cFF81CF42" << Killer->GetName() << "|r Server Killer Is On A KillingSpree!!!!!!";
+            sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+        }
+
+    }
+};
+
+void AddSC_PvP_System()
+{
+    new System_OnKill;
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/levelnpc.cpp b/src/server/scripts/Custom/levelnpc.cpp
new file mode 100644
index 0000000..20b4331
--- /dev/null
+++ b/src/server/scripts/Custom/levelnpc.cpp
@@ -0,0 +1,192 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Created by LordPsyan for Flaminglegion.net
+ *
+ */
+
+#include "ScriptPCH.h"
+#include "Config.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define SPELL_RESURRECTION_SICKNESS_15007  15007
+
+class levelnpc : public CreatureScript
+{
+public:
+    levelnpc() : CreatureScript("levelnpc") {}
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if(sConfigMgr->GetBoolDefault("LevelNPC.OnlyGMs", false)) // If LevelNPC.OnlyGMs is enabled in trinitycore.conf
+        if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            pCreature->MonsterWhisper("Sorry, I can only add levels to Platinum Members.", pPlayer);
+            return true;
+        }
+
+    bool EnableLevel80 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel80", true);
+    bool EnableLevel100 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel100", true);
+    bool EnableLevel150 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel150", true);
+    bool EnableLevel200 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel200", true);
+    bool EnableLevel255 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel255", true);
+    if (pPlayer->GetTeam() == ALLIANCE)
+    {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+    }
+    else
+    {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+    }
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+
+return true;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->IsInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+    bool EnableLevel80 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel80", true);
+    bool EnableLevel100 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel100", true);
+    bool EnableLevel150 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel150", true);
+    bool EnableLevel200 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel200", true);
+    bool EnableLevel255 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel255", true);
+
+//Mony Check
+if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+{
+if (!pPlayer->HasItemCount((sConfigMgr->GetIntDefault("LevelNPC.ItemEntryNum",0)), 0))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You ain't gots no darn chips.", pPlayer);
+    return;
+}
+}
+else if(pPlayer->GetMoney() < (sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+    return;
+}
+
+switch(uiAction)
+{
+
+//////////////////////////////////////////////////Leveling///////////////////////////////////////////////////////////////
+case 1000: //Leveling
+    if(EnableLevel80 && pPlayer->getLevel() < 80)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(1 Donation Chip) Instant 80 ->"         , GOSSIP_SENDER_MAIN, 1001);
+    if(EnableLevel100 && pPlayer->getLevel() < 100 && pPlayer->getLevel() >= 80)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(2 Donation Chips) Instant 100 ->"        , GOSSIP_SENDER_MAIN, 1002);
+    if(EnableLevel150 && pPlayer->getLevel() < 150 && pPlayer->getLevel() >= 100)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(5 Donation Chips) Instant 150 ->"        , GOSSIP_SENDER_MAIN, 1003);
+    if(EnableLevel200 && pPlayer->getLevel() < 200 && pPlayer->getLevel() >= 150)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(10 Donation Chips) Instant 200 ->"       , GOSSIP_SENDER_MAIN, 1004);
+    if(EnableLevel255 && pPlayer->getLevel() < 255 && pPlayer->getLevel() >= 200)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(20 Donation Chips) Instant 255 ->"       , GOSSIP_SENDER_MAIN, 1005);
+        pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                       , GOSSIP_SENDER_MAIN, 3000);
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+case 3000: //Leveling
+    if(EnableLevel80)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+case 1001: // Leveling
+    pPlayer->GiveLevel(80);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1002: // Leveling
+    pPlayer->GiveLevel(100);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 2, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1003: // Leveling
+    pPlayer->GiveLevel(150);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 5, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1004: // Leveling
+    pPlayer->GiveLevel(200);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 10, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1005: // Leveling
+    pPlayer->GiveLevel(255);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 20, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 5000://Remove Res Sickness
+    if(!pPlayer->HasAura(SPELL_RESURRECTION_SICKNESS_15007,0))
+    {
+        pCreature->MonsterWhisper("You don't have resurrection sickness.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pCreature->CastSpell(pPlayer,38588,false); // Healing effect
+    pPlayer->RemoveAurasDueToSpell(SPELL_RESURRECTION_SICKNESS_15007,0);
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+ pPlayer->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    pPlayer->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_levelnpc()
+{
+
+new levelnpc();
+
+}
diff --git a/src/server/scripts/Custom/npc_teleport.cpp b/src/server/scripts/Custom/npc_teleport.cpp
new file mode 100644
index 0000000..07d1ae2
--- /dev/null
+++ b/src/server/scripts/Custom/npc_teleport.cpp
@@ -0,0 +1,222 @@
+/**
+ *
+ * @File : npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+#include <sstream>
+
+#define GOSSIP_SHOW_DEST        1000
+#define GOSSIP_TELEPORT         1001
+#define GOSSIP_NEXT_PAGEC       1002
+#define GOSSIP_PREV_PAGEC       1003
+#define GOSSIP_NEXT_PAGED       1004
+#define GOSSIP_PREV_PAGED       1005
+#define GOSSIP_MAIN_MENU        1006
+
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+#define SPELL_VISUAL_TELEPORT   35517
+
+#define NB_ITEM_PAGE            15
+#define MSG_CAT                 100000
+#define MSG_DEST                100001
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+
+using namespace nsNpcTel;
+
+
+namespace
+{
+    Page PageC, PageD;
+    Page Cat;
+
+    // Conversion function int->string
+    std::string ConvertStr(const int64 &val)
+    {
+        std::ostringstream ostr;
+        ostr << val;
+        return ostr.str();
+    }
+
+    // Conversion function intMoney->stringMoney
+    std::string ConvertMoney(const uint32 &Money)
+    {
+        std::string Str(ConvertStr(Money));
+        uint32 SizeStr = Str.length();
+
+        if (SizeStr > 4)
+            Str = Str.insert(Str.length()-4, "po");
+        if (SizeStr > 2)
+            Str = Str.insert(Str.length()-2, "pa");
+        Str += "pc";
+
+        return Str;
+    }
+
+    // Teleport Player
+    void Teleport(Player * const player, const uint16 &map,
+                  const float &X, const float &Y, const float &Z, const float &orient)
+    {
+        player->CastSpell(player, SPELL_VISUAL_TELEPORT, true);
+        player->TeleportTo(map, X, Y, Z, orient);
+    }
+
+    // Display categories
+    void AffichCat(Player * const player, Creature * const creature)
+    {
+        if (PageC[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGEC, 0);
+
+        VCatDest_t i (PageC[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest.size() && i < (NB_ITEM_PAGE * (PageC[player] + 1)); ++i)
+        {
+            if (TabCatDest[i].IsAllowedToTeleport(player))
+                player->ADD_GOSSIP_ITEM(7, TabCatDest[i].GetName(player->IsGameMaster()).c_str(), GOSSIP_SHOW_DEST, i);
+        }
+
+        if (i < TabCatDest.size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGEC, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_CAT, creature->GetGUID());
+    }
+
+    // Display destination categories
+    void AffichDest(Player * const player, Creature * const creature)
+    {
+        if (PageD[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGED, 0);
+
+        CatDest::VDest_t i (PageD[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest[Cat[player]].size() && i < (NB_ITEM_PAGE * (PageD[player] + 1)); ++i)
+        {
+            player->ADD_GOSSIP_ITEM(5, TabCatDest[Cat[player]].GetDest(i).m_name.c_str(), GOSSIP_TELEPORT, i);
+        }
+
+        if (i < TabCatDest[Cat[player]].size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGED, 0);
+
+        if (CatDest::CountOfCategoryAllowedBy(player) > 1)
+            player->ADD_GOSSIP_ITEM(7, MAIN_MENU, GOSSIP_MAIN_MENU, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_DEST, creature->GetGUID());
+    }
+
+    // Verification before teleportation
+    void ActionTeleport(Player * const player, Creature * const creature, const uint32 &id)
+    {
+        Dest dest (TabCatDest[Cat[player]].GetDest(id));
+
+        if (player->getLevel() < dest.m_level && !player->IsGameMaster())
+        {
+            std::string msg ("You do not have the required level. This destination requires level " + ConvertStr(dest.m_level) + ".");
+            creature->MonsterWhisper(msg.c_str(), player);
+            return;
+        }
+
+        if (player->GetMoney() < dest.m_cost && !player->IsGameMaster())
+        {
+            std::string msg ("You do not have enough money. The price for teleportation is " + ConvertMoney(dest.m_cost) + ".");
+            creature->MonsterWhisper(msg.c_str(), player);
+            return;
+        }
+
+        if (!player->IsGameMaster() && dest.m_cost)
+            player->ModifyMoney(-1 * dest.m_cost);
+
+        Teleport(player, dest.m_map, dest.m_X, dest.m_Y, dest.m_Z, dest.m_orient);
+    }
+}
+
+class npc_teleport : public CreatureScript
+{
+public:
+    npc_teleport() : CreatureScript("npc_teleport") {}
+
+bool OnGossipHello(Player *player, Creature *creature)
+{
+    PageC(player) = PageD(player) = Cat(player) = 0;
+
+    if(player->IsInCombat())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->MonsterWhisper("You are in combat. Come back later", player);
+        return true;
+    }
+    AffichCat(player, creature);
+    return true;
+}
+
+bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 param)
+{
+    player->PlayerTalkClass->ClearMenus();
+    switch(sender)
+    {
+      // Display destinations
+      case GOSSIP_SHOW_DEST:
+        Cat(player) = param;
+        AffichDest(player, creature);
+        break;
+
+      // Previous categories page
+      case GOSSIP_PREV_PAGEC:
+        --PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Next page categories
+      case GOSSIP_NEXT_PAGEC:
+        ++PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Previous destinations page
+      case GOSSIP_PREV_PAGED:
+        --PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Next destination page
+      case GOSSIP_NEXT_PAGED:
+        ++PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Display main menu
+      case GOSSIP_MAIN_MENU:
+        OnGossipHello(player, creature);
+        break;
+
+      // Teleportation
+      case GOSSIP_TELEPORT:
+        player->CLOSE_GOSSIP_MENU();
+        if(player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0)) {
+            creature->CastSpell(player,38588,false); // Healing effect
+            player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+
+        ActionTeleport(player, creature, param);
+        break;
+    }
+    return true;
+}
+};
+
+void AddSC_npc_teleport()
+{
+    new npc_teleport;
+}
+// End of TeleNPC2
diff --git a/src/server/scripts/Custom/npcbuff.cpp b/src/server/scripts/Custom/npcbuff.cpp
new file mode 100644
index 0000000..9ecd4f3
--- /dev/null
+++ b/src/server/scripts/Custom/npcbuff.cpp
@@ -0,0 +1,426 @@
+/* Copyright (C) 2010 SAMCC Studios <http://www.samccstudios.com/>
+ * Written by LordPsyan
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+ /*
+Script Name: npc_buff v1.1
+Complete: 100%
+Comment: Database Driven Buff Master
+*/
+
+#include "ScriptPCH.h"
+#include "Config.h"
+#include "SystemConfig.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define GOSSIP_SMALLBUFF        2000
+#define GOSSIP_LARGEBUFF        3000
+#define GOSSIP_GMBUFF           4000
+#define GOSSIP_PLAYERTOOLS      5000
+
+#define SPELL_RESURRECTION_SICKNESS_15007  15007
+
+#define NB_BUFF_PAGE            10
+#define MSG_TYPE                100002
+#define MSG_BUFF                100003
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+class npc_buff : public CreatureScript
+{
+public:
+    npc_buff() : CreatureScript("npc_buff") {}
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if(sConfigMgr->GetBoolDefault("Npc_Buff.OnlyGMs", false)) // If Npc_Buff.OnlyGMs is enabled in worldserver.conf
+        if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            pCreature->MonsterWhisper("Sorry, I can only Buff Platinum Members.", pPlayer);
+            return true;
+        }
+
+    bool EnableSmallBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableSmallBuff", true);
+    bool EnableGreatBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGreatBuff", true);
+    bool EnableGMBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGMBuff", true);
+    bool EnablePlayerTools = sConfigMgr->GetBoolDefault("Npc_Buff.EnablePlayerTools", true);
+    bool EnableResSickness = sConfigMgr->GetBoolDefault("Npc_Buff.EnableRemoveResSickness", true);
+    bool EnableGivemeGold = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGivemeGold", false);
+
+    // Main Menu
+
+    // Check config if "Small  Buff " is enabled or not
+    if(EnableSmallBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Small Buff ->"              , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Great Buff" is enabled or not
+    if(EnableGreatBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Great Buff ->"              , GOSSIP_SENDER_MAIN, 2000);
+    // Check config if "GM Buff" is enabled or not
+    if(EnableGMBuff)
+    {
+    if (pPlayer->GetSession()->GetSecurity() > SEC_PLAYER)
+        {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Platinum Members Buff ->"                 , GOSSIP_SENDER_MAIN, 3000);
+        }
+    }
+    // Check config if "Player Tools" is enabled or not
+    if(EnablePlayerTools)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Player Tools ->"            , GOSSIP_SENDER_MAIN, 4000);
+
+    // Check config file if "Remove res sickness" option is enabled or not
+    if(EnableResSickness)
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_TYPE, pCreature->GetGUID());
+
+return true;
+}
+
+bool showSmallBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 2000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showSmallBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showGreatBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 3000 AND `cat_number` > 2000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showGreatBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showGmBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 4000 AND `cat_number` > 3000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showGmBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showPlayerTools(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 5000 AND `cat_number` > 4000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showPlayerTools(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->IsInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+    bool EnableSmallBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableSmallBuff", true);
+    bool EnableGreatBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGreatBuff", true);
+    bool EnableGMBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGMBuff", true);
+    bool EnablePlayerTools = sConfigMgr->GetBoolDefault("Npc_Buff.EnablePlayerTools", true);
+    bool EnableResSickness = sConfigMgr->GetBoolDefault("Npc_Buff.EnableRemoveResSickness", true);
+    bool EnableGivemeGold = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGivemeGold", false);
+
+//Money Check
+if (pPlayer->GetMoney() < (sConfigMgr->GetFloatDefault("BuffGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+    return;
+}
+
+
+  // send name as gossip item
+
+
+       QueryResult result;
+        uint32 spellId = 0;
+        uint32 catNumber = 0;
+        uint32 goldCost = 0;
+        std::string spellName = "";
+
+        result = WorldDatabase.PQuery("SELECT `spell_id`, `cat_number`, `cost`, `name` FROM `npc_buff_spells` WHERE `cat_number` = %u LIMIT 1", uiAction);
+
+        if (result)
+        {
+
+            do {
+
+            Field *fields = result->Fetch();
+            spellId = fields[0].GetInt32();
+            catNumber = fields[1].GetInt32();
+            goldCost = fields[2].GetInt32();
+            spellName = fields[3].GetString();
+
+            if (pPlayer->GetMoney() < goldCost)
+            {
+                pCreature->MonsterWhisper("You dont have enough money!", pPlayer);
+                pPlayer->CLOSE_GOSSIP_MENU();
+                return;
+            }
+            else if (uiAction < 5000 && uiAction != 1000 && uiAction != 2000 && uiAction != 3000 && uiAction != 4000 && uiAction != 5005)
+            {
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pPlayer->CastSpell(pPlayer,spellId,false);
+    pPlayer->ModifyMoney(-goldCost);
+
+            }
+
+            } while (result->NextRow());
+        } else {
+            //pPlayer->ADD_GOSSIP_ITEM( 7, MAIN_MENU, GOSSIP_SENDER_MAIN, 5005);
+        }
+
+ switch(uiAction)
+{
+
+case 1000: //Small  Buff
+         showSmallBuff(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+break;
+
+case 2000: //Great Buff
+
+
+        showGreatBuff(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+break;
+
+case 3000: //GM  Buff
+
+        showGmBuff(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF,pCreature->GetGUID());
+break;
+
+case 4000: //Player Tools
+    // Check config if "Give me Gold" is enabled or not
+
+        showPlayerTools(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF,pCreature->GetGUID());
+break;
+
+case 5005: //Back To Main Menu
+    // Main Menu
+    // Check config if "Small  Buff " is enabled or not
+    if(EnableSmallBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Small Buff ->"              , GOSSIP_SMALLBUFF, 1000);
+    // Check config if "Great Buff" is enabled or not
+    if(EnableGreatBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Great Buff ->"              , GOSSIP_LARGEBUFF, 2000);
+    // Check config if "GM Buff" is enabled or not
+    if(EnableGMBuff)
+    {
+    if (pPlayer->GetSession()->GetSecurity() > SEC_PLAYER)
+        {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Platinum Members Buff ->"                 , GOSSIP_SENDER_MAIN, 3000);
+        }
+    }
+    // Check config if "Player Tools" is enabled or not
+    if(EnablePlayerTools)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Player Tools ->"            , GOSSIP_PLAYERTOOLS, 4000);
+    // Check if Ress Sickness option is enabled
+    if(EnableResSickness)
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_TYPE, pCreature->GetGUID());
+break;
+
+case 5000://Remove Res Sickness
+    if(!pPlayer->HasAura(SPELL_RESURRECTION_SICKNESS_15007,0))
+    {
+        pCreature->MonsterWhisper("You don't have resurrection sickness.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pCreature->CastSpell(pPlayer,38588,false); // Healing effect
+    pPlayer->RemoveAurasDueToSpell(SPELL_RESURRECTION_SICKNESS_15007,0);
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    pPlayer->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+void AddSC_Npc_Buff()
+{
+    new npc_buff();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/professionnpc.cpp b/src/server/scripts/Custom/professionnpc.cpp
new file mode 100644
index 0000000..3407d40
--- /dev/null
+++ b/src/server/scripts/Custom/professionnpc.cpp
@@ -0,0 +1,396 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "Config.h"
+#include "SystemConfig.h"
+
+class professionnpc : public CreatureScript
+{
+public:
+    professionnpc() : CreatureScript("professionnpc") {}
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.OnlyGMs", false)) // If ProfessionNPC.OnlyGMs is enabled in trinitycore.conf
+        if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            pCreature->MonsterWhisper("Sorry, I can only trade to game masters.", pPlayer);
+            return true;
+        }
+
+    bool EnableProfessions = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableProfessions", true);
+    bool EnableSecondarySkills = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableSecondarySkills", true);
+
+    // Main Menu for Alliance
+    if (pPlayer->GetTeam() == ALLIANCE)
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+    else // Main Menu for Horde
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+
+return true;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->IsInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+    bool EnableProfessions = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableProfessions", true);
+    bool EnableSecondarySkills = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableSecondarySkills", true);
+
+//Mony Check
+if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+{
+if (!pPlayer->HasItemCount((sConfigMgr->GetIntDefault("ProfessionNPC.ItemEntryNum",0)), 1))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You ain't gots no darn chips.", pPlayer);
+    return;
+}
+else if(pPlayer->GetMoney() < (sConfigMgr->GetIntDefault("SkillGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+    return;
+}
+}
+switch(uiAction)
+{
+
+case 1000: //Profession
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Alchemy."              , GOSSIP_SENDER_MAIN, 1001);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Blacksmithing."        , GOSSIP_SENDER_MAIN, 1002);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Enchanting."           , GOSSIP_SENDER_MAIN, 1003);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Engineering."          , GOSSIP_SENDER_MAIN, 1004);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Herbalism."            , GOSSIP_SENDER_MAIN, 1005);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Inscription."          , GOSSIP_SENDER_MAIN, 1006);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Jewelcrafting."        , GOSSIP_SENDER_MAIN, 1007);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Leatherworking."       , GOSSIP_SENDER_MAIN, 1008);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Mining."               , GOSSIP_SENDER_MAIN, 1009);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Skinning."             , GOSSIP_SENDER_MAIN, 1010);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Tailoring."            , GOSSIP_SENDER_MAIN, 1011);
+            pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"          , GOSSIP_SENDER_MAIN, 3000);
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+
+case 2000: //Secondary Skills
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Cooking."              , GOSSIP_SENDER_MAIN, 2001);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "First Aid."            , GOSSIP_SENDER_MAIN, 2002);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Fishing."              , GOSSIP_SENDER_MAIN, 2003);
+            pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"          , GOSSIP_SENDER_MAIN, 3000);
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+
+case 3000: //Back To Main Menu
+    // Main Menu for Alliance
+    if (pPlayer->GetTeam() == ALLIANCE)
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+    else // Main Menu for Horde
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+
+//////////////////////////////////////////////////Professions///////////////////////////////////////////////////////////////
+
+case 1001: // Alchemy
+    if(!pPlayer->UpdateSkill(171,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(171,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1002: // Blacksmithing
+    if(!pPlayer->UpdateSkill(164,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(164,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1003: // Enchanting
+    if(!pPlayer->UpdateSkill(333,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(333,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1004: // Engineering
+    if(!pPlayer->UpdateSkill(202,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(202,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1005: // Herbalism
+    if(!pPlayer->UpdateSkill(182,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(182,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1006: // Inscription
+    if(!pPlayer->UpdateSkill(773,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(773,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1007: // Jewelcrafting
+    if(!pPlayer->UpdateSkill(755,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(755,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1008: // Leatherworking
+    if(!pPlayer->UpdateSkill(165,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(165,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1009: // Mining
+    if(!pPlayer->UpdateSkill(186,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(186,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1010: // Skinning
+    if(!pPlayer->UpdateSkill(393,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(393,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1011: // Tailoring
+    if(!pPlayer->UpdateSkill(197,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(197,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+//////////////////////////////////////////////////Secondary Skills///////////////////////////////////////////////////////////////
+
+case 2001: // Cooking
+    if(!pPlayer->UpdateSkill(185,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(185,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 2002: // First Aid
+    if(!pPlayer->UpdateSkill(129,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(129,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 2003: // Fishing
+    if(!pPlayer->UpdateSkill(356,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(356,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+ pPlayer->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    pPlayer->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_professionnpc()
+{
+
+new professionnpc();
+
+}
diff --git a/src/server/scripts/Custom/summon.cpp b/src/server/scripts/Custom/summon.cpp
new file mode 100644
index 0000000..ce7ea24
--- /dev/null
+++ b/src/server/scripts/Custom/summon.cpp
@@ -0,0 +1,46 @@
+#include "ScriptPCH.h"
+
+class summon : public ItemScript
+{
+        public:
+                summon() : ItemScript("summon")
+                {
+                }
+                bool OnUse(Player* pPlayer, Item* pItem, SpellCastTargets const& /*targets*/)
+                {
+   uint32 sSpell = 18282; //Icerune Visual Spell when used
+   if (pPlayer->IsInCombat())
+   {
+        pPlayer->GetSession()->SendNotification("You are in combat.");
+   }
+
+   else if (pPlayer->isMoving())
+   {
+        pPlayer->GetSession()->SendNotification("You can not do that while moving.");
+   }
+
+   else if (pPlayer->FindNearestCreature(80410, 40) || pPlayer->FindNearestCreature(100000, 8))
+   {
+        pPlayer->GetSession()->SendNotification("Teleportercan not be summoned because another Teleporter is within range.");
+   }
+
+   else
+   {
+        float x, y, z, o = pPlayer->GetOrientation();
+
+        if (o >= 3.141592)
+         o = o - 3.141592;
+        else
+         o = o + 3.141592;
+        pPlayer->GetClosePoint(x, y, z, pPlayer->GetObjectSize());
+        Creature* pCreature = pPlayer->SummonCreature(100000, x, y, z+2.2, o, TEMPSUMMON_TIMED_DESPAWN, 5000);
+        pCreature->CastSpell(pCreature, 63660);
+        return false;
+   }
+  return false;
+                }
+};
+void AddSC_summon()
+{
+        new summon();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Spells/spell_generic.cpp b/src/server/scripts/Spells/spell_generic.cpp
index 4c72d79..a91693b 100644
--- a/src/server/scripts/Spells/spell_generic.cpp
+++ b/src/server/scripts/Spells/spell_generic.cpp
@@ -37,6 +37,7 @@
 #include "SpellScript.h"
 #include "SpellAuraEffects.h"
 #include "Vehicle.h"
+#include "../Custom/Transmogrification.h"
 
 class spell_gen_absorb0_hitlimit1 : public SpellScriptLoader
 {
@@ -811,7 +812,12 @@ class spell_gen_clone_weapon_aura : public SpellScriptLoader
                         if (Player* player = caster->ToPlayer())
                         {
                             if (Item* mainItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
-                                target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, mainItem->GetEntry());
+                            {
+                                if (uint32 entry = sTransmogrification->GetFakeEntry(mainItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, entry);
+                                else
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, mainItem->GetEntry());
+                            }
                         }
                         else
                             target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID));
@@ -825,7 +831,10 @@ class spell_gen_clone_weapon_aura : public SpellScriptLoader
                         if (Player* player = caster->ToPlayer())
                         {
                             if (Item* offItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
-                                target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, offItem->GetEntry());
+                                if (uint32 entry = sTransmogrification->GetFakeEntry(offItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, entry);
+                                else
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, offItem->GetEntry());
                         }
                         else
                             target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1));
@@ -838,7 +847,10 @@ class spell_gen_clone_weapon_aura : public SpellScriptLoader
                         if (Player* player = caster->ToPlayer())
                         {
                             if (Item* rangedItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED))
-                                target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, rangedItem->GetEntry());
+                                if (uint32 entry = sTransmogrification->GetFakeEntry(rangedItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, entry);
+                                else
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, rangedItem->GetEntry());
                         }
                         else
                             target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2));
diff --git a/src/server/scripts/Spells/spell_paladin.cpp b/src/server/scripts/Spells/spell_paladin.cpp
index 447cb64..8dd7725 100644
--- a/src/server/scripts/Spells/spell_paladin.cpp
+++ b/src/server/scripts/Spells/spell_paladin.cpp
@@ -110,6 +110,12 @@ class spell_pal_ardent_defender : public SpellScriptLoader
             {
                 healPct = GetSpellInfo()->Effects[EFFECT_1].CalcValue();
                 absorbPct = GetSpellInfo()->Effects[EFFECT_0].CalcValue();
+
+                //npcbot - allow for npcbots
+                if (GetUnitOwner()->GetTypeId() == TYPEID_UNIT && GetUnitOwner()->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
+
                 return GetUnitOwner()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -124,6 +130,41 @@ class spell_pal_ardent_defender : public SpellScriptLoader
                 Unit* victim = GetTarget();
                 int32 remainingHealth = victim->GetHealth() - dmgInfo.GetDamage();
                 uint32 allowedHealth = victim->CountPctFromMaxHealth(35);
+
+                //npcbot - calc for bots
+                if (victim->GetTypeId() == TYPEID_UNIT/* && victim->ToCreature()->IsNPCBot()*/)
+                {
+                    if (remainingHealth <= 0 && !victim->ToCreature()->HasSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
+                    {
+                        // Cast healing spell, completely avoid damage
+                        absorbAmount = dmgInfo.GetDamage();
+
+                        uint32 defenseSkillValue = victim->GetDefenseSkillValue();
+                        // Max heal when defense skill denies critical hits from raid bosses
+                        // Formula: max defense at level + 140 (raiting from gear)
+                        uint32 reqDefForMaxHeal  = victim->getLevel() * 5 + 140;
+                        float pctFromDefense = (defenseSkillValue >= reqDefForMaxHeal)
+                            ? 1.0f
+                            : float(defenseSkillValue) / float(reqDefForMaxHeal);
+
+                        int32 healAmount = int32(victim->CountPctFromMaxHealth(int32(healPct * pctFromDefense)));
+                        victim->CastCustomSpell(victim, PAL_SPELL_ARDENT_DEFENDER_HEAL, &healAmount, NULL, NULL, true, NULL, aurEff);
+                        victim->ToCreature()->_AddCreatureSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL, time(NULL) + 120);
+                        victim->ToCreature()->AddBotSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL, 120 * IN_MILLISECONDS);
+                    }
+                    else if (remainingHealth < int32(allowedHealth))
+                    {
+                        // Reduce damage that brings us under 35% (or full damage if we are already under 35%) by x%
+                        uint32 damageToReduce = (victim->GetHealth() < allowedHealth)
+                            ? dmgInfo.GetDamage()
+                            : allowedHealth - remainingHealth;
+                        absorbAmount = CalculatePct(damageToReduce, absorbPct);
+                    }
+
+                    return;
+                }
+                //end npcbot
+
                 // If damage kills us
                 if (remainingHealth <= 0 && !victim->ToPlayer()->HasSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
                 {
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 76781e0..46517b4 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -568,6 +568,7 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load() override
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -610,6 +611,8 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target) && !caster->IsValidAttackTarget(target))
                         return SPELL_FAILED_BAD_TARGETS;
@@ -751,6 +754,7 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load() override
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.cpp b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
index 24e61e7..950f107 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
@@ -600,4 +600,35 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_UPD_CHAR_PET_SLOT_BY_ID, "UPDATE character_pet SET slot = ? WHERE owner = ? AND id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_ID, "DELETE FROM character_pet WHERE id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_SLOT, "DELETE FROM character_pet WHERE owner = ? AND (slot = ? OR slot > ?)", CONNECTION_ASYNC);
+
+    //Guild-Level-System
+    //Load
+    PrepareStatement(CHAR_SEL_GUILD_BONUS_INFO, "SELECT RequiredGuildLevel FROM guild_bonus_config WHERE BonusId = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_GUILD_LEVEL_INFO, "SELECT xp, level FROM guild WHERE guildid = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_GUILD_XP_FOR_NEXT_LEVEL, "SELECT xp_for_next_level FROM guild_xp_for_next_level WHERE level = ?", CONNECTION_SYNCH);
+
+    //Save
+    PrepareStatement(CHAR_UPD_GUILD_LEVEL, "UPDATE guild SET level = ? WHERE guildid = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_GUILD_XP, "UPDATE guild SET xp = (xp + ?) WHERE guildid = ?", CONNECTION_ASYNC);
+
+    // Bots
+    PrepareStatement(CHAR_SEL_NPCBOTS, "SELECT entry FROM characters_npcbot", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_NPCBOT_OWNER, "SELECT owner FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_OWNER, "UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_OWNER_ALL, "UPDATE characters_npcbot SET owner = ? WHERE owner = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_NPCBOT_ROLES, "SELECT roles FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_ROLES, "UPDATE characters_npcbot SET roles = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_NPCBOT_EQUIP, "SELECT equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE, "SELECT ii.creatorGuid, ii.giftCreatorGuid, ii.count, ii.duration, ii.charges, ii.flags, ii.enchantments, ii.randomPropertyId, ii.durability, ii.playedTime, ii.text, ii.guid, ii.itemEntry, ii.owner_guid "
+        "FROM item_instance ii JOIN characters_npcbot cn ON ii.guid IN "
+        "(cn.equipMhEx, cn.equipOhEx, cn.equipRhEx, cn.equipHead, cn.equipShoulders, cn.equipChest, cn.equipWaist, cn.equipLegs, cn.equipFeet, cn.equipWrist, cn.equipHands, cn.equipBack, cn.equipBody, cn.equipFinger1, cn.equipFinger2, cn.equipTrinket1, cn.equipTrinket2, cn.equipNeck) "
+        "WHERE cn.entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_EQUIP, "UPDATE characters_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, "
+        "equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?, equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_NPCBOT, "DELETE FROM characters_npcbot WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT, "INSERT INTO characters_npcbot (entry, roles) VALUES (?, ?)", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_FACTION, "UPDATE characters_npcbot SET faction = ? WHERE entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_NPCBOT_FACTION, "SELECT faction FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH);
+    // end Bots
 }
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.h b/src/server/shared/Database/Implementation/CharacterDatabase.h
index 98d7fe2..a4e8069 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.h
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.h
@@ -534,6 +534,28 @@ enum CharacterDatabaseStatements
     CHAR_DEL_ITEMCONTAINER_MONEY,
     CHAR_INS_ITEMCONTAINER_MONEY,
 
+    //Guild-Level-System
+    CHAR_SEL_GUILD_BONUS_INFO,
+    CHAR_SEL_GUILD_LEVEL_INFO,
+    CHAR_SEL_GUILD_XP_FOR_NEXT_LEVEL,
+    CHAR_UPD_GUILD_LEVEL,
+    CHAR_UPD_GUILD_XP,
+
+    // Bot
+    CHAR_SEL_NPCBOTS,
+    CHAR_SEL_NPCBOT_OWNER,
+    CHAR_UPD_NPCBOT_OWNER,
+    CHAR_UPD_NPCBOT_OWNER_ALL,
+    CHAR_SEL_NPCBOT_ROLES,
+    CHAR_UPD_NPCBOT_ROLES,
+    CHAR_SEL_NPCBOT_EQUIP,
+    CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE,
+    CHAR_UPD_NPCBOT_EQUIP,
+    CHAR_DEL_NPCBOT,
+    CHAR_INS_NPCBOT,
+    CHAR_UPD_NPCBOT_FACTION,
+    CHAR_SEL_NPCBOT_FACTION,
+
     MAX_CHARACTERDATABASE_STATEMENTS
 };
 
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.cpp b/src/server/shared/Database/Implementation/WorldDatabase.cpp
index d0e9c46..77c6d95 100644
--- a/src/server/shared/Database/Implementation/WorldDatabase.cpp
+++ b/src/server/shared/Database/Implementation/WorldDatabase.cpp
@@ -91,4 +91,9 @@ void WorldDatabaseConnection::DoPrepareStatements()
     PrepareStatement(WORLD_DEL_DISABLES, "DELETE FROM disables WHERE entry = ? AND sourceType = ?", CONNECTION_ASYNC);
     // 0: uint8
     PrepareStatement(WORLD_SEL_REQ_XP, "SELECT xp_for_next_level FROM player_xp_for_level WHERE lvl = ?", CONNECTION_SYNCH);
+
+    // Bot
+    PrepareStatement(WORLD_SEL_NPCBOT_INFO, "SELECT guid, map, position_x, position_y, position_z, orientation FROM creature WHERE id = ?", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS, "SELECT hp, mana, armor, str, agi, sta, inte, spi FROM pet_levelstats WHERE creature_entry = ? AND level = ?", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_UPD_NPCBOT_POSITION, "UPDATE creature SET map = ?, position_x = ?, position_y = ?, position_z = ?, orientation = ? WHERE guid = ?", CONNECTION_ASYNC);
 }
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.h b/src/server/shared/Database/Implementation/WorldDatabase.h
index a815373..197150b 100644
--- a/src/server/shared/Database/Implementation/WorldDatabase.h
+++ b/src/server/shared/Database/Implementation/WorldDatabase.h
@@ -112,6 +112,11 @@ enum WorldDatabaseStatements
     WORLD_DEL_DISABLES,
     WORLD_SEL_REQ_XP,
 
+    // Bot
+    WORLD_SEL_NPCBOT_INFO,
+    WORLD_SEL_NPCBOT_PET_LEVELSTATS,
+    WORLD_UPD_NPCBOT_POSITION,
+
     MAX_WORLDDATABASE_STATEMENTS
 };
 
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
index 78a29db..ae5c342 100644
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -127,6 +127,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells
   ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
   ${CMAKE_SOURCE_DIR}/src/server/game/Tools
+  ${CMAKE_SOURCE_DIR}/src/server/game/Trinichat
   ${CMAKE_SOURCE_DIR}/src/server/game/Warden
   ${CMAKE_SOURCE_DIR}/src/server/game/Warden/Modules
   ${CMAKE_SOURCE_DIR}/src/server/game/Weather
diff --git a/src/server/worldserver/CommandLine/CliRunnable.cpp b/src/server/worldserver/CommandLine/CliRunnable.cpp
index ac46b21..0bed869 100644
--- a/src/server/worldserver/CommandLine/CliRunnable.cpp
+++ b/src/server/worldserver/CommandLine/CliRunnable.cpp
@@ -34,6 +34,7 @@
 #include "MapManager.h"
 #include "Player.h"
 #include "Util.h"
+#include "../../game/TriniChat/IRCClient.h"
 
 #if PLATFORM != PLATFORM_WINDOWS
 #include <readline/readline.h>
@@ -114,6 +115,14 @@ void commandFinished(void*, bool /*success*/)
     printf("TC> ");
     fflush(stdout);
 }
+//Reconnect TriniChat to IRC server via CLI command
+bool HandleIRCRelogCommand(bool, const char *args)
+{
+    TC_LOG_ERROR("misc" "TriniChat is dropping from IRC Server","");
+    sIRC.ResetIRC();
+    TC_LOG_ERROR("misc" "TriniChat is reconnecting to IRC Server","");
+    return true;
+}
 
 #ifdef linux
 // Non-blocking keypress detector, when return pressed, return 1, else always return 0
diff --git a/src/server/worldserver/Main.cpp b/src/server/worldserver/Main.cpp
index 75d9ca5..1b8c794 100644
--- a/src/server/worldserver/Main.cpp
+++ b/src/server/worldserver/Main.cpp
@@ -30,6 +30,7 @@
 
 #include "Log.h"
 #include "Master.h"
+#include "../../game/TriniChat/IRCClient.h"
 
 #ifndef _TRINITY_CORE_CONFIG
 # define _TRINITY_CORE_CONFIG  "worldserver.conf"
diff --git a/src/server/worldserver/Master.cpp b/src/server/worldserver/Master.cpp
index 6e42146..ac92dea 100644
--- a/src/server/worldserver/Master.cpp
+++ b/src/server/worldserver/Master.cpp
@@ -42,7 +42,7 @@
 #include "Util.h"
 #include "AuthSocket.h"
 #include "RealmList.h"
-
+#include "../../game/TriniChat/IRCClient.h"
 #include "BigNumber.h"
 #include "OpenSSLCrypto.h"
 
@@ -278,6 +278,15 @@ int Master::Run()
         soapThread = new ACE_Based::Thread(runnable);
     }
 
+  // Start up TriniChat
+    if (sIRC.Active == 1)
+    {
+        ACE_Based::Thread irc(new IRCClient);
+        irc.setPriority ((ACE_Based::Priority)2);
+    }
+    else
+        TC_LOG_ERROR("misc" "*** TriniChat Is Disabled. *","");
+
     ///- Start up freeze catcher thread
     if (uint32 freezeDelay = sConfigMgr->GetIntDefault("MaxCoreStuckTime", 0))
     {
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 90f330b..70a7637 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -757,6 +757,13 @@ RecruitAFriend.MaxDifference = 4
 DisableWaterBreath = 4
 
 #
+#    Enable or Disable "Fatigue" timer
+#           default = 1 (enabled)
+#                   = 0 (disabled)
+
+fatigue.enabled = 1
+
+#
 #    AllFlightPaths
 #        Description: Character knows all flight paths (of both factions) after creation.
 #        Default:     0 - (Disabled)
@@ -1205,6 +1212,14 @@ AllowTwoSide.Trade = 0
 
 TalentsInspecting = 1
 
+#    Fake.WHO.List
+#        Add fake players to fill in WHO LIST (who is online list, "O" button) if there is less then
+#        49 real players online
+#        Default: 0 (disabled)
+#                 1 (enabled)
+
+Fake.Who.List = 0
+
 #
 ###################################################################################################
 
@@ -2296,6 +2311,271 @@ Network.TcpNodelay = 1
 #
 ###################################################################################################
 
+###############################################################################
+# AUCTION HOUSE BOT SETTINGS
+#
+#    AuctionHouseBot.DEBUG
+#        Enable/Disable Debugging output
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.DEBUG_FILTERS
+#        Enable/Disable Debugging output from Filters
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableSeller
+#        Enable/Disable the part of AHBot that puts items up for auction
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableBuyer
+#        Enable/Disable the part of AHBot that buys items from players
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.UseBuyPriceForSeller
+#        Should the Seller use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    AuctionHouseBot.UseBuyPriceForBuyer
+#        Should the Buyer use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    Auction House Bot character data
+#        AuctionHouseBot.Account is the account number
+#         (in realmd->account table) of the player you want to run
+#         as the auction bot.
+#        AuctionHouseBot.GUID is the GUID (in characters->characters table)
+#         of the player you want to run as the auction bot.
+#    Default: 0 (Auction House Bot disabled)
+#
+#    AuctionHouseBot.ItemsPerCycle
+#        Number of Items to Add/Remove from the AH during mass operations
+#    Default 200
+#
+###############################################################################
+
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.DEBUG_FILTERS = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 1
+#
+#    AuctionHouseBot.VendorItems
+#        Include items that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.VendorTradeGoods
+#        Include Trade Goods that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.LootItems
+#        Include items that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.LootTradeGoods
+#        Include Trade Goods that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.OtherItems
+#        Include misc. items.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.OtherTradeGoods
+#        Include misc. Trade Goods.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.Bonding_types
+#        Indicates which bonding types to allow seller to put up for auction
+#            No_Bind
+#             Default 1 (True)
+#            Bind_When_Picked_Up
+#             Default 0 (False)
+#            Bind_When_Equipped
+#             Default 1 (True)
+#            Bind_When_Use
+#             Default 1 (True)
+#            Bind_Quest_Item
+#             Default 0 (False)
+#
+#    AuctionHouseBot.DisabledItems
+#        Disable certain items that are usually unavailable to Players. List of ids separated by space
+#    Default "21878 27774 27811 28117 28112" (PTR items)
+#
+#    AuctionHouseBot.DisablePermEnchant
+#        Disable Items with a Permanent Enchantment
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableConjured
+#        Disable Conjured Items
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableGems
+#        Disable Gems
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoney
+#        Disable Items that are used as money
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoneyLoot
+#        Disable Items that have Money as a loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableLootable
+#        Disable Items that have other items as loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableKeys
+#        Disable Items that are keys
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableDuration
+#        Disable Items with a duration
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel
+#        Disable items that are BOP or Quest Item
+#        with a Required level that is less than the Item Level
+#        (This prevents a level 10 with a level 60 weapon or armor)
+#        (May need further refinement)
+#    Default 0 (False)
+#
+###############################################################################
+
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+AuctionHouseBot.DisabledItems = "21878 27774 27811 28117 28112"
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 2
+#
+#     These Filters are boolean (0 or 1) and will disable items that are
+#     specifically meant for the Class named.
+#     (UnusedClass is Class 10, which was skipped for some reason)
+#     Default 0 (allowed)
+#
+###############################################################################
+
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 3
+#
+#    AuctionHouseBot.DisableItemsBelowLevel
+#        Prevent Seller from listing Items below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveLevel
+#        Prevent Seller from listing Items above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowLevel
+#        Prevent Seller from listing Trade Goods below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveLevel
+#        Prevent Seller from listing Trade Goods above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowGUID
+#        Prevent Seller from listing Items below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveGUID
+#        Prevent Seller from listing Items above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowGUID
+#        Prevent Seller from listing Trade Goods below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveGUID
+#        Prevent Seller from listing Trade Goods above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqLevel
+#        Prevent Seller from listing Items below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqLevel
+#        Prevent Seller from listing Items above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqLevel
+#        Prevent Seller from listing Trade Goods below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqLevel
+#        Prevent Seller from listing Trade Goods above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqSkillRank
+#        Prevent Seller from listing Items below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqSkillRank
+#        Prevent Seller from listing Items above this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqSkillRank
+#        Prevent Seller from listing Trade Goods below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqSkillRank
+#        Prevent Seller from listing Trade Goods above this Required Skill Rank
+#    Default 0 (Off)
+#
+###############################################################################
+
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
 ###################################################################################################
 # CONSOLE AND REMOTE ACCESS
 #
@@ -2359,6 +2639,48 @@ SOAP.Port = 7878
 
 #
 ###################################################################################################
+#
+#       Profession NPC
+#
+# Enable or Disable Primary Professions
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+ProfessionNPC.EnableProfessions = 1
+
+# Enable or Disable Secondary Professions
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+ProfessionNPC.EnableSecondarySkills = 1
+
+# Number of Skill points
+#         default = 10
+
+SkillPoints = 10
+
+# GM Only
+#         default = 0 (Anyone can use)
+#                   = 1 (GM only)
+
+ProfessionNPC.OnlyGMs = 0
+
+# Cost of skill points (in copper)
+#         default = 10000 (10 gold)
+
+SkillGoldCost = 10000
+
+# Use Tokens instead of gold
+#         default = 0 (Use Gold)
+#                 = 1 (Use Tokens)
+
+ProfessionNPC.UseTokens = 1
+
+# Entry number of "token" Item
+#         default = 0 (No item. ProfessionNPC.UseTokens must = 0)
+#                 = n (n = entry number of item)
+
+ProfessionNPC.ItemEntryNum = 99999
 
 ###################################################################################################
 # CHARACTER DELETE OPTIONS
@@ -2397,6 +2719,251 @@ CharDelete.KeepDays = 30
 
 #
 ###################################################################################################
+# TriniChat IRC BOT For Trinity Core Configuration File #
+#########################################################
+# irc.active
+# Enable TriniChat Addon
+# Default: 1 - Enable
+# 0 - Disable
+#
+irc.active = 1
+
+##################################################
+# irc.icc
+# IRC connect code
+# Default: 001 - Welcome To Network msg
+# 375 - Beginning Of MOTD
+# 376 - End Of MOTD
+#
+irc.icc = 001
+
+##################################################
+# irc.host
+# IRC server to have TriniChat connect to
+#
+irc.host = "irc.xxxx.net"
+
+##################################################
+# irc.port
+# IRC server port to use
+#
+irc.port = "1337"
+
+##################################################
+# irc.user
+# The username to have TriniChat use to connect to the IRC server
+# irc.nick
+# IRC nickname to be used by the bot
+# irc.pass
+# The password to be used to identify to NickServ (IRC NickName Enforcement Services)
+#
+irc.user = "Trini_Chat"
+irc.nick = "Trini_Chat"
+irc.pass = "ServicesPass"
+
+##################################################
+# irc.auth
+# IRC Authentication Method
+# Default: 0 - Disable
+# 1 - NickServ - Normal Method - PRIVMSG NickServ :IDENTIFY Password
+# 2 - NickServ - Alternate Method To Identify To A Different Nick - PRIVMSG NickServ :IDENTIFY irc.auth.nick Password
+# 3 - QuakeNet - Normal Method - PRIVMSG Q@CServe.quakenet.org :AUTH irc.nick Password
+# 4 - QuakeNet - Alternate Method To Identify To A Different Nick - PRIVMSG Q@CServe.quakenet.org :AUTH irc.auth.nick Password
+# irc.auth.nick
+# IRC Nickname to use if Auth method 2 or 4 is used
+#
+irc.auth = 0
+irc.auth.nick = "AuthNick"
+
+##################################################
+# irc.ldef
+# Leave a defined IRC channel on server connect
+# Default: 0 - Disable
+# 1 - Enable
+# irc.defchan
+# IRC channel to leave on server connect if irc.ldef is on
+#
+irc.ldef = 0
+irc.defchan = "lobby"
+
+##################################################
+# irc.wct
+# Time to wait before (re)attemptimg connection to IRC server
+# Default: 30000 - (30 Seconds)
+# irc.maxattempt
+# Maximum attempts to try IRC server
+# Default: 20
+#
+irc.wct = 30000
+irc.maxattempt = 20
+
+##################################################
+# irc.auto.announce
+# Time to wait in Minutes to announce random messages from database.
+# Default: 30 - (30 Minutes)
+#
+irc.auto.announce = 30
+
+##################################################
+# irc.autojoin_kick
+# Autojoin IRC channel if kicked
+# Default: 1 - Enable
+# 0 - Disable
+#
+irc.autojoin_kick = 1
+
+##################################################
+# irc.command_prefix
+# IRC command prefix
+# Example: (.)online all
+#
+irc.command_prefix = "\"
+
+##################################################
+# irc.joinmsg
+# irc.rstmsg
+# irc.kickmsg
+# TriniChat bot join/restart/kick messages
+#
+irc.joinmsg = "Trinity Core With TriniChat $Ver Is Up And Running! Command Trigger Is: $Trigger"
+irc.rstmsg = "TriniChat Is Restarting, I Will Be Right Back."
+irc.kickmsg = "Do Not Kick Me Again, Severe Actions Will Be Taken!"
+
+##################################################
+# irc.chan_#
+# wow.chan_#
+# IRC and WOW channels to link. Leave # out of IRC channel. Both channels _ARE_ case sensitive
+# NOTE: you can have more than 1 IRC channel linked to wow channels, as in example:
+# Example: irc.chan_1 = "Trinity"
+# irc.chan_2 = "trinity2"
+# wow.chan_1 = "world"
+# wow.chan_2 = "LookingForGroup"
+# irc.pass_#
+# Passwords for said IRC channels (IRC server side)
+# Example:
+# irc.pass_1 = "password" password for irc channel #1
+# irc.pass_2 = "password2" password for irc channel #2
+irc.chan_1 = "ircchan"
+wow.chan_1 = "world"
+irc.pass_1 = "pass"
+
+##################################################
+# irc.StatusChannel
+# Channel Number To Display Status Messages In (AuctionHouse, Levels, Deaths, Etc)
+# Default: 1 - Channel ID 1
+# irc.AnnounceChannel
+# Channel Number To Display Announcements In (Announces, Notifies, Event)
+# Default: 1 - Channel ID 1
+#
+irc.StatusChannel = 1
+irc.AnnounceChannel = 1
+
+##################################################
+# irc.op_gm_login
+# Op The GM In All Channels The Bot Is On When They Log In To TriniChat
+# Default: 0 - Disable
+# 1 - Enable
+# irc.op_gm_level
+# The Minimum GM Level Required To Have The Bot Op The User
+# Default: 5 - GM Level 5
+#
+irc.op_gm_login = 0
+irc.op_gm_level = 3
+
+##################################################
+# irc.ajoin (Experimental/Under Development)
+# Force players to autojoin a WOW in game channel
+# Atleast one player must be in the channel on server start, and atleast one person online for invite to work
+# Default: 0 - Disable
+# 1 - Enable
+# irc.ajchan
+# Channel to join if above is Enabled.
+#
+irc.ajoin = 1
+irc.ajchan = "world"
+
+##################################################
+# irc.online.result
+# Maximum number of results per line for the online command
+#
+irc.online.result = 30
+
+##################################################
+# chat.*** (Defineable Strings) (maybe more in future)
+# wow_* - String is displayed in IRC channel
+# irc_* - String is displayed in WOW channel
+# Options: $Name, $Level, $Msg, $GM (not all options work in every string)
+#
+chat.wow_irc = "<WoW>[$Name($Level)] $Msg"
+chat.irc_wow = "<IRC>[$Name]: $Msg"
+chat.join_wow = "12>>04 $GM$Name Joined The $Channel Channel!"
+chat.join_irc = "[$Name]: Has Joined IRC!"
+chat.leave_wow = "12<<04 $GM$Name Left The $Channel Channel!"
+chat.leave_irc = "[$Name]: Has Left IRC!"
+chat.change_nick = "<> $Name Is Now Known As $NewName!"
+
+##################################################
+# Botmask
+# This defines what the bot announces, if its 0 everything is disabled
+# simply add the values of the elements you want to create this mask.
+# Example: WoW join/leaves are 1 and IRC join/leaves are 2, if you want both of these active then the BotMask is 3.
+# (1)Display WoW Chan Join/Leaves In IRC
+# (2)Display IRC Chan Join/Leaves/NickChanges In WoW
+# (4)Display Unknown Command Message When Trigger Is Used And No Command Exists
+# (8)Announce Security Level > 0 As GM At Login
+# (16)Announce GM In GM ON State AS GM At Login
+# (32)Return Errors To Notice. (If disabled then default is Private Message)
+# (64)Display WoW Status Messages (Levels/Deaths)
+# (128)Display Nick Changes From IRC In WOW
+# (256)Display WoW Announces/Notifies In IRC
+# (512)Do Not Let Players Use Commands On Higher GM Level Players
+# (1024)Enable AuctionHouse Announcements !!DISSABLED!!
+#
+Botmask = 1023
+
+##################################################
+# irc.gmlog
+# Minimum GM level to not show login/pass info in IRC logs
+# irc.logfile.prefix
+# The prefix of the IRC logfile. Directories can be added here.
+# Example: "IRC/IRC_" outputs IRC_YYYY-MM-DD.log to the IRC subdirectory in your logs dir
+# irc.logchannel
+# Specefies the channel where logged output gets broadcasted.
+# Default: "" (none)
+# irc.logchannelpw
+# The password for the log channel.
+# irc.logmask
+# Bitmask, see Botmask for explanation. Determines what gets logged to the logchannel.
+# (0) Do not broadcast into logchannel.
+# (1) Broadcast IRC Commands into logchannel.
+# (2) Broadcast Ingame GM Commands into logchannel.
+# (3) Broadcast both IRC Commands and GM Commands into logchannel.
+irc.gmlog = 1
+irc.logfile.prefix = "IRC_"
+irc.logchannel = "testlog"
+irc.logchannelpw = ""
+irc.logmask = 3
+
+##################################################
+# irc.fun.games (Experimental/Under Development)
+# Enable TriniChat Games
+# Default: 0 - Disable
+# 1 - Enable
+#
+irc.fun.games = 0
+
+##################################################
+# irc.gm#
+# GM tag to append to (GM onjoin / online command) IRC color codes are acceptable
+#
+irc.gm1 = "[VIP]"
+irc.gm2 = "[Donator]"
+irc.gm3 = "[Bug Tracker]"
+irc.gm4 = "[Moderator]"
+irc.gm5 = "[Game Master]"
+irc.gm6 = "[Admin]"
+irc.gm7 = "[Developer]"
+irc.gm8 = "[Owner]"
 
 ###################################################################################################
 # CUSTOM SERVER OPTIONS
@@ -2575,6 +3142,40 @@ LevelReq.Auction = 1
 LevelReq.Mail = 1
 
 #
+#     Anticheat.Enable
+#        Description: Enables or disables the Anticheat System functionality
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+Anticheat.Enable = 1
+
+#     Anticheat.ReportsForIngameWarnings
+#        Description: How many reports the player must have to notify to GameMasters ingame when he generates a new report.
+#        Default:     70
+
+Anticheat.ReportsForIngameWarnings = 70
+
+#     Anticheat.DetectionsEnabled
+#        Description: It represents which detections are enabled.
+#
+#        SPEED_HACK_DETECTION            = 1
+#        FLY_HACK_DETECTION              = 2
+#        WALK_WATER_HACK_DETECTION       = 4
+#        JUMP_HACK_DETECTION             = 8
+#        TELEPORT_PLANE_HACK_DETECTION   = 16
+#        CLIMB_HACK_DETECTION            = 32
+#
+#        Default:     31
+
+Anticheat.DetectionsEnabled = 31
+
+#     Anticheat.MaxReportsForDailyReport
+#        Description: How many reports must the player have to make a report that it is in DB for a day (not only during the player's session).
+#        Default:     70
+
+Anticheat.MaxReportsForDailyReport = 70
+
+#
 #     PlayerDump.DisallowPaths
 #        Description: Disallow using paths in PlayerDump output files
 #        Default:     1
@@ -2599,6 +3200,44 @@ UI.ShowQuestLevelsInDialogs = 0
 #
 ###################################################################################################
 
+# NPC Buff rewritten by LordPsyan
+#
+#        GM Only
+#         Default 0 = Any Player
+#                 1 = GM1 or higher
+
+Npc_Buff.OnlyGMs = 0
+
+#     Enables Small Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableSmallBuff = 1
+
+#     Enables Geat Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableGreatBuff = 1
+
+#     Enables GM Only Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableGMBuff = 1
+
+#     Enables Player Tools
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnablePlayerTools = 1
+
+#     Enables Remove Res Sickness
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableRemoveResSickness = 1
+
 ###################################################################################################
 #  LOGGING SYSTEM SETTINGS
 #
@@ -2786,3 +3425,394 @@ PacketSpoof.BanDuration = 86400
 
 #
 ###################################################################################################
+
+###################################################################################################
+#
+# BeastMaster Configuration
+#
+# BeastMaster Hunter Only
+#                 = 0 (Anyone can use)
+#         default = 1 (Hunter only)
+
+BeastMaster.OnlyHunter = 1
+
+#
+# BeastMaster Enable Normal Pets
+#                 = 0  (Normal pets disabled)
+#         default = 1  (Normal Pets enabled)
+#
+
+BeastMaster.EnableNormalPet = 1
+
+#
+# BeastMaster Enable Exotic Pets
+#                 = 0  (Anyone Can get Exotic pets)
+#         default = 1  (Can only get Exotic Pets if you know how)
+#
+
+BeastMaster.EnableExoticPet = 1
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# CROSSFACTION BG CONFIG
+#
+#    CrossfactionBG.enable = 1 - Mixed battleground enabled.
+#    CrossfactionBG.enable = 0 - Mixed battleground disabled.
+
+CrossfactionBG.enable = 1
+
+#
+###################################################################################################
+
+###################################################################################################
+# GuildHouse
+#
+# Settings for the GuildHouse Keeper.
+#
+#    Guildhouse.TokenOrGold
+#        Description: Use tokens or money to buy guild houses.
+#        Default:     0 - Use Money
+#                     1 - Use Token
+#
+
+Guildhouse.TokenOrGold = 0
+
+#    GuildHouse.BuyCost
+#        Description: Amount of gold or quantity of tokens to buy guildhouse.
+#        Default:     1000 - 1000 gold
+#
+
+Guildhouse.BuyCost = 1000
+
+#    GuildHouse.BuyCost
+#        Description: Amount of gold or quantity of tokens gained when selling guildhouse.
+#        Default:     5000000 - 500 gold
+#
+
+Guildhouse.SellCost = 500
+
+#
+###################################################################################################
+
+###################################################################################################
+#    Transmogrification config
+###################################################################################################
+#
+#    SETTINGS
+#
+#    Logger.custom.transmog
+#        Description: Transmogrification logging setting, see logger settings
+#        Default:    3, Console Server
+#
+#    Transmogrification.EnableTransmogInfo
+#        Description: Enables / Disables the info button for transmogrification
+#        Default:    1
+#
+#    Transmogrification.TransmogNpcText
+#        Description: The npc_text entry of the info menu for transmogrification
+#        Default:    50000
+#
+#    Transmogrification.Allowed
+#        Description: A list of item entries that are allowed for transmogrification (skips quality and CanUseItem check)
+#					  Example: "25 35674 5623"
+#        Default:    ""
+#
+#    Transmogrification.NotAllowed
+#        Description: A list of item entries that are NOT allowed for transmogrification
+#					  Example: "25 35674 5623"
+#        Default:    ""
+
+Logger.custom.transmog = 3, Console Server
+
+Transmogrification.EnableTransmogInfo = 1
+Transmogrification.TransmogNpcText = 50000
+
+Transmogrification.Allowed = ""
+Transmogrification.NotAllowed = ""
+
+#
+#    COPPER COST
+#
+#    Transmogrification.ScaledCostModifier
+#        Description: A multiplier for the default gold cost (change to 0 for no default cost)
+#        Default:    1.0
+#
+#    Transmogrification.CopperCost
+#        Description: Cost added on top of other costs (can be negative)
+#        Default:    0
+#
+#    For custom gold cost set ScaledCostModifier to 0.0 and CopperCost to what ever cost you want
+
+Transmogrification.ScaledCostModifier = 1.0
+Transmogrification.CopperCost = 0
+
+#
+#    TOKEN COST
+#
+#    Transmogrification.RequireToken
+#        Description: Adds/disables token cost
+#        Default:    0
+#
+#    Transmogrification.TokenEntry
+#        Description: Entry of the token item
+#        Default:    49426
+#
+#    Transmogrification.TokenAmount
+#        Description: Amount of tokens required
+#        Default:    1
+
+Transmogrification.RequireToken = 0
+Transmogrification.TokenEntry = 49426
+Transmogrification.TokenAmount = 1
+
+#
+#    REQUIREMENTS
+#
+#    Transmogrification.AllowPoor
+#        Description: Allow poor quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowCommon
+#        Description: Allow common quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowUncommon
+#        Description: Allow uncommon quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowRare
+#        Description: Allow rare quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowEpic
+#        Description: Allow epic quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowLegendary
+#        Description: Allow legendary quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowArtifact
+#        Description: Allow artifact quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowHeirloom
+#        Description: Allow heirloom quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowMixedArmorTypes
+#        Description: Allow cloth items to be transmogrified with plate for example
+#        Default:    0
+#
+#    Transmogrification.AllowMixedWeaponTypes
+#        Description: Allow axe to be transmogrified with dagger for example
+#        Default:    0
+#
+#    Transmogrification.AllowFishingPoles
+#        Description: Allow fishing poles to be transmogrified
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqRace
+#        Description: Ignore required race for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqClass
+#        Description: Ignore required class for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqSkill
+#        Description: Ignore required skill for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqSpell
+#        Description: Ignore required spell for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqLevel
+#        Description: Ignore required level for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqEvent
+#        Description: Ignore required event for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqStats
+#        Description: Ignore stat count > 0 requirement for source items
+#        Default:    0
+
+Transmogrification.AllowPoor = 0
+Transmogrification.AllowCommon = 0
+Transmogrification.AllowUncommon = 1
+Transmogrification.AllowRare = 1
+Transmogrification.AllowEpic = 1
+Transmogrification.AllowLegendary = 0
+Transmogrification.AllowArtifact = 0
+Transmogrification.AllowHeirloom = 1
+
+Transmogrification.AllowMixedArmorTypes = 0
+Transmogrification.AllowMixedWeaponTypes = 0
+Transmogrification.AllowFishingPoles = 0
+
+Transmogrification.IgnoreReqRace = 0
+Transmogrification.IgnoreReqClass = 0
+Transmogrification.IgnoreReqSkill = 0
+Transmogrification.IgnoreReqSpell = 0
+Transmogrification.IgnoreReqLevel = 0
+Transmogrification.IgnoreReqEvent = 0
+Transmogrification.IgnoreReqStats = 0
+
+#
+#    SET FEATURE
+#
+#    Transmogrification.EnableSets
+#        Description: Enables / Disables the set feature. If you want permanent disable, check Transmogrification.h
+#        Default:    1
+#
+#    Transmogrification.MaxSets
+#        Description: Maximum amount of sets a player can save (hardcap at 25)
+#        Default:    10
+#
+#    Transmogrification.EnableSetInfo
+#        Description: Enables / Disables the info button for set fature
+#        Default:    1
+#
+#    Transmogrification.SetNpcText
+#        Description: The npc_text entry of the info menu for the set feature
+#        Default:    50001
+#
+#    Transmogrification.SetCostModifier
+#        Description: A multiplier for the default gold cost (all costs summed together) (change to 0 for no default cost)
+#        Default:    3.0
+#
+#    Transmogrification.SetCopperCost
+#        Description: Cost added on top of other costs (can be negative)
+#        Default:    0
+
+Transmogrification.EnableSets = 1
+Transmogrification.MaxSets = 10
+
+Transmogrification.EnableSetInfo = 1
+Transmogrification.SetNpcText = 50001
+
+Transmogrification.SetCostModifier = 3.0
+Transmogrification.SetCopperCost = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#    NpcBot.Enable
+#        Description: Enable NpcBot system
+#        Default:   1 - enable
+#                   0 - disable
+
+NpcBot.Enable = 1
+
+#    NpcBot.MaxBots
+#        Description: Maximum number of bots allowed for players.
+#        Default:   1
+#        Recommend: 1-2
+#        Max:       4
+
+NpcBot.MaxBots = 1
+
+#    NpcBot.MaxBotsPerClass
+#        Description: Maximum bots of each class allowed for players.
+#        Default:   1
+#                   0 - no limit
+
+NpcBot.MaxBotsPerClass = 1
+
+#    NpcBot.BaseFollowDistance
+#        Description: Default bot follow distance.
+#        Note: This parameter determines bots' formation size, distance at which bots will chase and attack enemies.
+#        Note2: This parameter is set for each player at login.
+#        Default:   30
+
+NpcBot.BaseFollowDistance = 30
+
+#    NpcBot.XpReduction
+#        Description: XP percent penalty for each bot used starting with second.
+#        Example: 3 bots, xp reduction is 20: ((3-1)*20) = 40%, 60% exp gained only.
+#        Note: Maximum overall xp reduction is 90%.
+#        Default:   0
+
+NpcBot.XpReduction = 0
+
+#    NpcBot.HealTargetIconsMask
+#        Description: Icon number bitmask which bots use to search for additional targets to heal (out of party).
+#        Note: Many creatures cannot accept heal.
+#        Example: to check Star, Triangle and Square we need 1  8  32 = 41.
+#        Default:   0 (Disable)
+#                   1 - Star
+#                   2 - Circle
+#                   4 - Diamond
+#                   8 - Triangle
+#                   16 - Moon
+#                   32 - Square
+#                   64 - Cross
+#                   128 - Skull
+
+NpcBot.HealTargetIconsMask = 0
+
+#    NpcBot.Mult.Damage.Melee
+#    NpcBot.Mult.Damage.Spell
+#    NpcBot.Mult.Healing
+#        Description: Multipliers for bots' damage and healing. Allows to balance bots vs players.
+#        Minimum:   0.1
+#        Maximum:  10.0
+#        Default:   1.0
+
+NpcBot.Mult.Damage.Melee = 1.0
+NpcBot.Mult.Damage.Spell = 1.0
+NpcBot.Mult.Healing      = 1.0
+
+#    NpcBot.Enable.Dungeon
+#    NpcBot.Enable.Raid
+#    NpcBot.Enable.BG
+#    NpcBot.Enable.Arena
+#    NpcBot.Enable.DungeonFinder
+#        Description: Allow bots to enter PvE/PvP areas and Dungeon Finder query
+#        Default:   1 - (NpcBot.Enable.Dungeon)
+#                   0 - (NpcBot.Enable.Raid)
+#                   0 - (NpcBot.Enable.BG)
+#                   0 - (NpcBot.Enable.Arena)
+#                   1 - (NpcBot.Enable.DungeonFinder)
+
+NpcBot.Enable.Dungeon       = 1
+NpcBot.Enable.Raid          = 0
+NpcBot.Enable.BG            = 0
+NpcBot.Enable.Arena         = 0
+NpcBot.Enable.DungeonFinder = 1
+
+#    NpcBot.Limit.Dungeon
+#    NpcBot.Limit.Raid
+#        Description: Enable/Disable instance players limitation rules for bots.
+#        Default:   1 - (NpcBot.Limit.Dungeon)
+#                   1 - (NpcBot.Limit.Raid)
+
+NpcBot.Limit.Dungeon = 1
+NpcBot.Limit.Raid    = 1
+
+#    NpcBot.Cost
+#        Description: Bot recruitment cost (in copper).
+#        Note: This value is for level 80 characters.
+#              Cost is reduced for lower levels by simple formula: (cost * level / 80).
+#        Default:   1000000 (100 gold, 1g25s at level 1)
+
+NpcBot.Cost = 1000000
+
+#    NpcBot.PvP
+#        Description: Allow bots to attack player-controlled units (players, pets, bots, etc.)
+#        Note: This rule only applies to player-controlled bots
+#        Default:   1
+
+NpcBot.PvP = 1
+
+#
+###################################################################################################
\ No newline at end of file
-- 
1.7.10.4

