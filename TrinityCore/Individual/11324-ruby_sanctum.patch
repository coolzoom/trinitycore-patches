From c72dd2a356565090ffcff3e08dc482f959b0341e Mon Sep 17 00:00:00 2001
From: LordPsyan <uppp@juno.com>
Date: Mon, 28 Feb 2011 15:25:18 -0500
Subject: [PATCH] 11324-ruby_sanctum

---
 sql/CMakeLists.txt                                 |    1 +
 sql/extras/world_ruby_sanctum.sql                  |   74 ++
 src/server/scripts/Northrend/CMakeLists.txt        |    6 +
 .../Northrend/RubySanctum/boss_baltharus.cpp       |  367 +++++++++
 .../scripts/Northrend/RubySanctum/boss_halion.cpp  |  817 ++++++++++++++++++++
 .../Northrend/RubySanctum/boss_ragefire.cpp        |  192 +++++
 .../Northrend/RubySanctum/boss_zarithrian.cpp      |  231 ++++++
 .../RubySanctum/instance_ruby_sanctum.cpp          |  301 +++++++
 .../scripts/Northrend/RubySanctum/ruby_sanctum.h   |   74 ++
 9 files changed, 2063 insertions(+), 0 deletions(-)
 create mode 100644 sql/extras/world_ruby_sanctum.sql
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h

diff --git a/sql/CMakeLists.txt b/sql/CMakeLists.txt
index e1b0921..4562748 100644
--- a/sql/CMakeLists.txt
+++ b/sql/CMakeLists.txt
@@ -15,6 +15,7 @@ if( WITH_SQL )
       scripts
       base
       create
+	  All
     DESTINATION
       shared/trinity/sql
   )
diff --git a/sql/extras/world_ruby_sanctum.sql b/sql/extras/world_ruby_sanctum.sql
new file mode 100644
index 0000000..9915e87
--- /dev/null
+++ b/sql/extras/world_ruby_sanctum.sql
@@ -0,0 +1,74 @@
+DELETE FROM `script_texts` WHERE `entry` <= -1752008 AND `entry` >= -1752016;
+DELETE FROM `script_texts` WHERE `entry` <= -1752001 AND `entry` >= -1752006;
+DELETE FROM `script_texts` WHERE `entry` <= -1752017 AND `entry` >= -1752036;
+
+INSERT INTO `script_texts` (`entry`, `content_default`, `npc_entry`, `content_loc3`, `sound`, `type`, `language`) VALUES
+('-1752008', 'Help! I am trapped within this tree! I require aid!', '0', '', '17490', '1', '0'),        
+('-1752009', 'Thank you! I could not have held out for much longer.... A terrible thing has happened here.', '0', '', '17491', '1', '0'),       
+('-1752010', 'We believed the Sanctum was well-fortified, but we were not prepared for the nature of this assault.', '0', '', '17492', '0', '0'),       
+('-1752011', 'The Black dragonkin materialized from thin air, and set upon us before we could react.', '0', '', '17493', '0', '0'),     
+('-1752012', 'We did not stand a chance. As my brethren perished around me, I managed to retreat here and bar the entrance.', '0', '', '17494', '0', '0'),      
+('-1752013', 'They slaughtered us with cold efficiency, but the true focus of their interest seemed to be the eggs kept here in the Sanctum.', '0', '', '17495', '0', '0'),     
+('-1752014', 'The commander of the forces on the ground here is a cruel brute named Zarithrian, but I fear there are greater powers at work.', '0', '', '17496', '0', '0'),     
+('-1752015', 'In their initial assault, I caught a glimpse of their true leader, a fearsome full-grown twilight dragon.', '0', '', '17497', '0', '0'),  
+('-1752016', 'I know not the extent of their plans, heroes, but I know this: They cannot be allowed to succeed!', '0', '', '17498', '0', '0'),
+
+( -1752001, "Ah, the entertainment has arrived.", 0, "", 17520, 1, 0),
+( -1752002, "Baltharus leaves no survivors!", 0, "", 17521, 1, 0),
+( -1752003, "This world has enough heroes.", 0, "", 17522, 1, 0),
+( -1752004, "I..Didn''t saw...that coming...", 0, "", 17523, 1, 0),
+( -1752005, "Twice the pain and half the fun.", 0, "", 17524, 1, 0),
+( -1752006, "Your power wanes, ancient one.... Soon you will join your friends.", 0, "", 17525, 1, 0),
+
+( -1752017, "Alexstrasza has chosen capable allies... A pity that I must END YOU!", 0, "", 17512, 1, 0),
+( -1752018, "You thought you stood a chance?", 0, "", 17513, 1, 0),
+( -1752019, "It''s for the best.", 0, "", 17514, 1, 0),
+( -1752020, "HALION! I...", 0, "", 17515, 1, 0),
+( -1752021, "Turn them to ashes, minions!", 0, "", 17516, 1, 0),
+
+( -1752022, "You will sssuffer for this intrusion!", 0, "", 17528, 1, 0),
+( -1752023, "As it should be...", 0, "", 17529, 1, 0),
+( -1752024, "Halion will be pleased", 0, "", 17530, 1, 0),
+( -1752025, "Hhrr...Grr..", 0, "", 17531, 1, 0),
+( -1752026, "Burn in the master's flame!", 0, "", 17532, 1, 0),
+
+(-1752027, 'Insects! You''re too late. The Ruby Sanctum is lost.',NULL,NULL,17499,0,0),
+(-1752028, 'Your world teeters on the brink of annihilation. You will ALL bear witness to the coming of a new age of DESTRUCTION!',NULL,NULL,17500,0,0),
+(-1752029, 'Another hero falls.',NULL,NULL,17501,0,0),
+(-1752030, 'Hahahahaha.',NULL,NULL,17502,0,0),
+(-1752031, 'Relish this victory, mortals, for it will be your last! This world will burn with the master''s return!',NULL,NULL,17503,0,0),
+(-1752032, 'Not good enough.',NULL,NULL,17504,0,0),
+(-1752033, 'The heavens burn!',NULL,NULL,17505,0,0),
+(-1752034, 'Beware the shadow!',NULL,NULL,17506,0,0),
+(-1752035, 'You will find only suffering within the realm of twilight! Enter if you dare!',NULL,NULL,17507,0,0),
+(-1752036, 'I am the light and the darkness! Cower, mortals, before the herald of Deathwing!',NULL,NULL,17508,0,0);
+
+
+UPDATE `instance_template` SET `script`='instance_ruby_sanctum' WHERE (`map`='724');
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus' WHERE `entry` = '39751';
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus_summon' WHERE `entry` = '39899';
+UPDATE `creature_template` SET `ScriptName` = 'npc_xerestrasza' WHERE `entry` = '40429';
+UPDATE `creature_template` SET `ScriptName` = 'boss_zarithrian' WHERE `entry` = '39746';
+UPDATE `creature_template` SET `ScriptName` = 'boss_ragefire' WHERE `entry` = '39747';
+UPDATE `creature_template` SET `ScriptName` = 'boss_halion' WHERE `entry`= '39863';
+UPDATE `creature_template` SET `ScriptName` = 'boss_twilight_halion' WHERE `entry` = '40142';
+UPDATE `creature_template` SET `ScriptName` = 'npc_onyx_flamecaller' WHERE `entry` = '39814';
+UPDATE `creature_template` SET `ScriptName` = 'npc_meteor_strike', `flags_extra`=128 WHERE `entry` = '40041';
+UPDATE `creature_template` SET `ScriptName` = 'npc_meteor_flame', `flags_extra`=128 WHERE `entry` = '40042';
+UPDATE `creature_template` SET `ScriptName` = 'npc_spell_meteor_strike', `flags_extra`=128 WHERE `entry` = '40029';
+UPDATE `creature_template` SET `ScriptName` = 'npc_summon_halion', `flags_extra`=128 WHERE `entry` = '40044';
+
+
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger`='-74562') AND (`spell_effect`='74610');
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger`='-74792') AND (`spell_effect`='74800');
+INSERT INTO `spell_linked_spell` VALUES (-74562, 74610, 0, 'Fiery Combustion removed -> Combustion');
+INSERT INTO `spell_linked_spell` VALUES (-74792, 74800, 0, 'Soul Consumption removed -> Consumption');
+
+DELETE FROM `creature` WHERE `id`=39863 AND `map`=724;
+INSERT INTO `creature` VALUES (null,39863,724,15,65535,0,0,3144.93,527.233,72.8887,0.110395,604800,0,0,11156000,0,0,0,0,0,0);
+
+DELETE FROM `spell_script_names` WHERE `ScriptName`='spell_halion_portal';
+INSERT INTO `spell_script_names` VALUES (74812,'spell_halion_portal');
+
+UPDATE `gameobject_template` SET `data10`=74807 WHERE `entry`=202794;
+UPDATE `gameobject_template` SET `data10`=74812 WHERE `entry`=202796;
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
index 898fe59..9d99488 100644
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -174,6 +174,12 @@ set(scripts_STAT_SRCS
   Northrend/DraktharonKeep/drak_tharon_keep.h
   Northrend/DraktharonKeep/boss_tharon_ja.cpp
   Northrend/DraktharonKeep/boss_dred.cpp
+  Northrend/RubySanctum/boss_baltharus.cpp
+  Northrend/RubySanctum/boss_halion.cpp
+  Northrend/RubySanctum/boss_ragefire.cpp
+  Northrend/RubySanctum/boss_zarithrian.cpp
+  Northrend/RubySanctum/instance_ruby_sanctum.cpp
+  Northrend/RubySanctum/ruby_sanctum.h
 )
 
 message("  -> Prepared: Northrend")
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp b/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
new file mode 100644
index 0000000..17dc5c2
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
@@ -0,0 +1,367 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eScriptTexts
+{
+    SAY_AGGRO           = -1752001,
+    SAY_SLAY1           = -1752002,
+    SAY_SLAY2           = -1752003,
+    SAY_DEATH           = -1752004,
+    SAY_SUMMON_CLONE    = -1752005,
+
+    SAY_XERESTRASZA_1  = -1752008,
+    SAY_XERESTRASZA_2  = -1752009,
+    SAY_XERESTRASZA_3  = -1752010,
+    SAY_XERESTRASZA_4  = -1752011,
+    SAY_XERESTRASZA_5  = -1752012,
+    SAY_XERESTRASZA_6  = -1752013,
+    SAY_XERESTRASZA_7  = -1752014,
+    SAY_XERESTRASZA_8  = -1752015,
+    SAY_XERESTRASZA_9  = -1752016
+};
+
+enum eSpells
+{
+    SPELL_CLEAVE            = 40504,
+    SPELL_REPELLING_WAVE    = 74509,
+    SPELL_ENERVATING_BRAND  = 74502,
+    SPELL_BLADE_TEMPEST     = 75125,
+    SPELL_SUMMON_CLONE      = 74511
+};
+
+enum eEvents
+{
+    EVENT_CAST_CLEAVE           = 1,
+    EVENT_CAST_REPELLING_WAVE   = 2,
+    EVENT_CAST_ENERVATING_BRAND = 3,
+    EVENT_CAST_BLADE_TEMPEST    = 4,
+    EVENT_CAST_SUMMON_CLONE     = 5,
+    
+    ACTION_START_EVENT          = 6,
+    EVENT_XERESTRASZA_3         = 7,
+    EVENT_XERESTRASZA_4         = 8,
+    EVENT_XERESTRASZA_5         = 9,
+    EVENT_XERESTRASZA_6         = 10,
+    EVENT_XERESTRASZA_7         = 11,
+    EVENT_XERESTRASZA_8         = 12,
+    EVENT_XERESTRASZA_9         = 13,
+
+    EVENT_START_PHASE_TWO       = 14
+};
+
+enum ePhases
+{
+    PHASE_ALL = 0,
+    PHASE_1   = 1,
+    PHASE_2   = 2,
+
+    PHASE_1_MASK  = 1 << PHASE_1,
+    PHASE_2_MASK  = 1 << PHASE_2
+};
+
+Creature* pXerestrasza;
+
+class boss_baltharus : public CreatureScript
+{
+    public:
+        boss_baltharus() : CreatureScript("boss_baltharus") { }
+
+        struct boss_baltharusAI : public BossAI
+        {
+            boss_baltharusAI(Creature* pCreature) : BossAI(pCreature, DATA_BALTHARUS)
+            {
+                ASSERT(instance);
+            }
+
+            void Reset()
+            {
+                instance->SetBossState(DATA_BALTHARUS, NOT_STARTED);
+                events.Reset();
+                events.SetPhase(PHASE_1);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(7000,7500));
+            }
+
+            void EnterCombat(Unit*)
+            {
+                instance->SetBossState(DATA_BALTHARUS, IN_PROGRESS);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void JustSummoned(Creature *summon)
+            {
+                summons.Summon(summon);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustReachedHome()
+            {
+                summons.DespawnAll();
+                instance->SetData(DATA_BALTHARUS, FAIL);
+            }
+
+            void JustDied(Unit*)
+            {
+                DoScriptText(SAY_DEATH, me);
+                if (GameObject* flame = GetClosestGameObjectWithEntry(me, GO_FIRE_FIELD, 200.0f))
+                    flame->RemoveFromWorld();
+
+                if (instance->GetBossState(DATA_RAGEFIRE)==DONE)
+                {
+                   if (GameObject* flame = GetClosestGameObjectWithEntry(me, GO_FLAME_WALLS, 200.0f))
+                       flame->RemoveFromWorld();
+                }
+                pXerestrasza->AI()->DoAction(ACTION_START_EVENT);
+                _JustDied();
+                instance->SetData(DATA_BALTHARUS, DONE);
+                instance->SetBossState(DATA_BALTHARUS, DONE);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_CLEAVE:
+                            DoCastVictim(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                            break;
+                        case EVENT_START_PHASE_TWO:
+                            DoScriptText(SAY_SUMMON_CLONE, me);
+                            DoCast(SPELL_SUMMON_CLONE);
+                            DoCastAOE(SPELL_REPELLING_WAVE,true);
+                            break;
+                        case EVENT_CAST_ENERVATING_BRAND:
+                            DoCastVictim(SPELL_ENERVATING_BRAND, true);
+                            events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                            break;
+                        case EVENT_CAST_BLADE_TEMPEST:
+                            DoCastAOE(SPELL_BLADE_TEMPEST);
+                            events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(30000,35000));
+                            break;
+                    }
+                }
+
+                if (!(events.GetPhaseMask() & PHASE_2_MASK))
+                {
+                    if (me->GetHealth() <= ((me->GetMaxHealth() / 100) * 50))
+                    {
+                        events.SetPhase(PHASE_2);
+                        events.ScheduleEvent(EVENT_START_PHASE_TWO, 1000,0,PHASE_2);
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new boss_baltharusAI(pCreature);
+        }
+
+};
+
+class boss_baltharus_summon : public CreatureScript
+{
+    public:
+        boss_baltharus_summon() : CreatureScript("boss_baltharus_summon") { }
+
+        struct boss_baltharus_summonAI : public ScriptedAI
+        {
+            boss_baltharus_summonAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(20000,25000));
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_CLEAVE:
+                            DoCastVictim(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                            break;
+                        case EVENT_CAST_ENERVATING_BRAND:
+                            DoCastVictim(SPELL_ENERVATING_BRAND);
+                            events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                            break;
+                        case EVENT_CAST_BLADE_TEMPEST:
+                            DoCast(SPELL_BLADE_TEMPEST);
+                            events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(30000,45000));
+                            break;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new boss_baltharus_summonAI(pCreature);
+        }
+
+};
+
+class npc_xerestrasza : public CreatureScript
+{
+    public:
+        npc_xerestrasza() : CreatureScript("npc_xerestrasza") { }
+
+        struct npc_xerestraszaAI : public ScriptedAI
+        {
+            npc_xerestraszaAI(Creature *pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = me->GetInstanceScript();
+                pXerestrasza = me;
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                bIntro = false;
+                pInstance->SetData(DATA_XERESTRASZA,NOT_STARTED);
+            }
+
+            void MoveInLineOfSight(Unit*)
+            {
+                if (!bIntro)
+                {
+                    DoScriptText(SAY_XERESTRASZA_1, me);
+                    pInstance->SetData(DATA_XERESTRASZA,NOT_STARTED);
+                    bIntro = true;
+                }
+            }
+
+            void DoAction(const int32 action)
+            {
+                if (action == ACTION_START_EVENT)
+                {
+                    me->GetMotionMaster()->MovePoint(1, 3153.5490f, 385.53f, 86.33f);
+                    pInstance->SetData(DATA_XERESTRASZA,IN_PROGRESS);
+                    DoScriptText(SAY_XERESTRASZA_2, me);
+                    events.ScheduleEvent(EVENT_XERESTRASZA_3,9000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_4,20000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_5,31000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_6,42000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_7,53000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_8,64000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_9,75000); 
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_XERESTRASZA_3:
+                            DoScriptText(SAY_XERESTRASZA_3, me);
+                            break;
+                        case EVENT_XERESTRASZA_4:
+                            DoScriptText(SAY_XERESTRASZA_4, me);
+                            break;
+                        case EVENT_XERESTRASZA_5:
+                            DoScriptText(SAY_XERESTRASZA_5, me);
+                            break;
+                        case EVENT_XERESTRASZA_6:
+                            DoScriptText(SAY_XERESTRASZA_6, me);
+                            break;
+                        case EVENT_XERESTRASZA_7:
+                            DoScriptText(SAY_XERESTRASZA_7, me);
+                            break;
+                        case EVENT_XERESTRASZA_8:
+                            DoScriptText(SAY_XERESTRASZA_8, me);
+                            break;
+                        case EVENT_XERESTRASZA_9:
+                            DoScriptText(SAY_XERESTRASZA_9, me);
+                            pInstance->SetData(DATA_XERESTRASZA,DONE);
+                            pInstance->SetBossState(DATA_XERESTRASZA,DONE);
+                            break;
+                    }
+                }
+            }
+
+        private:
+            bool bIntro;
+            EventMap events;
+            InstanceScript* pInstance;
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_xerestraszaAI(pCreature);
+        }
+};
+
+
+void AddSC_boss_baltharus()
+{
+    new boss_baltharus();
+    new boss_baltharus_summon();
+    new npc_xerestrasza();
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp b/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
new file mode 100644
index 0000000..c2cab81
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
@@ -0,0 +1,817 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eTexts
+{
+    SAY_SPAWN       = -1752027,
+    SAY_AGGRO       = -1752028,
+    SAY_SLAY1       = -1752029,
+    SAY_SLAY2       = -1752030,
+    SAY_DEATH       = -1752031,
+    SAY_BERSERK     = -1752032,
+    SAY_SPECIAL1    = -1752033,
+    SAY_SPECIAL2    = -1752034,
+    SAY_PHASE2      = -1752035,
+    SAY_PHASE3      = -1752036
+};
+
+enum eSpells
+{
+    SPELL_FIRE_PILLAR               = 76006,
+    SPELL_FIERY_EXPLOSION           = 76010,
+    // All
+    SPELL_TWILIGHT_PRECISION        = 78243,
+    SPELL_CLEAVE                    = 74524,
+    SPELL_TAIL_LASH                 = 74531,
+    SPELL_BERSEK                    = 26662,
+    SPELL_TWILIGHT_DIVISION         = 75063,
+    SPELL_SUMMON_TWILIGHT_PORTAL    = 74809,
+
+    SPELL_METEOR_TARGET             = 74641,
+    SPELL_METEOR_STRIKE             = 74637,
+    SPELL_METEOR_DAMAGE             = 74648,
+    SPELL_METEOR_FLAME              = 74713,
+
+    // Halion
+    SPELL_FLAME_BREATH_10_NORMAL    = 74525,
+    SPELL_FLAME_BREATH_25_NORMAL    = 74526,
+    SPELL_FLAME_BREATH_10_HEROIC    = 74527,
+    SPELL_FLAME_BREATH_25_HEROIC    = 74528,
+    SPELL_FIERY_COMBUSTION          = 74562,
+
+    // Twilight Halion
+    SPELL_DUSK_SHROUD               = 75476,
+    SPELL_SOUL_CONSUMPTION          = 74792,
+    SPELL_DARK_BREATH_10_NORMAL     = 74806,
+    SPELL_DARK_BREATH_25_NORMAL     = 75954,
+    SPELL_DARK_BREATH_10_HEROIC     = 75955,
+    SPELL_DARK_BREATH_25_HEROIC     = 75956,
+
+    SPELL_AURE_TWILIGHT             = 74807
+};
+
+struct SpellsCorporeality
+{
+    uint32 SpellId1;
+    uint32 SpellId2;
+};
+
+static const SpellsCorporeality sCorporeality[11] =
+{
+    {74827, 74832},
+    {74828, 74833},
+    {74829, 74834},
+    {74830, 74835},
+    {74831, 74836},
+    {74832, 74827},
+    {74833, 74828},
+    {74834, 74829},
+    {74835, 74830},
+    {74836, 74831},
+    {74826, 74826}
+};
+
+enum eEvents
+{
+    EVENT_CAST_TWILIGHT_PRECISION   = 1,
+    EVENT_CAST_CLEAVE               = 2,
+    EVENT_CAST_FIERY_COMBUSTION     = 3,
+    EVENT_CAST_TAIL_LASH            = 4,
+    EVENT_CAST_FLAME_BREATH         = 5,
+    EVENT_CAST_DARK_BREATH          = 6,
+    EVENT_CAST_SOUL_CONSUMPTION     = 7,
+    EVENT_CAST_DUSK_SHROUD          = 8,
+    EVENT_FLAME_WALL                = 9,
+    EVENT_CAST_BERSEK               = 10,
+    EVENT_DPS                       = 11,
+    EVENT_METEOR_STRIKE             = 12,
+    EVENT_METEOR_DAMAGE             = 13,
+    EVENT_METEOR_FLAME              = 14,
+    EVENT_FIRE_PILLAR               = 15
+};
+
+enum ePhases
+{
+    PHASE_ALL = 0,
+    PHASE_1   = 1,
+    PHASE_2   = 2,
+    PHASE_3   = 3,
+
+    PHASE_1_MASK  = 1 << PHASE_1,
+    PHASE_2_MASK  = 1 << PHASE_2,
+    PHASE_3_MASK  = 1 << PHASE_3
+};
+
+Creature* pHalion;
+Creature* pTwilight;
+uint32 HalionDamage, TwilightDamage;
+uint32 HalionAura, TwilightAura;
+
+class boss_halion : public CreatureScript
+{
+    public:
+        boss_halion() : CreatureScript("boss_halion") { }
+
+        struct boss_halionAI : public BossAI
+        {
+            boss_halionAI(Creature *pCreature) : BossAI(pCreature, DATA_HALION)
+                {
+                    ASSERT(instance);
+                    pHalion = me;
+                }
+
+            void Reset()
+            {
+                if (instance->GetData(DATA_TWILIGHT_HALION)==IN_PROGRESS || instance->GetBossState(DATA_HALION)==IN_PROGRESS)
+                    return;
+
+                instance->SetBossState(DATA_HALION, NOT_STARTED);
+                events.Reset();
+                events.SetPhase(PHASE_1);
+                events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 1000);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(20000,25000));
+                events.ScheduleEvent(EVENT_CAST_FIERY_COMBUSTION, 15000);
+                events.ScheduleEvent(EVENT_METEOR_STRIKE, 20000);
+                events.ScheduleEvent(SPELL_BERSEK, 9999999);
+                PercentDamage = 0;
+                HalionDamage = 0;
+                HalionAura = 0;
+                RemoveAllGO();
+            }
+
+            void RemoveAllGO()
+            {
+                if (GameObject* flame1 = GetClosestGameObjectWithEntry(me, GO_FLAME_WALLS2, 100.0f))
+                    flame1->RemoveFromWorld();
+
+                if (GameObject* flame2 = GetClosestGameObjectWithEntry(me, GO_FLAME_WALLS3, 100.0f))
+                    flame2->RemoveFromWorld();
+
+                if (GameObject* portal1 = GetClosestGameObjectWithEntry(me, GO_TWILIGHT_PORTAL1, 100.0f))
+                    portal1->RemoveFromWorld();
+
+                if (GameObject* portal2 = GetClosestGameObjectWithEntry(me, GO_TWILIGHT_PORTAL2, 100.0f))
+                    portal2->RemoveFromWorld();
+            }
+
+            void MeteorStrike()
+            {
+                float x,y,z;
+                Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0);
+                if (pTarget)
+                {
+                    pTarget->GetPosition(x,y,z);
+                    me->SummonCreature(NPC_METEOR_STRIKE, x, y, z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 999999);
+                }
+            }
+
+            void EnterCombat(Unit*)
+            {
+                instance->SetBossState(DATA_HALION, IN_PROGRESS);
+                
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    return;
+                }
+                
+                events.ScheduleEvent(EVENT_FLAME_WALL, 3000,0,PHASE_1);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void CastCorporeality()
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                uint32 TotalDamage = HalionDamage+TwilightDamage;
+                if (TotalDamage > 0)
+                {
+                    PercentDamage = HalionDamage * 100 / TotalDamage;
+                }
+                else
+                {
+                    PercentDamage = 50;
+                }
+                HalionDamage = 0;
+                TwilightDamage = 0;
+                if (TwilightAura!=0)
+                {
+                    pTwilight->RemoveAurasDueToSpell(TwilightAura);
+                }
+                if (HalionAura!=0)
+                {
+                    pHalion->RemoveAurasDueToSpell(HalionAura);
+                }
+
+                uint8 idAura;
+                if (PercentDamage < 5)
+                {
+                    idAura = 9;
+                }
+                else if (PercentDamage < 15)
+                {
+                    idAura = 8;
+                }
+                else if (PercentDamage < 25)
+                {
+                    idAura = 7;
+                }
+                else if (PercentDamage < 35)
+                {
+                    idAura = 6;
+                }
+                else if (PercentDamage < 45)
+                {
+                    idAura = 5;
+                }
+                else if (PercentDamage < 55)
+                {
+                    idAura = 10;
+                }
+                else if (PercentDamage < 65)
+                {
+                    idAura = 0;
+                }
+                else if (PercentDamage < 75)
+                {
+                    idAura = 1;
+                }
+                else if (PercentDamage < 85)
+                {
+                    idAura = 2;
+                }
+                else if (PercentDamage < 95)
+                {
+                    idAura = 3;
+                }
+                else
+                {
+                    idAura = 4;
+                }
+                pHalion->CastSpell(pHalion, sCorporeality[idAura].SpellId1, true);
+                pTwilight->CastSpell(pTwilight, sCorporeality[idAura].SpellId2, true);
+                HalionAura=sCorporeality[idAura].SpellId1;
+                TwilightAura=sCorporeality[idAura].SpellId2;
+            }
+
+            void SetPhase3()
+            {
+                events.SetPhase(PHASE_3);
+                if (GameObject* portal = me->SummonGameObject(GO_TWILIGHT_PORTAL2, 3154.56f, 535.418f, 72.8889f, 4.47206f, 0, 0, 0.786772f, -0.617243f, 99999999))
+                {
+                    portal->SetPhaseMask(32,true);
+                    portal->SetRespawnTime(9999999);
+                }
+                events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                pHalion->SetHealth(pTwilight->GetHealth());
+            }
+
+            void DamageTaken(Unit* /*who*/, uint32 &dmg)
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                HalionDamage += dmg;    
+                
+                instance->SetData(DATA_DAMAGE, me->GetHealth() >= dmg ? me->GetHealth() - dmg : 0);
+            }
+
+            void JustSummoned(Creature *summon)
+            {
+                if (summon->GetEntry()==NPC_TWILIGHT_HALION)
+                {
+                    summon->SetPhaseMask(32,true);
+                    summons.Summon(summon);
+                }
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustReachedHome()
+            {
+                    instance->SetBossState(DATA_HALION,FAIL);
+                    RemoveAllGO();
+            }
+
+            void JustDied(Unit*)
+            {
+                _JustDied();
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+                RemoveAllGO();
+                DoScriptText(SAY_DEATH, me);
+                switch(instance->instance->GetDifficulty())
+                {
+                    case RAID_DIFFICULTY_10MAN_NORMAL:
+                        instance->DoCompleteAchievement(TWILIGHT_DESTROYER_NORMAL_10);
+                    case RAID_DIFFICULTY_10MAN_HEROIC:
+                        instance->DoCompleteAchievement(TWILIGHT_DESTROYER_HEROIC_10);
+                    case RAID_DIFFICULTY_25MAN_NORMAL:
+                        instance->DoCompleteAchievement(TWILIGHT_DESTROYER_NORMAL_25);
+                    case RAID_DIFFICULTY_25MAN_HEROIC:
+                        instance->DoCompleteAchievement(TWILIGHT_DESTROYER_HEROIC_25);
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (instance->GetBossState(DATA_ZARITHRIAN)!=DONE || instance->GetBossState(DATA_RAGEFIRE)!=DONE || instance->GetBossState(DATA_BALTHARUS)!=DONE)
+                {
+                    me->SetVisible(false);
+                    me->SetReactState(REACT_PASSIVE);
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                }
+                else 
+                {
+                    me->SetVisible(true);
+                    me->SetReactState(REACT_AGGRESSIVE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                }
+
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    if (instance->GetData(DATA_DAMAGE) > 0)
+                        me->SetHealth(instance->GetData(DATA_DAMAGE));
+                    else
+                        if (instance->GetData(DATA_TWILIGHT_HALION)==IN_PROGRESS)
+                            me->SetHealth(1);
+                }
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                if ((events.GetPhaseMask() & PHASE_1_MASK) || (events.GetPhaseMask() & PHASE_3_MASK))
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_TWILIGHT_PRECISION:
+                                DoCast(me, SPELL_TWILIGHT_PRECISION); // not working
+                                me->AddAura(SPELL_TWILIGHT_PRECISION, me); //test
+                                break;
+                            case EVENT_FLAME_WALL:
+                                if (GameObject* go_flame1 = me->SummonGameObject(GO_FLAME_WALLS2, 3154.56f, 535.418f, 72.8889f, 4.47206f, 0, 0, 0.786772f, -0.617243f, 999999))
+                                {
+                                    go_flame1->SetPhaseMask(1,true);
+                                }
+                                if (GameObject* go_flame2 = me->SummonGameObject(GO_FLAME_WALLS3, 3154.56f, 535.418f, 72.8889f, 4.47206f, 0, 0, 0.786772f, -0.617243f, 999999))
+                                {
+                                    go_flame2->SetPhaseMask(32,true);
+                                }
+                                break;
+                            case EVENT_CAST_TAIL_LASH:
+                                DoCast(SPELL_TAIL_LASH);
+                                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                                break;
+                            case EVENT_CAST_CLEAVE:
+                                DoCast(SPELL_CLEAVE);
+                                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                                break;
+                            case EVENT_METEOR_STRIKE:
+                                MeteorStrike();
+                                events.ScheduleEvent(EVENT_METEOR_STRIKE, 20000);
+                                break;
+                            case EVENT_CAST_FLAME_BREATH:
+                                DoCast(RAID_MODE(SPELL_FLAME_BREATH_10_NORMAL, SPELL_FLAME_BREATH_25_NORMAL, SPELL_FLAME_BREATH_10_HEROIC, SPELL_FLAME_BREATH_25_HEROIC));
+                                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(20000,25000));break;
+                            case EVENT_DPS:
+                                CastCorporeality();
+                                events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                                break;
+                            case EVENT_CAST_FIERY_COMBUSTION:
+                                Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0);
+                                if (pTarget && !pTarget->HasAura(SPELL_FIERY_COMBUSTION))
+                                    DoCast(pTarget, SPELL_FIERY_COMBUSTION);
+                                events.ScheduleEvent(EVENT_CAST_FIERY_COMBUSTION, 15000);
+                                break;
+                        }
+                    }
+                }
+
+               /* if ((events.GetPhaseMask() & PHASE_1_MASK) && me->HealthBelowPct(75))
+                {
+                    events.SetPhase(PHASE_2);
+                    instance->SetBossState(DATA_HALION, SPECIAL);
+                    DoScriptText(SAY_PHASE2, me);
+                    DoCast(me, SPELL_SUMMON_TWILIGHT_PORTAL);
+                    DoCast(me, SPELL_TWILIGHT_DIVISION);
+                    me->SummonCreature(NPC_TWILIGHT_HALION,SpawnPosHalion);
+                    me->SetReactState(REACT_PASSIVE);
+                    me->AttackStop();
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    me->SetVisible(false);
+                }*/
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            uint32 PercentDamage;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+                return new boss_halionAI(pCreature);
+        }
+
+};
+
+class boss_twilight_halion : public CreatureScript
+{
+    public:
+        boss_twilight_halion() : CreatureScript("boss_twilight_halion") { }
+
+        struct boss_twilight_halionAI : public ScriptedAI
+        {
+            boss_twilight_halionAI(Creature *pCreature) : ScriptedAI(pCreature)
+                {
+                    pInstance = me->GetInstanceScript();
+                    pTwilight = me;
+                }
+
+            void Reset()
+            {
+                if (pInstance->GetBossState(DATA_HALION)!=SPECIAL)
+                    return;
+                me->SetReactState(REACT_AGGRESSIVE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                events.Reset();
+                events.SetPhase(PHASE_2);
+                events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 1000);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                events.ScheduleEvent(EVENT_CAST_DUSK_SHROUD, urand(15000,20000));
+                events.ScheduleEvent(EVENT_CAST_DARK_BREATH, urand(20000,25000));
+                events.ScheduleEvent(EVENT_CAST_SOUL_CONSUMPTION, urand(15000,25000));
+                events.ScheduleEvent(EVENT_CAST_BERSEK, 9999999);
+                me->SetMaxHealth(pHalion->GetMaxHealth());
+                TwilightDamage = 0;
+            }
+
+            void EnterCombat(Unit*)
+            {
+                me->SetHealth(pHalion->GetHealth());
+                pInstance->SetData(DATA_TWILIGHT_HALION,IN_PROGRESS);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    if (pInstance->GetData(DATA_DAMAGE) != 0)
+                        me->SetHealth(pInstance->GetData(DATA_DAMAGE));
+                    else
+                        me->SetHealth(1);
+                }
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_TWILIGHT_PRECISION:
+                            DoCast(me, SPELL_TWILIGHT_PRECISION);
+                            break;
+                        case EVENT_CAST_TAIL_LASH:
+                            DoCast(SPELL_TAIL_LASH);
+                            events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                            break;
+                        case EVENT_CAST_DARK_BREATH:
+                            DoCast(RAID_MODE(SPELL_DARK_BREATH_10_NORMAL, SPELL_DARK_BREATH_25_NORMAL, SPELL_DARK_BREATH_10_HEROIC, SPELL_DARK_BREATH_25_HEROIC));
+                            events.ScheduleEvent(EVENT_CAST_DARK_BREATH, urand(20000,25000));break;
+                        case EVENT_CAST_CLEAVE:
+                            DoCast(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                            break;
+                        case EVENT_CAST_DUSK_SHROUD:
+                            DoCastAOE(SPELL_DUSK_SHROUD,true);
+                            events.ScheduleEvent(EVENT_CAST_DUSK_SHROUD, urand(15000,20000));
+                            break;
+                        case EVENT_CAST_SOUL_CONSUMPTION:
+                            DoCast(SPELL_SOUL_CONSUMPTION);
+                            events.ScheduleEvent(EVENT_CAST_SOUL_CONSUMPTION, urand(15000,25000));
+                            break;
+                        case EVENT_CAST_BERSEK:
+                            DoCast(me, SPELL_BERSEK);
+                            events.ScheduleEvent(EVENT_CAST_BERSEK, 9999999);
+                            break;
+                        case EVENT_DPS:
+                            if (pInstance->GetBossState(DATA_HALION)==SPECIAL)
+                                CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->CastCorporeality();
+                            events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                            break;
+                    }
+                }
+
+                if ((events.GetPhaseMask() & PHASE_2_MASK) && me->HealthBelowPct(50))
+                {
+                    pInstance->SetData(DATA_DAMAGE, me->GetHealth());
+                    events.SetPhase(PHASE_3);
+                    DoScriptText(SAY_PHASE3, me);
+                    pHalion->SetReactState(REACT_AGGRESSIVE);
+                    pHalion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    pHalion->SetVisible(true);
+                    CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->SetPhase3();
+                    events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+            void DamageTaken(Unit* /*who*/, uint32 &dmg)
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                TwilightDamage += dmg;    
+
+                pInstance->SetData(DATA_DAMAGE, me->GetHealth() >= dmg ? me->GetHealth() - dmg : 0);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustReachedHome()
+            {
+                pInstance->SetData(DATA_TWILIGHT_HALION, FAIL);
+                if (pInstance->GetBossState(DATA_HALION)==SPECIAL)
+                    pInstance->SetBossState(DATA_HALION,FAIL);
+                CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->Reset();
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+                me->ForcedDespawn(10);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+            }
+
+            void JustDied(Unit*)
+            {
+                pInstance->SetData(DATA_TWILIGHT_HALION,DONE);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+            }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+                return new boss_twilight_halionAI(pCreature);
+        }
+
+};
+
+class spell_halion_portal : public SpellScriptLoader
+{
+    public:
+        spell_halion_portal() : SpellScriptLoader("spell_halion_portal") { }
+
+        class spell_halion_portal_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_halion_portal_SpellScript)
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                PreventHitDefaultEffect(EFFECT_0);
+                GetHitPlayer()->RemoveAurasDueToSpell(SPELL_AURE_TWILIGHT);
+                GetHitPlayer()->SetPhaseMask(1,true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_halion_portal_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_APPLY_AURA);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_portal_SpellScript();
+        }
+};
+
+class npc_meteor_strike : public CreatureScript
+{
+    public:
+        npc_meteor_strike() : CreatureScript("npc_meteor_strike") { }
+
+        struct npc_meteor_strikeAI : public ScriptedAI
+        {
+            npc_meteor_strikeAI(Creature *pCreature) : ScriptedAI(pCreature){ }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                DoCast(me, SPELL_METEOR_STRIKE);
+                events.Reset();
+                events.ScheduleEvent(EVENT_METEOR_DAMAGE, 7000);
+                events.ScheduleEvent(EVENT_METEOR_STRIKE, 1000);
+                me->ForcedDespawn(15000);
+                angle = (float)(urand(0,62)/10);
+                dist = 0;
+                count = 0;
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_METEOR_STRIKE:
+                            DoCastAOE(SPELL_METEOR_TARGET);
+                            break;
+                        case EVENT_METEOR_DAMAGE:
+                            DoCastAOE(SPELL_METEOR_DAMAGE);
+                            events.ScheduleEvent(EVENT_METEOR_FLAME, 1000);
+                            break;
+                        case EVENT_METEOR_FLAME:
+                            float x, y;
+                            dist += 5;
+                            count ++;
+                            me->GetNearPoint2D(x, y, dist, angle);
+                            me->SummonCreature(NPC_METEOR_FLAME,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            me->GetNearPoint2D(x, y, dist, angle+M_PI);
+                            me->SummonCreature(NPC_METEOR_FLAME,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            me->GetNearPoint2D(x, y, dist, angle+3*M_PI/2);
+                            me->SummonCreature(NPC_METEOR_FLAME,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            me->GetNearPoint2D(x, y, dist, angle+M_PI/2);
+                            me->SummonCreature(NPC_METEOR_FLAME,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            if (count < 8)
+                                events.ScheduleEvent(EVENT_METEOR_FLAME, 1000);
+                            break;
+                    }
+                }
+            }
+
+        private:
+            EventMap events;
+            float dist, angle;
+            uint8 count;
+
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_meteor_strikeAI(pCreature);
+        }
+};
+
+class npc_spell_meteor_strike : public CreatureScript
+{
+    public:
+        npc_spell_meteor_strike() : CreatureScript("npc_spell_meteor_strike") { }
+
+        struct npc_spell_meteor_strikeAI : public ScriptedAI
+        {
+            npc_spell_meteor_strikeAI(Creature *pCreature) : ScriptedAI(pCreature){ }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                me->ForcedDespawn(10000);
+            }
+
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_spell_meteor_strikeAI(pCreature);
+        }
+};
+
+class npc_meteor_flame : public CreatureScript
+{
+    public:
+        npc_meteor_flame() : CreatureScript("npc_meteor_flame") { }
+
+        struct npc_meteor_flameAI : public ScriptedAI
+        {
+            npc_meteor_flameAI(Creature *pCreature) : ScriptedAI(pCreature){ }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                DoCast(me,SPELL_METEOR_FLAME);
+ 
+                me->ForcedDespawn(10000);
+            }
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_meteor_flameAI(pCreature);
+        }
+};
+
+class npc_summon_halion : public CreatureScript
+{
+    public:
+        npc_summon_halion() : CreatureScript("npc_summon_halion") { }
+
+        struct npc_summon_halionAI : public ScriptedAI
+        {
+            npc_summon_halionAI(Creature *pCreature) : ScriptedAI(pCreature)
+            { 
+                pInstance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                events.Reset();
+                events.ScheduleEvent(EVENT_FIRE_PILLAR, 10000);
+                DoCast(me,SPELL_FIRE_PILLAR);
+ 
+                me->ForcedDespawn(20000);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_FIRE_PILLAR:
+                            Creature *pHalion = pInstance->instance->GetCreature(pInstance->GetData64(DATA_HALION));
+                            if(pHalion)
+                            {
+                                DoCastAOE(SPELL_FIERY_EXPLOSION);
+                                pHalion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                pHalion->SetVisible(true);
+                                pHalion->SetReactState(REACT_AGGRESSIVE);
+                            }
+                            break;
+                    }
+                }
+            }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_summon_halionAI(pCreature);
+        }
+};
+
+void AddSC_boss_halion()
+{
+    new boss_halion();
+    new boss_twilight_halion();
+    new spell_halion_portal();
+    new npc_meteor_strike();
+    new npc_spell_meteor_strike();
+    new npc_meteor_flame();
+    new npc_summon_halion();
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp b/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
new file mode 100644
index 0000000..e829eb6
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
@@ -0,0 +1,192 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eScriptTexts
+{
+    SAY_AGGRO           = -1752022,
+    SAY_SLAY1           = -1752023,
+    SAY_SLAY2           = -1752024,
+    SAY_DEATH           = -1752025
+};
+
+enum eSpells
+{
+    SPELL_CONFLAGRATION     = 74456,
+    SPELL_ENRAGE            = 78722,
+    SPELL_FLAME_BREATH_10   = 74403,
+    SPELL_FLAME_BREATH_25   = 74404,
+    SPELL_FLAME_BEACON      = 74453
+};
+
+enum eEvents
+{
+    EVENT_CAST_CONFLAGRATION      = 1,
+    EVENT_CAST_ENRAGE             = 2,
+    EVENT_CAST_FLAME_BREATH       = 3,
+    EVENT_CAST_FLAME_BEACON       = 4,
+    EVENT_CAST_CONFLAGRATION_FLY  = 5,
+    EVENT_CAST_CONFLAGRATION_CAST = 6
+};
+
+#define TARGETS_10 2
+#define TARGETS_25 5
+
+class boss_ragefire : public CreatureScript
+{
+    public:
+        boss_ragefire() : CreatureScript("boss_ragefire") { }
+
+        struct boss_ragefireAI : public BossAI
+        {
+            boss_ragefireAI(Creature *pCreature) : BossAI(pCreature, DATA_RAGEFIRE)
+            {
+                ASSERT(instance);
+                me->SetUnitMovementFlags(MOVEMENTFLAG_CAN_FLY);
+            }
+
+            void Reset()
+            {
+                instance->SetBossState(DATA_RAGEFIRE, NOT_STARTED);
+                playerList.clear();
+                bConflagration = false;
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION, urand(45000,55000));
+                events.ScheduleEvent(EVENT_CAST_ENRAGE, urand(25000,35000));
+                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(10000,15000));
+            }
+
+            void EnterCombat(Unit*)
+            {
+                instance->SetBossState(DATA_RAGEFIRE, IN_PROGRESS);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustDied(Unit*)
+            {
+                _JustDied();
+                DoScriptText(SAY_DEATH, me);
+                instance->SetData(DATA_RAGEFIRE, DONE);
+                instance->SetBossState(DATA_RAGEFIRE, DONE);
+                if (instance->GetBossState(DATA_BALTHARUS)==DONE)
+                {
+                   if (GameObject* flame = GetClosestGameObjectWithEntry(me, GO_FLAME_WALLS, 200.0f))
+                       flame->RemoveFromWorld();
+                }
+            }
+
+            void JustReachedHome()
+            {
+                instance->SetBossState(DATA_RAGEFIRE, FAIL);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                if (!bConflagration)
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_CONFLAGRATION:
+                                bConflagration = true;
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION_FLY, 1000);
+                                break;
+                            case EVENT_CAST_ENRAGE:
+                                DoCast(SPELL_ENRAGE);
+                                events.ScheduleEvent(EVENT_CAST_ENRAGE, urand(25000,35000));
+                                break;
+                            case EVENT_CAST_FLAME_BREATH:
+                                DoCast(RAID_MODE(SPELL_FLAME_BREATH_10,SPELL_FLAME_BREATH_25,SPELL_FLAME_BREATH_10,SPELL_FLAME_BREATH_25));
+                                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(10000,15000));
+                                break;
+                        }
+                    }
+                }
+                else
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_CONFLAGRATION_FLY:
+                                me->GetMotionMaster()->MovePoint(1, (float)3159.04, (float)676.08, (float)103.05);
+                                SelectTargetList(playerList, RAID_MODE(TARGETS_10,TARGETS_25,TARGETS_10,TARGETS_25), SELECT_TARGET_RANDOM, 0, true);
+                                for (std::list<Unit*>::const_iterator itr = playerList.begin(); itr != playerList.end(); ++itr)
+                                {
+                                    Unit *pTemp = (*itr);
+                                    me->CastSpell(pTemp, SPELL_FLAME_BEACON, true);
+                                }
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION_CAST, 5000);
+                                break;
+                            case EVENT_CAST_CONFLAGRATION_CAST:
+                                for (std::list<Unit*>::const_iterator itr = playerList.begin(); itr != playerList.end(); ++itr)
+                                {
+                                    Unit *pTemp = (*itr);
+                                    me->CastSpell(pTemp, SPELL_CONFLAGRATION, true);
+                                }
+                                playerList.clear();
+                                me->GetMotionMaster()->MoveTargetedHome();
+                                bConflagration = false;
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION, urand(45000,55000));
+                                break;
+                        }
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            bool bConflagration;
+            std::list<Unit *> playerList;
+
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new boss_ragefireAI(pCreature);
+        }
+
+};
+
+
+void AddSC_boss_ragefire()
+{
+    new boss_ragefire();
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp b/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
new file mode 100644
index 0000000..ca4bb18
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
@@ -0,0 +1,231 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eTexts
+{
+    SAY_AGGRO = -1752017,
+    SAY_SLAY1 = -1752018,
+    SAY_SLAY2 = -1752019,
+    SAY_DEATH = -1752020
+};
+
+enum eSpells
+{
+    SPELL_CLEAVE_ARMOR          = 74367,
+    SPELL_INTIMIDATING_ROAR     = 74384,
+    SPELL_SUMMON_FLAMECALLER    = 74398,
+
+    SPELL_BLAST_NOVA_10         = 74392,
+    SPELL_BLAST_NOVA_25         = 74393,
+    SPELL_LAVA_GOUT_10          = 74394,
+    SPELL_LAVA_GOUT_25          = 74395
+};
+
+enum eEvents
+{
+    EVENT_CAST_CLEAVE_ARMOR         = 1,
+    EVENT_CAST_INTIMIDATING_ROAR    = 2,
+    EVENT_CAST_SUMMON_FLAMECALLER   = 3,
+
+    EVENT_CAST_BLAST_NOVA           = 4,
+    EVENT_CAST_LAVA_GOUT            = 5,
+    EVENT_MOVE_TO_RANDOM_PLAYER     = 6
+};
+
+static const Position SpawnPos[4] =
+{
+    {3022.67f, 479.01f, 89.23f, 2.38f},
+    {3016.55f, 510.26f, 90.03f, 0.89f},
+    {3039.37f, 590.13f, 87.90f, 3.74f},
+    {3018.86f, 549.40f, 89.25f, 5.23f}
+};
+
+Creature* pZarithrian;
+
+class boss_zarithrian : public CreatureScript
+{
+    public:
+        boss_zarithrian() : CreatureScript("boss_zarithrian") { }
+
+        struct boss_zarithrianAI : public BossAI
+        {
+            boss_zarithrianAI(Creature *pCreature) : BossAI(pCreature, DATA_ZARITHRIAN)
+            {
+                ASSERT(instance);
+                pZarithrian = me;
+            }
+
+            void Reset()
+            {
+                instance->SetBossState(DATA_ZARITHRIAN, NOT_STARTED);
+                events.Reset();
+                summons.DespawnAll();
+                summons.clear();
+                events.ScheduleEvent(EVENT_CAST_CLEAVE_ARMOR, urand(3500,4500));
+                events.ScheduleEvent(EVENT_CAST_INTIMIDATING_ROAR, urand(10000,11000));
+                events.ScheduleEvent(EVENT_CAST_SUMMON_FLAMECALLER, urand(40000,50000));
+            }
+
+            void EnterCombat(Unit*)
+            {
+                instance->SetBossState(DATA_ZARITHRIAN, IN_PROGRESS);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustSummoned(Creature *summon)
+            {
+                summons.Summon(summon);
+            }
+
+            void JustReachedHome()
+            {
+                summons.DespawnAll();
+                instance->SetData(DATA_ZARITHRIAN, FAIL);
+            }
+
+            void JustDied(Unit*)
+            {
+                _JustDied();
+                instance->SetBossState(DATA_ZARITHRIAN, DONE);
+                instance->SetData(DATA_ZARITHRIAN, DONE);
+                DoScriptText(SAY_DEATH, me);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_CLEAVE_ARMOR:
+                            DoCastVictim(SPELL_CLEAVE_ARMOR);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE_ARMOR, urand(3500,4500));
+                            break;
+                        case EVENT_CAST_INTIMIDATING_ROAR:
+                            DoCastAOE(SPELL_INTIMIDATING_ROAR);
+                            events.ScheduleEvent(EVENT_CAST_INTIMIDATING_ROAR, urand(10000,11000));
+                            break;
+                        case EVENT_CAST_SUMMON_FLAMECALLER:
+                            if (Creature* pCreature1 = me->SummonCreature(NPC_ONYX_FLAMECALLER,SpawnPos[0]))
+                            {
+                                pCreature1->GetMotionMaster()->MovePoint(1,SpawnPos[1]);
+                            }
+                            if (Creature* pCreature2 = me->SummonCreature(NPC_ONYX_FLAMECALLER,SpawnPos[2]))
+                            {
+                                pCreature2->GetMotionMaster()->MovePoint(1,SpawnPos[3]);
+                            }
+                            events.ScheduleEvent(EVENT_CAST_SUMMON_FLAMECALLER, urand(40000,50000));
+                            break;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new boss_zarithrianAI(pCreature);
+        }
+
+};
+
+class npc_onyx_flamecaller : public CreatureScript
+{
+    public:
+        npc_onyx_flamecaller() : CreatureScript("npc_onyx_flamecaller") { }
+
+        struct npc_onyx_flamecallerAI : public ScriptedAI
+        {
+            npc_onyx_flamecallerAI(Creature *pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                events.ScheduleEvent(EVENT_MOVE_TO_RANDOM_PLAYER, 3000);
+                events.ScheduleEvent(EVENT_CAST_BLAST_NOVA, urand(15000,25000));
+                events.ScheduleEvent(EVENT_CAST_LAVA_GOUT, urand(30000,35000));
+            }
+
+             void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_MOVE_TO_RANDOM_PLAYER:
+                            if (pZarithrian)
+                            {
+                                me->GetMotionMaster()->MovePoint(2,pZarithrian->GetPositionX(),pZarithrian->GetPositionY(),pZarithrian->GetPositionZ());
+                             }
+                            break;
+                        case EVENT_CAST_BLAST_NOVA:
+                            DoCast(RAID_MODE(SPELL_BLAST_NOVA_10,SPELL_BLAST_NOVA_25,SPELL_BLAST_NOVA_10,SPELL_BLAST_NOVA_25));
+                            events.ScheduleEvent(EVENT_CAST_BLAST_NOVA, urand(15000,25000));
+                            break;
+                        case EVENT_CAST_LAVA_GOUT:
+                            DoCast(RAID_MODE(SPELL_LAVA_GOUT_10,SPELL_LAVA_GOUT_25,SPELL_LAVA_GOUT_10,SPELL_LAVA_GOUT_25));
+                            events.ScheduleEvent(EVENT_CAST_LAVA_GOUT, urand(30000,35000));
+                            break;
+                    }
+                }
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_onyx_flamecallerAI(pCreature);
+        }
+};
+
+void AddSC_boss_zarithrian()
+{
+    new boss_zarithrian();
+    new npc_onyx_flamecaller();
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp b/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
new file mode 100644
index 0000000..41b3afd
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
@@ -0,0 +1,301 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+static const DoorData doorData[5] =
+{
+    {GO_FIRE_FIELD,   DATA_BALTHARUS,       DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS,  DATA_BALTHARUS,       DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS,  DATA_RAGEFIRE,        DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS,  DATA_ZARITHRIAN,      DOOR_TYPE_ROOM,    BOUNDARY_N   },
+    {0,               0,                    DOOR_TYPE_ROOM,    BOUNDARY_NONE}
+};
+
+class instance_ruby_sanctum : public InstanceMapScript
+{
+    public:
+        instance_ruby_sanctum() : InstanceMapScript("instance_ruby_sanctum", 724) { }
+
+        struct instance_ruby_sanctum_InstanceMapScript : public InstanceScript
+        {
+            instance_ruby_sanctum_InstanceMapScript(Map *pMap) : InstanceScript(pMap)
+            {
+                SetBossNumber(MAX_ENCOUNTER);
+                LoadDoorData(doorData);
+
+                m_uiDataDamage = 0;
+
+                m_uiXerestrasza = 0;
+                m_uiTwilightHalion = 0;
+
+                m_uiHalionPortalGUID = 0;
+                m_uiTwilightPortalGUID = 0;
+                m_uiBaltharusGUID = 0;
+                m_uiZarithrianGUID = 0;
+                m_uiRagefireGUID = 0;
+                m_uiHalionGUID = 0;
+                m_uiXerestraszaGUID = 0;
+                m_uiTwilightHalionGUID = 0;
+                m_uiGOFlameWallsGUID = 0;
+                m_uiGOTwilightWallsGUID = 0;
+            }
+
+            void OnCreatureCreate(Creature *pCreature)
+            {
+                switch(pCreature->GetEntry())
+                {
+                    case NPC_BALTHARUS: {    m_uiBaltharusGUID = pCreature->GetGUID();   break;}
+                    case NPC_RAGEFIRE:  {    m_uiRagefireGUID = pCreature->GetGUID();    break;}
+                    case NPC_XERESTRASZA: {  m_uiXerestraszaGUID = pCreature->GetGUID(); break;}
+                    case NPC_ZARITHRIAN:
+                    {
+                        m_uiZarithrianGUID = pCreature->GetGUID();
+                        if (GetBossState(DATA_RAGEFIRE)==DONE && GetBossState(DATA_BALTHARUS)==DONE)
+                        {
+                            pCreature->SetReactState(REACT_AGGRESSIVE);
+                            pCreature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
+                        else
+                        {
+                            pCreature->SetReactState(REACT_PASSIVE);
+                            pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
+                        break;
+                    }
+                    case NPC_HALION:
+                    {
+                        m_uiHalionGUID = pCreature->GetGUID();
+                        if (GetBossState(DATA_ZARITHRIAN)==DONE && GetBossState(DATA_RAGEFIRE)==DONE && GetBossState(DATA_BALTHARUS)==DONE)
+                        {
+                            pCreature->SetVisible(true);
+                            pCreature->SetReactState(REACT_AGGRESSIVE);
+                            pCreature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
+                        else
+                        {
+                            pCreature->SetVisible(false);
+                            pCreature->SetReactState(REACT_PASSIVE);
+                            pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
+                        break;
+                    }
+                    case NPC_TWILIGHT_HALION:{ m_uiTwilightHalionGUID = pCreature->GetGUID(); break;}
+                    default:
+                        break;
+                }
+            }
+
+            void OnGameObjectCreate(GameObject* pGo, bool add)
+            {
+                switch (pGo->GetEntry())
+                {
+                    case GO_FIRE_FIELD:
+                    case GO_FLAME_WALLS:
+                    //case GO_FLAME_WALLS2:
+                        AddDoor(pGo, add);
+                        break;
+                    case GO_TWILIGHT_PORTAL1: m_uiHalionPortalGUID = pGo->GetGUID(); break;
+                    case GO_TWILIGHT_PORTAL2: m_uiTwilightPortalGUID = pGo->GetGUID(); break;
+                    case GO_FLAME_WALLS2:     m_uiGOFlameWallsGUID = pGo->GetGUID(); break;
+                    case GO_FLAME_WALLS3:     m_uiGOTwilightWallsGUID = pGo->GetGUID(); break;
+                    default: break;
+                }
+            }
+
+            void SetData(uint32 uiType, uint32 uiData)
+            {
+                switch(uiType)
+                {
+                    case DATA_XERESTRASZA:     m_uiXerestrasza    = uiData; break;
+                    case DATA_TWILIGHT_HALION: m_uiTwilightHalion = uiData; break;
+                    case DATA_DAMAGE:          m_uiDataDamage     = uiData; break;   
+                }
+            }
+
+            uint32 GetData(uint32 uiType)
+            {
+                switch(uiType)
+                {
+                    case DATA_XERESTRASZA:     return m_uiXerestrasza;    break;
+                    case DATA_TWILIGHT_HALION: return m_uiTwilightHalion; break;
+                    case DATA_DAMAGE:          return m_uiDataDamage;     break;
+                }
+                return 0;
+            }
+
+            void BossZarithrian()
+            {
+                if (Creature* Zarithrian = instance->GetCreature(GetData64(DATA_ZARITHRIAN)))
+                {
+                    Zarithrian->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    Zarithrian->SetReactState(REACT_AGGRESSIVE);
+                }
+            }
+
+            bool SetBossState(uint32 type, EncounterState state)
+            {
+                if (!InstanceScript::SetBossState(type, state))
+                    return false;
+
+                switch (type)
+                {
+                    case DATA_BALTHARUS:
+                    {
+                        if (state==DONE)
+                        {
+                            if (GetBossState(DATA_RAGEFIRE)==DONE)
+                            {
+                                BossZarithrian();
+                            }
+                        }
+                        break;
+                    }
+                    case DATA_RAGEFIRE: 
+                    {
+                        if (state==DONE)
+                        {
+                            if (GetBossState(DATA_BALTHARUS)==DONE)
+                            {
+                                BossZarithrian();
+                            }
+                        }
+                        break;
+                    }
+                    case DATA_ZARITHRIAN:
+                    {
+                        if (GetBossState(DATA_BALTHARUS)==DONE && GetBossState(DATA_RAGEFIRE)==DONE)
+                        {
+                            if (state==DONE)
+                            {
+                                if (Creature* halion = instance->GetCreature(GetData64(DATA_HALION)))
+                                {
+                                    halion->SummonCreature(NPC_SUMMON_HALIOH,SpawnPosHalion,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,20000);
+                                }
+                            }
+                        }
+                        break;
+                    }
+                    case DATA_HALION:
+                    {
+						if (Creature* halion = instance->GetCreature(GetData64(DATA_HALION)))
+						{
+                        if (GetBossState(DATA_ZARITHRIAN)==DONE && GetBossState(DATA_RAGEFIRE)==DONE && GetBossState(DATA_BALTHARUS)==DONE)
+                        {
+                            halion->SetVisible(true);
+                            halion->SetReactState(REACT_AGGRESSIVE);
+                            halion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
+                        else
+                        {
+                            halion->SetVisible(false);
+                            halion->SetReactState(REACT_PASSIVE);
+                            halion->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
+						}
+						break;
+                    }
+                    default:
+                        break;
+                }
+
+                return true;
+            }
+
+            uint64 GetData64(uint32 uiData)
+            {
+                switch(uiData)
+                {
+                    case DATA_BALTHARUS:       return m_uiBaltharusGUID;      break;
+                    case DATA_ZARITHRIAN:      return m_uiZarithrianGUID;     break;
+                    case DATA_RAGEFIRE:        return m_uiRagefireGUID;       break;
+                    case DATA_HALION:          return m_uiHalionGUID;         break;
+                    case DATA_TWILIGHT_HALION: return m_uiTwilightHalionGUID; break;
+                    case DATA_XERESTRASZA:     return m_uiXerestraszaGUID;    break;
+                    case GO_TWILIGHT_PORTAL1:  return m_uiHalionPortalGUID;   break;
+                    case GO_TWILIGHT_PORTAL2:  return m_uiTwilightPortalGUID; break;
+                    case GO_FLAME_WALLS2:      return m_uiGOFlameWallsGUID;   break; 
+                    case GO_FLAME_WALLS3:      return m_uiGOTwilightWallsGUID;   break; 
+                    default: break;
+                }
+                return 0;
+            }
+
+            std::string GetSaveData()
+            {
+                std::ostringstream saveStream;
+                saveStream << GetBossSaveData() << " " << m_uiXerestrasza;
+                return saveStream.str();
+            }
+
+            void Load(const char* strIn)
+            {
+                if (!strIn)
+                {
+                    return;
+                }
+
+                std::istringstream loadStream(strIn);
+
+                uint32 tmpState;
+                
+                for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+                {
+                    loadStream >> tmpState;
+                    if (tmpState == IN_PROGRESS || tmpState > SPECIAL)
+                        tmpState = NOT_STARTED;
+                    SetBossState(i, EncounterState(tmpState));
+                }
+
+                loadStream >> m_uiXerestrasza;
+            }
+
+            private:
+                uint32 m_uiXerestrasza;
+                uint32 m_uiTwilightHalion;
+                uint32 m_uiDataDamage;
+
+                uint64 m_uiBaltharusGUID;
+                uint64 m_uiZarithrianGUID;
+                uint64 m_uiRagefireGUID;
+                uint64 m_uiHalionGUID;
+                uint64 m_uiXerestraszaGUID;
+                uint64 m_uiTwilightHalionGUID;
+                uint64 m_uiHalionPortalGUID;
+                uint64 m_uiTwilightPortalGUID;
+                uint64 m_uiGOFlameWallsGUID;
+                uint64 m_uiGOTwilightWallsGUID;
+        };
+        
+        InstanceScript* GetInstanceScript (InstanceMap *pMap) const
+        {
+            return new instance_ruby_sanctum_InstanceMapScript(pMap);
+        }
+};
+
+
+void AddSC_instance_ruby_sanctum()
+{
+    new instance_ruby_sanctum();
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h b/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h
new file mode 100644
index 0000000..850b62b
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h
@@ -0,0 +1,74 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DEF_RUBY_SANCTUM_H
+#define DEF_RUBY_SANCTUM_H
+
+static const Position SpawnPosHalion = {3144.93f, 527.233f, 72.8887f, 0.110395f};
+
+enum eData
+{
+    DATA_BALTHARUS       = 0,
+    DATA_RAGEFIRE        = 1,
+    DATA_ZARITHRIAN      = 2,
+    DATA_HALION          = 3,
+    MAX_ENCOUNTER        = 4,
+    DATA_XERESTRASZA     = 5,
+    DATA_TWILIGHT_HALION = 6,
+    DATA_DAMAGE          = 7
+};
+
+enum eAchievementData
+{
+    TWILIGHT_DESTROYER_NORMAL_10    = 4817,
+    TWILIGHT_DESTROYER_NORMAL_25    = 4815,
+    TWILIGHT_DESTROYER_HEROIC_10    = 4818,
+    TWILIGHT_DESTROYER_HEROIC_25    = 4816
+};
+
+enum eCreature
+{
+    NPC_BALTHARUS        = 39751,
+    NPC_BALTHARUS_SUMMON = 39899,
+    NPC_ZARITHRIAN       = 39746,
+    NPC_RAGEFIRE         = 39747,
+    NPC_HALION           = 39863,
+    NPC_TWILIGHT_HALION  = 40142,
+    NPC_XERESTRASZA      = 40429,
+    NPC_ONYX_FLAMECALLER = 39814,
+    NPC_METEOR_STRIKE    = 40041,
+    NPC_METEOR_FLAME     = 40042,
+    NPC_SUMMON_HALIOH    = 40044
+};
+
+enum eGameObject
+{
+    GO_FIRE_FIELD       = 203005,
+    GO_FLAME_WALLS      = 203006,
+    GO_FLAME_WALLS2     = 203007,
+    GO_FLAME_WALLS3     = 203624,
+    GO_TWILIGHT_PORTAL1 = 202794,
+    GO_TWILIGHT_PORTAL2 = 202796
+};
+
+#endif
\ No newline at end of file
-- 
1.7.2.3

