From 9a9565d85e222cf01908428a94838b697a743c44 Mon Sep 17 00:00:00 2001
From: root <root@deb.privatedns.com>
Date: Sun, 9 Jan 2011 09:33:05 -0500
Subject: [PATCH] 10988-IcecrownCitadel

---
 sql/CMakeLists.txt                                 |    1 +
 sql/ICC/FULL_world_icc_templates.sql               |  403 ++++++
 sql/ICC/FULL_world_spell_proc_event.sql            |   53 +
 sql/ICC/FULL_world_text.sql                        |  420 ++++++
 src/server/game/Entities/Unit/Unit.cpp             |   13 +-
 src/server/game/Scripting/ScriptLoader.cpp         |   34 +-
 src/server/game/Spells/Auras/SpellAuraEffects.cpp  |    2 +
 src/server/game/Spells/Spell.cpp                   |    6 +
 src/server/scripts/Northrend/CMakeLists.txt        |   16 +-
 .../IcecrownCitadel/boss_blood_queen_lana_thel.cpp |  720 +++-------
 .../IcecrownCitadel/boss_deathbringer_saurfang.cpp | 1259 +++--------------
 .../Northrend/IcecrownCitadel/boss_festergut.cpp   |  475 +++----
 .../IcecrownCitadel/boss_gunship_battle.cpp        |   21 +
 .../IcecrownCitadel/boss_lady_deathwhisper.cpp     |  939 ++++---------
 .../IcecrownCitadel/boss_lord_marrowgar.cpp        |  652 ++++-----
 .../IcecrownCitadel/boss_professor_putricide.cpp   | 1525 +++++++-------------
 .../IcecrownCitadel/boss_rat_des_blutes.cpp        | 1470 +++++++++++++++++++
 .../Northrend/IcecrownCitadel/boss_rotface.cpp     |  835 +++++------
 .../Northrend/IcecrownCitadel/boss_sindragosa.cpp  |  650 +++++++++
 .../IcecrownCitadel/boss_the_lich_king.cpp         | 1366 ++++++++++++++++++
 .../IcecrownCitadel/boss_valithria_dreamwalker.cpp |  415 ++++++
 .../Northrend/IcecrownCitadel/icecrown_citadel.cpp |  262 ++++
 .../Northrend/IcecrownCitadel/icecrown_citadel.h   |  436 +++---
 .../IcecrownCitadel/instance_icecrown_citadel.cpp  | 1199 +++++++++-------
 24 files changed, 8102 insertions(+), 5070 deletions(-)
 create mode 100644 sql/ICC/FULL_world_icc_templates.sql
 create mode 100644 sql/ICC/FULL_world_spell_proc_event.sql
 create mode 100644 sql/ICC/FULL_world_text.sql
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
 create mode 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
 create mode 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_rat_des_blutes.cpp
 create mode 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
 create mode 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
 create mode 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
 create mode 100644 src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp

diff --git a/sql/CMakeLists.txt b/sql/CMakeLists.txt
index e1b0921..341d926 100644
--- a/sql/CMakeLists.txt
+++ b/sql/CMakeLists.txt
@@ -11,6 +11,7 @@
 if( WITH_SQL )
   install(
     DIRECTORY
+      ICC
       updates
       scripts
       base
diff --git a/sql/ICC/FULL_world_icc_templates.sql b/sql/ICC/FULL_world_icc_templates.sql
new file mode 100644
index 0000000..7e00da9
--- /dev/null
+++ b/sql/ICC/FULL_world_icc_templates.sql
@@ -0,0 +1,403 @@
+﻿-- Cleanup
+UPDATE `creature_template` SET `ScriptName`='' WHERE `entry` IN (SELECT `id` FROM `creature` WHERE `map` = 631);
+
+-- GameObject
+UPDATE `gameobject_template` SET `ScriptName` = 'go_icecrown_teleporter' WHERE `entry` IN (202223,202235,202242,202243,202244,202245,202246);
+UPDATE `gameobject_template` SET `flags` = 32 WHERE `entry` IN (202235,202242,202243,202244,202245,202246);
+UPDATE `gameobject_template` SET `flags` = 52 WHERE `entry` = 202223;
+UPDATE `gameobject_template` SET `ScriptName` = '', `data10` = 70308 WHERE `entry` = 201584;
+UPDATE `gameobject` SET `phaseMask` = '1' WHERE `id` IN (202242,202243,202244,202245,202235,202223,202246);
+UPDATE `gameobject` SET `state` = '1' WHERE `id` IN (201614,201613);
+UPDATE `gameobject` SET `state` = '0' WHERE `id` IN (201375);
+UPDATE gameobject SET phaseMask = 17 WHERE id IN (201375,201374);
+-- test platform destruction
+UPDATE `gameobject_template` SET `flags` = 32 WHERE `entry` = 202161;
+UPDATE `gameobject` SET `state` = '1' WHERE `id` IN (202161);
+
+-- Boss
+UPDATE `creature_template` SET `ScriptName`='boss_lord_marrowgar' WHERE `entry` = 36612;
+UPDATE `creature_template` SET `ScriptName`='boss_lady_deathwhisper' WHERE `entry` = 36855;
+UPDATE `creature_template` SET `ScriptName`='boss_saurfang' WHERE `entry` = 37813;
+UPDATE `creature_template` SET `ScriptName`='boss_festergut' WHERE `entry` = 36626;
+UPDATE `creature_template` SET `ScriptName`='boss_rotface' WHERE `entry`= 36627;
+UPDATE `creature_template` SET `ScriptName`='boss_professor_putricide' WHERE `entry` = 36678;
+UPDATE `creature_template` SET `ScriptName`='boss_blood_elf_valanar_icc' WHERE `entry` = 37970;
+UPDATE `creature_template` SET `ScriptName`='boss_blood_elf_keleset_icc' WHERE `entry` = 37972;
+UPDATE `creature_template` SET `ScriptName`='boss_blood_elf_taldaram_icc' WHERE `entry` = 37973;
+UPDATE `creature_template` SET `ScriptName`='boss_blood_queen_lanathel' WHERE `entry` = 37955;
+UPDATE `creature_template` SET `ScriptName`='boss_valithria' WHERE `entry` = 36789;
+UPDATE `creature_template` SET `ScriptName`='boss_sindragosa' WHERE `entry` = 36853;
+UPDATE `creature_template` SET `ScriptName`='boss_the_lich_king' WHERE `entry` = 36597;
+
+-- Mobs
+UPDATE `creature_template` SET `ScriptName`='npc_tirion_icc' WHERE `entry`= 38995;
+UPDATE `creature_template` SET `ScriptName`='npc_swarming_shadows' WHERE `entry` = 38163;
+UPDATE `creature_template` SET `ScriptName`='npc_cold_flame' WHERE `entry` = 36672;
+UPDATE `creature_template` SET `ScriptName`='npc_bone_spike' WHERE `entry` = 36619;
+UPDATE `creature_template` SET `ScriptName`='npc_volatile_ooze' WHERE `entry` = 37697;
+UPDATE `creature_template` SET `ScriptName`='npc_valkyr_icc' WHERE `entry` = 36609;
+UPDATE `creature_template` SET `ScriptName`='npc_vile_spirit_icc' WHERE `entry`= 37799;
+UPDATE `creature_template` SET `ScriptName`='npc_ooze_little' WHERE `entry`= 36897;
+UPDATE `creature_template` SET `ScriptName`='npc_ooze_big' WHERE `entry`= 36899;
+UPDATE `creature_template` SET `ScriptName`='npc_shade' WHERE `entry` = 38222;
+UPDATE `creature_template` SET `ScriptName`='npc_dreamcloud_icc' WHERE `entry` = 37985;
+UPDATE `creature_template` SET `ScriptName`='npc_dreamportal_icc' WHERE `entry` IN (38186,37945,38429,38430);
+UPDATE `creature_template` SET `ScriptName`='npc_cult_fanatic_and_adherent' WHERE `entry` IN (37949,38010,38136,37890,38009,38135);
+UPDATE `creature_template` SET `ScriptName`='npc_rimefang' WHERE `entry`= 37533;
+UPDATE `creature_template` SET `ScriptName`='npc_spinestalker' WHERE `entry`= 37534;
+UPDATE `creature_template` SET `ScriptName`='npc_ice_tomb' WHERE `entry`= 36980;
+UPDATE `creature_template` SET `ScriptName`='npc_icc_puddle_stalker' WHERE `entry`= 37824;
+UPDATE `creature_template` SET `ScriptName`='npc_ooze_explode_stalker' WHERE `entry` = 38107;
+UPDATE `creature_template` SET `ScriptName`='npc_gas_cloud_icc' WHERE `entry` = 37562;
+UPDATE `creature_template` SET `ScriptName`='npc_bomb_icc' WHERE `entry` = 38159;
+UPDATE `creature_template` SET `ScriptName`='npc_stinky_icc' WHERE `entry` = 37025;
+UPDATE `creature_template` SET `ScriptName`='npc_precious_icc' WHERE `entry` = 37217;
+UPDATE `creature_template` SET `ScriptName`='npc_icc_combat_stalker' WHERE `entry` = 38752;
+UPDATE `creature_template` SET `ScriptName`='npc_valithria_alternative' WHERE `entry` = 37950;
+UPDATE `creature_template` SET `ScriptName`='boss_blood_council_controller' WHERE `entry`=38008;
+UPDATE `creature_template` SET `ScriptName`='npc_blood_queen_lana_thel' WHERE `entry`=38004;
+UPDATE `creature_template` SET `ScriptName`='npc_kinetic_bomb' WHERE `entry`=38454;
+UPDATE `creature_template` SET `ScriptName`='npc_dark_nucleus' WHERE `entry`=38369;
+UPDATE `creature_template` SET `ScriptName`='npc_ball_of_flame' WHERE `entry` IN (38332,38451);
+
+-- Other
+UPDATE `creature_template` SET `minlevel` = 82, `maxlevel` = 82, `faction_A` = 14, `faction_H` = 14, `unit_flags` = 33554434, `type_flags` = 1024 WHERE `entry` = 36672;
+UPDATE `creature_template` SET `minlevel` = 82, `maxlevel` = 82, `faction_A` = 35, `faction_H` = 35 WHERE `entry` = 37950;
+UPDATE `creature_template` SET `minlevel` = 80, `maxlevel` = 80, `faction_A` = 14, `faction_H` = 14, `unit_flags` = 0, type_flags = 0, `VehicleId` = 533 WHERE `entry` IN (36619,38233,38459,38460);
+UPDATE `creature_template` SET `faction_A`=2068, `faction_H`=2068 WHERE `entry` IN (36899,38123,3689902,3689903);
+UPDATE `creature_template` SET `faction_A` = 21, `faction_H` = 21, `unit_flags` = 33600, `vehicleId` = 639 WHERE `entry` IN (37813,38402,38582,38583);
+UPDATE `creature_template` SET `faction_A` = 35, `faction_H` = 35, `type_flags` = 67113036 WHERE `entry` IN (36789,38174);
+UPDATE `creature_template` SET `faction_A` = 14, `faction_H` = 14, `minlevel` = 80, `maxlevel` = 80 WHERE `entry` IN (37006,37013,37986,38107,38548,36659,37690,37562,38159);
+UPDATE `creature_template` SET `vehicleId` = 532 WHERE `entry` IN (36609,39120,39121,39122);
+UPDATE `creature_model_info` SET `bounding_radius` = 5,`combat_reach` = 5 WHERE `modelid` = 31119;
+UPDATE `creature_template` SET `mechanic_immune_mask` = 634339327 WHERE `entry` IN (36855,38106,38296,38297);
+UPDATE `creature_template` SET `flags_extra` = 2 WHERE `entry` IN (37007,38301);
+UPDATE `creature_template` SET `spell1` = 70360, `spell2`= 70539, `spell3`= 70542, `VehicleId` = 591 WHERE `entry`= 37672;
+UPDATE `creature_template` SET `spell1` = 72527, `spell2`= 72457, `spell3`= 70542, `VehicleId` = 591 WHERE `entry`= 38285;
+UPDATE `creature_template` SET `dynamicflags` = 8, `npcflag` = 0, `unit_flags` = 32832 WHERE `entry` = 38995;
+UPDATE `creature_template` SET `faction_A` = 14, `faction_H` = 14 WHERE `entry` IN (36899,38123);
+UPDATE `creature_template` SET `MovementType` = 1 WHERE `entry` IN(37985,37799,39284,39285,39286);
+UPDATE `creature_template` SET `InhabitType`=5,`flags_extra`=`flags_extra`|0x80 WHERE `entry`=30298;
+UPDATE `creature_template` SET `InhabitType`=5,`minlevel`=82,`maxlevel`=82,`faction_A`=14,`faction_H`=14,`speed_walk`=0.142857 WHERE `entry` IN (38454,38775,38776,38777); -- Kinetic Bomb
+UPDATE `creature_template` SET `minlevel`=82,`maxlevel`=82,`flags_extra`=`flags_extra`|0x80 WHERE `entry`=38458; -- Kinetic Bomb Target
+UPDATE `creature_template` SET `minlevel`=82,`maxlevel`=82,`exp`=2,`flags_extra`=`flags_extra`|0x80 WHERE `entry`=38422; -- Shock Vortex
+UPDATE `creature_template` SET `minlevel`=82,`maxlevel`=82,`exp`=2,`speed_walk`=1.57143,`unit_flags`=33554432,`flags_extra`=`flags_extra`|0x80 WHERE `entry`=38332; -- Ball of Flame
+UPDATE `creature_template` SET `minlevel`=82,`maxlevel`=82,`exp`=2,`speed_walk`=1.57143,`unit_flags`=33554432,`flags_extra`=`flags_extra`|0x80 WHERE `entry`=38451; -- Ball of Inferno Flame
+UPDATE `creature_template` SET `unit_flags`=536904000,`RegenHealth`=0,`equipment_id`=10092,`speed_run`=1.428571,`speed_walk`=1.6 WHERE `entry` IN (37970,38401,38784,38785); -- Prince Valanar
+UPDATE `creature_template` SET `unit_flags`=536904000,`RegenHealth`=0,`equipment_id`=10077,`speed_run`=1.428571,`speed_walk`=1.6 WHERE `entry` IN (37972,38399,38769,38770); -- Prince Keleseth
+UPDATE `creature_template` SET `unit_flags`=536904000,`RegenHealth`=0,`equipment_id`=10091,`speed_run`=1.428571,`speed_walk`=1.6 WHERE `entry` IN (37973,38400,38771,38772); -- Prince Taldaram
+UPDATE `creature_model_info` SET `bounding_radius`=0.5425,`combat_reach`=1.75 WHERE `modelid` IN (30856,30857,30858);
+UPDATE `creature_template` SET `RegenHealth`=0 WHERE `entry`=38369; -- Dark Nucleus
+UPDATE `creature_template` SET  `dynamicflags` = 8 WHERE entry IN (37970, 38401, 38784, 38785);
+UPDATE `creature_template` SET `RegenHealth` = '0' WHERE `entry` =38174;
+UPDATE `creature_template` SET `vehicleId` = 531 WHERE `entry` IN (36609,39120,39121,39122);
+
+-- Spell
+
+DELETE FROM `spell_script_names` WHERE `spell_id` IN(69783,69057,69140,72705,69147,69075,70834,70835,70836,70903,71236);
+
+-- Not attackable and disable move flag
+UPDATE `creature_template` SET `unit_flags` = 33555204 WHERE `entry` IN (37986,37824,38234,38317,36659,38548,37186,37006,37918,37690,38068,38163,38584,38752);
+UPDATE `creature_template` SET `unit_flags` = 33587972 WHERE `entry` = 37013;
+UPDATE `creature_template` SET `flags_extra` = 0 WHERE `entry` IN (37986,38234,38317,36659,38548,37186,37013);
+UPDATE `creature_template` SET `flags_extra` = 128 WHERE `entry` = 38234;
+UPDATE `creature_template` SET `flags_extra` = 130 WHERE `entry` = 38569;
+
+-- Instance
+UPDATE `instance_template` SET `script`='instance_icecrown_citadel' WHERE `map` = 631;
+
+-- Creature addon template
+
+DELETE FROM `creature_addon` WHERE `guid` IN (136107,104365);
+DELETE FROM `creature_template_addon` WHERE `entry` IN (37690,37672,36659,38186,37945,38429,38430,37918,37006,37186);
+
+INSERT INTO creature_addon (`guid`, `path_id`, `mount`, `bytes1`, `bytes2`, `emote`, `auras`) VALUES
+(136107, 0, 0, 0, 1, 0, '18950 0 18950 1 72242 0');
+
+INSERT INTO `creature_addon` (`guid`, `bytes1`) VALUES
+(104365,0x03000000); -- Blood Queen Lana'Thel
+
+INSERT INTO `creature_template_addon` (`entry`, `path_id`, `mount`, `bytes1`, `bytes2`, `emote`, `auras`) VALUES
+(37690, 0, 0, 0, 0, 0, '70345 0  70343 0'),
+(37672, 0, 0, 0, 0, 0, '70385 0 70405 0'),
+(38186, 0, 0, 0, 0, 0, '71304 0'),
+(37945, 0, 0, 0, 0, 0, '70763 0'),
+(38429, 0, 0, 0, 0, 0, '71986 0'),
+(38430, 0, 0, 0, 0, 0, '71994 0'),
+(37918, 0, 0, 0, 0, 0, '70715 0'),
+(37186, 0, 0, 0, 0, 0, '70022 0'),
+(37006, 0, 0, 0, 0, 0, '69776 0');
+
+-- Thanks YTDB
+
+-- Conditions
+
+DELETE FROM `conditions` WHERE `SourceEntry` IN (69508,70881,70360,36659,70781,70856,70857,70858,70859,70860,70861,69157,71614,70588,74074);
+DELETE FROM `conditions` WHERE `ConditionValue2` IN (SELECT `id` FROM `creature` WHERE `map` = 631);
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=13 AND `SourceEntry` IN (70952,70982,70981,70983,71070,71081,71080);
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=21 AND `SourceGroup` IN (37672,38285);
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`ElseGroup`,`ConditionTypeOrReference`,`ConditionValue1`,`ConditionValue2`,`ConditionValue3`,`ErrorTextId`,`ScriptName`,`Comment`) VALUES
+(13,0,70360,0,18,1,37690,0,0, '', ''),
+(13,0,69157,0,18,1,36659,0,0, '', 'Festergut - Gaseous Blight'),
+(13,0,69162,0,18,1,36659,0,0, '', 'Festergut - Gaseous Blight'),
+(13,0,69164,0,18,1,36659,0,0, '', 'Festergut - Gaseous Blight'),
+(13,0,71614,0,18,1,38995,0,0, '', 'LichKing - Ice Lock'),
+(13,0,70588,0,18,1,36789,0,0, '', 'Valithria - Suppression'),
+(13,0,70588,0,18,1,38174,0,0, '', 'Valithria - Suppression'),
+(13,0,71617,0,18,1,38317,0,0, '', 'Putricide - Tear Gas'),
+(13,0,69125,0,18,1,37013,0,0, '', ''),
+(21,37672,71516,0,3,49888,0,0,0, '', 'Mutated Abomination - Unholy Infusion'),
+(21,38285,71516,0,3,49888,0,0,0, '', 'Mutated Abomination - Unholy Infusion'),
+(13,0,70952,0,18,1,37970,0,0, '', 'Valanar - Invocation of Blood'),
+(13,0,70982,0,18,1,37973,0,0, '', 'Taldaram - Invocation of Blood'),
+(13,0,70981,0,18,1,37972,0,0, '', 'Keleseth - Invocation of Blood'),
+(13,0,70983,0,18,1,37970,0,0, '', 'Valanar - Invocation of Blood beam'),
+(13,0,70983,0,18,1,37973,0,0, '', 'Taldaram - Invocation of Blood beam'),
+(13,0,70983,0,18,1,37972,0,0, '', 'Keleseth - Invocation of Blood beam'),
+(13,0,71070,0,18,1,37970,0,0, '', 'Valanar - Invocation of Blood visual'),
+(13,0,71081,0,18,1,37973,0,0, '', 'Taldaram - Invocation of Blood visual'),
+(13,0,71080,0,18,1,37972,0,0, '', 'Keleseth - Invocation of Blood visual'),
+(13,0,74074,0,18,1,36597,0,0, '', 'The Lich King - Plague Siphon');
+
+-- creature
+
+DELETE FROM `creature` WHERE `id` IN(37813, 37013, 36659,37950);
+INSERT INTO `creature` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`, `npcflag`, `unit_flags`, `dynamicflags`) VALUES
+(48969,37013,631,1,1,11686,0,4291.18,3092.92,372.97,2.33874,300,0,0,25200,0,0,0,0,0,0), -- puddle stalker
+(48971,37013,631,1,1,11686,0,4312.14,3112.98,372.97,2.51327,300,0,0,25200,0,0,0,0,0,0),
+(48973,37013,631,1,1,11686,0,4244.04,3092.66,372.97,0.97738,300,0,0,25200,0,0,0,0,0,0),
+(48976,37013,631,1,1,11686,0,4223.47,3113.58,372.97,0.76794,300,0,0,25200,0,0,0,0,0,0),
+(48981,37013,631,1,1,11686,0,4222.44,3161.69,372.97,5.53269,300,0,0,25200,0,0,0,0,0,0),
+(48983,37013,631,1,1,11686,0,4243.89,3181.74,372.97,5.44543,300,0,0,25200,0,0,0,0,0,0),
+(48989,37013,631,1,1,11686,0,4312.36,3160.84,372.97,3.80482,300,0,0,25200,0,0,0,0,0,0),
+(48990,37013,631,1,1,11686,0,4291.45,3181.25,372.97,4.10152,300,0,0,25200,0,0,0,0,0,0),
+(93955,36659,631,15,1,11686,0,4267.87,3137.33,360.469,0,300,0,0,25200,0,0,0,0,0,0),
+(136107,37813,631,15,1,30790,0,-493.905,2211.35,541.114,3.18037,300,0,0,12299490,0,0,0,0,0,0), -- saurfang
+(1000000,37950,631,15,16,0,0,4203.65,2483.89,390.961,5.51524,604800,0,0,6000003,0,0,0,0,33540,8);
+
+-- Linked spell
+
+DELETE FROM `spell_linked_spell` WHERE `spell_trigger` IN (72202,70117);
+DELETE FROM `spell_linked_spell` WHERE `spell_effect` IN(72202,69166,70347,72380,69706,70702,70311, 69291, 70338,72846,69201,74074);
+INSERT INTO `spell_linked_spell` (`spell_trigger`,`spell_effect`,`type`,`comment`) VALUES
+(70360,70347,0,'Eat Ooze'),
+(72379,72380,0,'Blood Nova'),
+(72380,72202,0,'Blood Nova 10N'),
+(72438,72202,0,'Blood Nova 25N'),
+(72439,72202,0,'Blood Nova 10H'),
+(72440,72202,0,'Blood Nova 25H'),
+(72409,72202,0,'Rune of Blood 25N'),
+(72447,72202,0,'Rune of Blood 10H'),
+(72448,72202,0,'Rune of Blood 25H'),
+(72449,72202,0,'Rune of Blood 25H'),
+(69195,69166,0,'Pungent Blight 10N'),
+(71279,69166,0,'Pungent Blight 25N'),
+(73031,69166,0,'Pungent Blight 10H'),
+(73032,69166,0,'Pungent Blight 25H'),
+(70715,70702,0,'?'),
+(-69674,69706,0, 'Rotface: Mutated Infection Summon'),
+(-71224,69706,0, 'Rotface: Mutated Infection Summon'),
+(-73022,69706,0, 'Rotface: Mutated Infection Summon'),
+(-73023,69706,0, 'Rotface: Mutated Infection Summon'),
+(-70337,70338,0, 'The Lich King: Necrotic plague initial cast'),
+(-70337,72846,0, 'The Lich King: Necrotic plague immun'),
+(-70338,70338,0, 'The Lich King: Necrotic jump'),
+(-69200,69201,0, 'The Lich King: Raging Spirit'),
+(-70338,74074,0, 'The Licg King: Plague Siphon');
+
+-- Linked Respawn
+
+DELETE FROM `creature_linked_respawn` WHERE `guid` IN (136104,136105,136107,67608,67614,67901,77641,77642,77643,115558);
+INSERT INTO `creature_linked_respawn` (`guid`,`linkedGuid`) VALUES
+(136104,136104), -- Lord Marrowgar
+(136105,136105), -- Lady Deathwhisper
+(136107,136107), -- Deathbringer Saurfang
+(67608,67608), -- Festergut
+(67614,67614), -- Rotface
+(67901,67901), -- Professor Putricide
+(77641,77641), -- Prince Keleseth
+(77642,77642), -- Prince Taldaram
+(77643,77643), -- Prince Valanar
+(115558,115558); -- Blood-Queen Lana'thel
+
+-- Npc spell click spell
+
+DELETE FROM `npc_spellclick_spells` WHERE npc_entry IN (37945,38430);
+INSERT INTO `npc_spellclick_spells` (`npc_entry`, `spell_id`, `quest_start`, `quest_start_active`, `quest_end`, `cast_flags`, `aura_required`, `aura_forbidden`, `user_type`) VALUES
+(37945,70766,0,0,0,3,0,0,0),
+(38430,70766,0,0,0,3,0,0,0);
+
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (70405,72508,72509,72510) AND `ScriptName`='spell_putricide_mutated_transformation_dismiss';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (70311,71503) AND `ScriptName`='spell_putricide_mutated_transformation';
+DELETE FROM `spell_script_names` WHERE `spell_id`=70308 AND `ScriptName`='spell_putricide_mutation_init';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (71412,71415) AND `ScriptName`='spell_putricide_ooze_summon';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (72262) AND `ScriptName`='spell_lich_king_quake';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (74361) AND `ScriptName`='spell_lich_king_valkyr_summon';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (70541,73779,73780,73781) AND `ScriptName`='spell_lich_king_infection';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (70338,73785,73786,73787) AND `ScriptName`='spell_lich_king_necrotic_plague';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (69075,70834,70835,70836) AND `ScriptName`='spell_lord_marrowgar_bone_storm';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (70126) AND `ScriptName`='spell_sindragosa_ice_tomb';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (70127,72528,72529,72530) AND `ScriptName`='spell_sindragosa_mystic_buffet';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (69766) AND `ScriptName`='spell_sindragosa_unchained_magic';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (72219,72551,72552,72553) AND `ScriptName`='spell_festergut_gastric_bloat';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (69558) AND `ScriptName`='spell_rotface_unstable_explosion';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (68981,74270,74271,74272) AND `ScriptName`='spell_lich_king_winter';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (70534) AND `ScriptName`='spell_vile_spirit_distance_check';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (69110) AND `ScriptName`='spell_ice_burst_distance_check';
+DELETE FROM `spell_script_names` WHERE `spell_id`=71598 AND `ScriptName`='spell_creature_permanent_feign_death';
+DELETE FROM `spell_script_names` WHERE `spell_id`=71806 AND `ScriptName`='spell_taldaram_glittering_sparks';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (71718,72040) AND `ScriptName`='spell_taldaram_summon_flame_ball';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (55891,55947) AND `ScriptName`='spell_taldaram_flame_ball_visual';
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (71756,72782,72783,72784) AND `ScriptName`='spell_taldaram_ball_of_inferno_flame';
+DELETE FROM `spell_script_names` WHERE `spell_id`=72080 AND `ScriptName`='spell_valanar_kinetic_bomb';
+DELETE FROM `spell_script_names` WHERE `spell_id`=72087 AND `ScriptName`='spell_valanar_kinetic_bomb_knockback';
+DELETE FROM `spell_script_names` WHERE `spell_id`=73001 AND `ScriptName`='spell_blood_council_shadow_prison';
+DELETE FROM `spell_script_names` WHERE `spell_id`=72999 AND `ScriptName`='spell_blood_council_shadow_prison_damage';
+DELETE FROM `spell_script_names` WHERE `spell_id`=69538 AND `ScriptName`='spell_rotface_little_ooze_combine';
+DELETE FROM `spell_script_names` WHERE `spell_id`=69553 AND `ScriptName`='spell_rotface_large_ooze_combine';
+DELETE FROM `spell_script_names` WHERE `ScriptName`='spell_festergut_blighted_spores';
+DELETE FROM `spell_script_names` WHERE `ScriptName`='spell_lich_king_play_movie';
+DELETE FROM `spell_script_names` WHERE `ScriptName`='spell_valkyr_carry_can_cast';
+DELETE FROM `spell_script_names` WHERE `ScriptName`='spell_sindragosa_ice_tomb_effect';
+DELETE FROM `spell_script_names` WHERE `ScriptName`='spell_sindragosa_ice_tomb_effect';
+DELETE FROM `spell_script_names` WHERE `ScriptName`='spell_marrowgar_bone_spike_graveyard';
+
+INSERT INTO `spell_script_names` (`spell_id`, `ScriptName`) VALUES
+(71412,'spell_putricide_ooze_summon'),
+(71415,'spell_putricide_ooze_summon'),
+(72510,'spell_putricide_mutated_transformation_dismiss'),
+(72509,'spell_putricide_mutated_transformation_dismiss'),
+(72508,'spell_putricide_mutated_transformation_dismiss'),
+(70405,'spell_putricide_mutated_transformation_dismiss'),
+(70308,'spell_putricide_mutation_init'),
+(70311,'spell_putricide_mutated_transformation'),
+(71503,'spell_putricide_mutated_transformation'),
+(74361,'spell_lich_king_valkyr_summon'),
+(70541,'spell_lich_king_infection'),
+(73779,'spell_lich_king_infection'),
+(73780,'spell_lich_king_infection'),
+(73781,'spell_lich_king_infection'),
+(70338,'spell_lich_king_necrotic_plague'),
+(73785,'spell_lich_king_necrotic_plague'),
+(73786,'spell_lich_king_necrotic_plague'),
+(73787,'spell_lich_king_necrotic_plague'),
+(69075,'spell_lord_marrowgar_bone_storm'),
+(70834,'spell_lord_marrowgar_bone_storm'),
+(70835,'spell_lord_marrowgar_bone_storm'),
+(70836,'spell_lord_marrowgar_bone_storm'),
+(70126,'spell_sindragosa_ice_tomb'),
+(70127,'spell_sindragosa_mystic_buffet'),
+(72528,'spell_sindragosa_mystic_buffet'),
+(72529,'spell_sindragosa_mystic_buffet'),
+(72530,'spell_sindragosa_mystic_buffet'),
+(69766,'spell_sindragosa_unchained_magic'),
+(72219,'spell_festergut_gastric_bloat'),
+(72551,'spell_festergut_gastric_bloat'),
+(72552,'spell_festergut_gastric_bloat'),
+(72553,'spell_festergut_gastric_bloat'),
+(69558,'spell_rotface_unstable_explosion'),
+(68981,'spell_lich_king_winter'),
+(74270,'spell_lich_king_winter'),
+(74271,'spell_lich_king_winter'),
+(74272,'spell_lich_king_winter'),
+(70534,'spell_vile_spirit_distance_check'),
+(69110,'spell_ice_burst_distance_check'),
+(72262,'spell_lich_king_quake'),
+(73159,'spell_lich_king_play_movie'),
+(74506,'spell_valkyr_carry_can_cast'),
+(71598,'spell_creature_permanent_feign_death'),
+(71806,'spell_taldaram_glittering_sparks'),
+(71718,'spell_taldaram_summon_flame_ball'),
+(72040,'spell_taldaram_summon_flame_ball'),
+(55891,'spell_taldaram_flame_ball_visual'),
+(55947,'spell_taldaram_flame_ball_visual'),
+(71756,'spell_taldaram_ball_of_inferno_flame'),
+(72782,'spell_taldaram_ball_of_inferno_flame'),
+(72783,'spell_taldaram_ball_of_inferno_flame'),
+(72784,'spell_taldaram_ball_of_inferno_flame'),
+(72080,'spell_valanar_kinetic_bomb'),
+(72087,'spell_valanar_kinetic_bomb_knockback'),
+(73001,'spell_blood_council_shadow_prison'),
+(72999,'spell_blood_council_shadow_prison_damage'),
+(69538,'spell_rotface_little_ooze_combine'),
+(69553,'spell_rotface_large_ooze_combine'),
+(69290,'spell_festergut_blighted_spores'),
+(71222,'spell_festergut_blighted_spores'),
+(73033,'spell_festergut_blighted_spores'),
+(73034,'spell_festergut_blighted_spores'),
+(69675,'spell_sindragosa_ice_tomb_effect'),
+(70117,'spell_sindragosa_ice_tomb_effect'),
+(69057,'spell_marrowgar_bone_spike_graveyard'),
+(70826,'spell_marrowgar_bone_spike_graveyard'),
+(72088,'spell_marrowgar_bone_spike_graveyard'),
+(72089,'spell_marrowgar_bone_spike_graveyard'),
+
+-- ***_scripts table
+
+UPDATE waypoint_scripts SET delay = 3 WHERE dataint = 38879 AND command = 15;
+DELETE FROM `spell_scripts` WHERE id = 72429 AND command = 15;
+INSERT INTO `spell_scripts` VALUE
+('72429','0','3','15','72423','0','0','0','0','0','0');
+
+SET @LIGHT_S_HAMMER := 70781;
+SET @ORATORY_OF_THE_DAMNED := 70856;
+SET @RAMPART_OF_SKULLS := 70857;
+SET @DEATHBRINGER_S_RISE := 70858;
+SET @UPPER_SPIRE := 70859;
+SET @SINDRAGOSA_S_LAIR := 70861;
+SET @FROZEN_THRONE := 70860;
+
+-- Delete conditions (no longer valid)
+DELETE FROM `conditions` WHERE `SourceTypeOrReferenceId`=13 AND `SourceEntry` IN (@LIGHT_S_HAMMER,@ORATORY_OF_THE_DAMNED,@RAMPART_OF_SKULLS,@DEATHBRINGER_S_RISE,@UPPER_SPIRE,@SINDRAGOSA_S_LAIR,@FROZEN_THRONE);
+
+-- Add target coords
+DELETE FROM `spell_target_position` WHERE `id` IN (@LIGHT_S_HAMMER,@ORATORY_OF_THE_DAMNED,@RAMPART_OF_SKULLS,@DEATHBRINGER_S_RISE,@UPPER_SPIRE,@SINDRAGOSA_S_LAIR,@FROZEN_THRONE);
+INSERT INTO `spell_target_position` (`id`,`target_map`,`target_position_x`,`target_position_y`,`target_position_z`,`target_orientation`) VALUES
+(@LIGHT_S_HAMMER,631,-17.0711,2211.47,30.0546,3.14159),
+(@ORATORY_OF_THE_DAMNED,631,-503.593,2211.47,62.7621,3.14159),
+(@RAMPART_OF_SKULLS,631,-615.146,2211.47,199.909,0.0),
+(@DEATHBRINGER_S_RISE,631,-549.073,2211.29,539.223,0.0),
+(@UPPER_SPIRE,631,4199.484,2769.323,351.3722,3.124139),
+(@SINDRAGOSA_S_LAIR,631,4356.580,2565.75,220.402,4.71238),
+(@FROZEN_THRONE,631,529.3969,-2124.66,1041.37,3.14159);
+
+-- Event AI Thanks Heisei Project!
+DELETE FROM `creature_ai_scripts` WHERE `creature_id` IN (37868,36791,37863,37886,37934,38068,37698,36701);
+UPDATE `creature_template` SET `AIName`= 'EventAI' WHERE `entry` IN (37868,36791,37863,37886,37934,38068,37698,36701);
+INSERT INTO `creature_ai_scripts` VALUES
+('85021059','37868','0','0','100','7','15000','15000','27000','27000','11','71179','4','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Mana Void'),
+('85021060','37868','0','0','100','25','15000','15000','27000','27000','11','71741','4','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Mana Void'),
+('85021061','37868','0','0','100','3','10000','10000','18000','22000','11','70759','0','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Frostbolt Volley'),
+('85021062','37868','0','0','100','9','10000','10000','18000','22000','11','71889','0','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Frostbolt Volley'),
+('85021063','37868','0','0','100','5','10000','10000','18000','22000','11','72015','0','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Frostbolt Volley'),
+('85021064','37868','0','0','100','17','10000','10000','18000','22000','11','72016','0','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Frostbolt Volley'),
+('85021065','37868','0','0','100','31','18000','18000','28000','28000','11','70602','4','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Corruption'),
+('85021066','38068','0','0','100','30','30000','30000','0','0','37','0','0','1','0','0','0','0','0','0','0','0', 'Mana Void - Self Destruct'),
+('80021007','36791','0','0','100','7','8000','8000','22000','25000','11','69325','0','1','0','0','0','0','0','0','0','0','Blazing Skeleton - Casts Lay Waste'),
+('80021008','36791','0','0','100','25','8000','8000','22000','25000','11','71730','0','1','0','0','0','0','0','0','0','0','Blazing Skeleton - Casts Lay Waste'),
+('80021009','36791','0','0','100','6','0','0','0','0','21','0','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Stop Movement on Aggro'),
+('80021010','36791','4','0','100','6','0','0','0','0','11','70754','1','0','22','6','0','0','0','0','0','0','Blazing Skeleton - Cast Fireball and Set Phase 1 on Aggro'),
+('80021011','36791','3','0','100','6','15','0','0','0','21','1','0','0','22','5','0','0','0','0','0','0','Blazing Skeleton - Start Movement and Set Phase 2 when Mana is at 15%'),
+('80021012','36791','0','6','100','7','0','0','1500','3000','11','70754','1','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Cast Fireball above 15% Mana (Phase 1)'),
+('80021013','36791','3','5','100','6','100','28','0','0','21','0','0','0','22','6','0','0','0','0','0','0','Blazing Skeleton - Set Ranged Movement and Set Phase 1 when Mana is above 28% (Phase 2)'),
+('80021014','36791','9','0','100','7','30','50','0','0','22','1','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Start Movement Beyond 30 Yards'),
+('80021015','36791','7','0','100','6','0','0','0','0','22','0','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - On Evade set Phase to 0'),
+('80021016','36791','0','0','100','24','0','0','0','0','21','0','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Stop Movement on Aggro'),
+('80021017','36791','4','0','100','24','0','0','0','0','11','71748','1','0','22','6','0','0','0','0','0','0','Blazing Skeleton - Cast Fireball and Set Phase 1 on Aggro'),
+('80021018','36791','3','0','100','24','15','0','0','0','21','1','0','0','22','5','0','0','0','0','0','0','Blazing Skeleton - Start Movement and Set Phase 2 when Mana is at 15%'),
+('80021019','36791','0','6','100','25','0','0','1500','3000','11','71748','1','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Cast Fireball above 15% Mana (Phase 1)'),
+('80021020','36791','3','5','100','24','100','28','0','0','21','0','0','0','22','6','0','0','0','0','0','0','Blazing Skeleton - Set Ranged Movement and Set Phase 1 when Mana is above 28% (Phase 2)'),
+('80021021','36791','9','0','100','25','30','50','0','0','22','1','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Start Movement Beyond 30 Yards'),
+('80021022','36791','7','0','100','24','0','0','0','0','22','0','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - On Evade set Phase to 0'),
+('86021086','37863','4','0','100','30','0','0','0','0','11','70588','1','0','0','0','0','0','0','0','0','0','Suppresser - Cast Suppression'),
+('82021033','37886','0','0','100','7','10000','11000','22000','28000','11','70633','4','0','0','0','0','0','0','0','0','0','Gluttonous Abomination - Casts Gut Spray'),
+('82021034','37886','0','0','100','25','10000','11000','22000','28000','11','71283','4','0','0','0','0','0','0','0','0','0','Gluttonous Abomination - Casts Gut Spray'),
+('82021035','37886','6','0','100','30','0','0','0','0','11','70675','0','2','0','0','0','0','0','0','0','0', 'Gluttonous Abomination - Casts on death Summon Rot Worm'),
+('80021026','37934','2','0','100','7','10','0','12300','14900','11','70744','0','0','0','0','0','0','0','0','0','0','Blistering Zombie - Casts Acid Burst at 10% HP'),
+('80021027','37934','2','0','100','25','10','0','12300','14900','11','71733','0','0','0','0','0','0','0','0','0','0','Blistering Zombie - Casts Acid Burst at 10% HP'),
+('85021075','37698','2','0','100','6','25','0','0','0','11','72143','0','0','1','-106','0','0','0','0','0','0','Shambling Horror - Casts Enrage at 25% HP'),
+('85021076','37698','2','0','100','24','25','0','0','0','11','72146','0','0','1','-106','0','0','0','0','0','0','Shambling Horror - Casts Enrage at 25% HP'),
+('85021077','37698','0','0','100','7','7000','9000','15000','17000','11','72149','0','0','0','0','0','0','0','0','0','0','Shambling Horror - Casts Shockwave'),
+('85021078','37698','0','0','100','25','7000','9000','15000','17000','11','73794','0','0','0','0','0','0','0','0','0','0','Shambling Horror - Casts Shockwave'),
+('85021054','36701','0','0','100','7','10000','10000','25000','35000','11','69242','0','0','0','0','0','0','0','0','0','0','Raging Spirit - Cast Soul Shriek'),
+('85021055','36701','0','0','100','25','10000','10000','25000','35000','11','73800','0','0','0','0','0','0','0','0','0','0','Raging Spirit - Cast Soul Shriek');
diff --git a/sql/ICC/FULL_world_spell_proc_event.sql b/sql/ICC/FULL_world_spell_proc_event.sql
new file mode 100644
index 0000000..4d89112
--- /dev/null
+++ b/sql/ICC/FULL_world_spell_proc_event.sql
@@ -0,0 +1,53 @@
+﻿DELETE FROM `spell_proc_event` WHERE `entry` IN (70107);
+INSERT INTO `spell_proc_event` VALUES (70107, 0x08, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000054, 0x00000000, 0, 20, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (69762);
+INSERT INTO `spell_proc_event` VALUES (69762, 0x00, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00014000, 0x00000000, 0, 101, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72178);
+INSERT INTO `spell_proc_event` VALUES (72178, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00055510, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72176);
+INSERT INTO `spell_proc_event` VALUES (72176, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00051154, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (70602);
+INSERT INTO `spell_proc_event` VALUES (70602, 0x20, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x000AAA20, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (71494);
+INSERT INTO `spell_proc_event` VALUES (71494, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 101, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72176);
+INSERT INTO `spell_proc_event` VALUES (72176, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00051154, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72178);
+INSERT INTO `spell_proc_event` VALUES (72178, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00055510, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (71604);
+INSERT INTO `spell_proc_event` VALUES (71604, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (70001);
+INSERT INTO `spell_proc_event` VALUES (70001, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (71971);
+INSERT INTO `spell_proc_event` VALUES (71971, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72256);
+INSERT INTO `spell_proc_event` VALUES (72256, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72408);
+INSERT INTO `spell_proc_event` VALUES (72408, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (70672);
+INSERT INTO `spell_proc_event` VALUES (70672, 0x28, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000008, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72455);
+INSERT INTO `spell_proc_event` VALUES (72455, 0x28, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000008, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72832);
+INSERT INTO `spell_proc_event` VALUES (72832, 0x28, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000008, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72833);
+INSERT INTO `spell_proc_event` VALUES (72833, 0x28, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000008, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (70904);
+INSERT INTO `spell_proc_event` VALUES (70904, 0x10, 0x06, 0x00000000, 0x00000000, 0x00000000, 0x00008000, 0x00000000, 0, 100, 0);
\ No newline at end of file
diff --git a/sql/ICC/FULL_world_text.sql b/sql/ICC/FULL_world_text.sql
new file mode 100644
index 0000000..fca4e03
--- /dev/null
+++ b/sql/ICC/FULL_world_text.sql
@@ -0,0 +1,420 @@
+﻿DELETE FROM script_texts WHERE entry <= -1665902 AND entry >= -1666080;
+DELETE FROM script_texts WHERE entry <= -1810001 AND entry >= -1810032;
+
+# 1
+DELETE FROM script_texts WHERE `npc_entry` = 36612;
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(36612,-1631000,'This is the beginning AND the end, mortals. None may enter the master''s sanctum!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Смертные, ваш путь закончится так и не начавшись! Никто не смеет входить  в Обитель Господина!',16950,1,0,0,'SAY_ENTER_ZONE'),
+(36612,-1631001,'The Scourge will wash over this world as a swarm of death and destruction!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Плеть накроет этот мир волной смерти и разрушения!',16941,1,0,0,'SAY_AGGRO'),
+(36612,-1631002,'BONE STORM!',NULL,NULL, NULL,NULL,NULL,NULL,NULL,'ВИХРЬ КОСТЕЙ!',16946,1,0,0,'SAY_BONE_STORM'),
+(36612,-1631003,'Bound by bone!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Костяная хватка!',16947,1,0,0, 'SAY_BONESPIKE_1'),
+(36612,-1631004,'Stick Around!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Постой-ка тут!',16948,1,0,0,'SAY_BONESPIKE_2'),
+(36612,-1631005,'The only escape is death!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Единственный выход - это СМЕРТЬ!',16949,1,0,0,'SAY_BONESPIKE_3'),
+(36612,-1631006,'More bones for the offering!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Кости, для жертвоприношений!',16942,1,0,0,'SAY_KILL_1'),
+(36612,-1631007,'Languish in damnation!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Сгинь в вечных муках!',16943,1,0,0,'SAY_KILL_2'),
+(36612,-1631008,'I see... only darkness...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Я вижу... лишь тьму',16944,1,0,0,'SAY_DEATH'),
+(36612,-1631009,'THE MASTER''S RAGE COURSES THROUGH ME!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Во мне бушует ярость господина!',16945,1,0,0,'SAY_BERSERK'),
+(36612,-1631010,'Lord Marrowgar creates a whirling storm of bone!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Лорд Ребрад распадается, и его кости начинают вращаться',0,3,0,0,'SAY_BONE_STORM_EMOTE');
+
+#2
+DELETE FROM `script_texts` WHERE `entry` BETWEEN -1631028 AND -1631011;
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(36855,-1631011, 'You have found your way here, because you are among the few gifted with true vision in a world cursed with blindness.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17272,1,0,0, 'SAY_INTRO_1'),
+(36855,-1631012, 'You can see through the fog that hangs over this world like a shroud, and grasp where true power lies.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17273,1,0,0, 'SAY_INTRO_2'),
+(36855,-1631013, 'Fix your eyes upon your crude hands: the sinew, the soft meat, the dark blood coursing within.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16878,1,0,0, 'SAY_INTRO_3'),
+(36855,-1631014, 'It is a weakness; a crippling flaw.... A joke played by the Creators upon their own creations.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17268,1,0,0, 'SAY_INTRO_4'),
+(36855,-1631015, 'The sooner you come to accept your condition as a defect, the sooner you will find yourselves in a position to transcend it.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17269,1,0,0, 'SAY_INTRO_5'),
+(36855,-1631016, 'Through our Master, all things are possible. His power is without limit, and his will unbending.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17270,1,0,0, 'SAY_INTRO_6'),
+(36855,-1631017, 'Those who oppose him will be destroyed utterly, and those who serve -- who serve wholly, unquestioningly, with utter devotion of mind and soul -- elevated to heights beyond your ken.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17271,1,0,0, 'SAY_INTRO_7'),
+(36855,-1631018, 'What is this disturbance?! You dare trespass upon this hallowed ground? This shall be your final resting place.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16868,1,0,0, 'SAY_AGGRO'),
+(36855,-1631019, 'Enough! I see I must take matters into my own hands!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16877,1,0,0, 'SAY_PHASE_2'),
+(36855,-1631020, 'Lady Deathwhisper''s Mana Barrier shimmers and fades away!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0, 'SAY_PHASE_2_EMOTE'),
+(36855,-1631021, 'You are weak, powerless to resist my will!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16876,1,0,0, 'SAY_DOMINATE_MIND'),
+(36855,-1631022, 'Take this blessing and show these intruders a taste of our master''s power.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16873,1,0,0, 'SAY_DARK_EMPOWERMENT'),
+(36855,-1631023, 'I release you from the curse of flesh!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16874,1,0,0, 'SAY_DARK_TRANSFORMATION'),
+(36855,-1631024, 'Arise and exult in your pure form!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16875,1,0,0, 'SAY_ANIMATE_DEAD'),
+(36855,-1631025, 'Do you yet grasp of the futility of your actions?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16869,1,0,0, 'SAY_KILL_1'),
+(36855,-1631026, 'Embrace the darkness... Darkness eternal!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16870,1,0,0, 'SAY_KILL_2'),
+(36855,-1631027, 'This charade has gone on long enough.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16872,1,0,0, 'SAY_BERSERK'),
+(36855,-1631028, 'All part of the masters plan! Your end is... inevitable!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16871,1,0,0, 'SAY_DEATH');
+
+# 3
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(0,-1665919,'Thank the spirits for you, brothers and sisters. The Skybreaker has already left. Quickly now, to Orgrim''s Hammer! If you leave soon, you may be able to catch them.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,0,0,0,''),
+(0,-1665920,'This should be helpin''ya!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,0,0,0,''),
+(0,-1665921,'Aka''Magosh, brave warriors. The alliance is in great number here.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665922,'Captain Saurfang will be pleased to see you aboard Orgrim''s Hammer. Make haste, we will secure the area until you are ready for take-off.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665923,'A screeching cry pierces the air above!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665924,'A Spire Frostwyrm lands just before Orgrim''s Hammer.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665925,'Rise up, sons and daughters of the Horde! Today we battle a hated enemy of the Horde! LOK''TAR OGAR! Kor''kron, take us out!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665926,'What is that?! Something approaching in the distance!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665927,'ALLIANCE GUNSHIP! ALL HANDS ON DECK!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665928,'Move yer jalopy or we''ll blow it out of the sky, orc! The Horde''s got no business here!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665929,'You will know our business soon! KOR''KRON, ANNIHILATE THEM!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665930,'Marines, Sergeants, attack!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665931,'You DARE board my ship? Your death will come swiftly.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665932,'Riflemen, shoot faster!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665933,'Mortar team, reload!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665934,'We''re taking hull damage, get a sorcerer out here to shut down those cannons!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665935,'The Alliance falter. Onward to the Lich King!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665936,'Damage control! Put those fires out! You haven''t seen the last of the Horde!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665937,'Thank goodness you arrived when you did, heroes. Orgrim''s Hammer has already left. Quickly now, to The Skybreaker! If you leave soon, you may be able to catch them.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665938,'This ought to help!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665939,'Skybreaker Sorcerer summons a Skybreaker Battle Standard.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665940,'You have my thanks. We were outnumbered until you arrived.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665941,'Captain Muradin is waiting aboard The Skybreaker. We''ll secure the area until you are ready for take off.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665942,'Skybreaker infantry, hold position!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665943,'A screeching cry pierces the air above!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665944,'A Spire Frostwyrm lands just before The Skybreaker. ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665945,'Fire up the engines! We got a meetin with destiny, lads!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665946,'Hold on to yer hats!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665947,'What in the world is that? Grab me spyglass, crewman!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665948,'By me own beard! HORDE SAILIN IN FAST N HOT!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665949,'EVASIVE ACTION! MAN THE GUNS!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665950,'Cowardly dogs! Ye blindsighted us!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665951,'This is not your battle, dwarf. Back down or we will be forced to destroy your ship.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665952,'Not me battle? I dunnae who ye? think ye are, mister, but I got a score to settle with Arthas and yer not gettin in me way! FIRE ALL GUNS! FIRE! FIRE!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665953,'Reavers, Sergeants, attack!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665954,'What''s this then?! Ye won''t be takin this son o Ironforge''s vessel without a fight!.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665955,'Axethrowers, hurl faster!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665956,'Rocketeers, reload!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665957,'We''re taking hull damage, get a battle-mage out here to shut down those cannons!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665958,'Don''t say I didn''t warn ya, scoundrels! Onward, brothers and sisters!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665959,'Captain Bartlett, get us out of here! We''re taken too much damage to stay afloat!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,'');
+
+# 4
+DELETE FROM `script_texts` WHERE `entry` BETWEEN -1631077 AND -1631029;
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(37200,-1631029, 'Let''s get a move on then! Move ou...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16974,1,0,0, 'SAY_INTRO_ALLIANCE_1'),
+(37813,-1631030, 'For every Horde soldier that you killed -- for every Alliance dog that fell, the Lich King''s armies grew. Even now the val''kyr work to raise your fallen as Scourge.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16701,1,0,0, 'SAY_INTRO_ALLIANCE_2'),
+(37813,-1631031, 'Things are about to get much worse. Come, taste the power that the Lich King has bestowed upon me!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16702,1,0,0, 'SAY_INTRO_ALLIANCE_3'),
+(37200,-1631032, 'A lone orc against the might of the Alliance???',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16970,1,0,0, 'SAY_INTRO_ALLIANCE_4'),
+(37200,-1631033, 'Charge!!!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16971,1,0,0, 'SAY_INTRO_ALLIANCE_5'),
+(37813,-1631034, 'Dwarves...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16703,1,0,0, 'SAY_INTRO_ALLIANCE_6'),
+(37813,-1631035, 'Deathbringer Saurfang immobilizes Muradin and his guards.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,2,0,0, 'SAY_INTRO_ALLIANCE_7'),
+(37187,-1631036, 'Kor''kron, move out! Champions, watch your backs. The Scourge have been...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17103,1,0,22, 'SAY_INTRO_HORDE_1'),
+(37813,-1631037, 'Join me, father. Join me and we will crush this world in the name of the Scourge -- for the glory of the Lich King!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16704,1,0,0, 'SAY_INTRO_HORDE_2'),
+(37187,-1631038, 'My boy died at the Wrath Gate. I am here only to collect his body.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17097,0,0,397, 'SAY_INTRO_HORDE_3'),
+(37813,-1631039, 'Stubborn and old. What chance do you have? I am stronger, and more powerful than you ever were.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16705,1,0,5, 'SAY_INTRO_HORDE_4'),
+(37187,-1631040, 'We named him Dranosh. It means "Heart of Draenor" in orcish. I would not let the warlocks take him. My boy would be safe, hidden away by the elders of Garadar.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17098,0,0,1, 'SAY_INTRO_HORDE_5'),
+(37187,-1631041, 'I made a promise to his mother before she died; that I would cross the Dark Portal alone - whether I lived or died, my son would be safe. Untainted...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17099,0,0,1, 'SAY_INTRO_HORDE_6'),
+(37187,-1631042, 'Today, I fulfill that promise.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17100,0,0,397, 'SAY_INTRO_HORDE_7'),
+(37187,-1631043, 'High Overlord Saurfang charges!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17104,2,0,53, 'SAY_INTRO_HORDE_8'),
+(37813,-1631044, 'Pathetic old orc. Come then heroes. Come and face the might of the Scourge!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16706,1,0,15, 'SAY_INTRO_HORDE_9'),
+(37813,-1631045, 'BY THE MIGHT OF THE LICH KING!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16694,1,0,0, 'SAY_AGGRO'),
+(37813,-1631046, 'The ground runs red with your blood!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16699,1,0,0, 'SAY_MARK_OF_THE_FALLEN_CHAMPION'),
+(37813,-1631047, 'Feast, my minions!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16700,1,0,0, 'SAY_BLOOD_BEASTS'),
+(37813,-1631048, 'You are nothing!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16695,1,0,0, 'SAY_KILL_1'),
+(37813,-1631049, 'Your soul will find no redemption here!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16696,1,0,0, 'SAY_KILL_2'),
+(37813,-1631050, 'Deathbringer Saurfang goes into frenzy!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0, 'SAY_FRENZY'),
+(37813,-1631051, 'I have become...DEATH!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16698,1,0,0, 'SAY_BERSERK'),
+(37813,-1631052, 'I... Am... Released.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16697,1,0,0, 'SAY_DEATH'),
+(37200,-1631053, 'Muradin Bronzebeard gasps for air.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16975,2,0,0, 'SAY_OUTRO_ALLIANCE_1'),
+(37200,-1631054, 'That was Saurfang''s boy - the Horde commander at the Wrath Gate. Such a tragic end...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16976,0,0,0, 'SAY_OUTRO_ALLIANCE_2'),
+(37200,-1631055, 'What in the... There, in the distance!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16977,0,0,0, 'SAY_OUTRO_ALLIANCE_3'),
+(    0,-1631056, 'A Horde Zeppelin flies up to the rise.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,2,0,0, 'SAY_OUTRO_ALLIANCE_4'),
+(37200,-1631057, 'Soldiers, fall in! Looks like the Horde are comin'' to take another shot!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16978,1,0,0, 'SAY_OUTRO_ALLIANCE_5'),
+(    0,-1631058, 'The Zeppelin docks, and High Overlord Saurfang hops out, confronting the Alliance soldiers and Muradin',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,2,0,0, 'SAY_OUTRO_ALLIANCE_6'),
+(37200,-1631059, 'Don''t force me hand, orc. We can''t let ye pass.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16972,0,0,0, 'SAY_OUTRO_ALLIANCE_7'),
+(37187,-1631060, 'Behind you lies the body of my only son. Nothing will keep me from him.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17094,0,0,0, 'SAY_OUTRO_ALLIANCE_8'),
+(37200,-1631061, 'I... I can''t do it. Get back on yer ship and we''ll spare yer life.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16973,0,0,0, 'SAY_OUTRO_ALLIANCE_9'),
+(    0,-1631062, 'A mage portal from Stormwind appears between the two and Varian Wrynn and Jaina Proudmoore emerge.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,2,0,0, 'SAY_OUTRO_ALLIANCE_10'),
+(37879,-1631063, 'Stand down, Muradin. Let a grieving father pass.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16690,0,0,0, 'SAY_OUTRO_ALLIANCE_11'),
+(37187,-1631064, 'High Overlord Saurfang walks over to his son and kneels before his son''s body.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,2,0,0, 'SAY_OUTRO_ALLIANCE_12'),
+(37187,-1631065, '[Orcish] No''ku kil zil''nok ha tar.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17096,0,0,0, 'SAY_OUTRO_ALLIANCE_13'),
+(37187,-1631066, 'Higher Overlord Saurfang picks up the body of his son and walks over towards Varian',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,2,0,0, 'SAY_OUTRO_ALLIANCE_14'),
+(37187,-1631067, 'I will not forget this... kindness. I thank you, Highness',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17095,0,0,0, 'SAY_OUTRO_ALLIANCE_15'),
+(37879,-1631068, 'I... I was not at the Wrath Gate, but the soldiers who survived told me much of what happened. Your son fought with honor. He died a hero''s death. He deserves a hero''s burial.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16691,0,0,0, 'SAY_OUTRO_ALLIANCE_16'),
+(37188,-1631069, 'Lady Jaina Proudmoore cries.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16651,2,0,18, 'SAY_OUTRO_ALLIANCE_17'),
+(37879,-1631070, 'Jaina? Why are you crying?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16692,0,0,0, 'SAY_OUTRO_ALLIANCE_18'),
+(37188,-1631071, 'It was nothing, your majesty. Just... I''m proud of my king.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16652,0,0,0, 'SAY_OUTRO_ALLIANCE_19'),
+(37879,-1631072, 'Bah! Muradin, secure the deck and prepare our soldiers for an assault on the upper citadel. I''ll send out another regiment from Stormwind.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16693,0,0,0, 'SAY_OUTRO_ALLIANCE_20'),
+(37200,-1631073, 'Right away, yer majesty!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16979,0,0,0, 'SAY_OUTRO_ALLIANCE_21'),
+(37187,-1631074, 'High Overlord Saurfang coughs.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17105,2,0,0, 'SAY_OUTRO_HORDE_1'),
+(37187,-1631075, 'High Overlord Saurfang weeps over the corpse of his son.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17106,2,0,15, 'SAY_OUTRO_HORDE_2'),
+(37187,-1631076, 'You will have a proper ceremony in Nagrand next to the pyres of your mother and ancestors.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17101,0,0,0, 'SAY_OUTRO_HORDE_3'),
+(37187,-1631077, 'Honor, young heroes... no matter how dire the battle... Never forsake it!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17102,0,0,0, 'SAY_OUTRO_HORDE_4');
+
+# 5
+DELETE FROM `script_texts` WHERE `entry` BETWEEN -1631090 AND -1631078;
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(36626,-1631078, 'NOOOO! You kill Stinky! You pay!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16907,1,0,0, 'SAY_STINKY_DEAD'),
+(36626,-1631079, 'Fun time!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16901,1,0,0, 'SAY_AGGRO'),
+(36678,-1631080, 'Just an ordinary gas cloud. But watch out, because that''s no ordinary gas cloud!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17119,1,0,432, 'SAY_GASEOUS_BLIGHT'),
+(36626,-1631081, 'Festergut farts.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16911,2,0,0, 'EMOTE_GAS_SPORE'),
+(36626,-1631082, 'Festergut releases Gas Spores!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0, 'EMOTE_WARN_GAS_SPORE'),
+(36626,-1631083, 'Gyah! Uhhh, I not feel so good...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16906,1,0,0, 'SAY_PUNGENT_BLIGHT'),
+(36626,-1631084, 'Festergut begins to cast |cFFFF7F00Pungent Blight!|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0, 'EMOTE_WARN_PUNGENT_BLIGHT'),
+(36626,-1631085, 'Festergut vomits.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,2,0,0, 'EMOTE_PUNGENT_BLIGHT'),
+(36626,-1631086, 'Daddy, I did it!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16902,1,0,0, 'SAY_KILL_1'),
+(36626,-1631087, 'Dead, dead, dead!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16903,1,0,0, 'SAY_KILL_2'),
+(36626,-1631088, 'Fun time over!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16905,1,0,0, 'SAY_BERSERK'),
+(36626,-1631089, 'Da ... Ddy...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16904,1,0,0, 'SAY_DEATH'),
+(36678,-1631090, 'Oh, Festergut. You were always my favorite. Next to Rotface. The good news is you left behind so much gas, I can practically taste it!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17124,1,0,0, 'SAY_FESTERGUT_DEATH');
+
+# 6
+DELETE FROM `script_texts` WHERE `entry` BETWEEN -1631103 AND -1631091;
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(36678,-1631091,'Great news, everyone! The slime is flowing again!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17126,1,0,1,'SAY_ROTFACE_OOZE_FLOOD1'),
+(36678,-1631092,'Good news, everyone! I''ve fixed the poison slime pipes!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17123,1,0,1,'SAY_ROTFACE_OOZE_FLOOD2'),
+(36678,-1631093,'Terrible news, everyone, Rotface is dead! But great news everyone, he left behind plenty of ooze for me to use! Whaa...? I''m a poet, and I didn''t know it? Astounding!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17146,1,0,0,'SAY_ROTFACE_DEATH'),
+(36627,-1631094,'What? Precious? Noooooooooo!!!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16993,1,0,0,'SAY_PRECIOUS_DIES'),
+(36627,-1631095,'WEEEEEE!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16986,1,0,0,'SAY_AGGRO'),
+(36627,-1631096,'%s begins to cast Slime Spray!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_SLIME_SPRAY'),
+(36627,-1631097,'Icky sticky.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16991,1,0,0,'SAY_SLIME_SPRAY'),
+(36627,-1631098,'|TInterface\Icons\spell_shadow_unstableaffliction_2.blp:16|t%s begins to cast |cFFFF0000Unstable Ooze Explosion!|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_UNSTABLE_EXPLOSION'),
+(36627,-1631099,'I think I made an angry poo-poo. It gonna blow!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16992,1,0,0,'SAY_UNSTABLE_EXPLOSION'),
+(36627,-1631100,'Daddy make toys out of you!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16988,1,0,0,'SAY_KILL_1'),
+(36627,-1631101,'I brokes-ded it...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16987,1,0,0,'SAY_KILL_2'),
+(36627,-1631102,'Sleepy Time!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16990,1,0,0,'SAY_BERSERK'),
+(36627,-1631103,'Bad news daddy...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16989,1,0,0,'SAY_DEATH');
+
+# 7
+DELETE FROM `script_texts` WHERE `entry` BETWEEN -1631114 AND -1631104;
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(36678,-1631104,'Good news, everyone! I think I perfected a plague that will destroy all life on Azeroth!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17114,1,0,0,'SAY_AGGRO'),
+(36678,-1631105,'%s begins to cast Unstable Experiment!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_UNSTABLE_EXPERIMENT'),
+(36678,-1631106,'Two oozes, one room! So many delightful possibilities...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17122,1,0,0,'SAY_PHASE_TRANSITION_HEROIC'),
+(36678,-1631107,'Hmm. I don''t feel a thing. Whaa...? Where''d those come from?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17120,1,0,15,'SAY_TRANSFORM_1'),
+(36678,-1631108,'Tastes like... Cherry! Oh! Excuse me!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17121,1,0,15,'SAY_TRANSFORM_2'),
+(36678,-1631109,'|TInterface\Icons\inv_misc_herb_evergreenmoss.blp:16|t%s cast |cFF00FF00Malleable Goo!|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_MALLEABLE_GOO'),
+(36678,-1631110,'%s cast |cFFFF7F00Choking Gas Bomb!|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_CHOKING_GAS_BOMB'),
+(36678,-1631111,'Hmm... Interesting...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17115,1,0,0,'SAY_KILL_1'),
+(36678,-1631112,'That was unexpected!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17116,1,0,0,'SAY_KILL_2'),
+(36678,-1631113,'Great news, everyone!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17118,1,0,0,'SAY_BERSERK'),
+(36678,-1631114,'Bad news, everyone! I don''t think I''m going to make it.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17117,1,0,0,'SAY_DEATH');
+
+# 8
+DELETE FROM `script_texts` WHERE `entry` BETWEEN -1631139 AND -1631115;
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(38004,-1631115,'Foolish mortals. You thought us defeated so easily? The San''layn are the Lich King''s immortal soldiers! Now you shall face their might combined!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16795,1,0,1,'SAY_INTRO_1'),
+(38004,-1631116,'Rise up, brothers, and destroy our enemies.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16796,1,0,0,'SAY_INTRO_2'),
+(37972,-1631117,'Such wondrous power! The Darkfallen Orb has made me INVINCIBLE!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16727,1,0,0,'SAY_KELESETH_INVOCATION'),
+(37972,-1631118,'Invocation of Blood jumps to Prince Keleseth!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_KELESETH_INVOCATION'),
+(37972,-1631119,'Blood will flow!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16728,1,0,0,'SAY_KELESETH_SPECIAL'),
+(37972,-1631120,'Were you ever a threat?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16723,1,0,0,'SAY_KELESETH_KILL_1'),
+(37972,-1631121,'Truth is found in death.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16724,1,0,0,'SAY_KELESETH_KILL_2'),
+(37972,-1631122,'%s cackles maniacally!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16726,2,0,0,'EMOTE_KELESETH_BERSERK'),
+(37972,-1631123,'My queen... they come...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16725,1,0,0,'SAY_KELESETH_DEATH'),
+(37973,-1631124,'Tremble before Taldaram, mortals, for the power of the orb flows through me!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16857,1,0,0,'SAY_TALDARAM_INVOCATION'),
+(37973,-1631125,'Invocation of Blood jumps to Prince Taldaram!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_TALDARAM_INVOCATION'),
+(37973,-1631126,'Delight in the pain!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16858,1,0,0,'SAY_TALDARAM_SPECIAL'),
+(37973,-1631127,'Inferno Flames speed toward $N!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_TALDARAM_FLAME'),
+(37973,-1631128,'Worm food.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16853,1,0,0,'SAY_TALDARAM_KILL_1'),
+(37973,-1631129,'Beg for mercy!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16854,1,0,0,'SAY_TALDARAM_KILL_2'),
+(37973,-1631130,'%s laughs.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16856,2,0,0,'EMOTE_TALDARAM_BERSERK'),
+(37973,-1631131,'%s gurgles and dies.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16855,2,0,0,'EMOTE_TALDARAM_DEATH'),
+(37970,-1631132,'Naxxanar was merely a setback! With the power of the orb, Valanar will have his vengeance!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16685,1,0,0,'SAY_VALANAR_INVOCATION'),
+(37970,-1631133,'Invocation of Blood jumps to Prince Valanar!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_VALANAR_INVOCATION'),
+(37970,-1631134,'My cup runneth over.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16686,1,0,0,'SAY_VALANAR_SPECIAL'),
+(37970,-1631135,'%s begins casting Empowered Schock Vortex!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_VALANAR_SHOCK_VORTEX'),
+(37970,-1631136,'Dinner... is served.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16681,1,0,0,'SAY_VALANAR_KILL_1'),
+(37970,-1631137,'Do you see NOW the power of the Darkfallen?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16682,1,0,0,'SAY_VALANAR_KILL_2'),
+(37970,-1631138,'BOW DOWN BEFORE THE SAN''LAYN!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16684,1,0,0,'SAY_VALANAR_BERSERK'),
+(37970,-1631139,'...why...?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16683,1,0,0,'SAY_VALANAR_DEATH');
+
+# 9
+INSERT INTO `script_texts`(`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(37955,-1666053,'Is that all you got?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16791,1,0,0,''),
+(37955,-1666054,'You have made an... unwise... decision.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16782,1,0,0,''),
+(37955,-1666055,'Just a taste...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16783,1,0,0,''),
+(37955,-1666056,'Know my hunger!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16784,1,0,0,''),
+(37955,-1666057,'SUFFER!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16786,1,0,0,''),
+(37955,-1666058,'Can you handle this?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16787,1,0,0,''),
+(37955,-1666059,'Yes... feed my precious one! You''re mine now! ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16790,1,0,0,''),
+(37955,-1666060,'Here it comes.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16788,1,0,0,''),
+(37955,-1666061,'THIS ENDS NOW!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16793,1,0,0,''),
+(37955,-1666062,'But... we were getting along... so well...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16794,1,0,0,'');
+
+# 10
+INSERT INTO `script_texts`(`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(36789,-1666063,'Heroes, lend me your aid! I... I cannot hold them off much longer! You must heal my wounds!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17064,1,0,0,''),
+(36789,-1666064,'I have opened a portal into the Emerald Dream. Your salvation lies within, heroes.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17068,1,0,0,''),
+(36789,-1666065,'My strength is returning! Press on, heroes!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17070,1,0,0,''),
+(36789,-1666066,'I will not last much longer!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17069,1,0,0,''),
+(36789,-1666067,'Forgive me for what I do! I... cannot... stop... ONLY NIGHTMARES REMAIN!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17072,1,0,0,''),
+(36789,-1666068,'A tragic loss...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17066,1,0,0,''),
+(36789,-1666069,'FAILURES!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17067,1,0,0,''),
+(36789,-1666070,'I am renewed! Ysera grants me the favor to lay these foul creatures to rest!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17071,1,0,0,'');
+
+# 11
+INSERT INTO `script_texts`(`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(36853,-1666071,'You are fools to have come to this place! The icy winds of Northrend will consume your souls!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17007,1,0,0,''),
+(36853,-1666072,'Suffer, mortals, as your pathetic magic betrays you!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17014,1,0,0,''),
+(36853,-1666073,'Can you feel the cold hand of death upon your heart?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17013,1,0,0,''),
+(36853,-1666074,'Aaah! It burns! What sorcery is this?!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17015,1,0,0,''),
+(36853,-1666075,'Your incursion ends here! None shall survive!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17012,1,0,0,''),
+(36853,-1666076,'Now feel my master''s limitless power and despair!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17016,1,0,0,''),
+(36853,-1666077,'Perish!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17008,1,0,0,''),
+(36853,-1666078,'A flaw of mortality...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17009,1,0,0,''),
+(36853,-1666079,'Enough! I tire of these games!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17011,1,0,0,''),
+(36853,-1666080,'Free...at last...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17010,1,0,0,'');
+
+# 12
+INSERT INTO script_texts (npc_entry,entry,content_default,content_loc1,content_loc2,content_loc3,content_loc4,content_loc5,content_loc6,content_loc7,content_loc8,sound,type,language,emote,comment)VALUES
+(36597,-1810001, 'So...the Light''s vaunted justice has finally arrived. Shall I lay down Frostmourne and throw myself at your mercy, Fordring?',null,null,null,null,null,null,null,null,17349,1,0,0,''),
+(38995,-1810002, 'We will grant you a swift death, Arthas. More than can be said for the thousands you''ve tortured and slain.',null,null,null,null,null,null,null,null,17390,1,0,0,''),
+(36597,-1810003, 'You will learn of that first hand. When my work is complete, you will beg for mercy -- and I will deny you. Your anguished cries will be testament to my unbridled power.',null,null,null,null,null,null,null,null,17350,1,0,0,''),
+(38995,-1810004, 'So be it. Champions, attack!',null,null,null,null,null,null,null,null,17391,1,0,0,''),
+(36597,-1810005, 'I''ll keep you alive to witness the end, Fordring. I would not want the Light''s greatest champion to miss seeing this wretched world remade in my image.',null,null,null,null,null,null,null,null,17351,1,0,0,''),
+(38995,-1810006, 'Come then champions, feed me your rage!',null,null,null,null,null,null,null,null,17352,1,0,0,''),
+(36597,-1810007, 'I will freeze you from within until all that remains is an icy husk!',null,null,null,null,null,null,null,null,17369,1,0,0,''),
+(36597,-1810008, 'Apocalypse!',null,null,null,null,null,null,null,null,17371,1,0,0,''),
+(36597,-1810009, 'Bow down before your lord and master!',null,null,null,null,null,null,null,null,17372,1,0,0,''),
+(36597,-1810010, 'Hope wanes!',null,null,null,null,null,null,null,null,17363,1,0,0,''),
+(36597,-1810011, 'The end has come!',null,null,null,null,null,null,null,null,17364,1,0,0,''),
+(36597,-1810012, 'Face now your tragic end!',null,null,null,null,null,null,null,null,17365,1,0,0,''),
+(36597,-1810013, 'No question remains unanswered. No doubts linger. You are Azeroth''s greatest champions! You overcame every challenge I laid before you. My mightiest servants have fallen before your relentless onslaught, your unbridled fury... Is it truly righteousness that drives you? I wonder.',null,null,null,null,null,null,null,null,17353,1,0,0,''),
+(36597,-1810014, 'You trained them well, Fordring. You delivered the greatest fighting force this world has ever known... right into my hands -- exactly as I intended. You shall be rewarded for your unwitting sacrifice.',null,null,null,null,null,null,null,null,17355,1,0,0,''),
+(36597,-1810015, 'Watch now as I raise them from the dead to become masters of the Scourge. They will shroud this world in chaos and destruction. Azeroth''s fall will come at their hands -- and you will be the first to die.',null,null,null,null,null,null,null,null,17356,1,0,0,''),
+(36597,-1810016, 'I delight in the irony.',null,null,null,null,null,null,null,null,17357,1,0,0,''),
+(38995,-1810017, 'LIGHT, GRANT ME ONE FINAL BLESSING. GIVE ME THE STRENGTH... TO SHATTER THESE BONDS!',null,null,null,null,null,null,null,null,17392,14,0,0,''),
+(36597,-1810018, 'Impossible...',null,null,null,null,null,null,null,null,17358,1,0,0,''),
+(38995,-1810020, 'No more, Arthas! No more lives will be consumed by your hatred!',null,null,null,null,null,null,null,null,17393,1,0,0,''),
+(38579,-1810021, 'Free at last! It is over, my son. This is the moment of reckoning.',null,null,null,null,null,null,null,null,17397,1,0,0,''),
+(38995,-1810022, 'The Lich King must fall!',null,null,null,null,null,null,null,null,17389,1,0,0,''),
+(38579,-1810023, 'Rise up, champions of the Light!',null,null,null,null,null,null,null,null,17398,1,0,0,''),
+(36597,-1810024, 'Now I stand, the lion before the lambs... and they do not fear.',null,null,null,null,null,null,null,null,17361,1,0,0,''),
+(36597,-1810025, 'They cannot fear.',null,null,null,null,null,null,null,null,17362,1,0,0,''),
+(0,-1810026, 'Argh... Frostmourne, obey me!',null,null,null,null,null,null,null,null,17367,1,0,0,''),
+(36597,-1810027, 'Frostmourne hungers...',null,null,null,null,null,null,null,null,17366,1,0,0,''),
+(0,-1810028, 'Frostmourne feeds on the soul of your fallen ally!',null,null,null,null,null,null,null,null,17368,1,0,0,''),
+(36597,-1810029, 'Val''kyr, your master calls!',null,null,null,null,null,null,null,null,17373,1,0,0,''),
+(36597,-1810030, 'Watch as the world around you collapses!',null,null,null,null,null,null,null,null,17370,1,0,0,''),
+(36597,-1810031, 'You gnats actually hurt me! Perhaps I''ve toyed with you long enough, now taste the vengeance of the grave!',null,null,null,null,null,null,null,null,17359,1,0,0,''),
+(36597,-1810032, 'The Lich King begins to cast Defile',null,null,null,null,null,null,null,null,0,3,0,0,'');
+
+# Locale
+
+# Леди
+
+UPDATE `script_texts` SET `content_loc8`='Вы здесь потому, что наделены особым знанием: вы понимаете, что на мир пало проклятье слепоты!' WHERE `entry`=-1631011;
+UPDATE `script_texts` SET `content_loc8`='Вам удалось сквозь пелену лжи разглядеть источник истиной силы!' WHERE `entry`=-1631012;
+UPDATE `script_texts` SET `content_loc8`='Посмотрите на свои руки, задумайтесь над нелепостью их строения!' WHERE `entry`=-1631013;
+UPDATE `script_texts` SET `content_loc8`='Кожа, мускулы, кровь, что пульсирует в жилах, все это говорит о вашем не совершенстве, вашей слабостью. Создатели жестоко пошутили над вами!' WHERE `entry`=-1631014;
+UPDATE `script_texts` SET `content_loc8`='Чем раньше вы осознаете собственную ущербность, тем скорее выберете иной путь!' WHERE `entry`=-1631015;
+UPDATE `script_texts` SET `content_loc8`='Для нашего господина нет ничего невозможного, его сила не знает границ, ничто не может сломить его волю!' WHERE `entry`=-1631016;
+UPDATE `script_texts` SET `content_loc8`='Тот, кто откажется повиноваться будет уничтожен. Тот же, кто будет служить ему верой и правдой, достигнет таких высот, о которых вы не в силах даже помыслить!' WHERE `entry`=-1631017;
+UPDATE `script_texts` SET `content_loc8`='Как вы смеете ступать в эти священные покои, это место станет вашей могилой!' WHERE `entry`=-1631018;
+UPDATE `script_texts` SET `content_loc8`='Довольно! Пришла пора взять все в свои руки!' WHERE `entry`=-1631019;
+UPDATE `script_texts` SET `content_loc8`='Прими это благословение и покажи чужакам мощь нашего господина!' WHERE `entry`=-1631022;
+UPDATE `script_texts` SET `content_loc8`='Я освобождаю тебя от проклятья плоти, мой верный слуга!' WHERE `entry`=-1631023;
+UPDATE `script_texts` SET `content_loc8`='Восстань и обрети истинную форму!' WHERE `entry`=-1631024;
+UPDATE `script_texts` SET `content_loc8`='Ты не в силах противится моей воле!' WHERE `entry`=-1631021;
+UPDATE `script_texts` SET `content_loc8`='Мне надоел этот фарс!' WHERE `entry`=-1631027;
+UPDATE `script_texts` SET `content_loc8`='На все воля господина...Ваша смерть неизбежна...' WHERE `entry`=-1631028;
+UPDATE `script_texts` SET `content_loc8`='Вы осознали бессмысленность своих действий?' WHERE `entry`=-1631025;
+UPDATE `script_texts` SET `content_loc8`='Ступай во тьму... Вечную тьму!' WHERE `entry`=-1631026;
+
+# Саурфанг
+
+UPDATE `script_texts` SET `content_loc8`='ВО ИМЯ КОРОЛЯ-ЛИЧА!' WHERE `entry`=-1631045;
+UPDATE `script_texts` SET `content_loc8`='Земля обагрится вашей кровью!' WHERE `entry`=-1631046;
+UPDATE `script_texts` SET `content_loc8`='Веселитесь, слуги мои!' WHERE `entry`=-1631047;
+UPDATE `script_texts` SET `content_loc8`='Ты ничтожество!' WHERE `entry`=-1631048;
+UPDATE `script_texts` SET `content_loc8`='Твоя душа не обретет покоя!' WHERE `entry`=-1631049;
+UPDATE `script_texts` SET `content_loc8`='Я... Cтал СМЕРТЬЮ!' WHERE `entry`=-1631051;
+UPDATE `script_texts` SET `content_loc8`='Я... Освободился.' WHERE `entry`=-1631052;
+UPDATE `script_texts` SET `content_loc8`='Все павшие войны Орды. Все дохлые псы Альянса. Все пополнят Армию Короля-лича. Даже сейчас Валь`киры воскрешают ваших покойников, чтобы те стали частью Плети!' WHERE `entry`=-1631030;
+UPDATE `script_texts` SET `content_loc8`='Сейчас всё будет ещё хуже. Идите сюда, я покажу вам какой силой меня наделил Король-лич!' WHERE `entry`=-1631031;
+UPDATE `script_texts` SET `content_loc8`='Ха-ха-ха! Дворфы...' WHERE `entry`=-1631034;
+UPDATE `script_texts` SET `content_loc8`='Присоеденись ко мне, отец. Перейди на мою сторону, и вместе мы разрушим этот мир во имя Плети и во славу Короля-лича!' WHERE `entry`=-1631037;
+UPDATE `script_texts` SET `content_loc8`='Старый упрямец. У тебя нет шансов! Я сильнее и могущественнее, чем ты можешь представить!' WHERE `entry`=-1631039;
+UPDATE `script_texts` SET `content_loc8`='Жалкий старик! Ну что ж, герои. Хотите узнать, сколь могущественна Плеть?' WHERE `entry`=-1631044;
+UPDATE `script_texts` SET `content_loc8`='Один орк против мощи Альянса?' WHERE `entry`=-1631032;
+UPDATE `script_texts` SET `content_loc8`='Кор''крон, выдвигайтесь! Герои, будьте начеку. Плеть только что...' WHERE `entry`=-1631036;
+UPDATE `script_texts` SET `content_loc8`='Мой мальчик погиб у Врат Гнева. Я здесь, чтобы забрать его тело.' WHERE `entry`=-1631038;
+UPDATE `script_texts` SET `content_loc8`='Мы назвали его Дранош - на орочьем это значит "Сердце Дренора". Я бы не позволил чернокнижникам збрать его. Он был бы в безопасности в Гарадаре под защитой старейшин.' WHERE `entry`=-1631040;
+UPDATE `script_texts` SET `content_loc8`='Я пообещал его матери, когда она умирала, что пройду через Темный Портал один. неважно, умер бы я или выжил - мой сын остался бы цел. И чист...' WHERE `entry`=-1631041;
+UPDATE `script_texts` SET `content_loc8`='Сегодня я исполню это обещание.' WHERE `entry`=-1631042;
+UPDATE `script_texts` SET `content_loc8`='Мы похороним тебя как подобает, в Награнде, рядом с матерью и предками...' WHERE `entry`=-1666002;
+UPDATE `script_texts` SET `content_loc8`='Помните о чести, герои... какой бы жестокой не была битва... никогда не трекайтесь от неё.' WHERE `entry`=-1666003;
+UPDATE `script_texts` SET `content_loc8`='Мурадин защищай палубу, и приготовь солдат к штурму верхних этажей Цитадели. Я вызову из Штормграда подкрепление.' WHERE `entry`=-1665998;
+UPDATE `script_texts` SET `content_loc8`='Отступи, Мурадин. Позволь пройти скорбящему отцу.' WHERE `entry`=-1631063;
+UPDATE `script_texts` SET `content_loc8`='Я... Я не был у Врат Гнева. Но многое узнал от выживших солдат. Твой сын сражался достойно. Он пал смертью героя. И заслуживает погребения с почестями.' WHERE `entry`=-1631068;
+UPDATE `script_texts` SET `content_loc8`='Джайна, почему ты плачешь?' WHERE `entry`=-1631070;
+
+# Гниломорд
+
+UPDATE `script_texts` SET `content_loc8`='Что? Прелесть? Нееееееееееееет!!!' WHERE `entry`=-1631094;
+UPDATE `script_texts` SET `content_loc8`='УУИИИИИИ!' WHERE `entry`=-1631095;
+UPDATE `script_texts` SET `content_loc8`='Отличные новости, народ! Слизь снова потелка!' WHERE `entry`=-1631091;
+UPDATE `script_texts` SET `content_loc8`='Отличные новости, народ! Я починил трубы для подачи ядовитой слизи!' WHERE `entry`=-1631092;
+UPDATE `script_texts` SET `content_loc8`='Папочка сделает новые игрушки из вас!' WHERE `entry`=-1631100;
+UPDATE `script_texts` SET `content_loc8`='Я это заломал...' WHERE `entry`=-1631101;
+UPDATE `script_texts` SET `content_loc8`='Папочка, не огорчайся…' WHERE `entry`=-1631103;
+UPDATE `script_texts` SET `content_loc8`='Я сделал очень злую каку! Сейчас взорвется!' WHERE `entry`=-1631099;
+
+# Тухлопуз
+
+UPDATE `script_texts` SET `content_loc8`='Тухлопуз, ты всегда был моим любимчиком, как и Гниломорд! Молодец, что оставил столько газа. Я его даже чувствую!' WHERE `entry`=-1631090;
+UPDATE `script_texts` SET `content_loc8`='Нет! Вы убили Вонючку! Сейчас получите!' WHERE `entry`=-1631078;
+UPDATE `script_texts` SET `content_loc8`='Повеселимся?' WHERE `entry`=-1631079;
+UPDATE `script_texts` SET `content_loc8`='Что-то мне нехорошо...' WHERE `entry`=-1631083;
+UPDATE `script_texts` SET `content_loc8`='Веселью конец!' WHERE `entry`=-1631088;
+UPDATE `script_texts` SET `content_loc8`='Па-па...' WHERE `entry`=-1631089;
+UPDATE `script_texts` SET `content_loc8`='Мер-твец, мер-твец, мер-твец!' WHERE `entry`=-1631087;
+UPDATE `script_texts` SET `content_loc8`='Папочка! У меня получилось!' WHERE `entry`=-1631086;
+UPDATE `script_texts` SET `content_loc8`='Это обычное облаго газа, только будьте осторожны, не такое уж оно и обычное!' WHERE `entry`=-1631080;
+
+# Профессор Мерзоцоид
+
+UPDATE `script_texts` SET `content_loc8`='Отличные новости, народ! Я усовершенствовал штамм чумы, которая уничтожит весь Азерот!' WHERE `entry`=-1666026;
+UPDATE `script_texts` SET `content_loc8`='Хм, что-то я ничего не чувствую. Что?! Это еще откуда?' WHERE `entry`=-1666029;
+UPDATE `script_texts` SET `content_loc8`='На вкус, как вишенка! ОЙ! Извиниите!' WHERE `entry`=-1666030;
+UPDATE `script_texts` SET `content_loc8`='Плохие новости, народ… Похоже, у меня ничего не выйдет…' WHERE `entry`=-1666034;
+UPDATE `script_texts` SET `content_loc8`='Герои, вы должны мне помочь! Мои силы... на исходе. Залечите мои раны...' WHERE `entry`=-1666063;
+UPDATE `script_texts` SET `content_loc8`='Я открыла портал в Изумруднй Сон. Там вы найдете спасение, герои.' WHERE `entry`=-1666064;
+UPDATE `script_texts` SET `content_loc8`='Силы возвращаются ко мне. Герои, ещё немного!' WHERE `entry`=-1666065;
+UPDATE `script_texts` SET `content_loc8`='Я долго не продержусь!' WHERE `entry`=-1666066;
+UPDATE `script_texts` SET `content_loc8`='Прискорбная потеря...' WHERE `entry`=-1666068;
+UPDATE `script_texts` SET `content_loc8`='Простите меня! Я... не могу... оста... ВСЁ ВО ВЛАСТИ КОШМАРА!' WHERE `entry`=-1666067;
+UPDATE `script_texts` SET `content_loc8`='НЕУДАЧНИКИ!' WHERE `entry`=-16660690;
+UPDATE `script_texts` SET `content_loc8`='Я ИЗЛЕЧИЛАСЬ! Изера, даруй мне силу покончить с этими нечистивыми тварями.' WHERE `entry`=-1666070;
+
+# Синдрагоса
+
+UPDATE `script_texts` SET `content_loc8`='Глупцы, зачем вы сюда явились! Ледяные ветра Нордскола унесут ваши души!' WHERE `entry`=-1666071;
+UPDATE `script_texts` SET `content_loc8`='Трепещите, смертные, ибо ваша жалкая магия теперь бессильна!' WHERE `entry`=-1666072;
+UPDATE `script_texts` SET `content_loc8`='Вы чувствуете?' WHERE `entry`=-1666073;
+UPDATE `script_texts` SET `content_loc8`='Ааах! Жжется! Что это за магия?!' WHERE `entry`=-1666074;
+UPDATE `script_texts` SET `content_loc8`='Сейчас вы почуствуете всю мощь нашего господина!' WHERE `entry`=-1666076;
+UPDATE `script_texts` SET `content_loc8`='Погибни!' WHERE `entry`=-1666077;
+UPDATE `script_texts` SET `content_loc8`='Удел смертных...' WHERE `entry`=-1666078;
+UPDATE `script_texts` SET `content_loc8`='Довольно! Я устала от этих игр!' WHERE `entry`=-1666079;
+UPDATE `script_texts` SET `content_loc8`='Наконец-то...свободна...' WHERE `entry`=-1666080;
+
+# КОРОЛЬ-ЛИЧ
+
+UPDATE `script_texts` SET `content_loc8`='Неужели прибыли наконец хваленые силы Света? Мне бросить Ледяную Скорбь и сдаться на твою милось, Фордринг?' WHERE `entry`=-1810001;
+UPDATE `script_texts` SET `content_loc8`='Мы даруем тебе быструю смерть, Артас. Более быструю, чем ты заслуживаешь за то, что замучал и погубил десятки тысяч душ' WHERE `entry`=-1810002;
+UPDATE `script_texts` SET `content_loc8`='Ты пройдешь через эти мучения сам. И будешь МОЛИТЬ о пощаде, но я не буду слушать. Твои отчаянные крики послужат доказательством моей безграничной мощи.' WHERE `entry`=-1810003;
+UPDATE `script_texts` SET `content_loc8`='Да будет так. Чемпионы, в атаку!' WHERE `entry`=-1810004;
+UPDATE `script_texts` SET `content_loc8`='Я оставлю тебя в живых, чтобы ты увидел финал. Не могу допустить, чтобы величайший служитель Света пропустил рождение МОЕГО МИРА.' WHERE `entry`=-1810005;
+UPDATE `script_texts` SET `content_loc8`='Я проморожу вас насквозь - и вы разлетитесь на ледяные осколки.' WHERE `entry`=-1810007;
+UPDATE `script_texts` SET `content_loc8`='КОНЕЦ СВЕТА!' WHERE `entry`=-1810008;
+UPDATE `script_texts` SET `content_loc8`='Склонись перед своим господином и повелителем!.' WHERE `entry`=-1810009;
+UPDATE `script_texts` SET `content_loc8`='Надежда тает!' WHERE `entry`=-1810010;
+UPDATE `script_texts` SET `content_loc8`='Пришел КОНЕЦ!' WHERE `entry`=-1810011;
+UPDATE `script_texts` SET `content_loc8`='Встречайте трагический финал!' WHERE `entry`=-1810012;
+UPDATE `script_texts` SET `content_loc8`='Сомнений нет, вы величайшие герои Азерота! Вы преодолели все препятствия, которые я воздвиг перед вами. Сильнейшие из моих слуг пали под вашим натиском, сгорели в пламени вашей ярости!' WHERE `entry`=-1810013;
+UPDATE `script_texts` SET `content_loc8`='Ты отлично их обучил, Фордринг! ' WHERE `entry`=-1810014;
+UPDATE `script_texts` SET `content_loc8`='Смотри, как я буду всокрешать их, и превращать в воинов Плети! Они повергнут этот мир в пучину хаоса. Азерот падет от их рук! и ты станешь первой жертвой.' WHERE `entry`=-1810015;
+UPDATE `script_texts` SET `content_loc8`='Мне по душе эта ирония.' WHERE `entry`=-1810016;
+UPDATE `script_texts` SET `content_loc8`='СВЕТ, ДАРУЙ МНЕ ПОСЛЕДНЕЕ БЛАГОСЛОВЛЕНИЕ... ДАЙ МНЕ СИЛЫ РАЗБИТЬ ЭТИ ОКОВЫ!' WHERE `entry`=-1810017;
+UPDATE `script_texts` SET `content_loc8`='Невозможно...' WHERE `entry`=-1810018;
+UPDATE `script_texts` SET `content_loc8`='Аах! Вы меня и правда ранили. Я слишком долго с вами играл! Испытайте на себе Возмездие СМЕРТИ!' WHERE `entry`=-1666080;
+UPDATE `script_texts` SET `content_loc8`='И вот я стою как лев пред агнцами... И не дрожат они.' WHERE `entry`=-1810024;
+UPDATE `script_texts` SET `content_loc8`='Им неведом страх.' WHERE `entry`=-1810025;
+UPDATE `script_texts` SET `content_loc8`='Ну же герои, в вашей ярости моя сила!' WHERE `entry`=-1810006;
+UPDATE `script_texts` SET `content_loc8`='Ледяная Скорбь жаждет крови!' WHERE `entry`=-1810027;
+UPDATE `script_texts` SET `content_loc8`='Ледяная Скорбь поглотит душу вашего товарища.' WHERE `entry`=-1810028;
+UPDATE `script_texts` SET `content_loc8`='Смотрите как мир рушится вокруг вас!' WHERE `entry`=-1810030;
+UPDATE `script_texts` SET `content_loc8`='Валь''кира, твой гсоподин зовет!' WHERE `entry`=-1810029;
+UPDATE `script_texts` SET `content_loc8`='Хватит, Артас! Твоя ненависть не заберет больше ни одной жизни!' WHERE `entry`=-1810020;
+UPDATE `script_texts` SET `content_loc8`='Вы пришли, что бы вершить суд над Артасом? Что бы уничтожить Короля-лича?' WHERE `entry`=-1666080;
+UPDATE `script_texts` SET `content_loc8`='Вы не должны оказаться во власти Ледяной Скорби. Иначе, как и я, будете навек порабощены этим проклятым клинком!' WHERE `entry`=-1666080;
+UPDATE `script_texts` SET `content_loc8`='Помогите мне уничтожить эти истерзанные души! Вместе мы вытянем силу из Ледяной Скорби и ослабим Короля-лича!' WHERE `entry`=-1666080;
+UPDATE `script_texts` SET `content_loc8`='Наконец я свободен! Всё кончено, сын мой... Настал час расплаты!' WHERE `entry`=-1810021;
+UPDATE `script_texts` SET `content_loc8`='Поднимитесь, Воины Света!' WHERE `entry`=-1810023;
+UPDATE `script_texts` SET `content_loc8`='Король-лич падет!' WHERE `entry`=-1810022;
\ No newline at end of file
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 81b0233..8d9b2e7 100755
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -7926,6 +7926,15 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, AuraEffect* trig
                             CastSpell(pVictim, 27526, true, castItem, triggeredByAura);
                         return true;
                     }
+                    // Mark of the Fallen Champion
+                    case 72293:
+                        if(pVictim && pVictim->HasAura(72293) && !pVictim->isAlive())
+                        {
+                            Creature* saurfang = pVictim->FindNearestCreature(37813, 500.0f, true);
+                                if(saurfang && saurfang->isAlive())
+                                   saurfang->CastSpell(saurfang, 72260, true);
+                        }
+                        return true;
                 }
                 break;
             case SPELLFAMILY_MAGE:
@@ -8628,10 +8637,6 @@ bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, AuraEffect* trig
                 return false;
             break;
         }
-        // Deathbringer Saurfang - Blood Link
-        case 72202:
-            target = FindNearestCreature(37813, 75.0f); // NPC_DEATHBRINGER_SAURFANG = 37813
-            break;
         // Shadow's Fate (Shadowmourne questline)
         case 71169:
         {
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 794bb10..902a559 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -463,16 +463,19 @@ void AddSC_instance_halls_of_reflection();   // Halls of Reflection
 void AddSC_halls_of_reflection();
 void AddSC_boss_falric();
 void AddSC_boss_marwyn();
-void AddSC_boss_lord_marrowgar();       // Icecrown Citadel
-void AddSC_boss_lady_deathwhisper();
-void AddSC_boss_deathbringer_saurfang();
+void AddSC_instance_icecrown_citadel(); //Icecrown Citadel
+void AddSC_boss_saurfang();
 void AddSC_boss_festergut();
-void AddSC_boss_rotface();
+void AddSC_boss_lady_deathwhisper();
+void AddSC_boss_lord_marrowgar();
 void AddSC_boss_professor_putricide();
-void AddSC_boss_blood_prince_council();
+void AddSC_boss_sindragosa();
+void AddSC_boss_lichking();
+void AddSC_boss_rotface();
+void AddSC_boss_rat_des_blutes();
+void AddSC_icecrown_citadel();
 void AddSC_boss_blood_queen_lana_thel();
-void AddSC_icecrown_citadel_teleport();
-void AddSC_instance_icecrown_citadel();
+void AddSC_boss_valithria();
 
 void AddSC_dalaran();
 void AddSC_borean_tundra();
@@ -1150,16 +1153,19 @@ void AddNorthrendScripts()
     AddSC_halls_of_reflection();
     AddSC_boss_falric();
     AddSC_boss_marwyn();
-    AddSC_boss_lord_marrowgar();        // Icecrown Citadel
-    AddSC_boss_lady_deathwhisper();
-    AddSC_boss_deathbringer_saurfang();
+    AddSC_instance_icecrown_citadel(); //Icecrown Citadel
+    AddSC_boss_saurfang();
     AddSC_boss_festergut();
-    AddSC_boss_rotface();
+    AddSC_boss_lady_deathwhisper();
+    AddSC_boss_lord_marrowgar();
     AddSC_boss_professor_putricide();
-    AddSC_boss_blood_prince_council();
+    AddSC_boss_sindragosa();
+    AddSC_boss_lichking();
+    AddSC_boss_rotface();
+    AddSC_boss_rat_des_blutes();
+    AddSC_icecrown_citadel();
     AddSC_boss_blood_queen_lana_thel();
-    AddSC_icecrown_citadel_teleport();
-    AddSC_instance_icecrown_citadel();
+    AddSC_boss_valithria();
 
     AddSC_dalaran();
     AddSC_borean_tundra();
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
index f811b20..7fa54fe 100755
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -1888,6 +1888,8 @@ void AuraEffect::PeriodicTick(AuraApplication * aurApp, Unit * caster) const
                 target->CastSpell((Unit*)NULL , GetAmount() , true);
             break;
         case SPELL_AURA_PERIODIC_DUMMY:
+            if(GetId() == 72178)
+                caster->CastSpell(caster, 72202, true);
             PeriodicDummyTick(target, caster);
             break;
         case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index 819ec8e..ab7934f 100755
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -5117,6 +5117,12 @@ SpellCastResult Spell::CheckCast(bool strict)
                     if (m_caster->IsInWater())
                         return SPELL_FAILED_ONLY_ABOVEWATER;
                 }
+				else if (m_spellInfo->Id == 72202) //Blood Link
+				{
+				    Creature* saurfang = m_caster->FindNearestCreature(37813, 500.0f, true);
+					if(saurfang && saurfang->isAlive())
+					    saurfang->CastSpell(saurfang, 72195, true);
+				}
                 else if (m_spellInfo->SpellIconID == 156)    // Holy Shock
                 {
                     // spell different for friends and enemies
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
index f1c80b1..5a6afc6 100644
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -143,16 +143,20 @@ set(scripts_STAT_SRCS
   Northrend/VioletHold/boss_xevozz.cpp
   Northrend/VioletHold/boss_erekem.cpp
   Northrend/VioletHold/violet_hold.cpp
-  Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
+  Northrend/IcecrownCitadel/boss_sindragosa.cpp
+  Northrend/IcecrownCitadel/boss_the_lich_king.cpp
+  Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
+  Northrend/IcecrownCitadel/icecrown_citadel.cpp
   Northrend/IcecrownCitadel/icecrown_citadel.h
-  Northrend/IcecrownCitadel/icecrown_citadel_teleport.cpp
-  Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
-  Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
+  Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
   Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
   Northrend/IcecrownCitadel/boss_festergut.cpp
-  Northrend/IcecrownCitadel/boss_rotface.cpp
+  Northrend/IcecrownCitadel/boss_gunship_battle.cpp
+  Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
+  Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
   Northrend/IcecrownCitadel/boss_professor_putricide.cpp
-  Northrend/IcecrownCitadel/boss_blood_prince_council.cpp
+  Northrend/IcecrownCitadel/boss_rat_des_blutes.cpp
+  Northrend/IcecrownCitadel/boss_rotface.cpp
   Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
   Northrend/zuldrak.cpp
   Northrend/icecrown.cpp
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
index 8d3eace..c829fa8 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
@@ -1,598 +1,288 @@
-/*
- * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "ObjectMgr.h"
-#include "ScriptMgr.h"
-#include "ScriptedCreature.h"
-#include "SpellScript.h"
-#include "Spell.h"
-#include "SpellAuraEffects.h"
+/* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include "ScriptPCH.h"
 #include "icecrown_citadel.h"
 
-enum Texts
+enum Yells
 {
-    SAY_AGGRO                   = 0,
-    SAY_VAMPIRIC_BITE           = 1,
-    SAY_MIND_CONTROL            = 2,
-    EMOTE_BLOODTHIRST           = 3,
-    SAY_SWARMING_SHADOWS        = 4,
-    EMOTE_SWARMING_SHADOWS      = 5,
-    SAY_PACT_OF_THE_DARKFALLEN  = 6,
-    SAY_AIR_PHASE               = 7,
-    SAY_KILL                    = 8,
-    SAY_WIPE                    = 9,
-    SAY_BERSERK                 = 10,
-    SAY_DEATH                   = 11,
+    SAY_AGGRO            = -1666054,
+    SAY_VAMP_BITE_1      = -1666055,
+    SAY_VAMP_BITE_2      = -1666056,
+    SAY_SWARM_SHADOWS    = -1666057,
+    SAY_PACT_DARKFALLEN  = -1666058,
+    SAY_MIND_CONTROLL    = -1666059,
+    SAY_AIR_PHASE        = -1666060,
+    SAY_BERSERK          = -1666061,
+    SAY_DEATH            = -1666062
 };
 
 enum Spells
 {
-    SPELL_SHROUD_OF_SORROW                  = 70986,
-    SPELL_FRENZIED_BLOODTHIRST_VISUAL       = 71949,
-    SPELL_VAMPIRIC_BITE                     = 71726,
-    SPELL_ESSENCE_OF_THE_BLOOD_QUEEN_PLR    = 70879,
-    SPELL_FRENZIED_BLOODTHIRST              = 70877,
-    SPELL_UNCONTROLLABLE_FRENZY             = 70923,
-    SPELL_PRESENCE_OF_THE_DARKFALLEN        = 71952,
-    SPELL_BLOOD_MIRROR_DAMAGE               = 70821,
-    SPELL_BLOOD_MIRROR_VISUAL               = 71510,
-    SPELL_BLOOD_MIRROR_DUMMY                = 70838,
-    SPELL_DELIRIOUS_SLASH                   = 71623,
-    SPELL_PACT_OF_THE_DARKFALLEN_TARGET     = 71336,
-    SPELL_PACT_OF_THE_DARKFALLEN            = 71340,
-    SPELL_SWARMING_SHADOWS                  = 71264,
-    SPELL_TWILIGHT_BLOODBOLT_TARGET         = 71445,
-    SPELL_TWILIGHT_BLOODBOLT                = 71446,
-    SPELL_INCITE_TERROR                     = 73070,
-    SPELL_BLOODBOLT_WHIRL                   = 71772,
+    SPELL_PRESENCE_OF_DARKFALLEN    = 71952,
+    SPELL_SHROUD_OF_SORROW          = 72981,
+    SPELL_DELIRIOUS_SLASH           = 71623,
+    SPELL_BLOOD_MIRROR_1            = 70821,
+    SPELL_BLOOD_MIRROR_2            = 71510,
+    SPELL_VAMPIRIC_BITE             = 71726,
+    SPELL_PACT_OF_THE_DARKFALLEN_1  = 71340,
+    SPELL_PACT_OF_THE_DARKFALLEN_2  = 71341,
+    SPELL_SWARMING_SHADOWS          = 71264,
+    SPELL_TWILIGHT_BLOODBOLT        = 71446,
+    SPELL_BLOODBOLT_WHIRL           = 71899,
+    SPELL_BLOODBOLT_SPLASH          = 71447,
+    SPELL_INCITE_TERROR             = 73070,
+    SPELL_SWARMING_SHADOWS_VISUAL   = 71267,
+    SPELL_SWARMING_SHADOW           = 71267,
+    SPELL_ESSENCE_OF_BLOOD_QWEEN    = 70867,
+    SPELL_FRENZIED_BLOODTHIRST      = 70877,
+    SPELL_UNCONTROLLABLE_FRENZY     = 70923
 };
 
-enum Shadowmourne
+const Position SpawnLoc[]=
 {
-    QUEST_BLOOD_INFUSION                    = 24756,
-    ITEM_SHADOW_S_EDGE                      = 49888,
-
-    SPELL_GUSHING_WOUND                     = 72132,
-    SPELL_THIRST_QUENCHED                   = 72154,
-};
-
-static const uint32 vampireAuras[3][MAX_DIFFICULTY] =
-{
-    {70867, 71473, 71532, 71533},
-    {70879, 71525, 71530, 71531},
-    {70877, 71474, 70877, 71474},
-};
-
-#define ESSENCE_OF_BLOOD_QUEEN     RAID_MODE<uint32>(70867,71473,71532,71533)
-#define ESSENCE_OF_BLOOD_QUEEN_PLR RAID_MODE<uint32>(70879,71525,71530,71531)
-#define FRENZIED_BLOODTHIRST       RAID_MODE<uint32>(70877,71474,70877,71474)
-
-enum eEvents
-{
-    EVENT_BERSERK                   = 1,
-    EVENT_VAMPIRIC_BITE             = 2,
-    EVENT_BLOOD_MIRROR              = 3,
-    EVENT_DELIRIOUS_SLASH           = 4,
-    EVENT_PACT_OF_THE_DARKFALLEN    = 5,
-    EVENT_SWARMING_SHADOWS          = 6,
-    EVENT_TWILIGHT_BLOODBOLT        = 7,
-    EVENT_AIR_PHASE                 = 8,
-    EVENT_AIR_START_FLYING          = 9,
-    EVENT_AIR_FLY_DOWN              = 10,
-
-    EVENT_GROUP_NORMAL              = 1,
-    EVENT_GROUP_CANCELLABLE         = 2,
+    {4595.640f, 2769.195f, 400.137f, 0.0f}, //phase 2 pos
+    {4595.904f, 2769.315f, 421.838f, 0.0f} //fly pos
 };
 
-#define GUID_VAMPIRE 1
-
-enum ePoints
-{
-    POINT_CENTER    = 1,
-    POINT_AIR       = 2,
-    POINT_GROUND    = 3,
-};
-
-static const Position centerPos = {4595.7090f, 2769.4190f, 400.6368f, 0.0000f};
-static const Position airPos    = {4595.7090f, 2769.4190f, 422.3893f, 0.0000f};
-
-bool IsVampire(Unit const* unit)
-{
-    for (uint8 i = 0; i < 3; ++i)
-        if (unit->HasAura(vampireAuras[i][unit->GetMap()->GetSpawnMode()]))
-            return true;
-    return false;
-}
-
-class boss_blood_queen_lana_thel : public CreatureScript
+class boss_blood_queen_lanathel : public CreatureScript
 {
     public:
-        boss_blood_queen_lana_thel() : CreatureScript("boss_blood_queen_lana_thel") { }
+        boss_blood_queen_lanathel() : CreatureScript("boss_blood_queen_lanathel") { }
 
-        struct boss_blood_queen_lana_thelAI : public BossAI
+        struct boss_blood_queen_lanathelAI : public BossAI
         {
-            boss_blood_queen_lana_thelAI(Creature* creature) : BossAI(creature, DATA_BLOOD_QUEEN_LANA_THEL)
+            boss_blood_queen_lanathelAI(Creature* pCreature) : BossAI(pCreature, DATA_BLOOD_QUEEN_LANATHEL)
             {
-            }
-
-            void InitializeAI()
-            {
-                if (!instance || static_cast<InstanceMap*>(me->GetMap())->GetScriptId() != GetScriptId(ICCScriptName))
-                    me->IsAIEnabled = false;
-                else if (!me->isDead())
-                    Reset();
+                pInstance = me->GetInstanceScript();
             }
 
             void Reset()
             {
-                events.Reset();
-                events.ScheduleEvent(EVENT_BERSERK, 330000);
-                events.ScheduleEvent(EVENT_VAMPIRIC_BITE, 15000);
-                events.ScheduleEvent(EVENT_BLOOD_MIRROR, 2500, EVENT_GROUP_CANCELLABLE);
-                events.ScheduleEvent(EVENT_DELIRIOUS_SLASH, urand(20000, 24000), EVENT_GROUP_NORMAL);
-                events.ScheduleEvent(EVENT_PACT_OF_THE_DARKFALLEN, 15000, EVENT_GROUP_NORMAL);
-                events.ScheduleEvent(EVENT_SWARMING_SHADOWS, 30500, EVENT_GROUP_NORMAL);
-                events.ScheduleEvent(EVENT_TWILIGHT_BLOODBOLT, urand(20000, 25000), EVENT_GROUP_NORMAL);
-                events.ScheduleEvent(EVENT_AIR_PHASE, 124000 + uint32(Is25ManRaid() ? 3000 : 0));
-                me->SetSpeed(MOVE_FLIGHT, 0.642857f, true);
-                offtank = NULL;
-                vampires.clear();
-
-                instance->SetBossState(DATA_BLOOD_QUEEN_LANA_THEL, NOT_STARTED);
-            }
-
-            void EnterCombat(Unit* who)
-            {
-                if (!instance->CheckRequiredBosses(DATA_BLOOD_QUEEN_LANA_THEL, who->ToPlayer()))
-                {
-                    instance->DoCastSpellOnPlayers(LIGHT_S_HAMMER_TELEPORT);
-                    EnterEvadeMode();
-                    return;
-                }
-
-                DoZoneInCombat();
-                Talk(SAY_AGGRO);
-                instance->SetBossState(DATA_BLOOD_QUEEN_LANA_THEL, IN_PROGRESS);
-
-                DoCast(me, SPELL_SHROUD_OF_SORROW, true);
-                DoCast(me, SPELL_FRENZIED_BLOODTHIRST_VISUAL, true);
-            }
-
-            void JustDied(Unit* /*killer*/)
-            {
-                Talk(SAY_DEATH);
-                instance->DoRemoveAurasDueToSpellOnPlayers(ESSENCE_OF_BLOOD_QUEEN);
-                instance->DoRemoveAurasDueToSpellOnPlayers(ESSENCE_OF_BLOOD_QUEEN_PLR);
-                instance->DoRemoveAurasDueToSpellOnPlayers(FRENZIED_BLOODTHIRST);
-                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_UNCONTROLLABLE_FRENZY);
-                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_BLOOD_MIRROR_DAMAGE);
-                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_BLOOD_MIRROR_VISUAL);
-                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_BLOOD_MIRROR_DUMMY);
-                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_DELIRIOUS_SLASH);
-                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_PACT_OF_THE_DARKFALLEN);
-                instance->SetBossState(DATA_BLOOD_QUEEN_LANA_THEL, DONE);
+                m_uiPhase = 1;
+                m_uiPhaseTimer = 90000;
+                m_uiTwilightBloodboltTimer = 10000;
+                m_uiVampBiteTimer  = 15000;
+                m_uiSwarmingShadowsTimer = 30000;
+                m_uiPactofDarkfallenTimer  = 5000;
+                m_uiSetHoverTimer = 90000;
+                m_uiBloodboldSplashTimer = 900000;
+                m_uiLandingTimer = 900000;
+                m_uiFlyingFalseTimer = 900000;
+                m_uiBerserkTimer = 330000;
+
+                memset(&Darkfallen, 0, sizeof(Darkfallen));
+
+                if (pInstance && me->isAlive())
+                    pInstance->SetData(DATA_BLOOD_QUEEN_LANATHEL_EVENT, NOT_STARTED);
             }
 
-            void JustReachedHome()
+            void EnterCombat(Unit* /*who*/)
             {
-                Talk(SAY_WIPE);
-                instance->SetBossState(DATA_BLOOD_QUEEN_LANA_THEL, FAIL);
-            }
+                DoScriptText(SAY_AGGRO, me);
+                DoCast(SPELL_SHROUD_OF_SORROW);
 
-            void KilledUnit(Unit* victim)
-            {
-                if (victim->GetTypeId() == TYPEID_PLAYER)
-                    Talk(SAY_KILL);
+                if (pInstance)
+                    pInstance->SetData(DATA_BLOOD_QUEEN_LANATHEL_EVENT, IN_PROGRESS);
             }
 
-            void SetGUID(const uint64& guid, int32 type = 0)
+            void KilledUnit(Unit* pVictim)
             {
-                if (type == GUID_VAMPIRE)
-                    vampires.insert(guid);
+                pVictim->RemoveAllAuras();
             }
 
-            void MovementInform(uint32 type, uint32 id)
+            void JustDied(Unit* /*Killer*/)
             {
-                if (type != POINT_MOTION_TYPE)
-                    return;
+                DoScriptText(SAY_DEATH, me);
 
-                switch (id)
-                {
-                    case POINT_CENTER:
-                        DoCast(me, SPELL_INCITE_TERROR);
-                        events.ScheduleEvent(EVENT_AIR_PHASE, 100000 + uint32(Is25ManRaid() ? 0 : 20000));
-                        events.RescheduleEvent(EVENT_SWARMING_SHADOWS, 30500, EVENT_GROUP_NORMAL);
-                        events.RescheduleEvent(EVENT_PACT_OF_THE_DARKFALLEN, 25500, EVENT_GROUP_NORMAL);
-                        events.ScheduleEvent(EVENT_AIR_START_FLYING, 5000);
-                        break;
-                    case POINT_AIR:
-                        DoCast(me, SPELL_BLOODBOLT_WHIRL);
-                        Talk(SAY_AIR_PHASE);
-                        events.ScheduleEvent(EVENT_AIR_FLY_DOWN, 10000);
-                        break;
-                    case POINT_GROUND:
-                        me->RemoveUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                        me->RemoveByteFlag(UNIT_FIELD_BYTES_1, 3, 0x01);
-                        me->SetFlying(false);
-                        me->SetReactState(REACT_AGGRESSIVE);
-                        AttackStart(me->getVictim());
-                        events.ScheduleEvent(EVENT_BLOOD_MIRROR, 2500, EVENT_GROUP_CANCELLABLE);
-                        break;
-                    default:
-                        break;
-                }
+                if (pInstance)
+                    pInstance->SetData(DATA_BLOOD_QUEEN_LANATHEL_EVENT, DONE);
             }
 
-            void UpdateAI(const uint32 diff)
+            void UpdateAI(const uint32 uiDiff)
             {
-                if (!UpdateVictim() || !CheckInRoom())
+                if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
+                if (!me->HasAura(SPELL_SHROUD_OF_SORROW))
+                    DoCast(me, SPELL_SHROUD_OF_SORROW);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
-                    return;
+                if (m_uiBerserkTimer < uiDiff)
+                {
+                    DoScriptText(SAY_BERSERK, me);
+                    DoCast(me, SPELL_BERSERK);
+                    m_uiBerserkTimer = 330000;
+                } else m_uiBerserkTimer -= uiDiff;
 
-                while (uint32 eventId = events.ExecuteEvent())
+                if (m_uiPhase == 1)
                 {
-                    switch (eventId)
+                    if (m_uiPactofDarkfallenTimer <= uiDiff)
                     {
-                        case EVENT_BERSERK:
-                            DoScriptText(EMOTE_GENERIC_BERSERK_RAID, me);
-                            Talk(SAY_BERSERK);
-                            DoCast(me, SPELL_BERSERK);
-                            break;
-                        case EVENT_VAMPIRIC_BITE:
-                            if (Player* target = SelectRandomTarget(false))
-                            {
-                                DoCast(target, SPELL_VAMPIRIC_BITE);
-                                Talk(SAY_VAMPIRIC_BITE);
-                                vampires.insert(target->GetGUID());
-                            }
-                            break;
-                        case EVENT_BLOOD_MIRROR:
-                        {
-                            Player* newOfftank = SelectRandomTarget(true);
-                            if (offtank != newOfftank)
-                            {
-                                offtank = newOfftank;
-                                if (offtank)
-                                {
-                                    offtank->CastSpell(me->getVictim(), SPELL_BLOOD_MIRROR_DAMAGE, true);
-                                    me->getVictim()->CastSpell(offtank, SPELL_BLOOD_MIRROR_DUMMY, true);
-                                    DoCastVictim(SPELL_BLOOD_MIRROR_VISUAL);
-                                    if (Item* shadowsEdge = offtank->GetWeaponForAttack(BASE_ATTACK, true))
-                                        if (!offtank->HasAura(SPELL_THIRST_QUENCHED) && shadowsEdge->GetEntry() == ITEM_SHADOW_S_EDGE && !offtank->HasAura(SPELL_GUSHING_WOUND))
-                                            offtank->CastSpell(offtank, SPELL_GUSHING_WOUND, true);
-
-                                }
-                            }
-                            events.ScheduleEvent(EVENT_BLOOD_MIRROR, 2500, EVENT_GROUP_CANCELLABLE);
-                            break;
-                        }
-                        case EVENT_DELIRIOUS_SLASH:
-                            if (offtank && !me->HasByteFlag(UNIT_FIELD_BYTES_1, 3, 0x03))
-                                DoCast(offtank, SPELL_DELIRIOUS_SLASH);
-                            events.ScheduleEvent(EVENT_DELIRIOUS_SLASH, urand(20000, 24000), EVENT_GROUP_NORMAL);
-                            break;
-                        case EVENT_PACT_OF_THE_DARKFALLEN:
-                        {
-                            std::list<Player*> targets;
-                            SelectRandomTarget(false, &targets);
-                            uint32 targetCount = 2;
-                            // do not combine these checks! we want it incremented TWICE when both conditions are met
-                            if (IsHeroic())
-                                ++targetCount;
-                            if (Is25ManRaid())
-                                ++targetCount;
-                            Trinity::RandomResizeList<Player*>(targets, targetCount);
-                            if (targets.size() > 1)
-                            {
-                                Talk(SAY_PACT_OF_THE_DARKFALLEN);
-                                for (std::list<Player*>::iterator itr = targets.begin(); itr != targets.end(); ++itr)
-                                    DoCast(*itr, SPELL_PACT_OF_THE_DARKFALLEN);
-                            }
-                            events.ScheduleEvent(EVENT_PACT_OF_THE_DARKFALLEN, 30500, EVENT_GROUP_NORMAL);
-                            break;
-                        }
-                        case EVENT_SWARMING_SHADOWS:
-                            if (Player* target = SelectRandomTarget(false))
-                            {
-                                Talk(EMOTE_SWARMING_SHADOWS, target->GetGUID());
-                                Talk(SAY_SWARMING_SHADOWS);
-                                DoCast(target, SPELL_SWARMING_SHADOWS);
-                            }
-                            events.ScheduleEvent(EVENT_SWARMING_SHADOWS, 30500, EVENT_GROUP_NORMAL);
-                            break;
-                        case EVENT_TWILIGHT_BLOODBOLT:
-                        {
-                            std::list<Player*> targets;
-                            SelectRandomTarget(false, &targets);
-                            Trinity::RandomResizeList<Player*>(targets, uint32(Is25ManRaid() ? 4 : 2));
-                            for (std::list<Player*>::iterator itr = targets.begin(); itr != targets.end(); ++itr)
-                                DoCast(*itr, SPELL_TWILIGHT_BLOODBOLT);
-                            DoCast(me, SPELL_TWILIGHT_BLOODBOLT_TARGET);
-                            events.ScheduleEvent(EVENT_TWILIGHT_BLOODBOLT, urand(10000, 15000), EVENT_GROUP_NORMAL);
-                            break;
-                        }
-                        case EVENT_AIR_PHASE:
-                            DoStopAttack();
-                            me->SetReactState(REACT_PASSIVE);
-                            events.DelayEvents(7000, EVENT_GROUP_NORMAL);
-                            events.CancelEventsByGCD(EVENT_GROUP_CANCELLABLE);
-                            me->GetMotionMaster()->MovePoint(POINT_CENTER, centerPos);
-                            break;
-                        case EVENT_AIR_START_FLYING:
-                            me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                            me->SetByteFlag(UNIT_FIELD_BYTES_1, 3, 0x01);
-                            me->SetFlying(true);
-                            me->GetMotionMaster()->MovePoint(POINT_AIR, airPos);
-                            break;
-                        case EVENT_AIR_FLY_DOWN:
-                            me->GetMotionMaster()->MovePoint(POINT_GROUND, centerPos);
-                            break;
-                        default:
-                            break;
-                    }
-                }
-
-                DoMeleeAttackIfReady();
-            }
-
-            bool WasVampire(uint64 guid)
-            {
-                return vampires.count(guid) != 0;
-            }
-
-        private:
-            // offtank for this encounter is the player standing closest to main tank
-            Player* SelectRandomTarget(bool includeOfftank, std::list<Player*>* targetList = NULL)
-            {
-                const std::list<HostileReference*> &threatlist = me->getThreatManager().getThreatList();
-                std::list<Player*> tempTargets;
+                        DoScriptText(SAY_PACT_DARKFALLEN, me);
+                        m_uiPactofDarkfallenExplosionCount = 0;
+                        m_uiPactofDarkfallenExplodeTimer = 2000;
+                        m_uiPactofDarkfallenTimer = 25000;
+                    } else m_uiPactofDarkfallenTimer -= uiDiff;
 
-                if (threatlist.empty())
-                    return NULL;
+                    if (m_uiSwarmingShadowsTimer < uiDiff)
+                    {
+                        if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                        DoCast(pTarget, SPELL_SWARMING_SHADOWS);
+                        m_uiSwarmingShadowsTimer = 30000;
+                    } else m_uiSwarmingShadowsTimer -= uiDiff;
 
-                for (std::list<HostileReference*>::const_iterator itr = threatlist.begin(); itr != threatlist.end(); ++itr)
-                    if (Unit* refTarget = (*itr)->getTarget())
-                        if (refTarget != me->getVictim() && refTarget->GetTypeId() == TYPEID_PLAYER && (includeOfftank ? true : (refTarget != offtank)))
-                            tempTargets.push_back(refTarget->ToPlayer());
+                    if (m_uiTwilightBloodboltTimer < uiDiff)
+                    {
+                        if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                        DoCast(pTarget, SPELL_TWILIGHT_BLOODBOLT);
+                        m_uiTwilightBloodboltTimer = 9000;
+                    } else m_uiTwilightBloodboltTimer -= uiDiff;
 
-                if (tempTargets.empty())
-                    return NULL;
+                    if (m_uiVampBiteTimer < uiDiff)
+                    {
+                        DoScriptText(RAND(SAY_VAMP_BITE_1,SAY_VAMP_BITE_2), me);
+                        DoCast(me->getVictim(), SPELL_VAMPIRIC_BITE);
+                        m_uiVampBiteTimer = 40000;
+                    } else m_uiVampBiteTimer -= uiDiff;
 
-                if (targetList)
-                {
-                    *targetList = tempTargets;
-                    return NULL;
+                    if (m_uiPhaseTimer < uiDiff)
+                    {
+                        DoScriptText(SAY_AIR_PHASE, me);
+                        DoCast(me, SPELL_INCITE_TERROR);
+                        me->GetMotionMaster()->MovePoint(0, SpawnLoc[0]);
+                        me->SetReactState(REACT_PASSIVE);
+                        me->AttackStop();
+                        m_uiPhase = 2;
+                        m_uiPhaseTimer = 90000;
+                        m_uiSetHoverTimer = 5000;
+                        m_uiBloodboldSplashTimer = 10000;
+                        m_uiLandingTimer = 26000;
+                        m_uiFlyingFalseTimer = 30000;
+                    } else m_uiPhaseTimer -= uiDiff;
                 }
 
-                if (includeOfftank)
+                if (m_uiPhase == 2)
                 {
-                    tempTargets.sort(Trinity::ObjectDistanceOrderPred(me->getVictim()));
-                    return tempTargets.front();
-                }
-
-                std::list<Player*>::iterator itr = tempTargets.begin();
-                std::advance(itr, urand(0, tempTargets.size()-1));
-                return *itr;
-            }
-
-            Player* offtank;
-            std::set<uint64> vampires;
-        };
-
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new boss_blood_queen_lana_thelAI(creature);
-        }
-};
-
-// helper for shortened code
-typedef boss_blood_queen_lana_thel::boss_blood_queen_lana_thelAI LanaThelAI;
-
-class spell_blood_queen_vampiric_bite : public SpellScriptLoader
-{
-    public:
-        spell_blood_queen_vampiric_bite() : SpellScriptLoader("spell_blood_queen_vampiric_bite") { }
-
-        class spell_blood_queen_vampiric_bite_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_blood_queen_vampiric_bite_SpellScript);
-
-            bool Validate(SpellEntry const* /*spell*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_ESSENCE_OF_THE_BLOOD_QUEEN_PLR))
-                    return false;
-                if (!sSpellStore.LookupEntry(SPELL_FRENZIED_BLOODTHIRST))
-                    return false;
-                if (!sSpellStore.LookupEntry(SPELL_PRESENCE_OF_THE_DARKFALLEN))
-                    return false;
-                return true;
-            }
-
-            void OnCast()
-            {
-                if (GetCaster()->GetTypeId() != TYPEID_PLAYER)
-                    return;
+                    if (m_uiSetHoverTimer < uiDiff)
+                    {
+                        me->GetMotionMaster()->MovePoint(0, SpawnLoc[1]);
+                        me->SetUnitMovementFlags(MOVEMENTFLAG_JUMPING);
+                        me->SetFlying(true);
+                        m_uiSetHoverTimer = 90000;
+                    } else m_uiSetHoverTimer -= uiDiff;
 
-                if (IsVampire(GetHitUnit()))
-                {
-                    PreventHitDamage();
-                    PreventHitDefaultEffect(EFFECT_1);
-                    Spell::SendCastResult(GetCaster()->ToPlayer(), GetSpellInfo(), 0, SPELL_FAILED_BAD_TARGETS);
-                    return;
-                }
+                    if (m_uiBloodboldSplashTimer < uiDiff)
+                    {
+                        std::list<Unit*> targets;
+                        SelectTargetList(targets, 5, SELECT_TARGET_RANDOM, 80, true);
+                        for (std::list<Unit*>::const_iterator i = targets.begin(); i != targets.end(); ++i)
+                            DoCast(*i, SPELL_TWILIGHT_BLOODBOLT);
+                        m_uiBloodboldSplashTimer = 2000;
+                    } else m_uiBloodboldSplashTimer -= uiDiff;
+
+                    if (m_uiLandingTimer < uiDiff)
+                    {
+                        me->GetMotionMaster()->MovePoint(0, SpawnLoc[0]);
+                        me->SetUnitMovementFlags(MOVEMENTFLAG_JUMPING);
+                        m_uiLandingTimer = 900000;
+                        m_uiBloodboldSplashTimer = 900000;
+                    } else m_uiLandingTimer -= uiDiff;
 
-                SpellEntry const* spell = sSpellStore.LookupEntry(SPELL_FRENZIED_BLOODTHIRST);
-                spell = sSpellMgr->GetSpellForDifficultyFromSpell(spell, GetCaster());
-                GetCaster()->RemoveAura(spell->Id, 0, 0, AURA_REMOVE_BY_ENEMY_SPELL);
-                GetCaster()->CastSpell(GetCaster(), SPELL_ESSENCE_OF_THE_BLOOD_QUEEN_PLR, true);
-                // Presence of the Darkfallen buff on Blood-Queen
-                if (GetCaster()->GetMap()->IsHeroic())
-                    GetCaster()->CastSpell(GetCaster(), SPELL_PRESENCE_OF_THE_DARKFALLEN, true);
-                // Shadowmourne questline
-                if (GetCaster()->ToPlayer()->GetQuestStatus(QUEST_BLOOD_INFUSION) == QUEST_STATUS_INCOMPLETE)
-                {
-                    if (Aura* aura = GetCaster()->GetAura(SPELL_GUSHING_WOUND))
+                    if (m_uiFlyingFalseTimer < uiDiff)
                     {
-                        if (aura->GetStackAmount() == 3)
-                        {
-                            GetCaster()->CastSpell(GetCaster(), SPELL_THIRST_QUENCHED, true);
-                            GetCaster()->RemoveAura(aura);
-                        }
-                        else
-                            GetCaster()->CastSpell(GetCaster(), SPELL_GUSHING_WOUND, true);
-                    }
+                        me->SetFlying(false);
+                        me->RemoveAllAuras();
+                        me->SetReactState(REACT_AGGRESSIVE);
+                        me->GetMotionMaster()->MoveChase(me->getVictim());
+                        m_uiPhase = 1;
+                        m_uiFlyingFalseTimer = 900000;
+                    } else m_uiFlyingFalseTimer -= uiDiff;
                 }
-                if (InstanceScript* instance = GetCaster()->GetInstanceScript())
-                    if (Creature* bloodQueen = ObjectAccessor::GetCreature(*GetCaster(), instance->GetData64(DATA_BLOOD_QUEEN_LANA_THEL)))
-                        bloodQueen->AI()->SetGUID(GetHitUnit()->GetGUID(), GUID_VAMPIRE);
-            }
 
-            void Register()
-            {
-                BeforeHit += SpellHitFn(spell_blood_queen_vampiric_bite_SpellScript::OnCast);
+                DoMeleeAttackIfReady();
             }
+        private:
+            InstanceScript* pInstance;
+
+            uint32 m_uiTwilightBloodboltTimer;
+            uint32 m_uiPhaseTimer;
+            uint32 m_uiVampBiteTimer;
+            uint32 m_uiSwarmingShadowsTimer;
+            uint32 m_uiPactofDarkfallenTimer;
+            uint32 m_uiPactofDarkfallenExplodeTimer;
+            uint32 m_uiPactofDarkfallenExplosionCount;
+            uint32 m_uiPhase;
+            uint32 m_uiBerserkTimer;
+            uint32 m_uiSetHoverTimer;
+            uint32 m_uiLandingTimer;
+            uint32 m_uiFlyingFalseTimer;
+            uint32 m_uiBloodboldSplashTimer;
+            uint32 m_uiResetTimer;
+            Unit* Darkfallen[5];
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new spell_blood_queen_vampiric_bite_SpellScript();
+            return new boss_blood_queen_lanathelAI(pCreature);
         }
 };
 
-class spell_blood_queen_frenzied_bloodthirst : public SpellScriptLoader
+class npc_swarming_shadows : public CreatureScript
 {
     public:
-        spell_blood_queen_frenzied_bloodthirst() : SpellScriptLoader("spell_blood_queen_frenzied_bloodthirst") { }
+        npc_swarming_shadows() : CreatureScript("npc_swarming_shadows") { }
 
-        class spell_blood_queen_frenzied_bloodthirst_AuraScript : public AuraScript
+        struct npc_swarming_shadowsAI : public Scripted_NoMovementAI
         {
-            PrepareAuraScript(spell_blood_queen_frenzied_bloodthirst_AuraScript);
-
-            void OnApply(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            npc_swarming_shadowsAI(Creature *pCreature) : Scripted_NoMovementAI(pCreature)
             {
-                if (InstanceScript* instance = GetTarget()->GetInstanceScript())
-                    if (Creature* bloodQueen = ObjectAccessor::GetCreature(*GetTarget(), instance->GetData64(DATA_BLOOD_QUEEN_LANA_THEL)))
-                        bloodQueen->AI()->Talk(EMOTE_BLOODTHIRST);
+                pInstance = pCreature->GetInstanceScript();
             }
 
-            void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            void Reset()
             {
-                Unit* target = GetTarget();
-                if (GetTargetApplication()->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
-                    if (InstanceScript* instance = target->GetInstanceScript())
-                        if (Creature* bloodQueen = ObjectAccessor::GetCreature(*target, instance->GetData64(DATA_BLOOD_QUEEN_LANA_THEL)))
-                        {
-                            // this needs to be done BEFORE charm aura or we hit an assert in Unit::SetCharmedBy
-                            if (target->GetVehicleKit())
-                                target->RemoveVehicleKit();
-
-                            bloodQueen->AI()->Talk(SAY_MIND_CONTROL);
-                            bloodQueen->CastSpell(target, SPELL_UNCONTROLLABLE_FRENZY, true);
-                        }
+                m_uiSwarmingShadowTimer = 1200;
             }
 
-            void Register()
+            void UpdateAI(const uint32 uiDiff)
             {
-                OnEffectRemove += AuraEffectRemoveFn(spell_blood_queen_frenzied_bloodthirst_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_OVERRIDE_SPELLS, AURA_EFFECT_HANDLE_REAL);
-            }
-        };
+                if (!me->HasAura(SPELL_SWARMING_SHADOWS_VISUAL))
+                    DoCast(me, SPELL_SWARMING_SHADOWS_VISUAL);
 
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_blood_queen_frenzied_bloodthirst_AuraScript();
-        }
-};
-
-class spell_blood_queen_bloodbolt : public SpellScriptLoader
-{
-    public:
-        spell_blood_queen_bloodbolt() : SpellScriptLoader("spell_blood_queen_bloodbolt") { }
-
-        class spell_blood_queen_bloodbolt_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_blood_queen_bloodbolt_SpellScript);
-
-            bool Validate(SpellEntry const* /*spell*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_TWILIGHT_BLOODBOLT))
-                    return false;
-                return true;
-            }
-
-            void HandleDummy()
-            {
-                if (GetHitUnit()->GetTypeId() == TYPEID_PLAYER)
-                    GetCaster()->CastSpell(GetHitUnit(), SPELL_TWILIGHT_BLOODBOLT, true);
+                if (m_uiSwarmingShadowTimer < uiDiff)
+                {
+                    DoCast(me, SPELL_SWARMING_SHADOW);
+                    m_uiSwarmingShadowTimer = 2000;
+                } else m_uiSwarmingShadowTimer -= uiDiff;
             }
+        private:
+            InstanceScript* pInstance;
 
-            void Register()
-            {
-                AfterHit += SpellHitFn(spell_blood_queen_bloodbolt_SpellScript::HandleDummy);
-            }
+            uint32 m_uiSwarmingShadowTimer;
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new spell_blood_queen_bloodbolt_SpellScript();
-        }
-};
-
-class achievement_once_bitten_twice_shy_n : public AchievementCriteriaScript
-{
-    public:
-        achievement_once_bitten_twice_shy_n() : AchievementCriteriaScript("achievement_once_bitten_twice_shy_n") { }
-
-        bool OnCheck(Player* source, Unit* target)
-        {
-            if (!target)
-                return false;
-
-            if (LanaThelAI* lanaThelAI = CAST_AI(LanaThelAI, target->GetAI()))
-                return !lanaThelAI->WasVampire(source->GetGUID());
-            return false;
-        }
-};
-
-class achievement_once_bitten_twice_shy_v : public AchievementCriteriaScript
-{
-    public:
-        achievement_once_bitten_twice_shy_v() : AchievementCriteriaScript("achievement_once_bitten_twice_shy_v") { }
-
-        bool OnCheck(Player* source, Unit* target)
-        {
-            if (!target)
-                return false;
-
-            if (LanaThelAI* lanaThelAI = CAST_AI(LanaThelAI, target->GetAI()))
-                return lanaThelAI->WasVampire(source->GetGUID());
-            return false;
+            return new npc_swarming_shadowsAI(pCreature);
         }
 };
 
 void AddSC_boss_blood_queen_lana_thel()
 {
-    new boss_blood_queen_lana_thel();
-    new spell_blood_queen_vampiric_bite();
-    new spell_blood_queen_frenzied_bloodthirst();
-    new spell_blood_queen_bloodbolt();
-    new achievement_once_bitten_twice_shy_n();
-    new achievement_once_bitten_twice_shy_v();
+    new boss_blood_queen_lanathel();
+    new npc_swarming_shadows();
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
old mode 100755
new mode 100644
index 6f312c3..bf84c18
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
@@ -1,1153 +1,286 @@
 /*
- * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "ObjectMgr.h"
-#include "ScriptMgr.h"
-#include "ScriptedCreature.h"
-#include "ScriptedGossip.h"
-#include "SpellScript.h"
-#include "SpellAuras.h"
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include "ScriptPCH.h"
 #include "icecrown_citadel.h"
 
-enum ScriptTexts
+enum Yells
 {
-    // Deathbringer Saurfang
-    SAY_INTRO_ALLIANCE_2            = 0,
-    SAY_INTRO_ALLIANCE_3            = 1,
-    SAY_INTRO_ALLIANCE_6            = 2,
-    SAY_INTRO_ALLIANCE_7            = 3,
-    SAY_INTRO_HORDE_2               = 4,
-    SAY_INTRO_HORDE_4               = 5,
-    SAY_INTRO_HORDE_9               = 6,
-    SAY_AGGRO                       = 7,
-    SAY_MARK_OF_THE_FALLEN_CHAMPION = 8,
-    SAY_BLOOD_BEASTS                = 9,
-    SAY_KILL                        = 10,
-    SAY_FRENZY                      = 11,
-    SAY_BERSERK                     = 12,
-    SAY_DEATH                       = 13,
-
-    // High Overlord Saurfang
-    SAY_INTRO_HORDE_1               = 0,
-    SAY_INTRO_HORDE_3               = 1,
-    SAY_INTRO_HORDE_5               = 2,
-    SAY_INTRO_HORDE_6               = 3,
-    SAY_INTRO_HORDE_7               = 4,
-    SAY_INTRO_HORDE_8               = 5,
-    SAY_OUTRO_ALLIANCE_8            = 6,
-    SAY_OUTRO_ALLIANCE_12           = 7, // kneel after WP reached
-    SAY_OUTRO_ALLIANCE_13           = 8,
-    SAY_OUTRO_ALLIANCE_14           = 9,
-    SAY_OUTRO_ALLIANCE_15           = 10,
-    SAY_OUTRO_HORDE_1               = 11,
-    SAY_OUTRO_HORDE_2               = 12,
-    SAY_OUTRO_HORDE_3               = 13,
-    SAY_OUTRO_HORDE_4               = 14,
-
-    // Muradin Bronzebeard
-    SAY_INTRO_ALLIANCE_1            = 0,
-    SAY_INTRO_ALLIANCE_4            = 1,
-    SAY_INTRO_ALLIANCE_5            = 2,
-    SAY_OUTRO_ALLIANCE_1            = 3, // TODO ALLIANCE OUTRO
-    SAY_OUTRO_ALLIANCE_2            = 4,
-    SAY_OUTRO_ALLIANCE_3            = 5,
-    SAY_OUTRO_ALLIANCE_4            = 6,
-    SAY_OUTRO_ALLIANCE_5            = 7,
-    SAY_OUTRO_ALLIANCE_6            = 8,
-    SAY_OUTRO_ALLIANCE_7            = 9,
-    SAY_OUTRO_ALLIANCE_9            = 10,
-    SAY_OUTRO_ALLIANCE_10           = 11,
-    SAY_OUTRO_ALLIANCE_21           = 12,
-
-    // Lady Jaina Proudmoore
-    SAY_OUTRO_ALLIANCE_17           = 0,
-    SAY_OUTRO_ALLIANCE_19           = 1,
-
-    // King Varian Wrynn
-    SAY_OUTRO_ALLIANCE_11           = 0,
-    SAY_OUTRO_ALLIANCE_16           = 1,
-    SAY_OUTRO_ALLIANCE_18           = 2,
-    SAY_OUTRO_ALLIANCE_20           = 3,
+    SAY_AGGRO                       = -1631045,
+    SAY_MARK_OF_THE_FALLEN_CHAMPION = -1631046,
+    SAY_BLOOD_BEASTS                = -1631047,
+    SAY_KILL_1                      = -1631048,
+    SAY_KILL_2                      = -1631049,
+    SAY_FRENZY                      = -1631050,
+    SAY_BERSERK                     = -1631051,
+    SAY_DEATH                       = -1631052,
+
+    SAY_INTRO_ALLIANCE_1            = -1631029,
+    SAY_INTRO_ALLIANCE_2            = -1631030,
+    SAY_INTRO_ALLIANCE_3            = -1631031,
+    SAY_INTRO_ALLIANCE_4            = -1631032,
+    SAY_INTRO_ALLIANCE_5            = -1631033,
+    SAY_INTRO_ALLIANCE_6            = -1631034,
+    SAY_INTRO_ALLIANCE_7            = -1631035,
+
+    SAY_INTRO_HORDE_1               = -1631036,
+    SAY_INTRO_HORDE_2               = -1631037,
+    SAY_INTRO_HORDE_3               = -1631038,
+    SAY_INTRO_HORDE_4               = -1631039,
+    SAY_INTRO_HORDE_5               = -1631040,
+    SAY_INTRO_HORDE_6               = -1631041,
+    SAY_INTRO_HORDE_7               = -1631042,
+    SAY_INTRO_HORDE_8               = -1631043,
+    SAY_INTRO_HORDE_9               = -1631044,
+
+    SAY_OUTRO_ALLIANCE_1            = -1631053,
+    SAY_OUTRO_ALLIANCE_2            = -1631054,
+    SAY_OUTRO_ALLIANCE_3            = -1631055,
+    SAY_OUTRO_ALLIANCE_4            = -1631056,
+    SAY_OUTRO_ALLIANCE_5            = -1631057,
+    SAY_OUTRO_ALLIANCE_6            = -1631058,
+    SAY_OUTRO_ALLIANCE_7            = -1631059,
+    SAY_OUTRO_ALLIANCE_8            = -1631060,
+    SAY_OUTRO_ALLIANCE_9            = -1631061,
+    SAY_OUTRO_ALLIANCE_10           = -1631062,
+    SAY_OUTRO_ALLIANCE_11           = -1631063,
+    SAY_OUTRO_ALLIANCE_12           = -1631064,
+    SAY_OUTRO_ALLIANCE_13           = -1631065,
+    SAY_OUTRO_ALLIANCE_14           = -1631066,
+    SAY_OUTRO_ALLIANCE_15           = -1631067,
+    SAY_OUTRO_ALLIANCE_16           = -1631068,
+    SAY_OUTRO_ALLIANCE_17           = -1631069,
+    SAY_OUTRO_ALLIANCE_18           = -1631070,
+    SAY_OUTRO_ALLIANCE_19           = -1631071,
+    SAY_OUTRO_ALLIANCE_20           = -1631072,
+    SAY_OUTRO_ALLIANCE_21           = -1631073,
+
+    SAY_OUTRO_HORDE_1               = -1631074,
+    SAY_OUTRO_HORDE_2               = -1631075,
+    SAY_OUTRO_HORDE_3               = -1631076,
+    SAY_OUTRO_HORDE_4               = -1631077
 };
 
 enum Spells
 {
-    // Deathbringer Saurfang
-    SPELL_ZERO_POWER                    = 72242,
-    SPELL_GRIP_OF_AGONY                 = 70572, // Intro
-    SPELL_BLOOD_LINK                    = 72178,
-    SPELL_MARK_OF_THE_FALLEN_CHAMPION_S = 72256,
-    SPELL_RUNE_OF_BLOOD_S               = 72408,
-
-    SPELL_SUMMON_BLOOD_BEAST            = 72172,
-    SPELL_SUMMON_BLOOD_BEAST_25_MAN     = 72356, // Additional cast, does not replace
-    SPELL_FRENZY                        = 72737,
-    SPELL_BLOOD_NOVA_TRIGGER            = 72378,
-    SPELL_BLOOD_NOVA                    = 72380,
-    SPELL_BLOOD_POWER                   = 72371,
-    SPELL_BLOOD_LINK_POWER              = 72195,
-    SPELL_BLOOD_LINK_DUMMY              = 72202,
-    SPELL_MARK_OF_THE_FALLEN_CHAMPION   = 72293,
-    SPELL_BOILING_BLOOD                 = 72385,
-    SPELL_RUNE_OF_BLOOD                 = 72410,
-
-    // Blood Beast
-    SPELL_BLOOD_LINK_BEAST              = 72176,
-    SPELL_RESISTANT_SKIN                = 72723,
-    SPELL_SCENT_OF_BLOOD                = 72769, // Heroic only
-
-    SPELL_RIDE_VEHICLE                  = 70640, // Outro
-    SPELL_ACHIEVEMENT                   = 72928,
-};
-
-// Helper to get id of the aura on different modes (HasAura(baseId) wont work)
-#define BOILING_BLOOD_HELPER RAID_MODE<int32>(72385,72441,72442,72443)
-
-enum Events
-{
-    EVENT_INTRO_ALLIANCE_1      = 1,
-    EVENT_INTRO_ALLIANCE_2      = 2,
-    EVENT_INTRO_ALLIANCE_3      = 3,
-    EVENT_INTRO_ALLIANCE_4      = 4,
-    EVENT_INTRO_ALLIANCE_5      = 5,
-    EVENT_INTRO_ALLIANCE_6      = 6,
-    EVENT_INTRO_ALLIANCE_7      = 7,
-
-    EVENT_INTRO_HORDE_1         = 8,
-    EVENT_INTRO_HORDE_2         = 9,
-    EVENT_INTRO_HORDE_3         = 10,
-    EVENT_INTRO_HORDE_4         = 11,
-    EVENT_INTRO_HORDE_5         = 12,
-    EVENT_INTRO_HORDE_6         = 13,
-    EVENT_INTRO_HORDE_7         = 14,
-    EVENT_INTRO_HORDE_8         = 15,
-    EVENT_INTRO_HORDE_9         = 16,
-
-    EVENT_INTRO_FINISH          = 17,
-
-    EVENT_BERSERK               = 18,
-    EVENT_SUMMON_BLOOD_BEAST    = 19,
-    EVENT_BOILING_BLOOD         = 20,
-    EVENT_BLOOD_NOVA            = 21,
-    EVENT_RUNE_OF_BLOOD         = 22,
-
-    EVENT_OUTRO_ALLIANCE_1      = 23,
-    EVENT_OUTRO_ALLIANCE_2      = 24,
-    EVENT_OUTRO_ALLIANCE_3      = 25,
-    EVENT_OUTRO_ALLIANCE_4      = 26,
-    EVENT_OUTRO_ALLIANCE_5      = 27,
-    EVENT_OUTRO_ALLIANCE_6      = 28,
-    EVENT_OUTRO_ALLIANCE_7      = 29,
-    EVENT_OUTRO_ALLIANCE_8      = 30,
-    EVENT_OUTRO_ALLIANCE_9      = 31,
-    EVENT_OUTRO_ALLIANCE_10     = 32,
-    EVENT_OUTRO_ALLIANCE_11     = 33,
-    EVENT_OUTRO_ALLIANCE_12     = 34,
-    EVENT_OUTRO_ALLIANCE_13     = 35,
-    EVENT_OUTRO_ALLIANCE_14     = 36,
-    EVENT_OUTRO_ALLIANCE_15     = 37,
-    EVENT_OUTRO_ALLIANCE_16     = 38,
-    EVENT_OUTRO_ALLIANCE_17     = 39,
-    EVENT_OUTRO_ALLIANCE_18     = 40,
-    EVENT_OUTRO_ALLIANCE_19     = 41,
-    EVENT_OUTRO_ALLIANCE_20     = 42,
-    EVENT_OUTRO_ALLIANCE_21     = 43,
-
-    EVENT_OUTRO_HORDE_1         = 44,
-    EVENT_OUTRO_HORDE_2         = 45,
-    EVENT_OUTRO_HORDE_3         = 46,
-    EVENT_OUTRO_HORDE_4         = 47,
-    EVENT_OUTRO_HORDE_5         = 48,
-    EVENT_OUTRO_HORDE_6         = 49,
-    EVENT_OUTRO_HORDE_7         = 50,
-    EVENT_OUTRO_HORDE_8         = 51,
-};
-
-enum Phases
-{
-    PHASE_INTRO_A       = 1,
-    PHASE_INTRO_H       = 2,
-    PHASE_COMBAT        = 3,
-
-    PHASE_INTRO_MASK    = (1 << PHASE_INTRO_A) | (1 << PHASE_INTRO_H),
-};
-
-enum Actions
-{
-    ACTION_START_EVENT                  = -3781300,
-    ACTION_CONTINUE_INTRO               = -3781301,
-    ACTION_CHARGE                       = -3781302,
-    ACTION_START_OUTRO                  = -3781303,
-    ACTION_DESPAWN                      = -3781304,
-    ACTION_MARK_OF_THE_FALLEN_CHAMPION  = -72293,
-};
-
-#define DATA_MADE_A_MESS 45374613 // 4537, 4613 are achievement IDs
-
-enum MovePoints
-{
-    POINT_SAURFANG          = 3781300,
-    POINT_FIRST_STEP        = 3781301,
-    POINT_CHARGE            = 3781302,
-    POINT_CHOKE             = 3781303,
-    POINT_CORPSE            = 3781304,
-    POINT_FINAL             = 3781305
-};
-
-static const Position deathbringerPos = {-496.3542f, 2211.33f, 541.1138f, 0.0f};
-static const Position firstStepPos = {-541.3177f, 2211.365f, 539.2921f, 0.0f};
-
-static const Position chargePos[6] =
-{
-    {-509.6505f, 2211.377f, 539.2872f, 0.0f}, // High Overlord Saurfang/Muradin Bronzebeard
-    {-508.7480f, 2211.897f, 539.2870f, 0.0f}, // front left
-    {-509.2929f, 2211.411f, 539.2870f, 0.0f}, // front right
-    {-506.6607f, 2211.367f, 539.2870f, 0.0f}, // back middle
-    {-506.1137f, 2213.306f, 539.2870f, 0.0f}, // back left
-    {-509.0040f, 2211.743f, 539.2870f, 0.0f}  // back right
-};
-
-static const Position chokePos[6] =
-{
-    {-514.4834f, 2211.334f, 549.2887f, 0.0f}, // High Overlord Saurfang/Muradin Bronzebeard
-    {-510.1081f, 2211.592f, 546.3773f, 0.0f}, // front left
-    {-513.3210f, 2211.396f, 551.2882f, 0.0f}, // front right
-    {-507.3684f, 2210.353f, 545.7497f, 0.0f}, // back middle
-    {-507.0486f, 2212.999f, 545.5512f, 0.0f}, // back left
-    {-510.7041f, 2211.069f, 546.5298f, 0.0f}  // back right
+    SPELL_BLOOD_LINK            = 72178,
+    SPELL_BLOOD_POWER           = 72371,
+    SPELL_FRENZY                = 72737,
+    SPELL_TASTE_OF_BLOOD        = 69634,
+    SPELL_FALLEN_CHAMPION       = 72293,
+    SPELL_FALLEN_CHAMPION_AURA  = 72256,
+    SPELL_BOILING_BLOOD         = 72385,
+    SPELL_BLOOD_NOVA            = 72378,
+    SPELL_RUNE_OF_BLOOD_AURA    = 72408,
+    SPELL_RUNE_OF_BLOOD         = 72410,
+    SPELL_BLOOD_LINK_BEAST      = 72176,
+    SPELL_RESISTAN_SKIN         = 72723,
+    SPELL_SCENT_OF_BLOOD        = 72769,
+    SPELL_AGONY                 = 70572, //saurfang event
+    SPELL_ZERO_POWER            = 72242
 };
 
-static const Position finalPos = {-563.7552f, 2211.328f, 538.7848f, 0.0f};
+static const uint32 summonBloodBeast[5] = {72172, 72173, 72356, 72357, 72358};
 
-class boss_deathbringer_saurfang : public CreatureScript
+class boss_saurfang : public CreatureScript
 {
     public:
-        boss_deathbringer_saurfang() : CreatureScript("boss_deathbringer_saurfang") { }
+        boss_saurfang() : CreatureScript("boss_saurfang") { }
 
-        struct boss_deathbringer_saurfangAI : public BossAI
+        struct boss_saurfangAI : public BossAI
         {
-            boss_deathbringer_saurfangAI(Creature* creature) : BossAI(creature, DATA_DEATHBRINGER_SAURFANG)
-            {
-                ASSERT(creature->GetVehicleKit()); // we dont actually use it, just check if exists
-                introDone = false;
-                fallenChampionCount = 0;
-            }
-
-            void InitializeAI()
+            boss_saurfangAI(Creature* creature) : BossAI(creature, DATA_SAURFANG_EVENT), vehicle(creature->GetVehicleKit())
             {
-                if (!instance || static_cast<InstanceMap*>(me->GetMap())->GetScriptId() != GetScriptId(ICCScriptName))
-                    me->IsAIEnabled = false;
-                else if (!me->isDead())
-                    Reset();
+                instance = me->GetInstanceScript();
+                assert(vehicle);
+                bFrenzy = false;
+                me->CastSpell(me, SPELL_ZERO_POWER, true);
+                me->SetPower(me->getPowerType(), 0);
             }
 
             void Reset()
             {
-                me->SetReactState(REACT_DEFENSIVE);
-                events.Reset();
-                events.SetPhase(PHASE_COMBAT);
-                frenzy = false;
-                me->SetPower(POWER_ENERGY, 0);
-                DoCast(me, SPELL_ZERO_POWER, true);
-                DoCast(me, SPELL_BLOOD_LINK, true);
-                DoCast(me, SPELL_BLOOD_POWER, true);
-                DoCast(me, SPELL_MARK_OF_THE_FALLEN_CHAMPION_S, true);
-                DoCast(me, SPELL_RUNE_OF_BLOOD_S, true);
-                me->RemoveAurasDueToSpell(SPELL_BERSERK);
-                me->RemoveAurasDueToSpell(SPELL_FRENZY);
-                summons.DespawnAll();
-                instance->SetBossState(DATA_DEATHBRINGER_SAURFANG, NOT_STARTED);
+                uiBoilingBloodTimer = 25000;
+                uiBloodNovaTimer = 30000;
+                uiRuneOfBloodTimer = 20000;
+                uiSummonBloodBeastTimer = 40000;
+                uiBerserkTimer = 480000;
+
+                uiMessCount = 0;
+
+                me->GetVehicleKit();
+
+                if (instance)
+                    instance->SetData(DATA_SAURFANG_EVENT, NOT_STARTED);
             }
 
-            void EnterCombat(Unit* who)
+            void EnterCombat(Unit* /*who*/)
             {
-                if (!instance->CheckRequiredBosses(DATA_DEATHBRINGER_SAURFANG, who->ToPlayer()))
-                {
-                    instance->DoCastSpellOnPlayers(LIGHT_S_HAMMER_TELEPORT);
-                    EnterEvadeMode();
+                if(!instance)
                     return;
-                }
-
-                // oh just screw intro, enter combat - no exploits please
-                events.SetPhase(PHASE_COMBAT);
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
-                introDone = true;
 
-                Talk(SAY_AGGRO);
-                events.ScheduleEvent(EVENT_SUMMON_BLOOD_BEAST, 30000, 0, PHASE_COMBAT);
-                events.ScheduleEvent(EVENT_BERSERK, 480000, 0, PHASE_COMBAT);
-                events.ScheduleEvent(EVENT_BOILING_BLOOD, 15500, 0, PHASE_COMBAT);
-                events.ScheduleEvent(EVENT_BLOOD_NOVA, 17000, 0, PHASE_COMBAT);
-                events.ScheduleEvent(EVENT_RUNE_OF_BLOOD, 20000, 0, PHASE_COMBAT);
+                DoScriptText(SAY_AGGRO, me);
 
-                fallenChampionCount = 0;
-                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_MARK_OF_THE_FALLEN_CHAMPION);
-                instance->SetBossState(DATA_DEATHBRINGER_SAURFANG, IN_PROGRESS);
+                DoCast(me, SPELL_BLOOD_LINK, true);
+                DoCast(me, SPELL_BLOOD_POWER, true);
+                DoCast(me, SPELL_FALLEN_CHAMPION_AURA, true);
+                DoCast(me, SPELL_RUNE_OF_BLOOD_AURA, true);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_FALLEN_CHAMPION);
+                instance->SetData(DATA_SAURFANG_EVENT, IN_PROGRESS);
             }
 
             void JustDied(Unit* /*killer*/)
             {
-                DoCastAOE(SPELL_ACHIEVEMENT, true);
-                Talk(SAY_DEATH);
+                if (!instance)
+                    return;
 
-                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_MARK_OF_THE_FALLEN_CHAMPION);
-                instance->SetBossState(DATA_DEATHBRINGER_SAURFANG, DONE);
-                if (Creature* creature = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_SAURFANG_EVENT_NPC)))
-                    creature->AI()->DoAction(ACTION_START_OUTRO);
-            }
+                DoScriptText(SAY_DEATH, me);
 
-            void AttackStart(Unit* victim)
-            {
-                if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE))
-                    return;
+                instance->SetData(DATA_SAURFANG_EVENT, DONE);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_FALLEN_CHAMPION);
+                me->RemoveAurasDueToSpell(SPELL_FALLEN_CHAMPION_AURA);
+                me->RemoveAurasDueToSpell(SPELL_RUNE_OF_BLOOD_AURA);
+                me->SetPower(me->getPowerType(), 0);
 
-                ScriptedAI::AttackStart(victim);
-            }
+                if(uiMessCount < RAID_MODE(3,5,3,5))
+                    instance->DoCompleteAchievement(RAID_MODE(ACHIEV_MESS_10, ACHIEV_MESS_25));
 
-            void EnterEvadeMode()
-            {
-                ScriptedAI::EnterEvadeMode();
-                if (introDone)
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
             }
 
             void JustReachedHome()
             {
-                instance->SetBossState(DATA_DEATHBRINGER_SAURFANG, FAIL);
-                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_MARK_OF_THE_FALLEN_CHAMPION);
+                if (!instance)
+                    return;
+
+                instance->SetData(DATA_SAURFANG_EVENT, FAIL);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_FALLEN_CHAMPION);
+                me->RemoveAurasDueToSpell(SPELL_BLOOD_LINK);
+                me->RemoveAurasDueToSpell(SPELL_BLOOD_POWER);
+                me->RemoveAurasDueToSpell(SPELL_FALLEN_CHAMPION_AURA);
+                me->RemoveAurasDueToSpell(SPELL_RUNE_OF_BLOOD_AURA);
             }
 
             void KilledUnit(Unit* victim)
             {
                 if (victim->GetTypeId() == TYPEID_PLAYER)
-                    Talk(SAY_KILL);
+                    DoScriptText(RAND(SAY_KILL_1,SAY_KILL_2), me);
             }
 
-            void DamageTaken(Unit* /*attacker*/, uint32& /*damage*/)
+            void JustSummoned(Creature* summoned)
             {
-                if (!frenzy && HealthBelowPct(31)) // AT 30%, not below
-                {
-                    frenzy = true;
-                    DoCast(me, SPELL_FRENZY);
-                    Talk(SAY_FRENZY);
-                }
-            }
+                if(Unit* target = SelectTarget(SELECT_TARGET_FARTHEST, 1, 100.0f, true))
+                    summoned->AI()->AttackStart(target);
 
-            void JustSummoned(Creature* summon)
-            {
-                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1))
-                    summon->AI()->AttackStart(target);
+                summoned->CastSpell(summoned, SPELL_BLOOD_LINK_BEAST, true);
+                summoned->CastSpell(summoned, SPELL_RESISTAN_SKIN, true);
 
                 if (IsHeroic())
-                    DoCast(summon, SPELL_SCENT_OF_BLOOD);
-
-                summon->AI()->DoCast(summon, SPELL_BLOOD_LINK_BEAST, true);
-                summon->AI()->DoCast(summon, SPELL_RESISTANT_SKIN, true);
-                summons.Summon(summon);
+                    summoned->CastSpell(summoned, SPELL_SCENT_OF_BLOOD, true);
             }
 
-            void SummonedCreatureDespawn(Creature* summon)
+            void UpdateAI(const uint32 uiDiff)
             {
-                summons.Despawn(summon);
-            }
-
-            void MovementInform(uint32 type, uint32 id)
-            {
-                if (type != POINT_MOTION_TYPE && id != POINT_SAURFANG)
+                if(!UpdateVictim())
                     return;
 
-                instance->HandleGameObject(instance->GetData64(GO_SAURFANG_S_DOOR), false);
-            }
-
-            void SpellHitTarget(Unit* target, SpellEntry const* spell)
-            {
-                switch (spell->Id)
+                if (uiBoilingBloodTimer < uiDiff)
                 {
-                    case SPELL_MARK_OF_THE_FALLEN_CHAMPION:
-                        Talk(SAY_MARK_OF_THE_FALLEN_CHAMPION);
-                        break;
-                    case 72255: // Mark of the Fallen Champion, triggered id
-                    case 72444:
-                    case 72445:
-                    case 72446:
-                        if (me->GetPower(POWER_ENERGY) != me->GetMaxPower(POWER_ENERGY))
-                            target->CastCustomSpell(SPELL_BLOOD_LINK_DUMMY, SPELLVALUE_BASE_POINT0, 1, me, true);
-                        break;
-                    default:
-                        break;
-                }
-            }
+                    if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                        DoCast(target, SPELL_BOILING_BLOOD);
+                    uiBoilingBloodTimer = 25000;
+                } else uiBoilingBloodTimer -= uiDiff;
 
-            void UpdateAI(const uint32 diff)
-            {
-                if (!UpdateVictim() && !(events.GetPhaseMask() & PHASE_INTRO_MASK))
-                    return;
-
-                events.Update(diff);
-
-                if (me->HasUnitState(UNIT_STAT_CASTING))
-                    return;
-
-                while (uint32 eventId = events.ExecuteEvent())
+                if (uiBloodNovaTimer < uiDiff)
                 {
-                    switch (eventId)
-                    {
-                        case EVENT_INTRO_ALLIANCE_2:
-                            Talk(SAY_INTRO_ALLIANCE_2);
-                            break;
-                        case EVENT_INTRO_ALLIANCE_3:
-                            Talk(SAY_INTRO_ALLIANCE_3);
-                            break;
-                        case EVENT_INTRO_ALLIANCE_6:
-                            Talk(SAY_INTRO_ALLIANCE_6);
-                            Talk(SAY_INTRO_ALLIANCE_7);
-                            DoCast(me, SPELL_GRIP_OF_AGONY);
-                            break;
-                        case EVENT_INTRO_HORDE_2:
-                            Talk(SAY_INTRO_HORDE_2);
-                            break;
-                        case EVENT_INTRO_HORDE_4:
-                            Talk(SAY_INTRO_HORDE_4);
-                            break;
-                        case EVENT_INTRO_HORDE_9:
-                            DoCast(me, SPELL_GRIP_OF_AGONY);
-                            Talk(SAY_INTRO_HORDE_9);
-                            break;
-                        case EVENT_INTRO_FINISH:
-                            events.SetPhase(PHASE_COMBAT);
-                            introDone = true;
-                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
-                            break;
-                        case EVENT_SUMMON_BLOOD_BEAST:
-                            for (uint32 i10 = 0; i10 < 2; ++i10)
-                                DoCast(me, SPELL_SUMMON_BLOOD_BEAST+i10);
-                            if (Is25ManRaid())
-                                for (uint32 i25 = 0; i25 < 3; ++i25)
-                                    DoCast(me, SPELL_SUMMON_BLOOD_BEAST_25_MAN+i25);
-                            Talk(SAY_BLOOD_BEASTS);
-                            events.ScheduleEvent(EVENT_SUMMON_BLOOD_BEAST, 40000, 0, PHASE_COMBAT);
-                            break;
-                        case EVENT_BLOOD_NOVA:
-                        {
-                            // select at range only
-                            Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, -10.0f, true);
-                            if (!target)
-                                target = SelectTarget(SELECT_TARGET_RANDOM, 1, 10.0f, true);    // noone? select melee
-                            if (target)
-                                DoCast(target, SPELL_BLOOD_NOVA_TRIGGER);
-                            events.ScheduleEvent(EVENT_BLOOD_NOVA, urand(20000, 25000), 0, PHASE_COMBAT);
-                            break;
-                        }
-                        case EVENT_RUNE_OF_BLOOD:
-                            DoCastVictim(SPELL_RUNE_OF_BLOOD);
-                            events.ScheduleEvent(EVENT_RUNE_OF_BLOOD, urand(20000, 25000), 0, PHASE_COMBAT);
-                            break;
-                        case EVENT_BOILING_BLOOD:
-                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -BOILING_BLOOD_HELPER))
-                                DoCast(target, SPELL_BOILING_BLOOD);
-                            events.ScheduleEvent(EVENT_BOILING_BLOOD, urand(15000, 20000), 0, PHASE_COMBAT);
-                            break;
-                        case EVENT_BERSERK:
-                            DoCast(me, SPELL_BERSERK);
-                            Talk(SAY_BERSERK);
-                            break;
-                        default:
-                            break;
-                    }
-                }
-
-                DoMeleeAttackIfReady();
-            }
+                    for (uint8 i = 1; i <= RAID_MODE(1,3,1,3); ++i)
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_BLOOD_NOVA);
+                    uiBloodNovaTimer = 30000;
+                } else uiBloodNovaTimer -= uiDiff;
 
-            uint32 GetData(uint32 type)
-            {
-                if (type == DATA_MADE_A_MESS)
-                    if (fallenChampionCount < RAID_MODE<uint32>(3, 5, 3, 5))
-                        return 1;
-
-                return 0;
-            }
-
-            // intro setup
-            void DoAction(const int32 action)
-            {
-                switch (action)
+                if (uiSummonBloodBeastTimer <= uiDiff)
                 {
-                    case PHASE_INTRO_A:
-                    case PHASE_INTRO_H:
-                        if (GameObject* teleporter = GameObject::GetGameObject(*me, instance->GetData64(GO_SCOURGE_TRANSPORTER_SAURFANG)))
-                        {
-                            instance->HandleGameObject(0, false, teleporter);
-                            teleporter->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
-                        }
+                    for(uint8 i = 0; i < RAID_MODE(2,5,2,5); ++i)
+                        DoCast(me, summonBloodBeast[i]);
+                    DoScriptText(SAY_BLOOD_BEASTS, me);
+                    uiSummonBloodBeastTimer = 40000;
+                } else uiSummonBloodBeastTimer -= uiDiff;
 
-                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                        // controls what events will execute
-                        events.SetPhase(uint32(action));
-
-                        me->SetHomePosition(deathbringerPos.GetPositionX(), deathbringerPos.GetPositionY(), deathbringerPos.GetPositionZ(), me->GetOrientation());
-                        me->GetMotionMaster()->MovePoint(POINT_SAURFANG, deathbringerPos.GetPositionX(), deathbringerPos.GetPositionY(), deathbringerPos.GetPositionZ());
-
-                        events.ScheduleEvent(EVENT_INTRO_ALLIANCE_2, 2500, 0, PHASE_INTRO_A);
-                        events.ScheduleEvent(EVENT_INTRO_ALLIANCE_3, 20000, 0, PHASE_INTRO_A);
-
-                        events.ScheduleEvent(EVENT_INTRO_HORDE_2, 5000, 0, PHASE_INTRO_H);
-                        break;
-                    case ACTION_CONTINUE_INTRO:
-                        events.ScheduleEvent(EVENT_INTRO_ALLIANCE_6, 6500+500, 0, PHASE_INTRO_A);
-                        events.ScheduleEvent(EVENT_INTRO_FINISH, 8000, 0, PHASE_INTRO_A);
-
-                        events.ScheduleEvent(EVENT_INTRO_HORDE_4, 6500, 0, PHASE_INTRO_H);
-                        events.ScheduleEvent(EVENT_INTRO_HORDE_9, 46700+1000+500, 0, PHASE_INTRO_H);
-                        events.ScheduleEvent(EVENT_INTRO_FINISH,  46700+1000+8000, 0, PHASE_INTRO_H);
-                        break;
-                    case ACTION_MARK_OF_THE_FALLEN_CHAMPION:
-                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 0.0f, true, -SPELL_MARK_OF_THE_FALLEN_CHAMPION))
-                        {
-                            ++fallenChampionCount;
-                            DoCast(target, SPELL_MARK_OF_THE_FALLEN_CHAMPION);
-                            me->SetPower(POWER_ENERGY, 0);
-                            if (Aura* bloodPower = me->GetAura(SPELL_BLOOD_POWER))
-                                bloodPower->RecalculateAmountOfEffects();
-                        }
-                        break;
-                    default:
-                        break;
-                }
-            }
-
-        private:
-            uint32 fallenChampionCount;
-            bool introDone;
-            bool frenzy;   // faster than iterating all auras to find Frenzy
-        };
-
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new boss_deathbringer_saurfangAI(creature);
-        }
-};
-
-class npc_high_overlord_saurfang_icc : public CreatureScript
-{
-    public:
-        npc_high_overlord_saurfang_icc() : CreatureScript("npc_high_overlord_saurfang_icc") { }
-
-        struct npc_high_overlord_saurfangAI : public ScriptedAI
-        {
-            npc_high_overlord_saurfangAI(Creature* creature) : ScriptedAI(creature), vehicle(creature->GetVehicleKit())
-            {
-                ASSERT(vehicle);
-                instance = me->GetInstanceScript();
-            }
-
-            void Reset()
-            {
-                events.Reset();
-            }
-
-            void DoAction(const int32 action)
-            {
-                if (action == ACTION_START_EVENT)
+                if (me->GetPower(POWER_ENERGY) > 99)
                 {
-                    // Prevent crashes
-                    if (events.GetPhaseMask() & PHASE_INTRO_MASK)
-                        return;
-
-                    GetCreatureListWithEntryInGrid(guardList, me, NPC_SE_KOR_KRON_REAVER, 20.0f);
-                    guardList.sort(Trinity::ObjectDistanceOrderPred(me));
-                    uint32 x = 1;
-                    for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++x, ++itr)
-                        (*itr)->AI()->SetData(0, x);
-
-                    me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-                    Talk(SAY_INTRO_HORDE_1);
-                    events.SetPhase(PHASE_INTRO_H);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_3, 18500, 0, PHASE_INTRO_H);
-                    if (instance)
+                    if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, -SPELL_FALLEN_CHAMPION))
                     {
-                        deathbringerSaurfangGUID = instance->GetData64(DATA_DEATHBRINGER_SAURFANG);
-                        instance->HandleGameObject(instance->GetData64(GO_SAURFANG_S_DOOR), true);
+                        DoCast(target, SPELL_FALLEN_CHAMPION);
+                        DoScriptText(SAY_MARK_OF_THE_FALLEN_CHAMPION, me);
+                        me->SetPower(me->getPowerType(), 0);
+                        ++uiMessCount;
                     }
-                    if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, deathbringerSaurfangGUID))
-                        deathbringer->AI()->DoAction(PHASE_INTRO_H);
                 }
-                else if (action == ACTION_START_OUTRO)
-                {
-                    me->RemoveAurasDueToSpell(SPELL_GRIP_OF_AGONY);
-                    Talk(SAY_OUTRO_HORDE_1);
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_2, 10000);   // say
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_3, 18000);   // say
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_4, 24000);   // cast
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_5, 30000);   // move
-                    me->RemoveUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                    me->SendMovementFlagUpdate();
-                    me->Relocate(me->GetPositionX(), me->GetPositionY(), 539.2917f);
-                    me->SendMonsterMove(me->GetPositionX(), me->GetPositionY(), 539.2917f, SPLINEFLAG_FALLING, 0, 0.0f);
-                    for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++itr)
-                        (*itr)->AI()->DoAction(ACTION_DESPAWN);
-                }
-            }
 
-            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
-            {
-                if (spell->Id == SPELL_GRIP_OF_AGONY)
-                {
-                    me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                    me->GetMotionMaster()->MovePoint(POINT_CHOKE, chokePos[0]);
-                }
-            }
-
-            void MovementInform(uint32 type, uint32 id)
-            {
-                if (type != POINT_MOTION_TYPE)
-                    return;
-
-                if (id == POINT_FIRST_STEP)
-                {
-                    me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                    Talk(SAY_INTRO_HORDE_3);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_5, 15500, 0, PHASE_INTRO_H);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_6, 29500, 0, PHASE_INTRO_H);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_7, 43800, 0, PHASE_INTRO_H);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_8, 47000, 0, PHASE_INTRO_H);
-                    if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, deathbringerSaurfangGUID))
-                        deathbringer->AI()->DoAction(ACTION_CONTINUE_INTRO);
-                }
-                else if (id == POINT_CORPSE)
+                if (uiRuneOfBloodTimer < uiDiff)
                 {
-                    if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, deathbringerSaurfangGUID))
-                    {
-                        deathbringer->CastSpell(me, SPELL_RIDE_VEHICLE, true);  // for the packet logs.
-                        deathbringer->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                        deathbringer->setDeathState(ALIVE);
-                        deathbringer->EnterVehicle(vehicle, 0);
-                    }
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_5, 1000);    // move
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_6, 4000);    // say
-                }
-                else if (id == POINT_FINAL)
-                {
-                    if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, deathbringerSaurfangGUID))
-                        deathbringer->DespawnOrUnsummon();
-                    me->DespawnOrUnsummon();
-                }
-            }
+                    DoCastVictim( SPELL_RUNE_OF_BLOOD);
+                    uiRuneOfBloodTimer = 20000;
+                } else uiRuneOfBloodTimer -= uiDiff;
 
-            void UpdateAI(const uint32 diff)
-            {
-                events.Update(diff);
-                while (uint32 eventId = events.ExecuteEvent())
+                if(me->GetHealth()*100 / me->GetMaxHealth() < 31)
                 {
-                    switch (eventId)
+                    if (!bFrenzy)
                     {
-                        case EVENT_INTRO_HORDE_3:
-                            me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                            me->GetMotionMaster()->MovePoint(POINT_FIRST_STEP, firstStepPos.GetPositionX(), firstStepPos.GetPositionY(), firstStepPos.GetPositionZ());
-                            break;
-                        case EVENT_INTRO_HORDE_5:
-                            Talk(SAY_INTRO_HORDE_5);
-                            break;
-                        case EVENT_INTRO_HORDE_6:
-                            Talk(SAY_INTRO_HORDE_6);
-                            break;
-                        case EVENT_INTRO_HORDE_7:
-                            Talk(SAY_INTRO_HORDE_7);
-                            break;
-                        case EVENT_INTRO_HORDE_8:
-                            Talk(SAY_INTRO_HORDE_8);
-                            for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++itr)
-                                (*itr)->AI()->DoAction(ACTION_CHARGE);
-                            me->GetMotionMaster()->MoveCharge(chargePos[0].GetPositionX(), chargePos[0].GetPositionY(), chargePos[0].GetPositionZ(), 8.5f, POINT_CHARGE);
-                            break;
-                        case EVENT_OUTRO_HORDE_2:   // say
-                            if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, deathbringerSaurfangGUID))
-                                me->SetFacingToObject(deathbringer);
-                            Talk(SAY_OUTRO_HORDE_2);
-                            break;
-                        case EVENT_OUTRO_HORDE_3:   // say
-                            Talk(SAY_OUTRO_HORDE_3);
-                            break;
-                        case EVENT_OUTRO_HORDE_4:   // move
-                            if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, deathbringerSaurfangGUID))
-                            {
-                                float x, y, z;
-                                deathbringer->GetClosePoint(x, y, z, deathbringer->GetObjectSize());
-                                me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                                me->GetMotionMaster()->MovePoint(POINT_CORPSE ,x, y, z);
-                            }
-                            break;
-                        case EVENT_OUTRO_HORDE_5:   // move
-                            me->GetMotionMaster()->MovePoint(POINT_FINAL, finalPos);
-                            break;
-                        case EVENT_OUTRO_HORDE_6:   // say
-                            Talk(SAY_OUTRO_HORDE_4);
-                            break;
+                        DoCast(me, SPELL_FRENZY);
+                        DoScriptText(SAY_FRENZY, me);
+                        bFrenzy = true;
                     }
                 }
-            }
-
-        private:
-            EventMap events;
-            InstanceScript* instance;
-            Vehicle* vehicle;
-            uint64 deathbringerSaurfangGUID;
-            std::list<Creature*> guardList;
-        };
-
-        bool OnGossipHello(Player* player, Creature* creature)
-        {
-            if (creature->GetPositionZ() < 530.0f)
-                return false;
-
-            InstanceScript* instance = creature->GetInstanceScript();
-            if (instance && instance->GetBossState(DATA_DEATHBRINGER_SAURFANG) != DONE)
-            {
-                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Let it begin...", 631, -ACTION_START_EVENT);
-                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
-            }
-
-            return true;
-        }
-
-        bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action)
-        {
-            player->PlayerTalkClass->ClearMenus();
-            player->CLOSE_GOSSIP_MENU();
-            if (action == -ACTION_START_EVENT)
-                creature->AI()->DoAction(ACTION_START_EVENT);
 
-            return true;
-        }
-
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new npc_high_overlord_saurfangAI(creature);
-        }
-};
-
-class npc_muradin_bronzebeard_icc : public CreatureScript
-{
-    public:
-        npc_muradin_bronzebeard_icc() : CreatureScript("npc_muradin_bronzebeard_icc") { }
-
-        struct npc_muradin_bronzebeard_iccAI : public ScriptedAI
-        {
-            npc_muradin_bronzebeard_iccAI(Creature* creature) : ScriptedAI(creature)
-            {
-                instance = me->GetInstanceScript();
-            }
-
-            void Reset()
-            {
-                events.Reset();
-            }
-
-            void DoAction(const int32 action)
-            {
-                if (action == ACTION_START_EVENT)
+                if (uiBerserkTimer < uiDiff)
                 {
-                    // Prevent crashes
-                    if (events.GetPhaseMask() & PHASE_INTRO_MASK)
-                        return;
-
-                    events.SetPhase(PHASE_INTRO_A);
-                    GetCreatureListWithEntryInGrid(guardList, me, NPC_SE_SKYBREAKER_MARINE, 20.0f);
-                    guardList.sort(Trinity::ObjectDistanceOrderPred(me));
-                    uint32 x = 1;
-                    for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++x, ++itr)
-                        (*itr)->AI()->SetData(0, x);
+                    DoCast(SPELL_BERSERK);
+                    DoScriptText(SAY_BERSERK, me);
+                    uiBerserkTimer = 480000;
+                } else uiBerserkTimer -= uiDiff;
 
-                    me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-                    Talk(SAY_INTRO_ALLIANCE_1);
-                    events.ScheduleEvent(EVENT_INTRO_ALLIANCE_4, 2500+17500+9500, 0, PHASE_INTRO_A);
-                    if (instance)
-                    {
-                        deathbringerSaurfangGUID = instance->GetData64(DATA_DEATHBRINGER_SAURFANG);
-                        instance->HandleGameObject(instance->GetData64(GO_SAURFANG_S_DOOR), true);
-                    }
-                    if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, deathbringerSaurfangGUID))
-                        deathbringer->AI()->DoAction(PHASE_INTRO_A);
-                }
-                else if (action == ACTION_START_OUTRO)
-                {
-                    me->RemoveAurasDueToSpell(SPELL_GRIP_OF_AGONY);
-                    Talk(SAY_OUTRO_ALLIANCE_1);
-                    me->RemoveUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                    me->SendMovementFlagUpdate();
-                    me->Relocate(me->GetPositionX(), me->GetPositionY(), 539.2917f);
-                    me->SendMonsterMove(me->GetPositionX(), me->GetPositionY(), 539.2917f, SPLINEFLAG_FALLING, 0, 0.0f);
-                    for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++itr)
-                        (*itr)->AI()->DoAction(ACTION_DESPAWN);
-                }
-            }
-
-            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
-            {
-                if (spell->Id == SPELL_GRIP_OF_AGONY)
-                {
-                    me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                    me->GetMotionMaster()->MovePoint(POINT_CHOKE, chokePos[0]);
-                }
-            }
-
-            void MovementInform(uint32 type, uint32 id)
-            {
-                if (type != POINT_MOTION_TYPE || id != POINT_FIRST_STEP)
-                    return;
-
-                me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                Talk(SAY_INTRO_ALLIANCE_4);
-                events.ScheduleEvent(EVENT_INTRO_ALLIANCE_5, 5000, 0, PHASE_INTRO_A);
-                if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, deathbringerSaurfangGUID))
-                    deathbringer->AI()->DoAction(ACTION_CONTINUE_INTRO);
-            }
-
-            void UpdateAI(const uint32 diff)
-            {
-                events.Update(diff);
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
-                    {
-                        case EVENT_INTRO_ALLIANCE_4:
-                            me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                            me->GetMotionMaster()->MovePoint(POINT_FIRST_STEP, firstStepPos.GetPositionX(), firstStepPos.GetPositionY(), firstStepPos.GetPositionZ());
-                            break;
-                        case EVENT_INTRO_ALLIANCE_5:
-                            Talk(SAY_INTRO_ALLIANCE_5);
-                            for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++itr)
-                                (*itr)->AI()->DoAction(ACTION_CHARGE);
-                            me->GetMotionMaster()->MoveCharge(chargePos[0].GetPositionX(), chargePos[0].GetPositionY(), chargePos[0].GetPositionZ(), 8.5f, POINT_CHARGE);
-                            break;
-                    }
-                }
+                DoMeleeAttackIfReady();
             }
 
         private:
-            EventMap events;
             InstanceScript* instance;
-            uint64 deathbringerSaurfangGUID;
-            std::list<Creature*> guardList;
-        };
-
-        bool OnGossipHello(Player* player, Creature* creature)
-        {
-            if (creature->GetPositionZ() < 530.0f)
-                return false;
-
-            InstanceScript* instance = creature->GetInstanceScript();
-            if (instance && instance->GetBossState(DATA_DEATHBRINGER_SAURFANG) != DONE)
-            {
-                player->ADD_GOSSIP_ITEM(0, "Let it begin...", 631, -ACTION_START_EVENT+1);
-                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
-            }
-
-            return true;
-        }
-
-        bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action)
-        {
-            player->PlayerTalkClass->ClearMenus();
-            player->CLOSE_GOSSIP_MENU();
-            if (action == -ACTION_START_EVENT+1)
-                creature->AI()->DoAction(ACTION_START_EVENT);
-
-            return true;
-        }
-
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new npc_muradin_bronzebeard_iccAI(creature);
-        }
-};
-
-class npc_saurfang_event : public CreatureScript
-{
-    public:
-        npc_saurfang_event() : CreatureScript("npc_saurfang_event") { }
 
-        struct npc_saurfang_eventAI : public ScriptedAI
-        {
-            npc_saurfang_eventAI(Creature* creature) : ScriptedAI(creature)
-            {
-                uiNPCindex = 0;
-            }
-
-            void SetData(uint32 type, uint32 data)
-            {
-                ASSERT(!type && data && data < 6);
-                uiNPCindex = data;
-            }
+            Vehicle* vehicle;
 
-            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
-            {
-                if (spell->Id == SPELL_GRIP_OF_AGONY)
-                {
-                    me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                    me->GetMotionMaster()->MovePoint(POINT_CHOKE, chokePos[uiNPCindex]);
-                }
-            }
+            uint32 uiBoilingBloodTimer;
+            uint32 uiBloodNovaTimer;
+            uint32 uiRuneOfBloodTimer;
+            uint32 uiSummonBloodBeastTimer;
+            uint32 uiBerserkTimer;
 
-            void DoAction(const int32 action)
-            {
-                if (action == ACTION_CHARGE && uiNPCindex)
-                    me->GetMotionMaster()->MoveCharge(chargePos[uiNPCindex].GetPositionX(), chargePos[uiNPCindex].GetPositionY(), chargePos[uiNPCindex].GetPositionZ(), 13.0f, POINT_CHARGE);
-                else if (action == ACTION_DESPAWN)
-                    me->DespawnOrUnsummon();
-            }
+            uint8 uiMessCount;
 
-        private:
-            EventMap events;
-            uint32 uiNPCindex;
+            bool bFrenzy;
         };
 
         CreatureAI* GetAI(Creature* creature) const
         {
-            return new npc_saurfang_eventAI(creature);
-        }
-};
-
-class spell_deathbringer_blood_link : public SpellScriptLoader
-{
-    public:
-        spell_deathbringer_blood_link() : SpellScriptLoader("spell_deathbringer_blood_link") { }
-
-        class spell_deathbringer_blood_link_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_deathbringer_blood_link_SpellScript);
-
-            bool Validate(SpellEntry const* /*spellInfo*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_BLOOD_LINK_POWER))
-                    return false;
-                if (!sSpellStore.LookupEntry(SPELL_BLOOD_POWER))
-                    return false;
-                return true;
-            }
-
-            void HandleDummy(SpellEffIndex /*effIndex*/)
-            {
-                GetHitUnit()->CastCustomSpell(SPELL_BLOOD_LINK_POWER, SPELLVALUE_BASE_POINT0, GetEffectValue(), GetHitUnit(), true);
-                if (Aura* bloodPower = GetHitUnit()->GetAura(SPELL_BLOOD_POWER))
-                    bloodPower->RecalculateAmountOfEffects();
-                PreventHitDefaultEffect(EFFECT_0);
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_deathbringer_blood_link_SpellScript::HandleDummy, EFFECT_0, SPELL_EFFECT_DUMMY);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_deathbringer_blood_link_SpellScript();
-        }
-};
-
-class spell_deathbringer_blood_link_aura : public SpellScriptLoader
-{
-    public:
-        spell_deathbringer_blood_link_aura() : SpellScriptLoader("spell_deathbringer_blood_link_aura") { }
-
-        class spell_deathbringer_blood_link_AuraScript : public AuraScript
-        {
-            PrepareAuraScript(spell_deathbringer_blood_link_AuraScript);
-
-            bool Validate(SpellEntry const* /*spellInfo*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_MARK_OF_THE_FALLEN_CHAMPION))
-                    return false;
-                return true;
-            }
-
-            void HandlePeriodicTick(AuraEffect const* /*aurEff*/)
-            {
-                PreventDefaultAction();
-                if (GetUnitOwner()->getPowerType() == POWER_ENERGY && GetUnitOwner()->GetPower(POWER_ENERGY) == GetUnitOwner()->GetMaxPower(POWER_ENERGY))
-                    if (Creature* saurfang = GetUnitOwner()->ToCreature())
-                        saurfang->AI()->DoAction(ACTION_MARK_OF_THE_FALLEN_CHAMPION);
-            }
-
-            void Register()
-            {
-                OnEffectPeriodic += AuraEffectPeriodicFn(spell_deathbringer_blood_link_AuraScript::HandlePeriodicTick, EFFECT_1, SPELL_AURA_PERIODIC_DUMMY);
-            }
-        };
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_deathbringer_blood_link_AuraScript();
-        }
-};
-
-class spell_deathbringer_blood_power : public SpellScriptLoader
-{
-    public:
-        spell_deathbringer_blood_power() : SpellScriptLoader("spell_deathbringer_blood_power") { }
-
-        class spell_deathbringer_blood_power_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_deathbringer_blood_power_SpellScript);
-
-            void ModAuraValue()
-            {
-                if (Aura* aura = GetHitAura())
-                    aura->RecalculateAmountOfEffects();
-            }
-
-            void Register()
-            {
-                AfterHit += SpellHitFn(spell_deathbringer_blood_power_SpellScript::ModAuraValue);
-            }
-        };
-
-        class spell_deathbringer_blood_power_AuraScript : public AuraScript
-        {
-            PrepareAuraScript(spell_deathbringer_blood_power_AuraScript);
-
-            void RecalculateHook(AuraEffect const* /*aurEffect*/, int32& amount, bool& canBeRecalculated)
-            {
-                amount = int32(GetUnitOwner()->GetPower(POWER_ENERGY));
-                canBeRecalculated = true;
-            }
-
-            void Register()
-            {
-                DoEffectCalcAmount += AuraEffectCalcAmountFn(spell_deathbringer_blood_power_AuraScript::RecalculateHook, EFFECT_0, SPELL_AURA_MOD_SCALE);
-                DoEffectCalcAmount += AuraEffectCalcAmountFn(spell_deathbringer_blood_power_AuraScript::RecalculateHook, EFFECT_1, SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
-            }
-
-            bool Load()
-            {
-                if (GetUnitOwner()->getPowerType() != POWER_ENERGY)
-                    return false;
-                return true;
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_deathbringer_blood_power_SpellScript();
-        }
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_deathbringer_blood_power_AuraScript();
-        }
-};
-
-class spell_deathbringer_rune_of_blood : public SpellScriptLoader
-{
-    public:
-        spell_deathbringer_rune_of_blood() : SpellScriptLoader("spell_deathbringer_rune_of_blood") { }
-
-        class spell_deathbringer_rune_of_blood_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_deathbringer_rune_of_blood_SpellScript);
-
-            bool Validate(SpellEntry const* /*spellInfo*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_BLOOD_LINK_DUMMY))
-                    return false;
-                return true;
-            }
-
-            void HandleScript(SpellEffIndex effIndex)
-            {
-                PreventHitDefaultEffect(effIndex);  // make this the default handler
-                if (GetCaster()->GetPower(POWER_ENERGY) != GetCaster()->GetMaxPower(POWER_ENERGY))
-                    GetHitUnit()->CastCustomSpell(SPELL_BLOOD_LINK_DUMMY, SPELLVALUE_BASE_POINT0, 1, GetCaster(), true);
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_deathbringer_rune_of_blood_SpellScript::HandleScript, EFFECT_1, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_deathbringer_rune_of_blood_SpellScript();
-        }
-};
-
-class spell_deathbringer_blood_nova : public SpellScriptLoader
-{
-    public:
-        spell_deathbringer_blood_nova() : SpellScriptLoader("spell_deathbringer_blood_nova") { }
-
-        class spell_deathbringer_blood_nova_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_deathbringer_blood_nova_SpellScript);
-
-            bool Validate(SpellEntry const* /*spellInfo*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_BLOOD_LINK_DUMMY))
-                    return false;
-                return true;
-            }
-
-            void HandleScript(SpellEffIndex /*effIndex*/)
-            {
-                PreventHitDefaultEffect(EFFECT_1);  // make this the default handler
-                if (GetCaster()->GetPower(POWER_ENERGY) != GetCaster()->GetMaxPower(POWER_ENERGY))
-                    GetHitUnit()->CastCustomSpell(SPELL_BLOOD_LINK_DUMMY, SPELLVALUE_BASE_POINT0, 2, GetCaster(), true);
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_deathbringer_blood_nova_SpellScript::HandleScript, EFFECT_1, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_deathbringer_blood_nova_SpellScript();
-        }
-};
-
-class achievement_ive_gone_and_made_a_mess : public AchievementCriteriaScript
-{
-    public:
-        achievement_ive_gone_and_made_a_mess() : AchievementCriteriaScript("achievement_ive_gone_and_made_a_mess") { }
-
-        bool OnCheck(Player* /*source*/, Unit* target)
-        {
-            if (target)
-                if (Creature* saurfang = target->ToCreature())
-                    if (saurfang->AI()->GetData(DATA_MADE_A_MESS))
-                        return true;
-
-            return false;
+            return new boss_saurfangAI(creature);
         }
 };
 
-void AddSC_boss_deathbringer_saurfang()
+void AddSC_boss_saurfang()
 {
-    new boss_deathbringer_saurfang();
-    new npc_high_overlord_saurfang_icc();
-    new npc_muradin_bronzebeard_icc();
-    new npc_saurfang_event();
-    new spell_deathbringer_blood_link();
-    new spell_deathbringer_blood_link_aura();
-    new spell_deathbringer_blood_power();
-    new spell_deathbringer_rune_of_blood();
-    new spell_deathbringer_blood_nova();
-    new achievement_ive_gone_and_made_a_mess();
-}
+    new boss_saurfang();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
old mode 100755
new mode 100644
index a5f9c74..b4ba898
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
@@ -1,79 +1,58 @@
 /*
- * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "ObjectMgr.h"
-#include "ScriptMgr.h"
-#include "ScriptedCreature.h"
-#include "SpellScript.h"
-#include "SpellAuras.h"
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include "ScriptPCH.h"
 #include "icecrown_citadel.h"
 
-enum ScriptTexts
+enum Yells
 {
-    SAY_STINKY_DEAD             = 0,
-    SAY_AGGRO                   = 1,
-    EMOTE_GAS_SPORE             = 2,
-    EMOTE_WARN_GAS_SPORE        = 3,
-    SAY_PUNGENT_BLIGHT          = 4,
-    EMOTE_WARN_PUNGENT_BLIGHT   = 5,
-    EMOTE_PUNGENT_BLIGHT        = 6,
-    SAY_KILL                    = 7,
-    SAY_BERSERK                 = 8,
-    SAY_DEATH                   = 9,
+    SAY_STINKY                  = -1631078,
+    SAY_AGGRO                   = -1631079,
+    EMOTE_GAS_SPORE             = -1631081,
+    EMOTE_WARN_GAS_SPORE        = -1631082,
+    SAY_PUNGENT_BLIGHT          = -1631083,
+    EMOTE_WARN_PUNGENT_BLIGHT   = -1631084,
+    EMOTE_PUNGENT_BLIGHT        = -1631085,
+    SAY_KILL_1                  = -1631086,
+    SAY_KILL_2                  = -1631087,
+    SAY_BERSERK                 = -1631088,
+    SAY_DEATH                   = -1631089
 };
 
 enum Spells
 {
-    // Festergut
-    SPELL_INHALE_BLIGHT         = 69165,
-    SPELL_PUNGENT_BLIGHT        = 69195,
-    SPELL_GASTRIC_BLOAT         = 72219, // 72214 is the proper way (with proc) but atm procs can't have cooldown for creatures
-    SPELL_GASTRIC_EXPLOSION     = 72227,
-    SPELL_GAS_SPORE             = 69278,
-    SPELL_VILE_GAS              = 69240,
-    SPELL_INOCULATED            = 69291,
-
-    // Stinky
-    SPELL_MORTAL_WOUND          = 71127,
-    SPELL_DECIMATE              = 71123,
-    SPELL_PLAGUE_STENCH         = 71805,
+    SPELL_PUNGENT_BLIGHT     = 69195,
+    SPELL_INHALE_BLIGHT      = 69165,
+    SPELL_VILE_GAS           = 69240,
+    SPELL_GASTRIC_BLOAT      = 72219,
+    SPELL_GAS_SPORES         = 69279,
+    SPELL_UNOCULATED         = 69291,
+    SPELL_GAS_FLOOD          = 71379,
+    SPELL_MORTAL_WOUND       = 71127,
+    SPELL_DECIMATE           = 71123,
+    SPELL_PLAGUE_STENCH      = 71805,
+    SPELL_GASTRIC_EXPLOSION  = 72227,
+    SPELL_INOCULATED         = 69291
 };
 
-// Used for HasAura checks
-#define PUNGENT_BLIGHT_HELPER RAID_MODE<uint32>(69195,71219,73031,73032)
-#define INOCULATED_HELPER     RAID_MODE<uint32>(69291,72101,72102,72103)
-
 static const uint32 gaseousBlight[3]        = {69157, 69162, 69164};
 static const uint32 gaseousBlightVisual[3]  = {69126, 69152, 69154};
 
-enum Events
-{
-    EVENT_BERSERK       = 1,
-    EVENT_INHALE_BLIGHT = 2,
-    EVENT_VILE_GAS      = 3,
-    EVENT_GAS_SPORE     = 4,
-    EVENT_GASTRIC_BLOAT = 5,
-
-    EVENT_DECIMATE      = 6,
-    EVENT_MORTAL_WOUND  = 7,
-};
-
-#define DATA_INOCULATED_STACK 69291
-
 class boss_festergut : public CreatureScript
 {
     public:
@@ -81,34 +60,26 @@ class boss_festergut : public CreatureScript
 
         struct boss_festergutAI : public BossAI
         {
-            boss_festergutAI(Creature* creature) : BossAI(creature, DATA_FESTERGUT)
+            boss_festergutAI(Creature* creature) : BossAI(creature, DATA_FESTERGURT)
             {
-                maxInoculatedStack = 0;
-                inhaleCounter = 0;
-                gasDummyGUID = 0;
-            }
-
-            void InitializeAI()
-            {
-                if (!instance || static_cast<InstanceMap*>(me->GetMap())->GetScriptId() != GetScriptId(ICCScriptName))
-                    me->IsAIEnabled = false;
-                else if (!me->isDead())
-                    Reset();
+                instance = me->GetInstanceScript();
+                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
             }
 
             void Reset()
             {
-                events.Reset();
-                events.ScheduleEvent(EVENT_BERSERK, 300000);
-                events.ScheduleEvent(EVENT_INHALE_BLIGHT, urand(25000, 30000));
-                events.ScheduleEvent(EVENT_GAS_SPORE, urand(20000, 25000));
-                events.ScheduleEvent(EVENT_GASTRIC_BLOAT, urand(12500, 15000));
-                maxInoculatedStack = 0;
-                inhaleCounter = 0;
-                me->RemoveAurasDueToSpell(SPELL_BERSERK2);
-                if (Creature* gasDummy = me->FindNearestCreature(NPC_GAS_DUMMY, 100.0f, true))
+                uiInhaleBlightTimer = urand(23000,29000);
+                uiVileGasTimer = 20000;
+                uiGasSporesTimer = 20000;
+                uiGastricBloatTimer = 12000;
+                uiBerserkTimer = 300000;
+                uiGaseousTimer = 1000;
+
+                uiInhaleBlightCount = 0;
+
+                if (Creature* gasDummy = GetClosestCreatureWithEntry(me, CREATURE_ORANGE_GAS_STALKER, 100.0f, true))
                 {
-                    gasDummyGUID = gasDummy->GetGUID();
+                    uiGasDummyGUID = gasDummy->GetGUID();
                     for (uint8 i = 0; i < 3; ++i)
                     {
                         gasDummy->RemoveAurasDueToSpell(gaseousBlight[i]);
@@ -116,169 +87,144 @@ class boss_festergut : public CreatureScript
                     }
                 }
 
-                instance->SetBossState(DATA_FESTERGUT, NOT_STARTED);
+                if (instance)
+                    instance->SetData(DATA_FESTERGURT_EVENT, NOT_STARTED);
             }
 
-            void EnterCombat(Unit* who)
+            void EnterCombat(Unit* /*who*/)
             {
-                if (!instance->CheckRequiredBosses(DATA_FESTERGUT, who->ToPlayer()))
-                {
-                    instance->DoCastSpellOnPlayers(LIGHT_S_HAMMER_TELEPORT);
-                    EnterEvadeMode();
-                    return;
-                }
+                DoScriptText(SAY_AGGRO, me);
 
-                Talk(SAY_AGGRO);
-                if (Creature* gasDummy = me->FindNearestCreature(NPC_GAS_DUMMY, 100.0f, true))
-                    gasDummyGUID = gasDummy->GetGUID();
-                if (Creature* professor = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
+                if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
+                {
                     professor->AI()->DoAction(ACTION_FESTERGUT_COMBAT);
+                    professor->AI()->DoAction(ACTION_FESTERGUT_GAS);
+                }
 
-                DoZoneInCombat(me);
+                if (Creature* gasDummy = GetClosestCreatureWithEntry(me, CREATURE_ORANGE_GAS_STALKER, 100.0f, true))
+                {
+                    uiGasDummyGUID = gasDummy->GetGUID();
+                    for (uint8 i = 0; i < 3; ++i)
+                        gasDummy->CastSpell(gasDummy,gaseousBlight[i], true);
+                }
             }
 
-            void JustDied(Unit* /*killer*/)
+            void JustDied(Unit* /*pKiller*/)
             {
-                Talk(SAY_DEATH);
-                instance->SetBossState(DATA_FESTERGUT, DONE);
-                if (Creature* professor = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
+                if (!instance)
+                    return;
+
+                DoScriptText(SAY_DEATH, me);
+
+                instance->SetData(DATA_FESTERGURT_EVENT, DONE);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_GASTRIC_BLOAT);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_VILE_GAS);
+                me->RemoveAurasDueToSpell(SPELL_PUNGENT_BLIGHT);
+
+                if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
                     professor->AI()->DoAction(ACTION_FESTERGUT_DEATH);
 
-                _RemoveBlight();
+                if (Creature* gasDummy = Unit::GetCreature(*me, uiGasDummyGUID))
+                    gasDummy->RemoveAllAuras();
             }
 
             void JustReachedHome()
             {
-                instance->SetBossState(DATA_FESTERGUT, FAIL);
-            }
+                if (!instance)
+                    return;
 
-            void EnterEvadeMode()
-            {
-                ScriptedAI::EnterEvadeMode();
-                if (Creature* professor = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
-                    professor->AI()->EnterEvadeMode();
+                instance->SetData(DATA_FESTERGURT_EVENT, FAIL);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_GASTRIC_BLOAT);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_VILE_GAS);
+                me->RemoveAurasDueToSpell(SPELL_PUNGENT_BLIGHT);
             }
 
             void KilledUnit(Unit* victim)
             {
                 if (victim->GetTypeId() == TYPEID_PLAYER)
-                    Talk(SAY_KILL);
-            }
-
-            void MoveInLineOfSight(Unit* /*who*/)
-            {
-                // don't enter combat
-            }
-
-            void SpellHitTarget(Unit* target, SpellEntry const* spell)
-            {
-                if (spell->Id == PUNGENT_BLIGHT_HELPER)
-                    target->RemoveAurasDueToSpell(INOCULATED_HELPER);
+                {
+                    switch(rand()%1)
+                    {
+                        case 0: DoScriptText(SAY_KILL_1, me); break;
+                        case 1: DoScriptText(SAY_KILL_2, me); break;
+                    }
+                }
             }
 
-            void UpdateAI(const uint32 diff)
+            void UpdateAI(const uint32 uiDiff)
             {
-                if (!UpdateVictim() || !CheckInRoom())
+                if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
-
-                if (me->HasUnitState(UNIT_STAT_CASTING))
-                    return;
+                if (uiGastricBloatTimer < uiDiff)
+                {
+                    DoCast(me->getVictim(), SPELL_GASTRIC_BLOAT);
+                    uiGastricBloatTimer = 13000;
+                } else uiGastricBloatTimer -= uiDiff;
 
-                while (uint32 eventId = events.ExecuteEvent())
+                if (uiInhaleBlightTimer < uiDiff)
                 {
-                    switch (eventId)
+                    if (Creature* gasDummy = Unit::GetCreature(*me, uiGasDummyGUID))
                     {
-                        case EVENT_INHALE_BLIGHT:
+                        if(uiInhaleBlightCount == 3)
                         {
-                            _RemoveBlight();
-                            if (inhaleCounter == 3)
-                            {
-                                Talk(EMOTE_WARN_PUNGENT_BLIGHT);
-                                Talk(SAY_PUNGENT_BLIGHT);
-                                DoCast(me, SPELL_PUNGENT_BLIGHT);
-                                inhaleCounter = 0;
-                                if (Creature* professor = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
-                                    professor->AI()->DoAction(ACTION_FESTERGUT_GAS);
-                                events.RescheduleEvent(EVENT_GAS_SPORE, urand(20000, 25000));
-                            }
-                            else
-                            {
-                                DoCast(me, SPELL_INHALE_BLIGHT);
-                                // just cast and dont bother with target, conditions will handle it
-                                ++inhaleCounter;
-                                if (inhaleCounter < 3)
-                                    me->CastSpell(me, gaseousBlight[inhaleCounter], true, NULL, NULL, me->GetGUID());
-                            }
-                            events.ScheduleEvent(EVENT_INHALE_BLIGHT, urand(33500, 35000));
-                            break;
+                            DoScriptText(EMOTE_WARN_PUNGENT_BLIGHT, me);
+                            DoCast(me, SPELL_PUNGENT_BLIGHT);
+                            DoScriptText(SAY_PUNGENT_BLIGHT, me);
+                            uiInhaleBlightCount = 0;
+
+                            if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
+                                professor->AI()->DoAction(ACTION_FESTERGUT_GAS);
                         }
-                        case EVENT_VILE_GAS:
+                        else
                         {
-                            std::list<Unit*> targets;
-                            uint32 minTargets = RAID_MODE<uint32>(3, 8, 3, 8);
-                            SelectTargetList(targets, minTargets, SELECT_TARGET_RANDOM, -5.0f, true);
-                            float minDist = 0.0f;
-                            if (targets.size() >= minTargets)
-                                minDist = -5.0f;
-
-                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, minDist, true))
-                                DoCast(target, SPELL_VILE_GAS);
-                            events.ScheduleEvent(EVENT_VILE_GAS, urand(28000, 35000));
-                            break;
+                            DoCast(me, SPELL_INHALE_BLIGHT);
+                            gasDummy->RemoveAurasDueToSpell(gaseousBlight[uiInhaleBlightCount]);
+                            gasDummy->RemoveAurasDueToSpell(gaseousBlightVisual[uiInhaleBlightCount]);
+                            ++uiInhaleBlightCount;
                         }
-                        case EVENT_GAS_SPORE:
-                            Talk(EMOTE_WARN_GAS_SPORE);
-                            Talk(EMOTE_GAS_SPORE);
-                            me->CastCustomSpell(SPELL_GAS_SPORE, SPELLVALUE_MAX_TARGETS, RAID_MODE<int32>(2, 3, 2, 3), me);
-                            events.ScheduleEvent(EVENT_GAS_SPORE, urand(40000, 45000));
-                            events.RescheduleEvent(EVENT_VILE_GAS, urand(28000, 35000));
-                            break;
-                        case EVENT_GASTRIC_BLOAT:
-                            DoCastVictim(SPELL_GASTRIC_BLOAT);
-                            events.ScheduleEvent(EVENT_GASTRIC_BLOAT, urand(15000, 17500));
-                            break;
-                        case EVENT_BERSERK:
-                            DoCast(me, SPELL_BERSERK2);
-                            Talk(SAY_BERSERK);
-                            break;
-                        default:
-                            break;
                     }
-                }
+                    uiInhaleBlightTimer = urand(23000, 29000);
+                } else uiInhaleBlightTimer -= uiDiff;
 
-                DoMeleeAttackIfReady();
-            }
-
-            void SetData(uint32 type, uint32 data)
-            {
-                if (type == DATA_INOCULATED_STACK && data > maxInoculatedStack)
-                    maxInoculatedStack = data;
-            }
-
-            uint32 GetData(uint32 type)
-            {
-                if (type == DATA_INOCULATED_STACK)
-                    return uint32(maxInoculatedStack);
+                if (uiVileGasTimer < uiDiff)
+                {
+                    for (uint8 i = 1; i <= 3; i++)
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_VILE_GAS, true);
+                    uiVileGasTimer = 20000;
+                } else uiVileGasTimer -= uiDiff;
 
-                return 0;
-            }
+                if (uiGasSporesTimer < uiDiff)
+                {
+                    for (uint8 i = 1; i <= RAID_MODE(2,3,2,3); ++i)
+                        if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            target->CastSpell(target, SPELL_GAS_SPORES, true);
+                    DoScriptText(EMOTE_GAS_SPORE, me);
+                    DoScriptText(EMOTE_WARN_GAS_SPORE, me);
+                    uiGasSporesTimer = 20000;
+                } else uiGasSporesTimer -= uiDiff;
+
+                if(uiBerserkTimer < uiDiff)
+                {
+                    DoCast(me, SPELL_BERSERK);
+                    DoScriptText(SAY_BERSERK, me);
+                    uiBerserkTimer = 300000;
+                } else uiBerserkTimer -= uiDiff;
 
-            void _RemoveBlight()
-            {
-                if (Creature* gasDummy = ObjectAccessor::GetCreature(*me, gasDummyGUID))
-                    for (uint8 i = 0; i < 3; ++i)
-                    {
-                        gasDummy->RemoveAurasDueToSpell(gaseousBlight[i]);
-                        gasDummy->RemoveAurasDueToSpell(gaseousBlightVisual[i]);
-                    }
+                DoMeleeAttackIfReady();
             }
-
         private:
-            uint64 gasDummyGUID;
-            uint32 maxInoculatedStack;
-            uint8 inhaleCounter;
+            InstanceScript* instance;
+
+            uint32 uiInhaleBlightTimer;
+            uint32 uiGasSporesTimer;
+            uint32 uiVileGasTimer;
+            uint32 uiGastricBloatTimer;
+            uint32 uiBerserkTimer;
+            uint32 uiGaseousTimer;
+            uint64 uiGasDummyGUID;
+            uint8 uiInhaleBlightCount;
         };
 
         CreatureAI* GetAI(Creature* creature) const
@@ -301,53 +247,42 @@ class npc_stinky_icc : public CreatureScript
 
             void Reset()
             {
-                events.Reset();
-                events.ScheduleEvent(EVENT_DECIMATE, urand(20000, 25000));
-                events.ScheduleEvent(EVENT_MORTAL_WOUND, urand(3000, 7000));
+                uiDecimateTimer = 23000;
+                uiMortalTimer = urand(8000, 10000);
+
                 DoCast(me, SPELL_PLAGUE_STENCH);
             }
 
-            void UpdateAI(const uint32 diff)
+            void UpdateAI(const uint32 uiDiff)
             {
                 if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
-
-                if (me->HasUnitState(UNIT_STAT_CASTING))
-                    return;
+                if(uiDecimateTimer < uiDiff)
+                {
+                    DoCast(me->getVictim(), SPELL_DECIMATE);
+                    uiDecimateTimer = 23000;
+                } else uiDecimateTimer -= uiDiff;
 
-                while (uint32 eventId = events.ExecuteEvent())
+                if(uiMortalTimer < uiDiff)
                 {
-                    switch (eventId)
-                    {
-                        case EVENT_DECIMATE:
-                            DoCastVictim(SPELL_DECIMATE);
-                            events.ScheduleEvent(EVENT_DECIMATE, urand(20000, 25000));
-                            break;
-                        case EVENT_MORTAL_WOUND:
-                            DoCastVictim(SPELL_MORTAL_WOUND);
-                            events.ScheduleEvent(EVENT_MORTAL_WOUND, urand(10000, 12500));
-                            break;
-                        default:
-                            break;
-                    }
-                }
+                    DoCast(me->getVictim(), SPELL_MORTAL_WOUND);
+                    uiMortalTimer = urand(8000,10000);
+                } else uiMortalTimer -= uiDiff;
 
                 DoMeleeAttackIfReady();
             }
 
             void JustDied(Unit* /*who*/)
             {
-                uint64 festergutGUID = instance ? instance->GetData64(DATA_FESTERGUT) : 0;
-                if (Creature* festergut = me->GetCreature(*me, festergutGUID))
-                    if (festergut->isAlive())
-                        festergut->AI()->Talk(SAY_STINKY_DEAD);
+                uint64 festergutGUID = instance ? instance->GetData64(DATA_FESTERGURT) : 0;
+                if (Creature *festergut = me->GetCreature(*me, festergutGUID))
+                    DoScriptText(SAY_STINKY, festergut);
             }
-
         private:
-            EventMap events;
             InstanceScript* instance;
+            uint32 uiDecimateTimer;
+            uint32 uiMortalTimer;
         };
 
         CreatureAI* GetAI(Creature* creature) const
@@ -356,50 +291,15 @@ class npc_stinky_icc : public CreatureScript
         }
 };
 
-class spell_festergut_pungent_blight : public SpellScriptLoader
-{
-    public:
-        spell_festergut_pungent_blight() : SpellScriptLoader("spell_festergut_pungent_blight") { }
-
-        class spell_festergut_pungent_blight_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_festergut_pungent_blight_SpellScript);
-
-            void HandleScript(SpellEffIndex /*effIndex*/)
-            {
-                SpellEntry const* spellInfo = sSpellStore.LookupEntry(uint32(GetEffectValue()));
-                if (!spellInfo || GetCaster()->GetTypeId() != TYPEID_UNIT)
-                    return;
-
-                // Get Inhaled Blight id for our difficulty
-                spellInfo = sSpellMgr->GetSpellForDifficultyFromSpell(spellInfo, GetCaster());
-
-                // ...and remove it
-                GetCaster()->RemoveAurasDueToSpell(spellInfo->Id);
-                GetCaster()->ToCreature()->AI()->Talk(EMOTE_PUNGENT_BLIGHT);
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_festergut_pungent_blight_SpellScript::HandleScript, EFFECT_1, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_festergut_pungent_blight_SpellScript();
-        }
-};
-
 class spell_festergut_gastric_bloat : public SpellScriptLoader
 {
     public:
         spell_festergut_gastric_bloat() : SpellScriptLoader("spell_festergut_gastric_bloat") { }
 
+
         class spell_festergut_gastric_bloat_SpellScript : public SpellScript
         {
             PrepareSpellScript(spell_festergut_gastric_bloat_SpellScript);
-
             void HandleScript(SpellEffIndex /*effIndex*/)
             {
                 Aura const* aura = GetHitUnit()->GetAura(GetSpellInfo()->Id);
@@ -410,7 +310,6 @@ class spell_festergut_gastric_bloat : public SpellScriptLoader
                 if (!spellInfo)
                     return;
 
-                // Get Gastric Explosion id for our difficulty
                 spellInfo = sSpellMgr->GetSpellForDifficultyFromSpell(spellInfo, GetCaster());
                 GetHitUnit()->RemoveAurasDueToSpell(GetSpellInfo()->Id);
                 GetHitUnit()->CastSpell(GetHitUnit(), spellInfo, true);
@@ -442,14 +341,8 @@ class spell_festergut_blighted_spores : public SpellScriptLoader
                 if (!GetCaster()->IsAIEnabled || GetCaster()->GetTypeId() != TYPEID_UNIT)
                     return;
 
-                uint32 inoculateId = CAST_AI(ScriptedAI, GetCaster()->ToCreature()->AI())->INOCULATED_HELPER;
-                uint32 currStack = 0;
-                if (Aura const* inoculate = GetTarget()->GetAura(inoculateId))
-                    currStack = inoculate->GetStackAmount();
-
                 GetTarget()->CastSpell(GetTarget(), SPELL_INOCULATED, true);
-                ++currStack;
-                GetCaster()->ToCreature()->AI()->SetData(DATA_INOCULATED_STACK, currStack);
+                GetCaster()->CastSpell(GetTarget(), SPELL_INOCULATED, true);
             }
 
             void Register()
@@ -464,26 +357,10 @@ class spell_festergut_blighted_spores : public SpellScriptLoader
         }
 };
 
-class achievement_flu_shot_shortage : public AchievementCriteriaScript
-{
-    public:
-        achievement_flu_shot_shortage() : AchievementCriteriaScript("achievement_flu_shot_shortage") { }
-
-        bool OnCheck(Player* /*source*/, Unit* target)
-        {
-            if (target && target->GetTypeId() == TYPEID_UNIT)
-                return target->ToCreature()->AI()->GetData(DATA_INOCULATED_STACK) < 3;
-
-            return false;
-        }
-};
-
 void AddSC_boss_festergut()
 {
     new boss_festergut();
     new npc_stinky_icc();
-    new spell_festergut_pungent_blight();
     new spell_festergut_gastric_bloat();
     new spell_festergut_blighted_spores();
-    new achievement_flu_shot_shortage();
-}
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp
new file mode 100644
index 0000000..8d1b351
--- /dev/null
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "icecrown_citadel.h"
+#include "MapManager.h"
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
old mode 100755
new mode 100644
index 1e1ce88..ca9a303
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -15,146 +15,61 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "ObjectMgr.h"
-#include "ScriptMgr.h"
-#include "ScriptedCreature.h"
-#include "SpellScript.h"
+#include "ScriptPCH.h"
 #include "icecrown_citadel.h"
-#include "Group.h"
-
-enum ScriptTexts
-{
-    SAY_INTRO_1                 = 0,
-    SAY_INTRO_2                 = 1,
-    SAY_INTRO_3                 = 2,
-    SAY_INTRO_4                 = 3,
-    SAY_INTRO_5                 = 4,
-    SAY_INTRO_6                 = 5,
-    SAY_INTRO_7                 = 6,
-    SAY_AGGRO                   = 7,
-    SAY_PHASE_2                 = 8,
-    EMOTE_PHASE_2               = 9,
-    SAY_DOMINATE_MIND           = 10,
-    SAY_DARK_EMPOWERMENT        = 11,
-    SAY_DARK_TRANSFORMATION     = 12,
-    SAY_ANIMATE_DEAD            = 13,
-    SAY_KILL                    = 14,
-    SAY_BERSERK                 = 15,
-    SAY_DEATH                   = 16,
-};
 
 enum Spells
 {
-    // Lady Deathwhisper
-    SPELL_MANA_BARRIER              = 70842,
-    SPELL_SHADOW_BOLT               = 71254,
-    SPELL_DEATH_AND_DECAY           = 71001,
-    SPELL_DOMINATE_MIND_H           = 71289,
-    SPELL_FROSTBOLT                 = 71420,
-    SPELL_FROSTBOLT_VOLLEY          = 72905,
-    SPELL_TOUCH_OF_INSIGNIFICANCE   = 71204,
-    SPELL_SUMMON_SHADE              = 71363,
-    SPELL_SHADOW_CHANNELING         = 43897, // Prefight, during intro
-    SPELL_DARK_TRANSFORMATION_T     = 70895,
-    SPELL_DARK_EMPOWERMENT_T        = 70896,
-    SPELL_DARK_MARTYRDOM_T          = 70897,
-
-    // Achievement
-    SPELL_FULL_HOUSE                = 72827, // does not exist in dbc but still can be used for criteria check
-
-    // Both Adds
-    SPELL_TELEPORT_VISUAL           = 41236,
-
-    // Fanatics
-    SPELL_DARK_TRANSFORMATION       = 70900,
-    SPELL_NECROTIC_STRIKE           = 70659,
-    SPELL_SHADOW_CLEAVE             = 70670,
-    SPELL_VAMPIRIC_MIGHT            = 70674,
-    SPELL_FANATIC_S_DETERMINATION   = 71235,
-    SPELL_DARK_MARTYRDOM_FANATIC    = 71236,
-
-    //  Adherents
-    SPELL_DARK_EMPOWERMENT          = 70901,
-    SPELL_FROST_FEVER               = 67767,
-    SPELL_DEATHCHILL_BOLT           = 70594,
-    SPELL_DEATHCHILL_BLAST          = 70906,
-    SPELL_CURSE_OF_TORPOR           = 71237,
-    SPELL_SHORUD_OF_THE_OCCULT      = 70768,
-    SPELL_ADHERENT_S_DETERMINATION  = 71234,
-    SPELL_DARK_MARTYRDOM_ADHERENT   = 70903,
-
-    // Vengeful Shade
-    SPELL_VENGEFUL_BLAST            = 71544,
-    SPELL_VENGEFUL_BLAST_PASSIVE    = 71494,
-    SPELL_VENGEFUL_BLAST_25N        = 72010,
-    SPELL_VENGEFUL_BLAST_10H        = 72011,
-    SPELL_VENGEFUL_BLAST_25H        = 72012,
-};
-
-enum Events
-{
-    // Lady Deathwhisper
-    EVENT_INTRO_2                       = 1,
-    EVENT_INTRO_3                       = 2,
-    EVENT_INTRO_4                       = 3,
-    EVENT_INTRO_5                       = 4,
-    EVENT_INTRO_6                       = 5,
-    EVENT_INTRO_7                       = 6,
-    EVENT_INTRO_FINISH                  = 7,
-    EVENT_BERSERK                       = 8,
-    EVENT_DEATH_AND_DECAY               = 9,
-    EVENT_DOMINATE_MIND_H               = 10,
-
-    // Phase 1 only
-    EVENT_P1_SUMMON_WAVE                = 11,
-    EVENT_P1_SHADOW_BOLT                = 12,
-    EVENT_P1_EMPOWER_CULTIST            = 13,
-    EVENT_P1_REANIMATE_CULTIST          = 14,
-
-    // Phase 2 only
-    EVENT_P2_SUMMON_WAVE                = 15,
-    EVENT_P2_FROSTBOLT                  = 16,
-    EVENT_P2_FROSTBOLT_VOLLEY           = 17,
-    EVENT_P2_TOUCH_OF_INSIGNIFICANCE    = 18,
-    EVENT_P2_SUMMON_SHADE               = 19,
-
-    // Shared adds events
-    EVENT_CULTIST_DARK_MARTYRDOM        = 20,
-
-    // Cult Fanatic
-    EVENT_FANATIC_NECROTIC_STRIKE       = 21,
-    EVENT_FANATIC_SHADOW_CLEAVE         = 22,
-    EVENT_FANATIC_VAMPIRIC_MIGHT        = 23,
-
-    // Cult Adherent
-    EVENT_ADHERENT_FROST_FEVER          = 24,
-    EVENT_ADHERENT_DEATHCHILL           = 25,
-    EVENT_ADHERENT_CURSE_OF_TORPOR      = 26,
-    EVENT_ADHERENT_SHORUD_OF_THE_OCCULT = 27,
+    SPELL_DEATH_AND_DECAY   = 71001,
+    SPELL_DOMINATE_MIND     = 71289,
+    SPELL_SHADOW_BOLT       = 71254,
+    SPELL_MANA_BARRIER      = 70842,
+    SPELL_TRANSFORMATION    = 70900,
+    SPELL_FROST_BOLT        = 71420,
+    SPELL_FROST_BOLT_VALLEY = 72905,
+    SPELL_SUMMON_SHADE      = 71363,
+    SPELL_INSIGNIFICANCE    = 71204,
+    SPELL_BLAST             = 71494,
+    SPELL_VENGEFUL_BLAST    = 71544,
+    SPELL_PORT_VISUAL       = 41236,
+    SPELL_SHADOW_CHANNELING = 43897,
+    SPELL_TRANSFORMATION_T  = 70895,
+    SPELL_EMPOWERMENT_T     = 70896,
+    //SPELL_ANIMATED_DEAD   = ????? // not in DBC! Need sniffs
 };
 
-enum Phases
+enum Yells
 {
-    PHASE_ALL       = 0,
-    PHASE_INTRO     = 1,
-    PHASE_ONE       = 2,
-    PHASE_TWO       = 3,
-
-    PHASE_INTRO_MASK    = 1 << PHASE_INTRO,
-    PHASE_ONE_MASK      = 1 << PHASE_ONE,
+    SAY_INTRO_1        = -1631011,
+    SAY_INTRO_2        = -1631012,
+    SAY_INTRO_3        = -1631013,
+    SAY_INTRO_4        = -1631014,
+    SAY_INTRO_5        = -1631015,
+    SAY_INTRO_6        = -1631016,
+    SAY_INTRO_7        = -1631017,
+    SAY_AGGRO          = -1631018,
+    SAY_PHASE_2        = -1631019,
+    EMOTE_PHASE_2      = -1631020,
+    SAY_DOMINATE_MIND  = -1631021,
+    SAY_EMPOWERMENT    = -1631022,
+    SAY_TRANSFORMATION = -1631023,
+    SAY_ANIMATE_DEAD   = -1631024,
+    SAY_KILL_1         = -1631025,
+    SAY_KILL_2         = -1631026,
+    SAY_BERSERK        = -1631027,
+    SAY_DEATH          = -1631028
 };
 
-static const uint32 addEntries[2] = {NPC_CULT_FANATIC, NPC_CULT_ADHERENT};
-
-static const Position addSpawnPos[7] =
+const Position SpawnLoc[]=
 {
-    {-578.7066f, 2154.167f, 51.01529f, 1.692969f}, // 1 Left Door 1 (Cult Fanatic)
-    {-598.9028f, 2155.005f, 51.01530f, 1.692969f}, // 2 Left Door 2 (Cult Adherent)
-    {-619.2864f, 2154.460f, 51.01530f, 1.692969f}, // 3 Left Door 3 (Cult Fanatic)
-    {-578.6996f, 2269.856f, 51.01529f, 4.590216f}, // 4 Right Door 1 (Cult Adherent)
-    {-598.9688f, 2269.264f, 51.01529f, 4.590216f}, // 5 Right Door 2 (Cult Fanatic)
-    {-619.4323f, 2268.523f, 51.01530f, 4.590216f}, // 6 Right Door 3 (Cult Adherent)
-    {-524.2480f, 2211.920f, 62.90960f, 3.141592f}, // 7 Upper (Random Cultist)
+    {-578.7066f, 2154.167f, 51.01529f, 1.692969f},
+    {-598.9028f, 2155.005f, 51.01530f, 1.692969f},
+    {-619.2864f, 2154.460f, 51.01530f, 1.692969f},
+    {-578.6996f, 2269.856f, 51.01529f, 4.590216f},
+    {-598.9688f, 2269.264f, 51.01529f, 4.590216f},
+    {-619.4323f, 2268.523f, 51.01530f, 4.590216f},
+    {-524.2480f, 2211.920f, 62.90960f, 3.141592f},
+    {-623.0554f, 2211.326f, 51.76425f, 3.444574f}
 };
 
 class boss_lady_deathwhisper : public CreatureScript
@@ -164,362 +79,142 @@ class boss_lady_deathwhisper : public CreatureScript
 
         struct boss_lady_deathwhisperAI : public BossAI
         {
-            boss_lady_deathwhisperAI(Creature* creature) : BossAI(creature, DATA_LADY_DEATHWHISPER)
-            {
-                introDone = false;
-                dominateMindCount = RAID_MODE<uint8>(0,1,1,3);
-            }
-
-            void InitializeAI()
+            boss_lady_deathwhisperAI(Creature* pCreature) : BossAI(pCreature, DATA_DEATHWHISPER), summons(me)
             {
-                if (!instance || static_cast<InstanceMap*>(me->GetMap())->GetScriptId() != GetScriptId(ICCScriptName))
-                    me->IsAIEnabled = false;
-                else if (!me->isDead())
-                    Reset();
+                pInstance = pCreature->GetInstanceScript();
+                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);
+                me->ApplySpellImmune(SPELL_FROST_BOLT, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, false);
+                bIntro = false;
+                bFirstSummon = false;
             }
 
             void Reset()
             {
-                me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
-                me->SetLastManaUse(0xFFFFFFFF); // hacky, but no other way atm to prevent mana regen
-                events.Reset();
-                events.SetPhase(PHASE_ONE);
-                addWaveCounter = 0;
-                nextVengefulShadeTarget = 0;
-                DoCast(me, SPELL_SHADOW_CHANNELING);
-                me->RemoveAurasDueToSpell(SPELL_BERSERK);
-                me->RemoveAurasDueToSpell(SPELL_MANA_BARRIER);
-                me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, false);
-                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, false);
-                instance->SetBossState(DATA_LADY_DEATHWHISPER, NOT_STARTED);
-            }
+                m_uiPhase = 1;
+                m_uiIntroPhase = 1;
+                m_uiStage = 1;
 
-            void MoveInLineOfSight(Unit* who)
-            {
-                if (!introDone && me->IsWithinDistInMap(who, 100.0f))
-                {
-                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                    introDone = true;
-                    Talk(SAY_INTRO_1);
-                    events.SetPhase(PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_2, 11000, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_3, 21000, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_4, 31500, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_5, 39500, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_6, 48500, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_7, 58000, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_FINISH, 76000, 0, PHASE_INTRO);
-                }
-            }
+                m_uiIntroTimer = 1000;
+                m_uiSummonWaveTimer = !bFirstSummon ? 10000 : 60000;
+                m_uiDeathandDecayTimer = 10000;
+                m_uiFrostBoltTimer = 10000;
+                m_uiFrostValleyTimer = 18000;
+                m_uiShadowBoltTimer = 6000;
+                m_uiBerserkTimer = 600000;
+                m_uiInsignificanceTimer = 7000;
+                m_uiShadeTimer = 10000;
+                m_uiDominateMindTimer = 27000;
+                m_uiCultTimer = urand(20000, 23000);
 
-            void AttackStart(Unit* victim)
-            {
-                if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
-                    return;
+                me->SetLastManaUse(0xFFFFFFFF);
+
+                DoCast(me, SPELL_SHADOW_CHANNELING);
 
-                if (victim && me->Attack(victim, true) && !(events.GetPhaseMask() & PHASE_ONE_MASK))
-                    me->GetMotionMaster()->MoveChase(victim);
+                if (pInstance)
+                    pInstance->SetData(DATA_DEATHWHISPER_EVENT, NOT_STARTED);
             }
 
-            void EnterCombat(Unit* who)
+            void EnterCombat(Unit* /*pWho*/)
             {
-                if (!instance->CheckRequiredBosses(DATA_LADY_DEATHWHISPER, who->ToPlayer()))
-                {
-                    instance->DoCastSpellOnPlayers(LIGHT_S_HAMMER_TELEPORT);
-                    EnterEvadeMode();
-                    return;
-                }
+                DoScriptText(SAY_AGGRO, me);
 
-                events.Reset();
-                events.SetPhase(PHASE_ONE);
-                // phase-independent events
-                events.ScheduleEvent(EVENT_BERSERK, 600000);
-                events.ScheduleEvent(EVENT_DEATH_AND_DECAY, 10000);
-                // phase one only
-                events.ScheduleEvent(EVENT_P1_SUMMON_WAVE, 5000, 0, PHASE_ONE);
-                events.ScheduleEvent(EVENT_P1_SHADOW_BOLT, urand(5500, 6000), 0, PHASE_ONE);
-                events.ScheduleEvent(EVENT_P1_EMPOWER_CULTIST, urand(20000, 30000), 0, PHASE_ONE);
-                if (getDifficulty() != RAID_DIFFICULTY_10MAN_NORMAL)
-                    events.ScheduleEvent(EVENT_DOMINATE_MIND_H, 27000);
-
-                Talk(SAY_AGGRO);
-                DoStartNoMovement(who);
                 me->RemoveAurasDueToSpell(SPELL_SHADOW_CHANNELING);
-                DoCast(me, SPELL_MANA_BARRIER, true);
 
-                instance->SetBossState(DATA_LADY_DEATHWHISPER, IN_PROGRESS);
+                if (pInstance)
+                    pInstance->SetData(DATA_DEATHWHISPER_EVENT, IN_PROGRESS);
             }
 
-            void JustDied(Unit* killer)
+            void JustDied(Unit* /*pKiller*/)
             {
-                Talk(SAY_DEATH);
+                DoScriptText(SAY_DEATH, me);
 
-                instance->SetBossState(DATA_LADY_DEATHWHISPER, DONE);
-
-                std::set<uint32> livingAddEntries;
-                // Full House achievement
-                for (SummonList::iterator itr = summons.begin(); itr != summons.end(); ++itr)
-                    if (Unit* unit = ObjectAccessor::GetUnit(*me, *itr))
-                        if (unit->isAlive() && unit->GetEntry() != NPC_VENGEFUL_SHADE)
-                            livingAddEntries.insert(unit->GetEntry());
-
-                if (livingAddEntries.size() >= 5)
-                {
-                    if (Player* player = killer->GetCharmerOrOwnerPlayerOrPlayerItself())
-                    {
-                        if (Group* group = player->GetGroup())
-                        {
-                            for (GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
-                            {
-                                Player* member = itr->getSource();
-                                if (!member || !member->IsAtGroupRewardDistance(me))
-                                    continue;
-
-                                if (member->isAlive()|| !member->GetCorpse())
-                                    member->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_FULL_HOUSE, 0, me);
-                            }
-                        }
-                        else
-                            player->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_FULL_HOUSE, 0, me);
-                    }
-                }
-
-                summons.DespawnAll();
+                if (pInstance)
+                    pInstance->SetData(DATA_DEATHWHISPER_EVENT, DONE);
             }
 
             void JustReachedHome()
             {
-                instance->SetBossState(DATA_LADY_DEATHWHISPER, FAIL);
+                if(pInstance)
+                    pInstance->SetData(DATA_DEATHWHISPER_EVENT, FAIL);
 
                 summons.DespawnAll();
             }
 
-            void KilledUnit(Unit* victim)
+            void KilledUnit(Unit* pVictim)
             {
-                if (victim->GetTypeId() == TYPEID_PLAYER)
-                    Talk(SAY_KILL);
-            }
-
-            void DamageTaken(Unit* /*damageDealer*/, uint32& uiDamage)
-            {
-                // phase transition
-                if (events.GetPhaseMask() & PHASE_ONE_MASK && uiDamage > me->GetPower(POWER_MANA))
+                if (pVictim->GetTypeId() == TYPEID_PLAYER)
                 {
-                    Talk(SAY_PHASE_2);
-                    Talk(EMOTE_PHASE_2);
-                    DoStartMovement(me->getVictim());
-                    uiDamage -= me->GetPower(POWER_MANA);
-                    me->SetPower(POWER_MANA, 0);
-                    me->RemoveAurasDueToSpell(SPELL_MANA_BARRIER);
-                    events.SetPhase(PHASE_TWO);
-                    events.ScheduleEvent(EVENT_P2_FROSTBOLT, urand(10000, 12000), 0, PHASE_TWO);
-                    events.ScheduleEvent(EVENT_P2_FROSTBOLT_VOLLEY, urand(19000, 21000), 0, PHASE_TWO);
-                    events.ScheduleEvent(EVENT_P2_TOUCH_OF_INSIGNIFICANCE, urand(6000, 9000), 0, PHASE_TWO);
-                    events.ScheduleEvent(EVENT_P2_SUMMON_SHADE, urand(12000, 15000), 0, PHASE_TWO);
-                    // on heroic mode Lady Deathwhisper is immune to taunt effects in phase 2 and continues summoning adds
-                    if (IsHeroic())
+                    switch(rand()%1)
                     {
-                        me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
-                        me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
-                        events.ScheduleEvent(EVENT_P2_SUMMON_WAVE, urand(30000, 60000), 0, PHASE_TWO);
+                        case 0: DoScriptText(SAY_KILL_1, me); break;
+                        case 1: DoScriptText(SAY_KILL_2, me); break;
                     }
                 }
             }
 
-            void JustSummoned(Creature* summon)
+            void MoveInLineOfSight(Unit *pWho)
             {
-                summons.push_back(summon->GetGUID());
-                Unit* target = NULL;
-                if (summon->GetEntry() == NPC_VENGEFUL_SHADE)
+                if (!bIntro && me->IsWithinDistInMap(pWho, 100.0f, true))
                 {
-                    target = ObjectAccessor::GetUnit(*me, nextVengefulShadeTarget);   // Vengeful Shade
-                    nextVengefulShadeTarget = 0;
+                    DoScriptText(SAY_INTRO_1, me);
+                    m_uiIntroTimer = 11000;
+                    bIntro = true;
                 }
-                else
-                    target = SelectTarget(SELECT_TARGET_RANDOM);                        // Wave adds
-
-                summon->AI()->AttackStart(target);                                      // CAN be NULL
-                if (summon->GetEntry() == NPC_REANIMATED_FANATIC)
-                    summon->AI()->DoCast(summon, SPELL_FANATIC_S_DETERMINATION);
-                else if (summon->GetEntry() == NPC_REANIMATED_ADHERENT)
-                    summon->AI()->DoCast(summon, SPELL_ADHERENT_S_DETERMINATION);
             }
 
-            void UpdateAI(const uint32 diff)
+            void JustSummoned(Creature* pSummon)
             {
-                if ((!UpdateVictim() && !(events.GetPhaseMask() & PHASE_INTRO_MASK)) || !CheckInRoom())
-                    return;
+                DoCast(pSummon, SPELL_PORT_VISUAL);
 
-                events.Update(diff);
+                if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 120.0f, true))
+                    pSummon->AI()->AttackStart(pTarget);
 
-                if (me->HasUnitState(UNIT_STAT_CASTING) && !(events.GetPhaseMask() & PHASE_INTRO_MASK))
-                    return;
-
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
-                    {
-                        case EVENT_INTRO_2:
-                            Talk(SAY_INTRO_2);
-                            break;
-                        case EVENT_INTRO_3:
-                            Talk(SAY_INTRO_3);
-                            break;
-                        case EVENT_INTRO_4:
-                            Talk(SAY_INTRO_4);
-                            break;
-                        case EVENT_INTRO_5:
-                            Talk(SAY_INTRO_5);
-                            break;
-                        case EVENT_INTRO_6:
-                            Talk(SAY_INTRO_6);
-                            break;
-                        case EVENT_INTRO_7:
-                            Talk(SAY_INTRO_7);
-                            break;
-                        case EVENT_INTRO_FINISH:
-                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                            break;
-                        case EVENT_DEATH_AND_DECAY:
-                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
-                                DoCast(target, SPELL_DEATH_AND_DECAY);
-                            events.ScheduleEvent(EVENT_DEATH_AND_DECAY, urand(10000, 12000));
-                            break;
-                        case EVENT_DOMINATE_MIND_H:
-                            Talk(SAY_DOMINATE_MIND);
-                            for (uint8 i = 0; i < dominateMindCount; i++)
-                                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -SPELL_DOMINATE_MIND_H))
-                                    DoCast(target, SPELL_DOMINATE_MIND_H);
-                            events.ScheduleEvent(EVENT_DOMINATE_MIND_H, urand(40000, 45000));
-                            break;
-                        case EVENT_P1_SUMMON_WAVE:
-                            SummonWaveP1();
-                            events.ScheduleEvent(EVENT_P1_SUMMON_WAVE, 60000, 0, PHASE_ONE);
-                            break;
-                        case EVENT_P1_SHADOW_BOLT:
-                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
-                                DoCast(target, SPELL_SHADOW_BOLT);
-                            events.ScheduleEvent(EVENT_P1_SHADOW_BOLT, urand(5000, 8000), 0, PHASE_ONE);
-                            break;
-                        case EVENT_P1_REANIMATE_CULTIST:
-                            ReanimateCultist();
-                            break;
-                        case EVENT_P1_EMPOWER_CULTIST:
-                            EmpowerCultist();
-                            events.ScheduleEvent(EVENT_P1_EMPOWER_CULTIST, urand(18000, 25000));
-                            break;
-                        case EVENT_P2_FROSTBOLT:
-                            DoCastVictim(SPELL_FROSTBOLT);
-                            events.ScheduleEvent(EVENT_P2_FROSTBOLT, urand(10000, 11000), 0, PHASE_TWO);
-                            break;
-                        case EVENT_P2_FROSTBOLT_VOLLEY:
-                            DoCastAOE(SPELL_FROSTBOLT_VOLLEY);
-                            events.ScheduleEvent(EVENT_P2_FROSTBOLT_VOLLEY, urand(13000, 15000), 0, PHASE_TWO);
-                            break;
-                        case EVENT_P2_TOUCH_OF_INSIGNIFICANCE:
-                            DoCastVictim(SPELL_TOUCH_OF_INSIGNIFICANCE);
-                            events.ScheduleEvent(EVENT_P2_TOUCH_OF_INSIGNIFICANCE, urand(9000, 13000), 0, PHASE_TWO);
-                            break;
-                        case EVENT_P2_SUMMON_SHADE:
-                            if (Unit* shadeTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                            {
-                                nextVengefulShadeTarget = shadeTarget->GetGUID();
-                                DoCast(shadeTarget, SPELL_SUMMON_SHADE);
-                            }
-                            events.ScheduleEvent(EVENT_P2_SUMMON_SHADE, urand(18000, 23000), 0, PHASE_TWO);
-                            break;
-                        case EVENT_P2_SUMMON_WAVE:
-                            SummonWaveP2();
-                            events.ScheduleEvent(EVENT_P2_SUMMON_WAVE, 60000, 0, PHASE_TWO);
-                            break;
-                        case EVENT_BERSERK:
-                            DoCast(me, SPELL_BERSERK);
-                            Talk(SAY_BERSERK);
-                            break;
-                    }
-                }
-
-                // We should not melee attack when barrier is up
-                if (me->HasAura(SPELL_MANA_BARRIER))
-                    return;
-
-                DoMeleeAttackIfReady();
+                summons.Summon(pSummon);
             }
 
-            // summoning function for first phase
-            void SummonWaveP1()
+            void RandomSpawn()
             {
-                uint8 addIndex = addWaveCounter & 1;
-                uint8 addIndexOther = uint8(addIndex ^ 1);
-                _SummonAdd(addEntries[addIndex], addSpawnPos[addIndex*3]);
-                _SummonAdd(addEntries[addIndexOther], addSpawnPos[addIndex*3+1]);
-                _SummonAdd(addEntries[addIndex], addSpawnPos[addIndex*3+2]);
-                if (Is25ManRaid())
+                switch(m_uiStage)
                 {
-                    _SummonAdd(addEntries[addIndexOther], addSpawnPos[addIndexOther*3]);
-                    _SummonAdd(addEntries[addIndex], addSpawnPos[addIndexOther*3+1]);
-                    _SummonAdd(addEntries[addIndexOther], addSpawnPos[addIndexOther*3+2]);
-                    _SummonAdd(addEntries[urand(0,1)], addSpawnPos[6]);
+                    case 1:
+                        DoSummon(CREATURE_FANATIC, SpawnLoc[0]);
+                        DoSummon(CREATURE_ADHERENT, SpawnLoc[1]);
+                        DoSummon(CREATURE_FANATIC, SpawnLoc[2]);
+                        ++m_uiStage;
+                        break;
+                    case 2:
+                        DoSummon(CREATURE_ADHERENT, SpawnLoc[3]);
+                        DoSummon(CREATURE_FANATIC, SpawnLoc[4]);
+                        DoSummon(CREATURE_ADHERENT, SpawnLoc[5]);
+                        --m_uiStage;
+                        break;
                 }
-                ++addWaveCounter;
             }
 
-            // summoning function for second phase
-            void SummonWaveP2()
+            void DamageTaken(Unit* /*damageDealer*/, uint32& uiDamage)
             {
-                if (Is25ManRaid())
+                if(!me->HasAura(SPELL_MANA_BARRIER) && m_uiPhase == 1)
                 {
-                    uint8 addIndex = addWaveCounter & 1;
-                    _SummonAdd(addEntries[addIndex], addSpawnPos[addIndex*3]);
-                    _SummonAdd(addEntries[addIndex ^ 1], addSpawnPos[addIndex*3+1]);
-                    _SummonAdd(addEntries[addIndex], addSpawnPos[addIndex*3+2]);
+                    me->CastSpell(me, SPELL_MANA_BARRIER, true);
                 }
-                else
-                    _SummonAdd(addEntries[urand(0,1)], addSpawnPos[6]);
-                ++addWaveCounter;
-            }
 
-            // helper for summoning wave mobs
-            void _SummonAdd(uint32 entry, const Position& pos)
-            {
-                if (TempSummon* summon = me->SummonCreature(entry, pos, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000))
-                    summon->AI()->DoCast(summon, SPELL_TELEPORT_VISUAL);
-            }
-
-            void AddToReanimationQueue(Unit* summon)
-            {
-                reanimationQueue.push_back(summon->GetGUID());
-                events.ScheduleEvent(EVENT_P1_REANIMATE_CULTIST, 3000, 0, PHASE_ONE);
-            }
-
-            void ReanimateCultist()
-            {
-                if (reanimationQueue.empty())
-                    return;
-
-                uint64 cultistGUID = reanimationQueue.front();
-                Creature* cultist = ObjectAccessor::GetCreature(*me, cultistGUID);
-                reanimationQueue.pop_front();
-                if (!cultist)
-                    return;
+                if(me->HasAura(SPELL_MANA_BARRIER))
+                {
+                    me->SetHealth(me->GetHealth() +uiDamage);
+                    me->SetPower(POWER_MANA, (me->GetPower(POWER_MANA) -uiDamage));
 
-                Talk(SAY_ANIMATE_DEAD);
-                DoCast(cultist, SPELL_DARK_MARTYRDOM_T);
-            }
+                    if(uiDamage > me->GetPower(POWER_MANA) && m_uiPhase == 1)
+                    {
+                        DoScriptText(SAY_PHASE_2, me);
+                        DoScriptText(EMOTE_PHASE_2, me);
+                        me->SetPower(POWER_MANA, 0);
+                        me->RemoveAurasDueToSpell(SPELL_MANA_BARRIER);
+                        DoResetThreat();
+                        m_uiPhase = 2;
+                    }
 
-            void SpellHitTarget(Unit* target, SpellEntry const* spell)
-            {
-                if (spell->Id == SPELL_DARK_MARTYRDOM_T)
-                {
-                    Position pos;
-                    target->GetPosition(&pos);
-                    if (target->GetEntry() == NPC_CULT_FANATIC)
-                        me->SummonCreature(NPC_REANIMATED_FANATIC, pos, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000);
-                    else
-                        me->SummonCreature(NPC_REANIMATED_ADHERENT, pos, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000);
-
-                    if (TempSummon* summon = target->ToTempSummon())
-                        summon->UnSummon();
+                    if (IsHeroic())
+                        me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
                 }
             }
 
@@ -531,307 +226,209 @@ class boss_lady_deathwhisper : public CreatureScript
                 std::list<Creature*> tmpList;
                 for (SummonList::iterator itr = summons.begin(); itr != summons.end(); ++itr)
                     if (Creature* cre = ObjectAccessor::GetCreature(*me, *itr))
-                        if (cre->isAlive() && (cre->GetEntry() == NPC_CULT_FANATIC || cre->GetEntry() == NPC_CULT_ADHERENT))
+                        if (cre->isAlive() && (cre->GetEntry() == CREATURE_FANATIC || cre->GetEntry() == CREATURE_ADHERENT))
                             tmpList.push_back(cre);
 
-                // noone to empower
                 if (tmpList.empty())
                     return;
 
-                // select random cultist
                 std::list<Creature*>::iterator cultistItr = tmpList.begin();
                 std::advance(cultistItr, urand(0, tmpList.size()-1));
 
                 Creature* cultist = *cultistItr;
-                DoCast(cultist, cultist->GetEntry() == NPC_CULT_FANATIC ? SPELL_DARK_TRANSFORMATION_T : SPELL_DARK_EMPOWERMENT_T, true);
-                Talk(uint8(cultist->GetEntry() == NPC_CULT_FANATIC ? SAY_DARK_TRANSFORMATION : SAY_DARK_EMPOWERMENT));
+                DoCast(cultist, cultist->GetEntry() == CREATURE_FANATIC ? SPELL_TRANSFORMATION_T : SPELL_EMPOWERMENT_T, true);
+                DoScriptText(cultist->GetEntry() == CREATURE_FANATIC ? SAY_TRANSFORMATION : SAY_EMPOWERMENT, me);
             }
 
-        private:
-            uint64 nextVengefulShadeTarget;
-            std::deque<uint64> reanimationQueue;
-            uint32 addWaveCounter;
-            uint8 dominateMindCount;
-            bool introDone;
-        };
-
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new boss_lady_deathwhisperAI(creature);
-        }
-};
-
-class npc_cult_fanatic : public CreatureScript
-{
-    public:
-        npc_cult_fanatic() : CreatureScript("npc_cult_fanatic") { }
-
-        struct npc_cult_fanaticAI : public ScriptedAI
-        {
-            npc_cult_fanaticAI(Creature* creature) : ScriptedAI(creature) {}
-
-            void Reset()
+            void UpdateAI(const uint32 uiDiff)
             {
-                events.Reset();
-                events.ScheduleEvent(EVENT_FANATIC_NECROTIC_STRIKE, urand(10000, 12000));
-                events.ScheduleEvent(EVENT_FANATIC_SHADOW_CLEAVE, urand(14000, 16000));
-                events.ScheduleEvent(EVENT_FANATIC_VAMPIRIC_MIGHT, urand(20000, 27000));
-                if (me->GetEntry() == NPC_CULT_FANATIC)
-                    events.ScheduleEvent(EVENT_CULTIST_DARK_MARTYRDOM, urand(18000, 32000));
-            }
+                if(m_uiPhase == 1)
+                    DoStartNoMovement(me->getVictim());
+                else if(m_uiPhase == 2)
+                    DoStartMovement(me->getVictim());
 
-            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
-            {
-                if (spell->Id == SPELL_DARK_TRANSFORMATION)
-                    me->UpdateEntry(NPC_DEFORMED_FANATIC);
-                else if (spell->Id == SPELL_DARK_TRANSFORMATION_T)
+                if (m_uiIntroTimer <= uiDiff && bIntro && m_uiIntroPhase < 7)
                 {
-                    events.CancelEvent(EVENT_CULTIST_DARK_MARTYRDOM);
-                    me->InterruptNonMeleeSpells(true);
-                    DoCast(me, SPELL_DARK_TRANSFORMATION);
-                }
-            }
+                    switch (m_uiIntroPhase)
+                    {
+                        case 1: DoScriptText(SAY_INTRO_2, me); m_uiIntroTimer = 10000; break;
+                        case 2: DoScriptText(SAY_INTRO_3, me); m_uiIntroTimer = 7000;  break;
+                        case 3: DoScriptText(SAY_INTRO_4, me); m_uiIntroTimer = 12000; break;
+                        case 4: DoScriptText(SAY_INTRO_5, me); m_uiIntroTimer = 7000;  break;
+                        case 5: DoScriptText(SAY_INTRO_6, me); m_uiIntroTimer = 11000; break;
+                        case 6: DoScriptText(SAY_INTRO_7, me); m_uiIntroTimer = 20000; break;
+                    }
+                    ++m_uiIntroPhase;
+                } else m_uiIntroTimer -= uiDiff;
 
-            void UpdateAI(const uint32 diff)
-            {
                 if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
+                if (m_uiBerserkTimer < uiDiff)
+                {
+                    DoCast(me, SPELL_BERSERK);
+                    DoScriptText(SAY_BERSERK, me);
+                    m_uiBerserkTimer = 600000;
+                } else m_uiBerserkTimer -= uiDiff;
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
-                    return;
+                if (m_uiCultTimer < uiDiff)
+                {
+                    EmpowerCultist();
+                    m_uiCultTimer = urand(20000, 23000);
+                } else m_uiCultTimer -= uiDiff;
+
+                if (m_uiDeathandDecayTimer < uiDiff)
+                {
+                    if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                        DoCast(pTarget, SPELL_DEATH_AND_DECAY);
+                    m_uiDeathandDecayTimer = 11000;
+                } else m_uiDeathandDecayTimer -= uiDiff;
 
-                while (uint32 eventId = events.ExecuteEvent())
+                if (m_uiDominateMindTimer < uiDiff)
                 {
-                    switch (eventId)
+                    for (uint8 i = 1; i <= RAID_MODE(0,1,1,3); ++i)
                     {
-                        case EVENT_FANATIC_NECROTIC_STRIKE:
-                            DoCastVictim(SPELL_NECROTIC_STRIKE);
-                            events.ScheduleEvent(SPELL_NECROTIC_STRIKE, urand(11000, 13000));
-                            break;
-                        case EVENT_FANATIC_SHADOW_CLEAVE:
-                            DoCastVictim(SPELL_SHADOW_CLEAVE);
-                            events.ScheduleEvent(EVENT_FANATIC_SHADOW_CLEAVE, urand(9500, 11000));
-                            break;
-                        case EVENT_FANATIC_VAMPIRIC_MIGHT:
-                            DoCast(me, SPELL_VAMPIRIC_MIGHT);
-                            events.ScheduleEvent(EVENT_FANATIC_VAMPIRIC_MIGHT, urand(20000, 27000));
-                            break;
-                        case EVENT_CULTIST_DARK_MARTYRDOM:
-                            DoCast(me, SPELL_DARK_MARTYRDOM_FANATIC);
-                            events.ScheduleEvent(EVENT_CULTIST_DARK_MARTYRDOM, urand(16000, 21000));
-                            break;
+                        if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, -SPELL_DOMINATE_MIND))
+                            DoCast(pTarget, SPELL_DOMINATE_MIND);
                     }
-                }
-
-                DoMeleeAttackIfReady();
-            }
-
-        private:
-            EventMap events;
-        };
-
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new npc_cult_fanaticAI(creature);
-        }
-};
-
-class npc_cult_adherent : public CreatureScript
-{
-    public:
-        npc_cult_adherent() : CreatureScript("npc_cult_adherent") { }
+                    DoScriptText(SAY_DOMINATE_MIND, me);
+                    m_uiDominateMindTimer = 15000;
+                } else m_uiDominateMindTimer -= uiDiff;
 
-        struct npc_cult_adherentAI : public ScriptedAI
-        {
-            npc_cult_adherentAI(Creature* creature) : ScriptedAI(creature) {}
-
-            void Reset()
-            {
-                events.Reset();
-                events.ScheduleEvent(EVENT_ADHERENT_FROST_FEVER, urand(10000, 12000));
-                events.ScheduleEvent(EVENT_ADHERENT_DEATHCHILL, urand(14000, 16000));
-                events.ScheduleEvent(EVENT_ADHERENT_CURSE_OF_TORPOR, urand(14000, 16000));
-                events.ScheduleEvent(EVENT_ADHERENT_SHORUD_OF_THE_OCCULT, urand(32000, 39000));
-                if (me->GetEntry() == NPC_CULT_ADHERENT)
-                    events.ScheduleEvent(EVENT_CULTIST_DARK_MARTYRDOM, urand(18000, 32000));
-            }
-
-            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
-            {
-                if (spell->Id == SPELL_DARK_EMPOWERMENT)
-                    me->UpdateEntry(NPC_EMPOWERED_ADHERENT);
-                else if (spell->Id == SPELL_DARK_EMPOWERMENT_T)
+                if (m_uiPhase == 1)
                 {
-                    events.CancelEvent(EVENT_CULTIST_DARK_MARTYRDOM);
-                    me->InterruptNonMeleeSpells(true);
-                    DoCast(me, SPELL_DARK_EMPOWERMENT);
+                    if (m_uiShadowBoltTimer < uiDiff)
+                    {
+                        if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            DoCast(pTarget, SPELL_SHADOW_BOLT);
+                        m_uiShadowBoltTimer = 6000;
+                    } else m_uiShadowBoltTimer -= uiDiff;
+
+                    if (m_uiSummonWaveTimer < uiDiff)
+                    {
+                        if (Difficulty() == RAID_DIFFICULTY_10MAN_NORMAL || Difficulty() == RAID_DIFFICULTY_10MAN_HEROIC)
+                            RandomSpawn();
+                        else
+                        {
+                            DoSummon(CREATURE_FANATIC, SpawnLoc[0]);
+                            DoSummon(CREATURE_ADHERENT, SpawnLoc[1]);
+                            DoSummon(CREATURE_FANATIC, SpawnLoc[2]);
+                            DoSummon(CREATURE_ADHERENT, SpawnLoc[3]);
+                            DoSummon(CREATURE_FANATIC, SpawnLoc[4]);
+                            DoSummon(CREATURE_ADHERENT, SpawnLoc[5]);
+                            DoSummon(RAND(CREATURE_FANATIC,CREATURE_ADHERENT), SpawnLoc[6]);
+                        }
+                        bFirstSummon = false ? true : true;
+                        m_uiSummonWaveTimer = !bFirstSummon ? 10000 : 60000;
+                    } else m_uiSummonWaveTimer -= uiDiff;
                 }
-            }
 
-            void UpdateAI(const uint32 diff)
-            {
-                if (!UpdateVictim())
-                    return;
+                if (m_uiPhase == 2)
+                {
+                    if (m_uiFrostBoltTimer < uiDiff)
+                    {
+                        DoCast(me->getVictim(), SPELL_FROST_BOLT);
+                        m_uiFrostBoltTimer = 10000;
+                    } else m_uiFrostBoltTimer -= uiDiff;
 
-                events.Update(diff);
+                    if (m_uiFrostValleyTimer < uiDiff)
+                    {
+                        DoCast(SPELL_FROST_BOLT_VALLEY);
+                        m_uiFrostValleyTimer = 19000;
+                    } else m_uiFrostValleyTimer -= uiDiff;
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
-                    return;
+                    if (m_uiInsignificanceTimer < uiDiff)
+                    {
+                        DoCast(me->getVictim(), SPELL_INSIGNIFICANCE);
+                        m_uiInsignificanceTimer = 8000;
+                    } else m_uiInsignificanceTimer -= uiDiff;
 
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
+                    if (m_uiSummonWaveTimer < uiDiff)
                     {
-                        case EVENT_ADHERENT_FROST_FEVER:
-                            DoCastVictim(SPELL_FROST_FEVER);
-                            events.ScheduleEvent(EVENT_ADHERENT_FROST_FEVER, urand(9000, 13000));
-                            break;
-                        case EVENT_ADHERENT_DEATHCHILL:
-                            if (me->GetEntry() == NPC_EMPOWERED_ADHERENT)
-                                DoCastVictim(SPELL_DEATHCHILL_BLAST);
-                            else
-                                DoCastVictim(SPELL_DEATHCHILL_BOLT);
-                            events.ScheduleEvent(EVENT_ADHERENT_DEATHCHILL, urand(9000, 13000));
-                            break;
-                        case EVENT_ADHERENT_CURSE_OF_TORPOR:
-                            if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                                DoCast(target, SPELL_CURSE_OF_TORPOR);
-                            events.ScheduleEvent(EVENT_ADHERENT_CURSE_OF_TORPOR, urand(9000, 13000));
-                            break;
-                        case EVENT_ADHERENT_SHORUD_OF_THE_OCCULT:
-                            DoCast(me, SPELL_SHORUD_OF_THE_OCCULT);
-                            events.ScheduleEvent(EVENT_ADHERENT_SHORUD_OF_THE_OCCULT, urand(27000, 32000));
-                            break;
-                        case EVENT_CULTIST_DARK_MARTYRDOM:
-                            DoCast(me, SPELL_DARK_MARTYRDOM_ADHERENT);
-                            events.ScheduleEvent(EVENT_CULTIST_DARK_MARTYRDOM, urand(16000, 21000));
-                            break;
-                    }
-                }
+                        if (Difficulty() == RAID_DIFFICULTY_10MAN_HEROIC)
+                            DoSummon(RAND(CREATURE_FANATIC,CREATURE_ADHERENT), SpawnLoc[6]);
+                        if (Difficulty() == RAID_DIFFICULTY_25MAN_HEROIC)
+                            RandomSpawn();
+                        m_uiSummonWaveTimer = 60000;
+                    } else m_uiSummonWaveTimer -= uiDiff;
+
+                    if (m_uiShadeTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_SHADE);
+                        m_uiShadeTimer = 15000;
+                    } else m_uiShadeTimer -= uiDiff;
 
-                DoMeleeAttackIfReady();
+                    DoMeleeAttackIfReady();
+                }
             }
 
         private:
-            EventMap events;
+            InstanceScript* pInstance;
+
+            uint8 m_uiPhase;
+            uint8 m_uiIntroPhase;
+            uint8 m_uiStage;
+            uint32 m_uiDominateMindTimer;
+            uint32 m_uiSummonWaveTimer;
+            uint32 m_uiDeathandDecayTimer;
+            uint32 m_uiFrostBoltTimer;
+            uint32 m_uiFrostValleyTimer;
+            uint32 m_uiShadowBoltTimer;
+            uint32 m_uiBerserkTimer;
+            uint32 m_uiInsignificanceTimer;
+            uint32 m_uiShadeTimer;
+            uint32 m_uiCultTimer;
+            uint32 m_uiIntroTimer;
+
+            bool bIntro;
+            bool bFirstSummon;
+
+            SummonList summons;
         };
 
         CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new npc_cult_adherentAI(pCreature);
+            return new boss_lady_deathwhisperAI(pCreature);
         }
 };
 
-class npc_vengeful_shade : public CreatureScript
+class npc_shade : public CreatureScript
 {
     public:
-        npc_vengeful_shade() : CreatureScript("npc_vengeful_shade") { }
+        npc_shade() : CreatureScript("npc_shade") { }
 
-        struct npc_vengeful_shadeAI : public ScriptedAI
+        struct npc_shadeAI : public ScriptedAI
         {
-            npc_vengeful_shadeAI(Creature* creature) : ScriptedAI(creature)
-            {
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-            }
+            npc_shadeAI(Creature* pCreature) : ScriptedAI(pCreature) { }
 
             void Reset()
             {
-                me->AddAura(SPELL_VENGEFUL_BLAST_PASSIVE, me);
-            }
-
-            void SpellHitTarget(Unit* /*target*/, SpellEntry const* spell)
-            {
-                switch (spell->Id)
-                {
-                    case SPELL_VENGEFUL_BLAST:
-                    case SPELL_VENGEFUL_BLAST_25N:
-                    case SPELL_VENGEFUL_BLAST_10H:
-                    case SPELL_VENGEFUL_BLAST_25H:
-                        me->Kill(me);
-                        break;
-                    default:
-                        break;
-                }
-            }
-        };
-
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new npc_vengeful_shadeAI(creature);
-        }
-};
-
-class spell_deathwhisper_mana_barrier : public SpellScriptLoader
-{
-    public:
-        spell_deathwhisper_mana_barrier() : SpellScriptLoader("spell_deathwhisper_mana_barrier") { }
-
-        class spell_deathwhisper_mana_barrier_AuraScript : public AuraScript
-        {
-            PrepareAuraScript(spell_deathwhisper_mana_barrier_AuraScript);
-
-            void HandlePeriodicTick(AuraEffect const* /*aurEff*/)
-            {
-                PreventDefaultAction();
-                Unit* caster = GetCaster();
-                int32 missingHealth = int32(caster->GetMaxHealth() - caster->GetHealth());
-                caster->ModifyHealth(missingHealth);
-                caster->ModifyPower(POWER_MANA, -missingHealth);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetInCombatWithZone();
+                DoCast(me, SPELL_BLAST);
             }
 
-            void Register()
+            void SpellHitTarget(Unit * /*pTarget*/, const SpellEntry *spell)
             {
-                OnEffectPeriodic += AuraEffectPeriodicFn(spell_deathwhisper_mana_barrier_AuraScript::HandlePeriodicTick, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
+                if (spell->Id == SPELL_VENGEFUL_BLAST)
+                    me->ForcedDespawn();
             }
-        };
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_deathwhisper_mana_barrier_AuraScript();
-        }
-};
 
-class spell_cultist_dark_martyrdom : public SpellScriptLoader
-{
-    public:
-        spell_cultist_dark_martyrdom() : SpellScriptLoader("spell_cultist_dark_martyrdom") { }
-
-        class spell_cultist_dark_martyrdom_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_cultist_dark_martyrdom_SpellScript);
-
-            void HandleEffect(SpellEffIndex /*effIndex*/)
+            void UpdateAI(const uint32 /*uiDiff*/)
             {
-                if (GetCaster()->isSummon())
-                    if (Unit* owner = GetCaster()->ToTempSummon()->GetSummoner())
-                        if (owner->GetEntry() == NPC_LADY_DEATHWHISPER)
-                            CAST_AI(boss_lady_deathwhisper::boss_lady_deathwhisperAI, owner->ToCreature()->AI())->AddToReanimationQueue(GetCaster());
-
-                GetCaster()->Kill(GetCaster());
-                GetCaster()->SetDisplayId(uint32(GetCaster()->GetEntry() == NPC_CULT_FANATIC ? 38009 : 38010));
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_cultist_dark_martyrdom_SpellScript::HandleEffect, EFFECT_2, SPELL_EFFECT_FORCE_DESELECT);
+                DoMeleeAttackIfReady();
             }
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new spell_cultist_dark_martyrdom_SpellScript();
+            return new npc_shadeAI(pCreature);
         }
 };
 
 void AddSC_boss_lady_deathwhisper()
 {
     new boss_lady_deathwhisper();
-    new npc_cult_fanatic();
-    new npc_cult_adherent();
-    new npc_vengeful_shade();
-    new spell_deathwhisper_mana_barrier();
-    new spell_cultist_dark_martyrdom();
+    new npc_shade();
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
old mode 100755
new mode 100644
index 72e514b..aac8a63
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -15,432 +15,447 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "ObjectMgr.h"
-#include "ScriptMgr.h"
-#include "ScriptedCreature.h"
-#include "SpellScript.h"
-#include "SpellAuras.h"
+#include "ScriptPCH.h"
 #include "icecrown_citadel.h"
-#include "MapManager.h"
+#include "SpellAuraEffects.h"
 
-enum ScriptTexts
+enum Yells
 {
-    SAY_ENTER_ZONE              = 0,
-    SAY_AGGRO                   = 1,
-    SAY_BONE_STORM              = 2,
-    SAY_BONESPIKE               = 3,
-    SAY_KILL                    = 4,
-    SAY_DEATH                   = 5,
-    SAY_BERSERK                 = 6,
-    EMOTE_BONE_STORM            = 7,
+    SAY_INTRO     = -1631000,
+    SAY_AGGRO     = -1631001,
+    SAY_STORM     = -1631002,
+    SAY_SPIKE_1   = -1631003,
+    SAY_SPIKE_2   = -1631004,
+    SAY_SPIKE_3   = -1631005,
+    SAY_KILL_1    = -1631006,
+    SAY_KILL_2    = -1631007,
+    SAY_DEATH     = -1631008,
+    SAY_BERSERK   = -1631009,
+    STORM_EMOTE   = -1631010
 };
 
 enum Spells
 {
-    // Lord Marrowgar
-    SPELL_BONE_SLICE            = 69055,
-    SPELL_BONE_STORM            = 69076,
-    SPELL_BONE_SPIKE_GRAVEYARD  = 69057,
-    SPELL_COLDFLAME_NORMAL      = 69140,
-    SPELL_COLDFLAME_BONE_STORM  = 72705,
-
-    // Bone Spike
-    SPELL_IMPALED               = 69065,
-    SPELL_RIDE_VEHICLE          = 46598,
-
-    // Coldflame
-    SPELL_COLDFLAME_PASSIVE     = 69145,
+    SPELL_SABER_SLASH        = 69055,
+    SPELL_COLD_FLAME         = 69146,
+    SPELL_BONE_SPIKE         = 73142,
+    SPELL_SPIKE_IMPALING     = 69057,
+    SPELL_IMPALE             = 69062,
+    SPELL_IMPALED            = 69065,
+    SPELL_BONE_STORM         = 69076,
+    SPELL_COLD_FLAME_SPAWN   = 69138,
+    SPELL_COLD_FLAME_SPAWN_B = 72701
 };
 
-static const uint32 boneSpikeSummonId[3] = {69062, 72669, 72670};
-
-enum Events
-{
-    EVENT_BONE_SPIKE_GRAVEYARD  = 1,
-    EVENT_COLDFLAME             = 2,
-    EVENT_BONE_STORM_BEGIN      = 3,
-    EVENT_BONE_STORM_MOVE       = 4,
-    EVENT_BONE_STORM_END        = 5,
-    EVENT_ENABLE_BONE_SLICE     = 6,
-    EVENT_ENRAGE                = 7,
-    EVENT_WARN_BONE_STORM       = 8,
-
-    EVENT_COLDFLAME_TRIGGER     = 9,
-    EVENT_FAIL_BONED            = 10,
-
-    EVENT_GROUP_SPECIAL         = 1,
-};
-
-enum MovementPoints
+enum ePoint
 {
-    POINT_TARGET_BONESTORM_PLAYER   = 36612631,
-    POINT_TARGET_COLDFLAME          = 36672631,
+    POINT_PLAYER              = 366121
 };
 
-class boss_lord_marrowgar : public CreatureScript
+class npc_bone_spike : public CreatureScript
 {
     public:
-        boss_lord_marrowgar() : CreatureScript("boss_lord_marrowgar") { }
+        npc_bone_spike() : CreatureScript("npc_bone_spike") { }
 
-        struct boss_lord_marrowgarAI : public BossAI
+        struct npc_bone_spikeAI : public Scripted_NoMovementAI
         {
-            boss_lord_marrowgarAI(Creature* creature) : BossAI(creature, DATA_LORD_MARROWGAR)
+            npc_bone_spikeAI(Creature *creature) : Scripted_NoMovementAI(creature), vehicle(creature->GetVehicleKit())
             {
-                boneStormDuration = RAID_MODE<uint32>(20000, 30000, 20000, 30000);
-                baseSpeed = creature->GetSpeedRate(MOVE_RUN);
-                coldflameLastPos.Relocate(creature);
-                introDone = false;
-                boneSlice = false;
+                ASSERT(vehicle);
+                BoneSpikeGUID = 0;
+                instance = creature->GetInstanceScript();
             }
 
-            void InitializeAI()
+            void IsSummonedBy(Unit* summoner)
             {
-                if (!instance || static_cast<InstanceMap*>(me->GetMap())->GetScriptId() != GetScriptId(ICCScriptName))
-                    me->IsAIEnabled = false;
-                else if (!me->isDead())
-                    Reset();
+                BoneSpikeGUID = summoner->GetGUID();
+                summoner->EnterVehicle(vehicle, 0);
+                DoCast(summoner, SPELL_IMPALED);
+                uiAchievBonedTimer = 8000;
             }
 
             void Reset()
             {
-                me->SetSpeed(MOVE_RUN, baseSpeed, true);
-                me->RemoveAurasDueToSpell(SPELL_BONE_STORM);
-                me->RemoveAurasDueToSpell(SPELL_BERSERK);
-                events.Reset();
-                events.ScheduleEvent(EVENT_ENABLE_BONE_SLICE, 10000);
-                events.ScheduleEvent(EVENT_BONE_SPIKE_GRAVEYARD, urand(10000, 15000), EVENT_GROUP_SPECIAL);
-                events.ScheduleEvent(EVENT_COLDFLAME, 5000, EVENT_GROUP_SPECIAL);
-                events.ScheduleEvent(EVENT_WARN_BONE_STORM, urand(45000, 50000));
-                events.ScheduleEvent(EVENT_ENRAGE, 600000);
-                instance->SetBossState(DATA_LORD_MARROWGAR, NOT_STARTED);
+                BoneSpikeGUID = 0;
             }
 
-            void EnterCombat(Unit* /*who*/)
+            void JustDied(Unit* /*pKiller*/)
             {
-                Talk(SAY_AGGRO);
-
-                instance->SetBossState(DATA_LORD_MARROWGAR, IN_PROGRESS);
+                if (Player* boned = ObjectAccessor::GetPlayer(*me, BoneSpikeGUID))
+                    boned->RemoveAurasDueToSpell(SPELL_IMPALED);
             }
 
-            void JustDied(Unit* /*killer*/)
+            void KilledUnit(Unit* /*pVictim*/)
             {
-                Talk(SAY_DEATH);
-
-                instance->SetBossState(DATA_LORD_MARROWGAR, DONE);
+                me->Kill(me);
             }
 
-            void JustReachedHome()
+            void UpdateAI(const uint32 uiDiff)
             {
-                instance->SetBossState(DATA_LORD_MARROWGAR, FAIL);
-                instance->SetData(DATA_BONED_ACHIEVEMENT, uint32(true));    // reset
-            }
+                if (!BoneSpikeGUID || !instance)
+                    return;
 
-            void KilledUnit(Unit* victim)
-            {
-                if (victim->GetTypeId() == TYPEID_PLAYER)
-                    Talk(SAY_KILL);
-            }
+                if (Player* boned = ObjectAccessor::GetPlayer(*me, BoneSpikeGUID))
+                    if (!boned->HasAura(SPELL_IMPALED))
+                        me->Kill(me);
 
-            void MoveInLineOfSight(Unit* who)
-            {
-                if (!introDone && me->IsWithinDistInMap(who, 70.0f))
+                if (uiAchievBonedTimer <= uiDiff)
                 {
-                    Talk(SAY_ENTER_ZONE);
-                    introDone = true;
-                }
+                    instance->SetData(DATA_BONED, FAIL);
+                    uiAchievBonedTimer = 8000;
+                } else uiAchievBonedTimer -= uiDiff;
             }
 
-            void UpdateAI(const uint32 diff)
-            {
-                if (!UpdateVictim() || !CheckInRoom())
-                    return;
-
-                events.Update(diff);
+        private:
+            InstanceScript* instance;
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
-                    return;
+            uint64 BoneSpikeGUID;
+            uint32 uiAchievBonedTimer;
 
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
-                    {
-                        case EVENT_BONE_SPIKE_GRAVEYARD:
-                            if (IsHeroic() || !me->HasAura(SPELL_BONE_STORM))
-                                DoCast(me, SPELL_BONE_SPIKE_GRAVEYARD);
-                            events.ScheduleEvent(EVENT_BONE_SPIKE_GRAVEYARD, urand(15000, 20000), EVENT_GROUP_SPECIAL);
-                            break;
-                        case EVENT_COLDFLAME:
-                            coldflameLastPos.Relocate(me);
-                            if (!me->HasAura(SPELL_BONE_STORM))
-                                me->CastCustomSpell(SPELL_COLDFLAME_NORMAL, SPELLVALUE_MAX_TARGETS, 1, me);
-                            else
-                                DoCast(me, SPELL_COLDFLAME_BONE_STORM);
-                            events.ScheduleEvent(EVENT_COLDFLAME, 5000, EVENT_GROUP_SPECIAL);
-                            break;
-                        case EVENT_WARN_BONE_STORM:
-                            boneSlice = false;
-                            Talk(EMOTE_BONE_STORM);
-                            me->FinishSpell(CURRENT_MELEE_SPELL, false);
-                            DoCast(me, SPELL_BONE_STORM);
-                            events.DelayEvents(3000, EVENT_GROUP_SPECIAL);
-                            events.ScheduleEvent(EVENT_BONE_STORM_BEGIN, 3050);
-                            events.ScheduleEvent(EVENT_WARN_BONE_STORM, urand(90000, 95000));
-                            break;
-                        case EVENT_BONE_STORM_BEGIN:
-                            if (Aura* pStorm = me->GetAura(SPELL_BONE_STORM))
-                                pStorm->SetDuration(int32(boneStormDuration));
-                            me->SetSpeed(MOVE_RUN, baseSpeed*3.0f, true);
-                            Talk(SAY_BONE_STORM);
-                            events.ScheduleEvent(EVENT_BONE_STORM_END, boneStormDuration+1);
-                            // no break here
-                        case EVENT_BONE_STORM_MOVE:
-                        {
-                            events.ScheduleEvent(EVENT_BONE_STORM_MOVE, boneStormDuration/3);
-                            Unit* unit = SelectUnit(SELECT_TARGET_RANDOM, 1);
-                            if (!unit)
-                                unit = SelectUnit(SELECT_TARGET_RANDOM, 0);
-                            if (unit)
-                                me->GetMotionMaster()->MovePoint(POINT_TARGET_BONESTORM_PLAYER, unit->GetPositionX(), unit->GetPositionY(), unit->GetPositionZ());
-                            break;
-                        }
-                        case EVENT_BONE_STORM_END:
-                            if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
-                                me->GetMotionMaster()->MovementExpired();
-                            DoStartMovement(me->getVictim());
-                            me->SetSpeed(MOVE_RUN, baseSpeed, true);
-                            events.CancelEvent(EVENT_BONE_STORM_MOVE);
-                            events.ScheduleEvent(EVENT_ENABLE_BONE_SLICE, 10000);
-                            if (!IsHeroic())
-                                events.RescheduleEvent(EVENT_BONE_SPIKE_GRAVEYARD, urand(15000, 20000), EVENT_GROUP_SPECIAL);
-                            break;
-                        case EVENT_ENABLE_BONE_SLICE:
-                            boneSlice = true;
-                            break;
-                        case EVENT_ENRAGE:
-                            DoCast(me, SPELL_BERSERK, true);
-                            Talk(SAY_BERSERK);
-                            break;
-                    }
-                }
+            Vehicle* vehicle;
+        };
 
-                // We should not melee attack when storming
-                if (me->HasAura(SPELL_BONE_STORM))
-                    return;
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_bone_spikeAI(creature);
+        }
+};
 
-                // After 10 seconds since encounter start Bone Slice replaces melee attacks
-                if (boneSlice && !me->GetCurrentSpell(CURRENT_MELEE_SPELL))
-                    DoCastVictim(SPELL_BONE_SLICE);
+class npc_cold_flame : public CreatureScript
+{
+    public:
+        npc_cold_flame() : CreatureScript("npc_cold_flame") { }
 
-                DoMeleeAttackIfReady();
+        struct npc_cold_flameAI : public ScriptedAI
+        {
+            npc_cold_flameAI(Creature *creature) : ScriptedAI(creature)
+            {
+                instance = creature->GetInstanceScript();
             }
 
-            void MovementInform(uint32 type, uint32 id)
+            void Reset()
             {
-                if (type != POINT_MOTION_TYPE || id != POINT_TARGET_BONESTORM_PLAYER)
-                    return;
+                uiColdFlameTimer = 900;
+
+                SpellEntry* spell = GET_SPELL(SPELL_COLD_FLAME);
+                if (spell)
+                    spell->EffectRadiusIndex[0] = 16; //prevent stack damage
+                DoCast(me, SPELL_COLD_FLAME);
 
-                // lock movement
+                me->SetVisible(false);
                 DoStartNoMovement(me->getVictim());
+
+                uiStage = 1;
+                uiRadius = 2;
+                uiOwnerEntry = 0;
             }
 
-            const Position* GetLastColdflamePosition() const
+            void IsSummonedBy(Unit* owner)
             {
-                return &coldflameLastPos;
+                if(owner)
+                {
+                    if(owner->HasAura(SPELL_BONE_STORM))
+                        bCrossfire = true;
+                    else
+                        bCrossfire = false;
+
+                    uiOwnerEntry = owner->GetEntry();
+                }
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if(uiColdFlameTimer <= uiDiff)
+                {
+                    if(uiOwnerEntry == CREATURE_MARROWGAR)
+                    {
+                        if(bCrossfire)
+                        {
+                            float x, y;
+                            me->GetNearPoint2D(x, y, uiRadius*uiStage, 0);
+                            me->SummonCreature(CREATURE_COLD_FLAME, x, y, me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                            me->GetNearPoint2D(x, y, uiRadius*uiStage, M_PI/2);
+                            me->SummonCreature(CREATURE_COLD_FLAME, x, y, me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                            me->GetNearPoint2D(x, y, uiRadius*uiStage, M_PI*(M_PI/2));
+                            me->SummonCreature(CREATURE_COLD_FLAME, x, y, me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                            me->GetNearPoint2D(x, y, uiRadius*uiStage, M_PI);
+                            me->SummonCreature(CREATURE_COLD_FLAME, x, y, me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                        }
+                        else if (!bCrossfire)
+                        {
+                            float x, y;
+                            float angle = instance->GetData(DATA_ANGLE / 1000);
+                            me->GetNearPoint2D(x, y, uiRadius*uiStage, angle);
+                            me->SummonCreature(CREATURE_COLD_FLAME, x, y, me->GetPositionZ(), angle, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                        }
+                        ++uiStage;
+                        uiColdFlameTimer = 1000;
+                    }
+                } else uiColdFlameTimer -= uiDiff;
             }
 
         private:
-            uint32 boneStormDuration;
-            float baseSpeed;
-            Position coldflameLastPos;
-            bool introDone;
-            bool boneSlice;
+            InstanceScript* instance;
+
+            uint32 uiColdFlameTimer;
+            uint8 uiRadius;
+            uint8 uiStage;
+            uint32 uiOwnerEntry;
+            bool bCrossfire;
         };
 
         CreatureAI* GetAI(Creature* creature) const
         {
-            return new boss_lord_marrowgarAI(creature);
+            return new npc_cold_flameAI(creature);
         }
 };
 
-typedef boss_lord_marrowgar::boss_lord_marrowgarAI MarrowgarAI;
-
-class npc_coldflame : public CreatureScript
+class boss_lord_marrowgar : public CreatureScript
 {
     public:
-        npc_coldflame() : CreatureScript("npc_coldflame") { }
+        boss_lord_marrowgar() : CreatureScript("boss_lord_marrowgar") { }
 
-        struct npc_coldflameAI : public ScriptedAI
+        struct boss_lord_marrowgarAI : public BossAI
         {
-            npc_coldflameAI(Creature* creature) : ScriptedAI(creature)
+            boss_lord_marrowgarAI(Creature* creature) : BossAI(creature, DATA_MARROWGAR), summons(me)
             {
+                instance = creature->GetInstanceScript();
+                fBaseSpeed = me->GetSpeedRate(MOVE_RUN);
+                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);
+                bIntro = false;
             }
 
-            void IsSummonedBy(Unit* owner)
+            void Reset()
             {
-                if (owner->GetTypeId() != TYPEID_UNIT)
+                uiSaberSlashTimer = 7000;
+                uiBoneSpikeGraveyardTimer = 15000;
+                uiColdFlameTimer = 10000;
+                uiBoneStormTimer = 45000;
+                uiBoneStormRemoveTimer = 20000;
+                uiBerserkTimer = 600000;
+
+                me->SetSpeed(MOVE_RUN, fBaseSpeed, true);
+
+                if (!instance)
                     return;
-                Creature* creOwner = owner->ToCreature();
-                DoCast(me, SPELL_COLDFLAME_PASSIVE, true);
-                float x, y, z;
-                // random target case
-                if (!owner->HasAura(SPELL_BONE_STORM))
-                {
-                    // select any unit but not the tank (by owners threatlist)
-                    Unit* target = creOwner->AI()->SelectTarget(SELECT_TARGET_RANDOM, 1, 40.0f, true, -SPELL_IMPALED);
-                    if (!target)
-                        target = creOwner->AI()->SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true); // or the tank if its solo
-                    if (!target)
-                    {
-                        me->DespawnOrUnsummon();
-                        return;
-                    }
 
-                    target->GetPosition(x, y, z);
-                    float scale = 70.0f / me->GetExactDist2d(x, y);
-                    x = me->GetPositionX() + (x - me->GetPositionX()) * scale;
-                    y = me->GetPositionY() + (y - me->GetPositionY()) * scale;
-                }
-                else
-                {
-                    me->GetPosition(x, y, z);
-                    MarrowgarAI* marrowgarAI = CAST_AI(MarrowgarAI, creOwner->AI());
-                    Position const* ownerPos = marrowgarAI->GetLastColdflamePosition();
-                    float ang = me->GetAngle(ownerPos) - static_cast<float>(M_PI);
-                    MapManager::NormalizeOrientation(ang);
-                    x += 50.0f * cosf(ang);
-                    y += 50.0f * sinf(ang);
-                }
-                me->GetMotionMaster()->MovePoint(POINT_TARGET_COLDFLAME, x, y, z);
-                events.ScheduleEvent(EVENT_COLDFLAME_TRIGGER, 400);
+                instance->SetData(DATA_BONED, DONE);
+                instance->SetData(DATA_MARROWGAR_EVENT, NOT_STARTED);
+
+                if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
+                    me->GetMotionMaster()->MovementExpired();
             }
 
-            void UpdateAI(const uint32 diff)
+            void EnterCombat(Unit* /*pWho*/)
             {
-                events.Update(diff);
+                DoScriptText(SAY_AGGRO, me);
 
-                if (events.ExecuteEvent() == EVENT_COLDFLAME_TRIGGER)
-                {
-                    if (me->HasAura(SPELL_COLDFLAME_PASSIVE))
-                        DoCast(SPELL_COLDFLAME_PASSIVE);
-                    events.ScheduleEvent(EVENT_COLDFLAME_TRIGGER, 400);
-                }
+                if (instance)
+                    instance->SetData(DATA_MARROWGAR_EVENT, IN_PROGRESS);
+
+                summons.DespawnAll();
             }
 
-            void MovementInform(uint32 type, uint32 id)
+            void JustSummoned(Creature* summon)
             {
-                if (type != POINT_MOTION_TYPE || id != POINT_TARGET_COLDFLAME)
-                    return;
-
-                // stop triggering but dont despawn
-                me->RemoveAura(SPELL_COLDFLAME_PASSIVE);
+                summons.Summon(summon);
             }
 
-        private:
-            EventMap events;
-        };
+            void JustDied(Unit* /*pKiller*/)
+            {
+                if (!instance)
+                    return;
 
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new npc_coldflameAI(creature);
-        }
-};
+                DoScriptText(SAY_DEATH, me);
 
-class npc_bone_spike : public CreatureScript
-{
-    public:
-        npc_bone_spike() : CreatureScript("npc_bone_spike") { }
+                instance->SetData(DATA_MARROWGAR_EVENT, DONE);
+                if(instance->GetData(DATA_BONED) == DONE)
+                    instance->DoCompleteAchievement(RAID_MODE(ACHIEV_BONED_10, ACHIEV_BONED_25));
 
-        struct npc_bone_spikeAI : public Scripted_NoMovementAI
-        {
-            npc_bone_spikeAI(Creature* creature) : Scripted_NoMovementAI(creature), hasTrappedUnit(false)
-            {
-                ASSERT(creature->GetVehicleKit());
+                summons.DespawnAll();
             }
 
-            void JustDied(Unit* /*killer*/)
+            void JustReachedHome()
             {
-                if (TempSummon* summ = me->ToTempSummon())
-                    if (Unit* trapped = summ->GetSummoner())
-                        trapped->RemoveAurasDueToSpell(SPELL_IMPALED);
+                if (instance)
+                    instance->SetData(DATA_MARROWGAR_EVENT, FAIL);
 
-                me->DespawnOrUnsummon();
+                summons.DespawnAll();
             }
 
-            void KilledUnit(Unit* victim)
+            void KilledUnit(Unit* pVictim)
             {
-                me->DespawnOrUnsummon();
-                victim->RemoveAurasDueToSpell(SPELL_IMPALED);
+                if (pVictim->GetTypeId() == TYPEID_PLAYER)
+                {
+                    switch(rand()%1)
+                    {
+                        case 0: DoScriptText(SAY_KILL_1, me); break;
+                        case 1: DoScriptText(SAY_KILL_2, me); break;
+                    }
+                }
             }
 
-            void IsSummonedBy(Unit* summoner)
+            void MoveInLineOfSight(Unit* pWho)
             {
-                DoCast(summoner, SPELL_IMPALED);
-                summoner->CastSpell(me, SPELL_RIDE_VEHICLE, true);
-                events.ScheduleEvent(EVENT_FAIL_BONED, 8000);
-                hasTrappedUnit = true;
+                if (!bIntro && me->IsWithinDistInMap(pWho, 90.0f, true))
+                {
+                    DoScriptText(SAY_INTRO, me);
+                    bIntro = true;
+                }
             }
 
-            void UpdateAI(const uint32 diff)
+            void UpdateAI(const uint32 uiDiff)
             {
-                if (!hasTrappedUnit)
+                if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
+                if (uiBerserkTimer <= uiDiff)
+                {
+                    DoScriptText(SAY_BERSERK, me);
+                    DoCast(SPELL_BERSERK);
+                    uiBerserkTimer = 600000;
+                } else uiBerserkTimer -= uiDiff;
+
+                if (IsHeroic() || !me->HasAura(SPELL_BONE_STORM))
+                {
+                    if (uiBoneSpikeGraveyardTimer < uiDiff)
+                    {
+                        DoCast(me, SPELL_SPIKE_IMPALING);
+                        uiBoneSpikeGraveyardTimer = 15000;
+                    } else uiBoneSpikeGraveyardTimer -= uiDiff;
+                }
+
+                if (!me->HasAura(SPELL_BONE_STORM))
+                {
+                    if (uiBoneStormTimer <= uiDiff)
+                    {
+                        DoCast(SPELL_BONE_STORM);
+                        DoScriptText(SAY_STORM, me);
+                        DoScriptText(STORM_EMOTE, me);
+                        DoStartNoMovement(me->getVictim());
+                        me->SetSpeed(MOVE_RUN, fBaseSpeed*3.0f, true);
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            me->GetMotionMaster()->MovePoint(POINT_PLAYER, target->GetPositionX(), target->GetPositionY(), target->GetPositionZ());
+                        uiBoneStormTimer = 45000; //bone storm 30 second + other spell casting time
+                    } else uiBoneStormTimer -= uiDiff;
+
+                    if (uiColdFlameTimer <= uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 6.0f, true))
+                        {
+                            instance->SetData(DATA_ANGLE, (me->GetAngle(target)*1000));
+                            DoCast(target, SPELL_COLD_FLAME_SPAWN);
+                        }
+                        else
+                        {
+                            instance->SetData(DATA_ANGLE, (me->GetAngle(me->getVictim())*1000));
+                            DoCastVictim( SPELL_COLD_FLAME_SPAWN);
+                        }
+                        uiColdFlameTimer = 10000;
+                    } else uiColdFlameTimer -= uiDiff;
+
+                    if (uiSaberSlashTimer <= uiDiff)
+                    {
+                        DoCastVictim( SPELL_SABER_SLASH);
+                        uiSaberSlashTimer = 7000;
+                    } else uiSaberSlashTimer -= uiDiff;
+                }
+                else
+                {
+                    if (uiBoneStormRemoveTimer <= uiDiff)
+                    {
+                        me->RemoveAurasDueToSpell(SPELL_BONE_STORM);
+                        DoStartMovement(me->getVictim());
+                        me->SetSpeed(MOVE_RUN, fBaseSpeed, true);
+                        uiBoneStormRemoveTimer = RAID_MODE(20000,30000,20000,30000);
+                    } else uiBoneStormRemoveTimer -= uiDiff;
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+            void MovementInform(uint32 type, uint32 id)
+            {
+                if(type != POINT_MOTION_TYPE)
+                    return;
 
-                if (events.ExecuteEvent() == EVENT_FAIL_BONED)
-                    if (InstanceScript* instance = me->GetInstanceScript())
-                        instance->SetData(DATA_BONED_ACHIEVEMENT, uint32(false));
+                if(id = POINT_PLAYER)
+                {
+                    if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))
+                        me->GetMotionMaster()->MovePoint(POINT_PLAYER, target->GetPositionX(), target->GetPositionY(), target->GetPositionZ());
+                    DoCast(SPELL_COLD_FLAME_SPAWN_B);
+                }
             }
 
         private:
-            EventMap events;
-            bool hasTrappedUnit;
+            InstanceScript* instance;
+
+            uint32 uiSaberSlashTimer;
+            uint32 uiBoneSpikeGraveyardTimer;
+            uint32 uiBoneStormTimer;
+            uint32 uiBoneStormRemoveTimer;
+            uint32 uiColdFlameTimer;
+            uint32 uiBerserkTimer;
+            float fBaseSpeed;
+            bool bIntro;
+
+            SummonList summons;
         };
 
         CreatureAI* GetAI(Creature* creature) const
         {
-            return new npc_bone_spikeAI(creature);
+            return new boss_lord_marrowgarAI(creature);
         }
 };
 
-class spell_marrowgar_coldflame : public SpellScriptLoader
+class spell_lord_marrowgar_bone_storm : public SpellScriptLoader
 {
     public:
-        spell_marrowgar_coldflame() : SpellScriptLoader("spell_marrowgar_coldflame") { }
+        spell_lord_marrowgar_bone_storm() : SpellScriptLoader("spell_lord_marrowgar_bone_storm") { }
+
 
-        class spell_marrowgar_coldflame_SpellScript : public SpellScript
+        class spell_lord_marrowgar_bone_storm_SpellScript : public SpellScript
         {
-            PrepareSpellScript(spell_marrowgar_coldflame_SpellScript);
+            PrepareSpellScript(spell_lord_marrowgar_bone_storm_SpellScript)
 
-            void HandleScriptEffect(SpellEffIndex effIndex)
+            void onEffect(SpellEffIndex /*effIndex*/)
             {
-                PreventHitDefaultEffect(effIndex);
-                Unit* caster = GetCaster();
-                uint8 count = 1;
-                if (GetSpellInfo()->Id == 72705)
-                    count = 4;
+                int32 dmg = GetHitDamage();
+                float distance = GetHitUnit()->GetExactDist2d(GetCaster());
+                float distVariant = distance >= 20.0f ? 4 : (10.0f/3.0f);
+                if (distance < 5)
+                    distance = 5; //prevent exploit
 
-                for (uint8 i = 0; i < count; ++i)
-                    caster->CastSpell(caster, uint32(GetEffectValue()+i), true);
+                SetHitDamage(int32(dmg * distVariant / distance));
             }
 
             void Register()
             {
-                OnEffect += SpellEffectFn(spell_marrowgar_coldflame_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+                OnEffect += SpellEffectFn(spell_lord_marrowgar_bone_storm_SpellScript::onEffect, EFFECT_0, SPELL_EFFECT_SCHOOL_DAMAGE);
+            }
+
+            bool Load()
+            {
+                if (GetCaster()->GetEntry() != CREATURE_MARROWGAR)
+                    return false;
+                return true;
             }
         };
 
         SpellScript* GetSpellScript() const
         {
-            return new spell_marrowgar_coldflame_SpellScript();
+            return new spell_lord_marrowgar_bone_storm_SpellScript();
         }
 };
 
+typedef boss_lord_marrowgar::boss_lord_marrowgarAI MarrowgarAI;
+
 class spell_marrowgar_bone_spike_graveyard : public SpellScriptLoader
 {
     public:
         spell_marrowgar_bone_spike_graveyard() : SpellScriptLoader("spell_marrowgar_bone_spike_graveyard") { }
 
+
         class spell_marrowgar_bone_spike_graveyard_SpellScript : public SpellScript
         {
             PrepareSpellScript(spell_marrowgar_bone_spike_graveyard_SpellScript);
@@ -452,21 +467,20 @@ class spell_marrowgar_bone_spike_graveyard : public SpellScriptLoader
                 {
                     CreatureAI* marrowgarAI = marrowgar->AI();
                     bool yell = false;
-                    uint8 boneSpikeCount = uint8(GetCaster()->GetMap()->GetSpawnMode() & 1 ? 3 : 1);
+                    uint8 boneSpikeCount = GetCaster()->GetMap()->GetSpawnMode() & 1 ? 3 : 1;
                     for (uint8 i = 0; i < boneSpikeCount; ++i)
                     {
-                        // select any unit but not the tank
                         Unit* target = marrowgarAI->SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, -SPELL_IMPALED);
                         if (!target && !i)
                             target = marrowgarAI->SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true, -SPELL_IMPALED);
                         if (!target)
                             break;
                         yell = true;
-                        target->CastCustomSpell(boneSpikeSummonId[i], SPELLVALUE_BASE_POINT0, 0, target, true);
+                        target->CastCustomSpell(SPELL_IMPALE, SPELLVALUE_BASE_POINT0, 0, target, true);
                     }
 
                     if (yell)
-                        marrowgarAI->Talk(SAY_BONESPIKE);
+                        DoScriptText(RAND(SAY_SPIKE_1,SAY_SPIKE_2,SAY_SPIKE_3), GetCaster());
                 }
             }
 
@@ -482,44 +496,14 @@ class spell_marrowgar_bone_spike_graveyard : public SpellScriptLoader
         }
 };
 
-class spell_marrowgar_bone_storm : public SpellScriptLoader
-{
-    public:
-        spell_marrowgar_bone_storm() : SpellScriptLoader("spell_marrowgar_bone_storm") { }
-
-        class spell_marrowgar_bone_storm_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_marrowgar_bone_storm_SpellScript);
-
-            void RecalculateDamage(SpellEffIndex /*effIndex*/)
-            {
-                int32 dmg = GetHitDamage();
-                float distance = GetHitUnit()->GetExactDist2d(GetCaster());
-                if (distance < 5.0f)
-                    return;
-
-                float distVar = distance >= 20.0f ? 4 : (10.0f/3.0f);
-                SetHitDamage(int32(dmg * distVar / distance));
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_marrowgar_bone_storm_SpellScript::RecalculateDamage, EFFECT_0, SPELL_EFFECT_SCHOOL_DAMAGE);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_marrowgar_bone_storm_SpellScript();
-        }
-};
-
 void AddSC_boss_lord_marrowgar()
 {
-    new boss_lord_marrowgar();
-    new npc_coldflame();
     new npc_bone_spike();
-    new spell_marrowgar_coldflame();
+    new npc_cold_flame();
+    new boss_lord_marrowgar();
+    new spell_lord_marrowgar_bone_storm();
     new spell_marrowgar_bone_spike_graveyard();
-    new spell_marrowgar_bone_storm();
+
+    if (VehicleSeatEntry* vehSeat = const_cast<VehicleSeatEntry*>(sVehicleSeatStore.LookupEntry(6206)))
+        vehSeat->m_flags |= 0x400;
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
old mode 100755
new mode 100644
index 17c326c..ddbd58f
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
@@ -1,173 +1,113 @@
 /*
- * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "ObjectMgr.h"
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
 #include "ScriptMgr.h"
 #include "ScriptedCreature.h"
 #include "SpellScript.h"
 #include "SpellAuraEffects.h"
 #include "icecrown_citadel.h"
 
-enum ScriptTexts
+enum eBrothersYells
 {
-    // Festergut
-    SAY_FESTERGUT_GASEOUS_BLIGHT    = 0,
-    SAY_FESTERGUT_DEATH             = 1,
-
-    // Rotface
-    SAY_ROTFACE_OOZE_FLOOD          = 2,
-    SAY_ROTFACE_DEATH               = 3,
-
-    // Professor Putricide
-    SAY_AGGRO                       = 4,
-    EMOTE_UNSTABLE_EXPERIMENT       = 5,
-    SAY_PHASE_TRANSITION_HEROIC     = 6,
-    SAY_TRANSFORM_1                 = 7,
-    SAY_TRANSFORM_2                 = 8,    // always used for phase2 change, DO NOT GROUP WITH SAY_TRANSFORM_1
-    EMOTE_MALLEABLE_GOO             = 9,
-    EMOTE_CHOKING_GAS_BOMB          = 10,
-    SAY_KILL                        = 11,
-    SAY_BERSERK                     = 12,
-    SAY_DEATH                       = 13,
+    SAY_FESTERGUT_GASEOUS_BLIGHT = -1631080,
+    SAY_FESTERGUT_DEATH          = -1631090,
+
+    SAY_ROTFACE_DEATH            = -1666025
 };
 
-enum Spells
+enum eBrothersSpells
 {
-    // Festergut
-    SPELL_RELEASE_GAS_VISUAL            = 69125,
-    SPELL_GASEOUS_BLIGHT_LARGE          = 69157,
-    SPELL_GASEOUS_BLIGHT_MEDIUM         = 69162,
-    SPELL_GASEOUS_BLIGHT_SMALL          = 69164,
-    SPELL_MALLABLE_GOO_H                = 70852,
-
-    // Rotface
-    SPELL_VILE_GAS_H                    = 69240,
-
-    // Professor Putricide
-    SPELL_SLIME_PUDDLE_TRIGGER          = 70341,
-    SPELL_MALLEABLE_GOO                 = 70852,
-    SPELL_UNSTABLE_EXPERIMENT           = 70351,
-    SPELL_TEAR_GAS                      = 71617,    // phase transition
-    SPELL_CREATE_CONCOCTION             = 71621,
-    SPELL_GUZZLE_POTIONS                = 71893,
-    SPELL_OOZE_TANK_PROTECTION          = 71770,    // protects the tank
-    SPELL_CHOKING_GAS_BOMB              = 71255,
-    SPELL_OOZE_VARIABLE                 = 70352,
-    SPELL_GAS_VARIABLE                  = 70353,
-    SPELL_UNBOUND_PLAGUE                = 70911,
-    SPELL_UNBOUND_PLAGUE_SEARCHER       = 70917,
-    SPELL_PLAGUE_SICKNESS               = 70953,
-    SPELL_UNBOUND_PLAGUE_PROTECTION     = 70955,
-    SPELL_MUTATED_PLAGUE                = 72451,
-
-    // Slime Puddle
-    SPELL_GROW_STACKER                  = 70345,
-    SPELL_SLIME_PUDDLE_AURA             = 70343,
-
-    // Gas Cloud
-    SPELL_GASEOUS_BLOAT_PROC            = 70215,
-    SPELL_GASEOUS_BLOAT                 = 70672,
-    SPELL_GASEOUS_BLOAT_PROTECTION      = 70812,
-
-    // Volatile Ooze
-    SPELL_OOZE_ERUPTION                 = 70492,
-    SPELL_VOLATILE_OOZE_ADHESIVE        = 70447,
-    SPELL_OOZE_ERUPTION_SEARCH_PERIODIC = 70457,
-    SPELL_VOLATILE_OOZE_PROTECTION      = 70530,
-
-    // Choking Gas Bomb
-    SPELL_CHOKING_GAS_BOMB_PERIODIC     = 71259,
-    SPELL_CHOKING_GAS_EXPLOSION_TRIGGER = 71280,
-
-    // Mutated Abomination vehicle
-    SPELL_ABOMINATION_VEHICLE_POWER_DRAIN = 70385,
-    SPELL_MUTATED_TRANSFORMATION          = 70311,
-    SPELL_MUTATED_TRANSFORMATION_DAMAGE   = 70405,
-    SPELL_MUTATED_TRANSFORMATION_NAME     = 72401,
+    SPELL_RELEASE_GAS_VISUAL    = 69125,
+    SPELL_MALLABLE_GOO_H        = 70852,
+
+    SPELL_OOZE_FLOOD_H          = 69783,
+    SPELL_VILE_GAS              = 69240
 };
 
-#define SPELL_GASEOUS_BLOAT_HELPER RAID_MODE<uint32>(70672,72455,72832,72833)
+enum Yells
+{
+    SAY_AGGRO         = -1631104,
+    EMOTE_EXPERIMENT  = -1631105,
+    SAY_AIRLOCK       = -1666027,
+    SAY_PHASE_HC      = -1631106,
+    SAY_TRANSFORM_1   = -1631107,
+    SAY_TRANSFORM_2   = -1631108,
+    SAY_KILL_1        = -1631111,
+    SAY_KILL_2        = -1631112,
+    SAY_BERSERK       = -1631113,
+    SAY_DEATH         = -1631114,
+    EMOTE_GOO         = -1631109,
+    EMOTE_GAS_BOMB    = -1631110
+};
 
-enum Events
+enum Spells
 {
-    // Festergut
-    EVENT_FESTERGUT_DIES        = 1,
-    EVENT_FESTERGUT_GOO         = 2,
-
-    // Rotface
-    EVENT_ROTFACE_DIES          = 3,
-    EVENT_ROTFACE_VILE_GAS      = 4,
-    EVENT_ROTFACE_OOZE_FLOOD    = 5,
-
-    // Professor Putricide
-    EVENT_BERSERK               = 6,    // all phases
-    EVENT_SLIME_PUDDLE          = 7,    // all phases
-    EVENT_UNSTABLE_EXPERIMENT   = 8,    // P1 && P2
-    EVENT_TEAR_GAS              = 9,    // phase transition not heroic
-    EVENT_RESUME_ATTACK         = 10,
-    EVENT_MALLEABLE_GOO         = 11,
-    EVENT_CHOKING_GAS_BOMB      = 12,
-    EVENT_UNBOUND_PLAGUE        = 13,
-    EVENT_MUTATED_PLAGUE        = 14,
-    EVENT_PHASE_TRANSITION      = 15,
+    SPELL_UNSTABLE_EXPERIMENT   = 70351,
+    SPELL_TEAR_GAS              = 71617,
+    SPELL_CREATE_CONCOTION      = 71621,
+    SPELL_GUZZLE_POTIONS        = 71893,
+    SPELL_MALLEABLE_GOO         = 70852,
+    SPELL_MUTATED_PLAGUE        = 72451,
+    SPELL_OOZE_ERUPTION         = 70492,
+    SPELL_VOLATILE_OOZE         = 70447,
+    SPELL_CHOKING_GAS           = 71278,
+    SPELL_SLIME_PUDDLE          = 70341,
+    SPELL_SLIME_PUDDLE_AURA     = 70346,
+    SPELL_CHOKING_GAS_EXPLOSION = 71279,
+    SPELL_CHOKING_GAS_BOMB      = 71273,
+    SPELL_CHOKING_GAS_BOMB_1    = 71275,
+    SPELL_CHOKING_GAS_BOMB_2    = 71276,
+    SPELL_CHOKING_GAS_AURA      = 71259,
+    SPELL_SUMMON_OOZE           = 71413,
+    SPELL_GASEOUS_BLOAT         = 70672,
+    SPELL_MUTATED               = 70405,
+    SPELL_STRENGTH              = 71603,
+    SPELL_PUDDLE_TRIGGER        = 71425,
+    SPELL_HITTIN_PROC           = 71971,
+    SPELL_OOZE_SEARCH_EFFECT    = 70457,
+    SPELL_OOZE_FLOOD            = 69783,
+    SPELL_GAS_FLOOD             = 71379,
+    SPELL_TRANSFORMATION        = 70311,
+    SPELL_TRANSFORMATION_DAMAGE = 70405,
+    SPELL_TRANSFORMATION_NAME   = 72401,
+    SPELL_GASEOUS_PROTECTION    = 70812,
+    SPELL_VOLATILE_PROTECTION   = 70530
 };
 
-enum Phases
+enum ePhases
 {
-    PHASE_NONE          = 0,
     PHASE_FESTERGUT     = 1,
     PHASE_ROTFACE       = 2,
-    PHASE_COMBAT_1      = 4,
-    PHASE_COMBAT_2      = 5,
-    PHASE_COMBAT_3      = 6,
+    PHASE_COMBAT        = 3,
 
-    PHASE_MASK_COMBAT   = (1 << PHASE_COMBAT_1) | (1 << PHASE_COMBAT_2) | (1 << PHASE_COMBAT_3),
-    PHASE_MASK_NOT_SELF = (1 << PHASE_FESTERGUT) | (1 << PHASE_ROTFACE),
+    PHASE_MASK_NOT_SELF = (1 << PHASE_FESTERGUT) | (1 << PHASE_ROTFACE)
 };
 
-enum Points
-{
-    POINT_FESTERGUT = 366260,
-    POINT_ROTFACE   = 366270,
-    POINT_TABLE     = 366780,
-};
-
-static const Position festergutWatchPos = {4324.820f, 3166.03f, 389.3831f, 3.316126f}; //emote 432 (release gas)
-static const Position rotfaceWatchPos   = {4390.371f, 3164.50f, 389.3890f, 5.497787f}; //emote 432 (release ooze)
-static const Position tablePos          = {4356.190f, 3262.90f, 389.4820f, 1.483530f};
-
-static const uint32 oozeFloodSpells[4] = {69782, 69796, 69798, 69801};
-
-#define DATA_EXPERIMENT_STAGE   0
-#define EXPERIMENT_STATE_OOZE   false
-#define EXPERIMENT_STATE_GAS    true
+static const Position festergutWatchPos = {4324.821f, 3166.03f, 389.3831f, 3.316126f};
+static const Position rotfaceWatchPos   = {4390.371f, 3164.50f, 389.3890f, 5.497787f};
+static const Position professorStartPos = {4356.190f, 3262.90f, 389.4820f, 1.483530f};
 
-class StartMovementEvent : public BasicEvent
+const Position SpawnLoc[]=
 {
-    public:
-        StartMovementEvent(Creature& owner) : BasicEvent(), m_owner(owner) { }
-        bool Execute(uint64 /*eventTime*/, uint32 /*diff*/)
-        {
-            m_owner.GetMotionMaster()->MoveChase(m_owner.getVictim());
-            return true;
-        }
-
-    private:
-        Creature& m_owner;
+    {4486.825f, 3211.986f, 404.385f, 0.0f},
+    {4486.825f, 3111.452f, 389.385f, 0.0f},
+    {4486.825f, 3213.452f, 404.385f, 0.0f},
+    {4486.825f, 3213.452f, 389.385f, 0.0f}
 };
 
 class boss_professor_putricide : public CreatureScript
@@ -177,84 +117,78 @@ class boss_professor_putricide : public CreatureScript
 
         struct boss_professor_putricideAI : public BossAI
         {
-            boss_professor_putricideAI(Creature* creature) : BossAI(creature, DATA_PROFESSOR_PUTRICIDE),
-                baseSpeed(creature->GetSpeedRate(MOVE_RUN)), experimentState(EXPERIMENT_STATE_OOZE)
-            {
-                phase = PHASE_NONE;
-            }
-
-            void InitializeAI()
+            boss_professor_putricideAI(Creature* pCreature) : BossAI(pCreature, DATA_PROFESSOR_PUTRICIDE),summons(me)
             {
-                if (!instance || static_cast<InstanceMap*>(me->GetMap())->GetScriptId() != GetScriptId(ICCScriptName))
-                    me->IsAIEnabled = false;
-                else if (!me->isDead())
-                    Reset();
+                pInstance = me->GetInstanceScript();
+                phase = ePhases(0);
+                PhaseSwitch1 = false;
+                PhaseSwitch2 = false;
+                fDie = false; //festergut die
+                rDie = false; // rotface die
             }
 
             void Reset()
             {
-                if (!(events.GetPhaseMask() & PHASE_MASK_NOT_SELF))
-                    instance->SetBossState(DATA_PROFESSOR_PUTRICIDE, NOT_STARTED);
-                instance->SetData(DATA_NAUSEA_ACHIEVEMENT, uint32(true));
+                m_uiPhase = 1;
+                m_uiUnstableExperimentTimer = 35000;
+                m_uiPuddleTimer = 30000;
+                m_uiMalleableTimer = 15000;
+                m_uiPhaseSwitchTimer = 1000;
+                m_uiBerserkTimer = 600000;
+                m_uiBombTimer = 25000;
+                m_uiMutatedPlague = 10000;
 
-                events.Reset();
-                summons.DespawnAll();
-                _SetPhase(PHASE_COMBAT_1);
-                experimentState = EXPERIMENT_STATE_OOZE;
+                experement = 1;
+                phaseswitch = 0;
+                stage = 1;
+
+                fBaseSpeed = me->GetSpeedRate(MOVE_RUN);
                 me->SetReactState(REACT_DEFENSIVE);
                 me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
-                    me->GetMotionMaster()->MovementExpired();
-                if (GameObject* table = ObjectAccessor::GetGameObject(*me, instance->GetData64(DATA_PUTRICIDE_TABLE)))
-                    table->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
+
+                if (pInstance && me->isAlive())
+                    pInstance->SetData(DATA_PROFESSOR_PUTRICIDE_EVENT, NOT_STARTED);
             }
 
-            void EnterCombat(Unit* who)
+            void EnterCombat(Unit* /*who*/)
             {
-                if (events.GetPhaseMask() & PHASE_MASK_NOT_SELF)
+                if(!pInstance)
                     return;
 
-                if (!instance->CheckRequiredBosses(DATA_PROFESSOR_PUTRICIDE, who->ToPlayer()))
-                {
-                    instance->DoCastSpellOnPlayers(LIGHT_S_HAMMER_TELEPORT);
-                    EnterEvadeMode();
-                    return;
-                }
-
-                _SetPhase(PHASE_COMBAT_1);
-                Talk(SAY_AGGRO);
-                DoCast(me, SPELL_OOZE_TANK_PROTECTION, true);
+                pInstance->SetData(DATA_PROFESSOR_PUTRICIDE_EVENT, IN_PROGRESS);
+                SetSonPhase(PHASE_COMBAT);
+                DoScriptText(SAY_AGGRO, me);
                 DoZoneInCombat(me);
-
-                events.Reset();
-                events.ScheduleEvent(EVENT_BERSERK, 600000);
-                events.ScheduleEvent(EVENT_SLIME_PUDDLE, 10000);
-                events.ScheduleEvent(EVENT_UNSTABLE_EXPERIMENT, urand(25000, 30000));
-                if (IsHeroic())
-                    events.ScheduleEvent(EVENT_UNBOUND_PLAGUE, 20000);
-
-                instance->SetBossState(DATA_PROFESSOR_PUTRICIDE, IN_PROGRESS);
-                if (GameObject* table = ObjectAccessor::GetGameObject(*me, instance->GetData64(DATA_PUTRICIDE_TABLE)))
-                    table->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
             }
 
-            void JustReachedHome()
+            void JustDied(Unit* /*pKiller*/)
             {
-                me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                if (events.GetPhaseMask() & PHASE_MASK_COMBAT)
-                    instance->SetBossState(DATA_PROFESSOR_PUTRICIDE, FAIL);
+                DoScriptText(SAY_DEATH, me);
+
+                if (pInstance)
+                    pInstance->SetData(DATA_PROFESSOR_PUTRICIDE_EVENT, DONE);
+
+                summons.DespawnAll();
             }
 
             void KilledUnit(Unit* victim)
             {
                 if (victim->GetTypeId() == TYPEID_PLAYER)
-                    Talk(SAY_KILL);
+                {
+                    switch(rand()%1)
+                    {
+                        case 0: DoScriptText(SAY_KILL_1, me); break;
+                        case 1: DoScriptText(SAY_KILL_2, me); break;
+                    }
+                }
             }
 
-            void JustDied(Unit* /*killer*/)
+            void JustReachedHome()
             {
-                Talk(SAY_DEATH);
-                instance->SetBossState(DATA_PROFESSOR_PUTRICIDE, DONE);
+                if(pInstance)
+                    pInstance->SetData(DATA_PROFESSOR_PUTRICIDE_EVENT, FAIL);
+
+                summons.DespawnAll();
             }
 
             void JustSummoned(Creature* summon)
@@ -262,40 +196,28 @@ class boss_professor_putricide : public CreatureScript
                 summons.Summon(summon);
                 switch (summon->GetEntry())
                 {
-                    case NPC_GROWING_OOZE_PUDDLE:
-                        summon->CastSpell(summon, SPELL_GROW_STACKER, true);
-                        summon->CastSpell(summon, SPELL_SLIME_PUDDLE_AURA, true);
-                        break;
-                    case NPC_GAS_CLOUD:
-                        // no possible aura seen in sniff adding the aurastate
-                        summon->SetFlag(UNIT_FIELD_AURASTATE, 1 << (AURA_STATE_UNKNOWN22-1));
-                        summon->CastSpell(summon, SPELL_GASEOUS_BLOAT_PROC, true);
-                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -SPELL_GASEOUS_BLOAT_PROTECTION))
+                    case CREATURE_GAS_CLOUD:
+                        summon->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+                        summon->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -SPELL_GASEOUS_PROTECTION))
                         {
                             summon->AI()->AttackStart(target);
                             summon->CastCustomSpell(SPELL_GASEOUS_BLOAT, SPELLVALUE_MAX_TARGETS, 1, target, false);
                             summon->ClearUnitState(UNIT_STAT_CASTING);
                             summon->GetMotionMaster()->MoveIdle();
-                            summon->m_Events.AddEvent(new StartMovementEvent(*summon), summon->m_Events.CalculateTime(3500));
                         }
                         return;
-                    case NPC_VOLATILE_OOZE:
-                        // no possible aura seen in sniff adding the aurastate
-                        summon->SetFlag(UNIT_FIELD_AURASTATE, 1 << (AURA_STATE_UNKNOWN19-1));
-                        summon->CastSpell(summon, SPELL_OOZE_ERUPTION_SEARCH_PERIODIC, true);
-                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -SPELL_VOLATILE_OOZE_PROTECTION))
+                    case CREATURE_VOLATILE_OOZE:
+                        summon->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+                        summon->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -SPELL_VOLATILE_PROTECTION))
                         {
                             summon->AI()->AttackStart(target);
-                            summon->CastCustomSpell(SPELL_VOLATILE_OOZE_ADHESIVE, SPELLVALUE_MAX_TARGETS, 1, target, false);
+                            summon->CastCustomSpell(SPELL_VOLATILE_OOZE, SPELLVALUE_MAX_TARGETS, 1, target, false);
                             summon->ClearUnitState(UNIT_STAT_CASTING);
                             summon->GetMotionMaster()->MoveIdle();
-                            summon->m_Events.AddEvent(new StartMovementEvent(*summon), summon->m_Events.CalculateTime(3500));
                         }
                         return;
-                    case NPC_CHOKING_GAS_BOMB:
-                        summon->CastSpell(summon, SPELL_CHOKING_GAS_BOMB_PERIODIC, true);
-                        summon->CastSpell(summon, SPELL_CHOKING_GAS_EXPLOSION_TRIGGER, true);
-                        return;
                     default:
                         break;
                 }
@@ -303,78 +225,10 @@ class boss_professor_putricide : public CreatureScript
                     DoZoneInCombat(summon);
             }
 
-            void DamageTaken(Unit* /*attacker*/, uint32& /*damage*/)
-            {
-                switch (phase)
-                {
-                    case PHASE_COMBAT_1:
-                        if (HealthAbovePct(80))
-                            return;
-                        me->SetReactState(REACT_PASSIVE);
-                        DoAction(ACTION_CHANGE_PHASE);
-                        break;
-                    case PHASE_COMBAT_2:
-                        if (HealthAbovePct(35))
-                            return;
-                        me->SetReactState(REACT_PASSIVE);
-                        DoAction(ACTION_CHANGE_PHASE);
-                        break;
-                    default:
-                        break;
-                }
-            }
-
-            void MovementInform(uint32 type, uint32 id)
+            void SetSonPhase(ePhases newPhase)
             {
-                if (type != POINT_MOTION_TYPE)
-                    return;
-                switch (id)
-                {
-                    case POINT_FESTERGUT:
-                        instance->SetBossState(DATA_FESTERGUT, IN_PROGRESS); // needed here for delayed gate close
-                        me->SetSpeed(MOVE_RUN, baseSpeed, true);
-                        DoAction(ACTION_FESTERGUT_GAS);
-                        if (Creature* festergut = Unit::GetCreature(*me, instance->GetData64(DATA_FESTERGUT)))
-                            festergut->CastSpell(festergut, SPELL_GASEOUS_BLIGHT_LARGE, false, NULL, NULL, festergut->GetGUID());
-                        break;
-                    case POINT_ROTFACE:
-                        instance->SetBossState(DATA_ROTFACE, IN_PROGRESS);   // needed here for delayed gate close
-                        me->SetSpeed(MOVE_RUN, baseSpeed, true);
-                        DoAction(ACTION_ROTFACE_OOZE);
-                        events.ScheduleEvent(EVENT_ROTFACE_OOZE_FLOOD, 25000, 0, PHASE_ROTFACE);
-                        break;
-                    case POINT_TABLE:
-                        // stop attack
-                        me->GetMotionMaster()->MoveIdle();
-                        me->SetSpeed(MOVE_RUN, baseSpeed, true);
-                        if (GameObject* table = ObjectAccessor::GetGameObject(*me, instance->GetData64(DATA_PUTRICIDE_TABLE)))
-                            me->SetFacingToObject(table);
-                        // operating on new phase already
-                        switch (phase)
-                        {
-                            case PHASE_COMBAT_2:
-                            {
-                                SpellEntry const* spell = sSpellStore.LookupEntry(SPELL_CREATE_CONCOCTION);
-                                spell = sSpellMgr->GetSpellForDifficultyFromSpell(spell, me);
-                                DoCast(me, SPELL_CREATE_CONCOCTION);
-                                events.ScheduleEvent(EVENT_PHASE_TRANSITION, GetSpellCastTime(spell)+100);
-                                break;
-                            }
-                            case PHASE_COMBAT_3:
-                            {
-                                SpellEntry const* spell = sSpellStore.LookupEntry(SPELL_GUZZLE_POTIONS);
-                                spell = sSpellMgr->GetSpellForDifficultyFromSpell(spell, me);
-                                DoCast(me, SPELL_GUZZLE_POTIONS);
-                                events.ScheduleEvent(EVENT_PHASE_TRANSITION, GetSpellCastTime(spell)+100);
-                                break;
-                            }
-                            default:
-                                break;
-                        }
-                        break;
-                    default:
-                        break;
-                }
+                phase = newPhase;
+                events.SetPhase(newPhase);
             }
 
             void DoAction(const int32 action)
@@ -382,780 +236,507 @@ class boss_professor_putricide : public CreatureScript
                 switch (action)
                 {
                     case ACTION_FESTERGUT_COMBAT:
-                        _SetPhase(PHASE_FESTERGUT);
-                        me->SetSpeed(MOVE_RUN, baseSpeed*2.0f, true);
-                        me->GetMotionMaster()->MovePoint(POINT_FESTERGUT, festergutWatchPos);
+                        SetSonPhase(PHASE_FESTERGUT);
+                        me->SetSpeed(MOVE_RUN, fBaseSpeed*2.0f, true);
+                        me->GetMotionMaster()->MovePoint(0, festergutWatchPos);
                         me->SetReactState(REACT_PASSIVE);
                         if (IsHeroic())
                         {
-                            DoZoneInCombat(me);
-                            events.ScheduleEvent(EVENT_FESTERGUT_GOO, urand(15000, 20000), 0, PHASE_FESTERGUT);
+                            m_uiMalleableGooTimer = urand(16000, 20000);
                         }
                         break;
-                    case ACTION_FESTERGUT_GAS:
-                        Talk(SAY_FESTERGUT_GASEOUS_BLIGHT);
-                        DoCast(me, SPELL_RELEASE_GAS_VISUAL, true);
-                        break;
-                    case ACTION_FESTERGUT_DEATH:
-                        events.ScheduleEvent(EVENT_FESTERGUT_DIES, 4000, 0, PHASE_FESTERGUT);
-                        break;
                     case ACTION_ROTFACE_COMBAT:
-                    {
-                        _SetPhase(PHASE_ROTFACE);
-                        me->SetSpeed(MOVE_RUN, baseSpeed*2.0f, true);
-                        me->GetMotionMaster()->MovePoint(POINT_ROTFACE, rotfaceWatchPos);
+                        SetSonPhase(PHASE_ROTFACE);
+                        me->SetSpeed(MOVE_RUN, fBaseSpeed*2.0f, true);
+                        me->GetMotionMaster()->MovePoint(0, rotfaceWatchPos);
                         me->SetReactState(REACT_PASSIVE);
-                        oozeFloodStage = 0;
                         if (IsHeroic())
                         {
-                            DoZoneInCombat(me);
-                            events.ScheduleEvent(EVENT_ROTFACE_VILE_GAS, urand(15000, 20000), 0, PHASE_ROTFACE);
+                            m_uiVileGasTimer = urand(16000, 20000);
                         }
-                        // init random sequence of floods
-                        if (Creature* rotface = Unit::GetCreature(*me, instance->GetData64(DATA_ROTFACE)))
+                        break;
+                    case ACTION_FESTERGUT_GAS:
+                        DoScriptText(SAY_FESTERGUT_GASEOUS_BLIGHT, me);
+                        if (Creature* bfestergut = Unit::GetCreature(*me, instance->GetData64(DATA_FESTERGURT)))
                         {
-                            std::list<Creature*> list;
-                            GetCreatureListWithEntryInGrid(list, rotface, NPC_PUDDLE_STALKER, 36.0f);
-                            if (list.size() > 4)
-                            {
-                                list.sort(Trinity::ObjectDistanceOrderPred(rotface));
-                                do
-                                {
-                                    list.pop_back();
-                                } while (list.size() > 4);
-                            }
-
-                            uint8 i = 0;
-                            while (!list.empty())
-                            {
-                                std::list<Creature*>::iterator itr = list.begin();
-                                std::advance(itr, urand(0, list.size()-1));
-                                oozeFloodDummy[i++] = (*itr)->GetGUID();
-                                list.erase(itr);
-                            }
+                            bfestergut->CastSpell(bfestergut, SPELL_RELEASE_GAS_VISUAL, false, NULL, NULL, me->GetGUID());
                         }
                         break;
-                    }
-                    case ACTION_ROTFACE_OOZE:
-                        Talk(SAY_ROTFACE_OOZE_FLOOD);
-                        if (Creature* dummy = Unit::GetCreature(*me, oozeFloodDummy[oozeFloodStage]))
-                            dummy->CastSpell(dummy, oozeFloodSpells[oozeFloodStage], true, NULL, NULL, me->GetGUID()); // cast from self for LoS (with prof's GUID for logs)
-                        if (++oozeFloodStage == 4)
-                            oozeFloodStage = 0;
+                    //case ACTION_ROTFACE_GAS:
+                    case ACTION_FESTERGUT_DEATH:
+                        m_uiSayDieTimer = 4000;
+                        fDie = true;
                         break;
                     case ACTION_ROTFACE_DEATH:
-                        events.ScheduleEvent(EVENT_ROTFACE_DIES, 4500, 0, PHASE_ROTFACE);
+                        m_uiSayDieTimer = 4000;
+                        rDie = true;
                         break;
-                    case ACTION_CHANGE_PHASE:
-                        me->SetSpeed(MOVE_RUN, baseSpeed*2.0f, true);
-                        events.DelayEvents(30000);
-                        me->AttackStop();
-                        if (!IsHeroic())
-                        {
-                            DoCast(me, SPELL_TEAR_GAS);
-                            events.ScheduleEvent(EVENT_TEAR_GAS, 2500);
-                        }
-                        else
+                    default:
+                        break;
+                    }
+                }
+
+            void SpawnAdds()
+            {
+                switch(experement)
+                {
+                case 1:
+                    {
+                        Creature* green_stalker = me->SummonCreature(CREATURE_PUDDLE_STALKER, SpawnLoc[0], TEMPSUMMON_TIMED_DESPAWN, 4000);
+                        if(green_stalker)
                         {
-                            Talk(SAY_PHASE_TRANSITION_HEROIC);
-                            DoCast(me, SPELL_UNSTABLE_EXPERIMENT, true);
-                            DoCast(me, SPELL_UNSTABLE_EXPERIMENT, true);
-                            // cast variables
-                            if (Is25ManRaid())
-                            {
-                                std::list<Unit*> targetList;
-                                {
-                                    const std::list<HostileReference*>& threatlist = me->getThreatManager().getThreatList();
-                                    for (std::list<HostileReference*>::const_iterator itr = threatlist.begin(); itr != threatlist.end(); ++itr)
-                                        if ((*itr)->getTarget()->GetTypeId() == TYPEID_PLAYER)
-                                            targetList.push_back((*itr)->getTarget());
-                                }
-
-                                size_t half = targetList.size()/2;
-                                // half gets ooze variable
-                                while (half < targetList.size())
-                                {
-                                    std::list<Unit*>::iterator itr = targetList.begin();
-                                    advance(itr, urand(0, targetList.size()-1));
-                                    DoCast(*itr, SPELL_OOZE_VARIABLE);
-                                    targetList.erase(itr);
-                                }
-                                // and half gets gas
-                                for (std::list<Unit*>::iterator itr = targetList.begin(); itr != targetList.end(); ++itr)
-                                    DoCast(*itr, SPELL_GAS_VARIABLE);
-                            }
-                            me->GetMotionMaster()->MovePoint(POINT_TABLE, tablePos);
+                            green_stalker->CastSpell(green_stalker, SPELL_OOZE_FLOOD, true);
+                            DoSummon(CREATURE_VOLATILE_OOZE, SpawnLoc[1]);
                         }
-                        switch (phase)
+                    }
+                    break;
+                case 2:
+                    {
+                        Creature* orange_stalker = me->SummonCreature(CREATURE_PUDDLE_STALKER, SpawnLoc[2], TEMPSUMMON_TIMED_DESPAWN, 4000);
+                        if(orange_stalker)
                         {
-                            case PHASE_COMBAT_1:
-                                _SetPhase(PHASE_COMBAT_2);
-                                events.ScheduleEvent(EVENT_MALLEABLE_GOO, urand(21000, 26000));
-                                events.ScheduleEvent(EVENT_CHOKING_GAS_BOMB, urand(35000, 40000));
-                                break;
-                            case PHASE_COMBAT_2:
-                                _SetPhase(PHASE_COMBAT_3);
-                                events.ScheduleEvent(EVENT_MUTATED_PLAGUE, 25000);
-                                events.CancelEvent(EVENT_UNSTABLE_EXPERIMENT);
-                                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_MUTATED_TRANSFORMATION);
-                                instance->DoRemoveAurasDueToSpellOnPlayers(71503);  // SPELL_MUTATED_TRANSFORMATION2
-                                if (GameObject* table = ObjectAccessor::GetGameObject(*me, instance->GetData64(DATA_PUTRICIDE_TABLE)))
-                                    table->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
-                                break;
-                            default:
-                                break;
+                            orange_stalker->CastSpell(orange_stalker, SPELL_GAS_FLOOD, true);
+                            DoSummon(CREATURE_GAS_CLOUD, SpawnLoc[3]);
                         }
-                        break;
-                    default:
-                        break;
+                    }
                 }
             }
 
-            uint32 GetData(uint32 type)
+            void TwoAdds()
             {
-                if (type == DATA_EXPERIMENT_STAGE)
+                Creature* green_stalker = me->SummonCreature(CREATURE_PUDDLE_STALKER, SpawnLoc[0], TEMPSUMMON_TIMED_DESPAWN, 4000);//green
+                if(green_stalker)
                 {
-                    // ALSO MODIFIES!
-                    uint32 ret = uint32(experimentState);
-                    experimentState ^= true;
-                    return ret;
+                    green_stalker->CastSpell(green_stalker, SPELL_OOZE_FLOOD, true);
+                    DoSummon(CREATURE_VOLATILE_OOZE, SpawnLoc[2]);
+                }
+                Creature* orange_stalker = me->SummonCreature(CREATURE_PUDDLE_STALKER, SpawnLoc[1], TEMPSUMMON_TIMED_DESPAWN, 4000);//orange
+                if(orange_stalker)
+                {
+                    orange_stalker->CastSpell(orange_stalker, SPELL_GAS_FLOOD, true);
+                    DoSummon(CREATURE_GAS_CLOUD, SpawnLoc[3]);
                 }
-
-                return 0;
             }
 
-            void UpdateAI(const uint32 diff)
+            void PhaseSwitch()
             {
-                if ((!UpdateVictim() && !(events.GetPhaseMask() & PHASE_MASK_NOT_SELF)) || !CheckInRoom())
-                    return;
-
-                events.Update(diff);
-
-                if (me->HasUnitState(UNIT_STAT_CASTING))
-                    return;
-
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
+                switch(phaseswitch)
                     {
-                        case EVENT_FESTERGUT_DIES:
-                            Talk(SAY_FESTERGUT_DEATH);
-                            EnterEvadeMode();
-                            break;
-                        case EVENT_FESTERGUT_GOO:
-                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true))
-                                DoCast(target, SPELL_MALLABLE_GOO_H, true); // triggered, to skip LoS check
-                            events.ScheduleEvent(EVENT_FESTERGUT_GOO, urand(15000, 20000), 0, PHASE_FESTERGUT);
-                            break;
-                        case EVENT_ROTFACE_DIES:
-                            Talk(SAY_ROTFACE_DEATH);
-                            EnterEvadeMode();
-                            break;
-                        case EVENT_ROTFACE_VILE_GAS:
-                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true))
-                                DoCast(target, SPELL_VILE_GAS_H, true); // triggered, to skip LoS check
-                            events.ScheduleEvent(EVENT_ROTFACE_VILE_GAS, urand(15000, 20000), 0, PHASE_ROTFACE);
-                            break;
-                        case EVENT_ROTFACE_OOZE_FLOOD:
-                            DoAction(ACTION_ROTFACE_OOZE);
-                            events.ScheduleEvent(EVENT_ROTFACE_OOZE_FLOOD, 25000, 0, PHASE_ROTFACE);
-                            break;
-                        case EVENT_BERSERK:
-                            Talk(SAY_BERSERK);
-                            DoCast(me, SPELL_BERSERK2);
-                            break;
-                        case EVENT_SLIME_PUDDLE:
+                    case 0:
+                        if (!IsHeroic())
                         {
-                            std::list<Unit*> targets;
-                            SelectTargetList(targets, 2, SELECT_TARGET_RANDOM, 0.0f, true);
-                            if (!targets.empty())
-                                for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end(); ++itr)
-                                    DoCast(*itr, SPELL_SLIME_PUDDLE_TRIGGER);
-                            events.ScheduleEvent(EVENT_SLIME_PUDDLE, 35000);
-                            break;
-                        }
-                        case EVENT_UNSTABLE_EXPERIMENT:
-                            Talk(EMOTE_UNSTABLE_EXPERIMENT);
-                            DoCast(me, SPELL_UNSTABLE_EXPERIMENT);
-                            events.ScheduleEvent(EVENT_UNSTABLE_EXPERIMENT, urand(35000, 40000));
-                            break;
-                        case EVENT_TEAR_GAS:
-                            me->GetMotionMaster()->MovePoint(POINT_TABLE, tablePos);
-                            break;
-                        case EVENT_RESUME_ATTACK:
-                            me->SetReactState(REACT_DEFENSIVE);
-                            AttackStart(me->getVictim());
-                            // remove Tear Gas
-                            instance->DoRemoveAurasDueToSpellOnPlayers(71615);
-                            instance->DoRemoveAurasDueToSpellOnPlayers(71618);
-                            break;
-                        case EVENT_MALLEABLE_GOO:
-                            if (Is25ManRaid())
-                            {
-                                std::list<Unit*> targets;
-                                SelectTargetList(targets, 2, SELECT_TARGET_RANDOM, -7.0f, true);
-                                if (!targets.empty())
-                                {
-                                    Talk(EMOTE_MALLEABLE_GOO);
-                                    for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end(); ++itr)
-                                        DoCast(*itr, SPELL_MALLEABLE_GOO);
-                                }
-                            }
-                            else
+                            Creature* gas_stalker = me->FindNearestCreature(CREATURE_TEAR_GAS_STALKER, 150.0f, true);
+                            if(gas_stalker)
                             {
-                                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, -7.0f, true))
-                                {
-                                    Talk(EMOTE_MALLEABLE_GOO);
-                                    DoCast(target, SPELL_MALLEABLE_GOO);
-                                }
+                                me->CastSpell(gas_stalker, SPELL_TEAR_GAS, true);
                             }
-                            events.ScheduleEvent(EVENT_MALLEABLE_GOO, urand(25000, 30000));
-                            break;
-                        case EVENT_CHOKING_GAS_BOMB:
-                            Talk(EMOTE_CHOKING_GAS_BOMB);
-                            DoCast(me, SPELL_CHOKING_GAS_BOMB);
-                            events.ScheduleEvent(EVENT_CHOKING_GAS_BOMB, urand(35000, 40000));
-                            break;
-                        case EVENT_UNBOUND_PLAGUE:
-                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true))
-                            {
-                                me->CastCustomSpell(SPELL_UNBOUND_PLAGUE, SPELLVALUE_BASE_POINT0, 775, target);
-                                DoCast(target, SPELL_UNBOUND_PLAGUE_SEARCHER);
-                            }
-                            events.ScheduleEvent(EVENT_UNBOUND_PLAGUE, 90000);
-                            break;
-                        case EVENT_MUTATED_PLAGUE:
-                            DoCastVictim(SPELL_MUTATED_PLAGUE);
-                            events.ScheduleEvent(EVENT_MUTATED_PLAGUE, 10000);
-                            break;
-                        case EVENT_PHASE_TRANSITION:
+                        }
+                        if (IsHeroic())
                         {
-                            switch (phase)
-                            {
-                                case PHASE_COMBAT_2:
-                                    if (Creature* face = me->FindNearestCreature(NPC_TEAR_GAS_TARGET_STALKER, 50.0f))
-                                        me->SetFacingToObject(face);
-                                    me->HandleEmoteCommand(EMOTE_ONESHOT_KNEEL);
-                                    Talk(SAY_TRANSFORM_1);
-                                    events.ScheduleEvent(EVENT_RESUME_ATTACK, 5500, 0, PHASE_COMBAT_2);
-                                    break;
-                                case PHASE_COMBAT_3:
-                                    if (Creature* face = me->FindNearestCreature(NPC_TEAR_GAS_TARGET_STALKER, 50.0f))
-                                        me->SetFacingToObject(face);
-                                    me->HandleEmoteCommand(EMOTE_ONESHOT_KNEEL);
-                                    Talk(SAY_TRANSFORM_2);
-                                    events.ScheduleEvent(EVENT_RESUME_ATTACK, 8500, 0, PHASE_COMBAT_3);
-                                    break;
-                                default:
-                                    break;
-                            }
+                            DoScriptText(SAY_PHASE_HC,me);
+                            TwoAdds();
                         }
-                        default:
-                            break;
+                        ++phaseswitch;
+                        m_uiPhaseSwitchTimer = 4000;
+                        break;
+                    case 1:
+                        me->GetMotionMaster()->MovePoint(0, professorStartPos);
+                        ++phaseswitch;
+                        m_uiPhaseSwitchTimer = 9000;
+                        break;
+                    case 2:
+                        if(m_uiPhase == 1)
+                            DoCast(SPELL_CREATE_CONCOTION);
+                        if(m_uiPhase == 2)
+                            DoCast(SPELL_GUZZLE_POTIONS);
+                        ++phaseswitch;
+                        m_uiPhaseSwitchTimer = 3000;
+                        break;
+                    case 3:
+                        if(m_uiPhase == 1)
+                            m_uiPhase = 2;
+                        if(m_uiPhase == 2)
+                            m_uiPhase = 3;
+                        pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_TEAR_GAS);
+                        ++phaseswitch;
+                        break;
                     }
-                }
-
-                DoMeleeAttackIfReady();
             }
 
-        private:
-            void _SetPhase(Phases newPhase)
+            void UpdateAI(const uint32 uiDiff)
             {
-                phase = newPhase;
-                events.SetPhase(newPhase);
-            }
-
-            uint64 oozeFloodDummy[4];
-            Phases phase;          // external of EventMap because event phase gets reset on evade
-            const float baseSpeed;
-            uint8 oozeFloodStage;
-            bool experimentState;
-        };
-
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new boss_professor_putricideAI(creature);
-        }
-};
-
-class npc_volatile_ooze : public CreatureScript
-{
-    public:
-        npc_volatile_ooze() : CreatureScript("npc_volatile_ooze") { }
-
-        struct npc_volatile_oozeAI : public ScriptedAI
-        {
-            npc_volatile_oozeAI(Creature* creature) : ScriptedAI(creature)
-            {
-                newTargetSelectTimer = 0;
-            }
-
-            void SpellHitTarget(Unit* /*target*/, SpellEntry const* spell)
-            {
-                SpellEntry const* explode = sSpellStore.LookupEntry(SPELL_OOZE_ERUPTION);
-                explode = sSpellMgr->GetSpellForDifficultyFromSpell(explode, me);
-                if (explode->Id == spell->Id)
+                if(phase == PHASE_FESTERGUT)
                 {
-                    newTargetSelectTimer = 5000;
-                    DoStartNoMovement(me);
-                }
-            }
-
-            void UpdateAI(const uint32 diff)
-            {
-                if (!UpdateVictim())
-                    return;
-
-                if (!newTargetSelectTimer)
-                    return;
+                    if (m_uiMalleableGooTimer < uiDiff)
+                    {
+                        if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            DoCast(pTarget, SPELL_MALLABLE_GOO_H);
+                        m_uiMalleableGooTimer = urand(16000, 20000);
+                    } else m_uiMalleableGooTimer -= uiDiff;
 
-                if (newTargetSelectTimer <= diff)
-                {
-                    newTargetSelectTimer = 0;
-                    if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -SPELL_VOLATILE_OOZE_PROTECTION))
+                    if (m_uiSayDieTimer < uiDiff)
                     {
-                        AttackStart(target);
-                        me->CastCustomSpell(SPELL_VOLATILE_OOZE_ADHESIVE, SPELLVALUE_MAX_TARGETS, 1, target, false);
-                    }
-                    else
-                        me->DespawnOrUnsummon();
+                        if(fDie)
+                        {
+                            DoScriptText(SAY_FESTERGUT_DEATH, me);
+                            EnterEvadeMode();
+                            fDie = false;
+                        }
+                        m_uiSayDieTimer = 4000;
+                    } else m_uiSayDieTimer -= uiDiff;
                 }
-                else
-                    newTargetSelectTimer -= diff;
-            }
-
-        private:
-            // no need to use EventMap for just one event
-            uint32 newTargetSelectTimer;
-        };
 
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new npc_volatile_oozeAI(creature);
-        }
-};
-
-class spell_putricide_gaseous_bloat : public SpellScriptLoader
-{
-    public:
-        spell_putricide_gaseous_bloat() : SpellScriptLoader("spell_putricide_gaseous_bloat") { }
-
-        class spell_putricide_gaseous_bloat_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_putricide_gaseous_bloat_SpellScript);
-
-            void ModAuraStack()
-            {
-                if (Aura* aur = GetHitAura())
-                    aur->SetStackAmount(10);
-            }
+                if(phase == PHASE_ROTFACE)
+                {
+                    if (m_uiVileGasTimer < uiDiff)
+                    {
+                        for (uint8 i = 1; i <= 3; i++)
+                        {
+                            if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            {
+                                DoCast(pTarget, SPELL_VILE_GAS);
+                            }
+                        }
+                        m_uiVileGasTimer = urand (16000, 20000);
+                    } else m_uiVileGasTimer -= uiDiff;
 
-            void Register()
-            {
-                AfterHit += SpellHitFn(spell_putricide_gaseous_bloat_SpellScript::ModAuraStack);
-            }
-        };
+                    if (m_uiSayDieTimer < uiDiff)
+                    {
+                        if(rDie)
+                        {
+                            DoScriptText(SAY_ROTFACE_DEATH, me);
+                            EnterEvadeMode();
+                            rDie = false;
+                        }
+                        m_uiSayDieTimer = 4000;
+                    } else m_uiSayDieTimer -= uiDiff;
+                }
 
-        class spell_putricide_gaseous_bloat_AuraScript : public AuraScript
-        {
-            PrepareAuraScript(spell_putricide_gaseous_bloat_AuraScript);
+                if(phase == PHASE_COMBAT)
+                {
+                    if (m_uiBerserkTimer < uiDiff)
+                    {
+                        DoCast(me, SPELL_BERSERK);
+                        DoScriptText(SAY_BERSERK,me);
+                        m_uiBerserkTimer = 600000;
+                    } else m_uiBerserkTimer -= uiDiff;
 
-            void HandleExtraEffect(AuraEffect const* /*aurEff*/)
-            {
-                 GetTarget()->RemoveAuraFromStack(GetSpellProto()->Id, GetCasterGUID());
-            }
+                    if((me->GetHealth()*100) / me->GetMaxHealth() < 81 && PhaseSwitch1 == false)
+                    {
+                        PhaseSwitch();
+                        PhaseSwitch1 = true;
+                    }
 
-            void Register()
-            {
-                OnEffectPeriodic += AuraEffectPeriodicFn(spell_putricide_gaseous_bloat_AuraScript::HandleExtraEffect, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE);
-            }
-        };
+                    if((me->GetHealth()*100) / me->GetMaxHealth() < 36 && PhaseSwitch2 == false)
+                    {
+                        PhaseSwitch();
+                        PhaseSwitch2 = true;
+                    }
 
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_putricide_gaseous_bloat_SpellScript();
-        }
+                    if (m_uiPuddleTimer < uiDiff)
+                    {
+                        for (uint8 i = 1; i <= 2; i++)
+                        {
+                            if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, -8.0f, true))
+                                DoCast(pTarget, SPELL_SLIME_PUDDLE, true);
+                        }
+                        m_uiPuddleTimer = 30000;
+                    } else m_uiPuddleTimer -= uiDiff;
 
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_putricide_gaseous_bloat_AuraScript();
-        }
-};
+                    if (m_uiPhase == 1)
+                    {
+                        if (m_uiUnstableExperimentTimer < uiDiff)
+                        {
+                            SpawnAdds();
+                            DoCast(SPELL_UNSTABLE_EXPERIMENT);
+                            me->MonsterTextEmote(EMOTE_EXPERIMENT, NULL);
+                            m_uiUnstableExperimentTimer = 40000;
+                        } else m_uiUnstableExperimentTimer -= uiDiff;
+                    }
 
-class spell_putricide_expunged_gas : public SpellScriptLoader
-{
-    public:
-        spell_putricide_expunged_gas() : SpellScriptLoader("spell_putricide_expunged_gas") { }
+                    if (m_uiPhase == 2)
+                    {
+                        if (m_uiUnstableExperimentTimer < uiDiff)
+                        {
+                            DoCast(me, SPELL_UNSTABLE_EXPERIMENT);
+                            me->MonsterTextEmote(EMOTE_EXPERIMENT,NULL);
+                            TwoAdds();
+                            m_uiUnstableExperimentTimer = 40000;
+                        } else m_uiUnstableExperimentTimer -= uiDiff;
 
-        class spell_putricide_expunged_gas_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_putricide_expunged_gas_SpellScript);
+                        if (m_uiMalleableTimer < uiDiff)
+                        {
+                            for (uint8 i = 0; i <= RAID_MODE(1,2,1,2); i++)
+                            {
+                                if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, -8.0f, true))
+                                    DoCast(pTarget, SPELL_MALLEABLE_GOO);
+                            }
+                            m_uiMalleableTimer = 16000;
+                        } else m_uiMalleableTimer -= uiDiff;
 
-            void CalcDamage(SpellEffIndex /*effIndex*/)
-            {
-                if (GetCaster()->GetTypeId() != TYPEID_UNIT)
-                    return;
+                        if (m_uiBombTimer < uiDiff)
+                        {
+                            DoCast(SPELL_CHOKING_GAS_BOMB);
+                            DoCast(SPELL_CHOKING_GAS_BOMB_1);
+                            DoCast(SPELL_CHOKING_GAS_BOMB_2);
+                            m_uiBombTimer = 30000;
+                        } else m_uiBombTimer -= uiDiff;
+                    }
+                    if (m_uiPhase == 3)
+                    {
+                        if(!me->HasAura(SPELL_STRENGTH))
+                        {
+                            DoCast(me, SPELL_STRENGTH);
+                        }
 
-                InstanceScript* instance = GetCaster()->GetInstanceScript();
-                if (!instance)
-                    return;
+                        if (m_uiMalleableTimer < uiDiff)
+                        {
+                            for (uint8 i = 0; i <= RAID_MODE(1,2,1,2); i++)
+                            {
+                                if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, -8.0f, true))
+                                    DoCast(pTarget, SPELL_MALLEABLE_GOO);
+                            }
+                            m_uiMalleableTimer = 16000;
+                        } else m_uiMalleableTimer -= uiDiff;
 
-                Creature* professor = Unit::GetCreature(*GetCaster(), instance->GetData64(DATA_PROFESSOR_PUTRICIDE));
-                if (!professor)
-                    return;
+                        if (m_uiBombTimer < uiDiff)
+                        {
+                            DoCast(SPELL_CHOKING_GAS_BOMB);
+                            DoCast(SPELL_CHOKING_GAS_BOMB_1);
+                            DoCast(SPELL_CHOKING_GAS_BOMB_2);
+                            m_uiBombTimer = 30000;
+                        } else m_uiBombTimer -= uiDiff;
 
-                int32 dmg = 0;
-                ScriptedAI* professorAI = CAST_AI(ScriptedAI, professor->AI());
-                if (Aura* gasBloat = GetTargetUnit()->GetAura(professorAI->SPELL_GASEOUS_BLOAT_HELPER))
-                {
-                    uint32 stack = gasBloat->GetStackAmount();
-                    const int32 mod = professorAI->Is25ManRaid() ? 1500 : 1250;
-                    for (uint8 i = 1; i < stack; ++i)
-                        dmg += mod * stack;
+                        if (m_uiMutatedPlague < uiDiff)
+                        {
+                            DoCastVictim(SPELL_MUTATED_PLAGUE);
+                            m_uiMutatedPlague = 10000;
+                        } else m_uiMutatedPlague -= uiDiff;
+                    }
                 }
-                else
-                    GetCaster()->ToCreature()->DespawnOrUnsummon();
 
-                SetHitDamage(dmg);
+                DoMeleeAttackIfReady();
             }
 
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_putricide_expunged_gas_SpellScript::CalcDamage, EFFECT_0, SPELL_EFFECT_SCHOOL_DAMAGE);
-            }
+        private:
+            InstanceScript* pInstance;
+
+            uint32 m_uiPhase;
+            uint32 m_uiUnstableExperimentTimer;
+            uint32 m_uiResetTimer;
+            uint32 m_uiPuddleTimer;
+            uint32 m_uiMalleableTimer;
+            uint32 m_uiPhaseSwitchTimer;
+            uint32 m_uiBerserkTimer;
+            uint32 m_uiBombTimer;
+            uint32 m_uiMutatedPlague;
+            //festergut and rotface
+            uint32 m_uiMalleableGooTimer;
+            uint32 m_uiVileGasTimer;
+            uint32 m_uiSayDieTimer;
+            SummonList summons;
+            uint8 experement;
+            uint8 phaseswitch;
+            uint8 stage;
+
+            bool PhaseSwitch1;
+            bool PhaseSwitch2;
+            bool fDie; //festergut die
+            bool rDie; // rotface die
+
+            float fBaseSpeed;
+
+            ePhases phase;
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new spell_putricide_expunged_gas_SpellScript();
+            return new boss_professor_putricideAI(pCreature);
         }
 };
 
-class spell_putricide_slime_puddle : public SpellScriptLoader
+class npc_volatile_ooze : public CreatureScript
 {
     public:
-        spell_putricide_slime_puddle() : SpellScriptLoader("spell_putricide_slime_puddle") { }
+        npc_volatile_ooze() : CreatureScript("npc_volatile_ooze") { }
 
-        class spell_putricide_slime_puddle_AuraScript : public AuraScript
+        struct npc_volatile_oozeAI : public ScriptedAI
         {
-            PrepareAuraScript(spell_putricide_slime_puddle_AuraScript);
-
-            void HandleTriggerSpell(AuraEffect const* aurEff)
+            npc_volatile_oozeAI(Creature* pCreature) : ScriptedAI(pCreature)
             {
-                PreventDefaultAction();
-                if (Unit* caster = GetCaster())
-                {
-                    int32 radiusMod = 4;
-                    if (Aura* size = caster->GetAura(70347))
-                        radiusMod += size->GetStackAmount();
-
-                    uint32 triggerSpellId = GetSpellProto()->EffectTriggerSpell[aurEff->GetEffIndex()];
-                    caster->CastCustomSpell(triggerSpellId, SPELLVALUE_RADIUS_MOD, radiusMod*100, caster, true);
-                }
+                pInstance = pCreature->GetInstanceScript();
             }
 
-            void Register()
-            {
-                OnEffectPeriodic += AuraEffectPeriodicFn(spell_putricide_slime_puddle_AuraScript::HandleTriggerSpell, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
-            }
-        };
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_putricide_slime_puddle_AuraScript();
-        }
-};
-
-class spell_putricide_unstable_experiment : public SpellScriptLoader
-{
-    public:
-        spell_putricide_unstable_experiment() : SpellScriptLoader("spell_putricide_unstable_experiment") { }
-
-        class spell_putricide_unstable_experiment_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_putricide_unstable_experiment_SpellScript);
-
-            void HandleScript(SpellEffIndex effIndex)
+            void Reset()
             {
-                PreventHitDefaultEffect(effIndex);
-                if (GetCaster()->GetTypeId() != TYPEID_UNIT)
-                    return;
+                me->SetSpeed(MOVE_RUN, 0.5);
+                me->SetSpeed(MOVE_WALK, 0.5);
 
-                uint32 stage = GetCaster()->ToCreature()->AI()->GetData(DATA_EXPERIMENT_STAGE);
-                Creature* target = NULL;
-                std::list<Creature*> creList;
-                GetCreatureListWithEntryInGrid(creList, GetCaster(), NPC_ABOMINATION_WING_MAD_SCIENTIST_STALKER, 100.0f);
-                // 2 of them are spawned at green place - weird trick blizz
-                for (std::list<Creature*>::iterator itr = creList.begin(); itr != creList.end(); ++itr)
-                {
-                    target = *itr;
-                    std::list<Creature*> tmp;
-                    GetCreatureListWithEntryInGrid(tmp, target, NPC_ABOMINATION_WING_MAD_SCIENTIST_STALKER, 1.0f);
-                    if ((!stage && tmp.size() > 1) || (stage && tmp.size() == 1))
-                        break;
-                }
-
-                GetCaster()->CastSpell(target, uint32(GetSpellInfo()->EffectBasePoints[stage]+1), true, NULL, NULL, GetCaster()->GetGUID());
-            }
+                m_uiSearchTargetTimer = 1000;
+                target = false;
 
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_putricide_unstable_experiment_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+                me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
             }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_putricide_unstable_experiment_SpellScript();
-        }
-};
-
-class spell_putricide_ooze_summon : public SpellScriptLoader
-{
-    public:
-        spell_putricide_ooze_summon() : SpellScriptLoader("spell_putricide_ooze_summon") { }
-
-        class spell_putricide_ooze_summon_AuraScript : public AuraScript
-        {
-            PrepareAuraScript(spell_putricide_ooze_summon_AuraScript);
 
-            void HandleTriggerSpell(AuraEffect const* aurEff)
+            void SpellHitTarget(Unit* /*pTarget*/, const SpellEntry* spell)
             {
-                PreventDefaultAction();
-                if (Unit* caster = GetCaster())
+                SpellEntry const* explode = sSpellStore.LookupEntry(SPELL_OOZE_ERUPTION);
+                explode = sSpellMgr->GetSpellForDifficultyFromSpell(explode, me);
+                if (explode->Id == spell->Id)
                 {
-                    uint32 triggerSpellId = GetSpellProto()->EffectTriggerSpell[aurEff->GetEffIndex()];
-                    float x, y, z;
-                    GetTarget()->GetPosition(x, y, z);
-                    z = GetTarget()->GetMap()->GetHeight(x, y, z, true, 25.0f);
-                    x += 10.0f * cosf(caster->GetOrientation());
-                    y += 10.0f * sinf(caster->GetOrientation());
-                    caster->CastSpell(x, y, z, triggerSpellId, true, NULL, NULL, GetCasterGUID(), caster);
+                    m_uiSearchTargetTimer = 5000;
+                    DoStartNoMovement(me);
                 }
             }
 
-            void Register()
+            void UpdateAI(const uint32 uiDiff)
             {
-                OnEffectPeriodic += AuraEffectPeriodicFn(spell_putricide_ooze_summon_AuraScript::HandleTriggerSpell, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
-            }
-        };
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_putricide_ooze_summon_AuraScript();
-        }
-};
-
-class spell_putricide_ooze_eruption_searcher : public SpellScriptLoader
-{
-    public:
-        spell_putricide_ooze_eruption_searcher() : SpellScriptLoader("spell_putricide_ooze_eruption_searcher") { }
+                if (!UpdateVictim())
+                    return;
 
-        class spell_putricide_ooze_eruption_searcher_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_putricide_ooze_eruption_searcher_SpellScript);
+                if (!target && m_uiSearchTargetTimer < uiDiff)
+                {
+                    me->CastCustomSpell(SPELL_VOLATILE_OOZE, SPELLVALUE_MAX_TARGETS, 1, me->getVictim(), false);
+                    me->CastCustomSpell(SPELL_OOZE_SEARCH_EFFECT, SPELLVALUE_MAX_TARGETS, 1, me->getVictim(), false);
+                    target = true;
+                    m_uiSearchTargetTimer = 1000;
+                } else m_uiSearchTargetTimer -= uiDiff;
 
-            void HandleDummy(SpellEffIndex /*effIndex*/)
-            {
-                SpellEntry const* adhesive = sSpellStore.LookupEntry(SPELL_VOLATILE_OOZE_ADHESIVE);
-                adhesive = sSpellMgr->GetSpellForDifficultyFromSpell(adhesive, GetCaster());
-                if (GetHitUnit()->HasAura(adhesive->Id))
+                if (me->getVictim() && me->getVictim()->IsWithinDistInMap(me, 1))
                 {
-                    GetCaster()->CastSpell(GetHitUnit(), SPELL_OOZE_ERUPTION, true);
-                    GetHitUnit()->RemoveAurasDueToSpell(adhesive->Id, GetCaster()->GetGUID());
+                    DoCast(me, SPELL_OOZE_ERUPTION);
+                    me->getVictim()->RemoveAurasDueToSpell(SPELL_VOLATILE_OOZE);
+                    me->getVictim()->RemoveAurasDueToSpell(SPELL_OOZE_SEARCH_EFFECT);
+                    target = false;
                 }
-            }
 
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_putricide_ooze_eruption_searcher_SpellScript::HandleDummy, EFFECT_0, SPELL_EFFECT_DUMMY);
+                DoMeleeAttackIfReady();
             }
+        private:
+             InstanceScript* pInstance;
+
+             uint32 m_uiSearchTargetTimer;
+             bool target;
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new spell_putricide_ooze_eruption_searcher_SpellScript();
+            return new npc_volatile_oozeAI(pCreature);
         }
 };
 
-class spell_putricide_choking_gas_bomb : public SpellScriptLoader
+class npc_gas_cloud_icc : public CreatureScript
 {
     public:
-        spell_putricide_choking_gas_bomb() : SpellScriptLoader("spell_putricide_choking_gas_bomb") { }
+        npc_gas_cloud_icc() : CreatureScript("npc_gas_cloud_icc") { }
 
-        class spell_putricide_choking_gas_bomb_SpellScript : public SpellScript
+        struct npc_gas_cloud_iccAI : public ScriptedAI
         {
-            PrepareSpellScript(spell_putricide_choking_gas_bomb_SpellScript);
-
-            void HandleScript(SpellEffIndex /*effIndex*/)
+            npc_gas_cloud_iccAI(Creature* pCreature) : ScriptedAI(pCreature)
             {
-                uint32 skipIndex = urand(0, 2);
-                for (uint32 i = 0; i < 3; ++i)
-                {
-                    if (i == skipIndex)
-                        continue;
-
-                    uint32 spellId = uint32(SpellMgr::CalculateSpellEffectAmount(GetSpellInfo(), uint8(i)));
-                    GetCaster()->CastSpell(GetCaster(), spellId, true, NULL, NULL, GetCaster()->GetGUID());
-                }
+                pInstance = pCreature->GetInstanceScript();
             }
 
-            void Register()
+            void Reset()
             {
-                OnEffect += SpellEffectFn(spell_putricide_choking_gas_bomb_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
+                me->SetSpeed(MOVE_RUN, 0.5);
+                me->SetSpeed(MOVE_WALK, 0.5);
+                me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
 
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_putricide_choking_gas_bomb_SpellScript();
-        }
-};
+                m_uiBloatTimer = 6000;
+                m_uiSearchTargetTimer = 1000;
 
-class spell_putricide_unbound_plague : public SpellScriptLoader
-{
-    public:
-        spell_putricide_unbound_plague() : SpellScriptLoader("spell_putricide_unbound_plague") { }
+                target = false;
+            }
 
-        class spell_putricide_unbound_plague_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_putricide_unbound_plague_SpellScript);
+            void EnterCombat(Unit* /*who*/) { }
 
-            void HandleScript(SpellEffIndex /*effIndex*/)
+            void UpdateAI(const uint32 diff)
             {
-                if (!GetHitUnit())
-                    return;
+                if (m_uiBloatTimer < diff)
+                {
+                    DoCast(me->getVictim(), SPELL_GASEOUS_BLOAT);
+                    m_uiBloatTimer = 5000;
+                } else m_uiBloatTimer -= diff;
 
-                SpellEntry const* plague = sSpellStore.LookupEntry(SPELL_UNBOUND_PLAGUE);
-                SpellEntry const* searcher = sSpellStore.LookupEntry(SPELL_UNBOUND_PLAGUE_SEARCHER);
-                Creature* professor = NULL;
-                if (InstanceScript* instance = GetCaster()->GetInstanceScript())
+                if (!target && m_uiSearchTargetTimer < diff)
                 {
-                    professor = Unit::GetCreature(*GetCaster(), instance->GetData64(DATA_PROFESSOR_PUTRICIDE));
-                    if (professor)
+                    if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,1))
                     {
-                        plague = sSpellMgr->GetSpellForDifficultyFromSpell(plague, professor);
-                        searcher = sSpellMgr->GetSpellForDifficultyFromSpell(searcher, professor);
+                        DoCast(pTarget, SPELL_GASEOUS_BLOAT);
+                        me->AddThreat(pTarget, 10000000.0f);
+                        me->GetMotionMaster()->MoveChase(pTarget);
+                        target = true;
                     }
-                }
+                    m_uiSearchTargetTimer = 1000;
+                } else m_uiSearchTargetTimer -= diff;
 
-                if (!GetHitUnit()->HasAura(plague->Id))
-                {
-                    if (professor)
-                        if (Aura* oldPlague = GetCaster()->GetAura(plague->Id, professor->GetGUID()))
-                            if (Aura* newPlague = professor->AddAura(plague->Id, GetHitUnit()))
-                            {
-                                newPlague->SetMaxDuration(oldPlague->GetDuration());
-                                newPlague->SetDuration(oldPlague->GetDuration());
-                                oldPlague->Remove();
-                                GetCaster()->RemoveAurasDueToSpell(searcher->Id);
-                                GetCaster()->CastSpell(GetCaster(), SPELL_PLAGUE_SICKNESS, true);
-                                GetCaster()->CastSpell(GetCaster(), SPELL_UNBOUND_PLAGUE_PROTECTION, true);
-                                professor->CastSpell(GetHitUnit(), SPELL_UNBOUND_PLAGUE_SEARCHER, true);
-                            }
-                }
+                DoMeleeAttackIfReady();
             }
 
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_putricide_unbound_plague_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
+        private:
+            InstanceScript* pInstance;
+
+            uint32 m_uiBloatTimer;
+            uint32 m_uiSearchTargetTimer;
+            bool target;
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new spell_putricide_unbound_plague_SpellScript();
+            return new npc_gas_cloud_iccAI(pCreature);
         }
 };
 
-class spell_putricide_eat_ooze : public SpellScriptLoader
+class npc_bomb_icc : public CreatureScript
 {
     public:
-        spell_putricide_eat_ooze() : SpellScriptLoader("spell_putricide_eat_ooze") { }
+        npc_bomb_icc() : CreatureScript("npc_bomb_icc") { }
 
-        class spell_putricide_eat_ooze_SpellScript : public SpellScript
+        struct npc_bomb_iccAI : public ScriptedAI
         {
-            PrepareSpellScript(spell_putricide_eat_ooze_SpellScript);
-
-            void HandleScript(SpellEffIndex /*effIndex*/)
+            npc_bomb_iccAI(Creature* pCreature) : ScriptedAI(pCreature)
             {
-                if (Creature* target = GetCaster()->FindNearestCreature(NPC_GROWING_OOZE_PUDDLE, 15.0f))
-                {
-                    if (Aura* grow = target->GetAura(uint32(GetEffectValue())))
-                    {
-                        if (grow->GetStackAmount() < 4)
-                        {
-                            target->RemoveAurasDueToSpell(SPELL_GROW_STACKER);
-                            target->RemoveAura(grow);
-                            target->DespawnOrUnsummon();
-                        }
-                        else
-                            grow->ModStackAmount(-4);
-                    }
-                }
+                pInstance = pCreature->GetInstanceScript();
             }
 
-            void Register()
+            void Reset()
             {
-                OnEffect += SpellEffectFn(spell_putricide_eat_ooze_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
+                m_uiBoomTimer = 20000;
 
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_putricide_eat_ooze_SpellScript();
-        }
-};
-
-class spell_putricide_mutated_plague : public SpellScriptLoader
-{
-    public:
-        spell_putricide_mutated_plague() : SpellScriptLoader("spell_putricide_mutated_plague") { }
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetInCombatWithZone();
+                DoStartNoMovement(me->getVictim());
+            }
 
-        class spell_putricide_mutated_plague_AuraScript : public AuraScript
-        {
-            PrepareAuraScript(spell_putricide_mutated_plague_AuraScript);
+            void EnterCombat(Unit* /*who*/) { }
 
-            void HandleTriggerSpell(AuraEffect const* aurEff)
+            void UpdateAI(const uint32 diff)
             {
-                PreventDefaultAction();
-                Unit* caster = GetCaster();
-                if (!caster)
-                    return;
-
-                uint32 triggerSpell = GetSpellProto()->EffectTriggerSpell[aurEff->GetEffIndex()];
-                SpellEntry const* spell = sSpellStore.LookupEntry(triggerSpell);
-                spell = sSpellMgr->GetSpellForDifficultyFromSpell(spell, caster);
-
-                int32 damage = SpellMgr::CalculateSpellEffectAmount(spell, 0, caster);
-                float multiplier = 2.0f;
-                if (GetTarget()->GetMap()->GetSpawnMode() & 1)
-                    multiplier = 3.0f;
-
-                damage *= int32(pow(multiplier, GetStackAmount()));
-                damage = int32(damage * 1.5f);
+                if (m_uiBombTimer < diff)
+                {
+                    DoCast(SPELL_CHOKING_GAS_AURA);
+                    m_uiBombTimer = 1500;
+                } else m_uiBombTimer -= diff;
 
-                GetTarget()->CastCustomSpell(triggerSpell, SPELLVALUE_BASE_POINT0, damage, GetTarget(), true, NULL, aurEff, GetCasterGUID());
+                if (m_uiBoomTimer < diff)
+                {
+                    DoCast(SPELL_CHOKING_GAS_EXPLOSION);
+                    me->ForcedDespawn();
+                    m_uiBoomTimer = 20000;
+                } else m_uiBoomTimer -= diff;
             }
 
-            void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
-            {
-                if (GetTargetApplication()->GetRemoveMode() == AURA_REMOVE_BY_STACK)
-                    return;
-                uint32 healSpell = uint32(SpellMgr::CalculateSpellEffectAmount(GetSpellProto(), 0));
-                GetTarget()->CastSpell(GetTarget(), healSpell, true, NULL, NULL, GetCasterGUID());
-            }
+        private:
+            InstanceScript* pInstance;
 
-            void Register()
-            {
-                OnEffectPeriodic += AuraEffectPeriodicFn(spell_putricide_mutated_plague_AuraScript::HandleTriggerSpell, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
-                OnEffectRemove += AuraEffectRemoveFn(spell_putricide_mutated_plague_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
-            }
+            uint32 m_uiBombTimer;
+            uint32 m_uiBoomTimer;
         };
 
-        AuraScript* GetAuraScript() const
+        CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new spell_putricide_mutated_plague_AuraScript();
+            return new npc_bomb_iccAI(pCreature);
         }
 };
 
@@ -1164,6 +745,7 @@ class spell_putricide_mutation_init : public SpellScriptLoader
     public:
         spell_putricide_mutation_init() : SpellScriptLoader("spell_putricide_mutation_init") { }
 
+
         class spell_putricide_mutation_init_AuraScript : public AuraScript
         {
             PrepareAuraScript(spell_putricide_mutation_init_AuraScript);
@@ -1183,6 +765,7 @@ class spell_putricide_mutation_init : public SpellScriptLoader
             }
         };
 
+
         AuraScript* GetAuraScript() const
         {
             return new spell_putricide_mutation_init_AuraScript();
@@ -1194,22 +777,26 @@ class spell_putricide_mutated_transformation_dismiss : public SpellScriptLoader
     public:
         spell_putricide_mutated_transformation_dismiss() : SpellScriptLoader("spell_putricide_mutated_transformation_dismiss") { }
 
+
         class spell_putricide_mutated_transformation_dismiss_AuraScript : public AuraScript
         {
             PrepareAuraScript(spell_putricide_mutated_transformation_dismiss_AuraScript);
 
+
             void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
             {
                 if (Vehicle* veh = GetTarget()->GetVehicleKit())
                     veh->RemoveAllPassengers();
             }
 
+
             void Register()
             {
                 OnEffectRemove += AuraEffectRemoveFn(spell_putricide_mutated_transformation_dismiss_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
             }
         };
 
+
         AuraScript* GetAuraScript() const
         {
             return new spell_putricide_mutated_transformation_dismiss_AuraScript();
@@ -1221,20 +808,24 @@ class spell_putricide_mutated_transformation : public SpellScriptLoader
     public:
         spell_putricide_mutated_transformation() : SpellScriptLoader("spell_putricide_mutated_transformation") { }
 
+
         class spell_putricide_mutated_transformation_SpellScript : public SpellScript
         {
             PrepareSpellScript(spell_putricide_mutated_transformation_SpellScript);
 
+
             void HandleSummon(SpellEffIndex effIndex)
             {
                 PreventHitDefaultEffect(effIndex);
-                uint32 entry = uint32(GetSpellInfo()->EffectMiscValue[effIndex]);
-                SummonPropertiesEntry const* properties = sSummonPropertiesStore.LookupEntry(uint32(GetSpellInfo()->EffectMiscValueB[effIndex]));
+                uint32 entry = GetSpellInfo()->EffectMiscValue[effIndex];
+                SummonPropertiesEntry const* properties = sSummonPropertiesStore.LookupEntry(GetSpellInfo()->EffectMiscValueB[effIndex]);
                 Unit* caster = GetOriginalCaster();
                 if (!caster)
                     return;
 
-                uint32 duration = uint32(GetSpellDuration(GetSpellInfo()));
+
+                int32 duration = GetSpellDuration(GetSpellInfo());
+
 
                 Position pos;
                 caster->GetPosition(&pos);
@@ -1242,84 +833,65 @@ class spell_putricide_mutated_transformation : public SpellScriptLoader
                 if (!summon || !summon->IsVehicle())
                     return;
 
-                caster->CastSpell(summon, SPELL_MUTATED_TRANSFORMATION_NAME, true);
-                summon->CastSpell(summon, SPELL_ABOMINATION_VEHICLE_POWER_DRAIN, true);
-                summon->CastSpell(summon, SPELL_MUTATED_TRANSFORMATION_DAMAGE, true);
+
+                caster->CastSpell(summon, SPELL_TRANSFORMATION_NAME, true);
+                summon->CastSpell(summon, SPELL_TRANSFORMATION_DAMAGE, true);
                 caster->EnterVehicle(summon->GetVehicleKit(), 0);
 
+
                 summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, GetSpellInfo()->Id);
                 summon->SetCreatorGUID(caster->GetGUID());
             }
 
+
             void Register()
             {
                 OnEffect += SpellEffectFn(spell_putricide_mutated_transformation_SpellScript::HandleSummon, EFFECT_0, SPELL_EFFECT_SUMMON);
             }
         };
 
+
         SpellScript* GetSpellScript() const
         {
             return new spell_putricide_mutated_transformation_SpellScript();
         }
 };
 
-class spell_putricide_regurgitated_ooze : public SpellScriptLoader
+class spell_putricide_ooze_summon : public SpellScriptLoader
 {
     public:
-        spell_putricide_regurgitated_ooze() : SpellScriptLoader("spell_putricide_regurgitated_ooze") { }
-
-        class spell_putricide_regurgitated_ooze_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_putricide_regurgitated_ooze_SpellScript);
-
-            // the only purpose of this hook is to fail the achievement
-            void ExtraEffect(SpellEffIndex /*effIndex*/)
-            {
-                if (InstanceScript* instance = GetCaster()->GetInstanceScript())
-                    instance->SetData(DATA_NAUSEA_ACHIEVEMENT, uint32(false));
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_putricide_regurgitated_ooze_SpellScript::ExtraEffect, EFFECT_0, SPELL_EFFECT_APPLY_AURA);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_putricide_regurgitated_ooze_SpellScript();
-        }
-};
+        spell_putricide_ooze_summon() : SpellScriptLoader("spell_putricide_ooze_summon") { }
 
-// Stinky and Precious spell, it's here because its used for both (Festergut and Rotface "pets")
-class spell_stinky_precious_decimate : public SpellScriptLoader
-{
-    public:
-        spell_stinky_precious_decimate() : SpellScriptLoader("spell_stinky_precious_decimate") { }
 
-        class spell_stinky_precious_decimate_SpellScript : public SpellScript
+        class spell_putricide_ooze_summon_AuraScript : public AuraScript
         {
-            PrepareSpellScript(spell_stinky_precious_decimate_SpellScript);
+            PrepareAuraScript(spell_putricide_ooze_summon_AuraScript);
 
-            void HandleScript(SpellEffIndex /*effIndex*/)
+            void HandleTriggerSpell(AuraEffect const* aurEff)
             {
-                if (GetHitUnit()->GetHealthPct() > float(GetEffectValue()))
+                PreventDefaultAction();
+                if (Unit* caster = GetCaster())
                 {
-                    uint32 newHealth = GetHitUnit()->GetMaxHealth() * uint32(GetEffectValue()) / 100;
-                    if (GetHitUnit()->GetMaxHealth() >= newHealth)
-                        GetHitUnit()->SetHealth(newHealth);
+                    uint32 triggerSpellId = GetSpellProto()->EffectTriggerSpell[aurEff->GetEffIndex()];
+                    float x, y, z;
+                   GetTarget()->GetPosition(x, y, z);
+                    z = GetTarget()->GetMap()->GetHeight(x, y, z, true, 25.0f);
+                    x += 10.0f * cosf(caster->GetOrientation());
+                    y += 10.0f * sinf(caster->GetOrientation());
+                    caster->CastSpell(x, y, z, triggerSpellId, true, NULL, NULL, GetCasterGUID(), caster);
                 }
             }
 
             void Register()
             {
-                OnEffect += SpellEffectFn(spell_stinky_precious_decimate_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+                OnEffectPeriodic += AuraEffectPeriodicFn(spell_putricide_ooze_summon_AuraScript::HandleTriggerSpell, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
             }
         };
 
-        SpellScript* GetSpellScript() const
+
+        AuraScript* GetAuraScript() const
         {
-            return new spell_stinky_precious_decimate_SpellScript();
+            return new spell_putricide_ooze_summon_AuraScript();
         }
 };
 
@@ -1327,19 +899,10 @@ void AddSC_boss_professor_putricide()
 {
     new boss_professor_putricide();
     new npc_volatile_ooze();
-    new spell_putricide_gaseous_bloat();
-    new spell_putricide_expunged_gas();
-    new spell_putricide_slime_puddle();
-    new spell_putricide_unstable_experiment();
-    new spell_putricide_ooze_summon();
-    new spell_putricide_ooze_eruption_searcher();
-    new spell_putricide_choking_gas_bomb();
-    new spell_putricide_unbound_plague();
-    new spell_putricide_eat_ooze();
-    new spell_putricide_mutated_plague();
+    new npc_gas_cloud_icc();
+    new npc_bomb_icc();
     new spell_putricide_mutation_init();
     new spell_putricide_mutated_transformation_dismiss();
     new spell_putricide_mutated_transformation();
-    new spell_putricide_regurgitated_ooze();
-    new spell_stinky_precious_decimate();
+    new spell_putricide_ooze_summon();
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_rat_des_blutes.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_rat_des_blutes.cpp
new file mode 100644
index 0000000..30f0db2
--- /dev/null
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_rat_des_blutes.cpp
@@ -0,0 +1,1470 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ScriptMgr.h"
+#include "ScriptedCreature.h"
+#include "SpellScript.h"
+#include "SpellAuraEffects.h"
+#include "icecrown_citadel.h"
+
+enum eTexts
+{
+    // Blood Queen Lana'Thel
+    SAY_INTRO_1                 = -1631115,
+    SAY_INTRO_2                 = -1631116,
+
+    // Prince Keleseth
+    SAY_KELESETH_INVOCATION     = -1631117,
+    EMOTE_KELESETH_INVOCATION   = -1631118,
+    SAY_KELESETH_SPECIAL        = -1631119,
+    SAY_KELESETH_KILL_1         = -1631120,
+    SAY_KELESETH_KILL_2         = -1631121,
+    EMOTE_KELESETH_BERSERK      = -1631122,
+    SAY_KELESETH_DEATH          = -1631123,
+
+    // Prince Taldaram
+    SAY_TALDARAM_INVOCATION     = -1631124,
+    EMOTE_TALDARAM_INVOCATION   = -1631125,
+    SAY_TALDARAM_SPECIAL        = -1631126,
+    EMOTE_TALDARAM_FLAME        = -1631127,
+    SAY_TALDARAM_KILL_1         = -1631128,
+    SAY_TALDARAM_KILL_2         = -1631129,
+    EMOTE_TALDARAM_BERSERK      = -1631130,
+    EMOTE_TALDARAM_DEATH        = -1631131,
+
+    // Prince Valanar
+    SAY_VALANAR_INVOCATION      = -1631132,
+    EMOTE_VALANAR_INVOCATION    = -1631133,
+    SAY_VALANAR_SPECIAL         = -1631134,
+    EMOTE_VALANAR_SHOCK_VORTEX  = -1631135,
+    SAY_VALANAR_KILL_1          = -1631136,
+    SAY_VALANAR_KILL_2          = -1631137,
+    SAY_VALANAR_BERSERK         = -1631138,
+    SAY_VALANAR_DEATH           = -1631139
+};
+
+enum Spells
+{
+    SPELL_FEIGN_DEATH                   = 71598,
+    SPELL_OOC_INVOCATION_VISUAL         = 70934,
+    SPELL_INVOCATION_VISUAL_ACTIVE      = 71596,
+
+    // Heroic mode
+    SPELL_SHADOW_PRISON                 = 72998,
+    SPELL_SHADOW_PRISON_DAMAGE          = 72999,
+    SPELL_SHADOW_PRISON_DUMMY           = 73001,
+
+    // Prince Keleseth
+    SPELL_INVOCATION_OF_BLOOD_KELESETH  = 70981,
+    SPELL_SHADOW_RESONANCE              = 71943,
+    SPELL_SHADOW_LANCE                  = 71405,
+    SPELL_EMPOWERED_SHADOW_LANCE        = 71815,
+
+    // Dark Nucleus
+    SPELL_SHADOW_RESONANCE_AURA         = 72980,
+    SPELL_SHADOW_RESONANCE_RESIST       = 71822,
+
+    // Prince Taldaram
+    SPELL_INVOCATION_OF_BLOOD_TALDARAM  = 70982,
+    SPELL_GLITTERING_SPARKS             = 71806,
+    SPELL_CONJURE_FLAME                 = 71718,
+    SPELL_CONJURE_EMPOWERED_FLAME       = 72040,
+
+    // Ball of Flame
+    SPELL_FLAME_SPHERE_SPAWN_EFFECT     = 55891, // cast from creature_template_addon (needed cast before entering world)
+    SPELL_BALL_OF_FLAMES_VISUAL         = 71706,
+    SPELL_BALL_OF_FLAMES                = 71714,
+    SPELL_FLAMES                        = 71393,
+    SPELL_FLAME_SPHERE_DEATH_EFFECT     = 55947,
+
+    // Ball of Inferno Flame
+    SPELL_BALL_OF_FLAMES_PROC           = 71756,
+    SPELL_BALL_OF_FLAMES_PERIODIC       = 71709,
+
+    // Prince Valanar
+    SPELL_INVOCATION_OF_BLOOD_VALANAR   = 70952,
+    SPELL_KINETIC_BOMB_TARGET           = 72053,
+    SPELL_KINETIC_BOMB                  = 72080,
+    SPELL_SHOCK_VORTEX                  = 72037,
+    SPELL_EMPOWERED_SHOCK_VORTEX        = 72039,
+
+    // Kinetic Bomb
+    SPELL_UNSTABLE                      = 72059,
+    SPELL_KINETIC_BOMB_VISUAL           = 72054,
+    SPELL_KINETIC_BOMB_EXPLOSION        = 72052,
+
+    // Shock Vortex
+    SPELL_SHOCK_VORTEX_PERIODIC         = 71945,
+    SPELL_SHOCK_VORTEX_DUMMY            = 72633,
+};
+
+enum eEvents
+{
+    EVENT_INTRO_1               = 1,
+    EVENT_INTRO_2               = 2,
+
+    EVENT_INVOCATION_OF_BLOOD   = 3,
+    EVENT_BERSERK               = 4,
+
+    // Keleseth
+    EVENT_SHADOW_RESONANCE      = 5,
+    EVENT_SHADOW_LANCE          = 6,
+
+    // Taldaram
+    EVENT_GLITTERING_SPARKS     = 7,
+    EVENT_CONJURE_FLAME         = 8,
+
+    // Valanar
+    EVENT_KINETIC_BOMB          = 9,
+    EVENT_SHOCK_VORTEX          = 10,
+    EVENT_BOMB_DESPAWN          = 11,
+    EVENT_CONTINUE_FALLING      = 12,
+};
+
+enum eActions
+{
+    ACTION_STAND_UP             = 1,
+    ACTION_CAST_INVOCATION      = 2,
+    ACTION_REMOVE_INVOCATION    = 3,
+    ACTION_KINETIC_BOMB_JUMP    = 4,
+    ACTION_FLAME_BALL_CHASE     = 5,
+};
+
+enum ePoints
+{
+    POINT_INTRO_DESPAWN         = 380040,
+    POINT_KINETIC_BOMB_IMPACT   = 384540,
+};
+
+enum eDisplays
+{
+    DISPLAY_KINETIC_BOMB        = 31095,
+};
+
+class StandUpEvent : public BasicEvent
+{
+    public:
+        StandUpEvent(Creature& owner) : BasicEvent(), m_owner(owner) { }
+        bool Execute(uint64 /*eventTime*/, uint32 /*diff*/)
+        {
+            m_owner.HandleEmoteCommand(EMOTE_ONESHOT_ROAR);
+            return true;
+        }
+
+    private:
+        Creature& m_owner;
+};
+
+static const Position introFinalPos = {4660.490f, 2769.200f, 430.0000f, 0.000000f};
+static const Position triggerPos    = {4680.231f, 2769.134f, 379.9256f, 3.121708f};
+static const Position triggerEndPos = {4680.180f, 2769.150f, 365.5000f, 3.121708f};
+
+class boss_blood_council_controller : public CreatureScript
+{
+    public:
+        boss_blood_council_controller() : CreatureScript("boss_blood_council_controller") { }
+
+        struct boss_blood_council_controllerAI : public BossAI
+        {
+            boss_blood_council_controllerAI(Creature* creature) : BossAI(creature, DATA_BLOOD_PRINCES_CONTROL)
+            {
+                instance = creature->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                me->SetReactState(REACT_PASSIVE);
+                invocationStage = 0;
+
+                if(instance)
+                    instance->SetData(DATA_BLOOD_PRINCE_COUNCIL_EVENT, NOT_STARTED);
+            }
+
+            void EnterCombat(Unit* who)
+            {
+                if(!instance)
+                    return;
+
+                instance->SetData(DATA_BLOOD_PRINCE_COUNCIL_EVENT, IN_PROGRESS);
+
+                DoCast(me, SPELL_INVOCATION_OF_BLOOD_VALANAR);
+
+                if (Creature* keleseth = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_PRINCE_KELESETH_ICC)))
+                    if (!keleseth->isInCombat())
+                        DoZoneInCombat(keleseth);
+
+                if (Creature* taldaram = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_PRINCE_TALDARAM_ICC)))
+                    if (!taldaram->isInCombat())
+                        DoZoneInCombat(taldaram);
+
+                if (Creature* valanar = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_PRINCE_VALANAR_ICC)))
+                    if (!valanar->isInCombat())
+                        DoZoneInCombat(valanar);
+
+                events.ScheduleEvent(EVENT_INVOCATION_OF_BLOOD, 30000);
+
+                invocationOrder[0] = InvocationData(instance->GetData(DATA_PRINCE_VALANAR_ICC), SPELL_INVOCATION_OF_BLOOD_VALANAR, EMOTE_VALANAR_INVOCATION, 71070);
+                if (urand(0, 1))
+                {
+                    invocationOrder[1] = InvocationData(instance->GetData64(DATA_PRINCE_TALDARAM_ICC), SPELL_INVOCATION_OF_BLOOD_TALDARAM, EMOTE_TALDARAM_INVOCATION, 71081);
+                    invocationOrder[2] = InvocationData(instance->GetData64(DATA_PRINCE_KELESETH_ICC), SPELL_INVOCATION_OF_BLOOD_KELESETH, EMOTE_KELESETH_INVOCATION, 71080);
+                }
+                else
+                {
+                    invocationOrder[1] = InvocationData(instance->GetData64(DATA_PRINCE_KELESETH_ICC), SPELL_INVOCATION_OF_BLOOD_KELESETH, EMOTE_KELESETH_INVOCATION, 71080);
+                    invocationOrder[2] = InvocationData(instance->GetData64(DATA_PRINCE_TALDARAM_ICC), SPELL_INVOCATION_OF_BLOOD_TALDARAM, EMOTE_TALDARAM_INVOCATION, 71081);
+                }
+
+                if (IsHeroic())
+                {
+                    Map::PlayerList const &PlList = me->GetMap()->GetPlayers();
+                    if (PlList.isEmpty())
+                        return;
+
+                    for (Map::PlayerList::const_iterator i = PlList.begin(); i != PlList.end(); ++i)
+                    {
+                        if (Player* player = i->getSource())
+                        {
+                            if (player->isGameMaster())
+                                continue;
+
+                            if (player->isAlive())
+                                player->AddAura(SPELL_SHADOW_PRISON_DUMMY, player);
+                        }
+                    }
+                }
+            }
+
+            void JustReachedHome()
+            {
+                if(instance)
+                    instance->SetBossState(DATA_BLOOD_PRINCE_COUNCIL_EVENT, FAIL);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                _JustDied();
+                // kill the other 2 princes too
+                for (uint8 i = 0; i < 2; ++i)
+                {
+                    if (++invocationStage == 3)
+                        invocationStage = 0;
+
+                    if (Creature* prince = ObjectAccessor::GetCreature(*me, invocationOrder[invocationStage].guid))
+                        prince->Kill(prince);
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_INVOCATION_OF_BLOOD:
+                        {
+                            Creature* oldPrince = ObjectAccessor::GetCreature(*me, invocationOrder[invocationStage].guid);
+                            if (++invocationStage == 3)
+                                invocationStage = 0;
+
+                            Creature* newPrince = ObjectAccessor::GetCreature(*me, invocationOrder[invocationStage].guid);
+                            if (oldPrince)
+                            {
+                                oldPrince->AI()->DoAction(ACTION_REMOVE_INVOCATION);
+                                if (newPrince)
+                                    oldPrince->CastSpell(newPrince, invocationOrder[invocationStage].visualSpell, true);
+                            }
+
+                            if (newPrince)
+                                newPrince->SetHealth(me->GetHealth());
+
+                            DoCast(me, invocationOrder[invocationStage].spellId);
+                            DoScriptText(invocationOrder[invocationStage].textId, me);
+                            events.ScheduleEvent(EVENT_INVOCATION_OF_BLOOD, 30000);
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+            }
+
+        private:
+            struct InvocationData
+            {
+                uint64 guid;
+                uint32 spellId;
+                int32  textId;
+                uint32 visualSpell;
+
+                InvocationData(uint64 _guid, uint32 _spellId, int32 _textId, uint32 _visualSpell)
+                {
+                    guid = _guid;
+                    spellId = _spellId;
+                    textId = _textId;
+                    visualSpell = _visualSpell;
+                }
+
+                InvocationData() : guid(0), spellId(0), textId(0), visualSpell(0) { }
+            } invocationOrder[3];
+            uint8 invocationStage;
+            InstanceScript* instance;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new boss_blood_council_controllerAI(creature);
+        }
+};
+
+class boss_prince_keleseth_icc : public CreatureScript
+{
+    public:
+        boss_prince_keleseth_icc() : CreatureScript("boss_blood_elf_keleset_icc") { }
+
+        struct boss_prince_kelesethAI : public BossAI
+        {
+            boss_prince_kelesethAI(Creature* creature) : BossAI(creature, DATA_PRINCE_KELESETH_ICC)
+            {
+                bIsEmpowered = false;
+                spawnHealth = creature->GetMaxHealth();
+                instance = creature->GetInstanceScript();
+            }
+
+            void InitializeAI()
+            {
+                if (CreatureData const* data = sObjectMgr->GetCreatureData(me->GetDBTableGUIDLow()))
+                    if (data->curhealth)
+                        spawnHealth = data->curhealth;
+
+                me->SetReactState(REACT_DEFENSIVE);
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                summons.DespawnAll();
+
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                bIsEmpowered = false;
+                me->SetHealth(spawnHealth);
+                me->SetReactState(REACT_DEFENSIVE);
+                if (IsHeroic())
+                    DoCast(me, SPELL_SHADOW_PRISON);
+            }
+
+            void MoveInLineOfSight(Unit* /*who*/)
+            {
+            }
+
+            void EnterCombat(Unit* /*who*/)
+            {
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_BLOOD_PRINCES_CONTROL)))
+                    if (!controller->isInCombat())
+                        DoZoneInCombat(controller);
+
+                events.ScheduleEvent(EVENT_BERSERK, 600000);
+                events.ScheduleEvent(EVENT_SHADOW_RESONANCE, urand(10000, 15000));
+                events.ScheduleEvent(EVENT_SHADOW_LANCE, 2000);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                DoScriptText(SAY_KELESETH_DEATH, me);
+            }
+
+            void JustRespawned()
+            {
+                DoCast(me, SPELL_FEIGN_DEATH);
+                me->SetHealth(spawnHealth);
+            }
+
+            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
+            {
+                if (spell->Id == SPELL_INVOCATION_OF_BLOOD_KELESETH)
+                    DoAction(ACTION_CAST_INVOCATION);
+            }
+
+            void JustSummoned(Creature* summon)
+            {
+                summons.Summon(summon);
+            }
+
+            void DamageTaken(Unit* /*attacker*/, uint32& damage)
+            {
+                if (!bIsEmpowered)
+                    damage = 0;
+            }
+
+            void KilledUnit(Unit *victim)
+            {
+                if (victim->GetTypeId() == TYPEID_PLAYER)
+                    DoScriptText(RAND(SAY_KELESETH_KILL_1, SAY_KELESETH_KILL_2), me);
+            }
+
+            void DoAction(const int32 action)
+            {
+                switch (action)
+                {
+                    case ACTION_STAND_UP:
+                        me->RemoveAurasDueToSpell(SPELL_FEIGN_DEATH);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        me->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH);
+                        me->ForceValuesUpdateAtIndex(UNIT_NPC_FLAGS);   // was in sniff. don't ask why
+                        me->m_Events.AddEvent(new StandUpEvent(*me), me->m_Events.CalculateTime(1000));
+                        break;
+                    case ACTION_CAST_INVOCATION:
+                        DoScriptText(SAY_KELESETH_INVOCATION, me);
+                        DoCast(me, SPELL_INVOCATION_VISUAL_ACTIVE, true);
+                        bIsEmpowered = true;
+                        break;
+                    case ACTION_REMOVE_INVOCATION:
+                        me->SetHealth(spawnHealth);
+                        me->RemoveAurasDueToSpell(SPELL_INVOCATION_VISUAL_ACTIVE);
+                        me->RemoveAurasDueToSpell(SPELL_INVOCATION_OF_BLOOD_KELESETH);
+                        bIsEmpowered = false;
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom() || me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_BERSERK:
+                            DoCast(me, SPELL_BERSERK);
+                            DoScriptText(EMOTE_KELESETH_BERSERK, me);
+                            break;
+                        case EVENT_SHADOW_RESONANCE:
+                            DoScriptText(SAY_KELESETH_SPECIAL, me);
+                            DoCast(me, SPELL_SHADOW_RESONANCE);
+                            events.ScheduleEvent(EVENT_SHADOW_RESONANCE, urand(10000, 15000));
+                            break;
+                        case EVENT_SHADOW_LANCE:
+                            if (bIsEmpowered)
+                                DoCastVictim(SPELL_EMPOWERED_SHADOW_LANCE);
+                            else
+                                DoCastVictim(SPELL_SHADOW_LANCE);
+                            events.ScheduleEvent(EVENT_SHADOW_LANCE, 2000);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+
+                // does not melee
+            }
+
+        private:
+            bool bIsEmpowered;  // bool check faster than map lookup
+            uint32 spawnHealth;
+            InstanceScript* instance;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new boss_prince_kelesethAI(creature);
+        }
+};
+
+class boss_prince_taldaram_icc : public CreatureScript
+{
+    public:
+        boss_prince_taldaram_icc() : CreatureScript("boss_blood_elf_taldaram_icc") { }
+
+        struct boss_prince_taldaramAI : public BossAI
+        {
+            boss_prince_taldaramAI(Creature* creature) : BossAI(creature, DATA_PRINCE_TALDARAM_ICC)
+            {
+                bIsEmpowered = false;
+                spawnHealth = creature->GetMaxHealth();
+                instance = creature->GetInstanceScript();
+            }
+
+            void InitializeAI()
+            {
+                if (CreatureData const* data = sObjectMgr->GetCreatureData(me->GetDBTableGUIDLow()))
+                    if (data->curhealth)
+                        spawnHealth = data->curhealth;
+
+                me->SetReactState(REACT_DEFENSIVE);
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                summons.DespawnAll();
+
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                bIsEmpowered = false;
+                me->SetHealth(spawnHealth);
+                me->SetReactState(REACT_DEFENSIVE);
+                if (IsHeroic())
+                    DoCast(me, SPELL_SHADOW_PRISON);
+            }
+
+            void EnterCombat(Unit* /*who*/)
+            {
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_BLOOD_PRINCES_CONTROL)))
+                    if (!controller->isInCombat())
+                        DoZoneInCombat(controller);
+
+                events.ScheduleEvent(EVENT_BERSERK, 600000);
+                events.ScheduleEvent(EVENT_GLITTERING_SPARKS, urand(12000,15000));
+                events.ScheduleEvent(EVENT_CONJURE_FLAME, 20000);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                DoScriptText(EMOTE_TALDARAM_DEATH, me);
+            }
+
+            void JustRespawned()
+            {
+                DoCast(me, SPELL_FEIGN_DEATH);
+                me->SetHealth(spawnHealth);
+            }
+
+            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
+            {
+                if (spell->Id == SPELL_INVOCATION_OF_BLOOD_TALDARAM)
+                    DoAction(ACTION_CAST_INVOCATION);
+            }
+
+            void JustSummoned(Creature* summon)
+            {
+                summons.Summon(summon);
+                Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, -10.0f, true); // first try at distance
+                if (!target)
+                    target = SelectTarget(SELECT_TARGET_RANDOM, 0/*1*/, 0.0f, true);     // too bad for you raiders, its going to boom
+
+                if (summon->GetEntry() == CREATURE_BALL_OF_INFERNO_FLAME)
+                    DoScriptText(EMOTE_TALDARAM_FLAME, summon, target);             // safe, has NULL checks
+
+                if (target)
+                    summon->AI()->SetGUID(target->GetGUID());
+            }
+
+            void DamageTaken(Unit* /*attacker*/, uint32& damage)
+            {
+                if (!bIsEmpowered)
+                    damage = 0;
+            }
+
+            void KilledUnit(Unit *victim)
+            {
+                if (victim->GetTypeId() == TYPEID_PLAYER)
+                    DoScriptText(RAND(SAY_TALDARAM_KILL_1, SAY_TALDARAM_KILL_2), me);
+            }
+
+            void DoAction(const int32 action)
+            {
+                switch (action)
+                {
+                    case ACTION_STAND_UP:
+                        me->RemoveAurasDueToSpell(SPELL_FEIGN_DEATH);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        me->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH);
+                        me->ForceValuesUpdateAtIndex(UNIT_NPC_FLAGS);   // was in sniff. don't ask why
+                        me->m_Events.AddEvent(new StandUpEvent(*me), me->m_Events.CalculateTime(1000));
+                        break;
+                    case ACTION_CAST_INVOCATION:
+                        DoScriptText(SAY_TALDARAM_INVOCATION, me);
+                        DoCast(me, SPELL_INVOCATION_VISUAL_ACTIVE, true);
+                        bIsEmpowered = true;
+                        break;
+                    case ACTION_REMOVE_INVOCATION:
+                        me->SetHealth(spawnHealth);
+                        me->RemoveAurasDueToSpell(SPELL_INVOCATION_VISUAL_ACTIVE);
+                        me->RemoveAurasDueToSpell(SPELL_INVOCATION_OF_BLOOD_TALDARAM);
+                        bIsEmpowered = false;
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom() || me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_BERSERK:
+                            DoCast(me, SPELL_BERSERK);
+                            DoScriptText(EMOTE_TALDARAM_BERSERK, me);
+                            break;
+                        case EVENT_GLITTERING_SPARKS:
+                            DoCastVictim(SPELL_GLITTERING_SPARKS);
+                            events.ScheduleEvent(EVENT_GLITTERING_SPARKS, urand(15000, 50000));
+                            break;
+                        case EVENT_CONJURE_FLAME:
+                            if (bIsEmpowered)
+                            {
+                                DoCast(me, SPELL_CONJURE_EMPOWERED_FLAME);
+                                events.ScheduleEvent(EVENT_CONJURE_FLAME, urand(15000, 25000));
+                            }
+                            else
+                            {
+                                DoCast(me, SPELL_CONJURE_FLAME);
+                                events.ScheduleEvent(EVENT_CONJURE_FLAME, urand(20000, 30000));
+                            }
+                            DoScriptText(SAY_TALDARAM_SPECIAL, me);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            bool bIsEmpowered;  // bool check faster than map lookup
+            uint32 spawnHealth;
+            InstanceScript* instance;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new boss_prince_taldaramAI(creature);
+        }
+};
+
+class boss_prince_valanar_icc : public CreatureScript
+{
+    public:
+        boss_prince_valanar_icc() : CreatureScript("boss_blood_elf_valanar_icc") { }
+
+        struct boss_prince_valanarAI : public BossAI
+        {
+            boss_prince_valanarAI(Creature* creature) : BossAI(creature, DATA_PRINCE_VALANAR_ICC)
+            {
+                bIsEmpowered = false;
+                spawnHealth = creature->GetMaxHealth();
+                instance = creature->GetInstanceScript();
+            }
+
+            void InitializeAI()
+            {
+                if (CreatureData const* data = sObjectMgr->GetCreatureData(me->GetDBTableGUIDLow()))
+                    if (data->curhealth)
+                        spawnHealth = data->curhealth;
+
+                me->SetReactState(REACT_DEFENSIVE);
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                summons.DespawnAll();
+
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                bIsEmpowered = false;
+                me->SetHealth(me->GetMaxHealth());
+                me->SetReactState(REACT_DEFENSIVE);
+                if (IsHeroic())
+                    DoCast(me, SPELL_SHADOW_PRISON);
+            }
+
+            void EnterCombat(Unit* /*who*/)
+            {
+                if (Creature* controller = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_BLOOD_PRINCES_CONTROL)))
+                    if (!controller->isInCombat())
+                        DoZoneInCombat(controller);
+
+                events.ScheduleEvent(EVENT_BERSERK, 600000);
+                events.ScheduleEvent(EVENT_KINETIC_BOMB, urand(18000, 24000));
+                events.ScheduleEvent(EVENT_SHOCK_VORTEX, urand(15000, 20000));
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                DoScriptText(SAY_VALANAR_DEATH, me);
+            }
+
+            void JustRespawned()
+            {
+                DoCast(me, SPELL_FEIGN_DEATH);
+                me->SetHealth(spawnHealth);
+            }
+
+            void JustSummoned(Creature* summon)
+            {
+                switch (summon->GetEntry())
+                {
+                    case CREATURE_KINETIC_BOMB_TARGET:
+                        summon->SetReactState(REACT_PASSIVE);
+                        summon->CastSpell(summon, SPELL_KINETIC_BOMB, true, NULL, NULL, me->GetGUID());
+                        break;
+                    case CREATURE_KINETIC_BOMB:
+                    {
+                        float x, y, z;
+                        summon->GetPosition(x, y, z);
+                        float ground_Z = summon->GetMap()->GetHeight(x, y, z, true, 500.0f);
+                        summon->GetMotionMaster()->MovePoint(POINT_KINETIC_BOMB_IMPACT, x, y, ground_Z);
+                        break;
+                    }
+                    case CREATURE_SHOCK_VORTEX:
+                        summon->CastSpell(summon, SPELL_SHOCK_VORTEX_DUMMY, true);
+                        summon->CastSpell(summon, SPELL_SHOCK_VORTEX_PERIODIC, true);
+                        break;
+                }
+                summons.Summon(summon);
+                if (me->isInCombat())
+                    DoZoneInCombat(summon);
+            }
+
+            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
+            {
+                if (spell->Id == SPELL_INVOCATION_OF_BLOOD_VALANAR)
+                    DoAction(ACTION_CAST_INVOCATION);
+            }
+
+            void DamageTaken(Unit* /*attacker*/, uint32& damage)
+            {
+                if (!bIsEmpowered)
+                    damage = 0;
+            }
+
+            void KilledUnit(Unit *victim)
+            {
+                if (victim->GetTypeId() == TYPEID_PLAYER)
+                    DoScriptText(RAND(SAY_VALANAR_KILL_1, SAY_VALANAR_KILL_2), me);
+            }
+
+            void DoAction(const int32 action)
+            {
+                switch (action)
+                {
+                    case ACTION_STAND_UP:
+                        me->RemoveAurasDueToSpell(SPELL_FEIGN_DEATH);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        me->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH);
+                        me->ForceValuesUpdateAtIndex(UNIT_NPC_FLAGS);   // was in sniff. don't ask why
+                        me->m_Events.AddEvent(new StandUpEvent(*me), me->m_Events.CalculateTime(1000));
+                        break;
+                    case ACTION_CAST_INVOCATION:
+                        DoScriptText(SAY_VALANAR_INVOCATION, me);
+                        DoCast(me, SPELL_INVOCATION_VISUAL_ACTIVE, true);
+                        bIsEmpowered = true;
+                        break;
+                    case ACTION_REMOVE_INVOCATION:
+                        me->SetHealth(spawnHealth);
+                        me->RemoveAurasDueToSpell(SPELL_INVOCATION_VISUAL_ACTIVE);
+                        me->RemoveAurasDueToSpell(SPELL_INVOCATION_OF_BLOOD_VALANAR);
+                        bIsEmpowered = false;
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom() || me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_BERSERK:
+                            DoCast(me, SPELL_BERSERK);
+                            DoScriptText(SAY_VALANAR_BERSERK, me);
+                            break;
+                        case EVENT_KINETIC_BOMB:
+                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true))
+                            {
+                                DoCast(target, SPELL_KINETIC_BOMB_TARGET);
+                                DoScriptText(SAY_VALANAR_SPECIAL, me);
+                            }
+                            events.ScheduleEvent(EVENT_KINETIC_BOMB, urand(18000, 24000));
+                            break;
+                        case EVENT_SHOCK_VORTEX:
+                            if (bIsEmpowered)
+                            {
+                                DoCast(me, SPELL_EMPOWERED_SHOCK_VORTEX);
+                                DoScriptText(EMOTE_VALANAR_SHOCK_VORTEX, me);
+                                events.ScheduleEvent(EVENT_SHOCK_VORTEX, 30000);
+                            }
+                            else
+                            {
+                                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true))
+                                    DoCast(target, SPELL_SHOCK_VORTEX);
+                                events.ScheduleEvent(EVENT_SHOCK_VORTEX, urand(18000, 23000));
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            bool bIsEmpowered;  // bool check faster than map lookup
+            uint32 spawnHealth;
+            InstanceScript* instance;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new boss_prince_valanarAI(creature);
+        }
+};
+
+class npc_blood_queen_lana_thel : public CreatureScript
+{
+    public:
+        npc_blood_queen_lana_thel() : CreatureScript("npc_blood_queen_lana_thel") { }
+
+        struct npc_blood_queen_lana_thelAI : public ScriptedAI
+        {
+            npc_blood_queen_lana_thelAI(Creature* creature) : ScriptedAI(creature)
+            {
+                bIntroDone = false;
+                instance = creature->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                me->SetVisible(true);
+                me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
+            }
+
+            void MoveInLineOfSight(Unit* who)
+            {
+                if (bIntroDone)
+                    return;
+
+                if (!me->IsWithinDistInMap(who, 35.0f))
+                    return;
+
+                bIntroDone = true;
+                DoScriptText(SAY_INTRO_1, me);
+                events.SetPhase(1);
+                events.ScheduleEvent(EVENT_INTRO_1, 14000);
+                // summon a visual trigger
+                if (Creature* summon = DoSummon(CREATURE_FLOATING_TRIGGER, triggerPos, 15000, TEMPSUMMON_TIMED_DESPAWN))
+                {
+                    summon->CastSpell(summon, SPELL_OOC_INVOCATION_VISUAL, true);
+                    summon->SetSpeed(MOVE_FLIGHT, 0.15f, true);
+                    summon->GetMotionMaster()->MovePoint(0, triggerEndPos);
+                }
+            }
+
+            void MovementInform(uint32 type, uint32 id)
+            {
+                if (type == POINT_MOTION_TYPE && id == POINT_INTRO_DESPAWN)
+                    me->SetVisible(false);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!events.GetPhaseMask() || !instance)
+                    return;
+
+                events.Update(diff);
+
+                if (events.ExecuteEvent() == EVENT_INTRO_1)
+                {
+                    DoScriptText(SAY_INTRO_2, me);
+                    me->GetMotionMaster()->MovePoint(POINT_INTRO_DESPAWN, introFinalPos);
+                    events.Reset();
+
+                    // remove Feign Death from princes
+                    if (Creature* keleseth = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_PRINCE_KELESETH_ICC)))
+                        keleseth->AI()->DoAction(ACTION_STAND_UP);
+
+                    if (Creature* taldaram = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_PRINCE_TALDARAM_ICC)))
+                        taldaram->AI()->DoAction(ACTION_STAND_UP);
+
+                    if (Creature* valanar = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_PRINCE_VALANAR_ICC)))
+                    {
+                        valanar->AI()->DoAction(ACTION_STAND_UP);
+                        valanar->SetHealth(valanar->GetMaxHealth());
+                    }
+                }
+            }
+
+        private:
+            bool bIntroDone;
+            EventMap events;
+            InstanceScript* instance;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_blood_queen_lana_thelAI(creature);
+        }
+};
+
+class npc_ball_of_flame : public CreatureScript
+{
+    public:
+        npc_ball_of_flame() : CreatureScript("npc_ball_of_flame") { }
+
+        struct npc_ball_of_flameAI : public ScriptedAI
+        {
+            npc_ball_of_flameAI(Creature* creature) : ScriptedAI(creature)
+            {
+                despawnTimer = 0;
+            }
+
+            void Reset()
+            {
+                me->CastSpell(me, SPELL_BALL_OF_FLAMES_VISUAL, true);
+                if (me->GetEntry() == CREATURE_BALL_OF_INFERNO_FLAME)
+                {
+                    me->CastSpell(me, SPELL_BALL_OF_FLAMES_PROC, true);
+                    me->CastSpell(me, SPELL_BALL_OF_FLAMES_PERIODIC, true);
+                }
+            }
+
+            void MovementInform(uint32 type, uint32 id)
+            {
+                if (type == TARGETED_MOTION_TYPE && id == GUID_LOPART(chaseGUID) && chaseGUID)
+                {
+                    me->RemoveAurasDueToSpell(SPELL_BALL_OF_FLAMES_PERIODIC);
+                    DoCastAOE(SPELL_FLAMES);
+                    despawnTimer = 1000;
+                    chaseGUID = 0;
+                }
+            }
+
+            void SetGUID(const uint64& guid, int32 /*type*/)
+            {
+                chaseGUID = guid;
+            }
+
+            void DoAction(const int32 action)
+            {
+                if (action == ACTION_FLAME_BALL_CHASE)
+                    if (Player* target = ObjectAccessor::GetPlayer(*me, chaseGUID))
+                    {
+                        // need to clear states now because this call is before AuraEffect is fully removed
+                        me->ClearUnitState(UNIT_STAT_CASTING | UNIT_STAT_STUNNED);
+                        if (target && me->Attack(target, true))
+                            me->GetMotionMaster()->MoveChase(target, 1.0f);
+                    }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!despawnTimer)
+                    return;
+
+                if (despawnTimer <= diff)
+                {
+                    despawnTimer = 0;
+                    DoCast(me, SPELL_FLAME_SPHERE_DEATH_EFFECT);
+                }
+                else
+                    despawnTimer -= diff;
+            }
+
+        private:
+            uint32 despawnTimer;
+            uint64 chaseGUID;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_ball_of_flameAI(creature);
+        }
+};
+
+class npc_kinetic_bomb : public CreatureScript
+{
+    public:
+        npc_kinetic_bomb() : CreatureScript("npc_kinetic_bomb") { }
+
+        struct npc_kinetic_bombAI : public ScriptedAI
+        {
+            npc_kinetic_bombAI(Creature* creature) : ScriptedAI(creature) { }
+
+            void Reset()
+            {
+                events.Reset();
+                me->SetDisplayId(DISPLAY_KINETIC_BOMB);
+                me->CastSpell(me, SPELL_UNSTABLE, true);
+                me->CastCustomSpell(SPELL_KINETIC_BOMB_VISUAL, SPELLVALUE_BASE_POINT0, 0x7FFFFFFF, me, true);
+                me->SetReactState(REACT_PASSIVE);
+                me->SetSpeed(MOVE_FLIGHT, IsHeroic() ? 0.3f : 0.15f, true);
+                me->GetPosition(x, y, groundZ);
+                groundZ = me->GetMap()->GetHeight(x, y, groundZ, true, 500.0f);
+            }
+
+            void DoAction(const int32 action)
+            {
+                if (action == SPELL_KINETIC_BOMB_EXPLOSION)
+                    events.ScheduleEvent(EVENT_BOMB_DESPAWN, 1000);
+                else if (action == ACTION_KINETIC_BOMB_JUMP)
+                {
+                    me->GetMotionMaster()->Clear();
+                    me->GetMotionMaster()->MoveJump(x, y, me->GetPositionZ()+7.0f, 1.0f, 7.0f);
+                    events.ScheduleEvent(EVENT_CONTINUE_FALLING, 700);
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_BOMB_DESPAWN:
+                            me->SetVisible(false);
+                            break;
+                        case EVENT_CONTINUE_FALLING:
+                            me->GetMotionMaster()->Clear();
+                            me->GetMotionMaster()->MovePoint(POINT_KINETIC_BOMB_IMPACT, x, y, groundZ);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+
+        private:
+            EventMap events;
+            float x, y, groundZ;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_kinetic_bombAI(creature);
+        }
+};
+
+class npc_dark_nucleus : public CreatureScript
+{
+    public:
+        npc_dark_nucleus() : CreatureScript("npc_dark_nucleus") { }
+
+        struct npc_dark_nucleusAI : public ScriptedAI
+        {
+            npc_dark_nucleusAI(Creature* creature) : ScriptedAI(creature)
+            {
+                lockedTarget = false;
+                targetAuraCheck = 0;
+            }
+
+            void Reset()
+            {
+                me->SetReactState(REACT_PASSIVE);
+                me->CastSpell(me, SPELL_SHADOW_RESONANCE_AURA, true);
+            }
+
+            void EnterCombat(Unit* who)
+            {
+                targetAuraCheck = 1000;
+                if (me->GetDistance(who) >= 15.0f)
+                {
+                    DoStartMovement(who);
+                    return;
+                }
+
+                DoCast(who, SPELL_SHADOW_RESONANCE_RESIST);
+                me->ClearUnitState(UNIT_STAT_CASTING);
+            }
+
+            void MoveInLineOfSight(Unit* who)
+            {
+                if (me->GetDistance(who) >= 15.0f)
+                    return;
+
+                ScriptedAI::MoveInLineOfSight(who);
+            }
+
+            void DamageTaken(Unit* attacker, uint32& /*damage*/)
+            {
+                if (attacker == me)
+                    return;
+
+                if (!lockedTarget)
+                    if (me->getVictim() == attacker)
+                        lockedTarget = true;
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!me->isInCombat())
+                    return;
+
+                if (targetAuraCheck <= diff)
+                {
+                    targetAuraCheck = 1000;
+                    if (Unit *victim = me->getVictim())
+                        if (me->GetDistance(victim) < 15.0f &&
+                            !victim->HasAura(SPELL_SHADOW_RESONANCE_RESIST, me->GetGUID()))
+                        {
+                            DoCast(victim, SPELL_SHADOW_RESONANCE_RESIST);
+                            me->ClearUnitState(UNIT_STAT_CASTING);
+                        }
+                }
+                else
+                    targetAuraCheck -= diff;
+
+                if (!lockedTarget)
+                {
+                    if (Unit *victim = me->SelectVictim())
+                    {
+                        if (me->getVictim() && me->getVictim() != victim)
+                        {
+                            me->getVictim()->RemoveAurasDueToSpell(SPELL_SHADOW_RESONANCE_RESIST, me->GetGUID());
+                            lockedTarget = true;
+                        }
+
+                        lockedTarget = true;
+                        AttackStart(victim);
+                        DoCast(victim, SPELL_SHADOW_RESONANCE_RESIST);
+                        me->ClearUnitState(UNIT_STAT_CASTING);
+                    }
+                }
+            }
+
+        private:
+            uint32 targetAuraCheck; // no point for EventMap with only one timer
+            bool lockedTarget;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_dark_nucleusAI(creature);
+        }
+};
+
+class spell_taldaram_glittering_sparks : public SpellScriptLoader
+{
+    public:
+        spell_taldaram_glittering_sparks() : SpellScriptLoader("spell_taldaram_glittering_sparks") { }
+
+        class spell_taldaram_glittering_sparks_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_taldaram_glittering_sparks_SpellScript);
+
+            void HandleScript(SpellEffIndex effIndex)
+            {
+                PreventHitDefaultEffect(effIndex);
+                GetCaster()->CastSpell(GetCaster(), GetEffectValue(), true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_taldaram_glittering_sparks_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_taldaram_glittering_sparks_SpellScript();
+        }
+};
+
+class spell_taldaram_summon_flame_ball : public SpellScriptLoader
+{
+    public:
+        spell_taldaram_summon_flame_ball() : SpellScriptLoader("spell_taldaram_summon_flame_ball") { }
+
+        class spell_taldaram_summon_flame_ball_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_taldaram_summon_flame_ball_SpellScript);
+
+            void HandleScript(SpellEffIndex effIndex)
+            {
+                PreventHitDefaultEffect(effIndex);
+                GetCaster()->CastSpell(GetCaster(), GetEffectValue(), true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_taldaram_summon_flame_ball_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_DUMMY);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_taldaram_summon_flame_ball_SpellScript();
+        }
+};
+
+class spell_taldaram_flame_ball_visual : public SpellScriptLoader
+{
+    public:
+        spell_taldaram_flame_ball_visual() : SpellScriptLoader("spell_taldaram_flame_ball_visual") { }
+
+        class spell_flame_ball_visual_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_flame_ball_visual_AuraScript);
+
+            bool Load()
+            {
+                if (GetCaster()->GetEntry() == CREATURE_BALL_OF_FLAME || GetCaster()->GetEntry() == CREATURE_BALL_OF_INFERNO_FLAME)
+                    return true;
+                return false;
+            }
+
+            void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                Creature* target = GetTarget()->ToCreature();
+                if (!target)
+                    return;
+
+                // SPELL_FLAME_SPHERE_SPAWN_EFFECT
+                if (GetSpellProto()->Id == SPELL_FLAME_SPHERE_SPAWN_EFFECT)
+                {
+                    target->CastSpell(target, SPELL_BALL_OF_FLAMES, true);
+                    target->AI()->DoAction(ACTION_FLAME_BALL_CHASE);
+                }
+                else // SPELL_FLAME_SPHERE_DEATH_EFFECT
+                {
+                    if (TempSummon* summ = target->ToTempSummon())
+                        summ->UnSummon();
+                    else
+                        target->ForcedDespawn();
+                }
+            }
+
+            void Register()
+            {
+                OnEffectRemove += AuraEffectRemoveFn(spell_flame_ball_visual_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_MOD_STUN, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_flame_ball_visual_AuraScript();
+        }
+};
+
+class spell_taldaram_ball_of_inferno_flame : public SpellScriptLoader
+{
+    public:
+        spell_taldaram_ball_of_inferno_flame() : SpellScriptLoader("spell_taldaram_ball_of_inferno_flame") { }
+
+        class spell_taldaram_ball_of_inferno_flame_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_taldaram_ball_of_inferno_flame_SpellScript);
+
+            void ModAuraStack()
+            {
+                if (Aura* aur = GetHitAura())
+                    aur->SetStackAmount(GetSpellInfo()->StackAmount);
+            }
+
+            void Register()
+            {
+                AfterHit += SpellHitFn(spell_taldaram_ball_of_inferno_flame_SpellScript::ModAuraStack);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_taldaram_ball_of_inferno_flame_SpellScript();
+        }
+};
+
+class spell_valanar_kinetic_bomb : public SpellScriptLoader
+{
+    public:
+        spell_valanar_kinetic_bomb() : SpellScriptLoader("spell_valanar_kinetic_bomb") { }
+
+        class spell_valanar_kinetic_bomb_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_valanar_kinetic_bomb_SpellScript);
+
+            void ChangeSummonPos(SpellEffIndex /*effIndex*/)
+            {
+                WorldLocation* summonPos = GetTargetDest();
+                Position offset = {0.0f, 0.0f, 20.0f, 0.0f};
+                summonPos->RelocateOffset(offset);  // +20 in height
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_valanar_kinetic_bomb_SpellScript::ChangeSummonPos, EFFECT_0, SPELL_EFFECT_SUMMON);
+            }
+        };
+
+        class spell_valanar_kinetic_bomb_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_valanar_kinetic_bomb_AuraScript);
+
+            void HandleDummyTick(AuraEffect const* /*aurEff*/)
+            {
+                Unit* target = GetTarget();
+                if (target->GetTypeId() != TYPEID_UNIT)
+                    return;
+
+                if (Creature* bomb = target->FindNearestCreature(CREATURE_KINETIC_BOMB, 1.0f, true))
+                {
+                    bomb->CastSpell(bomb, SPELL_KINETIC_BOMB_EXPLOSION, true);
+                    bomb->RemoveAurasDueToSpell(SPELL_KINETIC_BOMB_VISUAL);
+                    target->RemoveAura(GetAura());
+                    bomb->AI()->DoAction(SPELL_KINETIC_BOMB_EXPLOSION);
+                }
+            }
+
+            void Register()
+            {
+                OnEffectPeriodic += AuraEffectPeriodicFn(spell_valanar_kinetic_bomb_AuraScript::HandleDummyTick, EFFECT_1, SPELL_AURA_PERIODIC_DUMMY);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_valanar_kinetic_bomb_SpellScript();
+        }
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_valanar_kinetic_bomb_AuraScript();
+        }
+};
+
+class spell_valanar_kinetic_bomb_knockback : public SpellScriptLoader
+{
+    public:
+        spell_valanar_kinetic_bomb_knockback() : SpellScriptLoader("spell_valanar_kinetic_bomb_knockback") { }
+
+        class spell_valanar_kinetic_bomb_knockback_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_valanar_kinetic_bomb_knockback_SpellScript);
+
+            void KnockIntoAir()
+            {
+                if (Creature* target = GetHitCreature())
+                    target->AI()->DoAction(ACTION_KINETIC_BOMB_JUMP);
+            }
+
+            void Register()
+            {
+                AfterHit += SpellHitFn(spell_valanar_kinetic_bomb_knockback_SpellScript::KnockIntoAir);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_valanar_kinetic_bomb_knockback_SpellScript();
+        }
+};
+
+class spell_blood_council_shadow_prison : public SpellScriptLoader
+{
+    public:
+        spell_blood_council_shadow_prison() : SpellScriptLoader("spell_blood_council_shadow_prison") { }
+
+        class spell_blood_council_shadow_prison_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_blood_council_shadow_prison_AuraScript);
+
+            void HandleDummyTick(AuraEffect const* aurEff)
+            {
+                if (GetTarget()->isMoving())
+                    GetTarget()->CastSpell(GetTarget(), SPELL_SHADOW_PRISON_DAMAGE, true, NULL, aurEff);
+            }
+
+            void Register()
+            {
+                OnEffectPeriodic += AuraEffectPeriodicFn(spell_blood_council_shadow_prison_AuraScript::HandleDummyTick, EFFECT_0, SPELL_AURA_PERIODIC_DUMMY);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_blood_council_shadow_prison_AuraScript();
+        }
+};
+
+class spell_blood_council_shadow_prison_damage : public SpellScriptLoader
+{
+    public:
+        spell_blood_council_shadow_prison_damage() : SpellScriptLoader("spell_blood_council_shadow_prison_damage") { }
+
+        class spell_blood_council_shadow_prison_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_blood_council_shadow_prison_SpellScript);
+
+            void AddExtraDamage()
+            {
+                if (Aura* aur = GetHitUnit()->GetAura(GetSpellInfo()->Id))
+                    if (AuraEffect const* eff = aur->GetEffect(1))
+                        SetHitDamage(GetHitDamage()+eff->GetAmount());
+            }
+
+            void Register()
+            {
+                OnHit += SpellHitFn(spell_blood_council_shadow_prison_SpellScript::AddExtraDamage);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_blood_council_shadow_prison_SpellScript();
+        }
+};
+
+void AddSC_boss_rat_des_blutes()
+{
+    new boss_blood_council_controller();
+    new boss_prince_keleseth_icc();
+    new boss_prince_taldaram_icc();
+    new boss_prince_valanar_icc();
+    new npc_blood_queen_lana_thel();
+    new npc_ball_of_flame();
+    new npc_kinetic_bomb();
+    new npc_dark_nucleus();
+    new spell_taldaram_glittering_sparks();
+    new spell_taldaram_summon_flame_ball();
+    new spell_taldaram_flame_ball_visual();
+    new spell_taldaram_ball_of_inferno_flame();
+    new spell_valanar_kinetic_bomb();
+    new spell_valanar_kinetic_bomb_knockback();
+    new spell_blood_council_shadow_prison();
+    new spell_blood_council_shadow_prison_damage();
+}
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp
index f71f7ce..2cb86ae 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp
@@ -1,80 +1,90 @@
 /*
- * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "ObjectMgr.h"
-#include "ScriptMgr.h"
-#include "ScriptedCreature.h"
-#include "SpellScript.h"
-#include "SpellAuras.h"
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+//Need fix 69783 and 69785 target
+
+#include "ScriptPCH.h"
 #include "icecrown_citadel.h"
 
-// KNOWN BUGS:
-// ~ No Slime Spray animation directly at target spot
-
-enum Texts
+enum Yells
 {
-    SAY_PRECIOUS_DIES           = 0,
-    SAY_AGGRO                   = 1,
-    EMOTE_SLIME_SPRAY           = 2,
-    SAY_SLIME_SPRAY             = 3,
-    EMOTE_UNSTABLE_EXPLOSION    = 4,
-    SAY_UNSTABLE_EXPLOSION      = 5,
-    SAY_KILL                    = 6,
-    SAY_BERSERK                 = 7,
-    SAY_DEATH                   = 8,
+    SAY_PRECIOUS    = -1631094,
+    SAY_AGGRO       = -1631095,
+    SAY_DEATH       = -1631103,
+    SAY_KILL_1      = -1631100,
+    SAY_KILL_2      = -1631101,
+    SAY_BERSERK     = -1631102,
+    SAY_SPRAY       = -1631097,
+    EMOTE_SPRAY     = -1631096,
+    SAY_OOZE_FLOOD  = -1631099,
+    EMOTE_EXPLOSION = -1631098,
+    SAY_EXPLOSION   = -1631099
 };
 
 enum Spells
 {
-    // Rotface
-    SPELL_SLIME_SPRAY                       = 69508,    // every 20 seconds
-    SPELL_MUTATED_INFECTION                 = 69674,    // hastens every 1:30
-
-    // Oozes
-    SPELL_LITTLE_OOZE_COMBINE               = 69537,    // combine 2 Small Oozes
-    SPELL_LARGE_OOZE_COMBINE                = 69552,    // combine 2 Large Oozes
-    SPELL_LARGE_OOZE_BUFF_COMBINE           = 69611,    // combine Large and Small Ooze
-    SPELL_OOZE_MERGE                        = 69889,    // 2 Small Oozes summon a Large Ooze
-    SPELL_WEAK_RADIATING_OOZE               = 69750,    // passive damage aura - small
-    SPELL_RADIATING_OOZE                    = 69760,    // passive damage aura - large
-    SPELL_UNSTABLE_OOZE                     = 69558,    // damage boost and counter for explosion
-    SPELL_GREEN_ABOMINATION_HITTIN__YA_PROC = 70001,    // prevents getting hit by infection
-    SPELL_UNSTABLE_OOZE_EXPLOSION           = 69839,
-    SPELL_STICKY_OOZE                       = 69774,
-    SPELL_UNSTABLE_OOZE_EXPLOSION_TRIGGER   = 69832,
-
-    // Precious
-    SPELL_MORTAL_WOUND                      = 71127,
-    SPELL_DECIMATE                          = 71123,
+    SPELL_OOZE_FLOOD_AURA    = 69788,
+    SPELL_OOZE_FLOOD         = 69783,
+    SPELL_OOZE_FLOOD_1       = 69785,
+    //SPELL_OOZE_FLOOD         = 70069,
+    SPELL_SLIME_SPRAY        = 69508,
+    SPELL_SLIME_SPRAY_1      = 70881,
+    SPELL_SLIME_SPRAY_SUMMON = 70883,
+    SPELL_STICKY_OOZE        = 69774,
+    SPELL_STICKY_OOZE_1      = 69776,
+    SPELL_RADIATING_OOZE     = 69750,
+    SPELL_RADIATING_OOZE_1   = 69760,
+    SPELL_UNSTABLE_OOZE      = 69558,
+    SPELL_EXPLOSION          = 69839,
+    SPELL_EXPLOSION_1        = 69832,
+    SPELL_MERGE_OOZE         = 69889,
+    SPELL_VOLATILE_OOZE      = 70447,
+    SPELL_DAZE               = 57416,
+    SPELL_INFECTION_AURA     = 69674,
+    SPELL_MORTAL_WOUND       = 71127,
+    SPELL_DECIMATE           = 71123,
+    SPELL_PRECIOUS_RIBBON    = 70404,
+    SPELL_LITTLE_OOZE        = 69537,
+    SPELL_LARGE_OOZE         = 69552
 };
 
-#define MUTATED_INFECTION RAID_MODE<int32>(69674,71224,73022,73023)
-
-enum Events
+const Position SpawnLoc[]=
 {
-    EVENT_SLIME_SPRAY       = 1,
-    EVENT_HASTEN_INFECTIONS = 2,
-    EVENT_MUTATED_INFECTION = 3,
-
-    EVENT_DECIMATE          = 4,
-    EVENT_MORTAL_WOUND      = 5,
+    {4468.825f, 3094.986f, 372.385f, 0.0f},
+    {4487.825f, 3114.452f, 372.385f, 0.0f},
+    {4489.825f, 3159.452f, 372.385f, 0.0f},
+    {4467.825f, 3178.986f, 372.385f, 0.0f},
+    {4424.421f, 3178.986f, 372.385f, 0.0f},
+    {4404.821f, 3158.452f, 372.385f, 0.0f},
+    {4404.825f, 3116.452f, 372.385f, 0.0f},
+    {4424.825f, 3095.986f, 372.385f, 0.0f}
+};
 
-    EVENT_STICKY_OOZE       = 6,
-    EVENT_UNSTABLE_DESPAWN  = 7,
+const Position StalkerSpawnLoc[]=
+{
+    {4468.825f, 3094.986f, 360.385f, 0.0f},
+    {4487.825f, 3114.452f, 360.385f, 0.0f},
+    {4489.825f, 3159.452f, 360.385f, 0.0f},
+    {4467.825f, 3178.986f, 360.385f, 0.0f},
+    {4424.421f, 3178.986f, 360.385f, 0.0f},
+    {4404.821f, 3158.452f, 360.385f, 0.0f},
+    {4404.825f, 3116.452f, 360.385f, 0.0f},
+    {4424.825f, 3095.986f, 360.385f, 0.0f}
 };
 
 class boss_rotface : public CreatureScript
@@ -84,654 +94,531 @@ class boss_rotface : public CreatureScript
 
         struct boss_rotfaceAI : public BossAI
         {
-            boss_rotfaceAI(Creature* creature) : BossAI(creature, DATA_ROTFACE)
-            {
-                infectionStage = 0;
-                infectionCooldown = 14000;
-            }
-
-            void InitializeAI()
+            boss_rotfaceAI(Creature* creature) : BossAI(creature, DATA_ROTFACE), summons(me)
             {
-                if (!instance || static_cast<InstanceMap*>(me->GetMap())->GetScriptId() != GetScriptId(ICCScriptName))
-                    me->IsAIEnabled = false;
-                else if (!me->isDead())
-                    Reset();
+                instance = me->GetInstanceScript();
+                bFlood = false;
             }
 
             void Reset()
             {
-                events.Reset();
-                events.ScheduleEvent(EVENT_SLIME_SPRAY, 20000);
-                events.ScheduleEvent(EVENT_HASTEN_INFECTIONS, 90000);
-                events.ScheduleEvent(EVENT_MUTATED_INFECTION, 14000);
-                infectionStage = 0;
-                infectionCooldown = 14000;
-                summons.DespawnAll();
+                uiFloodTimer = 35000;
+                uiSlimeSprayTimer = 15000;
+                uiBerserkTimer = 600000;
+                uiFloodEffectTimer = 1000;
+                uiInfectionTimer = 14000;
+
+                uiStage = 0;
+                uiFloodStage = 1;
 
-                instance->SetBossState(DATA_ROTFACE, NOT_STARTED);
+                if(instance)
+                    instance->SetData(DATA_ROTFACE_EVENT, NOT_STARTED);
             }
 
-            void EnterCombat(Unit* who)
+            void JustDied(Unit* /*pKiller*/)
             {
-                if (!instance->CheckRequiredBosses(DATA_ROTFACE, who->ToPlayer()))
-                {
-                    instance->DoCastSpellOnPlayers(LIGHT_S_HAMMER_TELEPORT);
-                    EnterEvadeMode();
+                if(!instance)
                     return;
-                }
 
-                Talk(SAY_AGGRO);
-                if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
-                    professor->AI()->DoAction(ACTION_ROTFACE_COMBAT);
+                DoScriptText(SAY_DEATH, me);
 
-                DoZoneInCombat(me);
-            }
+                instance->SetData(DATA_ROTFACE_EVENT, DONE);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_INFECTION_AURA);
 
-            void JustDied(Unit* /*killer*/)
-            {
-                Talk(SAY_DEATH);
-                instance->SetBossState(DATA_ROTFACE, DONE);
                 if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
                     professor->AI()->DoAction(ACTION_ROTFACE_DEATH);
-            }
 
-            void JustReachedHome()
-            {
-                instance->SetBossState(DATA_ROTFACE, FAIL);
-                instance->SetData(DATA_OOZE_DANCE_ACHIEVEMENT, uint32(true));   // reset
+                summons.DespawnAll();
             }
 
-            void KilledUnit(Unit* victim)
+            void EnterCombat(Unit* /*who*/)
             {
-                if (victim->GetTypeId() == TYPEID_PLAYER)
-                    Talk(SAY_KILL);
-            }
+                DoScriptText(SAY_AGGRO, me);
+
+                if(instance)
+                    instance->SetData(DATA_ROTFACE_EVENT, IN_PROGRESS);
 
-            void EnterEvadeMode()
-            {
-                ScriptedAI::EnterEvadeMode();
                 if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
-                    professor->AI()->EnterEvadeMode();
+                    professor->AI()->DoAction(ACTION_ROTFACE_COMBAT);
             }
 
-            void SpellHitTarget(Unit* /*target*/, SpellEntry const* spell)
+            void JustReachedHome()
             {
-                if (spell->Id == SPELL_SLIME_SPRAY)
-                    Talk(SAY_SLIME_SPRAY);
+                if(!instance)
+                    return;
+
+                instance->SetData(DATA_ROTFACE_EVENT, FAIL);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_INFECTION_AURA);
+
+                summons.DespawnAll();
             }
 
-            void MoveInLineOfSight(Unit* /*who*/)
+            void JustSummoned(Creature* summon)
             {
-                // don't enter combat
+                summons.Summon(summon);
             }
 
-            Unit* GetAuraEffectTriggerTarget(uint32 spellId, uint8 /*effIndex*/)
+            void KilledUnit(Unit* victim)
             {
-                if (spellId == SPELL_SLIME_SPRAY)
-                {
-                    for (std::list<uint64>::iterator itr = summons.begin(); itr != summons.end();)
-                    {
-                        Creature *summon = Unit::GetCreature(*me, *itr);
-                        if (!summon)
-                            summons.erase(itr++);
-                        else if (summon->GetEntry() == NPC_OOZE_SPRAY_STALKER)
-                            return summon;
-                        else
-                            ++itr;
-                    }
-                }
-
-                return NULL;
+                if (victim->GetTypeId() == TYPEID_PLAYER)
+                    DoScriptText(RAND(SAY_KILL_1,SAY_KILL_1), me);
             }
 
             void UpdateAI(const uint32 diff)
             {
-                if (!UpdateVictim() || !CheckInRoom())
+                if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
+                if (uiSlimeSprayTimer <= diff)
+                {
+                    if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, 0))
+                    {
+                        float x, y, z;
+                        pTarget->GetPosition(x, y, z);
+                        if(Creature* trigger = me->SummonCreature(CREATURE_OOZE_SPRAY_STALKER, x, y, z, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 4000))
+                        {
+                            me->CastSpell(trigger, SPELL_SLIME_SPRAY_1, true);
+                            me->CastSpell(trigger, SPELL_SLIME_SPRAY, true);
+                        }
+                        DoScriptText(SAY_SPRAY, me);
+                        DoScriptText(EMOTE_SPRAY, me);
+                    }
+                    uiSlimeSprayTimer = 15000;
+                } else uiSlimeSprayTimer -= diff;
 
-                if (me->HasUnitState(UNIT_STAT_CASTING))
-                    return;
+                if (uiInfectionTimer <= diff)
+                {
+                    if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, -SPELL_INFECTION_AURA))
+                        me->AddAura(SPELL_INFECTION_AURA, pTarget);
+                    uiInfectionTimer = 14000;
+                } else uiInfectionTimer -= diff;
 
-                while (uint32 eventId = events.ExecuteEvent())
+                if (uiFloodEffectTimer <= diff)
                 {
-                    switch (eventId)
+                    if(bFlood)
                     {
-                        case EVENT_SLIME_SPRAY:
-                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true))
+                        switch(uiFloodStage)
+                        {
+                            case 1:
                             {
-                                Position pos;
-                                target->GetPosition(&pos);
-                                DoSummon(NPC_OOZE_SPRAY_STALKER, pos, 8000, TEMPSUMMON_TIMED_DESPAWN);
-                                Talk(EMOTE_SLIME_SPRAY);
-                                DoCastAOE(SPELL_SLIME_SPRAY);
+                                if(Creature* stalker = me->FindNearestCreature(CREATURE_PUDDLE_STALKER, 100.0f, true))
+                                {
+                                    stalker->CastSpell(stalker, SPELL_OOZE_FLOOD, true);
+                                    ++uiFloodStage;
+                                    uiFloodEffectTimer = 4000;
+                                }
                             }
-                            events.ScheduleEvent(EVENT_SLIME_SPRAY, 20000);
                             break;
-                        case EVENT_HASTEN_INFECTIONS:
-                            if (infectionStage < 4)
+                            case 2:
                             {
-                                infectionCooldown -= 2000;
-                                events.ScheduleEvent(EVENT_HASTEN_INFECTIONS, 90000);
+                                if(Creature* stalker_puddle = me->FindNearestCreature(CREATURE_GREEN_GAS_STALKER, 100.0f, true))
+                                {
+                                    stalker_puddle->CastSpell(stalker_puddle, SPELL_OOZE_FLOOD_1, true);
+                                    --uiFloodStage;
+                                    bFlood = false;
+                                }
                             }
                             break;
-                        case EVENT_MUTATED_INFECTION:
-                        {
-                            Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -MUTATED_INFECTION);
-                            if (!target)
-                                target = SelectTarget(SELECT_TARGET_RANDOM, 0, 0.0f, true, -MUTATED_INFECTION);
-                            if (target)
-                                me->CastCustomSpell(SPELL_MUTATED_INFECTION, SPELLVALUE_MAX_TARGETS, 1, target, false);
-                            events.ScheduleEvent(EVENT_MUTATED_INFECTION, infectionCooldown);
-                            break;
                         }
-                        default:
-                            break;
                     }
-                }
+                } else uiFloodEffectTimer -= diff;
 
-                DoMeleeAttackIfReady();
-            }
-
-        private:
-            uint32 infectionCooldown;
-            uint8 infectionStage;
-        };
-
-        CreatureAI* GetAI(Creature* creature) const
-        {
-            return new boss_rotfaceAI(creature);
-        }
-};
-
-class npc_little_ooze : public CreatureScript
-{
-    public:
-        npc_little_ooze() : CreatureScript("npc_little_ooze") { }
-
-        struct npc_little_oozeAI : public ScriptedAI
-        {
-            npc_little_oozeAI(Creature* creature) : ScriptedAI(creature)
-            {
-            }
-
-            void IsSummonedBy(Unit* summoner)
-            {
-                DoCast(me, SPELL_LITTLE_OOZE_COMBINE, true);
-                DoCast(me, SPELL_WEAK_RADIATING_OOZE, true);
-                events.ScheduleEvent(EVENT_STICKY_OOZE, 5000);
-                me->AddThreat(summoner, 500000.0f);
-                // register in Rotface's summons - not summoned with Rotface as owner
-                if (InstanceScript* instance = me->GetInstanceScript())
-                    if (Creature* rotface = Unit::GetCreature(*me, instance->GetData64(DATA_ROTFACE)))
-                        rotface->AI()->JustSummoned(me);
-            }
-
-            void JustDied(Unit* /*killer*/)
-            {
-                me->DespawnOrUnsummon();
-                if (InstanceScript* instance = me->GetInstanceScript())
-                    if (Creature* rotface = Unit::GetCreature(*me, instance->GetData64(DATA_ROTFACE)))
-                        rotface->AI()->SummonedCreatureDespawn(me);
-            }
+                if (uiFloodTimer <= diff)
+                {
+                    if(uiStage > 3)
+                        uiStage = 0;
 
-            void UpdateAI(const uint32 diff)
-            {
-                if (!UpdateVictim())
-                    return;
+                    DoScriptText(SAY_OOZE_FLOOD, me);
 
-                events.Update(diff);
+                    me->SummonCreature(CREATURE_PUDDLE_STALKER, SpawnLoc[((uiStage + 0)*2)], TEMPSUMMON_TIMED_DESPAWN, 4000);
+                    me->SummonCreature(CREATURE_PUDDLE_STALKER, SpawnLoc[((uiStage*2) + 1)], TEMPSUMMON_TIMED_DESPAWN, 4000);
+                    me->SummonCreature(CREATURE_GREEN_GAS_STALKER, StalkerSpawnLoc[((uiStage + 0)*2)], TEMPSUMMON_TIMED_DESPAWN, 24000);
+                    me->SummonCreature(CREATURE_GREEN_GAS_STALKER, StalkerSpawnLoc[((uiStage*2) + 1)], TEMPSUMMON_TIMED_DESPAWN, 24000);
+                    ++uiStage;
+                    bFlood = true;
+                    uiFloodTimer = 25000;
+                } else uiFloodTimer -= diff;
 
-                if (events.ExecuteEvent() == EVENT_STICKY_OOZE)
+                if (uiBerserkTimer <= diff)
                 {
-                    DoCastVictim(SPELL_STICKY_OOZE);
-                    events.ScheduleEvent(EVENT_STICKY_OOZE, 15000);
-                }
+                    DoScriptText(SAY_BERSERK, me);
+                    DoCast(me, SPELL_BERSERK);
+                    uiBerserkTimer = 600000;
+                } else uiBerserkTimer -= diff;
 
                 DoMeleeAttackIfReady();
             }
-
         private:
-            EventMap events;
+            InstanceScript* instance;
+            uint32 uiFloodTimer;
+            uint32 uiSlimeSprayTimer;
+            uint32 uiBerserkTimer;
+            uint32 uiFloodEffectTimer;
+            uint32 uiInfectionTimer;
+            uint8 uiStage;
+            uint8 uiFloodStage;
+            bool bFlood;
+            SummonList summons;
         };
 
         CreatureAI* GetAI(Creature* creature) const
         {
-            return new npc_little_oozeAI(creature);
+            return new boss_rotfaceAI(creature);
         }
 };
 
-class npc_big_ooze : public CreatureScript
+class npc_ooze_big : public CreatureScript
 {
     public:
-        npc_big_ooze() : CreatureScript("npc_big_ooze") { }
+        npc_ooze_big() : CreatureScript("npc_ooze_big") { }
 
-        struct npc_big_oozeAI : public ScriptedAI
+        struct npc_ooze_bigAI : public ScriptedAI
         {
-            npc_big_oozeAI(Creature* creature) : ScriptedAI(creature)
+            npc_ooze_bigAI(Creature* creature) : ScriptedAI(creature)
             {
+                instance = creature->GetInstanceScript();
             }
 
-            void IsSummonedBy(Unit* /*summoner*/)
+            void Reset()
             {
-                DoCast(me, SPELL_LARGE_OOZE_COMBINE, true);
-                DoCast(me, SPELL_LARGE_OOZE_BUFF_COMBINE, true);
-                DoCast(me, SPELL_RADIATING_OOZE, true);
-                DoCast(me, SPELL_UNSTABLE_OOZE, true);
-                DoCast(me, SPELL_GREEN_ABOMINATION_HITTIN__YA_PROC, true);
-                events.ScheduleEvent(EVENT_STICKY_OOZE, 5000);
-                // register in Rotface's summons - not summoned with Rotface as owner
-                if (InstanceScript* instance = me->GetInstanceScript())
-                    if (Creature* rotface = Unit::GetCreature(*me, instance->GetData64(DATA_ROTFACE)))
-                        rotface->AI()->JustSummoned(me);
-            }
+                uiStickyOozeTimer = 9000;
 
-            void JustDied(Unit* /*killer*/)
-            {
-                me->DespawnOrUnsummon();
-                if (InstanceScript* instance = me->GetInstanceScript())
-                    if (Creature* rotface = Unit::GetCreature(*me, instance->GetData64(DATA_ROTFACE)))
-                        rotface->AI()->SummonedCreatureDespawn(me);
+                DoCast(SPELL_UNSTABLE_OOZE);
+                DoCast(SPELL_RADIATING_OOZE_1);
+                DoCast(SPELL_LARGE_OOZE);
+                me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
+                me->SetSpeed(MOVE_WALK, 0.5f);
+                me->SetSpeed(MOVE_RUN, 0.5);
             }
 
-            void DoAction(const int32 action)
-            {
-                if (action == EVENT_STICKY_OOZE)
-                    events.CancelEvent(EVENT_STICKY_OOZE);
-                else if (action == EVENT_UNSTABLE_DESPAWN)
-                {
-                    me->RemoveAllAuras();
-                    me->SetVisible(false);
-                    events.Reset();
-                    events.ScheduleEvent(EVENT_UNSTABLE_DESPAWN, 60000);
-                }
-            }
+            void EnterCombat(Unit* /*who*/) { }
+
+            void KilledUnit(Unit* /*pVictim*/) { }
 
             void UpdateAI(const uint32 diff)
             {
                 if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
-
-                while (uint32 eventId = events.ExecuteEvent())
+                if (uiStickyOozeTimer <= diff)
                 {
-                    switch (eventId)
-                    {
-                        case EVENT_STICKY_OOZE:
-                            DoCastVictim(SPELL_STICKY_OOZE);
-                            events.ScheduleEvent(EVENT_STICKY_OOZE, 15000);
-                            break;
-                        case EVENT_UNSTABLE_DESPAWN:
-                            me->Kill(me);
-                            break;
-                        default:
-                            break;
-                    }
-                }
+                    DoCast(me->getVictim(), SPELL_STICKY_OOZE);
+                    uiStickyOozeTimer = 10000;
+                } else uiStickyOozeTimer -= diff;
 
-                if (me->IsVisible())
-                    DoMeleeAttackIfReady();
+                DoMeleeAttackIfReady();
             }
-
         private:
-            EventMap events;
+            InstanceScript* instance;
+
+            uint32 uiStickyOozeTimer;
         };
 
         CreatureAI* GetAI(Creature* creature) const
         {
-            return new npc_big_oozeAI(creature);
+            return new npc_ooze_bigAI(creature);
         }
 };
 
-class npc_precious_icc : public CreatureScript
+class npc_ooze_little : public CreatureScript
 {
     public:
-        npc_precious_icc() : CreatureScript("npc_precious_icc") { }
+        npc_ooze_little() : CreatureScript("npc_ooze_little") { }
 
-        struct npc_precious_iccAI : public ScriptedAI
+        struct npc_ooze_littleAI : public ScriptedAI
         {
-            npc_precious_iccAI(Creature* creature) : ScriptedAI(creature)
+            npc_ooze_littleAI(Creature* creature) : ScriptedAI(creature)
             {
                 instance = creature->GetInstanceScript();
             }
 
             void Reset()
             {
-                events.Reset();
-                events.ScheduleEvent(EVENT_DECIMATE, urand(20000, 25000));
-                events.ScheduleEvent(EVENT_MORTAL_WOUND, urand(3000, 7000));
+                uiStickyOozeTimer = 10000;
+                bMerge = false;
+
+                DoCast(SPELL_RADIATING_OOZE);
+                DoCast(SPELL_LITTLE_OOZE);
+                me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
+                me->SetSpeed(MOVE_WALK, 0.5f);
+                me->SetSpeed(MOVE_RUN, 0.5f);
             }
 
+            void EnterCombat(Unit* /*who*/) { }
+
+            void KilledUnit(Unit* /*victim*/) { }
+
             void UpdateAI(const uint32 diff)
             {
                 if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
-
-                if (me->HasUnitState(UNIT_STAT_CASTING))
-                    return;
-
-                while (uint32 eventId = events.ExecuteEvent())
+                if (uiStickyOozeTimer <= diff)
                 {
-                    switch (eventId)
-                    {
-                        case EVENT_DECIMATE:
-                            DoCastVictim(SPELL_DECIMATE);
-                            events.ScheduleEvent(EVENT_DECIMATE, urand(20000, 25000));
-                            break;
-                        case EVENT_MORTAL_WOUND:
-                            DoCastVictim(SPELL_MORTAL_WOUND);
-                            events.ScheduleEvent(EVENT_MORTAL_WOUND, urand(10000, 12500));
-                            break;
-                        default:
-                            break;
-                    }
-                }
+                    DoCast(me->getVictim(), SPELL_STICKY_OOZE);
+                    uiStickyOozeTimer = 11000;
+                } else uiStickyOozeTimer -= diff;
 
                 DoMeleeAttackIfReady();
             }
-
-            void JustDied(Unit* /*who*/)
-            {
-                uint64 rotfaceGUID = instance ? instance->GetData64(DATA_ROTFACE) : 0;
-                if (Creature* rotface = Unit::GetCreature(*me, rotfaceGUID))
-                    if (rotface->isAlive())
-                        rotface->AI()->Talk(SAY_PRECIOUS_DIES);
-            }
-
         private:
-            EventMap events;
             InstanceScript* instance;
+            uint32 uiStickyOozeTimer;
+            bool bMerge;
         };
 
         CreatureAI* GetAI(Creature* creature) const
         {
-            return new npc_precious_iccAI(creature);
+            return new npc_ooze_littleAI(creature);
         }
 };
 
-class spell_rotface_ooze_flood : public SpellScriptLoader
+class npc_icc_puddle_stalker : public CreatureScript
 {
     public:
-        spell_rotface_ooze_flood() : SpellScriptLoader("spell_rotface_ooze_flood") { }
+        npc_icc_puddle_stalker() : CreatureScript("npc_icc_puddle_stalker") { }
 
-        class spell_rotface_ooze_flood_SpellScript : public SpellScript
+        struct npc_icc_puddle_stalkerAI : public ScriptedAI
         {
-            PrepareSpellScript(spell_rotface_ooze_flood_SpellScript);
+            npc_icc_puddle_stalkerAI(Creature* creature) : ScriptedAI(creature) { }
 
-            void HandleScript(SpellEffIndex /*effIndex*/)
+            void Reset()
             {
-                if (!GetHitUnit())
-                    return;
-                std::list<Creature*> list;
-                GetHitUnit()->GetCreatureListWithEntryInGrid(list, GetHitUnit()->GetEntry(), 12.5f);
-                list.sort(Trinity::ObjectDistanceOrderPred(GetHitUnit()));
-                GetHitUnit()->CastSpell(list.back(), uint32(GetEffectValue()), false, NULL, NULL, GetOriginalCaster() ? GetOriginalCaster()->GetGUID() : 0);
-            }
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetInCombatWithZone();
+                DoStartNoMovement(me->getVictim());
 
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_rotface_ooze_flood_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+                DoCast(me, SPELL_OOZE_FLOOD_AURA);
             }
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* creature) const
         {
-            return new spell_rotface_ooze_flood_SpellScript();
+            return new npc_icc_puddle_stalkerAI(creature);
         }
 };
 
-class spell_rotface_little_ooze_combine : public SpellScriptLoader
+class npc_ooze_explode_stalker : public CreatureScript
 {
     public:
-        spell_rotface_little_ooze_combine() : SpellScriptLoader("spell_rotface_little_ooze_combine") { }
+        npc_ooze_explode_stalker() : CreatureScript("npc_ooze_explode_stalker") { }
 
-        class spell_rotface_little_ooze_combine_SpellScript : public SpellScript
+        struct npc_ooze_explode_stalkerAI : public ScriptedAI
         {
-            PrepareSpellScript(spell_rotface_little_ooze_combine_SpellScript);
+            npc_ooze_explode_stalkerAI(Creature* creature) : ScriptedAI(creature) { }
 
-            void HandleScript(SpellEffIndex /*effIndex*/)
+            void Reset()
             {
-                if (!(GetHitCreature() && GetHitUnit()->isAlive()))
-                    return;
+                uiExplosionTimer = 2000;
 
-                GetCaster()->RemoveAurasDueToSpell(SPELL_LITTLE_OOZE_COMBINE);
-                GetHitCreature()->RemoveAurasDueToSpell(SPELL_LITTLE_OOZE_COMBINE);
-                GetHitCreature()->CastSpell(GetCaster(), SPELL_OOZE_MERGE, true);
-                GetHitCreature()->DespawnOrUnsummon();
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                DoStartNoMovement(me->getVictim());
+                me->SetInCombatWithZone();
+                DoCast(SPELL_EXPLOSION_1);
             }
 
-            void Register()
+            void UpdateAI(const uint32 uiDiff)
             {
-                OnEffect += SpellEffectFn(spell_rotface_little_ooze_combine_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+                if (uiExplosionTimer <= uiDiff)
+                {
+                    DoCast(SPELL_EXPLOSION_1);
+                    me->ForcedDespawn();
+                    uiExplosionTimer = 2000;
+                } else uiExplosionTimer -= uiDiff;
             }
+        private:
+            uint32 uiExplosionTimer;
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* creature) const
         {
-            return new spell_rotface_little_ooze_combine_SpellScript();
+            return new npc_ooze_explode_stalkerAI(creature);
         }
 };
 
-class spell_rotface_large_ooze_combine : public SpellScriptLoader
+class npc_precious_icc : public CreatureScript
 {
     public:
-        spell_rotface_large_ooze_combine() : SpellScriptLoader("spell_rotface_large_ooze_combine") { }
+        npc_precious_icc() : CreatureScript("npc_precious_icc") { }
 
-        class spell_rotface_large_ooze_combine_SpellScript : public SpellScript
+        struct npc_precious_iccAI : public ScriptedAI
         {
-            PrepareSpellScript(spell_rotface_large_ooze_combine_SpellScript);
-
-            void HandleScript(SpellEffIndex /*effIndex*/)
+            npc_precious_iccAI(Creature* creature) : ScriptedAI(creature)
             {
-                if (!(GetHitCreature() && GetHitCreature()->isAlive()))
-                    return;
-
-                if (Aura* unstable = GetCaster()->GetAura(SPELL_UNSTABLE_OOZE))
-                {
-                    if (Aura* targetAura = GetHitCreature()->GetAura(SPELL_UNSTABLE_OOZE))
-                        unstable->ModStackAmount(targetAura->GetStackAmount());
-                    else
-                        unstable->ModStackAmount(1);
-
-                    // no idea why, but this does not trigger explosion on retail (only small+large do)
-                }
-
-                // just for safety
-                GetHitCreature()->RemoveAurasDueToSpell(SPELL_LARGE_OOZE_BUFF_COMBINE);
-                GetHitCreature()->RemoveAurasDueToSpell(SPELL_LARGE_OOZE_COMBINE);
-                GetHitCreature()->DespawnOrUnsummon();
+                instance = creature->GetInstanceScript();
             }
 
-            void Register()
+            void Reset()
             {
-                OnEffect += SpellEffectFn(spell_rotface_large_ooze_combine_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_rotface_large_ooze_combine_SpellScript();
-        }
-};
+                uiDecimateTimer = 23000;
+                uiMortalTimer = urand(8000, 10000);
 
-class spell_rotface_large_ooze_buff_combine : public SpellScriptLoader
-{
-    public:
-        spell_rotface_large_ooze_buff_combine() : SpellScriptLoader("spell_rotface_large_ooze_buff_combine") { }
-
-        class spell_rotface_large_ooze_buff_combine_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_rotface_large_ooze_buff_combine_SpellScript);
+                DoCast(me, SPELL_PRECIOUS_RIBBON);
+            }
 
-            void HandleScript(SpellEffIndex /*effIndex*/)
+            void UpdateAI(const uint32 uiDiff)
             {
-                if (!(GetHitCreature() && GetHitCreature()->isAlive()))
+                if (!UpdateVictim())
                     return;
 
-                if (Aura* unstable = GetCaster()->GetAura(SPELL_UNSTABLE_OOZE))
+                if(uiDecimateTimer < uiDiff)
                 {
-                    uint8 newStack = uint8(unstable->GetStackAmount()+1);
-                    unstable->SetStackAmount(newStack);
+                    DoCast(me->getVictim(), SPELL_DECIMATE);
+                    uiDecimateTimer = 23000;
+                } else uiDecimateTimer -= uiDiff;
 
-                    // explode!
-                    if (newStack >= 5)
-                    {
-                        GetCaster()->RemoveAurasDueToSpell(SPELL_LARGE_OOZE_BUFF_COMBINE);
-                        GetCaster()->RemoveAurasDueToSpell(SPELL_LARGE_OOZE_COMBINE);
-                        if (InstanceScript* instance = GetCaster()->GetInstanceScript())
-                            if (Creature* rotface = Unit::GetCreature(*GetCaster(), instance->GetData64(DATA_ROTFACE)))
-                                if (rotface->isAlive())
-                                {
-                                    rotface->AI()->Talk(EMOTE_UNSTABLE_EXPLOSION);
-                                    rotface->AI()->Talk(SAY_UNSTABLE_EXPLOSION);
-                                }
-
-                        if (Creature* cre = GetCaster()->ToCreature())
-                            cre->AI()->DoAction(EVENT_STICKY_OOZE);
-                        GetCaster()->CastSpell(GetCaster(), SPELL_UNSTABLE_OOZE_EXPLOSION, false, NULL, NULL, GetCaster()->GetGUID());
-                        if (InstanceScript* instance = GetCaster()->GetInstanceScript())
-                            instance->SetData(DATA_OOZE_DANCE_ACHIEVEMENT, uint32(false));
-                    }
-                }
+                if(uiMortalTimer < uiDiff)
+                {
+                    DoCast(me->getVictim(), SPELL_MORTAL_WOUND);
+                    uiMortalTimer = urand(8000,10000);
+                } else uiMortalTimer -= uiDiff;
 
-                GetHitCreature()->DespawnOrUnsummon();
+                DoMeleeAttackIfReady();
             }
 
-            void Register()
+            void JustDied(Unit* who)
             {
-                OnEffect += SpellEffectFn(spell_rotface_large_ooze_buff_combine_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+                uint64 rotfaceGUID = instance ? instance->GetData64(DATA_ROTFACE) : 0;
+                if (Creature *rotface = me->GetCreature(*me, rotfaceGUID))
+                    DoScriptText(SAY_PRECIOUS, rotface);
             }
+        private:
+            InstanceScript* instance;
+            uint32 uiDecimateTimer;
+            uint32 uiMortalTimer;
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* creature) const
         {
-            return new spell_rotface_large_ooze_buff_combine_SpellScript();
+            return new npc_precious_iccAI(creature);
         }
 };
 
-class spell_rotface_unstable_ooze_explosion_init : public SpellScriptLoader
+class spell_rotface_unstable_explosion : public SpellScriptLoader
 {
     public:
-        spell_rotface_unstable_ooze_explosion_init() : SpellScriptLoader("spell_rotface_unstable_ooze_explosion_init") { }
+        spell_rotface_unstable_explosion() : SpellScriptLoader("spell_rotface_unstable_explosion") { } //69558
 
-        class spell_rotface_unstable_ooze_explosion_init_SpellScript : public SpellScript
-        {
-            PrepareSpellScript(spell_rotface_unstable_ooze_explosion_init_SpellScript);
 
-            bool Validate(SpellEntry const* /*spell*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_UNSTABLE_OOZE_EXPLOSION_TRIGGER))
-                    return false;
-                return true;
-            }
+        class spell_rotface_unstable_explosion_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_rotface_unstable_explosion_AuraScript)
 
-            void HandleCast(SpellEffIndex effIndex)
+            void OnApply(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
             {
-                PreventHitEffect(effIndex);
-                if (!GetHitUnit())
-                    return;
-
-                float x, y, z;
-                GetHitUnit()->GetPosition(x, y, z);
-                Creature* dummy = GetCaster()->SummonCreature(NPC_UNSTABLE_EXPLOSION_STALKER, x, y, z, 0.0f, TEMPSUMMON_TIMED_DESPAWN, 60000);
-                GetCaster()->CastSpell(dummy, SPELL_UNSTABLE_OOZE_EXPLOSION_TRIGGER, true);
+                if(GetStackAmount() >= 5)
+                {
+                    GetCaster()->RemoveAurasDueToSpell(SPELL_UNSTABLE_OOZE);
+                    GetCaster()->CastSpell(GetCaster(), SPELL_EXPLOSION, true);
+                    DoScriptText(EMOTE_EXPLOSION, GetCaster());
+                    if (InstanceScript* instance = GetCaster()->GetInstanceScript())
+                        if (Creature* rotface = Unit::GetCreature(*GetCaster(), instance->GetData64(DATA_ROTFACE)))
+                            if (rotface->isAlive())
+                                DoScriptText(SAY_EXPLOSION, rotface);
+                }
             }
 
             void Register()
             {
-                OnEffect += SpellEffectFn(spell_rotface_unstable_ooze_explosion_init_SpellScript::HandleCast, EFFECT_0, SPELL_EFFECT_FORCE_CAST);
+                OnEffectApply += AuraEffectApplyFn(spell_rotface_unstable_explosion_AuraScript::OnApply, EFFECT_0, SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, AURA_EFFECT_HANDLE_REAL);
             }
         };
 
-        SpellScript* GetSpellScript() const
+        AuraScript* GetAuraScript() const
         {
-            return new spell_rotface_unstable_ooze_explosion_init_SpellScript();
+            return new spell_rotface_unstable_explosion_AuraScript();
         }
 };
 
-class spell_rotface_unstable_ooze_explosion : public SpellScriptLoader
+class spell_rotface_little_ooze_combine : public SpellScriptLoader
 {
     public:
-        spell_rotface_unstable_ooze_explosion() : SpellScriptLoader("spell_rotface_unstable_ooze_explosion") { }
+        spell_rotface_little_ooze_combine() : SpellScriptLoader("spell_rotface_little_ooze_combine") { }
 
-        class spell_rotface_unstable_ooze_explosion_SpellScript : public SpellScript
+
+        class spell_rotface_little_ooze_combine_SpellScript : public SpellScript
         {
-            PrepareSpellScript(spell_rotface_unstable_ooze_explosion_SpellScript);
+            PrepareSpellScript(spell_rotface_little_ooze_combine_SpellScript);
 
-            void CheckTarget(SpellEffIndex effIndex)
+            void HandleScript(SpellEffIndex /*effIndex*/)
             {
-                PreventHitDefaultEffect(EFFECT_0);
-                if (!GetTargetUnit())
+                if (!(GetHitUnit() && GetHitUnit()->isAlive()))
                     return;
 
-                uint32 triggered_spell_id = GetSpellInfo()->EffectTriggerSpell[effIndex];
-
-                float x, y, z;
-                GetTargetUnit()->GetPosition(x, y, z);
-                // let Rotface handle the cast - caster dies before this executes
-                if (InstanceScript* script = GetTargetUnit()->GetInstanceScript())
-                    if (Creature* rotface = script->instance->GetCreature(script->GetData64(DATA_ROTFACE)))
-                        rotface->CastSpell(x, y, z, triggered_spell_id, true, NULL, NULL, GetCaster()->GetGUID(), GetTargetUnit());
+                GetCaster()->RemoveAurasDueToSpell(SPELL_LITTLE_OOZE);
+                GetHitUnit()->RemoveAurasDueToSpell(SPELL_LITTLE_OOZE);
+                GetHitUnit()->CastSpell(GetCaster(), SPELL_MERGE_OOZE, true);
+                if (TempSummon* summ = GetHitUnit()->ToTempSummon())
+                    summ->UnSummon();
+                else
+                    GetHitCreature()->ForcedDespawn();
             }
 
             void Register()
             {
-                OnEffect += SpellEffectFn(spell_rotface_unstable_ooze_explosion_SpellScript::CheckTarget, EFFECT_0, SPELL_EFFECT_TRIGGER_MISSILE);
+                OnEffect += SpellEffectFn(spell_rotface_little_ooze_combine_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
             }
         };
 
         SpellScript* GetSpellScript() const
         {
-            return new spell_rotface_unstable_ooze_explosion_SpellScript();
+            return new spell_rotface_little_ooze_combine_SpellScript();
         }
 };
 
-class spell_rotface_unstable_ooze_explosion_suicide : public SpellScriptLoader
+class spell_rotface_large_ooze_combine : public SpellScriptLoader
 {
     public:
-        spell_rotface_unstable_ooze_explosion_suicide() : SpellScriptLoader("spell_rotface_unstable_ooze_explosion_suicide") { }
+        spell_rotface_large_ooze_combine() : SpellScriptLoader("spell_rotface_large_ooze_combine") { }
+
 
-        class spell_rotface_unstable_ooze_explosion_suicide_AuraScript : public AuraScript
+        class spell_rotface_large_ooze_combine_SpellScript : public SpellScript
         {
-            PrepareAuraScript(spell_rotface_unstable_ooze_explosion_suicide_AuraScript);
+            PrepareSpellScript(spell_rotface_large_ooze_combine_SpellScript);
 
-            void DespawnSelf(AuraEffect const* /*aurEff*/)
+            void HandleScript(SpellEffIndex /*effIndex*/)
             {
-                PreventDefaultAction();
-                Unit* target = GetTarget();
-                if (target->GetTypeId() != TYPEID_UNIT)
+                if (!(GetHitUnit() && GetHitUnit()->isAlive()))
                     return;
 
-                target->ToCreature()->AI()->DoAction(EVENT_UNSTABLE_DESPAWN);
+                if (Aura* unstable = GetCaster()->GetAura(SPELL_UNSTABLE_OOZE))
+                {
+                    if (Aura* targetAura = GetHitUnit()->GetAura(SPELL_UNSTABLE_OOZE))
+                        unstable->ModStackAmount(targetAura->GetStackAmount());
+                    else
+                        unstable->ModStackAmount(1);
+                }
+
+                GetHitUnit()->RemoveAurasDueToSpell(SPELL_LARGE_OOZE);
+
+                if (TempSummon* summ = GetHitUnit()->ToTempSummon())
+                    summ->UnSummon();
+                else if (GetHitCreature())
+                    GetHitCreature()->ForcedDespawn();
             }
 
             void Register()
             {
-                OnEffectPeriodic += AuraEffectPeriodicFn(spell_rotface_unstable_ooze_explosion_suicide_AuraScript::DespawnSelf, EFFECT_2, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
+                OnEffect += SpellEffectFn(spell_rotface_large_ooze_combine_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
             }
         };
 
-        AuraScript* GetAuraScript() const
+
+        SpellScript* GetSpellScript() const
         {
-            return new spell_rotface_unstable_ooze_explosion_suicide_AuraScript();
+            return new spell_rotface_large_ooze_combine_SpellScript();
         }
 };
 
 void AddSC_boss_rotface()
 {
     new boss_rotface();
-    new npc_little_ooze();
-    new npc_big_ooze();
+    new npc_ooze_big();
+    new npc_ooze_little();
+    new npc_icc_puddle_stalker();
+    new npc_ooze_explode_stalker();
     new npc_precious_icc();
-    new spell_rotface_ooze_flood();
+    new spell_rotface_unstable_explosion();
     new spell_rotface_little_ooze_combine();
     new spell_rotface_large_ooze_combine();
-    new spell_rotface_large_ooze_buff_combine();
-    new spell_rotface_unstable_ooze_explosion_init();
-    new spell_rotface_unstable_ooze_explosion();
-    new spell_rotface_unstable_ooze_explosion_suicide();
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
new file mode 100644
index 0000000..9328638
--- /dev/null
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
@@ -0,0 +1,650 @@
+/*
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+/*
+*Need correct timers
+*Need add  Sindragossa fly in fly phase
+*/
+
+#include "ScriptMgr.h"
+#include "SpellScript.h"
+#include "SpellAuraEffects.h"
+#include "icecrown_citadel.h"
+
+enum Yells
+{
+    SAY_AGGRO            = -1666071,
+    SAY_UNCHAIND_MAGIC   = -1666072,
+    SAY_BLISTERING_COLD  = -1666073,
+    SAY_BREATH           = -1666074,
+    SAY_AIR_PHASE        = -1666075,
+    SAY_PHASE_3          = -1666076,
+    SAY_KILL_1           = -1666077,
+    SAY_KILL_2           = -1666078,
+    SAY_BERSERK          = -1666079,
+    SAY_DEATH            = -1666080
+};
+
+enum Spells
+{
+    SPELL_FROST_AURA          = 70084,
+    SPELL_CLEAVE              = 19983,
+    SPELL_TAIL_SMASH          = 71077,
+    SPELL_FROST_BREATH        = 73061,
+    SPELL_PERMEATING_CHILL    = 70109,
+    SPELL_UNCHAINED_MAGIC     = 69762, //     
+    SPELL_ICY_TRIP_PULL       = 70117,
+    SPELL_BOMB_VISUAL_1       = 64624,
+    SPELL_BOMB_VISUAL_2       = 69016,
+    SPELL_BLISTERING_COLD     = 71047,
+    SPELL_FROST_BOMB_TRIGGER  = 69846,
+    SPELL_FROST_BEACON        = 70126,
+    SPELL_ICE_TOMB            = 70157,
+    SPELL_FROST_BOMB          = 69845,
+    SPELL_MYSTIC_BUFFED       = 70128,
+    SPELL_ASPHYXATION         = 71665,
+    SPELL_FROST_AURA_ADD      = 71387,
+    SPELL_FROST_BREATH_ADD    = 71386,
+    SPELL_ICE_BLAST           = 71376,
+    SPELL_BELLOWING_ROAR      = 36922,
+    SPELL_CLEAVE_ADD          = 40505,
+    SPELL_TAIL_SWEEP          = 71369
+    //70521
+};
+
+enum ePoints
+{
+    POINT_PHASE_FLY                = 1,
+    POINT_PHASE_NORMAL             = 2
+};
+
+//need add correct coords
+const Position SpawnLoc[]=
+{
+    {4523.889f, 2486.907f, 280.249f, 3.155f}, //fly pos
+    {4407.439f, 2484.905f, 203.374f, 3.166f}, //center
+    {4407.439f, 2484.905f, 230.374f, 3.166f}, //center Z + 30
+    {4671.521f, 2481.815f, 343.365f, 3.166f} //spawn pos
+};
+
+class boss_sindragosa : public CreatureScript
+{
+    public:
+        boss_sindragosa() : CreatureScript("boss_sindragosa") { }
+
+        struct boss_sindragosaAI : public BossAI
+        {
+            boss_sindragosaAI(Creature* creature) : BossAI(creature, DATA_SINDRAGOSA)
+            {
+                instance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                uiPhase = 1;
+
+                uiBreathTimer = 15000;
+                uiTailSmashTimer = 15000;
+                uiBlisteringColdTimer = 30000;
+                uiMarkTimer = 25000;
+                uiBerserkTimer = 600000;
+                uiChangePhaseTimer = 110000;
+                uiUnchainedMagicTimer = 12000;
+                uiBombTimer = 7000;
+                uiCleaveTimer = 5000;
+                uiBombCount = 0;
+
+                me->SetFlying(true);
+                SetCombatMovement(true);
+                me->SetSpeed(MOVE_FLIGHT, 2.5f, true);
+
+                bMystic = false;
+                bCanSwitch = false;
+
+                if(instance)
+                    instance->SetData(DATA_SINDRAGOSA, NOT_STARTED);
+
+                if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
+                    me->GetMotionMaster()->MovementExpired();
+            }
+
+            void EnterCombat(Unit* /*who*/)
+            {
+                if(instance)
+                    instance->SetData(DATA_SINDRAGOSA, IN_PROGRESS);
+
+                DoCast(me, SPELL_FROST_AURA);
+                DoCast(me, SPELL_PERMEATING_CHILL);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                if (!instance)
+                    return;
+
+                DoScriptText(SAY_DEATH, me);
+
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_UNCHAINED_MAGIC);
+                instance->SetData(DATA_SINDRAGOSA, DONE);
+                if(instance->GetData(DATA_ALL_YOU_CAN_EAT) == DONE)
+                    instance->DoCompleteAchievement(RAID_MODE(ACHIEV_ALL_YOU_CAN_EAT_10,ACHIEV_ALL_YOU_CAN_EAT_25));
+            }
+
+            void KilledUnit(Unit* victim)
+            {
+                if (victim->GetTypeId() == TYPEID_PLAYER)
+                {
+                    switch(rand()%1)
+                    {
+                        case 0: DoScriptText(SAY_KILL_1, me); break;
+                        case 1: DoScriptText(SAY_KILL_2, me); break;
+                    }
+                }
+            }
+
+            void JustReachedHome()
+            {
+                if (!instance)
+                    return;
+
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_UNCHAINED_MAGIC);
+                instance->SetData(DATA_SINDRAGOSA, FAIL);
+            }
+
+            void DamageTaken(Unit* /*done_by*/, uint32& /*damage*/)
+            {
+                if(uiPhase == 1)
+                {
+                    if(!HealthAbovePct(85) && !bCanSwitch)
+                    {
+                        DoScriptText(SAY_AIR_PHASE, me);
+                        uiPhase = 2;
+                        bCanSwitch = true;
+                        SetCombatMovement(false);
+                        me->GetMotionMaster()->MovePoint(POINT_PHASE_FLY, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ() + 30);
+                        me->SetReactState(REACT_PASSIVE);
+                        me->AttackStop();
+                        me->SetInCombatWithZone();
+                    }
+                    if(HealthAbovePct(36))
+                        return;
+
+                    DoScriptText(SAY_PHASE_3, me);
+                    uiPhase = 3;
+                }
+            }
+
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (uiBerserkTimer <= uiDiff)
+                {
+                    DoScriptText(SAY_BERSERK, me);
+                    DoCast(me, SPELL_BERSERK);
+                    uiBerserkTimer = 600000;
+                } else uiBerserkTimer -= uiDiff;
+
+                if(uiPhase == 1)
+                {
+                    if(uiUnchainedMagicTimer <= uiDiff)
+                    {
+                        for (uint8 i = 1; i <= urand(2, 4); ++i)
+                        {
+                            if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, -10.0f, true, -SPELL_UNCHAINED_MAGIC))
+                                DoCast(target, SPELL_UNCHAINED_MAGIC);
+                        }
+                        DoScriptText(SAY_UNCHAIND_MAGIC, me);
+                        uiUnchainedMagicTimer = 12000;
+                    } else uiUnchainedMagicTimer -= uiDiff;
+
+                    if (uiBreathTimer <= uiDiff)
+                    {
+                        DoScriptText(SAY_BREATH, me);
+                        DoCastVictim(SPELL_FROST_BREATH);
+                        uiBreathTimer = 15000;
+                    } else uiBreathTimer -= uiDiff;
+
+                    if (uiCleaveTimer <= uiDiff)
+                    {
+                        DoCastVictim(SPELL_CLEAVE);
+                        uiCleaveTimer = 6000;
+                    } else uiCleaveTimer -= uiDiff;
+
+                    if (uiTailSmashTimer <= uiDiff)
+                    {
+                        DoCast(SPELL_TAIL_SMASH);
+                        uiTailSmashTimer = 15000;
+                    } else uiTailSmashTimer -= uiDiff;
+
+                    if (uiBlisteringColdTimer <= uiDiff)
+                    {
+                        DoCast(SPELL_ICY_TRIP_PULL);
+                        DoCast(SPELL_BLISTERING_COLD);
+                        DoScriptText(SAY_BLISTERING_COLD, me);
+                        uiBlisteringColdTimer = 30000;
+                    } else uiBlisteringColdTimer -= uiDiff;
+                }
+
+                if(uiPhase == 2)
+                {
+                    if (uiMarkTimer < uiDiff)
+                    {
+                        for (uint8 i = 1; i <= RAID_MODE(2,5,2,5); ++i)
+                        {
+                            if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, -SPELL_FROST_BEACON))
+                                DoCast(target, SPELL_FROST_BEACON);
+                        }
+                        uiMarkTimer = 25000;
+                    } else uiMarkTimer -= uiDiff;
+
+                    if (uiBombTimer <= uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 150.0f, true))
+                            DoCast(target, SPELL_FROST_BOMB);
+                        ++uiBombCount;
+                        uiBombTimer = 7000;
+                    } else uiBombTimer -= uiDiff;
+
+                    if(uiBombCount >= RAID_MODE(4,8,4,8))
+                    {
+                        me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_NONE);
+                        SetCombatMovement(true);
+                        me->SetReactState(REACT_AGGRESSIVE);
+                        me->AttackStop();
+                        me->SetInCombatWithZone();
+                        me->GetMotionMaster()->MovePoint(POINT_PHASE_NORMAL, SpawnLoc[1]);
+                        uiPhase = 1;
+                        uiBombCount = 0;
+                    }
+                }
+
+                if(uiPhase == 3)
+                {
+                    if (uiMarkTimer < uiDiff)
+                    {
+                        for (uint8 i = 1; i <= RAID_MODE(2,5,2,5); ++i)
+                        {
+                            if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, -SPELL_FROST_BEACON))
+                                DoCast(target, SPELL_FROST_BEACON);
+                        }
+                        uiMarkTimer = 25000;
+                    } else uiMarkTimer -= uiDiff;
+
+                    if (uiBreathTimer <= uiDiff)
+                    {
+                        DoScriptText(SAY_BREATH, me);
+                        DoCast(SPELL_FROST_BREATH);
+                        uiBreathTimer = 15000;
+                    } else uiBreathTimer -= uiDiff;
+
+                    if(!bMystic)
+                    {
+                       DoCast(me, SPELL_MYSTIC_BUFFED);
+                       bMystic = true;
+                    }
+                }
+
+                if(!bCanSwitch || uiPhase != 1)
+                    return;
+
+                if (uiChangePhaseTimer < uiDiff)
+                {
+                    DoScriptText(SAY_AIR_PHASE, me);
+                    uiPhase = 2;
+                    SetCombatMovement(false);
+                    me->GetMotionMaster()->MovePoint(POINT_PHASE_FLY, SpawnLoc[2]);
+                    me->SetReactState(REACT_PASSIVE);
+                    me->AttackStop();
+                    me->SetInCombatWithZone();
+                    uiChangePhaseTimer = 110000;
+                } else uiChangePhaseTimer -= uiDiff;
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            InstanceScript* instance;
+
+            uint8 uiPhase;
+            uint8 uiBombCount;
+            uint32 uiBreathTimer;
+            uint32 uiCleaveTimer;
+            uint32 uiTailSmashTimer;
+            uint32 uiBlisteringColdTimer;
+            uint32 uiBerserkTimer;
+            uint32 uiMarkTimer;
+            uint32 uiChangePhaseTimer;
+            uint32 uiUnchainedMagicTimer;
+            uint32 uiBombTimer;
+
+            bool bMystic;
+            bool bCanSwitch;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new boss_sindragosaAI(creature);
+        }
+};
+
+class npc_ice_tomb : public CreatureScript
+{
+    public:
+        npc_ice_tomb() : CreatureScript("npc_ice_tomb") { }
+
+        struct npc_ice_tombAI: public Scripted_NoMovementAI
+        {
+            npc_ice_tombAI(Creature* creature) : Scripted_NoMovementAI(creature)
+            {
+                uiTargetGUID = 0;
+            }
+
+            void SetGUID(const uint64& guid)
+            {
+                uiTargetGUID = guid;
+            }
+
+            void Reset()
+            {
+                uiTargetGUID = 0;
+            }
+
+            void JustDied(Unit* killer)
+            {
+                if (Player* IceTomb = ObjectAccessor::GetPlayer(*me, uiTargetGUID))
+                {
+                    IceTomb->RemoveAurasDueToSpell(SPELL_ICE_TOMB);
+                    IceTomb->RemoveAurasDueToSpell(SPELL_ASPHYXATION);
+                }
+            }
+
+            void KilledUnit(Unit* victim)
+            {
+                me->Kill(me);
+            }
+
+            void UpdateAI(const uint32 /*uiDiff*/)
+            {
+                if(!uiTargetGUID)
+                    return;
+
+                if (Player* IceTomb = ObjectAccessor::GetPlayer(*me, uiTargetGUID))
+                    if (!IceTomb->HasAura(SPELL_ICE_TOMB))
+                        me->Kill(me);
+            }
+
+        private:
+            uint64 uiTargetGUID;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_ice_tombAI(creature);
+        }
+};
+
+class npc_rimefang : public CreatureScript
+{
+    public:
+        npc_rimefang() : CreatureScript("npc_rimefang") { }
+
+        struct npc_rimefangAI: public ScriptedAI
+        {
+            npc_rimefangAI(Creature* creature) : ScriptedAI(creature)
+            {
+                instance = creature->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                uiFrostBreathTimer = 5000;
+                uiIceBlastTimer = 7000;
+                me->SetFlying(true);
+            }
+
+            void EnterCombat(Unit* /*who*/)
+            {
+                DoCast(me, SPELL_FROST_AURA_ADD);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                if(instance)
+                    if(instance->GetData(DATA_SINDRAGOSA) != DONE)
+                        instance->SetData(DATA_SPAWN, +1);
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (uiFrostBreathTimer <= uiDiff)
+                {
+                    DoCastVictim( SPELL_FROST_BREATH_ADD);
+                    uiFrostBreathTimer = 6000;
+                } else uiFrostBreathTimer -= uiDiff;
+
+                if (uiIceBlastTimer <= uiDiff)
+                {
+                    DoCast(me, SPELL_ICE_BLAST);
+                    uiIceBlastTimer = 8000;
+                } else uiIceBlastTimer -= uiDiff;
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            InstanceScript* instance;
+
+            uint32 uiFrostBreathTimer;
+            uint32 uiIceBlastTimer;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_rimefangAI(creature);
+        }
+};
+
+class npc_spinestalker : public CreatureScript
+{
+    public:
+        npc_spinestalker() : CreatureScript("npc_spinestalker") { }
+
+        struct npc_spinestalkerAI: public ScriptedAI
+        {
+            npc_spinestalkerAI(Creature* creature) : ScriptedAI(creature)
+            {
+                instance = creature->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                uiRoarTimer = 14000;
+                uiCleaveTimer = 6000;
+                uiSweepTimer = 7000;
+                me->SetFlying(true);
+            }
+
+            void EnterCombat(Unit* /*who*/)
+            {
+                DoCast(me, SPELL_FROST_AURA_ADD);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                if(instance)
+                    if(instance->GetData(DATA_SINDRAGOSA) != DONE)
+                        instance->SetData(DATA_SPAWN, +1);
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (uiRoarTimer <= uiDiff)
+                {
+                    DoCastAOE(SPELL_BELLOWING_ROAR);
+                    uiRoarTimer = 15000;
+                } else uiRoarTimer -= uiDiff;
+
+                if (uiCleaveTimer <= uiDiff)
+                {
+                    DoCastVictim( SPELL_CLEAVE_ADD);
+                    uiCleaveTimer = 5000;
+                } else uiCleaveTimer -= uiDiff;
+
+                if (uiSweepTimer <= uiDiff)
+                {
+                    DoCast(SPELL_TAIL_SWEEP);
+                    uiSweepTimer = 7000;
+                } else uiSweepTimer -= uiDiff;
+
+                DoMeleeAttackIfReady();
+            }
+        private:
+            InstanceScript* instance;
+
+            uint32 uiRoarTimer;
+            uint32 uiCleaveTimer;
+            uint32 uiSweepTimer;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_spinestalkerAI(creature);
+        }
+};
+
+class spell_sindragosa_ice_tomb : public SpellScriptLoader
+{
+    public:
+        spell_sindragosa_ice_tomb() : SpellScriptLoader("spell_sindragosa_ice_tomb") { } //70157
+
+
+        class spell_sindragosa_ice_tomb_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_sindragosa_ice_tomb_AuraScript)
+
+            void OnRemove(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                if(Unit* beacon = GetCaster())
+                {
+                    if (InstanceScript* instance = GetOwner()->GetInstanceScript())
+                        if (Creature* sindragosa = Unit::GetCreature(*GetOwner(), instance->GetData64(DATA_SINDRAGOSA)))
+                            if(sindragosa->isAlive())
+                                sindragosa->CastSpell(beacon, SPELL_ICE_TOMB, true);
+
+                    beacon->CastSpell(beacon, SPELL_ASPHYXATION, true);
+                    Creature* tomb = beacon->SummonCreature(CREATURE_ICE_TOMB, beacon->GetPositionX(), beacon->GetPositionY(), beacon->GetPositionZ(), 0, TEMPSUMMON_CORPSE_DESPAWN);
+                    if(tomb)
+                        tomb->AI()->SetGUID(beacon->GetGUID());
+                }
+            }
+
+            void Register()
+            {
+                OnEffectRemove += AuraEffectRemoveFn(spell_sindragosa_ice_tomb_AuraScript::OnRemove, EFFECT_2, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_sindragosa_ice_tomb_AuraScript();
+        }
+};
+
+class spell_sindragosa_mystic_buffet : public SpellScriptLoader
+{
+    public:
+        spell_sindragosa_mystic_buffet() : SpellScriptLoader("spell_sindragosa_mystic_buffet") { } //70127
+
+
+        class spell_sindragosa_mystic_buffet_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_sindragosa_mystic_buffet_AuraScript)
+
+            void OnApply(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                if (InstanceScript* instance = GetOwner()->GetInstanceScript())
+                    if(GetStackAmount() >= 5)
+                        instance->SetData(DATA_ALL_YOU_CAN_EAT, FAIL);
+                    else
+                        instance->SetData(DATA_ALL_YOU_CAN_EAT, DONE);
+            }
+
+            void Register()
+            {
+                OnEffectApply += AuraEffectApplyFn(spell_sindragosa_mystic_buffet_AuraScript::OnApply, EFFECT_0, SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_sindragosa_mystic_buffet_AuraScript();
+        }
+};
+
+class spell_sindragosa_unchained_magic : public SpellScriptLoader
+{
+    public:
+        spell_sindragosa_unchained_magic() : SpellScriptLoader("spell_sindragosa_unchained_magic") { } //69766
+
+
+        class spell_sindragosa_unchained_magic_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_sindragosa_unchained_magic_AuraScript)
+
+            void OnRemove(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                Unit* caster = GetCaster();
+                if (!caster)
+                    return;
+
+                int32 damage = (GetStackAmount() * 2000);
+                GetTarget()->CastCustomSpell(71044, SPELLVALUE_BASE_POINT0, damage, GetTarget(), true, NULL, aurEff, GetCasterGUID());
+            }
+
+            void Register()
+            {
+                OnEffectRemove += AuraEffectRemoveFn(spell_sindragosa_unchained_magic_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_sindragosa_unchained_magic_AuraScript();
+        }
+};
+
+void AddSC_boss_sindragosa()
+{
+    new boss_sindragosa();
+    new npc_spinestalker();
+    new npc_rimefang();
+    new npc_ice_tomb();
+    new spell_sindragosa_ice_tomb();
+    new spell_sindragosa_mystic_buffet(); //for achievement
+    new spell_sindragosa_unchained_magic();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
new file mode 100644
index 0000000..86024c3
--- /dev/null
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
@@ -0,0 +1,1366 @@
+/*
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include "ObjectMgr.h"
+#include "ScriptMgr.h"
+#include "ScriptedCreature.h"
+#include "SpellScript.h"
+#include "SpellAuraEffects.h"
+#include "icecrown_citadel.h"
+
+#define GOSSIP_MENU 10600
+//#define GOSSIP_MENU "Long have I waited for this day, hero. Are you and your allies prepared to bring the Lich King to justice? We charge on your command!"
+#define GOSSIP_START_EVENT "We are prepared, Highlord. Let us battle for the fate of Azeroth! For the light of dawn!"
+
+enum Yells
+{
+    SAY_INTRO_1_KING         = -1810001,
+    SAY_INTRO_2_TIRION       = -1810002,
+    SAY_INTRO_3_KING         = -1810003,
+    SAY_INTRO_4_TIRION       = -1810004,
+    SAY_INTRO_5_KING         = -1810005,
+    SAY_AGGRO                = -1810006,
+    SAY_REMORSELESS_WINTER   = -1810007,
+    SAY_RANDOM_1             = -1810008,
+    SAY_RANDOM_2             = -1810009,
+    SAY_KILL_1               = -1810010,
+    SAY_KILL_2               = -1810011,
+    SAY_BERSERK              = -1810012,
+    SAY_ENDING_1_KING        = -1810013,
+    SAY_ENDING_2_KING        = -1810014,
+    SAY_ENDING_3_KING        = -1810015,
+    SAY_ENDING_4_KING        = -1810016,
+    SAY_ENDING_5_TIRION      = -1810017,
+    SAY_ENDING_6_KING        = -1810018,
+    SAY_ENDING_8_TIRION      = -1810020,
+    SAY_ENDING_9_FATHER      = -1810021,
+    SAY_ENDING_10_TIRION     = -1810022,
+    SAY_ENDING_11_FATHER     = -1810023,
+    SAY_ENDING_12_KING       = -1810024,
+    SAY_DEATH_KING           = -1810025,
+    SAY_ESCAPE_FROSTMOURNE   = -1810026,
+    SAY_HARVEST_SOUL         = -1810027,
+    SAY_DEVOURED_FROSTMOURNE = -1810028,
+    SAY_SUMMON_VALKYR        = -1810029,
+    SAY_BROKEN_ARENA         = -1810030,
+    SAY_10_PROZENT           = -1810031,
+    SAY_EMOTE_DEFILE         = -1810032,
+};
+
+enum Spells
+{
+    SPELL_SUMMON_SHAMBLING_HORROR    = 70372,
+    SPELL_SUMMON_DRUDGE_GHOULS       = 70358,
+    SPELL_SUMMON_ICE_SPEHERE         = 69104,
+    SPELL_SUMMON_RAGING_SPIRIT       = 69200,
+    SPELL_SUMMON_VALKYR              = 74361,
+    SPELL_SUMMON_DEFILE              = 72762,
+    SPELL_SUMMON_VILE_SPIRIT         = 70498, //????????
+    SPELL_SUMMON_BROKEN_FROSTMOURNE  = 72406,
+    SPELL_SUMMON_SHADOW_TRAP         = 73539,
+    SPELL_INFEST                     = 70541,
+    SPELL_NECROTIC_PLAGUE            = 70337, //70337 - initial cast
+    SPELL_NECROTIC_PLAGUE_IMMUNITY   = 72846,
+    SPELL_PLAGUE_SIPHON              = 74074,
+    SPELL_REMORSELES_WINTER          = 68981,
+    SPELL_REMORSELES_WINTER_DAMAGE   = 68983,
+    SPELL_PAIN_AND_SUFFERING         = 74115,
+    //SPELL_RANDOM_TALK                = 73985,
+    SPELL_WINGS_OF_THE_DAMNED        = 74352,
+    SPELL_SOUL_REAPER                = 69409,
+    SPELL_SOUL_REAPER_HASTE_AURA     = 69410,
+    SPELL_HARVEST_SOUL_TELEPORT      = 71372, //72597
+    SPELL_HARVEST_SOULS              = 68980,
+    SPELL_QUAKE                      = 72262,
+    SPELL_CHANNEL_KING               = 71769,
+    SPELL_BROKEN_FROSTMOURNE         = 72398,
+    SPELL_BOOM_VISUAL                = 72726,
+    SPELL_ICEBLOCK_TRIGGER           = 71614,
+    SPELL_TIRION_LIGHT               = 71797,
+    SPELL_FROSTMOURNE_TRIGGER        = 72405,
+    SPELL_DISENGAGE                  = 61508,
+    SPELL_FURY_OF_FROSTMOURNE        = 72350,
+    SPELL_REVIVE                     = 72429,
+    SPELL_REVIVE_EFFECT              = 72423,
+    SPELL_CLONE_PLAYER               = 57507,
+    SPELL_DEFILE                     = 72743,
+    SPELL_ICE_PULSE                  = 69091,
+    SPELL_ICE_BURST                  = 69108,
+    SPELL_LIFE_SIPHON                = 73783,
+    SPELL_SOUL_SHRIEK                = 69242,
+    SPELL_WHOCKVAWE                  = 72149,
+    SPELL_ENRAGE                     = 72143,
+    SPELL_BURST                      = 70503,
+    SPELL_VILE_SPIRIT_DISTANCE_CHECK = 70502,
+    SPELL_ICE_BURST_DISTANCE_CHECK   = 69109,
+    SPELL_VILE_SPIRIT_ACTIVE         = 72130,
+    SPELL_RAGING_VISUAL              = 69198,
+    SPELL_REMOVE_WEAPON              = 72399,
+    SPELL_DROP_FROSTMOURNE           = 73017,
+    SPELL_SUMMON_FROSTMOURNE_TRIGGER = 72407,
+    SPELL_WMO_INTACT                 = 50176,
+    SPELL_WMO_DAMAGE                 = 50177,
+    SPELL_PLAY_MOVIE                 = 73159,
+    SPELL_SUMMON_MENETHIL            = 72420, //caster - 38584
+    SPELL_MENETHIL_VISUAL            = 72372,
+    SPELL_VALKYR_CARRY_CAN_CAST      = 74506,
+    SPELL_VALKYR_MOVE_PLAYER         = 68985, //74445
+    SPELL_VALKYR_TARGET_SEARCH       = 69030,
+    SPELL_VALKYR_CHARGE              = 74399,
+    SPELL_VALYR_EJECT_PASSANGER      = 68576,
+    SPELL_LIGH_EFFECT                = 71773,
+    SPELL_EMOTE_SHOUT                = 73213,
+    SPELL_RAGING_GHOUL_VISUAL        = 69636,
+    SPELL_RISEN_WITCH_DOCTOR_SPAWN   = 69639,
+    SPELL_ICE_SPHERE_VISUAL          = 69090,
+    SPELL_TIRION_JUMP                = 71809,
+    SPELL_LICH_KING_STOP_CAST_RES    = 72431,
+    SPELL_FROSTMOURNE_DESPAWN        = 72726,
+    SPELL_SUMMON_FROSTMOURNE         = 74081,
+    SPELL_SOUL_EFFECT                = 72305,
+
+    //SPELL_70501 //Vile Spirit Move Target Search
+};
+
+enum eActions
+{
+    ACTION_PHASESWITCH_1        = 1, //phase 1 and 3
+    ACTION_PHASESWITCH_2        = 2, //phase 2 and 4
+    ACTION_START_EVENT          = 3
+};
+
+enum ePoints
+{
+    POINT_START_EVENT_1              = 3659700,
+    POINT_PLATFORM_CENTRE            = 3659701,
+    POINT_PLATFORM_END               = 3659702,
+    POINT_VALKYR_END                 = 3659703,
+    POINT_VALKYR_ZET                 = 3659704
+};
+
+struct Position StartEvent[]=
+{
+    {465.0731f, -2123.473f, 1040.8569f},
+    {462.8351f, -2123.673f, 1040.9082f},
+    {461.5851f, -2123.673f, 1041.4082f},
+    {445.5851f, -2123.673f, 1056.1582f},
+    {436.0851f, -2123.673f, 1064.6582f}
+};
+
+struct Position MovePos[]=
+{
+    {461.792f, -2125.85f, 1040.860f, 0.0f}, // move
+    {503.156f, -2124.51f, 1040.860f, 0.0f}, // move center X: 505.2118 Y: -2124.353 Z: 840.9403
+    {490.110f, -2124.98f, 1040.860f, 0.0f}, // move tirion frostmourne
+    {467.069f, -2123.58f, 1040.857f, 0.0f}, // move tirion attack
+    {498.004f, 2201.57f, 1046.093f, 0.0f},  // move valkyr
+    {489.297f, -2124.84f, 1040.857f, 0.0f}, //start event tirion move 1
+    {503.682f, -2126.63f, 1040.940f, 0.0f}, //   
+    {508.989f, -2124.55f, 1045.356f, 0.0f} //   
+};
+
+/*struct Locations
+{
+    float x,y,z;
+};
+
+static Locations TeleportPoint[]=
+{
+    {959.996f, 212.576f, 193.843f},
+    {932.537f, 231.813f, 193.838f},
+    {958.675f, 254.767f, 193.822f},
+    {946.955f, 201.316f, 192.535f},
+    {944.294f, 149.676f, 197.551f},
+    {930.548f, 284.888f, 193.367f},
+    {965.997f, 278.398f, 195.777f},
+};*/
+
+class boss_the_lich_king : public CreatureScript
+{
+    public:
+        boss_the_lich_king() : CreatureScript("boss_the_lich_king") { }
+
+        struct boss_the_lich_kingAI : public BossAI
+        {
+            boss_the_lich_kingAI(Creature* creature) : BossAI(creature, DATA_LICH_KING), summons(me)
+            {
+                instance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                me->SetReactState(REACT_PASSIVE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+                uiPhase = 1;
+                uiRandomSpeechTimer = 33000;
+                uiBerserkTimer = 900000;
+                uiSummonShamblingHorrorTimer = 20000;
+                uiSummonDrudgeGhoulsTimer = 30000;
+                uiInfestTimer = 30000;
+                uiNecroticPlagueTimer = 30000;
+                uiIcePulsSummonTimer = 10000;
+                uiSummonSpiritTimer = 25000;
+                uiSummonValkyrTimer = 5000;
+                uiSoulReaperTimer = 30000;
+                uiDefileTimer = 25000;
+                uiInfestTimer = 40000;
+                uiSummonVileSpiritTimer = 30000;
+                uiHarvestSoulTimer = 70000;
+                uiSummonShadowTrap = 20000;
+                uiEndingTimer = 1000;
+                uiStage = 1;
+                uiTirionGUID = 0;
+
+                if(!instance)
+                    return;
+
+                instance->SetData(DATA_LICH_KING_EVENT, NOT_STARTED);
+                instance->SetData(DATA_BEEN_WAITING, NOT_STARTED);
+                instance->SetData(DATA_NECK_DEEP, DONE);
+
+                if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
+                    me->GetMotionMaster()->MovementExpired();
+
+                if(SpellEntry* spellRevive = GET_SPELL(SPELL_SUMMON_DEFILE))
+                    spellRevive->DurationIndex = 3;
+
+                if(SpellEntry* lock = GET_SPELL(SPELL_ICEBLOCK_TRIGGER))
+                    lock->Targets = 6; //target chain damage
+
+                if(SpellEntry* reaper = GET_SPELL(SPELL_SOUL_REAPER_HASTE_AURA))
+                    reaper->Targets = 1;
+
+                if(SpellEntry* plague = GET_SPELL(SPELL_PLAGUE_SIPHON)) //hack
+                    plague->Targets = 18;
+
+                if(SpellEntry* raging = GET_SPELL(SPELL_SUMMON_RAGING_SPIRIT))
+                {
+                    raging->DurationIndex = 28;
+                    raging->Effect[0] = 6;
+                }
+            }
+
+            void EnterCombat(Unit* /*pWho*/)
+            {
+                DoScriptText(SAY_AGGRO, me);
+                DoCast(me, SPELL_NECROTIC_PLAGUE_IMMUNITY);
+                if(instance)
+                    uiTirionGUID = instance->GetData64(DATA_TIRION);
+
+                if(instance)
+                    instance->SetData(DATA_LICH_KING_EVENT, IN_PROGRESS);
+            }
+
+            void JustDied(Unit* /*pKiller*/)
+            {
+                if(!instance)
+                    return;
+
+                DoScriptText(SAY_DEATH_KING, me);
+                DoCast(SPELL_PLAY_MOVIE);
+                instance->SetData(DATA_LICH_KING_EVENT, DONE);
+                if(instance->GetData(DATA_BEEN_WAITING) == DONE)
+                    instance->DoCompleteAchievement(RAID_MODE(ACHIEV_BEEN_WAITING_A_LONG_TIME_FOR_THIS_10,ACHIEV_BEEN_WAITING_A_LONG_TIME_FOR_THIS_25));
+                if(instance->GetData(DATA_NECK_DEEP) == FAIL)
+                    instance->DoCompleteAchievement(RAID_MODE(ACHIEV_NECK_DEEP_IN_VILE_10,ACHIEV_NECK_DEEP_IN_VILE_25));
+
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_INFEST);
+
+                summons.DespawnAll();
+            }
+
+            void MovementInform(uint32 type, uint32 id)
+            {
+                if(type != POINT_MOTION_TYPE)
+                    return;
+
+                switch(id)
+                {
+                    case POINT_PLATFORM_CENTRE:
+                        DoScriptText(SAY_REMORSELESS_WINTER, me);
+                        DoCast(me, SPELL_REMORSELES_WINTER);
+                        DoCast(me, SPELL_PAIN_AND_SUFFERING);
+                        DoCast(me, SPELL_WMO_INTACT);
+                        me->GetMotionMaster()->MovementExpired();
+                        break;
+                }
+            }
+
+            void JustReachedHome()
+            {
+                if(!instance)
+                    return;
+
+                instance->SetData(DATA_LICH_KING_EVENT, FAIL);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_INFEST);
+
+                if(uiTirionGUID)
+                    if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                        tirion->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+
+                summons.DespawnAll();
+            }
+
+            void KilledUnit(Unit* victim)
+            {
+                if (uiPhase != 6 && victim->GetTypeId() == TYPEID_PLAYER)
+                    DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2), me);
+            }
+
+            void JustSummoned(Creature* summoned)
+            {
+                summons.Summon(summoned);
+                switch(summoned->GetEntry())
+                {
+                    case CREATURE_ICE_SPHERE:
+                        summoned->CastSpell(summoned, SPELL_ICE_BURST_DISTANCE_CHECK, true);
+                        summoned->CastSpell(summoned, SPELL_ICE_PULSE, true);
+                        summoned->CastSpell(summoned, SPELL_ICE_SPHERE_VISUAL, true);
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                        {
+                            summoned->AI()->AttackStart(target);
+                            summoned->GetMotionMaster()->MoveChase(target);
+                        }
+                        break;
+                    case CREATURE_DEFILE:
+                        summoned->CastSpell(summoned, SPELL_DEFILE, true);
+                        summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        break;
+                    case CREATURE_RAGING_SPIRIT:
+                        summoned->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+                        summoned->getVictim()->CastSpell(summoned, SPELL_RAGING_VISUAL, true);
+                        summoned->CastSpell(summoned, SPELL_NECROTIC_PLAGUE_IMMUNITY, true);
+                        break;
+                    case CREATURE_VILE_SPIRIT:
+                        summoned->CastSpell(summoned, SPELL_VILE_SPIRIT_DISTANCE_CHECK, true);
+                        break;
+                    case CREATURE_TRIGGER:
+                        summoned->AI()->AttackStart(me);
+                        summoned->SetVisible(false);
+                        summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        break;
+                    case CREATURE_FROSTMOURNE_TRIGGER:
+                        summoned->CastSpell(summoned, SPELL_BROKEN_FROSTMOURNE, false);
+                        summoned->CastSpell(summoned, SPELL_FROSTMOURNE_TRIGGER, false);
+                        summoned->SetVisible(false);
+                        break;
+                    case CREAUTRE_MENETHIL:
+                        DoScriptText(SAY_ENDING_9_FATHER, summoned);
+                        summoned->CastSpell(summoned, SPELL_REVIVE, true);
+                        summoned->CastSpell(summoned, SPELL_MENETHIL_VISUAL, true);
+                        break;
+                    case CREATURE_VALKYR:
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            summoned->AI()->AttackStart(target);
+                        summoned->CastSpell(summoned, SPELL_WINGS_OF_THE_DAMNED, true);
+                        summoned->CastSpell(summoned, SPELL_VALKYR_CARRY_CAN_CAST, true);
+                        break;
+                    case CREATURE_DRUDGE_GHOUL:
+                        summoned->CastSpell(summoned, SPELL_RAGING_GHOUL_VISUAL, true);
+                        break;
+                    case CREATURE_SHAMBLING_HORROR:
+                        summoned->CastSpell(summoned, SPELL_RISEN_WITCH_DOCTOR_SPAWN, true);
+                        break;
+                }
+            }
+
+            void DoAction(const int32 action)
+            {
+                switch(action)
+                {
+                    case ACTION_PHASESWITCH_1:
+                        me->SetReactState(REACT_PASSIVE);
+                        me->AttackStop();
+                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        SetCombatMovement(false);
+                        me->SetInCombatWithZone();
+                        me->GetMotionMaster()->MovePoint(POINT_PLATFORM_CENTRE, MovePos[1]);
+                        break;
+                    case ACTION_PHASESWITCH_2:
+                        uiPhase = uiPhase == 2 ? 3 : 5;
+                        me->SetReactState(REACT_AGGRESSIVE);
+                        me->RemoveAurasDueToSpell(SPELL_PAIN_AND_SUFFERING);
+                        me->SetInCombatWithZone();
+                        SetCombatMovement(true);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        break;
+                }
+            }
+
+            void DamageTaken(Unit* /*done_by*/, uint32& /*damage*/)
+            {
+                switch(uiPhase)
+                {
+                    case 1:
+                        if(!HealthAbovePct(71))
+                        {
+                            uiPhase = 2;
+                            DoAction(ACTION_PHASESWITCH_1);
+                            break;
+                        }
+                    case 3:
+                        if(!HealthAbovePct(41))
+                        {
+                            uiPhase = 4;
+                            DoAction(ACTION_PHASESWITCH_1);
+                            break;
+                        }
+                    case 5:
+                        if(!HealthAbovePct(11))
+                        {
+                            me->SummonCreature(CREATURE_TRIGGER, MovePos[6], TEMPSUMMON_CORPSE_DESPAWN, 900000);
+                            summons.DespawnAll();
+                            uiPhase = 6; //ending
+                        }
+                        break;
+                }
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if(uiPhase != 6)
+                {
+                    if (uiRandomSpeechTimer < uiDiff)
+                    {
+                        DoScriptText(RAND(SAY_RANDOM_1,SAY_RANDOM_2), me);
+                        uiRandomSpeechTimer = 33000;
+                    } else uiRandomSpeechTimer -= uiDiff;
+
+                    if (uiBerserkTimer < uiDiff)
+                    {
+                        DoScriptText(SAY_BERSERK, me);
+                        DoCast(me, SPELL_BERSERK);
+                        uiBerserkTimer = 900000;
+                    } else uiBerserkTimer -= uiDiff;
+                }
+
+                if(uiPhase == 1)
+                {
+                    if (IsHeroic())
+                    {
+                        if (uiSummonShadowTrap < uiDiff)
+                        {
+                            if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                                DoCast(target, SPELL_SUMMON_SHADOW_TRAP, true);
+                            uiSummonShadowTrap = 30000;
+                        } else uiSummonShadowTrap -= uiDiff;
+                    }
+
+                    if (uiInfestTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_INFEST);
+                        uiInfestTimer = 30000;
+                    } else uiInfestTimer -= uiDiff;
+
+                    if (uiSummonDrudgeGhoulsTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_DRUDGE_GHOULS);
+                        uiSummonDrudgeGhoulsTimer = 20000;
+                    } else uiSummonDrudgeGhoulsTimer -= uiDiff;
+
+                    if (uiSummonShamblingHorrorTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_SHAMBLING_HORROR);
+                        uiSummonShamblingHorrorTimer = 30000;
+                    } else uiSummonShamblingHorrorTimer -= uiDiff;
+
+                    if (uiNecroticPlagueTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_NECROTIC_PLAGUE);
+                    } else uiNecroticPlagueTimer -= uiDiff;
+                }
+
+                if(uiPhase == 2) //transition phase 1
+                {
+                    if (uiSummonSpiritTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_SUMMON_RAGING_SPIRIT);
+                        uiSummonSpiritTimer = 20000;
+                    } else uiSummonSpiritTimer -= uiDiff;
+
+                    if (uiIcePulsSummonTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_ICE_SPEHERE);
+                        uiIcePulsSummonTimer = 15000;
+                    } else uiIcePulsSummonTimer -= uiDiff;
+                }
+
+                if(uiPhase == 3)
+                {
+                    if (uiDefileTimer < uiDiff)
+                    {
+                        DoScriptText(SAY_EMOTE_DEFILE, me);
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))
+                            DoCast(target, SPELL_SUMMON_DEFILE);
+                        uiDefileTimer = 20000;
+                    } else uiDefileTimer -= uiDiff;
+
+                    if (uiSummonValkyrTimer < uiDiff)
+                    {
+                        DoScriptText(SAY_SUMMON_VALKYR, me);
+                        DoCast(SPELL_SUMMON_VALKYR);
+                        uiSummonValkyrTimer = 35000;
+                        uiDefileTimer = 5000; //cast defile after cast valkyr summon
+                    } else uiSummonValkyrTimer -= uiDiff;
+
+                    if (uiSoulReaperTimer < uiDiff)
+                    {
+                        DoCastVictim(SPELL_SOUL_REAPER);
+                        DoCast(SPELL_SOUL_REAPER_HASTE_AURA);
+                        uiSoulReaperTimer = 30000;
+                    } else uiSoulReaperTimer -= uiDiff;
+
+                    if (uiInfestTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_INFEST);
+                        uiInfestTimer = 30000;
+                    } else uiInfestTimer -= uiDiff;
+                }
+
+                if(uiPhase == 4) //transition phase 2
+                {
+                    if (uiSummonSpiritTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_SUMMON_RAGING_SPIRIT);
+                        uiSummonSpiritTimer = 25000;
+                    } else uiSummonSpiritTimer -= uiDiff;
+
+                    if (uiIcePulsSummonTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_ICE_SPEHERE);
+                        uiIcePulsSummonTimer = 15000;
+                    } else uiIcePulsSummonTimer -= uiDiff;
+                }
+
+                if(uiPhase == 5)
+                {
+                    if (uiSummonVileSpiritTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_VILE_SPIRIT);
+                        uiSummonVileSpiritTimer = 30000;
+                    } else uiSummonVileSpiritTimer -= uiDiff;
+
+                    if (uiHarvestSoulTimer < uiDiff)
+                    {
+                        DoScriptText(SAY_HARVEST_SOUL, me);
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_HARVEST_SOULS);
+                        uiHarvestSoulTimer = 70000;
+                    } else uiHarvestSoulTimer -= uiDiff;
+
+                    if (uiSoulReaperTimer < uiDiff)
+                    {
+                        DoCastVictim(SPELL_SOUL_REAPER);
+                        DoCast(SPELL_SOUL_REAPER_HASTE_AURA);
+                        uiSoulReaperTimer = 30000;
+                    } else uiSoulReaperTimer -= uiDiff;
+
+                    if (uiDefileTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))
+                            DoCast(target, SPELL_SUMMON_DEFILE);
+                        uiDefileTimer = 20000;
+                    } else uiDefileTimer -= uiDiff;
+                }
+
+                if(uiPhase == 6)
+                {
+                    if (uiEndingTimer <= uiDiff)
+                    {
+                        switch(uiStage)
+                        {
+                            case 1:
+                                me->GetMotionMaster()->MoveIdle();
+                                me->SetReactState(REACT_PASSIVE);
+                                me->AttackStop();
+                                me->CastStop();
+                                me->SetInCombatWithZone();
+                                DoScriptText(SAY_10_PROZENT, me);
+                                DoCast(SPELL_FURY_OF_FROSTMOURNE);
+                                uiEndingTimer = 15000;
+                                break;
+                            case 2:
+                                DoScriptText(SAY_ENDING_1_KING, me);
+                                uiEndingTimer = 24000;
+                                break;
+                            case 3:
+                                DoScriptText(SAY_ENDING_2_KING, me);
+                                uiEndingTimer = 25000;
+                                break;
+                            case 4:
+                                me->GetMotionMaster()->MovePoint(0, MovePos[1]);
+                                uiEndingTimer = 4000;
+                                break;
+                            case 5:
+                                DoScriptText(SAY_ENDING_3_KING, me);
+                                DoCast(me, SPELL_CHANNEL_KING);
+                                me->HandleEmoteCommand(EMOTE_ONESHOT_LAUGH);
+                                uiEndingTimer = 28000;
+                                break;
+                            case 6:
+                                DoScriptText(SAY_ENDING_4_KING, me);
+                                uiEndingTimer = 8000;
+                                break;
+                            case 7:
+                            {
+                                if(uiTirionGUID)
+                                    if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                                        DoScriptText(SAY_ENDING_5_TIRION, tirion);
+                                uiEndingTimer = 11000;
+                                break;
+                            }
+                            case 8:
+                            {
+                                if(uiTirionGUID)
+                                    if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                                        tirion->CastSpell(tirion, SPELL_TIRION_LIGHT, true);
+                                uiEndingTimer = 7000;
+                                break;
+                            }
+                            case 9:
+                            {
+                                if(uiTirionGUID)
+                                    if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                                        tirion->GetMotionMaster()->MovePoint(0, MovePos[2]);
+                                uiEndingTimer = 1000;
+                                break;
+                            }
+                            case 10:
+                            {
+                                if(uiTirionGUID)
+                                {
+                                    if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                                    {
+                                        tirion->GetMotionMaster()->MoveJump(517.482910f, -2124.905762f, 1040.861328f, 10.0f, 15.0f);
+                                        tirion->SetUInt32Value(UNIT_NPC_EMOTESTATE, 375);
+                                    }
+                                }
+                                uiEndingTimer = 1000;
+                                break;
+                            }
+                            case 11:
+                                me->RemoveAura(SPELL_CHANNEL_KING);
+                                me->CastSpell(me, SPELL_BOOM_VISUAL, false);
+                                uiEndingTimer = 3000;
+                                break;
+                            case 12:
+                                DoCast(me, SPELL_DROP_FROSTMOURNE);
+                                uiEndingTimer = 1000;
+                                break;
+                            case 13:
+                                DoScriptText(SAY_ENDING_6_KING, me);
+                                uiEndingTimer = 3000;
+                                break;
+                            case 14:
+                                DoCast(me, SPELL_SUMMON_FROSTMOURNE_TRIGGER);
+                                DoCast(me, SPELL_REMOVE_WEAPON);
+                                uiEndingTimer = 2000;
+                                break;
+                            case 15:
+                                me->RemoveAllAuras();
+                                DoPlaySoundToSet(me, SOUND_ENDING_7_KING);
+                                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, 473);
+                                uiEndingTimer = 5000;
+                                break;
+                            case 16:
+                                DoScriptText(SAY_ENDING_8_TIRION, me);
+                                uiEndingTimer = 6000;
+                                break;
+                            case 17:
+                                DoCast(SPELL_SUMMON_MENETHIL);
+                                uiEndingTimer = 3000;
+                                break;
+                            case 18:
+                                DoScriptText(SAY_ENDING_11_FATHER, me);
+                                uiEndingTimer = 6000;
+                                break;
+                            case 19:
+                                DoScriptText(SAY_ENDING_10_TIRION, me);
+                                uiEndingTimer = 5000;
+                                break;
+                            case 20:
+                                {
+                                    DoScriptText(SAY_ENDING_12_KING, me);
+                                    if(uiTirionGUID)
+                                    {
+                                        if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                                        {
+                                            tirion->SetReactState(REACT_AGGRESSIVE);
+                                            tirion->AI()->AttackStart(me);
+                                        }
+                                    }
+                                    if(Creature* father = me->FindNearestCreature(CREAUTRE_MENETHIL, 25.0f, true))
+                                        father->AI()->AttackStart(me);
+                                    uiEndingTimer = 5000;
+                                    break;
+                                }
+                        }
+                        ++uiStage;
+                    } else uiEndingTimer -= uiDiff;
+                }
+
+                DoMeleeAttackIfReady();
+            }
+        private:
+            InstanceScript* instance;
+
+            uint8 uiStage;
+            uint8 uiPhase;
+
+            uint32 uiEndingTimer;
+            uint32 uiSummonShamblingHorrorTimer;
+            uint32 uiSummonDrudgeGhoulsTimer;
+            uint32 uiSummonShadowTrap;
+            uint32 uiInfestTimer;
+            uint32 uiNecroticPlagueTimer;
+            uint32 uiBerserkTimer;
+            uint32 uiSummonValkyrTimer;
+            uint32 uiSoulReaperTimer;
+            uint32 uiDefileTimer;
+            uint32 uiHarvestSoulTimer;
+            uint32 uiSummonVileSpiritTimer;
+            uint32 uiIcePulsSummonTimer;
+            uint32 uiSummonSpiritTimer;
+            uint32 uiRandomSpeechTimer;
+            uint64 uiTirionGUID;
+
+            SummonList summons;
+
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new boss_the_lich_kingAI(creature);
+        }
+};
+
+class npc_tirion_icc : public CreatureScript
+{
+    public:
+        npc_tirion_icc() : CreatureScript("npc_tirion_icc") { }
+
+        struct npc_tirion_iccAI : public ScriptedAI
+        {
+            npc_tirion_iccAI(Creature* creature) : ScriptedAI(creature)
+            {
+                instance = creature->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                uiIntroTimer = 1000;
+                uiStage = 1;
+                uiLichKingGUID = 0;
+                bIntro = false;
+
+                me->SetReactState(REACT_PASSIVE);
+                me->SetSpeed(MOVE_RUN, 1.8f);
+                me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+            }
+
+            void DoAction(const int32 action)
+            {
+                if(action == ACTION_START_EVENT)
+                {
+                    bIntro = true;
+                    if(instance)
+                        uiLichKingGUID = instance->GetData64(DATA_LICH_KING);
+                }
+            }
+
+            void SpellHit(Unit* /*caster*/, const SpellEntry * spell)
+            {
+                if(spell->Id == SPELL_LIGH_EFFECT)
+                    me->RemoveAurasDueToSpell(SPELL_ICEBLOCK_TRIGGER);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if(!bIntro || !uiLichKingGUID)
+                    return;
+
+                if(uiIntroTimer <= diff)
+                {
+                    switch(uiStage)
+                    {
+                        case 1:
+                            {
+                                if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                {
+                                    lich->SetStandState(UNIT_STAND_STATE_STAND);
+                                    lich->GetMotionMaster()->MovePoint(POINT_START_EVENT_1, MovePos[0]);
+                                }
+                                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_READY2H);
+                                uiIntroTimer = 3000;
+                                break;
+                            }
+                        case 2:
+                        {
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_TALK);
+                            DoScriptText(SAY_INTRO_1_KING, me);
+                            uiIntroTimer = 14000;
+                            break;
+                        }
+                        case 3:
+                        {
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_NONE);
+                            DoScriptText(SAY_INTRO_2_TIRION, me);
+                            uiIntroTimer = 9000;
+                            break;
+                        }
+                        case 4:
+                        {
+                            DoScriptText(SAY_INTRO_3_KING, me);
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_LAUGH);
+                            uiIntroTimer = 3000;
+                            break;
+                        }
+                        case 5:
+                        {
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_POINT_NOSHEATHE);
+                            uiIntroTimer = 2000;
+                            break;
+                        }
+                        case 6:
+                        {
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_NONE);
+                            uiIntroTimer = 18000;
+                            break;
+                        }
+                        case 7:
+                            me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_POINT_NOSHEATHE);
+                            DoScriptText(SAY_INTRO_4_TIRION, me);
+                            uiIntroTimer = 1000;
+                            break;
+                        case 8:
+                            me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_NONE);
+                            me->GetMotionMaster()->MovePoint(0, MovePos[3]);
+                            uiIntroTimer = 2000;
+                            break;
+                        case 9:
+                        {
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->CastSpell(me, SPELL_ICEBLOCK_TRIGGER, true);
+                            uiIntroTimer = 2000;
+                            break;
+                        }
+                        case 10:
+                        {
+                            DoScriptText(SAY_INTRO_5_KING, me);
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                            {
+                                lich->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                lich->SetReactState(REACT_AGGRESSIVE);
+                                if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))
+                                    lich->AI()->AttackStart(target);
+                            }
+                            uiIntroTimer = 12000;
+                            break;
+                        }
+                    }
+                    ++uiStage;
+                } else uiIntroTimer -= diff;
+            }
+            private:
+                InstanceScript* instance;
+
+                uint64 uiLichKingGUID;
+                uint32 uiIntroTimer;
+                uint8 uiStage;
+                bool bIntro;
+        };
+
+        bool OnGossipHello(Player* player, Creature* creature)
+        {
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT, GOSSIP_SENDER_MAIN, 999999);
+            player->SEND_GOSSIP_MENU(GOSSIP_MENU, creature->GetGUID());
+
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 /*uiSender*/, uint32 uiAction)
+        {
+            if (uiAction == 999999)
+            {
+                CAST_AI(npc_tirion_icc::npc_tirion_iccAI, creature->AI())->DoAction(ACTION_START_EVENT);
+                creature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                player->CLOSE_GOSSIP_MENU();
+            }
+            return true;
+        }
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_tirion_iccAI(creature);
+        }
+};
+
+class npc_valkyr_icc : public CreatureScript
+{
+    public:
+        npc_valkyr_icc() : CreatureScript("npc_valkyr_icc") { }
+
+        struct npc_valkyr_iccAI : public ScriptedAI
+        {
+            npc_valkyr_iccAI(Creature* creature) : ScriptedAI(creature), vehicle(creature->GetVehicleKit())
+            {
+                ASSERT(vehicle);
+            }
+
+            void Reset()
+            {
+                me->SetFlying(true);
+                bCanCast = false;
+                m_uiLifeSiphonTimer = 3000;
+
+                if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
+                    me->GetMotionMaster()->MovementExpired();
+            }
+
+            void DamageTaken(Unit* /*done_by*/, uint32& /*damage*/)
+            {
+                if(!HealthAbovePct(50) && IsHeroic() && !bCanCast)
+                {
+                    vehicle->RemoveAllPassengers();
+                    me->GetMotionMaster()->MovePoint(POINT_VALKYR_ZET, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ() + 10);
+                }
+            }
+
+            void PassengerBoarded(Unit* who, int8 /*seatId*/, bool apply)
+            {
+                if(apply)
+                    me->GetMotionMaster()->MovePoint(POINT_PLATFORM_END, MovePos[4]);
+            }
+
+            void MovementInform(uint32 type, uint32 id)
+            {
+                if(type != POINT_MOTION_TYPE)
+                    return;
+
+                if(bCanCast)
+                    me->GetMotionMaster()->Clear();
+
+                switch(id)
+                {
+                    case POINT_PLATFORM_END:
+                        vehicle->RemoveAllPassengers();
+                        float x,y,z;
+                        me->GetNearPoint2D(x, y, 50, me->GetAngle(me));
+                        me->GetMotionMaster()->MovePoint(POINT_VALKYR_END,x,y,z+15);
+                        break;
+                    case POINT_VALKYR_END:
+                        me->ForcedDespawn();
+                        break;
+                    case POINT_VALKYR_ZET:
+                        bCanCast = true;
+                        break;
+                }
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim() || !bCanCast)
+                    return;
+
+                if (m_uiLifeSiphonTimer < uiDiff)
+                {
+                    DoCastVictim(SPELL_LIFE_SIPHON);
+                    m_uiLifeSiphonTimer = 3000;
+                } else m_uiLifeSiphonTimer -= uiDiff;
+            }
+        private:
+            uint32 m_uiLifeSiphonTimer;
+            bool bCanCast;
+
+            Vehicle* vehicle;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_valkyr_iccAI(creature);
+        }
+};
+
+class npc_vile_spirit_icc : public CreatureScript
+{
+    public:
+        npc_vile_spirit_icc() : CreatureScript("npc_vile_spirit_icc") { }
+
+        struct npc_vile_spirit_iccAI : public ScriptedAI
+        {
+            npc_vile_spirit_iccAI(Creature* creature) : ScriptedAI(creature) { }
+
+            void Reset()
+            {
+                uiMoveTimer = 15000;
+                SetCombatMovement(false);
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (uiMoveTimer < uiDiff)
+                {
+                    DoCast(me, SPELL_VILE_SPIRIT_ACTIVE);
+                    SetCombatMovement(true);
+                    if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100, true))
+                        me->AddThreat(target, 100000.0f);
+                    uiMoveTimer = 1500000;
+                } else uiMoveTimer -= uiDiff;
+            }
+        private:
+            uint32 uiMoveTimer;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_vile_spirit_iccAI(creature);
+        }
+};
+
+class spell_lich_king_necrotic_plague : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_necrotic_plague() : SpellScriptLoader("spell_lich_king_necrotic_plague") { } //70338
+
+        class spell_lich_king_necrotic_plague_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_lich_king_necrotic_plague_AuraScript)
+
+            void OnApply(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                if (InstanceScript* instance = GetCaster()->GetInstanceScript())
+                {
+                    SetStackAmount(instance->GetData(DATA_NECROTIC_STACK));
+                    instance->SetData(DATA_NECROTIC_STACK, GetStackAmount() + 1);
+                    if(GetStackAmount() >= 30)
+                        instance->SetData(DATA_BEEN_WAITING, DONE);
+                }
+            }
+
+            void Register()
+            {
+                OnEffectApply += AuraEffectApplyFn(spell_lich_king_necrotic_plague_AuraScript::OnApply, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_lich_king_necrotic_plague_AuraScript();
+        }
+};
+
+class spell_lich_king_infection : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_infection() : SpellScriptLoader("spell_lich_king_infection") { } //70541
+
+
+        class spell_lich_king_infection_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_lich_king_infection_AuraScript)
+
+            void OnPeriodic(AuraEffect const* aurEff)
+            {
+                PreventDefaultAction();
+                if(GetTarget()->GetHealthPct() < 90 || !GetCaster())
+                    return;
+
+                GetTarget()->RemoveAurasDueToSpell(SPELL_INFEST);
+            }
+
+            void Register()
+            {
+                OnEffectPeriodic += AuraEffectPeriodicFn(spell_lich_king_infection_AuraScript::OnPeriodic, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_lich_king_infection_AuraScript();
+        }
+};
+
+class spell_lich_king_valkyr_summon : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_valkyr_summon() : SpellScriptLoader("spell_lich_king_valkyr_summon") { } //74361
+
+
+        class spell_lich_king_valkyr_summon_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_lich_king_valkyr_summon_AuraScript);
+
+            void OnApply(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                if (Unit* caster = GetCaster())
+                {
+                    uint8 spawnMod = caster->GetMap()->GetSpawnMode();
+                    SetDuration(spawnMod == 1 || spawnMod == 3 ? 3000 : 1000);
+                }
+            }
+
+            void HandleTriggerSpell(AuraEffect const* aurEff)
+            {
+                PreventDefaultAction();
+                if (Unit* caster = GetCaster())
+                {
+                    int triggerSpellId = GetSpellProto()->EffectTriggerSpell[aurEff->GetEffIndex()];
+                    float x, y, z;
+                    caster->GetPosition(x, y, z);
+                    caster->CastSpell(x, y, z + 6, triggerSpellId, true, NULL, NULL, GetCasterGUID(), caster);
+                }
+            }
+
+            void Register()
+            {
+                OnEffectPeriodic += AuraEffectPeriodicFn(spell_lich_king_valkyr_summon_AuraScript::HandleTriggerSpell, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
+                OnEffectApply += AuraEffectApplyFn(spell_lich_king_valkyr_summon_AuraScript::OnApply, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_lich_king_valkyr_summon_AuraScript();
+        }
+};
+
+class spell_lich_king_winter : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_winter() : SpellScriptLoader("spell_lich_king_winter") { } //68981
+
+
+        class spell_lich_king_winter_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_lich_king_winter_AuraScript)
+
+            void OnRemove(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                if (Unit* caster = GetCaster())
+                {
+                    caster->CastSpell(caster, SPELL_QUAKE, true);
+                    DoScriptText(SAY_BROKEN_ARENA, caster);
+                }
+            }
+
+            void Register()
+            {
+                OnEffectRemove += AuraEffectRemoveFn(spell_lich_king_winter_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_lich_king_winter_AuraScript();
+        }
+};
+
+class spell_lich_king_quake : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_quake() : SpellScriptLoader("spell_lich_king_quake") { } //72262
+
+
+        class spell_lich_king_quake_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_lich_king_quake_AuraScript)
+
+            void OnRemove(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                if(!GetCaster() || !GetOwner())
+                    return;
+
+                GetCaster()->CastSpell(GetCaster(), SPELL_WMO_DAMAGE, true);
+                if (InstanceScript* instance = GetTarget()->GetInstanceScript())
+                    if (Creature* lichKing = Unit::GetCreature(*GetTarget(), instance->GetData64(DATA_LICH_KING)))
+                        lichKing->AI()->DoAction(ACTION_PHASESWITCH_2);
+            }
+
+            void Register()
+            {
+                OnEffectRemove += AuraEffectRemoveFn(spell_lich_king_quake_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_lich_king_quake_AuraScript();
+        }
+};
+
+class spell_vile_spirit_distance_check : public SpellScriptLoader
+{
+    public:
+        spell_vile_spirit_distance_check() : SpellScriptLoader("spell_vile_spirit_distance_check") { }
+
+
+        class spell_vile_spirit_distance_check_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_vile_spirit_distance_check_SpellScript);
+
+
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive()))
+                    return;
+
+                if(Unit* caster = GetCaster())
+                {
+                    caster->CastSpell(caster, SPELL_BURST, true);
+
+                    if (InstanceScript* instance = caster->GetInstanceScript())
+                        instance->SetData(DATA_NECK_DEEP, FAIL);
+                }
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_vile_spirit_distance_check_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_DUMMY);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_vile_spirit_distance_check_SpellScript();
+        }
+};
+
+class spell_ice_burst_distance_check : public SpellScriptLoader
+{
+    public:
+        spell_ice_burst_distance_check() : SpellScriptLoader("spell_ice_burst_distance_check") { }
+
+
+        class spell_ice_burst_distance_check_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_ice_burst_distance_check_SpellScript);
+
+
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive()))
+                    return;
+
+                if(Unit* caster = GetCaster())
+                    caster->CastSpell(caster, SPELL_ICE_BURST, true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_ice_burst_distance_check_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_DUMMY);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_ice_burst_distance_check_SpellScript();
+        }
+};
+
+class spell_lich_king_play_movie : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_play_movie() : SpellScriptLoader("spell_lich_king_play_movie") { }
+
+
+        class spell_lich_king_play_movie_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_lich_king_play_movie_SpellScript);
+
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive()))
+                    return;
+
+                if (GetHitUnit()->GetTypeId() == TYPEID_PLAYER)
+                    GetHitUnit()->ToPlayer()->SendMovieStart(MOVIE_ID_ARTHAS_DEATH);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_lich_king_play_movie_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_lich_king_play_movie_SpellScript();
+        }
+};
+
+class spell_valkyr_carry_can_cast : public SpellScriptLoader
+{
+    public:
+        spell_valkyr_carry_can_cast() : SpellScriptLoader("spell_valkyr_carry_can_cast") { }
+
+
+        class spell_valkyr_carry_can_cast_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_valkyr_carry_can_cast_SpellScript);
+
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive() && GetCaster()))
+                    return;
+
+                if (GetHitUnit()->GetTypeId() == TYPEID_PLAYER)
+                    GetHitUnit()->CastSpell(GetCaster(), SPELL_VALKYR_MOVE_PLAYER, true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_valkyr_carry_can_cast_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_valkyr_carry_can_cast_SpellScript();
+        }
+};
+
+void AddSC_boss_lichking()
+{
+    new boss_the_lich_king();
+    new npc_tirion_icc();
+    new npc_valkyr_icc();
+    new npc_vile_spirit_icc();
+    new spell_lich_king_necrotic_plague();
+    new spell_lich_king_infection();
+    new spell_lich_king_valkyr_summon();
+    new spell_lich_king_winter();
+    new spell_vile_spirit_distance_check();
+    new spell_ice_burst_distance_check();
+    new spell_lich_king_quake();
+    new spell_lich_king_play_movie();
+    new spell_valkyr_carry_can_cast();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
new file mode 100644
index 0000000..d6f448c
--- /dev/null
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
@@ -0,0 +1,415 @@
+/*
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include "ScriptPCH.h"
+#include "icecrown_citadel.h"
+
+enum Yells
+{
+    SAY_AGGRO       = -1666063,
+    SAY_BELOW_25    = -1666066,
+    SAY_ABOVE_75    = -1666065,
+    SAY_DEATH       = -1666067,
+    SAY_PDEATH      = -1666068,
+    SAY_END         = -1666070,
+    SAY_BERSERK     = -1666069,
+    SAY_OPEN_PORTAL = -1666064
+};
+
+enum Spells
+{
+    SPELL_CORRUPTION    = 70904,
+    SPELL_DREAM_SLIP    = 71196,
+    SPELL_RAGE          = 71189,
+    SPELL_COLUMN        = 70704,
+    SPELL_DREAM_STATE   = 70766,
+    SPELL_VIGOR         = 70873,
+    SPELL_CLOUD_VISUAL  = 70876,
+    SPELL_PORTAL_N_PRE  = 71301,
+    SPELL_PORTAL_N_NPC  = 71305,
+    SPELL_PORTAL_H_PRE  = 71977,
+    SPELL_PORTAL_H_NPC  = 71987,
+};
+
+const Position Pos[] =
+{
+    {4239.579102f, 2566.753418f, 364.868439f, 0.0f}, //normal 0,1
+    {4240.688477f, 2405.794678f, 364.868591f, 0.0f}, // normal
+    {4165.112305f, 2405.872559f, 364.872925f, 0.0f}, //2,3
+    {4166.216797f, 2564.197266f, 364.873047f, 0.0f}
+};
+
+class boss_valithria : public CreatureScript
+{
+    public:
+        boss_valithria() : CreatureScript("boss_valithria") { }
+
+        struct boss_valithriaAI : public BossAI
+        {
+            boss_valithriaAI(Creature* pCreature) : BossAI(pCreature, DATA_VALITHRIA_DREAMWALKER)
+            {
+                pInstance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                m_uiStage = 1;
+
+                DoCast(me, SPELL_CORRUPTION);
+                me->SetHealth(uint32(me->GetMaxHealth() / 2));
+
+                m_uiEndTimer = 1000;
+
+                bIntro = false;
+                bEnd = false;
+                bAboveHP = false;
+                bBelowHP = false;
+
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+
+                if (pInstance)
+                    pInstance->SetData(DATA_VALITHRIA_DREAMWALKER_EVENT, NOT_STARTED);
+            }
+
+            void MoveInLineOfSight(Unit *who)
+            {
+                if (pInstance && pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) == NOT_STARTED)
+                    pInstance->SetData(DATA_VALITHRIA_DREAMWALKER_EVENT, IN_PROGRESS);
+
+                if (!bIntro && who->IsWithinDistInMap(me, 40.0f,true))
+                {
+                    DoScriptText(SAY_AGGRO, me);
+                    bIntro = true;
+
+                    ScriptedAI::MoveInLineOfSight(who);
+                }
+                if (pInstance && pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) == IN_PROGRESS)
+                    if(!who->IsWithinDistInMap(me, 60.0f,true))
+                        pInstance->SetData(DATA_VALITHRIA_DREAMWALKER_EVENT, FAIL);
+            }
+
+            void JustDied(Unit* /*pKiller*/)
+            {
+                DoScriptText(SAY_DEATH, me);
+
+                if (pInstance)
+                    pInstance->SetData(DATA_VALITHRIA_DREAMWALKER_EVENT, FAIL);
+            }
+
+            void DamageTaken(Unit* /*done_by*/, uint32& /*damage*/)
+            {
+                if (!pInstance || pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) == DONE)
+                    return;
+
+                if (!bAboveHP && HealthAbovePct(74))
+                {
+                    DoScriptText(SAY_ABOVE_75, me);
+                    bAboveHP = true;
+                }
+                if (!bBelowHP && HealthBelowPct(26))
+                {
+                    DoScriptText(SAY_BELOW_25, me);
+                    bBelowHP = true;
+                }
+                if (!bEnd && HealthAbovePct(99))
+                {
+                    DoScriptText(SAY_END, me);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                    me->SetReactState(REACT_PASSIVE);
+                    me->RemoveAurasDueToSpell(SPELL_CORRUPTION);
+                    bEnd = true;
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!bEnd || !pInstance || pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) == DONE)
+                    return;
+
+                if (m_uiEndTimer <= diff)
+                {
+                    switch(m_uiStage)
+                    {
+                        case 1:
+                            DoScriptText(SAY_BERSERK , me);
+                            DoCast(me, SPELL_RAGE);
+                            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                            ++m_uiStage;
+                            m_uiEndTimer = 6000;
+                            break;
+                        case 2:
+                            DoCast(SPELL_DREAM_SLIP);
+                            ++m_uiStage;
+                            m_uiEndTimer = 1000;
+                            break;
+                        case 3:
+                            me->ForcedDespawn();
+                            pInstance->SetData(DATA_VALITHRIA_DREAMWALKER_EVENT, DONE);
+                            m_uiEndTimer = 1000;
+                            bEnd = false;
+                            ++m_uiStage;
+                            break;
+                    }
+                } else m_uiEndTimer -= diff;
+            }
+
+        private:
+            InstanceScript* pInstance;
+
+            uint8 m_uiStage;
+            uint32 m_uiEndTimer;
+            bool bIntro;
+            bool bEnd;
+            bool bAboveHP;
+            bool bBelowHP;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new boss_valithriaAI(pCreature);
+        }
+};
+
+class npc_valithria_alternative : public CreatureScript
+{
+    public:
+        npc_valithria_alternative() : CreatureScript("npc_valithria_alternative") { }
+
+        struct npc_valithria_alternativeAI : public ScriptedAI
+        {
+            npc_valithria_alternativeAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = pCreature->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                me->SetPhaseMask(16, true);
+                me->AddUnitMovementFlag(MOVEMENTFLAG_CAN_FLY);
+                me->SendMovementFlagUpdate();
+                me->SetFlying(true);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+
+                m_uiSummonPortalTimer = 5000;
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (pInstance && pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) != IN_PROGRESS)
+                    return;
+
+                if (m_uiSummonPortalTimer <= diff)
+                {
+                    float x, y, z;
+                    me->GetPosition(x,y,z);
+                    for(uint8 i = 0; i <= 8; ++i) //need correct count
+                        me->SummonCreature(CREATURE_CLOUD, x + (urand(2, 6) * 10), y + (urand(1, 4) * 10), z + urand(2,8), 0, TEMPSUMMON_TIMED_DESPAWN, 15000);
+                    m_uiSummonPortalTimer = 5000;
+                } else m_uiSummonPortalTimer -= diff;
+            }
+        private:
+            InstanceScript* pInstance;
+
+            uint32 m_uiSummonPortalTimer;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_valithria_alternativeAI(pCreature);
+        }
+};
+
+class npc_dreamportal_icc : public CreatureScript //  
+{
+    public:
+        npc_dreamportal_icc() : CreatureScript("npc_dreamportal_icc") { }
+
+        struct npc_dreamportal_iccAI : public ScriptedAI
+        {
+            npc_dreamportal_iccAI(Creature* pCreature) : ScriptedAI(pCreature) { }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+
+                m_uiChangeTimer = 15000;
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if(me->GetEntry() == CREATURE_PORTAL_NORMAL_MODE_PRE)
+                {
+                    if (m_uiChangeTimer <= diff)
+                    {
+                        me->UpdateEntry(CREATURE_PORTAL_NORMAL_MODE_NPC);
+                    } else m_uiChangeTimer -= diff;
+                }
+
+                if(me->GetEntry() == CREATURE_PORTAL_HEROIC_MODE_PRE)
+                {
+                    if (m_uiChangeTimer <= diff)
+                    {
+                        me->UpdateEntry(CREATURE_PORTAL_HEROIC_MODE_NPC);
+                    } else m_uiChangeTimer -= diff;
+                }
+            }
+
+        private:
+            uint32 m_uiChangeTimer;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_dreamportal_iccAI(pCreature);
+        }
+};
+
+class npc_dreamcloud_icc : public CreatureScript //  
+{
+    public:
+        npc_dreamcloud_icc() : CreatureScript("npc_dreamcloud_icc") { }
+
+        struct npc_dreamcloud_iccAI : public ScriptedAI
+        {
+            npc_dreamcloud_iccAI(Creature* pCreature) : ScriptedAI(pCreature) { }
+
+            void Reset()
+            {
+                me->SetPhaseMask(16, true);
+                DoCast(SPELL_CLOUD_VISUAL);
+                me->AddUnitMovementFlag(MOVEMENTFLAG_CAN_FLY);
+                me->SendMovementFlagUpdate();
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+            }
+
+            void MoveInLineOfSight(Unit *who)
+            {
+                if (me->IsWithinDistInMap(who, 5.0f, true))
+                    DoCast(SPELL_VIGOR);
+
+                ScriptedAI::MoveInLineOfSight(who);
+            }
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_dreamcloud_iccAI(pCreature);
+        }
+};
+
+class npc_icc_combat_stalker : public CreatureScript
+{
+    public:
+        npc_icc_combat_stalker() : CreatureScript("npc_icc_combat_stalker") { }
+
+        struct npc_icc_combat_stalkerAI : public ScriptedAI
+        {
+            npc_icc_combat_stalkerAI(Creature* pCreature) : ScriptedAI(pCreature), summons(me)
+            {
+                pInstance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetInCombatWithZone();
+                DoStartNoMovement(me->getVictim());
+                m_uiSummonTimer = 20000;
+                m_uiPortalTimer = 50000;
+                m_uiColumnTimer = 13000;
+
+                if (pInstance && pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) != IN_PROGRESS)
+                    summons.DespawnAll();
+            }
+
+            void JustSummoned(Creature* pSummoned)
+            {
+                if (Creature* valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER)))
+                    pSummoned->AI()->AttackStart(valithria);
+
+                summons.Summon(pSummoned);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                if (Creature* valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER)))
+                    DoScriptText(SAY_PDEATH, valithria);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!pInstance || pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) != IN_PROGRESS)
+                    return;
+
+                if (m_uiSummonTimer <= diff)
+                {
+                    for (uint8 coords = 0; coords <= RAID_MODE(1,3,1,3); ++coords)
+                    {
+                        if(urand(0,1)) DoSummon(CREATURE_ZOMBIE, Pos[coords]);
+                        if(urand(0,1)) DoSummon(CREATURE_SKELETON, Pos[coords]);
+                        if(urand(0,1)) DoSummon(CREATURE_ARCHMAGE, Pos[coords]);
+                        if(urand(0,1)) DoSummon(CREATURE_SUPPRESSER, Pos[coords]);
+                        if(urand(0,1)) DoSummon(CREATURE_ABOMINATION, Pos[coords]);
+                    }
+                    m_uiSummonTimer = 20000;
+                } else m_uiSummonTimer -= diff;
+
+                if (m_uiColumnTimer <= diff)
+                {
+                    if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                        DoCast(pTarget, SPELL_COLUMN);
+                    m_uiColumnTimer = 13000;
+                } else m_uiColumnTimer -= diff;
+
+                if (m_uiPortalTimer <= diff)
+                {
+                    if (Creature* valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER)))
+                        DoScriptText(SAY_OPEN_PORTAL, valithria);
+
+                    for(uint8 p = 0; p < 6; ++p)
+                    {
+                        DoCast(RAID_MODE(SPELL_PORTAL_N_PRE,SPELL_PORTAL_N_PRE,SPELL_PORTAL_H_PRE,SPELL_PORTAL_H_PRE));
+                    }
+                    m_uiPortalTimer = 50000;
+                } else m_uiPortalTimer -= diff;
+            }
+            private:
+                InstanceScript* pInstance;
+
+                uint32 m_uiSummonTimer;
+                uint32 m_uiPortalTimer;
+                uint32 m_uiColumnTimer;
+                SummonList summons;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_icc_combat_stalkerAI(pCreature);
+        }
+};
+
+void AddSC_boss_valithria()
+{
+    new boss_valithria();
+    new npc_dreamportal_icc();
+    new npc_dreamcloud_icc();
+    new npc_icc_combat_stalker();
+    new npc_valithria_alternative();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp
new file mode 100644
index 0000000..af3f571
--- /dev/null
+++ b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ScriptPCH.h"
+#include "icecrown_citadel.h"
+#include "Spell.h"
+
+enum Spells
+{
+    SPELL_ON_ORGRIMS_HAMMER_DECK   = 70121, //maybe for gunship battle
+    SPELL_DARKMARTYRDOM_FANATIC     = 71236,
+    SPELL_DARKMARTYRDOM_ADHERENT    = 70903,
+    SPELL_DARKTRANSFORMATION        = 70900,
+    SPELL_NECROTICSTRIKE            = 70659,
+    SPELL_SHADOWCLEAVE              = 70670,
+    SPELL_VAMPIRICMIGHT             = 70674,
+    SPELL_FANATIC_DETERMINATION     = 71235,
+    SPELL_ADHERENT_DETERMINATION    = 71234,
+    SPELL_EMPOWEREMENT              = 70901,
+    SPELL_FROST_FEVER               = 67767,
+    SPELL_DEATHCHILL_BLAST          = 70906,
+    SPELL_DEATHCHILL_BOLT           = 70594,
+    SPELL_CURSE_OF_TORPOR           = 71237,
+    SPELL_SHORUD_OF_THE_OCCULT      = 70768,
+    SPELL_DARK_TRANSFORMATION_T     = 70895,
+    SPELL_DARK_EMPOWERMENT_T        = 70896,
+    SPELL_STANDART_HORDE            = 69811
+};
+
+enum TeleportSpells
+{
+    HAMMER        = 70781,
+    ORATORY       = 70856,
+    RAMPART       = 70857,
+    SAURFANG      = 70858,
+    UPPER_SPIRE   = 70859,
+    PLAGUEWORKS   = 9995,
+    CRIMSONHALL   = 9996,
+    FWHALLS       = 9997,
+    QUEEN         = 70861,
+    LICHKING      = 70860
+};
+
+class npc_cult_fanatic_and_adherent : public CreatureScript
+{
+    public:
+        npc_cult_fanatic_and_adherent() : CreatureScript("npc_cult_fanatic_and_adherent") { }
+
+        struct npc_cult_fanatic_and_adherentAI : public ScriptedAI
+        {
+            npc_cult_fanatic_and_adherentAI(Creature* creature) : ScriptedAI(creature) { }
+
+            void Reset()
+            {
+                uiStrikeTimer = urand(8000, 11000);
+                uiVampirTimer = urand(19000, 22000);
+                uiCleaveTimer = urand(7000, 9000);
+                uiMartyrdomTimer = urand(24000, 30000);
+                uiFrostFeverTimer = urand(9000, 11000);
+                uiDeathchillTimer = urand(10000, 12000);
+                uiCurseTimer = urand(8000, 10000);
+                uiOccultTimer = urand(25000, 29000);
+
+                bEmpowerement = false;
+
+                if(me->GetEntry() == CREATURE_REANIMATED_ADHERENT)
+                    DoCast(me, SPELL_ADHERENT_DETERMINATION);
+                if(me->GetEntry() == CREATURE_REANIMATED_FANATIC)
+                    DoCast(me, SPELL_FANATIC_DETERMINATION);
+            }
+
+            void JustDied(Unit* /*who*/) { }
+
+            void SpellHit(Unit* /*caster*/, const SpellEntry * spell)
+            {
+                if(me->GetEntry() == CREATURE_ADHERENT)
+                {
+                    if (spell->Id == SPELL_EMPOWEREMENT)
+                        me->UpdateEntry(CREATURE_EMPOWERED_ADHERENT);
+                    else if (spell->Id == SPELL_DARK_EMPOWERMENT_T)
+                    {
+                        DoCast(me, SPELL_EMPOWEREMENT);
+                        bEmpowerement = true;
+                    }
+                }
+                if(me->GetEntry() == CREATURE_FANATIC)
+                {
+                    if (spell->Id == SPELL_DARKTRANSFORMATION)
+                        me->UpdateEntry(CREATURE_DEFORMED_FANATIC);
+                    else if (spell->Id == SPELL_DARK_TRANSFORMATION_T)
+                        DoCast(me, SPELL_DARKTRANSFORMATION);
+                }
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim() || me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                if((me->GetEntry() == CREATURE_ADHERENT) || (me->GetEntry() == CREATURE_EMPOWERED_ADHERENT) || (me->GetEntry() == CREATURE_REANIMATED_ADHERENT))
+                {
+                    if (uiMartyrdomTimer <= uiDiff && !bEmpowerement)
+                    {
+                        DoCast(me, SPELL_DARKMARTYRDOM_ADHERENT);
+                        uiMartyrdomTimer = urand(24000, 30000);
+                    } else uiMartyrdomTimer -= uiDiff;
+
+                    if (uiFrostFeverTimer <= uiDiff)
+                    {
+                        DoCast(me->getVictim(), SPELL_FROST_FEVER);
+                        uiFrostFeverTimer = urand(9000, 11000);
+                    } else uiFrostFeverTimer -= uiDiff;
+
+                    if (uiDeathchillTimer <= uiDiff)
+                    {
+                        if (me->GetEntry() == CREATURE_EMPOWERED_ADHERENT)
+                            DoCast(me->getVictim(), SPELL_DEATHCHILL_BLAST);
+                        else
+                            DoCast(me->getVictim(), SPELL_DEATHCHILL_BOLT);
+                        uiDeathchillTimer = urand(10000, 12000);
+                    } else uiDeathchillTimer -= uiDiff;
+
+                    if (uiCurseTimer <= uiDiff)
+                    {
+                        if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            DoCast(target, SPELL_CURSE_OF_TORPOR);
+                        uiCurseTimer = urand(8000, 10000);
+                    } else uiCurseTimer -= uiDiff;
+
+                    if (uiOccultTimer <= uiDiff)
+                    {
+                        DoCast(me, SPELL_SHORUD_OF_THE_OCCULT);
+                        uiOccultTimer = urand(25000, 29000);
+                    } else uiOccultTimer -= uiDiff;
+                }
+                if((me->GetEntry() == CREATURE_FANATIC) || (me->GetEntry() == CREATURE_REANIMATED_FANATIC) || (me->GetEntry() == CREATURE_DEFORMED_FANATIC))
+                {
+                    if (uiMartyrdomTimer <= uiDiff)
+                    {
+                        DoCast(me, SPELL_DARKMARTYRDOM_FANATIC);
+                        uiMartyrdomTimer = urand(24000, 30000);
+                    } else uiMartyrdomTimer -= uiDiff;
+
+                    if (uiStrikeTimer <= uiDiff)
+                    {
+                        DoCast(me, SPELL_NECROTICSTRIKE);
+                        uiStrikeTimer = urand(8000, 11000);
+                    } else uiStrikeTimer -= uiDiff;
+
+                    if (uiCleaveTimer <= uiDiff)
+                    {
+                        DoCast(me, SPELL_SHADOWCLEAVE);
+                        uiCleaveTimer = urand(7000, 9000);
+                    } else uiCleaveTimer -= uiDiff;
+
+                    if (uiVampirTimer <= uiDiff)
+                    {
+                        DoCast(me, SPELL_VAMPIRICMIGHT);
+                        uiVampirTimer = urand(19000, 22000);
+                    } else uiVampirTimer -= uiDiff;
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            uint32 uiStrikeTimer;
+            uint32 uiCleaveTimer;
+            uint32 uiVampirTimer;
+            uint32 uiMartyrdomTimer;
+            uint32 uiFrostFeverTimer;
+            uint32 uiDeathchillTimer;
+            uint32 uiCurseTimer;
+            uint32 uiOccultTimer;
+
+            bool bEmpowerement;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_cult_fanatic_and_adherentAI(creature);
+        }
+};
+
+class go_icecrown_teleporter : public GameObjectScript
+{
+    public:
+        go_icecrown_teleporter() : GameObjectScript("go_icecrown_teleporter") { }
+
+        bool OnGossipHello(Player* player, GameObject* go)
+        {
+            InstanceScript* instance = go->GetInstanceScript();
+            if(!instance)
+                return false;
+
+            if(instance->GetData(DATA_MARROWGAR_EVENT) == DONE)
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to Light's Hammer.", GOSSIP_SENDER_MAIN, HAMMER);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Oratory of the Damned.", GOSSIP_SENDER_MAIN, ORATORY);
+            }
+            if(instance->GetData(DATA_DEATHWHISPER_EVENT) == DONE)
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Rampart of Skulls.", GOSSIP_SENDER_MAIN, RAMPART);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Deathbringer's Rise.", GOSSIP_SENDER_MAIN, SAURFANG);
+            }
+            if(instance->GetData(DATA_SAURFANG_EVENT) == DONE)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Upper Spire.", GOSSIP_SENDER_MAIN, UPPER_SPIRE);
+            if(instance->GetData(DATA_PROFESSOR_PUTRICIDE_EVENT) == DONE)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Plagueworks", GOSSIP_SENDER_MAIN, PLAGUEWORKS);
+            if(instance->GetData(DATA_BLOOD_QUEEN_LANATHEL_EVENT) == DONE)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Crimson Halls", GOSSIP_SENDER_MAIN, CRIMSONHALL);
+            if(instance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) == DONE)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Sindragosa's Lair", GOSSIP_SENDER_MAIN, QUEEN);
+            if(instance->GetData(DATA_SINDRAGOSA_EVENT) == DONE)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Frostwing Halls", GOSSIP_SENDER_MAIN, FWHALLS);
+
+            player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, go->GetGUID());
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, GameObject* /*go*/, uint32 uiSender, uint32 uiAction)
+        {
+            //player->PlayerTalkClass->ClearMenus();
+            if(!player->getAttackers().empty())
+                return false;
+
+            SpellEntry const* spell = sSpellStore.LookupEntry(uiAction);
+            if (!spell)
+                return false;
+
+            if (player->isInCombat())
+            {
+                Spell::SendCastResult(player, spell, 0, SPELL_FAILED_AFFECTING_COMBAT);
+                return true;
+            }
+
+            if (uiSender == GOSSIP_SENDER_MAIN)
+                player->CastSpell(player, spell, true);
+
+            return true;
+        }
+};
+
+void AddSC_icecrown_citadel()
+{
+    new npc_cult_fanatic_and_adherent();
+    new go_icecrown_teleporter();
+}
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
old mode 100755
new mode 100644
index 6eac43f..8333e4d
--- a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
+++ b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -18,115 +18,144 @@
 #ifndef DEF_ICECROWN_CITADEL_H
 #define DEF_ICECROWN_CITADEL_H
 
-#define ICCScriptName "instance_icecrown_citadel"
-
-// Shared spells used by every boss
-enum SharedSpells
+enum eBerserkSpells
 {
-    SPELL_BERSERK   = 26662,
-    SPELL_BERSERK2  = 47008
+    SPELL_BERSERK                         = 26662
 };
 
-enum TeleporterSpells
+enum eEnums
 {
-    LIGHT_S_HAMMER_TELEPORT         = 70781,
-    ORATORY_OF_THE_DAMNED_TELEPORT  = 70856,
-    RAMPART_OF_SKULLS_TELEPORT      = 70857,
-    DEATHBRINGER_S_RISE_TELEPORT    = 70858,
-    UPPER_SPIRE_TELEPORT            = 70859,
-    FROZEN_THRONE_TELEPORT          = 70860,
-    SINDRAGOSA_S_LAIR_TELEPORT      = 70861
+    SOUND_ENDING_7_KING                   = 17360,
+    MOVIE_ID_ARTHAS_DEATH                 = 16
 };
 
-enum DataTypes
+enum eAchievements
 {
-    // Encounter States/Boss GUIDs
-    DATA_LORD_MARROWGAR             = 0,
-    DATA_LADY_DEATHWHISPER          = 1,
-    DATA_GUNSHIP_EVENT              = 2,
-    DATA_DEATHBRINGER_SAURFANG      = 3,
-    DATA_FESTERGUT                  = 4,
-    DATA_ROTFACE                    = 5,
-    DATA_PROFESSOR_PUTRICIDE        = 6,
-    DATA_BLOOD_PRINCE_COUNCIL       = 7,
-    DATA_BLOOD_QUEEN_LANA_THEL      = 8,
-    DATA_VALITHRIA_DREAMWALKER      = 9,
-    DATA_SINDRAGOSA                 = 10,
-    DATA_THE_LICH_KING              = 11,
-
-    // Additional data
-    DATA_SAURFANG_EVENT_NPC         = 12,
-    DATA_BONED_ACHIEVEMENT          = 13,
-    DATA_OOZE_DANCE_ACHIEVEMENT     = 14,
-    DATA_PUTRICIDE_TABLE            = 15,
-    DATA_NAUSEA_ACHIEVEMENT         = 16,
-    DATA_ORB_WHISPERER_ACHIEVEMENT  = 17,
-    DATA_PRINCE_KELESETH_GUID       = 18,
-    DATA_PRINCE_TALDARAM_GUID       = 19,
-    DATA_PRINCE_VALANAR_GUID        = 20,
-    DATA_BLOOD_PRINCES_CONTROL      = 21,
+    ACHIEV_BONED_10                             = 4534,
+    ACHIEV_BONED_25                             = 4610,
+    AVHIEV_FULL_HOUSE_10                        = 4535,
+    AVHIEV_FULL_HOUSE_25                        = 4611,
+    ACHIEV_MESS_10                              = 4537,
+    ACHIEV_MESS_25                              = 4613,
+    ACHIEVMENT_ONCE_BITTEN_TWICE_SHY_10         = 4539,
+    ACHIEVMENT_ONCE_BITTEN_TWICE_SHY_25         = 4618,
+    ACHIEV_ALL_YOU_CAN_EAT_10                   = 4580,
+    ACHIEV_ALL_YOU_CAN_EAT_25                   = 4620,
+    ACHIEV_BEEN_WAITING_A_LONG_TIME_FOR_THIS_10 = 4601,
+    ACHIEV_BEEN_WAITING_A_LONG_TIME_FOR_THIS_25 = 4621,
+    ACHIEV_NECK_DEEP_IN_VILE_10                 = 4581,
+    ACHIEV_NECK_DEEP_IN_VILE_25                 = 4622
 };
 
-#define MAX_ENCOUNTER 12
-
-enum CreaturesIds
+enum ePutricideActions
 {
-    // At Light's Hammer
-    NPC_KOR_KRON_GENERAL                        = 37189,
-    NPC_ALLIANCE_COMMANDER                      = 37190,
-    NPC_KOR_KRON_LIEUTENANT                     = 38491,
-    NPC_SKYBREAKER_LIEUTENANT                   = 38492,
-    NPC_TORTUNOK                                = 37992,    // Druid Armor H
-    NPC_ALANA_MOONSTRIKE                        = 37999,    // Druid Armor A
-    NPC_GERARDO_THE_SUAVE                       = 37993,    // Hunter Armor H
-    NPC_TALAN_MOONSTRIKE                        = 37998,    // Hunter Armor A
-    NPC_UVLUS_BANEFIRE                          = 38284,    // Mage Armor H
-    NPC_MALFUS_GRIMFROST                        = 38283,    // Mage Armor A
-    NPC_IKFIRUS_THE_VILE                        = 37991,    // Rogue Armor H
-    NPC_YILI                                    = 37997,    // Rogue Armor A
-    NPC_VOL_GUK                                 = 38841,    // Shaman Armor H
-    NPC_JEDEBIA                                 = 38840,    // Shaman Armor A
-    NPC_HARAGG_THE_UNSEEN                       = 38181,    // Warlock Armor H
-    NPC_NIBY_THE_ALMIGHTY                       = 38182,    // Warlock Armor N
-    NPC_GARROSH_HELLSCREAM                      = 39372,
-    NPC_KING_VARIAN_WRYNN                       = 39371,
-
-    // Lord Marrowgar
-    NPC_LORD_MARROWGAR                          = 36612,
-    NPC_COLDFLAME                               = 36672,
-    NPC_BONE_SPIKE                              = 36619,
-
-    // Lady Deathwhisper
-    NPC_LADY_DEATHWHISPER                       = 36855,
-    NPC_CULT_FANATIC                            = 37890,
-    NPC_DEFORMED_FANATIC                        = 38135,
-    NPC_REANIMATED_FANATIC                      = 38009,
-    NPC_CULT_ADHERENT                           = 37949,
-    NPC_EMPOWERED_ADHERENT                      = 38136,
-    NPC_REANIMATED_ADHERENT                     = 38010,
-    NPC_VENGEFUL_SHADE                          = 38222,
+    ACTION_FESTERGUT_COMBAT     = -366260,
+    ACTION_FESTERGUT_GAS        = -366261,
+    ACTION_FESTERGUT_DEATH      = -366262,
 
-    // Deathbringer Saurfang
-    NPC_DEATHBRINGER_SAURFANG                   = 37813,
-    NPC_BLOOD_BEAST                             = 38508,
-    NPC_SE_JAINA_PROUDMOORE                     = 37188,    // SE means Saurfang Event
-    NPC_SE_MURADIN_BRONZEBEARD                  = 37200,
-    NPC_SE_KING_VARIAN_WRYNN                    = 37879,
-    NPC_SE_HIGH_OVERLORD_SAURFANG               = 37187,
-    NPC_SE_KOR_KRON_REAVER                      = 37920,
-    NPC_SE_SKYBREAKER_MARINE                    = 37830,
+    ACTION_ROTFACE_COMBAT       = -366270,
+    ACTION_ROTFACE_GAS          = -366271,
+    ACTION_ROTFACE_DEATH        = -366272,
+    ACTION_ROTFACE_OOZE         = -366273
+};
 
-    // Festergut
-    NPC_FESTERGUT                               = 36626,
-    NPC_GAS_DUMMY                               = 36659,
+enum Data
+{
+    DATA_MARROWGAR_EVENT,
+    DATA_DEATHWHISPER_EVENT,
+    DATA_GUNSHIP_BATTLE_EVENT,
+    DATA_SAURFANG_EVENT,
+    DATA_FESTERGURT_EVENT,
+    DATA_ROTFACE_EVENT,
+    DATA_PROFESSOR_PUTRICIDE_EVENT,
+    DATA_BLOOD_PRINCE_COUNCIL_EVENT,
+    DATA_BLOOD_QUEEN_LANATHEL_EVENT,
+    DATA_VALITHRIA_DREAMWALKER_EVENT,
+    DATA_SINDRAGOSA_EVENT,
+    DATA_LICH_KING_EVENT,
+    DATA_SPAWN
+};
 
-    // Rotface
-    NPC_ROTFACE                                 = 36627,
-    NPC_OOZE_SPRAY_STALKER                      = 37986,
-    NPC_PUDDLE_STALKER                          = 37013,
-    NPC_UNSTABLE_EXPLOSION_STALKER              = 38107,
+enum Data64
+{
+    DATA_MARROWGAR,
+    DATA_DEATHWHISPER,
+    DATA_SAURFANG,
+    DATA_GUNSHIP_BATTLE,
+    DATA_FESTERGURT,
+    DATA_ROTFACE,
+    DATA_PROFESSOR_PUTRICIDE,
+    DATA_PRINCE_VALANAR_ICC,
+    DATA_PRINCE_KELESETH_ICC,
+    DATA_PRINCE_TALDARAM_ICC,
+    DATA_BLOOD_QUEEN_LANATHEL,
+    DATA_VALITHRIA_DREAMWALKER,
+    DATA_SINDRAGOSA,
+    DATA_LICH_KING,
+    DATA_TIRION,
+    DATA_ANGLE,
+    DATA_BONED,
+    DATA_ALL_YOU_CAN_EAT,
+    DATA_BEEN_WAITING,
+    DATA_NECK_DEEP,
+    DATA_BLOOD_PRINCES_CONTROL,
+    DATA_NECROTIC_STACK,
+    DATA_PUTRICIDE_TABLE,
+};
 
-    // Professor Putricide
+enum eCreatures
+{
+    CREATURE_MARROWGAR               = 36612,
+    CREATURE_BONE_SPIKE              = 36619,
+    CREATURE_COLD_FLAME              = 36672,
+    CREATURE_DEATHWHISPER            = 36855,
+    CREATURE_ADHERENT                = 37949,
+    CREATURE_EMPOWERED_ADHERENT      = 38136,
+    CREATURE_REANIMATED_ADHERENT     = 38010,
+    CREATURE_FANATIC                 = 37890,
+    CREATURE_DEFORMED_FANATIC        = 38135,
+    CREATURE_REANIMATED_FANATIC      = 38009,
+    CREATURE_SHADE                   = 38222,
+    CREATURE_GUNSHIP                 = 30343,
+    CREATURE_KOR_KRON_GENERAL        = 37189,
+    CREATURE_ALLIANCE_COMMANDER      = 37190,
+    CREATURE_TORTUNOK                = 37992,
+    CREATURE_ALANA_MOONSTRIKE        = 37999,
+    CREATURE_GERARDO_THE_SUAVE       = 37993,
+    CREATURE_TALAN_MOONSTRIKE        = 37998,
+    CREATURE_UVLUS_BANEFIRE          = 38284,
+    CREATURE_MALFUS_GRIMFROST        = 38283,
+    CREATURE_IKFIRUS_THE_VILE        = 37991,
+    CREATURE_YILI                    = 37997,
+    CREATURE_VOL_GUK                 = 38841,
+    CREATURE_JEDEBIA                 = 38840,
+    CREATURE_HARAGG_THE_UNSEEN       = 38181,
+    CREATURE_SE_MURADIN_BRONZEBEARD  = 37200,
+    CREATURE_SE_KING_VARIAN_WRYNN    = 37879,
+    CREATURE_SE_HIGH_OVERLORD_SAURFANG    = 37187,
+    CREATURE_SE_KOR_KRON_REAVER      = 37920,
+    CREATURE_SE_SKYBREAKER_MARINE    = 37830,
+    CREATURE_NIBY_THE_ALMIGHTY       = 38182,
+    CREATURE_GARROSH_HELLSCREAM      = 39372,
+    CREATURE_KING_VARIAN_WRYNN       = 39371,
+    CREATURE_SAURFANG                = 37813,
+    CREATURE_FESTERGURT              = 36626,
+    CREATURE_PUDDLE_STALKER          = 37013,
+    CREATURE_ORANGE_GAS_STALKER      = 36659,
+    CREATURE_VILE_GAS_STALKER        = 38548,
+    CREATURE_ROTFACE                 = 36627,
+    CREATURE_OOZE_SPRAY_STALKER      = 37986,
+    CREATURE_GREEN_GAS_STALKER       = 37824,
+    CREATURE_LITTLE_OOZE             = 36897,
+    CREATURE_BIG_OOZE                = 36899,
+    CREATURE_STINKY                  = 37025,
+    CREATURE_PRECIOUS                = 37217,
+    CREATURE_PROFESSOR_PUTRICIDE     = 36678,
+    CREATURE_VOLATILE_OOZE           = 37697,
+    CREATURE_GAS_CLOUD               = 37562,
+    CREATURE_GROWING_OZZE_STALKER    = 38234,
+    CREATURE_TEAR_GAS_STALKER        = 38317,
+    CREATURE_CHOKING_GAS_BOMB        = 38159,
     NPC_PROFESSOR_PUTRICIDE                     = 36678,
     NPC_ABOMINATION_WING_MAD_SCIENTIST_STALKER  = 37824,
     NPC_GROWING_OOZE_PUDDLE                     = 37690,
@@ -134,120 +163,111 @@ enum CreaturesIds
     NPC_VOLATILE_OOZE                           = 37697,
     NPC_CHOKING_GAS_BOMB                        = 38159,
     NPC_TEAR_GAS_TARGET_STALKER                 = 38317,
-
-    // Blood Prince Council
-    NPC_PRINCE_KELESETH                         = 37972,
-    NPC_PRINCE_TALDARAM                         = 37973,
-    NPC_PRINCE_VALANAR                          = 37970,
-    NPC_BLOOD_ORB_CONTROLLER                    = 38008,
-    NPC_FLOATING_TRIGGER                        = 30298,
-    NPC_DARK_NUCLEUS                            = 38369,
-    NPC_BALL_OF_FLAME                           = 38332,
-    NPC_BALL_OF_INFERNO_FLAME                   = 38451,
-    NPC_KINETIC_BOMB_TARGET                     = 38458,
-    NPC_KINETIC_BOMB                            = 38454,
-    NPC_SHOCK_VORTEX                            = 38422,
-
-    // Blood-Queen Lana'thel
-    NPC_BLOOD_QUEEN_LANA_THEL                   = 37955,
+    CREATURE_PRINCE_VALANAR_ICC      = 37970,
+    CREATURE_PRINCE_KELESETH_ICC     = 37972,
+    CREATURE_PRINCE_TALDARAM_ICC     = 37973,
+    CREATURE_BLOOD_ORB_CONTROLLER    = 38008,
+    CREATURE_FLOATING_TRIGGER        = 30298,
+    CREATURE_DARK_NUCLEUS            = 38369,
+    CREATURE_BALL_OF_FLAME           = 38332,
+    CREATURE_BALL_OF_INFERNO_FLAME   = 38451,
+    CREATURE_KINETIC_BOMB_TARGET     = 38458,
+    CREATURE_KINETIC_BOMB            = 38454,
+    CREATURE_SHOCK_VORTEX            = 38422,
+    CREATURE_BLOOD_QUEEN_LANATHEL    = 37955,
+    CREATURE_SWARMING_SHADOWS        = 38163,
+    CREATURE_VALITHRIA_DREAMWALKER   = 36789,
+    CREATURE_PORTAL_NORMAL_MODE_PRE  = 38186,
+    CREATURE_PORTAL_NORMAL_MODE_NPC  = 37945,
+    CREATURE_PORTAL_HEROIC_MODE_PRE  = 38429,
+    CREATURE_PORTAL_HEROIC_MODE_NPC  = 38430,
+    CREATURE_WORM                    = 37907,
+    CREATURE_PORTAL                  = 37945,
+    CREATURE_CLOUD                   = 37985,
+    CREATURE_NIGHMARE                = 38421,
+    CREATURE_VOID                    = 38068,
+    CREATURE_ABOMINATION             = 37886,
+    CREATURE_SKELETON                = 36791,
+    CREATURE_ARCHMAGE                = 37868,
+    CREATURE_SUPPRESSER              = 37863,
+    CREATURE_ZOMBIE                  = 37934,
+    CREATURE_COMBAT_TRIGGER          = 38752,
+    CREATURE_SINDRAGOSA              = 36853,
+    CREATURE_ICE_TOMB                = 36980,
+    CREATURE_RIMEFANG                = 37533,
+    CREATURE_SPINESTALKER            = 37534,
+    CREATURE_LICH_KING               = 36597,
+    CREATURE_TIRION_ICC              = 38995,
+    CREAUTRE_MENETHIL                = 38579,
+    CREATURE_FROSTMOURNE_TRIGGER     = 38584,
+    CREATURE_TERENAS_F               = 36823, //for frostmourne
+    CREATURE_SPIRIT_WARDEN_F         = 36824,
+    CREATURE_ICE_SPHERE              = 36633,
+    CREATURE_DRUDGE_GHOUL            = 37695,
+    CREATURE_SHAMBLING_HORROR        = 37698,
+    CREATURE_VALKYR                  = 36609,
+    CREATURE_DEFILE                  = 38757,
+    CREATURE_RAGING_SPIRIT           = 36701,
+    CREATURE_TRIGGER                 = 38667,
+    CREATURE_VILE_SPIRIT             = 37799
 };
 
-enum GameObjectsIds
+enum eGameobjects
 {
-    // Lord Marrogar
-    GO_DOODAD_ICECROWN_ICEWALL02            = 201910,
-    GO_ICEWALL                              = 201911,
-    GO_LORD_MARROWGAR_S_ENTRANCE            = 201857,
-
-    // Lady Deathwhisper
-    GO_ORATORY_OF_THE_DAMNED_ENTRANCE       = 201563,
-    GO_LADY_DEATHWHISPER_ELEVATOR           = 202220,
-
-    // Deathbringer Saurfang
-    GO_SAURFANG_S_DOOR                      = 201825,
-    GO_DEATHBRINGER_S_CACHE_10N             = 202239,
-    GO_DEATHBRINGER_S_CACHE_25N             = 202240,
-    GO_DEATHBRINGER_S_CACHE_10H             = 202238,
-    GO_DEATHBRINGER_S_CACHE_25H             = 202241,
-    GO_SCOURGE_TRANSPORTER_SAURFANG         = 202244,
-
-    // Professor Putricide
-    GO_ORANGE_PLAGUE_MONSTER_ENTRANCE       = 201371,
-    GO_GREEN_PLAGUE_MONSTER_ENTRANCE        = 201370,
-    GO_SCIENTIST_AIRLOCK_DOOR_COLLISION     = 201612,
-    GO_SCIENTIST_AIRLOCK_DOOR_ORANGE        = 201613,
-    GO_SCIENTIST_AIRLOCK_DOOR_GREEN         = 201614,
-    GO_DOODAD_ICECROWN_ORANGETUBES02        = 201617,
-    GO_DOODAD_ICECROWN_GREENTUBES02         = 201618,
-    GO_SCIENTIST_ENTRANCE                   = 201372,
-    GO_DRINK_ME                             = 201584,
-
-    // Blood Prince Council
-    GO_CRIMSON_HALL_DOOR                    = 201376,
-    GO_BLOOD_ELF_COUNCIL_DOOR               = 201378,
-    GO_BLOOD_ELF_COUNCIL_DOOR_RIGHT         = 201377,
-
-    // Blood-Queen Lana'thel
-    GO_DOODAD_ICECROWN_BLOODPRINCE_DOOR_01  = 201746,
-    GO_DOODAD_ICECROWN_GRATE_01             = 201755,
-
-    // Valithria Dreamwalker
-    GO_GREEN_DRAGON_BOSS_ENTRANCE           = 201375,
-    GO_GREEN_DRAGON_BOSS_EXIT               = 201374,
-
-    // Sindragosa
-    GO_SINDRAGOSA_ENTRANCE_DOOR             = 201373,
-    GO_SINDRAGOSA_SHORTCUT_ENTRANCE_DOOR    = 201369,
-    GO_SINDRAGOSA_SHORTCUT_EXIT_DOOR        = 201379,
-};
-
-enum AchievementCriteriaIds
-{
-    // Lord Marrowgar
-    CRITERIA_BONED_10N                  = 12775,
-    CRITERIA_BONED_25N                  = 12962,
-    CRITERIA_BONED_10H                  = 13393,
-    CRITERIA_BONED_25H                  = 13394,
-
-    // Rotface
-    CRITERIA_DANCES_WITH_OOZES_10N      = 12984,
-    CRITERIA_DANCES_WITH_OOZES_25N      = 12966,
-    CRITERIA_DANCES_WITH_OOZES_10H      = 12985,
-    CRITERIA_DANCES_WITH_OOZES_25H      = 12983,
-
-    // Professor Putricide
-    CRITERIA_NAUSEA_10N                 = 12987,
-    CRITERIA_NAUSEA_25N                 = 12968,
-    CRITERIA_NAUSEA_10H                 = 12988,
-    CRITERIA_NAUSEA_25H                 = 12981,
-
-    // Blood Prince Council
-    CRITERIA_ORB_WHISPERER_10N          = 13033,
-    CRITERIA_ORB_WHISPERER_25N          = 12969,
-    CRITERIA_ORB_WHISPERER_10H          = 13034,
-    CRITERIA_ORB_WHISPERER_25H          = 13032,
-
-    // Blood-Queen Lana'thel
-    CRITERIA_KILL_LANA_THEL_10M         = 13340,
-    CRITERIA_KILL_LANA_THEL_25M         = 13360,
-    CRITERIA_ONCE_BITTEN_TWICE_SHY_10N  = 12780,
-    CRITERIA_ONCE_BITTEN_TWICE_SHY_25N  = 13012,
-    CRITERIA_ONCE_BITTEN_TWICE_SHY_10V  = 13011,
-    CRITERIA_ONCE_BITTEN_TWICE_SHY_25V  = 13013,
-};
-
-enum SharedActions
-{
-    // Festergut
-    ACTION_FESTERGUT_COMBAT     = -366260,
-    ACTION_FESTERGUT_GAS        = -366261,
-    ACTION_FESTERGUT_DEATH      = -366262,
-
-    // Rotface
-    ACTION_ROTFACE_COMBAT       = -366270,
-    ACTION_ROTFACE_OOZE         = -366271,
-    ACTION_ROTFACE_DEATH        = -366272,
-    ACTION_CHANGE_PHASE         = -366780
+    LORD_ICE_WALL_1                = 201910,
+    LORD_ICE_WALL_2                = 201911,
+    LORD_ENTRANCE                  = 201857,
+    ORATORY_ENTRANCE               = 201563,
+    LADY_ELEVATOR                  = 202220,
+    ORGRIM_S_HAMMER_HORDE_ICC      = 201812,
+    ORGRIM_S_HAMMER_ALLIANCE_ICC   = 201581,
+    THE_SKYBREAKER_HORDE_ICC       = 201811,
+    THE_SKYBREAKER_ALLIANCE_ICC    = 201580,
+    SAURFANG_DOOR                  = 201825,
+    BLOODWING_DOOR                 = 201920,
+    FROSTWING_DOOR                 = 201919,
+    CRIMSONHALL_DOOR               = 201376,
+    CRIMSONHALL_DOOR_1             = 201377,
+    CRIMSONHALL_DOOR_2             = 201378,
+    BLOODQUEEN_ELEVATOR            = 201755,
+    DRAGON_DOOR_1                  = 201375,
+    DRAGON_DOOR_2                  = 201374,
+    DRAGON_DOOR_3                  = 201379,
+    DREAMWALKER_DOOR_1             = 201380,
+    DREAMWALKER_DOOR_2             = 201381,
+    DREAMWALKER_DOOR_3             = 201382,
+    DREAMWALKER_DOOR_4             = 201383,
+    VALITHRIA_ELEVATOR             = 202234,
+    SINDRAGOSSA_ELEVATOR           = 196840,
+    SINDRAGOSSA_DOOR_1             = 201373,
+    SINDRAGOSSA_DOOR_2             = 201369,
+    PROF_COLLISION_DOOR            = 201612,
+    GREEN_PIPE                     = 201618,
+    ORANGE_PIPE                    = 201617,
+    OOZE_VALVE                     = 201615,
+    GAS_VALVE                      = 201616,
+    PROF_DOOR_GREEN                = 201614,
+    PROF_DOOR_ORANGE               = 201613,
+    ROTFACE_DOOR                   = 201370,
+    FESTERGUT_DOOR                 = 201371,
+    PROFESSOR_DOOR                 = 201372,
+    DRINK_ME                       = 201584,
+    SAURFANG_CACHE_10_N            = 202238,
+    SAURFANG_CACHE_25_N            = 202239,
+    SAURFANG_CACHE_10_H            = 202240,
+    SAURFANG_CACHE_25_H            = 202241,
+    DREAMWALKER_CACHE_10_N         = 201959,
+    DREAMWALKER_CACHE_25_N         = 202338,
+    DREAMWALKER_CACHE_10_H         = 202339,
+    DREAMWALKER_CACHE_25_H         = 202340,
+    ARTHAS_PLATFORM                = 202161,
+    FIRST_TELEPORT                 = 202242,
+    LORD_TELEPORT                  = 202243,
+    GUNSHIP_TELEPORT               = 202244,
+    SAURFANG_TELEPORT              = 202245,
+    CITADEL_TELEPORT               = 202235,
+    SINDRAGOSSA_TELEPORT           = 202246,
+    LICH_TELEPORT                  = 202223
 };
 
-#endif // DEF_ICECROWN_CITADEL_H
+#endif
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp b/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
old mode 100755
new mode 100644
index 7814137..215514e
--- a/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -15,162 +15,210 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "ObjectMgr.h"
-#include "ScriptMgr.h"
-#include "InstanceScript.h"
-#include "ScriptedCreature.h"
-#include "Map.h"
+#include "ScriptPCH.h"
 #include "icecrown_citadel.h"
 
-static const DoorData doorData[] =
+#define MAX_ENCOUNTER      13
+
+const Position SpawnLoc[]=
 {
-    {GO_LORD_MARROWGAR_S_ENTRANCE,           DATA_LORD_MARROWGAR,        DOOR_TYPE_ROOM,    BOUNDARY_N   },
-    {GO_ICEWALL,                             DATA_LORD_MARROWGAR,        DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
-    {GO_DOODAD_ICECROWN_ICEWALL02,           DATA_LORD_MARROWGAR,        DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
-    {GO_ORATORY_OF_THE_DAMNED_ENTRANCE,      DATA_LADY_DEATHWHISPER,     DOOR_TYPE_ROOM,    BOUNDARY_N   },
-    {GO_ORANGE_PLAGUE_MONSTER_ENTRANCE,      DATA_FESTERGUT,             DOOR_TYPE_ROOM,    BOUNDARY_E   },
-    {GO_GREEN_PLAGUE_MONSTER_ENTRANCE,       DATA_ROTFACE,               DOOR_TYPE_ROOM,    BOUNDARY_E   },
-    {GO_SCIENTIST_ENTRANCE,                  DATA_PROFESSOR_PUTRICIDE,   DOOR_TYPE_ROOM,    BOUNDARY_E   },
-    {GO_CRIMSON_HALL_DOOR,                   DATA_BLOOD_PRINCE_COUNCIL,  DOOR_TYPE_ROOM,    BOUNDARY_S   },
-    {GO_BLOOD_ELF_COUNCIL_DOOR,              DATA_BLOOD_PRINCE_COUNCIL,  DOOR_TYPE_PASSAGE, BOUNDARY_W   },
-    {GO_BLOOD_ELF_COUNCIL_DOOR_RIGHT,        DATA_BLOOD_PRINCE_COUNCIL,  DOOR_TYPE_PASSAGE, BOUNDARY_E   },
-    {GO_DOODAD_ICECROWN_BLOODPRINCE_DOOR_01, DATA_BLOOD_QUEEN_LANA_THEL, DOOR_TYPE_ROOM,    BOUNDARY_S   },
-    {GO_DOODAD_ICECROWN_GRATE_01,            DATA_BLOOD_QUEEN_LANA_THEL, DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
-    {GO_GREEN_DRAGON_BOSS_ENTRANCE,          DATA_VALITHRIA_DREAMWALKER, DOOR_TYPE_ROOM,    BOUNDARY_N   },
-    {GO_GREEN_DRAGON_BOSS_EXIT,              DATA_VALITHRIA_DREAMWALKER, DOOR_TYPE_PASSAGE, BOUNDARY_S   },
-    {GO_SINDRAGOSA_ENTRANCE_DOOR,            DATA_SINDRAGOSA,            DOOR_TYPE_ROOM,    BOUNDARY_S   },
-    {GO_SINDRAGOSA_SHORTCUT_ENTRANCE_DOOR,   DATA_SINDRAGOSA,            DOOR_TYPE_ROOM,    BOUNDARY_E   },
-    {GO_SINDRAGOSA_SHORTCUT_EXIT_DOOR,       DATA_SINDRAGOSA,            DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
-    {0,                                      0,                          DOOR_TYPE_ROOM,    BOUNDARY_NONE} // END
+    {4671.521f, 2481.815f, 343.365f, 3.166f} //spawn pos
 };
 
 class instance_icecrown_citadel : public InstanceMapScript
 {
     public:
-        instance_icecrown_citadel() : InstanceMapScript(ICCScriptName, 631) { }
+        instance_icecrown_citadel() : InstanceMapScript("instance_icecrown_citadel", 631) { }
 
         struct instance_icecrown_citadel_InstanceMapScript : public InstanceScript
         {
-            instance_icecrown_citadel_InstanceMapScript(InstanceMap* map) : InstanceScript(map)
+            instance_icecrown_citadel_InstanceMapScript(InstanceMap* pMap) : InstanceScript(pMap)
             {
-                SetBossNumber(MAX_ENCOUNTER);
-                LoadDoorData(doorData);
-                teamInInstance = 0;
-                ladyDeathwisperElevator = 0;
-                deathbringerSaurfang = 0;
-                saurfangDoor = 0;
-                saurfangEventNPC = 0;
-                deathbringersCache = 0;
-                saurfangTeleport = 0;
-                memset(putricidePipes, 0, 2*sizeof(uint64));
-                memset(putricideGates, 0, 2*sizeof(uint64));
-                putricideCollision = 0;
-                festergut = 0;
-                rotface = 0;
-                professorPutricide = 0;
-                putricideTable = 0;
-                memset(bloodCouncil, 0, 3*sizeof(uint64));
-                bloodCouncilController = 0;
-                bloodQueenLanaThel = 0;
-                isBonedEligible = true;
-                isOozeDanceEligible = true;
-                isNauseaEligible = true;
-                isOrbWhispererEligible = true;
-            }
-
-            void OnPlayerEnter(Player* player)
+                uiDifficulty = pMap->GetDifficulty();
+
+                uiLordMarrowgar         = 0;
+                uiLadyDeathwhisper      = 0;
+                uiGunship               = 0;
+                uiDeathbringerSaurfang  = 0;
+                uiFestergut             = 0;
+                uiRotface               = 0;
+                uiProfessorPutricide    = 0;
+                uiPrinceValanar         = 0;
+                uiPrinceKeleseth        = 0;
+                uiPrinceTaldaram        = 0;
+                uiBloodQueenLanathel    = 0;
+                uiValithriaDreamwalker  = 0;
+                uiSindragosa            = 0;
+                uiLichKing              = 0;
+                uiTirion                = 0;
+                uiSaurfangCache         = 0;
+
+                uiAngle                 = 0;
+                uiSpawn                 = 0;
+                uiBoned                 = 0;
+                uiAllYouCanEat          = 0;
+                uiNecroticStack         = 0;
+                uiBloodCouncilController = 0;
+                uiBeenWaiting           = 0;
+                uiNeckDeep              = 0;
+                uiIceWall1              = 0;
+                uiIceWall2              = 0;
+                uiMarrowgarEntrance     = 0;
+                uiLadyDeathwisperTransporter = 0;
+                uiOratoryDoor           = 0;
+                uiSaurfangDoor          = 0;
+                uiOrangeMonsterDoor     = 0;
+                uiGreenMonsterDoor      = 0;
+                uiProfCollisionDoor     = 0;
+                uiPutricideTable        = 0;
+                uiOrangePipe            = 0;
+                uiGreenPipe             = 0;
+                uiOozeValve             = 0;
+                uiGasValve              = 0;
+                uiProfDoorOrange        = 0;
+                uiProfDoorGreen         = 0;
+                uiRotfaceEntrance       = 0;
+                uiFestergurtEntrance    = 0;
+                uiProffesorDoor         = 0;
+                uiBloodwingDoor         = 0;
+                uiCrimsonHallDoor1      = 0;
+                uiCrimsonHallDoor2      = 0;
+                uiCrimsonHallDoor3      = 0;
+                uiBloodQueenTransporter = 0;
+                uiFrostwingDoor         = 0;
+                uiDragonDoor1           = 0;
+                uiDragonDoor2           = 0;
+                uiDragonDoor3           = 0;
+                uiRoostDoor1            = 0;
+                uiRoostDoor2            = 0;
+                uiRoostDoor3            = 0;
+                uiRoostDoor4            = 0;
+                uiValithriaTransporter  = 0;
+                uiSindragossaTransporter = 0;
+                uiSindragosaDoor1       = 0;
+                uiSindragosaDoor2       = 0;
+                uiFirstTp               = 0;
+                uiMarrowgarTp           = 0;
+                uiFlightWarTp           = 0;
+                uiSaurfangTp            = 0;
+                uiCitadelTp             = 0;
+                uiSindragossaTp         = 0;
+                uiLichTp                = 0;
+
+                memset(&uiEncounter, 0, sizeof(uiEncounter));
+            };
+
+            bool IsEncounterInProgress() const
             {
-                if (!teamInInstance)
-                    teamInInstance = player->GetTeam();
+                for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+                {
+                    if (uiEncounter[i] == IN_PROGRESS)
+                        return true;
+                }
+
+                return false;
             }
 
             void OnCreatureCreate(Creature* creature)
             {
-                if (!teamInInstance)
+                Map::PlayerList const &players = instance->GetPlayers();
+                uint32 TeamInInstance = 0;
+
+
+                if (!players.isEmpty())
                 {
-                    Map::PlayerList const &players = instance->GetPlayers();
-                    if (!players.isEmpty())
-                        if (Player* player = players.begin()->getSource())
-                            teamInInstance = player->GetTeam();
+                    if (Player* pPlayer = players.begin()->getSource())
+                        TeamInInstance = pPlayer->GetTeam();
                 }
-
-                switch (creature->GetEntry())
+                switch(creature->GetEntry())
                 {
-                    case NPC_KOR_KRON_GENERAL:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_ALLIANCE_COMMANDER, ALLIANCE);
+                    case CREATURE_KOR_KRON_GENERAL:
+                        if (TeamInInstance == ALLIANCE)
+                            creature->UpdateEntry(CREATURE_ALLIANCE_COMMANDER, ALLIANCE);
+                        break;
+                    case CREATURE_TORTUNOK:
+                        if (TeamInInstance == ALLIANCE)
+                            creature->UpdateEntry(CREATURE_ALANA_MOONSTRIKE, ALLIANCE);
                         break;
-                    case NPC_KOR_KRON_LIEUTENANT:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_SKYBREAKER_LIEUTENANT, ALLIANCE);
+                    case CREATURE_GERARDO_THE_SUAVE:
+                        if (TeamInInstance == ALLIANCE)
+                            creature->UpdateEntry(CREATURE_TALAN_MOONSTRIKE, ALLIANCE);
                         break;
-                    case NPC_TORTUNOK:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_ALANA_MOONSTRIKE, ALLIANCE);
+                    case CREATURE_UVLUS_BANEFIRE:
+                        if (TeamInInstance == ALLIANCE)
+                            creature->UpdateEntry(CREATURE_MALFUS_GRIMFROST, ALLIANCE);
                         break;
-                    case NPC_GERARDO_THE_SUAVE:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_TALAN_MOONSTRIKE, ALLIANCE);
+                    case CREATURE_IKFIRUS_THE_VILE:
+                        if (TeamInInstance == ALLIANCE)
+                            creature->UpdateEntry(CREATURE_YILI, ALLIANCE);
                         break;
-                    case NPC_UVLUS_BANEFIRE:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_MALFUS_GRIMFROST, ALLIANCE);
+                    case CREATURE_VOL_GUK:
+                        if (TeamInInstance == ALLIANCE)
+                            creature->UpdateEntry(CREATURE_JEDEBIA, ALLIANCE);
                         break;
-                    case NPC_IKFIRUS_THE_VILE:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_YILI, ALLIANCE);
+                    case CREATURE_HARAGG_THE_UNSEEN:
+                        if (TeamInInstance == ALLIANCE)
+                            creature->UpdateEntry(CREATURE_NIBY_THE_ALMIGHTY, ALLIANCE);
                         break;
-                    case NPC_VOL_GUK:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_JEDEBIA, ALLIANCE);
+                    case CREATURE_GARROSH_HELLSCREAM:
+                        if (TeamInInstance == ALLIANCE)
+                            creature->UpdateEntry(CREATURE_KING_VARIAN_WRYNN, ALLIANCE);
                         break;
-                    case NPC_HARAGG_THE_UNSEEN:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_NIBY_THE_ALMIGHTY, ALLIANCE);
+                    case CREATURE_SE_HIGH_OVERLORD_SAURFANG:
+                        if (TeamInInstance == ALLIANCE)
+                            creature->UpdateEntry(CREATURE_SE_MURADIN_BRONZEBEARD, ALLIANCE);
+                         break;
+                    case CREATURE_SE_KOR_KRON_REAVER:
+                        if (TeamInInstance == ALLIANCE)
+                            creature->UpdateEntry(CREATURE_SE_SKYBREAKER_MARINE, ALLIANCE);
                         break;
-                    case NPC_GARROSH_HELLSCREAM:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_KING_VARIAN_WRYNN, ALLIANCE);
+                    case CREATURE_MARROWGAR:
+                        uiLordMarrowgar = creature->GetGUID();
                         break;
-                    case NPC_DEATHBRINGER_SAURFANG:
-                        deathbringerSaurfang = creature->GetGUID();
+                    case CREATURE_DEATHWHISPER:
+                        uiLadyDeathwhisper = creature->GetGUID();
                         break;
-                    case NPC_SE_HIGH_OVERLORD_SAURFANG:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_SE_MURADIN_BRONZEBEARD, ALLIANCE);
-                    case NPC_SE_MURADIN_BRONZEBEARD:
-                        saurfangEventNPC = creature->GetGUID();
-                        creature->LastUsedScriptID = creature->GetScriptId();
+                    case CREATURE_GUNSHIP:
+                        uiGunship = creature->GetGUID();
                         break;
-                    case NPC_SE_KOR_KRON_REAVER:
-                        if (teamInInstance == ALLIANCE)
-                            creature->UpdateEntry(NPC_SE_SKYBREAKER_MARINE, ALLIANCE);
+                    case CREATURE_SAURFANG:
+                        uiDeathbringerSaurfang = creature->GetGUID();
                         break;
-                    case NPC_FESTERGUT:
-                        festergut = creature->GetGUID();
+                    case CREATURE_FESTERGURT:
+                        uiFestergut = creature->GetGUID();
                         break;
-                    case NPC_ROTFACE:
-                        rotface = creature->GetGUID();
+                    case CREATURE_ROTFACE:
+                        uiRotface = creature->GetGUID();
                         break;
-                    case NPC_PROFESSOR_PUTRICIDE:
-                        professorPutricide = creature->GetGUID();
+                    case CREATURE_PROFESSOR_PUTRICIDE:
+                        uiProfessorPutricide = creature->GetGUID();
                         break;
-                    case NPC_PRINCE_KELESETH:
-                        bloodCouncil[0] = creature->GetGUID();
+                    case CREATURE_PRINCE_VALANAR_ICC:
+                        uiPrinceValanar = creature->GetGUID();
                         break;
-                    case NPC_PRINCE_TALDARAM:
-                        bloodCouncil[1] = creature->GetGUID();
+                    case CREATURE_PRINCE_KELESETH_ICC:
+                        uiPrinceKeleseth = creature->GetGUID();
                         break;
-                    case NPC_PRINCE_VALANAR:
-                        bloodCouncil[2] = creature->GetGUID();
+                    case CREATURE_PRINCE_TALDARAM_ICC:
+                        uiPrinceTaldaram = creature->GetGUID();
                         break;
-                    case NPC_BLOOD_ORB_CONTROLLER:
-                        bloodCouncilController = creature->GetGUID();
+                    case CREATURE_BLOOD_ORB_CONTROLLER:
+                        uiBloodCouncilController = creature->GetGUID();
                         break;
-                    case NPC_BLOOD_QUEEN_LANA_THEL:
-                        bloodQueenLanaThel = creature->GetGUID();
+                    case CREATURE_BLOOD_QUEEN_LANATHEL:
+                        uiBloodQueenLanathel = creature->GetGUID();
                         break;
-                    default:
+                    case CREATURE_VALITHRIA_DREAMWALKER:
+                        uiValithriaDreamwalker = creature->GetGUID();
+                        break;
+                    case CREATURE_SINDRAGOSA:
+                        uiSindragosa = creature->GetGUID();
+                        break;
+                    case CREATURE_LICH_KING:
+                        uiLichKing = creature->GetGUID();
+                        break;
+                    case CREATURE_TIRION_ICC:
+                        uiTirion = creature->GetGUID();
                         break;
                 }
             }
@@ -179,416 +227,499 @@ class instance_icecrown_citadel : public InstanceMapScript
             {
                 switch (go->GetEntry())
                 {
-                    case GO_DOODAD_ICECROWN_ICEWALL02:
-                    case GO_ICEWALL:
-                    case GO_LORD_MARROWGAR_S_ENTRANCE:
-                    case GO_ORATORY_OF_THE_DAMNED_ENTRANCE:
-                    case GO_ORANGE_PLAGUE_MONSTER_ENTRANCE:
-                    case GO_GREEN_PLAGUE_MONSTER_ENTRANCE:
-                    case GO_SCIENTIST_ENTRANCE:
-                    case GO_CRIMSON_HALL_DOOR:
-                    case GO_BLOOD_ELF_COUNCIL_DOOR:
-                    case GO_BLOOD_ELF_COUNCIL_DOOR_RIGHT:
-                    case GO_DOODAD_ICECROWN_BLOODPRINCE_DOOR_01:
-                    case GO_DOODAD_ICECROWN_GRATE_01:
-                    case GO_GREEN_DRAGON_BOSS_ENTRANCE:
-                    case GO_GREEN_DRAGON_BOSS_EXIT:
-                    case GO_SINDRAGOSA_ENTRANCE_DOOR:
-                    case GO_SINDRAGOSA_SHORTCUT_ENTRANCE_DOOR:
-                    case GO_SINDRAGOSA_SHORTCUT_EXIT_DOOR:
-                        AddDoor(go, true);
-                        break;
-                    case GO_LADY_DEATHWHISPER_ELEVATOR:
-                        ladyDeathwisperElevator = go->GetGUID();
-                        if (GetBossState(DATA_LADY_DEATHWHISPER) == DONE)
-                        {
-                            go->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
-                            go->SetGoState(GO_STATE_READY);
-                        }
+                    case LORD_ICE_WALL_1:
+                        uiIceWall1 = go->GetGUID();
                         break;
-                    case GO_SAURFANG_S_DOOR:
-                        saurfangDoor = go->GetGUID();
+                    case LORD_ICE_WALL_2:
+                        uiIceWall2 = go->GetGUID();
                         break;
-                    case GO_DEATHBRINGER_S_CACHE_10N:
-                    case GO_DEATHBRINGER_S_CACHE_25N:
-                    case GO_DEATHBRINGER_S_CACHE_10H:
-                    case GO_DEATHBRINGER_S_CACHE_25H:
-                        deathbringersCache = go->GetGUID();
+                    case LORD_ENTRANCE:
+                        uiMarrowgarEntrance = go->GetGUID();
                         break;
-                    case GO_SCOURGE_TRANSPORTER_SAURFANG:
-                        saurfangTeleport = go->GetGUID();
+                    case ORATORY_ENTRANCE:
+                        uiOratoryDoor = go->GetGUID();
                         break;
-                    case GO_SCIENTIST_AIRLOCK_DOOR_COLLISION:
-                        putricideCollision = go->GetGUID();
-                        if (GetBossState(DATA_FESTERGUT) == DONE && GetBossState(DATA_ROTFACE) == DONE)
-                            HandleGameObject(putricideCollision, true, go);
+                    case SAURFANG_DOOR:
+                        uiSaurfangDoor = go->GetGUID();
                         break;
-                    case GO_SCIENTIST_AIRLOCK_DOOR_ORANGE:
-                        putricideGates[0] = go->GetGUID();
-                        if (GetBossState(DATA_FESTERGUT) == DONE && GetBossState(DATA_ROTFACE) == DONE)
-                            go->SetGoState(GO_STATE_ACTIVE_ALTERNATIVE);
-                        else if (GetBossState(DATA_FESTERGUT) == DONE)
-                            HandleGameObject(putricideGates[1], false, go);
+                    case BLOODWING_DOOR:
+                        uiBloodwingDoor = go->GetGUID();
                         break;
-                    case GO_SCIENTIST_AIRLOCK_DOOR_GREEN:
-                        putricideGates[1] = go->GetGUID();
-                        if (GetBossState(DATA_ROTFACE) == DONE && GetBossState(DATA_FESTERGUT) == DONE)
-                            go->SetGoState(GO_STATE_ACTIVE_ALTERNATIVE);
-                        else if (GetBossState(DATA_ROTFACE) == DONE)
-                            HandleGameObject(putricideGates[1], false, go);
+                    case FROSTWING_DOOR:
+                        uiFrostwingDoor = go->GetGUID();
                         break;
-                    case GO_DOODAD_ICECROWN_ORANGETUBES02:
-                        putricidePipes[0] = go->GetGUID();
-                        if (GetBossState(DATA_FESTERGUT) == DONE)
-                            HandleGameObject(putricidePipes[0], true, go);
+                    case CRIMSONHALL_DOOR:
+                        uiCrimsonHallDoor1 = go->GetGUID();
                         break;
-                    case GO_DOODAD_ICECROWN_GREENTUBES02:
-                        putricidePipes[1] = go->GetGUID();
-                        if (GetBossState(DATA_ROTFACE) == DONE)
-                            HandleGameObject(putricidePipes[1], true, go);
+                    case CRIMSONHALL_DOOR_1:
+                        uiCrimsonHallDoor2 = go->GetGUID();
                         break;
-                    case GO_DRINK_ME:
-                        putricideTable = go->GetGUID();
+                    case CRIMSONHALL_DOOR_2:
+                        uiCrimsonHallDoor3 = go->GetGUID();
                         break;
-                    default:
+                    case DRAGON_DOOR_1:
+                        uiDragonDoor1 = go->GetGUID();
                         break;
-                }
-            }
-
-            void OnGameObjectRemove(GameObject* go)
-            {
-                switch (go->GetEntry())
-                {
-                    case GO_DOODAD_ICECROWN_ICEWALL02:
-                    case GO_ICEWALL:
-                    case GO_LORD_MARROWGAR_S_ENTRANCE:
-                    case GO_ORATORY_OF_THE_DAMNED_ENTRANCE:
-                    case GO_ORANGE_PLAGUE_MONSTER_ENTRANCE:
-                    case GO_GREEN_PLAGUE_MONSTER_ENTRANCE:
-                    case GO_SCIENTIST_ENTRANCE:
-                    case GO_CRIMSON_HALL_DOOR:
-                    case GO_BLOOD_ELF_COUNCIL_DOOR:
-                    case GO_BLOOD_ELF_COUNCIL_DOOR_RIGHT:
-                    case GO_DOODAD_ICECROWN_BLOODPRINCE_DOOR_01:
-                    case GO_DOODAD_ICECROWN_GRATE_01:
-                    case GO_GREEN_DRAGON_BOSS_ENTRANCE:
-                    case GO_GREEN_DRAGON_BOSS_EXIT:
-                    case GO_SINDRAGOSA_ENTRANCE_DOOR:
-                    case GO_SINDRAGOSA_SHORTCUT_ENTRANCE_DOOR:
-                    case GO_SINDRAGOSA_SHORTCUT_EXIT_DOOR:
-                        AddDoor(go, false);
-                        break;
-                    default:
+                    case DRAGON_DOOR_2:
+                        uiDragonDoor2 = go->GetGUID();
+                        break;
+                    case DRAGON_DOOR_3:
+                        uiDragonDoor3 = go->GetGUID();
+                        break;
+                    case DREAMWALKER_DOOR_1:
+                        uiRoostDoor1 = go->GetGUID();
+                        break;
+                    case DREAMWALKER_DOOR_2:
+                        uiRoostDoor2 = go->GetGUID();
+                        break;
+                    case DREAMWALKER_DOOR_3:
+                        uiRoostDoor3 = go->GetGUID();
+                        break;
+                    case DREAMWALKER_DOOR_4:
+                        uiRoostDoor4 = go->GetGUID();
+                        break;
+                    case SINDRAGOSSA_DOOR_1:
+                        uiSindragosaDoor1 = go->GetGUID();
+                        break;
+                    case SINDRAGOSSA_DOOR_2:
+                        uiSindragosaDoor2 = go->GetGUID();
+                        break;
+                    case PROF_COLLISION_DOOR:
+                        uiProfCollisionDoor = go->GetGUID();
+                        if (uiEncounter[4] == NOT_STARTED)
+                            HandleGameObject(NULL, false, go);
+                        break;
+                    case GREEN_PIPE:
+                        uiGreenPipe = go->GetGUID();
+                        if (uiEncounter[5] == NOT_STARTED)
+                            HandleGameObject(NULL, false, go);
+                        break;
+                    case OOZE_VALVE:
+                        uiOozeValve = go->GetGUID();
+                        if (uiEncounter[5] == NOT_STARTED)
+                            HandleGameObject(NULL, false, go);
+                        break;
+                    case PROF_DOOR_GREEN:
+                        uiProfDoorGreen = go->GetGUID();
+                        if (uiEncounter[5] == DONE)
+                            HandleGameObject(NULL, true, go);
+                        break;
+                    case ORANGE_PIPE:
+                        uiOrangePipe = go->GetGUID();
+                        if (uiEncounter[4] == NOT_STARTED)
+                            HandleGameObject(NULL, false, go);
+                        break;
+                    case GAS_VALVE:
+                        uiGasValve = go->GetGUID();
+                        if (uiEncounter[4] == NOT_STARTED)
+                            HandleGameObject(NULL, false, go);
+                        break;
+                    case PROF_DOOR_ORANGE:
+                        uiProfDoorOrange = go->GetGUID();
+                        if (uiEncounter[4] == DONE)
+                            HandleGameObject(NULL, true, go);
+                        break;
+                    case ROTFACE_DOOR:
+                        uiGreenMonsterDoor = go->GetGUID();
+                        if (uiEncounter[5] == DONE)
+                            HandleGameObject(NULL, true, go);
+                        break;
+                    case FESTERGUT_DOOR:
+                        uiOrangeMonsterDoor = go->GetGUID();
+                        if (uiEncounter[4] == DONE)
+                            HandleGameObject(NULL, true, go);
+                        break;
+                    case PROFESSOR_DOOR:
+                        uiProffesorDoor = go->GetGUID();
+                        if (uiEncounter[6] == DONE)
+                            HandleGameObject(NULL, true, go);
+                        break;
+                    case DRINK_ME:
+                        uiPutricideTable = go->GetGUID();
+                        break;
+                    case SAURFANG_CACHE_10_N:
+                    case SAURFANG_CACHE_25_N:
+                    case SAURFANG_CACHE_10_H:
+                    case SAURFANG_CACHE_25_H:
+                        uiSaurfangCache = go->GetGUID();
+                        break;
+                    case DREAMWALKER_CACHE_10_N:
+                    case DREAMWALKER_CACHE_25_N:
+                    case DREAMWALKER_CACHE_10_H:
+                    case DREAMWALKER_CACHE_25_H:
+                        uiDreamwalkerCache = go->GetGUID();
+                        break;
+                    case LADY_ELEVATOR:
+                        uiLadyDeathwisperTransporter = go->GetGUID();
+                        break;
+                    case BLOODQUEEN_ELEVATOR:
+                        uiBloodQueenTransporter = go->GetGUID();
+                        break;
+                    case VALITHRIA_ELEVATOR:
+                        uiValithriaTransporter = go->GetGUID();
+                        break;
+                    case SINDRAGOSSA_ELEVATOR:
+                        uiSindragossaTransporter = go->GetGUID();
+                        break;
+                    case FIRST_TELEPORT:
+                        uiFirstTp = go->GetGUID();
+                        if (uiEncounter[0] == DONE)
+                            HandleGameObject(NULL, true, go);
+                        break;
+                    case LORD_TELEPORT:
+                        uiMarrowgarTp = go->GetGUID();
+                        if (uiEncounter[0] == NOT_STARTED)
+                            HandleGameObject(NULL, false, go);
+                        break;
+                    case GUNSHIP_TELEPORT:
+                        uiFlightWarTp = go->GetGUID();
+                        if (uiEncounter[2] == NOT_STARTED)
+                            HandleGameObject(NULL, false, go);
+                        break;
+                    case SAURFANG_TELEPORT:
+                        uiSaurfangTp = go->GetGUID();
+                        if (uiEncounter[4] == NOT_STARTED)
+                            HandleGameObject(NULL, false, go);
+                        break;
+                    case CITADEL_TELEPORT:
+                        uiCitadelTp = go->GetGUID();
+                        if (uiEncounter[4] == NOT_STARTED)
+                            HandleGameObject(NULL, false, go);
+                        break;
+                    case SINDRAGOSSA_TELEPORT:
+                        uiSindragossaTp = go->GetGUID();
+                        if(uiEncounter[10] == NOT_STARTED)
+                            HandleGameObject(NULL, true, go);
+                        break;
+                    case LICH_TELEPORT:
+                        uiLichTp = go->GetGUID();
+                        if(uiEncounter[10] == NOT_STARTED)
+                            HandleGameObject(NULL, false, go);
                         break;
                 }
             }
 
-            uint64 GetData64(uint32 type)
+            uint64 GetData64(uint32 identifier)
             {
-                switch (type)
+                switch(identifier)
                 {
-                    case DATA_DEATHBRINGER_SAURFANG:
-                        return deathbringerSaurfang;
-                    case DATA_SAURFANG_EVENT_NPC:
-                        return saurfangEventNPC;
-                    case GO_SAURFANG_S_DOOR:
-                        return saurfangDoor;
-                    case GO_SCOURGE_TRANSPORTER_SAURFANG:
-                        return saurfangTeleport;
-                    case DATA_FESTERGUT:
-                        return festergut;
-                    case DATA_ROTFACE:
-                        return rotface;
-                    case DATA_PROFESSOR_PUTRICIDE:
-                        return professorPutricide;
-                    case DATA_PUTRICIDE_TABLE:
-                        return putricideTable;
-                    case DATA_PRINCE_KELESETH_GUID:
-                        return bloodCouncil[0];
-                    case DATA_PRINCE_TALDARAM_GUID:
-                        return bloodCouncil[1];
-                    case DATA_PRINCE_VALANAR_GUID:
-                        return bloodCouncil[2];
-                    case DATA_BLOOD_PRINCES_CONTROL:
-                        return bloodCouncilController;
-                    case DATA_BLOOD_QUEEN_LANA_THEL:
-                        return bloodQueenLanaThel;
-                    default:
-                        break;
+                    case DATA_MARROWGAR:              return uiLordMarrowgar;
+                    case DATA_DEATHWHISPER:           return uiLadyDeathwhisper;
+                    case DATA_GUNSHIP_BATTLE:         return uiGunship;
+                    case DATA_SAURFANG:               return uiDeathbringerSaurfang;
+                    case DATA_FESTERGURT:             return uiFestergut;
+                    case DATA_ROTFACE:                return uiRotface;
+                    case DATA_PROFESSOR_PUTRICIDE:    return uiProfessorPutricide;
+                    case DATA_PRINCE_VALANAR_ICC:     return uiPrinceValanar;
+                    case DATA_PRINCE_KELESETH_ICC:    return uiPrinceKeleseth;
+                    case DATA_PRINCE_TALDARAM_ICC:    return uiPrinceTaldaram;
+                    case DATA_BLOOD_QUEEN_LANATHEL:   return uiBloodQueenLanathel;
+                    case DATA_VALITHRIA_DREAMWALKER:  return uiValithriaDreamwalker;
+                    case DATA_SINDRAGOSA:             return uiSindragosa;
+                    case DATA_LICH_KING:              return uiLichKing;
+                    case DATA_TIRION:                 return uiTirion;
+                    case DATA_ANGLE:                  return uiAngle;
+                    case DATA_BONED:                  return uiBoned;
+                    case DATA_ALL_YOU_CAN_EAT:        return uiAllYouCanEat;
+                    case DATA_BEEN_WAITING:           return uiBeenWaiting;
+                    case DATA_NECK_DEEP:              return uiNeckDeep;
+                    case DATA_BLOOD_PRINCES_CONTROL:  return uiBloodCouncilController;
+                    case DATA_NECROTIC_STACK:         return uiNecroticStack;
+                    case DATA_PUTRICIDE_TABLE:        return uiPutricideTable;
                 }
-
                 return 0;
             }
 
-            bool SetBossState(uint32 type, EncounterState state)
+            void SetData(uint32 type, uint32 data)
             {
-                if (!InstanceScript::SetBossState(type, state))
-                    return false;
-
-                switch (type)
+                switch(type)
                 {
-                    case DATA_LADY_DEATHWHISPER:
-                        SetBossState(DATA_GUNSHIP_EVENT, state);    // TEMP HACK UNTIL GUNSHIP SCRIPTED
-                        if (state == DONE)
-                            if (GameObject* elevator = instance->GetGameObject(ladyDeathwisperElevator))
+                    case DATA_MARROWGAR_EVENT:
+                        if(data == DONE)
+                        {
+                            HandleGameObject(uiIceWall1, true);
+                            HandleGameObject(uiIceWall2, true);
+                            HandleGameObject(uiMarrowgarEntrance, true);
+                            if (GameObject* FirstTp = instance->GetGameObject(uiFirstTp))
                             {
-                                elevator->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
-                                elevator->SetGoState(GO_STATE_READY);
+                                FirstTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                FirstTp->SetGoState(GOState(0));
                             }
+                            if (GameObject* MarrowgarTp = instance->GetGameObject(uiMarrowgarTp))
+                            {
+                                MarrowgarTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                MarrowgarTp->SetGoState(GOState(0));
+                            }
+                        }
+                        if(data == NOT_STARTED)
+                        {
+                            if (GameObject* FirstTp = instance->GetGameObject(uiFirstTp))
+                                FirstTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+
+                            if (GameObject* MarrowgarTp = instance->GetGameObject(uiMarrowgarTp))
+                                MarrowgarTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                        }
+                        if(data == IN_PROGRESS)
+                            HandleGameObject(uiMarrowgarEntrance, false);
+                        uiEncounter[0] = data;
                         break;
-                    case DATA_DEATHBRINGER_SAURFANG:
-                        switch (state)
+                    case DATA_DEATHWHISPER_EVENT:
+                        if(data == DONE)
+                        {
+                            HandleGameObject(uiOratoryDoor, true);
+                            if (GameObject* go = instance->GetGameObject(uiLadyDeathwisperTransporter))
+                            {
+                                go->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
+                                go->SetGoState(GO_STATE_READY);
+                            }
+                            if (GameObject* FlightWarTp = instance->GetGameObject(uiFlightWarTp))
+                            {
+                                FlightWarTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                FlightWarTp->SetGoState(GOState(0));
+                            }
+                            if (GameObject* SaurfangTp = instance->GetGameObject(uiSaurfangTp))
+                            {
+                                SaurfangTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                SaurfangTp->SetGoState(GOState(0));
+                            }
+                        }
+                        if(data == NOT_STARTED)
+                        {
+                            if (GameObject* FlightWarTp = instance->GetGameObject(uiFlightWarTp))
+                                FlightWarTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+
+                            if (GameObject* SaurfangTp = instance->GetGameObject(uiSaurfangTp))
+                                SaurfangTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+
+                        }
+                        if(data == IN_PROGRESS)
+                            HandleGameObject(uiOratoryDoor, false);
+                        uiEncounter[1] = data;
+                        break;
+                    /*case DATA_GUNSHIP_BATTLE_EVENT:
+                        switch(data)
                         {
                             case DONE:
-                                DoRespawnGameObject(deathbringersCache, 7*DAY);
-                            case NOT_STARTED:
-                                if (GameObject* teleporter = instance->GetGameObject(saurfangTeleport))
-                                {
-                                    HandleGameObject(saurfangTeleport, true, teleporter);
-                                    teleporter->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
-                                }
                                 break;
-                            default:
+                            case NOT_STARTED:
                                 break;
                         }
-                        break;
-                    case DATA_FESTERGUT:
-                        if (state == DONE)
+                        uiEncounter[2] = data;
+                        break;*/
+                    case DATA_SAURFANG_EVENT:
+                        if(data == DONE)
                         {
-                            if (GetBossState(DATA_ROTFACE) == DONE)
+                            if (GameObject* pChest = instance->GetGameObject(uiSaurfangCache))
+                                pChest->SetRespawnTime(pChest->GetRespawnDelay());
+
+                            if (GameObject* CitadelTp = instance->GetGameObject(uiCitadelTp))
                             {
-                                HandleGameObject(putricideCollision, true);
-                                if (GameObject* go = instance->GetGameObject(putricideGates[0]))
-                                    go->SetGoState(GO_STATE_ACTIVE_ALTERNATIVE);
-                                if (GameObject* go = instance->GetGameObject(putricideGates[1]))
-                                    go->SetGoState(GO_STATE_ACTIVE_ALTERNATIVE);
+                                CitadelTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                CitadelTp->SetGoState(GOState(0));
                             }
-                            else
-                                HandleGameObject(putricideGates[0], false);
-                            HandleGameObject(putricidePipes[0], true);
+                            HandleGameObject(uiSaurfangDoor, true);
+                            HandleGameObject(uiBloodwingDoor, true);
+                            HandleGameObject(uiFrostwingDoor, true);
+                        }
+                        if(data == NOT_STARTED)
+                        {
+                            if (GameObject* CitadelTp = instance->GetGameObject(uiCitadelTp))
+                                CitadelTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
                         }
+                        uiEncounter[3] = data;
                         break;
-                    case DATA_ROTFACE:
-                        if (state == DONE)
+                    case DATA_FESTERGURT_EVENT:
+                        if(data == DONE)
                         {
-                            if (GetBossState(DATA_FESTERGUT) == DONE)
+                            HandleGameObject(uiOrangeMonsterDoor, true);
+                            HandleGameObject(uiOrangePipe, true);
+                            HandleGameObject(uiGasValve, true);
+                            if (uiEncounter[5] == DONE)
                             {
-                                HandleGameObject(putricideCollision, true);
-                                if (GameObject* go = instance->GetGameObject(putricideGates[0]))
-                                    go->SetGoState(GO_STATE_ACTIVE_ALTERNATIVE);
-                                if (GameObject* go = instance->GetGameObject(putricideGates[1]))
-                                    go->SetGoState(GO_STATE_ACTIVE_ALTERNATIVE);
+                                HandleGameObject(uiProfCollisionDoor, true);
+                                if (GameObject* Oprofessordoor = instance->GetGameObject(uiProfDoorOrange))
+                                {
+                                    Oprofessordoor->SetGoState(GOState(2));
+                                }
                             }
-                            else
-                                HandleGameObject(putricideGates[1], false);
-                            HandleGameObject(putricidePipes[1], true);
                         }
+                        if(data == NOT_STARTED)
+                        {
+                            HandleGameObject(uiOrangeMonsterDoor, true);
+                            HandleGameObject(uiOrangePipe, false);
+                            HandleGameObject(uiGasValve, false);
+                            HandleGameObject(uiProfDoorOrange, false);
+                        }
+                        if(data == IN_PROGRESS)
+                        {
+                            HandleGameObject(uiOrangeMonsterDoor, false);
+                            HandleGameObject(uiOrangePipe, false);
+                            HandleGameObject(uiGasValve, false);
+                            HandleGameObject(uiProfDoorOrange, false);
+                        }
+                        uiEncounter[4] = data;
                         break;
-                    case DATA_BLOOD_PRINCE_COUNCIL:
-                    case DATA_BLOOD_QUEEN_LANA_THEL:
-                    case DATA_VALITHRIA_DREAMWALKER:
-                    case DATA_SINDRAGOSA:
-                    case DATA_THE_LICH_KING:
-                        break;
-                    default:
-                        break;
-                 }
-
-                 return true;
-            }
-
-            void SetData(uint32 type, uint32 data)
-            {
-                switch (type)
-                {
-                    case DATA_BONED_ACHIEVEMENT:
-                        isBonedEligible = data ? true : false;
-                        break;
-                    case DATA_OOZE_DANCE_ACHIEVEMENT:
-                        isOozeDanceEligible = data ? true : false;
-                        break;
-                    case DATA_NAUSEA_ACHIEVEMENT:
-                        isNauseaEligible = data ? true : false;
-                        break;
-                    case DATA_ORB_WHISPERER_ACHIEVEMENT:
-                        isOrbWhispererEligible = data ? true : false;
-                        break;
-                    default:
-                        break;
-                }
-            }
-
-            bool CheckAchievementCriteriaMeet(uint32 criteria_id, Player const* /*source*/, Unit const* /*target*/, uint32 /*miscvalue1*/)
-            {
-                switch (criteria_id)
-                {
-                    case CRITERIA_BONED_10N:
-                    case CRITERIA_BONED_25N:
-                    case CRITERIA_BONED_10H:
-                    case CRITERIA_BONED_25H:
-                        return isBonedEligible;
-                    case CRITERIA_DANCES_WITH_OOZES_10N:
-                    case CRITERIA_DANCES_WITH_OOZES_25N:
-                    case CRITERIA_DANCES_WITH_OOZES_10H:
-                    case CRITERIA_DANCES_WITH_OOZES_25H:
-                        return isOozeDanceEligible;
-                    case CRITERIA_NAUSEA_10N:
-                    case CRITERIA_NAUSEA_25N:
-                    case CRITERIA_NAUSEA_10H:
-                    case CRITERIA_NAUSEA_25H:
-                        return isNauseaEligible;
-                    case CRITERIA_ORB_WHISPERER_10N:
-                    case CRITERIA_ORB_WHISPERER_25N:
-                    case CRITERIA_ORB_WHISPERER_10H:
-                    case CRITERIA_ORB_WHISPERER_25H:
-                        return isOrbWhispererEligible;
-                    // Only one criteria for both modes, need to do it like this
-                    case CRITERIA_KILL_LANA_THEL_10M:
-                    case CRITERIA_ONCE_BITTEN_TWICE_SHY_10N:
-                    case CRITERIA_ONCE_BITTEN_TWICE_SHY_10V:
-                        return CAST_INST(InstanceMap, instance)->GetMaxPlayers() == 10;
-                    case CRITERIA_KILL_LANA_THEL_25M:
-                    case CRITERIA_ONCE_BITTEN_TWICE_SHY_25N:
-                    case CRITERIA_ONCE_BITTEN_TWICE_SHY_25V:
-                        return CAST_INST(InstanceMap, instance)->GetMaxPlayers() == 25;
-                    default:
-                        break;
-                }
-
-                return false;
-            }
-
-            bool CheckRequiredBosses(uint32 bossId, Player const* player = NULL) const
-            {
-                if (player && player->isGameMaster())
-                    return true;
-
-                switch (bossId)
-                {
-                    case DATA_THE_LICH_KING:
-                        if (!CheckPlagueworks(bossId))
-                            return false;
-                        if (!CheckCrimsonHalls(bossId))
-                            return false;
-                        if (!CheckFrostwingHalls(bossId))
-                            return false;
-                        break;
-                    case DATA_SINDRAGOSA:
-                    case DATA_VALITHRIA_DREAMWALKER:
-                        if (!CheckFrostwingHalls(bossId))
-                            return false;
-                        break;
-                    case DATA_BLOOD_QUEEN_LANA_THEL:
-                    case DATA_BLOOD_PRINCE_COUNCIL:
-                        if (!CheckCrimsonHalls(bossId))
-                            return false;
-                        break;
-                    case DATA_FESTERGUT:
-                    case DATA_ROTFACE:
-                    case DATA_PROFESSOR_PUTRICIDE:
-                        if (!CheckPlagueworks(bossId))
-                            return false;
-                        break;
-                    default:
-                        break;
-                }
-
-                if (!CheckLowerSpire(bossId))
-                    return false;
-
-                return true;
-            }
+                    case DATA_ROTFACE_EVENT:
+                        if(data == DONE)
+                        {
+                            HandleGameObject(uiGreenMonsterDoor, true);
+                            HandleGameObject(uiGreenPipe, true);
+                            HandleGameObject(uiOozeValve, true);
+                            if (uiEncounter[4] == DONE)
+                            {
+                                HandleGameObject(uiProfCollisionDoor, true);
+                                if (GameObject* Gprofessordoor = instance->GetGameObject(uiProfDoorGreen))
+                                {
+                                    Gprofessordoor->SetGoState(GOState(2));
+                                }
+                            }
+                        }
+                        if(data == NOT_STARTED)
+                        {
+                            HandleGameObject(uiGreenMonsterDoor, true);
+                            HandleGameObject(uiGreenPipe, false);
+                            HandleGameObject(uiOozeValve, false);
+                            HandleGameObject(uiProfDoorGreen, false);
+                        }
+                        if(data == IN_PROGRESS)
+                        {
+                            HandleGameObject(uiGreenMonsterDoor, false);
+                            HandleGameObject(uiGreenPipe, false);
+                            HandleGameObject(uiOozeValve, false);
+                            HandleGameObject(uiProfDoorGreen, false);
+                        }
+                        uiEncounter[5] = data;
+                        break;
+                    case DATA_PROFESSOR_PUTRICIDE_EVENT:
+                        if(data == DONE)
+                            HandleGameObject(uiProffesorDoor, true);
+                        if(data == NOT_STARTED)
+                            HandleGameObject(uiProffesorDoor, true);
+                        if(data == IN_PROGRESS)
+                            HandleGameObject(uiProffesorDoor, false);
+                        uiEncounter[6] = data;
+                        break;
+                    case DATA_BLOOD_PRINCE_COUNCIL_EVENT:
+                        if(data == DONE)
+                        {
+                            HandleGameObject(uiCrimsonHallDoor1, true);
+                            HandleGameObject(uiCrimsonHallDoor2, true);
+                            HandleGameObject(uiCrimsonHallDoor3, true);
+                        }
+                        if(data == NOT_STARTED)
+                            HandleGameObject(uiCrimsonHallDoor1, true);
 
-            bool CheckPlagueworks(uint32 bossId) const
-            {
-                switch (bossId)
-                {
-                    case DATA_THE_LICH_KING:
-                        if (GetBossState(DATA_PROFESSOR_PUTRICIDE) != DONE)
-                            return false;
-                        // no break
-                    case DATA_PROFESSOR_PUTRICIDE:
-                        if (GetBossState(DATA_FESTERGUT) != DONE || GetBossState(DATA_ROTFACE) != DONE)
-                            return false;
+                        if(data == IN_PROGRESS)
+                            HandleGameObject(uiCrimsonHallDoor1, false);
+                        uiEncounter[7] = data;
                         break;
-                    default:
+                    case DATA_BLOOD_QUEEN_LANATHEL_EVENT:
+                        if(data == DONE)
+                        {
+                            if (GameObject* go = instance->GetGameObject(uiBloodQueenTransporter))
+                            {
+                                go->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
+                                go->SetGoState(GO_STATE_READY);
+                            }
+                        }
+                        uiEncounter[8] = data;
                         break;
-                }
-
-                return true;
-            }
+                    case DATA_VALITHRIA_DREAMWALKER_EVENT:
+                        if(data == DONE)
+                        {
+                            if (GameObject* pChest = instance->GetGameObject(uiDreamwalkerCache))
+                                pChest->SetRespawnTime(pChest->GetRespawnDelay());
 
-            bool CheckCrimsonHalls(uint32 bossId) const
-            {
-                switch (bossId)
-                {
-                    case DATA_THE_LICH_KING:
-                        if (GetBossState(DATA_BLOOD_QUEEN_LANA_THEL) != DONE)
-                            return false;
-                        // no break
-                    case DATA_BLOOD_QUEEN_LANA_THEL:
-                        if (GetBossState(DATA_BLOOD_PRINCE_COUNCIL) != DONE)
-                            return false;
+                            if (GameObject* SindragossaTp = instance->GetGameObject(uiSindragossaTp))
+                            {
+                                SindragossaTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                SindragossaTp->SetGoState(GOState(0));
+                            }
+                            if (GameObject* go = instance->GetGameObject(uiValithriaTransporter))
+                            {
+                                go->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
+                                go->SetGoState(GO_STATE_READY);
+                            }
+                            if (GameObject* go = instance->GetGameObject(uiSindragossaTransporter))
+                            {
+                                go->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
+                                go->SetGoState(GO_STATE_READY);
+                            }
+                            HandleGameObject(uiDragonDoor1, true);
+                            HandleGameObject(uiDragonDoor2, true);
+                            HandleGameObject(uiDragonDoor3, true);
+                        }
+                        if(data == NOT_STARTED)
+                        {
+                            if (GameObject* SindragossaTp = instance->GetGameObject(uiSindragossaTp))
+                                SindragossaTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                        }
+                        if(data == IN_PROGRESS)
+                        {
+                            HandleGameObject(uiDragonDoor1, false);
+                            HandleGameObject(uiRoostDoor3, true);
+                            HandleGameObject(uiRoostDoor2, true);
+                            if (uiDifficulty == RAID_DIFFICULTY_25MAN_NORMAL || uiDifficulty == RAID_DIFFICULTY_25MAN_HEROIC)
+                            {
+                                HandleGameObject(uiRoostDoor1, true);
+                                HandleGameObject(uiRoostDoor4, true);
+                            }
+                        }
+                        uiEncounter[9] = data;
                         break;
-                    default:
+                    case DATA_SINDRAGOSA_EVENT:
+                        if(data == DONE)
+                        {
+                            HandleGameObject(uiSindragosaDoor1, true);
+                            HandleGameObject(uiSindragosaDoor2, true);
+                        }
+                        uiEncounter[10] = data;
                         break;
-                }
-
-                return true;
-            }
-
-            bool CheckFrostwingHalls(uint32 bossId) const
-            {
-                switch (bossId)
-                {
-                    case DATA_THE_LICH_KING:
-                        if (GetBossState(DATA_SINDRAGOSA) != DONE)
-                            return false;
-                        // no break
-                    case DATA_SINDRAGOSA:
-                        if (GetBossState(DATA_VALITHRIA_DREAMWALKER) != DONE)
-                            return false;
+                    case DATA_LICH_KING_EVENT:
+                        uiEncounter[11] = data;
                         break;
-                    default:
+                    case DATA_SPAWN:
+                        if(data >= 2)
+                            Creature* sindragosa = instance->SummonCreature(CREATURE_SINDRAGOSA, SpawnLoc[0]);
                         break;
                 }
 
-                return true;
+                if (data == DONE)
+                    SaveToDB();
             }
 
-            bool CheckLowerSpire(uint32 bossId) const
+            uint32 GetData(uint32 type)
             {
-                switch (bossId)
+                switch(type)
                 {
-                    case DATA_THE_LICH_KING:
-                    case DATA_SINDRAGOSA:
-                    case DATA_BLOOD_QUEEN_LANA_THEL:
-                    case DATA_PROFESSOR_PUTRICIDE:
-                    case DATA_VALITHRIA_DREAMWALKER:
-                    case DATA_BLOOD_PRINCE_COUNCIL:
-                    case DATA_ROTFACE:
-                    case DATA_FESTERGUT:
-                        if (GetBossState(DATA_DEATHBRINGER_SAURFANG) != DONE)
-                            return false;
-                        // no break
-                    case DATA_DEATHBRINGER_SAURFANG:
-                        if (GetBossState(DATA_GUNSHIP_EVENT) != DONE)
-                            return false;
-                        // no break
-                    case DATA_GUNSHIP_EVENT:
-                        if (GetBossState(DATA_LADY_DEATHWHISPER) != DONE)
-                            return false;
-                        // no break
-                    case DATA_LADY_DEATHWHISPER:
-                        if (GetBossState(DATA_LORD_MARROWGAR) != DONE)
-                            return false;
-                        // no break
-                    case DATA_LORD_MARROWGAR:
-                    default:
-                        break;
+                case DATA_MARROWGAR_EVENT:
+                    return uiEncounter[0];
+                case DATA_DEATHWHISPER_EVENT:
+                    return uiEncounter[1];
+                case DATA_GUNSHIP_BATTLE_EVENT:
+                    return uiEncounter[2];
+                case DATA_SAURFANG_EVENT:
+                    return uiEncounter[3];
+                case DATA_FESTERGURT_EVENT:
+                    return uiEncounter[4];
+                case DATA_ROTFACE_EVENT:
+                    return uiEncounter[5];
+                case DATA_PROFESSOR_PUTRICIDE_EVENT:
+                    return uiEncounter[6];
+                case DATA_BLOOD_PRINCE_COUNCIL_EVENT:
+                    return uiEncounter[7];
+                case DATA_BLOOD_QUEEN_LANATHEL_EVENT:
+                    return uiEncounter[8];
+                case DATA_VALITHRIA_DREAMWALKER_EVENT:
+                    return uiEncounter[9];
+                case DATA_SINDRAGOSA_EVENT:
+                    return uiEncounter[10];
+                case DATA_LICH_KING_EVENT:
+                    return uiEncounter[11];
+                case DATA_SPAWN:
+                    return uiEncounter[12];
                 }
-
-                return true;
+                return 0;
             }
 
             std::string GetSaveData()
@@ -596,7 +727,9 @@ class instance_icecrown_citadel : public InstanceMapScript
                 OUT_SAVE_INST_DATA;
 
                 std::ostringstream saveStream;
-                saveStream << "I C " << GetBossSaveData();
+                saveStream << "I C" << uiEncounter[0] << " " << uiEncounter[1] << " " << uiEncounter[2] << " " << uiEncounter[3]
+                << " " << uiEncounter[4] << " " << uiEncounter[5] << " " << uiEncounter[6] << " " << uiEncounter[7] << " " << uiEncounter[8]
+                << " " << uiEncounter[9] << " " << uiEncounter[10] << " " << uiEncounter[11];
 
                 OUT_SAVE_INST_DATA_COMPLETE;
                 return saveStream.str();
@@ -613,52 +746,116 @@ class instance_icecrown_citadel : public InstanceMapScript
                 OUT_LOAD_INST_DATA(in);
 
                 char dataHead1, dataHead2;
+                uint32 data0,data1,data2,data3,data4,data5,data6,data7,data8,data9,data10,data11;
 
                 std::istringstream loadStream(in);
-                loadStream >> dataHead1 >> dataHead2;
+                loadStream >> dataHead1 >> dataHead2 >> data0 >> data1 >> data2 >> data3 >> data4 >> data5 >> data6 >> data7 >> data8 >> data9 >> data10 >> data11;
 
                 if (dataHead1 == 'I' && dataHead2 == 'C')
                 {
+                    uiEncounter[0] = data0;
+                    uiEncounter[1] = data1;
+                    uiEncounter[2] = data2;
+                    uiEncounter[3] = data3;
+                    uiEncounter[4] = data4;
+                    uiEncounter[5] = data5;
+                    uiEncounter[6] = data6;
+                    uiEncounter[7] = data7;
+                    uiEncounter[8] = data8;
+                    uiEncounter[9] = data9;
+                    uiEncounter[10] = data10;
+                    uiEncounter[11] = data11;
+
                     for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
                     {
-                        uint32 tmpState;
-                        loadStream >> tmpState;
-                        if (tmpState == IN_PROGRESS || tmpState > SPECIAL)
-                            tmpState = NOT_STARTED;
-                        SetBossState(i, EncounterState(tmpState));
+                        loadStream >> uiEncounter[i];
+
+                        if (uiEncounter[i] == IN_PROGRESS)
+                            uiEncounter[i] = NOT_STARTED;
                     }
+
                 } else OUT_LOAD_INST_DATA_FAIL;
 
                 OUT_LOAD_INST_DATA_COMPLETE;
             }
 
         private:
-            uint64 ladyDeathwisperElevator;
-            uint64 deathbringerSaurfang;
-            uint64 saurfangDoor;
-            uint64 saurfangEventNPC;  // Muradin Bronzebeard or High Overlord Saurfang
-            uint64 deathbringersCache;
-            uint64 saurfangTeleport;
-            uint64 putricidePipes[2];
-            uint64 putricideGates[2];
-            uint64 putricideCollision;
-            uint64 festergut;
-            uint64 rotface;
-            uint64 professorPutricide;
-            uint64 putricideTable;
-            uint64 bloodCouncil[3];
-            uint64 bloodCouncilController;
-            uint64 bloodQueenLanaThel;
-            uint32 teamInInstance;
-            bool isBonedEligible;
-            bool isOozeDanceEligible;
-            bool isNauseaEligible;
-            bool isOrbWhispererEligible;
+            uint64 uiLordMarrowgar;
+            uint64 uiLadyDeathwhisper;
+            uint64 uiGunship;
+            uint64 uiDeathbringerSaurfang;
+            uint64 uiFestergut;
+            uint64 uiRotface;
+            uint64 uiProfessorPutricide;
+            uint64 uiPrinceValanar;
+            uint64 uiPrinceKeleseth;
+            uint64 uiPrinceTaldaram;
+            uint64 uiBloodQueenLanathel;
+            uint64 uiValithriaDreamwalker;
+            uint64 uiSindragosa;
+            uint64 uiLichKing;
+            uint64 uiTirion;
+            uint64 uiIceWall1;
+            uint64 uiIceWall2;
+            uint64 uiMarrowgarEntrance;
+            uint64 uiFrozenThrone;
+            uint64 uiSaurfangCache;
+            uint64 uiLadyDeathwisperTransporter;
+            uint64 uiOratoryDoor;
+            uint64 uiSaurfangDoor;
+            uint64 uiOrangeMonsterDoor;
+            uint64 uiGreenMonsterDoor;
+            uint64 uiProfCollisionDoor;
+            uint64 uiPutricideTable;
+            uint64 uiOrangePipe;
+            uint64 uiGreenPipe;
+            uint64 uiOozeValve;
+            uint64 uiGasValve;
+            uint64 uiProfDoorOrange;
+            uint64 uiProfDoorGreen;
+            uint64 uiRotfaceEntrance;
+            uint64 uiFestergurtEntrance;
+            uint64 uiProffesorDoor;
+            uint64 uiBloodwingDoor;
+            uint64 uiCrimsonHallDoor1;
+            uint64 uiCrimsonHallDoor2;
+            uint64 uiCrimsonHallDoor3;
+            uint64 uiBloodQueenTransporter;
+            uint64 uiFrostwingDoor;
+            uint64 uiDragonDoor1;
+            uint64 uiDragonDoor2;
+            uint64 uiDragonDoor3;
+            uint64 uiRoostDoor1;
+            uint64 uiRoostDoor2;
+            uint64 uiRoostDoor3;
+            uint64 uiRoostDoor4;
+            uint64 uiValithriaTransporter;
+            uint64 uiSindragossaTransporter;
+            uint64 uiDreamwalkerCache;
+            uint64 uiSindragosaDoor1;
+            uint64 uiSindragosaDoor2;
+            uint64 uiFirstTp;
+            uint64 uiMarrowgarTp;
+            uint64 uiFlightWarTp;
+            uint64 uiSaurfangTp;
+            uint64 uiCitadelTp;
+            uint64 uiSindragossaTp;
+            uint64 uiLichTp;
+            uint64 uiBloodCouncilController;
+            uint8 uiDifficulty;
+            uint8 uiBoned;
+            uint8 uiSpawn;
+            uint8 uiAllYouCanEat;
+            uint8 uiBeenWaiting;
+            uint8 uiNeckDeep;
+            uint8 uiNecroticStack;
+            uint8 uiAngle;
+            uint32 uiEncounter[MAX_ENCOUNTER];
         };
 
-        InstanceScript* GetInstanceScript(InstanceMap* map) const
+        InstanceScript* GetInstanceScript(InstanceMap* pMap) const
         {
-            return new instance_icecrown_citadel_InstanceMapScript(map);
+            return new instance_icecrown_citadel_InstanceMapScript(pMap);
         }
 };
 
-- 
1.5.6.5

