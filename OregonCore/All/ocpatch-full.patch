diff -Nuar oregoncore-current/sql/oc-patch/world-areaguardnpc.sql oregoncore-pq/sql/oc-patch/world-areaguardnpc.sql
--- oregoncore-current/sql/oc-patch/world-areaguardnpc.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-areaguardnpc.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,26 @@
+-- Table structure for table `npc_areaguard`
+
+CREATE TABLE IF NOT EXISTS `npc_areaguard` (
+  `creature_entry` mediumint(8) unsigned NOT NULL,
+  `guard_type` tinyint(3) unsigned NOT NULL default '0' COMMENT '0=All,1=Team,2=SecLvl,3=PlrLvl,4=Guild,5=PlrGuid',
+  `trigger_distance` float NOT NULL default '65' COMMENT 'In Feet - Max is 65',
+  `req_value` tinyint(3) unsigned NOT NULL default '0' COMMENT 'For Team 1=Ally,2=Horde',
+  `tele_map` mediumint(8) unsigned NOT NULL default '1' COMMENT 'Dflt tele dest is Ratchet',
+  `tele_x` float NOT NULL default '-955.726',
+  `tele_y` float NOT NULL default '-3747.16',
+  `tele_z` float NOT NULL default '5.47817',
+  `tele_o` float NOT NULL default '1.6369',
+  `comment` varchar(40) NOT NULL,
+  PRIMARY KEY  (`creature_entry`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='NPC Area Guard';
+
+-- Dumping data for table `npc_areaguard`
+
+INSERT INTO `npc_areaguard` (`creature_entry`, `guard_type`, `trigger_distance`, `req_value`, `tele_map`, `tele_x`, `tele_y`, `tele_z`, `tele_o`, `comment`) VALUES
+(92015, 0, 65, 0, 1, -955.726, -3747.16, 5.47817, 1.6369, 'Teleport all non-GM players to Ratchet');
+
+DELETE FROM `creature_template` WHERE `entry` = 92015;
+
+INSERT INTO `creature_template` (`entry`, `heroic_entry`, `modelid_A`, `modelid_A2`, `modelid_H`, `modelid_H2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `minhealth`, `maxhealth`, `minmana`, `maxmana`, `armor`, `faction_A`, `faction_H`, `npcflag`, `speed`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `baseattacktime`, `rangeattacktime`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `class`, `race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `PetSpellDataId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `RacialLeader`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(92015, 0, 10458, 0, 0, 0, 'Guard', '', NULL, 0, 70, 70, 12000, 12000, 4000, 4000, 12000, 35, 35, 129, 8, 1, 0, 2000, 50000, 0, 0, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 20, 20, 20, 20, 20, 20, 0, 0, 0, 0, 0, 521411, 521411, '', 0, 3, 0, 1, 0, 0, 0, 'npc_areaguard');
+
diff -Nuar oregoncore-current/sql/oc-patch/world-autobroadcast.sql oregoncore-pq/sql/oc-patch/world-autobroadcast.sql
--- oregoncore-current/sql/oc-patch/world-autobroadcast.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-autobroadcast.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,31 @@
+--
+-- Table structure for table `autobroadcast`
+--
+
+DROP TABLE `autobroadcast`;
+
+CREATE TABLE IF NOT EXISTS `autobroadcast` (
+  `id` int(11) NOT NULL auto_increment,
+  `message` longtext NOT NULL,
+  `addedby` varchar(12) NOT NULL default 'System',
+  `enabled` tinyint(3) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`),
+  KEY `enabled` (`enabled`)
+) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;
+
+--
+-- Data for table `autobroadcast`
+--
+
+DELETE FROM `autobroadcast` WHERE `id` = 1;
+INSERT INTO `autobroadcast` (`id`, `message`, `addedby`, `enabled`) VALUES
+(1, 'Welcome! Please report any issues you find.','System',1);
+
+DELETE FROM `oregon_string` WHERE `entry` = 11000;
+INSERT INTO `oregon_string` (entry, content_default, content_loc1, content_loc2, content_loc3, content_loc4, content_loc5, content_loc6, content_loc7, content_loc8)
+VALUES (11000, '|cffffff00[|c00077766Autobroadcast|cffffff00]: |cFFF222FF%s|r', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+
+DELETE FROM `command` WHERE `name` = 'reload autobroadcast';
+INSERT INTO `command` (`name`, `security`, `help`) VALUES ('reload autobroadcast', 3, 'Syntax: .reload autobroadcast\nReload autobroadcast table.');
+
+
diff -Nuar oregoncore-current/sql/oc-patch/world-buffhealnpc.sql oregoncore-pq/sql/oc-patch/world-buffhealnpc.sql
--- oregoncore-current/sql/oc-patch/world-buffhealnpc.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-buffhealnpc.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,9 @@
+--
+-- Dumping data for table `creature_template`
+--
+
+INSERT INTO `creature_template` (`entry`, `heroic_entry`, `modelid_A`, `modelid_A2`, `modelid_H`, `modelid_H2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `minhealth`, `maxhealth`, `minmana`, `maxmana`, `armor`, `faction_A`, `faction_H`, `npcflag`, `speed`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `baseattacktime`, `rangeattacktime`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `class`, `race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `PetSpellDataId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `RacialLeader`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(91000, 0, 3348, 0, 3348, 0, 'Alaresque', 'Supreme Mage', NULL, 0, 80, 80, 25000, 25000, 100000, 100000, 10000, 35, 35, 1, 1, 1, 1, 1763, 1763, 0, 1511, 1000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'EventAI', 0, 3, 0, 1, 0, 0, 0, 'npc_buff'),
+(91001, 0, 3486, 0, 3486, 0, 'Florana Nightingly', 'The Crimson Cross', NULL, 0, 80, 80, 25000, 25000, 100000, 100000, 10000, 35, 35, 1, 1, 1, 1, 1763, 1763, 0, 1511, 1000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'EventAI', 0, 3, 0, 1, 0, 0, 0, 'npc_heal'),
+(91002, 0, 10746, 0, 10746, 0, 'Flo Nizzengale', 'The Crimson Cross', NULL, 0, 80, 80, 25000, 25000, 100000, 100000, 10000, 35, 35, 1, 1, 1, 1, 1763, 1763, 0, 1511, 1000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'EventAI', 0, 3, 0, 1, 0, 0, 0, 'npc_heal');
+
diff -Nuar oregoncore-current/sql/oc-patch/world-chatspy.sql oregoncore-pq/sql/oc-patch/world-chatspy.sql
--- oregoncore-current/sql/oc-patch/world-chatspy.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-chatspy.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,21 @@
+DELETE FROM oregon_string WHERE entry BETWEEN 11600 AND 11608;
+
+INSERT INTO `oregon_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES
+(11600, 'ChatSpy appended to player |cffff0000%s|r(%u)', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(11601, 'ChatSpy for player |cffff0000%s|r(%u) cancelled by massive ChatSpy cancel.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(11602, 'All ChatSpys reset.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(11603, 'Player %s(%u) has no ChatSpy.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(11604, 'You were ChatSpying player, cancelled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(11605, '%s(%u) was ChatSpying player, cancelled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(11606, 'List of ChatSpys appended', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(11607, 'Total: %u', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+(11608, '%s(%u) spys |cffff0000%s|r(%u)', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+
+DELETE FROM `command` WHERE `name` LIKE 'chatspy%';
+
+INSERT INTO `command` (`name`, `security`, `help`) VALUES
+('chatspy', 3, 'Syntax: .chatpsy $PlayerName\r\n\r\nChatspy a player.  All chat will be echoed to the GM''s chatlog.  Can also be activated by .chatspy with the player selected.'),
+('chatspy cancel', 3, 'Syntax: .chatspy cancel $PlayerName\r\n\r\nRemoves the player from the GM''s ChatSpy.'),
+('chatspy reset', 3, 'Syntax: .chatspy reset\r\n\r\nClears the GM''s ChatSpy for all players.'),
+('chatspy status', 3, 'Syntax: .chatspy status\r\n\r\nShows a list of characters that are ChatSpied.');
+
diff -Nuar oregoncore-current/sql/oc-patch/world-codeboxnpc.sql oregoncore-pq/sql/oc-patch/world-codeboxnpc.sql
--- oregoncore-current/sql/oc-patch/world-codeboxnpc.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-codeboxnpc.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,98 @@
+--
+-- Table structure for table `npc_codes`
+--
+
+CREATE TABLE IF NOT EXISTS `npc_codes` (
+  `npc_id` mediumint(10) NOT NULL default '0' COMMENT 'The NPC ID',
+  `code` varchar(25) NOT NULL COMMENT 'The code you have to enter',
+  `uses` tinyint(3) NOT NULL default '1' COMMENT 'Number of uses left for this code',
+  `aura_id` mediumint(10) NOT NULL default '0' COMMENT 'The spell it will be applied',
+  `item_id` mediumint(10) NOT NULL default '0' COMMENT 'The gift (item)',
+  `quantity` tinyint(3) unsigned NOT NULL default '1' COMMENT 'The quantity of ITEMS',
+  PRIMARY KEY  (`npc_id`,`code`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
+
+--
+-- Dumping data for table `npc_codes`
+--
+
+INSERT INTO `npc_codes` (`npc_id`, `code`, `uses`, `aura_id`, `item_id`, `quantity`) VALUES
+(2943, 'murlocsuit', 3, 0, 33079, 1),
+(2943, 'surprise', -1, -1, 0, 1),
+(16070, 'murlocblue', 5, 0, 20371, 1),
+(16070, 'murlocpink', 5, 0, 22114, 1),
+(16070, 'surprise', -1, -1, 0, 1),
+(7951, 'murlocsuit', 3, 0, 33079, 1),
+(7951, 'surprise', -1, -1, 0, 1),
+(16076, 'murlocblue', 5, 0, 20371, 1),
+(16076, 'murlocpink', 5, 0, 22114, 1),
+(16076, 'surprise', -1, -1, 0, 1);
+
+
+--
+-- Table structure for table `npc_codes_text`
+--
+
+CREATE TABLE IF NOT EXISTS `npc_codes_text` (
+  `npc_id` mediumint(10) NOT NULL COMMENT 'from npc_codes',
+  `npc_text_id` mediumint(10) NOT NULL default '907' COMMENT 'from npc_text'
+) ENGINE=MyISAM DEFAULT CHARSET=latin1 COMMENT='Reward Codes System';
+
+--
+-- Dumping data for table `npc_codes_text`
+--
+
+INSERT INTO `npc_codes_text` (`npc_id`, `npc_text_id`) VALUES
+(7951, 13690),
+(16076, 907),
+(2943, 13690),
+(16070, 907);
+
+--
+-- Dumping data for table `npc_text`
+--
+
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`) VALUES
+(13690, 'What can I do for you?', '', 0, 1, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0);
+
+
+UPDATE creature_template SET ScriptName = 'npc_codebox' WHERE entry IN (2943, 7951, 16070, 16076);
+
+
+--
+-- Table structure for table `npc_codes_aura_loot`
+--
+
+CREATE TABLE IF NOT EXISTS `npc_codes_aura_loot` (
+  `group_id` mediumint(10) NOT NULL default '0' COMMENT 'Group that the auras belong to',
+  `aura_id` mediumint(10) NOT NULL default '0' COMMENT 'GUID of aura',
+  `name` varchar(25) default NULL COMMENT 'Name of aura',
+  PRIMARY KEY  (`group_id`,`aura_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+--
+-- Dumping data for table `npc_codes_aura_loot`
+--
+
+INSERT INTO `npc_codes_aura_loot` (`group_id`, `aura_id`, `name`) VALUES
+(1, 24708, 'male pirate costume'),
+(1, 24709, 'female pirate costume'),
+(1, 24710, 'male ninja costume'),
+(1, 24711, 'female ninja costume'),
+(1, 24713, 'leper gnome costume'),
+(1, 24723, 'skeleton costume'),
+(1, 24735, 'male ghost costume'),
+(1, 24736, 'female ghost costume'),
+(1, 24753, 'cannot cast');
+
+--
+-- Table structure for table `npc_codes_item_loot`
+--
+
+CREATE TABLE IF NOT EXISTS `npc_codes_item_loot` (
+  `group_id` mediumint(10) NOT NULL default '0' COMMENT 'Group that the items belong to',
+  `item_id` mediumint(10) NOT NULL default '0' COMMENT 'GUID of item',
+  `name` varchar(25) default NULL COMMENT 'Name of Item',
+  PRIMARY KEY  (`group_id`,`item_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
diff -Nuar oregoncore-current/sql/oc-patch/world-commandwarp.sql oregoncore-pq/sql/oc-patch/world-commandwarp.sql
--- oregoncore-current/sql/oc-patch/world-commandwarp.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-commandwarp.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,5 @@
+DELETE FROM `command` WHERE `name` = 'warp';
+
+INSERT INTO `command` (`name`, `security`, `help`) VALUES
+('warp', 3, 'Syntax: .warp $dir #value\r\n\r\nTeleport in the direction indicated by dir (f=forward,b=backward,u=up,d=down) by the number of coordinate units specified as value.');
+
diff -Nuar oregoncore-current/sql/oc-patch/world-emaralddream.sql oregoncore-pq/sql/oc-patch/world-emaralddream.sql
--- oregoncore-current/sql/oc-patch/world-emaralddream.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-emaralddream.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,11 @@
+-- Data for table `instance_template`
+
+INSERT INTO `instance_template` (`map`, `parent`, `maxPlayers`, `reset_delay`, `access_id`, `startLocX`, `startLocY`, `startLocZ`, `startLocO`, `script`) VALUES
+(169, 0, 40, 0, 0, NULL, NULL, NULL, NULL, '');
+
+
+-- Data for table `game_tele`
+
+INSERT INTO `game_tele` (`position_x`, `position_y`, `position_z`, `orientation`, `map`, `name`) VALUES
+( -2604.74, -2077.5, 126.758, 0.677952, 169, 'emeralddream');
+
diff -Nuar oregoncore-current/sql/oc-patch/world-goteleport.sql oregoncore-pq/sql/oc-patch/world-goteleport.sql
--- oregoncore-current/sql/oc-patch/world-goteleport.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-goteleport.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,44 @@
+--
+-- Table structure for table `gameobject_teleports`
+--
+
+CREATE TABLE IF NOT EXISTS `gameobject_teleports` (
+  `entry` int(10) unsigned NOT NULL auto_increment,
+  `mapid` int(10) unsigned NOT NULL,
+  `x_pos` float NOT NULL,
+  `y_pos` float NOT NULL,
+  `z_pos` float NOT NULL,
+  `orientation` float NOT NULL,
+  `required_level` int(10) unsigned NOT NULL,
+  PRIMARY KEY  (`entry`)
+) ENGINE=MyISAM  DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Optional table to create custom portals' AUTO_INCREMENT=2001013 ;
+
+--
+-- Dumping data for table `gameobject_teleports`
+--
+
+INSERT INTO `gameobject_teleports` (`entry`, `mapid`, `x_pos`, `y_pos`, `z_pos`, `orientation`, `required_level`) VALUES
+(2001000, 1, 9950.73, 2605.7, 1316.18, 3.72, 1),
+(2001001, 530, -3956.9, -11660.2, -138.75, 2.25, 1),
+(2001002, 0, -4830.45, -1188.09, 502.46, 1.01, 1),
+(2001003, 1, 1582.05, -4418.27, 8.05, 0.38, 1),
+(2001004, 530, 9474.99, -7295.07, 14.31, 5.92, 1),
+(2001005, 0, -8843.74, 611.06, 92.76, 0.75, 1),
+(2001006, 1, -1242.29, 71.16, 128.26, 5.96, 1),
+(2001007, 0, 1581.04, 276.09, -43.1027, 6.13, 1),
+(2001008, 530, -1833.9, 5371.17, -12.428, 1.92025, 1);
+
+--
+-- Dumping data for table `gameobject_template`
+--
+
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `castBarCaption`, `faction`, `flags`, `size`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `ScriptName`) VALUES
+(2001000, 10, 4393, 'Portal to Darnassus', '', 1732, 0, 1, 17608, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
+(2001001, 10, 6955, 'Portal to Exodar', '', 1732, 0, 1, 32268, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
+(2001002, 10, 4394, 'Portal to Ironforge', '', 1732, 0, 1, 17607, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
+(2001003, 10, 4395, 'Portal to Orgrimmar', '', 1735, 0, 1, 17609, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
+(2001004, 10, 6956, 'Portal to Silvermoon', '', 1735, 0, 1, 32270, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
+(2001005, 10, 4396, 'Portal to Stormwind', '', 1732, 0, 1, 17334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
+(2001006, 10, 4397, 'Portal to Thunder Bluff', '', 1735, 0, 1, 17610, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
+(2001007, 10, 4398, 'Portal to Undercity', '', 1735, 0, 1, 17611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
+(2001008, 10, 7146, 'Portal to Shattrath', '', 0, 0, 1, 33728, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '')
diff -Nuar oregoncore-current/sql/oc-patch/world-guildhouse.sql oregoncore-pq/sql/oc-patch/world-guildhouse.sql
--- oregoncore-current/sql/oc-patch/world-guildhouse.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-guildhouse.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,28 @@
+--
+-- Table structure for table `guild_houses`
+--
+
+CREATE TABLE IF NOT EXISTS `guild_houses` (
+  `id` int(8) unsigned NOT NULL auto_increment,
+  `guildId` bigint(20) NOT NULL default '0',
+  `x` double NOT NULL,
+  `y` double NOT NULL,
+  `z` double NOT NULL,
+  `map` int(11) NOT NULL,
+  `comment` varchar(255) NOT NULL default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM  DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC AUTO_INCREMENT=22 ;
+
+--
+-- Dumping data for table `guild_houses`
+--
+
+INSERT INTO `guild_houses` (`id`, `guildId`, `x`, `y`, `z`, `map`, `comment`) VALUES
+(1, 1, 16222, 16266, 14.2, 1, 'GM Island'),
+(2, 0, -10711, 2483, 8, 1, 'Village on the Veiled Sea (Silithus)'),
+(3, 0, -8323, -343, 146, 0, 'Elwynn Falls Camp (Elwynn Forest)'),
+(4, 0, -1840, -4233, 2.14, 0, 'Arathi Village (Arathi Highlands, Forbidding Sea)'),
+(5, 0, -6374, 1262, 7, 0, 'Harbor House (Elwynn Forest)'),
+(6, 0, 4303, -2760, 16.8, 0, 'Quel''Thalas Tower');
+
+
diff -Nuar oregoncore-current/sql/oc-patch/world-itemsummonnpc.sql oregoncore-pq/sql/oc-patch/world-itemsummonnpc.sql
--- oregoncore-current/sql/oc-patch/world-itemsummonnpc.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-itemsummonnpc.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,20 @@
+DELETE FROM `item_template` WHERE `entry` = 100035;
+
+INSERT INTO `item_template` (`entry`, `class`, `subclass`, `unk0`, `name`, `displayid`, `Quality`, `Flags`, `BuyCount`, `BuyPrice`, `SellPrice`, `InventoryType`, `AllowableClass`, `AllowableRace`, `ItemLevel`, `RequiredLevel`, `RequiredSkill`, `RequiredSkillRank`, `requiredspell`, `requiredhonorrank`, `RequiredCityRank`, `RequiredReputationFaction`, `RequiredReputationRank`, `maxcount`, `stackable`, `ContainerSlots`, `stat_type1`, `stat_value1`, `stat_type2`, `stat_value2`, `stat_type3`, `stat_value3`, `stat_type4`, `stat_value4`, `stat_type5`, `stat_value5`, `stat_type6`, `stat_value6`, `stat_type7`, `stat_value7`, `stat_type8`, `stat_value8`, `stat_type9`, `stat_value9`, `stat_type10`, `stat_value10`, `dmg_min1`, `dmg_max1`, `dmg_type1`, `dmg_min2`, `dmg_max2`, `dmg_type2`, `dmg_min3`, `dmg_max3`, `dmg_type3`, `dmg_min4`, `dmg_max4`, `dmg_type4`, `dmg_min5`, `dmg_max5`, `dmg_type5`, `armor`, `holy_res`, `fire_res`, `nature_res`, `frost_res`, `shadow_res`, `arcane_res`, `delay`, `ammo_type`, `RangedModRange`, `spellid_1`, `spelltrigger_1`, `spellcharges_1`, `spellppmRate_1`, `spellcooldown_1`, `spellcategory_1`, `spellcategorycooldown_1`, `spellid_2`, `spelltrigger_2`, `spellcharges_2`, `spellppmRate_2`, `spellcooldown_2`, `spellcategory_2`, `spellcategorycooldown_2`, `spellid_3`, `spelltrigger_3`, `spellcharges_3`, `spellppmRate_3`, `spellcooldown_3`, `spellcategory_3`, `spellcategorycooldown_3`, `spellid_4`, `spelltrigger_4`, `spellcharges_4`, `spellppmRate_4`, `spellcooldown_4`, `spellcategory_4`, `spellcategorycooldown_4`, `spellid_5`, `spelltrigger_5`, `spellcharges_5`, `spellppmRate_5`, `spellcooldown_5`, `spellcategory_5`, `spellcategorycooldown_5`, `bonding`, `description`, `PageText`, `LanguageID`, `PageMaterial`, `startquest`, `lockid`, `Material`, `sheath`, `RandomProperty`, `RandomSuffix`, `block`, `itemset`, `MaxDurability`, `area`, `Map`, `BagFamily`, `TotemCategory`, `socketColor_1`, `socketContent_1`, `socketColor_2`, `socketContent_2`, `socketColor_3`, `socketContent_3`, `socketBonus`, `GemProperties`, `RequiredDisenchantSkill`, `ArmorDamageModifier`, `ScriptName`, `DisenchantID`, `FoodType`, `minMoneyLoot`, `maxMoneyLoot`, `Duration`) VALUES
+(100035, 13, 0, -1, 'Summon the Supreme Mage', 12735, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28750, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'Summon the Buff Master', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_summonnpc', 0, 0, 0, 0, 0);
+
+DELETE FROM `creature_template` WHERE `entry` = 91000;
+
+INSERT INTO `creature_template` (`entry`, `heroic_entry`, `modelid_A`, `modelid_A2`, `modelid_H`, `modelid_H2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `minhealth`, `maxhealth`, `minmana`, `maxmana`, `armor`, `faction_A`, `faction_H`, `npcflag`, `speed`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `baseattacktime`, `rangeattacktime`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `class`, `race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `PetSpellDataId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `RacialLeader`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(91000, 0, 3348, 0, 3348, 0, 'Alaresque', 'Supreme Mage', NULL, 0, 80, 80, 25000, 25000, 100000, 100000, 10000, 35, 35, 1, 1, 1, 1, 1763, 1763, 0, 1511, 1000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 0, 1, 0, 0, 0, 'npc_buff');
+
+CREATE TABLE IF NOT EXISTS `item_summonnpc` (
+  `item_entry` mediumint(8) NOT NULL COMMENT 'item_template.entry',
+  `creature_entry` mediumint(8) NOT NULL COMMENT 'creature_template.entry',
+  `despawn` mediumint(8) unsigned NOT NULL default '60' COMMENT 'Time before despawn sec',
+  PRIMARY KEY  (`item_entry`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Reference data for item_summonnpc script';
+
+INSERT INTO `item_summonnpc` (`item_entry`, `creature_entry`, `despawn`) VALUES
+(100035, 91000, 60);
+
diff -Nuar oregoncore-current/sql/oc-patch/world-itemteleport.sql oregoncore-pq/sql/oc-patch/world-itemteleport.sql
--- oregoncore-current/sql/oc-patch/world-itemteleport.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-itemteleport.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,57 @@
+
+CREATE TABLE IF NOT EXISTS `item_teleports` (
+  `entry` int(10) unsigned NOT NULL,
+  `mapid` int(10) unsigned NOT NULL,
+  `x_pos` float NOT NULL,
+  `y_pos` float NOT NULL,
+  `z_pos` float NOT NULL,
+  `orientation` float NOT NULL,
+  `name` varchar(30) default NULL,
+  PRIMARY KEY  (`entry`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Optional table to create custom item portals';
+
+--
+-- Dumping data for table `item_teleports`
+--
+
+INSERT INTO `item_teleports` (`entry`, `mapid`, `x_pos`, `y_pos`, `z_pos`, `orientation`, `name`) VALUES
+(100010, 1, 16234.7, 16308.5, 20.844, 5.3328, 'GM Island'),
+(100022, 1, 9950.73, 2605.7, 1316.18, 3.72, 'Darnassus'),
+(100023, 530, -3956.9, -11660.2, -138.75, 2.25, 'Exodar'),
+(100024, 0, -4830.45, -1188.09, 502.46, 1.01, 'Ironforge'),
+(100025, 1, 1582.05, -4418.27, 8.05, 0.38, 'Orgrimmar'),
+(100026, 530, 9474.99, -7295.07, 14.31, 5.92, 'Silvermoon City'),
+(100027, 0, -8843.74, 611.06, 92.76, 0.75, 'Stormwind City'),
+(100021, 1, -1242.29, 71.16, 128.26, 5.96, 'Thunder Bluff'),
+(100020, 0, 1581.04, 276.09, -43.1027, 6.13, 'Undercity'),
+(100018, 530, -1833.9, 5371.17, -12.428, 1.92025, 'Shattrath City'),
+(100011, 1, 4600.31, -3866.36, 944.185, 1.04615, 'Hyjal'),
+(100012, 0, -11069, -1795, 53.7249, 2.36876, 'Karazhan Crypt'),
+(100013, 1, -11372.4, -4721.3, 5.64663, 0.04398, 'Tanaris Islands'),
+(100014, 0, -4845, -1082.69, 495.58, 3.08426, 'Old Ironforge'),
+(100015, 0, -8644.49, 584.137, 95.6914, 1.87553, 'Stormwind Prison'),
+(100016, 0, -4033.44, -1464.35, 169.863, 1.16318, 'Wetlands Farm');
+
+--
+-- Dumping data for table `item_template`
+--
+
+INSERT INTO `item_template` (`entry`, `class`, `subclass`, `unk0`, `name`, `displayid`, `Quality`, `Flags`, `BuyCount`, `BuyPrice`, `SellPrice`, `InventoryType`, `AllowableClass`, `AllowableRace`, `ItemLevel`, `RequiredLevel`, `RequiredSkill`, `RequiredSkillRank`, `requiredspell`, `requiredhonorrank`, `RequiredCityRank`, `RequiredReputationFaction`, `RequiredReputationRank`, `maxcount`, `stackable`, `ContainerSlots`, `stat_type1`, `stat_value1`, `stat_type2`, `stat_value2`, `stat_type3`, `stat_value3`, `stat_type4`, `stat_value4`, `stat_type5`, `stat_value5`, `stat_type6`, `stat_value6`, `stat_type7`, `stat_value7`, `stat_type8`, `stat_value8`, `stat_type9`, `stat_value9`, `stat_type10`, `stat_value10`, `dmg_min1`, `dmg_max1`, `dmg_type1`, `dmg_min2`, `dmg_max2`, `dmg_type2`, `dmg_min3`, `dmg_max3`, `dmg_type3`, `dmg_min4`, `dmg_max4`, `dmg_type4`, `dmg_min5`, `dmg_max5`, `dmg_type5`, `armor`, `holy_res`, `fire_res`, `nature_res`, `frost_res`, `shadow_res`, `arcane_res`, `delay`, `ammo_type`, `RangedModRange`, `spellid_1`, `spelltrigger_1`, `spellcharges_1`, `spellppmRate_1`, `spellcooldown_1`, `spellcategory_1`, `spellcategorycooldown_1`, `spellid_2`, `spelltrigger_2`, `spellcharges_2`, `spellppmRate_2`, `spellcooldown_2`, `spellcategory_2`, `spellcategorycooldown_2`, `spellid_3`, `spelltrigger_3`, `spellcharges_3`, `spellppmRate_3`, `spellcooldown_3`, `spellcategory_3`, `spellcategorycooldown_3`, `spellid_4`, `spelltrigger_4`, `spellcharges_4`, `spellppmRate_4`, `spellcooldown_4`, `spellcategory_4`, `spellcategorycooldown_4`, `spellid_5`, `spelltrigger_5`, `spellcharges_5`, `spellppmRate_5`, `spellcooldown_5`, `spellcategory_5`, `spellcategorycooldown_5`, `bonding`, `description`, `PageText`, `LanguageID`, `PageMaterial`, `startquest`, `lockid`, `Material`, `sheath`, `RandomProperty`, `RandomSuffix`, `block`, `itemset`, `MaxDurability`, `area`, `Map`, `BagFamily`, `TotemCategory`, `socketColor_1`, `socketContent_1`, `socketColor_2`, `socketContent_2`, `socketColor_3`, `socketContent_3`, `socketBonus`, `GemProperties`, `RequiredDisenchantSkill`, `ArmorDamageModifier`, `ScriptName`, `DisenchantID`, `FoodType`, `minMoneyLoot`, `maxMoneyLoot`, `Duration`) VALUES
+(100010, 15, 4, -1, 'Portal to GM Island', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to the legendary home of the GameMasters.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100011, 15, 4, -1, 'Portal to Hyjal', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Hyjal.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100012, 15, 4, -1, 'Portal to Karazhan Crypt', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Karazhan Crypt.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100013, 15, 4, -1, 'Portal to the Tanaris Islands', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to the Tanaris Islands.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100014, 15, 4, -1, 'Portal to Old Ironforge', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Old Ironforge.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100015, 15, 4, -1, 'Portal to Stormwind Prison', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Stormwind Prison.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100016, 15, 4, -1, 'Portal to Wetlands Farm', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to the Wetlands Farm.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100018, 15, 4, -1, 'Portal to Shattrath City', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Shattrath City.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100020, 15, 4, -1, 'Portal to Undercity', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Undercity.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100021, 15, 4, -1, 'Portal to Thunder Bluff', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Thunder Bluff.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100022, 15, 4, -1, 'Portal to Darnassus', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Darnassus.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100023, 15, 4, -1, 'Portal to The Exodar', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to The Exodar.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100024, 15, 4, -1, 'Portal to Ironforge', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Ironforge.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100025, 15, 4, -1, 'Portal to Orgrimmar', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Orgrimmar.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100026, 15, 4, -1, 'Portal to Silvermoon City', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Silvermoon City.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0),
+(100027, 15, 4, -1, 'Portal to Stormwind City', 14993, 4, 524353, 1, 0, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, -1, 0, -1, 3, 'This magic tome will transport you to Stormwind City.', 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 'item_teleport', 0, 0, 0, 0, 0);
+
+
diff -Nuar oregoncore-current/sql/oc-patch/world-npcdoorcodes.sql oregoncore-pq/sql/oc-patch/world-npcdoorcodes.sql
--- oregoncore-current/sql/oc-patch/world-npcdoorcodes.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-npcdoorcodes.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,27 @@
+DELETE FROM `creature_template` WHERE `entry` IN ( 91020, 92021 );
+
+INSERT INTO `creature_template` (`entry`, `heroic_entry`, `modelid_A`, `modelid_A2`, `modelid_H`, `modelid_H2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `minhealth`, `maxhealth`, `minmana`, `maxmana`, `armor`, `faction_A`, `faction_H`, `npcflag`, `speed`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `baseattacktime`, `rangeattacktime`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `class`, `race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `PetSpellDataId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `RacialLeader`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(91020, 0, 1985, 0, 1985, 0, 'Garble', 'Doorman', NULL, 0, 70, 70, 5000, 5000, 0, 0, 2865, 35, 35, 1, 1, 1, 1, 60, 165, 0, 97, 1500, 1500, 0, 0, 0, 0, 0, 0, 0, 50, 100, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 1, 1, 1, 1, 0, 0, 0, 'npc_door_codes'),
+(91021, 0, 1985, 0, 1985, 0, 'Reinhard', 'Doorman', NULL, 0, 70, 70, 5000, 5000, 0, 0, 2865, 35, 35, 1, 1, 1, 1, 60, 165, 0, 97, 1500, 1500, 0, 0, 0, 0, 0, 0, 0, 50, 100, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 1, 1, 1, 1, 0, 0, 0, 'npc_door_codes');
+
+DELETE FROM `gameobject_template` WHERE `entry` IN ( 600000, 600001 );
+
+INSERT INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `castBarCaption`, `faction`, `flags`, `size`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `ScriptName`) VALUES
+(600000, 0, 3811, 'Restricted Access Door 1', '', 14, 32, 0.75, 0, 0, 196608, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
+(600001, 0, 3811, 'Restricted Access Door 2', '', 14, 32, 0.75, 0, 0, 196608, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '');
+
+CREATE TABLE IF NOT EXISTS `npc_door_codes` (
+  `id` bigint(20) unsigned NOT NULL auto_increment COMMENT 'Code ID',
+  `secret` varchar(20) NOT NULL COMMENT 'Secret Word',
+  `creature_entry` mediumint(9) NOT NULL,
+  `gameobject_entry` mediumint(9) NOT NULL,
+  `opentimesec` smallint(5) unsigned NOT NULL default '5' COMMENT 'Seconds door stays open',
+  `comments` text,
+  PRIMARY KEY  (`id`),
+  UNIQUE KEY `creature_entry` (`creature_entry`)
+) ENGINE=MyISAM  DEFAULT CHARSET=latin1 AUTO_INCREMENT=3 ;
+
+INSERT INTO `npc_door_codes` (`id`, `secret`, `creature_entry`, `gameobject_entry`, `opentimesec`, `comments`) VALUES
+(1, 'sesame', 91020, 600000, 2, 'Test Code 1'),
+(2, 'howdy', 91021, 600001, 30, 'Test Code 2');
+
diff -Nuar oregoncore-current/sql/oc-patch/world-npctokens.sql oregoncore-pq/sql/oc-patch/world-npctokens.sql
--- oregoncore-current/sql/oc-patch/world-npctokens.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-npctokens.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,21 @@
+-- Table structure for table `npc_tokens`
+
+CREATE TABLE IF NOT EXISTS `npc_tokens` (
+  `type` tinyint(3) unsigned NOT NULL default '0' COMMENT 'Valid: 0-Gold, 1-Level, 2-Honor, 3-Arena, 4-MaxSkill',
+  `min_level` tinyint(3) unsigned NOT NULL default '1',
+  `max_level` tinyint(3) unsigned NOT NULL default '70',
+  `curr_item_id` mediumint(8) unsigned NOT NULL default '29434' COMMENT 'Currency - Dflt: Badge of Justice',
+  `curr_cost` tinyint(3) unsigned NOT NULL default '1',
+  `count_granted` mediumint(8) unsigned NOT NULL default '1',
+  UNIQUE KEY `type` (`type`,`min_level`,`max_level`,`curr_item_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='NPC Tokens';
+
+-- Data for table `npc_tokens`
+
+INSERT INTO `npc_tokens` (`type`, `min_level`, `max_level`, `curr_item_id`, `curr_cost`, `count_granted`) VALUES
+(0, 1, 70, 29434, 1, 500),
+(1, 1, 70, 29434, 1, 1),
+(2, 1, 70, 29434, 1, 500),
+(3, 1, 70, 29434, 1, 100),
+(4, 1, 70, 29434, 1, 1);
+
diff -Nuar oregoncore-current/sql/oc-patch/world-occhat.sql oregoncore-pq/sql/oc-patch/world-occhat.sql
--- oregoncore-current/sql/oc-patch/world-occhat.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-occhat.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,65 @@
+/**
+* Table structure for irc_commands
+*/
+DROP TABLE IF EXISTS `irc_commands`;
+CREATE TABLE `irc_commands` (
+  `Command` varchar(10) NOT NULL default '',
+  `Description` varchar(350) default NULL,
+  `gmlevel` tinyint(3) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`Command`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='IRC Module System';
+
+/**
+* Records 
+*/
+INSERT INTO `irc_commands` VALUES ('acct', '[acct <Player> <(un)lock/email/pass/rename/gmlevel>] : Perform Action To <Player> Account.', '3');
+INSERT INTO `irc_commands` VALUES ('ban', '[ban <Player/IP> <ip/acct/unban/reason>] : Ban/Unban <Player>', '3');
+INSERT INTO `irc_commands` VALUES ('chan', '[chan <op/deop/voice/devoice> <*IRC Nick*>] : Set Mode On Yourself, If <IRC Nick> Is Specified Then Set mode On Nick.', '3');
+INSERT INTO `irc_commands` VALUES ('char', '[char <Player> <mailcheat/taxicheat/maxskill/setskill/combatstop/quest/mod>] : Perform Action To Character.', '3');
+INSERT INTO `irc_commands` VALUES ('fun', '[fun <Player> <Sound/Say>] : Do Selected Fun Action To <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('help', '[help Command] : Use No Paramaters For List Of Available Commands.', '0');
+INSERT INTO `irc_commands` VALUES ('inchan', '[inchan <Channel>] : Display Users In Selected In Game <Channel>', '0');
+INSERT INTO `irc_commands` VALUES ('info', '[info] : Display Server Info. (Number Of Players Online/Max Since Last Restart/Uptime)', '0');
+INSERT INTO `irc_commands` VALUES ('item', '[item <Player> <add> <ItemID/[ItemName]> <Amount>] : Additem To <Player>, Use <ItemID> Or <[Exact Item Name]>.', '3');
+INSERT INTO `irc_commands` VALUES ('jail', '[jail <Player> <release/Reason>] : Jail Selected <Player> For <Reason>. Using release As <Reason> Releases Player.', '3');
+INSERT INTO `irc_commands` VALUES ('kick', '[kick <Player> <Reason>] : Kick <Player> For <Reason>.', '3');
+INSERT INTO `irc_commands` VALUES ('kill', '[kill <Player> <Reason>] : Kill <Player> For <Reason>.', '3');
+INSERT INTO `irc_commands` VALUES ('level', '[level <Player> <NewLevel>] : Level <Player> To <NewLevel>. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('login', '[login <UserName> <Password>] : Login To OCChat Admin Mode.  (Must Be Done In A PM)', '0');
+INSERT INTO `irc_commands` VALUES ('logout', '[logout] : Logout Of OCChat Admin Mode.', '0');
+INSERT INTO `irc_commands` VALUES ('lookup', '[lookup <acct/char/creature/faction/go/item/quest/skill/spell/tele> <ID/Name>] : ', '3');
+INSERT INTO `irc_commands` VALUES ('money', '[money <Player> <(-)Money>] : Give Money To <Player>, Use - To Take Money. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('mute', '[mute <Player> <release/TimeInMins> <Reason>] : Mute Player For Reason, For <TimeInMins>. Using release As Time Releases Player. *Can Be Done Offline*', '3');
+INSERT INTO `irc_commands` VALUES ('online', '[online] : Display All Users Logged In Game.', '0');
+INSERT INTO `irc_commands` VALUES ('pm', '[pm <Player> <Message>] : Whisper <Player> In WoW <Message>.', '3');
+INSERT INTO `irc_commands` VALUES ('reload', '[reload] : Reload OCChat Config Options And Security Level From DataBase.', '3');
+INSERT INTO `irc_commands` VALUES ('restart', '[restart] : Restart OCChat, NOT Oregon Core World Server Itself. Forces Reconnection To IRC Server.', '3');
+INSERT INTO `irc_commands` VALUES ('revive', '[revive <Player>] : Revive <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('saveall', '[saveall] : Forces Oregon Core To Save All Players.', '3');
+INSERT INTO `irc_commands` VALUES ('server', '[server setmotd [<motd>]/flusharenapoints]', '3');
+INSERT INTO `irc_commands` VALUES ('shutdown', '[shutdown <TimeInSeconds>] : Shuts The Server Down In <TimeInSeconds>, Use 0 For Immediate Shut Down', '3');
+INSERT INTO `irc_commands` VALUES ('spell', '[spell <Player> <Cast/Learn/UnLearn> <SpellID>] : Make <Player> <Learn> Or <UnLearn> A Spell, Or <Cast> A Spell On A <Player>.', '3');
+INSERT INTO `irc_commands` VALUES ('sysmsg', '[sysmsg <a/n/e/add/del/list> <Message>] : Broadcasts A System Message. (a-Broadcast System Message)(n-Broadcast Notify Message)(e-Event Message)', '3');
+INSERT INTO `irc_commands` VALUES ('tele', '[tele <Player> <l/c/r/to/cr/go/homebind> <Loc.Name/MAPID X Y Z/Recall/Player/Creature GUID/Gameobject GUID>] : Teleport Player To Location, Coords, Recall Location, Another Player, Creature or Gameobject. (l-Location)(c-Coords)', '3');
+INSERT INTO `irc_commands` VALUES ('top', '[top <accttime/chartime/money> <limit>] : Display top stats for given option. Only GM Higher Than Config Option Can Use Limit.', '3');
+INSERT INTO `irc_commands` VALUES ('who', '[who] : Displays Users Currently Logged In To OCChat.', '1');
+
+/**
+* Table structure for irc_inchan
+*/
+DROP TABLE IF EXISTS `irc_inchan`;
+CREATE TABLE `irc_inchan` (
+  `guid` int(11) unsigned NOT NULL default '0' COMMENT 'Global Unique Identifier',
+  `name` varchar(12) NOT NULL default '',
+  `channel` varchar(15) NOT NULL default '',
+  PRIMARY KEY  (`guid`,`channel`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='IRC Module System';
+
+/**
+* Records 
+*/
+
+DELETE FROM `oregon_string` WHERE entry IN (6610,6611,6612);
+INSERT INTO `oregon_string` VALUES ('6610', '|cffff0000[System Message]: %s|r', null, null, null, null, null, null, null, null);
+INSERT INTO `oregon_string` VALUES ('6611', '|cffff0000[Server Event]: %s|r', null, null, null, null, null, null, null, null);
+INSERT INTO `oregon_string` VALUES ('6612', '|cffff0000[Automatic]: %s|r', null, null, null, null, null, null, null, null);
diff -Nuar oregoncore-current/sql/oc-patch/world-soapcommands.sql oregoncore-pq/sql/oc-patch/world-soapcommands.sql
--- oregoncore-current/sql/oc-patch/world-soapcommands.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-soapcommands.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,8 @@
+INSERT INTO `command` VALUES
+('server version',1,'Syntax: .server version\r\n\r\nDisplay server version.'),
+('server dbversion',1,'Syntax: .server dbversion\r\n\r\nDisplay database version.'),
+('server rev',1,'Syntax: .server rev\r\n\r\nDisplay server revision number.'),
+('server playercount',1,'Syntax: .server playercount\r\n\r\nDisplay comma-delimited list of online players, max online players, queued players, max queued players.'),
+('server players',1,'Syntax: .server players\r\n\r\nDisplay status message of online and queued players'),
+('server uptime',1,'Syntax: .server uptime\r\n\r\nDisplay server uptime.');
+
diff -Nuar oregoncore-current/sql/oc-patch/world-telenpc.sql oregoncore-pq/sql/oc-patch/world-telenpc.sql
--- oregoncore-current/sql/oc-patch/world-telenpc.sql	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/sql/oc-patch/world-telenpc.sql	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,446 @@
+
+--
+-- Dumping data for table `creature_template`
+--
+
+INSERT INTO `creature_template` (`entry`, `heroic_entry`, `modelid_A`, `modelid_A2`, `modelid_H`, `modelid_H2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `minhealth`, `maxhealth`, `minmana`, `maxmana`, `armor`, `faction_A`, `faction_H`, `npcflag`, `speed`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `baseattacktime`, `rangeattacktime`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `class`, `race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `PetSpellDataId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `RacialLeader`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(91010, 0, 2202, 0, 2202, 0, 'Lariani the Enlightened', 'Teleport Master', NULL, 0, 70, 70, 5000, 5000, 0, 0, 2865, 35, 35, 1, 1, 1, 1, 60, 165, 0, 97, 1500, 1500, 0, 0, 0, 0, 0, 0, 0, 50, 100, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 1, 1, 1, 1, 0, 0, 0, 'npc_teleport'),
+(91011, 0, 17278, 0, 17278, 0, 'Cyriani Magus', 'Teleport Master', NULL, 0, 70, 70, 5000, 5000, 0, 0, 2865, 35, 35, 1, 1, 1, 1, 60, 165, 0, 97, 1500, 1500, 0, 0, 0, 0, 0, 0, 0, 50, 100, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 1, 1, 1, 1, 0, 0, 0, 'npc_teleport'),
+(91012, 0, 16855, 0, 16855, 0, 'Delanos the Worthy', 'Teleport Master', NULL, 0, 70, 70, 5000, 5000, 0, 0, 2865, 35, 35, 1, 1, 1, 1, 60, 165, 0, 97, 1500, 1500, 0, 0, 0, 0, 0, 0, 0, 50, 100, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 1, 1, 1, 1, 0, 0, 0, 'npc_teleport');
+
+--
+-- Table structure for table `npc_teleport_association`
+--
+
+CREATE TABLE IF NOT EXISTS `npc_teleport_association` (
+  `cat_id` int(6) unsigned NOT NULL default '0',
+  `display_order` tinyint(4) NOT NULL default '0',
+  `dest_id` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`cat_id`,`dest_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+--
+-- Dumping data for table `npc_teleport_association`
+--
+
+INSERT INTO `npc_teleport_association` (`cat_id`, `display_order`, `dest_id`) VALUES
+(1, 0, 3),
+(1, 0, 4),
+(1, 0, 5),
+(1, 0, 6),
+(2, 0, 1),
+(2, 0, 7),
+(2, 0, 8),
+(2, 0, 9),
+(3, 0, 10),
+(3, 0, 11),
+(3, 0, 12),
+(3, 0, 15),
+(4, 0, 13),
+(4, 0, 14),
+(4, 0, 16),
+(4, 0, 17),
+(5, 0, 18),
+(5, 0, 19),
+(5, 0, 20),
+(5, 0, 21),
+(5, 0, 22),
+(5, 0, 23),
+(5, 0, 24),
+(5, 0, 25),
+(5, 0, 26),
+(5, 0, 27),
+(5, 0, 28),
+(5, 0, 29),
+(5, 0, 30),
+(5, 0, 31),
+(5, 0, 32),
+(5, 0, 33),
+(5, 0, 34),
+(5, 0, 35),
+(5, 0, 36),
+(5, 0, 37),
+(5, 0, 38),
+(5, 0, 39),
+(5, 0, 40),
+(5, 0, 41),
+(5, 0, 42),
+(5, 0, 43),
+(5, 0, 44),
+(5, 0, 45),
+(5, 0, 46),
+(5, 0, 47),
+(5, 0, 48),
+(5, 0, 203),
+(6, 0, 49),
+(6, 0, 50),
+(6, 0, 51),
+(6, 0, 52),
+(6, 0, 53),
+(6, 0, 54),
+(6, 0, 55),
+(6, 0, 56),
+(6, 0, 57),
+(6, 0, 58),
+(6, 0, 59),
+(6, 0, 60),
+(6, 0, 61),
+(6, 0, 62),
+(6, 0, 63),
+(6, 0, 64),
+(6, 0, 65),
+(6, 0, 66),
+(6, 0, 67),
+(6, 0, 68),
+(6, 0, 69),
+(6, 0, 70),
+(6, 0, 71),
+(6, 0, 72),
+(6, 0, 73),
+(6, 0, 74),
+(6, 0, 75),
+(6, 0, 76),
+(6, 0, 204),
+(7, 0, 88),
+(7, 0, 89),
+(7, 0, 90),
+(7, 0, 91),
+(7, 0, 92),
+(7, 0, 93),
+(7, 0, 94),
+(7, 0, 95),
+(7, 0, 96),
+(7, 0, 97),
+(8, 0, 98),
+(8, 0, 99),
+(8, 0, 100),
+(8, 0, 101),
+(8, 0, 102),
+(8, 0, 103),
+(8, 0, 104),
+(8, 0, 105),
+(8, 0, 106),
+(11, 0, 77),
+(11, 0, 78),
+(11, 0, 80),
+(11, 0, 81),
+(11, 0, 82),
+(11, 0, 83),
+(11, 0, 84),
+(11, 0, 85),
+(11, 0, 86),
+(11, 0, 87),
+(11, 0, 107),
+(11, 0, 108),
+(11, 0, 109),
+(11, 0, 110),
+(11, 0, 111),
+(11, 0, 112),
+(11, 0, 113),
+(11, 0, 114),
+(11, 0, 158),
+(11, 0, 159),
+(14, 0, 231),
+(14, 0, 232),
+(14, 0, 233),
+(14, 0, 234),
+(15, 0, 161),
+(15, 0, 162),
+(15, 0, 163),
+(15, 0, 164),
+(15, 0, 165),
+(15, 0, 166),
+(15, 0, 167),
+(15, 0, 168),
+(15, 0, 169),
+(15, 0, 170),
+(15, 0, 171),
+(15, 0, 172),
+(15, 0, 173),
+(15, 0, 174),
+(15, 0, 175),
+(15, 0, 176),
+(15, 0, 177),
+(15, 0, 178),
+(15, 0, 179),
+(15, 0, 180),
+(15, 0, 181),
+(15, 0, 182),
+(15, 0, 183),
+(16, 0, 184),
+(16, 0, 185),
+(16, 0, 186),
+(16, 0, 187),
+(16, 0, 188),
+(16, 0, 189),
+(16, 0, 190),
+(16, 0, 191),
+(16, 0, 192),
+(18, 0, 207),
+(18, 0, 225),
+(19, 0, 206),
+(19, 0, 208),
+(19, 0, 209),
+(19, 0, 210),
+(19, 0, 213),
+(19, 0, 214),
+(19, 0, 215),
+(19, 0, 219),
+(19, 0, 226),
+(19, 0, 227),
+(19, 0, 229),
+(19, 0, 230),
+(20, 0, 205),
+(20, 0, 211),
+(20, 0, 212),
+(20, 0, 216),
+(20, 0, 217),
+(20, 0, 218),
+(20, 0, 221),
+(20, 0, 222),
+(20, 0, 223),
+(20, 0, 224);
+
+--
+-- Table structure for table `npc_teleport_category`
+--
+
+CREATE TABLE IF NOT EXISTS `npc_teleport_category` (
+  `id` int(6) unsigned NOT NULL default '0',
+  `name` varchar(255) NOT NULL default '',
+  `flag` tinyint(3) unsigned NOT NULL default '0',
+  `data0` bigint(20) unsigned NOT NULL default '0',
+  `data1` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+--
+-- Dumping data for table `npc_teleport_category`
+--
+
+INSERT INTO `npc_teleport_category` (`id`, `name`, `flag`, `data0`, `data1`) VALUES
+(1, '[Starting Zones]', 0, 1, 0),
+(2, '[Starting Zones]', 0, 2, 0),
+(3, ' - Capitals', 0, 1, 0),
+(4, ' - Capitals', 0, 2, 0),
+(5, 'Cities - Azeroth', 0, 1, 0),
+(6, 'Cities - Azeroth', 0, 2, 0),
+(7, 'Cities - Outland', 0, 1, 0),
+(8, 'Cities - Outland', 0, 2, 0),
+(11, 'Cities - Neutral', 0, 0, 0),
+(14, '[Arenas]', 0, 0, 0),
+(15, '[Instances - Classic]', 0, 0, 0),
+(16, '[Instances - TBC]', 5, 55, 0),
+(18, ' * GM Destinations', 3, 0, 0),
+(19, '[Undeveloped Places]', 2, 1, 0),
+(20, '[Undeveloped Places]', 2, 3, 0);
+
+
+--
+-- Table structure for table `npc_teleport_destination`
+--
+
+CREATE TABLE IF NOT EXISTS `npc_teleport_destination` (
+  `id` int(6) unsigned NOT NULL auto_increment,
+  `name` char(100) NOT NULL default '',
+  `pos_X` float NOT NULL default '0',
+  `pos_Y` float NOT NULL default '0',
+  `pos_Z` float NOT NULL default '0',
+  `map` smallint(5) unsigned NOT NULL default '0',
+  `orientation` float NOT NULL default '0',
+  `level` tinyint(3) unsigned NOT NULL default '0',
+  `cost` int(10) unsigned NOT NULL default '0',
+  `say_on_departure` varchar(80) default NULL,
+  `cast_on_arrival` mediumint(8) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=243 ;
+
+--
+-- Dumping data for table `npc_teleport_destination`
+--
+
+INSERT INTO `npc_teleport_destination` (`id`, `name`, `pos_X`, `pos_Y`, `pos_Z`, `map`, `orientation`, `level`, `cost`, `say_on_departure`, `cast_on_arrival`) VALUES
+(1, 'Blood Elf', 10347.2, -6353.87, 32.6684, 530, 0, 1, 0, 'See you soon!', 28750),
+(3, 'Draenei', -3996.05, -13886.3, 92.4881, 530, 0, 1, 0, 'See you soon!', 28750),
+(4, 'Dwarf/Gnome', -6227.05, 342.87, 383.362, 0, 0, 1, 0, 'See you soon!', 28750),
+(5, 'Human', -8920.86, -117.73, 82.3734, 0, 0, 1, 0, 'See you soon!', 28750),
+(6, 'Night Elf', 10327.4, 837.14, 1326.31, 1, 0, 1, 0, 'See you soon!', 28750),
+(7, 'Orc/Troll', -629.91, -4257.52, 38.2704, 1, 0, 1, 0, 'See you soon!', 28750),
+(8, 'Tauren', -2915.8, -249.45, 53.1197, 1, 0, 1, 0, 'See you soon!', 28750),
+(9, 'Undead', 1683.99, 1672.89, 136.456, 0, 0, 1, 0, 'See you soon!', 28750),
+(10, 'Darnassus', 9950.73, 2605.7, 1316.18, 1, 0, 1, 0, 'See you soon!', 28750),
+(11, 'Exodar', -3956.9, -11660.2, -138.75, 530, 0, 1, 0, 'See you soon!', 28750),
+(12, 'Ironforge', -4835.84, -1165.98, 502.201, 0, 0, 1, 0, 'See you soon!', 28750),
+(13, 'Orgrimmar', 1582.05, -4418.27, 8.05, 1, 0, 1, 0, 'See you soon!', 28750),
+(14, 'Silvermoon', 9474.99, -7295.07, 14.31, 530, 0, 1, 0, 'See you soon!', 28750),
+(15, 'Stormwind', -8843.74, 611.06, 92.76, 0, 0, 1, 0, 'See you soon!', 28750),
+(16, 'Thunder Bluff', -1242.29, 71.16, 128.26, 1, 0, 1, 0, 'See you soon!', 28750),
+(17, 'Undercity', 1581.04, 276.09, -43.1027, 0, 0, 1, 0, 'See you soon!', 28750),
+(18, 'Aerie Peak - Hinterlands', 325.36, -2117.39, 121.83, 0, 0, 34, 0, 'See you soon!', 28750),
+(19, 'Astranaar - Ashenvale', 2752.16, -432.65, 111.48, 1, 0, 12, 0, 'See you soon!', 28750),
+(20, 'Auberdine - Darkshore', 6391.65, 530.64, 8.67, 1, 0, 8, 0, 'See you soon!', 28750),
+(21, 'Azure Watch - Azuremyst', -4169.04, -12495.7, 44.2397, 530, 0, 1, 0, 'See you soon!', 28750),
+(22, 'Badlands', -6179.26, -3368.04, 245.82, 0, 0, 28, 0, 'See you soon!', 28750),
+(23, 'Blood Watch - Bloodmyst', -1954.41, -11912, 50.3972, 530, 0, 8, 0, 'See you soon!', 28750),
+(24, 'Chillwind Camp - Western Plaguelands', 937.58, -1419.46, 66.6, 0, 0, 44, 0, 'See you soon!', 28750),
+(25, 'Dark Portal - Blasted Lands', -367.39, 1008.87, 54.17, 530, 0, 55, 0, 'See you soon!', 28750),
+(26, 'Darkshire - Duskwood', -10516.2, -1160.67, 28.0996, 0, 0, 16, 0, 'See you soon!', 28750),
+(27, 'Dolanaar - Teldrassil', 9805.78, 951.39, 1308.78, 1, 0, 1, 0, 'See you soon!', 28750),
+(28, 'Feathermoon - Feralas', -4377.77, 3288.01, 13.55, 1, 0, 34, 0, 'See you soon!', 28750),
+(29, 'Forestsong - Ashenvale', 2961.28, -3216.36, 168.994, 1, 0, 24, 0, 'See you soon!', 28750),
+(30, 'Goldshire - Elwynn', -9467.13, 23.42, 56.33, 0, 0, 1, 0, 'See you soon!', 28750),
+(31, 'Kharanos - Dun Morogh', -5581.96, -527.253, 400.76, 0, 0, 1, 0, 'See you soon!', 28750),
+(32, 'Lakeshire - Redridge', -9216.7, -2152.57, 64.35, 0, 0, 12, 0, 'See you soon!', 28750),
+(33, 'Light''s Hope - Eastern Plaguelands', 2280.1, -5340.32, 89.36, 0, 0, 48, 0, 'See you soon!', 28750),
+(34, 'Menethil Harbor - Wetlands', -3826.67, -832.26, 10.09, 0, 0, 16, 0, 'See you soon!', 28750),
+(35, 'Morgan''s Vigil - Burning Steppes', -8393.65, -2744.31, 189.92, 0, 0, 40, 0, 'See you soon!', 28750),
+(36, 'Nethergarde Keep - Blasted Lands', -11097.1, -3432.11, 64.95, 0, 0, 38, 0, 'See you soon!', 28750),
+(37, 'Nijel''s Point - Desolace', 251.76, 1251.06, 192.15, 1, 0, 24, 0, 'See you soon!', 28750),
+(38, 'Rebel Camp - Stranglethorn', -11312.3, -191.84, 76.23, 0, 0, 22, 0, 'See you soon!', 28750),
+(39, 'Refuge Point - Arathi', -1261.94, -2550.4, 21.7709, 0, 0, 24, 0, 'See you soon!', 28750),
+(40, 'Sentinel Hill - Westfall', -10656.8, 1169.24, 34.46, 0, 0, 8, 0, 'See you soon!', 28750),
+(41, 'Southshore - Hillsbrad', -822.11, -494.07, 16.45, 0, 0, 18, 0, 'See you soon!', 28750),
+(42, 'Stonetalon Peak - Stonetalon', 2735.12, 1511.3, 236.82, 1, 0, 12, 0, 'See you soon!', 28750),
+(43, 'Talonbranch Glade - Felwood', 6204.08, -1951.43, 571.581, 1, 0, 42, 0, 'See you soon!', 28750),
+(44, 'Talrendis - Azshara', 2696.01, -3889.68, 108.55, 1, 0, 40, 0, 'See you soon!', 28750),
+(45, 'Thalanaar - Feralas/Thousand Needles', -4503.25, -778.42, -41.0645, 1, 0, 34, 0, 'See you soon!', 28750),
+(46, 'Thelsamar - Loch Modan', -5380.99, -2974.53, 323.16, 0, 0, 8, 0, 'See you soon!', 28750),
+(47, 'Theramore Isle - Dustwallow', -3856.58, -4557.22, 8.31, 1, 0, 28, 0, 'See you soon!', 28750),
+(48, 'Thorium Point - Searing Gorge', -6570.59, -1179.44, 314.63, 0, 0, 34, 0, 'See you soon!', 28750),
+(49, 'Bloodhoof - Mulgore', -2371.59, -344.945, -8.95687, 1, 0, 1, 0, 'See you soon!', 28750),
+(50, 'Bloodvenom Post - Felwood', 5111.5, -364.84, 358.069, 1, 0, 42, 0, 'See you soon!', 28750),
+(51, 'Brackenwall - Dustwallow', -3179.44, -2914.98, 33.2614, 1, 0, 28, 0, 'See you soon!', 28750),
+(52, 'Brill - Tirisfal Glades', 2268.82, 243.405, 34.2569, 0, 0, 1, 0, 'See you soon!', 28750),
+(53, 'Camp Mojache - Feralas', -4453.08, 244.037, 39.1076, 1, 0, 34, 0, 'See you soon!', 28750),
+(54, 'Camp Taurajo - Barrens', -2366.28, -1990.85, 96.705, 1, 0, 8, 0, 'See you soon!', 28750),
+(55, 'Crossroads - Barrens', -400.21, -2647.88, 96.22, 1, 0, 8, 0, 'See you soon!', 28750),
+(56, 'Dark Portal - Blasted Lands', -139.253, 1016.09, 54.1819, 530, 0, 55, 0, 'See you soon!', 28750),
+(57, 'Fairbreeze - Eversong Woods', 8695.4, -6630.78, 72.7438, 530, 0, 1, 0, 'See you soon!', 28750),
+(58, 'Falconwing - Eversong Woods', 9470.55, -6861.17, 17.4284, 530, 0, 1, 0, 'See you soon!', 28750),
+(59, 'Flamecrest - Burning Steppes', -7488.31, -2171.76, 165.379, 0, 0, 40, 0, 'See you soon!', 28750),
+(60, 'Freewind Post - Thousand Needles', -5476.14, -2463.29, 89.2849, 1, 0, 18, 0, 'See you soon!', 28750),
+(61, 'Grom''Gol - Strangethorn', -12368.1, 152.938, 2.91855, 0, 0, 22, 0, 'See you soon!', 28750),
+(62, 'Hammerfall - Arathi', -918.67, -3537.5, 72.76, 0, 0, 24, 0, 'See you soon!', 28750),
+(63, 'Kargath - Badlands', -6658.08, -2161.55, 245.355, 0, 0, 28, 0, 'See you soon!', 28750),
+(64, 'Light''s Hope - Eastern Plaguelands', 2323.49, -5303.68, 81.9969, 0, 0, 48, 0, 'See you soon!', 28750),
+(65, 'Razor Hill - Durotar', 348.152, -4686.92, 16.4582, 1, 0, 1, 0, 'See you soon!', 28750),
+(66, 'Revantusk - Hinterlands', -619.804, -4580.63, 11.6874, 0, 0, 34, 0, 'See you soon!', 28750),
+(67, 'Sepulcher - Silverpine', 505.633, 1636.29, 125.944, 0, 0, 8, 0, 'See you soon!', 28750),
+(68, 'Shadowprey - Desolace', -1585.29, 3163.02, 47.0976, 1, 0, 24, 0, 'See you soon!', 28750),
+(69, 'Splintertree Post - Ashenvale', 2341.8, -2574.55, 102.77, 1, 0, 12, 0, 'See you soon!', 28750),
+(70, 'Stonard - Swamp Of Sorrows', -10490.1, -3253.94, 21.0298, 0, 0, 28, 0, 'See you soon!', 28750),
+(71, 'Sunrock - Stonetalon', 899.11, 918.168, 106.258, 1, 0, 12, 0, 'See you soon!', 28750),
+(72, 'Tarren Mill - Hillsbrad', -3.44188, -938.574, 57.1637, 0, 0, 16, 0, 'See you soon!', 28750),
+(73, 'Thorium Point - Searing Gorge', -6521.54, -1097.52, 314.9, 0, 0, 34, 0, 'See you soon!', 28750),
+(74, 'Tranquillien - Ghostlands', 7558.95, -6897.39, 96.0274, 530, 0, 8, 0, 'See you soon!', 28750),
+(75, 'Valormok - Azshara', 3629.88, -4414.31, 111.17, 1, 0, 40, 0, 'See you soon!', 28750),
+(76, 'Zoram''Gar Outpost - Ashenvale', 3375.14, 996.61, 5.20047, 1, 0, 16, 0, 'See you soon!', 28750),
+(77, 'Booty Bay - Stranglethorn', -14300, 529.102, 8.6962, 0, 0, 12, 0, 'See you soon!', 28750),
+(78, 'Cenarion Hold - Silithus', -6874.26, 727.023, 45.6627, 1, 0, 50, 0, 'See you soon!', 28750),
+(80, 'Emerald Sanctuary - Felwood', 4011.97, -1297.09, 254.22, 1, 0, 42, 0, 'See you soon!', 28750),
+(81, 'Everlook - Winterspring', 6691.74, -4660.87, 721.7, 1, 0, 45, 0, 'See you soon!', 28750),
+(82, 'Gadgetzan - Tanaris', -7169.46, -3839.9, 8.75, 1, 0, 34, 0, 'See you soon!', 28750),
+(83, 'Hatchet Hills - Ghostlands', 6790.58, -7736.82, 126.108, 530, 0, 40, 0, 'See you soon!', 28750),
+(84, 'Marshal''s Refuge - UnGoro', -6104.02, -1147.66, -186.58, 1, 0, 40, 0, 'See you soon!', 28750),
+(85, 'Mudsprocket - Dustwallow', -4602.22, -3188.82, 34.92, 1, 0, 30, 0, 'See you soon!', 28750),
+(86, 'Night Haven - Moonglade', 7963.07, -2402.56, 488.95, 1, 0, 10, 0, 'See you soon!', 28750),
+(87, 'Ratchet - Barrens', -955.726, -3747.16, 5.47817, 1, 0, 8, 0, 'See you soon!', 28750),
+(88, 'Allerian Stronghold - Terokkar', -2926.33, 4015.55, 0.357476, 530, 0, 55, 0, 'See you soon!', 28750),
+(89, 'Honor Hold - Hellfire', -712.183, 2700.99, 94.4476, 530, 0, 55, 0, 'See you soon!', 28750),
+(90, 'Orebor Harborage - Zangarmarsh', 1044.07, 7361.85, 38.6303, 530, 0, 55, 0, 'See you soon!', 28750),
+(91, 'Sylvanaar - Blades Edge', 2088.02, 6891.66, 183.23, 530, 0, 55, 0, 'See you soon!', 28750),
+(92, 'Telaar - Nagrand', -2689.97, 7290.69, 41.516, 530, 0, 55, 0, 'See you soon!', 28750),
+(93, 'Telredor - Zangarmarsh', 283.684, 6084.02, 131.909, 530, 0, 55, 0, 'See you soon!', 28750),
+(94, 'Temple Of Telhamat - Hellfire', 191.455, 4338.16, 116.392, 530, 0, 55, 0, 'See you soon!', 28750),
+(95, 'Toshleys Station - Blades Edge', 1853.24, 5536.02, 276.959, 530, 0, 55, 0, 'See you soon!', 28750),
+(96, 'Shatter Point - Hellfire', 279.39, 1489.76, -15.4411, 530, 0, 55, 0, 'See you soon!', 28750),
+(97, 'Wildhammer Stronghold - Shadowmoon', -4060.39, 2176.59, 111.224, 530, 0, 55, 0, 'See you soon!', 28750),
+(98, 'Falcon Watch - Hellfire', -587.86, 4096.7, 91.5953, 530, 0, 55, 0, 'See you soon!', 28750),
+(99, 'Garadar - Nagrand', -1223.55, 7139.06, 57.2658, 530, 0, 55, 0, 'See you soon!', 28750),
+(100, 'Moknathal Village - Blades Edge', 2046.76, 4711.5, 149.623, 530, 0, 55, 0, 'See you soon!', 28750),
+(101, 'Shadowmoon Village - Shadowmoon', -2981.92, 2554.54, 77.1203, 530, 0, 55, 0, 'See you soon!', 28750),
+(102, 'Spinebreaker Post - Hellfire', -1324.19, 2356.33, 88.9544, 530, 0, 55, 0, 'See you soon!', 28750),
+(103, 'Stonebreaker Hold - Terokkar', -2624.14, 4440.03, 36.0927, 530, 0, 55, 0, 'See you soon!', 28750),
+(104, 'Swamprat Post - Zangarmarsh', 94.6451, 5200.61, 20.7692, 530, 0, 55, 0, 'See you soon!', 28750),
+(105, 'Thrallmar - Hellfire', 178.939, 2625.26, 87.4472, 530, 0, 55, 0, 'See you soon!', 28750),
+(106, 'Thunderlord Stronghold - Blades Edge', 2400.92, 5975.27, 151.781, 530, 0, 55, 0, 'See you soon!', 28750),
+(107, 'Zabrajin - Zangarmarsh', 239.589, 7906.16, 25.7965, 530, 0, 55, 0, 'See you soon!', 28750),
+(108, 'Altar Of Shatar - Shadowmoon (Aldor)', -3003.91, 861.802, -8.85133, 530, 0, 55, 0, 'See you soon!', 28750),
+(109, 'Area 52 - Netherstorm', 3055.84, 3691.89, 142.772, 530, 0, 55, 0, 'See you soon!', 28750),
+(110, 'Cosmowrench - Netherstorm', 2968.6, 1790.66, 139.121, 530, 0, 55, 0, 'See you soon!', 28750),
+(111, 'Evergrove - Blades Edge', 3015.36, 5446, 146.91, 530, 0, 55, 0, 'See you soon!', 28750),
+(112, 'Sanctum Of The Stars - Shadowmoon (Scryers)', -4085.71, 1120.44, 42.5768, 530, 0, 55, 0, 'See you soon!', 28750),
+(113, 'Shattrath City - Terokkar', -1833.9, 5371.17, -12.428, 530, 0, 20, 0, 'See you soon!', 28750),
+(114, 'Stormspire - Netherstorm', 4148.79, 2969.46, 352.264, 530, 0, 55, 0, 'See you soon!', 28750),
+(161, 'Ahn''Qiraj - Silithus', -8187.04, 1527.94, 4.19598, 1, 0, 55, 0, 'See you soon!', 28750),
+(162, 'Blackfathom Deeps - Ashenvale', 4248.44, 741.7, -25.2795, 1, 0, 19, 0, 'See you soon!', 28750),
+(163, 'Blackrock Mountain', -7581.15, -1130.07, 262.065, 0, 0, 40, 0, 'See you soon!', 28750),
+(164, 'Caverns Of Time - Tanaris', -8186.9, -4693.13, 16.2232, 1, 0, 66, 0, 'See you soon!', 28750),
+(165, 'Deadmines - Westfall', -11208.7, 1671.82, 24.6763, 0, 0, 10, 0, 'See you soon!', 28750),
+(166, 'Dire Maul - Feralas', -3981.73, 799.548, 161.008, 1, 0, 45, 0, 'See you soon!', 28750),
+(167, 'Gnomeregan - Dun Morogh', -5211.6, 597.061, 415.013, 0, 0, 20, 0, 'See you soon!', 28750),
+(168, 'Karazhan - Deadwind Pass', -11130, -2001.75, 48.24, 0, 0, 68, 0, 'See you soon!', 28750),
+(169, 'Maraudon - Desolace', -1414.69, 2809.38, 111.773, 1, 0, 30, 0, 'See you soon!', 28750),
+(170, 'Onyxia''s Lair - Dustwallow', -4730.76, -3740.4, 56.8569, 1, 0, 50, 0, 'See you soon!', 28750),
+(171, 'Ragefire Chasm - Orgrimmar', 1808.74, -4405.43, -18.7873, 1, 0, 8, 0, 'See you soon!', 28750),
+(172, 'Razorfen Downs - Barrens', -4656.07, -2517.31, 81.0134, 1, 0, 25, 0, 'See you soon!', 28750),
+(173, 'Razorfen Kraul - Barrens', -4474.27, -1688.34, 81.3005, 1, 0, 17, 0, 'See you soon!', 28750),
+(174, 'Scarlet Monastery - Tirisfal Glades', 2650.49, -668.272, 111.635, 0, 0, 20, 0, 'See you soon!', 28750),
+(175, 'Scholomance - Western Plaguelands', 1224.29, -2600.69, 87.6623, 0, 0, 45, 0, 'See you soon!', 28750),
+(176, 'Shadowfang Keep - Silverpine', -234.514, 1510.4, 74.8356, 0, 0, 10, 0, 'See you soon!', 28750),
+(177, 'Stockades - Stormwind', -8822.96, 795.366, 97.2204, 0, 0, 15, 0, 'See you soon!', 28750),
+(178, 'Stratholme - Eastern Plaguelands', 3352.92, -3379.03, 144.782, 0, 0, 45, 0, 'See you soon!', 28750),
+(179, 'Sunken Temple - Swamp Of Sorrows', -10480.3, -3816.02, 28.9117, 0, 0, 35, 0, 'See you soon!', 28750),
+(180, 'Uldaman - Badlands', -6112.81, -3296.81, 257.819, 0, 0, 30, 0, 'See you soon!', 28750),
+(181, 'Wailing Caverns - Barrens', -733.378, -2219.62, 17.103, 1, 0, 10, 0, 'See you soon!', 28750),
+(182, 'Zul''Farrak - Tanaris', -6812.32, -2886.15, 8.98442, 1, 0, 35, 0, 'See you soon!', 28750),
+(183, 'Zul''Gurub - Stranglethorn', -11893.1, -847.097, 33.6086, 0, 0, 50, 0, 'See you soon!', 28750),
+(184, 'Auchindoun - Terokkar', -3322.48, 4939.72, -101.222, 530, 0, 55, 0, 'See you soon!', 28750),
+(185, 'Black Temple - Shadowmoon', -3643.11, 311.532, 35.7227, 530, 0, 70, 0, 'See you soon!', 28750),
+(186, 'Coilfang Reservoir - Zangarmarsh', 727.903, 6849.35, -67.2935, 530, 0, 55, 0, 'See you soon!', 28750),
+(187, 'Gruul''s Lair - Blades Edge', 3529.51, 5102.04, 3.27001, 530, 0, 65, 0, 'See you soon!', 28750),
+(188, 'Hellfire Citadel - Hellfire', -339.992, 3037.05, -16.545, 530, 0, 55, 0, 'See you soon!', 28750),
+(189, 'Magisters Terrace - Quel Danas', 12884.8, -7293.86, 64.6754, 530, 0, 68, 0, 'See you soon!', 28750),
+(190, 'Sunwell Plateau - Quel Danas', 12619.4, -6767.57, 15.2699, 530, 0, 70, 0, 'See you soon!', 28750),
+(191, 'Tempest Keep - Netherstorm', 3098.8, 1516.12, 190.301, 530, 0, 70, 0, 'See you soon!', 28750),
+(192, 'Zul''Aman - Ghostlands', 6790.58, -7736.82, 126.108, 530, 0, 68, 0, 'See you soon!', 28750),
+(203, 'Azshara Crater - Alliance', 1115.09, 35.641, 319.66, 37, 0, 1, 0, 'See you soon!', 28750),
+(204, 'Azshara Crater - Horde', 37.8388, 905.824, 339.395, 37, 0, 1, 0, 'See you soon!', 28750),
+(205, 'Designer Island', 16303.5, -16173.5, 40.4344, 451, 0, 1, 0, 'See you soon!', 28750),
+(206, 'Elwynn Falls House', -8265.67, -218.426, 268.194, 0, 0, 1, 0, 'See you soon!', 28750),
+(207, 'GM Island', 16226.2, 16257, 13.2022, 1, 0, 1, 0, 'See you soon!', 28750),
+(208, 'Harbor House', -6371.56, 1249.31, 9.05903, 0, 0, 1, 0, 'See you soon!', 28750),
+(209, 'Hyjal', 4600.31, -3866.36, 944.185, 1, 0, 1, 0, 'See you soon!', 28750),
+(210, 'Ironforge Airport', -4696.91, -1700.22, 503.325, 0, 0, 1, 0, 'See you soon!', 28750),
+(211, 'Karazhan Crypts', -11069, -1795, 53.7249, 0, 0, 1, 0, 'See you soon!', 28750),
+(212, 'Kings Square - Stratholme', 3521.52, -3308.57, 131.456, 0, 0, 1, 0, 'See you soon!', 28750),
+(213, 'Long Wash Ruins', 6251.35, 948.62, 2.1908, 1, 0, 1, 0, 'See you soon!', 28750),
+(214, 'Lower Elwynn Camp', -8621.34, -534.612, 145.921, 0, 0, 1, 0, 'See you soon!', 28750),
+(215, 'Mount Ironforge', -4794.91, -1001.78, 896.206, 0, 0, 1, 0, 'See you soon!', 28750),
+(216, 'North Tanaris Island', -11372.4, -4721.3, 5.64663, 1, 0, 1, 0, 'See you soon!', 28750),
+(217, 'Old Ironforge', -4845, -1082.69, 495.58, 0, 0, 1, 0, 'See you soon!', 28750),
+(218, 'Programmer Island', 16321.5, 16182, 69.4439, 451, 0, 1, 0, 'See you soon!', 28750),
+(219, 'Quel Thalis Tower', 4256.6, -2838.52, 12.2214, 0, 0, 1, 0, 'See you soon!', 28750),
+(221, 'South Tanaris Island', -11852.6, -4757.43, 6.23677, 1, 0, 1, 0, 'See you soon!', 28750),
+(222, 'Stonetalon Lumber Camp', 1871.86, 1382.14, 140.994, 1, 0, 1, 0, 'See you soon!', 28750),
+(223, 'Stormwind Prison', -8644.49, 584.137, 95.6914, 0, 0, 1, 0, 'See you soon!', 28750),
+(224, 'Tanaris Sea Platform', -11647, -4705.32, 23.9449, 1, 0, 1, 0, 'See you soon!', 28750),
+(225, 'The Box', 16230.2, 16403.3, -64.3799, 1, 0, 1, 0, 'See you soon!', 28750),
+(226, 'Thunder Falls - Elwynn', -9296.74, 676.999, 131.824, 0, 0, 1, 0, 'See you soon!', 28750),
+(227, 'Troll Village - ZG', -11790.7, -1528.88, 27.3312, 0, 0, 1, 0, 'See you soon!', 28750),
+(229, 'Upper Elwynn Camp', -8323.69, -346.228, 145.761, 0, 0, 1, 0, 'See you soon!', 28750),
+(230, 'Wetlands Farm', -4112.63, -1074.3, 168.913, 0, 0, 1, 0, 'See you soon!', 28750),
+(231, 'Circle of Blood', 2839.44, 5930.17, 11.1002, 530, 3.16284, 18, 0, 'See you soon!', 28750),
+(232, 'Gurubashi', -13261.3, 168.294, 35.0792, 0, 1.00688, 18, 0, 'See you soon!', 28750),
+(233, 'Ring of Trials', -1999.94, 6581.71, 11.32, 530, 2.3, 18, 0, 'See you soon!', 28750),
+(234, 'The Maul', -3761.49, 1133.43, 132.083, 1, 4.57259, 18, 0, 'See you soon!', 28750),
+(235, 'Alterac Valley', 883.187, -489.375, 96.7618, 30, 3.06932, 18, 0, 'See you soon!', 28750),
+(236, 'Arathi Basin', 1308.68, 1306.03, -9.0107, 529, 3.91285, 18, 0, 'See you soon!', 28750),
+(237, 'Eye of the Storm', 2487.72, 1609.12, 1224.64, 566, 3.35671, 18, 0, 'See you soon!', 28750),
+(238, 'Warsong Gulch', 1525.95, 1481.66, 352.001, 489, 3.20756, 18, 0, 'See you soon!', 28750),
+(239, 'Alterac Valley', -818.155, -623.043, 54.0884, 30, 2.1, 18, 0, 'See you soon!', 28750),
+(240, 'Arathi Basin', 686.053, 683.165, -12.9149, 529, 0.18, 18, 0, 'See you soon!', 28750),
+(241, 'Eye of the Storm', 1843.73, 1529.77, 1224.43, 566, 0.297579, 18, 0, 'See you soon!', 28750),
+(242, 'Warsong Gulch', 930.851, 1431.57, 345.537, 489, 0.015704, 18, 0, 'See you soon!', 28750);
+
+
diff -Nuar oregoncore-current/src/CMakeLists.txt oregoncore-pq/src/CMakeLists.txt
--- oregoncore-current/src/CMakeLists.txt	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/CMakeLists.txt	2012-05-20 11:43:23.000000000 -0400
@@ -21,6 +21,7 @@
   add_subdirectory(collision)
   add_subdirectory(game)
   add_subdirectory(scripts)
+  add_subdirectory(irc)
   add_subdirectory(oregoncore)
 else()
   if( TOOLS )
diff -Nuar oregoncore-current/src/game/AuctionHouseHandler.cpp oregoncore-pq/src/game/AuctionHouseHandler.cpp
--- oregoncore-current/src/game/AuctionHouseHandler.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/AuctionHouseHandler.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -29,6 +29,7 @@
 #include "Opcodes.h"
 #include "UpdateMask.h"
 #include "Util.h"
+#include "../irc/IRCClient.h"
 
 // please DO NOT use iterator++, because it is slower than ++iterator!!!
 // post-incrementation is always slower than pre-incrementation !
@@ -284,6 +285,9 @@
     pl->SaveInventoryAndGoldToDB();
     CharacterDatabase.CommitTransaction();
 
+    if ((sIRC.BOTMASK & 1024) != 0)
+        sIRC.AHFunc(it->GetEntry(), it->GetProto()->Name1, pl->GetName(), AH->GetHouseId());
+
     SendAuctionCommandResult(AH->Id, AUCTION_SELL_ITEM, AUCTION_OK);
 }
 
diff -Nuar oregoncore-current/src/game/Channel.cpp oregoncore-pq/src/game/Channel.cpp
--- oregoncore-current/src/game/Channel.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/Channel.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -21,6 +21,7 @@
 #include "ObjectMgr.h"
 #include "SocialMgr.h"
 #include "World.h"
+#include "../irc/IRCClient.h"
 
 Channel::Channel(const std::string& name, uint32 channel_id)
  : m_name(name), m_announce(true), m_moderate(false), m_channelId(channel_id), m_ownerGUID(0), m_password(""), m_flags(0)
@@ -112,6 +113,7 @@
 
     MakeYouJoined(&data);
     SendToOne(&data, p);
+    sIRC.Handle_WoW_Channel(m_name, objmgr.GetPlayer(p), CHANNEL_JOIN);
 
     JoinNotify(p);
 
@@ -158,6 +160,7 @@
             SendToAll(&data);
         }
 
+        sIRC.Handle_WoW_Channel(m_name, objmgr.GetPlayer(p), CHANNEL_LEAVE);
         LeaveNotify(p);
 
         if (changeowner)
@@ -567,6 +570,11 @@
     }
     else
     {
+        // ChatSpy
+        for(PlayerList::iterator itr = players.begin(); itr != players.end(); ++itr)
+            if(Player* pl = objmgr.GetPlayer(itr->first))
+                pl->HandleChatSpyMessage(what, CHAT_MSG_CHANNEL, lang, plr, GetName());
+
         uint32 messageLength = strlen(what) + 1;
 
         WorldPacket data(SMSG_MESSAGECHAT, 1+4+8+4+m_name.size()+1+8+4+messageLength+1);
diff -Nuar oregoncore-current/src/game/Chat.cpp oregoncore-pq/src/game/Chat.cpp
--- oregoncore-current/src/game/Chat.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/Chat.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -39,6 +39,15 @@
 
 ChatCommand * ChatHandler::getCommandTable()
 {
+    static ChatCommand chatspyCommandTable[] =
+    {
+        { "reset",          SEC_ADMINISTRATOR,  false, &ChatHandler::HandleChatSpyResetCommand,        "", NULL },
+        { "cancel",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleChatSpyCancelCommand,       "", NULL },
+        { "status",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleChatSpyStatusCommand,       "", NULL },
+        { "",               SEC_ADMINISTRATOR,  false, &ChatHandler::HandleChatSpySetCommand,          "", NULL },
+        { NULL,             0,                  false, NULL,                                           "", NULL }
+    };
+
     static ChatCommand accountSetCommandTable[] =
     {
         { "addon",          SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleAccountSetAddonCommand,     "", NULL },
@@ -102,6 +111,12 @@
         { "idlerestart",    SEC_ADMINISTRATOR,  true,  NULL,                                           "", serverIdleRestartCommandTable },
         { "idleshutdown",   SEC_ADMINISTRATOR,  true,  NULL,                                           "", serverShutdownCommandTable },
         { "info",           SEC_PLAYER,         true,  &ChatHandler::HandleServerInfoCommand,          "", NULL },
+        { "version",        SEC_PLAYER,         true,  &ChatHandler::HandleServerVersionCommand,       "", NULL },
+        { "rev",            SEC_PLAYER,         true,  &ChatHandler::HandleServerRevCommand,           "", NULL },
+        { "dbversion",      SEC_PLAYER,         true,  &ChatHandler::HandleServerDBVersionCommand,     "", NULL },
+        { "uptime",         SEC_PLAYER,         true,  &ChatHandler::HandleServerUptimeCommand,        "", NULL },
+        { "playercount",    SEC_PLAYER,         true,  &ChatHandler::HandleServerPlayerCountCommand,   "", NULL },
+        { "players",        SEC_PLAYER,         true,  &ChatHandler::HandleServerPlayersCommand,       "", NULL },
         { "motd",           SEC_PLAYER,         true,  &ChatHandler::HandleServerMotdCommand,          "", NULL },
         { "plimit",         SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleServerPLimitCommand,        "", NULL },
         { "restart",        SEC_ADMINISTRATOR,  true,  NULL,                                           "", serverRestartCommandTable },
@@ -606,6 +621,8 @@
         { "server",         SEC_ADMINISTRATOR,  true,  NULL,                                           "", serverCommandTable   },
         { "pet",            SEC_GAMEMASTER,     false, NULL,                                           "", petCommandTable      },
 
+        { "chatspy",        SEC_ADMINISTRATOR,  false, NULL,                                           "", chatspyCommandTable  }, 
+
         { "aura",           SEC_ADMINISTRATOR,  false, &ChatHandler::HandleAuraCommand,                "", NULL },
         { "unaura",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleUnAuraCommand,              "", NULL },
         { "nameannounce",   SEC_MODERATOR,      false, &ChatHandler::HandleNameAnnounceCommand,        "", NULL },
@@ -670,7 +687,13 @@
         { "flusharenapoints",SEC_ADMINISTRATOR, true,  &ChatHandler::HandleFlushArenaPointsCommand,    "", NULL },
         { "sendmessage",    SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleSendMessageCommand,         "", NULL },
         { "playall",        SEC_ADMINISTRATOR,  false, &ChatHandler::HandlePlayAllCommand,             "", NULL },
+        { "ocrecon",        SEC_MODERATOR,      true,  &ChatHandler::HandleIRCRelogCommand,            "", NULL },
         { "repairitems",    SEC_GAMEMASTER,     false, &ChatHandler::HandleRepairitemsCommand,         "", NULL },
+
+        //Allows your players to gamble for fun and prizes
+        { "gamble",         SEC_PLAYER,         false, &ChatHandler::HandleGambleCommand,              "", NULL },
+        { "roulette",       SEC_PLAYER,         false, &ChatHandler::HandleRouletteCommand,            "", NULL },
+
         { "freeze",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleFreezeCommand,              "", NULL },
         { "unfreeze",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleUnFreezeCommand,            "", NULL },
         { "listfreeze",     SEC_ADMINISTRATOR,  false, &ChatHandler::HandleListFreezeCommand,          "", NULL },
@@ -679,6 +702,9 @@
         { "bindsight",      SEC_ADMINISTRATOR,  false, &ChatHandler::HandleBindSightCommand,           "", NULL },
         { "unbindsight",    SEC_ADMINISTRATOR,  false, &ChatHandler::HandleUnbindSightCommand,         "", NULL },
 
+        // warp command
+        { "warp",           SEC_ADMINISTRATOR,  false, &ChatHandler::HandleWarpCommand,                "", NULL },
+
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
@@ -888,6 +914,15 @@
                     sLog.outCommand(m_session->GetAccountId(),"Command: %s [Player: %s (Account: %u) X: %f Y: %f Z: %f Map: %u Selected: %s]",
                         fullcmd.c_str(),p->GetName(),m_session->GetAccountId(),p->GetPositionX(),p->GetPositionY(),p->GetPositionZ(),p->GetMapId(),
                         sel_guid.GetString().c_str());
+
+                    if ((sIRC.logmask & 2) != 0)
+                    {
+                        std::string logchan = "#";
+                        logchan += sIRC.logchan;
+                        std::stringstream ss;
+                        ss << sIRC.iLog.GetLogDateTimeStr() << ": [ " << p->GetName() << "(" << m_session->GetSecurity() << ") ] Used Command: [ " << fullcmd<< " ] Target: [" << sel_guid.GetString().c_str() << "]";
+                        sIRC.Send_IRC_Channel(logchan,ss.str().c_str(), true, "LOG");
+                    }
                 }
             }
         }
diff -Nuar oregoncore-current/src/game/Chat.h oregoncore-pq/src/game/Chat.h
--- oregoncore-current/src/game/Chat.h	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/Chat.h	2012-05-20 11:43:23.000000000 -0400
@@ -21,6 +21,7 @@
 #define OREGONCORE_CHAT_H
 
 #include "SharedDefines.h"
+#include "../irc/IRCClient.h"
 
 class ChatHandler;
 class WorldSession;
@@ -136,6 +137,7 @@
         bool HandleSendItemsCommand(const char* args);
         bool HandleSendMailCommand(const char* args);
         bool HandleSendMoneyCommand(const char* args);
+        bool HandleIRCpmCommand(const char* args);
 
         bool HandleDebugPlayCinematicCommand(const char* args);
         bool HandleDebugPlaySoundCommand(const char* args);
@@ -316,6 +318,12 @@
         bool HandleServerIdleRestartCommand(const char* args);
         bool HandleServerIdleShutDownCommand(const char* args);
         bool HandleServerInfoCommand(const char* args);
+        bool HandleServerVersionCommand(const char* args);
+        bool HandleServerRevCommand(const char* args);
+        bool HandleServerDBVersionCommand(const char* args);
+        bool HandleServerUptimeCommand(const char* args);
+        bool HandleServerPlayerCountCommand(const char* args);
+        bool HandleServerPlayersCommand(const char* args);
         bool HandleServerMotdCommand(const char* args);
         bool HandleServerPLimitCommand(const char* args);
         bool HandleServerRestartCommand(const char* args);
@@ -363,6 +371,10 @@
         bool HandleUnFreezeCommand(const char *args);
         bool HandleListFreezeCommand(const char* args);
 
+        //Gamble
+        bool HandleRouletteCommand(const char* args);
+        bool HandleGambleCommand(const char* args);
+
         bool HandleBanAccountCommand(const char* args);
         bool HandleBanCharacterCommand(const char* args);
         bool HandleBanIPCommand(const char* args);
@@ -439,6 +451,8 @@
 
         bool HandleResetAllCommand(const char * args);
 
+        // warp command
+        bool HandleWarpCommand(const char * args);                                              
 
         // GM ticket command handlers
         bool HandleGMTicketListCommand(const char* args);
@@ -497,10 +511,17 @@
         bool HandleFlushArenaPointsCommand(const char *args);
         bool HandlePlayAllCommand(const char* args);
         bool HandleRepairitemsCommand(const char* args);
+        bool HandleIRCRelogCommand(const char *args);
 
         bool HandleTempGameObjectCommand(const char* args);
         bool HandleTempAddSpwCommand(const char* args);
 
+        // ChatSpy
+        bool HandleChatSpyResetCommand(const char * args);
+        bool HandleChatSpyCancelCommand(const char * args);
+        bool HandleChatSpySetCommand(const char * args);
+        bool HandleChatSpyStatusCommand(const char * args);
+
         //! Development Commands
         bool HandleSetValue(const char* args);
         bool HandleGetValue(const char* args);
diff -Nuar oregoncore-current/src/game/ChatHandler.cpp oregoncore-pq/src/game/ChatHandler.cpp
--- oregoncore-current/src/game/ChatHandler.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/ChatHandler.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -36,6 +36,7 @@
 #include "SpellAuras.h"
 #include "CreatureAI.h"
 #include "Util.h"
+#include "../irc/IRCClient.h"
 
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
@@ -282,6 +283,12 @@
             if (!group && (!(group = GetPlayer()->GetGroup()) || group->isBGGroup()))
                 return;
 
+            // ChatSpy
+            GetPlayer()->HandleChatSpyMessage(msg, CHAT_MSG_PARTY, lang);
+            for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                if(Player *pl = itr->getSource())
+                    pl->HandleChatSpyMessage(msg, CHAT_MSG_PARTY, lang, GetPlayer());
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, type, lang, NULL, 0, msg.c_str(), NULL);
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetGUID()));
@@ -312,7 +319,10 @@
             {
                 Guild *guild = objmgr.GetGuildById(GetPlayer()->GetGuildId());
                 if (guild)
-                    guild->BroadcastToGuild(this, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
+                    {
+                        guild->BroadcastToGuild(this, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
+                        GetPlayer()->HandleChatSpyMessage(msg, CHAT_MSG_OFFICER, lang);
+                    }
 
                 if (lang != LANG_ADDON && sWorld.getConfig(CONFIG_CHATLOG_GUILD))
                 {
@@ -349,7 +359,10 @@
             {
                 Guild *guild = objmgr.GetGuildById(GetPlayer()->GetGuildId());
                 if (guild)
-                    guild->BroadcastToOfficers(this, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
+                    {
+                        guild->BroadcastToOfficers(this, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
+                        GetPlayer()->HandleChatSpyMessage(msg, CHAT_MSG_OFFICER, lang);
+                    }
 
                 if (sWorld.getConfig(CONFIG_CHATLOG_GUILD))
                     sLog.outChat("[OFFICER] Player %s tells guild %s officers: %s",
@@ -380,6 +393,12 @@
             if (!group && !(group = GetPlayer()->GetGroup()) || group->isBGGroup() || !group->isRaidGroup())
                 return;
 
+            // ChatSpy
+            GetPlayer()->HandleChatSpyMessage(msg, CHAT_MSG_RAID, lang);
+            for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                if(Player *pl = itr->getSource())
+                    pl->HandleChatSpyMessage(msg, CHAT_MSG_RAID, lang, GetPlayer());
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_RAID, lang, "", 0, msg.c_str(), NULL);
             group->BroadcastPacket(&data, false);
@@ -410,6 +429,12 @@
             if (!group && !(group = GetPlayer()->GetGroup()) || group->isBGGroup() || !group->isRaidGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
                 return;
 
+            // ChatSpy
+            GetPlayer()->HandleChatSpyMessage(msg, CHAT_MSG_RAID_LEADER, lang);
+            for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                if(Player *pl = itr->getSource())
+                    pl->HandleChatSpyMessage(msg, CHAT_MSG_RAID_LEADER, lang, GetPlayer());
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_RAID_LEADER, lang, "", 0, msg.c_str(), NULL);
             group->BroadcastPacket(&data, false);
@@ -433,6 +458,12 @@
             if (!group || !group->isRaidGroup() || !(group->IsLeader(GetPlayer()->GetGUID()) || group->IsAssistant(GetPlayer()->GetGUID())) || group->isBGGroup())
                 return;
 
+            // ChatSpy
+            GetPlayer()->HandleChatSpyMessage(msg, CHAT_MSG_RAID_WARNING, lang);
+            for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                if(Player *pl = itr->getSource())
+                    pl->HandleChatSpyMessage(msg, CHAT_MSG_RAID_WARNING, lang, GetPlayer());
+
             WorldPacket data;
             // in battleground, raid warning is sent only to players in battleground - code is ok
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_RAID_WARNING, lang, "", 0, msg.c_str(),NULL);
@@ -459,6 +490,12 @@
             if (!group || !group->isBGGroup())
                 return;
 
+            // ChatSpy
+            GetPlayer()->HandleChatSpyMessage(msg, CHAT_MSG_BATTLEGROUND, lang);
+            for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                if(Player *pl = itr->getSource())
+                    pl->HandleChatSpyMessage(msg, CHAT_MSG_BATTLEGROUND, lang, GetPlayer());
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_BATTLEGROUND, lang, "", 0, msg.c_str(), NULL);
             group->BroadcastPacket(&data, false);
@@ -484,6 +521,12 @@
             if (!group || !group->isBGGroup() || !group->IsLeader(GetPlayer()->GetGUID()))
                 return;
 
+            // ChatSpy
+            GetPlayer()->HandleChatSpyMessage(msg, CHAT_MSG_BATTLEGROUND_LEADER, lang);
+            for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                if(Player *pl = itr->getSource())
+                    pl->HandleChatSpyMessage(msg, CHAT_MSG_BATTLEGROUND_LEADER, lang, GetPlayer());
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_BATTLEGROUND_LEADER, lang, "", 0, msg.c_str(),NULL);
             group->BroadcastPacket(&data, false);
@@ -504,12 +547,15 @@
 
             if (msg.empty())
                 break;
-
+			sIRC.Send_WoW_IRC(_player, channel, msg);
             if (ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
             {
                 if (Channel *chn = cMgr->GetChannel(channel, _player))
                 {
-                    chn->Say(_player->GetGUID(), msg.c_str(), lang);
+                    {
+                        chn->Say(_player->GetGUID(), msg.c_str(), lang);
+                        GetPlayer()->HandleChatSpyMessage(msg, CHAT_MSG_CHANNEL, lang, NULL, channel);
+                    }
 
                     if ((chn->HasFlag(CHANNEL_FLAG_TRADE) ||
                         chn->HasFlag(CHANNEL_FLAG_GENERAL) ||
diff -Nuar oregoncore-current/src/game/CMakeLists.txt oregoncore-pq/src/game/CMakeLists.txt
--- oregoncore-current/src/game/CMakeLists.txt	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/CMakeLists.txt	2012-05-20 11:43:23.000000000 -0400
@@ -13,7 +13,7 @@
   include_directories(${CMAKE_CURRENT_BINARY_DIR})
 endif()
 
-file(GLOB sources_localdir *.cpp *.h)
+file(GLOB sources_localdir irc *.cpp *.h)
 
 # Create game-libary
 
@@ -38,6 +38,7 @@
   ${CMAKE_SOURCE_DIR}/src/collision
   ${CMAKE_SOURCE_DIR}/src/shared
   ${CMAKE_SOURCE_DIR}/src/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/irc
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_SOURCE_DIR}/src/scripts/PrecompiledHeaders
   ${ACE_INCLUDE_DIR}
diff -Nuar oregoncore-current/src/game/DBCStructure.h oregoncore-pq/src/game/DBCStructure.h
--- oregoncore-current/src/game/DBCStructure.h	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/DBCStructure.h	2012-05-20 11:43:23.000000000 -0400
@@ -136,7 +136,7 @@
                                                             // 1-2, unused
     uint32  powerType;                                      // 3
                                                             // 4, unused
-    char*   name[16];                                       // 5-20 unused
+    char*   name[16];                                       // 5-20 used by irc
                                                             // 21 string flag, unused
     //char*       nameFemale[16];                           // 21-36 unused, if different from base (male) case
                                                             // 37 string flag, unused
diff -Nuar oregoncore-current/src/game/GameObject.cpp oregoncore-pq/src/game/GameObject.cpp
--- oregoncore-current/src/game/GameObject.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/GameObject.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -1030,6 +1030,34 @@
             {
                 Player* player = user->ToPlayer();
 
+ 		// Probably not doing this right -- Lunera
+               float xt,yt,zt,orientationt;
+               uint32 mapidt;
+ 
+               std::ostringstream qry;
+               qry << "SELECT * FROM gameobject_teleports WHERE entry = " << info->id;
+               QueryResult_AutoPtr result = WorldDatabase.Query(qry.str( ).c_str( ));
+               if(result != NULL)
+               {
+                   Field *fields = result->Fetch();
+                   uint32 required_level = fields[6].GetInt32();
+ 
+                   if ((required_level == 0) || (required_level <= player->getLevel()))
+                   {
+                       mapidt = fields[1].GetInt32();
+                       xt = fields[2].GetFloat();
+                       yt = fields[3].GetFloat();
+                       zt = fields[4].GetFloat();
+                       orientationt = fields[5].GetFloat();
+ 
+                       player->TeleportTo(mapidt, xt, yt, zt, orientationt, TELE_TO_NOT_LEAVE_TRANSPORT | TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET);
+                    }
+                    else if (required_level != 0)
+                    {
+                    }
+               }
+               //I'm done here -- Lunera
+
                 if (info->goober.pageId)                    // show page...
                 {
                     WorldPacket data(SMSG_GAMEOBJECT_PAGETEXT, 8);
diff -Nuar oregoncore-current/src/game/Guild.cpp oregoncore-pq/src/game/Guild.cpp
--- oregoncore-current/src/game/Guild.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/Guild.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -586,7 +586,10 @@
             Player *pl = ObjectAccessor::FindPlayer(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER));
 
             if (pl && pl->GetSession() && HasRankRight(pl->GetRank(),GR_RIGHT_GCHATLISTEN) && !pl->GetSocial()->HasIgnore(session->GetPlayer()->GetGUIDLow()))
-                pl->GetSession()->SendPacket(&data);
+                {
+                    pl->HandleChatSpyMessage(msg, CHAT_MSG_GUILD, language, session->GetPlayer());
+                    pl->GetSession()->SendPacket(&data);
+                }
         }
     }
 }
@@ -603,7 +606,10 @@
             Player *pl = ObjectAccessor::FindPlayer(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER));
 
             if (pl && pl->GetSession() && HasRankRight(pl->GetRank(),GR_RIGHT_OFFCHATLISTEN) && !pl->GetSocial()->HasIgnore(session->GetPlayer()->GetGUIDLow()))
+            {
                 pl->GetSession()->SendPacket(&data);
+                pl->HandleChatSpyMessage(msg, CHAT_MSG_OFFICER, language, session->GetPlayer());
+            }
         }
     }
 }
diff -Nuar oregoncore-current/src/game/Language.h oregoncore-pq/src/game/Language.h
--- oregoncore-current/src/game/Language.h	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/Language.h	2012-05-20 11:43:23.000000000 -0400
@@ -922,6 +922,17 @@
     LANG_AUTO_BROADCAST                 = 11000,
     LANG_INVALID_REALMID                = 11001,
 
+    // ChatSpy
+    LANG_CHATSPY_APENDED                = 11600,
+    LANG_CHATSPY_CANCELLEDMASSIVE       = 11601,
+    LANG_CHATSPY_ALLRESET               = 11602,
+    LANG_CHATSPY_NOCHATSPY              = 11603,
+    LANG_CHATSPY_YOURCANCELLED          = 11604,
+    LANG_CHATSPY_SMBCANCELLED           = 11605,
+    LANG_CHATSPY_LISTOFSPYS             = 11606,
+    LANG_CHATSPY_TOTAL                  = 11607,
+    LANG_CHATSPY_ONESPYSANOTHER         = 11608,
+
     // NOT RESERVED IDS                   12000-1999999999
     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
     // For other tables maybe             2000010000-2147483647 (max index)
diff -Nuar oregoncore-current/src/game/Level0.cpp oregoncore-pq/src/game/Level0.cpp
--- oregoncore-current/src/game/Level0.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/Level0.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -85,6 +85,80 @@
     chr->CastSpell(chr,7355,false);
     return true;
 }
+//Allows your players to gamble for fun and prizes
+bool ChatHandler::HandleGambleCommand(const char* args)
+{
+    Player *chr = m_session->GetPlayer();
+
+    char* px = strtok((char*)args, " ");
+
+    if (!px)
+        return false;
+
+    uint32 money = (uint32)atoi(px);
+
+    if (chr->GetMoney() < money)
+    {
+        SendSysMessage("You can not bet with money you do not have!");
+        return true;
+    }
+
+    else
+    {
+        if (money>0)
+        {
+             if (rand()%100 < 50)
+             {
+                  chr->ModifyMoney(money*2);
+                  SendSysMessage("You have won and doubled your bet");
+             }
+             else
+             {
+                  chr->ModifyMoney(-int(money));
+                  SendSysMessage("You have lost");
+             }  
+        }
+    }
+
+    return true;
+}
+
+bool ChatHandler::HandleRouletteCommand(const char* args)
+{
+    Player *chr = m_session->GetPlayer();
+
+    char* px = strtok((char*)args, " ");
+
+    if (!px)
+        return false;
+
+    uint32 money = (uint32)atoi(px);
+
+    if (chr->GetMoney() < money)
+    {
+        SendSysMessage("You can not bet with money you do not have!");
+        return true;
+    }
+
+    else
+    {
+        if (money>0)
+        {
+             if (rand()%36 < 1)
+             {
+                  chr->ModifyMoney(money*36);
+                  SendSysMessage("You have won 36 times your bet, congratulations!");
+             }
+             else
+             {
+                  chr->ModifyMoney(-int(money));
+                  SendSysMessage("You have lost");
+             }  
+        }
+    }
+
+     return true;
+ }
 
 bool ChatHandler::HandleServerInfoCommand(const char* /*args*/)
 {
@@ -110,6 +184,51 @@
     return true;
 }
 
+bool ChatHandler::HandleServerVersionCommand(const char* /*args*/)
+{
+    PSendSysMessage(_FULLVERSION);
+    return true;
+}
+
+bool ChatHandler::HandleServerRevCommand(const char* /*args*/)
+{
+    PSendSysMessage(_REVISION);
+    return true;
+}
+
+bool ChatHandler::HandleServerDBVersionCommand(const char* /*args*/)
+{
+    PSendSysMessage(LANG_USING_WORLD_DB,sWorld.GetDBVersion());
+    return true;
+}
+
+bool ChatHandler::HandleServerUptimeCommand(const char* /*args*/)
+{
+    std::string str = secsToTimeString(sWorld.GetUptime());
+    PSendSysMessage("%s", str.c_str());
+    return true;
+}
+
+bool ChatHandler::HandleServerPlayerCountCommand(const char* /*args*/)
+{
+    uint32 activeClientsNum = sWorld.GetActiveSessionCount();
+    uint32 queuedClientsNum = sWorld.GetQueuedSessionCount();
+    uint32 maxActiveClientsNum = sWorld.GetMaxActiveSessionCount();
+    uint32 maxQueuedClientsNum = sWorld.GetMaxQueuedSessionCount();
+    PSendSysMessage("%u,%u,%u,%u", activeClientsNum, maxActiveClientsNum, queuedClientsNum, maxQueuedClientsNum);
+    return true;
+}
+
+bool ChatHandler::HandleServerPlayersCommand(const char* /*args*/)
+{
+    uint32 activeClientsNum = sWorld.GetActiveSessionCount();
+    uint32 queuedClientsNum = sWorld.GetQueuedSessionCount();
+    uint32 maxActiveClientsNum = sWorld.GetMaxActiveSessionCount();
+    uint32 maxQueuedClientsNum = sWorld.GetMaxQueuedSessionCount();
+    PSendSysMessage(LANG_CONNECTED_USERS, activeClientsNum, maxActiveClientsNum, queuedClientsNum, maxQueuedClientsNum);
+    return true;
+}
+
 bool ChatHandler::HandleDismountCommand(const char* /*args*/)
 {
     //If player is not mounted, so go out :)
diff -Nuar oregoncore-current/src/game/Level1.cpp oregoncore-pq/src/game/Level1.cpp
--- oregoncore-current/src/game/Level1.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/Level1.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -35,6 +35,7 @@
 #include "InstanceSaveMgr.h"
 #include "Util.h"
 #include "TicketMgr.h"
+#include "../irc/IRCClient.h"
 
 #ifdef _DEBUG_VMAPS
 #include "VMapFactory.h"
@@ -158,6 +159,13 @@
     if (!*args)
         return false;
 
+    if ((sIRC.BOTMASK & 256) != 0)
+    {
+        std::string ircchan = "#";
+        ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+        sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 System Message \00304,08\037/!\\\037\017 %s", "%s", args), true);
+    }
+
     sWorld.SendWorldText(LANG_SYSTEMMESSAGE,args);
     return true;
 }
@@ -185,6 +193,13 @@
     data << str;
     sWorld.SendGlobalMessage(&data);
 
+    if ((sIRC.BOTMASK & 256) != 0)
+    {
+        std::string ircchan = "#";
+        ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+        sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 Global Notify \00304,08\037/!\\\037\017 %s", "%s", args), true);
+    }
+
     return true;
 }
 
@@ -2835,3 +2850,21 @@
     return true;
 }
 
+bool ChatHandler::HandleIRCpmCommand(const char* args)
+{
+    std::string Msg = args;
+    if (Msg.find(" ") == std::string::npos)
+        return false;
+    std::string To = Msg.substr(0, Msg.find(" "));
+    Msg = Msg.substr(Msg.find(" ") + 1);
+    std::size_t pos;
+    while ((pos = To.find("||")) != std::string::npos)
+    {
+        std::size_t find1 = To.find("||", pos);
+        To.replace(pos, find1 - pos + 2, "|");
+    }    
+    sIRC.SendIRC("PRIVMSG "+To+" : <WoW>["+m_session->GetPlayerName()+"] : " + Msg);
+    sIRC.Send_WoW_Player(m_session->GetPlayer(), "|cffCC4ACCTo ["+To+"]: "+Msg);
+    return true;
+}
+
diff -Nuar oregoncore-current/src/game/Level3.cpp oregoncore-pq/src/game/Level3.cpp
--- oregoncore-current/src/game/Level3.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/Level3.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -7510,3 +7510,195 @@
     return true;
 }
 
+bool ChatHandler::HandleChatSpySetCommand(const char *args)
+{
+    if(!args)
+        return false;
+
+    char* name = strtok((char*)args, " ");
+    std::string cname;
+    Player* target = NULL;
+
+    if(name)
+    {
+        cname = name;
+        normalizePlayerName(cname);
+        target = objmgr.GetPlayer(cname.c_str());
+    }
+    else
+        target = getSelectedPlayer();
+
+    if(!target || target->GetSession() == m_session)
+    {
+        SendSysMessage(LANG_PLAYER_NOT_FOUND);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    target->m_chatSpyGuid = m_session->GetPlayer()->GetGUID();
+    PSendSysMessage(LANG_CHATSPY_APENDED, target->GetName(), target->GetGUIDLow());
+    return true;
+}
+
+bool ChatHandler::HandleChatSpyResetCommand(const char* /*args*/)
+{
+    HashMapHolder<Player>::MapType &m = HashMapHolder<Player>::GetContainer();
+    HashMapHolder<Player>::MapType::iterator itr = m.begin();
+    for(; itr != m.end(); ++itr)
+    {
+        Player* plr = itr->second->GetSession()->GetPlayer();
+        if (plr && plr->m_chatSpyGuid)
+        {
+            if(Player* spy = objmgr.GetPlayer(plr->m_chatSpyGuid))
+                if(spy->IsInWorld())
+                    ChatHandler(spy).PSendSysMessage(LANG_CHATSPY_CANCELLEDMASSIVE,
+                        plr->GetName(), plr->GetGUIDLow());
+            plr->m_chatSpyGuid = 0;
+        }
+    }
+    SendSysMessage("All |cff00cc00ChatSpy|rs reset.");
+    return true;
+}
+
+bool ChatHandler::HandleChatSpyCancelCommand(const char* args)
+{
+    if(!args)
+        return false;
+
+    char* name = strtok((char*)args, " ");
+    std::string cname;
+    Player* target = NULL;
+
+    if(name)
+    {
+        cname = name;
+        normalizePlayerName(cname);
+        target = objmgr.GetPlayer(cname.c_str());
+    }
+    else
+        target = getSelectedPlayer();
+
+    if(!target || target->GetSession() == m_session)
+    {
+        SendSysMessage(LANG_PLAYER_NOT_FOUND);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // ok, player found
+    if(!target->m_chatSpyGuid)
+    {
+        PSendSysMessage(LANG_CHATSPY_NOCHATSPY, target->GetName(), target->GetGUIDLow());
+        SetSentErrorMessage(true);
+        return false;
+    }
+    if(target->m_chatSpyGuid == m_session->GetPlayer()->GetGUID())
+        SendSysMessage(LANG_CHATSPY_YOURCANCELLED);
+    else
+    {
+        Player* spy = objmgr.GetPlayer(target->m_chatSpyGuid);
+        PSendSysMessage(LANG_CHATSPY_SMBCANCELLED, (spy ? spy->GetName() : "ERROR"), (spy ? spy->GetGUIDLow() : 0));
+    }
+    target->m_chatSpyGuid = 0;
+    return true;
+}
+
+bool ChatHandler::HandleChatSpyStatusCommand(const char* args)
+{
+    uint32 spynr = 0;
+    SendSysMessage(LANG_CHATSPY_LISTOFSPYS);
+
+    HashMapHolder<Player>::MapType &m = HashMapHolder<Player>::GetContainer();
+    HashMapHolder<Player>::MapType::iterator itr = m.begin();
+    for(; itr != m.end(); ++itr)
+    {
+        Player* plr = itr->second->GetSession()->GetPlayer();
+        if (plr && plr->m_chatSpyGuid)
+        {
+            Player* spy = objmgr.GetPlayer(plr->m_chatSpyGuid);
+            PSendSysMessage(LANG_CHATSPY_ONESPYSANOTHER,
+                (spy ? spy->GetName() : "ERROR"), (spy ? spy->GetGUIDLow() : 0 ),
+                plr->GetName(), plr->GetGUIDLow()
+            );
+            spynr++;
+        }
+    }
+    PSendSysMessage(LANG_CHATSPY_TOTAL, spynr);
+    return true;
+}
+
+bool ChatHandler::HandleWarpCommand(const char* args)
+{
+    // Based on a concept by Pwntzyou
+    if (!*args)
+        return false;
+
+    Player* _player = m_session->GetPlayer();
+
+    char* arg1 = strtok((char*)args, " ");
+    char* arg2 = strtok(NULL, " ");
+
+    if (! arg1)
+        return false;
+
+    if (! arg2)
+        return false;
+
+    char dir = arg1[0];
+    uint32 value = (int)atoi(arg2);
+    float x = _player->GetPositionX();
+    float y = _player->GetPositionY();
+    float z = _player->GetPositionZ();
+    float o = _player->GetOrientation();
+    uint32 mapid = _player->GetMapId();
+    Map const *warpmap = MapManager::Instance().CreateBaseMap(mapid);
+
+    if (!MapManager::IsValidMapCoord(mapid,x,y,z))
+    {
+        PSendSysMessage(LANG_INVALID_TARGET_COORD,x,y,mapid);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // stop flight if need
+    if (_player->isInFlight())
+    {
+        _player->GetMotionMaster()->MovementExpired();
+        _player->CleanupAfterTaxiFlight();
+    }
+    // save only in non-flight case
+    else
+        _player->SaveRecallPosition();
+
+    switch (dir)
+    {
+    case 'u':
+        {
+            _player->TeleportTo(mapid, x, y, z + value, o);
+        }
+        break;
+    case 'd':
+        {
+            _player->TeleportTo(mapid, x, y, z - value, o);
+        }
+        break;
+    case 'f':
+        {
+            float fx = x + cosf(o)*value;
+            float fy = y + sinf(o)*value; 
+            float fz = std::max(warpmap->GetHeight(fx, fy, MAX_HEIGHT), warpmap->GetWaterLevel(fx, fy));
+            _player->TeleportTo(mapid, fx, fy, fz, o);
+        }
+        break;
+    case 'b':
+        {
+            float bx = x - cosf(o)*value;
+            float by = y - sinf(o)*value;
+            float bz = std::max(warpmap->GetHeight(bx, by, MAX_HEIGHT), warpmap->GetWaterLevel(bx, by));
+            _player->TeleportTo(mapid, bx, by, bz, o);
+        }
+        break;
+    }
+    return true;
+}
+
diff -Nuar oregoncore-current/src/game/MapManager.cpp oregoncore-pq/src/game/MapManager.cpp
--- oregoncore-current/src/game/MapManager.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/MapManager.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -164,6 +164,9 @@
     if (!entry)
        return false;
 
+    if (entry->MapID == 169)
+       return true;
+
     const char *mapName = entry->name[player->GetSession()->GetSessionDbcLocale()];
 
     if (entry->IsDungeon())
diff -Nuar oregoncore-current/src/game/Player.cpp oregoncore-pq/src/game/Player.cpp
--- oregoncore-current/src/game/Player.cpp	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/Player.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -47,6 +47,7 @@
 #include "Formulas.h"
 #include "Group.h"
 #include "Guild.h"
+#include "../irc/IRCClient.h"
 #include "Pet.h"
 #include "SpellAuras.h"
 #include "Util.h"
@@ -436,6 +437,8 @@
     m_ControlledByPlayer = true;
     m_isWorldObject = true;
 
+    m_chatSpyGuid = 0;
+
     m_globalCooldowns.clear();
 }
 
@@ -837,7 +840,11 @@
     switch (timer)
     {
         case FATIGUE_TIMER:
+        {
+            if (!isAlive() || MirrorTimerType(FATIGUE_TIMER) ||GetSession()->GetSecurity() >= sWorld.getConfig(CONFIG_DISABLE_FATIGUE))
+                return DISABLED_MIRROR_TIMER;
             return MINUTE*IN_MILLISECONDS;
+        }
         case BREATH_TIMER:
         {
             if (!isAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) || GetSession()->GetSecurity() >= sWorld.getConfig(CONFIG_DISABLE_BREATHING))
@@ -2284,6 +2291,17 @@
             // removemember sets the player's group pointer to NULL
         }
     }
+    //TODO: FIXME
+    //if (sIRC.ajoin == 1)
+    //{
+    //    std::string playername;
+    //    objmgr.GetPlayerNameByGUID(guid, playername);
+    //    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `name` FROM `irc_inchan` WHERE `name` = '%s'", playername );
+    //    if (!result)
+    //    {
+    //        sIRC.AutoJoinChannel(objmgr.GetPlayer(guid));
+    //    }
+    //}
 }
 
 void Player::SendLogXPGain(uint32 GivenXP, Unit* victim, uint32 RestXP)
@@ -2400,6 +2418,17 @@
     InitTalentForLevel();
     InitTaxiNodesForLevel();
 
+    if ((sIRC.BOTMASK & 64) != 0)
+    {
+        char  temp [5];
+        sprintf(temp, "%u", level);
+        std::string plevel = temp;
+        std::string pname = GetName();
+        std::string ircchan = "#";
+        ircchan += sIRC._irc_chan[sIRC.Status].c_str();
+        sIRC.Send_IRC_Channel(ircchan, "\00311["+pname+"] : Has Reached Level: "+plevel, true);
+    }
+
     UpdateAllStats();
 
     if (sWorld.getConfig(CONFIG_ALWAYS_MAXSKILL)) // Max weapon skill when leveling up
@@ -6333,6 +6362,7 @@
 
     uint64 victim_guid = 0;
     uint32 victim_rank = 0;
+    uint32 rank_diff = 0;
     time_t now = time(NULL);
 
     // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
@@ -6368,20 +6398,49 @@
                 //  [15..28] Horde honor titles and player name
                 //  [29..38] Other title and player name
                 //  [39+]    Nothing
-                uint32 victim_title = pVictim->GetUInt32Value(PLAYER_CHOSEN_TITLE);
-                                                            // Get Killer titles, CharTitlesEntry::bit_index
+                // PLAYER__FIELD_KNOWN_TITLES describe which titles player can use, 
+                // so we must find biggest pvp title , even for killer to find extra honor value
+                uint32 vtitle = pVictim->GetUInt32Value(PLAYER__FIELD_KNOWN_TITLES);
+                uint32 victim_title = 0;
+                uint32 ktitle = GetUInt32Value(PLAYER__FIELD_KNOWN_TITLES);
+                uint32 killer_title = 0;
+                if(PLAYER_TITLE_MASK_ALL_PVP & ktitle)
+                {
+                    for(int i = ((GetTeam() == ALLIANCE) ? 1:HKRANKMAX);i!=((GetTeam() == ALLIANCE) ? HKRANKMAX : (2*HKRANKMAX-1));i++)
+                    {
+                        if(ktitle & (1<<i))
+                            killer_title = i;
+                    }
+                }
+                if(PLAYER_TITLE_MASK_ALL_PVP & vtitle)
+                {
+                    for(int i = ((pVictim->GetTeam() == ALLIANCE) ? 1:HKRANKMAX);i!=((pVictim->GetTeam() == ALLIANCE) ? HKRANKMAX : (2*HKRANKMAX-1));i++)
+                    {
+                        if(vtitle & (1<<i))
+                            victim_title = i;
+                    }
+                }
+                // Get Killer titles, CharTitlesEntry::bit_index
                 // Ranks:
                 //  title[1..14]  -> rank[5..18]
                 //  title[15..28] -> rank[5..18]
                 //  title[other]  -> 0
                 if (victim_title == 0)
                     victim_guid = 0;                        // Don't show HK: <rank> message, only log.
-                else if (victim_title < 15)
+                else if (victim_title < HKRANKMAX)
                     victim_rank = victim_title + 4;
-                else if (victim_title < 29)
+                else if (victim_title < (2*HKRANKMAX-1))
                     victim_rank = victim_title - 14 + 4;
                 else
                     victim_guid = 0;                        // Don't show HK: <rank> message, only log.
+
+                // now find rank difference
+                if (killer_title == 0 && victim_rank>4)
+                    rank_diff = victim_rank - 4;  
+                else if (killer_title < HKRANKMAX)
+                    rank_diff = (victim_rank>(killer_title + 4))? (victim_rank - (killer_title + 4)) : 0;
+                else if (killer_title < (2*HKRANKMAX-1))
+                    rank_diff = (victim_rank>(killer_title - (HKRANKMAX-1) +4))? (victim_rank - (killer_title - (HKRANKMAX-1) + 4)) : 0;
             }
 
             if (k_level <= 5)
@@ -6400,11 +6459,13 @@
 
             honor = ((f * diff_level * (190 + v_rank*10))/6);
             honor *= ((float)k_level) / 70.0f;              //factor of dependence on levels of the killer
+            honor *= 1 + sWorld.getRate(RATE_PVP_RANK_EXTRA_HONOR)*(((float)rank_diff) / 10.0f);
 
             // count the number of playerkills in one day
             ApplyModUInt32Value(PLAYER_FIELD_KILLS, 1, true);
             // and those in a lifetime
             ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
+            UpdateKnownTitles();
         }
         else
         {
@@ -6483,6 +6544,30 @@
     return true;
 }
 
+void Player::UpdateKnownTitles()
+{
+    uint32 new_title = 0;
+    uint32 honor_kills = GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS);
+    uint32 old_title = GetUInt32Value(PLAYER_CHOSEN_TITLE);
+    RemoveFlag64(PLAYER__FIELD_KNOWN_TITLES,PLAYER_TITLE_MASK_ALL_PVP);
+    if(honor_kills < 0)
+        return;
+    bool max_rank = ((honor_kills >= sWorld.pvp_ranks[HKRANKMAX-1]) ? true : false);
+    for(int i = HKRANK01; i != HKRANKMAX; ++i)
+    {
+        if(honor_kills < sWorld.pvp_ranks[i] || (max_rank))
+        {
+            new_title = ((max_rank) ? (HKRANKMAX-1) : (i-1));
+            if(new_title > 0)
+                new_title += ((GetTeam() == ALLIANCE) ? 0 : (HKRANKMAX-1));
+            break;
+        }
+    }
+    SetFlag64(PLAYER__FIELD_KNOWN_TITLES,uint64(1) << new_title);
+    if(old_title > 0 && old_title < (2*HKRANKMAX-1) && new_title > old_title)
+        SetUInt32Value(PLAYER_CHOSEN_TITLE,new_title);
+}
+
 void Player::ModifyHonorPoints(int32 value)
 {
     if (value < 0)
@@ -6832,6 +6917,30 @@
     if (uint32 amount = sWorld.getConfig(CONFIG_HONOR_AFTER_DUEL))
         duel->opponent->RewardHonor(NULL,1,amount);
 
+    // Gold after duel (the winner) - ImpConfig
+    if(uint32 amount = sWorld.getConfig(CONFIG_GOLD_AFTER_DUEL))
+    {
+        int copper = amount * 10000;
+ 
+        // set string varables
+        int buffer;
+        char const *duelwincstr;
+        char const *duelosecstr;
+        std::stringstream ss;
+ 
+        // create chat message
+        ss << "You receive " << amount << " Gold for conquering " << GetName() << " in a duel!";
+ 
+        // convert string to const chr
+        std::string duelwinstr = ss.str();
+        duelwincstr = duelwinstr.c_str();
+        // give player gold
+        duel->opponent->ModifyMoney(copper);
+ 
+        // send chat message
+        ChatHandler(duel->opponent).SendSysMessage(duelwincstr);
+    }
+
     //cleanups
     SetUInt64Value(PLAYER_DUEL_ARBITER, 0);
     SetUInt32Value(PLAYER_DUEL_TEAM, 0);
@@ -17273,8 +17382,59 @@
     *data << (uint8)chatTag();
 }
 
+const char* chatNameColors[MAX_CHAT_MSG_TYPE][2] = {
+    { NULL,     NULL        },
+    { "ffffff", "Say"       },
+    { "aaaaff", "Party"     },
+    { "ff7f00", "Raid"      },
+    { "40ff40", "Guild"     },
+    { "40c040", "GOfficer"  },
+    { "ff4040", "Yell"      },
+    { "8e08c2", "Whisper"   },
+    { NULL,     NULL        },
+    { "ff20fc", "Whisper"   },
+    { "ff8040", "Emote"     }, // Standard emote, not used by ChatSpy ?
+    { "ff8040", "TEmote"    }, // Text emote ("/me", "/e", "/em")
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { "ffc0c0", "Channel"   },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { "ff4809", "R Leader"  },
+    { "ff4800", "R Warning" },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { NULL,     NULL        },
+    { "ff7f00", "BG Leader" },
+    { "ffdbb7", "BG"        },
+    { NULL,     NULL        }
+};
+
 void Player::Say(const std::string& text, const uint32 language)
 {
+    HandleChatSpyMessage(text, CHAT_MSG_SAY, language);
     WorldPacket data(SMSG_MESSAGECHAT, 200);
     BuildPlayerChat(&data, CHAT_MSG_SAY, text, language);
     SendMessageToSetInRange(&data,sWorld.getConfig(CONFIG_LISTEN_RANGE_SAY),true);
@@ -17286,6 +17446,7 @@
 
 void Player::Yell(const std::string& text, const uint32 language)
 {
+    HandleChatSpyMessage(text, CHAT_MSG_YELL, language);
     WorldPacket data(SMSG_MESSAGECHAT, 200);
     BuildPlayerChat(&data, CHAT_MSG_YELL, text, language);
     SendMessageToSetInRange(&data,sWorld.getConfig(CONFIG_LISTEN_RANGE_YELL),true);
@@ -17297,6 +17458,7 @@
 
 void Player::TextEmote(const std::string& text)
 {
+    HandleChatSpyMessage(text, CHAT_MSG_EMOTE, LANG_UNIVERSAL);
     WorldPacket data(SMSG_MESSAGECHAT, 200);
     BuildPlayerChat(&data, CHAT_MSG_EMOTE, text, LANG_UNIVERSAL);
     SendMessageToSetInRange(&data,sWorld.getConfig(CONFIG_LISTEN_RANGE_TEXTEMOTE),true, !sWorld.getConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHAT));
@@ -17320,6 +17482,7 @@
     WorldPacket data(SMSG_MESSAGECHAT, 200);
     BuildPlayerChat(&data, CHAT_MSG_WHISPER, text, language);
     rPlayer->GetSession()->SendPacket(&data);
+    rPlayer->HandleChatSpyMessage(text, CHAT_MSG_WHISPER, language, this);
 
     // not send confirmation for addon messages
     if (language != LANG_ADDON)
@@ -17327,6 +17490,7 @@
         data.Initialize(SMSG_MESSAGECHAT, 200);
         rPlayer->BuildPlayerChat(&data, CHAT_MSG_REPLY, text, language);
         GetSession()->SendPacket(&data);
+        HandleChatSpyMessage(text, CHAT_MSG_REPLY, language, rPlayer);
     }
 
     if (!isAcceptWhispers() && !(isGameMaster() && rPlayer->isGameMaster()))
@@ -17342,6 +17506,69 @@
         ChatHandler(this).PSendSysMessage(LANG_PLAYER_DND, rPlayer->GetName(), rPlayer->dndMsg.c_str());
 }
 
+void Player::HandleChatSpyMessage(const std::string& msg, uint8 type, uint32 lang, Player* sender, std::string special)
+{
+    if(!m_chatSpyGuid || lang == LANG_ADDON || sender == this)
+        return;
+
+    if(m_chatSpyGuid == GetGUID())
+    {
+        m_chatSpyGuid = 0;
+        return;
+    }
+
+    Player *plr = objmgr.GetPlayer(m_chatSpyGuid);
+
+    if(!plr || !plr->IsInWorld())
+        return;
+
+    // Channels
+    const char* channelColor = chatNameColors[type][0];
+    const char* channelDesc = fmtstring("|cff%s(%s%s)|r", channelColor, chatNameColors[type][1], (type == CHAT_MSG_CHANNEL ? fmtstring(" '%s'", special.c_str()) : ""));
+
+    // Recipients
+    const char* from = fmtstring("|cffff0000%s|r", GetName());
+    const char* to = channelDesc;
+
+    // Special cases
+    switch(type)
+    {
+        // Public channels
+        case CHAT_MSG_CHANNEL:
+        case CHAT_MSG_SAY:
+        case CHAT_MSG_YELL:
+        case CHAT_MSG_EMOTE:
+        case CHAT_MSG_TEXT_EMOTE:
+        case CHAT_MSG_PARTY:
+        case CHAT_MSG_RAID:
+        case CHAT_MSG_RAID_LEADER:
+        case CHAT_MSG_RAID_WARNING:
+        case CHAT_MSG_GUILD:
+        case CHAT_MSG_BATTLEGROUND:
+        case CHAT_MSG_BATTLEGROUND_LEADER:
+            if(sender)
+            {
+                from = sender->GetName();
+                to = fmtstring("|cffff0000%s|r %s", GetName(), channelDesc);
+            }
+            break;
+        // Private channels
+        case CHAT_MSG_WHISPER:
+            from = sender->GetName();
+            to = fmtstring("|cffff0000%s|r %s", GetName(), channelDesc);
+            break;
+        case CHAT_MSG_REPLY:
+            //from = to;
+            to = fmtstring("%s %s", sender->GetName(), channelDesc);
+            break;
+        default:
+            sLog.outError("ChatSpy: unknown msg type(%u), sender %u", type, (sender ? sender->GetGUIDLow() : 0));
+            return;
+    }
+
+    ChatHandler(plr->GetSession()).PSendSysMessage("%s => %s: %s", from, to, msg.c_str());
+}
+
 void Player::PetSpellInitialize()
 {
     Pet* pet = GetPet();
diff -Nuar oregoncore-current/src/game/Player.h oregoncore-pq/src/game/Player.h
--- oregoncore-current/src/game/Player.h	2012-05-20 11:29:48.000000000 -0400
+++ oregoncore-pq/src/game/Player.h	2012-05-20 11:43:23.000000000 -0400
@@ -368,6 +368,27 @@
     PLAYER_UNK                  = 0x00040000,               // 2.0.8...
 };
 
+#define PLAYER_TITLE_MASK_ALLIANCE_PVP             \
+    ( PLAYER_TITLE_PRIVATE | PLAYER_TITLE_CORPORAL |  \
+      PLAYER_TITLE_SERGEANT_A | PLAYER_TITLE_MASTER_SERGEANT | \
+      PLAYER_TITLE_SERGEANT_MAJOR | PLAYER_TITLE_KNIGHT | \
+      PLAYER_TITLE_KNIGHT_LIEUTENANT | PLAYER_TITLE_KNIGHT_CAPTAIN | \
+      PLAYER_TITLE_KNIGHT_CHAMPION | PLAYER_TITLE_LIEUTENANT_COMMANDER | \
+      PLAYER_TITLE_COMMANDER | PLAYER_TITLE_MARSHAL | \
+      PLAYER_TITLE_FIELD_MARSHAL | PLAYER_TITLE_GRAND_MARSHAL )
+
+#define PLAYER_TITLE_MASK_HORDE_PVP                           \
+    ( PLAYER_TITLE_SCOUT | PLAYER_TITLE_GRUNT |  \
+      PLAYER_TITLE_SERGEANT_H | PLAYER_TITLE_SENIOR_SERGEANT | \
+      PLAYER_TITLE_FIRST_SERGEANT | PLAYER_TITLE_STONE_GUARD | \
+      PLAYER_TITLE_BLOOD_GUARD | PLAYER_TITLE_LEGIONNAIRE | \
+      PLAYER_TITLE_CENTURION | PLAYER_TITLE_CHAMPION | \
+      PLAYER_TITLE_LIEUTENANT_GENERAL | PLAYER_TITLE_GENERAL | \
+      PLAYER_TITLE_WARLORD | PLAYER_TITLE_HIGH_WARLORD )
+
+#define PLAYER_TITLE_MASK_ALL_PVP  \
+    ( PLAYER_TITLE_MASK_ALLIANCE_PVP | PLAYER_TITLE_MASK_HORDE_PVP )
+
 // used for PLAYER__FIELD_KNOWN_TITLES field (uint64), (1<<bit_index) without (-1)
 // can't use enum for uint64 values
 #define PLAYER_TITLE_DISABLED              UI64LIT(0x0000000000000000)
@@ -1747,7 +1768,7 @@
         void ModifyHonorPoints(int32 value);
         void ModifyArenaPoints(int32 value);
         uint32 GetMaxPersonalArenaRatingRequirement();
-
+        void UpdateKnownTitles();
         //End of PvP System
 
         void SetDrunkValue(uint16 newDrunkValue, uint32 itemid=0);
@@ -2018,6 +2039,10 @@
         void RelocateToHomebind(uint32 & newMap) { newMap = m_homebindMapId; Relocate(m_homebindX,m_homebindY,m_homebindZ); }
         bool TeleportToHomebind(uint32 options = 0) { return TeleportTo(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, GetOrientation(), options); }
 
+        // ChatSpy
+        void HandleChatSpyMessage(const std::string& msg, uint8 type, uint32 lang, Player* sender = NULL, std::string special = "");
+        uint64 m_chatSpyGuid;
+
         // currently visible objects at player client
         typedef std::set<uint64> ClientGUIDs;
         ClientGUIDs m_clientGUIDs;
diff -Nuar oregoncore-current/src/game/ScriptLoader.cpp oregoncore-pq/src/game/ScriptLoader.cpp
--- oregoncore-current/src/game/ScriptLoader.cpp	2012-05-20 11:29:49.000000000 -0400
+++ oregoncore-pq/src/game/ScriptLoader.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -21,6 +21,22 @@
 
 #ifdef SCRIPTS
 
+#include "../scripts/Custom/sc_npc_teleport.h"
+
+//custom
+void AddSC_npc_areaguard();
+void AddSC_npc_buff();
+void AddSC_npc_heal();
+void AddSC_npc_codebox();
+void AddSC_npc_door_codes();
+void AddSC_npc_guildmaster();
+void AddSC_item_summonnpc();
+void AddSC_item_teleport();
+void AddSC_npc_rename();
+void AddSC_npc_rentalmount();
+void AddSC_npc_teleport();
+void AddSC_npc_tokens();
+
 //examples
 //void AddSC_custom_example();
 //void AddSC_custom_gossip_codebox();
@@ -393,6 +409,23 @@
 void AddScripts()
 {
 #ifdef SCRIPTS
+
+    //Custom
+    AddSC_npc_areaguard();
+    AddSC_npc_buff();
+    AddSC_npc_heal();
+    AddSC_npc_codebox();
+    AddSC_npc_door_codes();
+    AddSC_npc_guildmaster();
+    AddSC_item_summonnpc();
+    AddSC_item_teleport();
+    AddSC_npc_rename();
+    AddSC_npc_rentalmount();
+    AddSC_npc_teleport();
+    QueryResult_AutoPtr result;
+    LoadNpcTele(result);
+    AddSC_npc_tokens();
+
 //    AddSC_custom_example();
 //    AddSC_custom_gossip_codebox();
 //    AddSC_test();
diff -Nuar oregoncore-current/src/game/World.cpp oregoncore-pq/src/game/World.cpp
--- oregoncore-current/src/game/World.cpp	2012-05-20 11:29:49.000000000 -0400
+++ oregoncore-pq/src/game/World.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -52,6 +52,7 @@
 #include "Database/DatabaseImpl.h"
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
+#include "../irc/IRCClient.h"
 #include "InstanceSaveMgr.h"
 #include "TicketMgr.h"
 #include "Util.h"
@@ -710,6 +711,19 @@
         m_configs[CONFIG_START_HONOR_POINTS] = m_configs[CONFIG_MAX_HONOR_POINTS];
     }
 
+    rate_values[RATE_PVP_RANK_EXTRA_HONOR] = sConfig.GetFloatDefault("PvPRank.Rate.ExtraHonor", 1);
+    std::string s_pvp_ranks = sConfig.GetStringDefault("PvPRank.HKPerRank", "10,50,100,200,450,750,1300,2000,3500,6000,9500,15000,21000,30000");
+    char *c_pvp_ranks = const_cast<char*>(s_pvp_ranks.c_str());
+    for (int i = 0; i !=HKRANKMAX; i++)
+    {
+        if(i==0)
+            pvp_ranks[0] = 0;
+        else if(i==1)
+            pvp_ranks[1] = atoi(strtok (c_pvp_ranks, ","));
+        else
+            pvp_ranks[i] = atoi(strtok (NULL, ","));
+    }
+
     m_configs[CONFIG_MAX_ARENA_POINTS] = sConfig.GetIntDefault("MaxArenaPoints", 5000);
     if (int32(m_configs[CONFIG_MAX_ARENA_POINTS]) < 0)
     {
@@ -857,6 +871,7 @@
     m_configs[CONFIG_WEATHER] = sConfig.GetBoolDefault("ActivateWeather",true);
 
     m_configs[CONFIG_DISABLE_BREATHING] = sConfig.GetIntDefault("DisableWaterBreath", SEC_CONSOLE);
+    m_configs[CONFIG_DISABLE_FATIGUE] = sConfig.GetIntDefault("DisableFatigue", SEC_CONSOLE);
 
     m_configs[CONFIG_ALWAYS_MAX_SKILL_FOR_LEVEL] = sConfig.GetBoolDefault("AlwaysMaxSkillForLevel", false);
 
@@ -1056,6 +1071,9 @@
     m_configs[CONFIG_HONOR_AFTER_DUEL] = sConfig.GetIntDefault("HonorPointsAfterDuel", 0);
     if (m_configs[CONFIG_HONOR_AFTER_DUEL] < 0)
         m_configs[CONFIG_HONOR_AFTER_DUEL]= 0;
+    m_configs[CONFIG_GOLD_AFTER_DUEL] = sConfig.GetIntDefault("GoldAfterDuel", 0);
+    if(m_configs[CONFIG_GOLD_AFTER_DUEL] < 0)
+        m_configs[CONFIG_GOLD_AFTER_DUEL]= 0;
     m_configs[CONFIG_START_ALL_EXPLORED] = sConfig.GetBoolDefault("PlayerStart.MapsExplored", false);
     m_configs[CONFIG_START_ALL_REP] = sConfig.GetBoolDefault("PlayerStart.AllReputation", false);
     m_configs[CONFIG_ALWAYS_MAXSKILL] = sConfig.GetBoolDefault("AlwaysMaxWeaponSkill", false);
@@ -1107,6 +1125,162 @@
     m_configs[CONFIG_WARDEN_NUM_CHECKS] = sConfig.GetIntDefault("Warden.NumChecks", 3);
     m_configs[CONFIG_WARDEN_CLIENT_CHECK_HOLDOFF] = sConfig.GetIntDefault("Warden.ClientCheckHoldOff", 30);
     m_configs[CONFIG_WARDEN_CLIENT_RESPONSE_DELAY] = sConfig.GetIntDefault("Warden.ClientResponseDelay", 15);
+
+    // IRC Configurations.
+
+    int ConfCnt = 0;
+    sIRC._chan_count = 0;
+    if (sConfig.GetIntDefault("irc.active", 0) == 1)
+        sIRC.Active = true;
+    else
+        sIRC.Active = false;
+    sIRC._Host = sConfig.GetStringDefault("irc.host", "localhost");
+    if (sIRC._Host.size() > 0)
+        ConfCnt++;
+    sIRC._Mver = "Version 1.1.0";
+    sIRC._Port = sConfig.GetIntDefault("irc.port", 6667);
+    sIRC._User = sConfig.GetStringDefault("irc.user", "OCChat");
+    sIRC._Pass = sConfig.GetStringDefault("irc.pass", "");
+    sIRC._Nick = sConfig.GetStringDefault("irc.nick", "OCChat");
+    sIRC._Auth = sConfig.GetIntDefault("irc.auth", 0);
+    sIRC._Auth_Nick = sConfig.GetStringDefault("irc.auth.nick", "AuthNick");
+    sIRC._ICC = sConfig.GetStringDefault("irc.icc", "001");
+    sIRC._defchan = sConfig.GetStringDefault("irc.defchan", "Lobby");
+    sIRC._ldefc = sConfig.GetIntDefault("irc.ldef", 0);
+    sIRC._wct = sConfig.GetIntDefault("irc.wct", 30000);
+    //sIRC.ajoin = sConfig.GetIntDefault("irc.ajoin", 1);
+    //sIRC.ajchan = sConfig.GetStringDefault("irc.ajchan", "Lobby");
+    sIRC.onlrslt = sConfig.GetIntDefault("irc.online.result", 10);
+    sIRC.BOTMASK = sConfig.GetIntDefault("Botmask", 0);
+    sIRC.logfile = sConfig.GetStringDefault("irc.logfile.prefix", "IRC_");
+    sIRC.logmask = sConfig.GetIntDefault("irc.logmask", 0);
+    sIRC.logchan = sConfig.GetStringDefault("irc.logchannel","");
+    sIRC.logchanpw = sConfig.GetStringDefault("irc.logchannelpassword","");
+    for (int i = 1; i < MAX_CONF_CHANNELS;i++)
+    {
+        std::ostringstream ss;
+        ss << i;
+        std::string ci = "irc.chan_" + ss.str();
+        std::string pw = "irc.pass_" + ss.str();
+        std::string t_chan = sConfig.GetStringDefault(ci.c_str(), "");
+        if (t_chan.size() > 0)
+        {
+            sIRC._chan_count++;
+            sIRC._irc_chan[sIRC._chan_count] = t_chan;
+            sIRC._irc_pass[sIRC._chan_count] = sConfig.GetStringDefault(pw.c_str(), t_chan.c_str());
+            ci = "wow.chan_" + ss.str();
+            sIRC._wow_chan[sIRC._chan_count] = sConfig.GetStringDefault(ci.c_str(), t_chan.c_str());
+        }
+    }
+    sIRC.JoinMsg = sConfig.GetStringDefault("irc.joinmsg", "OCChat $Ver for OregonCore");
+    sIRC.RstMsg  = sConfig.GetStringDefault("irc.rstmsg", "OCChat Is Restarting, I Will Be Right Back!");
+    sIRC.kikmsg = sConfig.GetStringDefault("irc.kickmsg", "Do Not Kick Me Again, Severe Actions Will Be Taken!");
+    // IRC LINES
+    sIRC.ILINES[WOW_IRC] = sConfig.GetStringDefault("chat.wow_irc", "\003<WoW>[\002$Name($Level)\002\003] $Msg");
+    sIRC.ILINES[IRC_WOW] = sConfig.GetStringDefault("chat.irc_wow", "\003<IRC>[$Name]: $Msg");
+    sIRC.ILINES[JOIN_WOW] = sConfig.GetStringDefault("chat.join_wow", "\00312>>\00304 $Name \003Joined The Channel!");
+    sIRC.ILINES[JOIN_IRC] = sConfig.GetStringDefault("chat.join_irc", "\003[$Name]: Has Joined IRC!");
+    sIRC.ILINES[LEAVE_WOW] = sConfig.GetStringDefault("chat.leave_wow", "\00312<<\00304 $Name \003Left The Channel!");
+    sIRC.ILINES[LEAVE_IRC] = sConfig.GetStringDefault("chat.leave_irc", "\003[$Name]: Has Left IRC!");
+    sIRC.ILINES[CHANGE_NICK] = sConfig.GetStringDefault("chat.change_nick", "\003<> $Name Is Now Known As $NewName!");
+    // OCChat Options
+    sIRC._MCA = sConfig.GetIntDefault("irc.maxattempt", 10);
+    sIRC._autojoinkick = sConfig.GetIntDefault("irc.autojoin_kick", 1);
+    sIRC._cmd_prefx = sConfig.GetStringDefault("irc.command_prefix", ".");
+
+    sIRC._op_gm = sConfig.GetIntDefault("irc.op_gm_login", 0);
+    sIRC._op_gm_lev = sConfig.GetIntDefault("irc.op_gm_level", 3);
+
+    // Misc Options
+    sIRC.gmlog = sConfig.GetIntDefault("irc.gmlog", 1);
+    sIRC.BOTMASK = sConfig.GetIntDefault("BotMask", 0);
+    sIRC.Status = sConfig.GetIntDefault("irc.StatusChannel", 1);
+    sIRC.anchn = sConfig.GetIntDefault("irc.AnnounceChannel", 1);
+    sIRC.ojGM1 = sConfig.GetStringDefault("irc.gm1", "[VIP]");
+    sIRC.ojGM2 = sConfig.GetStringDefault("irc.gm2", "[Donator]");
+    sIRC.ojGM3 = sConfig.GetStringDefault("irc.gm3", "[Bug Tracker]");
+    sIRC.ojGM4 = sConfig.GetStringDefault("irc.gm4", "[Moderator]");
+    sIRC.ojGM5 = sConfig.GetStringDefault("irc.gm5", "[Game Master]");
+    sIRC.ojGM6 = sConfig.GetStringDefault("irc.gm6", "[Admin]");
+    sIRC.ojGM7 = sConfig.GetStringDefault("irc.gm7", "[Developer]");
+    sIRC.ojGM8 = sConfig.GetStringDefault("irc.gm8", "[Owner]");
+    // REQUIRED GM LEVEL
+    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `Command`, `gmlevel` FROM `irc_commands` ORDER BY `Command`");
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        for (uint64 i=0; i < result->GetRowCount(); i++)
+        {
+            //TODO: ELSEIF? STRCMP?
+            std::string command = fields[0].GetCppString();
+            uint32 gmlvl = fields[1].GetUInt32();
+            if (command == "acct") sIRC.CACCT = gmlvl;
+            if (command == "ban") sIRC.CBAN = gmlvl;
+            if (command == "char") sIRC.CCHAN = gmlvl;
+            if (command == "char") sIRC.CCHAR = gmlvl;
+            if (command == "fun") sIRC.CFUN = gmlvl;
+            if (command == "help") sIRC.CHELP = gmlvl;
+            if (command == "inchan") sIRC.CINCHAN = gmlvl;
+            if (command == "info") sIRC.CINFO = gmlvl;
+            if (command == "item") sIRC.CITEM = gmlvl;
+            if (command == "jail") sIRC.CJAIL = gmlvl;
+            if (command == "kick") sIRC.CKICK = gmlvl;
+            if (command == "kill") sIRC._KILL = gmlvl;
+            if (command == "level") sIRC.CLEVEL = gmlvl;
+            if (command == "lookup") sIRC.CLOOKUP = gmlvl;
+            if (command == "money") sIRC.CMONEY = gmlvl;
+            if (command == "mute") sIRC.CMUTE = gmlvl;
+            if (command == "online") sIRC.CONLINE = gmlvl;
+            if (command == "pm") sIRC.CPM = gmlvl;
+            if (command == "reconnect") sIRC.CRECONNECT = gmlvl;
+            if (command == "reload") sIRC.CRELOAD = gmlvl;
+            if (command == "restart") sIRC.CSHUTDOWN = gmlvl;
+            if (command == "revive") sIRC.CREVIVE = gmlvl;
+            if (command == "saveall") sIRC.CSAVEALL = gmlvl;
+            if (command == "server") sIRC.CSERVERCMD = gmlvl;
+            if (command == "shutdown") sIRC.CSHUTDOWN = gmlvl;
+            if (command == "spell") sIRC.CSPELL = gmlvl;
+            if (command == "sysmsg") sIRC.CSYSMSG = gmlvl;
+            if (command == "tele") sIRC.CTELE = gmlvl;
+            if (command == "top") sIRC.CTOP = gmlvl;
+            if (command == "who") sIRC.CWHO = gmlvl;
+            result->NextRow();
+        }
+        
+    }
+    else
+    {
+        sIRC.CACCT     = 3;
+        sIRC.CBAN      = 3;
+        sIRC.CCHAN     = 3;
+        sIRC.CCHAR     = 3;
+        sIRC.CFUN      = 3;
+        sIRC.CHELP     = 3;
+        sIRC.CINCHAN   = 3;
+        sIRC.CINFO     = 3;
+        sIRC.CITEM     = 3;
+        sIRC.CJAIL     = 3;
+        sIRC.CKICK     = 3;
+        sIRC._KILL     = 3;
+        sIRC.CLEVEL    = 3;
+        sIRC.CLOOKUP   = 3;
+        sIRC.CMONEY    = 3;
+        sIRC.CMUTE     = 3;
+        sIRC.CONLINE   = 3;
+        sIRC.CPM       = 3;
+        sIRC.CRECONNECT= 3;
+        sIRC.CRELOAD   = 3;
+        sIRC.CREVIVE   = 3;
+        sIRC.CSAVEALL  = 3;
+        sIRC.CSERVERCMD= 3;
+        sIRC.CSHUTDOWN = 3;
+        sIRC.CSPELL    = 3;
+        sIRC.CSYSMSG   = 3;
+        sIRC.CTELE     = 3;
+        sIRC.CTOP      = 3;
+        sIRC.CWHO      = 3;
+    }
+
 }
 
 // Initialize the World
@@ -1117,6 +1291,7 @@
 
     // Initialize config settings
     LoadConfigSettings();
+    sLog.outString("Loading OregonCore configuration settings...");
 
     // Init highest guids before any table loading to prevent using not initialized guids in some code.
     objmgr.SetHighestGuids();
@@ -1414,6 +1589,9 @@
     sLog.outString("Loading Autobroadcasts...");
     LoadAutobroadcasts();
 
+    sLog.outString("Loading Autobroadcasts...");
+    LoadAutobroadcasts();
+
     // Load and initialize scripts
     sLog.outString("Loading Scripts...");
     sLog.outString();
@@ -1617,7 +1795,7 @@
 {
     m_Autobroadcasts.clear();
 
-    QueryResult_AutoPtr result = WorldDatabase.Query("SELECT text FROM autobroadcast");
+    QueryResult_AutoPtr result = WorldDatabase.Query("SELECT message FROM autobroadcast WHERE enabled = 1");
 
     if (!result)
     {
@@ -2310,33 +2488,36 @@
         return;
 
     std::string msg;
+    std::string ircchan = "#";
 
     std::list<std::string>::const_iterator itr = m_Autobroadcasts.begin();
     std::advance(itr, rand() % m_Autobroadcasts.size());
     msg = *itr;
 
-    uint32 abcenter = sConfig.GetIntDefault("AutoBroadcast.Center", 0);
+    ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
 
+    uint32 abcenter = sWorld.getConfig(CONFIG_AUTOBROADCAST_CENTER);
     if (abcenter == 0)
+    {
         sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
-
-    else if (abcenter == 1)
+    }
+    if (abcenter == 1)
     {
         WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
         data << msg;
         sWorld.SendGlobalMessage(&data);
     }
-
-    else if (abcenter == 2)
+    if (abcenter == 2)
     {
         sWorld.SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
-
         WorldPacket data(SMSG_NOTIFICATION, (msg.size()+1));
         data << msg;
         sWorld.SendGlobalMessage(&data);
     }
-
-    sLog.outString("AutoBroadcast: '%s'", msg.c_str());
+    if ( sIRC.Active )
+    { 
+        sIRC.Send_IRC_Channel(ircchan, sIRC.MakeMsg("\00304,08\037/!\\\037\017\00304 Automatic System Message \00304,08\037/!\\\037\017 %s", "%s", msg.c_str()), true);
+    }
 }
 
 void World::InitResultQueue()
diff -Nuar oregoncore-current/src/game/World.h oregoncore-pq/src/game/World.h
--- oregoncore-current/src/game/World.h	2012-05-20 11:29:49.000000000 -0400
+++ oregoncore-pq/src/game/World.h	2012-05-20 11:43:23.000000000 -0400
@@ -195,6 +195,7 @@
     CONFIG_CHANCE_OF_GM_SURVEY,
     CONFIG_INSTANT_LOGOUT,
     CONFIG_DISABLE_BREATHING,
+    CONFIG_DISABLE_FATIGUE,
     CONFIG_ALL_TAXI_PATHS,
     CONFIG_DECLINED_NAMES_USED,
     CONFIG_LISTEN_RANGE_SAY,
@@ -216,6 +217,7 @@
     CONFIG_BG_START_MUSIC,
     CONFIG_START_ALL_SPELLS,
     CONFIG_HONOR_AFTER_DUEL,
+    CONFIG_GOLD_AFTER_DUEL,
     CONFIG_START_ALL_EXPLORED,
     CONFIG_START_ALL_REP,
     CONFIG_ALWAYS_MAXSKILL,
@@ -318,9 +320,30 @@
     RATE_DURABILITY_LOSS_PARRY,
     RATE_DURABILITY_LOSS_ABSORB,
     RATE_DURABILITY_LOSS_BLOCK,
+    RATE_PVP_RANK_EXTRA_HONOR,
     MAX_RATES
 };
 
+enum HonorKillPvPRank
+{
+    HKRANK00,
+    HKRANK01,
+    HKRANK02,
+    HKRANK03,
+    HKRANK04,
+    HKRANK05,
+    HKRANK06,
+    HKRANK07,
+    HKRANK08,
+    HKRANK09,
+    HKRANK10,
+    HKRANK11,
+    HKRANK12,
+    HKRANK13,
+    HKRANK14,
+    HKRANKMAX
+};
+
 // Type of server
 enum RealmType
 {
@@ -517,6 +540,8 @@
         void SendZoneText(uint32 zone, const char *text, WorldSession *self = 0, uint32 team = 0);
         void SendServerMessage(ServerMessageType type, const char *text = "", Player* player = NULL);
 
+        uint32 pvp_ranks[HKRANKMAX];
+
         // Are we in the middle of a shutdown?
         bool IsShutdowning() const { return m_ShutdownTimer > 0; }
         void ShutdownServ(uint32 time, uint32 options, uint8 exitcode);
diff -Nuar oregoncore-current/src/irc/CMakeLists.txt oregoncore-pq/src/irc/CMakeLists.txt
--- oregoncore-current/src/irc/CMakeLists.txt	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/CMakeLists.txt	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,32 @@
+file(GLOB sources_localdir *.cpp *.h)
+
+SET(irc_STAT_SRCS
+  ${irc_STAT_SRCS}
+  ${sources_localdir}
+)
+
+include_directories(
+  ${CMAKE_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/include
+  ${CMAKE_SOURCE_DIR}/src/framework
+  ${CMAKE_SOURCE_DIR}/src/shared
+  ${CMAKE_SOURCE_DIR}/src/shared/vmap
+  ${CMAKE_SOURCE_DIR}/src/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/game
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${ACE_INCLUDE_DIR}
+  ${MYSQL_INCLUDE_DIR}
+)
+
+add_library(irc STATIC ${irc_STAT_SRCS})
+
+if(WIN32)
+  target_link_libraries(irc
+    ace
+  )
+else()
+  target_link_libraries(irc
+    ${ACE_LIBRARY}
+  )
+endif()
+
diff -Nuar oregoncore-current/src/irc/IRCClient.cpp oregoncore-pq/src/irc/IRCClient.cpp
--- oregoncore-current/src/irc/IRCClient.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/IRCClient.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "MapManager.h"
+
+#include "Policies/SingletonImp.h"
+INSTANTIATE_SINGLETON_1(IRCClient);
+
+#ifdef WIN32
+    #define Delay(x) Sleep(x)
+#else
+    #define Delay(x) sleep(x / 1000)
+#endif
+// IRCClient Constructor
+IRCClient::IRCClient()
+{
+    for (int i = 0;i > 5;i++)
+        sIRC.Script_Lock[i] = false;
+}
+// IRCClient Destructor
+IRCClient::~IRCClient(){}
+
+// ZThread Entry This function is called when the thread is created in Master.cpp (oregoncore)
+void IRCClient::run()
+{
+    sIRC.iLog.WriteLog(" %s : OregonCore with OCChat Has Been Started", sIRC.iLog.GetLogDateTimeStr().c_str());
+
+    // before we begin we wait a few 
+    // oregoncore is still starting up.
+    ACE_Based::Thread::Sleep(500);
+    sLog.outString("\n%s\n","OCChat: OCChat Threaded IRC Client");
+    sLog.outString("OCChat: %s", sIRC._Mver.c_str());
+    int cCount = 1;
+    // Clean Up MySQL Tables
+    sLog.outString("OCChat: Cleaning Up Inchan Table.");
+    WorldDatabase.PExecute("DELETE FROM `irc_inchan`");
+    sIRC._Max_Script_Inst = 0;
+    // Create a loop to keep the thread running untill active is set to false
+    while (sIRC.Active && !World::IsStopped())
+    {
+        // Initialize socket library
+        if (this->InitSock())
+        {
+            // Connect To The IRC Server
+            sLog.outString("OCChat: Connecting to %s Attempt # %d", sIRC._Host.c_str(), cCount);
+            if (this->Connect(sIRC._Host.c_str(), sIRC._Port))
+            {
+                // On connection success reset the connection counter
+                cCount = 0;
+                sLog.outString("OCChat: Connected And Logging In");
+                // Login to the IRC server
+                if (this->Login(sIRC._Nick, sIRC._User, sIRC._Pass))
+                {
+                    sLog.outString("OCChat: Logged In And Running.");
+                    // While we are connected to the irc server keep listening for data on the socket
+                    while (sIRC.Connected && !World::IsStopped()){ sIRC.SockRecv(); }
+                }
+                sLog.outString("OCChat: Connection To IRC Server Lost!");
+            }
+            // When an error occures or connection lost cleanup
+            Disconnect();
+            // Increase the connection counter
+            cCount++;
+            // if MAX_CONNECT_ATTEMPT is reached stop trying
+            if (sIRC._MCA != 0 && cCount == sIRC._MCA)
+                sIRC.Active = false;
+            // If we need to reattempt a connection wait WAIT_CONNECT_TIME milli seconds before we try again
+            if (sIRC.Active)
+                ACE_Based::Thread::Sleep(sIRC._wct);
+        }
+        else
+        {
+            // Socket could not initialize cancel
+            sIRC.Active = false;
+            sLog.outError("OCChat: Could not initialize socket.");
+        }
+    }
+    while (!World::IsStopped()){};
+}
+
+std::string IRCClient::GetChatLine(int nItem)
+{
+    return sIRC.ILINES[nItem];
+}
diff -Nuar oregoncore-current/src/irc/IRCClient.h oregoncore-pq/src/irc/IRCClient.h
--- oregoncore-current/src/irc/IRCClient.h	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/IRCClient.h	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_H
+#define _IRC_CLIENT_H
+
+#include "Policies/Singleton.h"
+#include "Player.h"
+#include "IRCLog.h"
+#include "IRCCmd.h"
+
+using namespace std;
+// The maximum ammount of channels used, must be >= config option
+#define MAX_CONF_CHANNELS 10
+#define MAX_CHAT_LINES 10
+// time we need to wait before we try another connecton attempt
+// Default is 30 seconds
+#define MAX_SCRIPT_INST 10
+// CLINES is used for the default chatlines
+// By using the GetChatLine function its easier and faster
+// to receieve the line you need.
+enum CLINES
+{
+    IRC_WOW = 0,
+    WOW_IRC = 1,
+    JOIN_WOW = 2,
+    JOIN_IRC = 3,
+    LEAVE_WOW = 4,
+    LEAVE_IRC = 5,
+    CHANGE_NICK = 6
+};
+// CACTION is used by the Handle_WoW_Channel function
+// this function is called in channel.h when a player
+// joins or leave a channel inside the client.
+enum CACTION
+{
+    CHANNEL_JOIN,
+    CHANNEL_LEAVE,
+};
+
+enum script_Names
+{
+    MCS_Players_Online  = 0,
+};
+
+// IRCClient main class
+class IRCClient : public ACE_Based::Runnable
+{
+    public:
+        // IRCClient Constructor
+        IRCClient();
+        // IRCClient Destructor
+        ~IRCClient();
+        // Thread Entry
+        void run();
+    public:
+        // AH Function
+        void AHFunc(uint64 itmid, std::string itmnme, std::string plname, uint32 faction);
+        // IRCClient active
+        bool    Active;
+        // Connected to IRC
+        bool    Connected;
+        // Socket indentifier
+        int     SOCKET;
+        fd_set  sfdset;
+        // Send data to IRC, in addition the endline is added \n
+        bool    SendIRC(std::string data);
+        // This function is called in ChatHandler.cpp and processes the chat from game to IRC
+        void    Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg);
+        // Sends a message to all players on the specified channel
+        void    Send_WoW_Channel(const char *channel, std::string chat);
+        // Send a system message to all players
+        void    Send_WoW_System(std::string Message);
+        // Send a message to the specified IRC channel
+        void    Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix = false, std::string nType = "PRIVMSG");
+        // Sends a message to all IRC Channels
+        void    Send_IRC_Channels(std::string sMsg);
+        std::string MakeMsg(std::string msg, std::string var, std::string val)
+        {
+            std::size_t start = msg.find(var);
+            if (start != std::string::npos)
+                msg.replace(start, var.length(), val);
+            return msg;
+        }
+        void    Send_WoW_Player(string sPlayer, string sMsg);
+        void    Send_WoW_Player(Player *plr, string sMsg);
+
+        // This function is called in Channel.cpp and processes Join/leave messages
+        void    Handle_WoW_Channel(std::string Channel, Player *plr, int nAction);
+        void    ResetIRC();
+    public:
+        void AutoJoinChannel(Player *plr);
+
+    public:
+        bool Script_Lock[5];
+        bool _AmiOp;
+
+    public:
+        string _Mver;
+        // IRC Server host
+        string  _Host;
+        // IRC Server Port
+        int _Port;
+        // IRC Username
+        string  _User;
+        // IRC Password
+        string  _Pass;
+        // IRC Nickname
+        string  _Nick;
+        //Password for in-game channel
+        std::string _irc_pass[MAX_CONF_CHANNELS];
+        // Authentication type
+        int _Auth;
+        string _Auth_Nick;
+        // IRC Connect code
+        string  _ICC;
+        // IRC Default channel
+        string  _defchan;
+        // IRC Leave Default channel
+        int _ldefc;
+        // Wait Connect Time
+        int _wct;
+        // BotMask Options
+        int Botmask;
+        // Status Channel
+        int Status;
+        // Announce Channel
+        int anchn;
+        int autoanc;
+        // IRC Channel count
+        int _chan_count;
+        // IRC Channel list
+        // Array to store our IRC channels
+        // each element will corrospond
+        // with _wow_chan array below.
+        std::string _irc_chan[MAX_CONF_CHANNELS];
+        // Game Channel list
+        std::string _wow_chan[MAX_CONF_CHANNELS];
+        // AutoJoin Options
+        int ajoin;
+        string ajchan;
+        // Online Command Max Results
+        int onlrslt;
+        // Channel OnJoin/Restart/Kick Messages
+        string  JoinMsg;
+        string  RstMsg;
+        string  kikmsg;
+        // Misc Options
+        string  ojGM1;
+        string  ojGM2;
+        string  ojGM3;
+        string  ojGM4;
+        string  ojGM5;
+        string  ojGM6;
+	 string  ojGM7;
+	 string  ojGM8;
+        string  logfile;
+        string  logchan;
+        string  logchanpw;
+        int     logmask;
+        int     games;
+        int     gmlog;
+        // IRC Commands Security Level
+        int     CACCT;
+        int     CBAN;
+        int     CCHAN;
+        int     CCHAR;
+        int     CFUN;
+        int     CHELP;
+        int     CINCHAN;
+        int     CINFO;
+        int     CITEM;
+        int     CJAIL;
+        int     CKICK;
+        int     _KILL;
+        int     CLEVEL;
+        int     CLOOKUP;
+        int     CMONEY;
+        int     CMUTE;
+        int     CONLINE;
+        int     CPM;
+        int     CRECONNECT;
+        int     CRELOAD;
+        int     CREVIVE;
+        int     CSAVEALL;
+        int     CSERVERCMD;
+        int     CSHUTDOWN;
+        int     CSPELL;
+        int     CSYSMSG;
+        int     CTELE;
+        int     CTOP;
+        int     CWHO;
+        // BotMask
+        int     BOTMASK;
+        // Max connect attempt
+        int     _MCA;
+        // Auto rejoin when kicked from irc
+        int     _autojoinkick;
+        // IRC Command prefix
+        string  _cmd_prefx;
+        int _op_gm;
+        int _op_gm_lev;
+        // Array that contains our chatlines from the conf file
+        // To increase this value change the MAX_CHAT_LINE define above
+        // Make sure the number of elements must match your items
+        // (remeber this starts at 0 so 0..9 is 10 items)
+        // and that you load the line in the LoadConfig function.
+        string  ILINES[MAX_CHAT_LINES];
+        string  GetChatLine(int nItem);
+
+        int _Max_Script_Inst;
+        // MAX_SCRIPT_INST
+
+        IRCLog iLog;
+
+private:
+        // Returns default chatline based on enum CLINES
+        // Initialize socket library
+        bool    InitSock();
+        // Connect to IRC Server
+        bool    Connect(const char *cHost, int nPort);
+        // Login to IRC Server
+        bool    Login(std::string sNick, std::string sUser, std::string sPass);
+        // Send raw data to IRC
+        bool    SendData(const char *data);
+        // Disconnect from IRC and cleanup socket
+        void    Disconnect();
+        // Processes the data receieved from IRC
+        void    Handle_IRC(std::string sData);
+        // Receieves data from the socket.
+        void    SockRecv();
+};
+#endif
+#define sIRC Oregon::Singleton<IRCClient>::Instance()
diff -Nuar oregoncore-current/src/irc/IRCCmd.cpp oregoncore-pq/src/irc/IRCCmd.cpp
--- oregoncore-current/src/irc/IRCCmd.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/IRCCmd.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,883 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCCmd.h"
+#include "IRCClient.h"
+#include "Database/DatabaseEnv.h"
+#include "ObjectMgr.h"
+#include "AccountMgr.h"
+#include "MapManager.h"
+#include "World.h"
+// Constructor
+IRCCmd::IRCCmd(){}
+// Destructor
+IRCCmd::~IRCCmd(){}
+
+std::string IRCCmd::MakeUpper(std::string Channel)
+{
+    std::string tmpchan = Channel;
+    std::transform(tmpchan.begin(), tmpchan.end(), tmpchan.begin(), towupper);
+    return tmpchan;
+}
+bool IRCCmd::ParamsValid(_CDATA *CD, int pCnt)
+{
+    CD->PCOUNT = pCnt;
+    if (CD->PARAMS.size() == 0)
+        return false;
+    return ValidParams(CD->PARAMS, pCnt);
+}
+
+int IRCCmd::ParamsValid(_CDATA *CD, int pCnt, int rLev)
+{
+    //CD->PCOUNT = pCnt;
+    if (!CanUse(CD->USER, rLev))
+        return E_AUTH;
+    else if (pCnt == 0)
+        return E_OK;
+    else if (CD->PARAMS.size() == 0)
+        return E_SIZE;
+    else if (!ValidParams(CD->PARAMS, pCnt))
+        return E_SIZE;
+    return E_OK;
+}
+
+// This function checks if chat from irc is a command or not
+// return true on yes and false on no
+bool IRCCmd::IsValid(std::string USER, std::string FROM, std::string CHAT, std::string TYPE)
+{
+    // If the first line of our chat is the command prefix we have a command
+    if (CHAT.substr(0, 1) == sIRC._cmd_prefx && CHAT.size() > 1)
+    {
+        _CDATA CDATA;
+        bool cValid    = false;
+        bool AuthValid = true;
+        bool dontlog   = true;
+        std::string* _PARAMS = getArray(CHAT, 2);
+        CDATA.USER      = USER;
+        CDATA.FROM      = FROM;
+        CDATA.TYPE      = TYPE;
+        CDATA.PCOUNT    = 0;
+        CDATA.CMD       = MakeUpper(_PARAMS[0].substr(1, _PARAMS[0].size() - 1));
+        CDATA.PARAMS    = _PARAMS[1];
+        if (CDATA.CMD == "LOGIN")
+        {
+            if (FROM == sIRC._Nick)
+            {             
+                if (ParamsValid(&CDATA, 2))  
+                    Handle_Login(&CDATA);
+                else
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"login <Player> <Password>)", true, "ERROR");
+            }
+            else
+                sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Please Send A PM To Login!", true, "ERROR");
+            if (GetLevel(USER) >= sIRC.gmlog)
+                dontlog = false;
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LOGOUT")
+        {
+            if (FROM == sIRC._Nick)
+            {
+                Handle_Logout(&CDATA);
+            }
+            else
+                sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Please Send A PM To Logout!", true, "ERROR");
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ACCT")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CACCT))
+            {
+                case E_OK:
+                    Account_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"acct <Player> <(un)lock/email/pass/rename/gmlevel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "BAN")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CBAN))
+            {
+                case E_OK:
+                    Ban_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"ban <Player> <acct/ip>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "CHAN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC.CCHAN))
+            {
+                case E_OK:
+                    Chan_Control(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"chan <op> <IRC User>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "CHAR")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CCHAR))
+            {
+                case E_OK:
+                    Char_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"char <Player> <mailcheat/taxicheat/maxskill/setskill/quest/mod>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "FUN")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CFUN))
+            {
+                case E_OK:
+                    Fun_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"fun <Player> <Sound/Say>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "HELP")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CHELP))
+            {
+                case E_OK:
+                    Help_IRC(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"help <Command>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "INCHAN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC.CINCHAN))
+            {
+                case E_OK:
+                    Inchan_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"inchan <Channel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "INFO")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CINFO))
+            {
+                case E_OK:
+                    Info_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"info)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ITEM")
+        {
+            CDATA.PCOUNT = 3;
+            switch(ParamsValid(&CDATA, 2, sIRC.CITEM))
+            {
+                case E_OK:
+                    Item_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> <ItemID/[ItemName]> <Amount>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "JAIL")
+        {
+            CDATA.PCOUNT = 3;
+            switch(ParamsValid(&CDATA, 1, sIRC.CJAIL))
+            {
+                case E_OK:
+                    Jail_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"jail <Player> <release/Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "KICK")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC.CKICK))
+            {
+                case E_OK:
+                    Kick_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"kick <Player> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "KILL")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC._KILL))
+            {
+                case E_OK:
+                    Kill_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"kill <Player> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LEVEL")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CLEVEL))
+            {
+                case E_OK:
+                    Level_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"level <Player> <NewLevel>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "LOOKUP")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CLOOKUP))
+            {
+                case E_OK:
+                    Lookup_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"lookup <acct/char/creature/faction/go/item/quest/skill/spell/tele> <ID/Name>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "MONEY")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CMONEY))
+            {
+                case E_OK:
+                    Money_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"money <Player> <(-)Money>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "MUTE")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CMUTE))
+            {
+                case E_OK:
+                    Mute_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"mute <Player> <release/TimeInMins> <Reason>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "ONLINE")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CONLINE))
+            {
+                case E_OK:
+                    Online_Players(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"online)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "PM")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CPM))
+            {
+                case E_OK:
+                    PM_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"pm <Player> <Message>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RELOAD")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CRELOAD))
+            {
+                case E_OK:
+                    sIRC.Send_IRC_Channels("Reloading Configiguration Options.");
+                    sWorld.LoadConfigSettings(true);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RECONNECT")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CRECONNECT))
+            {
+                case E_OK:
+                    sIRC.Send_IRC_Channels(sIRC.RstMsg);
+                    sIRC.ResetIRC();
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "RESTART")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CSHUTDOWN))
+            {
+                case E_OK:
+                    Restart_Oregon(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"server <setmotd/flusharenapoints>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "REVIVE")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 1, sIRC.CREVIVE))
+            {
+                case E_OK:
+                    Revive_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"revive <Player>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SAVEALL")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CSAVEALL))
+            {
+                case E_OK:
+                    Saveall_Player(&CDATA);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SERVER")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CSERVERCMD))
+            {
+                case E_OK:
+                    Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"server <setmotd/flusharenapoints>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SHUTDOWN")
+        {
+            switch(ParamsValid(&CDATA, 1, sIRC.CSHUTDOWN))
+            {
+                case E_OK:
+                    Shutdown_Oregon(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"shutdown <TimeInSeconds>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SPELL")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CSPELL))
+            {
+                case E_OK:
+                    Spell_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"spell <Player> <Cast/Learn/UnLearn> <SpellID>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "SYSMSG")
+        {
+            CDATA.PCOUNT = 2;
+            switch(ParamsValid(&CDATA, 2, sIRC.CSYSMSG))
+            {
+                case E_OK:
+                    Sysmsg_Server(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"sysmsg <a/e/n/add/del/list> <Message>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "TELE")
+        {
+            switch(ParamsValid(&CDATA, 2, sIRC.CTELE))
+            {
+                case E_OK:
+                    Tele_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"tele <Player> <l/c/r/to/cr/go/homebind> <Loc.Name/MAPID X Y Z/Recall/Player/Creature GUID/GO GUID/Homebind>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "TOP")
+        {
+            CDATA.PCOUNT = 1;
+            switch(ParamsValid(&CDATA, 1, sIRC.CTOP))
+            {
+                case E_OK:
+                    Top_Player(&CDATA);
+                    break;
+                case E_SIZE:
+                    sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"top <accttime/chartime/money> <limit>)", true, "ERROR");
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        else if (CDATA.CMD == "WHO")
+        {
+            switch(ParamsValid(&CDATA, 0, sIRC.CWHO))
+            {
+                case E_OK:
+                    Who_Logged(&CDATA);
+                    break;
+                case E_AUTH:
+                    AuthValid = false;
+                    break;
+            }
+            cValid = true;
+        }
+        if (!AuthValid && IsLoggedIn(USER))
+            sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Access Denied! Your Security Level Is Too Low To Use This Command!", true, "ERROR");
+        if (cValid == false && (sIRC.BOTMASK & 4) != 0)
+            sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : Unknown Command!", true, "ERROR");
+        if (cValid && dontlog)
+        {
+            sIRC.iLog.WriteLog(" %s : [ %s(%d) ] Used Command: [ %s ] With Parameters: [ %s ]", sIRC.iLog.GetLogDateTimeStr().c_str(), CDATA.USER.c_str(), GetLevel(USER), CDATA.CMD.c_str(), CDATA.PARAMS.c_str());
+            if ((sIRC.logmask & 1) != 0)
+            {
+                std::string logchan = "#";
+                logchan += sIRC.logchan;
+                std::stringstream ss;
+                ss << sIRC.iLog.GetLogDateTimeStr() << ": [ " << CDATA.USER << "(" << GetLevel(USER) << ") ] Used Command: [ " << CDATA.CMD << " ] With Parameters: [" << CDATA.PARAMS << " ]";
+                sIRC.Send_IRC_Channel(logchan, ss.str().c_str(), true);
+            }
+        }
+        return cValid;
+    }
+    return false;
+}
+
+bool IRCCmd::CanUse(std::string USER, int nLevel)
+{
+    if (IsLoggedIn(USER))
+    {
+        if (GetLevel(USER) >= nLevel)
+            return true;
+        else
+            return false;
+    }
+    else if (nLevel == 0)
+    {
+        return true;
+    }
+    else
+        sIRC.Send_IRC_Channel(USER, "\0034[ERROR] : You Are Not Logged In!", true, "ERROR");
+    return false;
+}
+
+std::string IRCCmd::ChanOrPM(_CDATA *CD)
+{
+    if (CD->FROM == sIRC._Nick)
+        return CD->USER;
+    else
+        return CD->FROM;
+}
+
+Player *IRCCmd::GetPlayer(std::string WHO)
+{
+    normalizePlayerName(WHO);
+    return ObjectAccessor::Instance().FindPlayerByName(WHO.c_str());
+}
+
+_client *IRCCmd::GetClient(std::string cname)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == cname)
+            return (*i);
+    }
+    return (NULL);
+}
+
+bool IRCCmd::IsLoggedIn(std::string USER)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == USER)
+            return true;
+    }
+    return false;
+}
+
+bool IRCCmd::AcctIsLoggedIn(std::string USER)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if (MakeUpper((*i)->UName) == MakeUpper(USER))
+            return true;
+    }
+    return false;
+}
+
+std::string IRCCmd::AcctIsBanned(std::string ACCT)
+{
+    uint32 acctid = sAccountMgr->GetId(ACCT);
+    std::string banned = "NOTBANNED";
+    QueryResult_AutoPtr result = LoginDatabase.PQuery("SELECT banreason FROM ip_banned WHERE ip=(SELECT last_ip FROM account WHERE id = '%i')", acctid);
+    if (result)
+    {
+        banned = (*result)[0].GetCppString();
+        
+        return "IP Banned. Reason:" + banned;
+    }
+    QueryResult_AutoPtr result2 = LoginDatabase.PQuery("SELECT banreason FROM account_banned WHERE id='%i'", acctid);
+    if (result2)
+    {
+        banned = (*result2)[0].GetCppString();
+        
+        return "Account Banned. Reason:" + banned;
+    }
+    return banned;
+}
+
+int IRCCmd::GetLevel(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+            return (*i)->GMLevel;
+    }
+    return 0;
+}
+
+int IRCCmd::AcctLevel(std::string plnme)
+{
+    uint64 guid = objmgr.GetPlayerGUIDByName(plnme);
+    uint32 account_id = 0;
+    uint32 security = 0;
+    account_id = objmgr.GetPlayerAccountIdByGUID(guid);
+    security = sAccountMgr->GetSecurity(account_id);
+    return security;
+}
+
+std::string IRCCmd::GetAccName(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+            return (*i)->UName;
+    }
+    return "";
+}
+
+std::string IRCCmd::GetNameFromAcct(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->UName == sName)
+            return (*i)->Name;
+    }
+    return "";
+}
+
+int IRCCmd::GetAcctIDFromName(std::string sName)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == sName)
+        {
+            uint32 acct_id = 0;
+            acct_id = sAccountMgr->GetId((*i)->UName.c_str());
+            return acct_id;
+        }
+    }
+    return 0;
+}
+
+std::string IRCCmd::GetAcctNameFromID(uint32 acctid)
+{
+    QueryResult_AutoPtr result = LoginDatabase.PQuery("SELECT username FROM account WHERE id = '%d'", acctid);
+    if (result)
+    {
+        std::string name = (*result)[0].GetCppString();
+        
+        return name;
+    }
+
+    return "";
+}
+
+std::string IRCCmd::GetIPFromPlayer(std::string player)
+{
+    QueryResult_AutoPtr result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE name = '%s'", player.c_str());
+    if (result)
+    {
+        std::string acctid = (*result)[0].GetCppString();
+        
+        QueryResult_AutoPtr result2 = LoginDatabase.PQuery("SELECT last_ip FROM account WHERE id = '%s'", acctid.c_str());
+        if (result2)
+        {
+            std::string ip = (*result2)[0].GetCppString();
+            
+            return ip;
+        }       
+    }
+
+    return "";
+}
+
+std::string IRCCmd::SecToDay(std::string secons)
+{
+    unsigned int seconds = atoi(secons.c_str());
+    unsigned int days = seconds / 86400;
+    unsigned int hours = seconds / 3600 % 24;
+    unsigned int mins = seconds / 60 % 60;
+    char tottime[1000];
+    sprintf(tottime, "%iDays:%iHours:%iMinutes", days, hours, mins);
+
+    return tottime;
+}
+
+bool IRCCmd::ValidParams(std::string PARAMS, int nCount)
+{
+    if (nCount == 1 && PARAMS.size() == 0)
+        return false;
+    int pcount = 0;
+    size_t p = -1;
+    for (int i = 0;i < nCount;i++)
+    {
+        p = PARAMS.find(" ", p + 1);
+        if (p == -1)
+            break;
+        else
+            pcount++;
+    }
+    nCount--;
+    if (pcount >= nCount)
+        return true;
+    else
+        return false;
+}
+
+std::string* IRCCmd::getArray(std::string PARAMS, int nCount)
+{
+    std::string *array = new std::string[nCount];
+    if (PARAMS.size() > 0)
+    {
+        int pcnt = 0;
+        size_t ps = 0;
+        size_t pc = -1;
+        for (int i = 0;i < nCount;i++)
+        {
+            pc = PARAMS.find(" ", pc + 1);
+            if (i + 1 == nCount && nCount != 1)
+            {
+                if (ps > 0 && pc > 0)
+                    array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+            }
+            else
+                array[i] = PARAMS.substr(ps, pc - ps);
+            ps = pc + 1;
+        }
+    }
+    return array;
+}
+
+std::string IRCCmd::MakeMsg(const char *sLine, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, sLine);
+    vsnprintf(tmpoutp, 1024, sLine, ap);
+    va_end(ap);
+    std::string outp = tmpoutp;
+    return outp;
+}
+
+void IRCClient::AHFunc(uint64 itmid, std::string itmnme, std::string plname, uint32 faction)
+{
+    IRCCmd Command;
+    Player* plr = Command.GetPlayer(plname);
+    if (plr)
+    {
+        std::string itemname = itmnme;
+
+        char  temp [7];
+        sprintf(temp, "%u", itmid);
+        std::string itemid = temp;
+
+        std::string wowname = "";
+        std::string ircname = "";
+        switch (plr->GetTeam())
+        {
+            case 67:wowname="|cffff0000"+plname+"|r";ircname="\0034"+plname;break;      //horde
+            case 469:wowname="|cff1589FF"+plname+"|r";ircname="\00312"+plname;break;    //alliance
+        }
+        
+        std::string wowfact = "|cffFF8040[Auction House]:|r";
+        std::string ircfact = "\00304,08\037/!\\\037\017\00307 Auction House \00304,08\037/!\\\037\017";
+        switch(faction)
+        {
+            //neutral
+            case 7:wowfact="|cffff8040[Neutral Auction House]:|r";ircfact="\00304,08\037/!\\\037\017\00307 Neutral Auction House \00304,08\037/!\\\037\017";break;
+            //horde
+            case 6:wowfact="|cffff0000[Horde Auction House]:|r";ircfact="\00304,08\037/!\\\037\017\00304 Horde Auction House \00304,08\037/!\\\037\017";break;
+            //alliance
+            case 2:wowfact="|cff1589FF[Alliance Auction House]:|r";ircfact="\00304,08\037/!\\\037\017\00312 Alliance Auction House \00304,08\037/!\\\037\017";break;
+        }
+        std::string wowstr = Command.MakeMsg("%s A New Item Has Been Added |cffffffff|Hitem:%s:0:0:0:0:0:0:0|h[%s]|h|r. By: %s",wowfact.c_str(), itemid.c_str(), itemname.c_str(), wowname.c_str());
+        std::string ircstr = Command.MakeMsg("%s A New Item Has Been Added [%s]. By: %s", ircfact.c_str(), itemname.c_str(), ircname.c_str());
+
+        sIRC.Send_WoW_Channel(sIRC._wow_chan[sIRC.Status].c_str(), wowstr.c_str());
+        sIRC.Send_IRC_Channel(sIRC._irc_chan[sIRC.Status].c_str(), ircstr.c_str());
+    }
+}
+
diff -Nuar oregoncore-current/src/irc/IRCCmde.cpp oregoncore-pq/src/irc/IRCCmde.cpp
--- oregoncore-current/src/irc/IRCCmde.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/IRCCmde.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,2238 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCCmd.h"
+#include "IRCClient.h"
+#include "MCS_OnlinePlayers.h"
+#include "WorldPacket.h"
+#include "Database/DatabaseEnv.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "World.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "AccountMgr.h"
+#include "Language.h"
+#include "SpellAuras.h"
+#include "SystemConfig.h"
+#include "Config/Config.h"
+
+#define Send_Player(p, m)           sIRC.Send_WoW_Player(p, m)
+#define Send_IRCA(c, m, b, t)       sIRC.Send_IRC_Channel(c, m, b, t)
+
+#ifdef WIN32
+#define Delay(x) Sleep(x)
+#else
+#define Delay(x) sleep(x / 1000)
+#endif
+
+void IRCCmd::Handle_Login(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    std::string isbanned = AcctIsBanned(_PARAMS[0]);
+    if (isbanned == "NOTBANNED")
+    {
+        if (!IsLoggedIn(CD->USER))
+        {
+            if (!AcctIsLoggedIn(_PARAMS[0].c_str()))
+            {
+                QueryResult_AutoPtr result = LoginDatabase.PQuery("SELECT `gmlevel` FROM `account` WHERE `username`='%s' AND `sha_pass_hash`=SHA1(CONCAT(UPPER(`username`),':',UPPER('%s')));", _PARAMS[0].c_str(), _PARAMS[1].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    int GMLevel = fields[0].GetInt16();
+                    if (GMLevel >= 0)
+                    {
+                        _client *NewClient = new _client();
+                         NewClient->Name     = CD->USER;
+                        NewClient->UName    = MakeUpper(_PARAMS[0]);
+                        NewClient->GMLevel  = fields[0].GetInt16();
+                        _CLIENTS.push_back(NewClient);
+                        Send_IRCA(CD->USER, MakeMsg("You Are Now Logged In As %s, Welcome To OCChat Admin Mode.", _PARAMS[0].c_str()), true, CD->TYPE);
+
+                        if (sIRC._op_gm == 1 && GMLevel >= sIRC._op_gm_lev)
+                        {
+                            for (int i=1;i < sIRC._chan_count + 1;i++)
+                            sIRC.SendIRC("MODE #"+sIRC._irc_chan[i]+" +o "+CD->USER);
+                        }
+                    }
+                }else
+                    Send_IRCA(CD->USER, "\0034[ERROR] : Sorry, Your Username Or Password Is Incorrect. Please Try Again. ", true, "ERROR");
+            }else
+                Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : %s Is Already Logged In With This Username. ", GetNameFromAcct(MakeUpper(_PARAMS[0])).c_str()), true, "ERROR");
+        }else
+            Send_IRCA(CD->USER, "\0034[ERROR] : You Are Already Logged In As "+ _PARAMS[0] +"!", true, "ERROR");
+    }else
+         Send_IRCA(CD->USER, "\0034[ERROR] : Sorry You Are "+isbanned+". You Cannot Log In To OCChat "+CD->USER.c_str()+"!", true, "ERROR");
+}
+
+void IRCCmd::Handle_Logout(_CDATA *CD)
+{
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        if ((*i)->Name == CD->USER)
+        {
+            _CLIENTS.erase(i);
+            delete (*i);
+            Send_IRCA(CD->USER, "You Are Now Logged Out!", true, CD->TYPE);
+            return;
+        }
+    }
+    Send_IRCA(CD->USER, "\0034[ERROR] : You Are Not Logged In!", true, "ERROR");
+}
+
+void IRCCmd::Account_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    uint64 guid = objmgr.GetPlayerGUIDByName(_PARAMS[0]);
+    uint32 account_id = 0;
+    account_id = objmgr.GetPlayerAccountIdByGUID(guid);
+    if (account_id)
+    {
+        if (account_id == GetAcctIDFromName(CD->USER) || GetLevel(CD->USER) >= sIRC._op_gm_lev)
+        {
+            Player* plr = objmgr.GetPlayer(guid);
+            if (_PARAMS[1] == "lock")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `locked` = '1' WHERE `id` = '%d'",account_id);
+                if (plr) Send_Player(plr, MakeMsg("Your Account Has Been Locked To Your Current IP By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Account Has Been Locked To Their Current IP Address.", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "unlock")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `locked` = '0' WHERE `id` = '%d'",account_id);
+                if (plr) Send_Player(plr, MakeMsg("Your Account Has Been UnLocked From The Associated IP By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Account Has Been UnLocked From The Associated IP Address.", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "email")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `email` = '%s' WHERE `id` = '%d'",_PARAMS[2].c_str() ,account_id);
+                if (plr) Send_Player(plr, MakeMsg("%s Has Changed Your EMail Adress To: %s", CD->USER.c_str(), _PARAMS[2].c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : EMail Address Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "pass")
+            {
+                LoginDatabase.PExecute("UPDATE `account` SET `sha_pass_hash` = SHA1(CONCAT(UPPER(`username`),':',UPPER('%s'))) WHERE `id` = '%d'",_PARAMS[2].c_str() ,account_id);
+                if (plr) Send_Player(plr, MakeMsg("%s Has Changed Your Password To: %s", CD->USER.c_str(), _PARAMS[2].c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Password Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "rename")
+            {
+                if (plr)
+                {
+                    plr->SetAtLoginFlag(AT_LOGIN_RENAME);
+                    Send_Player(plr, MakeMsg("%s Has Requested You Change This Characters Name, Rename Will Be Forced On Next Login!", CD->USER.c_str()));
+                }
+                CharacterDatabase.PExecute("UPDATE `characters` SET `at_login` = `at_login` | '1' WHERE `guid` = '%u'", guid);
+                Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Has Been Forced To Change Their Characters Name, Rename Will Be Forced On Next Login!", true, CD->TYPE);
+            }
+            else if (_PARAMS[1] == "gmlevel")
+            {
+                const char *cgmlevel = _PARAMS[2].c_str();
+                if (GetLevel(CD->USER) >= atoi(cgmlevel))
+                {
+                    LoginDatabase.PExecute("UPDATE `account` SET `gmlevel` = '%d' WHERE `id` = '%d'", _PARAMS[2].c_str(), account_id);
+                    Send_IRCA(ChanOrPM(CD), "\00313["+GetAcctNameFromID(account_id)+"] : Has GM Level Successfully Changed To: "+_PARAMS[2], true, CD->TYPE);
+                }
+                else
+                {
+                    Send_IRCA(CD->USER, "\0034[ERROR] : The Specified GM Level Is Higher Than Your GM Level.", true, "ERROR");
+                }
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : You Are Not A GM, You May Only Change Settings In Your Own Account.", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : No Such Player Exists, So Account Cannot Be Looked Up.", true, "ERROR");
+}
+
+void IRCCmd::Ban_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (_PARAMS[1] == "ip")
+    {
+        std::string ip = GetIPFromPlayer(_PARAMS[0]);
+        if (_PARAMS[2] == "")
+            _PARAMS[2] = "No Reason";
+        if (ip != "")
+        {
+            LoginDatabase.PExecute("INSERT IGNORE INTO `ip_banned` VALUES ('%s', UNIX_TIMESTAMP(), UNIX_TIMESTAMP(), '%s', '%s')", ip.c_str(), CD->USER.c_str(), _PARAMS[2].c_str());
+            if (Player* plr = GetPlayer(_PARAMS[0]))
+                plr->GetSession()->KickPlayer();
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Had Their IP Address Banned. [%s] Reason: %s",_PARAMS[0].c_str() ,ip.c_str() , _PARAMS[2].c_str()), true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : I Cannot Locate An IP Address For The Character Name Given.", true, "ERROR");
+    }
+    if (_PARAMS[1] == "acct")
+    {
+        uint64 guid = objmgr.GetPlayerGUIDByName(_PARAMS[0].c_str());
+        uint32 acctid = objmgr.GetPlayerAccountIdByGUID(guid);
+        if (_PARAMS[2] == "")
+            _PARAMS[2] = "No Reason";
+        if (acctid)
+        {
+            LoginDatabase.PExecute("INSERT INTO `account_banned` VALUES ('%u', UNIX_TIMESTAMP(), UNIX_TIMESTAMP(), '%s', '%s', 1)", acctid, CD->USER.c_str(), _PARAMS[2].c_str());
+            if (Player* plr = GetPlayer(_PARAMS[0]))
+                plr->GetSession()->KickPlayer();
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Had Their Account Banned. Reason: %s",_PARAMS[0].c_str(), _PARAMS[2].c_str()), true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : I Cannot Locate An Account For The Character Name Given.", true, "ERROR");
+    }
+    if (_PARAMS[1] == "unban")
+    {
+        std::string unbani = _PARAMS[0];
+        if (atoi(unbani.c_str()) > 0)
+        {
+            LoginDatabase.PExecute("DELETE FROM ip_banned WHERE ip = '%s'", _PARAMS[0].c_str());
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Removed From The IP Ban List.", _PARAMS[0].c_str()), true, CD->TYPE);
+        }
+        else
+        {
+            QueryResult_AutoPtr result = LoginDatabase.PQuery("SELECT id FROM `account` WHERE username = '%s'", _PARAMS[0].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string id = fields[0].GetCppString();
+
+                LoginDatabase.PExecute("DELETE FROM account_banned WHERE id = %s", id.c_str());
+                
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Removed From The Account Ban List.", _PARAMS[0].c_str()), true, CD->TYPE);
+
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : I Cannot Locate An Account Or IP Address For The Paramaters Given.", true, "ERROR");
+        }
+    }
+}
+
+void IRCCmd::Chan_Control(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (CD->FROM == sIRC._Nick)
+    {
+        Send_IRCA(CD->USER, "\0034[ERROR] : You Cannot Use This Command Through A PM Yet.", true, "ERROR");
+        return;
+    }
+    if (_PARAMS[0] == "op")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" +o "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" +o "+CD->USER);
+    }
+    if (_PARAMS[0] == "deop")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" -o "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" -o "+CD->USER);
+    }
+    if (_PARAMS[0] == "voice")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" +v "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" +v "+CD->USER);
+    }
+    if (_PARAMS[0] == "devoice")
+    {
+        if (_PARAMS[1].length() > 1)
+            sIRC.SendIRC("MODE "+CD->FROM+" -v "+_PARAMS[1]);
+        else
+            sIRC.SendIRC("MODE "+CD->FROM+" -v "+CD->USER);
+    }
+}
+
+void IRCCmd::Char_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 5);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    uint64 guid = objmgr.GetPlayerGUIDByName(_PARAMS[0]);
+    Player* plr = objmgr.GetPlayer(guid);
+    if (plr)
+    {
+        if (_PARAMS[1] == "mapcheat")
+        {
+            bool explore = false;
+            if (_PARAMS[2] != "0")
+                explore = true;
+            for (uint8 i=0; i<64; i++)
+            {
+                if (_PARAMS[2] != "0")
+                    plr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0xFFFFFFFF);
+                else
+                    plr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0);
+            }
+            if (explore)
+            {
+                Send_Player(plr, MakeMsg("All Your Zones Have Been Set To Explored By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Now Explored All Zones.", true, CD->TYPE);
+            }
+            else
+            {
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Now Had All Zones Set To Un-Explored.", true, CD->TYPE);
+                Send_Player(plr, MakeMsg("All Your Zones Have Been Set To Un-Explored By: %s", CD->USER.c_str()));
+            }
+        }
+        if (_PARAMS[1] == "taxicheat")
+        {
+            if (_PARAMS[2] != "0")
+            {
+                plr->SetTaxiCheater(true);
+                Send_Player(plr, MakeMsg("Taxi Node Cheat Has Been Enabled By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Taxi Node Cheat Has Been Enabled.", true, CD->TYPE);
+            }
+            else
+            {
+                plr->SetTaxiCheater(false);
+                Send_Player(plr, MakeMsg("Taxi Node Cheat Has Been Disabled By: %s", CD->USER.c_str()));
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Taxi Node Cheat Has Been Disabled.", true, CD->TYPE);
+            }
+        }
+        if (_PARAMS[1] == "maxskill")
+        {
+            plr->UpdateSkillsToMaxSkillsForLevel();
+            Send_Player(plr, MakeMsg("Your Skills Have Been Maxed Out By: %s", CD->USER.c_str()));
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Skills Have Been Maxed Out.", true, CD->TYPE);
+        }
+        if (_PARAMS[1] == "setskill")
+        {
+            std::string* _PARAMSA = getArray(_PARAMS[2], 4);
+            uint32 skill = atoi(_PARAMS[2].c_str());
+            uint16 step = atoi(_PARAMS[3].c_str());
+            uint16 level = atol(_PARAMS[4].c_str());
+            SkillLineEntry const* skilllookup = sSkillLineStore.LookupEntry(skill);
+            //if skillid entered is not a number and greater then 0 then the command is being used wrong
+            if (skill >= 0)
+            {
+                //does the skill even exist
+                if (skilllookup)
+                {
+                    //does player have the skill yet
+                    if (plr->GetSkillValue(skill))
+                    {
+                        plr->SetSkill(skill,step,level);
+                        Send_Player(plr, MakeMsg("Skill: %s Has Been Set To Level: %i By: %s",skilllookup->name[0], level, CD->USER.c_str()));
+                        Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Had Skill: %s Set To Level: %d",_PARAMS[0].c_str() , skilllookup->name[0], level), true, CD->TYPE);
+                    }
+                    else
+                        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Player Does Not Have The %s Skill Yet.", skilllookup->name[0]), true, "ERROR");
+                }
+                else
+                    Send_IRCA(CD->USER, "\0034[ERROR] : That Skill ID Does Not Exist.", true, "ERROR");
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : The Skill ID Entered Is Invalid.", true, "ERROR");
+        }
+        if (_PARAMS[1] == "combatstop")
+        {
+            if (!plr->isInCombat())
+            {
+                plr->CombatStop();
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Was Dropped From Combat",_PARAMS[0].c_str()), true, CD->TYPE);
+            }else
+            {
+                Send_IRCA(CD->USER, "\0034[ERROR] : Specified Player Is Not In Combat.", true, "ERROR");
+            }
+        }
+        if (_PARAMS[1] == "quest")
+        {
+            std::string s_param  = _PARAMS[3];
+            std::string QName = "";
+            char *args = (char*)s_param.c_str();
+            uint32 qId = 0;
+            if (args[0]=='[')
+            {
+                char* cQName = strtok((char*)args, "]");
+                if (cQName && cQName[0])
+                {
+                    QName = cQName+1;
+                    WorldDatabase.escape_string(QName);
+                    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry FROM quest_template WHERE name = '%s'", QName.c_str());
+                    if (!result)
+                    {
+                        Send_IRCA(CD->USER, "\0034[ERROR] : Quest Not Found!", true, "ERROR");
+                        return;
+                    }
+                    qId = result->Fetch()->GetUInt16();
+                    
+                }
+            }
+            else
+            {
+                qId = atoi(args);
+                QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT title FROM quest_template WHERE entry = '%d'", qId);
+                if (!result)
+                {
+                    Send_IRCA(CD->USER, "\0034[ERROR] : Quest Not Found!", true, "ERROR");
+                    return;
+                }
+                QName = result->Fetch()->GetCppString();
+                
+            }
+            if (_PARAMS[2] == "add")
+            {
+                Quest const* pQuest = objmgr.GetQuestTemplate(qId);
+                for (uint32 id = 0; id < sItemStorage.MaxEntry; id++)
+                {
+                    ItemPrototype const *pProto = sItemStorage.LookupEntry<ItemPrototype>(id);
+                    if (!pProto)
+                        continue;
+
+                    if (pProto->StartQuest == qId)
+                    {
+                        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : This Quest Requires Activation By Item %d, Add It To The Player And Start Quest Manually.", pProto->ItemId),true, "ERROR");
+                    }
+                }
+
+                if (plr->CanAddQuest(pQuest, true))
+                {
+                    plr->AddQuest(pQuest, NULL);
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Had Quest [%s] Added To Quest Log.", _PARAMS[0].c_str(), QName.c_str()), true, "ERROR");
+                }
+                else
+                {
+                    Send_IRCA(CD->USER, "\0034[ERROR] : Cannot Add Quest To Player, He Either Has No Space Or He Already Has The Quest In His Quest Log.", true, "ERROR");
+                }
+            }
+            if (_PARAMS[2] == "remove")
+            {
+                Quest const* pQuest = objmgr.GetQuestTemplate(qId);
+                for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+                {
+                    uint32 quest = plr->GetQuestSlotQuestId(slot);
+                    if (quest==qId)
+                    {
+                        plr->SetQuestSlot(slot,0);
+                        plr->TakeQuestSourceItem(quest, false);
+                    }
+                }
+                plr->SetQuestStatus(qId, QUEST_STATUS_NONE);
+                plr->getQuestStatusMap()[qId].m_rewarded = false;
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Quest [%s] Removed.", _PARAMS[0].c_str(), QName.c_str()), true, CD->TYPE);
+            }
+            if (_PARAMS[2] == "complete")
+            {
+                Quest const* pQuest = objmgr.GetQuestTemplate(qId);
+                if (plr->GetQuestStatus(qId) == QUEST_STATUS_NONE)
+                {
+                    Send_IRCA(CD->USER, "\0034[ERROR] : Player Does Not Have This Quest In Quest Log, Cannot Complete It.", true, "ERROR");
+                }
+                else
+                {
+                    for (uint8 x = 0; x < QUEST_OBJECTIVES_COUNT; ++x)
+                    {
+                        uint32 id = pQuest->ReqItemId[x];
+                        uint32 count = pQuest->ReqItemCount[x];
+                        if (!id || !count)
+                            continue;
+                        uint32 curItemCount = plr->GetItemCount(id,true);
+                        ItemPosCountVec dest;
+                        uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, id, count-curItemCount);
+                        if (msg == EQUIP_ERR_OK)
+                        {
+                            Item* item = plr->StoreNewItem(dest, id, true);
+                            plr->SendNewItem(item,count-curItemCount,true,false);
+                        }
+                    }
+
+                    for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+                    {
+                        uint32 creature = pQuest->ReqCreatureOrGOId[i];
+                        uint32 creaturecount = pQuest->ReqCreatureOrGOCount[i];
+                        if (uint32 spell_id = pQuest->ReqSpell[i])
+                        {
+                            for (uint16 z = 0; z < creaturecount; ++z)
+                                plr->CastedCreatureOrGO(creature,0,spell_id);
+                        }
+                        else if (creature > 0)
+                        {
+                            if (CreatureInfo const* cInfo = objmgr.GetCreatureTemplate(creature))
+                                for (uint16 z = 0; z < creaturecount; ++z)
+                                    plr->KilledMonster(cInfo,0);
+                        }
+                        else if (creature < 0)
+                        {
+                            for (uint16 z = 0; z < creaturecount; ++z)
+                                plr->CastedCreatureOrGO(creature,0,0);
+                        }
+                    }
+
+                    if (uint32 repFaction = pQuest->GetRepObjectiveFaction())
+                    {
+                        uint32 repValue = pQuest->GetRepObjectiveValue();
+                        uint32 curRep = plr->GetReputation(repFaction);
+                        if (curRep < repValue)
+                        {
+                            FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction);
+                            plr->SetFactionReputation(factionEntry,repValue);
+                        }
+                    }
+                    
+                    int32 ReqOrRewMoney = pQuest->GetRewOrReqMoney();
+                    if (ReqOrRewMoney < 0)
+                        plr->ModifyMoney(-ReqOrRewMoney);
+
+                    plr->CompleteQuest(qId);
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Quest [%s] Status Set To Complete.", _PARAMS[0].c_str(), QName.c_str()), true, CD->TYPE);
+                }
+            }
+        }
+        if (_PARAMS[1] == "mod")
+        {
+            /*if (_PARAMS[2] == "rep") TODO
+            {
+                uint32 factionId = atoi((char*)_PARAMS[3].c_str());
+                FactionEntry const *factionEntry = sFactionStore.LookupEntry(factionId);
+                if (!factionEntry)
+                {
+                    Send_IRCA(CD->USER, "\0034[ERROR] : No Faction With That Name Exists.", true, "ERROR");
+                }
+                else
+                {
+                    int32 amount = atol((char*)_PARAMS[4].c_str());
+                    if (amount > -39000 && amount < 43000)
+                    {
+                        plr->SetFactionReputation(factionId,amount);
+                        Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Reputation With Faction %s Set To %s.", _PARAMS[0].c_str(), _PARAMS[3].c_str(), _PARAMS[4].c_str()), true, CD->TYPE);
+                    }
+                    else
+                    {
+                        Send_IRCA(CD->USER, "\0034[ERROR] : Reputation Value Incorrect. Must Be Between -39000 and 43000.", true, "ERROR");
+                    }
+                }
+            }*/
+            if (_PARAMS[2] == "morph")
+            {
+                uint16 display_id = (uint16)atoi((char*)_PARAMS[3].c_str());
+                plr->SetDisplayId(display_id);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Morphed Into DisplayID: %s.", _PARAMS[0].c_str(), _PARAMS[3].c_str()), true, CD->TYPE);
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "\0034[ERROR] : Valid Parameters Are: morph <displayid>, reputation <faction><value>.", true, "ERROR");
+            }
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : No Character With That Name Exists.", true, "ERROR");
+}
+
+void IRCCmd::Fun_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (_PARAMS[1] == "say")
+        {
+            plr->Say(_PARAMS[2], LANG_UNIVERSAL);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Was Forced To Say: "+_PARAMS[2]+".", true, CD->TYPE);
+        }
+        if (_PARAMS[1] == "sound")
+        {
+            uint32 sndid = atoi(_PARAMS[2].c_str());
+            plr->SendPlaySound(sndid ,true);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Just Heard Sound ID: "+_PARAMS[2]+".", true, CD->TYPE);
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : Player Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Help_IRC(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `Command`, `Description`, `gmlevel` FROM `irc_commands`");
+    if (result)
+    {
+        if (IsLoggedIn(CD->USER))
+        {
+            if (_PARAMS[0] == "")
+            {
+                QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT * FROM `irc_commands` WHERE `gmlevel` <= %u ORDER BY `Command`", GetLevel(CD->USER));
+                if (result)
+                {
+                    std::string output = "\002OCChat IRC Commands:\017 ";
+                    for (uint64 i=0; i < result->GetRowCount(); i++)
+                    {
+                        Field *fields = result->Fetch();
+                        output += fields[0].GetCppString() + ", ";
+                        result->NextRow();
+                    }
+                    
+                    Send_IRCA(CD->USER, output, true, CD->TYPE.c_str());
+                }
+            }
+            else
+            {
+                QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `irc_commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    if (fields[1].GetUInt32() > GetLevel(CD->USER))
+                    {
+                        Send_IRCA(CD->USER, "You Do Not Have Access To That Command, So No Help Is Available.", true, CD->TYPE.c_str());
+                        return;
+                    }
+                    if (result)
+                    {
+                        std::string cmdhlp = fields[0].GetCppString();
+                        
+                        Send_IRCA(CD->USER, cmdhlp, true, CD->TYPE.c_str());
+                    }
+                }
+                else
+                    Send_IRCA(CD->USER, "\0034[ERROR] : No Such Command Exists, Please Check The Spelling And Try Again.", true, "ERROR");
+            }
+        }
+        else if (!IsLoggedIn(CD->USER))
+        {
+            if (_PARAMS[0] == "")
+            {
+                QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT * FROM `irc_commands` WHERE `gmlevel` = 0 ORDER BY `Command`");
+                if (result)
+                {
+                    std::string output = "\002OCChat IRC Commands:\017 ";
+                    for (uint64 i=0; i < result->GetRowCount(); i++)
+                    {
+                        Field *fields = result->Fetch();
+                        output += fields[0].GetCppString() + ", ";
+                        result->NextRow();
+                    }
+                    
+                    Send_IRCA(CD->USER, output, true, CD->TYPE.c_str());
+                    Send_IRCA(CD->USER, "You Are Currently Not Logged In, Please Login To See A Complete List Of Commands Available To You.", true, CD->TYPE.c_str());
+                }
+            }
+            else
+            {
+                QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `irc_commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    if (fields[1].GetUInt32() > 0)
+                    {
+                        Send_IRCA(CD->USER, "You Do Not Have Access To That Command, So No Help Is Available.", true, CD->TYPE.c_str());
+                        return;
+                    }
+                    std::string cmdhlp = fields[0].GetCppString();
+                    
+                    Send_IRCA(CD->USER, cmdhlp, true, CD->TYPE.c_str());
+                }
+                else
+                    Send_IRCA(CD->USER, "\0034[ERROR] : No Such Command Exists, Please Check The Spelling And Try Again.", true, "ERROR");
+            }
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : Database Error! Please Make Sure You Used irc_commands.sql, You Must Have A Table In Your World Database (irc_commands)!", true, "ERROR");
+}
+
+void IRCCmd::Inchan_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "")
+    {
+        Send_IRCA(CD->USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"inchan <ChannelName>)", true, "ERROR");
+        return;
+    }
+    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT * FROM `irc_inchan` WHERE `channel` = '%s' ORDER BY `name`", _PARAMS[0].c_str());
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        std::string output = "\002Players In The [ "+fields[2].GetCppString()+" ] Channel:\017 ";
+        for (uint64 i=0; i < result->GetRowCount(); i++)
+        {
+            output += fields[1].GetCppString() + ", ";
+            result->NextRow();
+        }
+        
+        Send_IRCA(ChanOrPM(CD), output, true, CD->TYPE);
+    }
+    else
+        Send_IRCA(ChanOrPM(CD), "No Players Are Currently In [ "+_PARAMS[0]+" ] Channel!", true, CD->TYPE.c_str());
+}
+
+void IRCCmd::Info_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    char clientsNum [50];
+    sprintf(clientsNum, "%u", sWorld.GetActiveSessionCount());
+    char maxClientsNum [50];
+    sprintf(maxClientsNum, "%u", sWorld.GetMaxActiveSessionCount());
+    char ircupdt [50];
+    sprintf(ircupdt, "%u", sWorld.GetUpdateTime());
+    std::string str = secsToTimeString(sWorld.GetUptime());
+    std::string svnrev = _FULLVERSION;
+
+    float rdm = (sConfig.GetFloatDefault("Rate.Drop.Money", 1.0f));
+    float rxk = (sConfig.GetFloatDefault("Rate.XP.Kill", 1.0f));
+    float rxq = (sConfig.GetFloatDefault("Rate.XP.Quest", 1.0f));
+    
+    Send_IRCA(ChanOrPM(CD), "\x2 Number Of Players Online:\x3\x31\x30 " + (std::string)clientsNum + "\xF |\x2 Max Since Last Restart:\x3\x31\x30 "+(std::string)maxClientsNum+"\xF |\x2 UpTime:\x3\x31\x30 "+str, true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), "\x2 Server:\x3\x31\x30 " +svnrev+ "\xF |\x2 Update Time:\x3\x31\x30 "+(std::string)ircupdt, true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), MakeMsg("\x2 Server Rates - [Monster XP:\x3\x31\x30 %d\xF\x2][Quest XP:\x3\x31\x30 %d\xF\x2][Money Drop Rate:\x3\x31\x30 %d\xF\x2]", int(rxk), int(rxq), int(rdm)), true, CD->TYPE);
+    Send_IRCA(ChanOrPM(CD), "\x2 MotD:\x3\x31\x30 "+(std::string)sWorld.GetMotd(), true, CD->TYPE);
+
+}
+
+void IRCCmd::Item_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+
+    normalizePlayerName(_PARAMS[0]);
+    Player *chr = GetPlayer(_PARAMS[0].c_str());
+    if (_PARAMS[1] == "add")
+    {
+        std::string s_param  = _PARAMS[2];
+
+        char *args = (char*)s_param.c_str();
+        uint32 itemId = 0;
+        if (args[0]=='[')
+        {
+            char* citemName = strtok((char*)args, "]");
+            if (citemName && citemName[0])
+            {
+                std::string itemName = citemName+1;
+                WorldDatabase.escape_string(itemName);
+                QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+                if (!result)
+                {
+                    Send_IRCA(CD->USER, "\0034[ERROR] : Item Not Found!", true, "ERROR");
+                    return;
+                }
+                itemId = result->Fetch()->GetUInt16();
+                
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> [Exact Item Name] <Amount>)", true, "ERROR");
+                return;
+            }
+        }
+        else
+        {
+            std::string itemName = s_param;
+            WorldDatabase.escape_string(itemName);
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+            if (result)
+            {
+                itemId = result->Fetch()->GetUInt16();
+            }
+            
+
+            char* cId = strtok(args, " ");
+            if (!cId)
+            {
+                Send_IRCA(CD->USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> <ItemID> <Amount>)", true, "ERROR");
+                return;
+            }
+            itemId = atol(cId);
+        }
+            char* ccount = strtok(NULL, " ");
+            int32 count = 1;
+            if (ccount) { count = atol(ccount); }
+            Player* plTarget = chr;
+        if (!plTarget)
+        {
+            Send_IRCA(CD->USER, "\0034[ERROR] : "+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+            return;
+        }
+        ItemPrototype const *pProto = objmgr.GetItemPrototype(itemId);
+        //Subtract
+        if (count < 0)
+        {
+            plTarget->DestroyItemCount(itemId, -count, true, false);
+            char itemid2[255];
+            sprintf(itemid2,"%d",itemId);
+            std::string itake = " \00313["+ _PARAMS[0] +"] : Has Had Item " +itemid2+ " Taken From Them!";
+            Send_IRCA(ChanOrPM(CD), itake, true, CD->TYPE);
+            return;
+        }
+        //Adding items
+        uint32 noSpaceForCount = 0;
+
+        // check space and find places
+        ItemPosCountVec dest;
+        uint8 msg = plTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &noSpaceForCount);
+        if (msg == EQUIP_ERR_INVENTORY_FULL)                   // convert to possibel store amount
+            count -= noSpaceForCount;
+        else if (msg != EQUIP_ERR_OK)                          // other error, can't add
+        {
+            char s_countForStore[255];
+            sprintf(s_countForStore,"%d",count);
+            std::string ierror = " \00313["+ _PARAMS[0] +"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+            Send_IRCA(ChanOrPM(CD), ierror, true, CD->TYPE);
+            return;
+        }
+        Item* item = plTarget->StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+        if (count > 0 && item)
+        {
+                plTarget->SendNewItem(item,count,true,false);
+                QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT name FROM item_template WHERE entry = %d", itemId);
+                char* dbitemname = NULL;
+                if (result)
+                {
+                    dbitemname = (char*)result->Fetch()->GetString();
+                }
+                std::string iinfo = " \00313[" + _PARAMS[0] + "] : Has Been Given Item "+dbitemname+". From: "+CD->USER.c_str()+".";
+                Send_IRCA(ChanOrPM(CD), iinfo, true, CD->TYPE);
+                
+        }
+        if (noSpaceForCount > 0)
+        {
+            char s_countForStore[255];
+            sprintf(s_countForStore,"%d",noSpaceForCount);
+            std::string ierror = " \00313["+ _PARAMS[0] +"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+            Send_IRCA(ChanOrPM(CD), ierror, true, CD->TYPE);
+            return;
+        }
+    }
+    else
+    {
+        Send_IRCA(CD->USER, "\0034[ERROR] : Syntax Error! ("+sIRC._cmd_prefx+"item <Player> <add> <ItemID> <Amount>)", true, "ERROR");
+        return;
+    }
+}
+
+void IRCCmd::Jail_Player(_CDATA *CD)
+{
+    if (ValidParams(CD->PARAMS, 1))
+    {
+        std::string* _PARAMS = getArray(CD->PARAMS, 2);
+        if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+        {
+            Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+            return;
+        }
+        if (Player *plr = GetPlayer(_PARAMS[0]))
+        {
+            std::string sReason = "";
+            if (_PARAMS[1] == "release")
+            {
+                float rposx, rposy, rposz, rposo = 0;
+                uint32 rmapid = 0;
+                CharacterDatabase.escape_string(_PARAMS[0]);
+                QueryResult_AutoPtr result = CharacterDatabase.PQuery("SELECT `map`, `position_x`, `position_y`, `position_z` FROM `character_homebind` WHERE `guid` = '" UI64FMTD "'", plr->GetGUID());
+                if (result)
+                {
+                    Field *fields = result->Fetch();
+                    rmapid = fields[0].GetUInt16();
+                    rposx = fields[1].GetFloat();
+                    rposy = fields[2].GetFloat();
+                    rposz = fields[3].GetFloat();
+                    
+                    plr->SetMovement(MOVE_UNROOT);
+                    plr->TeleportTo(rmapid, rposx, rposy, rposz, rposo);
+                    plr->RemoveAurasDueToSpell(42201);
+                    plr->RemoveAurasDueToSpell(23775);
+                    plr->RemoveAurasDueToSpell(9454);
+                    Send_Player(plr, MakeMsg("You Have Been Released By: %s.", CD->USER.c_str()));
+                    sReason = " \00313["+_PARAMS[0]+"] : Has Been Released By: "+CD->USER+".";
+                    Send_IRCA(ChanOrPM(CD), sReason, true, CD->TYPE);
+                }
+            }
+            else
+            {
+                if (_PARAMS[1] == "")
+                    _PARAMS[1] = "No Reason Given.";
+                plr->TeleportTo(13, 0, 0, 0, 0);
+                plr->SetMovement(MOVE_ROOT);
+                plr->CastSpell(plr, 42201, true);
+                plr->CastSpell(plr, 23775, true);
+                plr->CastSpell(plr, 9454, true);
+                Send_Player(plr, MakeMsg("You Have Been Jailed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+                sReason = " \00313["+_PARAMS[0]+"] : Has Been Jailed By: "+CD->USER+". Reason: "+_PARAMS[1]+".";
+                Send_IRCA(ChanOrPM(CD), sReason, true, CD->TYPE);
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : "+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+    }
+}
+
+void IRCCmd::Kick_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (_PARAMS[1] == "")
+        _PARAMS[1] = "No Reason Given.";
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        plr->GetSession()->KickPlayer();
+        Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been Kicked By: "+CD->USER+". Reason: "+_PARAMS[1]+".", true, CD->TYPE);
+        if (sWorld.getConfig(CONFIG_SHOW_KICK_IN_WORLD))
+            sIRC.Send_WoW_System("Player|cffff0000 "+_PARAMS[0]+"|r kicked by|cffff0000 "+CD->USER+"|r. Reason:|cffff0000"+_PARAMS[1]+"|r.");
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : "+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Kill_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isAlive())
+        {
+            plr->DealDamage(plr, plr->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            plr->SaveToDB();
+            if (_PARAMS[1] == "")
+                _PARAMS[1] = "No Reason Given.";
+            Send_IRCA(ChanOrPM(CD), MakeMsg("\00313[%s] : Has Been Killed By: %s.", _PARAMS[0].c_str(), CD->USER.c_str()) +  +  + " Reason: "+_PARAMS[1]+".", true, CD->TYPE);
+            Send_Player(plr, MakeMsg("You Have Been Killed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : "+_PARAMS[0]+" Is Already Dead!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : "+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Lookup_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (_PARAMS[0] == "acct")
+    {
+        uint32 acctid = atoi(_PARAMS[1].c_str());
+        if (sAccountMgr->GetId(_PARAMS[1]))
+            acctid = sAccountMgr->GetId(_PARAMS[1]);
+        if (acctid > 0)
+        {
+            std::string DateTime = "%a, %b %d, %Y - %h:%i%p";
+            QueryResult_AutoPtr result = LoginDatabase.PQuery("SELECT `account`.`id`, username, `gmlevel`, last_ip, (SELECT banreason FROM account_banned WHERE `account`.`id` = %d LIMIT 1) as banned, (SELECT banreason FROM ip_banned WHERE ip = last_ip) as bannedip, DATE_FORMAT(last_login, '%s') FROM `account` WHERE `account`.`id` = %d" , acctid, DateTime.c_str(), acctid, acctid);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 id = fields[0].GetUInt32();
+                std::string usrname = fields[1].GetCppString();
+                uint32 gm = fields[2].GetUInt32();
+                std::string lastip = fields[3].GetCppString();
+                std::string banreason = fields[4].GetCppString();
+                std::string banreasonip = fields[5].GetCppString();
+                std::string lastlogin = fields[6].GetCppString();
+                
+
+                QueryResult_AutoPtr chars = CharacterDatabase.PQuery("SELECT guid, name, (SELECT SUM(totaltime) FROM characters WHERE account = %d) AS tottime FROM characters WHERE account = %u", id, id);
+                std::string characters = "None";
+                std::string totaccttime = "Never Logged In";
+                if (chars)
+                {
+                    characters = "";
+                    Field *fields = chars->Fetch();
+                    totaccttime = SecToDay(fields[2].GetCppString());
+                    for (uint64 i=0; i < chars->GetRowCount(); i++)
+                    {
+                        std::string guid = fields[0].GetCppString();
+                        std::string charname = fields[1].GetCppString();
+                        characters.append(charname+"("+guid+"), ");
+                        chars->NextRow();
+                    }
+                    
+                }
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Username:\x3\x31\x30 %s \xF|\x2 AccountID:\x3\x31\x30 %d \xF|\x2 GM Level:\x3\x31\x30 %d \xF|\x2 Last IP:\x3\x31\x30 %s \xF|\x2 Last Login:\x3\x31\x30 %s", usrname.c_str(), id, gm, lastip.c_str(), lastlogin.c_str()), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Total Play Time:\x3\x31\x30 %s \xF|\x2 Characters:\x3\x31\x30 %s ", totaccttime.c_str(), characters.c_str()), true, CD->TYPE);
+                if (banreason.length() > 1)
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\0034This User Has An Account Ban. Ban Reason: %s", banreason.c_str()), true, CD->TYPE);
+                if (banreasonip.length() > 1)
+                    Send_IRCA(ChanOrPM(CD), MakeMsg("\0034This User Has An IP Ban. Ban Reason: %s", banreasonip.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Account ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult_AutoPtr result = LoginDatabase.PQuery("SELECT id, username FROM `account` WHERE username LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string accts = "\002Account Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string acctid = fields[0].GetCppString();
+                    std::string acctname = fields[1].GetCppString();
+                    accts.append(acctname+"("+acctid+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), accts, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Username. I Cant Find Any Users With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "char")
+    {
+        uint32 plguid = atoi(_PARAMS[1].c_str());
+        if (objmgr.GetPlayerGUIDByName(_PARAMS[1].c_str()))
+            plguid = objmgr.GetPlayerGUIDByName(_PARAMS[1].c_str());
+        if (plguid > 0)
+        {
+            QueryResult_AutoPtr result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, online, SUBSTRING_INDEX(SUBSTRING_INDEX(`name`, ' ' , 35), ' ' , -1) AS level, SUBSTRING_INDEX(SUBSTRING_INDEX(`name`, ' ' , 238), ' ' , -1) AS guildid, SUBSTRING_INDEX(SUBSTRING_INDEX(`name`, ' ' , 239), ' ' , -1) AS guildrank, SUBSTRING_INDEX(SUBSTRING_INDEX(`name`, ' ' , 927), ' ' , -1) AS xp, SUBSTRING_INDEX(SUBSTRING_INDEX(`name`, ' ' , 928), ' ' , -1) AS maxxp, SUBSTRING_INDEX(SUBSTRING_INDEX(name, ' ' , 1462), ' ' , -1) AS gold, SUBSTRING_INDEX(SUBSTRING_INDEX(`name`, ' ' , 1454), ' ' , -1) AS hk, totaltime FROM characters WHERE guid =%i", plguid);
+            uint32 latency = 0;
+            Player *chr = objmgr.GetPlayer(plguid);
+            if (chr)
+            {
+                latency = chr->GetSession()->GetLatency();
+            }
+            char templatency [100];
+            sprintf(templatency, "%ums", latency);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string pguid = fields[0].GetCppString();
+                std::string pacct = fields[1].GetCppString();
+                std::string pname = fields[2].GetCppString();
+                uint32 praceid = fields[3].GetUInt32();
+                uint32 pclassid = fields[4].GetUInt32();
+                std::string ponline = (fields[5].GetInt32() == 1 ? "\x3\x30\x33Online" : "\x3\x30\x34Offline\xF");
+                std::string plevel = fields[6].GetCppString();
+                uint32 pguildid = fields[7].GetUInt32();
+                uint32 pguildrank = fields[8].GetUInt32();
+                std::string pxp = fields[9].GetCppString();
+                std::string pmaxxp = fields[10].GetCppString();
+                unsigned int money = fields[11].GetInt32();
+                std::string hk = fields[12].GetCppString();
+                std::string totaltim = SecToDay(fields[13].GetCppString());
+                
+                std::string sqlquery = "SELECT `gmlevel` FROM `account` WHERE `id` = '" + pacct + "';";
+                QueryResult_AutoPtr result = LoginDatabase.Query(sqlquery.c_str());
+                Field *fields2 = result->Fetch();
+                std::string pgmlvl = fields2[0].GetCppString();
+                
+                std::string guildinfo = "";
+                if (pguildid != 0)
+                {
+                    Guild* guild = objmgr.GetGuildById(pguildid);
+                    if (guild)
+                    {
+                        guildinfo = " " + guild->GetRankName(pguildrank) + " Of " + guild->GetName();
+                    }
+                }
+                else guildinfo = " None";
+                ChrRacesEntry const* prace = sChrRacesStore.LookupEntry(praceid);
+                ChrClassesEntry const* pclass = sChrClassesStore.LookupEntry(pclassid);
+
+                if (atoi(plevel.c_str()) < sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL))
+                    plevel += " (" + pxp + "/" + pmaxxp + ")";
+                unsigned int gold = money / 10000;
+                unsigned int silv = (money % 10000) / 100;
+                unsigned int cop = (money % 10000) % 100;
+                char tempgold [100];
+                sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+                if (ponline == "\x3\x30\x33Online")
+                {
+                    Player * plr = ObjectAccessor::Instance().FindPlayerByName(pname.c_str());
+                    if (plr)
+                    {
+                        AreaTableEntry const* area = GetAreaEntryByAreaID(plr->GetAreaId());
+                        ponline += " in " + (std::string) area->area_name[sWorld.GetDefaultDbcLocale()];
+                        if (area->zone != 0)
+                        {
+                            AreaTableEntry const* zone = GetAreaEntryByAreaID(area->zone);
+                            ponline += " (" + (std::string)zone->area_name[sWorld.GetDefaultDbcLocale()] + ")";
+                        }
+                    }
+                }
+                std::string pinfo  = "\x2 About Player:\x3\x31\x30 " +pname+ "\xF |\x2 GM Level:\x3\x31\x30 " +pgmlvl+ "\xF |\x2 AcctID:\x3\x31\x30 " +pacct+ "\xF |\x2 CharID:\x3\x31\x30 " +pguid+ " \xF |\x2 Played Time:\x2\x3\x31\x30 " +totaltim.c_str()+" \xF |\x2 Latency:\x2\x3\x31\x30 "+templatency;
+                std::string pinfo2 = "\x2 Race:\x2\x3\x31\x30 " + (std::string)prace->name[sWorld.GetDefaultDbcLocale()] + "\xF |\x2 Class:\x2\x3\x31\x30 " + (std::string)pclass->name[sWorld.GetDefaultDbcLocale()] + "\xF |\x2 Level:\x2\x3\x31\x30 " + plevel + "\xF |\x2 Money:\x2 " + tempgold + "\xF |\x2 Guild Info:\x2\x3\x31\x30 "+guildinfo+"\xF |\x2 Status:\x2 " + ponline;
+                //        pinfo3 = " :" + " \x2Honor Kills:\x2\x3\x31\x30 " + hk;
+                Send_IRCA(ChanOrPM(CD),pinfo , true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD),pinfo2 , true, CD->TYPE);
+                //        Send_IRCA(ChanOrPM(CD),pinfo3 , true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Character ID. (GUID)" ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult_AutoPtr result = CharacterDatabase.PQuery("SELECT guid, account, name FROM characters WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\x2 Character Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string guid = fields[0].GetCppString();
+                    std::string account = fields[1].GetCppString();
+                    std::string name = fields[2].GetCppString();
+                    MakeUpper(name);
+                    items.append(name+"(Account:"+account+" - GUID:"+guid+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Character. I Cant Find Any Characters With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "creature")
+    {
+        std::string creature = _PARAMS[1];
+        if (atoi(creature.c_str()) > 0)
+        {
+            WorldDatabase.escape_string(_PARAMS[1]);
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry, modelid_A, name, (minlevel*maxlevel/2) as level, faction_A, armor,  (SELECT count(*) FROM creature WHERE id = '%s') as spawns FROM creature_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 entry = fields[0].GetUInt32();
+                uint32 modelid = fields[1].GetUInt32();
+                std::string name = fields[2].GetCppString();
+                uint32 level = fields[3].GetUInt32();
+                uint32 faction = fields[4].GetUInt32();
+                uint32 armor = fields[5].GetUInt32();
+                uint32 spawns = fields[6].GetUInt32();
+                
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Name:\x3\x31\x30 %s \xF|\x2 CreatureID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Spawns:\x3\x31\x30 %d", name.c_str(), entry, modelid, spawns), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Level:\x3\x31\x30 %d \xF|\x2 Faction:\x3\x31\x30 %d \xF|\x2 Armor:\x3\x31\x30 %d", level, faction, armor), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Creature ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry, name FROM creature_template WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\002Creature Search Results:\x3\x31\x30 ";
+                //Send_IRCA(ChanOrPM(CD), "", true, CD->TYPE);
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string CreatureID = fields[0].GetCppString();
+                    std::string Name = fields[1].GetCppString();
+                    items.append(Name+"("+CreatureID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Creature. I Cant Find Any Creatures With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "faction")
+    {
+        std::string faction = _PARAMS[1];
+        if (atoi(faction.c_str()) > 0)
+        {
+            FactionEntry const *factionEntry = sFactionStore.LookupEntry(atoi(faction.c_str()));
+            if (factionEntry)
+            {
+                std::string name = factionEntry->name[sWorld.GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2 Faction:\x3\x31\x30 %s \xF|\x2 FactionID:\x3\x31\x30 %s",name.c_str(), faction.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown FactionID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string factions = "\002Faction Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sFactionStore.GetNumRows(); id++)
+            {
+                FactionEntry const *factionEntry = sFactionStore.LookupEntry(id);
+                if (factionEntry)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = factionEntry->name[sWorld.GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char factionid[100];
+                        sprintf(factionid, "%d", id);
+                        factions.append(name+"("+factionid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                factions.append("No Factions Found.");
+            Send_IRCA(ChanOrPM(CD), factions, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "go")
+    {
+        std::string gobject = _PARAMS[1];
+        if (atoi(gobject.c_str()) > 0)
+        {
+            WorldDatabase.escape_string(_PARAMS[1]);
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry, type, displayId, name, faction, (SELECT count(*) FROM gameobject WHERE id = '%s') as spawns FROM gameobject_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 entry = fields[0].GetUInt32();
+                uint32 type = fields[1].GetUInt32();
+                uint32 modelid = fields[2].GetUInt32();
+                std::string name = fields[3].GetCppString();
+                uint32 faction = fields[4].GetUInt32();
+                uint32 spawns = fields[5].GetUInt32();
+                
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2GO Name:\x3\x31\x30 %s \xF|\x2 GameobjectID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Spawns:\x3\x31\x30 %d", name.c_str(), entry, modelid, spawns), true, CD->TYPE);
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Type:\x3\x31\x30 %d \xF|\x2 Faction:\x3\x31\x30 %d", type, faction), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Creature ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry, name FROM gameobject_template WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string gos = "\002Gameobject Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string GOID = fields[0].GetCppString();
+                    std::string GoName = fields[1].GetCppString();
+                    gos.append(GoName+"("+GOID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), gos, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Game Object. I Cant Find Any Game Object's With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "item")
+    {
+        std::string item = _PARAMS[1];
+        if (atoi(item.c_str()) > 0)
+        {
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry, name, displayid, (SELECT count(*) FROM creature_loot_template WHERE item = '%s') as loot FROM `item_template` WHERE entry = %s", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                QueryResult_AutoPtr result2 = CharacterDatabase.PQuery("SELECT count(*) FROM `character_inventory` WHERE item_template = %s", _PARAMS[1].c_str());
+                Field *fields2 = result2->Fetch();
+                uint32 charcnt = fields2[0].GetUInt32();
+                
+
+                uint32 ItemID = fields[0].GetUInt32();
+                std::string ItmName = fields[1].GetCppString();
+                uint32 DisplayID = fields[2].GetUInt32();
+                uint32 loots = 0;
+                loots = fields[3].GetUInt32();
+                
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Item:\x3\x31\x30 %s \xF|\x2 ItemID:\x3\x31\x30 %d \xF|\x2 DisplayID:\x3\x31\x30 %d \xF|\x2 Owned By:\x3\x31\x30 %d players \xF|\x2 Dropped By:\x3\x31\x30 %d creatures", ItmName.c_str(), ItemID, DisplayID, charcnt, loots), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown ItemID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry, name FROM `item_template` WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string items = "\002Item Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string ItemID = fields[0].GetCppString();
+                    std::string ItemName = fields[1].GetCppString();
+                    items.append(ItemName+"("+ItemID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), items, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Item. I Cant Find Any Items With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "quest")
+    {
+        std::string quest = _PARAMS[1];
+        if (atoi(quest.c_str()) > 0)
+        {
+            WorldDatabase.escape_string(_PARAMS[1]);
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry, Title FROM quest_template WHERE entry = '%s';", _PARAMS[1].c_str(), _PARAMS[1].c_str());
+            if (result)
+            {
+                QueryResult_AutoPtr result2 = CharacterDatabase.PQuery("SELECT count(*) FROM character_queststatus WHERE quest = '%s' AND status = '1';", _PARAMS[1].c_str());
+                Field *fields2 = result2->Fetch();
+                uint32 status = fields2[0].GetUInt32();
+                
+
+                Field *fields = result->Fetch();
+                uint32 entry = fields[0].GetUInt32();
+                std::string name = fields[1].GetCppString();
+                
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Quest Name:\x3\x31\x30 %s \xF|\x2 QuestID:\x3\x31\x30 %d \xF|\x2 Completed:\x3\x31\x30 %d times", name.c_str(), entry, status), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Quest ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT entry, Title FROM quest_template WHERE Title LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string quests = "\002Quest Search Results:\x3\x31\x30 ";
+                //Send_IRCA(ChanOrPM(CD), "", true, CD->TYPE);
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string QuestID = fields[0].GetCppString();
+                    std::string QuestName = fields[1].GetCppString();
+                    quests.append(QuestName+"("+QuestID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                
+                Send_IRCA(ChanOrPM(CD), quests, true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Quest. I Cant Find Any Quest's With Those Search Terms." ,true, "ERROR");
+        }
+    }
+    if (_PARAMS[0] == "skill")
+    {
+        std::string skill = _PARAMS[1];
+        if (atoi(skill.c_str()) > 0)
+        {
+            SkillLineEntry const *skillInfo = sSkillLineStore.LookupEntry(atoi(skill.c_str()));
+            if (skillInfo)
+            {
+                std::string name = skillInfo->name[sWorld.GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Skill:\x3\x31\x30 %s \xF|\x2 SkillID:\x3\x31\x30 %s",name.c_str(), skill.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown SkillID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string skills = "\002Skill Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sSkillLineStore.GetNumRows(); id++)
+            {
+                SkillLineEntry const *skillInfo = sSkillLineStore.LookupEntry(id);
+                if (skillInfo)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = skillInfo->name[sWorld.GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char skillid[100];
+                        sprintf(skillid, "%d", id);
+                        skills.append(name+"("+skillid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                skills.append("No Skills Found.");
+            Send_IRCA(ChanOrPM(CD), skills, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "spell")
+    {
+        std::string spell = _PARAMS[1];
+        if (atoi(spell.c_str()) > 0)
+        {
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(atoi(spell.c_str()));
+            if (spellInfo)
+            {
+                std::string name = spellInfo->SpellName[sWorld.GetDefaultDbcLocale()];
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Spell:\x3\x31\x30 %s \xF|\x2 SpellID:\x3\x31\x30 %s",name.c_str(), spell.c_str()), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown SpellID." ,true, "ERROR");
+
+        }
+        else
+        {
+            uint32 counter = 0;
+            std::string spells = "\002Spell Search Results:\x3\x31\x30 ";
+            for (uint32 id = 0; id < sSpellStore.GetNumRows(); id++)
+            {
+                SpellEntry const *spellInfo = sSpellStore.LookupEntry(id);
+                if (spellInfo)
+                {
+                    MakeLower(_PARAMS[1]);
+                    std::string name = spellInfo->SpellName[sWorld.GetDefaultDbcLocale()];
+                    MakeLower(name);
+                    if (name.find(_PARAMS[1]) != std::string::npos && counter < 10)
+                    {
+                        char itemid[100];
+                        sprintf(itemid, "%d", id);
+                        spells.append(name+"("+itemid+")\xF | \x3\x31\x30\x2");
+                        ++counter;
+                    }
+                }
+            }
+            if (counter == 0)
+                spells.append("No Spells Found.");
+            Send_IRCA(ChanOrPM(CD), spells, true, CD->TYPE);
+        }
+    }
+    if (_PARAMS[0] == "tele")
+    {
+        std::string tele = _PARAMS[1];
+        if (atoi(tele.c_str()) > 0)
+        {
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT * FROM `game_tele` WHERE id = %s", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+
+                uint32 teleid = fields[0].GetUInt32();
+                uint32 pos_x = fields[1].GetUInt32();
+                uint32 pos_y = fields[2].GetUInt32();
+                uint32 pos_z = fields[3].GetUInt32();
+                uint32 oriet = fields[4].GetUInt32();
+                uint32 map = fields[5].GetUInt32();
+                std::string telname = fields[6].GetCppString();
+                
+
+                Send_IRCA(ChanOrPM(CD), MakeMsg("\x2Tele Name:\x3\x31\x30 %s \xF|\x2 TeleID:\x3\x31\x30 %d \xF|\x2 Coordinates:\x3\x31\x30 [X: %d, Y: %d, Z: %d, MAP: %d, Orientation: %d]", telname.c_str(), teleid, pos_x, pos_y, pos_z, map, oriet), true, CD->TYPE);
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Teleport Location ID." ,true, "ERROR");
+        }
+        else
+        {
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT id, name FROM `game_tele` WHERE name LIKE '%%%s%%' LIMIT 10", _PARAMS[1].c_str());
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                std::string teles = "\002Tele Location Search Results:\x3\x31\x30 ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    std::string TeleID = fields[0].GetCppString();
+                    std::string TeleName = fields[1].GetCppString();
+                    teles.append(TeleName+"("+TeleID+")\xF | \x3\x31\x30\x2");
+                    result->NextRow();
+                }
+                Send_IRCA(ChanOrPM(CD), teles, true, CD->TYPE);
+                
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Unknown Item. I Cant Find Any Items With Those Search Terms." ,true, "ERROR");
+        }
+    }
+}
+
+void IRCCmd::Level_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    uint64 guid = objmgr.GetPlayerGUIDByName(player.c_str());
+    std::string s_newlevel  = _PARAMS[1];
+    uint8 i_newlvl = atoi(s_newlevel.c_str());
+    if (!guid)
+    {
+        Send_IRCA(CD->USER, "\0034[ERROR] : Player Not Found!", true, "ERROR");
+        return;
+    } else if (i_newlvl < 1 || i_newlvl > sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL))
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Level Must Be Between 1 And %i!",sConfig.GetIntDefault("MaxPlayerLevel", 70)), true, "ERROR");
+        return;
+    } else
+    {
+        Player *chr = objmgr.GetPlayer(guid);
+        int32 i_oldlvl = chr ? chr->getLevel() : Player::GetUInt32ValueFromDB(UNIT_FIELD_LEVEL,guid);
+        if (chr)
+        {
+            chr->GiveLevel(i_newlvl);
+            chr->InitTalentForLevel();
+            chr->SetUInt32Value(PLAYER_XP,0);
+            WorldPacket data;
+            ChatHandler CH(chr->GetSession());
+            if (i_oldlvl == i_newlvl)
+                CH.FillSystemMessageData(&data, "Your level progress has been reset.");
+            else
+            if (i_oldlvl < i_newlvl)
+                CH.FillSystemMessageData(&data, fmtstring("You have been leveled up (%i)",i_newlvl-i_oldlvl));
+            else
+            if (i_oldlvl > i_newlvl)
+                CH.FillSystemMessageData(&data, fmtstring("You have been leveled down (%i)",i_newlvl-i_oldlvl));
+            chr->GetSession()->SendPacket(&data);
+        }
+        else
+        {
+            Tokens values;
+            Player::LoadValuesArrayFromDB(values,guid);
+            Player::SetUInt32ValueInArray(values,UNIT_FIELD_LEVEL,i_newlvl);
+            Player::SetUInt32ValueInArray(values,PLAYER_XP,0);
+            Player::SaveValuesArrayInDB(values,guid);
+        }
+    }
+    Send_IRCA(ChanOrPM(CD), "\00313[" + _PARAMS[0]+ "] : Has Been Leveled To " + _PARAMS[1] + ". By: "+CD->USER+".", true, CD->TYPE);
+}
+
+void IRCCmd::Money_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    uint64 guid = objmgr.GetPlayerGUIDByName(player.c_str());
+    Player *chr = objmgr.GetPlayer(guid);
+
+    std::string s_money  = _PARAMS[1];
+    int32 money = atoi(s_money.c_str());
+    unsigned int gold = money / 10000;
+    unsigned int silv = (money % 10000) / 100;
+    unsigned int cop = (money % 10000) % 100;
+    char tempgold [100];
+    sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+    if (!guid)
+    {
+        Send_IRCA(CD->USER, "\0034[ERROR] : Player Not Found!", true, "ERROR");
+        return;
+    }
+    else
+    {
+        Player *chr = objmgr.GetPlayer(guid);
+        uint32 moneyuser = 0;
+        if (chr)
+            moneyuser = chr->GetMoney();
+        else {
+        CharacterDatabase.escape_string(player);
+        std::string sqlquery = "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(name, ' ' , 1462), ' ' , -1) AS `gold` FROM `characters` WHERE `name` = '"+player+"';";
+        QueryResult_AutoPtr result = CharacterDatabase.Query(sqlquery.c_str());
+            Field *fields = result->Fetch();
+            moneyuser = fields[0].GetInt32();
+            
+        }
+            int32 addmoney = money;
+            int32 newmoney = moneyuser + addmoney;
+            char s_newmoney[255];
+            sprintf(s_newmoney,"%d",newmoney);
+            if (addmoney < 0)
+            {
+                sLog.outDetail("USER1: %i, ADD: %i, DIF: %i\\n", moneyuser, addmoney, newmoney);
+                if (newmoney <= 0)
+                {
+                    Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Had All Money Taken By: "+CD->USER.c_str()+".", true, CD->TYPE);
+                    if (chr)
+                    {
+                        chr->SetMoney(0);
+                        Send_Player(chr, MakeMsg("You Have Been Liquidated By: %s. Total Money Is Now 0.", CD->USER.c_str()));
+                    }
+                    else
+                        CharacterDatabase.PExecute("UPDATE `characters` SET name=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+                }
+                else
+                {
+                    Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Had ("+s_money+"\00313) Taken From Them By: "+CD->USER.c_str()+".", true, CD->TYPE);
+                    if (chr)
+                    {
+                        chr->SetMoney(newmoney);
+                        Send_Player(chr, MakeMsg("You Have Had %s Copper Taken From You By: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+                    }
+                    else
+                        CharacterDatabase.PExecute("UPDATE `characters` SET name=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+                }
+            }
+            else
+            {
+                Send_IRCA(ChanOrPM(CD), "\00313["+player+"] : Has Been Given ("+tempgold+"\00313) From: "+CD->USER.c_str()+".", true, CD->TYPE);
+                if (chr)
+                {
+                    chr->ModifyMoney(addmoney);
+                    Send_Player(chr, MakeMsg("You Have Been Given %s Copper. From: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+                }
+                else
+                    CharacterDatabase.PExecute("UPDATE `characters` SET name=concat(substring_index(name,' ',1462-1),' ','%u',' ', right(name,length(name)-length(substring_index(name,' ',1462))-1)) where guid='%u'",newmoney, guid);
+            }
+    }
+}
+
+void IRCCmd::Mute_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    normalizePlayerName(_PARAMS[0]);
+    uint64 guid = objmgr.GetPlayerGUIDByName(_PARAMS[0]);
+    if (guid)
+    {
+        if (_PARAMS[1] == "release")
+        {
+            Player* plr = objmgr.GetPlayer(guid);
+            uint32 account_id = 0;
+            account_id = objmgr.GetPlayerAccountIdByGUID(guid);
+            LoginDatabase.PExecute("UPDATE `account` SET `mutetime` = '0' WHERE `id` = '%u'", account_id);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been UnMuted By: "+CD->USER+"." , true, CD->TYPE);
+            if (plr)
+            {
+                plr->GetSession()->m_muteTime = 0;
+                Send_Player(plr, MakeMsg("You Have Been UnMuted By: %s.", CD->USER.c_str()));
+            }
+        }
+        else
+        {
+            if (_PARAMS[2] == "")
+                _PARAMS[2] = "No Reason Given";
+            Player* plr = objmgr.GetPlayer(guid);
+            time_t mutetime = time(NULL) + atoi(_PARAMS[1].c_str())*60;
+            uint32 account_id = 0;
+            account_id = objmgr.GetPlayerAccountIdByGUID(guid);
+            if (plr) plr->GetSession()->m_muteTime = mutetime;
+            LoginDatabase.PExecute("UPDATE `account` SET `mutetime` = " UI64FMTD " WHERE `id` = '%u'",uint64(mutetime), account_id);
+            Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Been Muted By: "+CD->USER+". For: "+_PARAMS[1]+" Minutes. Reason: "+_PARAMS[2] , true, CD->TYPE);
+            if (plr) Send_Player(plr, MakeMsg("You Have Been Muted By: %s. For: %s Minutes. Reason: %s", CD->USER.c_str(), _PARAMS[1].c_str(), _PARAMS[2].c_str()));
+        }
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : Player Does Not Exist!", true, "ERROR");
+}
+
+void IRCCmd::Online_Players(_CDATA *CD)
+{
+        sIRC.Script_Lock[MCS_Players_Online] = true;
+        ACE_Based::Thread script(new mcs_OnlinePlayers(CD));
+}
+
+void IRCCmd::PM_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isAcceptWhispers())
+        {
+            std::string sMsg = MakeMsg("|cffFE87FD[<IRC>%s] Whispers: %s|r", CD->USER.c_str(), _PARAMS[1].c_str());
+            WorldPacket data(SMSG_MESSAGECHAT, 200);
+            data << (uint8)CHAT_MSG_SYSTEM;
+            data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)plr->GetGUID();
+            data << (uint32)0;
+            data << (uint64)plr->GetGUID();
+            data << (uint32)(sMsg.length()+1);
+            data << sMsg;
+            data << (uint8)0;
+            plr->GetSession()->SendPacket(&data);
+            plr->SendPlaySound(3081, true);
+            Send_IRCA(ChanOrPM(CD), "\00313To ["+_PARAMS[0]+"] : "+_PARAMS[1]+".", true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : Is Not Accepting Private Messages!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : Player not online!", true, "ERROR");
+}
+
+void IRCCmd::Restart_Oregon(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "cancel")
+    {
+        sWorld.ShutdownCancel();
+        Send_IRCA(ChanOrPM(CD), "\0034Server Restart Has Been Cancelled.", true, CD->TYPE);
+    }
+
+    int32 i_time = atoi(_PARAMS[0].c_str());
+    if (i_time < 0)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Please Enter A Number! And No Negative Numbers! "+_PARAMS[0]+" Seconds!?", true, CD->TYPE);
+        return;
+    }
+    if (i_time > 1)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Requested Server To Restart In "+_PARAMS[0]+" Seconds!", true, CD->TYPE);
+        sWorld.ShutdownServ(i_time,SHUTDOWN_MASK_RESTART, RESTART_EXIT_CODE);
+        Delay(i_time*1000);
+        Send_IRCA(ChanOrPM(CD), "\0034Server Will Now Restart.. Be Back In A Flash!", true, CD->TYPE);
+    }
+}
+
+void IRCCmd::Revive_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (plr->isDead())
+        {
+            plr->ResurrectPlayer(0.5f);
+            plr->SpawnCorpseBones();
+            plr->SaveToDB();
+            sIRC.Send_IRC_Channel(ChanOrPM(CD), " \00313["+_PARAMS[0]+"] : Has Been Revived By: " + CD->USER, true, CD->TYPE);
+            Send_Player(plr, MakeMsg("You Have Been Revived By: %s.", CD->USER.c_str()));
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : "+_PARAMS[0]+" Is Not Dead!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : "+_PARAMS[0]+" Is Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Saveall_Player(_CDATA *CD)
+{
+    ObjectAccessor::Instance().SaveAllPlayers();
+    Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Saved All Players!", true, CD->TYPE);
+}
+
+void IRCCmd::Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    if (_PARAMS[0] == "setmotd")
+    {
+        sWorld.SetMotd(_PARAMS[1]);
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Set New Message Of The Day To: "+_PARAMS[1], true, CD->TYPE);
+    }
+    if (_PARAMS[0] == "flusharenapoints")
+    {
+        sBattleGroundMgr.DistributeArenaPoints();
+    }
+}
+
+void IRCCmd::Shutdown_Oregon(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    if (_PARAMS[0] == "cancel")
+    {
+        sWorld.ShutdownCancel();
+        Send_IRCA(ChanOrPM(CD), "\0034Server Shutdown Has Been Cancelled.", true, CD->TYPE);
+    }
+
+    int32 i_time = atoi(_PARAMS[0].c_str());
+    if (i_time < 0)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Please Enter A Number! And No Negative Numbers! "+_PARAMS[0]+" Seconds!?", true, CD->TYPE);
+        return;
+    }
+    if (i_time > 1)
+    {
+        Send_IRCA(ChanOrPM(CD), "\00313["+CD->USER+"] : Has Requested Server To Be Shut Down In "+_PARAMS[0]+" Seconds!", true, CD->TYPE);
+        sWorld.ShutdownServ(i_time, 0 , SHUTDOWN_EXIT_CODE);
+        Delay(i_time*1000);
+        Send_IRCA(ChanOrPM(CD), "\0034Server Will Now Shut Down.. Good Bye!", true, CD->TYPE);
+    }
+}
+
+void IRCCmd::Spell_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    uint32 spell         = atoi(_PARAMS[2].c_str());
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+        if (spellInfo)
+        {
+            std::string name = spellInfo->SpellName[sWorld.GetDefaultDbcLocale()];
+            if (_PARAMS[1] == "cast")
+            {
+                plr->CastSpell(plr, spell, true);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Had Spell "+name+" Casted On Them.", true, CD->TYPE);
+            }
+            if (_PARAMS[1] == "learn")
+            {
+                plr->learnSpell(spell);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Learned Spell "+name+".", true, CD->TYPE);
+            }
+            if (_PARAMS[1] == "unlearn")
+            {
+                plr->removeSpell(spell);
+                Send_IRCA(ChanOrPM(CD), "\00313["+_PARAMS[0]+"] : Has Unlearned Spell "+name+".", true, CD->TYPE);
+            }
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : Incorrect Spell ID!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : Player Not Online!", true, "ERROR");
+}
+
+void IRCCmd::Sysmsg_Server(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    std::string ircchan = "#";
+    ircchan += sIRC._irc_chan[sIRC.anchn].c_str();
+    if (_PARAMS[0] == "a")
+    {
+        std::string str = _PARAMS[1];
+        std::string ancmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 System Message \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        sWorld.SendWorldText(6610,str.c_str());
+        sIRC.Send_IRC_Channel(ircchan, ancmsg, true);
+    }
+    else if (_PARAMS[0] == "e")
+    {
+        std::string str = _PARAMS[1];
+        std::string notstr = "[Server Event]: " + _PARAMS[1];
+        std::string notmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Server Event \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        WorldPacket data(SMSG_NOTIFICATION, (notstr.size()+1));
+        data << notstr;
+        WorldPacket data2(SMSG_PLAY_SOUND,32);
+        data2 << (uint32)1400;
+        sWorld.SendGlobalMessage(&data2);
+        sWorld.SendGlobalMessage(&data);
+        sWorld.SendWorldText(6611,str.c_str());
+        sIRC.Send_IRC_Channel(ircchan, notmsg, true);
+    }
+    else if (_PARAMS[0] == "n")
+    {
+        std::string str = "Global notify: " + _PARAMS[1];
+        std::string notmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Global Notify \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld.SendGlobalMessage(&data);
+        sIRC.Send_IRC_Channel(ircchan, notmsg, true);
+    }
+    else if (_PARAMS[0] == "gm")
+    {
+        std::string str = "GM Announcement: " + _PARAMS[1];
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld.SendGlobalGMMessage(&data);
+
+    }
+    else if (_PARAMS[0] == "add")
+    {
+        WorldDatabase.PExecute("INSERT INTO autobroadcast (message, addedby, enabled) VALUES ('%s', '%s', %d)", _PARAMS[1].c_str(), CD->USER.c_str(), 1);
+        std::string str = _PARAMS[1];
+        std::string ancmsg = MakeMsg("\00304,08\037/!\\\037\017\00304 Automatic System Message \00304,08\037/!\\\037\017 %s",_PARAMS[1].c_str());
+        sWorld.SendWorldText(6612,str.c_str());
+        sIRC.Send_IRC_Channel(ircchan, ancmsg, true);
+        sWorld.LoadAutobroadcasts();
+    }
+    else if (_PARAMS[0] == "del")
+    {
+        WorldDatabase.PExecute("DELETE FROM autobroadcast WHERE id = %s", _PARAMS[1].c_str());
+        Send_IRCA(ChanOrPM(CD), MakeMsg("Deleted Automatic Announcement Message ID: %s", _PARAMS[1].c_str()), true, CD->TYPE);
+        sWorld.LoadAutobroadcasts();
+    }
+    else if (_PARAMS[0] == "list")
+    {
+        QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT * FROM autobroadcast WHERE enabled = 1 LIMIT 5;", _PARAMS[1].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string id = fields[0].GetCppString();
+                std::string message = fields[1].GetCppString();
+                std::string addedby = fields[2].GetCppString();
+                Send_IRCA(ChanOrPM(CD), MakeMsg("ID: %s - Added By: %s - Message: %s", id.c_str(), addedby.c_str(), message.c_str()), true, CD->TYPE);
+                result->NextRow();
+            }
+            
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : No Auto Announce Messages Are In The Database.", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : Please Use (a-Announce)(n-Notify)(e-Event) As Second Parameter!", true, "ERROR");
+}
+
+void IRCCmd::Tele_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 4);
+    if (AcctLevel(_PARAMS[0]) > GetLevel(CD->USER) && (sIRC.BOTMASK & 512)!= 0)
+    {
+        Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : Nice Try, This Player Has A Higher GM Level Than You! [ %i ]", AcctLevel(_PARAMS[0])), true, "ERROR");
+        return;
+    }
+    bool DoTeleport = false;
+    float pX, pY, pZ, pO = 0;
+    uint32 mapid = 0;
+    std::string rMsg = " \0034[ERROR] : Teleport Failed!";
+    std::string wMsg = "Invalid Tele Location";
+    Player* plr = GetPlayer(_PARAMS[0]);
+    if (plr)
+    {
+        if (plr->isInFlight() || plr->isInCombat())
+        {
+            Send_IRCA(CD->USER, MakeMsg("\0034[ERROR] : %s Is Busy And Cannot Be Teleported! They Could Be In Combat, Or Flying.",_PARAMS[0].c_str()), true, "ERROR");
+            return;
+        }
+    }
+    if (_PARAMS[1] == "l" || _PARAMS[1].size() > 2)
+    {
+        if (_PARAMS[1].size() > 1)
+            _PARAMS[2] = _PARAMS[1];
+        WorldDatabase.escape_string(_PARAMS[2]);
+        QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT position_x, position_y, position_z, orientation, map FROM game_tele WHERE name='%s';", _PARAMS[2].c_str());
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            pX = fields[0].GetFloat();
+            pY = fields[1].GetFloat();
+            pZ = fields[2].GetFloat();
+            pO = fields[3].GetFloat();
+            mapid = fields[4].GetUInt16();
+            
+            rMsg = MakeMsg(" \00313[%s] : Teleported To %s! By: %s.",
+                _PARAMS[0].c_str(),
+                _PARAMS[2].c_str(),
+                CD->USER.c_str());
+            wMsg = MakeMsg("You Have Been Teleported To %s By: %s.",
+                _PARAMS[2].c_str(),
+                CD->USER.c_str());
+            DoTeleport = true;
+        }
+        else
+        {
+            WorldDatabase.escape_string(_PARAMS[2]);
+            QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT name FROM game_tele WHERE name LIKE '%%%s%%' LIMIT 7;", _PARAMS[2].c_str());
+            if (result)
+            {
+                std::string telename = "<> ";
+                for (uint64 i=0; i < result->GetRowCount(); i++)
+                {
+                    Field *fields = result->Fetch();
+                    telename.append(fields[0].GetCppString());
+                    result->NextRow();
+                    telename.append(" <> ");
+                }
+                
+                Send_IRCA(CD->USER, "I Cannot Find Location: "+_PARAMS[2]+" . Perhaps One Of These Will Work For You.", true, "ERROR");
+                Send_IRCA(CD->USER, telename, true, "ERROR");
+                return;
+            }
+            else
+                Send_IRCA(CD->USER, "\0034[ERROR] : Location Not Found! Nothing Even Close Found!", true, "ERROR");
+                return;
+        }
+    }
+    else if (_PARAMS[1] == "c")
+    {
+        std::string* _PARAMSA = getArray(_PARAMS[2], 4);
+        pX = atof(_PARAMSA[1].c_str());
+        pY = atof(_PARAMSA[2].c_str());
+        pZ = atof(_PARAMSA[3].c_str());
+        mapid = atoi(_PARAMSA[0].c_str());
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMSA[0].c_str(),
+            _PARAMSA[1].c_str(),
+            _PARAMSA[2].c_str(),
+            _PARAMSA[3].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Have Been Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+            _PARAMSA[0].c_str(),
+            _PARAMSA[1].c_str(),
+            _PARAMSA[2].c_str(),
+            _PARAMSA[3].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+    }
+    else if (_PARAMS[1] == "r")
+    {
+        if (plr)
+        {
+            pX = plr->m_recallX;
+            pY = plr->m_recallY;
+            pZ = plr->m_recallZ;
+            pO = plr->m_recallO;
+            mapid = plr->m_recallMap;
+            rMsg = MakeMsg(" \00313[%s] : Has Been Recalled To Their Previous Location.",
+                _PARAMS[0].c_str());
+            wMsg = MakeMsg("You Have Been Recalled To Your Previous Location. By: %s",
+                CD->USER.c_str());
+            DoTeleport = true;
+        }
+        else
+        {
+            Send_IRCA(CD->USER, MakeMsg("\00313[%s] : Cannot Be Recalled, They Are Not Online.", _PARAMS[0].c_str()), true, "ERROR");
+            return;
+        }
+
+    }
+    else if (_PARAMS[1] == "to")
+    {
+        Player* plr2 = GetPlayer(_PARAMS[2]);
+        if (plr2)
+        {
+            plr2->GetContactPoint(plr, pX, pY, pZ);
+            mapid = plr2->GetMapId();
+        }
+        else
+        {
+            if (uint64 guid = objmgr.GetPlayerGUIDByName(_PARAMS[2].c_str()))
+            {
+                bool in_flight;
+                Player::LoadPositionFromDB(mapid, pX, pY, pZ, pO, in_flight, guid);
+            }
+            else
+            {
+                Send_IRCA(CD->USER, "\0034[ERROR] : Second Player Not Found!", true, "ERROR");
+                return;
+            }
+        }
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Player: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+    }
+    else if (_PARAMS[1] == "cr")
+    {
+      QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map FROM creature WHERE guid ='%s' LIMIT 1", _PARAMS[2].c_str());
+      if (!result)
+      {
+          Send_IRCA(CD->USER, "\0034[ERROR] : Creature GUID not found", true, "ERROR");
+      }
+      else
+      {
+        Field *fields = result->Fetch();
+        pX = fields[0].GetFloat();
+        pY = fields[1].GetFloat();
+        pZ = fields[2].GetFloat();
+        pO = fields[3].GetFloat();
+        mapid = fields[4].GetUInt16();
+
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Creature: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+        
+      }
+    }
+    else if (_PARAMS[1] == "go")
+    {
+      QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map FROM gameobject WHERE guid ='%s' LIMIT 1", _PARAMS[2].c_str());
+      if (!result)
+      {
+          Send_IRCA(CD->USER, "\0034[ERROR] : GO GUID not found", true, "ERROR");
+      }
+      else
+      {
+        Field *fields = result->Fetch();
+        pX = fields[0].GetFloat();
+        pY = fields[1].GetFloat();
+        pZ = fields[2].GetFloat();
+        pO = fields[3].GetFloat();
+        mapid = fields[4].GetUInt16();
+
+        rMsg = MakeMsg(" \00313[%s] : Teleported To Gameobject: [%s] By: %s.",
+            _PARAMS[0].c_str(),
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+            _PARAMS[2].c_str(),
+            CD->USER.c_str());
+        DoTeleport = true;
+        
+      }
+    }
+    else if (_PARAMS[1] == "homebind")
+    {
+        QueryResult_AutoPtr result = CharacterDatabase.PQuery("SELECT position_x,position_y,position_z,map FROM `character_homebind` WHERE guid = '%d'", plr->GetGUID());
+        if (!result)
+        {
+          Send_IRCA(CD->USER, "\0034[ERROR] : Unexpected Error Loading Homebind Location", true, "ERROR");
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            pX = fields[0].GetFloat();
+            pY = fields[1].GetFloat();
+            pZ = fields[2].GetFloat();
+            pO = 1;
+            mapid = fields[3].GetUInt16();
+
+            rMsg = MakeMsg(" \00313[%s] : Teleported To Homebind Location By: %s.",
+                _PARAMS[0].c_str(),
+                CD->USER.c_str());
+            wMsg = MakeMsg("You Are Being Teleported To Your Homebind Location By: %s.",
+            CD->USER.c_str());
+            DoTeleport = true;
+            
+        }
+
+    }
+    if (DoTeleport)
+    {
+        if (MapManager::IsValidMapCoord(mapid, pX ,pY ,pZ))
+        {
+                //if player is online teleport them in real time, if not set the DB to our coordinates.
+                if (plr)
+                {
+                    plr->SaveRecallPosition();
+                    plr->TeleportTo(mapid, pX, pY, pZ, pO);
+                    sIRC.Send_IRC_Channel(ChanOrPM(CD), rMsg, true, CD->TYPE);
+                    Send_Player(plr, wMsg);
+                }
+                else
+                {
+                    uint64 guid = objmgr.GetPlayerGUIDByName(_PARAMS[0]);
+                    Player::SavePositionInDB(mapid,pX,pY,pZ,pO,MapManager::Instance().GetZoneId(mapid,pX,pY,pZ),guid);
+                    sIRC.Send_IRC_Channel(ChanOrPM(CD), rMsg + " \0034*Offline Tele.* ", true, CD->TYPE);
+                }
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : Invalid Location!", true, "ERROR");
+    }
+    else
+        Send_IRCA(CD->USER, "\0034[ERROR] : Invalid Paramaters, Please Try Again [ "+sIRC._cmd_prefx+"help tele ] For More Information. ", true, "ERROR");
+}
+
+void IRCCmd::Top_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    uint32 limitr = 10;
+    if (atoi(_PARAMS[1].c_str()) > 0 && GetLevel(CD->USER) >= sIRC._op_gm_lev)
+        limitr = atoi(_PARAMS[1].c_str());
+    if (_PARAMS[0] == "accttime")
+    {
+        QueryResult_AutoPtr result = CharacterDatabase.PQuery("SELECT account, name, (SUM(totaltime)) AS combinetime FROM characters GROUP BY account ORDER BY combinetime DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Accounts By Played Time:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                uint32 account = fields[0].GetUInt32();
+                std::string PlName = GetAcctNameFromID(account);
+                std::string Time = SecToDay(fields[2].GetCppString());
+                uint32 rank = i+1;
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, PlName.c_str(), Time.c_str()));
+                result->NextRow();
+            }
+            
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : No Accounts Returned." ,true, "ERROR");
+    }
+    if (_PARAMS[0] == "chartime")
+    {
+        QueryResult_AutoPtr result = CharacterDatabase.PQuery("SELECT name, totaltime FROM characters ORDER BY totaltime DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Characters By Played Time:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string Name = fields[0].GetCppString();
+                std::string Time = SecToDay(fields[1].GetCppString());
+                uint32 rank = i+1;
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, Name.c_str(), Time.c_str()));
+                result->NextRow();
+            }
+            
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : No Characters Returned." ,true, "ERROR");
+    }
+    if (_PARAMS[0] == "money")
+    {
+        QueryResult_AutoPtr result = CharacterDatabase.PQuery("SELECT name, money FROM characters ORDER BY money DESC LIMIT 0, %d ", limitr);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            std::string tptime = MakeMsg("\x2 Top%d Characters By Money:\x3\x31\x30 ", limitr);
+            for (uint64 i=0; i < result->GetRowCount(); i++)
+            {
+                std::string Name = fields[0].GetCppString();
+                unsigned int money = fields[1].GetInt32();
+
+                uint32 rank = i+1;
+
+                unsigned int gold = money / 10000;
+                unsigned int silv = (money % 10000) / 100;
+                unsigned int cop = (money % 10000) % 100;
+                char tempgold [100];
+                sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+
+                tptime.append(MakeMsg("[%u]%s %s \xF| \x3\x31\x30\x2", rank, Name.c_str(), tempgold));
+                result->NextRow();
+            }
+            
+            Send_IRCA(ChanOrPM(CD), tptime, true, CD->TYPE);
+        }
+        else
+            Send_IRCA(CD->USER, "\0034[ERROR] : No Characters Returned." ,true, "ERROR");
+    }
+
+}
+
+void IRCCmd::Who_Logged(_CDATA *CD)
+{
+    std::string OPS = "";
+    for (std::list<_client*>::iterator i=_CLIENTS.begin(); i!=_CLIENTS.end();i++)
+    {
+        OPS.append(MakeMsg(" \002[GM:%d IRC: %s - WoW: %s]\002 ", (*i)->GMLevel, (*i)->Name.c_str(), (*i)->UName.c_str()));
+    }
+    Send_IRCA(ChanOrPM(CD), OPS, true, CD->TYPE);
+}
diff -Nuar oregoncore-current/src/irc/IRCCmd.h oregoncore-pq/src/irc/IRCCmd.h
--- oregoncore-current/src/irc/IRCCmd.h	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/IRCCmd.h	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CMD_H
+#define _IRC_CMD_H
+
+#define MAX_CLIENTS 50
+#include "Common.h"
+#include "Player.h"
+#include "ObjectAccessor.h"
+#include "BattleGroundMgr.h"
+
+struct ChannelUser
+{
+    int UserType;
+    std::string Name;
+    std::string UName;
+    int UserLevel;
+};
+
+struct _client
+{
+    bool        LoggedIn;
+    std::string Name;
+    std::string UName;
+    int         GMLevel;
+};
+struct _CDATA
+{
+    std::string CMD;
+    std::string USER;
+    std::string FROM;
+    std::string PARAMS;
+    std::string TYPE;
+    int PCOUNT;
+};
+enum APVERR
+{
+    E_OK,
+    E_SIZE,
+    E_AUTH,
+    E_IVALID,
+};
+enum ESOUNDS
+{
+    S_ENTERWORLD    = 602,
+    S_QUESTFAILED   = 847,
+    S_INVITE        = 880,
+    S_LEVELUP       = 888,
+    S_COINSOUND     = 895,
+    S_WHISPER       = 3081,
+    S_STEALTH       = 3325,
+};
+class IRCCmd
+{
+    public:
+        IRCCmd();
+        ~IRCCmd();
+        
+        void    Handle_Logout(_CDATA *CD);
+        bool    IsLoggedIn(std::string USER);
+        bool    IsValid(std::string USER, std::string FROM, std::string CHAT, std::string TYPE);
+        bool    AcctIsLoggedIn(std::string USER);
+        _client *GetClient(std::string cname);
+
+    public:
+        static std::string MakeMsg(const char *sLine, ...);
+        static std::string ChanOrPM(_CDATA *CD);
+        int AcctLevel(std::string plnme);
+        int GetLevel(std::string sName);
+        std::string MakeUpper(std::string Channel);
+        std::string  AcctIsBanned(std::string ACCT);
+        std::list<_client*> _CLIENTS;
+        Player* GetPlayer(std::string WHO);
+
+    private:
+        // OCChat Commands
+        void    Handle_Login(_CDATA *CD);
+        void    Account_Player(_CDATA *CD);
+        void    Ban_Player(_CDATA *CD);
+        void    Chan_Control(_CDATA *CD);
+        void    Char_Player(_CDATA *CD);
+        void    Fun_Player(_CDATA *CD);
+        void    Help_IRC(_CDATA *CD);
+        void    Item_Player(_CDATA *CD);
+        void    Inchan_Server(_CDATA *CD);
+        void    Info_Server(_CDATA *CD);
+        void    Jail_Player(_CDATA *CD);
+        void    Kick_Player(_CDATA *CD);
+        void    Kill_Player(_CDATA *CD);
+        void    Level_Player(_CDATA *CD);
+        void    Lookup_Player(_CDATA *CD);
+        void    Money_Player(_CDATA *CD);
+        void    Mute_Player(_CDATA *CD);
+        void    Online_Players(_CDATA *CD);
+        void    PM_Player(_CDATA *CD);
+        void    Revive_Player(_CDATA *CD);
+        void    Saveall_Player(_CDATA *CD);
+        void    Server(_CDATA *CD);
+        void    Shutdown_Oregon(_CDATA *CD);
+        void    Restart_Oregon(_CDATA *CD);
+        void    Spell_Player(_CDATA *CD);
+        void    Sysmsg_Server(_CDATA *CD);
+        void    Tele_Player(_CDATA *CD);
+        void    Top_Player(_CDATA *CD);
+        void    Who_Logged(_CDATA *CD);
+        bool    CanUse(std::string USER, int nLevel);
+        bool    ValidParams(std::string PARAMS, int nCount = 1);
+        bool    ParamsValid(_CDATA *CD, int pCnt);
+        int     ParamsValid(_CDATA *CD, int pCnt, int rLev);
+        std::string GetAccName(std::string sName);
+        std::string GetNameFromAcct(std::string sName);
+        std::string GetAcctNameFromID(uint32 acctid);
+        std::string GetIPFromPlayer(std::string player);
+        std::string SecToDay(std::string secons);
+        int GetAcctIDFromName(std::string sName);
+        std::string* getArray(std::string PARAMS, int nCount = 1);
+};
+inline void MakeLower(std::string& str)
+{
+    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
+}
+#endif
diff -Nuar oregoncore-current/src/irc/IRCFunc.h oregoncore-pq/src/irc/IRCFunc.h
--- oregoncore-current/src/irc/IRCFunc.h	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/IRCFunc.h	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_FUNC
+#define _IRC_CLIENT_FUNC
+
+std::string GetUser(std::string szU)
+{
+    int pos = szU.find("!");
+    return szU.substr(0, pos);
+}
+// Delink will remove anything considered "non chat" from a string
+std::string Delink(std::string msg)
+{
+    std::size_t pos;
+    
+        while((pos = msg.find("|Htrade")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hglyph")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hitem")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+         std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Henchant")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+        //msg.replace(find2, 2, "\x2");
+    }
+    while((pos = msg.find("|Hquest")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+         std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hspell")) != std::string::npos)
+    {
+         std::size_t find1 = msg.find("|h", pos);
+         std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Htalent")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        std::size_t find2 = msg.find("|h", find1 + 2);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Hachievement")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    while((pos = msg.find("|Htrade")) != std::string::npos)
+    {
+        std::size_t find1 = msg.find("|h", pos);
+        msg.replace(pos, find1 - pos + 2, "\x2");
+        msg.replace(msg.find("|h", pos), 2, "\x2");
+    }
+    return msg;
+}
+
+// This function converts the characters used by the client to identify colour to IRC format.
+std::string WoWcol2IRC(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[17][6] = { "\xF", "\xF", "\x3\x31\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x34", "\x3\x31\x34", "\x3\x31\x32", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x31\x32", "\x3\x30\x37"};
+    char WoWCol[17][12] = { "|r", "|cffffffff", "|cff9d9d9d", "|cff1eff00", "|cff0070dd", "|cffa335ee", "|cffff8000", "|cffe6cc80", "|cffffd000", "|cff808080", "|cff71d5ff", "|cffffff00", "|cffff2020", "|cff40c040", "|cff4e96f7", "|cff71d5ff", "|cffff8040"};
+    for (int i=0; i<=15; i++)
+    {
+        while ((pos = msg.find(WoWCol[i])) != std::string::npos)
+        {
+            if (i == 0)
+                msg.replace(pos, 2, IRCCol[i]);
+            else
+                msg.replace(pos, 11, IRCCol[i]);
+        }
+    }
+    return msg;
+}
+
+// This function converts the characters used by IRC to identify colour to a format the client can understand.
+std::string IRCcol2WoW(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[18][4] = { "\x3\x30", "\x3\x31", "\x3\x32", "\x3\x33", "\x3\x34", "\x3\x35", "\x3\x36", "\x3\x37", "\x3\x38", "\x3\x39", "\x3\x31\x30", "\x3\x31\x31", "\x3\x31\x32", "\x3\x31\x33", "\x3\x31\x34", "\x3\x31\x35", "\x3\x30\x37", "\x3\x30\x37"};
+    char IRCCol2[10][4] = { "\x3\x30\x30", "\x3\x30\x31", "\x3\x30\x32", "\x3\x30\x33", "\x3\x30\x34", "\x3\x30\x35", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x38", "\x3\x30\x39"};
+    char WoWcol[18][12] = { "|cffffffff", "|cff000000", "|cff00007f", "|cff009300", "|cffff0000", "|cff7f0000", "|cff9c009c", "|cfffc9300", "|cffffff00", "|cff00fc00", "|cff009393", "|cff00ffff", "|cff0000fc", "|cffff00ff", "|cff7f7f7f", "|cffd2d2d2", "|cff808080", "|cff71d5ff"};
+    for (int i=15; i>=0; i--)
+    {
+        if (i<10)
+        {
+            while ((pos = msg.find(IRCCol2[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 2, WoWcol[i]);
+            }
+
+        }
+        else
+        {
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+        }
+
+        // Remove Bold, Reverse, Underline from IRC
+        char Checker[3][3] = {"\x2","\x16","\x1F"}; // This is the Hex part not Dec. In Decimal its (2,22,31)
+        for (int I=0; I < 3; I++)
+        {
+            while ((pos = msg.find(Checker[I])) != std::string::npos)
+            {    
+                msg.replace(pos, 1, "");
+            }
+        }
+        // Finished Removing !
+
+    }
+
+    while ((pos = msg.find("\x3")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+    while ((pos = msg.find("\xF")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+
+    return msg;
+}
+
+// This function compares 2 strings
+int nocase_cmp(const string & s1, const string& s2)
+{
+    string::const_iterator it1=s1.begin();
+    string::const_iterator it2=s2.begin();
+
+    //stop when either string's end has been reached
+    while ((it1!=s1.end()) && (it2!=s2.end()))
+    {
+        if (::toupper(*it1) != ::toupper(*it2))              //letters differ?
+            // return -1 to indicate smaller than, 1 otherwise
+            return (::toupper(*it1)  < ::toupper(*it2)) ? -1 : 1;
+        //proceed to the next character in each string
+        ++it1;
+        ++it2;
+    }
+    size_t size1=s1.size(), size2=s2.size();                // cache lengths
+    //return -1,0 or 1 according to strings' lengths
+    if (size1==size2)
+        return 0;
+    return (size1<size2) ? -1 : 1;
+}
+
+std::string MakeMsgA(const char *sLine, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, sLine);
+    vsnprintf(tmpoutp, 1024, sLine, ap);
+    va_end(ap);
+    std::string outp = tmpoutp;
+    return outp;
+}
+
+std::string MakeMsgP(int CLINE, std::string Msg, Player *plr)
+{
+    std::string sMsg = sIRC.MakeMsg(sIRC.GetChatLine(CLINE), "$Msg", Msg);
+    if (plr->GetTeam() == 67)
+        sMsg = sIRC.MakeMsg(sMsg, "$Name", MakeMsgA("\0034%s\003", plr->GetName()));
+    else if (plr->GetTeam() == 469)
+        sMsg = sIRC.MakeMsg(sMsg, "$Name", MakeMsgA("\00312%s\003", plr->GetName()));
+    if (plr->isAFK())
+        sMsg = sIRC.MakeMsg(sMsg, "$Tag", "<AFK>");
+    else if (plr->isDND())
+        sMsg = sIRC.MakeMsg(sMsg, "$Tag", "<DND>");
+    else
+        sMsg = sIRC.MakeMsg(sMsg, "$Tag", "");
+    sMsg = sIRC.MakeMsg(sMsg, "$Level", MakeMsgA("%d", plr->getLevel()));
+    sMsg = Delink(sMsg);
+    sMsg = WoWcol2IRC(sMsg);
+    return sMsg;
+}
+
+// This function checks if a channel exists in out configuration
+// OCChat supports as many channels as you like
+bool Channel_Valid(std::string Channel)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+    {
+        if (nocase_cmp(sIRC._wow_chan[i], Channel)==0)
+            return true;
+    }
+    return false;
+}
+
+std::string GetWoWChannel(std::string Channel)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+    {
+        if ("#" + sIRC._irc_chan[i] == Channel)
+            return sIRC._wow_chan[i];
+    }
+    return "";
+}
+
+std::string GetIRCChannel(std::string Channel)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+    {
+        if (sIRC._wow_chan[i] == Channel)
+            return sIRC._irc_chan[i];
+    }
+    return "";
+}
+
+std::string* getArray(std::string PARAMS, int nCount, std::string)
+{
+    std::string *array = new std::string[nCount];
+    if (PARAMS.size() > 0)
+    {
+        int pcnt = 0;
+        size_t ps = 0;
+        size_t pc = -1;
+        for (int i = 0;i < nCount;i++)
+        {
+            pc = PARAMS.find(" ", pc + 1);
+            if (i + 1 == nCount && nCount != 1)
+            {
+                if (ps > 0 && pc > 0)
+                    array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+            }
+            else
+                array[i] = PARAMS.substr(ps, pc - ps);
+            ps = pc + 1;
+        }
+    }
+    return array;
+}
+#endif
diff -Nuar oregoncore-current/src/irc/IRCIO.cpp oregoncore-pq/src/irc/IRCIO.cpp
--- oregoncore-current/src/irc/IRCIO.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/IRCIO.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,470 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#include "IRCCmd.h"
+#include "IRCFunc.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "ChannelMgr.h"
+#include "Config/Config.h"
+#include "Channel.h"
+#include "World.h"
+
+IRCCmd Command;
+void IRCClient::Handle_IRC(std::string sData)
+{
+    sLog.outDebug(sData.c_str());
+    // If first 5 chars are ERROR then something is wrong
+    // either link is being closed, nickserv ghost command, etc...
+    if (sData.substr(0, 5) == "ERROR")
+    {
+        Disconnect();
+        return;
+    }
+    if (sData.substr(0, 4) == "PING")
+    {
+        // if the first 4 characters contain PING
+        // the server is checking if we are still alive
+        // sen back PONG back plus whatever the server send with it
+        SendIRC("PONG " + sData.substr(4, sData.size() - 4));
+    }
+    else
+    {
+        // if the first line contains : its an irc message
+        // such as private messages channel join etc.
+        if (sData.substr(0, 1) == ":")
+        {
+            // find the spaces in the receieved line
+            size_t p1 = sData.find(" ");
+            size_t p2 = sData.find(" ", p1 + 1);
+            // because the irc protocol uses simple spaces
+            // to seperate data we can easy pick them out
+            // since we know the position of the spaces
+            std::string USR = sData.substr(1, p1 - 1);
+            std::string CMD = sData.substr(p1 + 1, p2 - p1 - 1);
+            // trasform the commands to lowercase to make sure they always match
+            std::transform(CMD.begin(), CMD.end(), CMD.begin(), towlower);
+            // Extract the username from the first part
+            std::string szUser = GetUser(USR);
+            // if we receieved the internet connect code
+            // we know for sure that were in and we can
+            // authenticate ourself.
+            if (CMD == sIRC._ICC)
+            {
+                // _Auth is defined in oregoncore.conf (irc.auth)
+                // 0 do not authenticate
+                // 1 use nickserv
+                // 2 use quakenet
+                // aditionally you can provide you own authentication method here
+                switch(sIRC._Auth)
+                {
+                    case 1:
+                        SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC._Pass);
+                        break;
+                    case 2:
+                        SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC._Auth_Nick + " " + sIRC._Pass);
+                        break;
+                    case 3:
+                        SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC._Nick + " " + sIRC._Pass);
+                        break;
+                    case 4:
+                        SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC._Auth_Nick + " " + sIRC._Pass);
+                        break;
+                }
+                // if we join a default channel leave this now.
+                if (sIRC._ldefc==1)
+                    SendIRC("PART #" + sIRC._defchan);
+                // Loop thru the channel array and send a command to join them on IRC.
+                for (int i=1;i < sIRC._chan_count + 1;i++)
+                {
+                        if (sIRC._irc_pass[i].size() > 0)
+                                SendIRC("JOIN #" + sIRC._irc_chan[i] + " " + sIRC._irc_pass[i]);
+                        else
+                        SendIRC("JOIN #" + sIRC._irc_chan[i]);
+                }
+                // See if there's a logchannel available, if so: join it.
+                if (sIRC.logchan.size() > 0)
+                {
+                    if (sIRC.logchanpw.size() > 0)
+                        SendIRC("JOIN #" + sIRC.logchan + " " + sIRC.logchanpw);
+                    else
+                        SendIRC("JOIN #" + sIRC.logchan);
+                }
+            }
+            // someone joined the channel this could be the bot or another user
+            if (CMD == "join")
+            {
+                size_t p = sData.find(":", p1);
+                std::string CHAN = sData.substr(p + 1, sData.size() - p - 2);
+                // if the user is us it means we join the channel
+                if ((szUser == sIRC._Nick))
+                {
+                    // its us that joined the channel
+                    Send_IRC_Channel(CHAN, MakeMsg(MakeMsg(sIRC.JoinMsg, "$Ver", sIRC._Mver.c_str()), "$Trigger", sIRC._cmd_prefx.c_str()), true);
+                }
+                else
+                {
+                    // if the user is not us its someone else that joins
+                    // so we construct a message and send this to the clients.
+                    // OCChat now uses Send_WoW_Channel to send to the client
+                    // this makes OCChat handle the packets instead of previously the world.
+                    if ((sIRC.BOTMASK & 2) != 0)
+                        Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(JOIN_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+                }
+            }
+            // someone on irc left or quit the channel
+            if (CMD == "part" || CMD == "quit")
+            {
+                size_t p3 = sData.find(" ", p2 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                // Logout IRC Nick From OCChat If User Leaves Or Quits IRC.
+                if (Command.IsLoggedIn(szUser))
+                {
+                    _CDATA CDATA;
+                    CDATA.USER      = szUser;
+                    Command.Handle_Logout(&CDATA);
+                }
+                // Construct a message and inform the clients on the same channel.
+                if ((sIRC.BOTMASK & 2) != 0)
+                    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(LEAVE_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+            }
+            // someone changed their nick
+            if (CMD == "nick" && (sIRC.BOTMASK & 128) != 0)
+            {
+                MakeMsg(MakeMsg(GetChatLine(CHANGE_NICK), "$Name", szUser), "$NewName", sData.substr(sData.find(":", p2) + 1));
+                // If the user is logged in and changes their nick 
+                // then we want to either log them out or update 
+                // their nick in the bot. I chose to update the bots user list.
+                if (Command.IsLoggedIn(szUser))
+                {
+                    std::string NewNick = sData.substr(sData.find(":", p2) + 1);
+                    // On freenode I noticed the server sends an extra character
+                    // at the end of the string, so we need to erase the last
+                    // character of the string. if you have a problem with getting
+                    // the last letter of your nick erased, then remove the - 1.
+                    NewNick.erase(NewNick.length() - 1, 1);
+
+                    for (std::list<_client*>::iterator i=Command._CLIENTS.begin(); i!=Command._CLIENTS.end();i++)
+                    {
+                        if ((*i)->Name == szUser)
+                        {
+                            (*i)->Name     = NewNick;
+                            sIRC.Send_IRC_Channel(NewNick.c_str(), "I Noticed You Changed Your Nick, I Have Updated My Internal Database Accordingly.", true, "NOTICE");
+                            
+                            // Figure why not output to the logfile, makes tracing problems easier.
+                            sIRC.iLog.WriteLog(" %s : %s Changed Nick To: %s", sIRC.iLog.GetLogDateTimeStr().c_str(), szUser.c_str(), NewNick.c_str());
+                        }
+                    }
+                }
+
+            }
+            // someone was kicked from irc
+            if (CMD == "kick")
+            {
+                // extract the details
+                size_t p3 = sData.find(" ", p2 + 1);
+                size_t p4 = sData.find(" ", p3 + 1);
+                size_t p5 = sData.find(":", p4);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                std::string WHO = sData.substr(p3 + 1, p4 - p3 - 1);
+                std::string BY = sData.substr(p4 + 1, sData.size() - p4 - 1);
+                // if the one kicked was us
+                if (WHO == sIRC._Nick)
+                {
+                    // and autojoin is enabled
+                    // return to the channel
+                    if (sIRC._autojoinkick == 1)
+                    {
+                        SendIRC("JOIN " + CHAN);
+                        Send_IRC_Channel(CHAN, sIRC.kikmsg, true);
+                    }
+                }
+                else
+                {
+                    // if it is not us who was kicked we need to inform the clients someone
+                    // was removed from the channel
+                    // construct a message and send it to the players.
+                    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), "<IRC>[" + WHO + "]: Was Kicked From " + CHAN + " By: " + szUser);
+                }
+            }
+            // a private chat message was receieved.
+            if (CMD == "privmsg" || CMD == "notice")
+            {
+                // extract the values
+                size_t p = sData.find(" ", p2 + 1);
+                std::string FROM = sData.substr(p2 + 1, p - p2 - 1);
+                std::string CHAT = sData.substr(p + 2, sData.size() - p - 3);
+                // if this is our username it means we recieved a PM
+                if (FROM == sIRC._Nick)
+                {
+                    if (CHAT.find("\001VERSION\001") < CHAT.size())
+                    {
+                        Send_IRC_Channel(szUser, MakeMsg("\001VERSION OCChat %s\001", "%s" , sIRC._Mver.c_str()), true, "PRIVMSG");
+                    }
+                    // a pm is required for certain commands
+                    // such as login. to validate the command
+                    // we send it to the command class wich handles
+                    // evrything else.
+                    Command.IsValid(szUser, FROM, CHAT, CMD);
+                }
+                else
+                {
+                    // if our name is not in it, it means we receieved chat on one of the channels
+                    // magchat is in. the first thing we do is check if it is a command or not
+                    if (!Command.IsValid(szUser, FROM, CHAT, CMD))
+                    {
+                        Send_WoW_Channel(GetWoWChannel(FROM).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(IRC_WOW), "$Name", szUser), "$Msg", CHAT)));
+                    }
+                    // if we indeed receieved a command we do not want to display this to the players
+                    // so only incanse the isvalid command returns false it will be sent to all player.
+                    // the isvalid function will automaitcly process the command on true.
+                }
+            }
+            if (CMD == "mode")
+            {
+                // extract the mode details
+                size_t p3 = sData.find(" ", p2 + 1);
+                size_t p4 = sData.find(" ", p3 + 1);
+                size_t p5 = sData.find(" ", p4 + 1);
+                std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+                std::string MODE = sData.substr(p3 + 1, p4 - p3 - 1);
+                std::string NICK = sData.substr(p4 + 1, p5 - p4 - 1);
+                bool _AmiOp;
+                _AmiOp = false;
+                //A mode was changed on us
+                if (NICK.c_str() == sIRC._Nick)
+                    _AmiOp = true;
+
+            }
+        }
+    }
+}
+
+// This function is called in Channel.h
+// based on nAction it will inform the people on
+// irc when someone leaves one of the game channels.
+// nAction is based on the struct CACTION
+void IRCClient::Handle_WoW_Channel(std::string Channel, Player *plr, int nAction)
+{
+    // make sure that we are connected
+    if (sIRC.Connected && (sIRC.BOTMASK & 1)!= 0)
+    {
+        if (Channel_Valid(Channel))
+        {
+            std::string GMRank = "";
+            std::string pname = plr->GetName();
+            bool DoGMAnnounce = false;
+            if (plr->GetSession()->GetSecurity() > 0 && (sIRC.BOTMASK & 8)!= 0)
+                DoGMAnnounce = true;
+            if (plr->isGameMaster() && (sIRC.BOTMASK & 16)!= 0)
+                DoGMAnnounce = true;
+            if (DoGMAnnounce)
+            {
+                switch(plr->GetSession()->GetSecurity())    //switch case to determine what rank the "gm" is
+                {
+                    case 0: GMRank = "";break;
+                    case 1: GMRank = "\0037"+sIRC.ojGM1;break;
+                    case 2: GMRank = "\0037"+sIRC.ojGM2;break;
+                    case 3: GMRank = "\0037"+sIRC.ojGM3;break;
+                    case 4: GMRank = "\0037"+sIRC.ojGM4;break;
+                    case 5: GMRank = "\0037"+sIRC.ojGM5;break;
+	 	     case 6: GMRank = "\0037"+sIRC.ojGM6;break;
+		     case 7: GMRank = "\0037"+sIRC.ojGM7;break;
+		     case 8: GMRank = "\0037"+sIRC.ojGM8;break;
+                }
+            }
+            std::string ChatTag = "";
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("\0034");break;      //horde
+                case 469:ChatTag.append("\00312");break;    //alliance
+            }
+            std::string query = "INSERT INTO `irc_inchan` VALUES (%d,'"+pname+"','"+Channel+"')";
+            std::string lchan = "DELETE FROM `irc_inchan` WHERE `guid` = %d AND `channel` = '"+Channel+"'";
+            switch(nAction)
+            {
+                case CHANNEL_JOIN:
+                    Send_IRC_Channel(GetIRCChannel(Channel), MakeMsg(MakeMsg(MakeMsg(GetChatLine(JOIN_WOW), "$Name", ChatTag + plr->GetName()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+                    WorldDatabase.PExecute(query.c_str(), plr->GetGUID());
+                    break;
+                case CHANNEL_LEAVE:
+                    Send_IRC_Channel(GetIRCChannel(Channel), MakeMsg(MakeMsg(MakeMsg(GetChatLine(LEAVE_WOW), "$Name", ChatTag + plr->GetName()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+                    break;
+            }
+        }
+    }
+}
+
+// This function sends chat to a irc channel or user
+// to prevent the # beeing appended to send a msg to a user
+// set the NoPrefix to true
+void IRCClient::Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix, std::string nType)
+{
+    std::string mType = "PRIVMSG";
+    if (Command.MakeUpper(nType.c_str()) == "NOTICE")
+        mType = "NOTICE";
+    if (Command.MakeUpper(nType.c_str()) == "ERROR" && (sIRC.BOTMASK & 32)!= 0)
+        mType = "NOTICE";
+    if (sIRC.Connected)
+    {
+        if (NoPrefix)
+            SendIRC(mType + " " + sChannel + " :" + sMsg);
+        else
+            SendIRC(mType + " #" + sChannel + " :" + sMsg);
+    }
+}
+
+// This function sends a message to all irc channels
+// that OCChat has in its configuration
+void IRCClient::Send_IRC_Channels(std::string sMsg)
+{
+    for (int i=1;i < sIRC._chan_count + 1;i++)
+        Send_IRC_Channel(sIRC._irc_chan[i], sMsg);
+}
+
+// This function is called in ChatHandler.cpp, any channel chat from wow will come
+// to this function, validates the channel and constructs a message that is send to IRC
+void IRCClient::Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg)
+{
+    // Check if the channel exist in our configuration
+    if (Channel_Valid(Channel) && Msg.substr(0, 1) != ".")
+        Send_IRC_Channel(GetIRCChannel(Channel), MakeMsgP(WOW_IRC, Msg, plr));
+}
+
+void IRCClient::Send_WoW_Player(std::string sPlayer, std::string sMsg)
+{
+    normalizePlayerName(sPlayer);
+    if (Player* plr = ObjectAccessor::Instance().FindPlayerByName(sPlayer.c_str()))
+        Send_WoW_Player(plr, sMsg);
+}
+
+void IRCClient::Send_WoW_Player(Player *plr, string sMsg)
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    data << (uint8)CHAT_MSG_SYSTEM;
+    data << (uint32)LANG_UNIVERSAL;
+    data << (uint64)plr->GetGUID();
+    data << (uint32)0;
+    data << (uint64)plr->GetGUID();
+    data << (uint32)(sMsg.length()+1);
+    data << sMsg;
+    data << (uint8)0;
+    plr->GetSession()->SendPacket(&data);
+}
+
+// This function will construct and send a packet to all players
+// on the given channel ingame. (previuosly found in world.cpp)
+// it loops thru all sessions and checks if they are on the channel
+// if so construct a packet and send it.
+void IRCClient::Send_WoW_Channel(const char *channel, std::string chat)
+{
+    if (!(strlen(channel) > 0))
+        return;
+
+    #ifdef USE_UTF8
+        std::string chat2 = chat;
+        if (ConvertUTF8(chat2.c_str(), chat2))
+            chat = chat2;
+    #endif
+
+    HashMapHolder<Player>::MapType& m = ObjectAccessor::Instance().GetPlayers();
+    for (HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            if (ChannelMgr* cMgr = channelMgr(itr->second->GetSession()->GetPlayer()->GetTeam()))
+            {
+                if (Channel *chn = cMgr->GetChannel(channel, itr->second->GetSession()->GetPlayer()))
+                {
+                    WorldPacket data;
+                    data.Initialize(SMSG_MESSAGECHAT);
+                    data << (uint8)CHAT_MSG_CHANNEL;
+                    data << (uint32)LANG_UNIVERSAL;
+                    data << (uint64)0;
+                    data << (uint32)0;
+                    data << channel;
+                    data << (uint64)0;
+                    data << (uint32) (strlen(chat.c_str()) + 1);
+                    data << IRCcol2WoW(chat.c_str());
+                    data << (uint8)0;
+                    itr->second->GetSession()->SendPacket(&data);
+                }
+            }
+        }
+    }
+}
+
+void IRCClient::Send_WoW_System(std::string Message)
+{
+    HashMapHolder<Player>::MapType& m = ObjectAccessor::Instance().GetPlayers();
+    for (HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            WorldPacket data;
+            data.Initialize(CHAT_MSG_SYSTEM);
+            data << (uint8)CHAT_MSG_SYSTEM;
+            data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)0;
+            data << (uint32)0;
+            data << (uint64)0;
+            data << (uint32) (strlen(Message.c_str()) + 1);
+            data << Message.c_str();
+            data << (uint8)0;
+            itr->second->GetSession()->SendPacket(&data);
+        }
+    }
+}
+void IRCClient::ResetIRC()
+{
+    SendData("QUIT");
+    Disconnect();
+}
+
+#define CHAT_INVITE_NOTICE 0x18
+
+// this function should be called on player login Player::AddToWorld
+void IRCClient::AutoJoinChannel(Player *plr)
+{
+    //this will work if at least 1 player is logged in regrdless if he is on the channel or not
+    // the first person that login empty server is the one with bad luck and wont be invited, 
+    // if at least 1 player is online the player will be inited to the chanel
+
+    std::string m_name = sIRC.ajchan;
+    WorldPacket data;
+    data.Initialize(SMSG_CHANNEL_NOTIFY, 1+m_name.size()+1);
+    data << uint8(CHAT_INVITE_NOTICE);
+    data << m_name.c_str();
+
+    HashMapHolder<Player>::MapType& m = ObjectAccessor::Instance().GetPlayers();
+    for (HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            data << uint64(itr->second->GetGUID());
+            break;
+        }
+    }
+    plr->GetSession()->SendPacket(&data);
+}
diff -Nuar oregoncore-current/src/irc/IRCLog.cpp oregoncore-pq/src/irc/IRCLog.cpp
--- oregoncore-current/src/irc/IRCLog.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/IRCLog.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCLog.h"
+#include "Config/Config.h"
+#include "IRCClient.h"
+#include <stdarg.h>
+
+IRCLog::IRCLog()
+{
+    std::string logsDir = sConfig.GetStringDefault("LogsDir","");
+    std::string ircLogName = logsDir + "/IRC_";
+    std::string ircLogTimestamp = GetLogDateStr();
+        ircLogName += ircLogTimestamp +".log";
+    ircLogfile.open (ircLogName.c_str(), std::ios::app);
+}
+
+IRCLog::~IRCLog()
+{
+    ircLogfile.close();
+}
+// Was added because using the time for logs is very annoying... one log per day.. much cleaner looking..
+std::string IRCLog::GetLogDateStr() const
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[20];
+    snprintf(buf,20,"%04d-%02d-%02d",aTm->tm_year+1900,aTm->tm_mon+1,aTm->tm_mday);
+    return std::string(buf);
+}
+
+std::string IRCLog::GetLogDateTimeStr() const
+{
+    time_t t = time(NULL);
+    tm* aTm = localtime(&t);
+    //       YYYY   year
+    //       MM     month (2 digits 01-12)
+    //       DD     day (2 digits 01-31)
+    //       HH     hour (2 digits 00-23)
+    //       MM     minutes (2 digits 00-59)
+    //       SS     seconds (2 digits 00-59)
+    char buf[30];
+    snprintf(buf,30,"[ %04d-%02d-%02d ] [ %02d:%02d:%02d ]",aTm->tm_year+1900,aTm->tm_mon+1,aTm->tm_mday,aTm->tm_hour,aTm->tm_min,aTm->tm_sec);
+    return std::string(buf);
+}
+
+void IRCLog::WriteLog(const char *what, ...)
+{
+    va_list ap;
+    char tmpoutp[1024];
+    va_start(ap, what);
+    vsnprintf(tmpoutp, 1024, what, ap);
+    va_end(ap);
+    ircLogfile << tmpoutp;
+    ircLogfile << "\n";
+    ircLogfile.flush();
+}
diff -Nuar oregoncore-current/src/irc/IRCLog.h oregoncore-pq/src/irc/IRCLog.h
--- oregoncore-current/src/irc/IRCLog.h	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/IRCLog.h	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_LOG_H
+#define _IRC_LOG_H
+
+#include "Common.h"
+#include <fstream>
+
+class IRCLog
+{
+    public:
+        IRCLog();
+        ~IRCLog();
+
+    public:
+        void WriteLog(const char *what, ...);
+        std::string GetLogDateStr() const;
+        std::string GetLogDateTimeStr() const;
+    private:
+        std::ofstream ircLogfile;
+};
+
+
+#endif
diff -Nuar oregoncore-current/src/irc/IRCSock.cpp oregoncore-pq/src/irc/IRCSock.cpp
--- oregoncore-current/src/irc/IRCSock.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/IRCSock.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "IRCClient.h"
+#define MAXDATASIZE 512
+#include <fcntl.h>
+
+#include <stdio.h>
+#include <sys/types.h>
+
+
+#define _UNICODE
+
+#ifdef _MBCS
+#undef _MBCS
+#endif
+
+bool IRCClient::InitSock()
+{
+    #ifdef _WIN32
+    WSADATA wsaData;                                        //WSAData
+    if (WSAStartup(MAKEWORD(2,0),&wsaData) != 0)
+    {
+        sLog.outError("IRC Error: Winsock Initialization Error");
+        return false;
+    }
+    #endif
+    if ((sIRC.SOCKET = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
+    {
+        sLog.outError("IRC Error: Socket Error");
+        return false;
+    }
+    int on = 1;
+    if (setsockopt (sIRC.SOCKET, SOL_SOCKET, SO_REUSEADDR, (const char*) &on, sizeof (on)) == -1)
+    {
+        sLog.outError("IRC Error: Invalid Socket");
+        return false;
+    }
+    #ifdef _WIN32
+    u_long iMode = 0;
+    ioctlsocket(sIRC.SOCKET, FIONBIO, &iMode);
+    #else
+    fcntl(sIRC.SOCKET, F_SETFL, O_NONBLOCK);                // set to non-blocking
+    fcntl(sIRC.SOCKET, F_SETFL, O_ASYNC);                   // set to asynchronous I/O
+    #endif
+    return true;
+}
+
+bool IRCClient::Connect(const char *cHost, int nPort)
+{
+    sIRC.Connected = false;
+    struct hostent *he;
+    if ((he=gethostbyname(cHost)) == NULL)
+    {
+        sLog.outError("IRCLIENT: Could not resolve host: %s", cHost);
+        return false;
+    }
+    struct sockaddr_in their_addr;
+    their_addr.sin_family = AF_INET;
+    their_addr.sin_port = htons(nPort);
+    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+    memset(&(their_addr.sin_zero), '\0', 8);
+    if (::connect(sIRC.SOCKET, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == -1)
+    {
+        sLog.outError("IRCLIENT: Cannot connect to %s", cHost);
+        return false;
+    }
+    //FD_ZERO(&sIRC.sfdset);
+    //FD_SET(sIRC.SOCKET,&sIRC.sfdset);
+    sIRC.Connected = true;
+    return true;
+}
+
+bool IRCClient::Login(std::string sNick, std::string sUser, std::string sPass)
+{
+    char hostname[128];
+    gethostname(hostname, sizeof(hostname));
+    if (SendIRC("HELLO"))
+        if (SendIRC("PASS " + sPass))
+            if (SendIRC("NICK " + sNick))
+                if (SendIRC("USER " + sUser + " " + (std::string)hostname + " OCChat :OCChat "+sIRC._Mver.c_str()))
+                    return true;
+    return false;
+}
+
+bool IRCClient::SendData(const char *data)
+{
+    if (sIRC.Connected)
+    {
+        if (send(sIRC.SOCKET, data, strlen(data), 0) == -1)
+        {
+            sLog.outError("IRC Error: Socket Receieve ** \n");
+            //Disconnect();
+            return false;
+        }
+    }
+    return true;
+}
+
+bool IRCClient::SendIRC(std::string data)
+{
+    std::string RealData = data + "\n";
+    return SendData(RealData.c_str());
+}
+
+void IRCClient::Disconnect()
+{
+    if (sIRC.SOCKET)
+    {
+        #ifdef _WIN32
+        closesocket(sIRC.SOCKET);
+        //WSACleanup();
+        #else
+        close(sIRC.SOCKET);
+        #endif
+    }
+}
+
+void IRCClient::SockRecv()
+{
+//    wchar_t bufferdata;
+
+    char szBuffer[MAXDATASIZE];
+
+    memset(szBuffer, 0, MAXDATASIZE);
+    
+    int nBytesRecv = ::recv(sIRC.SOCKET, szBuffer, MAXDATASIZE - 1, 0);
+    if (nBytesRecv == -1)
+    {
+        sLog.outError("Connection lost.");
+        sIRC.Connected = false;
+    }
+    else
+    {
+        if (-1 == nBytesRecv)
+        {
+            sLog.outError("Error occurred while receiving from socket.");
+        }
+        else
+        {
+            std::string reply;
+            std::istringstream iss(szBuffer);
+            while (getline(iss, reply))
+            {
+                Handle_IRC(reply);
+            }
+        }
+    }
+}
diff -Nuar oregoncore-current/src/irc/MCS_OnlinePlayers.cpp oregoncore-pq/src/irc/MCS_OnlinePlayers.cpp
--- oregoncore-current/src/irc/MCS_OnlinePlayers.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/MCS_OnlinePlayers.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "MCS_OnlinePlayers.h"
+
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "Config/Config.h"
+
+mcs_OnlinePlayers::mcs_OnlinePlayers() { CD = NULL; }
+
+mcs_OnlinePlayers::mcs_OnlinePlayers(_CDATA *_CD)
+{
+    //create a new instance of data struct and copy its data
+    CD = new _CDATA();
+    CD->CMD = _CD->CMD;
+    CD->FROM = _CD->FROM;
+    CD->PARAMS = _CD->PARAMS;
+    CD->PCOUNT = _CD->PCOUNT;
+    CD->USER = _CD->USER;
+    CD->TYPE = _CD->TYPE;
+}
+
+mcs_OnlinePlayers::~mcs_OnlinePlayers()
+{
+    if (CD)
+        delete CD;
+}
+
+void mcs_OnlinePlayers::run()
+{
+    int OnlineCount = 0;
+    std::string IRCOut = "";
+    HashMapHolder<Player>::MapType& m = ObjectAccessor::Instance().GetPlayers();
+    for (HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            OnlineCount++;
+            Player *plr = itr->second->GetSession()->GetPlayer();
+            std::string ChatTag = " ";
+            switch(plr->GetSession()->GetSecurity())
+            {
+                  case 0: ChatTag.append("");break;
+                  case 1: ChatTag.append("\0037"+sIRC.ojGM1);break;
+                  case 2: ChatTag.append("\0037"+sIRC.ojGM2);break;
+                  case 3: ChatTag.append("\0037"+sIRC.ojGM3);break;
+                  case 4: ChatTag.append("\0037"+sIRC.ojGM4);break;
+                  case 5: ChatTag.append("\0037"+sIRC.ojGM5);break;
+		   case 6: ChatTag.append("\0037"+sIRC.ojGM6);break;
+		   case 7: ChatTag.append("\0037"+sIRC.ojGM7);break;
+		   case 8: ChatTag.append("\0037"+sIRC.ojGM8);break;
+            }
+            if (plr->isAFK())
+                ChatTag.append("\002\0037<AFK>\003\002");
+            else if (plr->isDND())
+                ChatTag.append("\002\0037<DND>\003\002");
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("\0034");break;      //horde
+                case 469:ChatTag.append("\00312");break;    //alliance
+            }
+
+            IRCOut.append(IRCCmd::MakeMsg("%s\002%s\003\017\002(%d)\002\017", ChatTag.c_str(), plr->GetName(), plr->getLevel()));
+
+            // after XX players have been added to the string
+            // output to irc and reset for the next XX
+            if (OnlineCount % sIRC.onlrslt == 0)
+            {
+                sIRC.Send_IRC_Channel(IRCCmd::ChanOrPM(CD), IRCCmd::MakeMsg("\002 %s", IRCOut.c_str()), true, CD->TYPE.c_str());
+                IRCOut = "";
+                ACE_Based::Thread::Sleep(1000);
+            }
+        }
+    }
+    // Remainder in IRCOUT && Total plyersonline
+    sIRC.Send_IRC_Channel(IRCCmd::ChanOrPM(CD), IRCCmd::MakeMsg("\002Players Online(%d):\017 %s", OnlineCount, IRCOut.c_str()), true, CD->TYPE);
+
+    sIRC.Script_Lock[MCS_Players_Online] = false;
+}
diff -Nuar oregoncore-current/src/irc/MCS_OnlinePlayers.h oregoncore-pq/src/irc/MCS_OnlinePlayers.h
--- oregoncore-current/src/irc/MCS_OnlinePlayers.h	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/irc/MCS_OnlinePlayers.h	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2005-2008 MaNGOS <http://www.mangosproject.org/>
+ *
+ * Copyright (C) 2008 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Oregon <http://www.oregoncore.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _IRC_CLIENT_ONLINE
+#define _IRC_CLIENT_ONLINE
+
+#include "IRCClient.h"
+#include "IRCCmd.h"
+
+class mcs_OnlinePlayers : public ACE_Based::Runnable
+{
+    public:
+        mcs_OnlinePlayers();
+        mcs_OnlinePlayers(_CDATA *_CD);
+        ~mcs_OnlinePlayers();
+        void run();
+    public:
+        _CDATA *CD;
+};
+
+#endif
diff -Nuar oregoncore-current/src/oregoncore/CliRunnable.cpp oregoncore-pq/src/oregoncore/CliRunnable.cpp
--- oregoncore-current/src/oregoncore/CliRunnable.cpp	2012-05-20 11:29:49.000000000 -0400
+++ oregoncore-pq/src/oregoncore/CliRunnable.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -31,6 +31,7 @@
 #include "MapManager.h"
 #include "Player.h"
 #include "Util.h"
+#include "../irc/IRCClient.h"
 
 #if PLATFORM != WINDOWS
 #include <readline/readline.h>
@@ -654,6 +655,15 @@
     return true;
 }
 
+//Reconnect OCChat to IRC server via CLI command
+bool ChatHandler::HandleIRCRelogCommand(const char *args)
+{
+    SendSysMessage("OCChat is dropping from IRC Server");
+    sIRC.ResetIRC();
+    SendSysMessage("OCChat is reconnecting to IRC Server");
+    return true;
+}
+
 #ifdef linux
 // Non-blocking keypress detector, when return pressed, return 1, else always return 0
 int kb_hit_return()
diff -Nuar oregoncore-current/src/oregoncore/CMakeLists.txt oregoncore-pq/src/oregoncore/CMakeLists.txt
--- oregoncore-current/src/oregoncore/CMakeLists.txt	2012-05-20 11:29:49.000000000 -0400
+++ oregoncore-pq/src/oregoncore/CMakeLists.txt	2012-05-20 11:43:23.000000000 -0400
@@ -35,6 +35,7 @@
   ${CMAKE_SOURCE_DIR}/src/shared/Database
   ${CMAKE_SOURCE_DIR}/src/framework
   ${CMAKE_SOURCE_DIR}/src/game
+  ${CMAKE_SOURCE_DIR}/src/irc
   ${ACE_INCLUDE_DIR}
   ${MYSQL_INCLUDE_DIR}
   ${OPENSSL_INCLUDE_DIR}
@@ -64,6 +65,7 @@
   collision
   g3dlib
   gsoap
+  irc
   ${JEMALLOC_LIBRARY}
   ${READLINE_LIBRARY}
   ${TERMCAP_LIBRARY}
diff -Nuar oregoncore-current/src/oregoncore/Main.cpp oregoncore-pq/src/oregoncore/Main.cpp
--- oregoncore-current/src/oregoncore/Main.cpp	2012-05-20 11:29:49.000000000 -0400
+++ oregoncore-pq/src/oregoncore/Main.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -22,6 +22,7 @@
 #include "Common.h"
 #include "Database/DatabaseEnv.h"
 #include "Config/Config.h"
+#include "../irc/IRCClient.h"
 
 #include "Log.h"
 #include "Master.h"
diff -Nuar oregoncore-current/src/oregoncore/Master.cpp oregoncore-pq/src/oregoncore/Master.cpp
--- oregoncore-current/src/oregoncore/Master.cpp	2012-05-20 11:29:49.000000000 -0400
+++ oregoncore-pq/src/oregoncore/Master.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -35,6 +35,7 @@
 #include "CliRunnable.h"
 #include "RARunnable.h"
 #include "Util.h"
+#include "../irc/IRCClient.h"
 #include "OCSoap.h"
 
 #ifdef _WIN32
@@ -215,6 +216,15 @@
 
     uint32 socketSelecttime = sWorld.getConfig(CONFIG_SOCKET_SELECTTIME);
 
+    // Start up OCChat
+    if (sIRC.Active == 1)
+    {
+        ACE_Based::Thread irc(new IRCClient);
+        irc.setPriority ((ACE_Based::Priority)2);
+    }
+    else
+        sLog.outString("OCChat: OCChat Is Disabled.");
+
     // Start up freeze catcher thread
     ACE_Based::Thread* freeze_thread = NULL;
     if (uint32 freeze_delay = sConfig.GetIntDefault("MaxCoreStuckTime", 0))
diff -Nuar oregoncore-current/src/oregoncore/oregoncore.conf.dist oregoncore-pq/src/oregoncore/oregoncore.conf.dist
--- oregoncore-current/src/oregoncore/oregoncore.conf.dist	2012-05-20 11:29:49.000000000 -0400
+++ oregoncore-pq/src/oregoncore/oregoncore.conf.dist	2012-05-20 11:43:23.000000000 -0400
@@ -702,6 +702,10 @@
 #        Disable/enable waterbreathing for security level (0..4) or higher
 #        Default: 4 (None)
 #
+#    DisableFatigue
+#        Disable/enable fatigue for security level (0..4) or high
+#        Default: 4 (None)
+#
 #    AllFlightPaths
 #        Players will start with all flight paths
 #         (Note: ALL flight paths, not only player's team)
@@ -834,6 +838,7 @@
 StartArenaPoints = 0
 InstantLogout = 1
 DisableWaterBreath = 4
+DisableFatigue = 4
 AllFlightPaths = 0
 AlwaysMaxSkillForLevel = 0
 ActivateWeather = 1
@@ -1897,6 +1902,40 @@
 ###############################################################################
 # CUSTOM SERVER OPTIONS
 #
+#    GuildMasterNPC.BuyEnabled
+#        Allow players to buy Guild Houses.
+#        Default: 1 (Yes)
+#                 0 (No)
+#
+#    GuildMasterNPC.BuyGossip
+#        Text for buy menu option (good idea to include price)
+#        Default: "Buy a Guild House for 500 Gold"
+#
+#    GuildMasterNPC.BuyPriceInGold
+#        Amount in gold needed to purchase a guild house.
+#        Default: 500 (Gold)
+#
+#    GuildMasterNPC.SellEnabled
+#        Allow players to sell Guild Houses.
+#        Default: 1 (Yes)
+#                 0 (No)
+#
+#    GuildMasterNPC.SellGossip
+#        Text for sell menu option (good idea to include price)
+#        Default: "Sell your Guild House for 400 Gold"
+#
+#    GuildMasterNPC.SellPriceInGold
+#        Amount of gold given to player when selling guild house.
+#        Default: 400 (Gold)
+#
+#    RentalMountNPC.SlowPrice
+#        Price in copper for regular mount.
+#        Default: 100 (1 silver)
+#
+#    RentalMountNPC.FastPrice
+#        Price in copper for swift mount.
+#        Default: 500 (5 silver)
+#
 #    PlayerStart.AllReputation
 #        Players will start with most of the high level reputations that are
 #         needed for items, mounts etc.
@@ -1920,6 +1959,10 @@
 #        The amount of honor points the duel winner will get after a duel.
 #        Default: 0 - disable
 #
+#    GoldAfterDuel
+#        The base amount, in gold, to award the winner of a duel.
+#        Default: 0 - disable
+#
 #    AlwaysMaxWeaponSkill
 #        Players will automatically gain max weapon/defense skill when
 #         logging in, leveling up etc.
@@ -1943,6 +1986,20 @@
 #    PvPToken.ItemCount
 #        Modify the item ID count - Default: 1
 #
+#    PvPRank.Rate.ExtraHonor
+#    Rate of honor bonus for killing higher PVP ranked players
+#    Default: 
+#        1 - 10% more honor per RANK difference
+#        2 - 20%
+#        0 - off
+#
+#    PvPRank.HKPerRank
+#    Honor Kills needed for each rank, use "," between values.
+#    Whole string must be enclosed with " "
+#    Always specify 14 values, for 14 ranks
+#    Default: 
+#        "10,50,100,200,450,750,1300,2000,3500,6000,9500,15000,21000,30000"
+#
 #    NoResetTalentsCost
 #        Enable or disable no cost when reseting talents
 #
@@ -1987,18 +2044,38 @@
 #       Default: 0 (Disabled)
 #                1 - Enabled
 #
+#   RenameNPC.Enable
+#       Enable the Rename NPC.
+#       Default: 1 - Enabled
+#                0 (Disabled)
+#
+#   RenameNPC.CostInGold
+#       Cost to rename character in gold.
+#       Default: 100
+#
 ###############################################################################
 
+GuildMasterNPC.BuyEnabled = 1
+GuildMasterNPC.BuyGossip = "Buy a Guild House for 500 Gold"
+GuildMasterNPC.BuyPriceInGold = 500
+GuildMasterNPC.SellEnabled = 1
+GuildMasterNPC.SellGossip = "Sell your GuildHouse for 400 Gold"
+GuildMasterNPC.SellPriceInGold = 400
+RentalMountNPC.SlowPrice = 100
+RentalMountNPC.FastPrice = 500
 PlayerStart.AllReputation = 0
 PlayerStart.AllSpells = 0
 PlayerStart.MapsExplored = 0
 MusicInBattleground = 0
 HonorPointsAfterDuel = 0
+GoldAfterDuel = 0
 AlwaysMaxWeaponSkill = 0
 PvPToken.Enable = 0
 PvPToken.MapAllowType = 4
 PvPToken.ItemID = 29434
 PvPToken.ItemCount = 1
+PvPRank.Rate.ExtraHonor = 1
+PvPRank.HKPerRank = "10,50,100,200,450,750,1300,2000,3500,6000,9500,15000,21000,30000"
 NoResetTalentsCost = 0
 ShowKickInWorld = 0
 RecordUpdateTimeDiffInterval = 60000
@@ -2006,6 +2083,8 @@
 PlayerStart.String = ""
 DuelMod.Enable = 0
 DuelMod.Cooldowns = 0
+RenameNPC.Enable = 1
+RenameNPC.CostInGold = 100
 
 ###############################################################################
 # AUTO BROADCAST
@@ -2073,3 +2152,200 @@
 Warden.ClientCheckHoldOff = 15
 Warden.LogFile = "warden.log"
 
+##############################################################################
+# OCChat IRC BOT Configuration
+#
+# irc.active
+#     Enable OCChat Addon
+#     Default: 1 - Enable
+#              0 - Disable
+#
+# irc.icc
+#     IRC connect code
+#     Default: 001 - Welcome To Network msg
+#              375 - Beginning Of MOTD
+#              376 - End Of MOTD
+#
+# irc.host
+#     IRC server to have OCChat connect to
+#
+# irc.port
+#     IRC server port to use
+#
+# irc.user
+#     The username to have OCChat use to connect to the IRC server
+# irc.nick
+#     IRC nickname to be used by the bot
+# irc.pass
+#     The password to be used to identify to NickServ
+#
+# irc.auth
+#     IRC Authentication Method
+#     Default: 0 - Disable
+#              1 - NickServ - Normal Method
+#                  - PRIVMSG NickServ :IDENTIFY Password
+#              2 - NickServ - Alternate Method To Identify To A Different Nick
+#                - PRIVMSG NickServ :IDENTIFY irc.auth.nick Password
+#              3 - QuakeNet - Normal Method
+#                 - PRIVMSG Q@CServe.quakenet.org :AUTH irc.nick Password
+#              4 - QuakeNet - Alternate Method To Identify To A Different Nick
+#                - PRIVMSG Q@CServe.quakenet.org :AUTH irc.auth.nick Password
+# irc.auth.nick
+#     IRC Nickname to use if Auth method 2 or 4 is used
+#
+# irc.ldef
+#     Leave a defined IRC channel on server connect
+#     Default: 0 - Disable
+#              1 - Enable
+# irc.defchan
+#     IRC channel to leave on server connect if irc.ldef is on
+#
+# irc.wct
+#     Time to wait before (re)attemptimg connection to IRC server
+#     Default: 30000 - (30 Seconds)
+# irc.maxattempt
+#     Maximum attempts to try IRC server
+#     Default: 20
+#
+# irc.autojoin_kick
+#     Autojoin IRC channel if kicked
+#     Default: 1 - Enable
+#              0 - Disable
+#
+# irc.command_prefix
+#     IRC command prefix
+#     Example: \online all
+#
+# irc.joinmsg
+# irc.rstmsg
+# irc.kickmsg
+#     OCChat bot join/restart/kick messages
+#
+# irc.chan_#
+# wow.chan_#
+#     IRC and WOW channels to link. Leave # out of IRC channel.
+#     Both channels _ARE_ case sensitive
+#     NOTE: you can have more than 1 IRC channel linked to wow channels,
+#           as in example:
+#     Example: irc.chan_1 = "oregon"
+#              irc.chan_2 = "oregon22"
+#              wow.chan_1 = "world"
+#              wow.chan_2 = "LookingForGroup"
+# irc.pass_#
+#     Passwords for said IRC channels (IRC server side)
+#    Example:
+#        irc.pass_1 = "password"      password for irc channel #1
+#        irc.pass_2 = "password2"     password for irc channel #2
+#
+# irc.StatusChannel
+#     Channel Number To Display Status Messages In
+#         (AuctionHouse, Levels, Deaths, Etc)
+#     Default: 1 - Channel ID 1
+# irc.AnnounceChannel
+#     Channel Number To Display Announcements In
+#         (Announces, Notifies, Event)
+#     Default: 1 - Channel ID 1
+#
+# irc.op_gm_login
+#     Op The GM In All Channels The Bot Is On When They Log In To OCChat
+#     Default: 0 - Disable
+#              1 - Enable
+# irc.op_gm_level
+#     The Minimum GM Level Required To Have The Bot Op The User
+#     Default: 5 - GM Level 5
+#
+# irc.online.result
+#     Maximum number of results per line for the online command
+#
+# chat.*** (Defineable Strings) (maybe more in future)
+#     wow_* - String is displayed in IRC channel
+#     irc_* - String is displayed in WOW channel
+#     Options: $Name, $Level, $Msg, $GM (not all options work in every string)
+#
+# Botmask
+#     This defines what the bot announces, if its 0 everything is disabled
+#     simply add the values of the elements you want to create this mask.
+#     Example: WoW join/leaves are 1 and IRC join/leaves are 2,
+#              if you want both of these active then the BotMask is 3.
+#  (1)Display WoW Chan Join/Leaves In IRC
+#  (2)Display IRC Chan Join/Leaves/NickChanges In WoW
+#  (4)Display Unknown Command Message When Trigger Is Used And No Command Exists
+#
+#  (8)Announce Security Level > 0 As GM At Login
+#  (16)Announce GM In GM ON State AS GM At Login
+#  (32)Return Errors To Notice. (If disabled then default is Private Message)
+#  (64)Display WoW Status Messages (Levels/Deaths)
+#  (128)Display Nick Changes From IRC In WOW
+#  (256)Display WoW Announces/Notifies In IRC
+#  (512)Do Not Let Players Use Commands On Higher GM Level Players
+#  (1024)Enable AuctionHouse Announcements !!DISSABLED!!
+#
+# irc.gmlog
+#     Minimum GM level to not show login/pass info in IRC logs
+# irc.logfile.prefix
+#     The prefix of the IRC logfile. Directories can be added here.
+#     Example: "IRC/IRC_" outputs IRC_YYYY-MM-DD.log to the
+#              IRC subdirectory in your logs dir
+# irc.logchannel
+#      Specefies the channel where logged output gets broadcasted.
+#      Default: "" (none)
+# irc.logchannelpw
+#     The password for the log channel.
+#     (2) Broadcast Ingame GM Commands into logchannel.
+#     (3) Broadcast both IRC Commands and GM Commands into logchannel.
+#
+# irc.gm#
+#     GM tag to append to (GM onjoin / online command) IRC color codes
+#     are acceptable
+#
+##############################################################################
+
+irc.active = 0
+irc.icc = 001
+irc.host = "localhost"
+irc.port = "6667"
+irc.user = "OCChat"
+irc.nick = "OCChat"
+irc.pass = ""
+irc.auth = 0
+irc.auth.nick = "AuthNick"
+irc.ldef = 0
+irc.defchan = "World"
+irc.wct = 30000
+irc.maxattempt = 20
+irc.autojoin_kick = 1
+irc.command_prefix = "\"
+irc.joinmsg = "OregonCore With OCChat Is Up And Running! Command Trigger Is: $Trigger"
+irc.rstmsg  = "OCChat Is Restarting, I Will Be Right Back."
+irc.kickmsg = "Do Not Kick Me Again, Severe Actions Will Be Taken!"
+irc.chan_1 = "World"
+wow.chan_1 = "world"
+irc.chan_2 = "LFG"
+wow.chan_2 = "LookingForGroup"
+irc.StatusChannel = 1
+irc.AnnounceChannel = 1
+irc.op_gm_login = 0
+irc.op_gm_level = 3
+irc.online.result = 30
+chat.wow_irc = "WoW - [$Name($Level)] $Msg"
+chat.irc_wow = "IRC - [$Name] $Msg"
+chat.join_wow = "$GM$Name Joined the $Channel Channel!"
+chat.join_irc = "[$Name]: Has Joined IRC!"
+chat.leave_wow = "$GM$Name Left the $Channel Channel!"
+chat.leave_irc = "[$Name]: Has Left IRC!"
+chat.change_nick = "$Name is now known as $NewName!"
+Botmask = 1023
+irc.gmlog = 1
+irc.logfile.prefix = "IRC_"
+irc.logchannel = "System"
+irc.logchannelpw = ""
+irc.logmask = 3
+irc.gm1 = "[GM1]"
+irc.gm2 = "[GM2]"
+irc.gm3 = "[GM3]"
+irc.gm4 = "[GM4]"
+irc.gm5 = "[GM5]"
+irc.gm6 = "[GM6]"
+irc.gm7 = "[GM7]"
+irc.gm8 = "[GM8]"
+
diff -Nuar oregoncore-current/src/scripts/Custom/item_summonnpc.cpp oregoncore-pq/src/scripts/Custom/item_summonnpc.cpp
--- oregoncore-current/src/scripts/Custom/item_summonnpc.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/item_summonnpc.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,77 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * Modified for OregonCore - Copyright (2010) Oregon <http://www.oregoncore.com>
+ * Modifications by Celtus - 2010-09-13
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: item_summonnpc
+SD%Complete: 100
+SDComment: Summon NPC
+SDCategory: Items
+EndScriptData */
+
+#include "ScriptPCH.h"
+#include <cstring>
+
+bool ItemUse_item_summonnpc(Player* pPlayer, Item* pItem, const SpellCastTargets &pTargets)
+{
+
+    // Declare Variables
+    uint32 itemId = pItem->GetEntry();
+    uint32 npcId;
+    uint32 despawnSec;
+    extern DatabaseType WorldDatabase;
+
+if ((pPlayer->isInCombat()) || (pPlayer->isInFlight()) || (pPlayer->isDead()))
+{
+      pPlayer->SendEquipError(EQUIP_ERR_NOT_IN_COMBAT, pItem, NULL);
+        return false;
+}
+if (pPlayer->IsMounted()) // Is player mounted
+{
+      pPlayer->SendEquipError(EQUIP_ERR_CANT_DO_RIGHT_NOW, pItem, NULL);
+        return true;
+}
+{
+        // Fetch the NPC Id
+        QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `creature_entry`, `despawn` FROM `item_summonnpc` WHERE `item_entry` = '%i' LIMIT 1",itemId);
+    if(result)
+    {
+        Field *fields = result->Fetch();
+        // Read NPC Id from the query result
+        npcId = fields[0].GetInt32();
+        // Read time before despawn
+        despawnSec = fields[1].GetUInt32() * 1000;
+        // Summon the NPC
+	pPlayer->SummonCreature(npcId,pPlayer->GetPositionX() ,pPlayer->GetPositionY()-2, pPlayer->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, despawnSec);
+        return true;
+    } else {
+        // Summons failed - show info in log
+        outstring_log ("Item_SummonNPC Failed: %i)",itemId);
+    }
+}
+        return false;
+}
+void AddSC_item_summonnpc()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="item_summonnpc";
+    newscript->pItemUse = &ItemUse_item_summonnpc;
+    newscript->RegisterSelf();
+}
diff -Nuar oregoncore-current/src/scripts/Custom/item_teleport.cpp oregoncore-pq/src/scripts/Custom/item_teleport.cpp
--- oregoncore-current/src/scripts/Custom/item_teleport.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/item_teleport.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,48 @@
+/* ScriptData
+SDName: Item_Teleport
+SD%Complete: 100
+SDComment: Used for Teleport Item Scripts
+SDCategory: Items
+EndScriptData */
+
+#include "ScriptPCH.h"
+#include <cstring>
+
+bool ItemUse_item_teleport(Player *player, Item* _Item, SpellCastTargets const& targets)
+{
+    // Declare variables
+    float x_pos, y_pos, z_pos, o_pos;
+    uint32 mapid;
+    uint32 itemId = _Item->GetEntry();
+    extern DatabaseType WorldDatabase;
+
+    // Fetch the coordinates
+    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `mapid`, `X_pos`, `Y_pos`, `Z_pos`, `orientation`  FROM `item_teleports` WHERE `entry` = '%i' LIMIT 1",itemId);
+    if(result)
+    {
+        Field *fields = result->Fetch();
+        // Read coords from the query result
+        mapid = fields[0].GetInt32();
+        x_pos = fields[1].GetFloat();
+        y_pos = fields[2].GetFloat();
+        z_pos = fields[3].GetFloat();
+        o_pos = fields[4].GetFloat();
+        // Teleport the player and show info in log
+        player->TeleportTo(mapid, x_pos, y_pos, z_pos, o_pos);
+        outstring_log ("Teleport Activated: %i (m:%i x:%f y:%f z:%f o:%f)",itemId,mapid,x_pos,y_pos,z_pos,o_pos);
+        return true;
+    } else {
+        // Teleport failed - show info in log
+        outstring_log ("Teleport Failed: %i (m:%i x:%f y:%f z:%f o:%f)",itemId,mapid,x_pos,y_pos,z_pos,o_pos);
+    }
+}
+
+void AddSC_item_teleport()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="item_teleport";
+    newscript->pItemUse = &ItemUse_item_teleport;
+    newscript->RegisterSelf();
+}
diff -Nuar oregoncore-current/src/scripts/Custom/npc_areaguard.cpp oregoncore-pq/src/scripts/Custom/npc_areaguard.cpp
--- oregoncore-current/src/scripts/Custom/npc_areaguard.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/npc_areaguard.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,135 @@
+#include "ScriptPCH.h"
+
+/*******************************************************
+ * npc_areaguard
+ *******************************************************/
+
+struct npc_areaguardAI : public Scripted_NoMovementAI
+{
+    npc_areaguardAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
+    {
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        pCreature->ApplySpellImmune(0, IMMUNITY_DAMAGE, SPELL_SCHOOL_NORMAL, true);
+        pCreature->ApplySpellImmune(0, IMMUNITY_DAMAGE, SPELL_SCHOOL_MASK_MAGIC, true);
+    }
+
+    void Reset(){}
+
+    void Aggro(Unit* /*pWho*/){}
+
+    void AttackStart(Unit* /*pWho*/){}
+
+    void MoveInLineOfSight(Unit *pWho)
+    {
+        // Return if Distance is greater than maximum (65 ft) - saves data reads
+        if (!me->IsWithinDist(pWho, 65.0f, false))
+            return;
+
+        extern DatabaseType WorldDatabase;
+        uint32 creatureID = me->GetEntry();
+        uint32 guardType;
+        uint32 triggerDist;
+        uint32 reqValue;
+        uint32 teleMap;
+        float teleX,teleY,teleZ,teleO;
+
+        QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `guard_type`, `trigger_distance`, `req_value`,`tele_map`,`tele_x`,`tele_y`,`tele_z`,`tele_o` FROM `npc_areaguard` WHERE `creature_entry` = %i LIMIT 1",creatureID);
+        if (result)
+        {
+            Field *fields = result->Fetch();
+            guardType = fields[0].GetUInt32();
+            triggerDist = fields[1].GetFloat();
+            reqValue = fields[2].GetUInt32();
+            teleMap = fields[3].GetUInt32();
+            teleX = fields[4].GetFloat();
+            teleY = fields[5].GetFloat();
+            teleZ = fields[6].GetFloat();
+            teleO = fields[7].GetFloat();
+        } else {
+            return;
+        }
+
+        if (!pWho || !pWho->IsInWorld())
+            return;
+
+        // Return if distance is greater than the trigger_distance
+        if (!me->IsWithinDist(pWho, triggerDist, false))
+            return;
+
+        Player *pPlayer = pWho->GetCharmerOrOwnerPlayerOrPlayerItself();
+
+        // Return if player has GM flag on or is in process of teleport
+        if (!pPlayer || pPlayer->isGameMaster() || pPlayer->IsBeingTeleported())
+            return;
+
+        switch (guardType)
+        {
+            case 0:
+                // Action on all players without GM flag on
+                pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                break;
+            case 1:
+                {
+                // Action based on Team
+                if (reqValue == 1) // Alliance Required 
+                    if (pPlayer->GetTeam() != 469) // Player is Horde
+                        pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                if (reqValue == 2) // Horde Required
+                    if (pPlayer->GetTeam() != 67) // Player is Alliance
+                        pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                }
+                break;
+            case 2:
+                {
+                // Action based on GM Level
+                if (pPlayer->GetSession()->GetSecurity() < reqValue)
+                    pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                }
+                break;
+            case 3:
+                {
+                // Action based on Player Level
+                if (pPlayer->getLevel() < reqValue)
+                    pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                }
+                break;
+            case 4:
+                {
+                // Action based on Guild ID
+                if (pPlayer->GetGuildId() != reqValue)
+                    pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                }
+                break;
+            case 5:
+                {
+                // Action based on Player GUID
+                if (pPlayer->GetGUID() != reqValue)
+                    pPlayer->TeleportTo(teleMap,teleX,teleY,teleZ,teleO);
+                }
+                break;
+        }
+ 
+        float x,y,z,o;
+        me->GetHomePosition(x,y,z,o);
+        me->SetOrientation(o);
+        return;
+    }
+
+    void UpdateAI(const uint32 /*diff*/){}
+};
+
+CreatureAI* GetAI_npc_areaguard(Creature* pCreature)
+{
+    return new npc_areaguardAI(pCreature);
+}
+
+void AddSC_npc_areaguard()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "npc_areaguard";
+    newscript->GetAI = &GetAI_npc_areaguard;
+    newscript->RegisterSelf();
+}
+
diff -Nuar oregoncore-current/src/scripts/Custom/npc_buff.cpp oregoncore-pq/src/scripts/Custom/npc_buff.cpp
--- oregoncore-current/src/scripts/Custom/npc_buff.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/npc_buff.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,254 @@
+/* ScriptData
+SDName: NPC_Buff
+SD%Complete: 95
+SDComment: Buff Master
+SDCategory: NPC
+EndScriptData */
+
+#include "ScriptPCH.h"
+
+bool GossipHello_NPC_Buff(Player *player, Creature *_Creature)
+{
+    // Main Menu for Alliance
+    if ( player->GetTeam() == ALLIANCE )
+    {
+        player->ADD_GOSSIP_ITEM( 7, "Small Spells ->", GOSSIP_SENDER_MAIN, 1000);
+        player->ADD_GOSSIP_ITEM( 7, "GM Spells ->", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM( 7, "Other Gifts ->", GOSSIP_SENDER_MAIN, 4000);
+    }
+    else // Main Menu for Horde
+    {
+        player->ADD_GOSSIP_ITEM( 7, "Small Spells ->", GOSSIP_SENDER_MAIN, 1000);
+        player->ADD_GOSSIP_ITEM( 7, "GM Spells ->", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM( 7, "Other Gifts ->", GOSSIP_SENDER_MAIN, 4000);
+    }
+
+    player->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness", GOSSIP_SENDER_MAIN, 5000);
+
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+
+return true;
+}
+
+void SendDefaultMenu_NPC_Buff(Player *player, Creature *_Creature, uint32 action )
+{
+
+// Not allow in combat
+if(!player->getAttackers().empty())
+{
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+switch(action)
+{
+
+case 1000: // Small Buff
+    player->ADD_GOSSIP_ITEM( 5, "Give me Mark of the Wild"                          , GOSSIP_SENDER_MAIN, 1001);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Thorns"                                    , GOSSIP_SENDER_MAIN, 1005);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Amplify Magic"                             , GOSSIP_SENDER_MAIN, 1010);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Arcane Intellect"                          , GOSSIP_SENDER_MAIN, 1015);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Dampen Magic"                              , GOSSIP_SENDER_MAIN, 1025);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Blessing of Kings"                         , GOSSIP_SENDER_MAIN, 1030);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Blessing of Might"                         , GOSSIP_SENDER_MAIN, 1035);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Blessing of Wisdom"                        , GOSSIP_SENDER_MAIN, 1040);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Divine Spirit"                             , GOSSIP_SENDER_MAIN, 1045);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Power Word: Fortitude"                     , GOSSIP_SENDER_MAIN, 1050);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Shadow Protection"                         , GOSSIP_SENDER_MAIN, 1055);
+    player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                                      , GOSSIP_SENDER_MAIN, 5005);
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+    break;
+
+case 3000: // GM Buff
+    player->ADD_GOSSIP_ITEM( 5, "Give me Agamaggan's Agility"                       , GOSSIP_SENDER_MAIN, 3001);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Agamaggan's Strength"                      , GOSSIP_SENDER_MAIN, 3005);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Increased Stamina"                         , GOSSIP_SENDER_MAIN, 3020);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Razorhide"                                 , GOSSIP_SENDER_MAIN, 3025);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Rising Spirit"                             , GOSSIP_SENDER_MAIN, 3030);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Spirit of the Wind"                        , GOSSIP_SENDER_MAIN, 3035);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Wisdom of Agamaggan"                       , GOSSIP_SENDER_MAIN, 3040);
+    player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                                      , GOSSIP_SENDER_MAIN, 5005);
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+    break;
+
+case 4000: // Player Tools
+    player->ADD_GOSSIP_ITEM( 5, "Give me Gold"                                      , GOSSIP_SENDER_MAIN, 4001);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Soul Shards"                               , GOSSIP_SENDER_MAIN, 4005);
+    player->ADD_GOSSIP_ITEM( 5, "Maximize my Skills"
+    , GOSSIP_SENDER_MAIN, 4007);
+    player->ADD_GOSSIP_ITEM( 5, "Heal Me, Please"                                   , GOSSIP_SENDER_MAIN, 4010);
+    player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                                      , GOSSIP_SENDER_MAIN, 5005);
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+    break;
+
+case 5005: // Back To Main Menu
+    // Main Menu for Alliance
+    if ( player->GetTeam() == ALLIANCE )
+    {
+        player->ADD_GOSSIP_ITEM( 7, "Small Spells ->", GOSSIP_SENDER_MAIN, 1000);
+        player->ADD_GOSSIP_ITEM( 7, "GM Spells ->", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM( 7, "Other Gifts ->", GOSSIP_SENDER_MAIN, 4000);
+    }
+    else // Main Menu for Horde
+    {
+        player->ADD_GOSSIP_ITEM( 7, "Small Spells ->", GOSSIP_SENDER_MAIN, 1000);
+        player->ADD_GOSSIP_ITEM( 7, "GM Spells ->", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM( 7, "Other Gifts ->", GOSSIP_SENDER_MAIN, 4000);
+    }
+
+    player->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness", GOSSIP_SENDER_MAIN, 5000);
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+    break;
+
+// Small Buff
+
+case 1001: // Give me Mark of the Wild
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,9885,false);
+break;
+
+case 1005: // Give me Thorns
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,26992,false);
+break;
+
+case 1010: // Give me Amplify Magic
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,33946,false);
+break;
+
+case 1015: // Give me Arcane Intellect
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,27126,false);
+break;
+
+case 1025: // Give me Dampen Magic
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,33944,false);
+break;
+
+case 1030: // Give me Blessing of Kings
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,20217,false);
+break;
+
+case 1035: // Give me Blessing of Might
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,19838,false);
+break;
+
+case 1040: // Give me Blessing of Wisdom
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,25290,false);
+break;
+
+case 1045: // Give me Divine Spirit
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,25312,false);
+break;
+
+case 1050: // Give me Power Word: Fortitude
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,10938,false);
+break;
+
+case 1055: // Give me Shadow Protection
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,25433,false);
+break;
+
+// GM Buff
+
+case 3001: // Give me Agamaggan's Agility
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,17013,false);
+break;
+
+case 3005: // Give me Agamaggan's Strength
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,16612,false);
+break;
+
+case 3020: // Give me Increased Stamina
+    player->CLOSE_GOSSIP_MENU();
+    player->CastSpell(player,25661,false);
+break;
+
+case 3025: // Give me Razorhide
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,16610,false);
+break;
+
+case 3030: // Give me Rising Spirit
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,10767,false);
+break;
+
+case 3035: // Give me Spirit of the Wind
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,16618,false);
+break;
+
+case 3040: // Give me Wisdom of Agamaggan
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,7764,false);
+break;
+
+// Player Tools
+
+case 4001://Give me Gold
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,46642,false); // 5000 gold
+break;
+
+case 4005://Give me Soul Shards
+    player->CLOSE_GOSSIP_MENU();
+    player->CastSpell(player,24827,false);
+break;
+
+case 4007: // Update Skill to Max for Level      
+    player->CLOSE_GOSSIP_MENU();
+    player->UpdateSkillsToMaxSkillsForLevel();
+break;
+
+case 4010: // Heal me please
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,38588,false);
+break;
+
+case 5000://Remove Res Sickness
+    if(!player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0)) {
+        _Creature->MonsterWhisper("You are not suffering from resurrection sickness.", player->GetGUID());
+        GossipHello_NPC_Buff(player, _Creature);
+        return;
+    }
+
+    _Creature->CastSpell(player,38588,false); // Healing effect
+    player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+    player->CLOSE_GOSSIP_MENU();
+    break;
+
+    player->CLOSE_GOSSIP_MENU();
+
+    } // end of switch
+} //end of function
+
+bool GossipSelect_NPC_Buff(Player *player, Creature *_Creature, uint32 sender, uint32 action)
+{
+    // Main menu
+    if (sender == GOSSIP_SENDER_MAIN)
+        SendDefaultMenu_NPC_Buff( player, _Creature, action );
+    return true;
+}
+
+void AddSC_npc_buff()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "npc_buff";
+    newscript->pGossipHello = &GossipHello_NPC_Buff;
+    newscript->pGossipSelect = &GossipSelect_NPC_Buff;
+    newscript->RegisterSelf();
+}
+
diff -Nuar oregoncore-current/src/scripts/Custom/npc_codebox.cpp oregoncore-pq/src/scripts/Custom/npc_codebox.cpp
--- oregoncore-current/src/scripts/Custom/npc_codebox.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/npc_codebox.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,228 @@
+/* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/* ScriptData
+SDName: NPC_Code_Codebox
+SD%Complete: 100
+SDComment: Makes an NPC give a gift if a valid code is entered
+SDCategory: NPCs
+EndScriptData */
+
+#include "ScriptPCH.h"
+#include <cstring>
+
+#define C_GOSSIP_MENU 907
+#define D_ENTER_CODE "I have a code!"
+#define D_CANCEL_CODE "Nevermind..."
+#define SAY_INV_FULL "Your code is right, but you have no space in your bags!  Come back when you have some free space."
+#define SAY_EXPIRED "Sorry, your code has expired.  Come back when you have a valid one."
+#define SAY_INVALID "Sorry, your code is not valid.  Come back when you have a new one."
+#define SAY_GIVE_PRESENT "This is for you!  I hope you enjoy it."
+#define SAY_EXTRA_BUFF "How lucky you are!  You get an item and a buff!"
+#define SAY_GIVE_BUFF "Here is a special buff, just for you!"
+#define SAY_GOODBYE "Nice to see you!  Goodbye!"
+
+/*
+ Returns TRUE if the gift is given.
+ Returns FALSE if the code is wrong
+   or if the gift can't be given (i.e. full inventory).
+
+ ~elegos
+*/
+bool checkCode(Player *player, Creature *_Creature, const char* sCode)
+{
+    // Some variables declarations.
+    int32 item_id = 0;
+    int32 aura_id = 0;
+    uint32 quantity = 0;
+    int32 uses = 0;
+    bool check = false;
+
+    extern DatabaseType WorldDatabase;
+    uint32 creatureID = _Creature->GetEntry();
+
+    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `item_id`, `aura_id`, `quantity`, `uses`  FROM `npc_codes` WHERE `code` = '%s' AND npc_id = %i LIMIT 1",sCode,creatureID);
+    if(result)
+    {
+        check = true;
+        Field *fields = result->Fetch();
+
+        item_id = fields[0].GetInt32();
+        aura_id = fields[1].GetInt32();
+        quantity = fields[2].GetUInt32();
+        uses = fields[3].GetUInt32();
+
+        if(uses != 0)
+        {
+            if(item_id > 0)
+            {
+                ItemPosCountVec dest;
+                uint8 canStoreNewItem = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item_id, quantity);
+                if(canStoreNewItem == EQUIP_ERR_OK)
+                {
+                    Item *newItem = NULL;
+                    newItem = player->StoreNewItem(dest,item_id,quantity,true);
+                    player->SendNewItem(newItem,quantity,true,false);
+                }
+                else
+                {
+                    _Creature->MonsterWhisper(SAY_INV_FULL, player->GetGUID());
+                    check = false;
+                }
+            }
+            else if(item_id < 0)
+            {
+                uint32 id = item_id * -1;
+                uint32 num;
+                uint32 item;
+                QueryResult_AutoPtr items = WorldDatabase.PQuery("SELECT `item_id` FROM `npc_codes_item_loot` WHERE `group_id` = '%i'",id);
+                if(items)
+                {
+                    num = rand()%items->GetRowCount();
+                    Field *i;
+                    uint32 count = 0;
+                    do
+                    {
+                        i = items->Fetch();
+                        item = i[0].GetUInt32();
+                        ++count;
+                    }while((count < num) && (items->NextRow()));
+                    ItemPosCountVec dest;
+                    uint8 canStoreNewItem = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item, quantity);
+                    if(canStoreNewItem == EQUIP_ERR_OK)
+                    {
+                        Item *newItem = NULL;
+                        newItem = player->StoreNewItem(dest,item,quantity,true);
+                        player->SendNewItem(newItem,quantity,true,false);
+                    }
+                    else
+                    {
+                        _Creature->MonsterWhisper(SAY_INV_FULL, player->GetGUID());
+                        check = false;
+                    }
+                }
+            }
+            if(aura_id > 0 && check == true)
+            {
+                _Creature->CastSpell(player, aura_id, true);
+            }
+            else if(aura_id < 0 && check == true)
+            {
+                uint32 id = aura_id * -1;
+                uint32 num;
+                uint32 aura;
+                QueryResult_AutoPtr auras = WorldDatabase.PQuery("SELECT `aura_id` FROM `npc_codes_aura_loot` WHERE `group_id` = '%i'",id);
+                if(auras)
+                {
+                    num = rand()%auras->GetRowCount();
+                    Field *a;
+                    uint32 count = 0;
+                    do
+                    {
+                        a = auras->Fetch();
+                        aura = a[0].GetUInt32();
+                        ++count;
+                    }while((count < num) && (auras->NextRow()));
+                    _Creature->CastSpell(player, aura, true);
+                }
+            }
+        }
+        else
+        {
+            check = false;
+            _Creature->MonsterWhisper(SAY_EXPIRED, player->GetGUID());
+        }
+    }
+    else
+    {
+        check = false;
+        _Creature->MonsterWhisper(SAY_INVALID, player->GetGUID());
+    }
+
+
+    if(check == true)
+    {
+        if(uses > 0)
+        {
+            WorldDatabase.PExecute("UPDATE `npc_codes` SET `uses` = (`uses` - 1) WHERE `code` = '%s' LIMIT 1",sCode);
+        }
+        if(item_id != 0 && aura_id == 0)
+            _Creature->MonsterSay(SAY_GIVE_PRESENT, LANG_UNIVERSAL, NULL);
+        if(item_id != 0 && aura_id != 0)
+            _Creature->MonsterSay(SAY_EXTRA_BUFF, LANG_UNIVERSAL, NULL);
+        if(item_id == 0 && aura_id != 0)
+            _Creature->MonsterSay(SAY_GIVE_BUFF, LANG_UNIVERSAL, NULL);
+    }
+    return check;
+}
+
+//This function is called when the player opens the gossip menubool
+bool GossipHello_npc_codebox(Player *player, Creature *_Creature)
+{
+    int32 text_id = C_GOSSIP_MENU;
+    
+    extern DatabaseType WorldDatabase;
+    uint32 creatureID = _Creature->GetEntry();
+
+    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `npc_text_id` FROM `npc_codes_text` WHERE npc_id = %i LIMIT 1",creatureID);
+    if(result)
+    {
+        Field *fields = result->Fetch();
+        text_id = fields[0].GetInt32();
+    }
+
+    player->ADD_GOSSIP_ITEM_EXTENDED(0, D_ENTER_CODE, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1, "", 0, true);
+    player->ADD_GOSSIP_ITEM(0, D_CANCEL_CODE, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+
+    player->PlayerTalkClass->SendGossipMenu(text_id,_Creature->GetGUID());
+    return true;
+}
+
+//This function is called when the player clicks an option on the gossip menubool
+bool GossipSelect_npc_codebox(Player *player, Creature *_Creature, uint32 sender, uint32 action )
+{
+    if(action == GOSSIP_ACTION_INFO_DEF+2)
+    {
+        _Creature->MonsterSay(SAY_GOODBYE, LANG_UNIVERSAL, NULL); 
+        player->CLOSE_GOSSIP_MENU();
+    }
+    return true;
+}
+
+bool GossipSelectWithCode_npc_codebox( Player *player, Creature *_Creature, uint32 sender, uint32 action, const char* sCode )
+{
+    if(sender == GOSSIP_SENDER_MAIN)
+    {
+        if(action == GOSSIP_ACTION_INFO_DEF+1)
+        {
+            checkCode(player, _Creature, sCode);
+            player->CLOSE_GOSSIP_MENU();
+            return true;
+        }
+    }
+    return false;
+}
+
+void AddSC_npc_codebox()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name="npc_codebox";
+    newscript->pGossipHello =           &GossipHello_npc_codebox;
+    newscript->pGossipSelect =          &GossipSelect_npc_codebox;
+    newscript->pGossipSelectWithCode =  &GossipSelectWithCode_npc_codebox;
+    newscript->RegisterSelf();
+}
+
diff -Nuar oregoncore-current/src/scripts/Custom/npc_door_codes.cpp oregoncore-pq/src/scripts/Custom/npc_door_codes.cpp
--- oregoncore-current/src/scripts/Custom/npc_door_codes.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/npc_door_codes.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,87 @@
+/*######
+## npc_door_codes
+######*/
+
+// Based on an awesome script by Pixeel - TC2 Forums
+
+#include "ScriptPCH.h"
+#include "ObjectMgr.h"
+#include "ScriptMgr.h"
+#include "Chat.h"
+
+bool verification1Code(Player *pPlayer, Creature *pCreature, const char* sCode)
+{
+    bool verification1 = false;
+
+    QueryResult_AutoPtr result = WorldDatabase.PQuery( "SELECT `secret`, `gameobject_entry`, `opentimesec` FROM `npc_door_codes` WHERE `secret` = '%s' AND `creature_entry` = %u LIMIT 1", sCode, pCreature->GetEntry() );
+    
+    if(result)
+    {
+        Field *fields = result->Fetch();
+          verification1 = true;
+          uint32 targetGo = fields[1].GetUInt32();
+          GameObject* SecureDoor = pCreature->FindNearestGameObject(targetGo, 10.0f);
+              if (!SecureDoor)
+              {
+                  return false;
+              }
+     
+              if (SecureDoor)
+              {
+                  SecureDoor->UseDoorOrButton(fields[2].GetUInt32());
+              }
+    }
+    
+    if(!result)
+    {
+        verification1 = false;
+    }
+    
+    return verification1;
+}
+
+bool GossipHello_npc_door_codes(Player *pPlayer, Creature *pCreature)
+{
+    pPlayer->ADD_GOSSIP_ITEM_EXTENDED(0, "I know the secret word.", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1, "", 0, true);
+    pPlayer->ADD_GOSSIP_ITEM(0, "I do not know the secret word.", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+
+    pPlayer->PlayerTalkClass->SendGossipMenu(91020,pCreature->GetGUID());
+    return true;
+}
+
+bool GossipSelect_npc_door_codes(Player *pPlayer, Creature *pCreature, uint32 sender, uint32 action )
+{
+    if(action == GOSSIP_ACTION_INFO_DEF+2)
+    {
+        pCreature->MonsterWhisper("Sorry, No one comes in without the secret word.", pPlayer->GetGUID());
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    return true;
+}
+
+bool GossipSelectWithCode_npc_door_codes( Player *player, Creature *pCreature, uint32 sender, uint32 action, const char* sCode )
+{
+    if(sender == GOSSIP_SENDER_MAIN)
+    {
+        if(action == GOSSIP_ACTION_INFO_DEF+1)
+        {
+            verification1Code(player, pCreature, sCode);
+            player->CLOSE_GOSSIP_MENU();
+            return true;
+        }
+    }
+    return false;
+}
+
+void AddSC_npc_door_codes()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name="npc_door_codes";
+    newscript->pGossipHello =           &GossipHello_npc_door_codes;
+    newscript->pGossipSelect =          &GossipSelect_npc_door_codes;
+    newscript->pGossipSelectWithCode =  &GossipSelectWithCode_npc_door_codes;
+    newscript->RegisterSelf();
+    
+}
+
diff -Nuar oregoncore-current/src/scripts/Custom/npc_guildmaster.cpp oregoncore-pq/src/scripts/Custom/npc_guildmaster.cpp
--- oregoncore-current/src/scripts/Custom/npc_guildmaster.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/npc_guildmaster.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,338 @@
+/* ScriptData
+SDName: GuildMaster
+SD%Complete: 95
+SDComment: Guild House Master
+SDCategory: NPC
+EndScriptData */
+
+#include "ScriptPCH.h"
+#include "Config/Config.h"
+
+extern DatabaseType WorldDatabase;
+
+#define MSG_GOSSIP_TELE          "Teleport to Guild House"
+#define MSG_GOSSIP_NEXTPAGE      "Next -->"
+#define MSG_INCOMBAT             "You are in battle!"
+#define MSG_NOGUILDHOUSE         "Your guild does not have a Guild House."
+#define MSG_NOFREEGH             "Unfortunately, all the Guild Houses have been sold."
+#define MSG_ALREADYHAVEGH        "Sorry, but you already have a Guild House (%s)."
+#define MSG_NOTENOUGHMONEY       "You must have %u gold to buy a Guild House."
+#define MSG_GHOCCUPIED           "Unfortunately, this Guild House is already in use."
+#define MSG_CONGRATULATIONS      "Congratulations! You now own a Guild House."
+#define MSG_SOLD                 "You sold your Guild House. Here is %u in gold."
+#define MSG_NOTINGUILD           "You are not in a guild!"
+
+#define CODE_SELL                "SELL"
+#define MSG_CODEBOX_SELL         "Enter \"" CODE_SELL "\" to sell your Guild House."
+
+#define OFFSET_GH_ID_TO_ACTION   1500
+#define OFFSET_SHOWBUY_FROM      10000
+
+#define ACTION_TELE              1001
+#define ACTION_SHOW_BUYLIST      1002  //deprecated. Use (OFFSET_SHOWBUY_FROM + 0) instead
+#define ACTION_SELL_GUILDHOUSE   1003
+
+#define ICON_GOSSIP_BALOON       0
+#define ICON_GOSSIP_WING         2
+#define ICON_GOSSIP_BOOK         3
+#define ICON_GOSSIP_WHEEL1       4
+#define ICON_GOSSIP_WHEEL2       5
+#define ICON_GOSSIP_GOLD         6
+#define ICON_GOSSIP_BALOONDOTS   7
+#define ICON_GOSSIP_TABARD       8
+#define ICON_GOSSIP_XSWORDS      9
+
+#define GOSSIP_COUNT_MAX         10
+
+bool isPlayerGuildLeader(Player *player)
+{
+    return (player->GetRank() == 0) && (player->GetGuildId() != 0);
+}
+
+bool getGuildHouseCoords(uint32 guildId, float &x, float &y, float &z, uint32 &map)
+{
+    if (guildId == 0)
+    {
+        //if player has no guild
+        return false;
+    }
+
+    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `x`, `y`, `z`, `map` FROM `guild_houses` WHERE `guildId` = %u", guildId);
+    if(result)
+    {
+        Field *fields = result->Fetch();
+        x = fields[0].GetFloat();
+        y = fields[1].GetFloat();
+        z = fields[2].GetFloat();
+        map = fields[3].GetUInt32();
+        return true;
+    }
+    return false;
+}
+
+void teleportPlayerToGuildHouse(Player *player, Creature *_creature)
+{
+    if (player->GetGuildId() == 0)
+    {
+        //if player has no guild
+        _creature->MonsterWhisper(MSG_NOTINGUILD, player->GetGUID());
+        return;
+    }
+
+    if (!player->getAttackers().empty())
+    {
+        //if player in combat
+        _creature->MonsterSay(MSG_INCOMBAT, LANG_UNIVERSAL, player->GetGUID());
+        return;
+    }
+
+    float x, y, z;
+    uint32 map;
+
+    if (getGuildHouseCoords(player->GetGuildId(), x, y, z, map))
+    {
+        //teleport player to the specified location
+        player->TeleportTo(map, x, y, z, 0.0f);
+    }
+    else
+        _creature->MonsterWhisper(MSG_NOGUILDHOUSE, player->GetGUID());
+
+}
+
+bool showBuyList(Player *player, Creature *_creature, uint32 showFromId = 0)
+{
+    //show not occupied guildhouses
+
+    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `id`, `comment` FROM `guild_houses` WHERE `guildId` = 0 AND `id` > %u ORDER BY `id` ASC LIMIT %u",
+        showFromId, GOSSIP_COUNT_MAX);
+
+    if (result)
+    {
+        uint32 guildhouseId = 0;
+        std::string comment = "";
+        do
+        {
+
+            Field *fields = result->Fetch();
+
+            guildhouseId = fields[0].GetInt32();
+            comment = fields[1].GetString();
+            
+            //send comment as a gossip item
+            //transmit guildhouseId in Action variable
+            player->ADD_GOSSIP_ITEM(ICON_GOSSIP_TABARD, comment, GOSSIP_SENDER_MAIN,
+                guildhouseId + OFFSET_GH_ID_TO_ACTION);
+
+        } while (result->NextRow());
+
+        if (result->GetRowCount() == GOSSIP_COUNT_MAX)
+        {
+            //assume that we have additional page
+            //add link to next GOSSIP_COUNT_MAX items
+            player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOONDOTS, MSG_GOSSIP_NEXTPAGE, GOSSIP_SENDER_MAIN, 
+                guildhouseId + OFFSET_SHOWBUY_FROM);
+        }
+
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+
+        return true;
+    } else
+    {
+        if (showFromId == 0)
+        {
+            //all guildhouses are occupied
+            _creature->MonsterWhisper(MSG_NOFREEGH, player->GetGUID());
+            player->CLOSE_GOSSIP_MENU();
+        } else
+        {
+            //this condition occurs when COUNT(guildhouses) % GOSSIP_COUNT_MAX == 0
+            //just show GHs from beginning
+            showBuyList(player, _creature, 0);
+        }
+    }
+
+    return false;
+}
+
+bool isPlayerHasGuildhouse(Player *player, Creature *_creature, bool whisper = false)
+{
+
+    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `comment` FROM `guild_houses` WHERE `guildId` = %u",
+        player->GetGuildId());
+
+    if (result)
+    {
+        if (whisper)
+        {
+            //whisper to player "already have etc..."
+            Field *fields = result->Fetch();
+            char msg[100];
+            sprintf(msg, MSG_ALREADYHAVEGH, fields[0].GetString());
+            _creature->MonsterWhisper(msg, player->GetGUID());
+        }
+
+        return true;
+    }
+    return false;
+
+}
+
+void buyGuildhouse(Player *player, Creature *_creature, uint32 guildhouseId)
+{
+    uint32 buyprice = (sConfig.GetIntDefault("GuildMasterNPC.BuyPriceInGold",500)*10000);
+    if (player->GetMoney() < buyprice)
+    {
+        //show how much money player need to buy GH (in gold)
+        char msg[100];
+        sprintf(msg, MSG_NOTENOUGHMONEY, buyprice / 10000);
+        _creature->MonsterWhisper(msg, player->GetGUID());
+        return;
+    }
+
+    if (isPlayerHasGuildhouse(player, _creature, true))
+    {
+        //player already have GH
+        return;
+    }
+
+    //check if somebody already occupied this GH
+    QueryResult_AutoPtr result = WorldDatabase.PQuery("SELECT `id` FROM `guild_houses` WHERE `id` = %u AND `guildId` <> 0",
+        guildhouseId);
+
+    if (result)
+    {
+        _creature->MonsterWhisper(MSG_GHOCCUPIED, player->GetGUID());
+        return;
+    }
+
+    //update DB
+    QueryResult_AutoPtr result_updt = WorldDatabase.PQuery("UPDATE `guild_houses` SET `guildId` = %u WHERE `id` = %u",
+        player->GetGuildId(), guildhouseId);
+    
+    player->ModifyMoney(-buyprice);
+    _creature->MonsterSay(MSG_CONGRATULATIONS, LANG_UNIVERSAL, player->GetGUID());
+    
+}
+
+void sellGuildhouse(Player *player, Creature *_creature)
+{
+    uint32 sellprice = (sConfig.GetIntDefault("GuildMasterNPC.SellPriceInGold",400)*10000);
+    if (isPlayerHasGuildhouse(player, _creature))
+    {
+        QueryResult_AutoPtr result = WorldDatabase.PQuery("UPDATE `guild_houses` SET `guildId` = 0 WHERE `guildId` = %u",
+        player->GetGuildId());
+        
+        player->ModifyMoney(sellprice);
+
+        //display message e.g. "here your money etc."
+        char msg[100];
+        sprintf(msg, MSG_SOLD, (sellprice/10000));
+        _creature->MonsterWhisper(msg, player->GetGUID());
+    }
+}
+
+bool GossipHello_npc_guildmaster(Player *player, Creature *_creature)
+{
+    player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOON, MSG_GOSSIP_TELE, 
+        GOSSIP_SENDER_MAIN, ACTION_TELE);
+
+    if (isPlayerGuildLeader(player))
+    {
+        uint8 buyEnabled = sConfig.GetIntDefault("GuildMasterNPC.BuyEnabled", 1);
+        if ( buyEnabled == 1 )
+        {
+            //show additional menu for guild leader
+            std::string buyGHGossip = sConfig.GetStringDefault("GuildMasterNPC.BuyGossip", "Buy a Guild House for 500 Gold");
+            player->ADD_GOSSIP_ITEM(ICON_GOSSIP_GOLD, buyGHGossip,
+                GOSSIP_SENDER_MAIN, ACTION_SHOW_BUYLIST);
+        }
+        if (isPlayerHasGuildhouse(player, _creature))
+        {
+            uint8 sellEnabled = sConfig.GetIntDefault("GuildMasterNPC.SellEnabled", 1);
+            if ( sellEnabled == 1 )
+            {
+                //and additional for guildhouse owner
+                std::string sellGHGossip = sConfig.GetStringDefault("GuildMasterNPC.SellGossip", "Sell your Guild House for 400 Gold");
+                player->PlayerTalkClass->GetGossipMenu().AddMenuItem(ICON_GOSSIP_GOLD, sellGHGossip, GOSSIP_SENDER_MAIN, ACTION_SELL_GUILDHOUSE, MSG_CODEBOX_SELL, 0, true);
+            }
+        }
+    }
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+    return true;
+}
+
+
+bool GossipSelect_npc_guildmaster(Player *player, Creature *_creature, uint32 sender, uint32 action )
+{
+    if (sender != GOSSIP_SENDER_MAIN)
+        return false;
+
+    switch (action)
+    {
+        case ACTION_TELE:
+            //teleport player to GH
+            player->CLOSE_GOSSIP_MENU();
+            teleportPlayerToGuildHouse(player, _creature);
+            break;
+        case ACTION_SHOW_BUYLIST:
+            //show list of GHs which currently not occupied
+            showBuyList(player, _creature);
+            break;
+        default:
+            if (action > OFFSET_SHOWBUY_FROM)
+            {
+                showBuyList(player, _creature, action - OFFSET_SHOWBUY_FROM);
+            } else if (action > OFFSET_GH_ID_TO_ACTION)
+            {
+                //player clicked on buy list
+                player->CLOSE_GOSSIP_MENU();
+                //get guildhouseId from action
+                //guildhouseId = action - OFFSET_GH_ID_TO_ACTION
+                buyGuildhouse(player, _creature, action - OFFSET_GH_ID_TO_ACTION);
+            }
+            break;
+    }
+    
+    return true;
+}
+
+bool GossipSelectWithCode_npc_guildmaster( Player *player, Creature *_creature,
+                                      uint32 sender, uint32 action, const char* sCode )
+{
+    if(sender == GOSSIP_SENDER_MAIN)
+    {
+        if(action == ACTION_SELL_GUILDHOUSE)
+        {
+            int i = -1;
+            try
+            {
+                //compare code
+                if (strlen(sCode) + 1 == sizeof CODE_SELL)
+                    i = strcmp(CODE_SELL, sCode);
+
+            } catch(char *str) {error_db_log(str);}
+
+            if (i == 0)
+            {
+                //right code
+                sellGuildhouse(player, _creature);
+            }
+            player->CLOSE_GOSSIP_MENU();
+            return true;
+        }
+    }
+    return false;
+}
+
+
+void AddSC_npc_guildmaster()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "npc_guildmaster";
+    newscript->pGossipHello = &GossipHello_npc_guildmaster;
+    newscript->pGossipSelect = &GossipSelect_npc_guildmaster;
+    newscript->pGossipSelectWithCode =  &GossipSelectWithCode_npc_guildmaster;
+    newscript->RegisterSelf();
+}
+
diff -Nuar oregoncore-current/src/scripts/Custom/npc_heal.cpp oregoncore-pq/src/scripts/Custom/npc_heal.cpp
--- oregoncore-current/src/scripts/Custom/npc_heal.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/npc_heal.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,91 @@
+/* ScriptData
+SDName: NPC_Heal
+SD%Complete: 100
+SDComment: Healer
+SDCategory: NPC
+EndScriptData */
+
+#include "ScriptPCH.h"
+
+bool GossipHello_NPC_Heal(Player *player, Creature *_Creature)
+{
+    // Main Menu 
+    player->ADD_GOSSIP_ITEM( 5, "Give me Blessing of Might"
+    , GOSSIP_SENDER_MAIN, 1035);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Blessing of Wisdom"
+    , GOSSIP_SENDER_MAIN, 1040);
+    player->ADD_GOSSIP_ITEM( 5, "Give me Power Word: Fortitude"
+    , GOSSIP_SENDER_MAIN, 1045);
+    player->ADD_GOSSIP_ITEM( 5, "Heal Me, Please"
+    , GOSSIP_SENDER_MAIN, 4010);
+    player->ADD_GOSSIP_ITEM( 5, "Remove Resurrect Sickness"
+    , GOSSIP_SENDER_MAIN, 5000);
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+    return true;
+}
+
+void SendDefaultMenu_NPC_Heal(Player *player, Creature *_Creature, uint32 action )
+{
+
+switch(action)
+{
+
+// Small Buff
+
+case 1035: // Give me Blessing of Might
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,19838,false);
+break;
+
+case 1040: // Give me Blessing of Wisdom
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,25290,false);
+break;
+
+case 1045: // Give me Power Word: Fortitude
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,10938,false);
+break;
+
+// Player Tools
+
+case 4010: // Heal me please
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->CastSpell(player,38588,false);
+break;
+
+case 5000: // Remove Res Sickness
+    if(!player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0)) {
+        _Creature->MonsterWhisper("You do not have resurrection sickness.", player->GetGUID());
+        GossipHello_NPC_Heal(player, _Creature);
+        return;
+    }
+
+    _Creature->CastSpell(player,38588,false); // Healing effect
+    player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+    player->CLOSE_GOSSIP_MENU();
+    break;
+
+    player->CLOSE_GOSSIP_MENU();
+
+    } // end of switch
+} //end of function
+
+bool GossipSelect_NPC_Heal(Player *player, Creature *_Creature, uint32 sender, uint32 action)
+{
+    // Main menu
+    if (sender == GOSSIP_SENDER_MAIN)
+        SendDefaultMenu_NPC_Heal( player, _Creature, action );
+    return true;
+}
+
+void AddSC_npc_heal()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "npc_heal";
+    newscript->pGossipHello = &GossipHello_NPC_Heal;
+    newscript->pGossipSelect = &GossipSelect_NPC_Heal;
+    newscript->RegisterSelf();
+}
+
diff -Nuar oregoncore-current/src/scripts/Custom/npc_rename.cpp oregoncore-pq/src/scripts/Custom/npc_rename.cpp
--- oregoncore-current/src/scripts/Custom/npc_rename.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/npc_rename.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,68 @@
+#include "ScriptPCH.h"
+#include "Config/Config.h"
+
+enum ActNpcRename
+{
+    ACT_RENAME   = 1001,
+    ACT_CONFIRM  = 1002
+};
+
+#define GOSSIP_RENAME_HELLO        "I want to change my name and hide a terrible deed."
+#define GOSSIP_RENAME_CONFIRM      "Are you sure?"
+#define MSG_NOT_ENOUGH_MONEY       "Get out, you are wasting my time!  Come back if you can pay me!"
+#define MSG_COMPLETE_RENAME        "Done!  Now log out of the game and sign in again.  Your secret will die with you!"
+
+bool GossipHello_npc_rename(Player* pPlayer, Creature* pCreature)
+{
+    bool EnableRename = sConfig.GetBoolDefault("RenameNPC.Enable", true);
+
+    if (EnableRename)
+    {
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_RENAME_HELLO, GOSSIP_SENDER_MAIN, ACT_RENAME);
+        pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, pCreature->GetGUID());
+    }
+    return true;
+}
+
+bool GossipSelect_npc_rename(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    if (uiSender != GOSSIP_SENDER_MAIN)
+        return false;
+
+        uint32 RenameCost = sConfig.GetIntDefault("RenameNPC.CostInGold", 100);
+        uint32 RenameCopper = RenameCost * 10000;
+
+    switch (uiAction)
+    {
+        case ACT_RENAME:
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_RENAME_CONFIRM, GOSSIP_SENDER_MAIN, ACT_CONFIRM);
+            pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, pCreature->GetGUID());
+            break;
+        case ACT_CONFIRM:
+            if (pPlayer->GetMoney() < RenameCopper)
+            {
+                pCreature->MonsterWhisper(MSG_NOT_ENOUGH_MONEY, pPlayer->GetGUID());
+            } else {
+                pCreature->MonsterWhisper(MSG_COMPLETE_RENAME, pPlayer->GetGUID());
+                pPlayer->ModifyMoney(-RenameCopper);
+                pPlayer->SetAtLoginFlag(AT_LOGIN_RENAME);
+            }
+            pPlayer->CLOSE_GOSSIP_MENU();
+            break;
+        default: 
+            pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    return true;
+}
+
+void AddSC_npc_rename()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="npc_rename";
+    newscript->pGossipHello = &GossipHello_npc_rename;
+    newscript->pGossipSelect = &GossipSelect_npc_rename;
+    newscript->RegisterSelf();
+}
+
diff -Nuar oregoncore-current/src/scripts/Custom/npc_rentalmount.cpp oregoncore-pq/src/scripts/Custom/npc_rentalmount.cpp
--- oregoncore-current/src/scripts/Custom/npc_rentalmount.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/npc_rentalmount.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,65 @@
+#include "ScriptPCH.h" 
+#include "Config/Config.h"
+
+#define MSG_GOSSIP_TEXT_1  "I would like to rent a mount." 
+#define MSG_GOSSIP_TEXT_2  "I would like to rent a very fast mount." 
+#define MSG_NOT_MONEY      "You do not have enough money." 
+#define MSG_MOUTED         "You already have a mount." 
+#define MOUNT_SPELL_ID_1   43899 
+#define MOUNT_SPELL_ID_2   43900 
+
+bool GossipHello_npc_rentalmount(Player *player, Creature *_creature) 
+{ 
+    player->ADD_GOSSIP_ITEM(4, MSG_GOSSIP_TEXT_1, GOSSIP_SENDER_MAIN, 1001); 
+    player->ADD_GOSSIP_ITEM(4, MSG_GOSSIP_TEXT_2, GOSSIP_SENDER_MAIN, 1002); 
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID()); 
+    return true; 
+} 
+
+bool GossipSelect_npc_rentalmount(Player *player, Creature *_creature, uint32 sender, uint32 action ) 
+{ 
+    if (sender != GOSSIP_SENDER_MAIN) 
+        return false; 
+
+    if (player->IsMounted()){ 
+        _creature->MonsterWhisper(MSG_MOUTED, player->GetGUID()); 
+         return false; 
+    } 
+
+    uint32 slowprice = sConfig.GetIntDefault("RentalMountNPC.SlowPrice",100);
+    uint32 fastprice = sConfig.GetIntDefault("RentalMountNPC.FastPrice",500);
+
+    switch (action) 
+    { 
+    case 1001: 
+        if (player->GetMoney() < slowprice) 
+        { 
+            _creature->MonsterWhisper(MSG_NOT_MONEY, player->GetGUID()); 
+        } else { 
+            player->AddAura(MOUNT_SPELL_ID_1,    player); 
+            player->ModifyMoney(-slowprice); 
+        } 
+        break; 
+    case 1002: 
+        if (player->GetMoney() < fastprice) 
+        { 
+            _creature->MonsterWhisper(MSG_NOT_MONEY, player->GetGUID()); 
+        } else { 
+            player->AddAura(MOUNT_SPELL_ID_2,    player); 
+            player->ModifyMoney(-fastprice); 
+        } 
+        break; 
+    } 
+    player->CLOSE_GOSSIP_MENU();
+    return true; 
+} 
+
+void AddSC_npc_rentalmount() 
+{ 
+     Script *newscript; 
+     newscript = new Script; 
+     newscript->Name = "npc_rentalmount"; 
+     newscript->pGossipHello = &GossipHello_npc_rentalmount; 
+     newscript->pGossipSelect = &GossipSelect_npc_rentalmount; 
+     newscript->RegisterSelf(); 
+}
diff -Nuar oregoncore-current/src/scripts/Custom/npc_teleport.cpp oregoncore-pq/src/scripts/Custom/npc_teleport.cpp
--- oregoncore-current/src/scripts/Custom/npc_teleport.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/npc_teleport.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,220 @@
+/**
+ * npc_teleport.cpp
+ * Based on code by Wilibald09
+ **/
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+#include <sstream>
+
+
+#define GOSSIP_SHOW_DEST        1000
+#define GOSSIP_TELEPORT         1001
+#define GOSSIP_NEXT_PAGEC       1002
+#define GOSSIP_PREV_PAGEC       1003
+#define GOSSIP_NEXT_PAGED       1004
+#define GOSSIP_PREV_PAGED       1005
+#define GOSSIP_MAIN_MENU        1006
+
+#define SPELL_VISUAL_TELEPORT   35517
+
+#define NB_ITEM_PAGE            10
+#define MSG_CAT                 100000
+#define MSG_DEST                100001
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+
+using namespace nsNpcTel;
+
+
+namespace
+{
+    Page PageC, PageD;
+    Page Cat;
+
+    // Conversion function int->string
+    std::string ConvertStr(const int64 &val)
+    {
+        std::ostringstream ostr;
+        ostr << val;
+        return ostr.str();
+    }
+
+    // Conversion function intMoney->stringMoney
+    std::string ConvertMoney(const uint32 &Money)
+    {
+        std::string Str(ConvertStr(Money));
+        uint32 SizeStr = Str.length();
+
+        if (SizeStr > 4)
+            Str = Str.insert(Str.length()-4, "g");
+        if (SizeStr > 2)
+            Str = Str.insert(Str.length()-2, "s");
+        Str += "c";
+
+        return Str;
+    }
+
+    // Teleport Player
+    void Teleport(Creature * const creature, Player * const player, 
+                  const uint16 &map, const float &X, const float &Y,
+                  const float &Z, const float &orient, 
+                  const uint32 &cast_on_arrival)
+    {
+        player->CastSpell(player, SPELL_VISUAL_TELEPORT, true);
+        player->TeleportTo(map, X, Y, Z, orient);
+        if ( cast_on_arrival > 0 )
+          creature->CastSpell(player, cast_on_arrival, true);
+    }
+
+    // Display categories
+    void AffichCat(Player * const player, Creature * const creature)
+    {
+        if (PageC[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGEC, 0);
+
+        VCatDest_t i (PageC[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest.size() && i < (NB_ITEM_PAGE * (PageC[player] + 1)); ++i)
+        {
+            if (TabCatDest[i].IsAllowedToTeleport(player))
+                player->ADD_GOSSIP_ITEM(7, TabCatDest[i].GetName(player->isGameMaster()).c_str(), GOSSIP_SHOW_DEST, i);
+        }
+
+        if (i < TabCatDest.size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGEC, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_CAT, creature->GetGUID());
+    }
+
+    // Display destination categories
+    void AffichDest(Player * const player, Creature * const creature)
+    {
+        if (PageD[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGED, 0);
+
+        CatDest::VDest_t i (PageD[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest[Cat[player]].size() && i < (NB_ITEM_PAGE * (PageD[player] + 1)); ++i)
+        {
+            player->ADD_GOSSIP_ITEM(5, TabCatDest[Cat[player]].GetDest(i).m_name.c_str(), GOSSIP_TELEPORT, i);
+        }
+
+        if (i < TabCatDest[Cat[player]].size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGED, 0);
+
+        if (CatDest::CountOfCategoryAllowedBy(player) > 1)
+            player->ADD_GOSSIP_ITEM(7, MAIN_MENU, GOSSIP_MAIN_MENU, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_DEST, creature->GetGUID());
+    }
+
+    // Verification before teleportation
+    void ActionTeleport(Player * const player, Creature * const creature, const uint32 &id)
+    {
+        Dest dest (TabCatDest[Cat[player]].GetDest(id));
+
+        if (player->getLevel() < dest.m_level && !player->isGameMaster()) 
+        {
+            std::string msg ("You do not meet the level requirement. This destination requires level " + ConvertStr(dest.m_level) + ".");
+            creature->MonsterWhisper(msg.c_str(), player->GetGUID());
+            return;
+        }
+
+        if (player->GetMoney() < dest.m_cost && !player->isGameMaster())
+        {
+            std::string msg ("You do not have enough money. The price for teleportation is " + ConvertMoney(dest.m_cost) + ".");
+            creature->MonsterWhisper(msg.c_str(), player->GetGUID());
+            return;
+        }
+
+        if (!player->isGameMaster() && dest.m_cost)
+            player->ModifyMoney(-1 * dest.m_cost);
+
+        std::string saydepart = dest.m_sayondeparture;
+        creature->MonsterSay( saydepart.c_str(), LANG_UNIVERSAL, NULL );
+
+        Teleport(creature, player, dest.m_map, dest.m_X, dest.m_Y, dest.m_Z, dest.m_orient, dest.m_castonarrival );
+    }
+}
+
+bool GossipHello_npc_teleport(Player *player, Creature *creature)
+{
+    PageC(player) = PageD(player) = Cat(player) = 0;
+
+    if(player->isInCombat())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->MonsterWhisper("You are in combat!", player->GetGUID());
+        return true;
+    }
+    AffichCat(player, creature);
+    return true;
+}
+
+bool GossipSelect_npc_teleport(Player *player, Creature *creature, uint32 sender, uint32 param)
+{
+    switch(sender) 
+    {
+      // Display destinations
+      case GOSSIP_SHOW_DEST:
+        Cat(player) = param;
+        AffichDest(player, creature);
+        break;
+
+      // Previous categories page
+      case GOSSIP_PREV_PAGEC:
+        --PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Next page categories
+      case GOSSIP_NEXT_PAGEC:
+        ++PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Previous destinations page
+      case GOSSIP_PREV_PAGED:
+        --PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Next destination page
+      case GOSSIP_NEXT_PAGED:
+        ++PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Display main menu
+      case GOSSIP_MAIN_MENU:
+        GossipHello_npc_teleport(player, creature);
+        break;
+
+      // Teleportation
+      case GOSSIP_TELEPORT:
+        player->CLOSE_GOSSIP_MENU();
+        if(player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0)) {
+            creature->CastSpell(player,38588,false); // Healing effect
+            player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+
+        ActionTeleport(player, creature, param);
+        break;
+    }
+    return true;
+}
+
+
+void AddSC_npc_teleport()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name="npc_teleport";
+    newscript->pGossipHello =  &GossipHello_npc_teleport;
+    newscript->pGossipSelect = &GossipSelect_npc_teleport;
+    newscript->RegisterSelf();
+}
+
diff -Nuar oregoncore-current/src/scripts/Custom/npc_tokens.cpp oregoncore-pq/src/scripts/Custom/npc_tokens.cpp
--- oregoncore-current/src/scripts/Custom/npc_tokens.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/npc_tokens.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,192 @@
+/* ScriptData
+SDName: Token Exchange NPC
+SD%Complete: 100
+SDComment: By Celtus based on concepts from the TC2 Forums
+SDCategory: NPC
+EndScriptData */
+
+#include "ScriptPCH.h"
+#include <cstring>
+
+extern DatabaseType WorldDatabase;
+
+uint32 goldItemId;
+uint32 tokensForGold;
+uint32 goldGranted;
+uint32 levelItemId;
+uint32 tokensForLevel;
+uint32 levelsGranted;
+uint32 honorItemId;
+uint32 tokensForHonor;
+uint32 honorGranted;
+uint32 arenaItemId;
+uint32 tokensForArena;
+uint32 arenaGranted;
+uint32 skillItemId;
+uint32 tokensForMaxSkill;
+
+bool GossipHello_npc_tokens(Player* pPlayer, Creature* pCreature)
+{
+    uint32 playerLevel = pPlayer->getLevel();
+
+    QueryResult_AutoPtr result0 = WorldDatabase.PQuery("SELECT `curr_item_id`, `curr_cost`, `count_granted` FROM `npc_tokens` WHERE `type` = 0 AND `min_level` <= %i AND `max_level` >= %i LIMIT 1", playerLevel, playerLevel);
+    if (result0) 
+    {
+      Field *fields0 = result0->Fetch();
+      goldItemId = fields0[0].GetUInt32(); 
+      tokensForGold = fields0[1].GetUInt32();
+      goldGranted = fields0[2].GetUInt32();
+      pPlayer->ADD_GOSSIP_ITEM( 9, "Trade Tokens for Gold", GOSSIP_SENDER_MAIN, 1000);
+    }
+    QueryResult_AutoPtr result1 = WorldDatabase.PQuery("SELECT `curr_item_id`, `curr_cost`, `count_granted` FROM `npc_tokens` WHERE `type` = 1 AND `min_level` <= %i AND `max_level` >= %i LIMIT 1", playerLevel, playerLevel);
+    if (result1)
+    {
+      Field *fields1 = result1->Fetch();
+      levelItemId = fields1[0].GetUInt32();
+      tokensForLevel = fields1[1].GetUInt32();
+      levelsGranted = fields1[2].GetUInt32();
+      pPlayer->ADD_GOSSIP_ITEM( 9, "Trade Tokens for Levels", GOSSIP_SENDER_MAIN, 2000);
+    }
+    QueryResult_AutoPtr result2 = WorldDatabase.PQuery("SELECT `curr_item_id`, `curr_cost`, `count_granted` FROM `npc_tokens` WHERE `type` = 2 AND `min_level` <= %i AND `max_level` >= %i LIMIT 1", playerLevel, playerLevel);
+    if (result2)
+    {
+      Field *fields2 = result2->Fetch();
+      honorItemId = fields2[0].GetUInt32();
+      tokensForHonor = fields2[1].GetUInt32();
+      honorGranted = fields2[2].GetUInt32();
+      pPlayer->ADD_GOSSIP_ITEM( 9, "Trade Tokens for Honor Points", GOSSIP_SENDER_MAIN, 3000);
+    }
+    QueryResult_AutoPtr result3 = WorldDatabase.PQuery("SELECT `curr_item_id`, `curr_cost`, `count_granted` FROM `npc_tokens` WHERE `type` = 3 AND `min_level` <= %i AND `max_level` >= %i LIMIT 1", playerLevel, playerLevel);
+    if (result3)
+    {
+      Field *fields3 = result3->Fetch();
+      arenaItemId = fields3[0].GetUInt32();
+      tokensForArena = fields3[1].GetUInt32();
+      arenaGranted = fields3[2].GetUInt32();      
+      pPlayer->ADD_GOSSIP_ITEM( 9, "Trade Tokens for Arena Points", GOSSIP_SENDER_MAIN, 4000);
+    }
+    QueryResult_AutoPtr result4 = WorldDatabase.PQuery("SELECT `curr_item_id`, `curr_cost` FROM `npc_tokens` WHERE `type` = 4 AND `min_level` <= %i AND `max_level` >= %i LIMIT 1", playerLevel, playerLevel);
+    if (result4)    {
+      Field *fields4 = result4->Fetch();
+      skillItemId = fields4[0].GetUInt32();
+      tokensForMaxSkill = fields4[1].GetUInt32();
+      pPlayer->ADD_GOSSIP_ITEM( 9, "Trade Tokens for Maximum Skills", GOSSIP_SENDER_MAIN, 5000);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;    
+}
+
+void SendDefaultMenu_npc_tokens(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+    // Not allowed if in combat.
+    if (pPlayer->isInCombat())
+    {
+      pPlayer->CLOSE_GOSSIP_MENU();
+      pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+      return;
+    }
+    
+    // Process menu selection
+    switch(uiAction)
+    {
+        case 1000:
+            // Trade Tokens for Gold
+            if(pPlayer->HasItemCount(goldItemId, tokensForGold , true))
+            {
+                pPlayer->CLOSE_GOSSIP_MENU();
+                pPlayer->DestroyItemCount(goldItemId, tokensForGold, true);
+                pPlayer->ModifyMoney(goldGranted * 10000);
+                pCreature->MonsterWhisper("Here is your Gold.", pPlayer->GetGUID());
+            }
+            else
+            {
+                pPlayer->CLOSE_GOSSIP_MENU();
+                pCreature->MonsterSay("You do not have enough tokens!", LANG_UNIVERSAL, NULL);
+            }
+            break;
+
+        case 2000:
+            // Trade Tokens for Level
+            if(pPlayer->HasItemCount(levelItemId, tokensForLevel, true))
+            {
+                pPlayer->CLOSE_GOSSIP_MENU();
+                pPlayer->DestroyItemCount(levelItemId, tokensForLevel, true);
+                pPlayer->GiveLevel(pPlayer->getLevel() + levelsGranted);
+                pCreature->MonsterWhisper("Your level has been changed.", pPlayer->GetGUID());
+            }
+            else
+            {
+                pPlayer->CLOSE_GOSSIP_MENU();
+                pCreature->MonsterSay("You do not have enough tokens!", LANG_UNIVERSAL, NULL);
+            }
+            break;
+
+        case 3000:
+            // Trade Tokens for Honor Points
+            if(pPlayer->HasItemCount(honorItemId, tokensForHonor, true))
+            {
+                pPlayer->CLOSE_GOSSIP_MENU();
+                pPlayer->DestroyItemCount(honorItemId, tokensForHonor, true);
+                pPlayer->ModifyHonorPoints(+ honorGranted);
+                pCreature->MonsterWhisper("Here are your Honor Points.", pPlayer->GetGUID());
+            }
+            else
+            {
+                pPlayer->CLOSE_GOSSIP_MENU();
+                pCreature->MonsterSay("You do not have enough tokens!", LANG_UNIVERSAL, NULL);
+            }
+            break;
+ 
+        case 4000:
+            // Trade Tokens for Arena Points
+            if(pPlayer->HasItemCount(arenaItemId, tokensForArena, true))
+            {
+                pPlayer->CLOSE_GOSSIP_MENU();
+                pPlayer->DestroyItemCount(arenaItemId, tokensForArena, true);
+                pPlayer->ModifyArenaPoints(+ arenaGranted);
+                pCreature->MonsterWhisper("Here are your Arena Points.", pPlayer->GetGUID());
+            }
+            else
+            {
+                pPlayer->CLOSE_GOSSIP_MENU();
+                pCreature->MonsterSay("You do not have enough tokens!", LANG_UNIVERSAL, NULL);
+            }
+            break;
+
+        case 5000:
+            // Trade Tokens for MaxSkill
+            if(pPlayer->HasItemCount(skillItemId, tokensForMaxSkill, true))
+            {
+                pPlayer->CLOSE_GOSSIP_MENU();
+                pPlayer->DestroyItemCount(skillItemId, tokensForMaxSkill, true);
+                pPlayer->UpdateSkillsToMaxSkillsForLevel();
+                pCreature->MonsterWhisper("Your Skills are now at Maximum", pPlayer->GetGUID());
+            }
+            else
+            {
+                pPlayer->CLOSE_GOSSIP_MENU();
+                pCreature->MonsterSay("You do not have enough tokens!", LANG_UNIVERSAL, NULL);
+            }
+            break;
+    }
+}
+
+bool GossipSelect_npc_tokens(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    // Show menu
+    if (uiSender == GOSSIP_SENDER_MAIN)
+        SendDefaultMenu_npc_tokens(pPlayer, pCreature, uiAction);
+    return true;
+}
+
+void AddSC_npc_tokens()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "npc_tokens";
+    newscript->pGossipHello = &GossipHello_npc_tokens;
+    newscript->pGossipSelect = &GossipSelect_npc_tokens;
+    newscript->RegisterSelf();
+}
+
diff -Nuar oregoncore-current/src/scripts/Custom/sc_npc_teleport.cpp oregoncore-pq/src/scripts/Custom/sc_npc_teleport.cpp
--- oregoncore-current/src/scripts/Custom/sc_npc_teleport.cpp	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/sc_npc_teleport.cpp	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,365 @@
+/**
+ * sc_npc_teleport.cpp
+ * Based on code by Wilibald09
+ **/
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+#include "ProgressBar.h"
+
+#define TELE    nsNpcTel::CatDest
+#define PAGE    nsNpcTel::Page
+#define PAGEI   PAGE::Instance
+
+
+nsNpcTel::VCatDest nsNpcTel::TabCatDest;
+
+
+const uint32 PAGE::operator [] (Player * const player) const
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i].GetPageId();
+    }
+    return 0;
+}
+
+PAGE::Instance & PAGE::operator () (Player * const player)
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i];
+    }
+    m_TabInstance.push_back(Instance(player));
+    return m_TabInstance.back();
+}
+
+PAGE::Instance & PAGEI::operator = (const uint32 &id)
+{
+    m_PageId = id;
+    return *this;
+}
+
+PAGE::Instance & PAGEI::operator ++ (void)
+{
+    ++m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator ++ (int32)
+{
+    Instance tmp (*this);
+    ++m_PageId;
+    return tmp;
+}
+
+PAGE::Instance & PAGEI::operator -- (void)
+{
+    --m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator -- (int32)
+{
+    Instance tmp (*this);
+    --m_PageId;
+    return tmp;
+}
+
+TELE::CatDest(const uint32 &id, const std::string &name,
+              const Flag &flag, const uint64 &data0, const uint32 &data1)
+    : m_id(id), m_name(name), m_flag(flag), m_data0(data0), m_data1(data1)
+{
+    m_TabDest.clear();
+}
+
+std::string TELE::GetName(const bool IsGM /* = false */) const
+{
+    if (!IsGM || m_flag != FLAG_TEAM)
+        return m_name;
+
+    switch (m_data0)
+    {
+      case TEAM_HORDE:      return std::string(m_name + " (H)");
+      case TEAM_ALLIANCE:   return std::string(m_name + " (A)");
+    }
+    return m_name;
+}
+
+bool TELE::IsAllowedToTeleport(Player * const player) const
+{
+    if (player->isGameMaster())
+    {
+        if (m_flag == FLAG_GMLEVEL)
+            return player->GetSession()->GetSecurity() >= m_data0;
+        return true;
+    }
+
+    switch (m_flag)
+    {
+      case FLAG_TEAM:
+        switch (m_data0)
+        {
+          case TEAM_HORDE:      return player->GetTeam() == HORDE;
+          case TEAM_ALLIANCE:   return player->GetTeam() == ALLIANCE;
+          case TEAM_ALL:        return true;
+        }
+
+      case FLAG_GUILD:
+        return player->GetGuildId() == m_data0;
+
+      case FLAG_GMLEVEL:
+        return player->GetSession()->GetSecurity() >= m_data0;
+
+      case FLAG_ISGM:
+        return player->isGameMaster();
+
+      case FLAG_ACCOUNT:
+        return player->GetSession()->GetAccountId() == m_data0;
+
+      case FLAG_LEVEL:
+        return player->getLevel() >= m_data0;
+
+      case FLAG_ITEM:
+        return player->HasItemCount(m_data0, m_data1, true);
+
+      case FLAG_QUEST:
+        if (m_data1 < MAX_QUEST_STATUS)
+            return player->GetQuestStatus(m_data0) == m_data1;
+        return player->GetQuestRewardStatus(m_data0);
+
+      case FLAG_GENDER:
+        return player->getGender() == m_data0;
+
+      case FLAG_RACE:
+        return player->getRace() == m_data0;
+
+      case FLAG_CLASS:
+        return player->getClass() == m_data0;
+
+      case FLAG_REPUTATION:
+        return player->GetReputationRank(m_data0) >= m_data1;
+
+      case FLAG_PLAYER:
+        return player->GetGUID() == m_data0;
+    }
+
+    error_log("Invalid flag (category: %u). Important problem...", GetCatID());
+    return false;
+}
+
+uint32 TELE::CountOfCategoryAllowedBy(Player * const player)
+{
+    uint32 count (0);
+    for (VCatDest_t i(0); i < TabCatDest.size(); ++i)
+    {   
+        if (TabCatDest[i].IsAllowedToTeleport(player))
+            ++count;
+    }
+    return count;
+}
+
+bool nsNpcTel::IsValidData(const uint32 &cat,   const Flag &flag,
+                           const uint64 &data0, const uint32 &data1)
+{
+    switch(flag)
+    {
+      case FLAG_TEAM:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0 < MAX_FLAG_TEAM)
+            return true;
+        error_log("Invalid data0 (Team) (category: %u).", cat);
+        return false;
+
+      case FLAG_GUILD:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        error_log("Invalid data0 (GuildID) (category: %u).", cat);
+        return false;
+
+      case FLAG_GMLEVEL:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        error_log("Invalid data0 (GmLevel) (category: %u).", cat);
+        return false;
+
+      case FLAG_ISGM:
+        if (data0)
+            error_log("Invalid data0 (category: %u).", cat);
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        return true;
+
+      case FLAG_ACCOUNT:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        error_log("Invalid data0 (AccountID) (category: %u).", cat);
+        return false;
+
+      case FLAG_LEVEL:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        error_log("Invalid data0 (Level) (category: %u).", cat);
+        return false;
+
+      case FLAG_ITEM:
+        if (!data0)
+        {
+            error_log("Invalid data0 (ItemID) (category: %u).", cat);
+            return false;
+        }
+        if (data1)
+            return true;
+        error_log("Invalid data1 (Item Count) (category: %u).", cat);
+        return false;
+
+      case FLAG_QUEST:
+        if (!data0)
+        {
+            error_log("Invalid data0 (QuestID) (category: %u).", cat);
+            return false;
+        }
+        if (data1 < MAX_QUEST_STATUS + 1)
+            return true;
+        error_log("Invalid data1 (Quest Status) (category: %u).", cat);
+        return false;
+
+      case FLAG_GENDER:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0 < GENDER_NONE)
+            return true;
+        error_log("Invalid data0 (Gender) (category: %u).", cat);
+        return false;
+
+      case FLAG_RACE:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_RACES)
+            return true;
+        error_log("Invalid data0 (Race) (category: %u).", cat);
+        return false;
+
+      case FLAG_CLASS:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_CLASSES)
+            return true;
+        error_log("Invalid data0 (Class) (category: %u).", cat);
+        return false;
+
+      case FLAG_REPUTATION:
+        if (!data0)
+        {
+            error_log("Invalid data0 (Faction/Reputation) (category: %u).", cat);
+            return false;
+        }
+        if (data1 <= REP_EXALTED)
+            return true;
+        error_log("Invalid data1 (Faction/Reputation) (category: %u).", cat);
+        return false;
+
+      case FLAG_PLAYER:
+        if (data1)
+            error_log("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        error_log("Invalid data0 (PlayerGuid) (category: %u).", cat);
+        return false;
+    }
+
+    error_log("Invalid flag (category: %u).", cat);
+    return false;
+}
+
+void LoadNpcTele(QueryResult_AutoPtr result)
+{
+
+    result = WorldDatabase.PQuery(
+    "SELECT C.`flag`, C.`data0`, C.`data1`, A.`cat_id`, C.`name` `namecat`, "
+          " D.`name` `namedest`, D.`pos_X`, D.`pos_Y`, D.`pos_Z`, "
+          " D.`orientation`, D.`map`, D.`level`, D.`cost`, A.`display_order`, "
+          " D.`say_on_departure`, D.`cast_on_arrival` "
+    " FROM `npc_teleport_category` C, `npc_teleport_destination` D, "
+    " `npc_teleport_association` A " 
+    " WHERE C.`id` = A.`cat_id` AND D.`id` = A.`dest_id` "
+    " ORDER BY A.`cat_id`, A.`display_order`, `namedest`");
+
+    nsNpcTel::TabCatDest.clear();
+
+    if (result)
+    {
+        outstring_log( "OSCR: Loading NPC Teleport Data...");
+        barGoLink bar(result->GetRowCount());
+
+        uint32 catid = 0;
+        uint32 nbDest = 0;
+        bool IsValidCat = true;
+        bool FirstTime = true;
+
+        do
+        {
+            bar.step();
+            Field *fields = result->Fetch();
+
+            if (!IsValidCat && catid == fields[3].GetUInt32() && !FirstTime)
+                continue;
+
+            IsValidCat = true;
+            FirstTime = false;
+
+            if (!nsNpcTel::IsValidData(fields[3].GetUInt32(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+               fields[1].GetUInt64(), fields[2].GetUInt32()))
+            {
+                IsValidCat = false;
+                catid = fields[3].GetUInt32();
+                continue;
+            }
+
+            if (catid != fields[3].GetUInt32())
+            {
+                catid = fields[3].GetUInt32();
+                nsNpcTel::CatDest categorie (catid, fields[4].GetCppString(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                  fields[1].GetUInt64(), fields[2].GetUInt32());
+                nsNpcTel::TabCatDest.push_back(categorie);
+            }
+
+            nsNpcTel::Dest item =
+            {
+                fields[5].GetCppString(),   // Name
+                fields[6].GetFloat(),       // X
+                fields[7].GetFloat(),       // Y
+                fields[8].GetFloat(),       // Z
+                fields[9].GetFloat(),       // Orientation
+                fields[10].GetUInt16(),     // Map
+                fields[11].GetUInt8(),      // Level
+                fields[12].GetUInt32(),     // Cost
+                fields[14].GetCppString(),  // Say on Departure
+                fields[15].GetUInt32(),     // Cast on Arrival     
+            };
+
+            nsNpcTel::TabCatDest.back().AddDest(item);
+            ++nbDest;
+        } while (result->NextRow());
+
+        outstring_log("");
+        outstring_log("OSCR: >> Loaded %u npc_teleport.", nbDest);
+    } else outstring_log("OSCR: WARNING >> Loaded 0 npc_teleport.");
+}
+
+
+#undef TELE
+#undef PAGE
+#undef PAGEI
+
diff -Nuar oregoncore-current/src/scripts/Custom/sc_npc_teleport.h oregoncore-pq/src/scripts/Custom/sc_npc_teleport.h
--- oregoncore-current/src/scripts/Custom/sc_npc_teleport.h	1969-12-31 19:00:00.000000000 -0500
+++ oregoncore-pq/src/scripts/Custom/sc_npc_teleport.h	2012-05-20 11:43:23.000000000 -0400
@@ -0,0 +1,146 @@
+/**
+ * sc_npc_teleport.h
+ * Based on code by Wilibald09
+ **/
+
+#ifndef SC_NPC_TELEPORT_H
+#define SC_NPC_TELEPORT_H
+
+#include <vector>
+
+
+namespace nsNpcTel
+{
+    // Different types of permissions
+    enum Flag
+    {
+        FLAG_TEAM       = 0,
+        FLAG_GUILD      = 1,
+        FLAG_GMLEVEL    = 2,
+        FLAG_ISGM       = 3,
+        FLAG_ACCOUNT    = 4,
+        FLAG_LEVEL      = 5,
+        FLAG_ITEM       = 6,
+        FLAG_QUEST      = 7,
+        FLAG_GENDER     = 8,
+        FLAG_RACE       = 9,
+        FLAG_CLASS      = 10,
+        FLAG_REPUTATION = 11,
+        FLAG_PLAYER     = 12,
+        MAX_FLAG,
+    };
+
+    // Different parameters of FLAG_TEAM
+    enum
+    {
+        TEAM_ALL        = 0,
+        TEAM_ALLIANCE   = 1,
+        TEAM_HORDE      = 2,
+        MAX_FLAG_TEAM,
+    };
+
+    // Structure representing the destinations
+    struct Dest
+    {
+        std::string m_name;
+        float       m_X, m_Y, m_Z, m_orient;
+        uint16      m_map;
+        uint8       m_level;
+        uint32      m_cost;
+        std::string m_sayondeparture;
+        uint32      m_castonarrival;
+    };
+
+    // Class representing the categories of destinations
+    class CatDest
+    {
+      public:
+
+        typedef std::vector<Dest> VDest;
+        typedef VDest::size_type  VDest_t;
+
+        CatDest(const uint32 &id, const std::string &name,
+                const Flag &flag, const uint64 &data0, const uint32 &data1);
+
+        void   AddDest  (const Dest &item)       { m_TabDest.push_back(item); }
+        Dest   GetDest  (const uint32 &id) const { return m_TabDest[id]; }
+        uint32 GetCatID (void)             const { return m_id; }
+        uint32 size     (void)             const { return m_TabDest.size(); }
+
+        std::string GetName(const bool IsGM = false)    const;
+        bool IsAllowedToTeleport(Player * const player) const;
+
+        static uint32 CountOfCategoryAllowedBy(Player * const player);
+
+      private:
+
+        uint32      m_id;
+        std::string m_name;
+        Flag        m_flag;
+        uint64      m_data0;
+        uint32      m_data1;
+        VDest       m_TabDest;
+    };
+
+    // Class page for current player
+    class Page
+    {
+      protected:
+
+        // Class instance for current player
+        class Instance
+        {
+          public:
+
+            Instance(Player * const player, const uint32 &PageId = 0)
+                : m_player(player), m_PageId(PageId) {}
+
+            Instance & operator =  (const uint32 &id);
+            Instance & operator ++ (void);
+            Instance   operator ++ (int32);
+            Instance & operator -- (void);
+            Instance   operator -- (int32);
+
+            uint32   GetPageId(void) const { return m_PageId; }
+            Player * GetPlayer(void) const { return m_player; }
+        
+          private:
+
+            Player *m_player;
+            uint32  m_PageId;
+        };
+
+
+      public:
+
+        typedef std::vector<Instance> VInst;
+        typedef VInst::size_type      VInst_t;
+
+        Page(void) { m_TabInstance.clear(); }
+
+        Instance &   operator () (Player * const player);
+        const uint32 operator [] (Player * const player) const;
+
+
+      private:
+
+        VInst m_TabInstance;
+    };
+
+    typedef std::vector <CatDest> VCatDest;
+    typedef VCatDest::size_type   VCatDest_t;
+
+    // Verification of data integrity
+    bool IsValidData(const uint32 &cat,   const Flag &flag,
+                     const uint64 &data0, const uint32 &data1);
+
+    extern VCatDest TabCatDest;
+}
+
+// Loading contents of database
+void LoadNpcTele(QueryResult_AutoPtr result);
+
+extern DatabaseType WorldDatabase;
+
+#endif
+
