From 2d0a11f98046507f8a024704c904b173a0263bba Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Tue, 22 Sep 2015 21:25:53 -0500
Subject: [PATCH] CrossFactionBG-WoWSource

---
 sql/custom/AVFix.sql                               |    3 +
 src/server/game/Battlegrounds/Battleground.cpp     |   43 +-
 src/server/game/Battlegrounds/Battleground.h       |    2 +-
 src/server/game/Battlegrounds/BattlegroundMgr.cpp  |    4 +-
 .../game/Battlegrounds/BattlegroundQueue.cpp       |   83 +-
 src/server/game/Battlegrounds/BattlegroundQueue.h  |   11 +-
 .../game/Battlegrounds/Zones/BattlegroundAB.cpp    |    4 +-
 .../game/Battlegrounds/Zones/BattlegroundAV.cpp    |   23 +-
 .../game/Battlegrounds/Zones/BattlegroundBE.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundBFG.cpp   |    4 +-
 .../game/Battlegrounds/Zones/BattlegroundDS.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundEY.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundIC.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundNA.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundRL.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundRV.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundSA.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundTP.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundWS.cpp    |    5 +-
 src/server/game/CMakeLists.txt                     |    2 +
 src/server/game/CMakeLists.txt.orig                |  217 +
 src/server/game/Cfbg/Cfbg.cpp                      |  325 +
 src/server/game/Cfbg/Cfbg.h                        |   35 +
 src/server/game/Entities/Player/Player.cpp         |   82 +-
 src/server/game/Entities/Player/Player.h           |   37 +-
 src/server/game/Entities/Unit/Unit.cpp             |   17 +-
 src/server/game/Entities/Unit/Unit.cpp.orig        |19614 ++++++++++++++++++++
 src/server/game/Entities/Unit/Unit.h               |    4 +-
 src/server/game/Entities/Unit/Unit.h.orig          | 2570 +++
 src/server/game/Handlers/CharacterHandler.cpp      |    3 +
 src/server/game/Handlers/ChatHandler.cpp           |   16 +
 src/server/game/Handlers/MiscHandler.cpp           |   15 +
 src/server/game/World/World.cpp                    |    1 +
 src/server/game/World/World.h                      |    1 +
 src/server/worldserver/worldserver.conf.dist       |   12 +
 35 files changed, 23057 insertions(+), 94 deletions(-)
 create mode 100644 sql/custom/AVFix.sql
 create mode 100644 src/server/game/CMakeLists.txt.orig
 create mode 100644 src/server/game/Cfbg/Cfbg.cpp
 create mode 100644 src/server/game/Cfbg/Cfbg.h
 create mode 100644 src/server/game/Entities/Unit/Unit.cpp.orig
 create mode 100644 src/server/game/Entities/Unit/Unit.h.orig

diff --git a/sql/custom/AVFix.sql b/sql/custom/AVFix.sql
new file mode 100644
index 0000000..a0c7eb9
--- /dev/null
+++ b/sql/custom/AVFix.sql
@@ -0,0 +1,3 @@
+UPDATE creature_template SET faction = 1 WHERE entry IN (4255,4257,5134,5135,5139,11948,11949,11997,12050,12096,12127,13086,13096,13138,13216,13257,13296,13298,13299,13317,13318,13319,13320,13326,13327,13331,13422,13437,13438,13439,13442,13443,13447,13546,13576,13577,13598,13617,13797,14187,14188,14284,14762,14763,14765,14766,14768,14769,12047,13396,13358,13080,13078);
+
+UPDATE creature_template SET faction = 2 WHERE entry IN (2225,3343,3625,10364,10367,11946,11947,11998,12051,12052,12053,12097,12121,12122,13088,13089,13097,13137,13140,13143,13144,13145,13146,13147,13152,13153,13154,13176,13179,13180,13181,13218,13236,13284,13316,13359,13377,13397,13425,13428,13441,13448,13536,13539,13545,13597,13616,13618,13798,14185,14186,14282,14285,14772,14773,14774,14775,14776,14777,13332,13099,13079);
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index ff904a8..a41f27b 100644
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -326,7 +326,7 @@ inline void Battleground::_CheckSafePositions(uint32 diff)
             if (Player* player = ObjectAccessor::FindPlayer(itr->first))
             {
                 player->GetPosition(&pos);
-                GetTeamStartLoc(player->GetBGTeam(), x, y, z, o);
+                GetTeamStartLoc(player->GetTeam(), x, y, z, o);
                 if (pos.GetExactDistSq(x, y, z) > maxDist)
                 {
                     sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BATTLEGROUND: Sending %s back to start location (map: %u) (possible exploit)", player->GetName().c_str(), GetMapId());
@@ -560,7 +560,7 @@ inline void Battleground::_ProcessJoin(uint32 diff)
                     player->GetSession()->SendPacket(&status);
 
                     // Correctly display EnemyUnitFrame
-                    player->SetByteValue(PLAYER_BYTES_3, 3, player->GetBGTeam());
+                    player->SetByteValue(PLAYER_BYTES_3, 3, player->GetTeam());
 
                     player->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
                     player->ResetAllPowers();
@@ -763,12 +763,32 @@ void Battleground::RewardHonorToTeam(uint32 Honor, uint32 TeamID)
             UpdatePlayerScore(player, SCORE_BONUS_HONOR, Honor);
 }
 
-void Battleground::RewardReputationToTeam(uint32 faction_id, uint32 Reputation, uint32 TeamID)
+void Battleground::RewardReputationToTeam(uint32 a_faction_id, uint32 h_faction_id, uint32 Reputation, uint32 teamId)
 {
-    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction_id))
-        for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
-            if (Player* player = _GetPlayerForTeam(TeamID, itr, "RewardReputationToTeam"))
-                player->GetReputationMgr().ModifyReputation(factionEntry, Reputation);
+    FactionEntry const* a_factionEntry = sFactionStore.LookupEntry(a_faction_id);
+    FactionEntry const* h_factionEntry = sFactionStore.LookupEntry(h_faction_id);
+
+    if (!a_factionEntry || !h_factionEntry)
+        return;
+
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+    {
+        if (itr->second.OfflineRemoveTime)
+            continue;
+
+        Player* plr = ObjectAccessor::FindPlayer(itr->first);
+
+        if (!plr)
+        {
+            sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BattleGround:RewardReputationToTeam: %u not found!", itr->first);
+            continue;
+        }
+
+        uint32 team = plr->GetTeam();
+
+        if (team == teamId)
+            plr->GetReputationMgr().ModifyReputation(plr->GetOTeam() == ALLIANCE ? a_factionEntry : h_factionEntry, Reputation);
+    }
 }
 
 void Battleground::UpdateWorldState(uint32 Field, uint32 Value)
@@ -1184,6 +1204,7 @@ void Battleground::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPac
 
     if (player)
     {
+        player->FitPlayerInTeam(false, this);
         // Do next only if found in battleground
         player->SetBattlegroundId(0, BATTLEGROUND_TYPE_NONE);  // We're not in BG.
         // reset destination bg team
@@ -1261,7 +1282,7 @@ void Battleground::AddPlayer(Player* player)
     // score struct must be created in inherited class
 
     uint64 guid = player->GetGUID();
-    uint32 team = player->GetBGTeam();
+    uint32 team = player->GetTeam();
 
     BattlegroundPlayer bp;
     bp.OfflineRemoveTime = 0;
@@ -1343,6 +1364,8 @@ void Battleground::AddPlayer(Player* player)
     // setup BG group membership
     PlayerAddedToBGCheckIfBGIsRunning(player);
     AddOrSetPlayerToCorrectBgGroup(player, team);
+
+    player->FitPlayerInTeam(true, this);
 }
 
 // this method adds player to his team's bg group, or sets his correct group if player is already in bg group
@@ -1412,8 +1435,8 @@ void Battleground::EventPlayerLoggedOut(Player* player)
 
         // 1 player is logging out, if it is the last, then end arena!
         if (isArena())
-            if (GetAlivePlayersCountByTeam(player->GetBGTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetBGTeam())))
-                EndBattleground(GetOtherTeam(player->GetBGTeam()));
+            if (GetAlivePlayersCountByTeam(player->GetTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetTeam())))
+                EndBattleground(GetOtherTeam(player->GetTeam()));
     }
 }
 
diff --git a/src/server/game/Battlegrounds/Battleground.h b/src/server/game/Battlegrounds/Battleground.h
index d142d18..5b51451 100644
--- a/src/server/game/Battlegrounds/Battleground.h
+++ b/src/server/game/Battlegrounds/Battleground.h
@@ -430,7 +430,7 @@ class Battleground
         void CastSpellOnTeam(uint32 SpellID, uint32 TeamID);
         void RemoveAuraOnTeam(uint32 SpellID, uint32 TeamID);
         void RewardHonorToTeam(uint32 Honor, uint32 TeamID);
-        void RewardReputationToTeam(uint32 faction_id, uint32 Reputation, uint32 TeamID);
+        void RewardReputationToTeam(uint32 a_faction_id, uint32 h_faction_id, uint32 Reputation, uint32 teamId);
         void UpdateWorldState(uint32 Field, uint32 Value);
         void UpdateWorldStateForPlayer(uint32 Field, uint32 Value, Player* Source);
         void EndBattleground(uint32 winner);
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.cpp b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
index b7014f3..102c03e 100644
--- a/src/server/game/Battlegrounds/BattlegroundMgr.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
@@ -299,7 +299,7 @@ void BattlegroundMgr::BuildBattlegroundStatusPacket(WorldPacket* data, Battlegro
             data->WriteBit(bgGuid[7]);
             data->WriteBit(bgGuid[1]);
             data->WriteBit(playerGuid[5]);
-            data->WriteBit(player->GetBGTeam() == HORDE ? 0 : 1);
+            data->WriteBit(player->GetTeam() == HORDE ? 0 : 1);
             data->WriteBit(bgGuid[0]);
             data->WriteBit(playerGuid[1]);
             data->WriteBit(bgGuid[3]);
@@ -1190,7 +1190,7 @@ void BattlegroundMgr::SendToBattleground(Player* player, uint32 instanceId, Batt
     {
         float x, y, z, O;
         uint32 mapid = bg->GetMapId();
-        uint32 team = player->GetBGTeam();
+        uint32 team = player->GetTeam();
 
         bg->GetTeamStartLoc(team, x, y, z, O);
         sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BattlegroundMgr::SendToBattleground: Sending %s to map %u, X %f, Y %f, Z %f, O %f (bgType %u)", player->GetName().c_str(), mapid, x, y, z, O, bgTypeId);
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.cpp b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
index 0526e2d..c6cccf8 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
@@ -158,6 +158,10 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
         index += BG_TEAMS_COUNT;
     if (ginfo->Team == HORDE)
         index++;
+
+    if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) && ArenaType == 0)
+        index = BG_QUEUE_MIXED;                      // BG_QUEUE_*_* -> BG_QUEUE_MIXED
+
     sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Adding Group to BattlegroundQueue bgTypeId : %u, bracket_id : %u, index : %u", BgTypeId, bracketId, index);
 
     uint32 lastOnlineTime = getMSTime();
@@ -203,31 +207,56 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
         {
             if (Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(ginfo->BgTypeId))
             {
-                char const* bgName = bg->GetName();
-                uint32 MinPlayers = bg->GetMinPlayersPerTeam();
-                uint32 qHorde = 0;
-                uint32 qAlliance = 0;
-                uint32 q_min_level = bracketEntry->minLevel;
-                uint32 q_max_level = bracketEntry->maxLevel;
-                GroupsQueueType::const_iterator itr;
-                for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].end(); ++itr)
-                    if (!(*itr)->IsInvitedToBGInstanceGUID)
-                        qAlliance += (*itr)->Players.size();
-                for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].end(); ++itr)
-                    if (!(*itr)->IsInvitedToBGInstanceGUID)
-                        qHorde += (*itr)->Players.size();
-
-                // Show queue status to player only (when joining queue)
-                if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED))
                 {
-                    ChatHandler(leader->GetSession()).PSendSysMessage(LANG_BG_QUEUE_ANNOUNCE_SELF, bgName, q_min_level, q_max_level,
-                        qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    char const* bgName = bg->GetName();
+                    uint32 MinPlayers = bg->GetMinPlayersPerTeam()*2;
+                    uint32 qPlayers = 0;
+                    uint32 q_min_level = bracketEntry->minLevel;
+                    uint32 q_max_level = bracketEntry->maxLevel;
+                    for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracketId][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_MIXED].end(); ++itr)
+                        if (!(*itr)->IsInvitedToBGInstanceGUID)
+                            qPlayers += (*itr)->Players.size();
+
+                    if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                    {
+                        ChatHandler(leader->GetSession()).PSendSysMessage("Queue status for %s (Lvl: %u to %u) Queued players: %u (Need at least %u more)", bgName, q_min_level, q_max_level, qPlayers, MinPlayers - qPlayers);
+                    }
+                    else
+                    {
+                        std::ostringstream ss;
+                        ss << "|cffff0000[BG Queue Announcer]:|r " << bgName << " -- [" << q_min_level << "-" << q_max_level << "] " << qPlayers << "/" << MinPlayers;
+                        sWorld->SendGlobalText(ss.str().c_str(), NULL);
+                    }
                 }
-                // System message
                 else
                 {
-                    sWorld->SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD, bgName, q_min_level, q_max_level,
-                        qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    char const* bgName = bg->GetName();
+                    uint32 MinPlayers = bg->GetMinPlayersPerTeam();
+                    uint32 qHorde = 0;
+                    uint32 qAlliance = 0;
+                    uint32 q_min_level = bracketEntry->minLevel;
+                    uint32 q_max_level = bracketEntry->maxLevel;
+                    GroupsQueueType::const_iterator itr;
+                    for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].end(); ++itr)
+                        if (!(*itr)->IsInvitedToBGInstanceGUID)
+                            qAlliance += (*itr)->Players.size();
+                    for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].end(); ++itr)
+                        if (!(*itr)->IsInvitedToBGInstanceGUID)
+                            qHorde += (*itr)->Players.size();
+
+                    // Show queue status to player only (when joining queue)
+                    if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                    {
+                        ChatHandler(leader->GetSession()).PSendSysMessage(LANG_BG_QUEUE_ANNOUNCE_SELF, bgName, q_min_level, q_max_level,
+                            qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    }
+                    // System message
+                    else
+                    {
+                        sWorld->SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD, bgName, q_min_level, q_max_level,
+                            qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    }
                 }
             }
         }
@@ -313,7 +342,7 @@ void BattlegroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
     {
         //we must check premade and normal team's queue - because when players from premade are joining bg,
         //they leave groupinfo so we can't use its players size to find out index
-        for (uint32 j = index; j < BG_QUEUE_GROUP_TYPES_COUNT; j += BG_TEAMS_COUNT)
+        for (uint8 j = 0; j < BG_QUEUE_GROUP_TYPES_COUNT; ++j)
         {
             GroupsQueueType::iterator k = m_QueuedGroups[bracket_id_tmp][j].begin();
             for (; k != m_QueuedGroups[bracket_id_tmp][j].end(); ++k)
@@ -503,6 +532,10 @@ void BattlegroundQueue::FillPlayersToBG(Battleground* bg, BattlegroundBracketId
     int32 hordeFree = bg->GetFreeSlotsForTeam(HORDE);
     int32 aliFree   = bg->GetFreeSlotsForTeam(ALLIANCE);
 
+    if (!bg->isArena())
+        if (FillXPlayersToBG(bracket_id, bg, false))
+            return;
+
     //iterator for iterating through bg queue
     GroupsQueueType::const_iterator Ali_itr = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].begin();
     //count of groups in queue - used to stop cycles
@@ -768,7 +801,8 @@ void BattlegroundQueue::BattlegroundQueueUpdate(uint32 /*diff*/, BattlegroundTyp
     if (m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].empty() &&
         m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].empty() &&
         m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].empty() &&
-        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].empty())
+        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].empty() &&
+        m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].empty())
         return;
 
     // battleground with free slot for player should be always in the beggining of the queue
@@ -859,7 +893,8 @@ void BattlegroundQueue::BattlegroundQueueUpdate(uint32 /*diff*/, BattlegroundTyp
     {
         // if there are enough players in pools, start new battleground or non rated arena
         if (CheckNormalMatch(bg_template, bracket_id, MinPlayersPerTeam, MaxPlayersPerTeam)
-            || (bg_template->isArena() && CheckSkirmishForSameFaction(bracket_id, MinPlayersPerTeam)))
+            || (bg_template->isArena() && CheckSkirmishForSameFaction(bracket_id, MinPlayersPerTeam))
+            || CheckCrossFactionMatch(bracket_id, bg_template))
         {
             // we successfully created a pool
             Battleground* bg2 = sBattlegroundMgr->CreateNewBattleground(bgTypeId, bracketEntry, arenaType, false);
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.h b/src/server/game/Battlegrounds/BattlegroundQueue.h
index ff8fb62..6a9db15 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.h
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.h
@@ -42,6 +42,7 @@ struct GroupQueueInfo                                       // stores informatio
 {
     std::map<uint64, PlayerQueueInfo*> Players;             // player queue info map
     uint32  Team;                                           // Player team (ALLIANCE/HORDE)
+    uint32  OTeam;                                          // Player team (ALLIANCE/HORDE)
     BattlegroundTypeId BgTypeId;                            // battleground type id
     bool    IsRated;                                        // rated
     uint8   ArenaType;                                      // 2v2, 3v3, 5v5 or 0 when BG
@@ -62,9 +63,10 @@ enum BattlegroundQueueGroupTypes
     BG_QUEUE_PREMADE_ALLIANCE   = 0,
     BG_QUEUE_PREMADE_HORDE      = 1,
     BG_QUEUE_NORMAL_ALLIANCE    = 2,
-    BG_QUEUE_NORMAL_HORDE       = 3
+    BG_QUEUE_NORMAL_HORDE       = 3,
+    BG_QUEUE_MIXED              = 4
 };
-#define BG_QUEUE_GROUP_TYPES_COUNT 4
+#define BG_QUEUE_GROUP_TYPES_COUNT 5
 
 class Battleground;
 class BattlegroundQueue
@@ -76,6 +78,11 @@ class BattlegroundQueue
         void BattlegroundQueueUpdate(uint32 diff, BattlegroundTypeId bgTypeId, BattlegroundBracketId bracket_id, uint8 arenaType = 0, bool isRated = false, uint32 minRating = 0);
         void UpdateEvents(uint32 diff);
 
+        bool FillXPlayersToBG(BattlegroundBracketId bracket_id, Battleground* bg, bool start = false);
+        typedef std::multimap<int32, GroupQueueInfo*> QueuedGroupMap;
+        int32 PreAddPlayers(QueuedGroupMap m_PreGroupMap, int32 MaxAdd, uint32 MaxInTeam);
+        bool CheckCrossFactionMatch(BattlegroundBracketId bracket_id, Battleground* bg);
+
         void FillPlayersToBG(Battleground* bg, BattlegroundBracketId bracket_id);
         bool CheckPremadeMatch(BattlegroundBracketId bracket_id, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam);
         bool CheckNormalMatch(Battleground* bg_template, BattlegroundBracketId bracket_id, uint32 minPlayers, uint32 maxPlayers);
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
index be94797..8ca89dd 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
@@ -120,7 +120,7 @@ void BattlegroundAB::PostUpdateImpl(uint32 diff)
                 m_ReputationScoreTics[team] += BG_AB_TickPoints[points];
                 if (m_ReputationScoreTics[team] >= m_ReputationTics)
                 {
-                    (team == TEAM_ALLIANCE) ? RewardReputationToTeam(509, 10, ALLIANCE) : RewardReputationToTeam(510, 10, HORDE);
+                    RewardReputationToTeam(509, 510, 10, team == ALLIANCE ? ALLIANCE : HORDE);
                     m_ReputationScoreTics[team] -= m_ReputationTics;
                 }
                 if (m_HonorScoreTics[team] >= m_HonorTics)
@@ -203,7 +203,7 @@ void BattlegroundAB::AddPlayer(Player* player)
     //create score and add it to map, default values are set in the constructor
     BattlegroundABScore* sc = new BattlegroundABScore;
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
index 26ba381..c28d9a9 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
@@ -77,7 +77,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
     if (entry == BG_AV_CreatureInfo[AV_NPC_A_BOSS][0])
     {
         CastSpellOnTeam(23658, HORDE); //this is a spell which finishes a quest where a player has to kill the boss
-        RewardReputationToTeam(729, BG_AV_REP_BOSS, HORDE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_BOSS, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonor(BG_AV_KILL_BOSS), HORDE);
         EndBattleground(HORDE);
         DelCreature(AV_CPLACE_TRIGGER17);
@@ -85,7 +85,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
     else if (entry == BG_AV_CreatureInfo[AV_NPC_H_BOSS][0])
     {
         CastSpellOnTeam(23658, ALLIANCE); //this is a spell which finishes a quest where a player has to kill the boss
-        RewardReputationToTeam(730, BG_AV_REP_BOSS, ALLIANCE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_BOSS, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonor(BG_AV_KILL_BOSS), ALLIANCE);
         EndBattleground(ALLIANCE);
         DelCreature(AV_CPLACE_TRIGGER19);
@@ -98,7 +98,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
             return;
         }
         m_CaptainAlive[0]=false;
-        RewardReputationToTeam(729, BG_AV_REP_CAPTAIN, HORDE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_CAPTAIN, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonor(BG_AV_KILL_CAPTAIN), HORDE);
         UpdateScore(ALLIANCE, (-1)*BG_AV_RES_CAPTAIN);
         //spawn destroyed aura
@@ -117,7 +117,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
             return;
         }
         m_CaptainAlive[1]=false;
-        RewardReputationToTeam(730, BG_AV_REP_CAPTAIN, ALLIANCE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_CAPTAIN, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonor(BG_AV_KILL_CAPTAIN), ALLIANCE);
         UpdateScore(HORDE, (-1)*BG_AV_RES_CAPTAIN);
         //spawn destroyed aura
@@ -139,6 +139,7 @@ void BattlegroundAV::HandleQuestComplete(uint32 questid, Player* player)
     if (GetStatus() != STATUS_IN_PROGRESS)
         return;//maybe we should log this, cause this must be a cheater or a big bug
     uint8 team = GetTeamIndexByTeamId(player->GetTeam());
+    uint8 oteam = GetTeamIndexByTeamId(GetOtherTeam(player->GetTeam()));
     //TODO add reputation, events (including quest not available anymore, next quest availabe, go/npc de/spawning)and maybe honor
     sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BG_AV Quest %i completed", questid);
     switch (questid)
@@ -163,21 +164,21 @@ void BattlegroundAV::HandleQuestComplete(uint32 questid, Player* player)
         case AV_QUEST_A_COMMANDER1:
         case AV_QUEST_H_COMMANDER1:
             m_Team_QuestStatus[team][1]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, oteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][1] == 30)
                 sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
         case AV_QUEST_A_COMMANDER2:
         case AV_QUEST_H_COMMANDER2:
             m_Team_QuestStatus[team][2]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, oteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][2] == 60)
                 sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
         case AV_QUEST_A_COMMANDER3:
         case AV_QUEST_H_COMMANDER3:
             m_Team_QuestStatus[team][3]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, oteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][3] == 120)
                 sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
@@ -240,7 +241,7 @@ void BattlegroundAV::HandleQuestComplete(uint32 questid, Player* player)
 void BattlegroundAV::UpdateScore(uint16 team, int16 points)
 { //note: to remove reinforcementpoints points must be negative, for adding reinforcements points must be positive
     ASSERT(team == ALLIANCE || team == HORDE);
-    uint8 teamindex = GetTeamIndexByTeamId(team); //0=ally 1=horde
+    uint8 teamindex = GetTeamIndexByTeamId(GetOtherTeam(team)); //0=ally 1=horde
     m_Team_Scores[teamindex] += points;
 
     UpdateWorldState(((teamindex == TEAM_HORDE)?AV_Horde_Score:AV_Alliance_Score), m_Team_Scores[teamindex]);
@@ -454,7 +455,7 @@ void BattlegroundAV::AddPlayer(Player* player)
     //create score and add it to map, default values are set in constructor
     BattlegroundAVScore* sc = new BattlegroundAVScore;
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
     if (m_MaxLevel == 0)
         m_MaxLevel=(player->getLevel()%10 == 0)? player->getLevel() : (player->getLevel()-(player->getLevel()%10))+10; //TODO: just look at the code \^_^/ --but queue-info should provide this information..
@@ -491,7 +492,7 @@ void BattlegroundAV::EndBattleground(uint32 winner)
             rep[i]   += BG_AV_REP_SURVIVING_CAPTAIN;
         }
         if (rep[i] != 0)
-            RewardReputationToTeam(i == 0 ? 730 : 729, rep[i], i == 0 ? ALLIANCE : HORDE);
+            RewardReputationToTeam(729, 730, 10, i == ALLIANCE ? ALLIANCE : HORDE);
         if (kills[i] != 0)
             RewardHonorToTeam(GetBonusHonor(kills[i]), i == 0 ? ALLIANCE : HORDE);
     }
@@ -610,7 +611,7 @@ void BattlegroundAV::EventPlayerDestroyedPoint(BG_AV_Nodes node)
             SpawnBGObject(BG_AV_OBJECT_BURN_DUNBALDAR_SOUTH + i + (tmp * 10), RESPAWN_IMMEDIATELY);
 
         UpdateScore((owner == ALLIANCE) ? HORDE : ALLIANCE, -1 * BG_AV_RES_TOWER);
-        RewardReputationToTeam(owner == ALLIANCE ? 730 : 729, BG_AV_REP_TOWER, owner);
+        RewardReputationToTeam(729, 730, BG_AV_REP_TOWER, owner);
         RewardHonorToTeam(GetBonusHonor(BG_AV_KILL_TOWER), owner);
 
         SpawnBGObject(BG_AV_OBJECT_TAURA_A_DUNBALDAR_SOUTH+GetTeamIndexByTeamId(owner)+(2*tmp), RESPAWN_ONE_DAY);
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundBE.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundBE.cpp
index 0851a1e..1c69ffe 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundBE.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundBE.cpp
@@ -69,7 +69,7 @@ void BattlegroundBE::AddPlayer(Player* player)
     Battleground::AddPlayer(player);
     BattlegroundScore* sc = new BattlegroundScore;
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
     UpdateArenaWorldState();
 }
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundBFG.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundBFG.cpp
index 1a4ba8d..7157c0a 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundBFG.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundBFG.cpp
@@ -149,7 +149,7 @@ void BattlegroundBFG::PostUpdateImpl(uint32 diff)
 
 				if (m_ReputationScoreTicks[team] >= m_ReputationTicks)
 				{
-					(team == BG_TEAM_ALLIANCE) ? RewardReputationToTeam(509, 10, ALLIANCE) : RewardReputationToTeam(510, 10, HORDE);
+					//(team == BG_TEAM_ALLIANCE) ? RewardReputationToTeam(509, 10, ALLIANCE) : RewardReputationToTeam(510, 10, HORDE);
 					m_ReputationScoreTicks[team] -= m_ReputationTicks;
 				}
 
@@ -234,7 +234,7 @@ void BattlegroundBFG::AddPlayer(Player* player)
 	BattlegroundBFGScore* sc = new BattlegroundBFGScore;
 	PlayerScores[player->GetGUID()] = sc;
 
-	sc->BgTeam = player->GetBGTeam();
+	sc->BgTeam = player->GetTeam();
 	sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
index ffe8ae9..3c74586 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
@@ -153,7 +153,7 @@ void BattlegroundDS::AddPlayer(Player* player)
     Battleground::AddPlayer(player);
     BattlegroundScore* sc = new BattlegroundScore;
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
     UpdateArenaWorldState();
 }
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp
index 03f27b4..ab45032 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp
@@ -350,7 +350,7 @@ void BattlegroundEY::AddPlayer(Player* player)
     m_PlayersNearPoint[EY_POINTS_MAX].push_back(player->GetGUID());
 
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
index a986844..29e7216 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
@@ -308,7 +308,7 @@ void BattlegroundIC::AddPlayer(Player* player)
     Battleground::AddPlayer(player);
     BattlegroundICScore* sc = new BattlegroundICScore;
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
 
     if (nodePoint[NODE_TYPE_QUARRY].nodeState == (player->GetTeamId() == TEAM_ALLIANCE ? NODE_STATE_CONTROLLED_A : NODE_STATE_CONTROLLED_H))
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundNA.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundNA.cpp
index a755a91..6a77eee 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundNA.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundNA.cpp
@@ -70,7 +70,7 @@ void BattlegroundNA::AddPlayer(Player* player)
     Battleground::AddPlayer(player);
     BattlegroundScore* sc = new BattlegroundScore;
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
     UpdateArenaWorldState();
 }
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundRL.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundRL.cpp
index 65b14fb..9caf201 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundRL.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundRL.cpp
@@ -66,7 +66,7 @@ void BattlegroundRL::AddPlayer(Player* player)
     Battleground::AddPlayer(player);
     BattlegroundScore* sc = new BattlegroundScore;
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
     UpdateArenaWorldState();
 }
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp
index eb4752b..77e438b 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundRV.cpp
@@ -101,7 +101,7 @@ void BattlegroundRV::AddPlayer(Player* player)
     Battleground::AddPlayer(player);
     BattlegroundScore* sc = new BattlegroundScore;
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
 
     UpdateWorldState(BG_RV_WORLD_STATE_A, GetAlivePlayersCountByTeam(ALLIANCE));
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp
index bfc6a34..948ed3d 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp
@@ -472,7 +472,7 @@ void BattlegroundSA::AddPlayer(Player* player)
     }
     SendTransportInit(player);
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundTP.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundTP.cpp
index 74004dc..79f2ab5 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundTP.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundTP.cpp
@@ -188,7 +188,7 @@ void BattlegroundTP::AddPlayer(Player* player)
 	//create score and add it to map, default values are set in the constructor
 	BattlegroundTPScore* sc = new BattlegroundTPScore;
 	PlayerScores[player->GetGUID()] = sc;
-	sc->BgTeam = player->GetBGTeam();
+	sc->BgTeam = player->GetTeam();
 	sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
index ca7de8d..135a383 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
@@ -220,7 +220,7 @@ void BattlegroundWS::AddPlayer(Player* player)
     BattlegroundWGScore* sc = new BattlegroundWGScore;
 
     PlayerScores[player->GetGUID()] = sc;
-    sc->BgTeam = player->GetBGTeam();
+    sc->BgTeam = player->GetTeam();
     sc->TalentTree = player->GetPrimaryTalentTree(player->GetActiveSpec());
 }
 
@@ -300,7 +300,6 @@ void BattlegroundWS::EventPlayerCapturedFlag(Player* Source)
         if (GetTeamScore(TEAM_ALLIANCE) < BG_WS_MAX_TEAM_SCORE)
             AddPoint(ALLIANCE, 1);
         PlaySoundToAll(BG_WS_SOUND_FLAG_CAPTURED_ALLIANCE);
-        RewardReputationToTeam(890, m_ReputationCapture, ALLIANCE);
     }
     else
     {
@@ -318,8 +317,8 @@ void BattlegroundWS::EventPlayerCapturedFlag(Player* Source)
         if (GetTeamScore(TEAM_HORDE) < BG_WS_MAX_TEAM_SCORE)
             AddPoint(HORDE, 1);
         PlaySoundToAll(BG_WS_SOUND_FLAG_CAPTURED_HORDE);
-        RewardReputationToTeam(889, m_ReputationCapture, HORDE);
     }
+    RewardReputationToTeam(890, 889, m_ReputationCapture, Source->GetTeam());
     //for flag capture is reward 2 honorable kills
     RewardHonorToTeam(GetBonusHonorFromKill(2), Source->GetTeam());
 
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 41f780d..90aedee 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -49,6 +49,7 @@ file(GLOB_RECURSE sources_Tickets Tickets/*.cpp Tickets/*.h)
 file(GLOB_RECURSE sources_Warden Warden/*.cpp Warden/*.h)
 file(GLOB_RECURSE sources_Weather Weather/*.cpp Weather/*.h)
 file(GLOB_RECURSE sources_World World/*.cpp World/*.h)
+file(GLOB_RECURSE sources_Cfbg Cfbg/*.cpp Cfbg/*.h)
 
 # Create game-libary
 
@@ -100,6 +101,7 @@ set(game_STAT_SRCS
   ${sources_Warden}
   ${sources_Weather}
   ${sources_World}
+  ${sources_Cfbg}
 )
 
 include_directories(
diff --git a/src/server/game/CMakeLists.txt.orig b/src/server/game/CMakeLists.txt.orig
new file mode 100644
index 0000000..41f780d
--- /dev/null
+++ b/src/server/game/CMakeLists.txt.orig
@@ -0,0 +1,217 @@
+# Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+file(GLOB_RECURSE sources_Accounts Accounts/*.cpp Accounts/*.h)
+file(GLOB_RECURSE sources_Anticheat Anticheat/*.cpp Anticheat/*.h)
+file(GLOB_RECURSE sources_Achievements Achievements/*.cpp Achievements/*.h)
+file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
+file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
+file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
+file(GLOB_RECURSE sources_Battlefield Battlefield/*.cpp Battlefield/*.h)
+file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
+file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
+file(GLOB_RECURSE sources_Chat Chat/*.cpp Chat/*.h)
+file(GLOB_RECURSE sources_Combat Combat/*.cpp Combat/*.h)
+file(GLOB_RECURSE sources_Conditions Conditions/*.cpp Conditions/*.h)
+file(GLOB_RECURSE sources_DataStores DataStores/*.cpp DataStores/*.h)
+file(GLOB_RECURSE sources_DungeonFinding DungeonFinding/*.cpp DungeonFinding/*.h)
+file(GLOB_RECURSE sources_Entities Entities/*.cpp Entities/*.h)
+file(GLOB_RECURSE sources_Events Events/*.cpp Events/*.h)
+file(GLOB_RECURSE sources_Globals Globals/*.cpp Globals/*.h)
+file(GLOB_RECURSE sources_Grids Grids/*.cpp Grids/*.h)
+file(GLOB_RECURSE sources_Groups Groups/*.cpp Groups/*.h)
+file(GLOB_RECURSE sources_Guilds Guilds/*.cpp Guilds/*.h)
+file(GLOB_RECURSE sources_Handlers Handlers/*.cpp Handlers/*.h)
+file(GLOB_RECURSE sources_Instances Instances/*.cpp Instances/*.h)
+file(GLOB_RECURSE sources_Loot Loot/*.cpp Loot/*.h)
+file(GLOB_RECURSE sources_Mails Mails/*.cpp Mails/*.h)
+file(GLOB_RECURSE sources_Maps Maps/*.cpp Maps/*.h)
+file(GLOB_RECURSE sources_Miscellaneous Miscellaneous/*.cpp Miscellaneous/*.h)
+file(GLOB_RECURSE sources_Movement Movement/*.cpp Movement/*.h)
+file(GLOB_RECURSE sources_OutdoorPvP OutdoorPvP/*.cpp OutdoorPvP/*.h)
+file(GLOB_RECURSE sources_Pools Pools/*.cpp Pools/*.h)
+file(GLOB_RECURSE sources_Quests Quests/*.cpp Quests/*.h)
+file(GLOB_RECURSE sources_Reputation Reputation/*.cpp Reputation/*.h)
+file(GLOB_RECURSE sources_Scripting Scripting/*.cpp Scripting/*.h)
+file(GLOB_RECURSE sources_Server Server/*.cpp Server/*.h)
+file(GLOB_RECURSE sources_Skills Skills/*.cpp Skills/*.h)
+file(GLOB_RECURSE sources_Spells Spells/*.cpp Spells/*.h)
+file(GLOB_RECURSE sources_Texts Texts/*.cpp Texts/*.h)
+file(GLOB_RECURSE sources_Tools Tools/*.cpp Tools/*.h)
+file(GLOB_RECURSE sources_Tickets Tickets/*.cpp Tickets/*.h)
+file(GLOB_RECURSE sources_Warden Warden/*.cpp Warden/*.h)
+file(GLOB_RECURSE sources_Weather Weather/*.cpp Weather/*.h)
+file(GLOB_RECURSE sources_World World/*.cpp World/*.h)
+
+# Create game-libary
+
+if (USE_COREPCH)
+  set(game_STAT_PCH_HDR PrecompiledHeaders/gamePCH.h)
+  set(game_STAT_PCH_SRC PrecompiledHeaders/gamePCH.cpp)
+endif ()
+
+set(game_STAT_SRCS
+  ${game_STAT_SRCS}
+  ${sources_Accounts}
+  ${sources_Anticheat}
+  ${sources_Achievements}
+  ${sources_Addons}
+  ${sources_AI}
+  ${sources_AuctionHouse}
+  ${sources_Battlefield}
+  ${sources_Battlegrounds}
+  ${sources_Calendar}
+  ${sources_Chat}
+  ${sources_Combat}
+  ${sources_Conditions}
+  ${sources_DataStores}
+  ${sources_DungeonFinding}
+  ${sources_Entities}
+  ${sources_Events}
+  ${sources_Globals}
+  ${sources_Grids}
+  ${sources_Groups}
+  ${sources_Guilds}
+  ${sources_Handlers}
+  ${sources_Instances}
+  ${sources_Loot}
+  ${sources_Mails}
+  ${sources_Maps}
+  ${sources_Miscellaneous}
+  ${sources_Movement}
+  ${sources_OutdoorPvP}
+  ${sources_Pools}
+  ${sources_Quests}
+  ${sources_Reputation}
+  ${sources_Scripting}
+  ${sources_Server}
+  ${sources_Skills}
+  ${sources_Spells}
+  ${sources_Texts}
+  ${sources_Tools}
+  ${sources_Tickets}
+  ${sources_Warden}
+  ${sources_Weather}
+  ${sources_World}
+)
+
+include_directories(
+  ${CMAKE_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/SFMT
+  ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/src/server/collision
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${CMAKE_CURRENT_SOURCE_DIR}/Accounts
+  ${CMAKE_CURRENT_SOURCE_DIR}/Anticheat
+  ${CMAKE_CURRENT_SOURCE_DIR}/Achievements
+  ${CMAKE_CURRENT_SOURCE_DIR}/Addons
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
+  ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield
+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield/Zones
+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
+  ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
+  ${CMAKE_CURRENT_SOURCE_DIR}/Calendar
+  ${CMAKE_CURRENT_SOURCE_DIR}/Chat
+  ${CMAKE_CURRENT_SOURCE_DIR}/Chat/Channels
+  ${CMAKE_CURRENT_SOURCE_DIR}/Combat
+  ${CMAKE_CURRENT_SOURCE_DIR}/Conditions
+  ${CMAKE_CURRENT_SOURCE_DIR}/DataStores
+  ${CMAKE_CURRENT_SOURCE_DIR}/DungeonFinding
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/AreaTrigger
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Creature
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Corpse
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/DynamicObject
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/GameObject
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Item
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Item/Container
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Object
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Object/Updates
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Pet
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Player
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Totem
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Unit
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Vehicle
+  ${CMAKE_CURRENT_SOURCE_DIR}/Entities/Transport
+  ${CMAKE_CURRENT_SOURCE_DIR}/Events
+  ${CMAKE_CURRENT_SOURCE_DIR}/Globals
+  ${CMAKE_CURRENT_SOURCE_DIR}/Grids/Cells
+  ${CMAKE_CURRENT_SOURCE_DIR}/Grids/Notifiers
+  ${CMAKE_CURRENT_SOURCE_DIR}/Grids
+  ${CMAKE_CURRENT_SOURCE_DIR}/Groups
+  ${CMAKE_CURRENT_SOURCE_DIR}/Guilds
+  ${CMAKE_CURRENT_SOURCE_DIR}/Handlers
+  ${CMAKE_CURRENT_SOURCE_DIR}/Instances
+  ${CMAKE_CURRENT_SOURCE_DIR}/Loot
+  ${CMAKE_CURRENT_SOURCE_DIR}/Mails
+  ${CMAKE_CURRENT_SOURCE_DIR}/Maps
+  ${CMAKE_CURRENT_SOURCE_DIR}/Miscellaneous
+  ${CMAKE_CURRENT_SOURCE_DIR}/Movement
+  ${CMAKE_CURRENT_SOURCE_DIR}/Movement/Spline
+  ${CMAKE_CURRENT_SOURCE_DIR}/Movement/MovementGenerators
+  ${CMAKE_CURRENT_SOURCE_DIR}/Movement/Waypoints
+  ${CMAKE_CURRENT_SOURCE_DIR}/OutdoorPvP
+  ${CMAKE_CURRENT_SOURCE_DIR}/Pools
+  ${CMAKE_CURRENT_SOURCE_DIR}/PrecompiledHeaders
+  ${CMAKE_CURRENT_SOURCE_DIR}/Quests
+  ${CMAKE_CURRENT_SOURCE_DIR}/Reputation
+  ${CMAKE_CURRENT_SOURCE_DIR}/Scripting
+  ${CMAKE_CURRENT_SOURCE_DIR}/Server/Protocol
+  ${CMAKE_CURRENT_SOURCE_DIR}/Server
+  ${CMAKE_CURRENT_SOURCE_DIR}/Skills
+  ${CMAKE_CURRENT_SOURCE_DIR}/Spells
+  ${CMAKE_CURRENT_SOURCE_DIR}/Spells/Auras
+  ${CMAKE_CURRENT_SOURCE_DIR}/Texts
+  ${CMAKE_CURRENT_SOURCE_DIR}/Tools
+  ${CMAKE_CURRENT_SOURCE_DIR}/Tickets
+  ${CMAKE_CURRENT_SOURCE_DIR}/Warden
+  ${CMAKE_CURRENT_SOURCE_DIR}/Warden/Modules
+  ${CMAKE_CURRENT_SOURCE_DIR}/Weather
+  ${CMAKE_CURRENT_SOURCE_DIR}/World
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${ACE_INCLUDE_DIR}
+  ${MYSQL_INCLUDE_DIR}
+  ${OPENSSL_INCLUDE_DIR}
+)
+
+add_library(game STATIC
+  ${game_STAT_SRCS}
+  ${game_STAT_PCH_SRC}
+)
+
+add_dependencies(game revision.h)
+
+# Generate precompiled header
+if (USE_COREPCH)
+  add_cxx_pch(game ${game_STAT_PCH_HDR} ${game_STAT_PCH_SRC})
+endif ()
diff --git a/src/server/game/Cfbg/Cfbg.cpp b/src/server/game/Cfbg/Cfbg.cpp
new file mode 100644
index 0000000..d0c9d3b
--- /dev/null
+++ b/src/server/game/Cfbg/Cfbg.cpp
@@ -0,0 +1,325 @@
+#include "Cfbg.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "Player.h"
+#include "Chat.h"
+#include "BattlegroundQueue.h"
+
+/*####################################################################################
+###############################CROSSFACTION BATTLEGROUNDS#############################
+####################################################################################*/
+
+uint8 Unit::getRace(bool forceoriginal) const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        Player* pPlayer = ((Player*)this);
+
+        if (forceoriginal)
+            return pPlayer->getORace();
+
+        if (pPlayer->InArena())
+            return GetByteValue(UNIT_FIELD_BYTES_0, 0);
+
+        if (!pPlayer->IsPlayingNative())
+            return pPlayer->getFRace();
+    }
+
+    return GetByteValue(UNIT_FIELD_BYTES_0, 0);
+}
+
+bool Player::SendRealNameQuery()
+{
+    if (IsPlayingNative())
+        return false;
+
+    WorldPacket data(SMSG_NAME_QUERY_RESPONSE, (8 + 1 + 1 + 1 + 1 + 1 + 10));
+    data.appendPackGUID(GetGUID());                             // player guid
+    data << uint8(0);                                       // added in 3.1; if > 1, then end of packet
+    data << GetName();                                   // played name
+    data << uint8(0);                                       // realm name for cross realm BG usage
+    data << uint8(getORace());
+    data << uint8(getGender());
+    data << uint8(getClass());
+    data << uint8(0);                                   // is not declined
+    GetSession()->SendPacket(&data);
+
+    return true;
+}
+
+void Player::SetFakeRaceAndMorph()
+{
+m_FakeRace = GetOTeam() == ALLIANCE ? RACE_BLOODELF : RACE_HUMAN;
+}
+
+bool Player::SendBattleGroundChat(uint32 msgtype, std::string message)
+{
+    // Select distance to broadcast to.
+    float distance = msgtype == CHAT_MSG_SAY ? sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY) : sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL);
+
+    if (Battleground* pBattleGround = GetBattleground())
+    {
+        if (pBattleGround->isArena()) // Only fake chat in BG's. CFBG should not interfere with arenas.
+            return false;
+
+        for (Battleground::BattlegroundPlayerMap::const_iterator itr = pBattleGround->GetPlayers().begin(); itr != pBattleGround->GetPlayers().end(); ++itr)
+        {
+            if (Player* pPlayer = ObjectAccessor::FindPlayer(itr->first))
+            {
+                if (GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) <= distance)
+                {
+                    WorldPacket data(SMSG_MESSAGECHAT, 200);
+
+                    if (GetTeam() == pPlayer->GetTeam())
+                        BuildPlayerChat(&data, msgtype, message, LANG_UNIVERSAL);
+                    else if (msgtype != CHAT_MSG_EMOTE)
+                       BuildPlayerChat(&data, msgtype, message, pPlayer->GetTeam() == ALLIANCE ? LANG_ORCISH : LANG_COMMON);
+
+                    pPlayer->GetSession()->SendPacket(&data);
+                }
+            }
+        }
+        return true;
+    }
+    else
+        return false;
+}
+
+void Player::MorphFit(bool value)
+{
+    if (!IsPlayingNative() && value)
+    {
+        if (GetOTeam() == HORDE)
+        {
+            if (getGender() == GENDER_MALE)
+            {
+                SetDisplayId(19723);
+                SetNativeDisplayId(19723);
+            }
+            else
+            {
+                SetDisplayId(19724);
+                SetNativeDisplayId(19724);
+            }
+        }
+        else
+        {
+            if (getGender() == GENDER_MALE)
+            {
+                SetDisplayId(20578);
+                SetNativeDisplayId(20578);
+            }
+            else
+            {
+                SetDisplayId(20579);
+                SetNativeDisplayId(20579);
+            }
+        }
+    }
+    else
+        InitDisplayIds();
+}
+
+void Player::FitPlayerInTeam(bool action, Battleground* pBattleGround)
+{
+    if (!pBattleGround)
+        pBattleGround = GetBattleground();
+
+    if ((!pBattleGround || pBattleGround->isArena()) && action)
+        return;
+
+    if(!IsPlayingNative() && action)
+        setFactionForRace(getRace());
+    else
+        setFactionForRace(getORace());
+
+    if (action)
+        SetForgetBGPlayers(true);
+    else
+        SetForgetInListPlayers(true);
+
+    MorphFit(action);
+
+    if (pBattleGround && action)
+        SendChatMessage("%sYou are playing for the %s%s in this %s", MSG_COLOR_WHITE, GetTeam() == ALLIANCE ? MSG_COLOR_DARKBLUE"alliance" : MSG_COLOR_RED"horde", MSG_COLOR_WHITE, pBattleGround->GetName());
+}
+
+void Player::DoForgetPlayersInList()
+{
+    // m_FakePlayers is filled from a vector within the battleground
+    // they were in previously so all players that have been in that BG will be invalidated.
+    for (FakePlayers::const_iterator itr = m_FakePlayers.begin(); itr != m_FakePlayers.end(); ++itr)
+    {
+        WorldPacket data(SMSG_INVALIDATE_PLAYER, 8);
+        data << *itr;
+        GetSession()->SendPacket(&data);
+        if (Player* pPlayer = ObjectAccessor::FindPlayer(*itr))
+            GetSession()->SendNameQueryOpcode(pPlayer->GetGUID());
+    }
+    m_FakePlayers.clear();
+}
+
+void Player::DoForgetPlayersInBG(Battleground* pBattleGround)
+{
+    for (Battleground::BattlegroundPlayerMap::const_iterator itr = pBattleGround->GetPlayers().begin(); itr != pBattleGround->GetPlayers().end(); ++itr)
+    {
+        // Here we invalidate players in the bg to the added player
+        WorldPacket data1(SMSG_INVALIDATE_PLAYER, 8);
+        data1 << itr->first;
+        GetSession()->SendPacket(&data1);
+
+        if (Player* pPlayer = ObjectAccessor::FindPlayer(itr->first))
+        {
+            GetSession()->SendNameQueryOpcode(pPlayer->GetGUID()); // Send namequery answer instantly if player is available
+            // Here we invalidate the player added to players in the bg
+            WorldPacket data2(SMSG_INVALIDATE_PLAYER, 8);
+            data2 << GetGUID();
+            pPlayer->GetSession()->SendPacket(&data2);
+            pPlayer->GetSession()->SendNameQueryOpcode(GetGUID());
+        }
+    }
+}
+
+bool BattlegroundQueue::CheckCrossFactionMatch(BattlegroundBracketId bracket_id, Battleground* bg)
+{
+    if (!sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) || bg->isArena())
+        return false; // Only do this if crossbg's are enabled.
+
+    // Here we will add all players to selectionpool, later we check if there are enough and launch a bg.
+    FillXPlayersToBG(bracket_id, bg, true);
+
+    if (sBattlegroundMgr->isTesting() && (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() || m_SelectionPools[TEAM_HORDE].GetPlayerCount()))
+        return true;
+
+    uint8 MPT = bg->GetMinPlayersPerTeam();
+    if (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() < MPT || m_SelectionPools[TEAM_HORDE].GetPlayerCount() < MPT)
+        return false;
+
+    return true;
+}
+
+// This function will invite players in the least populated faction, which makes battleground queues much faster.
+// This function will return true if cross faction battlegrounds are enabled, otherwise return false,
+// which is useful in FillPlayersToBG. Because then we can interrupt the regular invitation if cross faction bg's are enabled.
+bool BattlegroundQueue::FillXPlayersToBG(BattlegroundBracketId bracket_id, Battleground* bg, bool start)
+{
+    uint8 queuedPeople = 0;
+    for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].end(); ++itr)
+        if (!(*itr)->IsInvitedToBGInstanceGUID)
+            queuedPeople += (*itr)->Players.size();
+
+    if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) && (sBattlegroundMgr->isTesting() || queuedPeople >= bg->GetMinPlayersPerTeam()*2 || !start))
+    {
+        int32 aliFree   = start ? bg->GetMaxPlayersPerTeam() : bg->GetFreeSlotsForTeam(ALLIANCE);
+        int32 hordeFree = start ? bg->GetMaxPlayersPerTeam() : bg->GetFreeSlotsForTeam(HORDE);
+        // Empty selection pools. They will be refilled from queued groups.
+        m_SelectionPools[TEAM_ALLIANCE].Init();
+        m_SelectionPools[TEAM_HORDE].Init();
+        int32 valiFree = aliFree;
+        int32 vhordeFree = hordeFree;
+        int32 diff = 0;
+
+
+        // Add teams to their own factions as far as possible.
+        if (start)
+        {
+            QueuedGroupMap m_PreGroupMap_a, m_PreGroupMap_h;
+            int32 m_SmallestOfTeams = 0;
+            int32 queuedAlliance = 0;
+            int32 queuedHorde = 0;
+
+            for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].end(); ++itr)
+            {
+                if ((*itr)->IsInvitedToBGInstanceGUID)
+                    continue;
+
+                bool alliance = (*itr)->OTeam == ALLIANCE;
+
+                if (alliance)
+                {
+                    m_PreGroupMap_a.insert(std::make_pair((*itr)->Players.size(), *itr));
+                    queuedAlliance += (*itr)->Players.size();
+                }
+                else
+                {
+                    m_PreGroupMap_h.insert(std::make_pair((*itr)->Players.size(), *itr));
+                    queuedHorde += (*itr)->Players.size();
+                }
+            }
+
+            m_SmallestOfTeams = std::min(std::min(aliFree, queuedAlliance), std::min(hordeFree, queuedHorde));
+
+            valiFree -= PreAddPlayers(m_PreGroupMap_a, m_SmallestOfTeams, aliFree);
+            vhordeFree -= PreAddPlayers(m_PreGroupMap_h, m_SmallestOfTeams, hordeFree);
+        }
+
+        QueuedGroupMap m_QueuedGroupMap;
+
+        for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].end(); ++itr)
+            m_QueuedGroupMap.insert(std::make_pair((*itr)->Players.size(), *itr));
+
+        for (QueuedGroupMap::reverse_iterator itr = m_QueuedGroupMap.rbegin(); itr != m_QueuedGroupMap.rend(); ++itr)
+        {
+            GroupsQueueType allypool = m_SelectionPools[TEAM_ALLIANCE].SelectedGroups;
+            GroupsQueueType hordepool = m_SelectionPools[TEAM_HORDE].SelectedGroups;
+
+            GroupQueueInfo* ginfo = itr->second;
+
+            // If player already was invited via pre adding (add to own team first) or he was already invited to a bg, skip.
+            if (ginfo->IsInvitedToBGInstanceGUID ||
+                std::find(allypool.begin(), allypool.end(), ginfo) != allypool.end() ||
+                std::find(hordepool.begin(), hordepool.end(), ginfo) != hordepool.end() ||
+                (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() >= bg->GetMinPlayersPerTeam() &&
+                m_SelectionPools[TEAM_HORDE].GetPlayerCount() >= bg->GetMinPlayersPerTeam()))
+                continue;
+
+            diff = abs(valiFree - vhordeFree);
+            bool moreAli = valiFree < vhordeFree;
+
+            if (diff > 0)
+                ginfo->Team = moreAli ? HORDE : ALLIANCE;
+
+            bool alliance = ginfo->Team == ALLIANCE;
+
+            if (m_SelectionPools[alliance ? TEAM_ALLIANCE : TEAM_HORDE].AddGroup(ginfo, alliance ? aliFree : hordeFree))
+                alliance ? valiFree -= ginfo->Players.size() : vhordeFree -= ginfo->Players.size();
+        }
+
+        return true;
+    }
+    return false;
+}
+
+int32 BattlegroundQueue::PreAddPlayers(QueuedGroupMap m_PreGroupMap, int32 MaxAdd, uint32 MaxInTeam)
+{
+    int32 LeftToAdd = MaxAdd;
+    uint32 Added = 0;
+
+    for (QueuedGroupMap::reverse_iterator itr = m_PreGroupMap.rbegin(); itr != m_PreGroupMap.rend(); ++itr)
+    {
+        int32 PlayerSize = itr->first;
+        bool alliance = itr->second->OTeam == ALLIANCE;
+
+        if (PlayerSize <= LeftToAdd && m_SelectionPools[alliance ? TEAM_ALLIANCE : TEAM_HORDE].AddGroup(itr->second, MaxInTeam))
+            LeftToAdd -= PlayerSize, Added -= PlayerSize;
+    }
+
+    return LeftToAdd;
+}
+
+void Player::SendChatMessage(const char *format, ...)
+{
+    if (!IsInWorld())
+        return;
+
+    if (format)
+    {
+        va_list ap;
+        char str [2048];
+        va_start(ap, format);
+        vsnprintf(str, 2048, format, ap);
+        va_end(ap);
+
+        ChatHandler(GetSession()).SendSysMessage(str);
+    }
+}
diff --git a/src/server/game/Cfbg/Cfbg.h b/src/server/game/Cfbg/Cfbg.h
new file mode 100644
index 0000000..45567f8
--- /dev/null
+++ b/src/server/game/Cfbg/Cfbg.h
@@ -0,0 +1,35 @@
+#ifndef _CUSTOM_H
+#define _CUSTOM_H
+
+#define MSG_COLOR_LIGHTRED     "|cffff6060"
+#define MSG_COLOR_LIGHTBLUE    "|cff00ccff"
+#define MSG_COLOR_ANN_GREEN    "|c1f40af20"
+#define MSG_COLOR_RED          "|cffff0000"
+#define MSG_COLOR_GOLD         "|cffffcc00"
+#define MSG_COLOR_SUBWHITE     "|cffbbbbbb"
+#define MSG_COLOR_MAGENTA      "|cffff00ff"
+#define MSG_COLOR_YELLOW       "|cffffff00"
+#define MSG_COLOR_CYAN         "|cff00ffff"
+#define MSG_COLOR_DARKBLUE     "|cff0000ff"
+
+#define MSG_COLOR_GREY         "|cff9d9d9d"
+#define MSG_COLOR_WHITE        "|cffffffff"
+#define MSG_COLOR_GREEN        "|cff1eff00"
+#define MSG_COLOR_BLUE         "|cff0080ff"
+#define MSG_COLOR_PURPLE       "|cffb048f8"
+#define MSG_COLOR_ORANGE       "|cffff8000"
+
+#define MSG_COLOR_DRUID        "|cffff7d0a"
+#define MSG_COLOR_HUNTER       "|cffabd473"
+#define MSG_COLOR_MAGE         "|cff69ccf0"
+#define MSG_COLOR_PALADIN      "|cfff58cba"
+#define MSG_COLOR_PRIEST       "|cffffffff"
+#define MSG_COLOR_ROGUE        "|cfffff569"
+#define MSG_COLOR_SHAMAN       "|cff0070de"
+#define MSG_COLOR_WARLOCK      "|cff9482c9"
+#define MSG_COLOR_WARRIOR      "|cffc79c6e"
+#define MSG_COLOR_DEATH_KNIGHT "|cffc41f3b"
+#define MSG_COLOR_MONK         "|cff00ff96"
+
+#define LIMIT_UINT32 2147483647
+#endif
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index fc12360..a03fbb4 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -774,6 +774,12 @@ Player::Player(WorldSession* session): Unit(true), phaseMgr(this)
 #pragma warning(default:4355)
 #endif
 
+    m_FakeRace = 0;
+    m_RealRace = 0;
+    m_FakeMorph = 0;
+    m_ForgetBGPlayers = false;
+    m_ForgetInListPlayers = false;
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -1114,6 +1120,12 @@ bool Player::Create(uint32 guidlow, CharacterCreateInfo* createInfo)
     uint32 RaceClassGender = (createInfo->Race) | (createInfo->Class << 8) | (createInfo->Gender << 16);
 
     SetUInt32Value(UNIT_FIELD_BYTES_0, (RaceClassGender | (powertype << 24)));
+
+    SetORace();
+    m_team = TeamForRace(getORace());
+    SetFakeRaceAndMorph(); // m_team must be set before this can be used.
+    setFactionForRace(getORace());
+
     InitDisplayIds();
     if (sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_PVP || sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_RPPVP)
     {
@@ -3227,7 +3239,7 @@ void Player::GiveLevel(uint8 level)
         guild->UpdateMemberData(this, GUILD_MEMBER_DATA_LEVEL, level);
 
     PlayerLevelInfo info;
-    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), level, &info);
+    sObjectMgr->GetPlayerLevelInfo(getORace(), getClass(), level, &info);
 
     uint32 basehp = 0, basemana = 0;
     sObjectMgr->GetPlayerClassLevelInfo(getClass(), level, basehp, basemana);
@@ -3387,7 +3399,7 @@ void Player::InitStatsForLevel(bool reapplyMods)
     sObjectMgr->GetPlayerClassLevelInfo(getClass(), getLevel(), basehp, basemana);
 
     PlayerLevelInfo info;
-    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), getLevel(), &info);
+    sObjectMgr->GetPlayerLevelInfo(getORace(), getClass(), getLevel(), &info);
 
     SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
     SetUInt32Value(PLAYER_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(getLevel()));
@@ -5408,7 +5420,7 @@ void Player::CreateCorpse()
         return;
     }
 
-    _uf = GetUInt32Value(UNIT_FIELD_BYTES_0);
+    _uf = getORace();
     _pb = GetUInt32Value(PLAYER_BYTES);
     _pb2 = GetUInt32Value(PLAYER_BYTES_2);
 
@@ -7080,10 +7092,10 @@ uint32 Player::TeamForRace(uint8 race)
 
 void Player::setFactionForRace(uint8 race)
 {
-    m_team = TeamForRace(race);
+    SetBGTeam(TeamForRace(race));
 
     ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
-    setFaction(rEntry ? rEntry->FactionID : 0);
+    setFaction(rEntry ? rEntry->FactionID : getFaction());
 }
 
 ReputationRank Player::GetReputationRank(uint32 faction) const
@@ -7217,6 +7229,27 @@ void Player::RewardOnKill (Unit *victim, float rate)
     if (!Rew)
         return;
 
+    uint32 repfaction1 = Rew->RepFaction1;
+    uint32 repfaction2 = Rew->RepFaction2;
+
+    if (!IsPlayingNative())
+    {
+        if (GetOTeam() == ALLIANCE)
+        {
+            if (repfaction1 == 729)
+                repfaction1 = 730;
+            if (repfaction2 == 729)
+                repfaction2 = 730;
+        }
+        else
+        {
+            if (repfaction1 == 730)
+                repfaction1 = 729;
+            if (repfaction2 == 730)
+                repfaction2 = 729;
+        }
+    }
+
     uint32 ChampioningFaction = 0;
 
     if (GetChampioningFaction())
@@ -7235,29 +7268,29 @@ void Player::RewardOnKill (Unit *victim, float rate)
     uint32 team = GetTeam();
 
     // Skip Guild rep from championing if we are in a guild group
-    if (Rew->RepFaction1 == 1168 || Rew->RepFaction2 == 1168)
+    if (repfaction1 == 1168 || repfaction2 == 1168)
     {
         if (GetGroup() && GetGroup()->IsGuildGroup(GetGuildId()))
             ChampioningFaction = 0;
     }
 
-    if (Rew->RepFaction1 && (!Rew->TeamDependent || team == ALLIANCE))
+    if (repfaction1 && (!Rew->TeamDependent || team == ALLIANCE))
     {
-        int32 donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rew->RepValue1, ChampioningFaction ? ChampioningFaction : Rew->RepFaction1);
+        int32 donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rew->RepValue1, ChampioningFaction ? ChampioningFaction : repfaction1);
         donerep1 = int32(donerep1 * rate);
 
-        FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rew->RepFaction1);
+        FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : repfaction1);
         uint32 current_reputation_rank1 = GetReputationMgr().GetRank(factionEntry1);
         if (factionEntry1 && current_reputation_rank1 <= Rew->ReputationMaxCap1)
             GetReputationMgr().ModifyReputation(factionEntry1, donerep1);
     }
 
-    if (Rew->RepFaction2 && (!Rew->TeamDependent || team == HORDE))
+    if (repfaction2 && (!Rew->TeamDependent || team == HORDE))
     {
-        int32 donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rew->RepValue2, ChampioningFaction ? ChampioningFaction : Rew->RepFaction2);
+        int32 donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rew->RepValue2, ChampioningFaction ? ChampioningFaction : repfaction2);
         donerep2 = int32(donerep2 * rate);
 
-        FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rew->RepFaction2);
+        FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : repfaction2);
         uint32 current_reputation_rank2 = GetReputationMgr().GetRank(factionEntry2);
         if (factionEntry2 && current_reputation_rank2 <= Rew->ReputationMaxCap2)
             GetReputationMgr().ModifyReputation(factionEntry2, donerep2);
@@ -7402,7 +7435,7 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
         if (!victim || victim == this || victim->GetTypeId() != TYPEID_PLAYER)
             return false;
 
-        if (GetBGTeam() == victim->ToPlayer()->GetBGTeam())
+        if (GetTeam() == victim->ToPlayer()->GetTeam())
             return false;
 
         return true;
@@ -8173,7 +8206,7 @@ void Player::UpdateArea(uint32 newArea)
 
     // previously this was in UpdateZone (but after UpdateArea) so nothing will break
     pvpInfo.inNoPvPArea = false;
-    if (area && area->IsSanctuary())    // in sanctuary
+    if (area && area->IsSanctuary() || GetAreaId() == 4413)    // in sanctuary
     {
         SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
         pvpInfo.inNoPvPArea = true;
@@ -12241,13 +12274,13 @@ InventoryResult Player::CanUseItem(ItemTemplate const* proto) const
 
     if (proto)
     {
-        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetTeam() != HORDE)
+        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetOTeam() != HORDE)
             return EQUIP_ERR_CANT_EQUIP_EVER;
 
-        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetTeam() != ALLIANCE)
+        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetOTeam() != ALLIANCE)
             return EQUIP_ERR_CANT_EQUIP_EVER;
 
-        if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
+        if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getORaceMask()) == 0)
             return EQUIP_ERR_CANT_EQUIP_EVER;
 
         if (proto->RequiredSkill != 0)
@@ -17594,6 +17627,11 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
     bytes0 |= Gender << 16;                                 // gender
     SetUInt32Value(UNIT_FIELD_BYTES_0, bytes0);
 
+    SetORace();
+    m_team = TeamForRace(getORace());
+    SetFakeRaceAndMorph(); // m_team must be set before this can be used.
+    setFactionForRace(getORace());//Need to call it to initialize m_team (m_team can be calculated from race)
+
     SetUInt32Value(UNIT_FIELD_LEVEL, fields[6].GetUInt8());
     SetUInt32Value(PLAYER_XP, fields[7].GetUInt32());
 
@@ -17639,8 +17677,8 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
 
     //Need to call it to initialize m_team (m_team can be calculated from race)
     //Other way is to saves m_team into characters table.
-    setFactionForRace(getRace());
-    SetByteValue(PLAYER_BYTES_3, 3, GetTeam() == ALLIANCE);      // BattlefieldArenaFaction (0 or 1) set standart
+    //setFactionForRace(getRace());
+    //SetByteValue(PLAYER_BYTES_3, 3, GetTeam() == ALLIANCE);      // BattlefieldArenaFaction (0 or 1) set standart
 
     // load home bind and check in same time class/race pair, it used later for restore broken positions
     if (!_LoadHomeBind(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_HOME_BIND)))
@@ -19647,7 +19685,7 @@ void Player::SaveToDB(bool create /*=false*/)
         stmt->setUInt32(index++, GetGUIDLow());
         stmt->setUInt32(index++, GetSession()->GetAccountId());
         stmt->setString(index++, GetName());
-        stmt->setUInt8(index++, getRace());
+        stmt->setUInt8(index++, getORace());
         stmt->setUInt8(index++, getClass());
         stmt->setUInt8(index++, getGender());
         stmt->setUInt8(index++, getLevel());
@@ -19755,7 +19793,7 @@ void Player::SaveToDB(bool create /*=false*/)
         // Update query
         stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER);
         stmt->setString(index++, GetName());
-        stmt->setUInt8(index++, getRace());
+        stmt->setUInt8(index++, getORace());
         stmt->setUInt8(index++, getClass());
         stmt->setUInt8(index++, getGender());
         stmt->setUInt8(index++, getLevel());
@@ -23011,7 +23049,7 @@ void Player::ReportedAfkBy(Player* reporter)
 
 WorldLocation Player::GetStartPosition() const
 {
-    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getORace(), getClass());
     uint32 mapId = info->mapId;
     if (getClass() == CLASS_DEATH_KNIGHT && HasSpell(50977))
         mapId = 0;
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index ecf7a2b..40662ed 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -1242,6 +1242,35 @@ class Player : public Unit, public GridObject<Player>
     public:
         explicit Player (WorldSession* session);
         ~Player();
+        private:
+        bool m_ForgetBGPlayers;
+        bool m_ForgetInListPlayers;
+        uint8 m_FakeRace;
+        uint8 m_RealRace;
+        uint32 m_FakeMorph;
+    public:
+        typedef std::vector<uint64> FakePlayers;
+        void SendChatMessage(const char *format, ...);
+        void FitPlayerInTeam(bool action, Battleground* pBattleGround = NULL);
+        void DoForgetPlayersInList();
+        void DoForgetPlayersInBG(Battleground* pBattleGround);
+        uint8 getORace() const { return m_RealRace; }
+        void SetORace() { m_RealRace = GetByteValue(UNIT_FIELD_BYTES_0, 0); }; // SHOULD ONLY BE CALLED ON LOGIN
+        void SetFakeRace(); // SHOULD ONLY BE CALLED ON LOGIN
+        void SetFakeRaceAndMorph(); // SHOULD ONLY BE CALLED ON LOGIN
+        uint32 GetFakeMorph() { return m_FakeMorph; };
+        uint8 getFRace() const { return m_FakeRace; }
+        void SetForgetBGPlayers(bool value) { m_ForgetBGPlayers = value; }
+        bool ShouldForgetBGPlayers() { return m_ForgetBGPlayers; }
+        void SetForgetInListPlayers(bool value) { m_ForgetInListPlayers = value; }
+        bool ShouldForgetInListPlayers() { return m_ForgetInListPlayers; }
+        bool SendBattleGroundChat(uint32 msgtype, std::string message);
+        void MorphFit(bool value);
+        bool IsPlayingNative() const { return GetTeam() == m_team; }
+        uint32 GetOTeam() const { return m_team; }
+        uint32 GetTeam() const { return m_bgData.bgTeam && GetBattleground() ? m_bgData.bgTeam : m_team; }
+        bool SendRealNameQuery();
+        FakePlayers m_FakePlayers;
 
         void CleanupsBeforeDelete(bool finalCleanup = true);
 
@@ -1308,7 +1337,7 @@ class Player : public Unit, public GridObject<Player>
         PlayerSocial *GetSocial() { return m_social; }
 
         PlayerTaxi m_taxi;
-        void InitTaxiNodesForLevel() { m_taxi.InitTaxiNodesForLevel(getRace(), getClass(), getLevel()); }
+        void InitTaxiNodesForLevel() { m_taxi.InitTaxiNodesForLevel(getORace(), getClass(), getLevel()); }
         bool ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc = NULL, uint32 spellid = 0);
         bool ActivateTaxiPathTo(uint32 taxi_path_id, uint32 spellid = 0);
         void CleanupAfterTaxiFlight();
@@ -1389,6 +1418,7 @@ class Player : public Unit, public GridObject<Player>
         void Whisper(std::string const& text, const uint32 language, uint64 receiver);
         void WhisperAddon(std::string const& text, std::string const& prefix, Player* receiver);
         void BuildPlayerChat(WorldPacket* data, uint8 msgtype, std::string const& text, uint32 language, const char* addonPrefix = NULL) const;
+        /// Constructs the player Chat data for the specific functions to use
 
         /*********************************************************/
         /***                    STORAGE SYSTEM                 ***/
@@ -2281,8 +2311,7 @@ class Player : public Unit, public GridObject<Player>
         void CheckAreaExploreAndOutdoor(void);
 
         static uint32 TeamForRace(uint8 race);
-        uint32 GetTeam() const { return m_team; }
-        TeamId GetTeamId() const { return m_team == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
+        TeamId GetTeamId() const { return GetTeam() == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
         void setFactionForRace(uint8 race);
 
         void InitDisplayIds();
@@ -2500,7 +2529,7 @@ class Player : public Unit, public GridObject<Player>
             m_bgData.bgTeam = team;
             SetByteValue(PLAYER_BYTES_3, 3, uint8(team == ALLIANCE ? 1 : 0));
         }
-        uint32 GetBGTeam() const { return m_bgData.bgTeam ? m_bgData.bgTeam : GetTeam(); }
+        //uint32 GetBGTeam() const { return m_bgData.bgTeam ? m_bgData.bgTeam : GetTeam(); }
 
         void LeaveBattleground(bool teleportToEntryPoint = true);
         bool CanJoinToBattleground(Battleground const* bg) const;
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index d1b4729..65a04ad 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -17266,7 +17266,7 @@ void Unit::RemoveCharmedBy(Unit* charmer)
 void Unit::RestoreFaction()
 {
     if (GetTypeId() == TYPEID_PLAYER)
-        ToPlayer()->setFactionForRace(getRace());
+        ToPlayer()->setFactionForRace(ToPlayer()->getRace());
     else
     {
         if (HasUnitTypeMask(UNIT_MASK_MINION))
@@ -18228,6 +18228,21 @@ uint32 Unit::GetModelForTotem(PlayerTotemType totemType)
             }
             break;
         }
+        default: // One standard for other races.
+        {        // THANKS L30m4nc3r for this
+            switch (totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    // fire
+                    return 4589;
+                case SUMMON_TYPE_TOTEM_EARTH:   // earth
+                    return 4588;
+                case SUMMON_TYPE_TOTEM_WATER:   // water
+                    return 4587;
+                case SUMMON_TYPE_TOTEM_AIR:     // air
+                    return 4590;
+            }
+            break;
+        }
     }
     return 0;
 }
diff --git a/src/server/game/Entities/Unit/Unit.cpp.orig b/src/server/game/Entities/Unit/Unit.cpp.orig
new file mode 100644
index 0000000..d1b4729
--- /dev/null
+++ b/src/server/game/Entities/Unit/Unit.cpp.orig
@@ -0,0 +1,19614 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "AnticheatMgr.h"
+#include "Unit.h"
+#include "Common.h"
+#include "Battlefield.h"
+#include "BattlefieldMgr.h"
+#include "Battleground.h"
+#include "CellImpl.h"
+#include "ConditionMgr.h"
+#include "CreatureAI.h"
+#include "CreatureAIImpl.h"
+#include "CreatureGroups.h"
+#include "Creature.h"
+#include "Formulas.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "InstanceSaveMgr.h"
+#include "InstanceScript.h"
+#include "Log.h"
+#include "MapManager.h"
+#include "MoveSpline.h"
+#include "MoveSplineInit.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Opcodes.h"
+#include "OutdoorPvP.h"
+#include "PassiveAI.h"
+#include "PetAI.h"
+#include "Pet.h"
+#include "Player.h"
+#include "QuestDef.h"
+#include "ReputationMgr.h"
+#include "SpellAuraEffects.h"
+#include "SpellAuras.h"
+#include "Spell.h"
+#include "SpellInfo.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+#include "Totem.h"
+#include "Transport.h"
+#include "UpdateFieldFlags.h"
+#include "Util.h"
+#include "Vehicle.h"
+#include "World.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+#include "MovementStructures.h"
+#include "InfoMgr.h"
+
+#include <math.h>
+#include "IVMapManager.h"
+
+float baseMoveSpeed[MAX_MOVE_TYPE] =
+{
+    2.5f,                  // MOVE_WALK
+    7.0f,                  // MOVE_RUN
+    4.5f,                  // MOVE_RUN_BACK
+    4.722222f,             // MOVE_SWIM
+    2.5f,                  // MOVE_SWIM_BACK
+    3.141594f,             // MOVE_TURN_RATE
+    7.0f,                  // MOVE_FLIGHT
+    4.5f,                  // MOVE_FLIGHT_BACK
+    3.14f                  // MOVE_PITCH_RATE
+};
+
+float playerBaseMoveSpeed[MAX_MOVE_TYPE] =
+{
+    2.5f,                  // MOVE_WALK
+    7.0f,                  // MOVE_RUN
+    4.5f,                  // MOVE_RUN_BACK
+    4.722222f,             // MOVE_SWIM
+    2.5f,                  // MOVE_SWIM_BACK
+    3.141594f,             // MOVE_TURN_RATE
+    7.0f,                  // MOVE_FLIGHT
+    4.5f,                  // MOVE_FLIGHT_BACK
+    3.14f                  // MOVE_PITCH_RATE
+};
+
+// Used for prepare can/can`t triggr aura
+static bool InitTriggerAuraData();
+// Define can trigger auras
+static bool isTriggerAura[TOTAL_AURAS];
+// Define can't trigger auras (need for disable second trigger)
+static bool isNonTriggerAura[TOTAL_AURAS];
+// Triggered always, even from triggered spells
+static bool isAlwaysTriggeredAura[TOTAL_AURAS];
+// Prepare lists
+static bool procPrepared = InitTriggerAuraData();
+
+DamageInfo::DamageInfo(Unit* _attacker, Unit* _victim, uint32 _damage, SpellInfo const* _spellInfo, SpellSchoolMask _schoolMask, DamageEffectType _damageType)
+: m_attacker(_attacker), m_victim(_victim), m_damage(_damage), m_spellInfo(_spellInfo), m_schoolMask(_schoolMask),
+m_damageType(_damageType), m_attackType(BASE_ATTACK)
+{
+    m_absorb = 0;
+    m_resist = 0;
+    m_block = 0;
+}
+DamageInfo::DamageInfo(CalcDamageInfo& dmgInfo)
+: m_attacker(dmgInfo.attacker), m_victim(dmgInfo.target), m_damage(dmgInfo.damage), m_spellInfo(NULL), m_schoolMask(SpellSchoolMask(dmgInfo.damageSchoolMask)),
+m_damageType(DIRECT_DAMAGE), m_attackType(dmgInfo.attackType)
+{
+    m_absorb = 0;
+    m_resist = 0;
+    m_block = 0;
+}
+
+void DamageInfo::ModifyDamage(int32 amount)
+{
+    amount = std::min(amount, int32(GetDamage()));
+    m_damage += amount;
+}
+
+void DamageInfo::AbsorbDamage(uint32 amount)
+{
+    amount = std::min(amount, GetDamage());
+    m_absorb += amount;
+    m_damage -= amount;
+}
+
+void DamageInfo::ResistDamage(uint32 amount)
+{
+    amount = std::min(amount, GetDamage());
+    m_resist += amount;
+    m_damage -= amount;
+}
+
+void DamageInfo::BlockDamage(uint32 amount)
+{
+    amount = std::min(amount, GetDamage());
+    m_block += amount;
+    m_damage -= amount;
+}
+
+ProcEventInfo::ProcEventInfo(Unit* actor, Unit* actionTarget, Unit* procTarget, uint32 typeMask, uint32 spellTypeMask, uint32 spellPhaseMask, uint32 hitMask, Spell* spell, DamageInfo* damageInfo, HealInfo* healInfo, SpellInfo const* spellInfo)
+:_actor(actor), _actionTarget(actionTarget), _procTarget(procTarget), _typeMask(typeMask), _spellTypeMask(spellTypeMask), _spellPhaseMask(spellPhaseMask),
+_hitMask(hitMask), _spell(spell), _damageInfo(damageInfo), _healInfo(healInfo), _spellInfo(spellInfo)
+{
+}
+
+SpellSchoolMask ProcEventInfo::GetSchoolMask() const
+{
+    return _spellInfo ? _spellInfo->GetSchoolMask() : SPELL_SCHOOL_MASK_NONE;
+}
+
+// we can disable this warning for this since it only
+// causes undefined behavior when passed to the base class constructor
+#ifdef _MSC_VER
+#pragma warning(disable:4355)
+#endif
+Unit::Unit(bool isWorldObject): WorldObject(isWorldObject)
+    , m_movedPlayer(NULL)
+    , m_lastSanctuaryTime(0)
+    , m_TempSpeed(0.0f)
+    , IsAIEnabled(false)
+    , NeedChangeAI(false)
+    , m_ControlledByPlayer(false)
+    , movespline(new Movement::MoveSpline())
+    , i_AI(NULL)
+    , i_disabledAI(NULL)
+    , m_AutoRepeatFirstCast(false)
+    , m_procDeep(0)
+    , m_removedAurasCount(0)
+    , i_motionMaster(this)
+    , m_ThreatManager(this)
+    , m_vehicle(NULL)
+    , m_vehicleKit(NULL)
+    , m_unitTypeMask(UNIT_MASK_NONE)
+    , m_HostileRefManager(this)
+    , _lastDamagedTime(0)
+    , m_gameObjectType(MAX_GAMEOBJECT_TYPE)
+{
+#ifdef _MSC_VER
+#pragma warning(default:4355)
+#endif
+    m_objectType |= TYPEMASK_UNIT;
+    m_objectTypeId = TYPEID_UNIT;
+
+    m_updateFlag = UPDATEFLAG_LIVING;
+
+    m_attackTimer[BASE_ATTACK] = 0;
+    m_attackTimer[OFF_ATTACK] = 0;
+    m_attackTimer[RANGED_ATTACK] = 0;
+    m_modAttackSpeedPct[BASE_ATTACK] = 1.0f;
+    m_modAttackSpeedPct[OFF_ATTACK] = 1.0f;
+    m_modAttackSpeedPct[RANGED_ATTACK] = 1.0f;
+
+    m_extraAttacks = 0;
+    m_canDualWield = false;
+
+    m_movementCounter = 0;
+
+    m_state = 0;
+    m_deathState = ALIVE;
+
+    for (uint8 i = 0; i < CURRENT_MAX_SPELL; ++i)
+        m_currentSpells[i] = NULL;
+
+    m_addDmgOnce = 0;
+
+    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
+        m_SummonSlot[i] = 0;
+
+    for (uint8 i = 0; i < MAX_GAMEOBJECT_SLOT; ++i)
+        m_ObjectSlot[i] = 0;
+
+    m_auraUpdateIterator = m_ownedAuras.end();
+
+    m_interruptMask = 0;
+    m_transform = 0;
+    m_canModifyStats = false;
+
+    for (uint8 i = 0; i < MAX_SPELL_IMMUNITY; ++i)
+        m_spellImmune[i].clear();
+
+    for (uint8 i = 0; i < UNIT_MOD_END; ++i)
+    {
+        m_auraModifiersGroup[i][BASE_VALUE] = 0.0f;
+        m_auraModifiersGroup[i][BASE_PCT] = 1.0f;
+        m_auraModifiersGroup[i][TOTAL_VALUE] = 0.0f;
+        m_auraModifiersGroup[i][TOTAL_PCT] = 1.0f;
+    }
+                                                            // implement 50% base damage from offhand
+    m_auraModifiersGroup[UNIT_MOD_DAMAGE_OFFHAND][TOTAL_PCT] = 0.5f;
+
+    for (uint8 i = 0; i < MAX_ATTACK; ++i)
+    {
+        m_weaponDamage[i][MINDAMAGE] = BASE_MINDAMAGE;
+        m_weaponDamage[i][MAXDAMAGE] = BASE_MAXDAMAGE;
+    }
+
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+        m_createStats[i] = 0.0f;
+
+    m_attacking = NULL;
+    m_modMeleeHitChance = 0.0f;
+    m_modRangedHitChance = 0.0f;
+    m_modSpellHitChance = 0.0f;
+    m_baseSpellCritChance = 5;
+
+    m_soulSwapTargetGuid = 0;
+
+    m_CombatTimer = 0;
+
+    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
+        m_threatModifier[i] = 1.0f;
+
+    m_isSorted = true;
+
+    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
+        m_speed_rate[i] = 1.0f;
+
+    m_charmInfo = NULL;
+
+    _redirectThreadInfo = RedirectThreatInfo();
+
+    // remove aurastates allowing special moves
+    for (uint8 i = 0; i < MAX_REACTIVE; ++i)
+        m_reactiveTimer[i] = 0;
+
+    m_cleanupDone = false;
+    m_duringRemoveFromWorld = false;
+
+    m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GHOST, GHOST_VISIBILITY_ALIVE);
+
+    _focusSpell = NULL;
+    _lastLiquid = NULL;
+    _isWalkingBeforeCharm = false;
+
+    _disableMovementFlagUpdate = false;
+
+    _hoverGroundTargetable = true;
+
+    _PhaseDefinitionStore = sObjectMgr->GetPhaseDefinitionStore();
+    _baseSwapMap = NULL;
+
+    lastSpell = NULL;
+
+    _procTargetGuid = 0;
+}
+
+////////////////////////////////////////////////////////////
+// Methods of class GlobalCooldownMgr
+bool GlobalCooldownMgr::HasGlobalCooldown(SpellInfo const* spellInfo) const
+{
+    GlobalCooldownList::const_iterator itr = m_GlobalCooldowns.find(spellInfo->StartRecoveryCategory);
+    return itr != m_GlobalCooldowns.end() && itr->second.duration && getMSTimeDiff(itr->second.cast_time, getMSTime()) < itr->second.duration;
+}
+
+void GlobalCooldownMgr::AddGlobalCooldown(SpellInfo const* spellInfo, uint32 gcd)
+{
+    m_GlobalCooldowns[spellInfo->StartRecoveryCategory] = GlobalCooldown(gcd, getMSTime());
+}
+
+void GlobalCooldownMgr::CancelGlobalCooldown(SpellInfo const* spellInfo)
+{
+    m_GlobalCooldowns[spellInfo->StartRecoveryCategory].duration = 0;
+}
+
+////////////////////////////////////////////////////////////
+// Methods of class Unit
+Unit::~Unit()
+{
+    // set current spells as deletable
+    for (uint8 i = 0; i < CURRENT_MAX_SPELL; ++i)
+        if (m_currentSpells[i])
+        {
+            m_currentSpells[i]->SetReferencedFromCurrent(false);
+            m_currentSpells[i] = NULL;
+        }
+
+    _DeleteRemovedAuras();
+
+    delete m_charmInfo;
+    delete movespline;
+
+    ASSERT(!m_duringRemoveFromWorld);
+    ASSERT(!m_attacking);
+    ASSERT(m_attackers.empty());
+    ASSERT(m_sharedVision.empty());
+    ASSERT(m_Controlled.empty());
+    ASSERT(m_appliedAuras.empty());
+    ASSERT(m_ownedAuras.empty());
+    ASSERT(m_removedAuras.empty());
+    ASSERT(m_gameObj.empty());
+    ASSERT(m_dynObj.empty());
+}
+
+void Unit::Update(uint32 p_time)
+{
+    // WARNING! Order of execution here is important, do not change.
+    // Spells must be processed with event system BEFORE they go to _UpdateSpells.
+    // Or else we may have some SPELL_STATE_FINISHED spells stalled in pointers, that is bad.
+    m_Events.Update(p_time);
+
+    if (!IsInWorld())
+        return;
+
+    _UpdateSpells(p_time);
+
+    // If this is set during update SetCantProc(false) call is missing somewhere in the code
+    // Having this would prevent spells from being proced, so let's crash
+    ASSERT(!m_procDeep);
+
+    if (CanHaveThreatList() && getThreatManager().isNeedUpdateToClient(p_time))
+        SendThreatListUpdate();
+
+    // update combat timer only for players and pets (only pets with PetAI)
+    if (isInCombat() && (GetTypeId() == TYPEID_PLAYER || (ToCreature()->isPet() && IsControlledByPlayer())))
+    {
+        // Check UNIT_STATE_MELEE_ATTACKING or UNIT_STATE_CHASE (without UNIT_STATE_FOLLOW in this case) so pets can reach far away
+        // targets without stopping half way there and running off.
+        // These flags are reset after target dies or another command is given.
+        if (m_HostileRefManager.isEmpty())
+        {
+            // m_CombatTimer set at aura start and it will be freeze until aura removing
+            if (m_CombatTimer <= p_time)
+                ClearInCombat();
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
+
+    // not implemented before 3.0.2
+    if (uint32 base_att = getAttackTimer(BASE_ATTACK))
+        setAttackTimer(BASE_ATTACK, (p_time >= base_att ? 0 : base_att - p_time));
+    if (uint32 ranged_att = getAttackTimer(RANGED_ATTACK))
+        setAttackTimer(RANGED_ATTACK, (p_time >= ranged_att ? 0 : ranged_att - p_time));
+    if (uint32 off_att = getAttackTimer(OFF_ATTACK))
+        setAttackTimer(OFF_ATTACK, (p_time >= off_att ? 0 : off_att - p_time));
+
+    // update abilities available only for fraction of time
+    UpdateReactives(p_time);
+
+    if (isAlive())
+    {
+        ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, HealthBelowPct(20));
+        ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, HealthBelowPct(35));
+        ModifyAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT, HealthAbovePct(75));
+    }
+
+    UpdateSplineMovement(p_time);
+    i_motionMaster.UpdateMotion(p_time);
+}
+
+bool Unit::haveOffhandWeapon() const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+        return ToPlayer()->GetWeaponForAttack(OFF_ATTACK, true);
+    else
+        return m_canDualWield;
+}
+
+void Unit::MonsterMoveWithSpeed(float x, float y, float z, float speed, bool generatePath, bool forceDestination)
+{
+    Movement::MoveSplineInit init(this);
+    init.MoveTo(x, y, z, generatePath, forceDestination);
+    init.SetVelocity(speed);
+    init.Launch();
+}
+
+void Unit::SendMovementFlagUpdate(bool self /*= false*/)
+{
+    WorldPacket data;
+    BuildHeartBeatMsg(&data);
+    SendMessageToSet(&data, self);
+}
+
+void Unit::UpdateSplineMovement(uint32 t_diff)
+{
+    if (movespline->Finalized())
+        return;
+
+    movespline->updateState(t_diff);
+    bool arrived = movespline->Finalized();
+
+    if (arrived)
+        DisableSpline();
+
+    m_movesplineTimer.Update(t_diff);
+    if (m_movesplineTimer.Passed() || arrived)
+        UpdateSplinePosition();
+}
+
+void Unit::UpdateSplinePosition()
+{
+    uint32 const positionUpdateDelay = 400;
+
+    m_movesplineTimer.Reset(positionUpdateDelay);
+    Movement::Location loc = movespline->ComputePosition();
+    if (GetTransGUID())
+    {
+        Position& pos = m_movementInfo.t_pos;
+        pos.m_positionX = loc.x;
+        pos.m_positionY = loc.y;
+        pos.m_positionZ = loc.z;
+        pos.SetOrientation(loc.orientation);
+
+        if (Unit* vehicle = GetVehicleBase())
+        {
+            loc.x += vehicle->GetPositionX();
+            loc.y += vehicle->GetPositionY();
+            loc.z += vehicle->GetPositionZMinusOffset();
+            loc.orientation = vehicle->GetOrientation();
+        }
+        else if (TransportBase* transport = GetDirectTransport())
+                transport->CalculatePassengerPosition(loc.x, loc.y, loc.z, loc.orientation);
+    }
+
+        if (HasUnitState(UNIT_STATE_CANNOT_TURN))
+            loc.orientation = GetOrientation();
+
+    UpdatePosition(loc.x, loc.y, loc.z, loc.orientation);
+}
+
+void Unit::DisableSpline()
+{
+    m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_FORWARD);
+    movespline->_Interrupt();
+}
+
+void Unit::resetAttackTimer(WeaponAttackType type)
+{
+    m_attackTimer[type] = uint32(GetAttackTime(type) * m_modAttackSpeedPct[type]);
+}
+
+bool Unit::IsWithinCombatRange(const Unit* obj, float dist2compare) const
+{
+    if (!obj || !IsInMap(obj) || !InSamePhase(obj))
+        return false;
+
+    float dx = GetPositionX() - obj->GetPositionX();
+    float dy = GetPositionY() - obj->GetPositionY();
+    float dz = GetPositionZ() - obj->GetPositionZ();
+    float distsq = dx * dx + dy * dy + dz * dz;
+
+    float sizefactor = GetCombatReach() + obj->GetCombatReach();
+    float maxdist = dist2compare + sizefactor;
+
+    return distsq < maxdist * maxdist;
+}
+
+bool Unit::IsWithinMeleeRange(const Unit* obj, float dist) const
+{
+    if (!obj || !IsInMap(obj) || !InSamePhase(obj))
+        return false;
+
+    float dx = GetPositionX() - obj->GetPositionX();
+    float dy = GetPositionY() - obj->GetPositionY();
+    float dz = GetPositionZ() - obj->GetPositionZ();
+    float distsq = dx*dx + dy*dy + dz*dz;
+
+    float sizefactor = GetMeleeReach() + obj->GetMeleeReach();
+    float maxdist = dist + sizefactor;
+
+    return distsq < maxdist * maxdist;
+}
+
+void Unit::GetRandomContactPoint(const Unit* obj, float &x, float &y, float &z, float distance2dMin, float distance2dMax) const
+{
+    float combat_reach = GetCombatReach();
+    if (combat_reach < 0.1f) // sometimes bugged for players
+        combat_reach = DEFAULT_COMBAT_REACH;
+
+    uint32 attacker_number = getAttackers().size();
+    if (attacker_number > 0)
+        --attacker_number;
+    GetNearPoint(obj, x, y, z, obj->GetCombatReach(), distance2dMin+(distance2dMax-distance2dMin) * (float)rand_norm()
+        , GetAngle(obj) + (attacker_number ? (static_cast<float>(M_PI/2) - static_cast<float>(M_PI) * (float)rand_norm()) * float(attacker_number) / combat_reach * 0.3f : 0));
+}
+
+void Unit::UpdateInterruptMask()
+{
+    m_interruptMask = 0;
+    for (AuraApplicationList::const_iterator i = m_interruptableAuras.begin(); i != m_interruptableAuras.end(); ++i)
+        m_interruptMask |= (*i)->GetBase()->GetSpellInfo()->AuraInterruptFlags;
+
+    if (Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])
+        if (spell->getState() == SPELL_STATE_CASTING)
+            m_interruptMask |= spell->m_spellInfo->ChannelInterruptFlags;
+}
+
+bool Unit::HasAuraTypeWithFamilyFlags(AuraType auraType, uint32 familyName, uint32 familyFlags) const
+{
+    if (!HasAuraType(auraType))
+        return false;
+    AuraEffectList const& auras = GetAuraEffectsByType(auraType);
+    for (AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        if (SpellInfo const* iterSpellProto = (*itr)->GetSpellInfo())
+            if (iterSpellProto->SpellFamilyName == familyName && iterSpellProto->SpellFamilyFlags[0] & familyFlags)
+                return true;
+    return false;
+}
+
+bool Unit::HasBreakableByDamageAuraType(AuraType type, uint32 excludeAura) const
+{
+    AuraEffectList const& auras = GetAuraEffectsByType(type);
+    for (AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        if ((!excludeAura || excludeAura != (*itr)->GetSpellInfo()->Id) && //Avoid self interrupt of channeled Crowd Control spells like Seduction
+            ((*itr)->GetSpellInfo()->Attributes & SPELL_ATTR0_BREAKABLE_BY_DAMAGE
+            || (*itr)->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE))
+            return true;
+    return false;
+}
+
+bool Unit::HasBreakableByDamageCrowdControlAura(Unit* excludeCasterChannel) const
+{
+    uint32 excludeAura = 0;
+    if (Spell* currentChanneledSpell = excludeCasterChannel ? excludeCasterChannel->GetCurrentSpell(CURRENT_CHANNELED_SPELL) : NULL)
+        excludeAura = currentChanneledSpell->GetSpellInfo()->Id; //Avoid self interrupt of channeled Crowd Control spells like Seduction
+
+    return (   HasBreakableByDamageAuraType(SPELL_AURA_MOD_CONFUSE, excludeAura)
+            || HasBreakableByDamageAuraType(SPELL_AURA_MOD_STUN, excludeAura)
+            || HasBreakableByDamageAuraType(SPELL_AURA_TRANSFORM, excludeAura));
+}
+
+void Unit::DealDamageMods(Unit* victim, uint32 &damage, uint32* absorb)
+{
+    if (!victim || !victim->isAlive() || victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))
+    {
+        if (absorb)
+            *absorb += damage;
+        damage = 0;
+    }
+}
+
+uint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellSchoolMask damageSchoolMask, SpellInfo const* spellProto, bool durabilityLoss, bool splitted)
+{
+    if (!victim)
+        return 0;
+
+    if (victim->IsAIEnabled && !victim->GetAI())
+    {
+        sLog->outError(LOG_FILTER_GENERAL,
+            "Error while executing Unit::DealDamage. AI is enabled but get a NULL Ptr as return-statement. GUID: %u - Entry: %u",
+                victim->GetGUID(), victim->GetTypeId() == TYPEID_UNIT ? victim->GetEntry() : 0);
+        victim->IsAIEnabled = false;
+    }
+    
+    if (victim->IsAIEnabled)
+        victim->GetAI()->DamageTaken(this, damage);
+
+    if (IsAIEnabled)
+        GetAI()->DamageDealt(victim, damage, damagetype);
+
+    if (victim->GetTypeId() == TYPEID_PLAYER && this != victim)
+    {
+        // Signal to pets that their owner was attacked
+        Pet* pet = victim->ToPlayer()->GetPet();
+
+        if (pet && pet->isAlive())
+            pet->AI()->OwnerAttackedBy(this);
+
+        if (victim->ToPlayer()->GetCommandStatus(CHEAT_GOD))
+            return 0;
+    }
+
+    // Signal the pet it was attacked so the AI can respond if needed
+    if (victim->GetTypeId() == TYPEID_UNIT && this != victim && victim->isPet() && victim->isAlive() && victim->IsAIEnabled)
+        victim->ToPet()->AI()->AttackedBy(this);
+
+    if (damagetype != NODAMAGE)
+    {
+        uint32 flag = splitted ? (AURA_INTERRUPT_FLAG_TAKE_DAMAGE | AURA_INTERRUPT_FLAG_TAKE_DAMAGE2) : AURA_INTERRUPT_FLAG_TAKE_DAMAGE;
+        // interrupting auras with AURA_INTERRUPT_FLAG_DAMAGE before checking !damage (absorbed damage breaks that type of auras)
+        if (spellProto)
+        {
+            if (!(spellProto->AttributesEx4 & SPELL_ATTR4_DAMAGE_DOESNT_BREAK_AURAS))
+                victim->RemoveAurasWithInterruptFlags(flag, spellProto->Id, damage);
+        }
+        else
+            victim->RemoveAurasWithInterruptFlags(flag, 0, damage);
+
+        // get the owner of the pet in combat only when the pet does damage
+        if (GetOwner() && !IsFriendlyTo(victim))
+        {
+            SetInCombatWith(victim);
+            if (victim->GetTypeId() == TYPEID_PLAYER)
+                victim->SetInCombatWith(this);
+            AddThreat(victim, 0.0f);
+
+            GetOwner()->SetInCombatWith(victim);
+            GetOwner()->AddThreat(victim, 0.0f);
+        }
+
+        // We're going to call functions which can modify content of the list during iteration over it's elements
+        // Let's copy the list so we can prevent iterator invalidation
+        AuraEffectList vCopyDamageCopy(victim->GetAuraEffectsByType(SPELL_AURA_SHARE_DAMAGE_PCT));
+        // copy damage to casters of this aura
+        for (AuraEffectList::iterator i = vCopyDamageCopy.begin(); i != vCopyDamageCopy.end(); ++i)
+        {
+            // Check if aura was removed during iteration - we don't need to work on such auras
+            if (!((*i)->GetBase()->IsAppliedOnTarget(victim->GetGUID())))
+                continue;
+            // check damage school mask
+            if (((*i)->GetMiscValue() & damageSchoolMask) == 0)
+                continue;
+
+            Unit* shareDamageTarget = (*i)->GetCaster();
+            if (!shareDamageTarget)
+                continue;
+            SpellInfo const* spell = (*i)->GetSpellInfo();
+
+            uint32 share = CalculatePct(damage, (*i)->GetAmount());
+
+            // TODO: check packets if damage is done by victim, or by attacker of victim
+            DealDamageMods(shareDamageTarget, share, NULL);
+            DealDamage(shareDamageTarget, share, NULL, NODAMAGE, spell->GetSchoolMask(), spell, false);
+        }
+    }
+
+    // Rage from Damage made (only from direct weapon damage)
+    if (cleanDamage && damagetype == DIRECT_DAMAGE && this != victim && getPowerType() == POWER_RAGE)
+    {
+        uint32 rage = (GetAttackTime(cleanDamage->attackType) / 1000.0f) * 6.5f;
+        switch (cleanDamage->attackType)
+        {
+            case OFF_ATTACK:
+                rage /= 2;
+            case BASE_ATTACK:
+                RewardRage(rage, true);
+                break;
+            default:
+                break;
+        }
+    }
+
+    if (!damage)
+    {
+        // Rage from absorbed damage
+        if (cleanDamage && cleanDamage->absorbed_damage && victim->getPowerType() == POWER_RAGE)
+            victim->RewardRage(cleanDamage->absorbed_damage, false);
+
+        // Rage from damage received
+        if (this != victim && victim->getPowerType() == POWER_RAGE && cleanDamage && cleanDamage->hitOutCome != MELEE_HIT_MISS)
+        {
+            uint32 rage_damage = cleanDamage->mitigated_damage;
+            victim->RewardRage(rage_damage, false);
+        }
+
+        return 0;
+    }
+
+    sLog->outDebug(LOG_FILTER_UNITS, "DealDamageStart");
+
+    uint32 health = victim->GetHealth();
+    sLog->outDebug(LOG_FILTER_UNITS, "Unit " UI64FMTD " dealt %u damage to unit " UI64FMTD, GetGUID(), damage, victim->GetGUID());
+
+    // duel ends when player has 1 or less hp
+    bool duel_hasEnded = false;
+    bool duel_wasMounted = false;
+    if (victim->GetTypeId() == TYPEID_PLAYER && victim->ToPlayer()->duel && damage >= (health-1))
+    {
+        // prevent kill only if killed in duel and killed by opponent or opponent controlled creature
+        if (victim->ToPlayer()->duel->opponent == this || victim->ToPlayer()->duel->opponent->GetGUID() == GetOwnerGUID())
+            damage = health - 1;
+
+        duel_hasEnded = true;
+    }
+    else if (victim->IsVehicle() && damage >= (health-1) && victim->GetCharmer() && victim->GetCharmer()->GetTypeId() == TYPEID_PLAYER)
+    {
+        Player* victimRider = victim->GetCharmer()->ToPlayer();
+
+        if (victimRider && victimRider->duel && victimRider->duel->isMounted)
+        {
+            // prevent kill only if killed in duel and killed by opponent or opponent controlled creature
+            if (victimRider->duel->opponent == this || victimRider->duel->opponent->GetGUID() == GetCharmerGUID())
+                damage = health - 1;
+
+            duel_wasMounted = true;
+            duel_hasEnded = true;
+        }
+    }
+
+    if (GetTypeId() == TYPEID_PLAYER && this != victim)
+    {
+        Player* killer = ToPlayer();
+
+        // in bg, count dmg if victim is also a player
+        if (victim->GetTypeId() == TYPEID_PLAYER)
+            if (Battleground* bg = killer->GetBattleground())
+                bg->UpdatePlayerScore(killer, SCORE_DAMAGE_DONE, damage);
+
+        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DAMAGE_DONE, damage, 0, 0, victim);
+        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_DEALT, damage);
+    }
+
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+        victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_RECEIVED, damage);
+    else if (!victim->IsControlledByPlayer() || victim->IsVehicle())
+    {
+        if (!victim->ToCreature()->hasLootRecipient())
+            victim->ToCreature()->SetLootRecipient(this);
+
+        if (IsControlledByPlayer())
+            victim->ToCreature()->LowerPlayerDamageReq(health < damage ?  health : damage);
+    }
+
+    if (health <= damage)
+    {
+        sLog->outDebug(LOG_FILTER_UNITS, "DealDamage: victim just died");
+
+        if (victim->GetTypeId() == TYPEID_PLAYER && victim != this)
+            victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, health);
+
+        Kill(victim, durabilityLoss);
+
+        //Currency Reward
+        if (GetTypeId() == TYPEID_PLAYER && victim->GetTypeId() == TYPEID_UNIT)
+        {
+            Creature* _victim = victim->ToCreature();
+            if (_victim)
+            {
+                const CreatureTemplate* tpl = _victim->GetCreatureTemplate();
+                if (tpl->currencyId && tpl->currencyCount)
+                {
+                    Player* player = ToPlayer();
+                    Group* grp = player->GetGroup();
+
+                    if (grp)
+                    {
+                        for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            if (Player* grpMember = itr->getSource())
+                            {
+                                if (grpMember->GetMapId() == GetMapId())
+                                    grpMember->ModifyCurrency(tpl->currencyId, tpl->currencyCount*100, true, true, false);
+                            }
+                        }
+                    }
+                    else
+                        player->ModifyCurrency(tpl->currencyId, tpl->currencyCount*100, true, true, false);
+                }
+            }
+        }
+        else if (victim->GetTypeId() == TYPEID_UNIT)
+        {
+            Creature* _victim = victim->ToCreature();
+            if (_victim)
+            {
+                const CreatureTemplate* tpl = _victim->GetCreatureTemplate();
+                if (tpl->currencyId && tpl->currencyCount)
+                {
+                    Player* player = FindNearestPlayer(MAX_VISIBILITY_DISTANCE, true);
+                    if (player)
+                    {
+                        Group* grp = player->GetGroup();
+
+                        if (grp)
+                        {
+                            for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+                            {
+                                if (Player* grpMember = itr->getSource())
+                                {
+                                    if (grpMember->GetMapId() == GetMapId())
+                                        grpMember->ModifyCurrency(tpl->currencyId, tpl->currencyCount*100, true, true, false);
+                                }
+                            }
+                        }
+                        else
+                            player->ModifyCurrency(tpl->currencyId, tpl->currencyCount*100, true, true, false);
+                    }
+                }
+            }
+        }
+    }
+    else
+    {
+        sLog->outDebug(LOG_FILTER_UNITS, "DealDamageAlive");
+
+        if (victim->GetTypeId() == TYPEID_PLAYER)
+            victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, damage);
+
+        victim->ModifyHealth(-(int32)damage);
+
+        SpellFamilyNames family = SPELLFAMILY_GENERIC;
+        // Vengeance proc
+        switch(victim->getClass())
+        {
+            case CLASS_WARRIOR:     family = SPELLFAMILY_WARRIOR;       break;
+            case CLASS_PALADIN:     family = SPELLFAMILY_PALADIN;       break;
+            case CLASS_DRUID:       family = SPELLFAMILY_DRUID;         break;
+            // Dk's Vengeance has spellfamily warrior flag, don't know why
+            case CLASS_DEATH_KNIGHT:family = SPELLFAMILY_WARRIOR;   break;
+            default: break;
+        }
+        if (AuraEffect *aurEff = victim->GetAuraEffect(SPELL_AURA_DUMMY, family, 3031, 0))
+        {
+            if(this != victim && this->GetTypeId() != TYPEID_PLAYER && !(this->GetTypeId() == TYPEID_UNIT && this->isPet()))
+            {
+                // Tooltip says 5% of damage but wowpedia says:
+                // Patch 4.3.0 (2011-11-29): Vengeance has been redesigned slightly.
+                // It no longer ramps up slowly at the beginning of a fight.
+                // Instead, the first melee attack taken by the tank generates Vengeance equal to 33% of the damage taken by that attack.
+                // In addition, as it updates periodically during the fight, it's always set to at least 33% of the damage taken by the tank in the last 2 seconds.
+                // int32 value = ApplyPct(damage, aurEff->GetAmount());
+                int32 value = ApplyPct(damage, 33);
+                if(value < 1)
+                    value = 1;
+
+                if(uint32(value) > victim->CountPctFromMaxHealth(aurEff->GetAmount()*2))
+                    value = victim->CountPctFromMaxHealth(aurEff->GetAmount()*2);
+
+                if(victim->HasAura(76691))
+                {
+                    value += victim->GetAuraEffect(76691, EFFECT_0)->GetAmount();
+
+                    if(uint32(value) > victim->CountPctFromMaxHealth(aurEff->GetAmount()*2))
+                        value = victim->CountPctFromMaxHealth(aurEff->GetAmount()*2);
+                }
+
+                victim->CastCustomSpell(victim, 76691, &value, &value, NULL, true);
+            }
+        }
+
+        if (damagetype == DIRECT_DAMAGE || damagetype == SPELL_DIRECT_DAMAGE)
+        {
+            victim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_DIRECT_DAMAGE, spellProto ? spellProto->Id : 0);
+            if (victim->GetTypeId() == TYPEID_UNIT && !victim->isPet())
+                victim->SetLastDamagedTime(time(NULL));
+        }
+
+        if (victim->GetTypeId() != TYPEID_PLAYER)
+            victim->AddThreat(this, float(damage), damageSchoolMask, spellProto);
+        else                                                // victim is a player
+        {
+            // random durability for items (HIT TAKEN)
+            if (roll_chance_f(sWorld->getRate(RATE_DURABILITY_LOSS_DAMAGE)))
+            {
+                EquipmentSlots slot = EquipmentSlots(urand(0, EQUIPMENT_SLOT_END-1));
+                victim->ToPlayer()->DurabilityPointLossForEquipSlot(slot);
+            }
+        }
+
+        // Rage from damage received
+        if (this != victim && victim->getPowerType() == POWER_RAGE)
+        {
+            uint32 rage_damage = damage + (cleanDamage ? (cleanDamage->absorbed_damage + cleanDamage->mitigated_damage) : 0);
+            victim->RewardRage(rage_damage, false);
+        }
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            // random durability for items (HIT DONE)
+            if (roll_chance_f(sWorld->getRate(RATE_DURABILITY_LOSS_DAMAGE)))
+            {
+                EquipmentSlots slot = EquipmentSlots(urand(0, EQUIPMENT_SLOT_END-1));
+                ToPlayer()->DurabilityPointLossForEquipSlot(slot);
+            }
+        }
+
+        if (damagetype != NODAMAGE && damage)
+        {
+            if (victim != this && victim->GetTypeId() == TYPEID_PLAYER) // does not support creature push_back
+            {
+                if (damagetype != DOT)
+                    if (Spell* spell = victim->m_currentSpells[CURRENT_GENERIC_SPELL])
+                        if (spell->getState() == SPELL_STATE_PREPARING)
+                        {
+                            uint32 interruptFlags = spell->m_spellInfo->InterruptFlags;
+                            if (interruptFlags & SPELL_INTERRUPT_FLAG_ABORT_ON_DMG)
+                                victim->InterruptNonMeleeSpells(false);
+                            else if (interruptFlags & SPELL_INTERRUPT_FLAG_PUSH_BACK)
+                                spell->Delayed();
+                        }
+
+                if (Spell* spell = victim->m_currentSpells[CURRENT_CHANNELED_SPELL])
+                    if (spell->getState() == SPELL_STATE_CASTING)
+                    {
+                        uint32 channelInterruptFlags = spell->m_spellInfo->ChannelInterruptFlags;
+                        if (((channelInterruptFlags & CHANNEL_FLAG_DELAY) != 0) && (damagetype != DOT))
+                            spell->DelayedChannel();
+                    }
+            }
+        }
+
+        // last damage from duel opponent
+        if (duel_hasEnded)
+        {
+            Player* he = duel_wasMounted ? victim->GetCharmer()->ToPlayer() : victim->ToPlayer();
+
+            ASSERT(he && he->duel);
+
+            if (duel_wasMounted) // In this case victim==mount
+                victim->SetHealth(1);
+            else
+                he->SetHealth(1);
+
+            he->duel->opponent->CombatStopWithPets(true);
+            he->CombatStopWithPets(true);
+
+            he->CastSpell(he, 7267, true);                  // beg
+            he->DuelComplete(DUEL_WON);
+        }
+    }
+
+    sLog->outDebug(LOG_FILTER_UNITS, "DealDamageEnd returned %d damage", damage);
+
+    return damage;
+}
+
+void Unit::CastStop(uint32 except_spellid)
+{
+    for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)
+        if (m_currentSpells[i] && m_currentSpells[i]->m_spellInfo->Id != except_spellid)
+            InterruptSpell(CurrentSpellTypes(i), false);
+}
+
+void Unit::CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo, CustomSpellValues const* value, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
+{
+    if (!spellInfo)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "CastSpell: unknown spell by caster: %s %u)", (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+
+    // TODO: this is a workaround - not needed anymore, but required for some scripts :(
+    if (!originalCaster && triggeredByAura)
+        originalCaster = triggeredByAura->GetCasterGUID();
+
+    Spell* spell = new Spell(this, spellInfo, triggerFlags, originalCaster);
+
+    if (value)
+        for (CustomSpellValues::const_iterator itr = value->begin(); itr != value->end(); ++itr)
+            spell->SetSpellValue(itr->first, itr->second);
+
+    spell->m_CastItem = castItem;
+    spell->prepare(&targets, triggeredByAura);
+}
+
+void Unit::CastSpell(Unit* victim, uint32 spellId, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
+{
+    CastSpell(victim, spellId, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastSpell(Unit* victim, uint32 spellId, TriggerCastFlags triggerFlags /*= TRIGGER_NONE*/, Item* castItem /*= NULL*/, AuraEffect const* triggeredByAura /*= NULL*/, uint64 originalCaster /*= 0*/)
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "CastSpell: unknown spell id %u by caster: %s %u)", spellId, (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+
+    CastSpell(victim, spellInfo, triggerFlags, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastSpell(Unit* victim, SpellInfo const* spellInfo, bool triggered, Item* castItem/*= NULL*/, AuraEffect const* triggeredByAura /*= NULL*/, uint64 originalCaster /*= 0*/)
+{
+    CastSpell(victim, spellInfo, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastSpell(Unit* victim, SpellInfo const* spellInfo, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
+{
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+    CastSpell(targets, spellInfo, NULL, triggerFlags, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastCustomSpell(Unit* target, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
+{
+    CustomSpellValues values;
+    if (bp0)
+        values.AddSpellMod(SPELLVALUE_BASE_POINT0, *bp0);
+    if (bp1)
+        values.AddSpellMod(SPELLVALUE_BASE_POINT1, *bp1);
+    if (bp2)
+        values.AddSpellMod(SPELLVALUE_BASE_POINT2, *bp2);
+    CastCustomSpell(spellId, values, target, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastCustomSpell(Unit* target, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
+{
+    CustomSpellValues values;
+    if (bp0)
+        values.AddSpellMod(SPELLVALUE_BASE_POINT0, *bp0);
+    if (bp1)
+        values.AddSpellMod(SPELLVALUE_BASE_POINT1, *bp1);
+    if (bp2)
+        values.AddSpellMod(SPELLVALUE_BASE_POINT2, *bp2);
+    CastCustomSpell(spellId, values, target, triggerFlags, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* target, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
+{
+    CustomSpellValues values;
+    values.AddSpellMod(mod, value);
+    CastCustomSpell(spellId, values, target, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* target, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
+{
+    CustomSpellValues values;
+    values.AddSpellMod(mod, value);
+    CastCustomSpell(spellId, values, target, triggerFlags, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastCustomSpell(uint32 spellId, CustomSpellValues const& value, Unit* victim, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "CastSpell: unknown spell id %u by caster: %s %u)", spellId, (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+
+    CastSpell(targets, spellInfo, &value, triggerFlags, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastSpell(float x, float y, float z, uint32 spellId, bool triggered, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "CastSpell: unknown spell id %u by caster: %s %u)", spellId, (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+    SpellCastTargets targets;
+    targets.SetDst(x, y, z, GetOrientation());
+
+    CastSpell(targets, spellInfo, NULL, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastSpell(GameObject* go, uint32 spellId, bool triggered, Item* castItem, AuraEffect* triggeredByAura, uint64 originalCaster)
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "CastSpell: unknown spell id %u by caster: %s %u)", spellId, (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+    SpellCastTargets targets;
+    targets.SetGOTarget(go);
+
+    CastSpell(targets, spellInfo, NULL, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastWithDelay(uint32 delay, Unit* victim, uint32 spellid, bool triggered, bool repeat)
+{
+    class CastDelayEvent : public BasicEvent
+    {
+    public:
+        CastDelayEvent(Unit* _me, Unit* _victim, uint32 const& _spellId, bool const& _triggered, bool const& _repeat, uint32 const& _delay) :
+            me(_me), victim(_victim), spellId(_spellId), triggered(_triggered), repeat(_repeat), delay(_delay) { }
+
+        bool Execute(uint64 /*execTime*/, uint32 /*diff*/)
+        {
+            me->CastSpell(victim, spellId, triggered);
+            if (repeat)
+                me->CastWithDelay(delay, victim, spellId, triggered, repeat);
+            return true;
+        }
+
+    private:
+        Unit* me;
+        Unit* victim;
+        uint32 const spellId;
+        uint32 const delay;
+        bool const triggered;
+        bool const repeat;
+    };
+
+    m_Events.AddEvent(new CastDelayEvent(this, victim, spellid, triggered, repeat, delay), m_Events.CalculateTime(delay));
+}
+
+// Obsolete func need remove, here only for comotability vs another patches
+uint32 Unit::SpellNonMeleeDamageLog(Unit* victim, uint32 spellID, uint32 damage)
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellID);
+    SpellNonMeleeDamage damageInfo(this, victim, spellInfo->Id, spellInfo->SchoolMask);
+    damage = SpellDamageBonusDone(victim, spellInfo, damage, SPELL_DIRECT_DAMAGE);
+    damage = victim->SpellDamageBonusTaken(spellInfo, damage, SPELL_DIRECT_DAMAGE);
+
+    CalculateSpellDamageTaken(&damageInfo, damage, spellInfo);
+    DealDamageMods(damageInfo.target, damageInfo.damage, &damageInfo.absorb);
+    SendSpellNonMeleeDamageLog(&damageInfo);
+    DealSpellDamage(&damageInfo, true);
+    return damageInfo.damage;
+}
+
+void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 damage, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit)
+{
+    if (damage < 0)
+        return;
+
+    Unit* victim = damageInfo->target;
+    if (!victim || !victim->isAlive())
+        return;
+
+    SpellSchoolMask damageSchoolMask = SpellSchoolMask(damageInfo->schoolMask);
+
+    if (IsDamageReducedByArmor(damageSchoolMask, spellInfo))
+        damage = CalcArmorReducedDamage(victim, damage, spellInfo, attackType);
+
+    bool blocked = false;
+    // Per-school calc
+    switch (spellInfo->DmgClass)
+    {
+        // Melee and Ranged Spells
+        case SPELL_DAMAGE_CLASS_RANGED:
+        case SPELL_DAMAGE_CLASS_MELEE:
+        {
+            // Physical Damage
+            if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
+            {
+                // Get blocked status
+                blocked = isSpellBlocked(victim, spellInfo, attackType);
+            }
+
+            if (crit)
+            {
+                damageInfo->HitInfo |= SPELL_HIT_TYPE_CRIT;
+
+                // Calculate crit bonus
+                uint32 crit_bonus = damage;
+                // Apply crit_damage bonus for melee spells
+                if (Player* modOwner = GetSpellModOwner())
+                    modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CRIT_DAMAGE_BONUS, crit_bonus);
+                damage += crit_bonus;
+
+                // Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE
+                float critPctDamageMod = 0.0f;
+                if (attackType == RANGED_ATTACK)
+                    critPctDamageMod += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);
+                else
+                    critPctDamageMod += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);
+
+                // Increase crit damage from SPELL_AURA_MOD_CRIT_DAMAGE_BONUS
+                critPctDamageMod += (GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS, spellInfo->GetSchoolMask()) - 1.0f) * 100;
+
+                if (critPctDamageMod != 0)
+                    AddPct(damage, critPctDamageMod);
+            }
+
+            // Spell weapon based damage CAN BE crit & blocked at same time
+            if (blocked)
+            {
+                // double blocked amount if block is critical
+                uint32 value = victim->GetBlockPercent();
+                if (victim->isBlockCritical())
+                    value *= 2; // double blocked percent
+                damageInfo->blocked = CalculatePct(damage, value);
+                damage -= damageInfo->blocked;
+            }
+
+            // Some spells with this attribute should ignore resil
+            if (spellInfo->AttributesEx4 & SPELL_ATTR4_FIXED_DAMAGE)
+                 break;
+
+            ApplyResilience(victim, &damage, crit);
+            break;
+        }
+        // Magical Attacks
+        case SPELL_DAMAGE_CLASS_NONE:
+        case SPELL_DAMAGE_CLASS_MAGIC:
+        {
+            // If crit add critical bonus
+            if (crit)
+            {
+                damageInfo->HitInfo |= SPELL_HIT_TYPE_CRIT;
+                damage = SpellCriticalDamageBonus(spellInfo, damage, victim);
+            }
+
+            // Spells with this attribute should ignore resilience - Unholy Frenzy
+            if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE && spellInfo->AttributesEx4 & SPELL_ATTR4_FIXED_DAMAGE)
+                break;
+
+            ApplyResilience(victim, &damage, crit);
+            break;
+        }
+        default:
+            break;
+    }
+
+    // Script Hook For CalculateSpellDamageTaken -- Allow scripts to change the Damage post class mitigation calculations
+    sScriptMgr->ModifySpellDamageTaken(damageInfo->target, damageInfo->attacker, damage);
+
+    // Calculate absorb resist
+    if (damage > 0)
+    {
+        CalcAbsorbResist(victim, damageSchoolMask, SPELL_DIRECT_DAMAGE, damage, &damageInfo->absorb, &damageInfo->resist, spellInfo);
+        damage -= damageInfo->absorb + damageInfo->resist;
+    }
+    else
+        damage = 0;
+
+    damageInfo->damage = damage;
+}
+
+void Unit::DealSpellDamage(SpellNonMeleeDamage* damageInfo, bool durabilityLoss)
+{
+    if (damageInfo == 0)
+        return;
+
+    Unit* victim = damageInfo->target;
+
+    if (!victim)
+        return;
+
+    if (!victim->isAlive() || victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))
+        return;
+
+    SpellInfo const* spellProto = sSpellMgr->GetSpellInfo(damageInfo->SpellID);
+    if (spellProto == NULL)
+    {
+        sLog->outDebug(LOG_FILTER_UNITS, "Unit::DealSpellDamage has wrong damageInfo->SpellID: %u", damageInfo->SpellID);
+        return;
+    }
+
+    // Call default DealDamage
+    CleanDamage cleanDamage(damageInfo->cleanDamage, damageInfo->absorb, BASE_ATTACK, MELEE_HIT_NORMAL);
+    DealDamage(victim, damageInfo->damage, &cleanDamage, SPELL_DIRECT_DAMAGE, SpellSchoolMask(damageInfo->schoolMask), spellProto, durabilityLoss);
+}
+
+// TODO for melee need create structure as in
+void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* damageInfo, WeaponAttackType attackType)
+{
+    damageInfo->attacker         = this;
+    damageInfo->target           = victim;
+    damageInfo->damageSchoolMask = GetMeleeDamageSchoolMask();
+    damageInfo->attackType       = attackType;
+    damageInfo->damage           = 0;
+    damageInfo->cleanDamage      = 0;
+    damageInfo->absorb           = 0;
+    damageInfo->resist           = 0;
+    damageInfo->blocked_amount   = 0;
+
+    damageInfo->TargetState      = 0;
+    damageInfo->HitInfo          = 0;
+    damageInfo->procAttacker     = PROC_FLAG_NONE;
+    damageInfo->procVictim       = PROC_FLAG_NONE;
+    damageInfo->procEx           = PROC_EX_NONE;
+    damageInfo->hitOutCome       = MELEE_HIT_EVADE;
+
+    if (!victim)
+        return;
+
+    if (!isAlive() || !victim->isAlive())
+        return;
+
+    // Select HitInfo/procAttacker/procVictim flag based on attack type
+    switch (attackType)
+    {
+        case BASE_ATTACK:
+            damageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_MAINHAND_ATTACK;
+            damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
+            break;
+        case OFF_ATTACK:
+            damageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_OFFHAND_ATTACK;
+            damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
+            damageInfo->HitInfo      = HITINFO_OFFHAND;
+            break;
+        default:
+            return;
+    }
+
+    // Physical Immune check
+    if (damageInfo->target->IsImmunedToDamage(SpellSchoolMask(damageInfo->damageSchoolMask)))
+    {
+       damageInfo->HitInfo       |= HITINFO_NORMALSWING;
+       damageInfo->TargetState    = VICTIMSTATE_IS_IMMUNE;
+
+       damageInfo->procEx        |= PROC_EX_IMMUNE;
+       damageInfo->damage         = 0;
+       damageInfo->cleanDamage    = 0;
+       return;
+    }
+
+    damage += CalculateDamage(damageInfo->attackType, false, true);
+    // Add melee damage bonus
+    damage = MeleeDamageBonusDone(damageInfo->target, damage, damageInfo->attackType);
+    damage = damageInfo->target->MeleeDamageBonusTaken(this, damage, damageInfo->attackType);
+
+    AuraEffectList const& autoAttack = GetAuraEffectsByType(SPELL_AURA_MOD_AUTOATTACK_DAMAGE);
+    for (AuraEffectList::const_iterator i = autoAttack.begin(); i != autoAttack.end(); ++i)
+        AddPct(damage, (*i)->GetAmount());
+
+    // Script Hook For CalculateMeleeDamage -- Allow scripts to change the Damage pre class mitigation calculations
+    sScriptMgr->ModifyMeleeDamage(damageInfo->target, damageInfo->attacker, damage);
+
+    // Calculate armor reduction
+    if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))
+    {
+        damageInfo->damage = CalcArmorReducedDamage(damageInfo->target, damage, NULL, damageInfo->attackType);
+        damageInfo->cleanDamage += damage - damageInfo->damage;
+    }
+    else
+        damageInfo->damage = damage;
+
+    damageInfo->hitOutCome = RollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
+
+    switch (damageInfo->hitOutCome)
+    {
+        case MELEE_HIT_EVADE:
+            damageInfo->HitInfo        |= HITINFO_MISS | HITINFO_SWINGNOHITSOUND;
+            damageInfo->TargetState     = VICTIMSTATE_EVADES;
+            damageInfo->procEx         |= PROC_EX_EVADE;
+            damageInfo->damage = 0;
+            damageInfo->cleanDamage = 0;
+            return;
+        case MELEE_HIT_MISS:
+            damageInfo->HitInfo        |= HITINFO_MISS;
+            damageInfo->TargetState     = VICTIMSTATE_INTACT;
+            damageInfo->procEx         |= PROC_EX_MISS;
+            damageInfo->damage          = 0;
+            damageInfo->cleanDamage     = 0;
+            break;
+        case MELEE_HIT_NORMAL:
+            damageInfo->TargetState     = VICTIMSTATE_HIT;
+            damageInfo->procEx         |= PROC_EX_NORMAL_HIT;
+            break;
+        case MELEE_HIT_CRIT:
+        {
+            damageInfo->HitInfo        |= HITINFO_CRITICALHIT;
+            damageInfo->TargetState     = VICTIMSTATE_HIT;
+
+            damageInfo->procEx         |= PROC_EX_CRITICAL_HIT;
+            // Crit bonus calc
+            damageInfo->damage += damageInfo->damage;
+            float mod = 0.0f;
+            // Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE
+            if (damageInfo->attackType == RANGED_ATTACK)
+                mod += damageInfo->target->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);
+            else
+                mod += damageInfo->target->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);
+
+            // Increase crit damage from SPELL_AURA_MOD_CRIT_DAMAGE_BONUS
+            mod += (GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS, damageInfo->damageSchoolMask) - 1.0f) * 100;
+
+            if (mod != 0)
+                AddPct(damageInfo->damage, mod);
+            break;
+        }
+        case MELEE_HIT_PARRY:
+            damageInfo->TargetState  = VICTIMSTATE_PARRY;
+            damageInfo->procEx      |= PROC_EX_PARRY;
+            damageInfo->cleanDamage += damageInfo->damage;
+            damageInfo->damage = 0;
+            break;
+        case MELEE_HIT_DODGE:
+            damageInfo->TargetState  = VICTIMSTATE_DODGE;
+            damageInfo->procEx      |= PROC_EX_DODGE;
+            damageInfo->cleanDamage += damageInfo->damage;
+            damageInfo->damage = 0;
+            break;
+        case MELEE_HIT_BLOCK:
+            damageInfo->TargetState = VICTIMSTATE_HIT;
+            damageInfo->HitInfo    |= HITINFO_BLOCK;
+            damageInfo->procEx     |= PROC_EX_BLOCK | PROC_EX_NORMAL_HIT;
+            // 30% damage blocked, double blocked amount if block is critical
+            damageInfo->blocked_amount = CalculatePct(damageInfo->damage, damageInfo->target->isBlockCritical() ? damageInfo->target->GetBlockPercent() * 2 : damageInfo->target->GetBlockPercent());
+            damageInfo->damage      -= damageInfo->blocked_amount;
+            damageInfo->cleanDamage += damageInfo->blocked_amount;
+            break;
+        case MELEE_HIT_GLANCING:
+        {
+            damageInfo->HitInfo     |= HITINFO_GLANCING;
+            damageInfo->TargetState  = VICTIMSTATE_HIT;
+            damageInfo->procEx      |= PROC_EX_NORMAL_HIT;
+            int32 leveldif = int32(victim->getLevel()) - int32(getLevel());
+            if (leveldif > 3)
+                leveldif = 3;
+            float reducePercent = 1 - leveldif * 0.1f;
+            damageInfo->cleanDamage += damageInfo->damage - uint32(reducePercent * damageInfo->damage);
+            damageInfo->damage = uint32(reducePercent * damageInfo->damage);
+            break;
+        }
+        case MELEE_HIT_CRUSHING:
+            damageInfo->HitInfo     |= HITINFO_CRUSHING;
+            damageInfo->TargetState  = VICTIMSTATE_HIT;
+            damageInfo->procEx      |= PROC_EX_NORMAL_HIT;
+            // 150% normal damage
+            damageInfo->damage += (damageInfo->damage / 2);
+            break;
+        default:
+            break;
+    }
+
+    // Always apply HITINFO_AFFECTS_VICTIM in case its not a miss
+    if (!(damageInfo->HitInfo & HITINFO_MISS))
+        damageInfo->HitInfo |= HITINFO_AFFECTS_VICTIM;
+
+    int32 resilienceReduction = damageInfo->damage;
+    ApplyResilience(victim, &resilienceReduction, damageInfo->hitOutCome == MELEE_HIT_CRIT);
+    resilienceReduction = damageInfo->damage - resilienceReduction;
+    damageInfo->damage      -= resilienceReduction;
+    damageInfo->cleanDamage += resilienceReduction;
+
+    // Calculate absorb resist
+    if (int32(damageInfo->damage) > 0)
+    {
+        damageInfo->procVictim |= PROC_FLAG_TAKEN_DAMAGE;
+        // Calculate absorb & resists
+        CalcAbsorbResist(damageInfo->target, SpellSchoolMask(damageInfo->damageSchoolMask), DIRECT_DAMAGE, damageInfo->damage, &damageInfo->absorb, &damageInfo->resist);
+
+        if (damageInfo->absorb)
+        {
+            damageInfo->HitInfo |= (damageInfo->damage - damageInfo->absorb == 0 ? HITINFO_FULL_ABSORB : HITINFO_PARTIAL_ABSORB);
+            damageInfo->procEx  |= PROC_EX_ABSORB;
+        }
+
+        if (damageInfo->resist)
+            damageInfo->HitInfo |= (damageInfo->damage - damageInfo->resist == 0 ? HITINFO_FULL_RESIST : HITINFO_PARTIAL_RESIST);
+
+        damageInfo->damage -= damageInfo->absorb + damageInfo->resist;
+    }
+    else // Impossible get negative result but....
+        damageInfo->damage = 0;
+}
+
+void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
+{
+    Unit* victim = damageInfo->target;
+
+    if (!victim->isAlive() || victim->HasUnitState(UNIT_STATE_IN_FLIGHT) || (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode()))
+        return;
+
+    // Hmmmm dont like this emotes client must by self do all animations
+    if (damageInfo->HitInfo & HITINFO_CRITICALHIT)
+        victim->HandleEmoteCommand(EMOTE_ONESHOT_WOUND_CRITICAL);
+    if (damageInfo->blocked_amount && damageInfo->TargetState != VICTIMSTATE_BLOCKS)
+        victim->HandleEmoteCommand(EMOTE_ONESHOT_PARRY_SHIELD);
+
+    if (damageInfo->TargetState == VICTIMSTATE_PARRY)
+    {
+        // Get attack timers
+        float offtime  = float(victim->getAttackTimer(OFF_ATTACK));
+        float basetime = float(victim->getAttackTimer(BASE_ATTACK));
+        // Reduce attack time
+        if (victim->haveOffhandWeapon() && offtime < basetime)
+        {
+            float percent20 = victim->GetAttackTime(OFF_ATTACK) * 0.20f;
+            float percent60 = 3.0f * percent20;
+            if (offtime > percent20 && offtime <= percent60)
+                victim->setAttackTimer(OFF_ATTACK, uint32(percent20));
+            else if (offtime > percent60)
+            {
+                offtime -= 2.0f * percent20;
+                victim->setAttackTimer(OFF_ATTACK, uint32(offtime));
+            }
+        }
+        else
+        {
+            float percent20 = victim->GetAttackTime(BASE_ATTACK) * 0.20f;
+            float percent60 = 3.0f * percent20;
+            if (basetime > percent20 && basetime <= percent60)
+                victim->setAttackTimer(BASE_ATTACK, uint32(percent20));
+            else if (basetime > percent60)
+            {
+                basetime -= 2.0f * percent20;
+                victim->setAttackTimer(BASE_ATTACK, uint32(basetime));
+            }
+        }
+    }
+
+    // Call default DealDamage
+    CleanDamage cleanDamage(damageInfo->cleanDamage, damageInfo->absorb, damageInfo->attackType, damageInfo->hitOutCome);
+    DealDamage(victim, damageInfo->damage, &cleanDamage, DIRECT_DAMAGE, SpellSchoolMask(damageInfo->damageSchoolMask), NULL, durabilityLoss);
+
+    // If this is a creature and it attacks from behind it has a probability to daze it's victim
+    if ((damageInfo->hitOutCome == MELEE_HIT_CRIT || damageInfo->hitOutCome == MELEE_HIT_CRUSHING || damageInfo->hitOutCome == MELEE_HIT_NORMAL || damageInfo->hitOutCome == MELEE_HIT_GLANCING) &&
+        GetTypeId() != TYPEID_PLAYER && !ToCreature()->IsControlledByPlayer() && !victim->HasInArc(M_PI, this)
+        && (victim->GetTypeId() == TYPEID_PLAYER || !victim->ToCreature()->isWorldBoss())&& !victim->IsVehicle())
+    {
+        // -probability is between 0% and 40%
+        // 20% base chance
+        float Probability = 20.0f;
+
+        // there is a newbie protection, at level 10 just 7% base chance; assuming linear function
+        if (victim->getLevel() < 30)
+            Probability = 0.65f * victim->getLevel() + 0.5f;
+
+        uint32 VictimDefense = victim->GetMaxSkillValueForLevel(this);
+        uint32 AttackerMeleeSkill = GetMaxSkillValueForLevel();
+
+        Probability *= AttackerMeleeSkill/(float)VictimDefense*0.16;
+
+        if (Probability < 0)
+            Probability = 0;
+
+        if (Probability > 40.0f)
+            Probability = 40.0f;
+
+        if (roll_chance_f(Probability))
+            CastSpell(victim, 1604, true);
+    }
+
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->CastItemCombatSpell(victim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
+
+    // Do effect if any damage done to target
+    if (damageInfo->damage)
+    {
+        // We're going to call functions which can modify content of the list during iteration over it's elements
+        // Let's copy the list so we can prevent iterator invalidation
+        AuraEffectList vDamageShieldsCopy(victim->GetAuraEffectsByType(SPELL_AURA_DAMAGE_SHIELD));
+        for (AuraEffectList::const_iterator dmgShieldItr = vDamageShieldsCopy.begin(); dmgShieldItr != vDamageShieldsCopy.end(); ++dmgShieldItr)
+        {
+            SpellInfo const* i_spellProto = (*dmgShieldItr)->GetSpellInfo();
+            // Damage shield can be resisted...
+            if (SpellMissInfo missInfo = victim->SpellHitResult(this, i_spellProto, false))
+            {
+                victim->SendSpellMiss(this, i_spellProto->Id, missInfo);
+                continue;
+            }
+
+            // ...or immuned
+            if (IsImmunedToDamage(i_spellProto))
+            {
+                victim->SendSpellDamageImmune(this, i_spellProto->Id);
+                continue;
+            }
+
+            uint32 damage = (*dmgShieldItr)->GetAmount();
+
+            if (Unit* caster = (*dmgShieldItr)->GetCaster())
+            {
+                damage = caster->SpellDamageBonusDone(this, i_spellProto, damage, SPELL_DIRECT_DAMAGE);
+                damage = SpellDamageBonusTaken(i_spellProto, damage, SPELL_DIRECT_DAMAGE, 1, caster->GetGUID());
+            }
+
+            // No Unit::CalcAbsorbResist here - opcode doesn't send that data - this damage is probably not affected by that
+            victim->DealDamageMods(this, damage, NULL);
+
+            // TODO: Move this to a packet handler
+            WorldPacket data(SMSG_SPELLDAMAGESHIELD, 8 + 8 + 4 + 4 + 4 + 4 + 4);
+            data << uint64(victim->GetGUID());
+            data << uint64(GetGUID());
+            data << uint32(i_spellProto->Id);
+            data << uint32(damage);                  // Damage
+            int32 overkill = int32(damage) - int32(GetHealth());
+            data << uint32(overkill > 0 ? overkill : 0); // Overkill
+            data << uint32(i_spellProto->SchoolMask);
+            data << uint32(0); // FIX ME: Send resisted damage, both fully resisted and partly resisted
+            victim->SendMessageToSet(&data, true);
+
+            victim->DealDamage(this, damage, 0, SPELL_DIRECT_DAMAGE, i_spellProto->GetSchoolMask(), i_spellProto, true);
+        }
+    }
+}
+
+void Unit::HandleEmoteState(uint32 emote_id)
+{
+    SetUInt32Value(UNIT_NPC_EMOTESTATE, emote_id);
+}
+
+void Unit::HandleEmote(uint32 emote_id)
+{
+    if (!emote_id)
+        HandleEmoteState(EMOTE_ONESHOT_NONE);
+    else if (EmotesEntry const* emoteEntry = sEmotesStore.LookupEntry(emote_id))
+    {
+        if (emoteEntry->EmoteType) // 1,2 states, 0 command
+            HandleEmoteState(emote_id);
+        else
+            HandleEmoteCommand(emote_id);
+    }
+}
+
+void Unit::HandleEmoteCommand(uint32 anim_id)
+{
+    EmotesEntry const* emote = sEmotesStore.LookupEntry(anim_id);
+
+    if (!emote)
+        return;
+
+    if(GetTypeId() == TYPEID_PLAYER)
+    {
+        if (emote->EmoteType != 0)
+            SetUInt32Value(UNIT_NPC_EMOTESTATE, anim_id);
+        else
+            SetUInt32Value(UNIT_NPC_EMOTESTATE, 0);
+    }
+
+    WorldPacket data(SMSG_EMOTE, 4 + 8);
+    data << uint32(anim_id);
+    data << uint64(GetGUID());
+    SendMessageToSet(&data, true);
+}
+
+bool Unit::IsDamageReducedByArmor(SpellSchoolMask schoolMask, SpellInfo const* spellInfo, uint8 effIndex)
+{
+    // only physical spells damage gets reduced by armor
+    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
+        return false;
+    if (spellInfo)
+    {
+        // Rake
+        if (spellInfo->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE) && spellInfo->Mechanic == MECHANIC_BLEED)
+            return false;
+
+        // there are spells with no specific attribute but they have "ignores armor" in tooltip
+        if (spellInfo->AttributesCu & SPELL_ATTR0_CU_IGNORE_ARMOR)
+            return false;
+
+        // bleeding effects are not reduced by armor
+        if (effIndex != MAX_SPELL_EFFECTS)
+        {
+            if (spellInfo->Effects[effIndex].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE ||
+                spellInfo->Effects[effIndex].Effect == SPELL_EFFECT_SCHOOL_DAMAGE)
+                if (spellInfo->GetEffectMechanicMask(effIndex) & (1<<MECHANIC_BLEED))
+                    return false;
+        }
+    }
+    return true;
+}
+
+uint32 Unit::CalcArmorReducedDamage(Unit* victim, const uint32 damage, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/)
+{
+    uint32 newdamage = 0;
+    float armor = float(victim->GetArmor());
+
+    // bypass enemy armor by SPELL_AURA_BYPASS_ARMOR_FOR_CASTER
+    int32 armorBypassPct = 0;
+    AuraEffectList const & reductionAuras = victim->GetAuraEffectsByType(SPELL_AURA_BYPASS_ARMOR_FOR_CASTER);
+    for (AuraEffectList::const_iterator i = reductionAuras.begin(); i != reductionAuras.end(); ++i)
+        if ((*i)->GetCasterGUID() == GetGUID())
+            armorBypassPct += (*i)->GetAmount();
+    armor = CalculatePct(armor, 100 - std::min(armorBypassPct, 100));
+
+    // Ignore enemy armor by SPELL_AURA_MOD_TARGET_RESISTANCE aura
+    armor += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, SPELL_SCHOOL_MASK_NORMAL);
+
+    if (spellInfo)
+        if (Player* modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_IGNORE_ARMOR, armor);
+
+    AuraEffectList const& ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
+    for (AuraEffectList::const_iterator j = ResIgnoreAuras.begin(); j != ResIgnoreAuras.end(); ++j)
+    {
+        if ((*j)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
+            armor = floor(AddPct(armor, -(*j)->GetAmount()));
+    }
+
+    // Apply Player CR_ARMOR_PENETRATION rating
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        float maxArmorPen = 0;
+        if (victim->getLevel() < 60)
+            maxArmorPen = float(400 + 85 * victim->getLevel());
+        else
+            maxArmorPen = 400 + 85 * victim->getLevel() + 4.5f * 85 * (victim->getLevel() - 59);
+
+        // Cap armor penetration to this number
+        maxArmorPen = std::min((armor + maxArmorPen) / 3, armor);
+        // Figure out how much armor do we ignore
+        float armorPen = CalculatePct(maxArmorPen, ToPlayer()->GetRatingBonusValue(CR_ARMOR_PENETRATION));
+        // Got the value, apply it
+        armor -= std::min(armorPen, maxArmorPen);
+    }
+
+    if (armor < 0.0f)
+        armor = 0.0f;
+
+    float levelModifier = getLevel();
+    if (levelModifier > 80)
+        levelModifier = levelModifier + (4.5f * (levelModifier - 59)) + (20.0f * (levelModifier - 80));
+    else if (levelModifier > 59)
+        levelModifier = levelModifier + (4.5f * (levelModifier - 59));
+
+    float tmpvalue = 0.1f * armor / (8.5f * levelModifier + 40.0f);
+    tmpvalue = tmpvalue / (1.0f + tmpvalue);
+
+    if (tmpvalue < 0.0f)
+        tmpvalue = 0.0f;
+    if (tmpvalue > 0.75f)
+        tmpvalue = 0.75f;
+
+    newdamage = uint32(damage - (damage * tmpvalue));
+
+    return (newdamage > 1) ? newdamage : 1;
+}
+
+void Unit::CalcAbsorbResist(Unit* victim, SpellSchoolMask schoolMask, DamageEffectType damagetype, uint32 const damage, uint32 *absorb, uint32 *resist, SpellInfo const* spellInfo)
+{
+    if (!victim || !victim->isAlive() || !damage)
+        return;
+
+    DamageInfo dmgInfo = DamageInfo(this, victim, damage, spellInfo, schoolMask, damagetype);
+
+    // Magic damage, check for resists
+    // Ignore spells that cant be resisted
+    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0 && (!spellInfo || (spellInfo->AttributesEx4 & SPELL_ATTR4_IGNORE_RESISTANCES) == 0))
+    {
+        float victimResistance = float(victim->GetResistance(schoolMask));
+        victimResistance += float(GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, schoolMask));
+
+        if (Player* player = ToPlayer())
+            victimResistance -= float(player->GetSpellPenetrationItemMod());
+
+        // Resistance can't be lower then 0.
+        if (victimResistance < 0.0f)
+            victimResistance = 0.0f;
+
+        static uint32 const BOSS_LEVEL = 83;
+        static float const BOSS_RESISTANCE_CONSTANT = 510.0f;
+        uint32 level = victim->getLevel();
+        float resistanceConstant = 0.0f;
+
+        if (level == BOSS_LEVEL)
+            resistanceConstant = BOSS_RESISTANCE_CONSTANT;
+        else
+            resistanceConstant = level * 5.0f;
+
+        float averageResist = victimResistance / (victimResistance + resistanceConstant);
+        float discreteResistProbability[11];
+        for (uint32 i = 0; i < 11; ++i)
+        {
+            discreteResistProbability[i] = 0.5f - 2.5f * fabs(0.1f * i - averageResist);
+            if (discreteResistProbability[i] < 0.0f)
+                discreteResistProbability[i] = 0.0f;
+        }
+
+        if (averageResist <= 0.1f)
+        {
+            discreteResistProbability[0] = 1.0f - 7.5f * averageResist;
+            discreteResistProbability[1] = 5.0f * averageResist;
+            discreteResistProbability[2] = 2.5f * averageResist;
+        }
+
+        float r = float(rand_norm());
+        uint32 i = 0;
+        float probabilitySum = discreteResistProbability[0];
+
+        while (r >= probabilitySum && i < 10)
+            probabilitySum += discreteResistProbability[++i];
+
+        float damageResisted = float(damage * i / 10);
+
+        AuraEffectList const& ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
+        for (AuraEffectList::const_iterator j = ResIgnoreAuras.begin(); j != ResIgnoreAuras.end(); ++j)
+            if ((*j)->GetMiscValue() & schoolMask)
+                AddPct(damageResisted, -(*j)->GetAmount());
+
+        dmgInfo.ResistDamage(uint32(damageResisted));
+    }
+
+    // Ignore Absorption Auras
+    float auraAbsorbMod = 0;
+    AuraEffectList const& AbsIgnoreAurasA = GetAuraEffectsByType(SPELL_AURA_MOD_TARGET_ABSORB_SCHOOL);
+    for (AuraEffectList::const_iterator itr = AbsIgnoreAurasA.begin(); itr != AbsIgnoreAurasA.end(); ++itr)
+    {
+        if (!((*itr)->GetMiscValue() & schoolMask))
+            continue;
+
+        if ((*itr)->GetAmount() > auraAbsorbMod)
+            auraAbsorbMod = float((*itr)->GetAmount());
+    }
+
+    AuraEffectList const& AbsIgnoreAurasB = GetAuraEffectsByType(SPELL_AURA_MOD_TARGET_ABILITY_ABSORB_SCHOOL);
+    for (AuraEffectList::const_iterator itr = AbsIgnoreAurasB.begin(); itr != AbsIgnoreAurasB.end(); ++itr)
+    {
+        if (!((*itr)->GetMiscValue() & schoolMask))
+            continue;
+
+        if (((*itr)->GetAmount() > auraAbsorbMod) && (*itr)->IsAffectingSpell(spellInfo))
+            auraAbsorbMod = float((*itr)->GetAmount());
+    }
+    RoundToInterval(auraAbsorbMod, 0.0f, 100.0f);
+
+    // We're going to call functions which can modify content of the list during iteration over it's elements
+    // Let's copy the list so we can prevent iterator invalidation
+    AuraEffectList vSchoolAbsorbCopy(victim->GetAuraEffectsByType(SPELL_AURA_SCHOOL_ABSORB));
+    vSchoolAbsorbCopy.sort(Trinity::AbsorbAuraOrderPred());
+
+    // absorb without mana cost
+    for (AuraEffectList::iterator itr = vSchoolAbsorbCopy.begin(); (itr != vSchoolAbsorbCopy.end()) && (dmgInfo.GetDamage() > 0); ++itr)
+    {
+        AuraEffect* absorbAurEff = *itr;
+        // Check if aura was removed during iteration - we don't need to work on such auras
+        AuraApplication const* aurApp = absorbAurEff->GetBase()->GetApplicationOfTarget(victim->GetGUID());
+        if (!aurApp)
+            continue;
+        if (!(absorbAurEff->GetMiscValue() & schoolMask))
+            continue;
+
+        // get amount which can be still absorbed by the aura
+        int32 currentAbsorb = absorbAurEff->GetAmount();
+        // aura with infinite absorb amount - let the scripts handle absorbtion amount, set here to 0 for safety
+        if (currentAbsorb < 0)
+            currentAbsorb = 0;
+
+        // Apply absorb mod auras
+        AddPct(currentAbsorb, -auraAbsorbMod);
+
+        uint32 tempAbsorb = uint32(currentAbsorb);
+
+        bool defaultPrevented = false;
+
+        absorbAurEff->GetBase()->CallScriptEffectAbsorbHandlers(absorbAurEff, aurApp, dmgInfo, tempAbsorb, defaultPrevented);
+        currentAbsorb = tempAbsorb;
+
+        if (defaultPrevented)
+            continue;
+
+        // absorb must be smaller than the damage itself
+        currentAbsorb = RoundToInterval(currentAbsorb, 0, int32(dmgInfo.GetDamage()));
+
+        dmgInfo.AbsorbDamage(currentAbsorb);
+
+        tempAbsorb = currentAbsorb;
+        absorbAurEff->GetBase()->CallScriptEffectAfterAbsorbHandlers(absorbAurEff, aurApp, dmgInfo, tempAbsorb);
+
+        // Check if our aura is using amount to count damage
+        if (absorbAurEff->GetAmount() >= 0)
+        {
+            // Reduce shield amount
+            absorbAurEff->SetAmount(absorbAurEff->GetAmount() - currentAbsorb);
+            // Aura cannot absorb anything more - remove it
+            if (absorbAurEff->GetAmount() <= 0)
+                absorbAurEff->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
+        }
+    }
+
+    // absorb by mana cost
+    AuraEffectList vManaShieldCopy(victim->GetAuraEffectsByType(SPELL_AURA_MANA_SHIELD));
+    for (AuraEffectList::const_iterator itr = vManaShieldCopy.begin(); (itr != vManaShieldCopy.end()) && (dmgInfo.GetDamage() > 0); ++itr)
+    {
+        AuraEffect* absorbAurEff = *itr;
+        // Check if aura was removed during iteration - we don't need to work on such auras
+        AuraApplication const* aurApp = absorbAurEff->GetBase()->GetApplicationOfTarget(victim->GetGUID());
+        if (!aurApp)
+            continue;
+        // check damage school mask
+        if (!(absorbAurEff->GetMiscValue() & schoolMask))
+            continue;
+
+        // get amount which can be still absorbed by the aura
+        int32 currentAbsorb = absorbAurEff->GetAmount();
+        // aura with infinite absorb amount - let the scripts handle absorbtion amount, set here to 0 for safety
+        if (currentAbsorb < 0)
+            currentAbsorb = 0;
+
+        uint32 tempAbsorb = currentAbsorb;
+
+        bool defaultPrevented = false;
+
+        absorbAurEff->GetBase()->CallScriptEffectManaShieldHandlers(absorbAurEff, aurApp, dmgInfo, tempAbsorb, defaultPrevented);
+        currentAbsorb = tempAbsorb;
+
+        if (defaultPrevented)
+            continue;
+
+        AddPct(currentAbsorb, -auraAbsorbMod);
+
+        // absorb must be smaller than the damage itself
+        currentAbsorb = RoundToInterval(currentAbsorb, 0, int32(dmgInfo.GetDamage()));
+
+        int32 manaReduction = currentAbsorb;
+
+        // lower absorb amount by talents
+        if (float manaMultiplier = absorbAurEff->GetSpellInfo()->Effects[absorbAurEff->GetEffIndex()].CalcValueMultiplier(absorbAurEff->GetCaster()))
+            manaReduction = int32(float(manaReduction) * manaMultiplier);
+
+        int32 manaTaken = -victim->ModifyPower(POWER_MANA, -manaReduction);
+
+        // take case when mana has ended up into account
+        currentAbsorb = currentAbsorb ? int32(float(currentAbsorb) * (float(manaTaken) / float(manaReduction))) : 0;
+
+        dmgInfo.AbsorbDamage(currentAbsorb);
+
+        tempAbsorb = currentAbsorb;
+        absorbAurEff->GetBase()->CallScriptEffectAfterManaShieldHandlers(absorbAurEff, aurApp, dmgInfo, tempAbsorb);
+
+        // Check if our aura is using amount to count damage
+        if (absorbAurEff->GetAmount() >= 0)
+        {
+            absorbAurEff->SetAmount(absorbAurEff->GetAmount() - currentAbsorb);
+            if ((absorbAurEff->GetAmount() <= 0))
+                absorbAurEff->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
+        }
+    }
+
+    // split damage auras - only when not damaging self
+    if (victim != this)
+    {
+        // We're going to call functions which can modify content of the list during iteration over it's elements
+        // Let's copy the list so we can prevent iterator invalidation
+        AuraEffectList vSplitDamagePctCopy(victim->GetAuraEffectsByType(SPELL_AURA_SPLIT_DAMAGE_PCT));
+        for (AuraEffectList::iterator itr = vSplitDamagePctCopy.begin(), next; (itr != vSplitDamagePctCopy.end()) &&  (dmgInfo.GetDamage() > 0); ++itr)
+        {
+            // Check if aura was removed during iteration - we don't need to work on such auras
+            AuraApplication const* aurApp = (*itr)->GetBase()->GetApplicationOfTarget(victim->GetGUID());
+            if (!aurApp)
+                continue;
+
+            // check damage school mask
+            if (!((*itr)->GetMiscValue() & schoolMask))
+                continue;
+
+            // Damage can be splitted only if aura has an alive caster
+            Unit* caster = (*itr)->GetCaster();
+            if (!caster || (caster == victim) || !caster->IsInWorld() || !caster->isAlive())
+                continue;
+
+            uint32 splitDamage = CalculatePct(dmgInfo.GetDamage(), (*itr)->GetAmount());
+
+            (*itr)->GetBase()->CallScriptEffectSplitHandlers((*itr), aurApp, dmgInfo, splitDamage);
+
+            // absorb must be smaller than the damage itself
+            splitDamage = RoundToInterval(splitDamage, uint32(0), uint32(dmgInfo.GetDamage()));
+
+            dmgInfo.AbsorbDamage(splitDamage);
+            uint32 splitted = splitDamage;
+            uint32 split_absorb = 0;
+            DealDamageMods(caster, splitted, &split_absorb);
+
+            SendSpellNonMeleeDamageLog(caster, (*itr)->GetSpellInfo()->Id, splitted, schoolMask, split_absorb, 0, false, 0, false);
+
+            CleanDamage cleanDamage = CleanDamage(splitted, 0, BASE_ATTACK, MELEE_HIT_NORMAL);
+            DealDamage(caster, splitted, &cleanDamage, DIRECT_DAMAGE, schoolMask, (*itr)->GetSpellInfo(), false, true);
+        }
+    }
+
+    *resist = dmgInfo.GetResist();
+    *absorb = dmgInfo.GetAbsorb();
+}
+
+void Unit::CalcHealAbsorb(Unit* victim, const SpellInfo* healSpell, uint32 &healAmount, uint32 &absorb)
+{
+    if (!healAmount)
+        return;
+
+    int32 RemainingHeal = healAmount;
+
+    // Need remove expired auras after
+    bool existExpired = false;
+
+    // absorb without mana cost
+    AuraEffectList const& vHealAbsorb = victim->GetAuraEffectsByType(SPELL_AURA_SCHOOL_HEAL_ABSORB);
+    for (AuraEffectList::const_iterator i = vHealAbsorb.begin(); i != vHealAbsorb.end() && RemainingHeal > 0; ++i)
+    {
+        if (!((*i)->GetMiscValue() & healSpell->SchoolMask))
+            continue;
+
+        // Max Amount can be absorbed by this aura
+        int32 currentAbsorb = (*i)->GetAmount();
+
+        // Found empty aura (impossible but..)
+        if (currentAbsorb <= 0)
+        {
+            existExpired = true;
+            continue;
+        }
+
+        // currentAbsorb - damage can be absorbed by shield
+        // If need absorb less damage
+        if (RemainingHeal < currentAbsorb)
+            currentAbsorb = RemainingHeal;
+
+        RemainingHeal -= currentAbsorb;
+
+        // Reduce shield amount
+        (*i)->SetAmount((*i)->GetAmount() - currentAbsorb);
+        // Need remove it later
+        if ((*i)->GetAmount() <= 0)
+            existExpired = true;
+    }
+
+    // Remove all expired absorb auras
+    if (existExpired)
+    {
+        for (AuraEffectList::const_iterator i = vHealAbsorb.begin(); i != vHealAbsorb.end();)
+        {
+            AuraEffect* auraEff = *i;
+            ++i;
+            if (auraEff->GetAmount() <= 0)
+            {
+                uint32 removedAuras = victim->m_removedAurasCount;
+                auraEff->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
+                if (removedAuras+1 < victim->m_removedAurasCount)
+                    i = vHealAbsorb.begin();
+            }
+        }
+    }
+
+    absorb = RemainingHeal > 0 ? (healAmount - RemainingHeal) : healAmount;
+    healAmount = RemainingHeal;
+}
+
+void Unit::AttackerStateUpdate (Unit* victim, WeaponAttackType attType, bool extra)
+{
+    if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
+        return;
+
+    if (victim == NULL)
+        return;
+
+    if (!victim->isAlive())
+        return;
+
+    if ((attType == BASE_ATTACK || attType == OFF_ATTACK) && !IsWithinLOSInMap(victim))
+        return;
+
+    CombatStart(victim);
+    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);
+
+    if (attType != BASE_ATTACK && attType != OFF_ATTACK)
+        return;                                             // ignore ranged case
+
+    // melee attack spell casted at main hand attack only - no normal melee dmg dealt
+    if (attType == BASE_ATTACK && m_currentSpells[CURRENT_MELEE_SPELL] && !extra)
+        m_currentSpells[CURRENT_MELEE_SPELL]->cast();
+    else
+    {
+        // attack can be redirected to another target
+        victim = GetMeleeHitRedirectTarget(victim);
+
+        CalcDamageInfo damageInfo;
+        CalculateMeleeDamage(victim, 0, &damageInfo, attType);
+        // Send log damage message to client
+        DealDamageMods(victim, damageInfo.damage, &damageInfo.absorb);
+        SendAttackStateUpdate(&damageInfo);
+
+        //TriggerAurasProcOnEvent(damageInfo);
+        ProcDamageAndSpell(damageInfo.target, damageInfo.procAttacker, damageInfo.procVictim, damageInfo.procEx, damageInfo.damage, damageInfo.absorb, damageInfo.attackType);
+
+        DealMeleeDamage(&damageInfo, true);
+
+        if (GetTypeId() == TYPEID_PLAYER)
+            sLog->outDebug(LOG_FILTER_UNITS, "AttackerStateUpdate: (Player) %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
+                GetGUIDLow(), victim->GetGUIDLow(), victim->GetTypeId(), damageInfo.damage, damageInfo.absorb, damageInfo.blocked_amount, damageInfo.resist);
+        else
+            sLog->outDebug(LOG_FILTER_UNITS, "AttackerStateUpdate: (NPC)    %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
+                GetGUIDLow(), victim->GetGUIDLow(), victim->GetTypeId(), damageInfo.damage, damageInfo.absorb, damageInfo.blocked_amount, damageInfo.resist);
+    }
+}
+
+void Unit::HandleProcExtraAttackFor(Unit* victim)
+{
+    while (m_extraAttacks)
+    {
+        AttackerStateUpdate(victim, BASE_ATTACK, true);
+        --m_extraAttacks;
+    }
+}
+
+MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(const Unit* victim, WeaponAttackType attType) const
+{
+    // This is only wrapper
+
+    // Miss chance based on melee
+    //float miss_chance = MeleeMissChanceCalc(victim, attType);
+    float miss_chance = MeleeSpellMissChance(victim, attType, 0);
+
+    // Critical hit chance
+    float crit_chance = GetUnitCriticalChance(attType, victim);
+
+    // stunned target cannot dodge and this is check in GetUnitDodgeChance() (returned 0 in this case)
+    float dodge_chance = victim->GetUnitDodgeChance();
+    float block_chance = victim->GetUnitBlockChance();
+    float parry_chance = victim->GetUnitParryChance();
+
+    // Useful if want to specify crit & miss chances for melee, else it could be removed
+    sLog->outDebug(LOG_FILTER_UNITS, "MELEE OUTCOME: miss %f crit %f dodge %f parry %f block %f", miss_chance, crit_chance, dodge_chance, parry_chance, block_chance);
+
+    return RollMeleeOutcomeAgainst(victim, attType, int32(crit_chance*100), int32(miss_chance*100), int32(dodge_chance*100), int32(parry_chance*100), int32(block_chance*100));
+}
+
+MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackType attType, int32 crit_chance, int32 miss_chance, int32 dodge_chance, int32 parry_chance, int32 block_chance) const
+{
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode())
+        return MELEE_HIT_EVADE;
+
+    int32 attackerMaxSkillValueForLevel = GetMaxSkillValueForLevel(victim);
+    int32 victimMaxSkillValueForLevel = victim->GetMaxSkillValueForLevel(this);
+
+    // bonus from skills is 0.04%
+    int32    skillBonus  = 4 * (attackerMaxSkillValueForLevel - victimMaxSkillValueForLevel);
+    int32    sum = 0, tmp = 0;
+    int32    roll = urand (0, 10000);
+
+    sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: skill bonus of %d for attacker", skillBonus);
+    sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: rolled %d, miss %d, dodge %d, parry %d, block %d, crit %d",
+        roll, miss_chance, dodge_chance, parry_chance, block_chance, crit_chance);
+
+    tmp = miss_chance;
+
+    if (tmp > 0 && roll < (sum += tmp))
+    {
+        sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: MISS");
+        return MELEE_HIT_MISS;
+    }
+
+    // always crit against a sitting target (except 0 crit chance)
+    if (victim->GetTypeId() == TYPEID_PLAYER && crit_chance > 0 && !victim->IsStandState())
+    {
+        sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: CRIT (sitting victim)");
+        return MELEE_HIT_CRIT;
+    }
+
+    // Dodge chance
+
+    // only players can't dodge if attacker is behind
+    if (victim->GetTypeId() == TYPEID_PLAYER && !victim->HasInArc(M_PI, this) && !victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    {
+        sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: attack came from behind and victim was a player.");
+    }
+    else
+    {
+        // Reduce dodge chance by attacker expertise rating
+        if (GetTypeId() == TYPEID_PLAYER)
+            dodge_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);
+        else
+            dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+
+        // Modify dodge chance by attacker SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
+        dodge_chance+= GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE) * 100;
+        dodge_chance = int32 (float (dodge_chance) * GetTotalAuraMultiplier(SPELL_AURA_MOD_ENEMY_DODGE));
+
+        tmp = dodge_chance;
+        if ((tmp > 0)                                        // check if unit _can_ dodge
+            && ((tmp -= skillBonus) > 0)
+            && roll < (sum += tmp))
+        {
+            sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: DODGE <%d, %d)", sum-tmp, sum);
+            return MELEE_HIT_DODGE;
+        }
+    }
+
+    // parry & block chances
+
+    // check if attack comes from behind, nobody can parry or block if attacker is behind
+    if (!victim->HasInArc(M_PI, this) && !victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+        sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: attack came from behind.");
+    else
+    {
+        // Reduce parry chance by attacker expertise rating
+        if (GetTypeId() == TYPEID_PLAYER)
+            parry_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);
+        else
+            parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+
+        if (victim->GetTypeId() == TYPEID_PLAYER || !(victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_PARRY))
+        {
+            int32 tmp2 = int32(parry_chance);
+            if (tmp2 > 0                                         // check if unit _can_ parry
+                && (tmp2 -= skillBonus) > 0
+                && roll < (sum += tmp2))
+            {
+                sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: PARRY <%d, %d)", sum-tmp2, sum);
+                return MELEE_HIT_PARRY;
+            }
+        }
+
+        if (victim->GetTypeId() == TYPEID_PLAYER || !(victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+        {
+            tmp = block_chance;
+            if (tmp > 0                                          // check if unit _can_ block
+                && (tmp -= skillBonus) > 0
+                && roll < (sum += tmp))
+            {
+                sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: BLOCK <%d, %d)", sum-tmp, sum);
+                return MELEE_HIT_BLOCK;
+            }
+        }
+    }
+
+    // Critical chance
+    tmp = crit_chance;
+
+    if (tmp > 0 && roll < (sum += tmp))
+    {
+        sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: CRIT <%d, %d)", sum-tmp, sum);
+        if (GetTypeId() == TYPEID_UNIT && (ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_CRIT))
+            sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: CRIT DISABLED)");
+        else
+            return MELEE_HIT_CRIT;
+    }
+
+    // Max 40% chance to score a glancing blow against mobs that are higher level (can do only players and pets and not with ranged weapon)
+    if (attType != RANGED_ATTACK &&
+        (GetTypeId() == TYPEID_PLAYER || ToCreature()->isPet()) &&
+        victim->GetTypeId() != TYPEID_PLAYER && !victim->ToCreature()->isPet() &&
+        getLevel() < victim->getLevelForTarget(this))
+    {
+        // cap possible value (with bonuses > max skill)
+        int32 skill = attackerMaxSkillValueForLevel;
+
+        tmp = (10 + (victimMaxSkillValueForLevel - skill)) * 100;
+        tmp = tmp > 4000 ? 4000 : tmp;
+        if (roll < (sum += tmp))
+        {
+            sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: GLANCING <%d, %d)", sum-4000, sum);
+            return MELEE_HIT_GLANCING;
+        }
+    }
+
+    // mobs can score crushing blows if they're 4 or more levels above victim
+    if (getLevelForTarget(victim) >= victim->getLevelForTarget(this) + 4 &&
+        // can be from by creature (if can) or from controlled player that considered as creature
+        !IsControlledByPlayer() &&
+        !(GetTypeId() == TYPEID_UNIT && ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_CRUSH))
+    {
+        // when their weapon skill is 15 or more above victim's defense skill
+        tmp = victimMaxSkillValueForLevel;
+        // tmp = mob's level * 5 - player's current defense skill
+        tmp = attackerMaxSkillValueForLevel - tmp;
+        if (tmp >= 15)
+        {
+            // add 2% chance per lacking skill point, min. is 15%
+            tmp = tmp * 200 - 1500;
+            if (roll < (sum += tmp))
+            {
+                sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: CRUSHING <%d, %d)", sum-tmp, sum);
+                return MELEE_HIT_CRUSHING;
+            }
+        }
+    }
+
+    sLog->outDebug(LOG_FILTER_UNITS, "RollMeleeOutcomeAgainst: NORMAL");
+    return MELEE_HIT_NORMAL;
+}
+
+uint32 Unit::CalculateDamage(WeaponAttackType attType, bool normalized, bool addTotalPct)
+{
+    float min_damage, max_damage;
+
+    if (GetTypeId() == TYPEID_PLAYER && (normalized || !addTotalPct))
+        ToPlayer()->CalculateMinMaxDamage(attType, normalized, addTotalPct, min_damage, max_damage);
+    else
+    {
+        switch (attType)
+        {
+            case RANGED_ATTACK:
+                min_damage = GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE);
+                max_damage = GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE);
+                break;
+            case BASE_ATTACK:
+                min_damage = GetFloatValue(UNIT_FIELD_MINDAMAGE);
+                max_damage = GetFloatValue(UNIT_FIELD_MAXDAMAGE);
+                break;
+            case OFF_ATTACK:
+                min_damage = GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE);
+                max_damage = GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE);
+                break;
+                // Just for good manner
+            default:
+                min_damage = 0.0f;
+                max_damage = 0.0f;
+                break;
+        }
+    }
+
+    if (min_damage > max_damage)
+        std::swap(min_damage, max_damage);
+
+    if (max_damage == 0.0f)
+        max_damage = 5.0f;
+
+    return urand((uint32)min_damage, (uint32)max_damage);
+}
+
+float Unit::CalculateLevelPenalty(SpellInfo const* spellProto) const
+{
+    if (spellProto->SpellLevel <= 0 || spellProto->SpellLevel >= spellProto->MaxLevel)
+        return 1.0f;
+
+    float LvlPenalty = 0.0f;
+
+    if (spellProto->SpellLevel < 20)
+        LvlPenalty = 20.0f - spellProto->SpellLevel * 3.75f;
+    float LvlFactor = (float(spellProto->SpellLevel) + 6.0f) / float(getLevel());
+    if (LvlFactor > 1.0f)
+        LvlFactor = 1.0f;
+
+    return AddPct(LvlFactor, -LvlPenalty);
+}
+
+void Unit::SendMeleeAttackStart(Unit* victim)
+{
+    WorldPacket data(SMSG_ATTACKSTART, 8 + 8);
+    data << uint64(GetGUID());
+    data << uint64(victim->GetGUID());
+    SendMessageToSet(&data, true);
+    sLog->outDebug(LOG_FILTER_UNITS, "WORLD: Sent SMSG_ATTACKSTART");
+}
+
+void Unit::SendMeleeAttackStop(Unit* victim)
+{
+    WorldPacket data(SMSG_ATTACKSTOP, (8+8+4));
+    data.append(GetPackGUID());
+    data.append(victim ? victim->GetPackGUID() : 0);
+    data << uint32(0);                                     //! Can also take the value 0x01, which seems related to updating rotation
+    SendMessageToSet(&data, true);
+    sLog->outDebug(LOG_FILTER_UNITS, "WORLD: Sent SMSG_ATTACKSTOP");
+
+    if (victim)
+        sLog->outInfo(LOG_FILTER_UNITS, "%s %u stopped attacking %s %u", (GetTypeId() == TYPEID_PLAYER ? "Player" : "Creature"), GetGUIDLow(), (victim->GetTypeId() == TYPEID_PLAYER ? "player" : "creature"), victim->GetGUIDLow());
+    else
+        sLog->outInfo(LOG_FILTER_UNITS, "%s %u stopped attacking", (GetTypeId() == TYPEID_PLAYER ? "Player" : "Creature"), GetGUIDLow());
+}
+
+bool Unit::isSpellBlocked(Unit* victim, SpellInfo const* spellProto, WeaponAttackType /*attackType*/)
+{
+    // These spells can't be blocked
+    if (spellProto && spellProto->Attributes & SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK)
+        return false;
+
+    if (victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION) || victim->HasInArc(M_PI, this))
+    {
+        // Check creatures flags_extra for disable block
+        if (victim->GetTypeId() == TYPEID_UNIT &&
+            victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                return false;
+
+        if (roll_chance_f(victim->GetUnitBlockChance()))
+            return true;
+    }
+    return false;
+}
+
+bool Unit::isBlockCritical()
+{
+    if (roll_chance_i(GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_CRIT_CHANCE)))
+        return true;
+    return false;
+}
+
+int32 Unit::GetMechanicResistChance(const SpellInfo* spell)
+{
+    if (!spell)
+        return 0;
+    int32 resist_mech = 0;
+    for (uint8 eff = 0; eff < MAX_SPELL_EFFECTS; ++eff)
+    {
+        if (!spell->Effects[eff].IsEffect())
+           break;
+        int32 effect_mech = spell->GetEffectMechanic(eff);
+        if (effect_mech)
+        {
+            int32 temp = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MECHANIC_RESISTANCE, effect_mech);
+            if (resist_mech < temp)
+                resist_mech = temp;
+        }
+    }
+    return resist_mech;
+}
+
+// Melee based spells hit result calculations
+SpellMissInfo Unit::MeleeSpellHitResult(Unit* victim, SpellInfo const* spell)
+{
+    // Spells with SPELL_ATTR3_IGNORE_HIT_RESULT will additionally fully ignore
+    // resist and deflect chances
+    if (spell->AttributesEx3 & SPELL_ATTR3_IGNORE_HIT_RESULT)
+        return SPELL_MISS_NONE;
+
+    WeaponAttackType attType = BASE_ATTACK;
+
+    // Check damage class instead of attack type to correctly handle judgements
+    // - they are meele, but can't be dodged/parried/deflected because of ranged dmg class
+    if (spell->DmgClass == SPELL_DAMAGE_CLASS_RANGED)
+        attType = RANGED_ATTACK;
+
+    uint32 roll = urand (0, 10000);
+
+    uint32 missChance = uint32(MeleeSpellMissChance(victim, attType, spell->Id) * 100.0f);
+    // Roll miss
+    uint32 tmp = missChance;
+    if (roll < tmp)
+        return SPELL_MISS_MISS;
+
+    // Chance resist mechanic (select max value from every mechanic spell effect)
+    int32 resist_mech = 0;
+    // Get effects mechanic and chance
+    for (uint8 eff = 0; eff < MAX_SPELL_EFFECTS; ++eff)
+    {
+        int32 effect_mech = spell->GetEffectMechanic(eff);
+        if (effect_mech)
+        {
+            int32 temp = victim->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MECHANIC_RESISTANCE, effect_mech);
+            if (resist_mech < temp*100)
+                resist_mech = temp*100;
+        }
+    }
+    // Roll chance
+    tmp += resist_mech;
+    if (roll < tmp)
+        return SPELL_MISS_RESIST;
+
+    bool canDodge = true;
+    bool canParry = true;
+    bool canBlock = spell->AttributesEx3 & SPELL_ATTR3_BLOCKABLE_SPELL;
+
+    // Same spells cannot be parry/dodge
+    if (spell->Attributes & SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK)
+        return SPELL_MISS_NONE;
+
+    // Chance resist mechanic
+    int32 resist_chance = victim->GetMechanicResistChance(spell) * 100;
+    tmp += resist_chance;
+    if (roll < tmp)
+        return SPELL_MISS_RESIST;
+
+    // Ranged attacks can only miss, resist and deflect
+    if (attType == RANGED_ATTACK)
+    {
+        canParry = false;
+        canDodge = false;
+
+        // only if in front
+        if (victim->HasInArc(M_PI, this) || victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+        {
+            int32 deflect_chance = victim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * 100;
+            tmp+=deflect_chance;
+            if (roll < tmp)
+                return SPELL_MISS_DEFLECT;
+        }
+        return SPELL_MISS_NONE;
+    }
+
+    // Check for attack from behind
+    if (!victim->HasInArc(M_PI, this))
+    {
+        if (!victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+        {
+            // Can`t dodge from behind in PvP (but its possible in PvE)
+            if (victim->GetTypeId() == TYPEID_PLAYER)
+                canDodge = false;
+            // Can`t parry or block
+            canParry = false;
+            canBlock = false;
+        }
+    }
+    // Check creatures flags_extra for disable parry
+    if (victim->GetTypeId() == TYPEID_UNIT)
+    {
+        uint32 flagEx = victim->ToCreature()->GetCreatureTemplate()->flags_extra;
+        if (flagEx & CREATURE_FLAG_EXTRA_NO_PARRY)
+            canParry = false;
+        // Check creatures flags_extra for disable block
+        if (flagEx & CREATURE_FLAG_EXTRA_NO_BLOCK)
+            canBlock = false;
+    }
+    // Ignore combat result aura
+    AuraEffectList const& ignore = GetAuraEffectsByType(SPELL_AURA_IGNORE_COMBAT_RESULT);
+    for (AuraEffectList::const_iterator i = ignore.begin(); i != ignore.end(); ++i)
+    {
+        if (!(*i)->IsAffectingSpell(spell))
+            continue;
+        switch ((*i)->GetMiscValue())
+        {
+            case MELEE_HIT_DODGE: canDodge = false; break;
+            case MELEE_HIT_BLOCK: canBlock = false; break;
+            case MELEE_HIT_PARRY: canParry = false; break;
+            default:
+                sLog->outDebug(LOG_FILTER_UNITS, "Spell %u SPELL_AURA_IGNORE_COMBAT_RESULT has unhandled state %d", (*i)->GetId(), (*i)->GetMiscValue());
+                break;
+        }
+    }
+
+    if (canDodge)
+    {
+        // Roll dodge
+        int32 dodgeChance = int32(victim->GetUnitDodgeChance() * 100.0f);
+        // Reduce enemy dodge chance by SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
+        dodgeChance += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE) * 100;
+        dodgeChance = int32(float(dodgeChance) * GetTotalAuraMultiplier(SPELL_AURA_MOD_ENEMY_DODGE));
+        // Reduce dodge chance by attacker expertise rating
+        if (GetTypeId() == TYPEID_PLAYER)
+            dodgeChance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100.0f);
+        else
+            dodgeChance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+        if (dodgeChance < 0)
+            dodgeChance = 0;
+
+        if (roll < (tmp += dodgeChance))
+            return SPELL_MISS_DODGE;
+    }
+
+    if (canParry)
+    {
+        // Roll parry
+        int32 parryChance = int32(victim->GetUnitParryChance() * 100.0f);
+        // Reduce parry chance by attacker expertise rating
+        if (GetTypeId() == TYPEID_PLAYER)
+            parryChance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100.0f);
+        else
+            parryChance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+        if (parryChance < 0)
+            parryChance = 0;
+
+        tmp += parryChance;
+        if (roll < tmp)
+            return SPELL_MISS_PARRY;
+    }
+
+    if (canBlock)
+    {
+        int32 blockChance = int32(victim->GetUnitBlockChance() * 100.0f);
+        if (blockChance < 0)
+            blockChance = 0;
+        tmp += blockChance;
+
+        if (roll < tmp)
+            return SPELL_MISS_BLOCK;
+    }
+
+    return SPELL_MISS_NONE;
+}
+
+// TODO need use unit spell resistances in calculations
+SpellMissInfo Unit::MagicSpellHitResult(Unit* victim, SpellInfo const* spell)
+{
+    // Can`t miss on dead target (on skinning for example)
+    if (!victim->isAlive() && victim->GetTypeId() != TYPEID_PLAYER)
+        return SPELL_MISS_NONE;
+
+    // All positive spells can`t miss
+    // Can't miss spells on yourself
+    if ((spell->IsPositive() && !IsHostileTo(victim)) || this == victim)
+        return SPELL_MISS_NONE;
+
+    if (spell->AttributesEx8 & SPELL_ATTR8_CANT_MISS || spell->AttributesEx3 & SPELL_ATTR3_IGNORE_HIT_RESULT)
+        return SPELL_MISS_NONE;
+
+    SpellSchoolMask schoolMask = spell->GetSchoolMask();
+    // PvP - PvE spell misschances per leveldif > 2
+    int32 lchance = victim->GetTypeId() == TYPEID_PLAYER ? 7 : 11;
+    int32 thisLevel = getLevelForTarget(victim);
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->isTrigger())
+        thisLevel = std::max<int32>(thisLevel, spell->SpellLevel);
+    int32 leveldif = int32(victim->getLevelForTarget(this)) - thisLevel;
+
+    // Base hit chance from attacker and victim levels
+    int32 modHitChance;
+    if (leveldif < 3)
+        modHitChance = 96 - leveldif;
+    else
+        modHitChance = 94 - (leveldif - 2) * lchance;
+
+    // Spellmod from SPELLMOD_RESIST_MISS_CHANCE
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spell->Id, SPELLMOD_RESIST_MISS_CHANCE, modHitChance);
+
+    // Chance hit from victim SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE auras
+    modHitChance += victim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE, schoolMask);
+
+    int32 HitChance = modHitChance * 100;
+    // Increase hit chance from attacker SPELL_AURA_MOD_SPELL_HIT_CHANCE and attacker ratings
+    HitChance += int32(m_modSpellHitChance * 100.0f);
+
+    if (HitChance < 100)
+        HitChance = 100;
+    else if (HitChance > 10000)
+        HitChance = 10000;
+
+    int32 tmp = 10000 - HitChance;
+
+    int32 rand = irand(0, 10000);
+
+    if (rand < tmp)
+        return SPELL_MISS_MISS;
+
+    // Spells with SPELL_ATTR3_IGNORE_HIT_RESULT will additionally fully ignore
+    // resist and deflect chances
+    if (spell->AttributesEx3 & SPELL_ATTR3_IGNORE_HIT_RESULT)
+        return SPELL_MISS_NONE;
+
+    // Chance resist mechanic (select max value from every mechanic spell effect)
+    int32 resist_chance = victim->GetMechanicResistChance(spell) * 100;
+    tmp += resist_chance;
+
+   // Roll chance
+    if (rand < tmp)
+        return SPELL_MISS_RESIST;
+
+    // cast by caster in front of victim
+    if (victim->HasInArc(M_PI, this) || victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    {
+        int32 deflect_chance = victim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * 100;
+        tmp += deflect_chance;
+        if (rand < tmp)
+            return SPELL_MISS_DEFLECT;
+    }
+
+    return SPELL_MISS_NONE;
+}
+
+// Calculate spell hit result can be:
+// Every spell can: Evade/Immune/Reflect/Sucesful hit
+// For melee based spells:
+//   Miss
+//   Dodge
+//   Parry
+// For spells
+//   Resist
+SpellMissInfo Unit::SpellHitResult(Unit* victim, SpellInfo const* spell, bool CanReflect)
+{
+    // Check for immune
+    if (victim->IsImmunedToSpell(spell, this))
+        return SPELL_MISS_IMMUNE;
+
+    // All positive spells can`t miss
+    // TODO: client not show miss log for this spells - so need find info for this in dbc and use it!
+    if (spell->IsPositive()
+        &&(!IsHostileTo(victim)))  // prevent from affecting enemy by "positive" spell
+        return SPELL_MISS_NONE;
+
+    // Check for immune
+    if (victim->IsImmunedToDamage(spell, false))
+        return SPELL_MISS_IMMUNE;
+
+    if (this == victim)
+        return SPELL_MISS_NONE;
+
+    // Return evade for units in evade mode
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsInEvadeMode())
+        return SPELL_MISS_EVADE;
+
+    if (spell->AttributesEx8 & SPELL_ATTR8_CANT_MISS)
+        return SPELL_MISS_NONE;
+
+    // Try victim reflect spell
+    if (CanReflect)
+    {
+        int32 reflectchance = victim->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS);
+        Unit::AuraEffectList const& mReflectSpellsSchool = victim->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS_SCHOOL);
+        for (Unit::AuraEffectList::const_iterator i = mReflectSpellsSchool.begin(); i != mReflectSpellsSchool.end(); ++i)
+            if ((*i)->GetMiscValue() & spell->GetSchoolMask())
+                reflectchance += (*i)->GetAmount();
+        if (reflectchance > 0 && roll_chance_i(reflectchance))
+        {
+            // Start triggers for remove charges if need (trigger only for victim, and mark as active spell)
+            ProcDamageAndSpell(victim, PROC_FLAG_NONE, PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_NEG, PROC_EX_REFLECT, 1, 0, BASE_ATTACK, spell);
+            return SPELL_MISS_REFLECT;
+        }
+    }
+
+    switch (spell->DmgClass)
+    {
+        case SPELL_DAMAGE_CLASS_RANGED:
+        case SPELL_DAMAGE_CLASS_MELEE:
+            return MeleeSpellHitResult(victim, spell);
+        case SPELL_DAMAGE_CLASS_NONE:
+            return SPELL_MISS_NONE;
+        case SPELL_DAMAGE_CLASS_MAGIC:
+            return MagicSpellHitResult(victim, spell);
+    }
+    return SPELL_MISS_NONE;
+}
+
+float Unit::GetUnitDodgeChance() const
+{
+    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STATE_CONTROLLED))
+        return 0.0f;
+
+    if (GetTypeId() == TYPEID_PLAYER)
+        return GetFloatValue(PLAYER_DODGE_PERCENTAGE);
+    else
+    {
+        if (ToCreature()->isTotem())
+            return 0.0f;
+        else
+        {
+            float dodge = 5.0f;
+            dodge += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
+            return dodge > 0.0f ? dodge : 0.0f;
+        }
+    }
+}
+
+float Unit::GetUnitParryChance() const
+{
+    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STATE_CONTROLLED))
+        return 0.0f;
+
+    float chance = 0.0f;
+
+    if (Player const* player = ToPlayer())
+    {
+        if (player->CanParry())
+        {
+            Item* tmpitem = player->GetWeaponForAttack(BASE_ATTACK, true);
+            if (!tmpitem)
+                tmpitem = player->GetWeaponForAttack(OFF_ATTACK, true);
+
+            if (tmpitem)
+                chance = GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+        }
+    }
+    else if (GetTypeId() == TYPEID_UNIT)
+    {
+        if (GetCreatureType() == CREATURE_TYPE_HUMANOID)
+        {
+            chance = 5.0f;
+            chance += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
+        }
+    }
+
+    return chance > 0.0f ? chance : 0.0f;
+}
+
+float Unit::GetUnitMissChance(WeaponAttackType attType) const
+{
+    float miss_chance = 5.00f;
+
+    if (attType == RANGED_ATTACK)
+        miss_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE);
+    else
+        miss_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);
+
+    return miss_chance;
+}
+
+float Unit::GetUnitBlockChance() const
+{
+    if (IsNonMeleeSpellCasted(false) || HasUnitState(UNIT_STATE_CONTROLLED))
+        return 0.0f;
+
+    if (Player const* player = ToPlayer())
+    {
+        if (player->CanBlock())
+        {
+            Item* tmpitem = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+            if (tmpitem && !tmpitem->IsBroken())
+                return GetFloatValue(PLAYER_BLOCK_PERCENTAGE);
+        }
+        // is player but has no block ability or no not broken shield equipped
+        return 0.0f;
+    }
+    else
+    {
+        if (ToCreature()->isTotem())
+            return 0.0f;
+        else
+        {
+            float block = 5.0f;
+            block += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
+            return block > 0.0f ? block : 0.0f;
+        }
+    }
+}
+
+float Unit::GetUnitCriticalChance(WeaponAttackType attackType, const Unit* victim) const
+{
+    float crit;
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        switch (attackType)
+        {
+            case BASE_ATTACK:
+                crit = GetFloatValue(PLAYER_CRIT_PERCENTAGE);
+                break;
+            case OFF_ATTACK:
+                crit = GetFloatValue(PLAYER_OFFHAND_CRIT_PERCENTAGE);
+                break;
+            case RANGED_ATTACK:
+                crit = GetFloatValue(PLAYER_RANGED_CRIT_PERCENTAGE);
+                break;
+                // Just for good manner
+            default:
+                crit = 0.0f;
+                break;
+        }
+    }
+    else
+    {
+        crit = 5.0f;
+        crit += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
+        crit += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
+    }
+
+    // flat aura mods
+    if (attackType == RANGED_ATTACK)
+        crit += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_CHANCE);
+    else
+        crit += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_CHANCE);
+
+    AuraEffectList const& dummyAuras = victim->GetAuraEffectsByType(SPELL_AURA_DUMMY);
+    for (AuraEffectList::const_iterator i = dummyAuras.begin(); i != dummyAuras.end(); ++i)
+    {
+        switch ((*i)->GetId())
+        {
+            case 50365: // Improved Blood presence
+            case 50371:
+                if ((*i)->GetEffIndex() != EFFECT_1 || !victim->HasAura(48263))
+                    continue;
+                crit += (*i)->GetAmount();
+                break;
+        }
+    }
+
+    if (isPet() && ToPet()->GetOwner() && ToPet()->GetOwner()->getClass() == CLASS_WARLOCK) // Curse of Gul'dan
+        if (AuraEffect const* aura = victim->GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 1923, EFFECT_0))
+            crit += aura->GetAmount();
+
+    crit += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);
+
+    return crit;
+}
+
+void Unit::_DeleteRemovedAuras()
+{
+    while (!m_removedAuras.empty())
+    {
+        delete m_removedAuras.front();
+        m_removedAuras.pop_front();
+    }
+}
+
+void Unit::_UpdateSpells(uint32 time)
+{
+    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
+        _UpdateAutoRepeatSpell();
+
+    // remove finished spells from current pointers
+    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
+    {
+        if (m_currentSpells[i] && m_currentSpells[i]->getState() == SPELL_STATE_FINISHED)
+        {
+            m_currentSpells[i]->SetReferencedFromCurrent(false);
+            m_currentSpells[i] = NULL;                      // remove pointer
+        }
+    }
+
+    // m_auraUpdateIterator can be updated in indirect called code at aura remove to skip next planned to update but removed auras
+    for (m_auraUpdateIterator = m_ownedAuras.begin(); m_auraUpdateIterator != m_ownedAuras.end();)
+    {
+        Aura* i_aura = m_auraUpdateIterator->second;
+        ++m_auraUpdateIterator;                            // need shift to next for allow update if need into aura update
+        i_aura->UpdateOwner(time, this);
+    }
+
+    // remove expired auras - do that after updates(used in scripts?)
+    for (AuraMap::iterator i = m_ownedAuras.begin(); i != m_ownedAuras.end();)
+    {
+        if (i->second->IsExpired())
+            RemoveOwnedAura(i, AURA_REMOVE_BY_EXPIRE);
+        else
+            ++i;
+    }
+
+    for (VisibleAuraMap::iterator itr = m_visibleAuras.begin(); itr != m_visibleAuras.end(); ++itr)
+        if (itr->second->IsNeedClientUpdate())
+            itr->second->ClientUpdate();
+
+    _DeleteRemovedAuras();
+
+    if (!m_gameObj.empty())
+    {
+        GameObjectList::iterator itr;
+        for (itr = m_gameObj.begin(); itr != m_gameObj.end();)
+        {
+            if (!(*itr)->isSpawned())
+            {
+                (*itr)->SetOwnerGUID(0);
+                (*itr)->SetRespawnTime(0);
+                (*itr)->Delete();
+                m_gameObj.erase(itr++);
+            }
+            else
+                ++itr;
+        }
+    }
+}
+
+void Unit::_UpdateAutoRepeatSpell()
+{
+    // check "realtime" interrupts
+    // don't cancel spells which are affected by a SPELL_AURA_CAST_WHILE_WALKING effect
+    if (((GetTypeId() == TYPEID_PLAYER && ToPlayer()->isMoving()) || IsNonMeleeSpellCasted(false, false, true, m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id == 75)) &&
+        !HasAuraTypeWithAffectMask(SPELL_AURA_CAST_WHILE_WALKING, m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo))
+    {
+        // cancel wand shoot
+        if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
+            InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+        m_AutoRepeatFirstCast = true;
+        return;
+    }
+
+    // apply delay (Auto Shot (spellID 75) not affected)
+    if (m_AutoRepeatFirstCast && getAttackTimer(RANGED_ATTACK) < 500 && m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
+        setAttackTimer(RANGED_ATTACK, 500);
+    m_AutoRepeatFirstCast = false;
+
+    // castroutine
+    if (isAttackReady(RANGED_ATTACK))
+    {
+        // Check if able to cast
+        if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->CheckCast(true) != SPELL_CAST_OK)
+        {
+            InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            return;
+        }
+
+        // we want to shoot
+        Spell* spell = new Spell(this, m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo, TRIGGERED_FULL_MASK);
+        spell->prepare(&(m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_targets));
+
+        // all went good, reset attack
+        resetAttackTimer(RANGED_ATTACK);
+    }
+}
+
+void Unit::SetCurrentCastedSpell(Spell* pSpell)
+{
+    ASSERT(pSpell);                                         // NULL may be never passed here, use InterruptSpell or InterruptNonMeleeSpells
+
+    CurrentSpellTypes CSpellType = pSpell->GetCurrentContainer();
+
+    if (pSpell == m_currentSpells[CSpellType])             // avoid breaking self
+        return;
+
+    // break same type spell if it is not delayed
+    InterruptSpell(CSpellType, false);
+
+    // special breakage effects:
+    switch (CSpellType)
+    {
+        case CURRENT_GENERIC_SPELL:
+        {
+            // generic spells always break channeled not delayed spells
+            InterruptSpell(CURRENT_CHANNELED_SPELL, false);
+
+            // autorepeat breaking
+            if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
+            {
+                // break autorepeat if not Auto Shot
+                if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
+                    InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                m_AutoRepeatFirstCast = true;
+            }
+            if (pSpell->m_spellInfo->CalcCastTime(this) > 0)
+                AddUnitState(UNIT_STATE_CASTING);
+
+            break;
+        }
+        case CURRENT_CHANNELED_SPELL:
+        {
+            // channel spells always break generic non-delayed and any channeled spells
+            InterruptSpell(CURRENT_GENERIC_SPELL, false);
+            InterruptSpell(CURRENT_CHANNELED_SPELL);
+
+            // it also does break autorepeat if not Auto Shot
+            if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] &&
+                m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
+                InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            AddUnitState(UNIT_STATE_CASTING);
+
+            break;
+        }
+        case CURRENT_AUTOREPEAT_SPELL:
+        {
+            // only Auto Shoot does not break anything
+            if (pSpell->m_spellInfo->Id != 75)
+            {
+                // generic autorepeats break generic non-delayed and channeled non-delayed spells
+                InterruptSpell(CURRENT_GENERIC_SPELL, false);
+                InterruptSpell(CURRENT_CHANNELED_SPELL, false);
+            }
+            // special action: set first cast flag
+            m_AutoRepeatFirstCast = true;
+
+            break;
+        }
+        default:
+            break; // other spell types don't break anything now
+    }
+
+    // current spell (if it is still here) may be safely deleted now
+    if (m_currentSpells[CSpellType])
+        m_currentSpells[CSpellType]->SetReferencedFromCurrent(false);
+
+    // set new current spell
+    m_currentSpells[CSpellType] = pSpell;
+    pSpell->SetReferencedFromCurrent(true);
+
+    pSpell->m_selfContainer = &(m_currentSpells[pSpell->GetCurrentContainer()]);
+}
+
+void Unit::InterruptSpell(CurrentSpellTypes spellType, bool withDelayed, bool withInstant)
+{
+    ASSERT(spellType < CURRENT_MAX_SPELL);
+
+    //sLog->outDebug(LOG_FILTER_UNITS, "Interrupt spell for unit %u.", GetEntry());
+    Spell* spell = m_currentSpells[spellType];
+    if (spell
+        && (withDelayed || spell->getState() != SPELL_STATE_DELAYED)
+        && (withInstant || spell->GetCastTime() > 0))
+    {
+        // for example, do not let self-stun aura interrupt itself
+        if (!spell->IsInterruptable() || spell->GetSpellInfo()->Id == 85422 || spell->GetSpellInfo()->Id == 85425 || spell->GetSpellInfo()->Id == 43648|| spell->GetSpellInfo()->Id == 43658)
+            return;
+
+        // send autorepeat cancel message for autorepeat spells
+        if (spellType == CURRENT_AUTOREPEAT_SPELL)
+            if (GetTypeId() == TYPEID_PLAYER)
+                ToPlayer()->SendAutoRepeatCancel(this);
+
+        if (spell->GetSpellInfo()->AttributesEx3 & SPELL_ATTR3_UNK13)
+            return;				
+				
+        if (spell->getState() != SPELL_STATE_FINISHED)
+            spell->cancel();
+
+        m_currentSpells[spellType] = NULL;
+        spell->SetReferencedFromCurrent(false);
+    }
+}
+
+void Unit::FinishSpell(CurrentSpellTypes spellType, bool ok /*= true*/)
+{
+    Spell* spell = m_currentSpells[spellType];
+    if (!spell)
+        return;
+
+    if (spellType == CURRENT_CHANNELED_SPELL)
+        spell->SendChannelUpdate(0);
+
+    spell->finish(ok);
+}
+
+bool Unit::IsNonMeleeSpellCasted(bool withDelayed, bool skipChanneled, bool skipAutorepeat, bool isAutoshoot, bool skipInstant) const
+{
+    // We don't do loop here to explicitly show that melee spell is excluded.
+    // Maybe later some special spells will be excluded too.
+
+    // if skipInstant then instant spells shouldn't count as being casted
+    if (skipInstant && m_currentSpells[CURRENT_GENERIC_SPELL] && !m_currentSpells[CURRENT_GENERIC_SPELL]->GetCastTime())
+        return false;
+
+    // generic spells are casted when they are not finished and not delayed
+    if (m_currentSpells[CURRENT_GENERIC_SPELL] &&
+        (m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_FINISHED) &&
+        (withDelayed || m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_DELAYED))
+    {
+        if (!isAutoshoot || !(m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS))
+            return true;
+    }
+    // channeled spells may be delayed, but they are still considered casted
+    else if (!skipChanneled && m_currentSpells[CURRENT_CHANNELED_SPELL] &&
+        (m_currentSpells[CURRENT_CHANNELED_SPELL]->getState() != SPELL_STATE_FINISHED))
+    {
+        if (!isAutoshoot || !(m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS))
+            return true;
+    }
+    // autorepeat spells may be finished or delayed, but they are still considered casted
+    else if (!skipAutorepeat && m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
+        return true;
+
+    return false;
+}
+
+void Unit::InterruptNonMeleeSpells(bool withDelayed, uint32 spell_id, bool withInstant)
+{
+    // generic spells are interrupted if they are not finished or delayed
+    if (m_currentSpells[CURRENT_GENERIC_SPELL] && (!spell_id || m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->Id == spell_id))
+        InterruptSpell(CURRENT_GENERIC_SPELL, withDelayed, withInstant);
+
+    // autorepeat spells are interrupted if they are not finished or delayed
+    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] && (!spell_id || m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id == spell_id))
+        InterruptSpell(CURRENT_AUTOREPEAT_SPELL, withDelayed, withInstant);
+
+    // channeled spells are interrupted if they are not finished, even if they are delayed
+    if (m_currentSpells[CURRENT_CHANNELED_SPELL] && (!spell_id || m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->Id == spell_id))
+        InterruptSpell(CURRENT_CHANNELED_SPELL, true, true);
+}
+
+Spell* Unit::FindCurrentSpellBySpellId(uint32 spell_id) const
+{
+    for (uint32 i = 0; i < CURRENT_MAX_SPELL; i++)
+        if (m_currentSpells[i] && m_currentSpells[i]->m_spellInfo->Id == spell_id)
+            return m_currentSpells[i];
+    return NULL;
+}
+
+int32 Unit::GetCurrentSpellCastTime(uint32 spell_id) const
+{
+    if (Spell const* spell = FindCurrentSpellBySpellId(spell_id))
+        return spell->GetCastTime();
+    return 0;
+}
+
+bool Unit::isInFrontInMap(Unit const* target, float distance,  float arc) const
+{
+    return IsWithinDistInMap(target, distance) && HasInArc(arc, target);
+}
+
+bool Unit::isInBackInMap(Unit const* target, float distance, float arc) const
+{
+    return IsWithinDistInMap(target, distance) && !HasInArc(2 * M_PI - arc, target);
+}
+
+bool Unit::isInAccessiblePlaceFor(Creature const* c) const
+{
+    if (IsInWater())
+        return c->canSwim();
+    else
+        return c->canWalk() || c->CanFly();
+}
+
+void Unit::UpdateUnderwaterState(Map* m, float x, float y, float z)
+{
+    if (!isPet() && !IsVehicle())
+        return;
+
+    LiquidData liquid_status;
+    ZLiquidStatus res = m->getLiquidStatus(x, y, z, MAP_ALL_LIQUIDS, &liquid_status);
+    if (!res)
+    {
+        if (_lastLiquid && _lastLiquid->SpellId)
+            RemoveAurasDueToSpell(_lastLiquid->SpellId);
+
+        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_UNDERWATER);
+        _lastLiquid = NULL;
+        return;
+    }
+
+    if (uint32 liqEntry = liquid_status.entry)
+    {
+        LiquidTypeEntry const* liquid = sLiquidTypeStore.LookupEntry(liqEntry);
+        if (_lastLiquid && _lastLiquid->SpellId && _lastLiquid->Id != liqEntry)
+            RemoveAurasDueToSpell(_lastLiquid->SpellId);
+
+        if (liquid && liquid->SpellId)
+        {
+            if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER))
+            {
+                if (!HasAura(liquid->SpellId))
+                    CastSpell(this, liquid->SpellId, true);
+            }
+            else
+                RemoveAurasDueToSpell(liquid->SpellId);
+        }
+
+        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_ABOVEWATER);
+        _lastLiquid = liquid;
+    }
+    else if (_lastLiquid && _lastLiquid->SpellId)
+    {
+        RemoveAurasDueToSpell(_lastLiquid->SpellId);
+        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_UNDERWATER);
+        _lastLiquid = NULL;
+    }
+}
+
+void Unit::DeMorph()
+{
+    SetDisplayId(GetNativeDisplayId());
+}
+
+Aura* Unit::_TryStackingOrRefreshingExistingAura(SpellInfo const* newAura, uint8 effMask, Unit* caster, int32* baseAmount /*= NULL*/, Item* castItem /*= NULL*/, uint64 casterGUID /*= 0*/)
+{
+    ASSERT(casterGUID || caster);
+    if (!casterGUID)
+        casterGUID = caster->GetGUID();
+
+    // passive and Incanter's Absorption and auras with different type can stack with themselves any number of times
+    if (!newAura->IsMultiSlotAura())
+    {
+        // check if cast item changed
+        uint64 castItemGUID = 0;
+        if (castItem)
+            castItemGUID = castItem->GetGUID();
+
+        // find current aura from spell and change it's stackamount, or refresh it's duration
+        if (Aura* foundAura = GetOwnedAura(newAura->Id, casterGUID, (newAura->AttributesCu & SPELL_ATTR0_CU_ENCHANT_PROC) ? castItemGUID : 0, 0))
+        {
+            // effect masks do not match
+            // extremely rare case
+            // let's just recreate aura
+            if (effMask != foundAura->GetEffectMask())
+                return NULL;
+
+            // update basepoints with new values - effect amount will be recalculated in ModStackAmount
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                if (!foundAura->HasEffect(i))
+                    continue;
+
+                foundAura->GetEffect(i)->ResetPeriodic();
+
+                int bp;
+                if (baseAmount)
+                    bp = *(baseAmount + i);
+                else
+                    bp = foundAura->GetSpellInfo()->Effects[i].BasePoints;
+
+                int32* oldBP = const_cast<int32*>(&(foundAura->GetEffect(i)->m_baseAmount));
+                *oldBP = bp;
+            }
+
+            // correct cast item guid if needed
+            if (castItemGUID != foundAura->GetCastItemGUID())
+            {
+                uint64* oldGUID = const_cast<uint64 *>(&foundAura->m_castItemGuid);
+                *oldGUID = castItemGUID;
+            }
+
+            // try to increase stack amount
+            foundAura->ModStackAmount(1);
+            return foundAura;
+        }
+    }
+
+    return NULL;
+}
+
+void Unit::_AddAura(UnitAura* aura, Unit* caster)
+{
+    ASSERT(!m_cleanupDone);
+    m_ownedAuras.insert(AuraMap::value_type(aura->GetId(), aura));
+
+    _RemoveNoStackAurasDueToAura(aura);
+
+    if (aura->IsRemoved())
+        return;
+
+    // Save the auras we applied on other targets as we might need access to them
+    if (caster && aura->GetSpellInfo()->NeedsSpecialTreatment())
+    {
+        ACE_Guard<ACE_Recursive_Thread_Mutex> g(m_appliedAuraMutex);
+        caster->appliedAuras.push_back(aura);
+    }
+
+    aura->SetIsSingleTarget(caster && aura->GetSpellInfo()->IsSingleTarget());
+    if (aura->IsSingleTarget())
+    {
+        ASSERT((IsInWorld() && !IsDuringRemoveFromWorld()) || (aura->GetCasterGUID() == GetGUID()));
+        // register single target aura
+        caster->GetSingleCastAuras().push_back(aura);
+        // remove other single target auras
+        Unit::AuraList& scAuras = caster->GetSingleCastAuras();
+        for (Unit::AuraList::iterator itr = scAuras.begin(); itr != scAuras.end();)
+        {
+            if ((*itr) != aura &&
+                (*itr)->GetSpellInfo()->IsSingleTargetWith(aura->GetSpellInfo()))
+            {
+                (*itr)->Remove();
+                itr = scAuras.begin();
+            }
+            else
+                ++itr;
+        }
+    }
+}
+
+// creates aura application instance and registers it in lists
+// aura application effects are handled separately to prevent aura list corruption
+AuraApplication * Unit::_CreateAuraApplication(Aura* aura, uint8 effMask)
+{
+    // can't apply aura on unit which is going to be deleted - to not create a memory leak
+    ASSERT(!m_cleanupDone);
+    // aura musn't be removed
+    ASSERT(!aura->IsRemoved());
+
+    // aura mustn't be already applied on target
+    ASSERT (!aura->IsAppliedOnTarget(GetGUID()) && "Unit::_CreateAuraApplication: aura musn't be applied on target");
+
+    SpellInfo const* aurSpellInfo = aura->GetSpellInfo();
+    uint32 aurId = aurSpellInfo->Id;
+
+    // ghost spell check, allow apply any auras at player loading in ghost mode (will be cleanup after load)
+    if (!isAlive() && !aurSpellInfo->IsDeathPersistent() &&
+        (GetTypeId() != TYPEID_PLAYER || !ToPlayer()->GetSession()->PlayerLoading()))
+        return NULL;
+
+    Unit* caster = aura->GetCaster();
+
+    AuraApplication * aurApp = new AuraApplication(this, caster, aura, effMask);
+    m_appliedAuras.insert(AuraApplicationMap::value_type(aurId, aurApp));
+
+    if (aurSpellInfo->AuraInterruptFlags)
+    {
+        m_interruptableAuras.push_back(aurApp);
+        AddInterruptMask(aurSpellInfo->AuraInterruptFlags);
+    }
+
+    if (AuraStateType aState = aura->GetSpellInfo()->GetAuraState())
+        m_auraStateAuras.insert(AuraStateAurasMap::value_type(aState, aurApp));
+
+    aura->_ApplyForTarget(this, caster, aurApp);
+    return aurApp;
+}
+
+void Unit::_ApplyAuraEffect(Aura* aura, uint8 effIndex)
+{
+    ASSERT(aura);
+    ASSERT(aura->HasEffect(effIndex));
+    AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());
+    ASSERT(aurApp);
+    if (!aurApp->GetEffectMask())
+        _ApplyAura(aurApp, 1<<effIndex);
+    else
+        aurApp->_HandleEffect(effIndex, true);
+}
+
+// handles effects of aura application
+// should be done after registering aura in lists
+void Unit::_ApplyAura(AuraApplication * aurApp, uint8 effMask)
+{
+    Aura* aura = aurApp->GetBase();
+
+    _RemoveNoStackAurasDueToAura(aura);
+
+    if (aurApp->GetRemoveMode())
+        return;
+
+    // Update target aura state flag
+    if (AuraStateType aState = aura->GetSpellInfo()->GetAuraState())
+        ModifyAuraState(aState, true);
+
+    if (aurApp->GetRemoveMode())
+        return;
+
+    // Sitdown on apply aura req seated
+    if (aura->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED && !IsSitState())
+        SetStandState(UNIT_STAND_STATE_SIT);
+
+    Unit* caster = aura->GetCaster();
+
+    if (aurApp->GetRemoveMode())
+        return;
+
+    aura->HandleAuraSpecificMods(aurApp, caster, true, false);
+
+    // apply effects of the aura
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (effMask & 1<<i && (!aurApp->GetRemoveMode()))
+            aurApp->_HandleEffect(i, true);
+    }
+}
+
+// removes aura application from lists and unapplies effects
+void Unit::_UnapplyAura(AuraApplicationMap::iterator &i, AuraRemoveMode removeMode)
+{
+    AuraApplication * aurApp = i->second;
+    ASSERT(aurApp);
+    ASSERT(!aurApp->GetRemoveMode());
+    ASSERT(aurApp->GetTarget() == this);
+
+    aurApp->SetRemoveMode(removeMode);
+    Aura* aura = aurApp->GetBase();
+    sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "Aura %u now is remove mode %d", aura->GetId(), removeMode);
+
+    // dead loop is killing the server probably
+    ASSERT(m_removedAurasCount < 0xFFFFFFFF);
+
+    ++m_removedAurasCount;
+
+    Unit* caster = aura->GetCaster();
+
+    // Remove all pointers from lists here to prevent possible pointer invalidation on spellcast/auraapply/auraremove
+    m_appliedAuras.erase(i);
+
+    if (aura->GetSpellInfo()->AuraInterruptFlags)
+    {
+        m_interruptableAuras.remove(aurApp);
+        UpdateInterruptMask();
+    }
+
+    bool auraStateFound = false;
+    AuraStateType auraState = aura->GetSpellInfo()->GetAuraState();
+    if (auraState)
+    {
+        bool canBreak = false;
+        // Get mask of all aurastates from remaining auras
+        for (AuraStateAurasMap::iterator itr = m_auraStateAuras.lower_bound(auraState); itr != m_auraStateAuras.upper_bound(auraState) && !(auraStateFound && canBreak);)
+        {
+            if (itr->second == aurApp)
+            {
+                m_auraStateAuras.erase(itr);
+                itr = m_auraStateAuras.lower_bound(auraState);
+                canBreak = true;
+                continue;
+            }
+            auraStateFound = true;
+            ++itr;
+        }
+    }
+
+    aurApp->_Remove();
+    aura->_UnapplyForTarget(this, caster, aurApp);
+
+    // remove effects of the spell - needs to be done after removing aura from lists
+    for (uint8 itr = 0; itr < MAX_SPELL_EFFECTS; ++itr)
+    {
+        if (aurApp->HasEffect(itr))
+            aurApp->_HandleEffect(itr, false);
+    }
+
+    // all effect mustn't be applied
+    ASSERT(!aurApp->GetEffectMask());
+
+    // Remove totem at next update if totem loses its aura
+    if ((aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE || aurApp->GetRemoveMode() == AURA_REMOVE_BY_DEFAULT)
+        && GetTypeId() == TYPEID_UNIT && ToCreature()->isTotem()&& ToTotem()->GetGUID() == aura->GetCasterGUID())
+    {
+        if (ToTotem()->GetSpell() == aura->GetId() && ToTotem()->GetTotemType() == TOTEM_PASSIVE)
+            ToTotem()->setDeathState(JUST_DIED);
+    }
+
+    // Remove aurastates only if were not found
+    if (!auraStateFound)
+        ModifyAuraState(auraState, false);
+
+    aura->HandleAuraSpecificMods(aurApp, caster, false, false);
+
+    // only way correctly remove all auras from list
+    //if (removedAuras != m_removedAurasCount) new aura may be added
+        i = m_appliedAuras.begin();
+}
+
+void Unit::_UnapplyAura(AuraApplication * aurApp, AuraRemoveMode removeMode)
+{
+    // aura can be removed from unit only if it's applied on it, shouldn't happen
+    ASSERT(aurApp->GetBase()->GetApplicationOfTarget(GetGUID()) == aurApp);
+
+    uint32 spellId = aurApp->GetBase()->GetId();
+    AuraApplicationMapBoundsNonConst range = m_appliedAuras.equal_range(spellId);
+
+    for (AuraApplicationMap::iterator iter = range.first; iter != range.second;)
+    {
+        if (iter->second == aurApp)
+        {
+            _UnapplyAura(iter, removeMode);
+            return;
+        }
+        else
+            ++iter;
+    }
+    sLog->outError(LOG_FILTER_UNITS, "Unit::_UnapplyAura: try to removed non apply or already removed aura %u", spellId);
+}
+
+void Unit::_RemoveNoStackAurasDueToAura(Aura* aura)
+{
+    SpellInfo const* spellProto = aura->GetSpellInfo();
+
+    // passive spell special case (only non stackable with ranks)
+    if (spellProto->IsPassiveStackableWithRanks())
+        return;
+
+    bool remove = false;
+    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
+    {
+        if (remove)
+        {
+            remove = false;
+            i = m_appliedAuras.begin();
+        }
+
+        if (aura->CanStackWith(i->second->GetBase()))
+            continue;
+
+        RemoveAura(i, AURA_REMOVE_BY_DEFAULT);
+        if (i == m_appliedAuras.end())
+            break;
+        remove = true;
+    }
+}
+
+void Unit::_RegisterAuraEffect(AuraEffect* aurEff, bool apply)
+{
+    if (apply)
+        m_modAuras[aurEff->GetAuraType()].push_back(aurEff);
+    else
+        m_modAuras[aurEff->GetAuraType()].remove(aurEff);
+}
+
+// All aura base removes should go threw this function!
+void Unit::RemoveOwnedAura(AuraMap::iterator &i, AuraRemoveMode removeMode)
+{
+    Aura* aura = i->second;
+    ASSERT(!aura->IsRemoved());
+
+    // if unit currently update aura list then make safe update iterator shift to next
+    if (m_auraUpdateIterator == i)
+        ++m_auraUpdateIterator;
+
+    m_ownedAuras.erase(i);
+    m_removedAuras.push_back(aura);
+
+    // Unregister single target aura
+    if (aura->IsSingleTarget())
+        aura->UnregisterSingleTarget();
+
+    if (aura->GetSpellInfo()->NeedsSpecialTreatment())
+    {
+        Unit* temp = aura->GetCaster();
+        if (!temp)
+            temp = ObjectAccessor::GetObjectInOrOutOfWorld(aura->GetCasterGUID(), (Unit*)NULL);
+        if (temp)
+        {
+            ACE_Guard<ACE_Recursive_Thread_Mutex> g(m_appliedAuraMutex);
+            temp->appliedAuras.remove(aura);
+        }
+    }
+
+    aura->_Remove(removeMode);
+
+    i = m_ownedAuras.begin();
+}
+
+void Unit::RemoveOwnedAura(uint32 spellId, uint64 casterGUID, uint8 reqEffMask, AuraRemoveMode removeMode)
+{
+    for (AuraMap::iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId);)
+        if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask) && (!casterGUID || itr->second->GetCasterGUID() == casterGUID))
+        {
+            RemoveOwnedAura(itr, removeMode);
+            itr = m_ownedAuras.lower_bound(spellId);
+        }
+        else
+            ++itr;
+}
+
+void Unit::RemoveOwnedAura(Aura* aura, AuraRemoveMode removeMode)
+{
+    if (aura->IsRemoved())
+        return;
+
+    ASSERT(aura->GetOwner() == this);
+
+    uint32 spellId = aura->GetId();
+    AuraMapBoundsNonConst range = m_ownedAuras.equal_range(spellId);
+
+    for (AuraMap::iterator itr = range.first; itr != range.second; ++itr)
+    {
+        if (itr->second == aura)
+        {
+            RemoveOwnedAura(itr, removeMode);
+            return;
+        }
+    }
+
+    ASSERT(false);
+}
+
+Aura* Unit::GetOwnedAura(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask, Aura* except) const
+{
+    AuraMapBounds range = m_ownedAuras.equal_range(spellId);
+    for (AuraMap::const_iterator itr = range.first; itr != range.second; ++itr)
+    {
+        if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask)
+                && (!casterGUID || itr->second->GetCasterGUID() == casterGUID)
+                && (!itemCasterGUID || itr->second->GetCastItemGUID() == itemCasterGUID)
+                && (!except || except != itr->second))
+        {
+            return itr->second;
+        }
+        else
+        {
+            if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask && itr->second->GetSpellInfo()->SpellFamilyName == SPELLFAMILY_GENERIC) && itr->second->GetSpellInfo()->StackAmount/*&& (castUnit->GetTypeId() == TYPEID_UNIT) && (auraUnit->GetTypeId() == TYPEID_UNIT)*/ && (!except || except != itr->second) && !(itr->second->GetSpellInfo()->AttributesEx3 & SPELL_ATTR3_STACK_FOR_DIFF_CASTERS))
+                return itr->second;
+        }
+
+    }
+    return NULL;
+}
+
+void Unit::RemoveAura(AuraApplicationMap::iterator &i, AuraRemoveMode mode)
+{
+    AuraApplication * aurApp = i->second;
+    // Do not remove aura which is already being removed
+    if (aurApp->GetRemoveMode())
+        return;
+    Aura* aura = aurApp->GetBase();
+    _UnapplyAura(i, mode);
+    // Remove aura - for Area and Target auras
+    if (aura->GetOwner() == this)
+        aura->Remove(mode);
+}
+
+void Unit::RemoveAura(uint32 spellId, uint64 caster, uint8 reqEffMask, AuraRemoveMode removeMode)
+{
+    AuraApplicationMapBoundsNonConst range = m_appliedAuras.equal_range(spellId);
+    for (AuraApplicationMap::iterator iter = range.first; iter != range.second;)
+    {
+        Aura const* aura = iter->second->GetBase();
+        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)
+                && (!caster || aura->GetCasterGUID() == caster))
+        {
+            RemoveAura(iter, removeMode);
+            return;
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAura(AuraApplication * aurApp, AuraRemoveMode mode)
+{
+    // we've special situation here, RemoveAura called while during aura removal
+    // this kind of call is needed only when aura effect removal handler
+    // or event triggered by it expects to remove
+    // not yet removed effects of an aura
+    if (aurApp->GetRemoveMode())
+    {
+        // remove remaining effects of an aura
+        for (uint8 itr = 0; itr < MAX_SPELL_EFFECTS; ++itr)
+        {
+            if (aurApp->HasEffect(itr))
+                aurApp->_HandleEffect(itr, false);
+        }
+        return;
+    }
+    // no need to remove
+    if (aurApp->GetBase()->GetApplicationOfTarget(GetGUID()) != aurApp || aurApp->GetBase()->IsRemoved())
+        return;
+
+    uint32 spellId = aurApp->GetBase()->GetId();
+    AuraApplicationMapBoundsNonConst range = m_appliedAuras.equal_range(spellId);
+
+    for (AuraApplicationMap::iterator iter = range.first; iter != range.second;)
+    {
+        if (aurApp == iter->second)
+        {
+            RemoveAura(iter, mode);
+            return;
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAura(Aura* aura, AuraRemoveMode mode)
+{
+    if (aura->IsRemoved())
+        return;
+    if (AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID()))
+        RemoveAura(aurApp, mode);
+}
+
+void Unit::RemoveAurasDueToSpell(uint32 spellId, uint64 casterGUID, uint8 reqEffMask, AuraRemoveMode removeMode)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
+    {
+        Aura const* aura = iter->second->GetBase();
+        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)
+            && (!casterGUID || aura->GetCasterGUID() == casterGUID))
+        {
+            RemoveAura(iter, removeMode);
+            iter = m_appliedAuras.lower_bound(spellId);
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAuraFromStack(uint32 spellId, uint64 casterGUID, AuraRemoveMode removeMode)
+{
+    AuraMapBoundsNonConst range = m_ownedAuras.equal_range(spellId);
+    for (AuraMap::iterator iter = range.first; iter != range.second;)
+    {
+        Aura* aura = iter->second;
+        if ((aura->GetType() == UNIT_AURA_TYPE)
+                && (!casterGUID || aura->GetCasterGUID() == casterGUID))
+        {
+            aura->ModStackAmount(-1, removeMode);
+            return;
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint32 dispellerSpellId, uint64 casterGUID, Unit* dispeller, uint8 chargesRemoved/*= 1*/)
+{
+    AuraMapBoundsNonConst range = m_ownedAuras.equal_range(spellId);
+    for (AuraMap::iterator iter = range.first; iter != range.second;)
+    {
+        Aura* aura = iter->second;
+        if (aura->GetCasterGUID() == casterGUID)
+        {
+            DispelInfo dispelInfo(dispeller, dispellerSpellId, chargesRemoved);
+
+            // Call OnDispel hook on AuraScript
+            aura->CallScriptDispel(&dispelInfo);
+
+            if (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES)
+                aura->ModCharges(-dispelInfo.GetRemovedCharges(), AURA_REMOVE_BY_ENEMY_SPELL);
+            else
+                aura->ModStackAmount(-dispelInfo.GetRemovedCharges(), AURA_REMOVE_BY_ENEMY_SPELL);
+
+            // Call AfterDispel hook on AuraScript
+            aura->CallScriptAfterDispel(&dispelInfo);
+
+            return;
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAurasDueToSpellBySteal(uint32 spellId, uint64 casterGUID, Unit* stealer)
+{
+    AuraMapBoundsNonConst range = m_ownedAuras.equal_range(spellId);
+    for (AuraMap::iterator iter = range.first; iter != range.second;)
+    {
+        Aura* aura = iter->second;
+        if (aura->GetCasterGUID() == casterGUID)
+        {
+            int32 damage[MAX_SPELL_EFFECTS];
+            int32 baseDamage[MAX_SPELL_EFFECTS];
+            uint8 effMask = 0;
+            uint8 recalculateMask = 0;
+            Unit* caster = aura->GetCaster();
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                if (aura->GetEffect(i))
+                {
+                    baseDamage[i] = aura->GetEffect(i)->GetBaseAmount();
+                    damage[i] = aura->GetEffect(i)->GetAmount();
+                    effMask |= (1<<i);
+                    if (aura->GetEffect(i)->CanBeRecalculated())
+                        recalculateMask |= (1<<i);
+                }
+                else
+                {
+                    baseDamage[i] = 0;
+                    damage[i] = 0;
+                }
+            }
+
+            bool stealCharge = aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES;
+            bool applyToStealer = !(aura->GetSpellInfo()->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE);
+            // Cast duration to unsigned to prevent permanent aura's such as Righteous Fury being permanently added to caster
+
+            uint32 dur = std::min(2u * MINUTE * IN_MILLISECONDS, uint32(aura->GetDuration()));
+
+            if (applyToStealer)
+            {
+                if (Aura* oldAura = stealer->GetAura(aura->GetId(), aura->GetCasterGUID()))
+                {
+                    if (stealCharge)
+                        oldAura->ModCharges(1);
+                    else
+                        oldAura->ModStackAmount(1);
+                    oldAura->SetDuration(int32(dur));
+                }
+                else
+                {
+                    // single target state must be removed before aura creation to preserve existing single target aura
+                    if (aura->IsSingleTarget())
+                        aura->UnregisterSingleTarget();
+
+                    if (Aura* newAura = Aura::TryRefreshStackOrCreate(aura->GetSpellInfo(), effMask, stealer, NULL, &baseDamage[0], NULL, aura->GetCasterGUID()))
+                    {
+                        // created aura must not be single target aura,, so stealer won't loose it on recast
+                        if (newAura->IsSingleTarget())
+                        {
+                            newAura->UnregisterSingleTarget();
+                            // bring back single target aura status to the old aura
+                            aura->SetIsSingleTarget(true);
+                            caster->GetSingleCastAuras().push_back(aura);
+                        }
+                        newAura->m_needsUnregister = false;
+                        // FIXME: using aura->GetMaxDuration() maybe not blizzlike but it fixes stealing of spells like Innervate
+                        newAura->SetLoadedState(aura->GetMaxDuration(), int32(dur), stealCharge ? 1 : aura->GetCharges(), 1, recalculateMask, &damage[0]);
+                        newAura->ApplyForTargets();
+                    }
+                }
+            }
+
+            if (stealCharge)
+                aura->ModCharges(-1, AURA_REMOVE_BY_ENEMY_SPELL);
+            else
+                aura->ModStackAmount(-1, AURA_REMOVE_BY_ENEMY_SPELL);
+
+            return;
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAurasDueToItemSpell(uint32 spellId, uint64 castItemGuid)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
+    {
+        if (iter->second->GetBase()->GetCastItemGUID() == castItemGuid)
+        {
+            RemoveAura(iter);
+            iter = m_appliedAuras.lower_bound(spellId);
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAurasByType(AuraType auraType, uint64 casterGUID, Aura* except, bool negative, bool positive, SpellFamilyNames SpellFamilyName, uint32 schoolMask)
+{
+    for (AuraEffectList::iterator iter = m_modAuras[auraType].begin(); iter != m_modAuras[auraType].end();)
+    {
+        Aura* aura = (*iter)->GetBase();
+        AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());
+
+        ++iter;
+        if (aura != except && (!casterGUID || aura->GetCasterGUID() == casterGUID)
+            && ((negative && !aurApp->IsPositive()) || (positive && aurApp->IsPositive()))
+            && (!SpellFamilyName || aura->GetSpellInfo()->SpellFamilyName == SpellFamilyName)
+            && (!schoolMask || aura->GetSpellInfo()->SchoolMask & schoolMask))
+        {
+            uint32 removedAuras = m_removedAurasCount;
+            RemoveAura(aurApp);
+            if (m_removedAurasCount > removedAuras + 1)
+                iter = m_modAuras[auraType].begin();
+        }
+    }
+}
+
+void Unit::RemoveAurasWithAttribute(uint32 flags)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        SpellInfo const* spell = iter->second->GetBase()->GetSpellInfo();
+        if (spell->Attributes & flags)
+            RemoveAura(iter);
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveNotOwnSingleTargetAuras(uint32 newPhase)
+{
+    // single target auras from other casters
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        AuraApplication const* aurApp = iter->second;
+        Aura const* aura = aurApp->GetBase();
+
+        if (aura->GetCasterGUID() != GetGUID() && (aura->GetSpellInfo()->IsSingleTarget() || aura->GetSpellInfo()->NeedsSpecialTreatment()))
+        {
+            if (!newPhase)
+                RemoveAura(iter);
+            else
+            {
+                Unit* caster = aura->GetCaster();
+                if (!caster || !caster->InSamePhase(newPhase))
+                    RemoveAura(iter);
+                else
+                    ++iter;
+            }
+        }
+        else
+            ++iter;
+    }
+
+    // single target auras at other targets
+    AuraList& scAuras = GetSingleCastAuras();
+    for (AuraList::iterator iter = scAuras.begin(); iter != scAuras.end();)
+    {
+        Aura* aura = *iter;
+        if (aura->GetUnitOwner() != this && !aura->GetUnitOwner()->InSamePhase(newPhase))
+        {
+            aura->Remove();
+            iter = scAuras.begin();
+        }
+        else
+            ++iter;
+    }
+
+    //special treatment auras at other targets
+    appliedAurasList& auras = appliedAuras;
+    for (appliedAurasList::iterator iter = auras.begin(); iter != auras.end();)
+    {
+        Aura* aura = *iter;
+        if (aura->GetUnitOwner() != this && !aura->GetUnitOwner()->InSamePhase(newPhase))
+        {
+            aura->Remove();
+            iter = auras.begin();
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAurasWithInterruptFlags(uint32 flag, uint32 except, uint32 damage)
+{
+    if (!(m_interruptMask & flag))
+        return;
+
+    // interrupt auras
+    for (AuraApplicationList::iterator iter = m_interruptableAuras.begin(); iter != m_interruptableAuras.end();)
+    {
+        Aura* aura = (*iter)->GetBase();
+        ++iter;
+        if ((aura->GetSpellInfo()->AuraInterruptFlags & flag) && (!except || aura->GetId() != except) &&
+            !(flag & AURA_INTERRUPT_FLAG_MOVING && HasAuraTypeWithAffectMask(SPELL_AURA_CAST_WHILE_WALKING, aura->GetSpellInfo())))
+        {
+            bool remove = true;
+            if (aura->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE2
+                && !(aura->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE))
+            {
+                for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+                    if (AuraEffect* aurEff = aura->GetEffect(i))
+                    {
+                        switch (aurEff->GetAuraType())
+                        {
+                            case SPELL_AURA_MOD_CONFUSE:
+                            case SPELL_AURA_MOD_FEAR:
+                            case SPELL_AURA_MOD_STUN:
+                            case SPELL_AURA_MOD_ROOT:
+                            case SPELL_AURA_TRANSFORM:
+                            {
+                                if (!aurEff->GetAmount() || !aura->GetSpellInfo()->ProcFlags)
+                                    break;
+
+                                if (aurEff->GetAmount() && int32(damage) < aurEff->GetAmount())
+                                {
+                                    aurEff->SetAmount(aurEff->GetAmount() - damage);
+                                    remove = false;
+                                }
+                                break;
+                            }
+                        }
+                        if (remove)
+                            break;
+                    }
+            }
+
+            if (remove)
+            {
+                uint32 removedAuras = m_removedAurasCount;
+                RemoveAura(aura);
+                if (m_removedAurasCount > removedAuras + 1)
+                    iter = m_interruptableAuras.begin();
+            }
+        }
+    }
+
+    // interrupt channeled spell
+    if (Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])
+        if (spell->getState() == SPELL_STATE_CASTING
+            && (spell->m_spellInfo->ChannelInterruptFlags & flag)
+            && spell->m_spellInfo->Id != except &&
+            !(flag & AURA_INTERRUPT_FLAG_MOVING && HasAuraTypeWithAffectMask(SPELL_AURA_CAST_WHILE_WALKING, spell->m_spellInfo)))
+            InterruptNonMeleeSpells(false);
+
+    UpdateInterruptMask();
+}
+
+void Unit::RemoveAurasWithFamily(SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        Aura const* aura = iter->second->GetBase();
+        if (!casterGUID || aura->GetCasterGUID() == casterGUID)
+        {
+            SpellInfo const* spell = aura->GetSpellInfo();
+            if (spell->SpellFamilyName == uint32(family) && spell->SpellFamilyFlags.HasFlag(familyFlag1, familyFlag2, familyFlag3))
+            {
+                RemoveAura(iter);
+                continue;
+            }
+        }
+        ++iter;
+    }
+}
+
+void Unit::RemoveMovementImpairingAuras()
+{
+    RemoveAurasWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT));
+}
+
+void Unit::RemoveAurasWithMechanic(uint32 mechanic_mask, AuraRemoveMode removemode, uint32 except)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        Aura const* aura = iter->second->GetBase();
+        if (!except || aura->GetId() != except)
+        {
+            if (aura->GetSpellInfo()->GetAllEffectsMechanicMask() & mechanic_mask)
+            {
+                RemoveAura(iter, removemode);
+                continue;
+            }
+        }
+        ++iter;
+    }
+}
+
+void Unit::RemoveAreaAurasDueToLeaveWorld()
+{
+    // make sure that all area auras not applied on self are removed - prevent access to deleted pointer later
+    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
+    {
+        Aura* aura = iter->second;
+        ++iter;
+        Aura::ApplicationMap const& appMap = aura->GetApplicationMap();
+        for (Aura::ApplicationMap::const_iterator itr = appMap.begin(); itr!= appMap.end();)
+        {
+            AuraApplication * aurApp = itr->second;
+            ++itr;
+            Unit* target = aurApp->GetTarget();
+            if (target == this)
+                continue;
+            target->RemoveAura(aurApp);
+            // things linked on aura remove may apply new area aura - so start from the beginning
+            iter = m_ownedAuras.begin();
+        }
+    }
+
+    // remove area auras owned by others
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        if (iter->second->GetBase()->GetOwner() != this)
+        {
+            RemoveAura(iter);
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAllAuras()
+{
+    // this may be a dead loop if some events on aura remove will continiously apply aura on remove
+    // we want to have all auras removed, so use your brain when linking events
+    while (!m_appliedAuras.empty() || !m_ownedAuras.empty())
+    {
+        AuraApplicationMap::iterator aurAppIter;
+        for (aurAppIter = m_appliedAuras.begin(); aurAppIter != m_appliedAuras.end();)
+            _UnapplyAura(aurAppIter, AURA_REMOVE_BY_DEFAULT);
+
+        AuraMap::iterator aurIter;
+        for (aurIter = m_ownedAuras.begin(); aurIter != m_ownedAuras.end();)
+            RemoveOwnedAura(aurIter);
+    }
+}
+
+void Unit::RemoveArenaAuras()
+{
+    // in join, remove positive buffs, on end, remove negative
+    // used to remove positive visible auras in arenas
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        AuraApplication const* aurApp = iter->second;
+        Aura const* aura = aurApp->GetBase();
+        if (!(aura->GetSpellInfo()->AttributesEx4 & SPELL_ATTR4_UNK21) // don't remove stances, shadowform, pally/hunter auras
+            && !aura->IsPassive()                               // don't remove passive auras
+            && (aurApp->IsPositive() || !(aura->GetSpellInfo()->AttributesEx3 & SPELL_ATTR3_DEATH_PERSISTENT))) // not negative death persistent auras
+            RemoveAura(iter);
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAllAurasOnDeath()
+{
+    // used just after dieing to remove all visible auras
+    // and disable the mods for the passive ones
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        Aura const* aura = iter->second->GetBase();
+        if (!aura->IsPassive() && !aura->IsDeathPersistent())
+            _UnapplyAura(iter, AURA_REMOVE_BY_DEATH);
+        else
+            ++iter;
+    }
+
+    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
+    {
+        Aura* aura = iter->second;
+        if (!aura->IsPassive() && !aura->IsDeathPersistent())
+            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEATH);
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAllAurasRequiringDeadTarget()
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        Aura const* aura = iter->second->GetBase();
+        if (!aura->IsPassive() && aura->GetSpellInfo()->IsRequiringDeadTarget())
+            _UnapplyAura(iter, AURA_REMOVE_BY_DEFAULT);
+        else
+            ++iter;
+    }
+
+    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
+    {
+        Aura* aura = iter->second;
+        if (!aura->IsPassive() && aura->GetSpellInfo()->IsRequiringDeadTarget())
+            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEFAULT);
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAllAurasExceptType(AuraType type)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        Aura const* aura = iter->second->GetBase();
+        if (!aura->GetSpellInfo()->HasAura(type))
+            _UnapplyAura(iter, AURA_REMOVE_BY_DEFAULT);
+        else
+            ++iter;
+    }
+
+    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
+    {
+        Aura* aura = iter->second;
+        if (!aura->GetSpellInfo()->HasAura(type))
+            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEFAULT);
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAllNonPassiveAurasExceptType(AuraType type)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        Aura const* aura = iter->second->GetBase();
+        if (aura && !aura->GetSpellInfo()->HasAura(type) && !aura->GetSpellInfo()->IsPassive())
+            _UnapplyAura(iter, AURA_REMOVE_BY_DEFAULT);
+        else
+            ++iter;
+    }
+
+    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
+    {
+        Aura* aura = iter->second;
+        if (aura && !aura->GetSpellInfo()->HasAura(type) && !aura->GetSpellInfo()->IsPassive())
+            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEFAULT);
+        else
+            ++iter;
+    }
+}
+
+void Unit::DelayOwnedAuras(uint32 spellId, uint64 caster, int32 delaytime)
+{
+    AuraMapBoundsNonConst range = m_ownedAuras.equal_range(spellId);
+    for (; range.first != range.second; ++range.first)
+    {
+        Aura* aura = range.first->second;
+        if (!caster || aura->GetCasterGUID() == caster)
+        {
+            if (aura->GetDuration() < delaytime)
+                aura->SetDuration(0);
+            else
+                aura->SetDuration(aura->GetDuration() - delaytime);
+
+            // update for out of range group members (on 1 slot use)
+            aura->SetNeedClientUpdateForTargets();
+            sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "Aura %u partially interrupted on unit %u, new duration: %u ms", aura->GetId(), GetGUIDLow(), aura->GetDuration());
+        }
+    }
+}
+
+void Unit::_RemoveAllAuraStatMods()
+{
+    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
+        (*i).second->GetBase()->HandleAllEffects(i->second, AURA_EFFECT_HANDLE_STAT, false);
+}
+
+void Unit::_ApplyAllAuraStatMods()
+{
+    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
+        (*i).second->GetBase()->HandleAllEffects(i->second, AURA_EFFECT_HANDLE_STAT, true);
+}
+
+AuraEffect* Unit::GetAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster) const
+{
+    AuraApplicationMapBounds range = m_appliedAuras.equal_range(spellId);
+    for (AuraApplicationMap::const_iterator itr = range.first; itr != range.second; ++itr)
+    {
+        if (itr->second->HasEffect(effIndex)
+                && (!caster || itr->second->GetBase()->GetCasterGUID() == caster))
+        {
+            return itr->second->GetBase()->GetEffect(effIndex);
+        }
+    }
+    return NULL;
+}
+
+AuraEffect* Unit::GetAuraEffectOfRankedSpell(uint32 spellId, uint8 effIndex, uint64 caster) const
+{
+    uint32 rankSpell = sSpellMgr->GetFirstSpellInChain(spellId);
+    while (rankSpell)
+    {
+        if (AuraEffect* aurEff = GetAuraEffect(rankSpell, effIndex, caster))
+            return aurEff;
+        rankSpell = sSpellMgr->GetNextSpellInChain(rankSpell);
+    }
+    return NULL;
+}
+
+AuraEffect* Unit::GetAuraEffect(AuraType type, SpellFamilyNames name, uint32 iconId, uint8 effIndex) const
+{
+    AuraEffectList const& auras = GetAuraEffectsByType(type);
+    for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        if (effIndex != (*itr)->GetEffIndex())
+            continue;
+        SpellInfo const* spell = (*itr)->GetSpellInfo();
+        if (spell->SpellIconID == iconId && spell->SpellFamilyName == uint32(name) && (!spell->SpellFamilyFlags || type == SPELL_AURA_DUMMY))
+            return *itr;
+    }
+    return NULL;
+}
+
+AuraEffect* Unit::GetAuraEffect(AuraType type, SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID)
+{
+    AuraEffectList const& auras = GetAuraEffectsByType(type);
+    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
+    {
+        SpellInfo const* spell = (*i)->GetSpellInfo();
+        if (spell->SpellFamilyName == uint32(family) && spell->SpellFamilyFlags.HasFlag(familyFlag1, familyFlag2, familyFlag3))
+        {
+            if (casterGUID && (*i)->GetCasterGUID() != casterGUID)
+                continue;
+            return (*i);
+        }
+    }
+    return NULL;
+}
+
+AuraApplication * Unit::GetAuraApplication(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask, AuraApplication * except) const
+{
+    AuraApplicationMapBounds range = m_appliedAuras.equal_range(spellId);
+    for (; range.first != range.second; ++range.first)
+    {
+        AuraApplication* app = range.first->second;
+        Aura const* aura = app->GetBase();
+
+        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)
+                && (!casterGUID || aura->GetCasterGUID() == casterGUID)
+                && (!itemCasterGUID || aura->GetCastItemGUID() == itemCasterGUID)
+                && (!except || except != app))
+        {
+            return app;
+        }
+    }
+    return NULL;
+}
+
+Aura* Unit::GetAura(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask) const
+{
+    AuraApplication * aurApp = GetAuraApplication(spellId, casterGUID, itemCasterGUID, reqEffMask);
+    return aurApp ? aurApp->GetBase() : NULL;
+}
+
+AuraApplication * Unit::GetAuraApplicationOfRankedSpell(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask, AuraApplication* except) const
+{
+    uint32 rankSpell = sSpellMgr->GetFirstSpellInChain(spellId);
+    while (rankSpell)
+    {
+        if (AuraApplication * aurApp = GetAuraApplication(rankSpell, casterGUID, itemCasterGUID, reqEffMask, except))
+            return aurApp;
+        rankSpell = sSpellMgr->GetNextSpellInChain(rankSpell);
+    }
+    return NULL;
+}
+
+Aura* Unit::GetAuraOfRankedSpell(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask) const
+{
+    AuraApplication * aurApp = GetAuraApplicationOfRankedSpell(spellId, casterGUID, itemCasterGUID, reqEffMask);
+    return aurApp ? aurApp->GetBase() : NULL;
+}
+
+void Unit::GetDispellableAuraList(Unit* caster, uint32 dispelMask, DispelChargesList& dispelList)
+{
+    // we should not be able to dispel diseases if the target is affected by unholy blight
+    if (dispelMask & (1 << DISPEL_DISEASE) && HasAura(50536))
+        dispelMask &= ~(1 << DISPEL_DISEASE);
+
+    AuraMap const& auras = GetOwnedAuras();
+    for (AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura* aura = itr->second;
+        AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());
+        if (!aurApp)
+            continue;
+
+        // don't try to remove passive auras
+        if (aura->IsPassive())
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            if (aura->GetSpellInfo()->Dispel == DISPEL_MAGIC)
+            {
+                // do not remove positive auras if friendly target
+                //               negative auras if non-friendly target
+                if (aurApp->IsPositive() == IsFriendlyTo(caster))
+                    continue;
+            }
+
+            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
+            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
+            // Polymorph instead of 1 / (5 + 1) -> 16%.
+            bool dispel_charges = aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES;
+            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                dispelList.push_back(std::make_pair(aura, charges));
+        }
+    }
+}
+
+bool Unit::HasAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster) const
+{
+    AuraApplicationMapBounds range = m_appliedAuras.equal_range(spellId);
+    for (AuraApplicationMap::const_iterator itr = range.first; itr != range.second; ++itr)
+    {
+        if (itr->second->HasEffect(effIndex)
+                && (!caster || itr->second->GetBase()->GetCasterGUID() == caster))
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
+uint32 Unit::GetAuraCount(uint32 spellId) const
+{
+    uint32 count = 0;
+    AuraApplicationMapBounds range = m_appliedAuras.equal_range(spellId);
+
+    for (AuraApplicationMap::const_iterator itr = range.first; itr != range.second; ++itr)
+    {
+        if (itr->second->GetBase()->GetStackAmount() == 0)
+            ++count;
+        else
+            count += (uint32)itr->second->GetBase()->GetStackAmount();
+    }
+
+    return count;
+}
+
+bool Unit::HasAura(uint32 spellId, uint64 casterGUID, uint64 itemCasterGUID, uint8 reqEffMask) const
+{
+    if (GetAuraApplication(spellId, casterGUID, itemCasterGUID, reqEffMask))
+        return true;
+    return false;
+}
+
+bool Unit::HasAuraWithDispelType(uint32 dispelType, uint64 casterGUID)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
+    {
+        SpellInfo const* spellInfo = iter->second->GetBase()->GetSpellInfo();
+        if (spellInfo->Dispel == dispelType && iter->second->GetBase()->GetCasterGUID() == casterGUID)
+            return true;
+    }
+    return false;
+}
+
+bool Unit::HasAuraType(AuraType auraType) const
+{
+    return (!m_modAuras[auraType].empty());
+}
+
+bool Unit::HasAuraTypeWithCaster(AuraType auratype, uint64 caster) const
+{
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if (caster == (*i)->GetCasterGUID())
+            return true;
+    return false;
+}
+
+bool Unit::HasAuraTypeWithMiscvalue(AuraType auratype, int32 miscvalue) const
+{
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if (miscvalue == (*i)->GetMiscValue())
+            return true;
+    return false;
+}
+
+bool Unit::HasAuraTypeWithAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
+{
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if ((*i)->IsAffectingSpell(affectedSpell))
+            return true;
+    return false;
+}
+
+bool Unit::HasAuraTypeWithValue(AuraType auratype, int32 value) const
+{
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if (value == (*i)->GetAmount())
+            return true;
+    return false;
+}
+
+bool Unit::HasNegativeAuraWithInterruptFlag(uint32 flag, uint64 guid)
+{
+    if (!(m_interruptMask & flag))
+        return false;
+    for (AuraApplicationList::iterator iter = m_interruptableAuras.begin(); iter != m_interruptableAuras.end(); ++iter)
+    {
+        if (!(*iter)->IsPositive() && (*iter)->GetBase()->GetSpellInfo()->AuraInterruptFlags & flag && (!guid || (*iter)->GetBase()->GetCasterGUID() == guid))
+            return true;
+    }
+    return false;
+}
+
+bool Unit::HasNegativeAuraWithAttribute(uint32 flag, uint64 guid)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
+    {
+        Aura const* aura = iter->second->GetBase();
+        if (!iter->second->IsPositive() && aura->GetSpellInfo()->Attributes & flag && (!guid || aura->GetCasterGUID() == guid))
+            return true;
+    }
+    return false;
+}
+
+bool Unit::HasAuraWithMechanic(uint32 mechanicMask)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
+    {
+        SpellInfo const* spellInfo  = iter->second->GetBase()->GetSpellInfo();
+        if (spellInfo->Mechanic && (mechanicMask & (1 << spellInfo->Mechanic)))
+            return true;
+
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            if (iter->second->HasEffect(i) && spellInfo->Effects[i].Effect && spellInfo->Effects[i].Mechanic)
+                if (mechanicMask & (1 << spellInfo->Effects[i].Mechanic))
+                    return true;
+    }
+
+    return false;
+}
+
+AuraEffect* Unit::IsScriptOverriden(SpellInfo const* spell, int32 script) const
+{
+    AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() == script)
+            if ((*i)->IsAffectingSpell(spell))
+                return (*i);
+    }
+    return NULL;
+}
+
+uint32 Unit::GetDiseasesByCaster(uint64 casterGUID, bool remove)
+{
+    static const AuraType diseaseAuraTypes[] =
+    {
+        SPELL_AURA_PERIODIC_DAMAGE,                 // Frost Fever and Blood Plague
+        SPELL_AURA_MOD_DAMAGE_FROM_CASTER,          // Ebon Plague
+        SPELL_AURA_NONE
+    };
+
+    uint32 diseases = 0;
+    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
+    {
+        for (AuraEffectList::iterator i = m_modAuras[*itr].begin(); i != m_modAuras[*itr].end();)
+        {
+            // Get auras with disease dispel type by caster
+            if ((*i)->GetSpellInfo()->Dispel == DISPEL_DISEASE
+                && (*i)->GetCasterGUID() == casterGUID)
+            {
+                ++diseases;
+
+                if (remove)
+                {
+                    RemoveAura((*i)->GetId(), (*i)->GetCasterGUID());
+                    i = m_modAuras[*itr].begin();
+                    continue;
+                }
+            }
+            ++i;
+        }
+    }
+    return diseases;
+}
+
+uint32 Unit::GetDoTsByCaster(uint64 casterGUID) const
+{
+    static const AuraType diseaseAuraTypes[] =
+    {
+        SPELL_AURA_PERIODIC_DAMAGE,
+        SPELL_AURA_PERIODIC_DAMAGE_PERCENT,
+        SPELL_AURA_NONE
+    };
+
+    uint32 dots = 0;
+    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
+    {
+        Unit::AuraEffectList const& auras = GetAuraEffectsByType(*itr);
+        for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
+        {
+            // Get auras by caster
+            if ((*i)->GetCasterGUID() == casterGUID)
+                ++dots;
+        }
+    }
+    return dots;
+}
+
+Unit::AuraEffectList Unit::GetAuraDotsByCaster(uint64 casterGUID) const
+{
+    static const AuraType diseaseAuraTypes[] =
+    {
+        SPELL_AURA_PERIODIC_DAMAGE,
+        SPELL_AURA_PERIODIC_DAMAGE_PERCENT,
+        SPELL_AURA_NONE
+    };
+
+    AuraEffectList dotsList;
+    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
+    {
+        Unit::AuraEffectList const& auras = GetAuraEffectsByType(*itr);
+        for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
+        {
+            // Get auras by caster
+            if ((*i)->GetCasterGUID() == casterGUID)
+                dotsList.push_back(*i);
+        }
+    }
+
+    return dotsList;
+}
+
+int32 Unit::GetTotalAuraModifier(AuraType auratype) const
+{
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+            modifier += (*i)->GetAmount();
+
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        modifier += itr->second;
+
+    return modifier;
+}
+
+float Unit::GetTotalAuraMultiplier(AuraType auratype) const
+{
+    float multiplier = 1.0f;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        AddPct(multiplier, (*i)->GetAmount());
+
+    return multiplier;
+}
+
+int32 Unit::GetMaxPositiveAuraModifier(AuraType auratype)
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetAmount() > modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetMaxNegativeAuraModifier(AuraType auratype) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if ((*i)->GetAmount() < modifier)
+            modifier = (*i)->GetAmount();
+
+    return modifier;
+}
+
+int32 Unit::GetTotalAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const
+{
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if ((*i)->GetMiscValue() & misc_mask)
+            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+                modifier += (*i)->GetAmount();
+
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        modifier += itr->second;
+
+    return modifier;
+}
+
+float Unit::GetTotalAuraMultiplierByMiscMask(AuraType auratype, uint32 misc_mask) const
+{
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
+    float multiplier = 1.0f;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if (((*i)->GetMiscValue() & misc_mask))
+        {
+            // Check if the Aura Effect has a the Same Effect Stack Rule and if so, use the highest amount of that SpellGroup
+            // If the Aura Effect does not have this Stack Rule, it returns false so we can add to the multiplier as usual
+            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+                AddPct(multiplier, (*i)->GetAmount());
+        }
+    }
+    // Add the highest of the Same Effect Stack Rule SpellGroups to the multiplier
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        AddPct(multiplier, itr->second);
+
+    return multiplier;
+}
+
+int32 Unit::GetMaxPositiveAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask, const AuraEffect* except) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if (except != (*i) && (*i)->GetMiscValue()& misc_mask && (*i)->GetAmount() > modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetMaxNegativeAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue()& misc_mask && (*i)->GetAmount() < modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
+{
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() == misc_value)
+            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+                modifier += (*i)->GetAmount();
+    }
+
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        modifier += itr->second;
+
+    return modifier;
+}
+
+float Unit::GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_value) const
+{
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
+    float multiplier = 1.0f;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() == misc_value)
+            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+                AddPct(multiplier, (*i)->GetAmount());
+    }
+
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        AddPct(multiplier, itr->second);
+
+    return multiplier;
+}
+
+int32 Unit::GetMaxPositiveAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() == misc_value && (*i)->GetAmount() > modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() == misc_value && (*i)->GetAmount() < modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetTotalAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
+{
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->IsAffectingSpell(affectedSpell))
+            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+                modifier += (*i)->GetAmount();
+    }
+
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        modifier += itr->second;
+
+    return modifier;
+}
+
+float Unit::GetTotalAuraMultiplierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
+{
+    std::map<SpellGroup, int32> SameEffectSpellGroup;
+    float multiplier = 1.0f;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->IsAffectingSpell(affectedSpell))
+            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*i)->GetSpellInfo(), (*i)->GetAmount(), SameEffectSpellGroup))
+                AddPct(multiplier, (*i)->GetAmount());
+    }
+
+    for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
+        AddPct(multiplier, itr->second);
+
+    return multiplier;
+}
+
+int32 Unit::GetMaxPositiveAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->IsAffectingSpell(affectedSpell) && (*i)->GetAmount() > modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetMaxNegativeAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->IsAffectingSpell(affectedSpell) && (*i)->GetAmount() < modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+void Unit::_RegisterDynObject(DynamicObject* dynObj)
+{
+    m_dynObj.push_back(dynObj);
+}
+
+void Unit::_UnregisterDynObject(DynamicObject* dynObj)
+{
+    m_dynObj.remove(dynObj);
+}
+
+DynamicObject* Unit::GetDynObject(uint32 spellId)
+{
+    if (m_dynObj.empty())
+        return NULL;
+    for (DynObjectList::const_iterator i = m_dynObj.begin(); i != m_dynObj.end();++i)
+    {
+        DynamicObject* dynObj = *i;
+        if (dynObj->GetSpellId() == spellId)
+            return dynObj;
+    }
+    return NULL;
+}
+
+void Unit::RemoveDynObject(uint32 spellId)
+{
+    if (m_dynObj.empty())
+        return;
+    for (DynObjectList::iterator i = m_dynObj.begin(); i != m_dynObj.end();)
+    {
+        DynamicObject* dynObj = *i;
+        if (dynObj->GetSpellId() == spellId)
+        {
+            dynObj->Remove();
+            i = m_dynObj.begin();
+        }
+        else
+            ++i;
+    }
+}
+
+void Unit::RemoveAllDynObjects()
+{
+    while (!m_dynObj.empty())
+        m_dynObj.front()->Remove();
+}
+
+GameObject* Unit::GetGameObject(uint32 spellId) const
+{
+    for (GameObjectList::const_iterator i = m_gameObj.begin(); i != m_gameObj.end(); ++i)
+        if ((*i)->GetSpellId() == spellId)
+            return *i;
+
+    return NULL;
+}
+
+void Unit::AddGameObject(GameObject* gameObj)
+{
+    if (!gameObj || !gameObj->GetOwnerGUID() == 0)
+        return;
+
+    m_gameObj.push_back(gameObj);
+    gameObj->SetOwnerGUID(GetGUID());
+
+    if (GetTypeId() == TYPEID_PLAYER && gameObj->GetSpellId())
+    {
+        SpellInfo const* createBySpell = sSpellMgr->GetSpellInfo(gameObj->GetSpellId());
+        // Need disable spell use for owner
+        if (createBySpell && createBySpell->Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE)
+            // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existing cases)
+            AddSpellAndCategoryCooldowns(createBySpell, 0, NULL, true);
+    }
+}
+
+void Unit::RemoveGameObject(GameObject* gameObj, bool del)
+{
+    if (!gameObj || gameObj->GetOwnerGUID() != GetGUID())
+        return;
+
+    gameObj->SetOwnerGUID(0);
+
+    for (uint8 i = 0; i < MAX_GAMEOBJECT_SLOT; ++i)
+    {
+        if (m_ObjectSlot[i] == gameObj->GetGUID())
+        {
+            m_ObjectSlot[i] = 0;
+            break;
+        }
+    }
+
+    // GO created by some spell
+    if (uint32 spellid = gameObj->GetSpellId())
+    {
+        RemoveAurasDueToSpell(spellid);
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            SpellInfo const* createBySpell = sSpellMgr->GetSpellInfo(spellid);
+            // Need activate spell use for owner
+            if (createBySpell && createBySpell->Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE)
+                // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existing cases)
+                ToPlayer()->SendCooldownEvent(createBySpell);
+        }
+    }
+
+    m_gameObj.remove(gameObj);
+
+    if (del)
+    {
+        gameObj->SetRespawnTime(0);
+        gameObj->Delete();
+    }
+}
+
+void Unit::RemoveGameObject(uint32 spellid, bool del)
+{
+    if (m_gameObj.empty())
+        return;
+    GameObjectList::iterator i, next;
+    for (i = m_gameObj.begin(); i != m_gameObj.end(); i = next)
+    {
+        next = i;
+        if (spellid == 0 || (*i)->GetSpellId() == spellid)
+        {
+            (*i)->SetOwnerGUID(0);
+            if (del)
+            {
+                (*i)->SetRespawnTime(0);
+                (*i)->Delete();
+            }
+
+            next = m_gameObj.erase(i);
+        }
+        else
+            ++next;
+    }
+}
+
+void Unit::RemoveAllGameObjects()
+{
+    // remove references to unit
+    while (!m_gameObj.empty())
+    {
+        GameObjectList::iterator i = m_gameObj.begin();
+        (*i)->SetOwnerGUID(0);
+        (*i)->SetRespawnTime(0);
+        (*i)->Delete();
+        m_gameObj.erase(i);
+    }
+}
+
+void Unit::SendSpellNonMeleeDamageLog(SpellNonMeleeDamage* log)
+{
+    WorldPacket data(SMSG_SPELLNONMELEEDAMAGELOG, (16+4+4+4+1+4+4+1+1+4+4+1)); // we guess size
+    data.append(log->target->GetPackGUID());
+    data.append(log->attacker->GetPackGUID());
+    data << uint32(log->SpellID);
+    data << uint32(log->damage);                            // damage amount
+    int32 overkill = log->damage - log->target->GetHealth();
+    data << uint32(overkill > 0 ? overkill : 0);            // overkill
+    data << uint8 (log->schoolMask);                        // damage school
+    data << uint32(log->absorb);                            // AbsorbedDamage
+    data << uint32(log->resist);                            // resist
+    data << uint8 (log->physicalLog);                       // if 1, then client show spell name (example: %s's ranged shot hit %s for %u school or %s suffers %u school damage from %s's spell_name
+    data << uint8 (log->unused);                            // unused
+    data << uint32(log->blocked);                           // blocked
+    data << uint32(log->HitInfo);
+    data << uint8 (0);                                      // flag to use extend data
+    SendMessageToSet(&data, true);
+}
+
+void Unit::SendSpellNonMeleeDamageLog(Unit* target, uint32 SpellID, uint32 Damage, SpellSchoolMask damageSchoolMask, uint32 AbsorbedDamage, uint32 Resist, bool PhysicalDamage, uint32 Blocked, bool CriticalHit)
+{
+    SpellNonMeleeDamage log(this, target, SpellID, damageSchoolMask);
+    log.damage = Damage - AbsorbedDamage - Resist - Blocked;
+    log.absorb = AbsorbedDamage;
+    log.resist = Resist;
+    log.physicalLog = PhysicalDamage;
+    log.blocked = Blocked;
+    log.HitInfo = SPELL_HIT_TYPE_UNK1 | SPELL_HIT_TYPE_UNK3 | SPELL_HIT_TYPE_UNK6;
+    if (CriticalHit)
+        log.HitInfo |= SPELL_HIT_TYPE_CRIT;
+    SendSpellNonMeleeDamageLog(&log);
+}
+
+void Unit::ProcDamageAndSpell(Unit* victim, uint32 procAttacker, uint32 procVictim, uint32 procExtra, uint32 amount, uint32 absorb, WeaponAttackType attType
+                              , SpellInfo const* procSpell, SpellInfo const* procAura, SpellInfo const* interruptedSpell, bool procSpellIsHeal, bool onCast)
+{
+     // Not much to do if no flags are set.
+    if (procAttacker)
+        ProcDamageAndSpellFor(false, victim, procAttacker, procExtra, attType, procSpell, amount, absorb, procAura, interruptedSpell, procSpellIsHeal, onCast);
+    // Now go on with a victim's events'n'auras
+    // Not much to do if no flags are set or there is no victim
+    if (victim && victim->isAlive() && procVictim && !onCast)
+        victim->ProcDamageAndSpellFor(true, this, procVictim, procExtra, attType, procSpell, amount, absorb, procAura, interruptedSpell, procSpellIsHeal);
+}
+
+void Unit::SendPeriodicAuraLog(SpellPeriodicAuraLogInfo* pInfo)
+{
+    AuraEffect const* aura = pInfo->auraEff;
+
+    WorldPacket data(SMSG_PERIODICAURALOG, 30);
+    data.append(GetPackGUID());
+    data.appendPackGUID(aura->GetCasterGUID());
+    data << uint32(aura->GetId());                          // spellId
+    data << uint32(1);                                      // count
+    data << uint32(aura->GetAuraType());                    // auraId
+    switch (aura->GetAuraType())
+    {
+        case SPELL_AURA_PERIODIC_DAMAGE:
+        case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
+            data << uint32(pInfo->damage);                  // damage
+            data << uint32(pInfo->overDamage);              // overkill?
+            data << uint32(aura->GetSpellInfo()->GetSchoolMask());
+            data << uint32(pInfo->absorb);                  // absorb
+            data << uint32(pInfo->resist);                  // resist
+            data << uint8(pInfo->critical);                 // new 3.1.2 critical tick
+            break;
+        case SPELL_AURA_PERIODIC_HEAL:
+        case SPELL_AURA_OBS_MOD_HEALTH:
+            data << uint32(pInfo->damage);                  // damage
+            data << uint32(pInfo->overDamage);              // overheal
+            data << uint32(pInfo->absorb);                  // absorb
+            data << uint8(pInfo->critical);                 // new 3.1.2 critical tick
+            break;
+        case SPELL_AURA_OBS_MOD_POWER:
+        case SPELL_AURA_PERIODIC_ENERGIZE:
+            data << uint32(aura->GetMiscValue());           // power type
+            data << uint32(pInfo->damage);                  // damage
+            break;
+        case SPELL_AURA_PERIODIC_MANA_LEECH:
+            data << uint32(aura->GetMiscValue());           // power type
+            data << uint32(pInfo->damage);                  // amount
+            data << float(pInfo->multiplier);               // gain multiplier
+            break;
+        default:
+            sLog->outError(LOG_FILTER_UNITS, "Unit::SendPeriodicAuraLog: unknown aura %u", uint32(aura->GetAuraType()));
+            return;
+    }
+
+    SendMessageToSet(&data, true);
+}
+
+void Unit::SendSpellMiss(Unit* target, uint32 spellID, SpellMissInfo missInfo)
+{
+    WorldPacket data(SMSG_SPELLLOGMISS, (4+8+1+4+8+1));
+    data << uint32(spellID);
+    data << uint64(GetGUID());
+    data << uint8(0);                                       // can be 0 or 1
+    data << uint32(1);                                      // target count
+    // for (i = 0; i < target count; ++i)
+    data << uint64(target->GetGUID());                      // target GUID
+    data << uint8(missInfo);
+    // end loop
+    SendMessageToSet(&data, true);
+}
+
+void Unit::SendSpellDamageResist(Unit* target, uint32 spellId)
+{
+    WorldPacket data(SMSG_PROCRESIST, 8+8+4+1);
+    data << uint64(GetGUID());
+    data << uint64(target->GetGUID());
+    data << uint32(spellId);
+    data << uint8(0); // bool - log format: 0-default, 1-debug
+    SendMessageToSet(&data, true);
+}
+
+void Unit::SendSpellDamageImmune(Unit* target, uint32 spellId)
+{
+    WorldPacket data(SMSG_SPELLORDAMAGE_IMMUNE, 8+8+4+1);
+    data << uint64(GetGUID());
+    data << uint64(target->GetGUID());
+    data << uint32(spellId);
+    data << uint8(0); // bool - log format: 0-default, 1-debug
+    SendMessageToSet(&data, true);
+}
+
+void Unit::SendAttackStateUpdate(CalcDamageInfo* damageInfo)
+{
+    sLog->outDebug(LOG_FILTER_UNITS, "WORLD: Sending SMSG_ATTACKERSTATEUPDATE");
+
+    uint32 count = 1;
+    size_t maxsize = 4+5+5+4+4+1+4+4+4+4+4+1+4+4+4+4+4*12;
+    WorldPacket data(SMSG_ATTACKERSTATEUPDATE, maxsize);    // we guess size
+    data << uint32(damageInfo->HitInfo);
+    data.append(damageInfo->attacker->GetPackGUID());
+    data.append(damageInfo->target->GetPackGUID());
+    data << uint32(damageInfo->damage);                     // Full damage
+    int32 overkill = damageInfo->damage - damageInfo->target->GetHealth();
+    data << uint32(overkill < 0 ? 0 : overkill);            // Overkill
+    data << uint8(count);                                   // Sub damage count
+
+    for (uint32 i = 0; i < count; ++i)
+    {
+        data << uint32(damageInfo->damageSchoolMask);       // School of sub damage
+        data << float(damageInfo->damage);                  // sub damage
+        data << uint32(damageInfo->damage);                 // Sub Damage
+    }
+
+    if (damageInfo->HitInfo & (HITINFO_FULL_ABSORB | HITINFO_PARTIAL_ABSORB))
+    {
+        for (uint32 i = 0; i < count; ++i)
+            data << uint32(damageInfo->absorb);             // Absorb
+    }
+
+    if (damageInfo->HitInfo & (HITINFO_FULL_RESIST | HITINFO_PARTIAL_RESIST))
+    {
+        for (uint32 i = 0; i < count; ++i)
+            data << uint32(damageInfo->resist);             // Resist
+    }
+
+    data << uint8(damageInfo->TargetState);
+    data << uint32(0);  // Unknown attackerstate
+    data << uint32(0);  // Melee spellid
+
+    if (damageInfo->HitInfo & HITINFO_BLOCK)
+        data << uint32(damageInfo->blocked_amount);
+
+    if (damageInfo->HitInfo & HITINFO_RAGE_GAIN)
+        data << uint32(0);
+
+    //! Probably used for debugging purposes, as it is not known to appear on retail servers
+    if (damageInfo->HitInfo & HITINFO_UNK1)
+    {
+        data << uint32(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        for (uint8 i = 0; i < 2; ++i)
+        {
+            data << float(0);
+            data << float(0);
+        }
+        data << uint32(0);
+    }
+
+    SendMessageToSet(&data, true);
+}
+
+void Unit::SendAttackStateUpdate(uint32 HitInfo, Unit* target, uint8 /*SwingType*/, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount)
+{
+    CalcDamageInfo dmgInfo;
+    dmgInfo.HitInfo = HitInfo;
+    dmgInfo.attacker = this;
+    dmgInfo.target = target;
+    dmgInfo.damage = Damage - AbsorbDamage - Resist - BlockedAmount;
+    dmgInfo.damageSchoolMask = damageSchoolMask;
+    dmgInfo.absorb = AbsorbDamage;
+    dmgInfo.resist = Resist;
+    dmgInfo.TargetState = TargetState;
+    dmgInfo.blocked_amount = BlockedAmount;
+    SendAttackStateUpdate(&dmgInfo);
+}
+
+bool Unit::HandleAuraProcOnPowerAmount(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 /*procEx*/, uint32 cooldown)
+{
+    // Get triggered aura spell info
+    SpellInfo const* auraSpellInfo = triggeredByAura->GetSpellInfo();
+
+    // Get effect index used for the proc
+    uint32 effIndex = triggeredByAura->GetEffIndex();
+
+    // Power amount required to proc the spell
+    int32 powerAmountRequired = triggeredByAura->GetAmount();
+    // Power type required to proc
+    Powers powerRequired = Powers(auraSpellInfo->Effects[triggeredByAura->GetEffIndex()].MiscValue);
+
+    // Set trigger spell id, target, custom basepoints
+    uint32 trigger_spell_id = auraSpellInfo->Effects[triggeredByAura->GetEffIndex()].TriggerSpell;
+
+    Unit*  target = NULL;
+    int32  basepoints0 = 0;
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    /* Try handle unknown trigger spells or with invalid power amount or misc value
+    if (sSpellMgr->GetSpellInfo(trigger_spell_id) == NULL || powerAmountRequired == NULL || powerRequired >= MAX_POWER)
+    {
+        switch (auraSpellInfo->SpellFamilyName)
+        {
+            case SPELLFAMILY_GENERIC:
+            {
+                break;
+            }
+        }
+    }*/
+
+    // All ok. Check current trigger spell
+    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(trigger_spell_id);
+    if (triggerEntry == NULL)
+    {
+        // Not cast unknown spell
+        // sLog->outError("Unit::HandleAuraProcOnPowerAmount: Spell %u have 0 in EffectTriggered[%d], not handled custom case?", auraSpellInfo->Id, triggeredByAura->GetEffIndex());
+        return false;
+    }
+
+    // not allow proc extra attack spell at extra attack
+    if (m_extraAttacks && triggerEntry->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
+        return false;
+
+    if (!powerRequired || !powerAmountRequired)
+    {
+        sLog->outError(LOG_FILTER_SPELLS_AURAS, "Unit::HandleAuraProcOnPowerAmount: Spell %u have 0 powerAmountRequired in EffectAmount[%d] or 0 powerRequired in EffectMiscValue, not handled custom case?", auraSpellInfo->Id, triggeredByAura->GetEffIndex());
+        return false;
+    }
+
+    if (GetPower(powerRequired) != powerAmountRequired)
+        return false;
+
+    // Custom requirements (not listed in procEx) Warning! damage dealing after this
+    // Custom triggered spells
+    switch (auraSpellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_DRUID:
+        {
+            // Eclipse Mastery Driver Passive
+            if (auraSpellInfo->Id == 79577)
+            {
+                uint32 solarEclipseMarker = 67483;
+                uint32 lunarEclipseMarker = 67484;
+
+                switch (effIndex)
+                {
+                    case 0:
+                    {
+                        // Do not proc if proc spell isnt starfire and starsurge
+                        if (procSpell->Id != 2912 && procSpell->Id != 78674 && procSpell->Id != 8921)
+                            return false;
+
+                        // Do not proc if we are already at max amount
+                        if (GetPower(POWER_ECLIPSE) == 100 && HasAura(lunarEclipseMarker))
+                            return false;
+
+                        if (HasAura(solarEclipseMarker))
+                        {
+                            RemoveAurasDueToSpell(solarEclipseMarker);
+                            CastSpell(this, lunarEclipseMarker, true);
+                        }
+                        break;
+                    }
+                    case 1:
+                    {
+                        // Do not proc if proc spell isnt wrath and starsurge
+                        if (procSpell->Id != 5176 && procSpell->Id != 78674 && procSpell->Id != 93402)
+                            return false;
+
+                        // Do not proc if we are already at max amount
+                        if (GetPower(POWER_ECLIPSE) == -100 && HasAura(solarEclipseMarker))
+                            return false;
+
+                        if (HasAura(lunarEclipseMarker))
+                        {
+                            RemoveAurasDueToSpell(lunarEclipseMarker);
+                            CastSpell(this, solarEclipseMarker, true);
+                        }
+                        break;
+                    }
+                }
+            }
+            break;
+        }
+    }
+
+    if (cooldown && HasSpellCooldown(trigger_spell_id))
+        return false;
+
+    // try detect target manually if not set
+    if (target == NULL)
+        target = !(procFlag & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && triggerEntry && triggerEntry->IsPositive() ? this : victim;
+
+    if (basepoints0)
+        CastCustomSpell(target, trigger_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
+    else
+        CastSpell(target, trigger_spell_id, true, castItem, triggeredByAura);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->AddSpellCooldown(trigger_spell_id, 0, time(NULL) + cooldown);
+
+    return true;
+}
+
+//victim may be NULL
+bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, uint32 absorb, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown, SpellInfo const* interruptedSpell, bool procSpellIsHeal, bool onCast)
+{
+    SpellInfo const* dummySpell = triggeredByAura->GetSpellInfo();
+    uint32 effIndex = triggeredByAura->GetEffIndex();
+    int32  triggerAmount = triggeredByAura->GetAmount();
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    uint32 triggered_spell_id = 0;
+    uint32 cooldown_spell_id = 0; // for random trigger, will be one of the triggered spell to avoid repeatable triggers
+                                  // otherwise, it's the triggered_spell_id by default
+    Unit* target = victim;
+    int32 basepoints0 = 0;
+    uint64 originalCaster = 0;
+
+    if (onCast)
+    {
+        switch (dummySpell->SpellFamilyName)
+        {
+            case SPELLFAMILY_HUNTER:
+                switch (dummySpell->Id)
+                {
+                    case 53221: // Improved Steady Shot
+                    case 53222:
+                    case 53224:
+                    {
+                        if (!procSpell || _spellsCastedInRow[procSpell->Id] < 2)
+                            return false;
+
+                        int32 bp0 = triggeredByAura->GetAmount();
+                        CastCustomSpell(victim, 53220, &bp0, NULL, NULL, true);
+                        _spellsCastedInRow[procSpell->Id] = 0;
+                        return true;
+                    }
+                }
+                break;
+        }
+        return false;
+    }
+
+    switch (dummySpell->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            switch (dummySpell->Id)
+            {
+                // Wrath of Tarecgosa
+                case 101056:
+                {
+                    if (!roll_chance_i(4))
+                        return false;
+
+                    basepoints0 = damage;
+                    triggered_spell_id = 101085;
+                    break;
+                }
+                case 107786: // Item - Dragon Soul - Proc - Agi Melee 1H Axe
+                case 109873: // Item - Dragon Soul - Proc - Agi Melee 1H Axe Heroic
+                case 109866: // Item - Dragon Soul - Proc - Agi Melee 1H Axe LFR
+                {
+                    const static uint32 DamageSpell[3][3]=
+                    {
+                      //Flameblast   Shadowblast  Iceblast
+                        {107785,     107787,      107789}, // Normal
+                        {109872,     109868,      109870}, // Heroic
+                        {109871,     109867,      109869}, // LFR
+                    };
+
+                    int32 index = -1;
+                    switch (dummySpell->Id)
+                    {
+                        case 107786: index = 0; break; // Normal
+                        case 109873: index = 1; break; // Heroic
+                        case 109866: index = 2; break; // LFR
+                    }
+
+                    ASSERT(index >= 0 && index <= 2);
+                    triggered_spell_id = DamageSpell[index][urand(0, 2)];
+                    break;
+                }
+                // Engulfing Magic
+                case 86622:
+                case 95639:
+                case 95640:
+                case 95641:
+                {
+                    basepoints0 = damage;
+                    triggered_spell_id = 86631;
+                    target = this;
+                }
+                break;
+                // Torment
+                case 99256:
+                case 100230:
+                case 100231:
+                case 100232:
+                {
+                    if (!victim || victim->HasAura(99263))
+                        return false;
+
+                    int32 stack = ToPlayer()->GetAura(dummySpell->Id)->GetStackAmount();
+                    if (stack >= 3)
+                    {
+                        if (!victim->HasAura(99262))
+                            CastSpell(victim,99262,true);
+
+                        if (victim->HasAura(99262))
+                            ToPlayer()->GetAura(99262)->SetStackAmount(stack / 3);
+                    }
+                    break;
+                }
+                case 100129:
+                {
+                    if (procEx & PROC_EX_CRITICAL_HIT)
+                        if (damage >= uint32(triggerAmount))
+                        {
+                            AddAura(100415,victim);
+                            RemoveAurasDueToSpell(100129);
+                        }
+                    break;
+                }
+                // Consuming Flames
+                case 77786:
+                case 92971:
+                case 92972:
+                case 92973:
+                    if(procSpell != triggeredByAura->GetSpellInfo())
+                        triggeredByAura->SetAmount(triggeredByAura->GetAmount() + damage / 2);
+                    break;
+                case 96879: // Weight of a feather
+                case 97117:
+                {
+                    int32 cap = triggerAmount;
+                    int32 overheal = (GetHealth() + damage) - GetMaxHealth();
+                    if (overheal > 0)
+                    {
+                        overheal = std::min(cap, overheal);
+                        if (AuraEffect* tracker = GetAuraEffect(96881, EFFECT_0))
+                        {
+                            tracker->SetAmount(std::min(cap, tracker->GetAmount() + overheal));
+                            tracker->GetBase()->RefreshDuration();
+                        }
+                        else
+                            CastCustomSpell(this, 96881, &overheal, NULL, NULL, true);
+
+                        return true;
+                    }
+                    break;
+                }
+                case 89832: // Death strike enabler
+                {
+                    uint32 timeNow = time(NULL);
+                    uint32 auraAmount = 0;
+                    // Remove old entries
+                    for (std::map<uint32, uint32>::iterator itr = recentDamageTaken.begin(); itr != recentDamageTaken.end();)
+                    {
+                        if (timeNow - itr->first > 5)
+                            recentDamageTaken.erase(itr++);
+                        else
+                            ++itr;
+                    }
+                    recentDamageTaken[timeNow] = damage;
+                    // Update enabler with recent damage
+                    if (AuraEffect* aurEff = GetAuraEffect(89832, EFFECT_0))
+                    {
+                        for (std::map<uint32, uint32>::iterator itr = recentDamageTaken.begin(); itr != recentDamageTaken.end(); itr++)
+                            auraAmount += itr->second;
+                        aurEff->SetAmount(auraAmount);
+                    }
+                    break;
+                }
+                // Unstable Power
+                case 24658:
+                {
+                    if (!procSpell || procSpell->Id == 24659)
+                        return false;
+                    // Need remove one 24659 aura
+                    RemoveAuraFromStack(24659);
+                    return true;
+                }
+                // Restless Strength
+                case 24661:
+                {
+                    // Need remove one 24662 aura
+                    RemoveAuraFromStack(24662);
+                    return true;
+                }
+                case 85466: // Bane of Havoc
+                {                   
+                    Unit::AuraList& scAuras = GetSingleCastAuras();
+                    for (Unit::AuraList::iterator itr = scAuras.begin(); itr != scAuras.end();)
+                    {
+                            if (Unit* owner = (*itr)->GetUnitOwner())
+                            {
+                                if (owner == victim)
+                                    return false;
+
+                                basepoints0 = CalculatePct(damage, (*itr)->GetEffect(0)->GetAmount());
+                                triggered_spell_id = 85455;
+                                target = owner;
+                                break;
+                            }
+                        else
+                            ++itr;
+                    }
+                    break;
+                }
+                // Mark of Malice
+                case 33493:
+                {
+                    // Cast finish spell at last charge
+                    if (triggeredByAura->GetBase()->GetCharges() > 1)
+                        return false;
+
+                    target = this;
+                    triggered_spell_id = 33494;
+                    break;
+                }
+                // Twisted Reflection (boss spell)
+                case 21063:
+                    triggered_spell_id = 21064;
+                    break;
+                // Vampiric Aura (boss spell)
+                case 38196:
+                {
+                    basepoints0 = 3 * damage;               // 300%
+                    if (basepoints0 < 0)
+                        return false;
+
+                    triggered_spell_id = 31285;
+                    target = this;
+                    break;
+                }
+                // Aura of Madness (Darkmoon Card: Madness trinket)
+                //=====================================================
+                // 39511 Sociopath: +35 strength (Paladin, Rogue, Druid, Warrior)
+                // 40997 Delusional: +70 attack power (Rogue, Hunter, Paladin, Warrior, Druid)
+                // 40998 Kleptomania: +35 agility (Warrior, Rogue, Paladin, Hunter, Druid)
+                // 40999 Megalomania: +41 damage/healing (Druid, Shaman, Priest, Warlock, Mage, Paladin)
+                // 41002 Paranoia: +35 spell/melee/ranged crit strike rating (All classes)
+                // 41005 Manic: +35 haste (spell, melee and ranged) (All classes)
+                // 41009 Narcissism: +35 intellect (Druid, Shaman, Priest, Warlock, Mage, Paladin, Hunter)
+                // 41011 Martyr Complex: +35 stamina (All classes)
+                // 41406 Dementia: Every 5 seconds either gives you +5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)
+                // 41409 Dementia: Every 5 seconds either gives you -5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)
+                case 39446:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER || !isAlive())
+                        return false;
+
+                    // Select class defined buff
+                    switch (getClass())
+                    {
+                        case CLASS_PALADIN:                 // 39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409
+                        case CLASS_DRUID:                   // 39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409
+                            triggered_spell_id = RAND(39511, 40997, 40998, 40999, 41002, 41005, 41009, 41011, 41409);
+                            cooldown_spell_id = 39511;
+                            break;
+                        case CLASS_ROGUE:                   // 39511, 40997, 40998, 41002, 41005, 41011
+                        case CLASS_WARRIOR:                 // 39511, 40997, 40998, 41002, 41005, 41011
+                        case CLASS_DEATH_KNIGHT:
+                            triggered_spell_id = RAND(39511, 40997, 40998, 41002, 41005, 41011);
+                            cooldown_spell_id = 39511;
+                            break;
+                        case CLASS_PRIEST:                  // 40999, 41002, 41005, 41009, 41011, 41406, 41409
+                        case CLASS_SHAMAN:                  // 40999, 41002, 41005, 41009, 41011, 41406, 41409
+                        case CLASS_MAGE:                    // 40999, 41002, 41005, 41009, 41011, 41406, 41409
+                        case CLASS_WARLOCK:                 // 40999, 41002, 41005, 41009, 41011, 41406, 41409
+                            triggered_spell_id = RAND(40999, 41002, 41005, 41009, 41011, 41406, 41409);
+                            cooldown_spell_id = 40999;
+                            break;
+                        case CLASS_HUNTER:                  // 40997, 40999, 41002, 41005, 41009, 41011, 41406, 41409
+                            triggered_spell_id = RAND(40997, 40999, 41002, 41005, 41009, 41011, 41406, 41409);
+                            cooldown_spell_id = 40997;
+                            break;
+                        default:
+                            return false;
+                    }
+
+                    target = this;
+                    if (roll_chance_i(10))
+                        ToPlayer()->Say("This is Madness!", LANG_UNIVERSAL); // TODO: It should be moved to database, shouldn't it?
+                    break;
+                }
+                // Sunwell Exalted Caster Neck (??? neck)
+                // cast ??? Light's Wrath if Exalted by Aldor
+                // cast ??? Arcane Bolt if Exalted by Scryers
+                case 46569:
+                    return false;                           // old unused version
+                // Sunwell Exalted Caster Neck (Shattered Sun Pendant of Acumen neck)
+                // cast 45479 Light's Wrath if Exalted by Aldor
+                // cast 45429 Arcane Bolt if Exalted by Scryers
+                case 45481:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    // Get Aldor reputation rank
+                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
+                    {
+                        target = this;
+                        triggered_spell_id = 45479;
+                        break;
+                    }
+                    // Get Scryers reputation rank
+                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
+                    {
+                        // triggered at positive/self casts also, current attack target used then
+                        if (target && IsFriendlyTo(target))
+                        {
+                            target = GetVictim();
+                            if (!target)
+                            {
+                                uint64 selected_guid = ToPlayer()->GetSelection();
+                                target = ObjectAccessor::GetUnit(*this, selected_guid);
+                                if (!target)
+                                    return false;
+                            }
+                            if (IsFriendlyTo(target))
+                                return false;
+                        }
+
+                        triggered_spell_id = 45429;
+                        break;
+                    }
+                    return false;
+                }
+                // Sunwell Exalted Melee Neck (Shattered Sun Pendant of Might neck)
+                // cast 45480 Light's Strength if Exalted by Aldor
+                // cast 45428 Arcane Strike if Exalted by Scryers
+                case 45482: // Bane of Havoc
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    // Get Aldor reputation rank
+                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
+                    {
+                        target = this;
+                        triggered_spell_id = 45480;
+                        break;
+                    }
+                    // Get Scryers reputation rank
+                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
+                    {
+                        triggered_spell_id = 45428;
+                        break;
+                    }
+                    return false;
+                }
+                // Sunwell Exalted Tank Neck (Shattered Sun Pendant of Resolve neck)
+                // cast 45431 Arcane Insight if Exalted by Aldor
+                // cast 45432 Light's Ward if Exalted by Scryers
+                case 45483:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    // Get Aldor reputation rank
+                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
+                    {
+                        target = this;
+                        triggered_spell_id = 45432;
+                        break;
+                    }
+                    // Get Scryers reputation rank
+                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
+                    {
+                        target = this;
+                        triggered_spell_id = 45431;
+                        break;
+                    }
+                    return false;
+                }
+                // Sunwell Exalted Healer Neck (Shattered Sun Pendant of Restoration neck)
+                // cast 45478 Light's Salvation if Exalted by Aldor
+                // cast 45430 Arcane Surge if Exalted by Scryers
+                case 45484:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    // Get Aldor reputation rank
+                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
+                    {
+                        target = this;
+                        triggered_spell_id = 45478;
+                        break;
+                    }
+                    // Get Scryers reputation rank
+                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
+                    {
+                        triggered_spell_id = 45430;
+                        break;
+                    }
+                    return false;
+                }
+                // Kill command
+                case 58914:
+                {
+                    // Remove aura stack from pet
+                    RemoveAuraFromStack(58914);
+                    Unit* owner = GetOwner();
+                    if (!owner)
+                        return true;
+                    // reduce the owner's aura stack
+                    owner->RemoveAuraFromStack(34027);
+                    return true;
+                }
+                // Vampiric Touch (generic, used by some boss)
+                case 52723:
+                case 60501:
+                {
+                    triggered_spell_id = 52724;
+                    basepoints0 = damage / 2;
+                    target = this;
+                    break;
+                }
+                // Shadowfiend Death (Gain mana if pet dies with Glyph of Shadowfiend)
+                case 57989:
+                {
+                    Unit* owner = GetOwner();
+                    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+                        return false;
+                    // Glyph of Shadowfiend (need cast as self cast for owner, no hidden cooldown)
+                    owner->CastSpell(owner, 58227, true, castItem, triggeredByAura);
+                    return true;
+                }
+                // Glyph of Scourge Strike
+                case 58642:
+                {
+                    triggered_spell_id = 69961; // Glyph of Scourge Strike
+                    break;
+                }
+                // Glyph of Life Tap
+                case 63320:
+                {
+                    triggered_spell_id = 63321; // Life Tap
+                    break;
+                }
+                // Purified Shard of the Scale - Onyxia 10 Caster Trinket
+                case 69755:
+                {
+                    triggered_spell_id = (procFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS) ? 69733 : 69729;
+                    break;
+                }
+                // Shiny Shard of the Scale - Onyxia 25 Caster Trinket
+                case 69739:
+                {
+                    triggered_spell_id = (procFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS) ? 69734 : 69730;
+                    break;
+                }
+                case 71519: // Deathbringer's Will Normal
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    std::vector<uint32> RandomSpells;
+                    switch (getClass())
+                    {
+                        case CLASS_WARRIOR:
+                        case CLASS_PALADIN:
+                        case CLASS_DEATH_KNIGHT:
+                            RandomSpells.push_back(71484);
+                            RandomSpells.push_back(71491);
+                            RandomSpells.push_back(71492);
+                            break;
+                        case CLASS_SHAMAN:
+                        case CLASS_ROGUE:
+                            RandomSpells.push_back(71486);
+                            RandomSpells.push_back(71485);
+                            RandomSpells.push_back(71492);
+                            break;
+                        case CLASS_DRUID:
+                            RandomSpells.push_back(71484);
+                            RandomSpells.push_back(71485);
+                            RandomSpells.push_back(71492);
+                            break;
+                        case CLASS_HUNTER:
+                            RandomSpells.push_back(71486);
+                            RandomSpells.push_back(71491);
+                            RandomSpells.push_back(71485);
+                            break;
+                        default:
+                            return false;
+                    }
+                    if (RandomSpells.empty()) // shouldn't happen
+                        return false;
+
+                    uint8 rand_spell = irand(0, (RandomSpells.size() - 1));
+                    CastSpell(target, RandomSpells[rand_spell], true, castItem, triggeredByAura, originalCaster);
+                    for (std::vector<uint32>::iterator itr = RandomSpells.begin(); itr != RandomSpells.end(); ++itr)
+                    {
+                        if (HasSpellCooldown(*itr))
+                            AddSpellCooldown(*itr, 0, time(NULL) + cooldown);
+                    }
+                    break;
+                }
+                case 71562: // Deathbringer's Will Heroic
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    std::vector<uint32> RandomSpells;
+                    switch (getClass())
+                    {
+                        case CLASS_WARRIOR:
+                        case CLASS_PALADIN:
+                        case CLASS_DEATH_KNIGHT:
+                            RandomSpells.push_back(71561);
+                            RandomSpells.push_back(71559);
+                            RandomSpells.push_back(71560);
+                            break;
+                        case CLASS_SHAMAN:
+                        case CLASS_ROGUE:
+                            RandomSpells.push_back(71558);
+                            RandomSpells.push_back(71556);
+                            RandomSpells.push_back(71560);
+                            break;
+                        case CLASS_DRUID:
+                            RandomSpells.push_back(71561);
+                            RandomSpells.push_back(71556);
+                            RandomSpells.push_back(71560);
+                            break;
+                        case CLASS_HUNTER:
+                            RandomSpells.push_back(71558);
+                            RandomSpells.push_back(71559);
+                            RandomSpells.push_back(71556);
+                            break;
+                        default:
+                            return false;
+                    }
+                    if (RandomSpells.empty()) // shouldn't happen
+                        return false;
+
+                    uint8 rand_spell = irand(0, (RandomSpells.size() - 1));
+                    CastSpell(target, RandomSpells[rand_spell], true, castItem, triggeredByAura, originalCaster);
+                    for (std::vector<uint32>::iterator itr = RandomSpells.begin(); itr != RandomSpells.end(); ++itr)
+                    {
+                        if (HasSpellCooldown(*itr))
+                            AddSpellCooldown(*itr, 0, time(NULL) + cooldown);
+                    }
+                    break;
+                }
+                case 65032: // Boom aura (321 Boombot)
+                {
+                    if (victim->GetEntry() != 33343)   // Scrapbot
+                        return false;
+
+                    InstanceScript* instance = GetInstanceScript();
+                    if (!instance)
+                        return false;
+
+                    instance->DoCastSpellOnPlayers(65037);  // Achievement criteria marker
+                    break;
+                }
+                case 47020: // Enter vehicle XT-002 (Scrapbot)
+                {
+                    if (GetTypeId() != TYPEID_UNIT)
+                        return false;
+
+                    Unit* vehicleBase = GetVehicleBase();
+                    if (!vehicleBase)
+                        return false;
+
+                    // Todo: Check if this amount is blizzlike
+                    vehicleBase->ModifyHealth(int32(vehicleBase->CountPctFromMaxHealth(1)));
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_MAGE:
+        {
+            // Magic Absorption
+            if (dummySpell->SpellIconID == 459)             // only this spell has SpellIconID == 459 and dummy aura
+            {
+                if (getPowerType() != POWER_MANA)
+                    return false;
+
+                // mana reward
+                basepoints0 = CalculatePct(GetMaxPower(POWER_MANA), triggerAmount);
+                target = this;
+                triggered_spell_id = 29442;
+                break;
+            }
+            // Hot Streak & Improved Hot Streak
+            if (dummySpell->SpellIconID == 2999)
+            {
+                if (effIndex != 0)
+                    return false;
+                AuraEffect* counter = triggeredByAura->GetBase()->GetEffect(EFFECT_1);
+                if (!counter || (dummySpell->Id != 44445 && procSpell && procSpell->Id == 92315))
+                    return true;
+
+                // Count spell criticals in a row in second aura
+                if (procEx & PROC_EX_CRITICAL_HIT)
+                {
+                    counter->SetAmount(counter->GetAmount() * 2);
+                    if (counter->GetAmount() < 100 && dummySpell->Id != 44445) // not enough or Hot Streak spell
+                        return true;
+                    if (procSpell && dummySpell->Id == 44445)
+                    {
+                        float critChance = GetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1 + GetFirstSchoolInMask(procSpell->GetSchoolMask()));
+                        triggerAmount = triggerAmount * (1.0f - critChance / 100.0f);
+                    }
+                    // Crititcal counted -> roll chance
+                    if (roll_chance_i(triggerAmount))
+                        CastSpell(this, 48108, true, castItem, triggeredByAura);
+                }
+                counter->SetAmount(25);
+                return true;
+            }
+            // Incanter's Regalia set (add trigger chance to Mana Shield)
+            if (dummySpell->SpellFamilyFlags[0] & 0x8000)
+            {
+                if (GetTypeId() != TYPEID_PLAYER)
+                    return false;
+
+                target = this;
+                triggered_spell_id = 37436;
+                break;
+            }
+            switch (dummySpell->Id)
+            {
+                // Aura (buff) Potion of Treasure Finding
+                case 80263:
+                {
+                    Player* caster = ToPlayer();
+                    if (!caster)
+                        return false;
+
+                    switch (caster->GetZoneId())
+                    {
+                        case 5144: // Shimmering Expanse
+                        case 5145: // Abyssal Depths
+                        case 4815: // Kelp'Thar Forest
+                        case 5146: // Vash'jir
+                        case 616:  // Mount Hyjal
+                        case 5042: // Deepholm
+                        case 5034: // Uldum
+                            break;
+                        default:
+                            return false;
+                    }
+
+                    caster->AddItem(67539, 1);
+                }
+                case 29074: // Master of Elements
+                case 29075:
+                {
+                    if (!procSpell)
+                        return false;
+
+                    basepoints0 = int32(procSpell->CalcPowerCost(this, procSpell->GetSchoolMask()));
+                    basepoints0 = CalculatePct(basepoints0, triggerAmount);
+
+                    if (basepoints0 > 0)
+                        triggered_spell_id = 29077;
+                    break;
+                }
+                case 11119: // Ignite
+                case 11120:
+                case 12846:
+                {
+                    if (!procSpell || !victim)
+                        return false;
+
+                    triggered_spell_id = 12654;
+                    SpellInfo const* igniteDot = sSpellMgr->GetSpellInfo(triggered_spell_id);
+                    basepoints0 = int32(CalculatePct(damage, triggerAmount));
+                    basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);
+                    basepoints0 /= igniteDot->GetMaxTicks();
+                    break;
+                }
+                case 83156: // Piercing chill
+                case 83157:
+                {
+                    if (!victim || !procSpell || procSpell->Id != 116)
+                        return false;
+
+                    triggered_spell_id = 83154;
+                    break;
+                }
+                // Nether Vortex
+                case 86181:
+                case 86209:
+                {
+                    if (!procSpell || procSpell->Id != 30451)
+                        return false;
+
+                    Unit::AuraList& scAuras = GetSingleCastAuras();
+                    for (Unit::AuraList::iterator itr = scAuras.begin(); itr != scAuras.end();)
+                    {
+                        if ((*itr)->GetSpellInfo()->Id == 31589 && (*itr)->GetOwner() != victim)
+                            return false;
+                        else
+                            ++itr;
+                    }
+                    CastSpell(this, 86262, true);
+                    triggered_spell_id = 31589;
+                    break;
+                }
+                // Glyph of Polymorph
+                case 56375:
+                {
+                    if (!target)
+                        return false;
+                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE, 0, target->GetAura(32409)); // SW:D shall not be removed.
+                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE_PERCENT, 0, NULL, true, false);
+                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_LEECH);
+                    return true;
+                }
+                // Glyph of Icy Veins
+                case 56374:
+                {
+                    RemoveAurasByType(SPELL_AURA_HASTE_SPELLS, 0, 0, true, false);
+                    RemoveAurasByType(SPELL_AURA_MOD_DECREASE_SPEED);
+                    return true;
+                }
+                // Glyph of Ice Block
+                case 56372:
+                {
+                    Player* player = ToPlayer();
+                    if (!player)
+                        return false;
+
+                    // Remove Frost Nova cooldown
+                    player->RemoveSpellCooldown(122, true);
+                    break;
+                }
+                // Permafrost
+                case 11175:
+                case 12569:
+                case 12571:
+                {
+                    if (!GetGuardianPet())
+                        return false;
+
+                    // heal amount
+                    basepoints0 = CalculatePct(damage, triggerAmount);
+                    target = this;
+                    triggered_spell_id = 91394;
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            switch (dummySpell->Id)
+            {
+                // Glyph of Sunder Armor
+                case 58387:
+                {
+                    target = SelectNearbyTarget(victim);
+                    if (!target)
+                        return false;
+                    triggered_spell_id = 7386;
+                    break;
+                }
+                // Victorious
+                case 32216:
+                {
+                    RemoveAura(dummySpell->Id);
+                    return false;
+                }
+            }
+            // Second Wind
+            if (dummySpell->SpellIconID == 1697)
+            {
+                // only for spells and hit/crit (trigger start always) and not start from self casted spells (5530 Mace Stun Effect for example)
+                if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)))
+                    return false;
+                // Need stun or root mechanic
+                if (!(procSpell->GetAllEffectsMechanicMask() & ((1<<MECHANIC_ROOT)|(1<<MECHANIC_STUN))))
+                    return false;
+
+                switch (dummySpell->Id)
+                {
+                    case 29834:
+                        triggered_spell_id = 29841;
+                        break;
+                    case 29838:
+                        triggered_spell_id = 29842;
+                        break;
+                    default:
+                        sLog->outError(LOG_FILTER_UNITS, "Unit::HandleDummyAuraProc: non handled spell id: %u (SW)", dummySpell->Id);
+                    return false;
+                }
+
+                target = this;
+                break;
+            }
+            break;
+        }
+        case SPELLFAMILY_WARLOCK:
+        {
+            // Seed of Corruption
+            if (dummySpell->SpellFamilyFlags[1] & 0x00000010)
+            {
+                if (procSpell && procSpell->SpellFamilyFlags[1] & 0x8000)
+                    return false;
+                // if damage is more than need or target die from damage deal finish spell
+                if (triggeredByAura->GetAmount() <= int32(damage) || GetHealth() <= damage)
+                {
+                    // remember guid before aura delete
+                    uint64 casterGuid = triggeredByAura->GetCasterGUID();
+
+                    // Remove aura (before cast for prevent infinite loop handlers)
+                    RemoveAurasDueToSpell(triggeredByAura->GetId());
+
+                    uint32 spell = sSpellMgr->GetSpellWithRank(27285, dummySpell->GetRank());
+
+                    // Cast finish spell (triggeredByAura already not exist!)
+                    if (Unit* caster = GetUnit(*this, casterGuid))
+                        caster->CastSpell(this, spell, true, castItem, triggeredByAura);
+                    return true;                            // no hidden cooldown
+                }
+
+                // Damage counting
+                triggeredByAura->SetAmount(triggeredByAura->GetAmount() - damage);
+                return true;
+            }
+            // Seed of Corruption (Mobs cast) - no die req
+            if (dummySpell->SpellFamilyFlags.IsEqual(0, 0, 0) && dummySpell->SpellIconID == 1932)
+            {
+                // if damage is more than need deal finish spell
+                if (triggeredByAura->GetAmount() <= int32(damage))
+                {
+                    // remember guid before aura delete
+                    uint64 casterGuid = triggeredByAura->GetCasterGUID();
+
+                    // Remove aura (before cast for prevent infinite loop handlers)
+                    RemoveAurasDueToSpell(triggeredByAura->GetId());
+
+                    // Cast finish spell (triggeredByAura already not exist!)
+                    if (Unit* caster = GetUnit(*this, casterGuid))
+                        caster->CastSpell(this, 32865, true, castItem);
+                    return true;                            // no hidden cooldown
+                }
+                // Damage counting
+                triggeredByAura->SetAmount(triggeredByAura->GetAmount() - damage);
+                return true;
+            }
+            switch (dummySpell->Id)
+            {
+                case 85112: // Burning Embers
+                case 91986:
+                {
+                    if (!procSpell || !victim || effIndex != 0)
+                        return false;
+                    
+                    Unit* caster = this;
+                    if (isPet())
+                    {
+                        Pet* pet = ToCreature()->ToPet();
+                        if (pet->GetOwner())
+                            caster = pet->GetOwner();
+                    }
+                    triggered_spell_id = 85421;
+                    SpellInfo const* emberDot = sSpellMgr->GetSpellInfo(triggered_spell_id);
+                    basepoints0 = int32(CalculatePct(damage, triggerAmount) / emberDot->GetMaxTicks());
+                    basepoints0 += victim->GetRemainingPeriodicAmount(caster->GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);
+                    
+                    if (AuraEffect* aurEff = victim->GetAuraEffect(triggered_spell_id, 0, caster->GetGUID()))
+                    {
+                        basepoints0 = std::max(basepoints0, aurEff->GetAmount());
+                    }
+                    float multiplier = dummySpell->Id == 85112 ? 1.4f : 0.7f;
+                    int32 maxdamage = int32(caster->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_ALL) * multiplier + dummySpell->Effects[EFFECT_1].CalcValue(caster)) / emberDot->GetMaxTicks();
+                                                                                               
+                    basepoints0 = std::min(basepoints0, maxdamage);
+                    break;
+                }
+                // Glyph of Shadowflame
+                case 63310:
+                {
+                    triggered_spell_id = 63311;
+                    break;
+                }
+                // Nightfall
+                case 18094:
+                case 18095:
+                // Glyph of corruption
+                case 56218:
+                {
+                    target = this;
+                    triggered_spell_id = 17941;
+                    break;
+                }
+                // Shadowflame (Voidheart Raiment set bonus)
+                case 37377:
+                {
+                    triggered_spell_id = 37379;
+                    break;
+                }
+                // Pet Healing (Corruptor Raiment or Rift Stalker Armor)
+                case 37381:
+                {
+                    target = GetGuardianPet();
+                    if (!target)
+                        return false;
+
+                    // heal amount
+                    basepoints0 = CalculatePct(int32(damage), triggerAmount);
+                    triggered_spell_id = 37382;
+                    break;
+                }
+                // Shadowflame Hellfire (Voidheart Raiment set bonus)
+                case 39437:
+                {
+                    triggered_spell_id = 37378;
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_PRIEST:
+        {
+            // Vampiric Touch
+            if (dummySpell->SpellFamilyFlags[1] & 0x00000400)
+            {
+                if (!victim || !victim->isAlive())
+                    return false;
+
+                if (effIndex != 0)
+                    return false;
+
+                // victim is caster of aura
+                if (triggeredByAura->GetCasterGUID() != victim->GetGUID())
+                    return false;
+
+                // Energize 1% of max. mana
+                victim->CastSpell(victim, 57669, true, castItem, triggeredByAura);
+                return true;                                // no hidden cooldown
+            }
+            switch (dummySpell->Id)
+            {
+                case 77485: // Echo of light
+                {
+                    if (triggeredByAura->GetEffIndex() != EFFECT_0)
+                        return false;
+
+                    triggered_spell_id = 77489;
+                    SpellInfo const* trigger = sSpellMgr->GetSpellInfo(triggered_spell_id);
+                    if (!trigger)
+                        return false;
+                    basepoints0 = int32(CalculatePct(damage, triggerAmount) / (trigger->GetMaxDuration() / trigger->Effects[0].Amplitude));
+                    // Add remaining ticks to healing done
+                    basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_HEAL);
+                    break;
+                }
+                case 78202: // Shadowy Apparition
+                case 78203:
+                case 78204:
+                {
+                    if (!victim || !victim->isAlive() || this == victim || triggeredByAura->GetEffIndex() != 0)
+                        return false;
+
+                    int32 roll_chance = triggerAmount;
+                    if (isMoving())
+                        roll_chance = (roll_chance * dummySpell->Effects[EFFECT_1].BasePoints) / 3.0f;
+
+                    if (roll_chance_i(roll_chance))
+                    {
+                        triggered_spell_id = 87212;
+                        _procTargetGuid = victim->GetGUID();
+                    }
+                    break;
+                }
+                case 87099: // Sin and Punishment
+                case 87100:
+                {
+                    if (!ToPlayer())
+                        return false;
+
+                    int32 cooldown = 34433;
+                    Player* pl = ToPlayer();
+                    int32 reducedCooldown = 1000 * triggeredByAura->GetAmount();
+                    if (HasSpellCooldown(cooldown))
+                    {
+                        uint32 newCooldownDelay = pl->GetSpellCooldownDelay(cooldown);
+                        if (newCooldownDelay < uint32(reducedCooldown / 1000))
+                            newCooldownDelay = 0;
+                        else
+                            newCooldownDelay -= uint32(reducedCooldown / 1000);
+                        AddSpellCooldown(cooldown, 0, uint32(time(NULL) + newCooldownDelay));
+
+                        WorldPacket data(SMSG_MODIFY_COOLDOWN, 4+8+4);
+                        data << uint32(cooldown);               // Spell ID
+                        data << uint64(GetGUID());              // Player GUID
+                        data << int32(-reducedCooldown);        // Cooldown mod in milliseconds
+                        pl->GetSession()->SendPacket(&data);
+                    }
+                    return true;
+                }
+                case 81659: // Evangelism
+                case 81662:
+                {
+                    if (!procSpell)
+                        return false;
+
+                    uint32 spellId = 0;
+                    bool mindFlay = procSpell->Id == 15407;
+                    // Periodic damage from holy fire should not trigger evangelism
+                    if (procFlag & PROC_FLAG_DONE_PERIODIC && !mindFlay)
+                        return false;
+                    switch (triggeredByAura->GetId())
+                    {
+                        case 81659:
+                            spellId = mindFlay ? 87117 : 81660;
+                            break;
+                        case 81662:
+                            spellId = mindFlay ? 87118 : 81661;
+                            break;
+                    }
+                    CastSpell(target, spellId, true, castItem, triggeredByAura, originalCaster);
+                    // Archangel marker
+                    CastSpell(target, 87154, true, castItem, triggeredByAura, originalCaster);
+                    return true;
+                }
+                case 47509: // Divine Aegis
+                case 47511:
+                case 47515:
+                {
+                    if (!victim || !procSpell || (!(procEx & PROC_EX_CRITICAL_HIT) && procSpell->Id != 596))
+                        return false;
+
+                    int32 absorb = CalculatePct(int32(damage), triggeredByAura->GetAmount());
+                    // Shield discipline
+                    if (AuraEffect const* mastery = GetDummyAuraEffect(SPELLFAMILY_HUNTER, 566, EFFECT_0))
+                        AddPct(absorb, mastery->GetAmount());
+
+                    // Multiple effects stack, so let's try to find this aura.
+                    if (AuraEffect const* aegis = victim->GetAuraEffect(47753, EFFECT_0))
+                        absorb += aegis->GetAmount();
+
+                    absorb = std::min(absorb, int32(victim->CountPctFromMaxHealth(40)));
+                    basepoints0 = absorb;
+                    triggered_spell_id = 47753;
+                    break;
+                }
+                case 14523: // Atonement
+                case 81749:
+                {
+                    basepoints0 = damage * triggeredByAura->GetAmount() / 100.0f;
+                    if (procEx & PROC_EX_CRITICAL_HIT)
+                    {
+                        basepoints0 /= 2.0f;
+                        triggered_spell_id = 94472;
+                    }
+                    else
+                    {
+                        CustomSpellValues values;
+                        values.AddSpellMod(SPELLVALUE_RADIUS_MOD, 1500.0f);
+                        values.AddSpellMod(SPELLVALUE_BASE_POINT0, basepoints0);
+                        CastCustomSpell(81751, values, victim, TRIGGERED_FULL_MASK);
+                    }
+                    break;
+                }
+                case 92295: // Train of thought
+                case 92297:
+                {
+                    if (!ToPlayer() || (procSpell->Id != 2060 && procSpell->Id != 585))
+                        return false;
+
+                    int cooldowns[2] = {47540, 89485};
+                    int i = procSpell->Id == 2060 ? 1 : 0;
+                    uint32 multiplier = !i ? 100 : 1000;
+
+                    Player* pl = ToPlayer();
+                    int32 reducedCooldown = multiplier * triggeredByAura->GetAmount();
+                    if (HasSpellCooldown(cooldowns[i]))
+                    {
+                        uint32 newCooldownDelay = pl->GetSpellCooldownDelay(cooldowns[i]);
+                        if (newCooldownDelay < uint32(reducedCooldown / 1000))
+                            newCooldownDelay = 0;
+                        else
+                            newCooldownDelay -= uint32(reducedCooldown / 1000);
+                        AddSpellCooldown(cooldowns[i], 0, uint32(time(NULL) + newCooldownDelay));
+
+                        WorldPacket data(SMSG_MODIFY_COOLDOWN, 4+8+4);
+                        data << uint32(cooldowns[i]);           // Spell ID
+                        data << uint64(GetGUID());              // Player GUID
+                        data << int32(-reducedCooldown);        // Cooldown mod in milliseconds
+                        pl->GetSession()->SendPacket(&data);
+                    }
+                    return true;
+                }
+                // Vampiric Embrace
+                case 15286:
+                {
+                    if (!victim || !victim->isAlive() || procSpell->SpellFamilyFlags[1] & 0x80000)
+                        return false;
+
+                    // heal amount
+                    int32 self = CalculatePct(int32(damage), triggerAmount);
+                    int32 team = CalculatePct(int32(damage), triggerAmount / 2);
+                    CastCustomSpell(this, 15290, &team, &self, NULL, true, castItem, triggeredByAura);
+                    return true;                                // no hidden cooldown
+                }
+                // Priest Tier 6 Trinket (Ashtongue Talisman of Acumen)
+                case 40438:
+                {
+                    // Shadow Word: Pain
+                    if (procSpell->SpellFamilyFlags[0] & 0x8000)
+                        triggered_spell_id = 40441;
+                    // Renew
+                    else if (procSpell->SpellFamilyFlags[0] & 0x40)
+                        triggered_spell_id = 40440;
+                    else
+                        return false;
+
+                    target = this;
+                    break;
+                }
+                // Oracle Healing Bonus ("Garments of the Oracle" set)
+                case 26169:
+                {
+                    // heal amount
+                    basepoints0 = int32(CalculatePct(damage, 10));
+                    target = this;
+                    triggered_spell_id = 26170;
+                    break;
+                }
+                // Frozen Shadoweave (Shadow's Embrace set) warning! its not only priest set
+                case 39372:
+                {
+                    if (!procSpell || (procSpell->GetSchoolMask() & (SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_SHADOW)) == 0)
+                        return false;
+
+                    // heal amount
+                    basepoints0 = CalculatePct(int32(damage), triggerAmount);
+                    target = this;
+                    triggered_spell_id = 39373;
+                    break;
+                }
+                // Greater Heal (Vestments of Faith (Priest Tier 3) - 4 pieces bonus)
+                case 28809:
+                {
+                    triggered_spell_id = 28810;
+                    break;
+                }
+                // Priest T10 Healer 2P Bonus
+                case 70770:
+                    // Flash Heal
+                    if (procSpell->SpellFamilyFlags[0] & 0x800)
+                    {
+                        triggered_spell_id = 70772;
+                        SpellInfo const* blessHealing = sSpellMgr->GetSpellInfo(triggered_spell_id);
+                        if (!blessHealing)
+                            return false;
+                        basepoints0 = int32(CalculatePct(damage, triggerAmount) / (blessHealing->GetMaxDuration() / blessHealing->Effects[0].Amplitude));
+                    }
+                    break;
+                // Priest Shadow T12 2p bonus
+                case 99155:
+                {
+                    triggered_spell_id = 99156;
+                    target= victim;
+                    basepoints0 = damage * 0.2;
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_DRUID:
+        {
+            switch (dummySpell->Id)
+            {
+                // Glyph of Healing Touch
+                case 54825:
+                    if (Player* const player = ToPlayer())
+                        player->ModifySpellCooldown(17116, -(triggerAmount * IN_MILLISECONDS));
+                    break;
+                case 46832: // PvP 4 piece - Sudden Eclipse
+                {
+                    Player* caster = ToPlayer();
+                    if (!caster)
+                        return false;
+
+                    // No boomy, no deal.
+                    if (caster->GetPrimaryTalentTree(caster->GetActiveSpec()) != TALENT_TREE_DRUID_BALANCE)
+                        return false;
+
+                    // Can't proc when in eclipse state
+                    if (HasAura(48517) || HasAura(48518))
+                        return false;
+
+                    basepoints0 = GetPower(POWER_ECLIPSE) >= 0 ? triggeredByAura->GetSpellInfo()->Effects[EFFECT_0].BasePoints
+                        : -triggeredByAura->GetSpellInfo()->Effects[EFFECT_1].BasePoints;
+                    triggered_spell_id = 95746;
+                    break;
+                }
+                /*case 84840: // Vengeance
+                {
+                    if (!damage || !ToPlayer())
+                        return false;
+                    
+                    Aura* aur = GetAura(76691);
+                    if (!aur)
+                        aur = AddAura(76691,this);
+                    
+                    if (!aur)
+                        return false;
+                    uint32 amount = CalculatePct(damage, triggeredByAura->GetAmount());
+                    amount += aur->GetEffect(EFFECT_0)->GetAmount();
+                    uint32 maxAmount = 0;
+                    
+                    
+                    maxAmount = ToPlayer()->GetCreateHealth() * 0.1f + ToPlayer()->GetStat(STAT_STAMINA);
+                    amount = std::min(maxAmount, amount);
+                    
+                    aur->SetMaxDuration(30*IN_MILLISECONDS);
+                    aur->SetDuration(30*IN_MILLISECONDS);
+                    aur->GetEffect(EFFECT_0)->ChangeAmount(amount);
+                    aur->GetEffect(EFFECT_1)->ChangeAmount(amount);
+                    break;
+                }*/
+                case 17007: // Leader of the pack
+                {
+                    if (GetTypeId() != TYPEID_PLAYER || (GetShapeshiftForm() != FORM_CAT && GetShapeshiftForm() != FORM_BEAR))
+                        return false;
+
+                    // custom cooldown processing case
+                    if (cooldown && HasSpellCooldown(dummySpell->Id))
+                        return false;
+
+                    // Regenerate 8% mana
+                    basepoints0 = GetMaxPower(POWER_MANA) * (triggerAmount / 100.0f);
+                    CastCustomSpell(this, 68285, &basepoints0, NULL, NULL, true);
+                    // Regenerate 4% health
+                    if (AuraEffect* aurEff = GetAuraEffect(24932, EFFECT_1, GetGUID()))
+                    {
+                        basepoints0 = CountPctFromMaxHealth(aurEff->GetAmount());
+                        CastCustomSpell(this, 34299, &basepoints0, NULL, NULL, true);
+                    }
+                    // apply cooldown
+                    if (cooldown)
+                        ToPlayer()->AddSpellCooldown(dummySpell->Id, 0, time(NULL) + cooldown);
+                    return true;
+                }
+				// Nature's Ward
+				case 33881:                      // Rank 1
+				case 33882:                      // Rank 2
+				{
+					if (HealthAbovePct(50))
+						return false;
+
+						CastSpell(this, 45281, true);
+						CastSpell(this, 774, true);
+					break;
+				}
+                // Glyph of Bloodletting
+                case 54815:
+                {
+                    if (!target)
+                        return false;
+
+                    // try to find spell Rip on the target
+                    if (AuraEffect const* AurEff = target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00800000, 0x0, 0x0, GetGUID()))
+                    {
+                        // Rip's max duration, note: spells which modifies Rip's duration also counted
+                        uint32 CountMin = AurEff->GetBase()->GetMaxDuration();
+
+                        // just Rip's max duration without other spells
+                        uint32 CountMax = AurEff->GetSpellInfo()->GetMaxDuration();
+
+                        // add possible auras' and Glyph of Shred's max duration
+                        CountMax += 3 * triggerAmount * IN_MILLISECONDS;      // Glyph of Bloodletting        -> +6 seconds
+                        CountMax += HasAura(60141) ? 4 * IN_MILLISECONDS : 0; // Rip Duration/Lacerate Damage -> +4 seconds
+
+                        // if min < max -> that means caster didn't cast 3 shred yet
+                        // so set Rip's duration and max duration
+                        if (CountMin < CountMax)
+                        {
+                            AurEff->GetBase()->SetDuration(AurEff->GetBase()->GetDuration() + triggerAmount * IN_MILLISECONDS);
+                            AurEff->GetBase()->SetMaxDuration(CountMin + triggerAmount * IN_MILLISECONDS);
+                            return true;
+                        }
+                    }
+                    // if not found Rip
+                    return false;
+                }
+                // Healing Touch (Dreamwalker Raiment set)
+                case 28719:
+                {
+                    // mana back
+                    basepoints0 = int32(CalculatePct(procSpell->ManaCost, 30));
+                    target = this;
+                    triggered_spell_id = 28742;
+                    break;
+                }
+                // Healing Touch Refund (Idol of Longevity trinket)
+                case 28847:
+                {
+                    target = this;
+                    triggered_spell_id = 28848;
+                    break;
+                }
+                // Mana Restore (Malorne Raiment set / Malorne Regalia set)
+                case 37288:
+                case 37295:
+                {
+                    target = this;
+                    triggered_spell_id = 37238;
+                    break;
+                }
+                // Druid Tier 6 Trinket
+                case 40442:
+                {
+                    float  chance;
+
+                    // Starfire
+                    if (procSpell->SpellFamilyFlags[0] & 0x4)
+                    {
+                        triggered_spell_id = 40445;
+                        chance = 25.0f;
+                    }
+                    // Rejuvenation
+                    else if (procSpell->SpellFamilyFlags[0] & 0x10)
+                    {
+                        triggered_spell_id = 40446;
+                        chance = 25.0f;
+                    }
+                    // Mangle (Bear) and Mangle (Cat)
+                    else if (procSpell->SpellFamilyFlags[1] & 0x00000440)
+                    {
+                        triggered_spell_id = 40452;
+                        chance = 40.0f;
+                    }
+                    else
+                        return false;
+
+                    if (!roll_chance_f(chance))
+                        return false;
+
+                    target = this;
+                    break;
+                }
+                // Maim Interrupt
+                case 44835:
+                {
+                    // Deadly Interrupt Effect
+                    triggered_spell_id = 32747;
+                    break;
+                }
+                // Item - Druid T10 Balance 4P Bonus
+                case 70723:
+                {
+                    // Wrath & Starfire
+                    if ((procSpell->SpellFamilyFlags[0] & 0x5) && (procEx & PROC_EX_CRITICAL_HIT))
+                    {
+                        triggered_spell_id = 71023;
+                        SpellInfo const* triggeredSpell = sSpellMgr->GetSpellInfo(triggered_spell_id);
+                        if (!triggeredSpell)
+                            return false;
+                        basepoints0 = CalculatePct(int32(damage), triggerAmount) / (triggeredSpell->GetMaxDuration() / triggeredSpell->Effects[0].Amplitude);
+                        // Add remaining ticks to damage done
+                        basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);
+                    }
+                    break;
+                }
+                // Glyph of Starsurge
+                case 62971:
+                    if (Player* const caster = ToPlayer())
+                        caster->ModifySpellCooldown(48505, -(triggerAmount * IN_MILLISECONDS));
+                    return true;
+                // Item - Druid T10 Restoration 4P Bonus (Rejuvenation)
+                case 70664:
+                {
+                    // Proc only from normal Rejuvenation
+                    if (procSpell->SpellVisual[0] != 32)
+                        return false;
+
+                    Player* caster = ToPlayer();
+                    if (!caster)
+                        return false;
+                    if (!caster->GetGroup() && victim == this)
+                        return false;
+
+                    CastCustomSpell(70691, SPELLVALUE_BASE_POINT0, damage, victim, true);
+                    return true;
+                }
+                // Druid Feral T12 2p bonus
+                case 99001:
+                {
+                    triggered_spell_id = 99002;
+                    target = victim;
+                    basepoints0 = damage * 0.05f;
+                    break;
+                }
+                // Rogue T12 2p bonus (wrong dbc)
+                case 99174:
+                {
+                    triggered_spell_id = 99173;
+                    target= victim;
+                    basepoints0 = damage * 0.3f;
+                    if (victim->GetAura(99173, GetGUID()))
+                    {
+                        basepoints0 += (victim->GetRemainingPeriodicAmount(GetGUID(), 99173, SPELL_AURA_PERIODIC_DAMAGE));
+                    }
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_ROGUE:
+        {
+            switch (dummySpell->Id)
+            {
+                case 76838: // Strikes of opportunity
+                {
+                    if (triggeredByAura->GetEffIndex() != EFFECT_0 || !roll_chance_i(triggerAmount))
+                        return false;
+
+                    // Don't let it proc from sweeping strikes, causes a crash - #TODO: Confirm and generate crashlog
+                    if (procSpell && procSpell->Id == 26654)
+                        return false;
+
+                    // Do not proc from triggered spell
+                    if (procSpell && procSpell->Id == 76858)
+                        return false;
+
+                    triggered_spell_id = 76858;
+                    break;
+                }
+                case 76806: // Main Gauche
+                {
+                    if (triggeredByAura->GetEffIndex() != EFFECT_0 || !roll_chance_i(triggerAmount))
+                        return false;
+
+                    triggered_spell_id = 86392;
+                    break;
+                }
+                case 56805: // Glyph of kick
+                {
+                    if (!ToPlayer())
+                        return false;
+
+                    Player* pl = ToPlayer();
+                    int32 reducedCooldown = triggeredByAura->GetAmount();
+                    if (pl->HasSpellCooldown(1766))
+                    {
+                        uint32 newCooldownDelay = pl->GetSpellCooldownDelay(1766);
+                        if (newCooldownDelay < uint32(reducedCooldown / 1000))
+                            newCooldownDelay = 0;
+                        else
+                            newCooldownDelay -= uint32(reducedCooldown / 1000);
+
+                        pl->AddSpellCooldown(1766, 0, uint32(time(NULL) + newCooldownDelay));
+                        WorldPacket data(SMSG_MODIFY_COOLDOWN, 4+8+4);
+                        data << uint32(1766);                   // Spell ID
+                        data << uint64(GetGUID());              // Player GUID
+                        data << int32(-reducedCooldown);        // Cooldown mod in milliseconds
+                        pl->GetSession()->SendPacket(&data);
+                    }
+                    return true;
+                }
+                case 14168: // Improved Expose Armor
+                case 14169:
+                {
+                    if (!ToPlayer() || procSpell->Id != 8647)
+                        return false;
+
+                    basepoints0 = ToPlayer()->GetComboPoints();
+                    triggered_spell_id = 79128;
+                    break;
+                }
+                case 32748: // Deadly Throw Interrupt
+                {
+                    // Prevent cast Deadly Throw Interrupt on self from last effect (apply dummy) of Deadly Throw
+                    if (this == victim)
+                        return false;
+
+                    triggered_spell_id = 32747;
+                    break;
+                }
+                case 51698: // Honor Among thieves
+                case 51700:
+                case 51701:
+                {
+                    Unit* caster = triggeredByAura->GetBase()->GetCaster();
+                    if (!caster)
+                        return false;
+
+                    Unit* spellTarget = ObjectAccessor::GetUnit(*caster, caster->ToPlayer()->GetComboTarget());
+                    if (!spellTarget)
+                        spellTarget = caster->ToPlayer()->GetSelectedUnit();
+
+                    if (spellTarget && !spellTarget->IsFriendlyTo(caster))
+                        caster->CastSpell(spellTarget, 51699, true);
+
+                    return true;
+                }
+                case 79133: // Venomous Wounds
+                case 79134:
+                {
+                    Player* caster = ToPlayer();
+                    if (triggeredByAura->GetEffIndex() != EFFECT_1|| !caster
+                        || !target || !target->HasAuraWithDispelType(DISPEL_POISON, caster->GetGUID()))
+                        return false;
+
+                    int32 bp0 = triggeredByAura->GetAmount();
+                    caster->CastSpell(target, 79136, true);
+                    caster->CastCustomSpell(caster, 51637, &bp0, 0 , 0, true);
+                    return true;
+                }
+                case 14171: // Serrated Blades
+                case 14172:
+                {
+                    if (!ToPlayer() || !target || (procSpell && procSpell->Id != 2098))
+                        return false;
+
+                    Player* pl = ToPlayer();
+                    uint32 chance = pl->GetComboPoints() * triggerAmount;
+                    if (!roll_chance_i(chance))
+                        return false;
+
+                    if (AuraEffect const* aur = target->GetAuraEffect(1943, 0, GetGUID()))
+                    {
+                        aur->GetBase()->SetDuration(aur->GetBase()->GetMaxDuration(), true);
+                        return true;
+                    }
+                }
+                case 84652: // Bandit's guile
+                case 84653:
+                case 84654:
+                {
+                    // Don't proc anymore when we have the maximum benefit
+                    if (!target || HasAura(84747))
+                        return false;
+
+                    // Apply the counter / damage buff
+                    if (!target->HasAura(84748))
+                        CastSpell(target, 84748, true);
+
+                    AuraEffect* aur0 = target->GetAuraEffect(84748, EFFECT_0, GetGUID());
+                    if (AuraEffect* aur1 = target->GetAuraEffect(84748, EFFECT_1, GetGUID()))
+                    {
+                        aur1->SetAmount(aur1->GetAmount() + 1);
+                        uint8 stacks = aur1->GetAmount();
+                        switch (stacks)
+                        {
+                            case 4:
+                                aur1->GetBase()->RefreshDuration();
+                                CastSpell(this, 84745, true);
+                                aur0->SetAmount(10);
+                                break;
+                            case 8:
+                                RemoveAurasDueToSpell(84745);
+                                aur1->GetBase()->RefreshDuration();
+                                CastSpell(this, 84746, true);
+                                aur0->SetAmount(20);
+                                break;
+                            case 12:
+                                RemoveAurasDueToSpell(84746);
+                                aur1->GetBase()->RefreshDuration();
+                                CastSpell(this, 84747, true);
+                                aur0->SetAmount(30);
+                                break;
+                        }
+                    }
+                    return true;
+                }
+            }
+            switch (dummySpell->SpellIconID)
+            {
+                case 2909: // Cut to the Chase
+                {
+                    // "refresh your Slice and Dice duration to its 5 combo point maximum"
+                    // lookup Slice and Dice
+                    if (Aura* aur = GetAura(5171))
+                    {
+                        aur->SetDuration(aur->GetSpellInfo()->GetMaxDuration(), true);
+                        return true;
+                    }
+                    return false;
+                }
+                case 2963: // Deadly Brew
+                {
+                    triggered_spell_id = 3409;
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_HUNTER:
+        {
+            switch (dummySpell->Id)
+            {
+                case 3579: // Lock and Load
+                {
+                    // Proc only from periodic (from trap activation proc another aura of this spell)
+                    if (!(procFlag & PROC_FLAG_DONE_PERIODIC)
+                            || !roll_chance_i(triggerAmount)) return false;
+                    triggered_spell_id = 56453;
+                    target = this;
+                    break;
+                }
+                case 53480: // Roar of Sacrifice
+                {
+                    Unit* pet = triggeredByAura->GetCaster();
+                    if (!pet)
+                        return false;
+
+                    triggered_spell_id = 67481;
+                    basepoints0 = CalculatePct(damage + absorb, triggerAmount);
+                    target = pet;
+                    break;
+                }
+                case 76659: // Wild Quiver
+                {
+                    if (triggeredByAura->GetEffIndex() != EFFECT_0 || !roll_chance_i(triggerAmount))
+                        return false;
+
+                    triggered_spell_id = 76663;
+                    break;
+                }
+                case 56333: // T.N.T
+                case 56336:
+                {
+                    triggered_spell_id = 56453;
+                    break;
+                }
+                case 34497: // Thrill of the hunt
+                case 34498:
+                case 34499:
+                {
+                    int32 basepoints = procSpell->ManaCost * (triggeredByAura->GetAmount() / 100.0f);
+                    triggered_spell_id = 34720;
+                    break;
+                }
+                case 82897: // Resistance is futile
+                {
+                    if (!victim)
+                        return false;
+
+                    triggered_spell_id = 86316;
+                    break;
+                }
+                case 53241: // Marked for Death
+                case 53243:
+                {
+                    triggered_spell_id = 88691;
+                    break;
+                }
+                case 83356: // Sic 'em rank 2
+                {
+                    triggered_spell_id = 89388;
+                    break;
+                }
+                case 82898: // Crouching Tiger, Hidden Chimera
+                case 82899:
+                {
+                    if (!ToPlayer() || ToPlayer()->HasSpellCooldown(dummySpell->Id))
+                        return false;
+
+                    uint32 meleeProcMask = (PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK | PROC_FLAG_TAKEN_SPELL_MELEE_DMG_CLASS);
+                    uint32 rangedProcMask = (PROC_FLAG_TAKEN_RANGED_AUTO_ATTACK | PROC_FLAG_TAKEN_SPELL_RANGED_DMG_CLASS | PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_NEG);
+
+                    if (procFlag & meleeProcMask && triggeredByAura->GetEffIndex() != EFFECT_0 && !(procFlag & rangedProcMask))
+                        return false;
+                    else if (procFlag & rangedProcMask && triggeredByAura->GetEffIndex() != EFFECT_1 && !(procFlag & meleeProcMask))
+                        return false;
+
+                    Player* pl = ToPlayer();
+                    int32 reducedCooldown = triggeredByAura->GetAmount();
+                    uint32 cooldownSpell = triggeredByAura->GetEffIndex() == EFFECT_0 ? 781 : 19263;
+                    if (pl->HasSpellCooldown(cooldownSpell))
+                    {
+                        uint32 newCooldownDelay = pl->GetSpellCooldownDelay(cooldownSpell);
+                        if (newCooldownDelay < uint32(reducedCooldown / 1000))
+                            newCooldownDelay = 0;
+                        else
+                            newCooldownDelay -= uint32(reducedCooldown / 1000);
+                        pl->AddSpellCooldown(cooldownSpell, 0, uint32(time(NULL) + newCooldownDelay));
+                        WorldPacket data(SMSG_MODIFY_COOLDOWN, 4+8+4);
+                        data << uint32(cooldownSpell);           // Spell ID
+                        data << uint64(GetGUID());              // Player GUID
+                        data << int32(-reducedCooldown);        // Cooldown mod in milliseconds
+                        pl->GetSession()->SendPacket(&data);
+
+                        if (cooldown)
+                            pl->AddSpellCooldown(dummySpell->Id, 0, time(NULL) + cooldown);
+                    }
+                    return true;
+                }
+                case 82661: // Aspect of the fox
+                {
+                    basepoints0 = triggerAmount;
+                    if (AuraEffect* aur = GetDummyAuraEffect(SPELLFAMILY_HUNTER, 5080, EFFECT_1))
+                        basepoints0 += aur->GetAmount();
+                    triggered_spell_id = 82716;
+                    break;
+                }
+                case 94003: // Crit counter
+                {
+                    if (procSpell->Id != 83381 || !GetOwner())
+                        return false;
+
+                    // Count spell criticals in a row
+                    if (procEx & PROC_EX_CRITICAL_HIT)
+                    {
+                        triggeredByAura->SetAmount(triggeredByAura->GetAmount() + 1);
+                        if (triggeredByAura->GetAmount() < 2)
+                            return true;
+
+                        if (AuraEffect* killingStreak = GetOwner()->GetDummyAuraEffect(SPELLFAMILY_HUNTER, 4980, EFFECT_0))
+                        {
+                            uint32 spellId = killingStreak->GetId() == 82748 ? 94006 : 94007;
+                            // Crititcal counted -> roll chance
+                            GetOwner()->CastSpell(GetOwner(), spellId, true, castItem, triggeredByAura);
+                        }
+                    }
+                    triggeredByAura->SetAmount(0);
+                    return true;
+                }
+            }
+            switch (dummySpell->SpellIconID)
+            {
+                case 2236: // Thrill of the Hunt
+                {
+                    if (!procSpell)
+                        return false;
+
+
+                    basepoints0 = CalculatePct(procSpell->CalcPowerCost(this, SpellSchoolMask(procSpell->SchoolMask)), triggerAmount);
+
+                    if (basepoints0 <= 0)
+                        return false;
+
+                    target = this;
+                    triggered_spell_id = 34720;
+                    break;
+                }
+                case 3560: // Rapid Recuperation
+                {
+                    // This effect only from Rapid Killing (focus regen)
+                    if (!(procSpell->SpellFamilyFlags[1] & 0x01000000) || procSpell->Id ==77769)
+                        return false;
+
+                    target = this;
+                    triggered_spell_id = 58883;
+                    basepoints0 = CalculatePct(GetMaxPower(POWER_FOCUS), triggerAmount);
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            // Light's Beacon - Beacon of Light
+            if (dummySpell->Id == 53651)
+            {
+                // Victim is the caster in this case
+                if (!victim)
+                    return false;
+                Unit* target = this;
+                triggered_spell_id = 53652;
+                Unit* beaconTarget = NULL;
+                bool returnEarly = false;
+                if (GetTypeId() != TYPEID_PLAYER)
+                {
+                    target = victim->GetOwner();
+                    if (!target || target->GetTypeId() != TYPEID_PLAYER)
+                        return false;
+                }
+
+                if (Group* group = target->ToPlayer()->GetGroup())
+                {
+                    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        if (Player* member = itr->getSource())
+                        {
+                            // check if it was heal by paladin which casted this beacon of light
+                            if (member->GetAura(53563, victim->GetGUID()))
+                            {
+                                // do not proc when target of beacon of light is healed
+                                if (member == this)
+                                {
+                                    returnEarly = true;
+                                    break;
+                                }
+
+                                beaconTarget = member;
+                                basepoints0 = int32(damage);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                // Tower of Radiance
+                if (GetAura(53563, victim->GetGUID()))
+                    if (AuraEffect* aurEff = victim->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_PALADIN, 3402, EFFECT_1))
+                        if (roll_chance_i(aurEff->GetSpellInfo()->Effects[EFFECT_0].BasePoints))
+                            if (procSpell->Id == 19750 || procSpell->Id == 82326)
+                                victim->CastSpell(victim, 88852, true);
+
+                if (returnEarly)
+                    return false;
+
+                if (beaconTarget && IsWithinLOSInMap(beaconTarget))
+                {
+                    int32 percent = 0;
+                    switch (procSpell->Id)
+                    {
+                        case 85673: // Word of Glory
+                        case 20473: // Holy Shock
+                        case 19750: // Flash of Light
+                        case 82326: // Divine Light
+                        case 85222: // Light of Dawn
+                            percent = triggerAmount; // 50% heal from these spells
+                            break;
+                        case 635:   // Holy Light
+                            percent = triggerAmount * 2; // 100% heal from Holy Light
+                            break;
+                    }
+                    basepoints0 = CalculatePct(damage, percent);
+                    victim->CastCustomSpell(beaconTarget, triggered_spell_id, &basepoints0, NULL, NULL, true, 0, triggeredByAura, victim->GetGUID());
+                    return true;
+                }
+                return false;
+            }
+            switch (dummySpell->Id)
+            {
+				// Ancient Healer
+			    case 86674:
+			    {
+			        int32 bp0 = damage;
+			        int32 bp1 = CalculatePct(bp0, 10);
+			        if (!bp0 || !bp1 || !victim)
+			          return false;
+			        this->CastCustomSpell(victim, 86678, &bp0, &bp1, NULL, true, NULL, triggeredByAura);
+			        return true;
+			    
+			    }
+			    	// Ancient Crusader (guardian)
+			    case 86703:
+			    {
+			        if (Unit* owner = GetCharmerOrOwner())
+			        {
+			          owner->CastSpell(owner, 86700, true);
+			          return true;
+			        }
+			        break;
+			    }
+			    
+			    	// Ancient Crusader - Player
+			    case 86701:
+			    {
+			        target = this;
+			        triggered_spell_id = 86700;
+			        break;
+			    }
+                case 85803: // Selfless Healer
+                case 85804:
+                {
+                    if (this == victim || triggeredByAura->GetEffIndex() != EFFECT_1)
+                        return false;
+
+                    basepoints0 = triggerAmount * GetHolyPoints();
+                    break;
+                }
+                case 89901: // Judgements of the bold
+                {
+                    triggered_spell_id = 89906;
+                    basepoints0 = int32(CalculatePct(GetCreateMana(), triggerAmount)) / 10.0f;
+                    break;
+                }
+                case 31878: // Judgements of the wise
+                {
+                    triggered_spell_id = 31930;
+                    basepoints0 = int32(CalculatePct(GetCreateMana(), triggerAmount / 2)) / 10.0f;
+                    break;
+                }
+                case 76669: // Illuminated healing
+                {
+                    if (!victim || !damage || triggeredByAura->GetEffIndex() != EFFECT_0)
+                        return false;
+
+                    basepoints0 = CalculatePct(damage, triggerAmount);
+                    if (AuraEffect* absorb = victim->GetAuraEffect(86273, EFFECT_0, GetGUID()))
+                        basepoints0 += absorb->GetAmount();
+                    basepoints0 = std::min(basepoints0, int32(CountPctFromMaxHealth(33)));
+                    triggered_spell_id = 86273;
+                    break;
+                }
+                case 85495: // Speed of light
+                case 85498:
+                case 85499:
+                {
+                    basepoints0 = triggerAmount;
+                    triggered_spell_id = 85497;
+                    break;
+                }
+                // Sacred Shield
+                case 53601:
+                {
+                    if (procFlag & PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS)
+                        return false;
+
+                    if (damage > 0)
+                        triggered_spell_id = 58597;
+
+                    // Item - Paladin T8 Holy 4P Bonus
+                    if (Unit* caster = triggeredByAura->GetCaster())
+                        if (AuraEffect const* aurEff = caster->GetAuraEffect(64895, 0))
+                            cooldown = aurEff->GetAmount();
+
+                    target = this;
+                    break;
+                }
+                // Holy Power (Redemption Armor set)
+                case 28789:
+                {
+                    if (!victim)
+                        return false;
+
+                    // Set class defined buff
+                    switch (victim->getClass())
+                    {
+                        case CLASS_PALADIN:
+                        case CLASS_PRIEST:
+                        case CLASS_SHAMAN:
+                        case CLASS_DRUID:
+                            triggered_spell_id = 28795;     // Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.
+                            break;
+                        case CLASS_MAGE:
+                        case CLASS_WARLOCK:
+                            triggered_spell_id = 28793;     // Increases the friendly target's spell damage and healing by up to $s1 for $d.
+                            break;
+                        case CLASS_HUNTER:
+                        case CLASS_ROGUE:
+                            triggered_spell_id = 28791;     // Increases the friendly target's attack power by $s1 for $d.
+                            break;
+                        case CLASS_WARRIOR:
+                            triggered_spell_id = 28790;     // Increases the friendly target's armor
+                            break;
+                        default:
+                            return false;
+                    }
+                    break;
+                }
+                case 31801: // Seal of Truth
+                {
+                    // Only single-target spells
+                    if (effIndex != 0)
+                        return false;
+
+                    // At melee attack or Hammer of the Righteous spell damage considered as melee attack
+                    bool increaseStack = !procSpell || !procSpell->IsTargetingArea();
+                    triggered_spell_id = 31803;
+
+                    // On target with 5 stacks of Censure direct damage is done
+                    if (Aura* aur = victim->GetAura(triggered_spell_id, GetGUID()))
+                    {
+                        if (aur->GetStackAmount() == 5)
+                        {
+                            if (increaseStack)
+                                aur->RefreshDuration();
+                            CastSpell(victim, 42463, true);
+                            return true;
+                        }
+                    }
+
+                    if (!increaseStack)
+                        return false;
+                    break;
+                }
+                // Paladin Tier 6 Trinket (Ashtongue Talisman of Zeal)
+                case 40470:
+                {
+                    if (!procSpell)
+                        return false;
+
+                    float chance;
+
+                    // Flash of light/Holy light
+                    if (procSpell->SpellFamilyFlags[0] & 0xC0000000)
+                    {
+                        triggered_spell_id = 40471;
+                        chance = 15.0f;
+                    }
+                    // Judgement (any)
+                    else if (procSpell->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT)
+                    {
+                        triggered_spell_id = 40472;
+                        chance = 50.0f;
+                    }
+                    else
+                        return false;
+
+                    if (!roll_chance_f(chance))
+                        return false;
+
+                    break;
+                }
+                // Item - Paladin T8 Holy 2P Bonus
+                case 64890:
+                {
+                    triggered_spell_id = 64891;
+                    basepoints0 = triggerAmount * damage / 300;
+                    break;
+                }
+                case 71406: // Tiny Abomination in a Jar
+                case 71545: // Tiny Abomination in a Jar (Heroic)
+                {
+                    if (!victim || !victim->isAlive())
+                        return false;
+
+                    CastSpell(this, 71432, true, NULL, triggeredByAura);
+
+                    Aura const* dummy = GetAura(71432);
+                    if (!dummy || dummy->GetStackAmount() < (dummySpell->Id == 71406 ? 8 : 7))
+                        return false;
+
+                    RemoveAurasDueToSpell(71432);
+                    triggered_spell_id = 71433;  // default main hand attack
+                    // roll if offhand
+                    if (Player const* player = ToPlayer())
+                        if (player->GetWeaponForAttack(OFF_ATTACK, true) && urand(0, 1))
+                            triggered_spell_id = 71434;
+                    target = victim;
+                    break;
+                }
+                // Item - Icecrown 25 Normal Dagger Proc
+                case 71880:
+                {
+                    switch (getPowerType())
+                    {
+                        case POWER_MANA:
+                            triggered_spell_id = 71881;
+                            break;
+                        case POWER_RAGE:
+                            triggered_spell_id = 71883;
+                            break;
+                        case POWER_ENERGY:
+                            triggered_spell_id = 71882;
+                            break;
+                        case POWER_RUNIC_POWER:
+                            triggered_spell_id = 71884;
+                            break;
+                        default:
+                            return false;
+                    }
+                    break;
+                }
+                // Item - Icecrown 25 Heroic Dagger Proc
+                case 71892:
+                {
+                    switch (getPowerType())
+                    {
+                        case POWER_MANA:
+                            triggered_spell_id = 71888;
+                            break;
+                        case POWER_RAGE:
+                            triggered_spell_id = 71886;
+                            break;
+                        case POWER_ENERGY:
+                            triggered_spell_id = 71887;
+                            break;
+                        case POWER_RUNIC_POWER:
+                            triggered_spell_id = 71885;
+                            break;
+                        default:
+                            return false;
+                    }
+                    break;
+                }
+                case 99074: // Paladin Protection T12 2p bonus
+                {
+                    triggered_spell_id = 99075;
+                    target = victim;
+                    basepoints0 = damage * 0.2f;
+                    break;
+                }
+                case 99093: // Paladin Retribution T12 2p bonus
+                {
+                    triggered_spell_id = 99092;
+                    target = victim;
+                    basepoints0 = damage * 0.15f / 2;
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_SHAMAN:
+        {
+            switch (dummySpell->Id)
+            {
+                case 77222: // Elemental Overload
+                {
+                    if (triggeredByAura->GetEffIndex() != EFFECT_0 || !roll_chance_i(triggerAmount))
+                        return false;
+
+                    switch (procSpell->Id)
+                    {
+                        case 403:
+                            triggered_spell_id = 45284;
+                            break;
+                        case 421:
+                            triggered_spell_id = 45297;
+                            break;
+                        case 51505:
+                            triggered_spell_id = 77451;
+                            break;
+                    }
+                    break;
+                }
+                case 77755: // Lava Surge
+                case 77756:
+                {
+                    triggered_spell_id = 77762;
+                    break;
+                }
+                case 86183: // Feedback
+                case 86184:
+                case 86185:
+                {
+                    if (!ToPlayer())
+                        return false;
+
+                    Player* pl = ToPlayer();
+                    int32 reducedCooldown = -triggeredByAura->GetAmount();
+                    int32 cooldown = 16166;
+                    if (pl->HasSpellCooldown(cooldown))
+                    {
+                        uint32 newCooldownDelay = pl->GetSpellCooldownDelay(cooldown);
+                        if (newCooldownDelay < uint32(reducedCooldown / 1000))
+                            newCooldownDelay = 0;
+                        else
+                            newCooldownDelay -= uint32(reducedCooldown / 1000);
+                        pl->AddSpellCooldown(cooldown, 0, uint32(time(NULL) + newCooldownDelay));
+                        WorldPacket data(SMSG_MODIFY_COOLDOWN, 4+8+4);
+                        data << uint32(cooldown);               // Spell ID
+                        data << uint64(GetGUID());              // Player GUID
+                        data << int32(-reducedCooldown);        // Cooldown mod in milliseconds
+                        pl->GetSession()->SendPacket(&data);
+                    }
+                    return true;
+                }
+                case 16086: // Seasoned winds
+                case 16544:
+                {
+                    float multip = triggeredByAura->GetId() == 16086 ? 0.5f : 1.0f;
+                    uint8 level = getLevel();
+                    switch (interruptedSpell->SchoolMask)
+                    {
+                        case SPELL_SCHOOL_MASK_FIRE:
+                            triggered_spell_id = 97618;
+                            break;
+                        case SPELL_SCHOOL_MASK_NATURE:
+                            triggered_spell_id = 97620;
+                            break;
+                        case SPELL_SCHOOL_MASK_FROST:
+                            triggered_spell_id = 97619;
+                            break;
+                        case SPELL_SCHOOL_MASK_SHADOW:
+                            triggered_spell_id = 97622;
+                            break;
+                        case SPELL_SCHOOL_MASK_ARCANE:
+                            triggered_spell_id = 97621;
+                            break;
+                        default:
+                            return false;
+                    }
+                    if (level < 70)
+                        basepoints0 = level;
+                    else if (level < 80)
+                        basepoints0 = level + (level - 70) * 5;
+                    else
+                        basepoints0 = level + (level - 70) * 5 + (level - 80) * 7;
+                    basepoints0 *= multip;
+                    break;
+                }
+                case 974:   // Earth shield
+                {
+                    basepoints0 = triggeredByAura->GetAmount();
+                    triggered_spell_id = 379;
+                    break;
+                }
+                case 51562: // Tidal Waves
+                case 51563:
+                case 51564:
+                {
+                    basepoints0 = -triggerAmount;
+                    int32 basepoints1 = triggerAmount;
+                    CastCustomSpell(this, 53390, &basepoints0, &basepoints1, NULL, true);
+                    return true;
+                }
+                case 82984: // Telluric Currents
+                case 82988:
+                {
+                    basepoints0 = damage * (triggerAmount / 100.0f);
+                    triggered_spell_id = 82987;
+                    break;
+                }
+                case 16176: // Ancestral healing
+                case 16235:
+                {
+                    if (!victim || !procSpellIsHeal)
+                        return false;
+                    basepoints0 = damage * (triggeredByAura->GetAmount() / 100.0f);
+                    triggered_spell_id = 105284;
+                    uint32 maxHealth = victim->GetMaxHealth();
+                    // Check for already existing buff, use amount
+                    if (AuraEffect* aur = victim->GetAuraEffect(105284, EFFECT_0, GetGUID()))
+                    {
+                        basepoints0 += aur->GetAmount();
+                        maxHealth -= aur->GetAmount();
+                    }
+                    basepoints0 = std::min(basepoints0, int32(CalculatePct(maxHealth, 10)));
+                    break;
+                }
+                case 16180: // Resurgence
+                case 16196:
+                {
+                    if (!procSpell || !HasAura(52127))
+                        return false;
+
+                    SpellInfo const* triggerSpellinfo = sSpellMgr->GetSpellInfo(101033);
+                    float baseModifier = triggerAmount / 100.0f;
+                    float spellModifier = 1.0f;
+                    switch (procSpell->Id)
+                    {
+                        case 8004:  // Healing Surge
+                        case 61295: // Riptide
+                        case 73685: // Unleash Life
+                            spellModifier = 0.6f;
+                            break;
+                        case 1064: // Chain Heal
+                            spellModifier = 0.333f;
+                            break;
+                    }
+                    basepoints0 = triggerSpellinfo->Effects[EFFECT_0].CalcValue(this) * baseModifier * spellModifier;
+                    // Need to skip default calculation
+                    EnergizeBySpell(this, 101033, basepoints0, POWER_MANA);
+                    return true;
+                }
+                case 77794: // Focused Insight
+                case 77795:
+                case 77796:
+                {
+                    if (!victim || !procSpell || triggeredByAura->GetEffIndex() != EFFECT_0)
+                        return false;
+
+                    int32 bp0 = -CalculatePct(procSpell->CalcPowerCost(this, SpellSchoolMask(procSpell->SchoolMask)), triggerAmount);
+                    int32 bp1 = triggeredByAura->GetSpellInfo()->Effects[EFFECT_1].BasePoints;
+                    int32 bp2 = bp1;
+                    CastCustomSpell(this, 77800, &bp0, &bp1, &bp2, true);
+                    return true;
+                }
+                // Totemic Power (The Earthshatterer set)
+                case 28823:
+                {
+                    if (!victim)
+                        return false;
+
+                    // Set class defined buff
+                    switch (victim->getClass())
+                    {
+                        case CLASS_PALADIN:
+                        case CLASS_PRIEST:
+                        case CLASS_SHAMAN:
+                        case CLASS_DRUID:
+                            triggered_spell_id = 28824;     // Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.
+                            break;
+                        case CLASS_MAGE:
+                        case CLASS_WARLOCK:
+                            triggered_spell_id = 28825;     // Increases the friendly target's spell damage and healing by up to $s1 for $d.
+                            break;
+                        case CLASS_HUNTER:
+                        case CLASS_ROGUE:
+                            triggered_spell_id = 28826;     // Increases the friendly target's attack power by $s1 for $d.
+                            break;
+                        case CLASS_WARRIOR:
+                            triggered_spell_id = 28827;     // Increases the friendly target's armor
+                            break;
+                        default:
+                            return false;
+                    }
+                    break;
+                }
+                // Lesser Healing Wave (Totem of Flowing Water Relic)
+                case 28849:
+                {
+                    target = this;
+                    triggered_spell_id = 28850;
+                    break;
+                }
+                // Windfury Weapon (Passive) 1-8 Ranks
+                case 33757:
+                {
+                    Player* player = ToPlayer();
+                    if (!player || !castItem || !castItem->IsEquipped() || !victim || !victim->isAlive())
+                        return false;
+
+                    // custom cooldown processing case
+                    if (cooldown && player->HasSpellCooldown(dummySpell->Id))
+                        return false;
+
+                    if (triggeredByAura->GetBase() && castItem->GetGUID() != triggeredByAura->GetBase()->GetCastItemGUID())
+                        return false;
+
+                    WeaponAttackType attType = WeaponAttackType(player->GetAttackBySlot(castItem->GetSlot()));
+                    if ((attType != BASE_ATTACK && attType != OFF_ATTACK)
+                        || (attType == BASE_ATTACK && procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)
+                        || (attType == OFF_ATTACK && procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK))
+                         return false;
+
+                    // Now compute real proc chance...
+                    uint32 chance = 20;
+                    player->ApplySpellMod(dummySpell->Id, SPELLMOD_CHANCE_OF_SUCCESS, chance);
+
+                    Item* addWeapon = player->GetWeaponForAttack(attType == BASE_ATTACK ? OFF_ATTACK : BASE_ATTACK, true);
+                    uint32 enchant_id_add = addWeapon ? addWeapon->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)) : 0;
+                    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id_add);
+                    if (pEnchant && pEnchant->spellid[0] == dummySpell->Id)
+                        chance += 14;
+
+                    if (!roll_chance_i(chance))
+                        return false;
+
+                    // Now amount of extra power stored in 1 effect of Enchant spell
+                    uint32 spellId = 8232;
+                    SpellInfo const* windfurySpellInfo = sSpellMgr->GetSpellInfo(spellId);
+                    if (!windfurySpellInfo)
+                    {
+                        sLog->outError(LOG_FILTER_UNITS, "Unit::HandleDummyAuraProc: non-existing spell id: %u (Windfury)", spellId);
+                        return false;
+                    }
+
+                    int32 extra_attack_power = CalculateSpellDamage(victim, windfurySpellInfo, 1);
+
+                    // Value gained from additional AP
+                    basepoints0 = int32(extra_attack_power / 14.0f * GetAttackTime(attType) / 1000);
+
+                    if (procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK)
+                        triggered_spell_id = 25504;
+
+                    if (procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)
+                        triggered_spell_id = 33750;
+
+                    // apply cooldown before cast to prevent processing itself
+                    if (cooldown)
+                        player->AddSpellCooldown(dummySpell->Id, 0, time(NULL) + cooldown);
+
+                    // Attack three times
+                    for (uint32 i = 0; i < 3; ++i)
+                        CastCustomSpell(victim, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
+
+                    return true;
+                }
+                // Shaman Tier 6 Trinket
+                case 40463:
+                {
+                    if (!procSpell)
+                        return false;
+
+                    float chance;
+                    if (procSpell->SpellFamilyFlags[0] & 0x1)
+                    {
+                        triggered_spell_id = 40465;         // Lightning Bolt
+                        chance = 15.0f;
+                    }
+                    else if (procSpell->SpellFamilyFlags[0] & 0x80)
+                    {
+                        triggered_spell_id = 40465;         // Lesser Healing Wave
+                        chance = 10.0f;
+                    }
+                    else if (procSpell->SpellFamilyFlags[1] & 0x00000010)
+                    {
+                        triggered_spell_id = 40466;         // Stormstrike
+                        chance = 50.0f;
+                    }
+                    else
+                        return false;
+
+                    if (!roll_chance_f(chance))
+                        return false;
+
+                    target = this;
+                    break;
+                }
+                // Glyph of Healing Wave
+                case 55440:
+                {
+                    // Not proc from self heals
+                    if (this == victim)
+                        return false;
+                    basepoints0 = CalculatePct(int32(damage), triggerAmount);
+                    target = this;
+                    triggered_spell_id = 55533;
+                    break;
+                }
+                // Spirit Hunt
+                case 58877:
+                {
+                    damage += absorb;
+                    // Cast on owner
+                    target = GetOwner();
+                    if (!target)
+                        return false;
+                    basepoints0 = CalculatePct(int32(damage), triggerAmount);
+                    triggered_spell_id = 58879;
+                    // Cast on spirit wolf
+                    CastCustomSpell(this, triggered_spell_id, &basepoints0, NULL, NULL, true, NULL, triggeredByAura);
+                    break;
+                }
+                // Shaman T8 Elemental 4P Bonus
+                case 64928:
+                {
+                    basepoints0 = CalculatePct(int32(damage), triggerAmount);
+                    triggered_spell_id = 64930;            // Electrified
+                    break;
+                }
+                // Shaman T9 Elemental 4P Bonus
+                case 67228:
+                {
+                    // Lava Burst
+                    if (procSpell->SpellFamilyFlags[1] & 0x1000)
+                    {
+                        triggered_spell_id = 71824;
+                        SpellInfo const* triggeredSpell = sSpellMgr->GetSpellInfo(triggered_spell_id);
+                        if (!triggeredSpell)
+                            return false;
+                        basepoints0 = CalculatePct(int32(damage), triggerAmount) / (triggeredSpell->GetMaxDuration() / triggeredSpell->Effects[0].Amplitude);
+                    }
+                    break;
+                }
+                // Item - Shaman T10 Restoration 4P Bonus
+                case 70808:
+                {
+                    // Chain Heal
+                    if ((procSpell->SpellFamilyFlags[0] & 0x100) && (procEx & PROC_EX_CRITICAL_HIT))
+                    {
+                        triggered_spell_id = 70809;
+                        SpellInfo const* triggeredSpell = sSpellMgr->GetSpellInfo(triggered_spell_id);
+                        if (!triggeredSpell)
+                            return false;
+                        basepoints0 = CalculatePct(int32(damage), triggerAmount) / (triggeredSpell->GetMaxDuration() / triggeredSpell->Effects[0].Amplitude);
+                        // Add remaining ticks to healing done
+                        basepoints0 += GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_HEAL);
+                    }
+                    break;
+                }
+                // Item - Shaman T10 Elemental 2P Bonus
+                case 70811:
+                {
+                    // Lightning Bolt & Chain Lightning
+                    if (procSpell->SpellFamilyFlags[0] & 0x3)
+                    {
+                        if (ToPlayer()->HasSpellCooldown(16166))
+                        {
+                            uint32 newCooldownDelay = ToPlayer()->GetSpellCooldownDelay(16166);
+                            if (newCooldownDelay < 3)
+                                newCooldownDelay = 0;
+                            else
+                                newCooldownDelay -= 2;
+                            ToPlayer()->AddSpellCooldown(16166, 0, uint32(time(NULL) + newCooldownDelay));
+
+                            WorldPacket data(SMSG_MODIFY_COOLDOWN, 4+8+4);
+                            data << uint32(16166);                  // Spell ID
+                            data << uint64(GetGUID());              // Player GUID
+                            data << int32(-2000);                   // Cooldown mod in milliseconds
+                            ToPlayer()->GetSession()->SendPacket(&data);
+                            return true;
+                        }
+                    }
+                    return false;
+                }
+                // Item - Shaman T10 Elemental 4P Bonus
+                case 70817:
+                {
+                    if (!target)
+                        return false;
+                    // try to find spell Flame Shock on the target
+                    if (AuraEffect const* aurEff = target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, 0x10000000, 0x0, 0x0, GetGUID()))
+                    {
+                        Aura* flameShock  = aurEff->GetBase();
+                        int32 maxDuration = flameShock->GetMaxDuration();
+                        int32 newDuration = flameShock->GetDuration() + 2 * aurEff->GetAmplitude();
+
+                        flameShock->SetDuration(newDuration);
+                        // is it blizzlike to change max duration for FS?
+                        if (newDuration > maxDuration)
+                            flameShock->SetMaxDuration(newDuration);
+
+                        return true;
+                    }
+                    // if not found Flame Shock
+                    return false;
+                }
+                break;
+            }
+            // Ancestral Awakening
+            if (dummySpell->SpellIconID == 3065)
+            {
+                triggered_spell_id = 52759;
+                basepoints0 = CalculatePct(int32(damage), triggerAmount);
+                target = this;
+                break;
+            }
+            // Flametongue Weapon (Passive)
+            if (dummySpell->SpellFamilyFlags[0] & 0x200000)
+            {
+                if (GetTypeId() != TYPEID_PLAYER  || !victim || !victim->isAlive() || !castItem || !castItem->IsEquipped())
+                    return false;
+
+                WeaponAttackType attType = WeaponAttackType(Player::GetAttackBySlot(castItem->GetSlot()));
+                if ((attType != BASE_ATTACK && attType != OFF_ATTACK)
+                    || (attType == BASE_ATTACK && procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)
+                    || (attType == OFF_ATTACK && procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK))
+                    return false;
+
+                float fire_onhit = float(CalculatePct(dummySpell->Effects[EFFECT_0]. CalcValue(), 1.0f));
+
+                float add_spellpower = (float)(SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_FIRE)
+                                     + victim->SpellBaseDamageBonusTaken(SPELL_SCHOOL_MASK_FIRE));
+
+                // 1.3speed = 5%, 2.6speed = 10%, 4.0 speed = 15%, so, 1.0speed = 3.84%
+                ApplyPct(add_spellpower, 3.84f);
+
+                // Enchant on Off-Hand and ready?
+                if (castItem->GetSlot() == EQUIPMENT_SLOT_OFFHAND && procFlag & PROC_FLAG_DONE_OFFHAND_ATTACK)
+                {
+                    float BaseWeaponSpeed = GetAttackTime(OFF_ATTACK) / 1000.0f;
+
+                    // Value1: add the tooltip damage by swingspeed + Value2: add spelldmg by swingspeed
+                    basepoints0 = int32((fire_onhit * BaseWeaponSpeed) + (add_spellpower * BaseWeaponSpeed));
+                    triggered_spell_id = 10444;
+                }
+
+                // Enchant on Main-Hand and ready?
+                else if (castItem->GetSlot() == EQUIPMENT_SLOT_MAINHAND && procFlag & PROC_FLAG_DONE_MAINHAND_ATTACK)
+                {
+                    float BaseWeaponSpeed = GetAttackTime(BASE_ATTACK) / 1000.0f;
+
+                    // Value1: add the tooltip damage by swingspeed +  Value2: add spelldmg by swingspeed
+                    basepoints0 = int32((fire_onhit * BaseWeaponSpeed) + (add_spellpower * BaseWeaponSpeed));
+                    triggered_spell_id = 10444;
+                }
+
+                // If not ready, we should  return, shouldn't we?!
+                else
+                    return false;
+
+                CastCustomSpell(victim, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
+                return true;
+            }
+            // Static Shock
+            if (dummySpell->SpellIconID == 3059)
+            {
+                // Lightning Shield
+                if (GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_SHAMAN, 0x400, 0, 0))
+                {
+                    uint32 spell = 26364;
+
+                    // custom cooldown processing case
+                    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(spell))
+                        ToPlayer()->RemoveSpellCooldown(spell);
+
+                    CastSpell(target, spell, true, castItem, triggeredByAura);
+                    return true;
+                }
+                return false;
+            }
+            break;
+        }
+        case SPELLFAMILY_DEATHKNIGHT:
+        {
+            switch (dummySpell->Id)
+            {
+                case 77606: // Dark Simulacrum
+                {
+                    bool hasManaCost = procSpell->PowerType == POWER_MANA && (procSpell->ManaCost || procSpell->ManaCostPercentage);
+                    if (!procSpell || !hasManaCost || procSpell->DmgClass != SPELL_DAMAGE_CLASS_MAGIC || procSpell->HasEffect(SPELL_EFFECT_SUMMON) || procSpell->HasEffect(SPELL_EFFECT_SUMMON_PET)
+                        || (procSpell->Stances && !(procSpell->AttributesEx2 & SPELL_ATTR2_NOT_NEED_SHAPESHIFT)) || procSpell->HasAura(SPELL_AURA_MOD_SHAPESHIFT))
+                        return false;
+
+                    if (Unit* caster = triggeredByAura->GetCaster())
+                    {
+                        int32 bp0 = procSpell->Id;
+                        caster->CastCustomSpell(caster, 77616, &bp0, NULL, NULL, true);
+                        int32 spellPower = SpellBaseDamageBonusDone(SpellSchoolMask(procSpell->SchoolMask));
+                        int32 healPower = SpellBaseHealingBonusDone(SpellSchoolMask(procSpell->SchoolMask));
+                        // Spell needs to be an exact copy so we grant the dk the same amount of spellpower as the dk had
+                        caster->CastCustomSpell(caster, 94984, &spellPower, &healPower, NULL, true);
+                    }
+                    break;
+                }
+                case 51099: // Ebon Plaguebringer
+                case 51160:
+                {
+                    basepoints0 = triggeredByAura->GetAmount();
+                    triggered_spell_id = 65142;
+                    break;
+                }
+                case 81229: // Runic Empowerment
+                {
+                    Player* player = ToPlayer();
+                    if (!player || player->getClass() != CLASS_DEATH_KNIGHT)
+                        return false;
+
+                    // Runic Corruption
+                    if (AuraEffect* aur = player->GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 4068, EFFECT_0))
+                    {
+                        Aura* oldRc = player->GetAura(51460);
+                        int32 duration = oldRc ? oldRc->GetDuration() : 0;
+                        int32 basepoints0 = aur->GetAmount();
+                        player->CastCustomSpell(player, 51460, &basepoints0, NULL, NULL, true);
+                        if (oldRc)
+                        {
+                            if (Aura* newRc = player->GetAura(51460))
+                            {
+                                newRc->SetMaxDuration(duration + newRc->GetDuration());
+                                newRc->SetDuration(duration + newRc->GetDuration());
+                            }
+                        }
+                        return true;
+                    }
+
+                    uint32 runesOnCooldown = 0;
+                    uint32 cooldownRunes[MAX_RUNES];
+                    for (uint32 i = 0; i < MAX_RUNES; ++i)
+                        if (player->GetRuneCooldown(i))
+                        {
+                            cooldownRunes[runesOnCooldown] = player->GetBaseRune(i);
+                            runesOnCooldown++;
+                        }
+
+                    if (runesOnCooldown)
+                    {
+                        uint8 randomRune = urand(0, runesOnCooldown - 1);
+                        switch (cooldownRunes[randomRune])
+                        {
+                            case RUNE_BLOOD:
+                                triggered_spell_id = 81166;
+                                break;
+                            case RUNE_FROST:
+                                triggered_spell_id = 81168;
+                                break;
+                            case RUNE_UNHOLY:
+                                triggered_spell_id = 81169;
+                                break;
+                        }
+                    }
+                    break;
+                }
+            }
+            // Blood-Caked Blade
+            if (dummySpell->SpellIconID == 138)
+            {
+                if (!target || !target->isAlive())
+                    return false;
+
+                triggered_spell_id = dummySpell->Effects[effIndex].TriggerSpell;
+                break;
+            }
+            // Butchery
+            if (dummySpell->SpellIconID == 2664)
+            {
+                basepoints0 = triggerAmount;
+                triggered_spell_id = 50163;
+                target = this;
+                break;
+            }
+            // Dancing Rune Weapon
+            if (dummySpell->Id == 49028)
+            {
+                // 1 dummy aura for dismiss rune blade
+                if (effIndex != 1)
+                    return false;
+
+                Unit* pPet = NULL;
+                for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr) // Find Rune Weapon
+                    if ((*itr)->GetEntry() == 27893)
+                    {
+                        pPet = *itr;
+                        break;
+                    }
+
+                if (pPet && pPet->GetVictim() && damage && procSpell)
+                {
+                    pPet->CastSpell(pPet->GetVictim(), procSpell->Id, true);
+                    break;
+                }
+                else
+                    return false;
+            }
+            // Unholy Blight
+            if (dummySpell->Id == 49194)
+            {
+                triggered_spell_id = 50536;
+                SpellInfo const* unholyBlight = sSpellMgr->GetSpellInfo(triggered_spell_id);
+                if (!unholyBlight)
+                    return false;
+
+                basepoints0 = CalculatePct(int32(damage), triggerAmount);
+
+                //Glyph of Unholy Blight
+                if (AuraEffect* glyph=GetAuraEffect(63332, 0))
+                    AddPct(basepoints0, glyph->GetAmount());
+
+                basepoints0 = basepoints0 / (unholyBlight->GetMaxDuration() / unholyBlight->Effects[0].Amplitude);
+                basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), triggered_spell_id, SPELL_AURA_PERIODIC_DAMAGE);
+                break;
+            }
+            // Threat of Thassarian
+            if (dummySpell->SpellIconID == 2023)
+            {
+                // Must Dual Wield
+                if (!procSpell || !haveOffhandWeapon())
+                    return false;
+                // Chance as basepoints for dummy aura
+                if (!roll_chance_i(triggerAmount))
+                    return false;
+
+                switch (procSpell->Id)
+                {
+                    case 49020: triggered_spell_id = 66198; break; // Obliterate
+                    case 49143: triggered_spell_id = 66196; break; // Frost Strike
+                    case 45462: triggered_spell_id = 66216; break; // Plague Strike
+                    case 49998: triggered_spell_id = 66188; break; // Death Strike
+                    case 56815: triggered_spell_id = 66217; break; // Rune Strike
+                    case 45902: triggered_spell_id = 66215; break; // Blood Strike
+                    default:
+                        return false;
+                }
+                break;
+            }
+            // Runic Power Back on Snare/Root
+            if (dummySpell->Id == 61257)
+            {
+                // only for spells and hit/crit (trigger start always) and not start from self casted spells
+                if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == victim)
+                    return false;
+                // Need snare or root mechanic
+                if (!(procSpell->GetAllEffectsMechanicMask() & ((1<<MECHANIC_ROOT)|(1<<MECHANIC_SNARE))))
+                    return false;
+                triggered_spell_id = 61258;
+                target = this;
+                break;
+            }
+            break;
+        }
+        case SPELLFAMILY_POTION:
+        {
+            // alchemist's stone
+            if (dummySpell->Id == 17619)
+            {
+                if (procSpell->SpellFamilyName == SPELLFAMILY_POTION)
+                {
+                    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; i++)
+                    {
+                        if (procSpell->Effects[i].Effect == SPELL_EFFECT_HEAL)
+                        {
+                            triggered_spell_id = 21399;
+                        }
+                        else if (procSpell->Effects[i].Effect == SPELL_EFFECT_ENERGIZE)
+                        {
+                            triggered_spell_id = 21400;
+                        }
+                        else
+                            continue;
+
+                        basepoints0 = int32(CalculateSpellDamage(this, procSpell, i) * 0.4f);
+                        CastCustomSpell(this, triggered_spell_id, &basepoints0, NULL, NULL, true, NULL, triggeredByAura);
+                    }
+                    return true;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_PET:
+        {
+            switch (dummySpell->SpellIconID)
+            {
+                // Guard Dog
+                case 201:
+                {
+                    if (!victim)
+                        return false;
+
+                    triggered_spell_id = 54445;
+                    target = this;
+                    float addThreat = float(CalculatePct(procSpell->Effects[0].CalcValue(this), triggerAmount));
+                    victim->AddThreat(this, addThreat);
+                    break;
+                }
+                // Silverback
+                case 1582:
+                    triggered_spell_id = dummySpell->Id == 62765 ? 62801 : 62800;
+                    target = this;
+                    break;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    // if not handled by custom case, get triggered spell from dummySpell proto
+    if (!triggered_spell_id)
+        triggered_spell_id = dummySpell->Effects[triggeredByAura->GetEffIndex()].TriggerSpell;
+
+    // processed charge only counting case
+    if (!triggered_spell_id)
+        return true;
+
+    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);
+    if (!triggerEntry)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "Unit::HandleDummyAuraProc: Spell %u has non-existing triggered spell %u", dummySpell->Id, triggered_spell_id);
+        return false;
+    }
+
+    if (cooldown_spell_id == 0)
+        cooldown_spell_id = triggered_spell_id;
+
+    if (cooldown && HasSpellCooldown(cooldown_spell_id))
+        return false;
+
+    if (basepoints0)
+        CastCustomSpell(target, triggered_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura, originalCaster);
+    else
+        CastSpell(target, triggered_spell_id, true, castItem, triggeredByAura, originalCaster);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->AddSpellCooldown(cooldown_spell_id, 0, time(NULL) + cooldown);
+
+    return true;
+}
+
+    /*
+    */
+
+
+// Used in case when access to whole aura is needed
+// All procs should be handled like this...
+bool Unit::HandleAuraProc(Unit* victim, uint32 /*damage*/, Aura* triggeredByAura, SpellInfo const* procSpell, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown, bool * handled)
+{
+    SpellInfo const* dummySpell = triggeredByAura->GetSpellInfo();
+
+    switch (dummySpell->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+            switch (dummySpell->Id)
+            {
+                // Vital Spark
+                case 99262:
+                    if (victim && victim->HasAura(99252))
+                    {
+                        AddAura(99263,this);
+                        if (HasAura(99263))
+                        {
+                            GetAura(99263)->SetStackAmount(GetAura(99262)->GetStackAmount());
+                            GetAura(99263)->RefreshDuration();
+                        }
+                        RemoveAurasDueToSpell(99262);
+                    }
+                    break;
+                case 85768: // Dark intent on warlock
+                {
+                    *handled = true;
+                    Unit* target = NULL;
+                    int32 bp0 = triggeredByAura->GetSpellInfo()->Effects[EFFECT_0].BasePoints / 3;
+                    Unit::AuraList& scAuras = GetSingleCastAuras();
+                    // Find dark intent on linked target
+                    for (Unit::AuraList::iterator itr = scAuras.begin(); itr != scAuras.end(); itr++)
+                    {
+                        if ((*itr)->GetSpellInfo()->Id == 85767)
+                        {
+                            target = (*itr)->GetUnitOwner();
+                            break;
+                        }
+                    }
+                    if (!target)
+                        return false;
+
+                    CastCustomSpell(target, 85759, &bp0, NULL, NULL, true);
+                    return true;
+                }
+                // Nevermelting Ice Crystal
+                case 71564:
+                    RemoveAuraFromStack(71564);
+                    *handled = true;
+                    break;
+                // Gaseous Bloat
+                case 70672:
+                case 72455:
+                case 72832:
+                case 72833:
+                {
+                    *handled = true;
+                    uint32 stack = triggeredByAura->GetStackAmount();
+                    int32 const mod = (GetMap()->GetSpawnMode() & 1) ? 1500 : 1250;
+                    int32 dmg = 0;
+                    for (uint8 i = 1; i < stack; ++i)
+                        dmg += mod * stack;
+                    if (Unit* caster = triggeredByAura->GetCaster())
+                        caster->CastCustomSpell(70701, SPELLVALUE_BASE_POINT0, dmg);
+                    break;
+                }
+                // Ball of Flames Proc
+                case 71756:
+                case 72782:
+                case 72783:
+                case 72784:
+                    RemoveAuraFromStack(dummySpell->Id);
+                    *handled = true;
+                    break;
+                // Discerning Eye of the Beast
+                case 59915:
+                {
+                    CastSpell(this, 59914, true);   // 59914 already has correct basepoints in DBC, no need for custom bp
+                    *handled = true;
+                    break;
+                }
+                // Swift Hand of Justice
+                case 59906:
+                {
+                    int32 bp0 = CalculatePct(GetMaxHealth(), dummySpell->Effects[EFFECT_0]. CalcValue());
+                    CastCustomSpell(this, 59913, &bp0, NULL, NULL, true);
+                    *handled = true;
+                    break;
+                }
+            }
+            break;
+        case SPELLFAMILY_PALADIN:
+        {
+            switch (dummySpell->Id)
+            {
+                case 20066: // Repentance
+                {
+                    // Censure does not break repentance
+                    if (procSpell && procSpell->Id == 31803)
+                    {
+                        *handled = true;
+                        return false;
+                    }
+                    break;
+                }
+            }
+            // Judgements of the Just
+            if (dummySpell->SpellIconID == 3015)
+            {
+                *handled = true;
+                CastSpell(victim, 68055, true);
+                return true;
+            }
+            // Glyph of Divinity
+            else if (dummySpell->Id == 54939)
+            {
+                *handled = true;
+                // Check if we are the target and prevent mana gain
+                if (victim && triggeredByAura->GetCasterGUID() == victim->GetGUID())
+                    return false;
+                // Lookup base amount mana restore
+                for (uint8 i = 0; i < MAX_SPELL_EFFECTS; i++)
+                {
+                    if (procSpell->Effects[i].Effect == SPELL_EFFECT_ENERGIZE)
+                    {
+                        // value multiplied by 2 because you should get twice amount
+                        int32 mana = procSpell->Effects[i].CalcValue() * 2;
+                        CastCustomSpell(this, 54986, 0, &mana, NULL, true);
+                    }
+                }
+                return true;
+            }
+            break;
+        }
+        case SPELLFAMILY_DRUID:
+            // Item - Druid T11 Feral 4P Bonus
+            if (dummySpell->Id == 90165)
+            {
+                *handled = true;
+                CastSpell(this, 90166, true);
+                return true;
+            }
+            break;
+        case SPELLFAMILY_MAGE:
+        {
+            switch (dummySpell->Id)
+            {
+                case 31661: // Dragon's breath
+                {
+                    // Living bomb explosion doesn't break dragon's breath
+                    if (procSpell && procSpell->Id == 44461)
+                    {
+                        *handled = true;
+                        return false;
+                    }
+                    break;
+                }
+                // Empowered Fire
+                case 31656:
+                case 31657:
+                case 31658:
+                {
+                    *handled = true;
+
+                    SpellInfo const* spInfo = sSpellMgr->GetSpellInfo(67545);
+                    if (!spInfo)
+                        return false;
+
+                    int32 bp0 = int32(CalculatePct(GetCreateMana(), spInfo->Effects[0].CalcValue()));
+                    CastCustomSpell(this, 67545, &bp0, NULL, NULL, true, NULL, triggeredByAura->GetEffect(EFFECT_0), GetGUID());
+                    return true;
+                }
+                case 44544:
+                {
+                    *handled = true;
+                    RemoveAuraFromStack(44544);
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_PRIEST:
+        {
+            if (dummySpell->Id == 14751) // Chakra
+            {
+                switch (procSpell->Id)
+                {
+                    case 2050:  // Heal
+                    case 2060:  // Greater heal
+                    case 2061:  // Flash Heal
+                    case 32546: // Binding Heal
+                    {
+                        *handled = true;
+                        CastSpell(this, 81208, true);  // Chakra: Serenity
+                        return true;
+                    }
+                    case 33076: // Prayer of Mending
+                    case 596:   // Prayer of Healing
+                    {
+                        *handled = true;
+                        CastSpell(this, 81206, true);  // Chakra: Sanctuary
+                        return true;
+                    }
+                    case 585:   // Smite
+                    case 73510: // Mind Spike
+                    {
+                        *handled = true;
+                        CastSpell(this, 81209, true);  // Chakra: Chastise
+                        return true;
+                    }
+                    default:
+                        *handled = true;
+                        return false;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_WARLOCK:
+        {
+            switch (dummySpell->Id)
+            {
+                case 85767: // Dark intent on target
+                {
+                    *handled = true;
+                    Unit* target = triggeredByAura->GetCaster();
+                    int32 bp0 = triggeredByAura->GetSpellInfo()->Effects[EFFECT_0].BasePoints;
+                    if (!target)
+                        return false;
+
+                    CastCustomSpell(target, 85759, &bp0, NULL, NULL, true);
+                    return true;
+                }
+            }
+        }
+        case SPELLFAMILY_DEATHKNIGHT:
+        {
+            switch (dummySpell->Id)
+            {
+                case 56835: // Reaping
+                case 50034: // Blood Rites
+                {
+                    *handled = true;
+                    // Convert recently used Blood Rune to Death Rune
+                    if (Player* player = ToPlayer())
+                    {
+                        if (player->getClass() != CLASS_DEATH_KNIGHT)
+                            return false;
+
+                        AuraEffect* aurEff = triggeredByAura->GetEffect(EFFECT_0);
+                        if (!aurEff)
+                            return false;
+
+                    // Reset amplitude - set death rune remove timer to 30s
+					aurEff->ResetPeriodic(true);
+
+						for (uint8 i = 0; i < MAX_RUNES; ++i)
+                        {
+                            if (!(ToPlayer()->GetLastUsedRuneMask() & (1 << i)))
+                                continue;
+								
+							// Mark aura as used
+                            player->AddRuneByAuraEffect(i, RUNE_DEATH, aurEff, aurEff->GetAuraType(), aurEff->GetSpellInfo());
+                        }
+                        return true;
+                    }
+                    return false;
+                }
+
+                case 49588: // Unholy command
+                case 49589:
+                {
+                    *handled = true;
+                    if (ToPlayer())
+                        ToPlayer()->RemoveSpellCooldown(49576, true);
+                    break;
+                }
+                // Bone Shield cooldown
+                case 49222:
+                {
+                    *handled = true;
+                    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+                    {
+                        if (ToPlayer()->HasSpellCooldown(100000))
+                            return false;
+                        ToPlayer()->AddSpellCooldown(100000, 0, time(NULL) + cooldown);
+                    }
+                    return true;
+                }
+                // Hungering Cold aura drop
+                case 49203:
+                    // Drop only in not disease case
+                    if (procSpell && procSpell->Dispel == DISPEL_DISEASE)
+                        *handled = true;
+                    return false;
+            }
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            switch (dummySpell->Id)
+            {
+                // Item - Warrior T10 Protection 4P Bonus
+                case 70844:
+                {
+                    int32 basepoints0 = CalculatePct(GetMaxHealth(), dummySpell->Effects[EFFECT_1]. CalcValue());
+                    CastCustomSpell(this, 70845, &basepoints0, NULL, NULL, true);
+                    break;
+                }
+                // Recklessness
+                case 1719:
+                {
+                    //! Possible hack alert
+                    //! Don't drop charges on proc, they will be dropped on SpellMod removal
+                    //! Before this change, it was dropping two charges per attack, one in ProcDamageAndSpellFor, and one in RemoveSpellMods.
+                    //! The reason of this behaviour is Recklessness having three auras, 2 of them can not proc (isTriggeredAura array) but the other one can, making the whole spell proc.
+                    *handled = true;
+                    break;
+                }
+                default:
+                    break;
+            }
+            break;
+        }
+
+        case SPELLFAMILY_SHAMAN:
+        {
+            switch (dummySpell->Id)
+            {
+                // Shaman - Elemental T12 2p bonus
+                case 99204:
+                    if(Player* player = this->ToPlayer())
+                    {
+                        // this proc will reduce the fire elemental totem cooldown by 4 secs.
+                        if(player->HasSpellCooldown(2894))
+                        {
+                            player->ModifySpellCooldown(2894, -4000);
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+		case SPELLFAMILY_ROGUE:
+			switch (dummySpell->Id)
+			{
+				// Gouge
+			case 1776:
+				*handled = true;
+				// Check so gouge spell effect [1] (SPELL_EFFECT_SCHOOL_DAMAGE) cannot cancel stun effect
+				if (procSpell && procSpell->Id == 1776)
+					return false;
+				Unit* caster = triggeredByAura->GetCaster();
+				//rank2 Sanguinary Vein
+				if (caster->HasAura(79147) && procSpell)
+					switch (procSpell->Id){
+					case 89775: // Hemorrhage glyph bleed
+					case 703:   // Garrote bleed
+					case 1943:  // Rupture bleed
+						return false;
+						break;
+				}
+				//rank1 Sanguinary Vein
+				else if (caster->HasAura(79146) && procSpell)
+					switch (procSpell->Id){
+					case 89775: // Hemorrhage glyph bleed
+					case 703:   // Garrote bleed
+					case 1943:  // Rupture bleed
+						return roll_chance_i(50); // 50% chance to break
+						break;
+				}
+				return true;
+				break;
+			}
+			break;
+	}
+	return false;
+}
+
+bool Unit::HandleProcTriggerSpell(Unit* victim, uint32 damage, uint32 absorb, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlags, uint32 procEx, uint32 cooldown)
+{
+    // Get triggered aura spell info
+    SpellInfo const* auraSpellInfo = triggeredByAura->GetSpellInfo();
+
+    // Basepoints of trigger aura
+    int32 triggerAmount = triggeredByAura->GetAmount();
+    uint32 chance = triggeredByAura->GetSpellInfo()->ProcChance;
+
+    // Set trigger spell id, target, custom basepoints
+    uint32 trigger_spell_id = auraSpellInfo->Effects[triggeredByAura->GetEffIndex()].TriggerSpell;
+
+    Unit*  target = NULL;
+    int32  basepoints0 = 0;
+
+    if (triggeredByAura->GetAuraType() == SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE)
+        basepoints0 = triggerAmount;
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    // Try handle unknown trigger spells
+    //if (sSpellMgr->GetSpellInfo(trigger_spell_id) == NULL)
+    {
+        switch (auraSpellInfo->SpellFamilyName)
+        {
+            case SPELLFAMILY_GENERIC:
+                switch (auraSpellInfo->Id)
+                {
+                    // Elementium Shield Spike
+                    case 78835:
+                    case 92429:
+                        if(victim->GetTypeId() == TYPEID_PLAYER)
+                        {
+                            Player * player = victim->ToPlayer();
+
+                            if(player->HasSpellCooldown(trigger_spell_id))
+                                return false;
+                            else
+                                player->AddSpellCooldown(trigger_spell_id, 0, 1000);
+                        }
+                        break;
+                    case 86303: // Reactive Barrier
+                    case 86304:
+                        if (HealthBelowPctDamaged(50, damage))
+                        {
+                            if (!ToPlayer()->HasSpellCooldown(11426))
+                            {
+                                CastSpell(victim, 86347, true);
+                                CastSpell(victim, 11426, TRIGGERED_IGNORE_CAST_IN_PROGRESS);
+                            }
+                        }
+                        break;
+                    case 23780:             // Aegis of Preservation (Aegis of Preservation trinket)
+                        trigger_spell_id = 23781;
+                        break;
+                    case 33896:             // Desperate Defense (Stonescythe Whelp, Stonescythe Alpha, Stonescythe Ambusher)
+                        trigger_spell_id = 33898;
+                        break;
+                    case 43820:             // Charm of the Witch Doctor (Amani Charm of the Witch Doctor trinket)
+                        // Pct value stored in dummy
+                        basepoints0 = victim->GetCreateHealth() * auraSpellInfo->Effects[1].CalcValue() / 100;
+                        target = victim;
+                        break;
+                    case 79900: // Static Shock
+                        trigger_spell_id = 79911;
+                        break;
+                    case 80086: // Poison Bomb
+                        {
+                            if(GetTypeId() != TYPEID_UNIT)
+                                return false;
+                            CastSpell(this, 80089, true); // Slime Puddle
+                            CastSpell(this, 80092, true); // Explosion
+                            ToCreature()->DespawnOrUnsummon(100);
+                            return true;
+                        }
+                    break;
+                    case 57345:             // Darkmoon Card: Greatness
+                    {
+                        float stat = 0.0f;
+                        // strength
+                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 60229;stat = GetStat(STAT_STRENGTH); }
+                        // agility
+                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 60233;stat = GetStat(STAT_AGILITY);  }
+                        // intellect
+                        if (GetStat(STAT_INTELLECT)> stat) { trigger_spell_id = 60234;stat = GetStat(STAT_INTELLECT);}
+                        // spirit
+                        if (GetStat(STAT_SPIRIT)   > stat) { trigger_spell_id = 60235;                               }
+                        break;
+                    }
+                    case 64568:             // Blood Reserve
+                    {
+                        if (HealthBelowPctDamaged(35, damage))
+                        {
+                            CastCustomSpell(this, 64569, &triggerAmount, NULL, NULL, true);
+                            RemoveAura(64568);
+                        }
+                        return false;
+                    }
+                    case 67702:             // Death's Choice, Item - Coliseum 25 Normal Melee Trinket
+                    {
+                        float stat = 0.0f;
+                        // strength
+                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 67708;stat = GetStat(STAT_STRENGTH); }
+                        // agility
+                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 67703;                               }
+                        break;
+                    }
+                    case 67771:             // Death's Choice (heroic), Item - Coliseum 25 Heroic Melee Trinket
+                    {
+                        float stat = 0.0f;
+                        // strength
+                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 67773;stat = GetStat(STAT_STRENGTH); }
+                        // agility
+                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 67772;                               }
+                        break;
+                    }
+                    // Mana Drain Trigger
+                    case 27522:
+                    case 40336:
+                    {
+                        // On successful melee or ranged attack gain $29471s1 mana and if possible drain $27526s1 mana from the target.
+                        if (isAlive())
+                            CastSpell(this, 29471, true, castItem, triggeredByAura);
+                        if (victim && victim->isAlive())
+                            CastSpell(victim, 27526, true, castItem, triggeredByAura);
+                        return true;
+                    }
+                    // Evasive Maneuvers
+                    case 50240:
+                    {
+                        // Remove a Evasive Charge
+                        Aura* charge = GetAura(50241);
+                        if (charge && charge->ModStackAmount(-1, AURA_REMOVE_BY_ENEMY_SPELL))
+                            RemoveAurasDueToSpell(50240);
+                    }
+                    // Warrior - Vigilance, SPELLFAMILY_GENERIC
+                    if (auraSpellInfo->Id == 50720)
+                    {
+                        target = triggeredByAura->GetCaster();
+                        if (!target)
+                            return false;
+                    }
+                }
+                break;
+            case SPELLFAMILY_MAGE:
+                if (auraSpellInfo->SpellIconID == 2127)     // Blazing Speed
+                {
+                    switch (auraSpellInfo->Id)
+                    {
+                        case 31641:  // Rank 1
+                        case 31642:  // Rank 2
+                            trigger_spell_id = 31643;
+                            break;
+                        default:
+                            sLog->outError(LOG_FILTER_UNITS, "Unit::HandleProcTriggerSpell: Spell %u miss posibly Blazing Speed", auraSpellInfo->Id);
+                            return false;
+                    }
+                }
+                break;
+            case SPELLFAMILY_WARRIOR:
+                switch (auraSpellInfo->Id)
+                {
+                    case 50421: // Scent of Blood
+                    {
+                        CastSpell(this, 50422, true);
+                        RemoveAuraFromStack(auraSpellInfo->Id);
+                        return false;
+                    }
+                }
+                break;
+            case SPELLFAMILY_PRIEST:
+            {
+                // Greater Heal Refund
+                if (auraSpellInfo->Id == 37594)
+                    trigger_spell_id = 37595;
+                break;
+            }
+            case SPELLFAMILY_DRUID:
+            {
+                switch (auraSpellInfo->Id)
+                {
+                    // Druid Forms Trinket
+                    case 37336:
+                    {
+                        switch (GetShapeshiftForm())
+                        {
+                            case FORM_NONE:     trigger_spell_id = 37344; break;
+                            case FORM_CAT:      trigger_spell_id = 37341; break;
+                            case FORM_BEAR:     trigger_spell_id = 37340; break;
+                            case FORM_TREE:     trigger_spell_id = 37342; break;
+                            case FORM_MOONKIN:  trigger_spell_id = 37343; break;
+                            default:
+                                return false;
+                        }
+                        break;
+                    }
+                    // Druid T9 Feral Relic (Lacerate, Swipe, Mangle, and Shred)
+                    case 67353:
+                    {
+                        switch (GetShapeshiftForm())
+                        {
+                            case FORM_CAT:      trigger_spell_id = 67355; break;
+                            case FORM_BEAR:     trigger_spell_id = 67354; break;
+                            default:
+                                return false;
+                        }
+                        break;
+                    }
+                    default:
+                        break;
+                }
+                break;
+            }
+            case SPELLFAMILY_HUNTER:
+            {
+                if (auraSpellInfo->SpellIconID == 3247)     // Piercing Shots
+                {
+                    switch (auraSpellInfo->Id)
+                    {
+                        case 53234:  // Rank 1
+                        case 53237:  // Rank 2
+                        case 53238:  // Rank 3
+                            trigger_spell_id = 63468;
+                            break;
+                        default:
+                            sLog->outError(LOG_FILTER_UNITS, "Unit::HandleProcTriggerSpell: Spell %u miss posibly Piercing Shots", auraSpellInfo->Id);
+                            return false;
+                    }
+                    SpellInfo const* TriggerPS = sSpellMgr->GetSpellInfo(trigger_spell_id);
+                    if (!TriggerPS)
+                        return false;
+
+                    basepoints0 = CalculatePct(int32(damage), triggerAmount) / (TriggerPS->GetMaxDuration() / TriggerPS->Effects[0].Amplitude);
+                    basepoints0 += victim->GetRemainingPeriodicAmount(GetGUID(), trigger_spell_id, SPELL_AURA_PERIODIC_DAMAGE);
+                    break;
+                }
+                // Item - Hunter T9 4P Bonus
+                if (auraSpellInfo->Id == 67151)
+                {
+                    trigger_spell_id = 68130;
+                    target = this;
+                    break;
+                }
+                if (auraSpellInfo->SpellIconID == 3579) // Lock and Load
+                {
+                    if (procFlags & PROC_FLAG_DONE_PERIODIC)
+                    {
+                        int32 procchance = 0;
+                        if (AuraEffect* auEff = GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_HUNTER, 355, 0))
+                        {
+                            procchance = auEff->GetAmount();
+                            
+                        }
+                    if (!roll_chance_i(procchance))
+                        return false;
+                    }
+                break;
+                }
+            break;
+            }
+            case SPELLFAMILY_PALADIN:
+            {
+                switch (auraSpellInfo->Id)
+                {
+                    // Hand of Light
+                    case 76672:
+                    {
+                        // Energize effect of Crusader strike
+                        if (this == victim)
+                            return false;
+
+                        trigger_spell_id = 96172;
+                        basepoints0 = (damage + absorb) * triggeredByAura->GetAmount() / 100.0f;
+                        // Inquisition
+                        if (AuraEffect* aurEff = GetAuraEffect(84963, EFFECT_0))
+                            AddPct(basepoints0, aurEff->GetAmount());
+                        break;
+                    }
+                    case 85416: // Grand Crusader
+                    {
+                        if (procSpell && procSpell->Id != 31935)
+                            return false;
+                        break;
+                    }
+                    // Healing Discount
+                    case 37705:
+                    {
+                        trigger_spell_id = 37706;
+                        target = this;
+                        break;
+                    }
+                    // Soul Preserver
+                    case 60510:
+                    {
+                        switch (getClass())
+                        {
+                            case CLASS_DRUID:
+                                trigger_spell_id = 60512;
+                                break;
+                            case CLASS_PALADIN:
+                                trigger_spell_id = 60513;
+                                break;
+                            case CLASS_PRIEST:
+                                trigger_spell_id = 60514;
+                                break;
+                            case CLASS_SHAMAN:
+                                trigger_spell_id = 60515;
+                                break;
+                        }
+
+                        target = this;
+                        break;
+                    }
+                    case 37657: // Lightning Capacitor
+                    case 54841: // Thunder Capacitor
+                    case 67712: // Item - Coliseum 25 Normal Caster Trinket
+                    case 67758: // Item - Coliseum 25 Heroic Caster Trinket
+                    {
+                        if (!victim || !victim->isAlive() || GetTypeId() != TYPEID_PLAYER)
+                            return false;
+
+                        uint32 stack_spell_id = 0;
+                        switch (auraSpellInfo->Id)
+                        {
+                            case 37657:
+                                stack_spell_id = 37658;
+                                trigger_spell_id = 37661;
+                                break;
+                            case 54841:
+                                stack_spell_id = 54842;
+                                trigger_spell_id = 54843;
+                                break;
+                            case 67712:
+                                stack_spell_id = 67713;
+                                trigger_spell_id = 67714;
+                                break;
+                            case 67758:
+                                stack_spell_id = 67759;
+                                trigger_spell_id = 67760;
+                                break;
+                        }
+
+                        CastSpell(this, stack_spell_id, true, NULL, triggeredByAura);
+
+                        Aura* dummy = GetAura(stack_spell_id);
+                        if (!dummy || dummy->GetStackAmount() < triggerAmount)
+                            return false;
+
+                        RemoveAurasDueToSpell(stack_spell_id);
+                        target = victim;
+                        break;
+                    }
+                    default:
+                        break;
+                }
+                break;
+            }
+            case SPELLFAMILY_SHAMAN:
+            {
+                switch (auraSpellInfo->Id)
+                {
+                    // Lightning Shield (The Ten Storms set)
+                    case 23551:
+                    {
+                        trigger_spell_id = 23552;
+                        target = victim;
+                        break;
+                    }
+                    // Damage from Lightning Shield (The Ten Storms set)
+                    case 23552:
+                    {
+                        trigger_spell_id = 27635;
+                        break;
+                    }
+                    // Mana Surge (The Earthfury set)
+                    case 23572:
+                    {
+                        if (!procSpell)
+                            return false;
+                        basepoints0 = int32(CalculatePct(procSpell->ManaCost, 35));
+                        trigger_spell_id = 23571;
+                        target = this;
+                        break;
+                    }
+                    case 30881: // Nature's Guardian Rank 1
+                    case 30883: // Nature's Guardian Rank 2
+                    case 30884: // Nature's Guardian Rank 3
+                    {
+                        if (!HealthBelowPctDamaged(30, damage))
+                            return false;
+
+                        basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));
+                        target = this;
+                        trigger_spell_id = 31616;
+                        if (victim && victim->isAlive())
+                            victim->getThreatManager().modifyThreatPercent(this, -10);
+                        break;
+                    }
+                    // Shaman Resto T12 - 2P bonus
+                    case 99190:
+                    {
+                        trigger_spell_id = 99189;
+                        break;
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_DEATHKNIGHT:
+            {
+                // Item - Death Knight T10 Melee 4P Bonus
+                if (auraSpellInfo->Id == 70656)
+                {
+                    if (GetTypeId() != TYPEID_PLAYER || getClass() != CLASS_DEATH_KNIGHT)
+                        return false;
+
+                    for (uint8 i = 0; i < MAX_RUNES; ++i)
+                        if (ToPlayer()->GetRuneCooldown(i) == 0)
+                            return false;
+                }
+                break;
+            }
+            case SPELLFAMILY_ROGUE:
+            {
+                switch (auraSpellInfo->Id)
+                {
+                    // Rogue T10 2P bonus, should only proc on caster
+                    case 70805:
+                    {
+                        if (victim != this)
+                            return false;
+                        break;
+                    }
+                    // Rogue T10 4P bonus, should proc on victim
+                    case 70803:
+                    {
+                        target = victim;
+                        break;
+                    }
+                }
+                break;
+            }
+            default:
+                 break;
+        }
+    }
+
+    // All ok. Check current trigger spell
+    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(trigger_spell_id);
+    if (triggerEntry == NULL)
+    {
+        // Don't cast unknown spell
+        // sLog->outError(LOG_FILTER_UNITS, "Unit::HandleProcTriggerSpell: Spell %u has 0 in EffectTriggered[%d]. Unhandled custom case?", auraSpellInfo->Id, triggeredByAura->GetEffIndex());
+        return false;
+    }
+
+    // not allow proc extra attack spell at extra attack
+    if (m_extraAttacks && triggerEntry->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
+        return false;
+
+    // Custom requirements (not listed in procEx) Warning! damage dealing after this
+    // Custom triggered spells
+    switch (auraSpellInfo->Id)
+    {
+        // Shield Specialization
+        case 12298:
+        case 12724:
+        case 12725:
+            // If reflected, 4x more rage
+            if (procEx & PROC_EX_REFLECT)
+                if (SpellInfo const* const spellInfo = sSpellMgr->GetSpellInfo(trigger_spell_id))
+                    basepoints0 = spellInfo->Effects[EFFECT_0].BasePoints * 4;
+            target = this;
+            break;
+        // Item - Warrior T11 DPS 4P Bonus
+        case 90295:
+            if (!procSpell || (procSpell->Id != 7384 && procSpell->Id != 85288))
+                return false;
+            break;
+        case 71761: // Deep Freeze Immunity State
+        {
+            if (!procSpell || procSpell->Id != 44572)
+                return false;
+
+            // Deep Freeze should deal damage to permanently stun-immune targets.
+            if (victim->GetTypeId() != TYPEID_UNIT || !(victim->IsImmunedToSpellEffect(sSpellMgr->GetSpellInfo(44572), 0)))
+                return false;
+            break;
+        }
+        case 47516: // Grace
+        case 47517:
+        {
+            // Penance channel spell has same familymask as the actual heal
+            if (!procSpell || procSpell->Id == 47757)
+                return false;
+            break;
+        }
+        case 85126: // Seals of Command
+        {
+            if (!HasAuraState(AURA_STATE_JUDGEMENT))
+                return false;
+            break;
+        }
+        case 51682: // Savage combat
+        case 58413:
+        case 58410: // Master Poisoner
+        {
+            // Somehow someone managed to have both talents which are triggered by each other
+            // which resulted in an endless loop so prevent proc from anything else than poisons
+            if (!procSpell || procSpell->Dispel != DISPEL_POISON)
+                return false;
+            break;
+        }
+        // Glyph of Backstab
+        case 56800:
+        {
+            if (procSpell->Id != 53)
+                return false;
+            break;
+        }
+        case 20138: // Protector of the innocent
+        case 20139:
+        case 20140:
+        {
+            if (victim == this || (procSpell && procSpell->IsTargetingArea()))
+                return false;
+            break;
+        }
+        case 55666: // Desecration
+        case 55667:
+        {
+            if (!victim)
+                return false;
+            SpellInfo const* triggeredInfo = sSpellMgr->GetSpellInfo(triggeredByAura->GetSpellInfo()->Effects[EFFECT_0].TriggerSpell);
+            if (victim->IsImmunedToSpell(triggeredInfo))
+                return false;
+            break;
+        }
+        case 16176: // Ancestral Healing
+        case 16235:
+        {
+            // Two procEvents with different procEx conditions
+            if (!(procEx & PROC_EX_CRITICAL_HIT))
+                return false;
+            break;
+        }
+        case 88994: // masochism
+        case 88995:
+        {
+            damage += absorb;
+            if (damage < CountPctFromMaxHealth(10) && !(procSpell && procSpell->Id == 32409))
+                return false;
+            break;
+        }
+        case 80128: // Impending Victory
+        case 80129:
+        {
+            if (!victim->HealthBelowPctDamaged(20, damage))
+                return false;
+            basepoints0 = triggeredByAura->GetAmount();
+            break;
+        }
+        case 50685: // Incite
+        case 50686:
+        case 50687:
+        {
+            // Crits triggered by incite aren't supposed to re-trigger
+            if (HasAura(trigger_spell_id))
+                return false;
+            break;
+        }
+        case 20784: // Frenzy passive
+        {
+            basepoints0 = triggerAmount;
+            break;
+        }
+        case 45234: // Focused Will
+        case 45243:
+        {
+            if (damage < CountPctFromMaxHealth(10) && !(procEx & PROC_EX_CRITICAL_HIT))
+                return false;
+            break;
+        }
+        case 89488: // Strength of Soul
+        case 89489:
+        {
+            basepoints0 = triggerAmount;
+            break;
+        }
+        case 84583: //Lambs to the Slaughter
+        case 84587:
+        case 84588:
+        {
+            // Refresh Rend
+            if (victim)
+                if (Aura* aur = victim->GetAura(94009, GetGUID()))
+                    aur->SetDuration(aur->GetSpellInfo()->GetMaxDuration(), true);
+            break;
+        }
+        case 12834: // Deep Wounds
+        case 12849:
+        case 12867:
+        {
+            if (GetTypeId() != TYPEID_PLAYER)
+                return false;
+
+            // now compute approximate weapon damage by formula from wowwiki.com
+            Item* item = NULL;
+            if (procFlags & PROC_FLAG_DONE_OFFHAND_ATTACK)
+                item = ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+            else
+                item = ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+            // dunno if it's really needed but will prevent any possible crashes
+            if (!item)
+                return false;
+
+            ItemTemplate const* weapon = item->GetTemplate();
+
+            float weaponDPS = weapon->DPS;
+            float attackPower = GetTotalAttackPowerValue(BASE_ATTACK) / 14.0f;
+            float weaponSpeed = float(weapon->Delay) / 1000.0f;
+            basepoints0 = int32((weaponDPS + attackPower) * weaponSpeed);
+            break;
+        }
+        case 81913: // Die by the sword
+        case 81914:
+        {
+            if (!HealthBelowPctDamaged(20, damage))
+                return false;
+            break;
+        }
+        // Persistent Shield (Scarab Brooch trinket)
+        // This spell originally trigger 13567 - Dummy Trigger (vs dummy efect)
+        case 26467:
+        {
+            basepoints0 = int32(CalculatePct(damage, 15));
+            target = victim;
+            trigger_spell_id = 26470;
+            break;
+        }
+        // Unyielding Knights (item exploit 29108\29109)
+        case 38164:
+        {
+            if (!victim || victim->GetEntry() != 19457)  // Proc only if your target is Grillok
+                return false;
+            break;
+        }
+        // Deflection
+        case 52420:
+        {
+            if (!HealthBelowPctDamaged(35, damage))
+                return false;
+            break;
+        }
+
+        // Cheat Death
+        case 28845:
+        {
+            // When your health drops below 20%
+            if (HealthBelowPctDamaged(20, damage) || HealthBelowPct(20))
+                return false;
+            break;
+        }
+        // Greater Heal Refund (Avatar Raiment set)
+        case 37594:
+        {
+            if (!victim || !victim->isAlive())
+                return false;
+
+            // Doesn't proc if target already has full health
+            if (victim->IsFullHealth())
+                return false;
+            // If your Greater Heal brings the target to full health, you gain $37595s1 mana.
+            if (victim->GetHealth() + damage < victim->GetMaxHealth())
+                return false;
+            break;
+        }
+        // Bonus Healing (Crystal Spire of Karabor mace)
+        case 40971:
+        {
+            // If your target is below $s1% health
+            if (!victim || !victim->isAlive() || victim->HealthAbovePct(triggerAmount))
+                return false;
+            break;
+        }
+        // Rapid Recuperation
+        case 53228:
+        case 53232:
+        {
+            // This effect only from Rapid Fire (ability cast)
+            if (!(procSpell->SpellFamilyFlags[0] & 0x20))
+                return false;
+            break;
+        }
+        // Decimation
+        case 63156:
+        case 63158:
+            // Can proc only if target has hp below 25%
+            if (!victim || !victim->HealthBelowPct(auraSpellInfo->Effects[EFFECT_1].CalcValue()))
+                return false;
+            break;
+        // Deathbringer Saurfang - Blood Beast's Blood Link
+        case 72176:
+            basepoints0 = 3;
+            break;
+        // Professor Putricide - Ooze Spell Tank Protection
+        case 71770:
+            if (victim)
+                victim->CastSpell(victim, trigger_spell_id, true);    // EffectImplicitTarget is self
+            return true;
+        case 45057: // Evasive Maneuvers (Commendation of Kael`thas trinket)
+        case 71634: // Item - Icecrown 25 Normal Tank Trinket 1
+        case 71640: // Item - Icecrown 25 Heroic Tank Trinket 1
+        case 75475: // Item - Chamber of Aspects 25 Normal Tank Trinket
+        case 75481: // Item - Chamber of Aspects 25 Heroic Tank Trinket
+        {
+            // Procs only if damage takes health below $s1%
+            if (!HealthBelowPctDamaged(triggerAmount, damage))
+                return false;
+            break;
+        }
+		case 96947: // Loom of fate (for Spidersilk Spindle trinket http://www.wowhead.com/item=68981)
+		case 97130: // Loom of fate (for spidersilk Spindle trinket http://www.wowhead.com/item=69138)
+		{
+			// Procs only if damage takes health below 35%
+			if (!HealthBelowPctDamaged(35, damage) || HealthBelowPct(35))
+				return false;
+			break;
+		}
+        default:
+            break;
+    }
+
+    // Custom basepoints/target for exist spell
+    // dummy basepoints or other customs
+    switch (trigger_spell_id)
+    {
+        case 57761: // Brain Freeze
+        {
+            // Can not proc from frostfire bolt
+            if (!procSpell || procSpell->Id == 44614)
+                return false;
+            break;
+        }
+        case 30294: // Soul leech
+        {
+            int32 bp1 = basepoints0;
+            CastCustomSpell(this, trigger_spell_id, &basepoints0, &bp1, NULL, true);
+            CastSpell(this, 57669, true);
+            return true;
+        }
+        case 26364: // Lightning shield
+        {
+            // Custom cooldown handling because we have to return false so no charges are dropped
+            if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(trigger_spell_id))
+                return false;
+
+            bool customHandling = GetAuraEffect(100956, EFFECT_0) || GetAuraEffect(55448, EFFECT_0);
+            Aura* shield = triggeredByAura->GetBase();
+            uint8 maxCharges = 3;
+            // 4 piece PvP Bonus
+            if (AuraEffect* bonus = GetAuraEffect(100956, EFFECT_0))
+            {
+                // Rolling Thunder increases maximum charges of Lightning shield
+                if (AuraEffect* rollingThunder = GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_SHAMAN, 141, EFFECT_0))
+                    maxCharges = rollingThunder->GetAmount();
+                if (shield->GetCharges() < maxCharges)
+                {
+                    shield->SetCharges(shield->GetCharges() + 1);
+                    shield->RefreshDuration();
+                }
+            }
+
+            if (customHandling)
+            {
+                // try detect target manually if not set
+                target = !(procFlags & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && triggerEntry && triggerEntry->IsPositive() ? this : victim;
+                CastSpell(target, trigger_spell_id, true, castItem, triggeredByAura);
+
+                // If we don't have the set bonus, drop a charge
+                if (!GetAuraEffect(100956, EFFECT_0) && shield->GetCharges() > maxCharges)
+                    shield->DropCharge();
+
+                if (cooldown && GetTypeId() == TYPEID_PLAYER)
+                    ToPlayer()->AddSpellCooldown(trigger_spell_id, 0, time(NULL) + cooldown);
+
+                return false;
+            }
+            break;
+        }
+        case 96263: // Sacred Shield
+        {
+            if (!HealthBelowPctDamaged(30, damage))
+                return false;
+            break;
+        }
+        case 93400: // Shooting stars
+        {
+            if (GetTypeId() != TYPEID_PLAYER)
+                return false;
+
+            // remove starsurge cooldown
+            ToPlayer()->RemoveSpellCooldown(78674, true);
+            break;
+        }
+        case 85416: // Grand Crusader
+        {
+            // remove Avangers Shield cooldown
+            ToPlayer()->RemoveSpellCooldown(31935, true);
+            break;
+        }
+        case 81262: // Efflorescence
+        {
+            int32 basepoints1 = damage * (triggerAmount / 100.0f);
+            CastCustomSpell(victim, trigger_spell_id, NULL, &basepoints1, NULL, true);
+            return true;
+        }
+        case 81141: // Crimson Scourge
+        {
+            if (!victim || !victim->HasAura(55078))
+                return false;
+            break;
+        }
+        case 81162: // Will of the necropolis
+        {
+            if (GetTypeId() != TYPEID_PLAYER || GetHealthPct() > 30.0f)
+                return false;
+
+            if (cooldown && ToPlayer()->HasSpellCooldown(trigger_spell_id))
+                return false;
+
+            CastSpell(this, 96171, true);
+            ToPlayer()->RemoveSpellCooldown(48982, true);
+            break;
+        }
+        case 91342: // Shadow Infusion
+        {
+            // Don't proc from dummy spell
+            if (!procSpell || GetTypeId() != TYPEID_PLAYER || procSpell->Id == 47541)
+                return false;
+
+            if (Pet* pet = ToPlayer()->GetPet())
+            {
+                // No procs when in Dark transformation
+                if (pet->HasAura(63560))
+                    return false;
+
+                if (Aura* Infusion = pet->GetAura(91342, GetGUID()))
+                {
+                    uint8 stacks = Infusion->GetStackAmount();
+                    if (++stacks == Infusion->GetSpellInfo()->StackAmount)
+                        CastSpell(this, 93426, true);
+                }
+            }
+            else
+                return false;
+            break;
+        }
+        case 81340: // Sudden Doom
+        {
+            if (procFlags & PROC_FLAG_DONE_OFFHAND_ATTACK)
+                return false;
+            break;
+        }
+        case 96268: // Death's advance
+        {
+            Player* player = ToPlayer();
+            if (!player)
+                return false;
+
+            uint8 unholyRunesOnCooldown = 0;
+            for (uint32 i = 2; i < 4; ++i)
+                if (player->GetRuneCooldown(i))
+                    unholyRunesOnCooldown++;
+            if (unholyRunesOnCooldown < 2)
+                return false;
+            break;
+        }
+        case 88765: // Rolling Thunder
+        {
+            Aura* lShield = GetAura(324, GetGUID());
+            // Lava burst is contained in the procmask
+            if (!lShield || !procSpell || procSpell->Id == 77451)
+                return false;
+
+            uint8 charges = lShield->GetCharges();
+            if (charges < 9)
+            {
+                lShield->SetCharges(++charges);
+                lShield->RefreshDuration();
+                if (lShield->GetCharges() == 9)
+                    CastSpell(this, 95774, true);
+            }
+            break;
+        }
+        // Auras which should proc on area aura source (caster in this case):
+        // Cast positive spell on enemy target
+        case 7099:  // Curse of Mending
+        case 39703: // Curse of Mending
+        case 29494: // Temptation
+        case 20233: // Improved Lay on Hands (cast on target)
+        {
+            target = victim;
+            break;
+        }
+        // Finish movies that add combo
+        case 14189: // Seal Fate (Netherblade set)
+        case 14157: // Ruthlessness
+        {
+            if (!victim || victim == this)
+                return false;
+            // Need add combopoint AFTER finish movie (or they dropped in finish phase)
+            break;
+        }
+        case 84590: // Deadly momentum
+        {
+            // Refresh Slice and dice
+            if (AuraEffect const* aur = GetAuraEffect(5171, 0, GetGUID()))
+                aur->GetBase()->SetDuration(aur->GetBase()->GetMaxDuration(), true);
+
+            // Refresh Recuperate
+            if (AuraEffect const* aur = GetAuraEffect(73651, 0, GetGUID()))
+                aur->GetBase()->SetDuration(aur->GetBase()->GetMaxDuration(), true);
+
+            break;
+        }
+        // Impact proc
+        case 64343:
+        {
+            ToPlayer()->RemoveSpellCooldown(2136, true);
+            break;
+        }
+        // Item - Druid T10 Balance 2P Bonus
+        case 16870:
+        {
+            if (HasAura(70718))
+                CastSpell(this, 70721, true);
+            break;
+        }
+        // Enlightenment (trigger only from mana cost spells)
+        case 35095:
+        {
+            if (!procSpell || procSpell->PowerType != POWER_MANA || (procSpell->ManaCost == 0 && procSpell->ManaCostPercentage == 0 && procSpell->ManaCostPerlevel == 0))
+                return false;
+            break;
+        }
+        case 46916:  // Slam! (Bloodsurge proc)
+        case 52437:  // Sudden Death
+        {
+            // Item - Warrior T10 Melee 4P Bonus
+            if (AuraEffect const* aurEff = GetAuraEffect(70847, 0))
+            {
+                if (!roll_chance_i(aurEff->GetAmount()))
+                    break;
+                CastSpell(this, 70849, true, castItem, triggeredByAura); // Extra Charge!
+                CastSpell(this, 71072, true, castItem, triggeredByAura); // Slam GCD Reduced
+                CastSpell(this, 71069, true, castItem, triggeredByAura); // Execute GCD Reduced
+            }
+            break;
+        }
+        // Sword and Board
+        case 50227:
+        {
+            // Remove cooldown on Shield Slam
+            if (GetTypeId() == TYPEID_PLAYER)
+                ToPlayer()->RemoveSpellCooldown(23922, true);
+            break;
+        }
+        // Maelstrom Weapon
+        case 53817:
+        {
+            // Item - Shaman T10 Enhancement 4P Bonus
+            if (AuraEffect const* aurEff = GetAuraEffect(70832, 0))
+                if (Aura const* maelstrom = GetAura(53817))
+                    if ((maelstrom->GetStackAmount() == maelstrom->GetSpellInfo()->StackAmount - 1) && roll_chance_i(aurEff->GetAmount()))
+                        CastSpell(this, 70831, true, castItem, triggeredByAura);
+            break;
+        }
+        // Glyph of Death's Embrace
+        case 58679:
+        {
+            // Proc only when used on summons
+            if (!victim || !victim->isSummon())
+                return false;
+            break;
+        }
+        // Glyph of Death Grip
+        case 58628:
+        {
+            // remove cooldown of Death Grip
+            if (GetTypeId() == TYPEID_PLAYER)
+                ToPlayer()->RemoveSpellCooldown(49576, true);
+            return true;
+        }
+        // Savage Defense
+        case 62606:
+        {
+            basepoints0 = CalculatePct(triggerAmount, GetTotalAttackPowerValue(BASE_ATTACK));
+            // Savage defender mastery
+            if (AuraEffect* mastery = GetDummyAuraEffect(SPELLFAMILY_HUNTER, 146, EFFECT_0))
+                AddPct(basepoints0, mastery->GetAmount());
+            break;
+        }
+        // Chakra: Serenity should proc only on direct heals
+        case 81208:
+        {
+            for (uint32 i = 0; i < MAX_SPELL_EFFECTS; i++)
+            {
+                if (procSpell->Effects[i].Effect == SPELL_EFFECT_HEAL)
+                    return true;
+            }
+            return false;
+        }	
+        // Culling the Herd
+        case 70893:
+        {
+            // check if we're doing a critical hit
+            if (!(procSpell->SpellFamilyFlags[1] & 0x10000000) && (procEx != PROC_EX_CRITICAL_HIT))
+                return false;
+            // check if we're procced by Claw, Bite or Smack (need to use the spell icon ID to detect it)
+            if (!(procSpell->SpellIconID == 262 || procSpell->SpellIconID == 1680 || procSpell->SpellIconID == 473))
+                return false;
+            break;
+        }
+        // Shadow's Fate (Shadowmourne questline)
+        case 71169:
+        {
+            // Victim needs more checks so bugs, rats or summons can not be affected by the proc.
+            if (GetTypeId() != TYPEID_PLAYER || !victim || victim->GetTypeId() != TYPEID_UNIT || victim->GetCreatureType() == CREATURE_TYPE_CRITTER)
+                return false;
+
+            Player* player = ToPlayer();
+            if (player->GetQuestStatus(24547) == QUEST_STATUS_INCOMPLETE)
+            {
+                break;
+            }
+            else if (player->GetDifficulty(true) == RAID_DIFFICULTY_25MAN_NORMAL || player->GetDifficulty(true) == RAID_DIFFICULTY_25MAN_HEROIC)
+            {
+                uint32 spellId = 0;
+                uint32 questId = 0;
+                switch (victim->GetEntry())
+                {
+                    case 36678:             // NPC:     Professor Putricide
+                        questId = 24749;    // Quest:   Unholy Infusion
+                        spellId = 71516;    // Spell:   Shadow Infusion
+                        break;
+                    case 37955:             // NPC:     Blood-Queen Lana'thel
+                        questId = 24756;    // Quest:   Blood Infusion
+                        spellId = 72154;    // Spell:   Thirst Quenched
+                        break;
+                    case 36853:             // NPC:     Sindragosa
+                        questId = 24757;    // Quest:   Frost Infusion
+                        spellId = 72290;    // Spell:   Frost-Imbued Blade
+                        break;
+                    default:
+                        return false;
+                }
+
+                if (player->GetQuestStatus(questId) != QUEST_STATUS_INCOMPLETE || !player->HasAura(spellId))
+                    return false;
+
+                break;
+            }
+            else
+                return false;
+        }
+    }
+
+    if (cooldown && ToPlayer()->HasSpellCooldown(trigger_spell_id))
+        return false;
+
+    // try detect target manually if not set
+    if (target == NULL)
+        target = !(procFlags & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && triggerEntry && triggerEntry->IsPositive() ? this : victim;
+
+    if (basepoints0)
+        CastCustomSpell(target, trigger_spell_id, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
+    else
+        CastSpell(target, trigger_spell_id, true, castItem, triggeredByAura);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->AddSpellCooldown(trigger_spell_id, 0, time(NULL) + cooldown);
+
+    return true;
+}
+
+bool Unit::HandleOverrideClassScriptAuraProc(Unit* victim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellInfo const* /*procSpell*/, uint32 cooldown)
+{
+    int32 scriptId = triggeredByAura->GetMiscValue();
+
+    if (!victim || !victim->isAlive())
+        return false;
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    uint32 triggered_spell_id = 0;
+
+    switch (scriptId)
+    {
+        case 4533:                                          // Dreamwalker Raiment 2 pieces bonus
+        {
+            // Chance 50%
+            if (!roll_chance_i(50))
+                return false;
+
+            switch (victim->getPowerType())
+            {
+                case POWER_MANA:   triggered_spell_id = 28722; break;
+                case POWER_RAGE:   triggered_spell_id = 28723; break;
+                case POWER_ENERGY: triggered_spell_id = 28724; break;
+                default:
+                    return false;
+            }
+            break;
+        }
+        case 4537:                                          // Dreamwalker Raiment 6 pieces bonus
+            triggered_spell_id = 28750;                     // Blessing of the Claw
+            break;
+        default:
+            break;
+    }
+
+    // not processed
+    if (!triggered_spell_id)
+        return false;
+
+    // standard non-dummy case
+    SpellInfo const* triggerEntry = sSpellMgr->GetSpellInfo(triggered_spell_id);
+
+    if (!triggerEntry)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "Unit::HandleOverrideClassScriptAuraProc: Spell %u triggering for class script id %u", triggered_spell_id, scriptId);
+        return false;
+    }
+
+    if (cooldown && HasSpellCooldown(triggered_spell_id))
+        return false;
+
+    CastSpell(victim, triggered_spell_id, true, castItem, triggeredByAura);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->AddSpellCooldown(triggered_spell_id, 0, time(NULL) + cooldown);
+
+    return true;
+}
+
+void Unit::SetAltPower(int32 power)
+{
+    alt = power;
+
+    if (HasAura(93103)) // Corruption Cho'gall. - Finished.
+    {
+        if (alt >= 25 && !HasAura(81836))
+           AddAura(81836, ToPlayer());
+        
+        if (alt >= 50 && !HasAura(81829))
+           AddAura(81829, ToPlayer());
+        
+        if (alt >= 75 && !HasAura(82125))
+        {
+           AddAura(82125, ToPlayer());
+           AddAura(82167, ToPlayer());
+           Creature* malformation = ToPlayer()->SummonCreature(43888, ToPlayer()->GetPositionX(), ToPlayer()->GetPositionY(), ToPlayer()->GetPositionZ(), ToPlayer()->GetOrientation(), TEMPSUMMON_MANUAL_DESPAWN);
+           malformation->CastSpell(ToPlayer(), 46598, true);
+        }
+
+        if (alt >= 100 && !HasAura(82193))
+        {
+            AddAura(82193, ToPlayer());
+            AddAura(82170, ToPlayer());
+        }
+    }
+    else if (HasAura(78949)) //Electricity Onyxia. - Finished.
+    {
+        if (alt >= 100)
+            CastSpell(ToUnit(), 78999, true);
+    }
+    else if (HasAura(88824)) //Sound Atramedes. - Finished.
+    {
+        if (alt >= 100)
+            CastSpell(ToPlayer(), 102133, true);
+    }
+    else if (HasAura(98229)) //Concentration Majordomo HC. - LOADING BAR NOT DONE.
+    {
+        if (alt >= 25 && !HasAura(98254))
+           AddAura(98254, ToPlayer());
+        
+        if (alt >= 50 && !HasAura(98253))
+        {
+           AddAura(98253, ToPlayer());
+           ToPlayer()->RemoveAurasDueToSpell(98254, true);
+        }
+        
+        if (alt >= 75 && !HasAura(98252))
+        {
+           AddAura(98252, ToPlayer());
+           RemoveAurasDueToSpell(98253, true);
+        }
+        
+        if (alt >= 100 && !HasAura(98245))
+        {
+           AddAura(98245, ToPlayer());
+           ToPlayer()->RemoveAurasDueToSpell(98252, true);
+        }
+    }
+    else if (HasAura(101410)) // Molten Feathers Alysrazor
+    {
+        if (alt >= 3)
+        {
+           CastSpell(ToUnit(), 98624, true);
+           alt = 0;
+           ToUnit()->SetPower(POWER_ALTERNATE_POWER, 0);
+           AddAura(101410, ToPlayer());
+        }
+    }
+
+    if (alt < 0)
+        alt = 0;
+
+    if (alt > 100)
+        alt = 100;
+
+
+    WorldPacket data(SMSG_POWER_UPDATE);
+    data.append(GetPackGUID());
+    data << int32(1);
+    data << int8(POWER_ALTERNATE_POWER);
+    data << int32(alt);
+    SendMessageToSet(&data, GetTypeId() == TYPEID_PLAYER ? true : false);
+}
+
+void Unit::setPowerType(Powers new_powertype)
+{
+    SetByteValue(UNIT_FIELD_BYTES_0, 3, new_powertype);
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (ToPlayer()->GetGroup())
+            ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POWER_TYPE);
+    }
+    else if (Pet* pet = ToCreature()->ToPet())
+    {
+        if (pet->isControlled())
+        {
+            Unit* owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_POWER_TYPE);
+        }
+    }
+
+    switch (new_powertype)
+    {
+        default:
+        case POWER_MANA:
+            break;
+        case POWER_RAGE:
+            SetMaxPower(POWER_RAGE, GetCreatePowers(POWER_RAGE));
+            SetPower(POWER_RAGE, 0);
+            break;
+        case POWER_FOCUS:
+            SetMaxPower(POWER_FOCUS, GetCreatePowers(POWER_FOCUS));
+            SetPower(POWER_FOCUS, GetCreatePowers(POWER_FOCUS));
+            break;
+        case POWER_ENERGY:
+            SetMaxPower(POWER_ENERGY, GetCreatePowers(POWER_ENERGY));
+            break;
+    }
+}
+
+FactionTemplateEntry const* Unit::getFactionTemplateEntry() const
+{
+    FactionTemplateEntry const* entry = sFactionTemplateStore.LookupEntry(getFaction());
+    if (!entry)
+    {
+        static uint64 guid = 0;                             // prevent repeating spam same faction problem
+
+        if (GetGUID() != guid)
+        {
+            if (Player const* player = ToPlayer())
+                sLog->outError(LOG_FILTER_UNITS, "Player %s has invalid faction (faction template id) #%u", player->GetName().c_str(), getFaction());
+            else if (Creature const* creature = ToCreature())
+                sLog->outError(LOG_FILTER_UNITS, "Creature (template id: %u) has invalid faction (faction template id) #%u", creature->GetCreatureTemplate()->Entry, getFaction());
+            else
+                sLog->outError(LOG_FILTER_UNITS, "Unit (name=%s, type=%u) has invalid faction (faction template id) #%u", GetName().c_str(), uint32(GetTypeId()), getFaction());
+
+            guid = GetGUID();
+        }
+    }
+    return entry;
+}
+
+
+
+// function based on function Unit::UnitReaction from 13850 client
+ReputationRank Unit::GetReactionTo(Unit const* target) const
+{
+    // always friendly to self
+    if (this == target)
+        return REP_FRIENDLY;
+
+    // always friendly to charmer or owner
+    if (GetCharmerOrOwnerOrSelf() == target->GetCharmerOrOwnerOrSelf())
+        return REP_FRIENDLY;
+
+    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
+    {
+        if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
+        {
+            Player const* selfPlayerOwner = GetAffectingPlayer();
+            Player const* targetPlayerOwner = target->GetAffectingPlayer();
+
+            if (selfPlayerOwner && targetPlayerOwner)
+            {
+                // always friendly to other unit controlled by player, or to the player himself
+                if (selfPlayerOwner == targetPlayerOwner)
+                    return REP_FRIENDLY;
+
+                // duel - always hostile to opponent
+                if (selfPlayerOwner->duel && selfPlayerOwner->duel->opponent == targetPlayerOwner && selfPlayerOwner->duel->startTime != 0)
+                    return REP_HOSTILE;
+
+                // same group - checks dependant only on our faction - skip FFA_PVP for example
+                if (selfPlayerOwner->IsInRaidWith(targetPlayerOwner))
+                    return REP_FRIENDLY; // return true to allow config option AllowTwoSide.Interaction.Group to work
+                    // however client seems to allow mixed group parties, because in 13850 client it works like:
+                    // return GetFactionReactionTo(getFactionTemplateEntry(), target);
+            }
+
+            // check FFA_PVP
+            if (GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP
+                && target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP)
+                return REP_HOSTILE;
+
+            if (selfPlayerOwner)
+            {
+                if (FactionTemplateEntry const* targetFactionTemplateEntry = target->getFactionTemplateEntry())
+                {
+                    if (ReputationRank const* repRank = selfPlayerOwner->GetReputationMgr().GetForcedRankIfAny(targetFactionTemplateEntry))
+                        return *repRank;
+                    if (!selfPlayerOwner->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_IGNORE_REPUTATION))
+                    {
+                        if (FactionEntry const* targetFactionEntry = sFactionStore.LookupEntry(targetFactionTemplateEntry->faction))
+                        {
+                            if (targetFactionEntry->CanHaveReputation())
+                            {
+                                // check contested flags
+                                if (targetFactionTemplateEntry->factionFlags & FACTION_TEMPLATE_FLAG_CONTESTED_GUARD
+                                    && selfPlayerOwner->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP))
+                                    return REP_HOSTILE;
+
+                                // if faction has reputation, hostile state depends only from AtWar state
+                                if (selfPlayerOwner->GetReputationMgr().IsAtWar(targetFactionEntry))
+                                    return REP_HOSTILE;
+                                return REP_FRIENDLY;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    // do checks dependant only on our faction
+    return GetFactionReactionTo(getFactionTemplateEntry(), target);
+}
+
+ReputationRank Unit::GetFactionReactionTo(FactionTemplateEntry const* factionTemplateEntry, Unit const* target)
+{
+	// always neutral when no template entry found
+	if (!factionTemplateEntry)
+		return REP_NEUTRAL;
+
+	FactionTemplateEntry const* targetFactionTemplateEntry = target->getFactionTemplateEntry();
+	if (!targetFactionTemplateEntry)
+		return REP_NEUTRAL;
+
+	if (Player const* targetPlayerOwner = target->GetAffectingPlayer())
+	{
+		// check contested flags
+		if (factionTemplateEntry->factionFlags & FACTION_TEMPLATE_FLAG_CONTESTED_GUARD
+			&& targetPlayerOwner->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP))
+			return REP_HOSTILE;
+		if (ReputationRank const* repRank = targetPlayerOwner->GetReputationMgr().GetForcedRankIfAny(factionTemplateEntry))
+			return *repRank;
+		if (!target->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_IGNORE_REPUTATION))
+		{
+			if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(factionTemplateEntry->faction))
+			{
+				if (factionEntry->CanHaveReputation())
+				{
+					// CvP case - check reputation, don't allow state higher than neutral when at war
+					ReputationRank repRank = targetPlayerOwner->GetReputationMgr().GetRank(factionEntry);
+					if (targetPlayerOwner->GetReputationMgr().IsAtWar(factionEntry))
+						repRank = std::min(REP_NEUTRAL, repRank);
+					return repRank;
+				}
+			}
+		}
+	}
+
+	// common faction based check
+	if (factionTemplateEntry->IsHostileTo(*targetFactionTemplateEntry))
+		return REP_HOSTILE;
+	if (factionTemplateEntry->IsFriendlyTo(*targetFactionTemplateEntry))
+		return REP_FRIENDLY;
+	if (targetFactionTemplateEntry->IsFriendlyTo(*factionTemplateEntry))
+		return REP_FRIENDLY;
+	if (factionTemplateEntry->factionFlags & FACTION_TEMPLATE_FLAG_HOSTILE_BY_DEFAULT)
+		return REP_HOSTILE;
+	// neutral by default
+	return REP_NEUTRAL;
+}
+
+bool Unit::IsHostileTo(Unit const* unit) const
+{
+    return GetReactionTo(unit) <= REP_HOSTILE;
+}
+
+bool Unit::IsFriendlyTo(Unit const* unit) const
+{
+    return GetReactionTo(unit) >= REP_FRIENDLY;
+}
+
+bool Unit::IsHostileToPlayers() const
+{
+    FactionTemplateEntry const* my_faction = getFactionTemplateEntry();
+    if (!my_faction || !my_faction->faction)
+        return false;
+
+    FactionEntry const* raw_faction = sFactionStore.LookupEntry(my_faction->faction);
+    if (raw_faction && raw_faction->reputationListID >= 0)
+        return false;
+
+    return my_faction->IsHostileToPlayers();
+}
+
+bool Unit::IsNeutralToAll() const
+{
+    FactionTemplateEntry const* my_faction = getFactionTemplateEntry();
+    if (!my_faction || !my_faction->faction)
+        return true;
+
+    FactionEntry const* raw_faction = sFactionStore.LookupEntry(my_faction->faction);
+    if (raw_faction && raw_faction->reputationListID >= 0)
+        return false;
+
+    return my_faction->IsNeutralToAll();
+}
+
+bool Unit::Attack(Unit* victim, bool meleeAttack)
+{
+    if (!victim || victim == this)
+        return false;
+
+    // dead units can neither attack nor be attacked
+    if (!isAlive() || !victim->IsInWorld() || !victim->isAlive())
+        return false;
+
+    // player cannot attack in mount state
+    if (GetTypeId() == TYPEID_PLAYER && IsMounted())
+        return false;
+
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsInEvadeMode())
+        return false;
+
+    // nobody can attack GM in GM-mode
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim->ToPlayer()->isGameMaster())
+            return false;
+    }
+    else
+    {
+        if (victim->ToCreature()->IsInEvadeMode())
+            return false;
+    }
+
+    // Unit with SPELL_AURA_SPIRIT_OF_REDEMPTION can not attack
+    if (HasAuraType(SPELL_AURA_SPIRIT_OF_REDEMPTION))
+        return false;	
+	
+    // remove SPELL_AURA_MOD_UNATTACKABLE at attack (in case non-interruptible spells stun aura applied also that not let attack)
+    if (HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
+        RemoveAurasByType(SPELL_AURA_MOD_UNATTACKABLE);
+
+    if (m_attacking)
+    {
+        if (m_attacking == victim)
+        {
+            // switch to melee attack from ranged/magic
+            if (meleeAttack)
+            {
+                if (!HasUnitState(UNIT_STATE_MELEE_ATTACKING))
+                {
+                    AddUnitState(UNIT_STATE_MELEE_ATTACKING);
+                    SendMeleeAttackStart(victim);
+                    return true;
+                }
+            }
+            else if (HasUnitState(UNIT_STATE_MELEE_ATTACKING))
+            {
+                ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
+                SendMeleeAttackStop(victim);
+                return true;
+            }
+            return false;
+        }
+
+        // switch target
+        InterruptSpell(CURRENT_MELEE_SPELL);
+        if (!meleeAttack)
+            ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
+    }
+
+    if (m_attacking)
+        m_attacking->_removeAttacker(this);
+
+    m_attacking = victim;
+    m_attacking->_addAttacker(this);
+
+    // Set our target
+    SetTarget(victim->GetGUID());
+
+    if (meleeAttack)
+        AddUnitState(UNIT_STATE_MELEE_ATTACKING);
+
+    // set position before any AI calls/assistance
+    //if (GetTypeId() == TYPEID_UNIT)
+    //    ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());
+
+    if (GetTypeId() == TYPEID_UNIT && !ToCreature()->isPet())
+    {
+        // should not let player enter combat by right clicking target - doesn't helps
+        SetInCombatWith(victim);
+        if (victim->GetTypeId() == TYPEID_PLAYER)
+            victim->SetInCombatWith(this);
+        AddThreat(victim, 0.0f);
+
+        ToCreature()->SendAIReaction(AI_REACTION_HOSTILE);
+        ToCreature()->CallAssistance();
+    }
+
+    // delay offhand weapon attack to next attack time
+    if (haveOffhandWeapon())
+        resetAttackTimer(OFF_ATTACK);
+
+    if (meleeAttack)
+        SendMeleeAttackStart(victim);
+
+    // Let the pet know we've started attacking someting. Handles melee attacks only
+    // Spells such as auto-shot and others handled in WorldSession::HandleCastSpellOpcode
+    if (this->GetTypeId() == TYPEID_PLAYER)
+    {
+        Pet* playerPet = this->ToPlayer()->GetPet();
+
+        if (playerPet && playerPet->isAlive())
+            playerPet->AI()->OwnerAttacked(victim);
+    }
+
+    return true;
+}
+
+bool Unit::AttackStop()
+{
+    if (!m_attacking)
+        return false;
+
+    Unit* victim = m_attacking;
+
+    m_attacking->_removeAttacker(this);
+    m_attacking = NULL;
+
+    // Clear our target
+    SetTarget(0);
+
+    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
+
+    InterruptSpell(CURRENT_MELEE_SPELL);
+
+    // reset only at real combat stop
+    if (Creature* creature = ToCreature())
+    {
+        creature->SetNoCallAssistance(false);
+
+        if (creature->HasSearchedAssistance())
+        {
+            creature->SetNoSearchAssistance(false);
+            UpdateSpeed(MOVE_RUN, false);
+        }
+    }
+
+    SendMeleeAttackStop(victim);
+
+    return true;
+}
+
+void Unit::CombatStop(bool includingCast)
+{
+    if (includingCast && IsNonMeleeSpellCasted(false))
+        InterruptNonMeleeSpells(false);
+
+    AttackStop();
+    RemoveAllAttackers();
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        ToPlayer()->SendAttackSwingCancelAttack();     // melee and ranged forced attack cancel
+        ToPlayer()->m_holyPowerRegenTimerCount = 0;
+    }
+    ClearInCombat();
+}
+
+void Unit::CombatStopWithPets(bool includingCast)
+{
+    CombatStop(includingCast);
+
+    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        (*itr)->CombatStop(includingCast);
+}
+
+bool Unit::isAttackingPlayer() const
+{
+    if (HasUnitState(UNIT_STATE_ATTACK_PLAYER))
+        return true;
+
+    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        if ((*itr)->isAttackingPlayer())
+            return true;
+
+    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
+        if (m_SummonSlot[i])
+            if (Creature* summon = GetMap()->GetCreature(m_SummonSlot[i]))
+                if (summon->isAttackingPlayer())
+                    return true;
+
+    return false;
+}
+
+void Unit::RemoveAllAttackers()
+{
+    while (!m_attackers.empty())
+    {
+        AttackerSet::iterator iter = m_attackers.begin();
+        if (!(*iter)->AttackStop())
+        {
+            sLog->outError(LOG_FILTER_UNITS, "WORLD: Unit has an attacker that isn't attacking it!");
+            m_attackers.erase(iter);
+        }
+    }
+}
+
+void Unit::ModifyAuraState(AuraStateType flag, bool apply)
+{
+    if (apply)
+    {
+        if (!HasFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1)))
+        {
+            SetFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));
+            if (GetTypeId() == TYPEID_PLAYER)
+            {
+                PlayerSpellMap const& sp_list = ToPlayer()->GetSpellMap();
+                for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)
+                {
+                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
+                        continue;
+                    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);
+                    if (!spellInfo || !spellInfo->IsPassive())
+                        continue;
+                    if (spellInfo->CasterAuraState == uint32(flag))
+                        CastSpell(this, itr->first, true, NULL);
+                }
+            }
+            else if (Pet* pet = ToCreature()->ToPet())
+            {
+                for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+                {
+                    if (itr->second._state == DATA_REMOVED)
+                        continue;
+                    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);
+                    if (!spellInfo || !spellInfo->IsPassive())
+                        continue;
+                    if (spellInfo->CasterAuraState == uint32(flag))
+                        CastSpell(this, itr->first, true, NULL);
+                }
+            }
+        }
+    }
+    else
+    {
+        if (HasFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1)))
+        {
+            RemoveFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));
+
+            if (flag != AURA_STATE_ENRAGE)                  // enrage aura state triggering continues auras
+            {
+                Unit::AuraApplicationMap& tAuras = GetAppliedAuras();
+                for (Unit::AuraApplicationMap::iterator itr = tAuras.begin(); itr != tAuras.end();)
+                {
+                    SpellInfo const* spellProto = (*itr).second->GetBase()->GetSpellInfo();
+                    if (spellProto->CasterAuraState == uint32(flag))
+                        RemoveAura(itr);
+                    else
+                        ++itr;
+                }
+            }
+        }
+    }
+}
+
+uint32 Unit::BuildAuraStateUpdateForTarget(Unit* target) const
+{
+    uint32 auraStates = GetUInt32Value(UNIT_FIELD_AURASTATE) &~(PER_CASTER_AURA_STATE_MASK);
+    for (AuraStateAurasMap::const_iterator itr = m_auraStateAuras.begin(); itr != m_auraStateAuras.end(); ++itr)
+        if ((1<<(itr->first-1)) & PER_CASTER_AURA_STATE_MASK)
+            if (itr->second->GetBase()->GetCasterGUID() == target->GetGUID())
+                auraStates |= (1<<(itr->first-1));
+
+    return auraStates;
+}
+
+bool Unit::HasAuraState(AuraStateType flag, SpellInfo const* spellProto, Unit const* Caster) const
+{
+    if (Caster)
+    {
+        if (spellProto)
+        {
+            AuraEffectList const& stateAuras = Caster->GetAuraEffectsByType(SPELL_AURA_ABILITY_IGNORE_AURASTATE);
+            for (AuraEffectList::const_iterator j = stateAuras.begin(); j != stateAuras.end(); ++j)
+                if ((*j)->IsAffectingSpell(spellProto))
+                    return true;
+        }
+        // Check per caster aura state
+        // If aura with aurastate by caster not found return false
+        if ((1<<(flag-1)) & PER_CASTER_AURA_STATE_MASK)
+        {
+            AuraStateAurasMapBounds range = m_auraStateAuras.equal_range(flag);
+            for (AuraStateAurasMap::const_iterator itr = range.first; itr != range.second; ++itr)
+                if (itr->second->GetBase()->GetCasterGUID() == Caster->GetGUID())
+                    return true;
+            return false;
+        }
+    }
+
+    return HasFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));
+}
+
+void Unit::SetOwnerGUID(uint64 owner)
+{
+    if (GetOwnerGUID() == owner)
+        return;
+
+    SetUInt64Value(UNIT_FIELD_SUMMONEDBY, owner);
+    if (!owner)
+        return;
+
+    // Update owner dependent fields
+    Player* player = ObjectAccessor::GetPlayer(*this, owner);
+    if (!player || !player->HaveAtClient(this)) // if player cannot see this unit yet, he will receive needed data with create object
+        return;
+
+    SetFieldNotifyFlag(UF_FLAG_OWNER);
+
+    UpdateData udata(GetMapId());
+    WorldPacket packet;
+    BuildValuesUpdateBlockForPlayer(&udata, player);
+    udata.BuildPacket(&packet);
+    player->SendDirectMessage(&packet);
+
+    RemoveFieldNotifyFlag(UF_FLAG_OWNER);
+}
+
+Unit* Unit::GetOwner() const
+{
+    if (uint64 ownerid = GetOwnerGUID())
+    {
+        return ObjectAccessor::GetUnit(*this, ownerid);
+    }
+    return NULL;
+}
+
+Unit* Unit::GetCharmer() const
+{
+    if (uint64 charmerid = GetCharmerGUID())
+        return ObjectAccessor::GetUnit(*this, charmerid);
+    return NULL;
+}
+
+Player* Unit::GetCharmerOrOwnerPlayerOrPlayerItself() const
+{
+    uint64 guid = GetCharmerOrOwnerGUID();
+    if (IS_PLAYER_GUID(guid))
+        return ObjectAccessor::GetPlayer(*this, guid);
+
+    return GetTypeId() == TYPEID_PLAYER ? (Player*)this : NULL;
+}
+
+Player* Unit::GetAffectingPlayer() const
+{
+    if (!GetCharmerOrOwnerGUID())
+        return GetTypeId() == TYPEID_PLAYER ? (Player*)this : NULL;
+
+    if (Unit* owner = GetCharmerOrOwner())
+        return owner->GetCharmerOrOwnerPlayerOrPlayerItself();
+    return NULL;
+}
+
+Minion *Unit::GetFirstMinion() const
+{
+    if (uint64 pet_guid = GetMinionGUID())
+    {
+        if (Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, pet_guid))
+            if (pet->HasUnitTypeMask(UNIT_MASK_MINION))
+                return (Minion*)pet;
+
+        sLog->outError(LOG_FILTER_UNITS, "Unit::GetFirstMinion: Minion %u not exist.", GUID_LOPART(pet_guid));
+        const_cast<Unit*>(this)->SetMinionGUID(0);
+    }
+
+    return NULL;
+}
+
+Guardian* Unit::GetGuardianPet() const
+{
+    if (uint64 pet_guid = GetPetGUID())
+    {
+        if (Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, pet_guid))
+            if (pet->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+                return (Guardian*)pet;
+
+        sLog->outFatal(LOG_FILTER_UNITS, "Unit::GetGuardianPet: Guardian " UI64FMTD " not exist.", pet_guid);
+        const_cast<Unit*>(this)->SetPetGUID(0);
+    }
+
+    return NULL;
+}
+
+Unit* Unit::GetCharm() const
+{
+    if (uint64 charm_guid = GetCharmGUID())
+    {
+        if (Unit* pet = ObjectAccessor::GetUnit(*this, charm_guid))
+            return pet;
+
+        sLog->outError(LOG_FILTER_UNITS, "Unit::GetCharm: Charmed creature %u not exist.", GUID_LOPART(charm_guid));
+        const_cast<Unit*>(this)->SetUInt64Value(UNIT_FIELD_CHARM, 0);
+    }
+
+    return NULL;
+}
+
+void Unit::SetMinion(Minion *minion, bool apply, PetSlot slot)
+{
+    sLog->outDebug(LOG_FILTER_UNITS, "SetMinion %u for %u, apply %u", minion->GetEntry(), GetEntry(), apply);
+
+
+    if (apply)
+    {
+        if (minion->GetOwnerGUID())
+        {
+            sLog->outFatal(LOG_FILTER_UNITS, "SetMinion: Minion %u is not the minion of owner %u", minion->GetEntry(), GetEntry());
+            return;
+        }
+
+        minion->SetOwnerGUID(GetGUID());
+
+        m_Controlled.insert(minion);
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            minion->m_ControlledByPlayer = true;
+            minion->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+        }
+
+        // Can only have one pet. If a new one is summoned, dismiss the old one.
+        if (minion->IsGuardianPet())
+        {
+            if (Guardian* oldPet = GetGuardianPet())
+            {
+                if (oldPet != minion && (oldPet->isPet() || minion->isPet() || oldPet->GetEntry() != minion->GetEntry()))
+                {
+                    // remove existing minion pet
+                    if (oldPet->isPet())
+                        ((Pet*)oldPet)->Remove(PET_SLOT_ACTUAL_PET_SLOT);
+                    else
+                        oldPet->UnSummon();
+                    SetPetGUID(minion->GetGUID());
+                    SetMinionGUID(0);
+                }
+            }
+            else
+            {
+                SetPetGUID(minion->GetGUID());
+                SetMinionGUID(0);
+            }
+        }
+
+        if (slot == PET_SLOT_UNK_SLOT)
+        {
+            if (minion->isHunterPet())
+                sLog->outError(LOG_FILTER_GENERAL, "Pet System Error: Hunter pet was set as minion with slot %u", PET_SLOT_UNK_SLOT);
+
+            slot = PET_SLOT_OTHER_PET;
+        }
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            // If its not a Hunter Pet, only set pet slot. use setPetSlotUsed only for hanter pets.
+            // Always save thoose spots where hunter is correct
+            if (!minion->isHunterPet())
+                ToPlayer()->_currentPetSlot = slot;
+            else if (slot >= PET_SLOT_HUNTER_FIRST && slot <= PET_SLOT_HUNTER_LAST)
+                ToPlayer()->_currentPetSlot = slot;
+            else
+                sLog->outFatal(LOG_FILTER_UNITS, "Unit::SetMinion. Try to add hunter pet to not allowed slot(%i). Minion %u for %u", slot, minion->GetEntry(), GetGUIDLow());
+        }
+
+        if (minion->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
+        {
+            if (AddUInt64Value(UNIT_FIELD_SUMMON, minion->GetGUID()))
+            {
+            }
+        }
+
+        if (minion->m_Properties && minion->m_Properties->Type == SUMMON_TYPE_MINIPET)
+        {
+            SetCritterGUID(minion->GetGUID());
+        }
+
+        // PvP, FFAPvP
+        minion->SetByteValue(UNIT_FIELD_BYTES_2, 1, GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+        // FIXME: hack, speed must be set only at follow
+        if (GetTypeId() == TYPEID_PLAYER && minion->isPet())
+            for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
+                minion->SetSpeed(UnitMoveType(i), m_speed_rate[i], true);
+
+        // Ghoul pets have energy instead of mana (is anywhere better place for this code?)
+        if (minion->IsPetGhoul())
+        {
+            minion->setPowerType(POWER_ENERGY);
+            minion->SetPower(POWER_ENERGY, minion->GetMaxPower(POWER_ENERGY));
+        }
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            // Send infinity cooldown - client does that automatically but after relog cooldown needs to be set again
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(minion->GetUInt32Value(UNIT_CREATED_BY_SPELL));
+
+            if (spellInfo && (spellInfo->Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE))
+                AddSpellAndCategoryCooldowns(spellInfo, 0, NULL, true);
+        }
+    }
+    else
+    {
+        if (minion->GetOwnerGUID() != GetGUID())
+        {
+            sLog->outFatal(LOG_FILTER_UNITS, "SetMinion: Minion %u is not the minion of owner %u", minion->GetEntry(), GetEntry());
+            return;
+        }
+
+        m_Controlled.erase(minion);
+
+        if (minion->m_Properties && minion->m_Properties->Type == SUMMON_TYPE_MINIPET)
+        {
+            if (GetCritterGUID() == minion->GetGUID())
+                SetCritterGUID(0);
+        }
+
+        if (minion->IsGuardianPet())
+        {
+            if (GetPetGUID() == minion->GetGUID())
+                SetPetGUID(0);
+        }
+        else if (minion->isTotem())
+        {
+            // All summoned by totem minions must disappear when it is removed.
+        if (SpellInfo const* spInfo = sSpellMgr->GetSpellInfo(minion->ToTotem()->GetSpell()))
+            for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                if (spInfo->Effects[i].Effect != SPELL_EFFECT_SUMMON)
+                    continue;
+
+                RemoveAllMinionsByEntry(spInfo->Effects[i].MiscValue);
+            }
+        }
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(minion->GetUInt32Value(UNIT_CREATED_BY_SPELL));
+            // Remove infinity cooldown
+            if (spellInfo && (spellInfo->Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE))
+                ToPlayer()->SendCooldownEvent(spellInfo);
+        }
+
+        //if (minion->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+        {
+            if (RemoveUInt64Value(UNIT_FIELD_SUMMON, minion->GetGUID()))
+            {
+                // Check if there is another minion
+                for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+                {
+                    // do not use this check, creature do not have charm guid
+                    //if (GetCharmGUID() == (*itr)->GetGUID())
+                    if (GetGUID() == (*itr)->GetCharmerGUID())
+                        continue;
+
+                    //ASSERT((*itr)->GetOwnerGUID() == GetGUID());
+                    if ((*itr)->GetOwnerGUID() != GetGUID())
+                    {
+                        OutDebugInfo();
+                        (*itr)->OutDebugInfo();
+                        ASSERT(false);
+                    }
+                    ASSERT((*itr)->GetTypeId() == TYPEID_UNIT);
+
+                    if (!(*itr)->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
+                        continue;
+
+                    if (AddUInt64Value(UNIT_FIELD_SUMMON, (*itr)->GetGUID()))
+                    {
+                        // show another pet bar if there is no charm bar
+                        if (GetTypeId() == TYPEID_PLAYER && !GetCharmGUID())
+                        {
+                            if ((*itr)->isPet())
+                                ToPlayer()->PetSpellInitialize();
+                            else
+                                ToPlayer()->CharmSpellInitialize();
+                        }
+                    }
+                    break;
+                }
+            }
+        }
+    }
+}
+
+void Unit::RecalculatePetsScalingResistance(uint32 school)
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); itr++)
+        if ((*itr)->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+            ((Guardian*)(*itr))->RecalculatePetScalingResistance(school);
+}
+
+void Unit::RecalculatePetsScalingStats(Stats stats)
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); itr++)
+        if ((*itr)->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+            ((Guardian*)(*itr))->RecalculatePetScalingStats(stats);
+}
+
+void Unit::RecalculatePetsScalingHitRating()
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); itr++)
+        if ((*itr)->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+            ((Guardian*)(*itr))->RecalculatePetScalingHitRating();
+}
+
+void Unit::RecalculatePetsScalingCritRating()
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); itr++)
+        if ((*itr)->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+            ((Guardian*)(*itr))->RecalculatePetScalingCritRating();
+}
+
+void Unit::RecalculatePetsScalingAttackSpeed(WeaponAttackType att)
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); itr++)
+        if ((*itr)->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+            ((Guardian*)(*itr))->RecalculatePetScalingAttackSpeed(att);
+}
+
+void Unit::RecalculatePetsScalingAttackPower()
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); itr++)
+        if ((*itr)->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+            ((Guardian*)(*itr))->RecalculatePetScalingAttackPower();
+}
+
+void Unit::RecalculatePetsScalingDamageDone()
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); itr++)
+        if ((*itr)->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+            ((Guardian*)(*itr))->RecalculatePetScalingDamageDone();
+}
+
+void Unit::RecalculatePetsScalingDamageDonePct()
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); itr++)
+        if ((*itr)->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+            ((Guardian*)(*itr))->RecalculatePetScalingDamageDonePct();
+}
+
+void Unit::GetAllMinionsByEntry(std::list<Creature*>& Minions, uint32 entry)
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); itr++)
+        if ((*itr)->GetEntry() == entry && (*itr)->GetTypeId() == TYPEID_UNIT
+            && (*itr)->ToCreature()->isSummon()) // minion, actually
+            Minions.push_back((*itr)->ToCreature());
+}
+
+void Unit::RemoveAllMinionsByEntry(uint32 entry)
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); )
+    {
+        Unit* unit = *itr;
+        ++itr;
+        if (unit->GetEntry() == entry && unit->GetTypeId() == TYPEID_UNIT
+            && unit->ToCreature()->isSummon()) // minion, actually
+            unit->ToTempSummon()->UnSummon();    // i think this is safe because i have never heard that a despawned minion will trigger a same minion
+    }
+}
+
+void Unit::SetCharm(Unit* charm, bool apply)
+{
+    if (apply)
+    {
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            if (!AddUInt64Value(UNIT_FIELD_CHARM, charm->GetGUID()))
+                sLog->outFatal(LOG_FILTER_UNITS, "Player %s is trying to charm unit %u, but it already has a charmed unit " UI64FMTD "", GetName().c_str(), charm->GetEntry(), GetCharmGUID());
+
+            charm->m_ControlledByPlayer = true;
+            // TODO: maybe we can use this flag to check if controlled by player
+            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, GetByteValue(UNIT_FIELD_BYTES_2, 1));        // PvP, FFAPvP
+        }
+        else
+        {
+            charm->m_ControlledByPlayer = false;
+            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_PVP);
+            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+        }
+
+        if (!charm->AddUInt64Value(UNIT_FIELD_CHARMEDBY, GetGUID()))
+            sLog->outFatal(LOG_FILTER_UNITS, "Unit %u is being charmed, but it already has a charmer " UI64FMTD "", charm->GetEntry(), charm->GetCharmerGUID());
+
+        _isWalkingBeforeCharm = charm->IsWalking();
+        if (_isWalkingBeforeCharm)
+        {
+            charm->SetWalk(false);
+            charm->SendMovementWalkMode();
+        }
+
+        m_Controlled.insert(charm);
+    }
+    else
+    {
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            if (!RemoveUInt64Value(UNIT_FIELD_CHARM, charm->GetGUID()))
+                sLog->outFatal(LOG_FILTER_UNITS, "Player %s is trying to uncharm unit %u, but it has another charmed unit " UI64FMTD "", GetName().c_str(), charm->GetEntry(), GetCharmGUID());
+        }
+        else
+        {
+            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);
+            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+        }
+
+        if (!charm->RemoveUInt64Value(UNIT_FIELD_CHARMEDBY, GetGUID()))
+            sLog->outFatal(LOG_FILTER_UNITS, "Unit %u is being uncharmed, but it has another charmer " UI64FMTD "", charm->GetEntry(), charm->GetCharmerGUID());
+
+        if (charm->GetTypeId() == TYPEID_PLAYER)
+        {
+            charm->m_ControlledByPlayer = true;
+            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+            charm->ToPlayer()->UpdatePvPState();
+        }
+        else if (Player* player = charm->GetCharmerOrOwnerPlayerOrPlayerItself())
+        {
+            charm->m_ControlledByPlayer = true;
+            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, player->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+        }
+        else
+        {
+            charm->m_ControlledByPlayer = false;
+            charm->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);
+        }
+
+        if (charm->IsWalking() != _isWalkingBeforeCharm)
+        {
+            charm->SetWalk(_isWalkingBeforeCharm);
+            charm->SendMovementWalkMode();
+        }
+
+        if (charm->GetTypeId() == TYPEID_PLAYER
+            || !charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_MINION)
+            || charm->GetOwnerGUID() != GetGUID())
+            m_Controlled.erase(charm);
+    }
+}
+
+int32 Unit::DealHeal(Unit* victim, uint32 addhealth)
+{
+    int32 gain = 0;
+
+    if (victim->IsAIEnabled)
+        victim->GetAI()->HealReceived(this, addhealth);
+
+    if (IsAIEnabled)
+        GetAI()->HealDone(victim, addhealth);
+
+    if (addhealth)
+        gain = victim->ModifyHealth(int32(addhealth));
+
+    Unit* unit = this;
+
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->isTotem())
+        unit = GetOwner();
+
+    if (Player* player = unit->ToPlayer())
+    {
+        if (Battleground* bg = player->GetBattleground())
+            bg->UpdatePlayerScore(player, SCORE_HEALING_DONE, gain);
+
+        // use the actual gain, as the overheal shall not be counted, skip gain 0 (it ignored anyway in to criteria)
+        if (gain)
+            player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HEALING_DONE, gain, 0, 0, victim);
+
+        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEAL_CASTED, addhealth);
+    }
+
+    if (Player* player = victim->ToPlayer())
+    {
+        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_HEALING_RECEIVED, gain);
+        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEALING_RECEIVED, addhealth);
+    }
+
+    return gain;
+}
+
+Unit* Unit::GetMagicHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo)
+{
+    // Patch 1.2 notes: Spell Reflection no longer reflects abilities
+    if (spellInfo->Attributes & SPELL_ATTR0_ABILITY || spellInfo->AttributesEx & SPELL_ATTR1_CANT_BE_REDIRECTED || spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
+        return victim;
+
+    Unit::AuraEffectList const& magnetAuras = victim->GetAuraEffectsByType(SPELL_AURA_SPELL_MAGNET);
+    for (Unit::AuraEffectList::const_iterator itr = magnetAuras.begin(); itr != magnetAuras.end(); ++itr)
+        if (Unit* magnet = (*itr)->GetBase()->GetCaster())
+            return magnet;
+
+    return victim;
+}
+
+Unit* Unit::GetMeleeHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo)
+{
+	AuraEffectList const& hitTriggerAuras = victim->GetAuraEffectsByType(SPELL_AURA_ADD_CASTER_HIT_TRIGGER);
+	for (AuraEffectList::const_iterator i = hitTriggerAuras.begin(); i != hitTriggerAuras.end(); ++i)
+	{
+		if (Unit* magnet = (*i)->GetBase()->GetCaster())
+		if (_IsValidAttackTarget(magnet, spellInfo) && roll_chance_i((*i)->GetAmount())
+			&& IsInRange(magnet, 0.0f, (*i)->GetSpellInfo()->Effects[(*i)->GetEffIndex()].CalcRadius()))
+		{
+			(*i)->GetBase()->DropCharge(AURA_REMOVE_BY_EXPIRE);
+			return magnet;
+		}
+	}
+	return victim;
+}
+
+Unit* Unit::GetFirstControlled() const
+{
+    // Sequence: charmed, pet, other guardians
+    Unit* unit = GetCharm();
+    if (!unit)
+        if (uint64 guid = GetMinionGUID())
+            unit = ObjectAccessor::GetUnit(*this, guid);
+
+    return unit;
+}
+
+void Unit::RemoveAllControlled()
+{
+    // possessed pet and vehicle
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->StopCastingCharm();
+
+    while (!m_Controlled.empty())
+    {
+        Unit* target = *m_Controlled.begin();
+        m_Controlled.erase(m_Controlled.begin());
+        if (target->GetCharmerGUID() == GetGUID())
+            target->RemoveCharmAuras();
+        else if (target->GetOwnerGUID() == GetGUID() && target->isSummon())
+            target->ToTempSummon()->UnSummon();
+        else
+            sLog->outError(LOG_FILTER_UNITS, "Unit %u is trying to release unit %u which is neither charmed nor owned by it", GetEntry(), target->GetEntry());
+    }
+    if (GetPetGUID())
+        sLog->outFatal(LOG_FILTER_UNITS, "Unit %u is not able to release its pet " UI64FMTD, GetEntry(), GetPetGUID());
+    if (GetMinionGUID())
+        sLog->outFatal(LOG_FILTER_UNITS, "Unit %u is not able to release its minion " UI64FMTD, GetEntry(), GetMinionGUID());
+    if (GetCharmGUID())
+        sLog->outFatal(LOG_FILTER_UNITS, "Unit %u is not able to release its charm " UI64FMTD, GetEntry(), GetCharmGUID());
+}
+
+Unit* Unit::GetNextRandomRaidMemberOrPet(float radius)
+{
+    Player* player = NULL;
+    if (GetTypeId() == TYPEID_PLAYER)
+        player = ToPlayer();
+    // Should we enable this also for charmed units?
+    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->isPet())
+        player = GetOwner()->ToPlayer();
+
+    if (!player)
+        return NULL;
+    Group* group = player->GetGroup();
+    // When there is no group check pet presence
+    if (!group)
+    {
+        // We are pet now, return owner
+        if (player != this)
+            return IsWithinDistInMap(player, radius) ? player : NULL;
+        Unit* pet = GetGuardianPet();
+        // No pet, no group, nothing to return
+        if (!pet)
+            return NULL;
+        // We are owner now, return pet
+        return IsWithinDistInMap(pet, radius) ? pet : NULL;
+    }
+
+    std::vector<Unit*> nearMembers;
+    // reserve place for players and pets because resizing vector every unit push is unefficient (vector is reallocated then)
+    nearMembers.reserve(group->GetMembersCount() * 2);
+
+    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+        if (Player* Target = itr->getSource())
+        {
+            // IsHostileTo check duel and controlled by enemy
+            if (Target != this && Target->isAlive() && IsWithinDistInMap(Target, radius) && !IsHostileTo(Target))
+                nearMembers.push_back(Target);
+
+        // Push player's pet to vector
+        if (Unit* pet = Target->GetGuardianPet())
+            if (pet != this && pet->isAlive() && IsWithinDistInMap(pet, radius) && !IsHostileTo(pet))
+                nearMembers.push_back(pet);
+        }
+
+    if (nearMembers.empty())
+        return NULL;
+
+    uint32 randTarget = urand(0, nearMembers.size()-1);
+    return nearMembers[randTarget];
+}
+
+// only called in Player::SetSeer
+// so move it to Player?
+void Unit::AddPlayerToVision(Player* player)
+{
+    if (m_sharedVision.empty())
+    {
+        setActive(true);
+        SetWorldObject(true);
+    }
+    m_sharedVision.push_back(player);
+}
+
+// only called in Player::SetSeer
+void Unit::RemovePlayerFromVision(Player* player)
+{
+    m_sharedVision.remove(player);
+    if (m_sharedVision.empty())
+    {
+        setActive(false);
+        SetWorldObject(false);
+    }
+}
+
+void Unit::RemoveBindSightAuras()
+{
+    RemoveAurasByType(SPELL_AURA_BIND_SIGHT);
+}
+
+void Unit::RemoveCharmAuras()
+{
+    RemoveAurasByType(SPELL_AURA_MOD_CHARM);
+    RemoveAurasByType(SPELL_AURA_MOD_POSSESS_PET);
+    RemoveAurasByType(SPELL_AURA_MOD_POSSESS);
+    RemoveAurasByType(SPELL_AURA_AOE_CHARM);
+}
+
+void Unit::UnsummonAllTotems()
+{
+    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
+    {
+        if (!m_SummonSlot[i])
+            continue;
+
+        if (Creature* OldTotem = GetMap()->GetCreature(m_SummonSlot[i]))
+            if (OldTotem->isSummon())
+                OldTotem->ToTempSummon()->UnSummon();
+    }
+}
+
+void Unit::SendHealSpellLog(Unit* victim, uint32 SpellID, uint32 Damage, uint32 OverHeal, uint32 Absorb, bool critical)
+{
+    // we guess size
+    WorldPacket data(SMSG_SPELLHEALLOG, 8+8+4+4+4+4+1+1);
+    data.append(victim->GetPackGUID());
+    data.append(GetPackGUID());
+    data << uint32(SpellID);
+    data << uint32(Damage);
+    data << uint32(OverHeal);
+    data << uint32(Absorb); // Absorb amount
+    data << uint8(critical ? 1 : 0);
+    data << uint8(0); // unused
+    SendMessageToSet(&data, true);
+}
+
+int32 Unit::HealBySpell(Unit* victim, SpellInfo const* spellInfo, uint32 addHealth, bool critical)
+{
+    uint32 absorb = 0;
+    // calculate heal absorb and reduce healing
+    CalcHealAbsorb(victim, spellInfo, addHealth, absorb);
+
+    int32 gain = DealHeal(victim, addHealth);
+    SendHealSpellLog(victim, spellInfo->Id, addHealth, uint32(addHealth - gain), absorb, critical);
+    return gain;
+}
+
+void Unit::SendEnergizeSpellLog(Unit* victim, uint32 spellID, uint32 damage, Powers powerType)
+{
+    WorldPacket data(SMSG_SPELLENERGIZELOG, (8+8+4+4+4+1));
+    data.append(victim->GetPackGUID());
+    data.append(GetPackGUID());
+    data << uint32(spellID);
+    data << uint32(powerType);
+    data << uint32(damage);
+    SendMessageToSet(&data, true);
+}
+
+void Unit::EnergizeBySpell(Unit* victim, uint32 spellID, int32 damage, Powers powerType)
+{
+    SendEnergizeSpellLog(victim, spellID, damage, powerType);
+    // needs to be called after sending spell log
+    victim->ModifyPower(powerType, damage);
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellID);
+    victim->getHostileRefManager().threatAssist(this, float(damage) * 0.5f, spellInfo);
+}
+
+uint32 Unit::SpellDamageBonusDone(Unit* victim, SpellInfo const* spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack)
+{
+    if (!spellProto || !victim || damagetype == DIRECT_DAMAGE)
+        return pdamage;
+
+    // Some spells don't benefit from done mods
+    if (spellProto->AttributesEx3 & SPELL_ATTR3_NO_DONE_BONUS)
+        return pdamage;
+
+    // small exception for Deep Wounds, can't find any general rule
+    // should ignore ALL damage mods, they already calculated in trigger spell
+    if (spellProto->Id == 12721) // Deep Wounds
+        return pdamage;
+
+    // For totems get damage bonus from owner
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->isTotem())
+        if (Unit* owner = GetOwner())
+            return owner->SpellDamageBonusDone(victim, spellProto, pdamage, damagetype);
+
+    // Done total percent damage auras
+    float DoneTotalMod = 1.0f;
+    float ApCoeffMod = 1.0f;
+    int32 DoneTotal = 0;
+
+    // Pet damage?
+    if (GetTypeId() == TYPEID_UNIT && !ToCreature()->isPet())
+        DoneTotalMod *= ToCreature()->GetSpellDamageMod(ToCreature()->GetCreatureTemplate()->rank);
+
+    uint32 creatureTypeMask = victim->GetCreatureTypeMask();
+    // Add flat bonus from spell damage versus
+    DoneTotal += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_FLAT_SPELL_DAMAGE_VERSUS, creatureTypeMask);
+    AuraEffectList const& mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
+    for (AuraEffectList::const_iterator i = mDamageDoneVersus.begin(); i != mDamageDoneVersus.end(); ++i)
+        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+            AddPct(DoneTotalMod, (*i)->GetAmount());
+
+    // bonus against aurastate
+    AuraEffectList const& mDamageDoneVersusAurastate = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE);
+    for (AuraEffectList::const_iterator i = mDamageDoneVersusAurastate.begin(); i != mDamageDoneVersusAurastate.end(); ++i)
+        if (victim->HasAuraState(AuraStateType((*i)->GetMiscValue())))
+            AddPct(DoneTotalMod, (*i)->GetAmount());
+
+    // Damage bonus based on mana
+    AuraEffectList const& mDamageDoneByPower = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_BY_POWER);
+    for (AuraEffectList::const_iterator i = mDamageDoneByPower.begin(); i != mDamageDoneByPower.end(); ++i)
+        if ((*i)->GetMiscValue() & spellProto->GetSchoolMask())
+        {
+            float powerPercentage = float(GetPower(POWER_MANA)) / float(GetMaxPower(POWER_MANA));
+            int32 amount = (*i)->GetAmount() * powerPercentage;
+            AddPct(DoneTotalMod, amount);
+        }
+
+    // Add SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC percent bonus
+    AddPct(DoneTotalMod, GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC, spellProto->Mechanic));
+
+    // done scripted mod (take it from owner)
+    Unit* owner = GetOwner() ? GetOwner() : this;
+    AuraEffectList const& mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
+    {
+        if (!(*i)->IsAffectingSpell(spellProto))
+            continue;
+
+        switch ((*i)->GetMiscValue())
+        {
+            case 4920: // Molten Fury
+            case 4919:
+            case 12368:
+            {
+                if (victim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))
+                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                break;
+            }
+            case 6917: // Death's Embrace damage effect
+            case 6926:
+            case 6928:
+            {
+                // Health at 25% or less (25% stored at effect 2 of the spell)
+                if (victim->HealthBelowPct(CalculateSpellDamage(this, (*i)->GetSpellInfo(), EFFECT_2)))
+                    AddPct(DoneTotalMod, (*i)->GetAmount());
+            }
+            case 6916: // Death's Embrace heal effect
+            case 6925:
+            case 6927:
+                if (HealthBelowPct(CalculateSpellDamage(this, (*i)->GetSpellInfo(), EFFECT_2)))
+                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                break;
+            // Soul Siphon
+            case 4992:
+            case 4993:
+            {
+                // effect 1 m_amount
+                int32 maxPercent = (*i)->GetAmount();
+                // effect 0 m_amount
+                int32 stepPercent = CalculateSpellDamage(this, (*i)->GetSpellInfo(), 0);
+                // count affliction effects and calc additional damage in percentage
+                int32 modPercent = 0;
+                AuraApplicationMap const& victimAuras = victim->GetAppliedAuras();
+                for (AuraApplicationMap::const_iterator itr = victimAuras.begin(); itr != victimAuras.end(); ++itr)
+                {
+                    Aura const* aura = itr->second->GetBase();
+                    SpellInfo const* spell = aura->GetSpellInfo();
+                    if (spell->SpellFamilyName != SPELLFAMILY_WARLOCK || !(spell->SpellFamilyFlags[1] & 0x0004071B || spell->SpellFamilyFlags[0] & 0x8044C402))
+                        continue;
+                    modPercent += stepPercent * aura->GetStackAmount();
+                    if (modPercent >= maxPercent)
+                    {
+                        modPercent = maxPercent;
+                        break;
+                    }
+                }
+                AddPct(DoneTotalMod, modPercent);
+                break;
+            }
+            case 5481: // Starfire Bonus
+            {
+                if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x200002, 0, 0))
+                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                break;
+            }
+            case 4418: // Increased Shock Damage
+            case 4554: // Increased Lightning Damage
+            case 4555: // Improved Moonfire
+            case 5142: // Increased Lightning Damage
+            case 5147: // Improved Consecration / Libram of Resurgence
+            case 5148: // Idol of the Shooting Star
+            case 6008: // Increased Lightning Damage
+            case 8627: // Totem of Hex
+            {
+                DoneTotal += (*i)->GetAmount();
+                break;
+            }
+        }
+    }
+
+    // Custom scripted damage
+    switch (spellProto->SpellFamilyName)
+    {
+        case SPELLFAMILY_MAGE:
+            // Ice Lance
+            if (spellProto->Id == 30455)
+            {
+                // Ice lance deals double damage against frozen targets
+                if (victim->HasAuraState(AURA_STATE_FROZEN, spellProto, this))
+                    DoneTotalMod *= 2.0f;
+
+                // 25% increased damage when used with fingers of frost
+                // No aura existant that holds the percentage
+                if (HasAura(44544))
+                    AddPct(DoneTotalMod, 25);
+            }
+            // Frost Mastery
+            if (victim->HasAuraState(AURA_STATE_FROZEN, spellProto, this))
+                if (AuraEffect* aur = GetDummyAuraEffect(SPELLFAMILY_MAGE, 119, EFFECT_0))
+                    AddPct(DoneTotalMod, aur->GetAmount());
+
+            // Torment the weak
+            if (spellProto->GetSchoolMask() & SPELL_SCHOOL_MASK_ARCANE)
+            {
+                if (victim->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_SLOW_ATTACK)))
+                {
+                    AuraEffectList const& mDumyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+                    for (AuraEffectList::const_iterator i = mDumyAuras.begin(); i != mDumyAuras.end(); ++i)
+                    {
+                        if ((*i)->GetSpellInfo()->SpellIconID == 2215)
+                        {
+                            AddPct(DoneTotalMod, (*i)->GetAmount());
+                            break;
+                        }
+                    }
+                }
+            }
+            break;
+        case SPELLFAMILY_PRIEST:
+            switch (spellProto->Id)
+            {
+                case 585: // Smite
+                {
+                    // Glyph of Smite
+                    if (AuraEffect* aurEff = GetAuraEffect(55692, 0))
+                        if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x100000, 0, 0, GetGUID()))
+                            AddPct(DoneTotalMod, aurEff->GetAmount());
+                    break;
+                }
+                case 32379: // Shadow Word: death
+                {
+                    bool atOrBelowPct = victim->GetHealthPct() <= 25.0f;
+                    if (atOrBelowPct)
+                    {
+                        // Three times more damage to targets at or below 25%
+                        AddPct(DoneTotalMod, 200);
+                        // Mind Melt
+                        if (AuraEffect* aurEff = GetDummyAuraEffect(SPELLFAMILY_PRIEST, 3139, EFFECT_0))
+                            AddPct(DoneTotalMod, aurEff->GetAmount());
+                    }
+                    break;
+                }
+                case 8092:  // Mind blast
+                case 73510: // Mind Spike
+                {
+                    // Shadow orbs
+                    if (AuraEffect* aurEff = GetDummyAuraEffect(SPELLFAMILY_GENERIC, 4941, EFFECT_0))
+                    {
+                        uint8 stacks = aurEff->GetBase()->GetStackAmount();
+                        int32 add = 0;
+                        if (AuraEffect* mastery = GetAuraEffect(77486, EFFECT_0))
+                            add = mastery->GetAmount();
+                        int32 amount = aurEff->GetAmount() / (2.0f * stacks) + add;
+                        AddPct(DoneTotalMod, amount * stacks);
+                        CastCustomSpell(this, 95799, &amount, &amount, NULL, true);
+                        aurEff->GetBase()->Remove();
+                    }
+                    break;
+                }
+            }
+            break;
+        case SPELLFAMILY_WARLOCK:
+            // Fire and Brimstone
+            if (spellProto->SpellFamilyFlags[1] & 0x00020040)
+                if (victim->HasAuraState(AURA_STATE_CONFLAGRATE))
+                {
+                    AuraEffectList const& mDumyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+                    for (AuraEffectList::const_iterator i = mDumyAuras.begin(); i != mDumyAuras.end(); ++i)
+                        if ((*i)->GetSpellInfo()->SpellIconID == 3173)
+                        {
+                            AddPct(DoneTotalMod, (*i)->GetAmount());
+                            break;
+                        }
+                }
+            // Drain Soul - increased damage for targets under 25 % HP
+            if (spellProto->SpellFamilyFlags[0] & 0x00004000)
+                if (victim->GetHealthPct() <= 25.0f)
+                    DoneTotalMod *= 2;
+            // Shadow Bite (30% increase from each dot)
+            if (spellProto->SpellFamilyFlags[1] & 0x00400000 && isPet())
+                if (uint8 count = victim->GetDoTsByCaster(GetOwnerGUID()))
+                    AddPct(DoneTotalMod, 30 * count);
+            break;
+        case SPELLFAMILY_DEATHKNIGHT:
+            switch (spellProto->Id)
+            {
+                case 45477: // Icy touch
+                case 49184: // Howling Blast
+                case 49020: // Obliterate
+                {
+                    // Merciless Combat
+                    if (AuraEffect* aurEff = GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, SPELLFAMILY_DEATHKNIGHT, EFFECT_0))
+                        if (victim->GetHealthPct() <= 35.0f)
+                            AddPct(DoneTotalMod, aurEff->GetAmount());
+                    break;
+                }
+            }
+            // Sigil of the Vengeful Heart
+            if (spellProto->SpellFamilyFlags[0] & 0x2000)
+                if (AuraEffect* aurEff = GetAuraEffect(64962, EFFECT_1))
+                    DoneTotal += aurEff->GetAmount();
+            break;
+    }
+
+    // Done fixed damage bonus auras
+    int32 DoneAdvertisedBenefit  = SpellBaseDamageBonusDone(spellProto->GetSchoolMask());
+    // Pets just add their bonus damage to their spell damage
+    // note that their spell damage is just gain of their own auras
+    if (isSummon() && isCharmedOwnedByPlayerOrPlayer())
+        DoneAdvertisedBenefit += ToTempSummon()->GetSpellBonusDamage();
+    // Check for table values
+    float coeff = 0;
+    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);
+    if (bonus)
+    {
+        if (damagetype == DOT)
+        {
+            coeff = bonus->dot_damage;
+            if (bonus->ap_dot_bonus > 0)
+            {
+                WeaponAttackType attType = spellProto->IsRangedWeaponSpell() ? RANGED_ATTACK : BASE_ATTACK;
+                float APbonus = float(victim->GetTotalAuraModifier(attType == BASE_ATTACK ? SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS : SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS));
+                APbonus += GetTotalAttackPowerValue(attType);
+                DoneTotal += int32(bonus->ap_dot_bonus * stack * ApCoeffMod * APbonus);
+            }
+        }
+        else
+        {
+            coeff = bonus->direct_damage;
+            if (bonus->ap_bonus > 0)
+            {
+                WeaponAttackType attType = spellProto->IsRangedWeaponSpell() ? RANGED_ATTACK : BASE_ATTACK;
+                float APbonus = float(victim->GetTotalAuraModifier(attType == BASE_ATTACK ? SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS : SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS));
+                APbonus += GetTotalAttackPowerValue(attType);
+                DoneTotal += int32(bonus->ap_bonus * stack * ApCoeffMod * APbonus);
+            }
+        }
+    }
+    // Default calculation
+    if (DoneAdvertisedBenefit)
+    {
+        if (!bonus || coeff < 0)
+            coeff = CalculateDefaultCoefficient(spellProto, damagetype) * int32(stack);
+
+        float factorMod = CalculateLevelPenalty(spellProto) * stack;
+
+        if (Player* modOwner = GetSpellModOwner())
+        {
+            coeff *= 100.0f;
+            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);
+            coeff /= 100.0f;
+        }
+        DoneTotal += int32(DoneAdvertisedBenefit * coeff * factorMod);
+    }
+
+    AuraEffectList const& mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
+    for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
+    {
+        if (spellProto->EquippedItemClass == -1 && (*i)->GetSpellInfo()->EquippedItemClass != -1)    //prevent apply mods from weapon specific case to non weapon specific spells (Example: thunder clap and two-handed weapon specialization)
+            continue;
+
+        if ((*i)->GetMiscValue() & spellProto->GetSchoolMask())
+        {
+            if ((*i)->GetSpellInfo()->EquippedItemClass == -1)
+                AddPct(DoneTotalMod, (*i)->GetAmount());
+            else if (!((*i)->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK) && ((*i)->GetSpellInfo()->EquippedItemSubClassMask == 0))
+                AddPct(DoneTotalMod, (*i)->GetAmount());
+            else if (ToPlayer() && ToPlayer()->HasItemFitToSpellRequirements((*i)->GetSpellInfo()))
+                AddPct(DoneTotalMod, (*i)->GetAmount());
+        }
+    }
+
+    if (spellProto->AttributesEx6 & SPELL_ATTR6_NO_DONE_PCT_DAMAGE_MODS)
+        DoneTotalMod = 1.0f;
+
+    float tmpDamage = (int32(pdamage) + DoneTotal) * DoneTotalMod;
+    // apply spellmod to Done damage (flat and pct)
+    if (!(spellProto->AttributesEx10 & SPELL_ATTR10_UNK1))
+        if (Player* modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, tmpDamage);
+
+    return uint32(std::max(tmpDamage, 0.0f));
+}
+
+uint32 Unit::SpellDamageBonusTaken(SpellInfo const* spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack, uint64 casterGUID)
+{
+    if (!spellProto || damagetype == DIRECT_DAMAGE)
+        return pdamage;
+
+    int32 TakenTotal = 0;
+    float TakenTotalMod = 1.0f;
+
+
+    //.. taken pct: dummy auras
+    AuraEffectList const& mDummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+    for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
+    {
+        switch ((*i)->GetSpellInfo()->SpellIconID)
+        {
+            // Cheat Death
+            case 2109:
+                if ((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        continue;
+                    AddPct(TakenTotalMod, (*i)->GetAmount());
+                }
+                break;
+        }
+    }
+
+    if (spellProto->AttributesEx4 & SPELL_ATTR4_FIXED_DAMAGE)
+    {
+        float tmpDamage = float(pdamage) * TakenTotalMod;
+        return uint32(std::max(tmpDamage, 0.0f));
+    }
+
+    // from positive and negative SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN
+    // multiplicative bonus, for example Dispersion + Shadowform (0.10*0.85=0.085)
+    TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, spellProto->GetSchoolMask());
+
+    // From caster spells
+    AuraEffectList const& mOwnerTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER);
+    for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)
+        if ((*i)->GetCasterGUID() == casterGUID && (*i)->IsAffectingSpell(spellProto))
+            AddPct(TakenTotalMod, (*i)->GetAmount());
+
+    // Mod damage from spell mechanic
+    if (uint32 mechanicMask = spellProto->GetAllEffectsMechanicMask())
+    {
+        AuraEffectList const& mDamageDoneMechanic = GetAuraEffectsByType(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT);
+        for (AuraEffectList::const_iterator i = mDamageDoneMechanic.begin(); i != mDamageDoneMechanic.end(); ++i)
+            if (mechanicMask & uint32(1<<((*i)->GetMiscValue())))
+                AddPct(TakenTotalMod, (*i)->GetAmount());
+    }
+
+    int32 TakenAdvertisedBenefit = SpellBaseDamageBonusTaken(spellProto->GetSchoolMask());
+
+    // Check for table values
+    float coeff = 0;
+    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);
+    if (bonus)
+        coeff = (damagetype == DOT) ? bonus->dot_damage : bonus->direct_damage;
+
+    // Default calculation
+    if (TakenAdvertisedBenefit)
+    {
+        if (!bonus || coeff < 0)
+            coeff = CalculateDefaultCoefficient(spellProto, damagetype) * int32(stack);
+
+        float factorMod = CalculateLevelPenalty(spellProto) * stack;
+        // level penalty still applied on Taken bonus - is it blizzlike?
+        if (Player* modOwner = GetSpellModOwner())
+        {
+            coeff *= 100.0f;
+            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);
+            coeff /= 100.0f;
+        }
+        TakenTotal+= int32(TakenAdvertisedBenefit * coeff * factorMod);
+    }
+
+    float tmpDamage = (float(pdamage) + TakenTotal) * TakenTotalMod;
+    return uint32(std::max(tmpDamage, 0.0f));
+}
+
+int32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask schoolMask)
+{
+    // Handle overrides first
+    AuraEffectList const& overrides = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_SPELL_POWER_BY_AP_PCT);
+    for (AuraEffectList::const_iterator i = overrides.begin(); i != overrides.end(); ++i)
+        return int32(GetTotalAttackPowerValue(BASE_ATTACK) * ((*i)->GetAmount() / 100.0f));
+
+    int32 DoneAdvertisedBenefit = 0;
+    AuraEffectList const& mDamageDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
+    for (AuraEffectList::const_iterator i = mDamageDone.begin(); i != mDamageDone.end(); ++i)
+        if (((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_MAGIC) != 0 && ((*i)->GetMiscValue() & schoolMask) != 0 &&
+        (*i)->GetSpellInfo()->EquippedItemClass == -1 &&
+                                                            // -1 == any item class (not wand then)
+        (*i)->GetSpellInfo()->EquippedItemInventoryTypeMask == -1)
+                                                            // 0 == any inventory type (not wand then)
+            DoneAdvertisedBenefit += (*i)->GetAmount();
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        // Base value
+        uint32 spellPower = ToPlayer()->GetBaseSpellPowerBonus();
+        // Check if we are ever using mana - PaperDollFrame.lua
+        if (GetPowerIndex(POWER_MANA) != MAX_POWERS)
+            spellPower += std::max(0, int32(GetStat(STAT_INTELLECT)) - 10);  // spellpower from intellect
+
+        // Damage bonus from stats
+        AuraEffectList const& mDamageDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT);
+        for (AuraEffectList::const_iterator i = mDamageDoneOfStatPercent.begin(); i != mDamageDoneOfStatPercent.end(); ++i)
+        {
+            if ((*i)->GetMiscValue() & schoolMask)
+            {
+                // stat used stored in miscValueB for this aura
+                Stats usedStat = Stats((*i)->GetMiscValueB());
+                spellPower += int32(CalculatePct(GetStat(usedStat), (*i)->GetAmount()));
+            }
+        }
+        // ... and attack power
+        AuraEffectList const& mDamageDonebyAP = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER);
+        for (AuraEffectList::const_iterator i =mDamageDonebyAP.begin(); i != mDamageDonebyAP.end(); ++i)
+            if ((*i)->GetMiscValue() & schoolMask)
+                spellPower += int32(CalculatePct(GetTotalAttackPowerValue(BASE_ATTACK), (*i)->GetAmount()));
+
+        // Spell power from SPELL_AURA_MOD_SPELL_POWER_PCT
+        AuraEffectList const& mSpellPowerPct = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_POWER_PCT);
+        for (AuraEffectList::const_iterator i = mSpellPowerPct.begin(); i != mSpellPowerPct.end(); ++i)
+            AddPct(spellPower, (*i)->GetAmount());
+
+        DoneAdvertisedBenefit += spellPower;
+
+    }
+    return DoneAdvertisedBenefit;
+}
+
+int32 Unit::SpellBaseDamageBonusTaken(SpellSchoolMask schoolMask)
+{
+    int32 TakenAdvertisedBenefit = 0;
+
+    AuraEffectList const& mDamageTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
+    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
+        if (((*i)->GetMiscValue() & schoolMask) != 0)
+            TakenAdvertisedBenefit += (*i)->GetAmount();
+
+    return TakenAdvertisedBenefit;
+}
+
+bool Unit::isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType, Spell* spell) const
+{
+    //! Mobs can't crit with spells. Player Totems can
+    //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
+    if (IS_CREATURE_GUID(GetGUID()) && !(isTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438)
+        return false;
+
+    // not critting spell
+    if ((spellProto->AttributesEx2 & SPELL_ATTR2_CANT_CRIT))
+        return false;
+
+    // Always critting spell
+    if (spellProto->Id == 94472)
+        return true;
+
+    float crit_chance = 0.0f;
+    switch (spellProto->DmgClass)
+    {
+        case SPELL_DAMAGE_CLASS_NONE:
+            // We need more spells to find a general way (if there is any)
+            switch (spellProto->Id)
+            {
+                case 379:   // Earth Shield
+                case 33778: // Lifebloom Final Bloom
+                case 64844: // Divine Hymn
+                case 71607: // Item - Bauble of True Blood 10m
+                case 71646: // Item - Bauble of True Blood 25m
+                    break;
+                default:
+                    return false;
+            }
+        case SPELL_DAMAGE_CLASS_MAGIC:
+        {
+            if (schoolMask & SPELL_SCHOOL_MASK_NORMAL)
+                crit_chance = 0.0f;
+            // For other schools
+            else if (GetTypeId() == TYPEID_PLAYER)
+                crit_chance = GetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1 + GetFirstSchoolInMask(schoolMask));
+            else
+            {
+                crit_chance = (float)m_baseSpellCritChance;
+                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);
+            }
+            // taken
+            if (victim)
+            {
+                if (!spellProto->IsPositive())
+                {
+                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE
+                    crit_chance += victim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE, schoolMask);
+                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE
+                    crit_chance += victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);
+                }
+                // Custom crit by class
+                switch (spellProto->SpellFamilyName)
+                {
+                    case SPELLFAMILY_PRIEST:
+                    {
+                        // Renewed Hope
+                        if (AuraEffect const* aurEff = GetDummyAuraEffect(SPELLFAMILY_PRIEST, 329, EFFECT_0))
+                            if (victim->HasAura(6788, GetGUID()) || victim->HasAura(77613, GetGUID()))
+                                if (spellProto->SpellFamilyFlags & aurEff->GetSpellInfo()->Effects[0].SpellClassMask)
+                                    crit_chance += aurEff->GetAmount();
+                        break;
+                    }
+                    case SPELLFAMILY_DRUID:
+                        // Improved Faerie Fire
+                        if (victim->HasAuraState(AURA_STATE_FAERIE_FIRE))
+                            if (AuraEffect const* aurEff = GetDummyAuraEffect(SPELLFAMILY_DRUID, 109, 0))
+                                crit_chance += aurEff->GetAmount();
+
+                        // cumulative effect - don't break
+
+                        // Starfire
+                        if (spellProto->SpellFamilyFlags[0] & 0x4 && spellProto->SpellIconID == 1485)
+                        {
+                            // Improved Insect Swarm
+                            if (AuraEffect const* aurEff = GetDummyAuraEffect(SPELLFAMILY_DRUID, 1771, 0))
+                                if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00000002, 0, 0))
+                                    crit_chance += aurEff->GetAmount();
+                           break;
+                        }
+                    break;
+                    case SPELLFAMILY_ROGUE:
+                        // Shiv-applied poisons can't crit
+                        if (FindCurrentSpellBySpellId(5938))
+                            crit_chance = 0.0f;
+                        break;
+                    case SPELLFAMILY_PALADIN:
+                        // Word of glory
+                        if(spellProto->Id == 85673)
+                        {
+                            if(victim->HasAura(20235)) // Last Word rank 2
+                                if(victim->HealthBelowPct(35))
+                                    crit_chance += 60.0f;
+                            if(victim->HasAura(20234)) // Last Word rank 1
+                                if(victim->HealthBelowPct(35))
+                                    crit_chance += 30.0f;
+                        }
+                        // Flash of light
+                        if (spellProto->SpellFamilyFlags[0] & 0x40000000)
+                        {
+                            // Sacred Shield
+                            if (AuraEffect const* aura = victim->GetAuraEffect(58597, 1, GetGUID()))
+                                crit_chance += aura->GetAmount();
+                            break;
+                        }
+                        // Exorcism
+                        else if (spellProto->Category == 19)
+                        {
+                            if (victim->GetCreatureTypeMask() & CREATURE_TYPEMASK_DEMON_OR_UNDEAD)
+                                return true;
+                            break;
+                        }
+                    break;
+                    case SPELLFAMILY_SHAMAN:
+                        // Lava Burst
+                        if (spellProto->SpellFamilyFlags[1] & 0x00001000 || spellProto->SpellFamilyFlags[2] & 0x00408000)
+                        {
+                            if (victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, 0x10000000, 0, 0, GetGUID()))
+                                if (victim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE) > -100)
+                                    return true;
+                            break;
+                        }
+                    break;
+                    case SPELLFAMILY_WARLOCK:
+                        // Searing Pain
+                        if (spellProto->SpellFamilyFlags[0] & 0x00000100)
+                        {
+                            // Soulburn
+                            if (spell->IsChangeBySoulBurn())
+                                crit_chance += 100.0f;
+                            // Improved Searing Pain
+                            if (AuraEffect const* aurEff = GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 816, 0))
+                                if (victim->GetHealthPct() < 25.0f)
+                                    crit_chance += aurEff->GetAmount();
+                        }
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELL_DAMAGE_CLASS_MELEE:
+            if (victim)
+            {
+                // Custom crit by class
+                switch (spellProto->SpellFamilyName)
+                {
+                    case SPELLFAMILY_DRUID:
+                        // Rend and Tear - bonus crit chance for Ferocious Bite on bleeding targets
+                        if (spellProto->SpellFamilyFlags[0] & 0x00800000
+                            && spellProto->SpellIconID == 1680
+                            && victim->HasAuraState(AURA_STATE_BLEEDING))
+                        {
+                            if (AuraEffect const* rendAndTear = GetDummyAuraEffect(SPELLFAMILY_DRUID, 2859, 1))
+                                crit_chance += rendAndTear->GetAmount();
+                            break;
+                        }
+                        switch (spellProto->Id)
+                        {
+                            case 6785: // Ravage
+                            {
+                                // Predatory Strikes
+                                if (AuraEffect const* predator = GetDummyAuraEffect(SPELLFAMILY_DRUID, 1563, 0))
+                                    if (victim->GetHealthPct() >= 80.0f)
+                                        crit_chance += predator->GetAmount();
+                                break;
+                            }
+                        }
+                    break;
+                    case SPELLFAMILY_HUNTER:
+                    {
+                        switch (spellProto->Id)
+                        {
+                            case 83381: // Kill command
+                            {
+                                if (Unit* owner = GetOwner())
+                                    // Improved Kill command
+                                    if (AuraEffect const* aura = owner->GetDummyAuraEffect(SPELLFAMILY_HUNTER, 2221, EFFECT_0))
+                                        crit_chance += aura->GetAmount();
+                                break;
+                            }
+                        }
+                        break;
+                    }
+                    case SPELLFAMILY_PALADIN:
+                        switch(spellProto->Id)
+                        {
+                            // Templar's Verdict
+                            case 85256:
+                            {
+                                int32 damage = victim->CalculateDamage(BASE_ATTACK, true, true);
+
+                                // Divine Purpose check
+                                if (this->HasAura(90174))
+                                {
+                                    damage *= 2.35f;
+                                }
+                                else
+                                {
+                                    switch (this->GetPower(POWER_HOLY_POWER))
+                                    {
+                                        case 0: // 1 Holy Power
+                                            damage *= 0.3f;
+                                            break;
+                                        case 1: // 2 Holy Power
+                                            damage *= 0.9f;
+                                            break;
+                                        case 2: // 3 Holy Power
+                                            damage *= 2.35f;
+                                            break;
+                                    }
+                                }
+
+                                //crit_chance += damage;
+                            }
+                            break;
+                        }
+                    break;
+                    case SPELLFAMILY_WARRIOR:
+                        // Victory Rush
+                        if (spellProto->SpellFamilyFlags[1] & 0x100)
+                        {
+                           // Glyph of Victory Rush
+                            if (AuraEffect const* aurEff = GetAuraEffect(58382, 0))
+                                crit_chance += aurEff->GetAmount();
+                            break;
+                        }
+                    break;
+                }
+            }
+        case SPELL_DAMAGE_CLASS_RANGED:
+        {
+            if (victim)
+            {
+                // Custom crit by class
+                switch (spellProto->SpellFamilyName)
+                {
+                    case SPELLFAMILY_HUNTER:
+                    {
+                        switch (spellProto->Id)
+                        {
+                            case 19434: // Aimed shot
+                            case 56641: // Steady Shot
+                            case 77767: // Cobra Shot
+                            {
+                                AuraEffect const* marker = GetDummyAuraEffect(SPELLFAMILY_HUNTER, 2222, EFFECT_1);
+                                if (marker && victim->GetHealthPct() >= float(marker->GetAmount()))
+                                // Careful Aim
+                                    if (AuraEffect const* aura = GetDummyAuraEffect(SPELLFAMILY_HUNTER, 2222, EFFECT_0))
+                                        crit_chance += aura->GetAmount();
+                                break;
+                            }
+                        }
+                        break;
+                    }
+                }
+                crit_chance += GetUnitCriticalChance(attackType, victim);
+                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);
+            }
+            break;
+        }
+        default:
+            return false;
+    }
+    // percent done
+    // only players use intelligence for critical chance computations
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRITICAL_CHANCE, crit_chance, spell);
+
+    AuraEffectList const& critAuras = victim->GetAuraEffectsByType(SPELL_AURA_MOD_CRIT_CHANCE_FOR_CASTER);
+    for (AuraEffectList::const_iterator i = critAuras.begin(); i != critAuras.end(); ++i)
+        if ((*i)->GetCasterGUID() == GetGUID() && (*i)->IsAffectingSpell(spellProto))
+            crit_chance += (*i)->GetAmount();
+
+    if (isPet() && ToPet()->GetOwner() && ToPet()->GetOwner()->getClass() == CLASS_WARLOCK) // Curse of Gul'dan
+        if (AuraEffect const* aura = victim->GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 1923, EFFECT_0))
+            crit_chance += aura->GetAmount();
+
+    if (spellProto->DmgClass == SPELL_DAMAGE_CLASS_MAGIC && victim)
+    {
+        // scripted (increase crit chance ... against ... target by x%
+        AuraEffectList const& mOverrideClassScript = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+        for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
+        {
+            if (!((*i)->IsAffectingSpell(spellProto)))
+                continue;
+
+            switch ((*i)->GetMiscValue())
+            {
+                // Shatter
+                case  911:
+                    if (!victim->HasAuraState(AURA_STATE_FROZEN, spellProto, this))
+                        break;
+                    AddPct(crit_chance, (*i)->GetAmount()*20);
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    crit_chance = crit_chance > 0.0f ? crit_chance : 0.0f;
+    if (roll_chance_f(crit_chance))
+        return true;
+    return false;
+}
+
+uint32 Unit::SpellCriticalDamageBonus(SpellInfo const* spellProto, uint32 damage, Unit* /*victim*/)
+{
+    // Calculate critical bonus
+    int32 crit_bonus = damage;
+    float crit_mod = 0.0f;
+
+    switch (spellProto->DmgClass)
+    {
+        case SPELL_DAMAGE_CLASS_MELEE:                      // for melee based spells is 100%
+        case SPELL_DAMAGE_CLASS_RANGED:
+            // TODO: write here full calculation for melee/ranged spells
+            crit_bonus += damage;
+            break;
+        default:
+            crit_bonus += damage / 2;                       // for spells is 50%
+            // 4.0.1 All mage and warlock spells now crit for 200% damage.
+            //if (spellProto->SpellFamilyName == SPELLFAMILY_MAGE || spellProto->SpellFamilyName == SPELLFAMILY_WARLOCK)
+            //    crit_bonus += damage;
+            //else
+            //    crit_bonus += damage / 2;                       // for spells is 50%
+            //break;
+    }
+
+    crit_mod += (GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS, spellProto->GetSchoolMask()) - 1.0f) * 100;
+
+    if (crit_bonus != 0)
+        AddPct(crit_bonus, crit_mod);
+
+    crit_bonus -= damage;
+    // adds additional damage to critBonus (from talents)
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRIT_DAMAGE_BONUS, crit_bonus);
+
+    crit_bonus += damage;
+
+    return crit_bonus;
+}
+
+uint32 Unit::SpellCriticalHealingBonus(SpellInfo const* /*spellProto*/, uint32 damage, Unit* /*victim*/)
+{
+    // Calculate critical bonus
+    int32 crit_bonus = damage;
+
+    damage += crit_bonus;
+
+    damage = int32(float(damage) * GetTotalAuraMultiplier(SPELL_AURA_MOD_CRITICAL_HEALING_AMOUNT));
+
+    return damage;
+}
+
+uint32 Unit::SpellHealingBonusDone(Unit* victim, SpellInfo const* spellProto, uint32 healamount, DamageEffectType damagetype, uint32 stack)
+{
+    // For totems get healing bonus from owner (statue isn't totem in fact)
+    if (GetTypeId() == TYPEID_UNIT && isTotem())
+        if (Unit* owner = GetOwner())
+            return owner->SpellHealingBonusDone(victim, spellProto, healamount, damagetype, stack);
+
+    // No bonus healing for potion spells
+    if (spellProto->SpellFamilyName == SPELLFAMILY_POTION)
+        return healamount;
+
+    float DoneTotalMod = 1.0f;
+    int32 DoneTotal = 0;
+
+    // Healing done percent
+    AuraEffectList const& mHealingDonePct = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE_PERCENT);
+    for (AuraEffectList::const_iterator i = mHealingDonePct.begin(); i != mHealingDonePct.end(); ++i)
+        if ((*i)->GetId() == 99263)
+            if (victim && victim->HasAura(99252))
+                AddPct(DoneTotalMod, (*i)->GetAmount());
+
+    // Healing bonus based on targets hp
+    AuraEffectList const& mDamageDoneByPower = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE_BY_POWER);
+    for (AuraEffectList::const_iterator i = mDamageDoneByPower.begin(); i != mDamageDoneByPower.end(); ++i)
+    {
+        int32 amount = (*i)->GetAmount() * (1.0f - (victim->GetHealthPct() / 100.0f));
+        AddPct(DoneTotalMod, amount);
+    }
+
+    // done scripted mod (take it from owner)
+    Unit* owner = GetOwner() ? GetOwner() : this;
+    AuraEffectList const& mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
+    {
+        if (!(*i)->IsAffectingSpell(spellProto))
+            continue;
+        switch ((*i)->GetMiscValue())
+        {
+            case 4415: // Increased Rejuvenation Healing
+            case 4953:
+            case 3736: // Hateful Totem of the Third Wind / Increased Lesser Healing Wave / LK Arena (4/5/6) Totem of the Third Wind / Savage Totem of the Third Wind
+                DoneTotal += (*i)->GetAmount();
+                break;
+            case   21: // Test of Faith
+            case 6935:
+            case 6918:
+                if (victim->HealthBelowPct(50))
+                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                break;
+            case 8477: // Nourish Heal Boost
+            {
+                int32 stepPercent = (*i)->GetAmount();
+                int32 modPercent = 0;
+                AuraApplicationMap const& victimAuras = victim->GetAppliedAuras();
+                for (AuraApplicationMap::const_iterator itr = victimAuras.begin(); itr != victimAuras.end(); ++itr)
+                {
+                    Aura const* aura = itr->second->GetBase();
+                    if (aura->GetCasterGUID() != GetGUID())
+                        continue;
+                    SpellInfo const* m_spell = aura->GetSpellInfo();
+                    if (m_spell->SpellFamilyName != SPELLFAMILY_DRUID ||
+                        !(m_spell->SpellFamilyFlags[1] & 0x00000010 || m_spell->SpellFamilyFlags[0] & 0x50))
+                        continue;
+                    modPercent += stepPercent * aura->GetStackAmount();
+                }
+                AddPct(DoneTotalMod, modPercent);
+                break;
+            }
+            default:
+                break;
+        }
+    }
+
+    // Dummy auras
+    AuraEffectList const& mDummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+    for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
+    {
+        switch ((*i)->GetSpellInfo()->Id)
+        {
+            case 30867: // Nature's Blessing
+            case 30868:
+            case 30869:
+            {
+                // Only increase if Direct heal & is affected by earth shield
+                if (damagetype != DOT && victim->HasAura(974))
+                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                break;
+            }
+            case 16187: // Soothing rains
+            case 16205:
+                if (spellProto->Id == 52042)
+                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                break;
+        }
+    }
+
+    // Done fixed damage bonus auras
+    int32 DoneAdvertisedBenefit = SpellBaseHealingBonusDone(spellProto->GetSchoolMask());
+
+    // Check for table values
+    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);
+    float coeff = 0;
+    float factorMod = 1.0f;
+    if (bonus)
+    {
+        if (damagetype == DOT)
+        {
+            coeff = bonus->dot_damage;
+            if (bonus->ap_dot_bonus > 0)
+                DoneTotal += int32(bonus->ap_dot_bonus * stack * GetTotalAttackPowerValue(
+                    (spellProto->IsRangedWeaponSpell() && spellProto->DmgClass !=SPELL_DAMAGE_CLASS_MELEE) ? RANGED_ATTACK : BASE_ATTACK));
+        }
+        else
+        {
+            coeff = bonus->direct_damage;
+            if (bonus->ap_bonus > 0)
+                DoneTotal += int32(bonus->ap_bonus * stack * GetTotalAttackPowerValue(
+                    (spellProto->IsRangedWeaponSpell() && spellProto->DmgClass == SPELL_DAMAGE_CLASS_RANGED) ? RANGED_ATTACK : BASE_ATTACK));
+        }
+    }
+    else
+    {
+        // No bonus healing for SPELL_DAMAGE_CLASS_NONE class spells by default
+        if (spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE)
+            return healamount;
+    }
+
+    // Default calculation
+    if (DoneAdvertisedBenefit)
+    {
+        if (!bonus || coeff < 0)
+            coeff = CalculateDefaultCoefficient(spellProto, damagetype) * int32(stack) * 1.88f;  // As wowwiki says: C = (Cast Time / 3.5) * 1.88 (for healing spells)
+
+        factorMod *= CalculateLevelPenalty(spellProto) * stack;
+
+        if (Player* modOwner = GetSpellModOwner())
+        {
+            coeff *= 100.0f;
+            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);
+            coeff /= 100.0f;
+        }
+
+        DoneTotal += int32(DoneAdvertisedBenefit * coeff * factorMod);
+    }
+
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        switch (spellProto->Effects[i].ApplyAuraName)
+        {
+            // Bonus healing does not apply to these spells
+            case SPELL_AURA_PERIODIC_LEECH:
+            case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
+                DoneTotal = 0;
+                break;
+        }
+        if (spellProto->Effects[i].Effect == SPELL_EFFECT_HEALTH_LEECH)
+            DoneTotal = 0;
+    }
+
+    // use float as more appropriate for negative values and percent applying
+    float heal = float(int32(healamount) + DoneTotal) * DoneTotalMod;
+    // apply spellmod to Done amount
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
+
+    return uint32(std::max(heal, 0.0f));
+}
+
+uint32 Unit::SpellHealingBonusTaken(SpellInfo const* spellProto, uint32 healamount, DamageEffectType damagetype, uint32 stack, uint64 casterGUID)
+{
+    float TakenTotalMod = 1.0f;
+
+    // Healing taken percent
+    float minval = float(GetMaxNegativeAuraModifier(SPELL_AURA_MOD_HEALING_PCT));
+    if (minval)
+        AddPct(TakenTotalMod, minval);
+
+    float maxval = float(GetMaxPositiveAuraModifier(SPELL_AURA_MOD_HEALING_PCT));
+    if (maxval)
+        AddPct(TakenTotalMod, maxval);
+
+    // Tenacity increase healing % taken
+    if (AuraEffect const* Tenacity = GetAuraEffect(58549, 0))
+        AddPct(TakenTotalMod, Tenacity->GetAmount());
+
+    // Healing Done
+    int32 TakenTotal = 0;
+
+    // Taken fixed damage bonus auras
+    int32 TakenAdvertisedBenefit = SpellBaseHealingBonusTaken(spellProto->GetSchoolMask());
+
+    // Nourish cast
+    if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags[1] & 0x2000000)
+    {
+        // Rejuvenation, Regrowth, Lifebloom, or Wild Growth
+        if (GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x50, 0x4000010, 0))
+            // increase healing by 20%
+            TakenTotalMod *= 1.2f;
+    }
+
+    // Check for table values
+    SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);
+    float coeff = 0;
+    float factorMod = 1.0f;
+    if (bonus)
+        coeff = (damagetype == DOT) ? bonus->dot_damage : bonus->direct_damage;
+    else
+    {
+        // No bonus healing for SPELL_DAMAGE_CLASS_NONE class spells by default
+        if (spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE)
+        {
+            healamount = uint32(std::max((float(healamount) * TakenTotalMod), 0.0f));
+            return healamount;
+        }
+    }
+
+    // Default calculation
+    if (TakenAdvertisedBenefit)
+    {
+        if (!bonus || coeff < 0)
+            coeff = CalculateDefaultCoefficient(spellProto, damagetype) * int32(stack) * 1.88f;  // As wowwiki says: C = (Cast Time / 3.5) * 1.88 (for healing spells)
+
+        factorMod *= CalculateLevelPenalty(spellProto) * int32(stack);
+        if (Player* modOwner = GetSpellModOwner())
+        {
+            coeff *= 100.0f;
+            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);
+            coeff /= 100.0f;
+        }
+
+        TakenTotal += int32(TakenAdvertisedBenefit * coeff * factorMod);
+    }
+
+    AuraEffectList const& mHealingGet= GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_RECEIVED);
+    for (AuraEffectList::const_iterator i = mHealingGet.begin(); i != mHealingGet.end(); ++i)
+        if (casterGUID == (*i)->GetCasterGUID() && (*i)->IsAffectingSpell(spellProto))
+            AddPct(TakenTotalMod, (*i)->GetAmount());
+
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        switch (spellProto->Effects[i].ApplyAuraName)
+        {
+            // Bonus healing does not apply to these spells
+            case SPELL_AURA_PERIODIC_LEECH:
+            case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
+                TakenTotal = 0;
+                break;
+        }
+        if (spellProto->Effects[i].Effect == SPELL_EFFECT_HEALTH_LEECH)
+            TakenTotal = 0;
+    }
+
+    float heal = float(int32(healamount) + TakenTotal) * TakenTotalMod;
+
+    return uint32(std::max(heal, 0.0f));
+}
+
+int32 Unit::SpellBaseHealingBonusDone(SpellSchoolMask schoolMask)
+{
+    // Handle overrides first
+    AuraEffectList const& overrides = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_SPELL_POWER_BY_AP_PCT);
+    for (AuraEffectList::const_iterator i = overrides.begin(); i != overrides.end(); ++i)
+        return int32(GetTotalAttackPowerValue(BASE_ATTACK) * ((*i)->GetAmount() / 100.0f));
+
+    int32 AdvertisedBenefit = 0;
+    AuraEffectList const& mHealingDone = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE);
+    for (AuraEffectList::const_iterator i = mHealingDone.begin(); i != mHealingDone.end(); ++i)
+        if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)
+            AdvertisedBenefit += (*i)->GetAmount();
+
+    // Healing bonus of spirit, intellect and strength
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        // Base value
+        uint32 spellPower = ToPlayer()->GetBaseSpellPowerBonus();
+        // Check if we are ever using mana - PaperDollFrame.lua
+        if (GetPowerIndex(POWER_MANA) != MAX_POWERS)
+            spellPower += std::max(0, int32(GetStat(STAT_INTELLECT)) - 10);  // spellpower from intellect
+
+        // Healing bonus from stats
+        AuraEffectList const& mHealingDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT);
+        for (AuraEffectList::const_iterator i = mHealingDoneOfStatPercent.begin(); i != mHealingDoneOfStatPercent.end(); ++i)
+        {
+            // stat used dependent from misc value (stat index)
+            Stats usedStat = Stats((*i)->GetSpellInfo()->Effects[(*i)->GetEffIndex()].MiscValue);
+            spellPower += int32(CalculatePct(GetStat(usedStat), (*i)->GetAmount()));
+        }
+
+        // ... and attack power
+        AuraEffectList const& mHealingDonebyAP = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER);
+        for (AuraEffectList::const_iterator i = mHealingDonebyAP.begin(); i != mHealingDonebyAP.end(); ++i)
+            if ((*i)->GetMiscValue() & schoolMask)
+                spellPower += int32(CalculatePct(GetTotalAttackPowerValue(BASE_ATTACK), (*i)->GetAmount()));
+
+        // Spell power from SPELL_AURA_MOD_SPELL_POWER_PCT
+        AuraEffectList const& mSpellPowerPct = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_POWER_PCT);
+        for (AuraEffectList::const_iterator i = mSpellPowerPct.begin(); i != mSpellPowerPct.end(); ++i)
+            AddPct(spellPower, (*i)->GetAmount());
+
+        AdvertisedBenefit += spellPower;
+    }
+    return AdvertisedBenefit;
+}
+
+int32 Unit::SpellBaseHealingBonusTaken(SpellSchoolMask schoolMask)
+{
+    int32 AdvertisedBenefit = 0;
+
+    AuraEffectList const& mDamageTaken = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING);
+    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
+        if (((*i)->GetMiscValue() & schoolMask) != 0)
+            AdvertisedBenefit += (*i)->GetAmount();
+
+    return AdvertisedBenefit;
+}
+
+bool Unit::IsImmunedToDamage(SpellSchoolMask shoolMask)
+{
+    // If m_immuneToSchool type contain this school type, IMMUNE damage.
+    SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
+    for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
+        if (itr->type & shoolMask)
+            return true;
+
+    // If m_immuneToDamage type contain magic, IMMUNE damage.
+    SpellImmuneList const& damageList = m_spellImmune[IMMUNITY_DAMAGE];
+    for (SpellImmuneList::const_iterator itr = damageList.begin(); itr != damageList.end(); ++itr)
+        if (itr->type & shoolMask)
+            return true;
+
+    return false;
+}
+
+bool Unit::IsImmunedToDamage(SpellInfo const* spellInfo, bool checkSchoolMask)
+{
+    if (spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
+        return false;
+
+    uint32 shoolMask = spellInfo->GetSchoolMask();
+    // There are cases in which schoolmask has already been checked
+    if (checkSchoolMask && spellInfo->Id != 42292 && spellInfo->Id != 59752)
+    {
+        // If m_immuneToSchool type contain this school type, IMMUNE damage.
+        SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
+        for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
+            if (itr->type & shoolMask && !spellInfo->CanPierceImmuneAura(sSpellMgr->GetSpellInfo(itr->spellId)))
+                return true;
+    }
+
+    // If m_immuneToDamage type contain magic, IMMUNE damage.
+    SpellImmuneList const& damageList = m_spellImmune[IMMUNITY_DAMAGE];
+    for (SpellImmuneList::const_iterator itr = damageList.begin(); itr != damageList.end(); ++itr)
+        if (itr->type & shoolMask)
+            return true;
+
+    return false;
+}
+
+bool Unit::IsImmunedToSpell(SpellInfo const* spellInfo, Unit* caster)
+{
+    if (!spellInfo)
+        return false;
+
+    // Single spell immunity.
+    SpellImmuneList const& idList = m_spellImmune[IMMUNITY_ID];
+    for (SpellImmuneList::const_iterator itr = idList.begin(); itr != idList.end(); ++itr)
+        if (itr->type == spellInfo->Id)
+            return true;
+
+    if (spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
+        return false;
+
+    if (spellInfo->Dispel)
+    {
+        SpellImmuneList const& dispelList = m_spellImmune[IMMUNITY_DISPEL];
+        for (SpellImmuneList::const_iterator itr = dispelList.begin(); itr != dispelList.end(); ++itr)
+            if (itr->type == spellInfo->Dispel)
+                return true;
+    }
+
+    // Spells that don't have effectMechanics.
+    if (spellInfo->Mechanic)
+    {
+        SpellImmuneList const& mechanicList = m_spellImmune[IMMUNITY_MECHANIC];
+        for (SpellImmuneList::const_iterator itr = mechanicList.begin(); itr != mechanicList.end(); ++itr)
+            if (itr->type == spellInfo->Mechanic)
+                return true;
+    }
+
+    bool immuneToAllEffects = true;
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        // State/effect immunities applied by aura expect full spell immunity
+        // Ignore effects with mechanic, they are supposed to be checked separately
+        if (!spellInfo->Effects[i].IsEffect())
+            continue;
+        if (!IsImmunedToSpellEffect(spellInfo, i, caster))
+        {
+            immuneToAllEffects = false;
+            break;
+        }
+    }
+
+    if (immuneToAllEffects) //Return immune only if the target is immune to all spell effects.
+        return true;
+
+    if (spellInfo->Id != 42292 && spellInfo->Id != 59752 && spellInfo->Id != 53490 && spellInfo->Id != 70029)
+    {
+        SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
+        for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
+        {
+            SpellInfo const* immuneSpellInfo = sSpellMgr->GetSpellInfo(itr->spellId);
+            if ((itr->type & spellInfo->GetSchoolMask())
+                && !(immuneSpellInfo && immuneSpellInfo->IsPositive() && (spellInfo->IsPositive() || this == caster))
+                && !spellInfo->CanPierceImmuneAura(immuneSpellInfo))
+                return true;
+        }
+    }
+
+    return false;
+}
+
+bool Unit::IsImmunedToSpellEffect(SpellInfo const* spellInfo, uint32 index, Unit* caster) const
+{
+    if (!spellInfo || !spellInfo->Effects[index].IsEffect())
+        return false;
+
+    if (spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)
+        return false;
+
+    // If m_immuneToEffect type contain this effect type, IMMUNE effect.
+    uint32 effect = spellInfo->Effects[index].Effect;
+    SpellImmuneList const& effectList = m_spellImmune[IMMUNITY_EFFECT];
+    for (SpellImmuneList::const_iterator itr = effectList.begin(); itr != effectList.end(); ++itr)
+        if (itr->type == effect)
+            return true;
+
+    if (uint32 mechanic = spellInfo->Effects[index].Mechanic)
+    {
+        SpellImmuneList const& mechanicList = m_spellImmune[IMMUNITY_MECHANIC];
+        for (SpellImmuneList::const_iterator itr = mechanicList.begin(); itr != mechanicList.end(); ++itr)
+            if (itr->type == mechanic)
+                return true;
+    }
+
+    if (uint32 aura = spellInfo->Effects[index].ApplyAuraName)
+    {
+        SpellImmuneList const& list = m_spellImmune[IMMUNITY_STATE];
+        for (SpellImmuneList::const_iterator itr = list.begin(); itr != list.end(); ++itr)
+            if (itr->type == aura)
+                if (!(spellInfo->AttributesEx3 & SPELL_ATTR3_IGNORE_HIT_RESULT))
+                    return true;
+
+        // Check for immune to application of harmful magical effects
+        AuraEffectList const& immuneAuraApply = GetAuraEffectsByType(SPELL_AURA_MOD_IMMUNE_AURA_APPLY_SCHOOL);
+        for (AuraEffectList::const_iterator iter = immuneAuraApply.begin(); iter != immuneAuraApply.end(); ++iter)
+            if ((spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE) &&
+                ((*iter)->GetMiscValue() & spellInfo->GetSchoolMask() || spellInfo->Dispel == DISPEL_MAGIC) &&
+                !spellInfo->IsPositiveEffect(index))
+                return true;
+    }
+
+    return false;
+}
+
+uint32 Unit::MeleeDamageBonusDone(Unit* victim, uint32 pdamage, WeaponAttackType attType, SpellInfo const* spellProto)
+{
+    if (!victim || pdamage == 0)
+        return 0;
+
+    uint32 creatureTypeMask = victim->GetCreatureTypeMask();
+
+    // Done fixed damage bonus auras
+    int32 DoneFlatBenefit = 0;
+
+    // ..done
+    AuraEffectList const& mDamageDoneCreature = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
+    for (AuraEffectList::const_iterator i = mDamageDoneCreature.begin(); i != mDamageDoneCreature.end(); ++i)
+        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+            DoneFlatBenefit += (*i)->GetAmount();
+
+    // ..done
+    // SPELL_AURA_MOD_DAMAGE_DONE included in weapon damage
+
+    // ..done (base at attack power for marked target and base at attack power for creature type)
+    int32 APbonus = 0;
+
+    if (attType == RANGED_ATTACK)
+    {
+        APbonus += victim->GetTotalAuraModifier(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS);
+
+        // ..done (base at attack power and creature type)
+        AuraEffectList const& mCreatureAttackPower = GetAuraEffectsByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS);
+        for (AuraEffectList::const_iterator i = mCreatureAttackPower.begin(); i != mCreatureAttackPower.end(); ++i)
+            if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+                APbonus += (*i)->GetAmount();
+    }
+    else
+    {
+        APbonus += victim->GetTotalAuraModifier(SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS);
+
+        // ..done (base at attack power and creature type)
+        AuraEffectList const& mCreatureAttackPower = GetAuraEffectsByType(SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS);
+        for (AuraEffectList::const_iterator i = mCreatureAttackPower.begin(); i != mCreatureAttackPower.end(); ++i)
+            if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+                APbonus += (*i)->GetAmount();
+    }
+
+    if (APbonus != 0)                                       // Can be negative
+    {
+        bool normalized = false;
+        if (spellProto)
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+                if (spellProto->Effects[i].Effect == SPELL_EFFECT_NORMALIZED_WEAPON_DMG)
+                {
+                    normalized = true;
+                    break;
+                }
+        DoneFlatBenefit += int32(APbonus/14.0f * GetAPMultiplier(attType, normalized));
+    }
+
+    if (spellProto)
+    {
+        // Check for table values
+        SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellProto->Id);
+        if (bonus)
+        {
+            if (bonus->ap_bonus > 0)
+            {
+                float APbonus = GetTotalAttackPowerValue(attType);
+                DoneFlatBenefit += int32(bonus->ap_bonus * APbonus);
+            }
+        }
+    }
+
+    // Done total percent damage auras
+    float DoneTotalMod = 1.0f;
+
+    AuraEffectList const& mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
+    for (AuraEffectList::const_iterator i = mDamageDoneVersus.begin(); i != mDamageDoneVersus.end(); ++i)
+        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+            AddPct(DoneTotalMod, (*i)->GetAmount());
+
+    // bonus against aurastate
+    AuraEffectList const& mDamageDoneVersusAurastate = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE);
+    for (AuraEffectList::const_iterator i = mDamageDoneVersusAurastate.begin(); i != mDamageDoneVersusAurastate.end(); ++i)
+        if (victim->HasAuraState(AuraStateType((*i)->GetMiscValue())))
+            AddPct(DoneTotalMod, (*i)->GetAmount());
+
+    // Add SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC percent bonus
+    if (spellProto)
+    {
+        AddPct(DoneTotalMod, GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_DAMAGE_DONE_FOR_MECHANIC, spellProto->Mechanic));
+
+        AuraEffectList const& mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
+        for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
+        {
+            if ((*i)->GetMiscValue() & spellProto->GetSchoolMask() && !(spellProto->GetSchoolMask() & SPELL_SCHOOL_MASK_NORMAL))
+            {
+                if ((*i)->GetSpellInfo()->EquippedItemClass == -1)
+                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                else if (!((*i)->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK) && ((*i)->GetSpellInfo()->EquippedItemSubClassMask == 0))
+                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                else if (ToPlayer() && ToPlayer()->HasItemFitToSpellRequirements((*i)->GetSpellInfo()))
+                    AddPct(DoneTotalMod, (*i)->GetAmount());
+            }
+        }
+
+        if (spellProto->AttributesEx6 & SPELL_ATTR6_NO_DONE_PCT_DAMAGE_MODS)
+            DoneTotalMod = 1.0f;
+    }
+
+    // done scripted mod (take it from owner)
+    // Unit* owner = GetOwner() ? GetOwner() : this;
+    // AuraEffectList const& mOverrideClassScript = owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+
+    float tmpDamage = float(int32(pdamage) + DoneFlatBenefit) * DoneTotalMod;
+
+    // apply spellmod to Done damage
+    if (spellProto)
+        if (Player* modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_DAMAGE, tmpDamage);
+
+    // bonus result can be negative
+    return uint32(std::max(tmpDamage, 0.0f));
+}
+
+uint32 Unit::MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage, WeaponAttackType attType, SpellInfo const* spellProto)
+{
+    if (pdamage == 0)
+        return 0;
+
+    int32 TakenFlatBenefit = 0;
+    float TakenTotalCasterMod = 0.0f;
+
+    // get all auras from caster that allow the spell to ignore resistance (sanctified wrath)
+    SpellSchoolMask attackSchoolMask = spellProto ? spellProto->GetSchoolMask() : SPELL_SCHOOL_MASK_NORMAL;
+    AuraEffectList const& IgnoreResistAuras = attacker->GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
+    for (AuraEffectList::const_iterator i = IgnoreResistAuras.begin(); i != IgnoreResistAuras.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() & attackSchoolMask)
+            TakenTotalCasterMod += (float((*i)->GetAmount()));
+    }
+
+    // ..taken
+    AuraEffectList const& mDamageTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
+    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
+        if ((*i)->GetMiscValue() & GetMeleeDamageSchoolMask())
+            TakenFlatBenefit += (*i)->GetAmount();
+
+    if (attType != RANGED_ATTACK)
+        TakenFlatBenefit += GetTotalAuraModifier(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN);
+    else
+        TakenFlatBenefit += GetTotalAuraModifier(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN);
+
+    // Taken total percent damage auras
+    float TakenTotalMod = 1.0f;
+
+    // ..taken
+    TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, GetMeleeDamageSchoolMask());
+
+    // .. taken pct (special attacks)
+    if (spellProto)
+    {
+        // From caster spells
+        AuraEffectList const& mOwnerTaken = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER);
+        for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)
+            if ((*i)->GetCasterGUID() == attacker->GetGUID() && (*i)->IsAffectingSpell(spellProto))
+                AddPct(TakenTotalMod, (*i)->GetAmount());
+
+        // Mod damage from spell mechanic
+        uint32 mechanicMask = spellProto->GetAllEffectsMechanicMask();
+
+        // Shred, Maul - "Effects which increase Bleed damage also increase Shred damage"
+        if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags[0] & 0x00008800)
+            mechanicMask |= (1<<MECHANIC_BLEED);
+
+        if (mechanicMask)
+        {
+            AuraEffectList const& mDamageDoneMechanic = GetAuraEffectsByType(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT);
+            for (AuraEffectList::const_iterator i = mDamageDoneMechanic.begin(); i != mDamageDoneMechanic.end(); ++i)
+                if (mechanicMask & uint32(1<<((*i)->GetMiscValue())))
+                    AddPct(TakenTotalMod, (*i)->GetAmount());
+        }
+    }
+
+    // .. taken pct: dummy auras
+    AuraEffectList const& mDummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+    for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
+    {
+        switch ((*i)->GetSpellInfo()->SpellIconID)
+        {
+            // Cheat Death
+            case 2109:
+                if ((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        continue;
+
+                    AddPct(TakenTotalMod, (*i)->GetAmount());
+                }
+                break;
+        }
+    }
+
+    // .. taken pct: class scripts
+    //*AuraEffectList const& mclassScritAuras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+    //for (AuraEffectList::const_iterator i = mclassScritAuras.begin(); i != mclassScritAuras.end(); ++i)
+    //{
+    //    switch ((*i)->GetMiscValue())
+    //    {
+    //    }
+    //}*/
+
+    if (attType != RANGED_ATTACK)
+    {
+        AuraEffectList const& mModMeleeDamageTakenPercent = GetAuraEffectsByType(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT);
+        for (AuraEffectList::const_iterator i = mModMeleeDamageTakenPercent.begin(); i != mModMeleeDamageTakenPercent.end(); ++i)
+            AddPct(TakenTotalMod, (*i)->GetAmount());
+    }
+    else
+    {
+        AuraEffectList const& mModRangedDamageTakenPercent = GetAuraEffectsByType(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT);
+        for (AuraEffectList::const_iterator i = mModRangedDamageTakenPercent.begin(); i != mModRangedDamageTakenPercent.end(); ++i)
+            AddPct(TakenTotalMod, (*i)->GetAmount());
+    }
+
+    float tmpDamage = 0.0f;
+
+    if (TakenTotalCasterMod)
+    {
+        if (TakenFlatBenefit < 0)
+        {
+            if (TakenTotalMod < 1)
+                tmpDamage = ((float(CalculatePct(pdamage, TakenTotalCasterMod) + TakenFlatBenefit) * TakenTotalMod) + CalculatePct(pdamage, TakenTotalCasterMod));
+            else
+                tmpDamage = ((float(CalculatePct(pdamage, TakenTotalCasterMod) + TakenFlatBenefit) + CalculatePct(pdamage, TakenTotalCasterMod)) * TakenTotalMod);
+        }
+        else if (TakenTotalMod < 1)
+            tmpDamage = ((CalculatePct(float(pdamage) + TakenFlatBenefit, TakenTotalCasterMod) * TakenTotalMod) + CalculatePct(float(pdamage) + TakenFlatBenefit, TakenTotalCasterMod));
+    }
+    if (!tmpDamage)
+        tmpDamage = (float(pdamage) + TakenFlatBenefit) * TakenTotalMod;
+
+    // bonus result can be negative
+    return uint32(std::max(tmpDamage, 0.0f));
+}
+
+void Unit::ApplyUberImmune(uint32 spellid, bool apply)
+{
+    if (apply)
+        RemoveAurasWithMechanic(IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK, AURA_REMOVE_BY_DEFAULT, spellid);
+    for (uint32 mech=MECHANIC_CHARM; mech!=MECHANIC_ENRAGED; ++mech)
+    {
+        if (mech == MECHANIC_DISARM)
+            continue;
+        if (1<<mech & IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK)
+            ApplySpellImmune(spellid, IMMUNITY_MECHANIC, mech, apply);
+    }
+}
+
+void Unit::ApplySpellImmune(uint32 spellId, uint32 op, uint32 type, bool apply)
+{
+    if (apply)
+    {
+        for (SpellImmuneList::iterator itr = m_spellImmune[op].begin(), next; itr != m_spellImmune[op].end(); itr = next)
+        {
+            next = itr; ++next;
+            if (itr->type == type)
+            {
+                m_spellImmune[op].erase(itr);
+                next = m_spellImmune[op].begin();
+            }
+        }
+        SpellImmune Immune;
+        Immune.spellId = spellId;
+        Immune.type = type;
+        m_spellImmune[op].push_back(Immune);
+    }
+    else
+    {
+        for (SpellImmuneList::iterator itr = m_spellImmune[op].begin(); itr != m_spellImmune[op].end(); ++itr)
+        {
+            if (itr->spellId == spellId && itr->type == type)
+            {
+                m_spellImmune[op].erase(itr);
+                break;
+            }
+        }
+    }
+}
+
+void Unit::ApplySpellDispelImmunity(const SpellInfo* spellProto, DispelType type, bool apply)
+{
+    ApplySpellImmune(spellProto->Id, IMMUNITY_DISPEL, type, apply);
+
+    if (apply && spellProto->AttributesEx & SPELL_ATTR1_DISPEL_AURAS_ON_IMMUNITY)
+    {
+        // Create dispel mask by dispel type
+        uint32 dispelMask = SpellInfo::GetDispelMask(type);
+        // Dispel all existing auras vs current dispel type
+        AuraApplicationMap& auras = GetAppliedAuras();
+        for (AuraApplicationMap::iterator itr = auras.begin(); itr != auras.end();)
+        {
+            SpellInfo const* spell = itr->second->GetBase()->GetSpellInfo();
+            if (spell->GetDispelMask() & dispelMask)
+            {
+                // Dispel aura
+                RemoveAura(itr);
+            }
+            else
+                ++itr;
+        }
+    }
+}
+
+float Unit::GetWeaponProcChance() const
+{
+    // normalized proc chance for weapon attack speed
+    // (odd formula...)
+    if (isAttackReady(BASE_ATTACK))
+        return (GetAttackTime(BASE_ATTACK) * 1.8f / 1000.0f);
+    else if (haveOffhandWeapon() && isAttackReady(OFF_ATTACK))
+        return (GetAttackTime(OFF_ATTACK) * 1.6f / 1000.0f);
+    return 0;
+}
+
+float Unit::GetPPMProcChance(uint32 WeaponSpeed, float PPM, const SpellInfo* spellProto) const
+{
+    // proc per minute chance calculation
+    if (PPM <= 0)
+        return 0.0f;
+
+    // Apply chance modifer aura
+    if (spellProto)
+        if (Player* modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_PROC_PER_MINUTE, PPM);
+
+    return floor((WeaponSpeed * PPM) / 600.0f);   // result is chance in percents (probability = Speed_in_sec * (PPM / 60))
+}
+
+void Unit::Mount(uint32 mount, uint32 VehicleId, uint32 creatureEntry)
+{
+    if (mount)
+        SetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID, mount);
+
+    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT);
+
+    if (Player* player = ToPlayer())
+    {
+        // mount as a vehicle
+        if (VehicleId)
+        {
+            if (CreateVehicleKit(VehicleId, creatureEntry))
+            {
+                // Send others that we now have a vehicle
+                WorldPacket data(SMSG_PLAYER_VEHICLE_DATA, GetPackGUID().size()+4);
+                data.appendPackGUID(GetGUID());
+                data << uint32(VehicleId);
+                SendMessageToSet(&data, true);
+
+                data.Initialize(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);
+                player->GetSession()->SendPacket(&data);
+
+                // mounts can also have accessories
+                GetVehicleKit()->InstallAllAccessories(false);
+            }
+        }
+
+		// unsummon pet
+		Pet* pet = player->GetPet();
+		if (pet)
+		{
+			Battleground* bg = ToPlayer()->GetBattleground();
+			// don't unsummon pet in arena & Battlegrounds but SetFlag UNIT_FLAG_STUNNED to disable pet's interface
+			if (bg)
+				pet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+			else
+				player->UnsummonPetTemporaryIfAny();
+		}
+
+        player->SendMovementSetCollisionHeight(player->GetCollisionHeight(true));
+    }
+
+    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOUNT);
+}
+
+void Unit::Dismount()
+{
+    if (!IsMounted())
+        return;
+
+    SetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID, 0);
+    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT);
+
+    if (Player* thisPlayer = ToPlayer())
+        thisPlayer->SendMovementSetCollisionHeight(thisPlayer->GetCollisionHeight(false));
+
+    WorldPacket data(SMSG_DISMOUNT, 8);
+    data.appendPackGUID(GetGUID());
+    SendMessageToSet(&data, true);
+
+    // dismount as a vehicle
+    if (GetTypeId() == TYPEID_PLAYER && GetVehicleKit())
+    {
+        // Send other players that we are no longer a vehicle
+        data.Initialize(SMSG_PLAYER_VEHICLE_DATA, 8+4);
+        data.appendPackGUID(GetGUID());
+        data << uint32(0);
+        ToPlayer()->SendMessageToSet(&data, true);
+        // Remove vehicle from player
+        RemoveVehicleKit();
+    }
+
+    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_MOUNTED);
+
+    // only resummon old pet if the player is already added to a map
+    // this prevents adding a pet to a not created map which would otherwise cause a crash
+    // (it could probably happen when logging in after a previous crash)
+    if (Player* player = ToPlayer())
+    {
+        if (Pet* pPet = player->GetPet())
+        {
+            if (pPet->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED) && !pPet->HasUnitState(UNIT_STATE_STUNNED))
+                pPet->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+        }
+        else
+            player->ResummonPetTemporaryUnSummonedIfAny();
+    }
+}
+
+MountCapabilityEntry const* Unit::GetMountCapability(uint32 mountType) const
+{
+    if (!mountType)
+        return NULL;
+
+    MountTypeEntry const* mountTypeEntry = sMountTypeStore.LookupEntry(mountType);
+    if (!mountTypeEntry)
+        return NULL;
+
+    uint32 zoneId, areaId;
+    GetZoneAndAreaId(zoneId, areaId);
+    uint32 ridingSkill = 5000;
+    if (GetTypeId() == TYPEID_PLAYER)
+        ridingSkill = ToPlayer()->GetSkillValue(SKILL_RIDING);
+
+    for (uint32 i = MAX_MOUNT_CAPABILITIES; i > 0; --i)
+    {
+        MountCapabilityEntry const* mountCapability = sMountCapabilityStore.LookupEntry(mountTypeEntry->MountCapability[i - 1]);
+        if (!mountCapability)
+            continue;
+
+        if (ridingSkill < mountCapability->RequiredRidingSkill)
+            continue;
+
+        if (HasExtraUnitMovementFlag(MOVEMENTFLAG2_FULL_SPEED_PITCHING))
+        {
+            if (!(mountCapability->Flags & MOUNT_FLAG_CAN_PITCH))
+                continue;
+        }
+        else if (HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+        {
+            if (!(mountCapability->Flags & MOUNT_FLAG_CAN_SWIM))
+                continue;
+        }
+        else if (!(mountCapability->Flags & 0x1))   // unknown flags, checked in 4.2.2 14545 client
+        {
+            if (!(mountCapability->Flags & 0x2))
+                continue;
+        }
+
+        if (mountCapability->RequiredMap != -1 && int32(GetMapId()) != mountCapability->RequiredMap)
+            continue;
+
+        if (mountCapability->RequiredArea && (mountCapability->RequiredArea != zoneId && mountCapability->RequiredArea != areaId))
+            continue;
+
+        if (mountCapability->RequiredAura && !HasAura(mountCapability->RequiredAura))
+            continue;
+
+        if (mountCapability->RequiredSpell && (GetTypeId() != TYPEID_PLAYER || !ToPlayer()->HasSpell(mountCapability->RequiredSpell)))
+            continue;
+
+        return mountCapability;
+    }
+
+    return NULL;
+}
+
+void Unit::SetInCombatWith(Unit* enemy)
+{
+    Unit* eOwner = enemy->GetCharmerOrOwnerOrSelf();
+    if (eOwner->IsPvP())
+    {
+        SetInCombatState(true, enemy);
+        return;
+    }
+
+    // check for duel
+    if (eOwner->GetTypeId() == TYPEID_PLAYER && eOwner->ToPlayer()->duel)
+    {
+        Unit const* myOwner = GetCharmerOrOwnerOrSelf();
+        if (((Player const*)eOwner)->duel->opponent == myOwner)
+        {
+            SetInCombatState(true, enemy);
+            return;
+        }
+    }
+    SetInCombatState(false, enemy);
+}
+
+bool Unit::IsInCombat(Unit* target) const
+{
+    Unit::AttackerSet const& attackers = getAttackers();
+    return attackers.find(target) != attackers.end();
+}
+
+void Unit::CombatStart(Unit* target, bool initialAggro)
+{
+    if (initialAggro)
+    {
+        if (!target->IsStandState())
+            target->SetStandState(UNIT_STAND_STATE_STAND);
+
+        if (!target->isInCombat() && target->GetTypeId() != TYPEID_PLAYER
+            && !target->ToCreature()->HasReactState(REACT_PASSIVE) && target->ToCreature()->IsAIEnabled)
+        {
+            if (target->isPet())
+                target->ToCreature()->AI()->AttackedBy(this); // PetAI has special handler before AttackStart()
+            else
+                target->ToCreature()->AI()->AttackStart(this);
+        }
+
+        if (target->GetTypeId() == TYPEID_UNIT && !target->ToCreature()->isPet())
+            target->AddThreat(this, 0.0f);
+
+        SetInCombatWith(target);
+        target->SetInCombatWith(this);
+    }
+    Unit* who = target->GetCharmerOrOwnerOrSelf();
+    if (who->GetTypeId() == TYPEID_PLAYER)
+      SetContestedPvP(who->ToPlayer());
+
+    Player* me = GetCharmerOrOwnerPlayerOrPlayerItself();
+    if (me && who->IsPvP()
+        && (who->GetTypeId() != TYPEID_PLAYER
+        || !me->duel || me->duel->opponent != who))
+    {
+        me->UpdatePvP(true);
+        me->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT);
+    }
+}
+
+void Unit::SetInCombatState(bool PvP, Unit* enemy)
+{
+    // only alive units can be in combat
+    if (!isAlive())
+        return;
+
+    if (PvP || (enemy && enemy->ToCreature() && enemy->ToCreature()->GetScriptName() == "npc_training_dummy"))
+        m_CombatTimer = 5500;
+
+    if (isInCombat() || HasUnitState(UNIT_STATE_EVADE))
+        return;
+
+    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
+
+    if (Creature* creature = ToCreature())
+    {
+        // Set home position at place of engaging combat for escorted creatures
+        if ((IsAIEnabled && creature->AI()->IsEscorted()) ||
+            GetMotionMaster()->GetCurrentMovementGeneratorType() == WAYPOINT_MOTION_TYPE ||
+            GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
+            creature->SetHomePosition(GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
+
+        if (enemy)
+        {
+            if (IsAIEnabled)
+            {
+                creature->AI()->EnterCombat(enemy);
+                RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC); // unit has engaged in combat, remove immunity so players can fight back
+            }
+            if (creature->GetFormation())
+                creature->GetFormation()->MemberAttackStart(creature, enemy);
+        }
+
+        if (isPet())
+        {
+            UpdateSpeed(MOVE_RUN, true);
+            UpdateSpeed(MOVE_SWIM, true);
+            UpdateSpeed(MOVE_FLIGHT, true);
+        }
+
+        if (!(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_MOUNTED_COMBAT))
+            Dismount();
+    }
+
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+    {
+        if (!(*itr)->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
+        {
+            (*itr)->SetInCombatState(PvP, enemy);
+            (*itr)->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
+        }
+    }
+}
+
+void Unit::ClearInCombat()
+{
+    m_CombatTimer = 0;
+    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
+
+    // Player's state will be cleared in Player::UpdateContestedPvP
+    if (Creature* creature = ToCreature())
+    {
+        if (creature->GetCreatureTemplate() && creature->GetCreatureTemplate()->unit_flags & UNIT_FLAG_IMMUNE_TO_PC)
+            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC); // set immunity state to the one from db on evade
+
+        ClearUnitState(UNIT_STATE_ATTACK_PLAYER);
+        if (HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_TAPPED))
+            SetUInt32Value(UNIT_DYNAMIC_FLAGS, creature->GetCreatureTemplate()->dynamicflags);
+
+        if (creature->isPet())
+        {
+            if (Unit* owner = GetOwner())
+                for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
+                    if (owner->GetSpeedRate(UnitMoveType(i)) > GetSpeedRate(UnitMoveType(i)))
+                        SetSpeed(UnitMoveType(i), owner->GetSpeedRate(UnitMoveType(i)), true);
+        }
+        else if (!isCharmed())
+            return;
+    }
+    else
+    {
+        ToPlayer()->UpdatePotionCooldown();
+        ToPlayer()->m_holyPowerRegenTimerCount = 0;
+    }
+
+    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
+}
+
+bool Unit::isTargetableForAttack(bool checkFakeDeath) const
+{
+    if (!isAlive())
+        return false;
+
+    if (HasFlag(UNIT_FIELD_FLAGS,
+        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_IMMUNE_TO_PC))
+        return false;
+
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->isGameMaster())
+        return false;
+
+    return !HasUnitState(UNIT_STATE_UNATTACKABLE) && (!checkFakeDeath || !HasUnitState(UNIT_STATE_DIED));
+}
+
+bool Unit::IsValidAttackTarget(Unit const* target) const
+{
+    return _IsValidAttackTarget(target, NULL);
+}
+
+// function based on function Unit::CanAttack from 13850 client
+bool Unit::_IsValidAttackTarget(Unit const* target, SpellInfo const* bySpell, WorldObject const* obj) const
+{
+	ASSERT(target);
+
+	bool areaSpell = false;
+	if (bySpell)
+		areaSpell = bySpell->IsAffectingArea();
+
+	// can't attack self
+	if (this == target)
+		return false;
+
+	if (target->GetEntry() == 53087 || target->GetEntry() == 52577)
+		return true;
+
+	// can't attack unattackable units or GMs
+	if (target->HasUnitState(UNIT_STATE_UNATTACKABLE)
+		|| (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->isGameMaster()))
+		return false;
+
+	// can't attack own vehicle or passenger
+	if (m_vehicle)
+	if (IsOnVehicle(target) || m_vehicle->GetBase()->IsOnVehicle(target))
+		return false;
+
+	// can't attack invisible (ignore stealth for aoe spells) also if the area being looked at is from a spell use the dynamic object created instead of the casting unit.
+	if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE))
+		&& (obj ? (!obj->canSeeOrDetect(target, bySpell && bySpell->IsAffectingArea()
+		&& (obj->GetTypeId() != TYPEID_GAMEOBJECT || obj->ToGameObject()->GetGoType() != GAMEOBJECT_TYPE_TRAP)))
+		: !canSeeOrDetect(target, bySpell && bySpell->IsAffectingArea())
+		&& GetGoType() != GAMEOBJECT_TYPE_TRAP))
+
+	// can't attack dead
+	if ((!bySpell || !bySpell->IsAllowingDeadTarget()) && !target->isAlive())
+		return false;
+
+	// can't attack untargetable
+	if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_UNTARGETABLE))
+		&& target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+		return false;
+
+	if (Player const* playerAttacker = ToPlayer())
+	{
+		if (playerAttacker->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_UNK19))
+			return false;
+	}
+
+	// check flags
+	if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_TAXI_FLIGHT | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_UNK_16)
+		|| (!HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))
+		|| (!target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC)))
+		return false;
+
+	if ((!bySpell || !(bySpell->AttributesEx8 & SPELL_ATTR8_ATTACK_IGNORE_IMMUNE_TO_PC_FLAG))
+		&& (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
+		// check if this is a world trigger cast - GOs are using world triggers to cast their spells, so we need to ignore their immunity flag here, this is a temp workaround, needs removal when go cast is implemented properly
+		&& GetEntry() != WORLD_TRIGGER)
+		return false;
+
+	// CvC case - can attack each other only when one of them is hostile
+	if (!HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && !target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
+		return GetReactionTo(target) <= REP_HOSTILE || target->GetReactionTo(this) <= REP_HOSTILE;
+
+	// PvP, PvC, CvP case
+	// can't attack friendly targets
+	if (GetReactionTo(target) > REP_NEUTRAL
+		|| target->GetReactionTo(this) > REP_NEUTRAL)
+		return false;
+
+	// Not all neutral creatures can be attacked
+	if (GetReactionTo(target) == REP_NEUTRAL &&
+		target->GetReactionTo(this) == REP_NEUTRAL)
+	{
+		if (!(target->GetTypeId() == TYPEID_PLAYER && GetTypeId() == TYPEID_PLAYER) &&
+			!(target->GetTypeId() == TYPEID_UNIT && GetTypeId() == TYPEID_UNIT))
+		{
+			Player const* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : ToPlayer();
+			Unit const* creature = target->GetTypeId() == TYPEID_UNIT ? target : this;
+
+			{
+				if (FactionTemplateEntry const* factionTemplate = creature->getFactionTemplateEntry())
+				if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(factionTemplate->faction))
+				if (FactionState const* repState = player->GetReputationMgr().GetState(factionEntry))
+				if (!(repState->Flags & FACTION_FLAG_AT_WAR))
+					return false;
+			}
+		}
+	}
+
+	Creature const* creatureAttacker = ToCreature();
+	if (creatureAttacker && creatureAttacker->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER)
+		return false;
+
+	Player const* playerAffectingAttacker = HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) ? GetAffectingPlayer() : NULL;
+	Player const* playerAffectingTarget = target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) ? target->GetAffectingPlayer() : NULL;
+
+	// check duel - before sanctuary checks
+	if (playerAffectingAttacker && playerAffectingTarget)
+	if (playerAffectingAttacker->duel && playerAffectingAttacker->duel->opponent == playerAffectingTarget && playerAffectingAttacker->duel->startTime != 0)
+		return true;
+
+	// PvP case - can't attack when attacker or target are in sanctuary
+	// however, 13850 client doesn't allow to attack when one of the unit's has sanctuary flag and is pvp
+	if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE)
+		&& ((target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_SANCTUARY) || (GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_SANCTUARY)))
+		return false;
+
+	// additional checks - only PvP case
+	if (playerAffectingAttacker && playerAffectingTarget)
+	{
+		if (target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_PVP)
+			return true;
+
+		if (GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP
+			&& target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP)
+			return true;
+
+		return (GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_UNK1)
+			|| (target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_UNK1);
+	}
+	return true;
+}
+
+bool Unit::IsValidAssistTarget(Unit const* target) const
+{
+    return _IsValidAssistTarget(target, NULL);
+}
+
+// function based on function Unit::CanAssist from 13850 client
+bool Unit::_IsValidAssistTarget(Unit const* target, SpellInfo const* bySpell) const
+{
+	ASSERT(target);
+
+	// can assist to self
+	if (this == target)
+		return true;
+
+	// can't assist unattackable units or GMs
+	if (target->HasUnitState(UNIT_STATE_UNATTACKABLE)
+		|| (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->isGameMaster()))
+		return false;
+
+	// can't assist own vehicle or passenger
+	if (m_vehicle)
+	if (IsOnVehicle(target) || m_vehicle->GetBase()->IsOnVehicle(target))
+		return false;
+
+	// can't assist invisible
+	if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_INVISIBLE)) && !canSeeOrDetect(target, bySpell && bySpell->IsAffectingArea()))
+		return false;
+
+	// can't assist dead
+	if ((!bySpell || !bySpell->IsAllowingDeadTarget()) && !target->isAlive())
+		return false;
+
+	// can't assist untargetable
+	if ((!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_CAN_TARGET_UNTARGETABLE))
+		&& target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+		return false;
+
+	if (!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_ASSIST_IGNORE_IMMUNE_FLAG))
+	{
+		if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
+		{
+			if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC))
+				return false;
+		}
+		else
+		{
+			if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC))
+				return false;
+		}
+	}
+
+	// can't assist non-friendly targets
+	if (GetReactionTo(target) <= REP_NEUTRAL
+		&& target->GetReactionTo(this) <= REP_NEUTRAL
+		&& (!ToCreature() || !(ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER)))
+		return false;
+
+	// PvP case
+	if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
+	{
+		Player const* targetPlayerOwner = target->GetAffectingPlayer();
+		if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE))
+		{
+			Player const* selfPlayerOwner = GetAffectingPlayer();
+			if (selfPlayerOwner && targetPlayerOwner)
+			{
+				// can't assist player which is dueling someone
+				if (selfPlayerOwner != targetPlayerOwner
+					&& targetPlayerOwner->duel)
+					return false;
+			}
+			// can't assist player in ffa_pvp zone from outside
+			if ((target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP)
+				&& !(GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_FFA_PVP))
+				return false;
+			// can't assist player out of sanctuary from sanctuary if has pvp enabled
+			if (target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_PVP)
+			if ((GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_SANCTUARY) && !(target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_SANCTUARY))
+				return false;
+		}
+	}
+	// PvC case - player can assist creature only if has specific type flags
+	// !target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) &&
+	else if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE)
+		&& (!bySpell || !(bySpell->AttributesEx6 & SPELL_ATTR6_ASSIST_IGNORE_IMMUNE_FLAG))
+		&& !((target->GetByteValue(UNIT_FIELD_BYTES_2, 1) & UNIT_BYTE2_FLAG_PVP)))
+	{
+		if (Creature const* creatureTarget = target->ToCreature())
+			return creatureTarget->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER || creatureTarget->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_AID_PLAYERS;
+	}
+	return true;
+}
+int32 Unit::ModifyHealth(int32 dVal)
+{
+    int32 gain = 0;
+
+    if (dVal == 0)
+        return 0;
+
+    int32 curHealth = (int32)GetHealth();
+
+    int32 val = dVal + curHealth;
+    if (val <= 0)
+    {
+        SetHealth(0);
+        return -curHealth;
+    }
+
+    int32 maxHealth = (int32)GetMaxHealth();
+
+    if (val < maxHealth)
+    {
+        SetHealth(val);
+        gain = val - curHealth;
+    }
+    else if (curHealth != maxHealth)
+    {
+        SetHealth(maxHealth);
+        gain = maxHealth - curHealth;
+    }
+
+    return gain;
+}
+
+void Unit::ResetAllPowers()
+{
+    SetHealth(GetMaxHealth());
+    if (getClass() == CLASS_PALADIN)
+        SetPower(POWER_HOLY_POWER, 0);
+    switch (getPowerType())
+    {
+        case POWER_MANA:
+            SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+            break;
+        case POWER_RAGE:
+            SetPower(POWER_RAGE, 0);
+            break;
+        case POWER_ENERGY:
+            SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
+            break;
+        case POWER_RUNIC_POWER:
+            SetPower(POWER_RUNIC_POWER, 0);
+            break;
+        case POWER_ECLIPSE:
+            SetPower(POWER_ECLIPSE, 0);
+            break;
+		case POWER_ALTERNATE_POWER:
+            SetPower(POWER_ALTERNATE_POWER, 0);
+            SetAltPower(0);
+            break;
+        default:
+            break;
+    }
+}
+
+int32 Unit::GetHealthGain(int32 dVal)
+{
+    int32 gain = 0;
+
+    if (dVal == 0)
+        return 0;
+
+    int32 curHealth = (int32)GetHealth();
+
+    int32 val = dVal + curHealth;
+    if (val <= 0)
+    {
+        return -curHealth;
+    }
+
+    int32 maxHealth = (int32)GetMaxHealth();
+
+    if (val < maxHealth)
+        gain = dVal;
+    else if (curHealth != maxHealth)
+        gain = maxHealth - curHealth;
+
+    return gain;
+}
+
+// returns negative amount on power reduction
+int32 Unit::ModifyPower(Powers power, int32 dVal)
+{
+    int32 gain = 0;
+
+    if (dVal == 0)
+        return 0;
+
+    int32 curPower = GetPower(power);
+
+    int32 val = dVal + curPower;
+    if (val <= GetMinPower(power))
+    {
+        SetPower(power, GetMinPower(power));
+        return -curPower;
+    }
+
+    int32 maxPower = GetMaxPower(power);
+
+    if (val < maxPower)
+    {
+        SetPower(power, val);
+        gain = val - curPower;
+    }
+    else if (curPower != maxPower)
+    {
+        SetPower(power, maxPower);
+        gain = maxPower - curPower;
+    }
+    else if (power == POWER_HOLY_POWER && GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->m_holyPowerRegenTimerCount = 0;
+
+    return gain;
+}
+
+// returns negative amount on power reduction
+int32 Unit::ModifyPowerPct(Powers power, float pct, bool apply)
+{
+    float amount = (float)GetMaxPower(power);
+    ApplyPercentModFloatVar(amount, pct, apply);
+
+    return ModifyPower(power, (int32)amount - GetMaxPower(power));
+}
+
+int32 Unit::GetHolyPoints() const
+{
+    return HasAura(90174)
+            ? GetMaxPower(POWER_HOLY_POWER)
+            : GetPower(POWER_HOLY_POWER);
+}
+
+bool Unit::IsAlwaysVisibleFor(WorldObject const* seer) const
+{
+    if (WorldObject::IsAlwaysVisibleFor(seer))
+        return true;
+
+    // Always seen by owner
+    if (uint64 guid = GetCharmerOrOwnerGUID())
+        if (seer->GetGUID() == guid)
+            return true;
+
+    if (Player const* seerPlayer = seer->ToPlayer())
+        if (Unit* owner =  GetOwner())
+            if (Player* ownerPlayer = owner->ToPlayer())
+                if (ownerPlayer->IsGroupVisibleFor(seerPlayer))
+                    return true;
+
+    return false;
+}
+
+bool Unit::IsAlwaysDetectableFor(WorldObject const* seer) const
+{
+    if (WorldObject::IsAlwaysDetectableFor(seer))
+        return true;
+
+    if (HasAuraTypeWithCaster(SPELL_AURA_MOD_STALKED, seer->GetGUID()))
+        return true;
+
+    return false;
+}
+
+void Unit::SetVisible(bool x)
+{
+    if (!x)
+        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_GAMEMASTER);
+    else
+        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
+
+    UpdateObjectVisibility();
+}
+
+void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
+{
+    //if (this->ToPlayer())
+    //    sAnticheatMgr->DisableAnticheatDetection(this->ToPlayer());
+
+    int32 main_speed_mod  = 0;
+    float stack_bonus     = 1.0f;
+    float non_stack_bonus = 1.0f;
+
+    int32 movement_inc = 1;
+ 	
+	if (sWorld->getIntConfig(CONFIG_DOUBLE_MOVING) == 1)
+	{
+		Map* pMap = GetMap();
+		AreaTableEntry const* zone = GetAreaEntryByAreaID(GetZoneId());
+
+ 		if (!pMap->Instanceable() && ToPlayer() && !GetUInt64Value(PLAYER_DUEL_ARBITER))
+		{
+ 	 		if (zone && !(zone->flags & AREA_FLAG_WINTERGRASP || zone->ID == 5389 || zone->ID == 5095)) // TolBarad Zones
+ 	 		{
+ 		 		movement_inc = 2;
+ 			} else {
+	 	 		movement_inc = 1;
+ 	 		}
+		}
+	}
+
+    switch (mtype)
+    {
+        // Only apply debuffs
+        case MOVE_FLIGHT_BACK:
+        case MOVE_RUN_BACK:
+        case MOVE_SWIM_BACK:
+        case MOVE_WALK:
+            break;
+        case MOVE_RUN:
+        {
+            if (IsMounted()) // Use on mount auras
+            {
+                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED);
+                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_SPEED_ALWAYS)*movement_inc;;
+                non_stack_bonus += GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK) / 100.0f;
+            }
+            else
+            {
+                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_SPEED);
+                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_SPEED_ALWAYS)*movement_inc;;
+                non_stack_bonus += GetMaxPositiveAuraModifier(SPELL_AURA_MOD_SPEED_NOT_STACK) / 100.0f;
+            }
+            break;
+        }
+        case MOVE_SWIM:
+        {
+            main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_SWIM_SPEED)*movement_inc;;
+            break;
+        }
+        case MOVE_FLIGHT:
+        {
+            if (GetTypeId() == TYPEID_UNIT && IsControlledByPlayer()) // not sure if good for pet
+            {
+                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
+                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_VEHICLE_SPEED_ALWAYS);
+
+                // for some spells this mod is applied on vehicle owner
+                int32 owner_speed_mod = 0;
+
+                if (Unit* owner = GetCharmer())
+                    owner_speed_mod = owner->GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
+
+                main_speed_mod = std::max(main_speed_mod, owner_speed_mod);
+            }
+            else if (IsMounted())
+            {
+                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS)*movement_inc;;
+            }
+            else             // Use not mount (shapeshift for example) auras (should stack)
+                main_speed_mod  = GetTotalAuraModifier(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED) + GetTotalAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
+
+            non_stack_bonus += GetMaxPositiveAuraModifier(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK) / 100.0f;
+
+            // Update speed for vehicle if available
+            if (GetTypeId() == TYPEID_PLAYER && GetVehicle())
+                GetVehicleBase()->UpdateSpeed(MOVE_FLIGHT, true);
+            break;
+        }
+        default:
+            sLog->outError(LOG_FILTER_UNITS, "Unit::UpdateSpeed: Unsupported move type (%d)", mtype);
+            return;
+    }
+
+    // now we ready for speed calculation
+    float speed = std::max(non_stack_bonus, stack_bonus);
+    if (main_speed_mod)
+        AddPct(speed, main_speed_mod);
+
+    switch (mtype)
+    {
+        case MOVE_RUN:
+        case MOVE_SWIM:
+        case MOVE_FLIGHT:
+        {
+            // Set creature speed rate
+            if (GetTypeId() == TYPEID_UNIT)
+            {
+                Unit* pOwner = GetCharmerOrOwner();
+                if ((isPet() || isGuardian()) && !isInCombat() && pOwner) // Must check for owner or crash on "Tame Beast"
+                {
+                    // For every yard over 5, increase speed by 0.01
+                    //  to help prevent pet from lagging behind and despawning
+                    float dist = GetDistance(pOwner);
+                    float base_rate = 1.00f; // base speed is 100% of owner speed
+
+                    if (dist < 5)
+                        dist = 5;
+
+                    float mult = base_rate + ((dist - 5) * 0.01f);
+                    speed *= mult;
+
+                    if (pOwner->GetSpeedRate(mtype) > speed)
+                        speed *= pOwner->GetSpeedRate(mtype); // pets derive speed from owner when not in combat
+                }
+                else
+                    speed *= ToCreature()->GetCreatureTemplate()->speed_run;    // at this point, MOVE_WALK is never reached
+            }
+
+            // Normalize speed by 191 aura SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED if need
+            // TODO: possible affect only on MOVE_RUN
+            if (int32 normalization = GetMaxPositiveAuraModifier(SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED))
+            {
+                // Use speed from aura
+                float max_speed = normalization / (IsControlledByPlayer() ? playerBaseMoveSpeed[mtype] : baseMoveSpeed[mtype]);
+                if (speed > max_speed)
+                    speed = max_speed;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    // for creature case, we check explicit if mob searched for assistance
+    if (GetTypeId() == TYPEID_UNIT)
+    {
+        if (ToCreature()->HasSearchedAssistance())
+            speed *= 0.66f;                                 // best guessed value, so this will be 33% reduction. Based off initial speed, mob can then "run", "walk fast" or "walk".
+    }
+
+    // Apply strongest slow aura mod to speed
+    int32 slow = GetMaxNegativeAuraModifier(SPELL_AURA_MOD_DECREASE_SPEED);
+    if (slow)
+    {
+        AddPct(speed, slow);
+        if (float minSpeedMod = (float)GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MINIMUM_SPEED))
+        {
+            float min_speed = minSpeedMod / 100.0f;
+            if (speed < min_speed)
+                speed = min_speed;
+        }
+    }
+    SetSpeed(mtype, speed, forced);
+}
+
+float Unit::GetSpeed(UnitMoveType mtype) const
+{
+    return m_speed_rate[mtype]*(IsControlledByPlayer() ? playerBaseMoveSpeed[mtype] : baseMoveSpeed[mtype]);
+}
+
+void Unit::SetSpeed(UnitMoveType mtype, float rate, bool forced)
+{
+    if (rate < 0)
+        rate = 0.0f;
+
+    // Update speed only on change
+    if (m_speed_rate[mtype] == rate)
+        return;
+
+    m_speed_rate[mtype] = rate;
+
+    propagateSpeedChange();
+
+    static Opcodes const moveTypeToOpcode[MAX_MOVE_TYPE][2] =
+    {
+        {SMSG_SPLINE_MOVE_SET_WALK_SPEED, SMSG_MOVE_SET_WALK_SPEED },
+        {SMSG_SPLINE_MOVE_SET_RUN_SPEED, SMSG_MOVE_SET_RUN_SPEED },
+        {SMSG_SPLINE_MOVE_SET_RUN_BACK_SPEED, SMSG_MOVE_SET_RUN_BACK_SPEED },
+        {SMSG_SPLINE_MOVE_SET_SWIM_SPEED, SMSG_MOVE_SET_SWIM_SPEED },
+        {SMSG_SPLINE_MOVE_SET_SWIM_BACK_SPEED, SMSG_MOVE_SET_SWIM_BACK_SPEED },
+        {SMSG_SPLINE_MOVE_SET_TURN_RATE, SMSG_MOVE_SET_TURN_RATE },
+        {SMSG_SPLINE_MOVE_SET_FLIGHT_SPEED,  SMSG_MOVE_SET_FLIGHT_SPEED },
+        {SMSG_SPLINE_MOVE_SET_FLIGHT_BACK_SPEED, SMSG_MOVE_SET_FLIGHT_BACK_SPEED },
+        {SMSG_SPLINE_MOVE_SET_PITCH_RATE, SMSG_MOVE_SET_PITCH_RATE },
+    };
+
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer())
+    {
+        ToPlayer()->m_forced_speed_changes[mtype] = m_movementCounter;
+
+        if (!isInCombat())
+            if (Pet* pet = ToPlayer()->GetPet())
+                pet->SetSpeed(mtype, m_speed_rate[mtype], forced);
+    }
+
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.ackCount = m_movementCounter++;
+    info.ackSpeed = GetSpeed(mtype);
+    info.guid = GetGUID();
+    Movement::PacketSender(this, moveTypeToOpcode[mtype][0], moveTypeToOpcode[mtype][1], &info).Send();
+}
+
+void Unit::setDeathState(DeathState s)
+{
+    if (s != ALIVE && s != JUST_RESPAWNED)
+    {
+        CombatStop();
+        DeleteThreatList();
+        m_deathState = s;
+        getHostileRefManager().deleteReferences();
+
+        if (IsNonMeleeSpellCasted(false))
+            InterruptNonMeleeSpells(false);
+
+        ExitVehicle();                                      // Exit vehicle before calling RemoveAllControlled
+                                                            // vehicles use special type of charm that is not removed by the next function
+                                                            // triggering an assert
+        UnsummonAllTotems();
+        RemoveAllControlled();
+        RemoveAllAurasOnDeath();
+    }
+
+    m_deathState = s;
+    if (s == JUST_DIED)
+    {
+        ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, false);
+        ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, false);
+        // remove aurastates allowing special moves
+        ClearAllReactives();
+        ClearDiminishings();
+        if (IsInWorld())
+        {
+            // Only clear MotionMaster for entities that exists in world
+            // Avoids crashes in the following conditions :
+            //  * Using 'call pet' on dead pets
+            //  * Using 'call stabled pet'
+            //  * Logging in with dead pets
+            GetMotionMaster()->Clear(false);
+            GetMotionMaster()->MoveIdle();
+        }
+        StopMoving();
+        DisableSpline();
+        // without this when removing IncreaseMaxHealth aura player may stuck with 1 hp
+        // do not why since in IncreaseMaxHealth currenthealth is checked
+        SetHealth(0);
+        SetPower(getPowerType(), 0);
+
+        // players in instance don't have ZoneScript, but they have InstanceScript
+        if (ZoneScript* zoneScript = GetZoneScript() ? GetZoneScript() : GetInstanceScript())
+            zoneScript->OnUnitDeath(this);
+    }
+    else if (s == JUST_RESPAWNED)
+        RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE); // clear skinnable for creature and player (at battleground)
+}
+
+/*########################################
+########                          ########
+########       AGGRO SYSTEM       ########
+########                          ########
+########################################*/
+bool Unit::CanHaveThreatList() const
+{
+    // only creatures can have threat list
+    if (GetTypeId() != TYPEID_UNIT)
+        return false;
+
+    // only alive units can have threat list
+    if (!isAlive() || isDying())
+        return false;
+
+    // totems can not have threat list
+    if (ToCreature()->isTotem())
+        return false;
+
+    // Dummys don't have threat lists
+    if (ToCreature()->GetScriptName() == "npc_training_dummy")
+        return false;
+
+    // vehicles can not have threat list
+    //if (ToCreature()->IsVehicle())
+    //    return false;
+
+    // summons can not have a threat list, unless they are controlled by a creature
+    if (HasUnitTypeMask(UNIT_MASK_MINION | UNIT_MASK_GUARDIAN | UNIT_MASK_CONTROLABLE_GUARDIAN) && IS_PLAYER_GUID(((Pet*)this)->GetOwnerGUID()))
+        return false;
+
+    return true;
+}
+
+//======================================================================
+
+float Unit::ApplyTotalThreatModifier(float fThreat, SpellSchoolMask schoolMask)
+{
+    if (!HasAuraType(SPELL_AURA_MOD_THREAT) || fThreat < 0)
+        return fThreat;
+
+    SpellSchools school = GetFirstSchoolInMask(schoolMask);
+
+    return fThreat * m_threatModifier[school];
+}
+
+//======================================================================
+
+void Unit::AddThreat(Unit* victim, float fThreat, SpellSchoolMask schoolMask, SpellInfo const* threatSpell)
+{
+    // Only mobs can manage threat lists
+    if (CanHaveThreatList())
+        m_ThreatManager.addThreat(victim, fThreat, schoolMask, threatSpell);
+}
+
+//======================================================================
+
+void Unit::DeleteThreatList()
+{
+    if (CanHaveThreatList() && !m_ThreatManager.isThreatListEmpty())
+        SendClearThreatListOpcode();
+    m_ThreatManager.clearReferences();
+}
+
+//======================================================================
+
+void Unit::TauntApply(Unit* taunter)
+{
+    ASSERT(GetTypeId() == TYPEID_UNIT);
+
+    if (!taunter || (taunter->GetTypeId() == TYPEID_PLAYER && taunter->ToPlayer()->isGameMaster()))
+        return;
+
+    if (!CanHaveThreatList())
+        return;
+
+    Creature* creature = ToCreature();
+
+    if (creature->HasReactState(REACT_PASSIVE))
+        return;
+
+    Unit* target = GetVictim();
+    if (target && target == taunter)
+        return;
+
+    SetInFront(taunter);
+    if (creature->IsAIEnabled)
+        creature->AI()->AttackStart(taunter);
+
+    //m_ThreatManager.tauntApply(taunter);
+}
+
+//======================================================================
+
+void Unit::TauntFadeOut(Unit* taunter)
+{
+    ASSERT(GetTypeId() == TYPEID_UNIT);
+
+    if (!taunter || (taunter->GetTypeId() == TYPEID_PLAYER && taunter->ToPlayer()->isGameMaster()))
+        return;
+
+    if (!CanHaveThreatList())
+        return;
+
+    Creature* creature = ToCreature();
+
+    if (creature->HasReactState(REACT_PASSIVE))
+        return;
+
+    Unit* target = GetVictim();
+    if (!target || target != taunter)
+        return;
+
+    if (m_ThreatManager.isThreatListEmpty())
+    {
+        if (creature->IsAIEnabled)
+            creature->AI()->EnterEvadeMode();
+        return;
+    }
+
+    target = creature->SelectVictim();  // might have more taunt auras remaining
+
+    if (target && target != taunter)
+    {
+        SetInFront(target);
+        if (creature->IsAIEnabled)
+            creature->AI()->AttackStart(target);
+    }
+}
+
+//======================================================================
+
+Unit* Creature::SelectVictim()
+{
+    // function provides main threat functionality
+    // next-victim-selection algorithm and evade mode are called
+    // threat list sorting etc.
+
+    Unit* target = NULL;
+    // First checking if we have some taunt on us
+    AuraEffectList const& tauntAuras = GetAuraEffectsByType(SPELL_AURA_MOD_TAUNT);
+    if (!tauntAuras.empty())
+    {
+        Unit* caster = tauntAuras.back()->GetCaster();
+
+        // The last taunt aura caster is alive an we are happy to attack him
+        if (caster && caster->isAlive())
+            return GetVictim();
+        else if (tauntAuras.size() > 1)
+        {
+            // We do not have last taunt aura caster but we have more taunt auras,
+            // so find first available target
+
+            // Auras are pushed_back, last caster will be on the end
+            AuraEffectList::const_iterator aura = --tauntAuras.end();
+            do
+            {
+                --aura;
+                caster = (*aura)->GetCaster();
+                if (caster && canSeeOrDetect(caster, true) && IsValidAttackTarget(caster) && caster->isInAccessiblePlaceFor(ToCreature()))
+                {
+                    target = caster;
+                    break;
+                }
+            } while (aura != tauntAuras.begin());
+        }
+        else
+            target = GetVictim();
+    }
+
+    if (CanHaveThreatList())
+    {
+        if (!target && !m_ThreatManager.isThreatListEmpty())
+            // No taunt aura or taunt aura caster is dead standard target selection
+            target = m_ThreatManager.getHostilTarget();
+    }
+    else if (!HasReactState(REACT_PASSIVE))
+    {
+        // We have player pet probably
+        target = getAttackerForHelper();
+        if (!target && isSummon())
+        {
+            if (Unit* owner = ToTempSummon()->GetOwner())
+            {
+                if (owner->isInCombat())
+                    target = owner->getAttackerForHelper();
+                if (!target)
+                {
+                    for (ControlList::const_iterator itr = owner->m_Controlled.begin(); itr != owner->m_Controlled.end(); ++itr)
+                    {
+                        if ((*itr)->isInCombat())
+                        {
+                            target = (*itr)->getAttackerForHelper();
+                            if (target)
+                                break;
+                        }
+                    }
+                }
+            }
+        }
+    }
+    else
+        return NULL;
+
+    if (target && _IsTargetAcceptable(target) && canCreatureAttack(target))
+    {
+        SetInFront(target);
+        return target;
+    }
+
+    // last case when creature must not go to evade mode:
+    // it in combat but attacker not make any damage and not enter to aggro radius to have record in threat list
+    // for example at owner command to pet attack some far away creature
+    // Note: creature does not have targeted movement generator but has attacker in this case
+    for (AttackerSet::const_iterator itr = m_attackers.begin(); itr != m_attackers.end(); ++itr)
+    {
+        if ((*itr) && !canCreatureAttack(*itr) && (*itr)->GetTypeId() != TYPEID_PLAYER
+        && !(*itr)->ToCreature()->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
+            return NULL;
+    }
+
+    // TODO: a vehicle may eat some mob, so mob should not evade
+    if (GetVehicle())
+        return NULL;
+
+    // search nearby enemy before enter evade mode
+    if (HasReactState(REACT_AGGRESSIVE))
+    {
+        target = SelectNearestTargetInAttackDistance(m_CombatDistance ? m_CombatDistance : ATTACK_DISTANCE);
+
+        if (target && _IsTargetAcceptable(target) && canCreatureAttack(target))
+            return target;
+    }
+
+    Unit::AuraEffectList const& iAuras = GetAuraEffectsByType(SPELL_AURA_MOD_INVISIBILITY);
+    if (!iAuras.empty())
+    {
+        for (Unit::AuraEffectList::const_iterator itr = iAuras.begin(); itr != iAuras.end(); ++itr)
+        {
+            if ((*itr)->GetBase()->IsPermanent())
+            {
+                AI()->EnterEvadeMode();
+                break;
+            }
+        }
+        return NULL;
+    }
+
+    // enter in evade mode in other case
+    AI()->EnterEvadeMode();
+
+    return NULL;
+}
+
+//======================================================================
+//======================================================================
+//======================================================================
+
+float Unit::ApplyEffectModifiers(SpellInfo const* spellProto, uint8 effect_index, float value) const
+{
+    if (Player* modOwner = GetSpellModOwner())
+    {
+        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_ALL_EFFECTS, value);
+        switch (effect_index)
+        {
+            case 0:
+                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT1, value);
+                break;
+            case 1:
+                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT2, value);
+                break;
+            case 2:
+                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_EFFECT3, value);
+                break;
+        }
+    }
+    return value;
+}
+
+// function uses real base points (typically value - 1)
+int32 Unit::CalculateSpellDamage(Unit const* target, SpellInfo const* spellProto, uint8 effect_index, int32 const* basePoints) const
+{
+    return spellProto->Effects[effect_index].CalcValue(this, basePoints, target);
+}
+
+int32 Unit::CalcSpellDuration(SpellInfo const* spellProto)
+{
+    uint8 comboPoints = m_movedPlayer ? m_movedPlayer->GetComboPoints() : 0;
+
+    int32 minduration = spellProto->GetDuration();
+    int32 maxduration = spellProto->GetMaxDuration();
+
+    int32 duration;
+
+    if (comboPoints && minduration != -1 && minduration != maxduration)
+        duration = minduration + int32((maxduration - minduration) * comboPoints / 5);
+    else
+        duration = minduration;
+
+    return duration;
+}
+
+int32 Unit::ModSpellDuration(SpellInfo const* spellProto, Unit const* target, int32 duration, bool positive, uint32 effectMask)
+{
+    // don't mod permanent auras duration
+    if (duration < 0)
+        return duration;
+
+    // cut duration only of negative effects
+    if (!positive)
+    {
+        int32 mechanic = spellProto->GetSpellMechanicMaskByEffectMask(effectMask);
+
+        int32 durationMod;
+        int32 durationMod_always = 0;
+        int32 durationMod_not_stack = 0;
+
+        for (uint8 i = 1; i <= MECHANIC_ENRAGED; ++i)
+        {
+            if (!(mechanic & 1<<i))
+                continue;
+            // Find total mod value (negative bonus)
+            int32 new_durationMod_always = target->GetTotalAuraModifierByMiscValue(SPELL_AURA_MECHANIC_DURATION_MOD, i);
+            // Find max mod (negative bonus)
+            int32 new_durationMod_not_stack = target->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MECHANIC_DURATION_MOD_NOT_STACK, i);
+            // Check if mods applied before were weaker
+            if (new_durationMod_always < durationMod_always)
+                durationMod_always = new_durationMod_always;
+            if (new_durationMod_not_stack < durationMod_not_stack)
+                durationMod_not_stack = new_durationMod_not_stack;
+        }
+
+        // Select strongest negative mod
+        if (durationMod_always > durationMod_not_stack)
+            durationMod = durationMod_not_stack;
+        else
+            durationMod = durationMod_always;
+
+        if (durationMod != 0)
+            AddPct(duration, durationMod);
+
+        // there are only negative mods currently
+        durationMod_always = target->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL, spellProto->Dispel);
+        durationMod_not_stack = target->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK, spellProto->Dispel);
+
+        durationMod = 0;
+        if (durationMod_always > durationMod_not_stack)
+            durationMod += durationMod_not_stack;
+        else
+            durationMod += durationMod_always;
+
+        if (durationMod != 0)
+            AddPct(duration, durationMod);
+    }
+    else
+    {
+        // else positive mods here, there are no currently
+        // when there will be, change GetTotalAuraModifierByMiscValue to GetTotalPositiveAuraModifierByMiscValue
+
+        // Mixology - duration boost
+        if (target->GetTypeId() == TYPEID_PLAYER)
+        {
+            if (spellProto->SpellFamilyName == SPELLFAMILY_POTION && (
+                sSpellMgr->IsSpellMemberOfSpellGroup(spellProto->Id, SPELL_GROUP_ELIXIR_BATTLE) ||
+                sSpellMgr->IsSpellMemberOfSpellGroup(spellProto->Id, SPELL_GROUP_ELIXIR_GUARDIAN)))
+            {
+                if (target->HasAura(53042) && target->HasSpell(spellProto->Effects[0].TriggerSpell))
+                    duration *= 2;
+            }
+        }
+    }
+
+    // Glyphs which increase duration of selfcasted buffs
+    if (target == this)
+    {
+        switch (spellProto->SpellFamilyName)
+        {
+            case SPELLFAMILY_DRUID:
+                if (spellProto->SpellFamilyFlags[0] & 0x100)
+                {
+                    // Glyph of Thorns
+                    if (AuraEffect* aurEff = GetAuraEffect(57862, 0))
+                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;
+                }
+                break;
+        }
+    }
+    return std::max(duration, 0);
+}
+
+void Unit::ModSpellCastTime(SpellInfo const* spellProto, int32 & castTime, Spell* spell)
+{
+    if (!spellProto || castTime < 0)
+        return;
+    // called from caster
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CASTING_TIME, castTime, spell);
+
+    if (!(spellProto->Attributes & (SPELL_ATTR0_ABILITY|SPELL_ATTR0_TRADESPELL)) && ((GetTypeId() == TYPEID_PLAYER && spellProto->SpellFamilyName) || GetTypeId() == TYPEID_UNIT))
+        castTime = int32(float(castTime) * GetFloatValue(UNIT_MOD_CAST_SPEED));
+    else if (spellProto->Attributes & SPELL_ATTR0_REQ_AMMO && !(spellProto->AttributesEx2 & SPELL_ATTR2_AUTOREPEAT_FLAG))
+        castTime = int32(float(castTime) * m_modAttackSpeedPct[RANGED_ATTACK]);
+    else if (spellProto->SpellVisual[0] == 3881 && HasAura(67556)) // cooking with Chef Hat.
+        castTime = 500;
+}
+
+DiminishingLevels Unit::GetDiminishing(DiminishingGroup group)
+{
+    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
+    {
+        if (i->DRGroup != group)
+            continue;
+
+        if (!i->hitCount)
+            return DIMINISHING_LEVEL_1;
+
+        if (!i->hitTime)
+            return DIMINISHING_LEVEL_1;
+
+        // If last spell was casted more than 15 seconds ago - reset the count.
+        if (i->stack == 0 && getMSTimeDiff(i->hitTime, getMSTime()) > 15000)
+        {
+            i->hitCount = DIMINISHING_LEVEL_1;
+            return DIMINISHING_LEVEL_1;
+        }
+        // or else increase the count.
+        else
+            return DiminishingLevels(i->hitCount);
+    }
+    return DIMINISHING_LEVEL_1;
+}
+
+void Unit::IncrDiminishing(DiminishingGroup group)
+{
+    // Checking for existing in the table
+    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
+    {
+        if (i->DRGroup != group)
+            continue;
+        if (int32(i->hitCount) < GetDiminishingReturnsMaxLevel(group))
+            i->hitCount += 1;
+        return;
+    }
+    m_Diminishing.push_back(DiminishingReturn(group, getMSTime(), DIMINISHING_LEVEL_2));
+}
+
+float Unit::ApplyDiminishingToDuration(DiminishingGroup group, int32 &duration, Unit* caster, DiminishingLevels Level, int32 limitduration)
+{
+    if (duration == -1 || group == DIMINISHING_NONE)
+        return 1.0f;
+
+    // test pet/charm masters instead pets/charmeds
+    Unit const* targetOwner = GetCharmerOrOwner();
+    Unit const* casterOwner = caster->GetCharmerOrOwner();
+
+    // Duration of crowd control abilities on pvp target is limited by 10 sec. (2.2.0)
+    if (limitduration > 0 && duration > limitduration)
+    {
+        Unit const* target = targetOwner ? targetOwner : this;
+        Unit const* source = casterOwner ? casterOwner : caster;
+
+        if ((target->GetTypeId() == TYPEID_PLAYER
+            || ((Creature*)target)->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_ALL_DIMINISH)
+            && source->GetTypeId() == TYPEID_PLAYER)
+            duration = limitduration;
+    }
+
+    float mod = 1.0f;
+
+    if (group == DIMINISHING_TAUNT)
+    {
+        if (GetTypeId() == TYPEID_UNIT && (ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_TAUNT_DIMINISH))
+        {
+            DiminishingLevels diminish = Level;
+            switch (diminish)
+            {
+                case DIMINISHING_LEVEL_1: break;
+                case DIMINISHING_LEVEL_2: mod = 0.65f; break;
+                case DIMINISHING_LEVEL_3: mod = 0.4225f; break;
+                case DIMINISHING_LEVEL_4: mod = 0.274625f; break;
+                case DIMINISHING_LEVEL_TAUNT_IMMUNE: mod = 0.0f; break;
+                default: break;
+            }
+        }
+    }
+    // Some diminishings applies to mobs too (for example, Stun)
+    else if ((GetDiminishingReturnsGroupType(group) == DRTYPE_PLAYER
+        && ((targetOwner ? (targetOwner->GetTypeId() == TYPEID_PLAYER) : (GetTypeId() == TYPEID_PLAYER))
+        || (GetTypeId() == TYPEID_UNIT && ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_ALL_DIMINISH)))
+        || GetDiminishingReturnsGroupType(group) == DRTYPE_ALL)
+    {
+        DiminishingLevels diminish = Level;
+        switch (diminish)
+        {
+            case DIMINISHING_LEVEL_1: break;
+            case DIMINISHING_LEVEL_2: mod = 0.5f; break;
+            case DIMINISHING_LEVEL_3: mod = 0.25f; break;
+            case DIMINISHING_LEVEL_IMMUNE: mod = 0.0f; break;
+            default: break;
+        }
+    }
+
+    duration = int32(duration * mod);
+    return mod;
+}
+
+void Unit::ApplyDiminishingAura(DiminishingGroup group, bool apply)
+{
+    // Checking for existing in the table
+    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
+    {
+        if (i->DRGroup != group)
+            continue;
+
+        if (apply)
+            i->stack += 1;
+        else if (i->stack)
+        {
+            i->stack -= 1;
+            // Remember time after last aura from group removed
+            if (i->stack == 0)
+                i->hitTime = getMSTime();
+        }
+        break;
+    }
+}
+
+float Unit::GetSpellMaxRangeForTarget(Unit const* target, SpellInfo const* spellInfo) const
+{
+    if (!spellInfo->RangeEntry)
+        return 0;
+    if (spellInfo->RangeEntry->maxRangeFriend == spellInfo->RangeEntry->maxRangeHostile)
+        return spellInfo->GetMaxRange();
+    if (target)
+        return spellInfo->GetMaxRange(!IsHostileTo(target));
+    return 0;
+}
+
+float Unit::GetSpellMinRangeForTarget(Unit const* target, SpellInfo const* spellInfo) const
+{
+    if (!spellInfo->RangeEntry)
+        return 0;
+    if (spellInfo->RangeEntry->minRangeFriend == spellInfo->RangeEntry->minRangeHostile)
+        return spellInfo->GetMinRange();
+    if (target)
+        return spellInfo->GetMinRange(!IsHostileTo(target));
+    return 0;
+}
+
+Unit* Unit::GetUnit(WorldObject& object, uint64 guid)
+{
+    return ObjectAccessor::GetUnit(object, guid);
+}
+
+Player* Unit::GetPlayer(WorldObject& object, uint64 guid)
+{
+    return ObjectAccessor::GetPlayer(object, guid);
+}
+
+Player* Unit::GetPlayer(uint64 guid)
+{
+    return ObjectAccessor::FindPlayer(guid);
+}
+
+Creature* Unit::GetCreature(WorldObject& object, uint64 guid)
+{
+    return object.GetMap()->GetCreature(guid);
+}
+
+uint32 Unit::GetCreatureType() const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        ShapeshiftForm form = GetShapeshiftForm();
+        SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(form);
+        if (ssEntry && ssEntry->creatureType > 0)
+            return ssEntry->creatureType;
+        else
+            return CREATURE_TYPE_HUMANOID;
+    }
+    else
+        return ToCreature()->GetCreatureTemplate()->type;
+}
+
+/*#######################################
+########                         ########
+########       STAT SYSTEM       ########
+########                         ########
+#######################################*/
+
+bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, float amount, bool apply)
+{
+    if (unitMod >= UNIT_MOD_END || modifierType >= MODIFIER_TYPE_END)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "ERROR in HandleStatModifier(): non-existing UnitMods or wrong UnitModifierType!");
+        return false;
+    }
+
+    switch (modifierType)
+    {
+        case BASE_VALUE:
+        case TOTAL_VALUE:
+            m_auraModifiersGroup[unitMod][modifierType] += apply ? amount : -amount;
+            break;
+        case BASE_PCT:
+        case TOTAL_PCT:
+            ApplyPercentModFloatVar(m_auraModifiersGroup[unitMod][modifierType], amount, apply);
+            break;
+        default:
+            break;
+    }
+
+    if (!CanModifyStats())
+        return false;
+
+    switch (unitMod)
+    {
+        case UNIT_MOD_STAT_STRENGTH:
+        case UNIT_MOD_STAT_AGILITY:
+        case UNIT_MOD_STAT_STAMINA:
+        case UNIT_MOD_STAT_INTELLECT:
+        case UNIT_MOD_STAT_SPIRIT:
+            UpdateStats(GetStatByAuraGroup(unitMod));
+            break;
+        case UNIT_MOD_ARMOR:
+            UpdateArmor();
+            break;
+        case UNIT_MOD_HEALTH:
+            UpdateMaxHealth();
+            break;
+        case UNIT_MOD_MANA:
+        case UNIT_MOD_RAGE:
+        case UNIT_MOD_FOCUS:
+        case UNIT_MOD_ENERGY:
+        case UNIT_MOD_RUNE:
+        case UNIT_MOD_RUNIC_POWER:
+            UpdateMaxPower(GetPowerTypeByAuraGroup(unitMod));
+            break;
+        case UNIT_MOD_RESISTANCE_HOLY:
+        case UNIT_MOD_RESISTANCE_FIRE:
+        case UNIT_MOD_RESISTANCE_NATURE:
+        case UNIT_MOD_RESISTANCE_FROST:
+        case UNIT_MOD_RESISTANCE_SHADOW:
+        case UNIT_MOD_RESISTANCE_ARCANE:
+            UpdateResistances(GetSpellSchoolByAuraGroup(unitMod));
+            break;
+        case UNIT_MOD_ATTACK_POWER:
+            UpdateAttackPowerAndDamage();
+            break;
+        case UNIT_MOD_ATTACK_POWER_RANGED:
+            UpdateAttackPowerAndDamage(true);
+            break;
+        case UNIT_MOD_DAMAGE_MAINHAND:
+            UpdateDamagePhysical(BASE_ATTACK);
+            break;
+        case UNIT_MOD_DAMAGE_OFFHAND:
+            UpdateDamagePhysical(OFF_ATTACK);
+            break;
+        case UNIT_MOD_DAMAGE_RANGED:
+            UpdateDamagePhysical(RANGED_ATTACK);
+            break;
+        default:
+            break;
+    }
+
+    return true;
+}
+
+float Unit::GetModifierValue(UnitMods unitMod, UnitModifierType modifierType) const
+{
+    if (unitMod >= UNIT_MOD_END || modifierType >= MODIFIER_TYPE_END)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "attempt to access non-existing modifier value from UnitMods!");
+        return 0.0f;
+    }
+
+    if (modifierType == TOTAL_PCT && m_auraModifiersGroup[unitMod][modifierType] <= 0.0f)
+        return 0.0f;
+
+    return m_auraModifiersGroup[unitMod][modifierType];
+}
+
+float Unit::GetTotalStatValue(Stats stat) const
+{
+    UnitMods unitMod = UnitMods(UNIT_MOD_STAT_START + stat);
+
+    if (m_auraModifiersGroup[unitMod][TOTAL_PCT] <= 0.0f)
+        return 0.0f;
+
+    // value = ((base_value * base_pct) + total_value) * total_pct
+    float value  = m_auraModifiersGroup[unitMod][BASE_VALUE] + GetCreateStat(stat);
+    value *= m_auraModifiersGroup[unitMod][BASE_PCT];
+    value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];
+    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];
+
+    return value;
+}
+
+float Unit::GetTotalAuraModValue(UnitMods unitMod) const
+{
+    if (unitMod >= UNIT_MOD_END)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "attempt to access non-existing UnitMods in GetTotalAuraModValue()!");
+        return 0.0f;
+    }
+
+    if (m_auraModifiersGroup[unitMod][TOTAL_PCT] <= 0.0f)
+        return 0.0f;
+
+    float value = m_auraModifiersGroup[unitMod][BASE_VALUE];
+    value *= m_auraModifiersGroup[unitMod][BASE_PCT];
+    value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];
+    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];
+
+    return value;
+}
+
+SpellSchools Unit::GetSpellSchoolByAuraGroup(UnitMods unitMod) const
+{
+    SpellSchools school = SPELL_SCHOOL_NORMAL;
+
+    switch (unitMod)
+    {
+        case UNIT_MOD_RESISTANCE_HOLY:     school = SPELL_SCHOOL_HOLY;          break;
+        case UNIT_MOD_RESISTANCE_FIRE:     school = SPELL_SCHOOL_FIRE;          break;
+        case UNIT_MOD_RESISTANCE_NATURE:   school = SPELL_SCHOOL_NATURE;        break;
+        case UNIT_MOD_RESISTANCE_FROST:    school = SPELL_SCHOOL_FROST;         break;
+        case UNIT_MOD_RESISTANCE_SHADOW:   school = SPELL_SCHOOL_SHADOW;        break;
+        case UNIT_MOD_RESISTANCE_ARCANE:   school = SPELL_SCHOOL_ARCANE;        break;
+
+        default:
+            break;
+    }
+
+    return school;
+}
+
+Stats Unit::GetStatByAuraGroup(UnitMods unitMod) const
+{
+    Stats stat = STAT_STRENGTH;
+
+    switch (unitMod)
+    {
+        case UNIT_MOD_STAT_STRENGTH:    stat = STAT_STRENGTH;      break;
+        case UNIT_MOD_STAT_AGILITY:     stat = STAT_AGILITY;       break;
+        case UNIT_MOD_STAT_STAMINA:     stat = STAT_STAMINA;       break;
+        case UNIT_MOD_STAT_INTELLECT:   stat = STAT_INTELLECT;     break;
+        case UNIT_MOD_STAT_SPIRIT:      stat = STAT_SPIRIT;        break;
+
+        default:
+            break;
+    }
+
+    return stat;
+}
+
+Powers Unit::GetPowerTypeByAuraGroup(UnitMods unitMod) const
+{
+    switch (unitMod)
+    {
+        case UNIT_MOD_RAGE:        return POWER_RAGE;
+        case UNIT_MOD_FOCUS:       return POWER_FOCUS;
+        case UNIT_MOD_ENERGY:      return POWER_ENERGY;
+        case UNIT_MOD_RUNE:        return POWER_RUNES;
+        case UNIT_MOD_RUNIC_POWER: return POWER_RUNIC_POWER;
+        default:
+        case UNIT_MOD_MANA:        return POWER_MANA;
+    }
+}
+
+float Unit::GetTotalAttackPowerValue(WeaponAttackType attType) const
+{
+    if (attType == RANGED_ATTACK)
+    {
+        int32 ap = GetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER);
+        if (ap < 0)
+            return 0.0f;
+        ap += GetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER_MOD_POS);
+        return ap * (1.0f + GetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER));
+    }
+    else
+    {
+        int32 ap = GetInt32Value(UNIT_FIELD_ATTACK_POWER);
+        if (ap < 0)
+            return 0.0f;
+        ap += GetInt32Value(UNIT_FIELD_ATTACK_POWER_MOD_POS);
+        return ap * (1.0f + GetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER));
+    }
+}
+
+float Unit::GetWeaponDamageRange(WeaponAttackType attType, WeaponDamageRange type) const
+{
+    if (attType == OFF_ATTACK && !haveOffhandWeapon())
+        return 0.0f;
+
+    return m_weaponDamage[attType][type];
+}
+
+void Unit::SetLevel(uint8 lvl)
+{
+    SetUInt32Value(UNIT_FIELD_LEVEL, lvl);
+
+    // group update
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        sInfoMgr->UpdateCharLevel(GetGUIDLow(), lvl);
+
+        if (ToPlayer()->GetGroup())
+            ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_LEVEL);
+    }
+}
+
+void Unit::SetHealth(uint32 val)
+{
+    if (getDeathState() == JUST_DIED)
+        val = 0;
+    else if (GetTypeId() == TYPEID_PLAYER && getDeathState() == DEAD)
+        val = 1;
+    else
+    {
+        uint32 maxHealth = GetMaxHealth();
+        if (maxHealth < val)
+            val = maxHealth;
+    }
+
+    SetUInt32Value(UNIT_FIELD_HEALTH, val);
+
+    // group update
+    if (Player* player = ToPlayer())
+    {
+        if (player->GetGroup())
+            player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_HP);
+    }
+    else if (Pet* pet = ToCreature()->ToPet())
+    {
+        if (pet->isControlled())
+        {
+            Unit* owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_HP);
+        }
+    }
+}
+
+void Unit::SetMaxHealth(uint32 val)
+{
+    if (!val)
+        val = 1;
+
+    uint32 health = GetHealth();
+    SetUInt32Value(UNIT_FIELD_MAXHEALTH, val);
+
+    // group update
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (ToPlayer()->GetGroup())
+            ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_HP);
+    }
+    else if (Pet* pet = ToCreature()->ToPet())
+    {
+        if (pet->isControlled())
+        {
+            Unit* owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_HP);
+        }
+    }
+
+    if (val < health)
+        SetHealth(val);
+}
+
+int32 Unit::GetPower(Powers power) const
+{
+    uint32 powerIndex = GetPowerIndex(power);
+    if (powerIndex == MAX_POWERS)
+        return 0;
+
+    return GetUInt32Value(UNIT_FIELD_POWER1 + powerIndex);
+}
+
+int32 Unit::GetMaxPower(Powers power) const
+{
+    uint32 powerIndex = GetPowerIndex(power);
+    if (powerIndex == MAX_POWERS)
+        return 0;
+
+    return GetInt32Value(UNIT_FIELD_MAXPOWER1 + powerIndex);
+}
+
+void Unit::SetPower(Powers power, int32 val)
+{
+    uint32 powerIndex = GetPowerIndex(power);
+    if (powerIndex == MAX_POWERS)
+        return;
+
+    int32 maxPower = int32(GetMaxPower(power));
+    if (maxPower < val)
+        val = maxPower;
+
+    if (power == POWER_HOLY_POWER && GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->m_holyPowerRegenTimerCount = 0;
+
+    SetInt32Value(UNIT_FIELD_POWER1 + powerIndex, val);
+
+    if (IsInWorld())
+    {
+        WorldPacket data(SMSG_POWER_UPDATE, 8 + 4 + 1 + 4);
+        data.append(GetPackGUID());
+        data << uint32(1); //power count
+        data << uint8(power);
+        data << int32(val);
+        SendMessageToSet(&data, GetTypeId() == TYPEID_PLAYER ? true : false);
+    }
+
+    // group update
+    if (Player* player = ToPlayer())
+    {
+        if (player->GetGroup())
+            player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);
+    }
+    else if (Pet* pet = ToCreature()->ToPet())
+    {
+        if (pet->isControlled())
+        {
+            Unit* owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);
+        }
+    }
+}
+
+void Unit::SetMaxPower(Powers power, int32 val)
+{
+    uint32 powerIndex = GetPowerIndex(power);
+    if (powerIndex == MAX_POWERS)
+        return;
+
+    int32 cur_power = GetPower(power);
+    SetInt32Value(UNIT_FIELD_MAXPOWER1 + powerIndex, val);
+
+    // group update
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (ToPlayer()->GetGroup())
+            ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_POWER);
+    }
+    else if (Pet* pet = ToCreature()->ToPet())
+    {
+        if (pet->isControlled())
+        {
+            Unit* owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);
+        }
+    }
+
+    if (val < cur_power)
+        SetPower(power, val);
+}
+
+uint32 Unit::GetPowerIndex(uint32 powerType) const
+{
+    /// This is here because hunter pets are of the warrior class.
+    /// With the current implementation, the core only gives them
+    /// POWER_RAGE, so we enforce the class to hunter so that they
+    /// effectively get focus power.
+    uint32 classId = getClass();
+    if (ToPet() && ToPet()->getPetType() == HUNTER_PET)
+        classId = CLASS_HUNTER;
+
+    return GetPowerIndexByClass(powerType, classId);
+}
+
+int32 Unit::GetCreatePowers(Powers power) const
+{
+    switch (power)
+    {
+        case POWER_MANA:
+            return GetCreateMana();
+        case POWER_RAGE:
+            return 1000;
+        case POWER_FOCUS:
+            if (GetTypeId() == TYPEID_PLAYER && getClass() == CLASS_HUNTER)
+                return 100;
+            return (GetTypeId() == TYPEID_PLAYER || !((Creature const*)this)->isPet() || ((Pet const*)this)->getPetType() != HUNTER_PET ? 0 : 100);
+        case POWER_ENERGY:
+            return 100;
+        case POWER_RUNIC_POWER:
+            return 1000;
+        case POWER_RUNES:
+            return 0;
+        case POWER_SOUL_SHARDS:
+            return 3;
+        case POWER_ECLIPSE:
+            return 100;
+        case POWER_HOLY_POWER:
+            return 3;
+        case POWER_HEALTH:
+            return 0;
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+void Unit::AddToWorld()
+{
+    if (!IsInWorld())
+    {
+        WorldObject::AddToWorld();
+    }
+}
+
+void Unit::RemoveFromWorld()
+{
+    // cleanup
+    if (GetGUID() == 0)
+    {
+        sLog->outError(LOG_FILTER_UNITS, "try to remove from world already removed Unit %u ", GetEntry());
+        return ;
+    }
+
+    if (IsInWorld())
+    {
+        m_duringRemoveFromWorld = true;
+        if (IsVehicle())
+            RemoveVehicleKit();
+
+        RemoveCharmAuras();
+        RemoveBindSightAuras();
+        RemoveNotOwnSingleTargetAuras();
+
+        RemoveAllGameObjects();
+        RemoveAllDynObjects();
+
+        ExitVehicle();  // Remove applied auras with SPELL_AURA_CONTROL_VEHICLE
+        UnsummonAllTotems();
+        RemoveAllControlled();
+
+        RemoveAreaAurasDueToLeaveWorld();
+
+        if (GetCharmerGUID())
+        {
+            sLog->outFatal(LOG_FILTER_UNITS, "Unit %u has charmer guid when removed from world", GetEntry());
+            ASSERT(false);
+        }
+
+        if (Unit* owner = GetOwner())
+        {
+            if (owner->m_Controlled.find(this) != owner->m_Controlled.end())
+            {
+                sLog->outFatal(LOG_FILTER_UNITS, "Unit %u is in controlled list of %u when removed from world", GetEntry(), owner->GetEntry());
+                ASSERT(false);
+            }
+        }
+
+        WorldObject::RemoveFromWorld();
+        m_duringRemoveFromWorld = false;
+    }
+}
+
+void Unit::CleanupBeforeRemoveFromMap(bool finalCleanup)
+{
+    // This needs to be before RemoveFromWorld to make GetCaster() return a valid pointer on aura removal
+    InterruptNonMeleeSpells(true);
+
+    if (IsInWorld())
+        RemoveFromWorld();
+
+    ASSERT(GetGUID());
+
+    // A unit may be in removelist and not in world, but it is still in grid
+    // and may have some references during delete
+    RemoveAllAuras();
+    RemoveAllGameObjects();
+
+    if (finalCleanup)
+        m_cleanupDone = true;
+
+    m_Events.KillAllEvents(false);                      // non-delatable (currently casted spells) will not deleted now but it will deleted at call in Map::RemoveAllObjectsInRemoveList
+    CombatStop();
+    ClearComboPointHolders();
+    DeleteThreatList();
+    getHostileRefManager().setOnlineOfflineState(false);
+    GetMotionMaster()->Clear(false);                    // remove different non-standard movement generators.
+}
+
+void Unit::CleanupsBeforeDelete(bool finalCleanup)
+{
+    CleanupBeforeRemoveFromMap(finalCleanup);
+
+    if (Creature* thisCreature = ToCreature())
+        if (GetTransport())
+            GetTransport()->RemovePassenger(thisCreature);
+}
+
+void Unit::UpdateCharmAI()
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+        return;
+
+    if (i_disabledAI) // disabled AI must be primary AI
+    {
+        if (!isCharmed())
+        {
+            delete i_AI;
+            i_AI = i_disabledAI;
+            i_disabledAI = NULL;
+        }
+    }
+    else
+    {
+        if (isCharmed())
+        {
+            i_disabledAI = i_AI;
+            if (isPossessed() || IsVehicle())
+                i_AI = new PossessedAI(ToCreature());
+            else
+                i_AI = new PetAI(ToCreature());
+        }
+    }
+}
+
+CharmInfo* Unit::InitCharmInfo()
+{
+    if (!m_charmInfo)
+        m_charmInfo = new CharmInfo(this);
+
+    return m_charmInfo;
+}
+
+void Unit::DeleteCharmInfo()
+{
+    if (!m_charmInfo)
+        return;
+
+    m_charmInfo->RestoreState();
+    delete m_charmInfo;
+    m_charmInfo = NULL;
+}
+
+CharmInfo::CharmInfo(Unit* unit)
+: _unit(unit), _CommandState(COMMAND_FOLLOW), _petnumber(0), _barInit(false),
+  _isCommandAttack(false), _isAtStay(false), _isFollowing(false), _isReturning(false),
+  _stayX(0.0f), _stayY(0.0f), _stayZ(0.0f)
+{
+    for (uint8 i = 0; i < MAX_SPELL_CHARM; ++i)
+        _charmspells[i].SetActionAndType(0, ACT_DISABLED);
+
+    if (_unit->GetTypeId() == TYPEID_UNIT)
+    {
+        _oldReactState = _unit->ToCreature()->GetReactState();
+        _unit->ToCreature()->SetReactState(REACT_PASSIVE);
+    }
+}
+
+CharmInfo::~CharmInfo()
+{
+}
+
+void CharmInfo::RestoreState()
+{
+    if (_unit->GetTypeId() == TYPEID_UNIT)
+        if (Creature* creature = _unit->ToCreature())
+            creature->SetReactState(_oldReactState);
+}
+
+void CharmInfo::InitPetActionBar()
+{
+    SetActionBar(ACTION_BAR_INDEX_START, COMMAND_ATTACK, ACT_COMMAND);
+    SetActionBar(ACTION_BAR_INDEX_START + 1, COMMAND_FOLLOW, ACT_COMMAND);
+    SetActionBar(ACTION_BAR_INDEX_START + 2, COMMAND_MOVE_TO, ACT_COMMAND);
+
+    // middle 4 SpellOrActions are spells/special attacks/abilities
+    for (uint32 i = 0; i < ACTION_BAR_INDEX_PET_SPELL_END-ACTION_BAR_INDEX_PET_SPELL_START; ++i)
+        SetActionBar(ACTION_BAR_INDEX_PET_SPELL_START + i, 0, ACT_PASSIVE);
+
+    SetActionBar(ACTION_BAR_INDEX_PET_SPELL_END, REACT_ASSIST, ACT_REACTION);
+    SetActionBar(ACTION_BAR_INDEX_PET_SPELL_END + 1, REACT_DEFENSIVE, ACT_REACTION);
+    SetActionBar(ACTION_BAR_INDEX_PET_SPELL_END + 2, REACT_PASSIVE, ACT_REACTION);
+}
+
+void CharmInfo::InitEmptyActionBar(bool withAttack)
+{
+    if (withAttack)
+        SetActionBar(ACTION_BAR_INDEX_START, COMMAND_ATTACK, ACT_COMMAND);
+    else
+        SetActionBar(ACTION_BAR_INDEX_START, 0, ACT_PASSIVE);
+    for (uint32 x = ACTION_BAR_INDEX_START+1; x < ACTION_BAR_INDEX_END; ++x)
+        SetActionBar(x, 0, ACT_PASSIVE);
+}
+
+void CharmInfo::InitPossessCreateSpells()
+{
+    InitEmptyActionBar();
+    if (_unit->GetTypeId() == TYPEID_UNIT)
+    {
+        for (uint32 i = 0; i < CREATURE_MAX_SPELLS; ++i)
+        {
+            uint32 spellId = _unit->ToCreature()->m_spells[i];
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (spellInfo && !(spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_DEAD))
+            {
+                if (spellInfo->IsPassive())
+                    _unit->CastSpell(_unit, spellInfo, true);
+                else
+                    AddSpellToActionBar(spellInfo, ACT_PASSIVE);
+            }
+        }
+    }
+}
+
+void CharmInfo::InitCharmCreateSpells()
+{
+    if (_unit->GetTypeId() == TYPEID_PLAYER)                // charmed players don't have spells
+    {
+        InitEmptyActionBar();
+        return;
+    }
+
+    InitPetActionBar();
+
+    for (uint32 x = 0; x < MAX_SPELL_CHARM; ++x)
+    {
+        uint32 spellId = _unit->ToCreature()->m_spells[x];
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+
+        if (!spellInfo || spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_DEAD)
+        {
+            _charmspells[x].SetActionAndType(spellId, ACT_DISABLED);
+            continue;
+        }
+
+        if (spellInfo->IsPassive())
+        {
+            _unit->CastSpell(_unit, spellInfo, true);
+            _charmspells[x].SetActionAndType(spellId, ACT_PASSIVE);
+        }
+        else
+        {
+            _charmspells[x].SetActionAndType(spellId, ACT_DISABLED);
+
+            ActiveStates newstate = ACT_PASSIVE;
+
+            if (!spellInfo->IsAutocastable())
+                newstate = ACT_PASSIVE;
+            else
+            {
+                if (spellInfo->NeedsExplicitUnitTarget())
+                {
+                    newstate = ACT_ENABLED;
+                    ToggleCreatureAutocast(spellInfo, true);
+                }
+                else
+                    newstate = ACT_DISABLED;
+            }
+
+            AddSpellToActionBar(spellInfo, newstate);
+        }
+    }
+}
+
+bool CharmInfo::AddSpellToActionBar(SpellInfo const* spellInfo, ActiveStates newstate)
+{
+    uint32 spell_id = spellInfo->Id;
+    uint32 first_id = spellInfo->GetFirstRankSpell()->Id;
+
+    // new spell rank can be already listed
+    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
+    {
+        if (uint32 action = PetActionBar[i].GetAction())
+        {
+            if (PetActionBar[i].IsActionBarForSpell() && sSpellMgr->GetFirstSpellInChain(action) == first_id)
+            {
+                PetActionBar[i].SetAction(spell_id);
+                return true;
+            }
+        }
+    }
+
+    // or use empty slot in other case
+    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
+    {
+        if (!PetActionBar[i].GetAction() && PetActionBar[i].IsActionBarForSpell())
+        {
+            if (spellInfo->AttributesEx4 & SPELL_ATTR4_UNK15)
+                continue;
+
+            SetActionBar(i, spell_id, newstate == ACT_DECIDE ? spellInfo->IsAutocastable() ? ACT_DISABLED : ACT_PASSIVE : newstate);
+            return true;
+        }
+    }
+    return false;
+}
+
+bool CharmInfo::RemoveSpellFromActionBar(uint32 spell_id)
+{
+    uint32 first_id = sSpellMgr->GetFirstSpellInChain(spell_id);
+
+    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
+    {
+        if (uint32 action = PetActionBar[i].GetAction())
+        {
+            if (PetActionBar[i].IsActionBarForSpell() && sSpellMgr->GetFirstSpellInChain(action) == first_id)
+            {
+                SetActionBar(i, 0, ACT_PASSIVE);
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+void CharmInfo::ToggleCreatureAutocast(SpellInfo const* spellInfo, bool apply)
+{
+    if (spellInfo->IsPassive())
+        return;
+
+    for (uint32 x = 0; x < MAX_SPELL_CHARM; ++x)
+        if (spellInfo->Id == _charmspells[x].GetAction())
+            _charmspells[x].SetType(apply ? ACT_ENABLED : ACT_DISABLED);
+}
+
+void CharmInfo::SetPetNumber(uint32 petnumber, bool statwindow)
+{
+    _petnumber = petnumber;
+    if (statwindow)
+        _unit->SetUInt32Value(UNIT_FIELD_PETNUMBER, _petnumber);
+    else
+        _unit->SetUInt32Value(UNIT_FIELD_PETNUMBER, 0);
+}
+
+void CharmInfo::LoadPetActionBar(const std::string& data)
+{
+    InitPetActionBar();
+
+    Tokenizer tokens(data, ' ');
+
+    if (tokens.size() != (ACTION_BAR_INDEX_END-ACTION_BAR_INDEX_START) * 2)
+        return;                                             // non critical, will reset to default
+
+    uint8 index = ACTION_BAR_INDEX_START;
+    Tokenizer::const_iterator iter = tokens.begin();
+    for (; index < ACTION_BAR_INDEX_END; ++iter, ++index)
+    {
+        // use unsigned cast to avoid sign negative format use at long-> ActiveStates (int) conversion
+        ActiveStates type  = ActiveStates(atol(*iter));
+        ++iter;
+        uint32 action = uint32(atol(*iter));
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(action);
+        if (spellInfo && spellInfo->AttributesEx4 & SPELL_ATTR4_UNK15)
+            continue;
+
+        PetActionBar[index].SetActionAndType(action, type);
+
+        // check correctness
+        if (PetActionBar[index].IsActionBarForSpell())
+        {
+            if (!spellInfo)
+                SetActionBar(index, 0, ACT_PASSIVE);
+            else if (!spellInfo->IsAutocastable())
+                SetActionBar(index, action, ACT_PASSIVE);
+        }
+    }
+}
+
+void CharmInfo::BuildActionBar(WorldPacket* data)
+{
+    for (uint32 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
+        *data << uint32(PetActionBar[i].packedData);
+}
+
+void CharmInfo::SetSpellAutocast(SpellInfo const* spellInfo, bool state)
+{
+    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
+    {
+        if (spellInfo->Id == PetActionBar[i].GetAction() && PetActionBar[i].IsActionBarForSpell())
+        {
+            PetActionBar[i].SetType(state ? ACT_ENABLED : ACT_DISABLED);
+            break;
+        }
+    }
+}
+
+bool Unit::isFrozen() const
+{
+    return HasAuraState(AURA_STATE_FROZEN);
+}
+
+struct ProcTriggeredData
+{
+    ProcTriggeredData(Aura* _aura)
+        : aura(_aura)
+    {
+        effMask = 0;
+        spellProcEvent = NULL;
+    }
+    SpellProcEventEntry const* spellProcEvent;
+    Aura* aura;
+    uint32 effMask;
+};
+
+typedef std::list< ProcTriggeredData > ProcTriggeredList;
+
+// List of auras that CAN be trigger but may not exist in spell_proc_event
+// in most case need for drop charges
+// in some types of aura need do additional check
+// for example SPELL_AURA_MECHANIC_IMMUNITY - need check for mechanic
+bool InitTriggerAuraData()
+{
+    for (uint16 i = 0; i < TOTAL_AURAS; ++i)
+    {
+        isTriggerAura[i] = false;
+        isNonTriggerAura[i] = false;
+        isAlwaysTriggeredAura[i] = false;
+    }
+    isTriggerAura[SPELL_AURA_PROC_ON_POWER_AMOUNT] = true;
+    isTriggerAura[SPELL_AURA_DUMMY] = true;
+    isTriggerAura[SPELL_AURA_MOD_CONFUSE] = true;
+    isTriggerAura[SPELL_AURA_MOD_THREAT] = true;
+    isTriggerAura[SPELL_AURA_MOD_STUN] = true; // Aura does not have charges but needs to be removed on trigger
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_DONE] = true;
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_TAKEN] = true;
+    isTriggerAura[SPELL_AURA_MOD_RESISTANCE] = true;
+    isTriggerAura[SPELL_AURA_MOD_STEALTH] = true;
+    isTriggerAura[SPELL_AURA_MOD_FEAR] = true; // Aura does not have charges but needs to be removed on trigger
+    isTriggerAura[SPELL_AURA_MOD_ROOT] = true;
+    isTriggerAura[SPELL_AURA_TRANSFORM] = true;
+    isTriggerAura[SPELL_AURA_REFLECT_SPELLS] = true;
+    isTriggerAura[SPELL_AURA_DAMAGE_IMMUNITY] = true;
+    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL] = true;
+    isTriggerAura[SPELL_AURA_PROC_TRIGGER_DAMAGE] = true;
+    isTriggerAura[SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK] = true;
+    isTriggerAura[SPELL_AURA_SCHOOL_ABSORB] = true; // Savage Defense untested
+    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT] = true;
+    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL] = true;
+    isTriggerAura[SPELL_AURA_REFLECT_SPELLS_SCHOOL] = true;
+    isTriggerAura[SPELL_AURA_MECHANIC_IMMUNITY] = true;
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN] = true;
+    isTriggerAura[SPELL_AURA_SPELL_MAGNET] = true;
+    isTriggerAura[SPELL_AURA_MOD_ATTACK_POWER] = true;
+    isTriggerAura[SPELL_AURA_ADD_CASTER_HIT_TRIGGER] = true;
+    isTriggerAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;
+    isTriggerAura[SPELL_AURA_MOD_MECHANIC_RESISTANCE] = true;
+    isTriggerAura[SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS] = true;
+    isTriggerAura[SPELL_AURA_MOD_MELEE_HASTE] = true;
+    isTriggerAura[SPELL_AURA_MOD_POWER_REGEN_PERCENT] = true;
+    isTriggerAura[SPELL_AURA_MOD_MELEE_HASTE_3] = true;
+    isTriggerAura[SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE] = true;
+    isTriggerAura[SPELL_AURA_RAID_PROC_FROM_CHARGE] = true;
+    isTriggerAura[SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE] = true;
+    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE] = true;
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_FROM_CASTER] = true;
+    isTriggerAura[SPELL_AURA_MOD_SPELL_CRIT_CHANCE] = true;
+    isTriggerAura[SPELL_AURA_ABILITY_IGNORE_AURASTATE] = true;
+    isTriggerAura[SPELL_AURA_ADD_FLAT_MODIFIER] = true;
+
+    isNonTriggerAura[SPELL_AURA_MOD_POWER_REGEN] = true;
+    isNonTriggerAura[SPELL_AURA_REDUCE_PUSHBACK] = true;
+
+    isAlwaysTriggeredAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_MOD_FEAR] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_MOD_ROOT] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_MOD_STUN] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_TRANSFORM] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_SPELL_MAGNET] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_SCHOOL_ABSORB] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_MOD_STEALTH] = true;
+
+    return true;
+}
+
+uint32 createProcExtendMask(SpellNonMeleeDamage* damageInfo, SpellMissInfo missCondition)
+{
+    uint32 procEx = PROC_EX_NONE;
+    // Check victim state
+    if (missCondition != SPELL_MISS_NONE)
+        switch (missCondition)
+        {
+            case SPELL_MISS_MISS:    procEx|=PROC_EX_MISS;   break;
+            case SPELL_MISS_RESIST:  procEx|=PROC_EX_RESIST; break;
+            case SPELL_MISS_DODGE:   procEx|=PROC_EX_DODGE;  break;
+            case SPELL_MISS_PARRY:   procEx|=PROC_EX_PARRY;  break;
+            case SPELL_MISS_BLOCK:   procEx|=PROC_EX_BLOCK;  break;
+            case SPELL_MISS_EVADE:   procEx|=PROC_EX_EVADE;  break;
+            case SPELL_MISS_IMMUNE:  procEx|=PROC_EX_IMMUNE; break;
+            case SPELL_MISS_IMMUNE2: procEx|=PROC_EX_IMMUNE; break;
+            case SPELL_MISS_DEFLECT: procEx|=PROC_EX_DEFLECT;break;
+            case SPELL_MISS_ABSORB:  procEx|=PROC_EX_ABSORB; break;
+            case SPELL_MISS_REFLECT: procEx|=PROC_EX_REFLECT;break;
+            default:
+                break;
+        }
+    else
+    {
+        // On block
+        if (damageInfo->blocked)
+            procEx|=PROC_EX_BLOCK;
+        // On absorb
+        if (damageInfo->absorb)
+            procEx|=PROC_EX_ABSORB;
+        // On crit
+        if (damageInfo->HitInfo & SPELL_HIT_TYPE_CRIT)
+            procEx|=PROC_EX_CRITICAL_HIT;
+        else
+            procEx|=PROC_EX_NORMAL_HIT;
+    }
+    return procEx;
+}
+
+void Unit::ProcDamageAndSpellFor(bool isVictim, Unit* target, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, SpellInfo const* procSpell,
+                                 uint32 damage, uint32 absorb, SpellInfo const* procAura, SpellInfo const* interruptedSpell, bool procSpellIsHeal, bool onCast)
+{
+    // Player is loaded now - do not allow passive spell casts to proc
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->GetSession()->PlayerLoading())
+        return;
+    // For melee/ranged based attack need update skills and set some Aura states if victim present
+    if (procFlag & MELEE_BASED_TRIGGER_MASK && target && !onCast)
+    {
+        // If exist crit/parry/dodge/block need update aura state (for victim and attacker)
+        if (procExtra & (PROC_EX_CRITICAL_HIT|PROC_EX_PARRY|PROC_EX_DODGE|PROC_EX_BLOCK))
+        {
+            // for victim
+            if (isVictim)
+            {
+                // if victim and dodge attack
+                if (procExtra & PROC_EX_DODGE)
+                {
+                    // Update AURA_STATE on dodge
+                    if (getClass() != CLASS_ROGUE) // skip Rogue Riposte
+                    {
+                        ModifyAuraState(AURA_STATE_DEFENSE, true);
+                        StartReactiveTimer(REACTIVE_DEFENSE);
+                    }
+                }
+                // if victim and parry attack
+                if (procExtra & PROC_EX_PARRY)
+                {
+                    // For Hunters only Counterattack (skip Mongoose bite)
+                    if (getClass() == CLASS_HUNTER)
+                    {
+                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, true);
+                        StartReactiveTimer(REACTIVE_HUNTER_PARRY);
+                    }
+                    else
+                    {
+                        ModifyAuraState(AURA_STATE_DEFENSE, true);
+                        StartReactiveTimer(REACTIVE_DEFENSE);
+                    }
+                }
+                // if and victim block attack
+                if (procExtra & PROC_EX_BLOCK)
+                {
+                    ModifyAuraState(AURA_STATE_DEFENSE, true);
+                    StartReactiveTimer(REACTIVE_DEFENSE);
+                }
+            }
+            else // For attacker
+            {
+                // Overpower on victim dodge
+                if (procExtra & PROC_EX_DODGE && GetTypeId() == TYPEID_PLAYER && getClass() == CLASS_WARRIOR)
+                {
+                    ToPlayer()->AddComboPoints(target, 1);
+                    StartReactiveTimer(REACTIVE_OVERPOWER);
+                }
+            }
+        }
+    }
+
+    Unit* actor = isVictim ? target : this;
+    Unit* actionTarget = !isVictim ? target : this;
+
+    DamageInfo damageInfo = DamageInfo(actor, actionTarget, damage, procSpell, procSpell ? SpellSchoolMask(procSpell->SchoolMask) : SPELL_SCHOOL_MASK_NORMAL, SPELL_DIRECT_DAMAGE);
+    HealInfo healInfo = HealInfo(actor, actionTarget, damage, procSpell, procSpell ? SpellSchoolMask(procSpell->SchoolMask) : SPELL_SCHOOL_MASK_NORMAL);
+    ProcEventInfo eventInfo = ProcEventInfo(actor, actionTarget, target, procFlag, 0, 0, procExtra, NULL, &damageInfo, &healInfo, procSpell);
+
+    ProcTriggeredList procTriggered;
+    // Fill procTriggered list
+    for (AuraApplicationMap::const_iterator itr = GetAppliedAuras().begin(); itr!= GetAppliedAuras().end(); ++itr)
+    {
+        // Do not allow auras to proc from effect triggered by itself
+        if (procAura && procAura->Id == itr->first)
+            continue;
+        ProcTriggeredData triggerData(itr->second->GetBase());
+        // Defensive procs are active on absorbs (so absorption effects are not a hindrance)
+        bool active = damage || (procExtra & PROC_EX_BLOCK && isVictim);
+        if (isVictim)
+            procExtra &= ~PROC_EX_INTERNAL_REQ_FAMILY;
+
+        SpellInfo const* spellProto = itr->second->GetBase()->GetSpellInfo();
+
+        // only auras that has triggered spell should proc from fully absorbed damage
+        if (procExtra & PROC_EX_ABSORB && isVictim)
+            if (damage || spellProto->Effects[EFFECT_0].TriggerSpell || spellProto->Effects[EFFECT_1].TriggerSpell || spellProto->Effects[EFFECT_2].TriggerSpell)
+                active = true;
+
+        // Stealth auras & cc auras are always active
+        if (spellProto->HasAura(SPELL_AURA_MOD_STEALTH) || spellProto->AttributesCu & SPELL_ATTR0_CU_AURA_CC)
+            active = true;
+
+        // Absorb auras with charges should obviously be active
+        if (spellProto->HasAura(SPELL_AURA_SCHOOL_ABSORB) && spellProto->ProcCharges)
+            active = true;
+
+        // Some procflags that should be triggered when damage is absorbed
+        if (procExtra & PROC_EX_ABSORB && !isVictim && spellProto->ProcFlags & (PROC_FLAG_DONE_MELEE_AUTO_ATTACK))
+            active = true;
+
+        if (!IsTriggeredAtSpellProcEvent(target, triggerData.aura, procSpell, procFlag, procExtra, attType, isVictim, active, triggerData.spellProcEvent))
+            continue;
+
+        // do checks using conditions table
+        ConditionList conditions = sConditionMgr->GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SPELL_PROC, spellProto->Id);
+        ConditionSourceInfo condInfo = ConditionSourceInfo(eventInfo.GetActor(), eventInfo.GetActionTarget());
+        if (!sConditionMgr->IsObjectMeetToConditions(condInfo, conditions))
+            continue;
+
+        // AuraScript Hook
+        if (!triggerData.aura->CallScriptCheckProcHandlers(itr->second, eventInfo))
+            continue;
+
+        // Triggered spells not triggering additional spells
+        bool triggered = !(spellProto->AttributesEx3 & SPELL_ATTR3_CAN_PROC_WITH_TRIGGERED) ?
+            (procExtra & PROC_EX_INTERNAL_TRIGGERED && !(procFlag & PROC_FLAG_DONE_TRAP_ACTIVATION)) : false;
+
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (itr->second->HasEffect(i))
+            {
+                AuraEffect* aurEff = itr->second->GetBase()->GetEffect(i);
+                // Skip this auras
+                if (isNonTriggerAura[aurEff->GetAuraType()])
+                    continue;
+                // If not trigger by default and spellProcEvent == NULL - skip
+                if (!isTriggerAura[aurEff->GetAuraType()] && triggerData.spellProcEvent == NULL)
+                    continue;
+                // Some spells must always trigger
+                if (!triggered || isAlwaysTriggeredAura[aurEff->GetAuraType()])
+                    triggerData.effMask |= 1<<i;
+            }
+        }
+        if (triggerData.effMask)
+            procTriggered.push_front(triggerData);
+    }
+
+    // Nothing found
+    if (procTriggered.empty())
+        return;
+
+    // Note: must SetCantProc(false) before return
+    if (procExtra & (PROC_EX_INTERNAL_TRIGGERED | PROC_EX_INTERNAL_CANT_PROC))
+        SetCantProc(true);
+
+    // Handle effects proceed this time
+    for (ProcTriggeredList::const_iterator i = procTriggered.begin(); i != procTriggered.end(); ++i)
+    {
+        // look for aura in auras list, it may be removed while proc event processing
+        if (i->aura->IsRemoved())
+            continue;
+
+        bool useCharges  = i->aura->IsUsingCharges();
+        // no more charges to use, prevent proc
+        if (useCharges && !i->aura->GetCharges())
+            continue;
+
+        bool takeCharges = false;
+        SpellInfo const* spellInfo = i->aura->GetSpellInfo();
+        uint32 Id = i->aura->GetId();
+
+        AuraApplication* aurApp = i->aura->GetApplicationOfTarget(GetGUID());
+
+        bool prepare = i->aura->CallScriptPrepareProcHandlers(aurApp, eventInfo);
+
+        // For players set spell cooldown if need
+        uint32 cooldown = 0;
+        if (prepare && GetTypeId() == TYPEID_PLAYER && i->spellProcEvent && i->spellProcEvent->cooldown)
+            cooldown = i->spellProcEvent->cooldown;
+
+        // Note: must SetCantProc(false) before return
+        if (spellInfo->AttributesEx3 & SPELL_ATTR3_DISABLE_PROC)
+            SetCantProc(true);
+
+        i->aura->CallScriptProcHandlers(aurApp, eventInfo);
+
+        // This bool is needed till separate aura effect procs are still here
+        bool handled = false;
+        if (!onCast && HandleAuraProc(target, damage, i->aura, procSpell, procFlag, procExtra, cooldown, &handled))
+        {
+            sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "ProcDamageAndSpell: casting spell %u (triggered with value by %s aura of spell %u)", spellInfo->Id, (isVictim?"a victim's":"an attacker's"), Id);
+            takeCharges = true;
+        }
+
+        if (!handled)
+        {
+            for (uint8 effIndex = 0; effIndex < MAX_SPELL_EFFECTS; ++effIndex)
+            {
+                if (!(i->effMask & (1<<effIndex)))
+                    continue;
+
+                AuraEffect* triggeredByAura = i->aura->GetEffect(effIndex);
+                ASSERT(triggeredByAura);
+
+                bool prevented = false;
+                if (!onCast)
+                    prevented = i->aura->CallScriptEffectProcHandlers(triggeredByAura, aurApp, eventInfo);
+
+                if (prevented)
+                {
+                    takeCharges = true;
+                    continue;
+                }
+
+                switch (triggeredByAura->GetAuraType())
+                {
+                    case SPELL_AURA_MOD_STEALTH:
+                    {
+                        if (onCast)
+                            break;
+
+                        // White swings or any actual damage will break stealth no matter what
+                        if (!procSpell || damage)
+                        {
+                            takeCharges = true;
+                            break;
+                        }
+
+                        // Friendly casts won't break stealth
+                        if (IsFriendlyTo(target))
+                            break;
+
+                        bool hasAbsorb = false;
+                        if (triggeredByAura->GetSpellInfo()->AttributesEx2 & SPELL_ATTR2_DAMAGE_REDUCED_SHIELD)
+                        {
+                            // Check if we have an aura that prevents stealth from breaking
+                            for (AuraApplicationMap::iterator itr = m_appliedAuras.begin(); itr != m_appliedAuras.end(); itr++)
+                            {
+                                SpellInfo const* spell = itr->second->GetBase()->GetSpellInfo();
+                                if (spell->AttributesEx2 & SPELL_ATTR2_DAMAGE_REDUCED_SHIELD && spell->Id != triggeredByAura->GetId())
+                                {
+                                    hasAbsorb = true;
+                                    break;
+                                }
+                            }
+                        }
+                        // Absorb auras prevent stealth breaking from periodic damage
+                        if (hasAbsorb && procFlag & PROC_FLAG_TAKEN_PERIODIC)
+                            break;
+
+                        // Experimental - not sure if correct
+                        if (!(procSpell->AttributesEx6 & SPELL_ATTR6_IGNORE_CASTER_AURAS) && !(procSpell->Attributes & SPELL_ATTR0_HIDDEN_CLIENTSIDE)
+                            && !(procSpell->AttributesEx & SPELL_ATTR1_NOT_BREAK_STEALTH) && !(procSpell->AttributesEx2 & SPELL_ATTR2_UNK28))
+                            takeCharges = true;
+
+                        // Non damaging Aoes don't remove stealth
+                        if (procSpell->IsTargetingArea() && !absorb && !procSpell->HasAura(SPELL_AURA_INTERFERE_TARGETTING))
+                            takeCharges = false;
+
+                        // Any kind of CC breakes stealth
+                        if (procSpell->AttributesCu & SPELL_ATTR0_CU_AURA_CC)
+                            takeCharges = true;
+                        break;
+                    }
+                    case SPELL_AURA_SPELL_MAGNET:
+                    {
+                        if (!onCast && procSpell && procSpell->DmgClass == SPELL_DAMAGE_CLASS_MAGIC)
+                        {
+                            // Patch 1.2 notes: Spell Reflection no longer reflects abilities
+                            bool cantTrigger = procSpell->Attributes & SPELL_ATTR0_ABILITY || procSpell->AttributesEx & SPELL_ATTR1_CANT_BE_REDIRECTED
+                                || procSpell->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY;
+
+                            if (!cantTrigger)
+                                if (Unit* magnet = triggeredByAura->GetBase()->GetUnitOwner())
+                                    if (magnet->GetGUID() == GetGUID())
+                                        takeCharges = magnet->isAlive();
+                        }
+                        break;
+                    }
+                    case SPELL_AURA_PROC_TRIGGER_SPELL:
+                    case SPELL_AURA_PROC_TRIGGER_SPELL_2:
+                    {
+                        if (onCast)
+                            break;
+
+                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "ProcDamageAndSpell: casting spell %u (triggered by %s aura of spell %u)", spellInfo->Id, (isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                        // Don`t drop charge or add cooldown for not started trigger
+                        if (HandleProcTriggerSpell(target, damage, absorb, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                            takeCharges = true;
+                        break;
+                    }
+                    case SPELL_AURA_PROC_TRIGGER_DAMAGE:
+                    {
+                        if (onCast)
+                            break;
+
+                        // target has to be valid
+                        if (!eventInfo.GetProcTarget())
+                            break;
+
+                        triggeredByAura->HandleProcTriggerDamageAuraProc(aurApp, eventInfo); // this function is part of the new proc system
+                        takeCharges = true;
+                        break;
+                    }
+                    case SPELL_AURA_MANA_SHIELD:
+                    case SPELL_AURA_DUMMY:
+                    {
+                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "ProcDamageAndSpell: casting spell id %u (triggered by %s dummy aura of spell %u)", spellInfo->Id, (isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                        if (HandleDummyAuraProc(target, damage, absorb, triggeredByAura, procSpell, procFlag, procExtra, cooldown, interruptedSpell, procSpellIsHeal, onCast))
+                            takeCharges = true;
+                        break;
+                    }
+                    case SPELL_AURA_PROC_ON_POWER_AMOUNT:
+                    {
+                        if (onCast)
+                            break;
+
+                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)", spellInfo->Id, (isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                        if (HandleAuraProcOnPowerAmount(target, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                            takeCharges = true;
+                        break;
+                    }
+                    case SPELL_AURA_OBS_MOD_POWER:
+                    case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:
+                    case SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN:
+                    case SPELL_AURA_MOD_MELEE_HASTE:
+                    case SPELL_AURA_MOD_MELEE_HASTE_3:
+                        if (onCast)
+                            break;
+
+                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)", spellInfo->Id, isVictim ? "a victim's" : "an attacker's", triggeredByAura->GetId());
+                        takeCharges = true;
+                        break;
+                    case SPELL_AURA_OVERRIDE_CLASS_SCRIPTS:
+                    {
+                        if (onCast)
+                            break;
+
+                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)", spellInfo->Id, (isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                        if (HandleOverrideClassScriptAuraProc(target, damage, triggeredByAura, procSpell, cooldown))
+                            takeCharges = true;
+                        break;
+                    }
+                    case SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE:
+                    {
+                        if (onCast)
+                            break;
+
+                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "ProcDamageAndSpell: casting mending (triggered by %s dummy aura of spell %u)",
+                            (isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+
+                        HandleAuraRaidProcFromChargeWithValue(triggeredByAura);
+                        takeCharges = true;
+                        break;
+                    }
+                    case SPELL_AURA_RAID_PROC_FROM_CHARGE:
+                    {
+                        if (onCast)
+                            break;
+
+                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "ProcDamageAndSpell: casting mending (triggered by %s dummy aura of spell %u)",
+                            (isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+
+                        HandleAuraRaidProcFromCharge(triggeredByAura);
+                        takeCharges = true;
+                        break;
+                    }
+                    case SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE:
+                    {
+                        if (onCast)
+                            break;
+
+                        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "ProcDamageAndSpell: casting spell %u (triggered with value by %s aura of spell %u)", spellInfo->Id, (isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+
+                        if (HandleProcTriggerSpell(target, damage, absorb, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                            takeCharges = true;
+                        break;
+                    }
+                    case SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK:
+                        if (onCast)
+                            break;
+
+                        // Skip melee hits or instant cast spells
+                        if (procSpell && procSpell->CalcCastTime() != 0)
+                            takeCharges = true;
+                        break;
+                    case SPELL_AURA_REFLECT_SPELLS_SCHOOL:
+                        if (onCast)
+                            break;
+
+                        // Skip Melee hits and spells ws wrong school
+                        if (procSpell && (triggeredByAura->GetMiscValue() & procSpell->SchoolMask))         // School check
+                            takeCharges = true;
+                        break;
+                    case SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT:
+                    case SPELL_AURA_MOD_POWER_COST_SCHOOL:
+                        if (onCast)
+                            break;
+
+                        // Skip melee hits and spells ws wrong school or zero cost
+                        if (procSpell &&
+                            (procSpell->ManaCost != 0 || procSpell->ManaCostPercentage != 0) && // Cost check
+                            (triggeredByAura->GetMiscValue() & procSpell->SchoolMask))          // School check
+                            takeCharges = true;
+                        break;
+                    case SPELL_AURA_MECHANIC_IMMUNITY:
+                        if (onCast)
+                            break;
+
+                        // Compare mechanic
+                        if (procSpell && procSpell->Mechanic == uint32(triggeredByAura->GetMiscValue()))
+                            takeCharges = true;
+                        break;
+                    case SPELL_AURA_MOD_MECHANIC_RESISTANCE:
+                        if (onCast)
+                            break;
+
+                        // Compare mechanic
+                        if (procSpell && procSpell->Mechanic == uint32(triggeredByAura->GetMiscValue()))
+                            takeCharges = true;
+                        break;
+                    case SPELL_AURA_MOD_DAMAGE_FROM_CASTER:
+                        if (onCast)
+                            break;
+
+                        // Compare casters
+                        if (triggeredByAura->GetCasterGUID() == target->GetGUID())
+                            takeCharges = true;
+                        break;
+                    // CC Auras which use their amount amount to drop
+                    // Are there any more auras which need this?
+                    case SPELL_AURA_MOD_CONFUSE:
+                    case SPELL_AURA_MOD_FEAR:
+                    case SPELL_AURA_MOD_STUN:
+                    case SPELL_AURA_MOD_ROOT:
+                    case SPELL_AURA_TRANSFORM:
+                    {
+                        if (onCast)
+                            break;
+
+                        // Absorbed damage counts
+                        damage += absorb;
+                        if (!damage || procSpellIsHeal)
+                            break;
+                        // Spell own direct damage at apply wont break the CC
+                        if (procSpell && (procSpell->Id == triggeredByAura->GetId()))
+                        {
+                            Aura* aura = triggeredByAura->GetBase();
+                            // called from spellcast, should not have ticked yet
+                            if (aura->GetDuration() == aura->GetMaxDuration())
+                                break;
+                        }
+                        // chargeable mods are breaking on hit
+                        if (useCharges)
+                            takeCharges = true;
+                        else
+                        {
+                            int32 damageLeft = triggeredByAura->GetAmount();
+                            // No damage left
+                            if (damageLeft < int32(damage))
+                                i->aura->Remove(AURA_REMOVE_BY_DAMAGE);
+                            else
+                                triggeredByAura->SetAmount(damageLeft - damage);
+                        }
+                        break;
+                    }
+                    //case SPELL_AURA_ADD_FLAT_MODIFIER:
+                    //case SPELL_AURA_ADD_PCT_MODIFIER:
+                        // HandleSpellModAuraProc
+                        //break;
+                    default:
+                        if (onCast)
+                            break;
+
+                        // nothing do, just charges counter
+                        takeCharges = true;
+                        break;
+                } // switch (triggeredByAura->GetAuraType())
+                i->aura->CallScriptAfterEffectProcHandlers(triggeredByAura, aurApp, eventInfo);
+            } // for (uint8 effIndex = 0; effIndex < MAX_SPELL_EFFECTS; ++effIndex)
+        } // if (!handled)
+
+        // Remove charge (aura can be removed by triggers)
+        if (prepare && useCharges && takeCharges)
+            i->aura->DropCharge();
+
+        i->aura->CallScriptAfterProcHandlers(aurApp, eventInfo);
+
+        if (spellInfo->AttributesEx3 & SPELL_ATTR3_DISABLE_PROC)
+            SetCantProc(false);
+    }
+
+    // Cleanup proc requirements
+    if (procExtra & (PROC_EX_INTERNAL_TRIGGERED | PROC_EX_INTERNAL_CANT_PROC))
+        SetCantProc(false);
+}
+
+void Unit::GetProcAurasTriggeredOnEvent(std::list<AuraApplication*>& aurasTriggeringProc, std::list<AuraApplication*>* procAuras, ProcEventInfo eventInfo)
+{
+    // use provided list of auras which can proc
+    if (procAuras)
+    {
+        for (std::list<AuraApplication*>::iterator itr = procAuras->begin(); itr!= procAuras->end(); ++itr)
+        {
+            ASSERT((*itr)->GetTarget() == this);
+            if (!(*itr)->GetRemoveMode())
+                if ((*itr)->GetBase()->IsProcTriggeredOnEvent(*itr, eventInfo))
+                {
+                    (*itr)->GetBase()->PrepareProcToTrigger(*itr, eventInfo);
+                    aurasTriggeringProc.push_back(*itr);
+                }
+        }
+    }
+    // or generate one on our own
+    else
+    {
+        for (AuraApplicationMap::iterator itr = GetAppliedAuras().begin(); itr!= GetAppliedAuras().end(); ++itr)
+        {
+            if (itr->second->GetBase()->IsProcTriggeredOnEvent(itr->second, eventInfo))
+            {
+                itr->second->GetBase()->PrepareProcToTrigger(itr->second, eventInfo);
+                aurasTriggeringProc.push_back(itr->second);
+            }
+        }
+    }
+}
+
+void Unit::TriggerAurasProcOnEvent(CalcDamageInfo& damageInfo)
+{
+    DamageInfo dmgInfo = DamageInfo(damageInfo);
+    TriggerAurasProcOnEvent(NULL, NULL, damageInfo.target, damageInfo.procAttacker, damageInfo.procVictim, 0, 0, damageInfo.procEx, NULL, &dmgInfo, NULL);
+}
+
+void Unit::TriggerAurasProcOnEvent(std::list<AuraApplication*>* myProcAuras, std::list<AuraApplication*>* targetProcAuras, Unit* actionTarget, uint32 typeMaskActor, uint32 typeMaskActionTarget, uint32 spellTypeMask, uint32 spellPhaseMask, uint32 hitMask, Spell* spell, DamageInfo* damageInfo, HealInfo* healInfo)
+{
+    // prepare data for self trigger
+    ProcEventInfo myProcEventInfo = ProcEventInfo(this, actionTarget, actionTarget, typeMaskActor, spellTypeMask, spellPhaseMask, hitMask, spell, damageInfo, healInfo, damageInfo->GetSpellInfo());
+    std::list<AuraApplication*> myAurasTriggeringProc;
+    GetProcAurasTriggeredOnEvent(myAurasTriggeringProc, myProcAuras, myProcEventInfo);
+
+    // prepare data for target trigger
+    ProcEventInfo targetProcEventInfo = ProcEventInfo(this, actionTarget, this, typeMaskActionTarget, spellTypeMask, spellPhaseMask, hitMask, spell, damageInfo, healInfo, damageInfo->GetSpellInfo());
+    std::list<AuraApplication*> targetAurasTriggeringProc;
+    if (typeMaskActionTarget)
+        GetProcAurasTriggeredOnEvent(targetAurasTriggeringProc, targetProcAuras, targetProcEventInfo);
+
+    TriggerAurasProcOnEvent(myProcEventInfo, myAurasTriggeringProc);
+
+    if (typeMaskActionTarget)
+        TriggerAurasProcOnEvent(targetProcEventInfo, targetAurasTriggeringProc);
+}
+
+void Unit::TriggerAurasProcOnEvent(ProcEventInfo& eventInfo, std::list<AuraApplication*>& aurasTriggeringProc)
+{
+    for (std::list<AuraApplication*>::iterator itr = aurasTriggeringProc.begin(); itr != aurasTriggeringProc.end(); ++itr)
+    {
+        if (!(*itr)->GetRemoveMode())
+            (*itr)->GetBase()->TriggerProcOnEvent(*itr, eventInfo);
+    }
+}
+
+SpellSchoolMask Unit::GetMeleeDamageSchoolMask() const
+{
+    return SPELL_SCHOOL_MASK_NORMAL;
+}
+
+Player* Unit::GetSpellModOwner() const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+        return (Player*)this;
+    if (ToCreature()->isPet() || ToCreature()->isTotem())
+    {
+        Unit* owner = GetOwner();
+        if (owner && owner->GetTypeId() == TYPEID_PLAYER)
+            return (Player*)owner;
+    }
+    return NULL;
+}
+
+///----------Pet responses methods-----------------
+void Unit::SendPetCastFail(uint8 castCount, SpellInfo const* spellInfo, SpellCastResult result)
+{
+    if (result == SPELL_CAST_OK)
+        return;
+
+    Unit* owner = GetCharmerOrOwner();
+    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Spell::SendCastResult(owner->ToPlayer(), spellInfo, castCount, result, SPELL_CUSTOM_ERROR_NONE, SMSG_PET_CAST_FAILED); 
+}
+
+void Unit::SendPetActionFeedback(uint8 msg)
+{
+    Unit* owner = GetOwner();
+    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    WorldPacket data(SMSG_PET_ACTION_FEEDBACK, 1);
+    data << uint8(msg);
+    owner->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+void Unit::SendPetTalk(uint32 pettalk)
+{
+    Unit* owner = GetOwner();
+    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    WorldPacket data(SMSG_PET_ACTION_SOUND, 8 + 4);
+    data << uint64(GetGUID());
+    data << uint32(pettalk);
+    owner->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+void Unit::SendPetAIReaction(uint64 guid)
+{
+    Unit* owner = GetOwner();
+    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    WorldPacket data(SMSG_AI_REACTION, 8 + 4);
+    data << uint64(guid);
+    data << uint32(AI_REACTION_HOSTILE);
+    owner->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+///----------End of Pet responses methods----------
+
+void Unit::StopMoving()
+{
+    ClearUnitState(UNIT_STATE_MOVING);
+
+    // not need send any packets if not in world or not moving
+    if (!IsInWorld() || movespline->Finalized())
+        return;
+
+    UpdateSplinePosition();
+    float z = GetPositionZMinusOffset();
+    if (z < VMAP_INVALID_HEIGHT_VALUE)
+    {
+        z = VMAP_INVALID_HEIGHT_VALUE;
+        Relocate(GetPositionX(), GetPositionY(), z);
+    }
+
+    Movement::MoveSplineInit init(this);
+    init.MoveTo(GetPositionX(), GetPositionY(), z, false);
+    init.SetFacing(GetOrientation());
+    init.Launch();
+}
+
+bool Unit::IsSitState() const
+{
+    uint8 s = getStandState();
+    return
+        s == UNIT_STAND_STATE_SIT_CHAIR        || s == UNIT_STAND_STATE_SIT_LOW_CHAIR  ||
+        s == UNIT_STAND_STATE_SIT_MEDIUM_CHAIR || s == UNIT_STAND_STATE_SIT_HIGH_CHAIR ||
+        s == UNIT_STAND_STATE_SIT;
+}
+
+bool Unit::IsStandState() const
+{
+    uint8 s = getStandState();
+    return !IsSitState() && s != UNIT_STAND_STATE_SLEEP && s != UNIT_STAND_STATE_KNEEL;
+}
+
+void Unit::SetStandState(uint8 state)
+{
+    SetByteValue(UNIT_FIELD_BYTES_1, 0, state);
+
+    if (IsStandState())
+       RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_SEATED);
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        WorldPacket data(SMSG_STANDSTATE_UPDATE, 1);
+        data << (uint8)state;
+        ToPlayer()->GetSession()->SendPacket(&data);
+    }
+}
+
+bool Unit::IsPolymorphed() const
+{
+    uint32 transformId = getTransForm();
+    if (!transformId)
+        return false;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(transformId);
+    if (!spellInfo)
+        return false;
+
+    return spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_MAGE_POLYMORPH;
+}
+
+void Unit::SetDisplayId(uint32 modelId)
+{
+    SetUInt32Value(UNIT_FIELD_DISPLAYID, modelId);
+}
+
+void Unit::RestoreDisplayId()
+{
+    AuraEffect* handledAura = NULL;
+    // try to receive model from transform auras
+    Unit::AuraEffectList const& transforms = GetAuraEffectsByType(SPELL_AURA_TRANSFORM);
+    if (!transforms.empty())
+    {
+        // iterate over already applied transform auras - from newest to oldest
+        for (Unit::AuraEffectList::const_reverse_iterator i = transforms.rbegin(); i != transforms.rend(); ++i)
+        {
+            if (AuraApplication const* aurApp = (*i)->GetBase()->GetApplicationOfTarget(GetGUID()))
+            {
+                if (!handledAura)
+                    handledAura = (*i);
+                // prefer negative auras
+                if (!aurApp->IsPositive())
+                {
+                    handledAura = (*i);
+                    break;
+                }
+            }
+        }
+    }
+    // transform aura was found
+    if (handledAura)
+        handledAura->HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true);
+    // we've found shapeshift
+    else if (uint32 modelId = GetModelForForm(GetShapeshiftForm()))
+        SetDisplayId(modelId);
+    // no auras found - set modelid to default
+    else
+        SetDisplayId(GetNativeDisplayId());
+}
+
+void Unit::ClearComboPointHolders()
+{
+    while (!m_ComboPointHolders.empty())
+    {
+        uint32 lowguid = *m_ComboPointHolders.begin();
+
+        Player* player = ObjectAccessor::FindPlayer(MAKE_NEW_GUID(lowguid, 0, HIGHGUID_PLAYER));
+        if (player && player->GetComboTarget() == GetGUID())         // recheck for safe
+            player->ClearComboPoints();                        // remove also guid from m_ComboPointHolders;
+        else
+            m_ComboPointHolders.erase(lowguid);             // or remove manually
+    }
+}
+
+void Unit::ClearAllReactives()
+{
+    for (uint8 i = 0; i < MAX_REACTIVE; ++i)
+        m_reactiveTimer[i] = 0;
+
+    if (HasAuraState(AURA_STATE_DEFENSE))
+        ModifyAuraState(AURA_STATE_DEFENSE, false);
+    if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
+        ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
+    if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->ClearComboPoints();
+}
+
+void Unit::UpdateReactives(uint32 p_time)
+{
+    for (uint8 i = 0; i < MAX_REACTIVE; ++i)
+    {
+        ReactiveType reactive = ReactiveType(i);
+
+        if (!m_reactiveTimer[reactive])
+            continue;
+
+        if (m_reactiveTimer[reactive] <= p_time)
+        {
+            m_reactiveTimer[reactive] = 0;
+
+            switch (reactive)
+            {
+                case REACTIVE_DEFENSE:
+                    if (HasAuraState(AURA_STATE_DEFENSE))
+                        ModifyAuraState(AURA_STATE_DEFENSE, false);
+                    break;
+                case REACTIVE_HUNTER_PARRY:
+                    if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
+                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
+                    break;
+                case REACTIVE_OVERPOWER:
+                    if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)
+                        ToPlayer()->ClearComboPoints();
+                    break;
+                default:
+                    break;
+            }
+        }
+        else
+        {
+            m_reactiveTimer[reactive] -= p_time;
+        }
+    }
+}
+
+Unit* Unit::SelectNearbyTarget(Unit* exclude, float dist) const
+{
+    std::list<Unit*> targets;
+    Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(this, this, dist);
+    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(this, targets, u_check);
+    VisitNearbyObject(dist, searcher);
+
+    // remove current target
+    if (GetVictim())
+        targets.remove(GetVictim());
+
+    if (exclude)
+        targets.remove(exclude);
+
+    // remove not LoS targets
+    for (std::list<Unit*>::iterator tIter = targets.begin(); tIter != targets.end();)
+    {
+        if (!IsWithinLOSInMap(*tIter) || (*tIter)->isTotem() || (*tIter)->isSpiritService() || (*tIter)->GetCreatureType() == CREATURE_TYPE_CRITTER)
+            targets.erase(tIter++);
+        else
+            ++tIter;
+    }
+
+    // no appropriate targets
+    if (targets.empty())
+        return NULL;
+
+    // select random
+    return Trinity::Containers::SelectRandomContainerElement(targets);
+}
+
+void Unit::ApplyAttackTimePercentMod(WeaponAttackType att, float val, bool apply, bool applyRegenPct)
+{
+    float remainingTimePct = (float)m_attackTimer[att] / (GetAttackTime(att) * m_modAttackSpeedPct[att]);
+    if (val > 0)
+    {
+        ApplyPercentModFloatVarPrecise(m_modAttackSpeedPct[att], val, !apply, 1.0f);
+        ApplyPercentModFloatValue(UNIT_FIELD_BASEATTACKTIME+att, val, !apply);
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            if (att == BASE_ATTACK)
+            {
+                ApplyPercentModFloatValuePrecise(PLAYER_FIELD_MOD_HASTE, val, !apply, 1.0f);
+                if (GetTypeId() == TYPEID_PLAYER && getClass() != CLASS_HUNTER && applyRegenPct)
+                    ApplyPercentModFloatValue(PLAYER_FIELD_MOD_HASTE_REGEN, val, !apply);
+            }
+            else if (att == RANGED_ATTACK)
+            {
+                ApplyPercentModFloatValuePrecise(PLAYER_FIELD_MOD_RANGED_HASTE, val, !apply, 1.0f);
+                if (getClass() == CLASS_HUNTER && applyRegenPct)
+                    ApplyPercentModFloatValue(PLAYER_FIELD_MOD_HASTE_REGEN, val, !apply);
+            }
+        }
+    }
+    else
+    {
+        ApplyPercentModFloatVarPrecise(m_modAttackSpeedPct[att], -val, apply, 1.0f);
+        ApplyPercentModFloatValue(UNIT_FIELD_BASEATTACKTIME+att, -val, apply);
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            if (att == BASE_ATTACK)
+            {
+                ApplyPercentModFloatValuePrecise(PLAYER_FIELD_MOD_HASTE, -val, apply, 1.0f);
+                if (GetTypeId() == TYPEID_PLAYER && getClass() != CLASS_HUNTER && applyRegenPct)
+                    ApplyPercentModFloatValue(PLAYER_FIELD_MOD_HASTE_REGEN, -val, apply);
+            }
+            else if (att == RANGED_ATTACK)
+            {
+                ApplyPercentModFloatValuePrecise(PLAYER_FIELD_MOD_RANGED_HASTE, -val, apply, 1.0f);
+                if (getClass() == CLASS_HUNTER && applyRegenPct)
+                    ApplyPercentModFloatValue(PLAYER_FIELD_MOD_HASTE_REGEN, -val, apply);
+            }
+        }
+    }
+
+    // Modify rune regeneration based on haste
+    if (applyRegenPct && att == BASE_ATTACK && getClass() == CLASS_DEATH_KNIGHT)
+        for (uint8 i = 0; i < NUM_RUNE_TYPES; i++)
+            ApplyPercentModFloatValue(PLAYER_RUNE_REGEN_1 + i, val, apply);
+
+    RecalculatePetsScalingAttackSpeed(att);
+    m_attackTimer[att] = uint32(GetAttackTime(att) * m_modAttackSpeedPct[att] * remainingTimePct);
+}
+
+void Unit::ApplyCastTimePercentMod(float val, bool apply)
+{
+    if (val > 0)
+    {
+        ApplyPercentModFloatValuePrecise(UNIT_MOD_CAST_SPEED, val, !apply, 1.0f);
+        ApplyPercentModFloatValuePrecise(UNIT_MOD_CAST_HASTE, val, !apply, 1.0f);
+    }
+    else
+    {
+        ApplyPercentModFloatValuePrecise(UNIT_MOD_CAST_SPEED, -val, apply, 1.0f);
+        ApplyPercentModFloatValuePrecise(UNIT_MOD_CAST_HASTE, -val, apply, 1.0f);
+    }
+}
+
+uint32 Unit::GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectType damagetype, uint32 CastingTime) const
+{
+    // Not apply this to creature casted spells with casttime == 0
+    if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !ToCreature()->isPet())
+        return 3500;
+
+    if (CastingTime > 7000) CastingTime = 7000;
+    if (CastingTime < 1500) CastingTime = 1500;
+
+    if (damagetype == DOT && !spellProto->IsChanneled())
+        CastingTime = 3500;
+
+    int32 overTime    = 0;
+    uint8 effects     = 0;
+    bool DirectDamage = false;
+    bool AreaEffect   = false;
+
+    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; i++)
+    {
+        switch (spellProto->Effects[i].Effect)
+        {
+            case SPELL_EFFECT_SCHOOL_DAMAGE:
+            case SPELL_EFFECT_POWER_DRAIN:
+            case SPELL_EFFECT_HEALTH_LEECH:
+            case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
+            case SPELL_EFFECT_POWER_BURN:
+            case SPELL_EFFECT_HEAL:
+                DirectDamage = true;
+                break;
+            case SPELL_EFFECT_APPLY_AURA:
+                switch (spellProto->Effects[i].ApplyAuraName)
+                {
+                    case SPELL_AURA_PERIODIC_DAMAGE:
+                    case SPELL_AURA_PERIODIC_HEAL:
+                    case SPELL_AURA_PERIODIC_LEECH:
+                        if (spellProto->GetDuration())
+                            overTime = spellProto->GetDuration();
+                        break;
+                    default:
+                        // -5% per additional effect
+                        ++effects;
+                        break;
+                }
+            default:
+                break;
+        }
+
+        if (spellProto->Effects[i].IsTargetingArea())
+            AreaEffect = true;
+    }
+
+    // Combined Spells with Both Over Time and Direct Damage
+    if (overTime > 0 && CastingTime > 0 && DirectDamage)
+    {
+        // mainly for DoTs which are 3500 here otherwise
+        uint32 OriginalCastTime = spellProto->CalcCastTime();
+        if (OriginalCastTime > 7000) OriginalCastTime = 7000;
+        if (OriginalCastTime < 1500) OriginalCastTime = 1500;
+        // Portion to Over Time
+        float PtOT = (overTime / 15000.0f) / ((overTime / 15000.0f) + (OriginalCastTime / 3500.0f));
+
+        if (damagetype == DOT)
+            CastingTime = uint32(CastingTime * PtOT);
+        else if (PtOT < 1.0f)
+            CastingTime  = uint32(CastingTime * (1 - PtOT));
+        else
+            CastingTime = 0;
+    }
+
+    // Area Effect Spells receive only half of bonus
+    if (AreaEffect)
+        CastingTime /= 2;
+
+    // 50% for damage and healing spells for leech spells from damage bonus and 0% from healing
+    for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        if (spellProto->Effects[j].Effect == SPELL_EFFECT_HEALTH_LEECH ||
+            (spellProto->Effects[j].Effect == SPELL_EFFECT_APPLY_AURA && spellProto->Effects[j].ApplyAuraName == SPELL_AURA_PERIODIC_LEECH))
+        {
+            CastingTime /= 2;
+            break;
+        }
+    }
+
+    // -5% of total per any additional effect
+    for (uint8 i = 0; i < effects; ++i)
+        CastingTime *= 0.95f;
+
+    return CastingTime;
+}
+
+void Unit::UpdateAuraForGroup(uint8 slot)
+{
+    if (slot >= MAX_AURAS)                        // slot not found, return
+        return;
+    if (Player* player = ToPlayer())
+    {
+        if (player->GetGroup())
+        {
+            player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_AURAS);
+            player->SetAuraUpdateMaskForRaid(slot);
+        }
+    }
+    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->isPet())
+    {
+        Pet* pet = ((Pet*)this);
+        if (pet->isControlled())
+        {
+            Unit* owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+            {
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_AURAS);
+                pet->SetAuraUpdateMaskForRaid(slot);
+            }
+        }
+    }
+}
+
+float Unit::CalculateDefaultCoefficient(SpellInfo const* spellInfo, DamageEffectType damagetype) const
+{
+    // Damage over Time spells bonus calculation
+    float DotFactor = 1.0f;
+    if (damagetype == DOT)
+    {
+
+        int32 DotDuration = spellInfo->GetDuration();
+        if (!spellInfo->IsChanneled() && DotDuration > 0)
+            DotFactor = DotDuration / 15000.0f;
+
+        if (uint32 DotTicks = spellInfo->GetMaxTicks())
+            DotFactor /= DotTicks;
+    }
+
+    int32 CastingTime = spellInfo->IsChanneled() ? spellInfo->GetDuration() : spellInfo->CalcCastTime();
+    // Distribute Damage over multiple effects, reduce by AoE
+    CastingTime = GetCastingTimeForBonus(spellInfo, damagetype, CastingTime);
+
+    // As wowwiki says: C = (Cast Time / 3.5)
+    return (CastingTime / 3500.0f) * DotFactor;
+}
+
+float Unit::GetAPMultiplier(WeaponAttackType attType, bool normalized)
+{
+    if (!normalized || GetTypeId() != TYPEID_PLAYER)
+        return float(GetAttackTime(attType)) / 1000.0f;
+
+    Item* Weapon = ToPlayer()->GetWeaponForAttack(attType, true);
+    if (!Weapon)
+        return 2.4f;                                         // fist attack
+
+    switch (Weapon->GetTemplate()->InventoryType)
+    {
+        case INVTYPE_2HWEAPON:
+            return 3.3f;
+        case INVTYPE_RANGED:
+        case INVTYPE_RANGEDRIGHT:
+        case INVTYPE_THROWN:
+            return 2.8f;
+        case INVTYPE_WEAPON:
+        case INVTYPE_WEAPONMAINHAND:
+        case INVTYPE_WEAPONOFFHAND:
+        default:
+            return Weapon->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ? 1.7f : 2.4f;
+    }
+}
+
+void Unit::SetContestedPvP(Player* attackedPlayer)
+{
+    Player* player = GetCharmerOrOwnerPlayerOrPlayerItself();
+
+    if (!player || (attackedPlayer && (attackedPlayer == player || (player->duel && player->duel->opponent == attackedPlayer))))
+        return;
+
+    player->SetContestedPvPTimer(30000);
+    if (!player->HasUnitState(UNIT_STATE_ATTACK_PLAYER))
+    {
+        player->AddUnitState(UNIT_STATE_ATTACK_PLAYER);
+        player->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP);
+        // call MoveInLineOfSight for nearby contested guards
+        UpdateObjectVisibility();
+    }
+    if (!HasUnitState(UNIT_STATE_ATTACK_PLAYER))
+    {
+        AddUnitState(UNIT_STATE_ATTACK_PLAYER);
+        // call MoveInLineOfSight for nearby contested guards
+        UpdateObjectVisibility();
+    }
+}
+
+void Unit::AddPetAura(PetAura const* petSpell)
+{
+    if (GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    m_petAuras.insert(petSpell);
+    if (Pet* pet = ToPlayer()->GetPet())
+        pet->CastPetAura(petSpell);
+}
+
+void Unit::RemovePetAura(PetAura const* petSpell)
+{
+    if (GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    m_petAuras.erase(petSpell);
+    if (Pet* pet = ToPlayer()->GetPet())
+        pet->RemoveAurasDueToSpell(petSpell->GetAura(pet->GetEntry()));
+}
+
+Pet* Unit::CreateTamedPetFrom(Creature* creatureTarget, uint32 spell_id)
+{
+    if (GetTypeId() != TYPEID_PLAYER)
+        return NULL;
+
+    Pet* pet = new Pet((Player*)this, HUNTER_PET);
+
+    if (!pet->CreateBaseAtCreature(creatureTarget))
+    {
+        delete pet;
+        return NULL;
+    }
+
+    uint8 level = creatureTarget->getLevel() + 5 < getLevel() ? (getLevel() - 5) : creatureTarget->getLevel();
+
+    InitTamedPet(pet, level, spell_id);
+
+    return pet;
+}
+
+Pet* Unit::CreateTamedPetFrom(uint32 creatureEntry, uint32 spell_id)
+{
+    if (GetTypeId() != TYPEID_PLAYER)
+        return NULL;
+
+    CreatureTemplate const* creatureInfo = sObjectMgr->GetCreatureTemplate(creatureEntry);
+    if (!creatureInfo)
+        return NULL;
+
+    Pet* pet = new Pet((Player*)this, HUNTER_PET);
+
+    if (!pet->CreateBaseAtCreatureInfo(creatureInfo, this) || !InitTamedPet(pet, getLevel(), spell_id))
+    {
+        delete pet;
+        return NULL;
+    }
+
+    return pet;
+}
+
+bool Unit::InitTamedPet(Pet* pet, uint8 level, uint32 spell_id)
+{
+    pet->SetCreatorGUID(GetGUID());
+    pet->setFaction(getFaction());
+    pet->SetUInt32Value(UNIT_CREATED_BY_SPELL, spell_id);
+
+    if (GetTypeId() == TYPEID_PLAYER)
+        pet->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+
+    if (!pet->InitStatsForLevel(level))
+    {
+        sLog->outError(LOG_FILTER_UNITS, "Pet::InitStatsForLevel() failed for creature (Entry: %u)!", pet->GetEntry());
+        return false;
+    }
+
+    pet->GetCharmInfo()->SetPetNumber(sObjectMgr->GeneratePetNumber(), true);
+    // this enables pet details window (Shift+P)
+    pet->InitPetCreateSpells();
+    //pet->InitLevelupSpellsForLevel();
+    pet->SetFullHealth();
+    return true;
+}
+
+bool Unit::IsTriggeredAtSpellProcEvent(Unit* victim, Aura* aura, SpellInfo const* procSpell, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, bool isVictim, bool active, SpellProcEventEntry const* & spellProcEvent)
+{
+    SpellInfo const* spellProto = aura->GetSpellInfo();
+
+    // let the aura be handled by new proc system if it has new entry
+    if (sSpellMgr->GetSpellProcEntry(spellProto->Id))
+        return false;
+
+    // Get proc Event Entry
+    spellProcEvent = sSpellMgr->GetSpellProcEvent(spellProto->Id);
+
+    // Get EventProcFlag
+    uint32 EventProcFlag;
+    if (spellProcEvent && spellProcEvent->procFlags) // if exist get custom spellProcEvent->procFlags
+        EventProcFlag = spellProcEvent->procFlags;
+    else
+        EventProcFlag = spellProto->ProcFlags;       // else get from spell proto
+    // Continue if no trigger exist
+    if (!EventProcFlag)
+        return false;
+
+    // Additional checks for triggered spells (ignore trap casts)
+    if (procExtra & PROC_EX_INTERNAL_TRIGGERED && !(procFlag & PROC_FLAG_DONE_TRAP_ACTIVATION))
+    {
+        if (!(spellProto->AttributesEx3 & SPELL_ATTR3_CAN_PROC_WITH_TRIGGERED))
+            return false;
+    }
+
+    // Check spellProcEvent data requirements
+    if (!sSpellMgr->IsSpellProcEventCanTriggeredBy(spellProcEvent, EventProcFlag, procSpell, procFlag, procExtra, active))
+        return false;
+    // In most cases req get honor or XP from kill
+    if (EventProcFlag & PROC_FLAG_KILL && GetTypeId() == TYPEID_PLAYER)
+    {
+        bool allow = false;
+
+        if (victim)
+            allow = ToPlayer()->isHonorOrXPTarget(victim);
+
+        // Shadow Word: Death - can trigger from every kill
+        if (aura->GetId() == 32409)
+            allow = true;
+        if (!allow)
+            return false;
+    }
+    // Aura added by spell can`t trigger from self (prevent drop charges/do triggers)
+    // But except periodic and kill triggers (can triggered from self)
+    if (procSpell && procSpell->Id == spellProto->Id
+        && !(spellProto->ProcFlags&(PROC_FLAG_TAKEN_PERIODIC | PROC_FLAG_KILL)))
+        return false;
+
+    // Check if current equipment allows aura to proc
+    if (!isVictim && GetTypeId() == TYPEID_PLAYER)
+    {
+        Player* player = ToPlayer();
+        if (spellProto->EquippedItemClass == ITEM_CLASS_WEAPON)
+        {
+            Item* item = NULL;
+            if (attType == BASE_ATTACK)
+                item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+            else if (attType == OFF_ATTACK)
+                item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+            else
+                item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED);
+
+            if (player->IsInFeralForm())
+                return false;
+
+            if (!item || item->IsBroken() || item->GetTemplate()->Class != ITEM_CLASS_WEAPON || !((1<<item->GetTemplate()->SubClass) & spellProto->EquippedItemSubClassMask))
+                return false;
+        }
+        else if (spellProto->EquippedItemClass == ITEM_CLASS_ARMOR)
+        {
+            // Check if player is wearing shield
+            Item* item = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+            if (!item || item->IsBroken() || item->GetTemplate()->Class != ITEM_CLASS_ARMOR || !((1<<item->GetTemplate()->SubClass) & spellProto->EquippedItemSubClassMask))
+                return false;
+        }
+    }
+    // Get chance from spell
+    float chance = float(spellProto->ProcChance);
+    // If in spellProcEvent exist custom chance, chance = spellProcEvent->customChance;
+    if (spellProcEvent && spellProcEvent->customChance)
+        chance = spellProcEvent->customChance;
+    // If PPM exist calculate chance from PPM
+    if (spellProcEvent && spellProcEvent->ppmRate != 0)
+    {
+        if (!isVictim)
+        {
+            uint32 WeaponSpeed = GetAttackTime(attType);
+            chance = GetPPMProcChance(WeaponSpeed, spellProcEvent->ppmRate, spellProto);
+        }
+        else
+        {
+            uint32 WeaponSpeed = victim->GetAttackTime(attType);
+            chance = victim->GetPPMProcChance(WeaponSpeed, spellProcEvent->ppmRate, spellProto);
+        }
+    }
+
+    // Dummy auras
+    AuraEffectList const& mDummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+    for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
+    {
+        switch ((*i)->GetSpellInfo()->Id)
+        {
+            case 51554: // Blessing of the Eternals
+            case 51555:
+            {
+                if (spellProto->SpellFamilyFlags & (*i)->GetSpellInfo()->Effects[(*i)->GetEffIndex()].SpellClassMask)
+                    if (victim && victim->GetHealthPct() < 35.0f)
+                        chance += (*i)->GetAmount();
+                break;
+            }
+        }
+    }
+
+    // Apply chance modifer aura
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CHANCE_OF_SUCCESS, chance);
+    return roll_chance_f(chance);
+}
+
+bool Unit::HandleAuraRaidProcFromChargeWithValue(AuraEffect* triggeredByAura)
+{
+    // aura can be deleted at casts
+    SpellInfo const* spellProto = triggeredByAura->GetSpellInfo();
+    int32 heal = triggeredByAura->GetAmount();
+    uint64 caster_guid = triggeredByAura->GetCasterGUID();
+
+    // Currently only Prayer of Mending
+    if (!(spellProto->SpellFamilyName == SPELLFAMILY_PRIEST && spellProto->SpellFamilyFlags[1] & 0x20))
+    {
+        sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "Unit::HandleAuraRaidProcFromChargeWithValue, received not handled spell: %u", spellProto->Id);
+        return false;
+    }
+
+    // jumps
+    int32 jumps = triggeredByAura->GetBase()->GetCharges()-1;
+
+    // next target selection
+    if (jumps > 0)
+    {
+        if (Unit* caster = triggeredByAura->GetCaster())
+        {
+            float radius = triggeredByAura->GetSpellInfo()->Effects[triggeredByAura->GetEffIndex()].CalcRadius(caster);
+
+            if (Unit* target = GetNextRandomRaidMemberOrPet(radius))
+            {
+                CastCustomSpell(target, spellProto->Id, &heal, NULL, NULL, true, NULL, triggeredByAura, caster_guid);
+                if (Aura* aura = target->GetAura(spellProto->Id, caster->GetGUID()))
+                    aura->SetCharges(jumps);
+            }
+        }
+    }
+
+    // heal
+    CastCustomSpell(this, 33110, &heal, NULL, NULL, true, NULL, NULL, caster_guid);
+    // current aura expire
+    triggeredByAura->GetBase()->SetCharges(1);             // will removed at next charges decrease
+    return true;
+	
+	 // Glyph of Prayer of Mending
+        if (HasAura(55685) && jumps == 4)
+        {
+            heal += heal * 0.6f;
+            CastCustomSpell(this, 33110, &heal, NULL, NULL, true, NULL, NULL, caster_guid);
+            return true;
+        }
+
+}
+bool Unit::HandleAuraRaidProcFromCharge(AuraEffect* triggeredByAura)
+{
+    // aura can be deleted at casts
+    SpellInfo const* spellProto = triggeredByAura->GetSpellInfo();
+
+    uint32 damageSpellId;
+    switch (spellProto->Id)
+    {
+        case 57949:            // shiver
+            damageSpellId = 57952;
+            //animationSpellId = 57951; dummy effects for jump spell have unknown use (see also 41637)
+            break;
+        case 59978:            // shiver
+            damageSpellId = 59979;
+            break;
+        case 43593:            // Cold Stare
+            damageSpellId = 43594;
+            break;
+        default:
+            sLog->outError(LOG_FILTER_UNITS, "Unit::HandleAuraRaidProcFromCharge, received unhandled spell: %u", spellProto->Id);
+            return false;
+    }
+
+    uint64 caster_guid = triggeredByAura->GetCasterGUID();
+
+    // jumps
+    int32 jumps = triggeredByAura->GetBase()->GetCharges()-1;
+
+    // current aura expire
+    triggeredByAura->GetBase()->SetCharges(1);             // will removed at next charges decrease
+
+    // next target selection
+    if (jumps > 0)
+    {
+        if (Unit* caster = triggeredByAura->GetCaster())
+        {
+            float radius = triggeredByAura->GetSpellInfo()->Effects[triggeredByAura->GetEffIndex()].CalcRadius(caster);
+            if (Unit* target= GetNextRandomRaidMemberOrPet(radius))
+            {
+                CastSpell(target, spellProto, true, NULL, triggeredByAura, caster_guid);
+                if (Aura* aura = target->GetAura(spellProto->Id, caster->GetGUID()))
+                    aura->SetCharges(jumps);
+            }
+        }
+    }
+
+    CastSpell(this, damageSpellId, true, NULL, triggeredByAura, caster_guid);
+
+    return true;
+}
+
+void Unit::SendDurabilityLoss(Player* receiver, uint32 percent)
+{
+    WorldPacket data(SMSG_DURABILITY_DAMAGE_DEATH, 4);
+    data << uint32(percent);
+    receiver->GetSession()->SendPacket(&data);
+}
+
+void Unit::PlayOneShotAnimKit(uint32 id)
+{
+    WorldPacket data(SMSG_PLAY_ONE_SHOT_ANIM_KIT, 7+2);
+    data.appendPackGUID(GetGUID());
+    data << uint16(id);
+    SendMessageToSet(&data, true);
+}
+
+void Unit::Kill(Unit* victim, bool durabilityLoss)
+{
+    // Prevent killing unit twice (and giving reward from kill twice)
+    if (!victim->GetHealth())
+        return;
+
+    // Spirit of Redemption can't be killed twice
+    if (victim->HasAura(27827))
+        return;
+
+    m_IsInKillingProcess = true;		
+		
+    // find player: owner of controlled `this` or `this` itself maybe
+    Player* player = GetCharmerOrOwnerPlayerOrPlayerItself();
+    Creature* creature = victim->ToCreature();
+
+    bool isRewardAllowed = true;
+    if (creature)
+    {
+        isRewardAllowed = creature->IsDamageEnoughForLootingAndReward();
+        if (!isRewardAllowed)
+            creature->SetLootRecipient(NULL);
+    }
+
+    if (isRewardAllowed && creature && creature->GetLootRecipient())
+        player = creature->GetLootRecipient();
+
+    // Reward player, his pets, and group/raid members
+    // call kill spell proc event (before real die and combat stop to triggering auras removed at death/combat stop)
+    if (isRewardAllowed && player && player != victim)
+    {
+        WorldPacket data(SMSG_PARTYKILLLOG, (8+8)); // send event PARTY_KILL
+        data << uint64(player->GetGUID()); // player with killing blow
+        data << uint64(victim->GetGUID()); // victim
+
+        Player* looter = player;
+
+        if (Group* group = player->GetGroup())
+        {
+            group->BroadcastPacket(&data, group->GetMemberGroup(player->GetGUID()));
+
+            if (creature)
+            {
+                group->UpdateLooterGuid(creature, true);
+                if (group->GetLooterGuid())
+                {
+                    looter = ObjectAccessor::FindPlayer(group->GetLooterGuid());
+                    if (looter)
+                    {
+                        creature->SetLootRecipient(looter);   // update creature loot recipient to the allowed looter.
+                        group->SendLooter(creature, looter);
+                    }
+                    else
+                        group->SendLooter(creature, NULL);
+                }
+                else
+                    group->SendLooter(creature, NULL);
+
+                group->UpdateLooterGuid(creature);
+            }
+        }
+        else
+        {
+            player->SendDirectMessage(&data);
+
+            if (creature)
+            {
+                WorldPacket data2(SMSG_LOOT_LIST, 8 + 1 + 1);
+                data2 << uint64(creature->GetGUID());
+                data2 << uint8(0); // unk1
+                data2 << uint8(0); // no group looter
+                player->SendMessageToSet(&data2, true);
+            }
+        }
+
+        if (creature)
+        {
+            Loot* loot = &creature->loot;
+            if (creature->lootForPickPocketed)
+                creature->lootForPickPocketed = false;
+
+            loot->clear();
+            if (uint32 lootid = creature->GetCreatureTemplate()->lootid)
+                loot->FillLoot(lootid, LootTemplates_Creature, looter, false, false, creature->GetLootMode());
+
+            loot->generateMoneyLoot(creature->GetCreatureTemplate()->mingold, creature->GetCreatureTemplate()->maxgold);
+        }
+
+        player->RewardPlayerAndGroupAtKill(victim, false);
+    }
+
+    // Do KILL and KILLED procs. KILL proc is called only for the unit who landed the killing blow (and its owner - for pets and totems) regardless of who tapped the victim
+    if (isPet() || isTotem())
+        if (Unit* owner = GetOwner())
+            owner->ProcDamageAndSpell(victim, PROC_FLAG_KILL, PROC_FLAG_NONE, PROC_EX_NONE, 0, 0);
+
+    if (victim->GetCreatureType() != CREATURE_TYPE_CRITTER)
+        ProcDamageAndSpell(victim, PROC_FLAG_KILL, PROC_FLAG_KILLED, PROC_EX_NONE, 0, 0);
+
+    // Proc auras on death - must be before aura/combat remove
+    victim->ProcDamageAndSpell(NULL, PROC_FLAG_DEATH, PROC_FLAG_NONE, PROC_EX_NONE, 0, 0, BASE_ATTACK, 0);
+
+    // update get killing blow achievements, must be done before setDeathState to be able to require auras on target
+    // and before Spirit of Redemption as it also removes auras
+    if (player)
+        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS, 1, 0, 0, victim);
+
+    // if talent known but not triggered (check priest class for speedup check)
+    bool spiritOfRedemption = false;
+    if (victim->GetTypeId() == TYPEID_PLAYER && victim->getClass() == CLASS_PRIEST)
+    {
+        AuraEffectList const& dummyAuras = victim->GetAuraEffectsByType(SPELL_AURA_DUMMY);
+        for (AuraEffectList::const_iterator itr = dummyAuras.begin(); itr != dummyAuras.end(); ++itr)
+        {
+            if ((*itr)->GetSpellInfo()->SpellIconID == 1654)
+            {
+                AuraEffect const* aurEff = *itr;
+                // save value before aura remove
+                uint32 ressSpellId = victim->GetUInt32Value(PLAYER_SELF_RES_SPELL);
+                if (!ressSpellId)
+                    ressSpellId = victim->ToPlayer()->GetResurrectionSpellId();
+                // Remove all expected to remove at death auras (most important negative case like DoT or periodic triggers)
+                victim->RemoveAllAurasOnDeath();
+                // restore for use at real death
+                victim->SetUInt32Value(PLAYER_SELF_RES_SPELL, ressSpellId);
+
+                // FORM_SPIRITOFREDEMPTION and related auras
+                victim->CastSpell(victim, 27827, true, NULL, aurEff);
+                spiritOfRedemption = true;
+                break;
+            }
+        }
+    }
+
+    if (!spiritOfRedemption)
+    {
+        sLog->outDebug(LOG_FILTER_UNITS, "SET JUST_DIED");
+        victim->setDeathState(JUST_DIED);
+    }
+
+    // Inform pets (if any) when player kills target)
+    // MUST come after victim->setDeathState(JUST_DIED); or pet next target
+    // selection will get stuck on same target and break pet react state
+    if (player)
+    {
+        Pet* pet = player->GetPet();
+        if (pet && pet->isAlive() && pet->isControlled())
+            pet->AI()->KilledUnit(victim);
+    }
+
+    // 10% durability loss on death
+    // clean InHateListOf
+    if (Player* plrVictim = victim->ToPlayer())
+    {
+        // remember victim PvP death for corpse type and corpse reclaim delay
+        // at original death (not at SpiritOfRedemtionTalent timeout)
+        plrVictim->SetPvPDeath(player != NULL);
+
+        // only if not player and not controlled by player pet. And not at BG
+        if ((durabilityLoss && !player && !victim->ToPlayer()->InBattleground()) || (player && sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP)))
+        {
+            double baseLoss = sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH);
+            uint32 loss = uint32(baseLoss - (baseLoss * plrVictim->GetTotalAuraMultiplier(SPELL_AURA_MOD_DURABILITY_LOSS)));
+            sLog->outDebug(LOG_FILTER_UNITS, "We are dead, losing %u percent durability", loss);
+            // Durability loss is calculated more accurately again for each item in Player::DurabilityLoss
+            plrVictim->DurabilityLossAll(baseLoss, false);
+            // durability lost message
+            SendDurabilityLoss(plrVictim, loss);
+        }
+        // Call KilledUnit for creatures
+        if (GetTypeId() == TYPEID_UNIT && IsAIEnabled)
+            ToCreature()->AI()->KilledUnit(victim);
+
+        // last damage from non duel opponent or opponent controlled creature
+        if (plrVictim->duel)
+        {
+            plrVictim->duel->opponent->CombatStopWithPets(true);
+            plrVictim->CombatStopWithPets(true);
+            plrVictim->DuelComplete(DUEL_INTERRUPTED);
+        }
+    }
+    else                                                // creature died
+    {
+        sLog->outDebug(LOG_FILTER_UNITS, "DealDamageNotPlayer");
+
+        if (!creature->isPet())
+        {
+            creature->DeleteThreatList();
+            CreatureTemplate const* cInfo = creature->GetCreatureTemplate();
+            if (cInfo && (cInfo->lootid || cInfo->maxgold > 0))
+                creature->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+        }
+
+        // Call KilledUnit for creatures, this needs to be called after the lootable flag is set
+        if (GetTypeId() == TYPEID_UNIT && IsAIEnabled)
+            ToCreature()->AI()->KilledUnit(victim);
+
+        // Call creature just died function
+        if (creature->IsAIEnabled)
+            creature->AI()->JustDied(this);
+
+        if (TempSummon* summon = creature->ToTempSummon())
+            if (Unit* summoner = summon->GetSummoner())
+                if (summoner->ToCreature() && summoner->IsAIEnabled)
+                    summoner->ToCreature()->AI()->SummonedCreatureDies(creature, this);
+
+        // Dungeon specific stuff, only applies to players killing creatures
+        if (creature->GetInstanceId())
+        {
+            Map* instanceMap = creature->GetMap();
+            Player* creditedPlayer = GetCharmerOrOwnerPlayerOrPlayerItself();
+            // TODO: do instance binding anyway if the charmer/owner is offline
+
+            if (instanceMap->IsDungeon() && creditedPlayer)
+            {
+                if (instanceMap->IsRaidOrHeroicDungeon())
+                {
+                    if (creature->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)
+                        ((InstanceMap*)instanceMap)->PermBindAllPlayers(creditedPlayer);
+                }
+                else
+                {
+                    // the reset time is set but not added to the scheduler
+                    // until the players leave the instance
+                    time_t resettime = creature->GetRespawnTimeEx() + 2 * HOUR;
+                    if (InstanceSave* save = sInstanceSaveMgr->GetInstanceSave(creature->GetInstanceId()))
+                        if (save->GetResetTime() < resettime) save->SetResetTime(resettime);
+                }
+            }
+        }
+    }
+
+    // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
+    // handle player kill only if not suicide (spirit of redemption for example)
+    if (player && this != victim)
+    {
+        if (OutdoorPvP* pvp = player->GetOutdoorPvP())
+            pvp->HandleKill(player, victim);
+
+        if (Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(player->GetZoneId()))
+            bf->HandleKill(player, victim);
+    }
+
+    //if (victim->GetTypeId() == TYPEID_PLAYER)
+    //    if (OutdoorPvP* pvp = victim->ToPlayer()->GetOutdoorPvP())
+    //        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();
+
+    // battleground things (do this at the end, so the death state flag will be properly set to handle in the bg->handlekill)
+    if (player && player->InBattleground())
+    {
+        if (Battleground* bg = player->GetBattleground())
+        {
+            if (victim->GetTypeId() == TYPEID_PLAYER)
+                bg->HandleKillPlayer((Player*)victim, player);
+            else
+                bg->HandleKillUnit(victim->ToCreature(), player);
+        }
+    }
+
+    // achievement stuff
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (GetTypeId() == TYPEID_UNIT)
+            victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILLED_BY_CREATURE, GetEntry());
+        else if (GetTypeId() == TYPEID_PLAYER && victim != this)
+            victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILLED_BY_PLAYER, 1, ToPlayer()->GetTeam());
+    }
+
+    // Hook for OnPVPKill Event
+    if (Player* killerPlr = ToPlayer())
+    {
+        if (Player* killedPlr = victim->ToPlayer())
+            sScriptMgr->OnPVPKill(killerPlr, killedPlr);
+        else if (Creature* killedCre = victim->ToCreature())
+            sScriptMgr->OnCreatureKill(killerPlr, killedCre);
+    }
+    else if (Creature* killerCre = ToCreature())
+    {
+        if (Player* killed = victim->ToPlayer())
+            sScriptMgr->OnPlayerKilledByCreature(killerCre, killed);
+    }
+}
+
+void Unit::SetControlled(bool apply, UnitState state)
+{
+    if (apply)
+    {
+        if (HasUnitState(state))
+            return;
+
+        AddUnitState(state);
+        switch (state)
+        {
+            case UNIT_STATE_STUNNED:
+                SetStunned(true);
+                CastStop();
+                break;
+            case UNIT_STATE_ROOT:
+                if (!HasUnitState(UNIT_STATE_STUNNED))
+                    SetRooted(true);
+                break;
+            case UNIT_STATE_CONFUSED:
+                if (!HasUnitState(UNIT_STATE_STUNNED))
+                {
+                    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
+                    SendMeleeAttackStop();
+                    // SendAutoRepeatCancel ?
+                    SetConfused(true);
+                    CastStop();
+                }
+                break;
+            case UNIT_STATE_FLEEING:
+                if (!HasUnitState(UNIT_STATE_STUNNED | UNIT_STATE_CONFUSED))
+                {
+                    ClearUnitState(UNIT_STATE_MELEE_ATTACKING);
+                    SendMeleeAttackStop();
+                    // SendAutoRepeatCancel ?
+                    SetFeared(true);
+                    CastStop();
+                }
+                break;
+            default:
+                break;
+        }
+    }
+    else
+    {
+        switch (state)
+        {
+            case UNIT_STATE_STUNNED: if (HasAuraType(SPELL_AURA_MOD_STUN))    return;
+                                    else    SetStunned(false);    break;
+            case UNIT_STATE_ROOT:    if (HasAuraType(SPELL_AURA_MOD_ROOT) || GetVehicle())    return;
+                                    else    SetRooted(false);     break;
+            case UNIT_STATE_CONFUSED:if (HasAuraType(SPELL_AURA_MOD_CONFUSE)) return;
+                                    else    SetConfused(false);   break;
+            case UNIT_STATE_FLEEING: if (HasAuraType(SPELL_AURA_MOD_FEAR))    return;
+                                    else    SetFeared(false);     break;
+            default: return;
+        }
+
+        ClearUnitState(state);
+
+        if (HasUnitState(UNIT_STATE_STUNNED))
+            SetStunned(true);
+        else
+        {
+            if (HasUnitState(UNIT_STATE_ROOT))
+                SetRooted(true);
+
+            if (HasUnitState(UNIT_STATE_CONFUSED))
+                SetConfused(true);
+            else if (HasUnitState(UNIT_STATE_FLEEING))
+                SetFeared(true);
+        }
+    }
+}
+
+void Unit::SendMoveRoot()
+{
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer())
+        ToPlayer()->m_movement_ack[ACK_ROOT] = m_movementCounter;
+
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.ackCount = m_movementCounter++;
+    info.guid = GetGUID();
+
+    Movement::PacketSender(this, SMSG_SPLINE_MOVE_ROOT, SMSG_MOVE_ROOT, &info).Send();
+}
+
+void Unit::SendMoveUnroot()
+{
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer())
+        ToPlayer()->m_movement_ack[ACK_UNROOT] = m_movementCounter;
+
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.ackCount = m_movementCounter++;
+    info.guid = GetGUID();
+
+    Movement::PacketSender(this, SMSG_SPLINE_MOVE_UNROOT, SMSG_MOVE_UNROOT, &info).Send();
+}
+
+void Unit::SetStunned(bool apply)
+{
+    if (apply)
+    {
+        SetTarget(0);
+        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+
+        // MOVEMENTFLAG_ROOT cannot be used in conjunction with MOVEMENTFLAG_MASK_MOVING (tested 3.3.5a)
+        // this will freeze clients. That's why we remove MOVEMENTFLAG_MASK_MOVING before
+        // setting MOVEMENTFLAG_ROOT
+        RemoveUnitMovementFlag(MOVEMENTFLAG_MASK_MOVING);
+        AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
+
+        StopMoving();
+        SendMoveRoot();
+        CastStop();
+    }
+    else
+    {
+        if (isAlive() && GetVictim())
+            SetTarget(GetVictim()->GetGUID());
+
+        // don't remove UNIT_FLAG_STUNNED for pet when owner is mounted (disabled pet's interface)
+        Unit* owner = GetOwner();
+        if (!owner || (owner->GetTypeId() == TYPEID_PLAYER && !owner->ToPlayer()->IsMounted()))
+            RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+
+        if (!HasUnitState(UNIT_STATE_ROOT))         // prevent moving if it also has root effect
+        {
+            SendMoveUnroot();
+            RemoveUnitMovementFlag(MOVEMENTFLAG_ROOT);
+        }
+    }
+}
+
+void Unit::SetRooted(bool apply)
+{
+    if (apply)
+    {
+        // MOVEMENTFLAG_ROOT cannot be used in conjunction with MOVEMENTFLAG_MASK_MOVING (tested 3.3.5a)
+        // this will freeze clients. That's why we remove MOVEMENTFLAG_MASK_MOVING before
+        // setting MOVEMENTFLAG_ROOT
+        RemoveUnitMovementFlag(MOVEMENTFLAG_MASK_MOVING);
+        AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
+
+        SendMoveRoot();
+        StopMoving();
+    }
+    else
+    {
+        if (!HasUnitState(UNIT_STATE_STUNNED))      // prevent moving if it also has stun effect
+        {
+            RemoveUnitMovementFlag(MOVEMENTFLAG_ROOT);
+            SendMoveUnroot();
+        }
+    }
+}
+
+void Unit::SetFeared(bool apply)
+{
+    if (apply)
+    {
+        SetTarget(0);
+
+        Unit* caster = NULL;
+        Unit::AuraEffectList const& fearAuras = GetAuraEffectsByType(SPELL_AURA_MOD_FEAR);
+        if (!fearAuras.empty())
+            caster = ObjectAccessor::GetUnit(*this, fearAuras.front()->GetCasterGUID());
+        if (!caster)
+            caster = getAttackerForHelper();
+        GetMotionMaster()->MoveFleeing(caster, fearAuras.empty() ? sWorld->getIntConfig(CONFIG_CREATURE_FAMILY_FLEE_DELAY) : 0);             // caster == NULL processed in MoveFleeing
+    }
+    else
+    {
+        if (isAlive())
+        {
+            if (GetMotionMaster()->GetCurrentMovementGeneratorType() == FLEEING_MOTION_TYPE)
+                GetMotionMaster()->MovementExpired();
+            if (GetVictim())
+                SetTarget(GetVictim()->GetGUID());
+        }
+    }
+
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->SetClientControl(this, !apply);
+}
+
+void Unit::SetConfused(bool apply)
+{
+    if (apply)
+    {
+        SetTarget(0);
+        GetMotionMaster()->MoveConfused();
+    }
+    else
+    {
+        if (isAlive())
+        {
+            if (GetMotionMaster()->GetCurrentMovementGeneratorType() == CONFUSED_MOTION_TYPE)
+                GetMotionMaster()->MovementExpired();
+            if (GetVictim())
+                SetTarget(GetVictim()->GetGUID());
+        }
+    }
+
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->SetClientControl(this, !apply);
+}
+
+bool Unit::SetCharmedBy(Unit* charmer, CharmType type, AuraApplication const* aurApp)
+{
+    if (!charmer)
+        return false;
+
+    // dismount players when charmed
+    if (GetTypeId() == TYPEID_PLAYER)
+        RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+    if (charmer->GetTypeId() == TYPEID_PLAYER)
+        charmer->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+    ASSERT(type != CHARM_TYPE_POSSESS || charmer->GetTypeId() == TYPEID_PLAYER);
+    ASSERT((type == CHARM_TYPE_VEHICLE) == (IsVehicle() && GetTypeId() != TYPEID_PLAYER));
+    sLog->outDebug(LOG_FILTER_UNITS, "SetCharmedBy: charmer %u (GUID %u), charmed %u (GUID %u), type %u.", charmer->GetEntry(), charmer->GetGUIDLow(), GetEntry(), GetGUIDLow(), uint32(type));
+
+    if (this == charmer)
+    {
+        sLog->outFatal(LOG_FILTER_UNITS, "Unit::SetCharmedBy: Unit %u (GUID %u) is trying to charm itself!", GetEntry(), GetGUIDLow());
+        return false;
+    }
+
+    //if (HasUnitState(UNIT_STATE_UNATTACKABLE))
+    //    return false;
+
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->GetTransport())
+    {
+        sLog->outFatal(LOG_FILTER_UNITS, "Unit::SetCharmedBy: Player on transport is trying to charm %u (GUID %u)", GetEntry(), GetGUIDLow());
+        return false;
+    }
+
+    // Already charmed
+    if (GetCharmerGUID())
+    {
+        sLog->outFatal(LOG_FILTER_UNITS, "Unit::SetCharmedBy: %u (GUID %u) has already been charmed but %u (GUID %u) is trying to charm it!", GetEntry(), GetGUIDLow(), charmer->GetEntry(), charmer->GetGUIDLow());
+        return false;
+    }
+
+    CastStop();
+    CombatStop(); // TODO: CombatStop(true) may cause crash (interrupt spells)
+    DeleteThreatList();
+
+    // Charmer stop charming
+    if (charmer->GetTypeId() == TYPEID_PLAYER)
+    {
+        charmer->ToPlayer()->StopCastingCharm();
+        charmer->ToPlayer()->StopCastingBindSight();
+    }
+
+    // Charmed stop charming
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        ToPlayer()->StopCastingCharm();
+        ToPlayer()->StopCastingBindSight();
+    }
+
+    // StopCastingCharm may remove a possessed pet?
+    if (!IsInWorld())
+    {
+        sLog->outFatal(LOG_FILTER_UNITS, "Unit::SetCharmedBy: %u (GUID %u) is not in world but %u (GUID %u) is trying to charm it!", GetEntry(), GetGUIDLow(), charmer->GetEntry(), charmer->GetGUIDLow());
+        return false;
+    }
+
+    // charm is set by aura, and aura effect remove handler was called during apply handler execution
+    // prevent undefined behaviour
+    if (aurApp && aurApp->GetRemoveMode())
+        return false;
+
+    // Set charmed
+    Map* map = GetMap();
+    if (!IsVehicle() || (IsVehicle() && map && !map->IsBattleground()))
+        setFaction(charmer->getFaction());
+
+    charmer->SetCharm(this, true);
+
+    if (GetTypeId() == TYPEID_UNIT)
+    {
+        if(GetEntry() != 35905) // little hack for the Quest: "Save Krennan"
+        {
+           ToCreature()->AI()->OnCharmed(true);
+           GetMotionMaster()->MoveIdle();
+        }
+    }
+    else
+    {
+        Player* player = ToPlayer();
+        if (player->isAFK())
+            player->ToggleAFK();
+        player->SetClientControl(this, 0);
+    }
+
+    // charm is set by aura, and aura effect remove handler was called during apply handler execution
+    // prevent undefined behaviour
+    if (aurApp && aurApp->GetRemoveMode())
+        return false;
+
+    // Pets already have a properly initialized CharmInfo, don't overwrite it.
+    if (type != CHARM_TYPE_VEHICLE && !GetCharmInfo())
+    {
+        InitCharmInfo();
+        if (type == CHARM_TYPE_POSSESS)
+            GetCharmInfo()->InitPossessCreateSpells();
+        else
+            GetCharmInfo()->InitCharmCreateSpells();
+    }
+
+    if (charmer->GetTypeId() == TYPEID_PLAYER)
+    {
+        switch (type)
+        {
+            case CHARM_TYPE_VEHICLE:
+                SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+                charmer->ToPlayer()->SetClientControl(this, 1);
+                charmer->ToPlayer()->SetMover(this);
+                charmer->ToPlayer()->SetViewpoint(this, true);
+                charmer->ToPlayer()->VehicleSpellInitialize();
+                break;
+            case CHARM_TYPE_POSSESS:
+                AddUnitState(UNIT_STATE_POSSESSED);
+                SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+                charmer->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                charmer->ToPlayer()->SetClientControl(this, 1);
+                charmer->ToPlayer()->SetMover(this);
+                charmer->ToPlayer()->SetViewpoint(this, true);
+                charmer->ToPlayer()->PossessSpellInitialize();
+                break;
+            case CHARM_TYPE_CHARM:
+                if (GetTypeId() == TYPEID_UNIT && charmer->getClass() == CLASS_WARLOCK)
+                {
+                    CreatureTemplate const* cinfo = ToCreature()->GetCreatureTemplate();
+                    if (cinfo && cinfo->type == CREATURE_TYPE_DEMON)
+                    {
+                        // to prevent client crash
+                        SetByteValue(UNIT_FIELD_BYTES_0, 1, (uint8)CLASS_MAGE);
+
+                        // just to enable stat window
+                        if (GetCharmInfo())
+                            GetCharmInfo()->SetPetNumber(sObjectMgr->GeneratePetNumber(), true);
+
+                        // if charmed two demons the same session, the 2nd gets the 1st one's name
+                        SetUInt32Value(UNIT_FIELD_PET_NAME_TIMESTAMP, uint32(time(NULL))); // cast can't be helped
+                    }
+                }
+                charmer->ToPlayer()->CharmSpellInitialize();
+                break;
+            default:
+            case CHARM_TYPE_CONVERT:
+                break;
+        }
+    }
+    return true;
+}
+
+void Unit::RemoveCharmedBy(Unit* charmer)
+{
+    if (!isCharmed())
+        return;
+
+    if (!charmer)
+        charmer = GetCharmer();
+    if (charmer != GetCharmer()) // one aura overrides another?
+    {
+//        sLog->outFatal(LOG_FILTER_UNITS, "Unit::RemoveCharmedBy: this: " UI64FMTD " true charmer: " UI64FMTD " false charmer: " UI64FMTD,
+//            GetGUID(), GetCharmerGUID(), charmer->GetGUID());
+//        ASSERT(false);
+        return;
+    }
+
+    CharmType type;
+    if (HasUnitState(UNIT_STATE_POSSESSED))
+        type = CHARM_TYPE_POSSESS;
+    else if (charmer && charmer->IsOnVehicle(this))
+        type = CHARM_TYPE_VEHICLE;
+    else
+        type = CHARM_TYPE_CHARM;
+
+    CastStop();
+    CombatStop(); // TODO: CombatStop(true) may cause crash (interrupt spells)
+    getHostileRefManager().deleteReferences();
+    DeleteThreatList();
+    Map* map = GetMap();
+    if (!IsVehicle() || (IsVehicle() && map && !map->IsBattleground()))
+        RestoreFaction();
+    GetMotionMaster()->InitDefault();
+
+    if (type == CHARM_TYPE_POSSESS)
+    {
+        ClearUnitState(UNIT_STATE_POSSESSED);
+        RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+    }
+
+    if (Creature* creature = ToCreature())
+    {
+        if (creature->AI())
+            creature->AI()->OnCharmed(false);
+
+        if (type != CHARM_TYPE_VEHICLE) // Vehicles' AI is never modified
+        {
+            creature->AIM_Initialize();
+
+            if (creature->AI() && charmer && charmer->isAlive())
+                creature->AI()->AttackStart(charmer);
+        }
+    }
+    else
+        ToPlayer()->SetClientControl(this, 1);
+
+    // If charmer still exists
+    if (!charmer)
+        return;
+
+    ASSERT(type != CHARM_TYPE_POSSESS || charmer->GetTypeId() == TYPEID_PLAYER);
+    ASSERT(type != CHARM_TYPE_VEHICLE || (GetTypeId() == TYPEID_UNIT && IsVehicle()));
+
+    charmer->SetCharm(this, false);
+
+    if (charmer->GetTypeId() == TYPEID_PLAYER)
+    {
+        switch (type)
+        {
+            case CHARM_TYPE_VEHICLE:
+                charmer->ToPlayer()->SetClientControl(charmer, 1);
+                charmer->ToPlayer()->SetMover(charmer);
+                charmer->ToPlayer()->SetViewpoint(this, false);
+                charmer->ToPlayer()->SetClientControl(this, 0);
+                if (GetTypeId() == TYPEID_PLAYER)
+                    ToPlayer()->SetMover(this);
+                break;
+            case CHARM_TYPE_POSSESS:
+                charmer->ToPlayer()->SetClientControl(charmer, 1);
+                charmer->ToPlayer()->SetMover(charmer);
+                charmer->ToPlayer()->SetViewpoint(this, false);
+                charmer->ToPlayer()->SetClientControl(this, 0);
+                charmer->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                if (GetTypeId() == TYPEID_PLAYER)
+                    ToPlayer()->SetMover(this);
+                break;
+            case CHARM_TYPE_CHARM:
+                if (GetTypeId() == TYPEID_UNIT && charmer->getClass() == CLASS_WARLOCK)
+                {
+                    CreatureTemplate const* cinfo = ToCreature()->GetCreatureTemplate();
+                    if (cinfo && cinfo->type == CREATURE_TYPE_DEMON)
+                    {
+                        SetByteValue(UNIT_FIELD_BYTES_0, 1, uint8(cinfo->unit_class));
+                        if (GetCharmInfo())
+                            GetCharmInfo()->SetPetNumber(0, true);
+                        else
+                            sLog->outError(LOG_FILTER_UNITS, "Aura::HandleModCharm: target="UI64FMTD" with typeid=%d has a charm aura but no charm info!", GetGUID(), GetTypeId());
+                    }
+                }
+                break;
+            default:
+            case CHARM_TYPE_CONVERT:
+                break;
+        }
+    }
+
+    // a guardian should always have charminfo
+    if (charmer->GetTypeId() == TYPEID_PLAYER && this != charmer->GetFirstControlled())
+        charmer->ToPlayer()->SendRemoveControlBar();
+    else if (GetTypeId() == TYPEID_PLAYER || (GetTypeId() == TYPEID_UNIT && !ToCreature()->isGuardian()))
+        DeleteCharmInfo();
+}
+
+void Unit::RestoreFaction()
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->setFactionForRace(getRace());
+    else
+    {
+        if (HasUnitTypeMask(UNIT_MASK_MINION))
+        {
+            if (Unit* owner = GetOwner())
+            {
+                setFaction(owner->getFaction());
+                return;
+            }
+        }
+
+        if (CreatureTemplate const* cinfo = ToCreature()->GetCreatureTemplate())  // normal creature
+        {
+            FactionTemplateEntry const* faction = getFactionTemplateEntry();
+            setFaction((faction && faction->friendlyMask & 0x004) ? cinfo->faction_H : cinfo->faction_A);
+        }
+    }
+}
+
+bool Unit::CreateVehicleKit(uint32 id, uint32 creatureEntry)
+{
+    VehicleEntry const* vehInfo = sVehicleStore.LookupEntry(id);
+    if (!vehInfo)
+        return false;
+
+    m_vehicleKit = new Vehicle(this, vehInfo, creatureEntry);
+    m_updateFlag |= UPDATEFLAG_VEHICLE;
+    m_unitTypeMask |= UNIT_MASK_VEHICLE;
+    return true;
+}
+
+void Unit::RemoveVehicleKit()
+{
+    if (!m_vehicleKit)
+        return;
+
+    m_vehicleKit->Uninstall();
+    delete m_vehicleKit;
+
+    m_vehicleKit = NULL;
+
+    m_updateFlag &= ~UPDATEFLAG_VEHICLE;
+    m_unitTypeMask &= ~UNIT_MASK_VEHICLE;
+    RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);
+    RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_PLAYER_VEHICLE);
+}
+
+Unit* Unit::GetVehicleBase() const
+{
+    return m_vehicle ? m_vehicle->GetBase() : NULL;
+}
+
+Creature* Unit::GetVehicleCreatureBase() const
+{
+    if (Unit* veh = GetVehicleBase())
+        if (Creature* c = veh->ToCreature())
+            return c;
+
+    return NULL;
+}
+
+uint64 Unit::GetTransGUID() const
+{
+    if (GetVehicle())
+        return GetVehicleBase()->GetGUID();
+    if (GetTransport())
+        return GetTransport()->GetGUID();
+
+    return 0;
+}
+
+TransportBase* Unit::GetDirectTransport() const
+{
+    if (Vehicle* veh = GetVehicle())
+        return veh;
+    return GetTransport();
+}
+
+bool Unit::IsInPartyWith(Unit const* unit) const
+{
+    if (this == unit)
+        return true;
+
+    const Unit* u1 = GetCharmerOrOwnerOrSelf();
+    const Unit* u2 = unit->GetCharmerOrOwnerOrSelf();
+    if (u1 == u2)
+        return true;
+
+    if (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_PLAYER)
+        return u1->ToPlayer()->IsInSameGroupWith(u2->ToPlayer());
+    else if ((u2->GetTypeId() == TYPEID_PLAYER && u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER) ||
+        (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER))
+        return true;
+    else
+        return false;
+}
+
+bool Unit::IsInRaidWith(Unit const* unit) const
+{
+    if (this == unit)
+        return true;
+
+    const Unit* u1 = GetCharmerOrOwnerOrSelf();
+    const Unit* u2 = unit->GetCharmerOrOwnerOrSelf();
+    if (u1 == u2)
+        return true;
+
+    if (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_PLAYER)
+        return u1->ToPlayer()->IsInSameRaidWith(u2->ToPlayer());
+    else if ((u2->GetTypeId() == TYPEID_PLAYER && u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER) ||
+            (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_PARTY_MEMBER))
+        return true;
+    else
+        return false;
+}
+
+void Unit::GetPartyMembers(std::list<Unit*> &TagUnitMap)
+{
+    Unit* owner = GetCharmerOrOwnerOrSelf();
+    Group* group = NULL;
+    if (owner->GetTypeId() == TYPEID_PLAYER)
+        group = owner->ToPlayer()->GetGroup();
+
+    if (group)
+    {
+        uint8 subgroup = owner->ToPlayer()->GetSubGroup();
+
+        for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* Target = itr->getSource();
+
+            // IsHostileTo check duel and controlled by enemy
+            if (Target && Target->GetSubGroup() == subgroup && !IsHostileTo(Target))
+            {
+                if (Target->isAlive() && IsInMap(Target))
+                    TagUnitMap.push_back(Target);
+
+                if (Guardian* pet = Target->GetGuardianPet())
+                    if (pet->isAlive() && IsInMap(Target))
+                        TagUnitMap.push_back(pet);
+            }
+        }
+    }
+    else
+    {
+        if (owner->isAlive() && (owner == this || IsInMap(owner)))
+            TagUnitMap.push_back(owner);
+        if (Guardian* pet = owner->GetGuardianPet())
+            if (pet->isAlive() && (pet == this || IsInMap(pet)))
+                TagUnitMap.push_back(pet);
+    }
+}
+
+Aura* Unit::AddAura(uint32 spellId, Unit* target)
+{
+    if (!target)
+        return NULL;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return NULL;
+
+    if (!target->isAlive() && !(spellInfo->Attributes & SPELL_ATTR0_PASSIVE) && !(spellInfo->AttributesEx2 & SPELL_ATTR2_CAN_TARGET_DEAD))
+        return NULL;
+
+    return AddAura(spellInfo, MAX_EFFECT_MASK, target);
+}
+
+Aura* Unit::AddAuraForTarget(Aura* aura, Unit* target)
+{
+    if (!target)
+        return NULL;
+
+    if (Aura* newAura = AddAura(aura->GetSpellInfo(), aura->GetEffectMask(), target))
+    {
+        newAura->SetMaxDuration(aura->GetDuration());
+        newAura->SetDuration(aura->GetDuration());
+        for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            if (aura->GetEffectMask() & (1 << i) && newAura->GetEffectMask() & (1 << i))
+                newAura->GetEffect(i)->SetAmount(aura->GetEffect(i)->GetAmount());
+
+        return newAura;
+    }
+    return NULL;
+}
+
+Aura* Unit::AddAura(SpellInfo const* spellInfo, uint8 effMask, Unit* target)
+{
+    if (!spellInfo)
+        return NULL;
+
+    if (target->IsImmunedToSpell(spellInfo))
+        return NULL;
+
+    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (!(effMask & (1<<i)))
+            continue;
+        if (target->IsImmunedToSpellEffect(spellInfo, i, this))
+            effMask &= ~(1<<i);
+    }
+
+    if (Aura* aura = Aura::TryRefreshStackOrCreate(spellInfo, effMask, target, this))
+    {
+        aura->ApplyForTargets();
+        return aura;
+    }
+    return NULL;
+}
+
+void Unit::SetAuraStack(uint32 spellId, Unit* target, uint32 stack)
+{
+    Aura* aura = target->GetAura(spellId, GetGUID());
+    if (!aura)
+        aura = AddAura(spellId, target);
+    if (aura && stack)
+        aura->SetStackAmount(stack);
+}
+
+void Unit::SendPlaySpellVisualKit(uint32 id, uint32 unkParam)
+{
+    ObjectGuid guid = GetGUID();
+
+    WorldPacket data(SMSG_PLAY_SPELL_VISUAL_KIT, 4 + 4+ 4 + 8);
+    data << uint32(0);
+    data << uint32(id);     // SpellVisualKit.dbc index
+    data << uint32(unkParam);
+    data.WriteBit(guid[4]);
+    data.WriteBit(guid[7]);
+    data.WriteBit(guid[5]);
+    data.WriteBit(guid[3]);
+    data.WriteBit(guid[1]);
+    data.WriteBit(guid[2]);
+    data.WriteBit(guid[0]);
+    data.WriteBit(guid[6]);
+    data.FlushBits();
+    data.WriteByteSeq(guid[0]);
+    data.WriteByteSeq(guid[4]);
+    data.WriteByteSeq(guid[1]);
+    data.WriteByteSeq(guid[6]);
+    data.WriteByteSeq(guid[7]);
+    data.WriteByteSeq(guid[2]);
+    data.WriteByteSeq(guid[3]);
+    data.WriteByteSeq(guid[5]);
+    SendMessageToSet(&data, true);
+}
+
+void Unit::ApplyResilience(Unit const* victim, int32* damage, bool isCrit) const
+{
+    // player mounted on multi-passenger mount is also classified as vehicle
+    if (IsVehicle() || (victim->IsVehicle() && victim->GetTypeId() != TYPEID_PLAYER))
+        return;
+
+    // Don't consider resilience if not in PvP - player or pet
+    if (!GetCharmerOrOwnerPlayerOrPlayerItself())
+        return;
+
+    Unit const* target = NULL;
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+        target = victim;
+    else if (victim->GetTypeId() == TYPEID_UNIT && victim->GetOwner() && victim->GetOwner()->GetTypeId() == TYPEID_PLAYER)
+        target = victim->GetOwner();
+
+    if (!target)
+        return;
+
+    *damage -= target->GetDamageReduction(*damage);
+}
+
+// Melee based spells can be miss, parry or dodge on this step
+// Crit or block - determined on damage calculation phase! (and can be both in some time)
+float Unit::MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, uint32 spellId) const
+{
+    //calculate miss chance
+    float missChance = victim->GetUnitMissChance(attType);
+
+    if (!spellId && ToPlayer() && haveOffhandWeapon())
+        missChance += 19;
+
+    // Calculate hit chance
+    float hitChance = 100.0f;
+
+    // Spellmod from SPELLMOD_RESIST_MISS_CHANCE
+    if (spellId)
+    {
+        if (Player* modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellId, SPELLMOD_RESIST_MISS_CHANCE, hitChance);
+    }
+
+    missChance += hitChance - 100.0f;
+
+    if (attType == RANGED_ATTACK)
+        missChance -= m_modRangedHitChance;
+    else
+        missChance -= m_modMeleeHitChance;
+
+    // Limit miss chance from 0 to 60%
+    if (missChance < 0.0f)
+        return 0.0f;
+    if (missChance > 100.0f)
+        return 100.0f;
+    return missChance;
+}
+
+void Unit::SetPhaseMask(uint32 newPhaseMask, bool update)
+{
+    if (newPhaseMask == GetPhaseMask())
+        return;
+
+    // terrain swap, load another map for creature movement generation
+    if (GetTypeId() == TYPEID_UNIT)
+    {
+        PhaseDefinitionStore::const_iterator itr = _PhaseDefinitionStore->find(GetZoneId());
+        PhaseDefinitionContainer::const_iterator phase;
+        if (itr != _PhaseDefinitionStore->end())
+            for (phase = itr->second.begin(); phase != itr->second.end(); ++phase) // if creature is spawn in different phase
+            {
+                if (newPhaseMask & phase->phasemask && phase->terrainswapmap && GetMapId() == phase->originmap)
+                    if ((_baseSwapMap = sMapMgr->FindBaseMap(phase->terrainswapmap)) == NULL)
+                    {
+                        sMapMgr->CreateBaseMap(phase->terrainswapmap);
+                        if ((_baseSwapMap = sMapMgr->FindBaseMap(phase->terrainswapmap)) == NULL)
+                            sLog->outError(LOG_FILTER_MAPS, "Map id '%u': does not exist!", phase->terrainswapmap);
+                    }
+            }
+    }
+
+    if (IsInWorld())
+    {
+        RemoveNotOwnSingleTargetAuras(newPhaseMask);            // we can lost access to caster or target
+
+        // modify hostile references for new phasemask, some special cases deal with hostile references themselves
+        if (GetTypeId() == TYPEID_UNIT || (!ToPlayer()->isGameMaster() && !ToPlayer()->GetSession()->PlayerLogout()))
+        {
+            HostileRefManager& refManager = getHostileRefManager();
+            HostileReference* ref = refManager.getFirst();
+
+            while (ref)
+            {
+                if (Unit* unit = ref->getSource()->getOwner())
+                    if (Creature* creature = unit->ToCreature())
+                        refManager.setOnlineOfflineState(creature, creature->InSamePhase(newPhaseMask));
+
+                ref = ref->next();
+            }
+
+            // modify threat lists for new phasemask
+            if (GetTypeId() != TYPEID_PLAYER)
+            {
+                std::list<HostileReference*> threatList = getThreatManager().getThreatList();
+                std::list<HostileReference*> offlineThreatList = getThreatManager().getOfflineThreatList();
+
+                // merge expects sorted lists
+                threatList.sort();
+                offlineThreatList.sort();
+                threatList.merge(offlineThreatList);
+
+                for (std::list<HostileReference*>::const_iterator itr = threatList.begin(); itr != threatList.end(); ++itr)
+                    if (Unit* unit = (*itr)->getTarget())
+                        unit->getHostileRefManager().setOnlineOfflineState(ToCreature(), unit->InSamePhase(newPhaseMask));
+            }
+        }
+    }
+
+    WorldObject::SetPhaseMask(newPhaseMask, update);
+
+    if (!IsInWorld())
+        return;
+
+    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        if ((*itr)->GetTypeId() == TYPEID_UNIT)
+            (*itr)->SetPhaseMask(newPhaseMask, true);
+
+    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
+        if (m_SummonSlot[i])
+            if (Creature* summon = GetMap()->GetCreature(m_SummonSlot[i]))
+                summon->SetPhaseMask(newPhaseMask, true);
+}
+
+void Unit::UpdateObjectVisibility(bool forced)
+{
+    if (!forced)
+        AddToNotify(NOTIFY_VISIBILITY_CHANGED);
+    else
+    {
+        WorldObject::UpdateObjectVisibility(true);
+        // call MoveInLineOfSight for nearby creatures
+        Trinity::AIRelocationNotifier notifier(*this);
+        VisitNearbyObject(GetVisibilityRange(), notifier);
+    }
+}
+
+void Unit::SendMoveKnockBack(Player* player, float speedXY, float speedZ, float vcos, float vsin)
+{
+    ObjectGuid guid = GetGUID();
+    WorldPacket data(SMSG_MOVE_KNOCK_BACK, (1+8+4+4+4+4+4));
+    data.WriteBit(guid[0]);
+    data.WriteBit(guid[3]);
+    data.WriteBit(guid[6]);
+    data.WriteBit(guid[7]);
+    data.WriteBit(guid[2]);
+    data.WriteBit(guid[5]);
+    data.WriteBit(guid[1]);
+    data.WriteBit(guid[4]);
+
+    data.WriteByteSeq(guid[1]);
+
+    data << float(vsin);
+    data << uint32(0);
+
+    data.WriteByteSeq(guid[6]);
+    data.WriteByteSeq(guid[7]);
+
+    data << float(speedXY);
+
+    data.WriteByteSeq(guid[4]);
+    data.WriteByteSeq(guid[5]);
+    data.WriteByteSeq(guid[3]);
+
+    data << float(speedZ);
+    data << float(vcos);
+
+    data.WriteByteSeq(guid[2]);
+    data.WriteByteSeq(guid[0]);
+
+    player->GetSession()->SendPacket(&data);
+}
+
+void Unit::KnockbackFrom(float x, float y, float speedXY, float speedZ)
+{
+    Player* player = NULL;
+    if (GetTypeId() == TYPEID_PLAYER)
+        player = ToPlayer();
+    else if (Unit* charmer = GetCharmer())
+    {
+        player = charmer->ToPlayer();
+        if (player && player->m_mover != this)
+            player = NULL;
+    }
+
+    if (!player)
+        GetMotionMaster()->MoveKnockbackFrom(x, y, speedXY, speedZ);
+    else
+    {
+        float vcos, vsin;
+        GetSinCos(x, y, vsin, vcos);
+        SendMoveKnockBack(player, speedXY, -speedZ, vcos, vsin);
+    }
+}
+
+float Unit::GetCombatRatingReduction(CombatRating cr) const
+{
+    if (Player const* player = ToPlayer())
+        return player->GetRatingBonusValue(cr);
+    // Player's pet get resilience from owner
+    else if (isPet() && GetOwner())
+        if (Player* owner = GetOwner()->ToPlayer())
+            return owner->GetRatingBonusValue(cr);
+
+    return 0.0f;
+}
+
+uint32 Unit::GetCombatRatingDamageReduction(CombatRating cr, float rate, float cap, uint32 damage) const
+{
+    float percent = std::min(GetCombatRatingReduction(cr) * rate, cap);
+    return CalculatePct(damage, percent);
+}
+
+uint32 Unit::GetModelForForm(ShapeshiftForm form) const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on Hair color
+                if (getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                else if (getRace() == RACE_TROLL)
+                {
+                    uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Red
+                        case 1:
+                            return 33668;
+                        case 2: // Yellow
+                        case 3:
+                            return 33667;
+                        case 4: // Blue
+                        case 5:
+                        case 6:
+                            return 33666;
+                        case 7: // Purple
+                        case 10:
+                            return 33665;
+                        default: // original - white
+                            return 33669;
+                    }
+                }
+                else if (getRace() == RACE_WORGEN)
+                {
+                    // Based on Skin color
+                    uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 1: // Brown
+                                return 33662;
+                            case 2: // Black
+                            case 7:
+                                return 33661;
+                            case 4: // yellow
+                                return 33664;
+                            case 3: // White
+                            case 5:
+                                return 33663;
+                            default: // original - Gray
+                                return 33660;
+                        }
+                    }
+                    // Female
+                    else
+                    {
+                        switch (skinColor)
+                        {
+                            case 5: // Brown
+                            case 6:
+                                return 33662;
+                            case 7: // Black
+                            case 8:
+                                return 33661;
+                            case 3: // yellow
+                            case 4:
+                                return 33664;
+                            case 2: // White
+                                return 33663;
+                            default: // original - Gray
+                                return 33660;
+                        }
+                    }
+                }
+                // Based on Skin color
+                else if (getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female
+                    else
+                    {
+                        switch (skinColor)
+                        {
+                            case 10: // White
+                                return 29409;
+                            case 6: // Light Brown
+                            case 7:
+                                return 29410;
+                            case 4: // Brown
+                            case 5:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                }
+                else if (Player::TeamForRace(getRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_BEAR:
+                // Based on Hair color
+                if (getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                else if (getRace() == RACE_TROLL)
+                {
+                    uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Red
+                        case 1:
+                            return 33657;
+                        case 2: // Yellow
+                        case 3:
+                            return 33659;
+                        case 7: // Purple
+                        case 10:
+                            return 33656;
+                        case 8: // White
+                        case 9:
+                        case 11:
+                        case 12:
+                            return 33658;
+                        default: // original - Blue
+                            return 33655;
+                    }
+                }
+                else if (getRace() == RACE_WORGEN)
+                {
+                    // Based on Skin color
+                    uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 1: // Brown
+                                return 33652;
+                            case 2: // Black
+                            case 7:
+                                return 33651;
+                            case 4: // Yellow
+                                return 33653;
+                            case 3: // White
+                            case 5:
+                                return 33654;
+                            default: // original - Gray
+                                return 33650;
+                        }
+                    }
+                    // Female
+                    else
+                    {
+                        switch (skinColor)
+                        {
+                            case 5: // Brown
+                            case 6:
+                                return 33652;
+                            case 7: // Black
+                            case 8:
+                                return 33651;
+                            case 3: // yellow
+                            case 4:
+                                return 33654;
+                            case 2: // White
+                                return 33653;
+                            default: // original - Gray
+                                return 33650;
+                        }
+                    }
+                }
+                // Based on Skin color
+                else if (getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                                return 29418;
+                            case 2: // White
+                            case 3:
+                                return 29419;
+                            case 6: // Light Brown/Grey
+                            case 7:
+                            case 8:
+                            case 9:
+                                return 29420;
+                            case 10: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                }
+                else if (Player::TeamForRace(getRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_MOONKIN:
+            {
+                switch (getRace())
+                {
+                    case RACE_TROLL:
+                        return 37174;
+                    case RACE_TAUREN:
+                        return 15375;
+                    case RACE_NIGHTELF:
+                        return 15374;
+                    case RACE_WORGEN:
+                        return 37173;
+                    default:
+                        return 0;
+                }
+            }
+            case FORM_TREE:
+            {
+                if(HasAura(95212)) // Druid - Glyph Treant
+                    return 18922;
+
+                switch (getRace())
+                {
+                    case RACE_TROLL:
+                        return 37166;
+                    case RACE_TAUREN:
+                        return 37163;
+                    case RACE_NIGHTELF:
+                        return 37165;
+                    case RACE_WORGEN:
+                        return 37164;
+                    default:
+                        return 0;
+                }
+            }
+			case FORM_FLIGHT:
+            {
+                switch (getRace())
+                {
+                    case RACE_NIGHTELF:
+                        return 20857;
+                    case RACE_WORGEN:
+                        return 37727;
+                    case RACE_TROLL:
+                        return 37728;
+                    case RACE_TAUREN:
+                        return 21244;
+                    default:
+                        return 0;
+                }
+            }
+			case FORM_FLIGHT_EPIC:
+			
+				switch (getRace())
+				{
+					case RACE_NIGHTELF:
+						return 21243;
+					case RACE_WORGEN:
+						return 37729;
+					case RACE_TROLL:
+						return 37730;
+					case RACE_TAUREN:
+						return 21244;
+					default:
+						return 0;
+				}
+            case FORM_GHOSTWOLF:
+                if(HasAura(58135)) // Glyph: Arctic Wolf
+                return 27312;
+            default:
+                break;
+        }
+    }
+
+    uint32 modelid = 0;
+    SpellShapeshiftFormEntry const* formEntry = sSpellShapeshiftFormStore.LookupEntry(form);
+    if (formEntry && formEntry->modelID_A)
+    {
+        // Take the alliance modelid as default
+        if (GetTypeId() != TYPEID_PLAYER)
+            return formEntry->modelID_A;
+        else
+        {
+            if (Player::TeamForRace(getRace()) == ALLIANCE)
+                modelid = formEntry->modelID_A;
+            else
+                modelid = formEntry->modelID_H;
+
+            // If the player is horde but there are no values for the horde modelid - take the alliance modelid
+            if (!modelid && Player::TeamForRace(getRace()) == HORDE)
+                modelid = formEntry->modelID_A;
+        }
+    }
+
+    return modelid;
+}
+
+uint32 Unit::GetModelForTotem(PlayerTotemType totemType)
+{
+    switch (getRace())
+    {
+        case RACE_ORC:
+        {
+            switch (totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    // fire
+                    return 30758;
+                case SUMMON_TYPE_TOTEM_EARTH:   // earth
+                    return 30757;
+                case SUMMON_TYPE_TOTEM_WATER:   // water
+                    return 30759;
+                case SUMMON_TYPE_TOTEM_AIR:     // air
+                    return 30756;
+            }
+            break;
+        }
+        case RACE_DWARF:
+        {
+            switch (totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    // fire
+                    return 30754;
+                case SUMMON_TYPE_TOTEM_EARTH:   // earth
+                    return 30753;
+                case SUMMON_TYPE_TOTEM_WATER:   // water
+                    return 30755;
+                case SUMMON_TYPE_TOTEM_AIR:     // air
+                    return 30736;
+            }
+            break;
+        }
+        case RACE_TROLL:
+        {
+            switch (totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    // fire
+                    return 30762;
+                case SUMMON_TYPE_TOTEM_EARTH:   // earth
+                    return 30761;
+                case SUMMON_TYPE_TOTEM_WATER:   // water
+                    return 30763;
+                case SUMMON_TYPE_TOTEM_AIR:     // air
+                    return 30760;
+            }
+            break;
+        }
+        case RACE_TAUREN:
+        {
+            switch (totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    // fire
+                    return 4589;
+                case SUMMON_TYPE_TOTEM_EARTH:   // earth
+                    return 4588;
+                case SUMMON_TYPE_TOTEM_WATER:   // water
+                    return 4587;
+                case SUMMON_TYPE_TOTEM_AIR:     // air
+                    return 4590;
+            }
+            break;
+        }
+        case RACE_DRAENEI:
+        {
+            switch (totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    // fire
+                    return 19074;
+                case SUMMON_TYPE_TOTEM_EARTH:   // earth
+                    return 19073;
+                case SUMMON_TYPE_TOTEM_WATER:   // water
+                    return 19075;
+                case SUMMON_TYPE_TOTEM_AIR:     // air
+                    return 19071;
+            }
+            break;
+        }
+        case RACE_GOBLIN:
+        {
+            switch (totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    // fire
+                    return 30783;
+                case SUMMON_TYPE_TOTEM_EARTH:   // earth
+                    return 30782;
+                case SUMMON_TYPE_TOTEM_WATER:   // water
+                    return 30784;
+                case SUMMON_TYPE_TOTEM_AIR:     // air
+                    return 30781;
+            }
+            break;
+        }
+    }
+    return 0;
+}
+
+void Unit::JumpTo(float speedXY, float speedZ, bool forward)
+{
+    float angle = forward ? 0 : M_PI;
+    if (GetTypeId() == TYPEID_UNIT)
+        GetMotionMaster()->MoveJumpTo(angle, speedXY, speedZ);
+    else
+    {
+        float vcos = std::cos(angle+GetOrientation());
+        float vsin = std::sin(angle+GetOrientation());
+        SendMoveKnockBack(ToPlayer(), speedXY, -speedZ, vcos, vsin);
+    }
+}
+
+void Unit::JumpTo(WorldObject* obj, float speedZ)
+{
+    float x, y, z;
+    obj->GetContactPoint(this, x, y, z);
+    float speedXY = GetExactDist2d(x, y) * 10.0f / speedZ;
+    GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
+}
+
+bool Unit::HandleSpellClick(Unit* clicker, int8 seatId)
+{
+    bool result = false;
+    uint32 spellClickEntry = GetVehicleKit() ? GetVehicleKit()->GetCreatureEntry() : GetEntry();
+    SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(spellClickEntry);
+    for (SpellClickInfoContainer::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)
+    {
+        //! First check simple relations from clicker to clickee
+        if (!itr->second.IsFitToRequirements(clicker, this))
+            continue;
+
+        //! Check database conditions
+        ConditionList conds = sConditionMgr->GetConditionsForSpellClickEvent(spellClickEntry, itr->second.spellId);
+        ConditionSourceInfo info = ConditionSourceInfo(clicker, this);
+        if (!sConditionMgr->IsObjectMeetToConditions(info, conds))
+            continue;
+
+        Unit* caster = (itr->second.castFlags & NPC_CLICK_CAST_CASTER_CLICKER) ? clicker : this;
+        Unit* target = (itr->second.castFlags & NPC_CLICK_CAST_TARGET_CLICKER) ? clicker : this;
+        uint64 origCasterGUID = (itr->second.castFlags & NPC_CLICK_CAST_ORIG_CASTER_OWNER) ? GetOwnerGUID() : clicker->GetGUID();
+
+        SpellInfo const* spellEntry = sSpellMgr->GetSpellInfo(itr->second.spellId);
+        // if (!spellEntry) should be checked at npc_spellclick load
+
+        if (seatId > -1)
+        {
+            uint8 i = 0;
+            bool valid = false;
+            while (i < MAX_SPELL_EFFECTS && !valid)
+            {
+                if (spellEntry->Effects[i].ApplyAuraName == SPELL_AURA_CONTROL_VEHICLE)
+                {
+                    valid = true;
+                    break;
+                }
+                ++i;
+            }
+
+            if (!valid)
+            {
+                sLog->outError(LOG_FILTER_SQL, "Spell %u specified in npc_spellclick_spells is not a valid vehicle enter aura!", itr->second.spellId);
+                continue;
+            }
+
+            if (IsInMap(caster))
+                caster->CastCustomSpell(itr->second.spellId, SpellValueMod(SPELLVALUE_BASE_POINT0+i), seatId + 1, target, GetVehicleKit() ? TRIGGERED_IGNORE_CASTER_MOUNTED_OR_ON_VEHICLE : TRIGGERED_NONE, NULL, NULL, origCasterGUID);
+            else    // This can happen during Player::_LoadAuras
+            {
+                int32 bp0[MAX_SPELL_EFFECTS];
+                for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+                    bp0[j] = spellEntry->Effects[j].BasePoints;
+
+                bp0[i] = seatId;
+                Aura::TryRefreshStackOrCreate(spellEntry, MAX_EFFECT_MASK, this, clicker, bp0, NULL, origCasterGUID);
+            }
+        }
+        else
+        {
+            if (IsInMap(caster))
+                caster->CastSpell(target, spellEntry, GetVehicleKit() ? TRIGGERED_IGNORE_CASTER_MOUNTED_OR_ON_VEHICLE : TRIGGERED_NONE, NULL, NULL, origCasterGUID);
+            else
+                Aura::TryRefreshStackOrCreate(spellEntry, MAX_EFFECT_MASK, this, clicker, NULL, NULL, origCasterGUID);
+        }
+
+        result = true;
+    }
+
+    if (result)
+    {
+        Creature* creature = ToCreature();
+        if (creature && creature->IsAIEnabled)
+            creature->AI()->OnSpellClick(clicker);
+    }
+
+    return result;
+}
+
+void Unit::EnterVehicle(Unit* base, int8 seatId)
+{
+    CastCustomSpell(VEHICLE_SPELL_RIDE_HARDCODED, SPELLVALUE_BASE_POINT0, seatId + 1, base, TRIGGERED_IGNORE_CASTER_MOUNTED_OR_ON_VEHICLE);
+}
+
+void Unit::Rio_EnterVehicle(Vehicle* vehicle, int8 seatId)
+{
+    if (m_vehicle)
+    {
+        if (m_vehicle == vehicle)
+        {
+            if (seatId >= 0 && seatId != GetTransSeat())
+            {
+                ChangeSeat(seatId);
+            }
+            return;
+        }
+        else
+        {
+            ExitVehicle();
+        }
+    }
+
+    ASSERT(!m_vehicle);
+    m_vehicle = vehicle;
+    if (!m_vehicle->AddPassenger(this, seatId))
+    {
+        m_vehicle = NULL;
+        return;
+    }
+}
+
+void Unit::_EnterVehicle(Vehicle* vehicle, int8 seatId, AuraApplication const* aurApp)
+{
+    // Must be called only from aura handler
+    if (!isAlive() || GetVehicleKit() == vehicle || vehicle->GetBase()->IsOnVehicle(this))
+        return;
+
+    if (m_vehicle)
+    {
+        if (m_vehicle == vehicle)
+        {
+            if (seatId >= 0 && seatId != GetTransSeat())
+            {
+                sLog->outDebug(LOG_FILTER_VEHICLES, "EnterVehicle: %u leave vehicle %u seat %d and enter %d.", GetEntry(), m_vehicle->GetBase()->GetEntry(), GetTransSeat(), seatId);
+                ChangeSeat(seatId);
+            }
+
+            return;
+        }
+        else
+        {
+            sLog->outDebug(LOG_FILTER_VEHICLES, "EnterVehicle: %u exit %u and enter %u.", GetEntry(), m_vehicle->GetBase()->GetEntry(), vehicle->GetBase()->GetEntry());
+            ExitVehicle();
+        }
+    }
+
+    if (aurApp && aurApp->GetRemoveMode())
+        return;
+
+    if (Player* player = ToPlayer())
+    {
+        if (vehicle->GetBase()->GetTypeId() == TYPEID_PLAYER && player->isInCombat())
+        {
+            vehicle->GetBase()->RemoveAura(const_cast<AuraApplication*>(aurApp));
+            return;
+        }
+    }
+
+    ASSERT(!m_vehicle);
+    (void)vehicle->AddPassenger(this, seatId);
+}
+
+void Unit::ChangeSeat(int8 seatId, bool next)
+{
+    if (!m_vehicle)
+        return;
+
+    // Don't change if current and new seat are identical
+    if (seatId == GetTransSeat())
+        return;
+
+    SeatMap::const_iterator seat = (seatId < 0 ? m_vehicle->GetNextEmptySeat(GetTransSeat(), next) : m_vehicle->Seats.find(seatId));
+    // The second part of the check will only return true if seatId >= 0. @Vehicle::GetNextEmptySeat makes sure of that.
+    if (seat == m_vehicle->Seats.end() || seat->second.Passenger)
+        return;
+
+    // Todo: the functions below could be consolidated and refactored to take
+    // SeatMap::const_iterator as parameter, to save redundant map lookups.
+    m_vehicle->RemovePassenger(this);
+
+    // Set m_vehicle to NULL before adding passenger as adding new passengers is handled asynchronously
+    // and someone may call ExitVehicle again before passenger is added to new seat
+    Vehicle* veh = m_vehicle;
+    m_vehicle = NULL;
+    if (!veh->AddPassenger(this, seatId))
+        ASSERT(false);
+}
+
+void Unit::ExitVehicle(Position const* /*exitPosition*/)
+{
+    //! This function can be called at upper level code to initialize an exit from the passenger's side.
+    if (!m_vehicle)
+        return;
+
+    GetVehicleBase()->RemoveAurasByType(SPELL_AURA_CONTROL_VEHICLE, GetGUID());
+    //! The following call would not even be executed successfully as the
+    //! SPELL_AURA_CONTROL_VEHICLE unapply handler already calls _ExitVehicle without
+    //! specifying an exitposition. The subsequent call below would return on if (!m_vehicle).
+    /*_ExitVehicle(exitPosition);*/
+    //! To do:
+    //! We need to allow SPELL_AURA_CONTROL_VEHICLE unapply handlers in spellscripts
+    //! to specify exit coordinates and either store those per passenger, or we need to
+    //! init spline movement based on those coordinates in unapply handlers, and
+    //! relocate exiting passengers based on Unit::moveSpline data. Either way,
+    //! Coming Soon(TM)
+}
+
+void Unit::_ExitVehicle(Position const* exitPosition)
+{
+    /// It's possible m_vehicle is NULL, when this function is called indirectly from @VehicleJoinEvent::Abort.
+    /// In that case it was not possible to add the passenger to the vehicle. The vehicle aura has already been removed
+    /// from the target in the aforementioned function and we don't need to do anything else at this point.
+    if (!m_vehicle)
+        return;
+
+    m_vehicle->RemovePassenger(this);
+
+    Player* player = ToPlayer();
+
+    // If player is on mouted duel and exits the mount should immediatly lose the duel
+    if (player && player->duel && player->duel->isMounted)
+        player->DuelComplete(DUEL_FLED);
+
+    // This should be done before dismiss, because there may be some aura removal
+    Vehicle* vehicle = m_vehicle;
+    m_vehicle = NULL;
+
+    SetControlled(false, UNIT_STATE_ROOT);      // SMSG_MOVE_FORCE_UNROOT, ~MOVEMENTFLAG_ROOT
+
+    Position pos;
+    if (!exitPosition)                          // Exit position not specified
+        vehicle->GetBase()->GetPosition(&pos);  // This should use passenger's current position, leaving it as it is now
+                                                // because we calculate positions incorrect (sometimes under map)
+    else
+        pos = *exitPosition;
+
+    AddUnitState(UNIT_STATE_MOVE);
+
+    if (player)
+        player->SetFallInformation(0, GetPositionZ());
+    else if (HasUnitMovementFlag(MOVEMENTFLAG_ROOT))
+    {
+        WorldPacket data(SMSG_SPLINE_MOVE_UNROOT, 8);
+        data.append(GetPackGUID());
+        SendMessageToSet(&data, false);
+    }
+
+    float height = pos.GetPositionZ();
+
+    Movement::MoveSplineInit init(this);
+    // Creatures without inhabit type air should begin falling after exiting the vehicle
+    if (GetTypeId() == TYPEID_UNIT && !CanFly() && height > GetMap()->GetWaterOrGroundLevel(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), &height) + 0.1f)
+        init.SetFall();
+
+    init.MoveTo(pos.GetPositionX(), pos.GetPositionY(), height, false);
+    init.SetFacing(GetOrientation());
+    init.SetTransportExit();
+    init.Launch();
+
+    if (player)
+        player->ResummonPetTemporaryUnSummonedIfAny();
+
+    if (vehicle->GetBase()->HasUnitTypeMask(UNIT_MASK_MINION) && vehicle->GetBase()->GetTypeId() == TYPEID_UNIT)
+        if (((Minion*)vehicle->GetBase())->GetOwner() == this)
+            vehicle->GetBase()->ToCreature()->DespawnOrUnsummon();
+
+    if (HasUnitTypeMask(UNIT_MASK_ACCESSORY))
+    {
+        // Vehicle just died, we die too
+        if (vehicle->GetBase()->getDeathState() == JUST_DIED)
+            setDeathState(JUST_DIED);
+        // If for other reason we as minion are exiting the vehicle (ejected, master dismounted) - unsummon
+        else if (isSummon() && ToTempSummon())
+            ToTempSummon()->DisappearAndDie();
+    }
+}
+
+void Unit::BuildMovementPacket(ByteBuffer *data) const
+{
+    *data << uint32(GetUnitMovementFlags());            // movement flags
+    *data << uint16(GetExtraUnitMovementFlags());       // 2.3.0
+    *data << uint32(getMSTime());                       // time / counter
+    *data << GetPositionX();
+    *data << GetPositionY();
+    *data << GetPositionZMinusOffset();
+    *data << GetOrientation();
+
+    bool onTransport = m_movementInfo.t_guid != 0;
+    bool hasInterpolatedMovement = m_movementInfo.flags2 & MOVEMENTFLAG2_INTERPOLATED_MOVEMENT;
+    bool time3 = false;
+    bool swimming = ((GetUnitMovementFlags() & (MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_FLYING))
+        || (m_movementInfo.flags2 & MOVEMENTFLAG2_ALWAYS_ALLOW_PITCHING));
+    bool interPolatedTurning = m_movementInfo.flags2 & MOVEMENTFLAG2_INTERPOLATED_TURNING;
+    bool jumping = GetUnitMovementFlags() & MOVEMENTFLAG_FALLING;
+    bool splineElevation = GetUnitMovementFlags() & MOVEMENTFLAG_SPLINE_ELEVATION;
+    bool splineData = false;
+
+    data->WriteBits(GetUnitMovementFlags(), 30);
+    data->WriteBits(m_movementInfo.flags2, 12);
+    data->WriteBit(onTransport);
+    if (onTransport)
+    {
+        data->WriteBit(hasInterpolatedMovement);
+        data->WriteBit(time3);
+    }
+
+    data->WriteBit(swimming);
+    data->WriteBit(interPolatedTurning);
+    if (interPolatedTurning)
+        data->WriteBit(jumping);
+
+    data->WriteBit(splineElevation);
+    data->WriteBit(splineData);
+
+    data->FlushBits(); // reset bit stream
+
+    *data << uint64(GetGUID());
+    *data << uint32(getMSTime());
+    *data << float(GetPositionX());
+    *data << float(GetPositionY());
+    *data << float(GetPositionZ());
+    *data << float(GetOrientation());
+
+    if (onTransport)
+    {
+        if (m_vehicle)
+            *data << uint64(m_vehicle->GetBase()->GetGUID());
+        else if (GetTransport())
+            *data << uint64(GetTransport()->GetGUID());
+        else // probably should never happen
+            *data << (uint64)0;
+
+        *data << float (GetTransOffsetX());
+        *data << float (GetTransOffsetY());
+        *data << float (GetTransOffsetZ());
+        *data << float (GetTransOffsetO());
+        *data << uint8 (GetTransSeat());
+        *data << uint32(GetTransTime());
+        if (hasInterpolatedMovement)
+            *data << int32(0); // Transport Time 2
+        if (time3)
+            *data << int32(0); // Transport Time 3
+    }
+
+    if (swimming)
+        *data << (float)m_movementInfo.pitch;
+
+    if (interPolatedTurning)
+    {
+        *data << (uint32)m_movementInfo.fallTime;
+        *data << (float)m_movementInfo.j_zspeed;
+        if (jumping)
+        {
+            *data << (float)m_movementInfo.j_sinAngle;
+            *data << (float)m_movementInfo.j_cosAngle;
+            *data << (float)m_movementInfo.j_xyspeed;
+        }
+    }
+
+    if (splineElevation)
+        *data << (float)m_movementInfo.splineElevation;
+}
+
+void Unit::SetCanFly(bool apply)
+{
+    if (apply)
+        AddUnitMovementFlag(MOVEMENTFLAG_CAN_FLY);
+    else
+        RemoveUnitMovementFlag(MOVEMENTFLAG_CAN_FLY);
+}
+
+void Unit::NearTeleportTo(float x, float y, float z, float orientation, bool casting /*= false*/)
+{
+    DisableSpline();
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->TeleportTo(GetMapId(), x, y, z, orientation, TELE_TO_NOT_LEAVE_TRANSPORT | TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET | (casting ? TELE_TO_SPELL : 0));
+    else
+    {
+        Position pos = {x, y, z, orientation};
+        SendTeleportPacket(pos);
+        UpdatePosition(x, y, z, orientation, true);
+        UpdateObjectVisibility();
+    }
+}
+
+void Unit::NearTeleportTo(Position position, bool casting /*= false*/)
+{
+    NearTeleportTo(position.GetPositionX(), position.GetPositionY(), position.GetPositionZ(), position.GetOrientation(), casting);
+}
+
+void Unit::WriteMovementInfo(WorldPacket& data, Movement::ExtraMovementStatusElement* extras /*= NULL*/)
+{
+	MovementInfo const& mi = m_movementInfo;
+
+	bool hasMovementFlags = GetUnitMovementFlags() != 0;
+	bool hasMovementFlags2 = GetExtraUnitMovementFlags() != 0;
+	bool hasTimestamp = true;
+	bool hasOrientation = !G3D::fuzzyEq(GetOrientation(), 0.0f);
+	bool hasTransportData = GetTransGUID() != 0;
+	bool hasSpline = IsSplineEnabled();
+
+	bool hasTransportTime2 = hasTransportData && m_movementInfo.t_time2 != 0;
+	bool hasTransportTime3 = false;
+	bool hasPitch = HasUnitMovementFlag(MovementFlags(MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_FLYING)) || HasExtraUnitMovementFlag(MOVEMENTFLAG2_ALWAYS_ALLOW_PITCHING);
+	bool hasFallDirection = HasUnitMovementFlag(MOVEMENTFLAG_FALLING);
+	bool hasFallData = hasFallDirection || m_movementInfo.fallTime != 0;
+	bool hasSplineElevation = HasUnitMovementFlag(MOVEMENTFLAG_SPLINE_ELEVATION);
+
+	MovementStatusElements const* sequence = GetMovementStatusElementsSequence(data.GetOpcode());
+	if (!sequence)
+	{
+		sLog->outError(LOG_FILTER_NETWORKIO, "Unit::WriteMovementInfo: No movement sequence found for opcode %s", GetOpcodeNameForLogging(data.GetOpcode()).c_str());
+		return;
+	}
+
+	ObjectGuid guid = GetGUID();
+	ObjectGuid tguid = hasTransportData ? GetTransGUID() : 0;
+
+	for (; *sequence != MSEEnd; ++sequence)
+	{
+		MovementStatusElements const& element = *sequence;
+
+		switch (element)
+		{
+		case MSEHasGuidByte0:
+		case MSEHasGuidByte1:
+		case MSEHasGuidByte2:
+		case MSEHasGuidByte3:
+		case MSEHasGuidByte4:
+		case MSEHasGuidByte5:
+		case MSEHasGuidByte6:
+		case MSEHasGuidByte7:
+			data.WriteBit(guid[element - MSEHasGuidByte0]);
+			break;
+		case MSEHasTransportGuidByte0:
+		case MSEHasTransportGuidByte1:
+		case MSEHasTransportGuidByte2:
+		case MSEHasTransportGuidByte3:
+		case MSEHasTransportGuidByte4:
+		case MSEHasTransportGuidByte5:
+		case MSEHasTransportGuidByte6:
+		case MSEHasTransportGuidByte7:
+			if (hasTransportData)
+				data.WriteBit(tguid[element - MSEHasTransportGuidByte0]);
+			break;
+		case MSEGuidByte0:
+		case MSEGuidByte1:
+		case MSEGuidByte2:
+		case MSEGuidByte3:
+		case MSEGuidByte4:
+		case MSEGuidByte5:
+		case MSEGuidByte6:
+		case MSEGuidByte7:
+			data.WriteByteSeq(guid[element - MSEGuidByte0]);
+			break;
+		case MSETransportGuidByte0:
+		case MSETransportGuidByte1:
+		case MSETransportGuidByte2:
+		case MSETransportGuidByte3:
+		case MSETransportGuidByte4:
+		case MSETransportGuidByte5:
+		case MSETransportGuidByte6:
+		case MSETransportGuidByte7:
+			if (hasTransportData)
+				data.WriteByteSeq(tguid[element - MSETransportGuidByte0]);
+			break;
+		case MSEHasMovementFlags:
+			data.WriteBit(!hasMovementFlags);
+			break;
+		case MSEHasMovementFlags2:
+			data.WriteBit(!hasMovementFlags2);
+			break;
+		case MSEHasTimestamp:
+			data.WriteBit(!hasTimestamp);
+			break;
+		case MSEHasOrientation:
+			data.WriteBit(!hasOrientation);
+			break;
+		case MSEHasTransportData:
+			data.WriteBit(hasTransportData);
+			break;
+		case MSEHasTransportTime2:
+			if (hasTransportData)
+				data.WriteBit(hasTransportTime2);
+			break;
+		case MSEHasTransportTime3:
+			if (hasTransportData)
+				data.WriteBit(hasTransportTime3);
+			break;
+		case MSEHasPitch:
+			data.WriteBit(!hasPitch);
+			break;
+		case MSEHasFallData:
+			data.WriteBit(hasFallData);
+			break;
+		case MSEHasFallDirection:
+			if (hasFallData)
+				data.WriteBit(hasFallDirection);
+			break;
+		case MSEHasSplineElevation:
+			data.WriteBit(!hasSplineElevation);
+			break;
+		case MSEHasSpline:
+			data.WriteBit(hasSpline);
+			break;
+		case MSEMovementFlags:
+			if (hasMovementFlags)
+				data.WriteBits(GetUnitMovementFlags(), 30);
+			break;
+		case MSEMovementFlags2:
+			if (hasMovementFlags2)
+				data.WriteBits(GetExtraUnitMovementFlags(), 12);
+			break;
+		case MSETimestamp:
+			if (hasTimestamp)
+				data << getMSTime();
+			break;
+		case MSEPositionX:
+			data << GetPositionX();
+			break;
+		case MSEPositionY:
+			data << GetPositionY();
+			break;
+		case MSEPositionZ:
+			data << GetPositionZ();
+			break;
+		case MSEOrientation:
+			if (hasOrientation)
+				data << GetOrientation();
+			break;
+		case MSETransportPositionX:
+			if (hasTransportData)
+				data << GetTransOffsetX();
+			break;
+		case MSETransportPositionY:
+			if (hasTransportData)
+				data << GetTransOffsetY();
+			break;
+		case MSETransportPositionZ:
+			if (hasTransportData)
+				data << GetTransOffsetZ();
+			break;
+		case MSETransportOrientation:
+			if (hasTransportData)
+				data << GetTransOffsetO();
+			break;
+		case MSETransportSeat:
+			if (hasTransportData)
+				data << GetTransSeat();
+			break;
+		case MSETransportTime:
+			if (hasTransportData)
+				data << GetTransTime();
+			break;
+		case MSETransportTime2:
+			if (hasTransportData && hasTransportTime2)
+				data << mi.t_time2;
+			break;
+		case MSETransportTime3:
+			if (hasTransportData && hasTransportTime3)
+				data << mi.t_time3;
+			break;
+		case MSEPitch:
+			if (hasPitch)
+				data << mi.pitch;
+			break;
+		case MSEFallTime:
+			if (hasFallData)
+				data << mi.fallTime;
+			break;
+		case MSEFallVerticalSpeed:
+			if (hasFallData)
+				data << mi.j_zspeed;
+			break;
+		case MSEFallCosAngle:
+			if (hasFallData && hasFallDirection)
+				data << mi.j_cosAngle;
+			break;
+		case MSEFallSinAngle:
+			if (hasFallData && hasFallDirection)
+				data << mi.j_sinAngle;
+			break;
+		case MSEFallHorizontalSpeed:
+			if (hasFallData && hasFallDirection)
+				data << mi.j_xyspeed;
+			break;
+		case MSESplineElevation:
+			if (hasSplineElevation)
+				data << mi.splineElevation;
+			break;
+		case MSECounter:
+			data << m_movementCounter++;
+			break;
+		case MSEZeroBit:
+			data.WriteBit(0);
+			break;
+		case MSEOneBit:
+			data.WriteBit(1);
+			break;
+		/*case MSEExtraElement:
+			extras->WriteNextElement(data);
+			break;
+		default:
+			ASSERT(Movement::PrintInvalidSequenceElement(element, __FUNCTION__));
+			break;*/
+		}
+	}
+}
+
+void Unit::SendTeleportPacket(Position& pos)
+{
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer())
+        ToPlayer()->m_movement_ack[ACK_TELEPORT] = m_movementCounter;
+
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.ackCount = m_movementCounter++;
+    info.guid = GetGUID();
+    info.pos.Relocate(pos);
+
+    /* TODO: Find the good opcode for unit */
+    Movement::PacketSender(this, SMSG_MOVE_UPDATE_TELEPORT, SMSG_MOVE_TELEPORT, &info).Send();
+}
+
+bool Unit::UpdatePosition(float x, float y, float z, float orientation, bool teleport)
+{
+    // prevent crash when a bad coord is sent by the client
+    if (!Trinity::IsValidMapCoord(x, y, z, orientation))
+    {
+        sLog->outDebug(LOG_FILTER_UNITS, "Unit::UpdatePosition(%f, %f, %f) .. bad coordinates!", x, y, z);
+        return false;
+    }
+
+    bool turn = (GetOrientation() != orientation);
+    bool relocated = (teleport || GetPositionX() != x || GetPositionY() != y || GetPositionZ() != z);
+
+    if (turn)
+        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TURNING);
+
+    if (relocated)
+    {
+        SetUInt32Value(UNIT_NPC_EMOTESTATE, 0);
+        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOVE);
+
+        // move and update visible state if need
+        if (GetTypeId() == TYPEID_PLAYER)
+            GetMap()->PlayerRelocation(ToPlayer(), x, y, z, orientation);
+        else
+            GetMap()->CreatureRelocation(ToCreature(), x, y, z, orientation);
+    }
+    else if (turn)
+        UpdateOrientation(orientation);
+
+    // code block for underwater state update
+    UpdateUnderwaterState(GetMap(), x, y, z);
+
+    return (relocated || turn);
+}
+
+//! Only server-side orientation update, does not broadcast to client
+void Unit::UpdateOrientation(float orientation)
+{
+    SetOrientation(orientation);
+    if (IsVehicle())
+        GetVehicleKit()->RelocatePassengers();
+}
+
+//! Only server-side height update, does not broadcast to client
+void Unit::UpdateHeight(float newZ)
+{
+    Relocate(GetPositionX(), GetPositionY(), newZ);
+    if (IsVehicle())
+        GetVehicleKit()->RelocatePassengers();
+}
+
+void Unit::SendThreatListUpdate()
+{
+    if (!getThreatManager().isThreatListEmpty())
+    {
+        uint32 count = getThreatManager().getThreatList().size();
+
+        sLog->outDebug(LOG_FILTER_UNITS, "WORLD: Send SMSG_THREAT_UPDATE Message");
+        WorldPacket data(SMSG_THREAT_UPDATE, 8 + count * 8);
+        data.append(GetPackGUID());
+        data << uint32(count);
+        ThreatContainer::StorageType const &tlist = getThreatManager().getThreatList();
+        for (ThreatContainer::StorageType::const_iterator itr = tlist.begin(); itr != tlist.end(); ++itr)
+        {
+            data.appendPackGUID((*itr)->getUnitGuid());
+            data << uint32((*itr)->getThreat()*100);
+        }
+        SendMessageToSet(&data, false);
+    }
+}
+
+void Unit::SendChangeCurrentVictimOpcode(HostileReference* pHostileReference)
+{
+    if (!getThreatManager().isThreatListEmpty())
+    {
+        uint32 count = getThreatManager().getThreatList().size();
+
+        sLog->outDebug(LOG_FILTER_UNITS, "WORLD: Send SMSG_HIGHEST_THREAT_UPDATE Message");
+        WorldPacket data(SMSG_HIGHEST_THREAT_UPDATE, 8 + 8 + count * 8);
+        data.append(GetPackGUID());
+        data.appendPackGUID(pHostileReference->getUnitGuid());
+        data << uint32(count);
+        ThreatContainer::StorageType const &tlist = getThreatManager().getThreatList();
+        for (ThreatContainer::StorageType::const_iterator itr = tlist.begin(); itr != tlist.end(); ++itr)
+        {
+            data.appendPackGUID((*itr)->getUnitGuid());
+            data << uint32((*itr)->getThreat());
+        }
+        SendMessageToSet(&data, false);
+    }
+}
+
+void Unit::SendClearThreatListOpcode()
+{
+    sLog->outDebug(LOG_FILTER_UNITS, "WORLD: Send SMSG_THREAT_CLEAR Message");
+    WorldPacket data(SMSG_THREAT_CLEAR, 8);
+    data.append(GetPackGUID());
+    SendMessageToSet(&data, false);
+}
+
+void Unit::SendRemoveFromThreatListOpcode(HostileReference* pHostileReference)
+{
+    sLog->outDebug(LOG_FILTER_UNITS, "WORLD: Send SMSG_THREAT_REMOVE Message");
+    WorldPacket data(SMSG_THREAT_REMOVE, 8 + 8);
+    data.append(GetPackGUID());
+    data.appendPackGUID(pHostileReference->getUnitGuid());
+    SendMessageToSet(&data, false);
+}
+
+// baseRage means damage taken when attacker = false
+void Unit::RewardRage(uint32 baseRage, bool attacker)
+{
+    float addRage;
+
+    if (attacker)
+    {
+        addRage = baseRage;
+        // talent who gave more rage on attack
+        AddPct(addRage, GetTotalAuraModifier(SPELL_AURA_MOD_RAGE_FROM_DAMAGE_DEALT));
+    }
+    else
+    {
+        // Calculate rage from health and damage taken
+        //! ToDo: Check formula
+        addRage = floor(0.5f + (18.92f * baseRage / GetMaxHealth()));
+        if (addRage < 1.0f)
+            addRage = 1.0f;
+        // Berserker Rage effect
+        if (HasAura(18499))
+            addRage *= 2.0f;
+    }
+
+    addRage *= sWorld->getRate(RATE_POWER_RAGE_INCOME);
+
+    ModifyPower(POWER_RAGE, uint32(addRage * 10));
+}
+
+void Unit::StopAttackFaction(uint32 faction_id)
+{
+    if (Unit* victim = GetVictim())
+    {
+        if (victim->getFactionTemplateEntry()->faction == faction_id)
+        {
+            AttackStop();
+            if (IsNonMeleeSpellCasted(false))
+                InterruptNonMeleeSpells(false);
+
+            // melee and ranged forced attack cancel
+            if (GetTypeId() == TYPEID_PLAYER)
+                ToPlayer()->SendAttackSwingCancelAttack();
+        }
+    }
+
+    AttackerSet const& attackers = getAttackers();
+    for (AttackerSet::const_iterator itr = attackers.begin(); itr != attackers.end();)
+    {
+        if ((*itr)->getFactionTemplateEntry()->faction == faction_id)
+        {
+            (*itr)->AttackStop();
+            itr = attackers.begin();
+        }
+        else
+            ++itr;
+    }
+
+    getHostileRefManager().deleteReferencesForFaction(faction_id);
+
+    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+            (*itr)->StopAttackFaction(faction_id);
+}
+
+void Unit::OutDebugInfo() const
+{
+    sLog->outError(LOG_FILTER_UNITS, "Unit::OutDebugInfo");
+    sLog->outInfo(LOG_FILTER_UNITS, "GUID "UI64FMTD", entry %u, type %u, name %s", GetGUID(), GetEntry(), (uint32)GetTypeId(), GetName().c_str());
+    sLog->outInfo(LOG_FILTER_UNITS, "OwnerGUID "UI64FMTD", MinionGUID "UI64FMTD", CharmerGUID "UI64FMTD", CharmedGUID "UI64FMTD, GetOwnerGUID(), GetMinionGUID(), GetCharmerGUID(), GetCharmGUID());
+    sLog->outInfo(LOG_FILTER_UNITS, "In world %u, unit type mask %u", (uint32)(IsInWorld() ? 1 : 0), m_unitTypeMask);
+    if (IsInWorld())
+        sLog->outInfo(LOG_FILTER_UNITS, "Mapid %u", GetMapId());
+
+    std::ostringstream o;
+    o << "Summon Slot: ";
+    for (uint32 i = 0; i < MAX_SUMMON_SLOT; ++i)
+        o << m_SummonSlot[i] << ", ";
+
+    sLog->outInfo(LOG_FILTER_UNITS, "%s", o.str().c_str());
+    o.str("");
+
+    o << "Controlled List: ";
+    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        o << (*itr)->GetGUID() << ", ";
+    sLog->outInfo(LOG_FILTER_UNITS, "%s", o.str().c_str());
+    o.str("");
+
+    o << "Aura List: ";
+    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.begin(); itr != m_appliedAuras.end(); ++itr)
+        o << itr->first << ", ";
+    sLog->outInfo(LOG_FILTER_UNITS, "%s", o.str().c_str());
+    o.str("");
+
+    if (IsVehicle())
+    {
+        o << "Passenger List: ";
+        for (SeatMap::iterator itr = GetVehicleKit()->Seats.begin(); itr != GetVehicleKit()->Seats.end(); ++itr)
+            if (Unit* passenger = ObjectAccessor::GetUnit(*GetVehicleBase(), itr->second.Passenger))
+                o << passenger->GetGUID() << ", ";
+        sLog->outInfo(LOG_FILTER_UNITS, "%s", o.str().c_str());
+    }
+
+    if (GetVehicle())
+        sLog->outInfo(LOG_FILTER_UNITS, "On vehicle %u.", GetVehicleBase()->GetEntry());
+}
+
+uint32 Unit::GetRemainingPeriodicAmount(uint64 caster, uint32 spellId, AuraType auraType, uint8 effectIndex) const
+{
+    uint32 amount = 0;
+    AuraEffectList const& periodicAuras = GetAuraEffectsByType(auraType);
+    for (AuraEffectList::const_iterator i = periodicAuras.begin(); i != periodicAuras.end(); ++i)
+    {
+        if ((*i)->GetCasterGUID() != caster || (*i)->GetId() != spellId || (*i)->GetEffIndex() != effectIndex || !(*i)->GetTotalTicks())
+            continue;
+        amount += uint32(((*i)->GetAmount() * std::max<int32>((*i)->GetTotalTicks() - int32((*i)->GetTickNumber()), 0)) / (*i)->GetTotalTicks());
+        break;
+    }
+
+    return amount;
+}
+
+void Unit::SendClearTarget()
+{
+    WorldPacket data(SMSG_BREAK_TARGET, GetPackGUID().size());
+    data.append(GetPackGUID());
+    SendMessageToSet(&data, false);
+}
+
+uint32 Unit::GetResistance(SpellSchoolMask mask) const
+{
+    int32 resist = -1;
+    for (int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; ++i)
+        if (mask & (1 << i) && (resist < 0 || resist > int32(GetResistance(SpellSchools(i)))))
+            resist = int32(GetResistance(SpellSchools(i)));
+
+    // resist value will never be negative here
+    return uint32(resist);
+}
+
+void CharmInfo::SetIsCommandAttack(bool val)
+{
+    _isCommandAttack = val;
+}
+
+bool CharmInfo::IsCommandAttack()
+{
+    return _isCommandAttack;
+}
+
+void CharmInfo::SetIsCommandFollow(bool val)
+{
+    _isCommandFollow = val;
+}
+
+bool CharmInfo::IsCommandFollow()
+{
+    return _isCommandFollow;
+}
+
+void CharmInfo::SaveStayPosition()
+{
+    //! At this point a new spline destination is enabled because of Unit::StopMoving()
+    G3D::Vector3 const stayPos = _unit->movespline->FinalDestination();
+    _stayX = stayPos.x;
+    _stayY = stayPos.y;
+    _stayZ = stayPos.z;
+}
+
+void CharmInfo::GetStayPosition(float &x, float &y, float &z)
+{
+    x = _stayX;
+    y = _stayY;
+    z = _stayZ;
+}
+
+void CharmInfo::SetIsAtStay(bool val)
+{
+    _isAtStay = val;
+}
+
+bool CharmInfo::IsAtStay()
+{
+    return _isAtStay;
+}
+
+void CharmInfo::SetIsFollowing(bool val)
+{
+    _isFollowing = val;
+}
+
+bool CharmInfo::IsFollowing()
+{
+    return _isFollowing;
+}
+
+void CharmInfo::SetIsReturning(bool val)
+{
+    _isReturning = val;
+}
+
+bool CharmInfo::IsReturning()
+{
+    return _isReturning;
+}
+
+void CharmInfo::SetIsMovingForCast(bool val)
+{
+    _isMovingForCast = val;
+}
+
+bool CharmInfo::IsMovingForCast()
+{
+    return _isMovingForCast;
+}
+
+void Unit::SetInFront(Unit const* target)
+{
+    if (!HasUnitState(UNIT_STATE_CANNOT_TURN))
+        SetOrientation(GetAngle(target));
+}
+
+void Unit::SetFacingTo(float ori)
+{
+    Movement::MoveSplineInit init(this);
+    init.MoveTo(GetPositionX(), GetPositionY(), GetPositionZMinusOffset(), false);
+    init.SetFacing(ori);
+    init.Launch();
+}
+
+void Unit::SetFacingToObject(WorldObject* object)
+{
+    // never face when already moving
+    if (!IsStopped())
+        return;
+
+    // TODO: figure out under what conditions creature will move towards object instead of facing it where it currently is.
+    SetFacingTo(GetAngle(object));
+}
+
+bool Unit::SetWalk(bool enable)
+{
+    if (enable == IsWalking())
+        return false;
+
+    if (enable)
+        AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
+    else
+        RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
+
+    return true;
+}
+
+bool Unit::SetDisableGravity(bool disable, bool /*packetOnly = false*/)
+{
+    if (disable == IsLevitating())
+        return false;
+
+    if (disable)
+        AddUnitMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY);
+    else
+        RemoveUnitMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY);
+
+    return true;
+}
+
+bool Unit::SetHover(bool enable)
+{
+    if (enable == HasUnitMovementFlag(MOVEMENTFLAG_HOVER))
+        return false;
+
+    if (enable)
+    {
+        //! No need to check height on ascent
+        AddUnitMovementFlag(MOVEMENTFLAG_HOVER);
+        if (float hh = GetFloatValue(UNIT_FIELD_HOVERHEIGHT))
+            UpdateHeight(GetPositionZ() + hh);
+    }
+    else
+    {
+        RemoveUnitMovementFlag(MOVEMENTFLAG_HOVER);
+        if (float hh = GetFloatValue(UNIT_FIELD_HOVERHEIGHT))
+        {
+            float newZ = GetPositionZ() - hh;
+            UpdateAllowedPositionZ(GetPositionX(), GetPositionY(), newZ);
+            UpdateHeight(newZ);
+        }
+    }
+
+    return true;
+}
+
+void Unit::SendMovementHover()
+{
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer())
+        ToPlayer()->m_movement_ack[ACK_HOVER] = m_movementCounter;
+
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.ackCount = m_movementCounter++;
+    info.guid = GetGUID();
+
+    if (HasUnitMovementFlag(MOVEMENTFLAG_HOVER))
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_SET_HOVER, SMSG_MOVE_SET_HOVER, &info).Send();
+    else
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_UNSET_HOVER, SMSG_MOVE_UNSET_HOVER, &info).Send();
+}
+
+void Unit::SendMovementWaterWalking()
+{
+   if (GetTypeId() == TYPEID_PLAYER && ToPlayer())
+        ToPlayer()->m_movement_ack[ACK_WATER_WALK] = m_movementCounter;
+
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.ackCount = m_movementCounter++;
+    info.guid = GetGUID();
+
+    if (HasUnitMovementFlag(MOVEMENTFLAG_WATERWALKING))
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_SET_WATER_WALK, SMSG_MOVE_WATER_WALK, &info).Send();
+    else
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_SET_LAND_WALK, SMSG_MOVE_LAND_WALK, &info).Send();
+}
+
+void Unit::SendMovementFeatherFall()
+{
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer())
+        ToPlayer()->m_movement_ack[ACK_FEATHER_FALL] = m_movementCounter;
+
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.ackCount = m_movementCounter++;
+    info.guid = GetGUID();
+
+    if (HasUnitMovementFlag(MOVEMENTFLAG_FALLING_SLOW))
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_SET_FEATHER_FALL, SMSG_MOVE_FEATHER_FALL, &info).Send();
+    else
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_SET_NORMAL_FALL, SMSG_MOVE_NORMAL_FALL, &info).Send();
+}
+
+void Unit::SendMovementDisableGravity()
+{
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer())
+        ToPlayer()->m_movement_ack[ACK_GRAVITY] = m_movementCounter;
+
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.ackCount = m_movementCounter++;
+    info.guid = GetGUID();
+
+    if (HasUnitMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY))
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_GRAVITY_DISABLE, SMSG_MOVE_GRAVITY_DISABLE, &info).Send();
+    else
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_GRAVITY_ENABLE, SMSG_MOVE_GRAVITY_ENABLE, &info).Send();
+}
+
+void Unit::SendMovementSwimming()
+{
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.guid = GetGUID();
+
+    if (HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_START_SWIM, SMSG_MOVE_START_SWIM, &info, true).Send();
+    else
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_STOP_SWIM, SMSG_MOVE_STOP_SWIM, &info, true).Send();
+}
+
+void Unit::SendMovementWalkMode()
+{
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.guid = GetGUID();
+
+    if (HasUnitMovementFlag(MOVEMENTFLAG_WALKING))
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_SET_WALK_MODE, SMSG_MOVE_SET_WALK_MODE, &info, true).Send();
+    else
+        Movement::PacketSender(this, SMSG_SPLINE_MOVE_SET_RUN_MODE, SMSG_MOVE_SET_RUN_MODE, &info, true).Send();
+}
+
+void Unit::SendMovementCanFlyChange()
+{
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer())
+        ToPlayer()->m_movement_ack[ACK_CAN_FLY] = m_movementCounter;
+
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.ackCount = m_movementCounter++;
+    info.guid = GetGUID();
+
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer())
+    {
+        Opcodes opcode = SMSG_MOVE_UNSET_CAN_FLY;
+        if (HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY))
+            opcode = SMSG_MOVE_SET_CAN_FLY;
+
+        WorldPacket data(opcode);
+        info.WriteToPacket(data);
+        ToPlayer()->SendDirectMessage(&data);
+    }
+    else
+    {
+        Opcodes opcode = SMSG_SPLINE_MOVE_UNSET_FLYING;
+        if (HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY))
+            opcode = SMSG_SPLINE_MOVE_SET_FLYING;
+
+        WorldPacket data(opcode);
+        info.WriteToPacket(data);
+        SendMessageToSet(&data, false);
+    }
+}
+
+bool Unit::IsSplineEnabled() const
+{
+    return movespline->Initialized();
+}
+
+uint32 Unit::GetSplineId() const
+{
+    return movespline->GetId();
+}
+
+void Unit::FocusTarget(Spell const* focusSpell, uint64 target)
+{
+    // already focused
+    if (_focusSpell)
+        return;
+
+    _focusSpell = focusSpell;
+    SetUInt64Value(UNIT_FIELD_TARGET, target);
+    if (focusSpell->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_DONT_TURN_DURING_CAST)
+        AddUnitState(UNIT_STATE_ROTATING);
+}
+
+void Unit::ReleaseFocus(Spell const* focusSpell)
+{
+    // focused to something else
+    if (focusSpell != _focusSpell)
+        return;
+
+    _focusSpell = NULL;
+    if (Unit* victim = GetVictim())
+        SetUInt64Value(UNIT_FIELD_TARGET, victim->GetGUID());
+    else
+        SetUInt64Value(UNIT_FIELD_TARGET, 0);
+
+    if (focusSpell->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_DONT_TURN_DURING_CAST)
+        ClearUnitState(UNIT_STATE_ROTATING);
+}
+
+bool Unit::IsVisionObscured(Unit* pVictim)
+{
+	Aura* victimAura = NULL;
+	Aura* myAura = NULL;
+	Unit* victimCaster = NULL;
+	Unit* myCaster = NULL;
+	AuraEffectList const& vAuras = pVictim->GetAuraEffectsByType(SPELL_AURA_INTERFERE_TARGETTING);
+	for (AuraEffectList::const_iterator i = vAuras.begin(); i != vAuras.end(); ++i)
+	{
+		victimAura = (*i)->GetBase();
+		victimCaster = victimAura->GetCaster();
+		break;
+	}
+	AuraEffectList const& myAuras = GetAuraEffectsByType(SPELL_AURA_INTERFERE_TARGETTING);
+	for (AuraEffectList::const_iterator i = myAuras.begin(); i != myAuras.end(); ++i)
+	{
+		myAura = (*i)->GetBase();
+		myCaster = myAura->GetCaster();
+		break;
+	}
+	if ((myAura != NULL && myCaster == NULL) || (victimAura != NULL && victimCaster == NULL))
+		return false; // Failed auras, will result in crash
+	// E.G. Victim is in smoke bomb, and I'm not
+	// Spells fail unless I'm friendly to the caster of victim's smoke bomb
+	if (victimAura != NULL && myAura == NULL)
+	{
+		if (IsFriendlyTo(victimCaster))
+			return false;
+		else
+			return true;
+	}
+	// Victim is not in smoke bomb, while I am
+	// Spells fail if my smoke bomb aura's caster is my enemy
+	else if (myAura != NULL && victimAura == NULL)
+	{
+		if (IsFriendlyTo(myCaster))
+			return false;
+		else
+			return true;
+	}
+	return false;
+}
+
+void Unit::UpdateRowCasts(uint32 spellId)
+{
+    uint8 times = 0;
+    rowCastsMap::const_iterator itr = _spellsCastedInRow.find(spellId);
+    if (itr != _spellsCastedInRow.end())
+        times = _spellsCastedInRow[spellId];
+
+    _spellsCastedInRow.clear();
+    _spellsCastedInRow[spellId] = times + 1;
+}
+
+void Unit::AddSpellCooldown(uint32 spellid, uint32 itemid, time_t end_time)
+{
+    SpellCooldown sc;
+    sc.end = end_time;
+    sc.itemid = itemid;
+    m_spellCooldowns[spellid] = sc;
+}
+
+void Unit::AddSpellAndCategoryCooldowns(SpellInfo const* spellInfo, uint32 itemId, Spell* spell, bool infinityCooldown)
+{
+    // init cooldown values
+    uint32 cat   = 0;
+    int32 rec    = -1;
+    int32 catrec = -1;
+
+    // some special item spells without correct cooldown in SpellInfo
+    // cooldown information stored in item prototype
+    // This used in same way in WorldSession::HandleItemQuerySingleOpcode data sending to client.
+
+    if (itemId)
+    {
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            for (uint8 idx = 0; idx < MAX_ITEM_SPELLS; ++idx)
+            {
+                if (uint32(proto->Spells[idx].SpellId) == spellInfo->Id)
+                {
+                    cat    = proto->Spells[idx].SpellCategory;
+                    rec    = proto->Spells[idx].SpellCooldown;
+                    catrec = proto->Spells[idx].SpellCategoryCooldown;
+                    // Add shared on use trinket cooldown serverside
+                    if (proto->InventoryType == INVTYPE_TRINKET && proto->Spells[idx].SpellTrigger == ITEM_SPELLTRIGGER_ON_USE)
+                    {
+                        if (Player* player = ToPlayer())
+                            for (uint8 i = EQUIPMENT_SLOT_TRINKET1; i < EQUIPMENT_SLOT_BACK; ++i)
+                            {
+                                // If usable, try to cast item spell
+                                if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                                {
+                                    if (ItemTemplate const* secondProto = item->GetTemplate())
+                                    {
+                                        for (uint8 spells = 0; spells < MAX_ITEM_SPELLS; ++spells)
+                                        {
+                                            _Spell const& spellData = secondProto->Spells[spells];
+                                            if (!spellData.SpellId || spellData.SpellId == spellInfo->Id || spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_USE
+                                                || spellData.SpellCategory != cat)
+                                                continue;
+
+                                            AddSpellCooldown(spellData.SpellId, item->GetEntry(), time(NULL) + (catrec / IN_MILLISECONDS));
+                                        }
+                                    }
+                                }
+                            }
+                    }
+                    break;
+                }
+            }
+        }
+    }
+
+    // if no cooldown found above then base at DBC data
+    if (rec < 0 && catrec < 0)
+    {
+        cat = spellInfo->Category;
+        rec = spellInfo->RecoveryTime;
+        catrec = spellInfo->CategoryRecoveryTime;
+    }
+
+    time_t curTime = time(NULL);
+
+    time_t catrecTime;
+    time_t recTime;
+
+    // overwrite time for selected category
+    if (infinityCooldown)
+    {
+        // use +MONTH as infinity mark for spell cooldown (will checked as MONTH/2 at save ans skipped)
+        // but not allow ignore until reset or re-login
+        catrecTime = catrec > 0 ? curTime+infinityCooldownDelay : 0;
+        recTime    = rec    > 0 ? curTime+infinityCooldownDelay : catrecTime;
+    }
+    else
+    {
+        // shoot spells used equipped item cooldown values already assigned in GetAttackTime(RANGED_ATTACK)
+        // prevent 0 cooldowns set by another way
+        if (rec <= 0 && catrec <= 0 && (cat == 76 || (spellInfo->IsAutoRepeatRangedSpell() && spellInfo->Id != 75)))
+            rec = GetAttackTime(RANGED_ATTACK);
+
+        // Now we have cooldown data (if found any), time to apply mods
+        if (Player* modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_COOLDOWN, rec, spell);
+
+        if (!(spellInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS))
+            if (Player* modOwner = GetSpellModOwner())
+                modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_COOLDOWN, catrec, spell);
+
+        // Apply SPELL_AURA_MOD_SPELL_CATEGORY_COOLDOWN modifiers
+        // Note: This aura applies its modifiers to all cooldowns of spells with set category, not to category cooldown only
+        if (cat)
+        {
+            if (int32 categoryModifier = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SPELL_CATEGORY_COOLDOWN, cat))
+            {
+                if (rec > 0)
+                    rec += categoryModifier;
+
+                if (catrec > 0)
+                    catrec += categoryModifier;
+            }
+        }
+
+        // replace negative cooldowns by 0
+        if (rec < 0)
+            rec = 0;
+
+        if (catrec < 0)
+            catrec = 0;
+
+        // no cooldown after applying spell mods
+        if (rec == 0 && catrec == 0)
+            return;
+
+        catrecTime = catrec ? curTime+catrec/IN_MILLISECONDS : 0;
+        recTime    = rec ? curTime+rec/IN_MILLISECONDS : catrecTime;
+    }
+
+    // self spell cooldown
+    if (recTime > 0)
+        AddSpellCooldown(spellInfo->Id, itemId, recTime);
+
+    // category spells
+    if (cat && catrec > 0)
+    {
+        SpellCategoryStore::const_iterator i_scstore = sSpellCategoryStore.find(cat);
+        if (i_scstore != sSpellCategoryStore.end())
+        {
+            for (SpellCategorySet::const_iterator i_scset = i_scstore->second.begin(); i_scset != i_scstore->second.end(); ++i_scset)
+            {
+                if (*i_scset == spellInfo->Id)                    // skip main spell, already handled above
+                    continue;
+
+                AddSpellCooldown(*i_scset, itemId, catrecTime);
+            }
+        }
+    }
+}
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index 9c31e7d..88b2eb0 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -1379,8 +1379,10 @@ class Unit : public WorldObject
         uint8 getLevel() const { return uint8(GetUInt32Value(UNIT_FIELD_LEVEL)); }
         uint8 getLevelForTarget(WorldObject const* /*target*/) const { return getLevel(); }
         void SetLevel(uint8 lvl);
-        uint8 getRace() const { return GetByteValue(UNIT_FIELD_BYTES_0, 0); }
+        uint8 getRace(bool forceoriginal = false) const;
+        uint8 getORace() { return getRace(true); }
         uint32 getRaceMask() const { return 1 << (getRace()-1); }
+        uint32 getORaceMask() const { return 1 << (getRace(true) - 1); }
         uint8 getClass() const { return GetByteValue(UNIT_FIELD_BYTES_0, 1); }
         uint32 getClassMask() const { return 1 << (getClass()-1); }
         uint8 getGender() const { return GetByteValue(UNIT_FIELD_BYTES_0, 2); }
diff --git a/src/server/game/Entities/Unit/Unit.h.orig b/src/server/game/Entities/Unit/Unit.h.orig
new file mode 100644
index 0000000..9c31e7d
--- /dev/null
+++ b/src/server/game/Entities/Unit/Unit.h.orig
@@ -0,0 +1,2570 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __UNIT_H
+#define __UNIT_H
+
+#include "EventProcessor.h"
+#include "FollowerReference.h"
+#include "FollowerRefManager.h"
+#include "HostileRefManager.h"
+#include "MotionMaster.h"
+#include "Object.h"
+#include "SpellAuraDefines.h"
+#include "ThreatManager.h"
+
+
+
+#define WORLD_TRIGGER   12999
+enum SpellInterruptFlags
+{
+    SPELL_INTERRUPT_FLAG_MOVEMENT     = 0x01, // why need this for instant?
+    SPELL_INTERRUPT_FLAG_PUSH_BACK    = 0x02, // push back
+    SPELL_INTERRUPT_FLAG_UNK3         = 0x04, // any info?
+    SPELL_INTERRUPT_FLAG_INTERRUPT    = 0x08, // interrupt
+    SPELL_INTERRUPT_FLAG_ABORT_ON_DMG = 0x10  // _complete_ interrupt on direct damage
+    //SPELL_INTERRUPT_UNK             = 0x20                // unk, 564 of 727 spells having this spell start with "Glyph"
+};
+
+// See SpellAuraInterruptFlags for other values definitions
+enum SpellChannelInterruptFlags
+{
+    CHANNEL_INTERRUPT_FLAG_INTERRUPT    = 0x08,  // interrupt
+    CHANNEL_FLAG_DELAY                  = 0x4000
+};
+
+enum SpellAuraInterruptFlags
+{
+    AURA_INTERRUPT_FLAG_HITBYSPELL          = 0x00000001,   // 0    removed when getting hit by a negative spell?
+    AURA_INTERRUPT_FLAG_TAKE_DAMAGE         = 0x00000002,   // 1    removed by any damage
+    AURA_INTERRUPT_FLAG_CAST                = 0x00000004,   // 2    cast any spells
+    AURA_INTERRUPT_FLAG_MOVE                = 0x00000008,   // 3    removed by any movement
+    AURA_INTERRUPT_FLAG_TURNING             = 0x00000010,   // 4    removed by any turning
+    AURA_INTERRUPT_FLAG_JUMP                = 0x00000020,   // 5    removed by entering combat
+    AURA_INTERRUPT_FLAG_NOT_MOUNTED         = 0x00000040,   // 6    removed by dismounting
+    AURA_INTERRUPT_FLAG_NOT_ABOVEWATER      = 0x00000080,   // 7    removed by entering water
+    AURA_INTERRUPT_FLAG_NOT_UNDERWATER      = 0x00000100,   // 8    removed by leaving water
+    AURA_INTERRUPT_FLAG_NOT_SHEATHED        = 0x00000200,   // 9    removed by unsheathing
+    AURA_INTERRUPT_FLAG_TALK                = 0x00000400,   // 10   talk to npc / loot? action on creature
+    AURA_INTERRUPT_FLAG_USE                 = 0x00000800,   // 11   mine/use/open action on gameobject
+    AURA_INTERRUPT_FLAG_MELEE_ATTACK        = 0x00001000,   // 12   removed by attacking
+    AURA_INTERRUPT_FLAG_SPELL_ATTACK        = 0x00002000,   // 13   ???
+    AURA_INTERRUPT_FLAG_UNK14               = 0x00004000,   // 14
+    AURA_INTERRUPT_FLAG_TRANSFORM           = 0x00008000,   // 15   removed by transform?
+    AURA_INTERRUPT_FLAG_UNK16               = 0x00010000,   // 16
+    AURA_INTERRUPT_FLAG_MOUNT               = 0x00020000,   // 17   misdirect, aspect, swim speed
+    AURA_INTERRUPT_FLAG_NOT_SEATED          = 0x00040000,   // 18   removed by standing up (used by food and drink mostly and sleep/Fake Death like)
+    AURA_INTERRUPT_FLAG_CHANGE_MAP          = 0x00080000,   // 19   leaving map/getting teleported
+    AURA_INTERRUPT_FLAG_IMMUNE_OR_LOST_SELECTION    = 0x00100000,   // 20   removed by auras that make you invulnerable, or make other to lose selection on you
+    AURA_INTERRUPT_FLAG_UNK21               = 0x00200000,   // 21
+    AURA_INTERRUPT_FLAG_TELEPORTED          = 0x00400000,   // 22
+    AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT    = 0x00800000,   // 23   removed by entering pvp combat
+    AURA_INTERRUPT_FLAG_DIRECT_DAMAGE       = 0x01000000,   // 24   removed by any direct damage
+    AURA_INTERRUPT_FLAG_LANDING             = 0x02000000,   // 25   removed by hitting the ground
+    AURA_INTERRUPT_FLAG_UNK26               = 0x04000000,   // 26
+    AURA_INTERRUPT_FLAG_TAKE_DAMAGE2        = 0x08000000,   // 27   removed by any damage (Player auras only)
+
+    AURA_INTERRUPT_FLAG_NOT_VICTIM = (AURA_INTERRUPT_FLAG_HITBYSPELL | AURA_INTERRUPT_FLAG_TAKE_DAMAGE | AURA_INTERRUPT_FLAG_DIRECT_DAMAGE),
+    AURA_INTERRUPT_FLAG_MOVING = (AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING)
+};
+
+enum SpellModOp
+{
+    SPELLMOD_DAMAGE                 = 0,
+    SPELLMOD_DURATION               = 1,
+    SPELLMOD_THREAT                 = 2,
+    SPELLMOD_EFFECT1                = 3,
+    SPELLMOD_CHARGES                = 4,
+    SPELLMOD_RANGE                  = 5,
+    SPELLMOD_RADIUS                 = 6,
+    SPELLMOD_CRITICAL_CHANCE        = 7,
+    SPELLMOD_ALL_EFFECTS            = 8,
+    SPELLMOD_NOT_LOSE_CASTING_TIME  = 9,
+    SPELLMOD_CASTING_TIME           = 10,
+    SPELLMOD_COOLDOWN               = 11,
+    SPELLMOD_EFFECT2                = 12,
+    SPELLMOD_IGNORE_ARMOR           = 13,
+    SPELLMOD_COST                   = 14,
+    SPELLMOD_CRIT_DAMAGE_BONUS      = 15,
+    SPELLMOD_RESIST_MISS_CHANCE     = 16,
+    SPELLMOD_JUMP_TARGETS           = 17,
+    SPELLMOD_CHANCE_OF_SUCCESS      = 18,
+    SPELLMOD_ACTIVATION_TIME        = 19,
+    SPELLMOD_DAMAGE_MULTIPLIER      = 20,
+    SPELLMOD_GLOBAL_COOLDOWN        = 21,
+    SPELLMOD_DOT                    = 22,
+    SPELLMOD_EFFECT3                = 23,
+    SPELLMOD_BONUS_MULTIPLIER       = 24,
+    // spellmod 25
+    SPELLMOD_PROC_PER_MINUTE        = 26,
+    SPELLMOD_VALUE_MULTIPLIER       = 27,
+    SPELLMOD_RESIST_DISPEL_CHANCE   = 28,
+    SPELLMOD_CRIT_DAMAGE_BONUS_2    = 29, //one not used spell
+    SPELLMOD_SPELL_COST_REFUND_ON_FAIL = 30
+};
+
+#define MAX_SPELLMOD 32
+
+enum SpellValueMod
+{
+    SPELLVALUE_BASE_POINT0,
+    SPELLVALUE_BASE_POINT1,
+    SPELLVALUE_BASE_POINT2,
+    SPELLVALUE_RADIUS_MOD,
+    SPELLVALUE_MAX_TARGETS,
+    SPELLVALUE_AURA_STACK
+};
+
+typedef std::pair<SpellValueMod, int32>     CustomSpellValueMod;
+class CustomSpellValues : public std::vector<CustomSpellValueMod>
+{
+    public:
+        void AddSpellMod(SpellValueMod mod, int32 value)
+        {
+            push_back(std::make_pair(mod, value));
+        }
+};
+
+enum SpellFacingFlags
+{
+    SPELL_FACING_FLAG_INFRONT = 0x0001
+};
+
+#define BASE_MINDAMAGE 1.0f
+#define BASE_MAXDAMAGE 2.0f
+#define BASE_ATTACK_TIME 2000
+
+// byte value (UNIT_FIELD_BYTES_1, 0)
+enum UnitStandStateType
+{
+    UNIT_STAND_STATE_STAND             = 0,
+    UNIT_STAND_STATE_SIT               = 1,
+    UNIT_STAND_STATE_SIT_CHAIR         = 2,
+    UNIT_STAND_STATE_SLEEP             = 3,
+    UNIT_STAND_STATE_SIT_LOW_CHAIR     = 4,
+    UNIT_STAND_STATE_SIT_MEDIUM_CHAIR  = 5,
+    UNIT_STAND_STATE_SIT_HIGH_CHAIR    = 6,
+    UNIT_STAND_STATE_DEAD              = 7,
+    UNIT_STAND_STATE_KNEEL             = 8,
+    UNIT_STAND_STATE_SUBMERGED         = 9
+};
+
+// byte flag value (UNIT_FIELD_BYTES_1, 2)
+enum UnitStandFlags
+{
+    UNIT_STAND_FLAGS_UNK1         = 0x01,
+    UNIT_STAND_FLAGS_CREEP        = 0x02,
+    UNIT_STAND_FLAGS_UNTRACKABLE  = 0x04,
+    UNIT_STAND_FLAGS_UNK4         = 0x08,
+    UNIT_STAND_FLAGS_UNK5         = 0x10,
+    UNIT_STAND_FLAGS_ALL          = 0xFF
+};
+
+// byte flags value (UNIT_FIELD_BYTES_1, 3)
+enum UnitBytes1_Flags
+{
+    UNIT_BYTE1_FLAG_ALWAYS_STAND    = 0x01,
+    UNIT_BYTE1_FLAG_HOVER           = 0x02,
+    UNIT_BYTE1_FLAG_UNK_3           = 0x04,
+    UNIT_BYTE1_FLAG_ALL             = 0xFF
+};
+
+// high byte (3 from 0..3) of UNIT_FIELD_BYTES_2
+enum ShapeshiftForm
+{
+    FORM_NONE               = 0x00,
+    FORM_CAT                = 0x01,
+    FORM_TREE               = 0x02,
+    FORM_TRAVEL             = 0x03,
+    FORM_AQUA               = 0x04,
+    FORM_BEAR               = 0x05,
+    FORM_AMBIENT            = 0x06,
+    FORM_GHOUL              = 0x07,
+    FORM_DIREBEAR           = 0x08, // Removed in 4.0.1
+    FORM_STEVES_GHOUL       = 0x09,
+    FORM_THARONJA_SKELETON  = 0x0A,
+    FORM_TEST_OF_STRENGTH   = 0x0B,
+    FORM_BLB_PLAYER         = 0x0C,
+    FORM_SHADOW_DANCE       = 0x0D,
+    FORM_CREATUREBEAR       = 0x0E,
+    FORM_CREATURECAT        = 0x0F,
+    FORM_GHOSTWOLF          = 0x10,
+    FORM_BATTLESTANCE       = 0x11,
+    FORM_DEFENSIVESTANCE    = 0x12,
+    FORM_BERSERKERSTANCE    = 0x13,
+    FORM_TEST               = 0x14,
+    FORM_ZOMBIE             = 0x15,
+    FORM_METAMORPHOSIS      = 0x16,
+    FORM_UNDEAD             = 0x19,
+    FORM_MASTER_ANGLER      = 0x1A,
+    FORM_FLIGHT_EPIC        = 0x1B,
+    FORM_SHADOW             = 0x1C,
+    FORM_FLIGHT             = 0x1D,
+    FORM_STEALTH            = 0x1E,
+    FORM_MOONKIN            = 0x1F,
+    FORM_SPIRITOFREDEMPTION = 0x20
+};
+
+// low byte (0 from 0..3) of UNIT_FIELD_BYTES_2
+enum SheathState
+{
+    SHEATH_STATE_UNARMED  = 0,                              // non prepared weapon
+    SHEATH_STATE_MELEE    = 1,                              // prepared melee weapon
+    SHEATH_STATE_RANGED   = 2                               // prepared ranged weapon
+};
+
+#define MAX_SHEATH_STATE    3
+
+// byte (1 from 0..3) of UNIT_FIELD_BYTES_2
+enum UnitPVPStateFlags
+{
+    UNIT_BYTE2_FLAG_PVP         = 0x01,
+    UNIT_BYTE2_FLAG_UNK1        = 0x02,
+    UNIT_BYTE2_FLAG_FFA_PVP     = 0x04,
+    UNIT_BYTE2_FLAG_SANCTUARY   = 0x08,
+    UNIT_BYTE2_FLAG_UNK4        = 0x10,
+    UNIT_BYTE2_FLAG_UNK5        = 0x20,
+    UNIT_BYTE2_FLAG_UNK6        = 0x40,
+    UNIT_BYTE2_FLAG_UNK7        = 0x80
+};
+
+// byte (2 from 0..3) of UNIT_FIELD_BYTES_2
+enum UnitRename
+{
+    UNIT_CAN_BE_RENAMED     = 0x01,
+    UNIT_CAN_BE_ABANDONED   = 0x02
+};
+
+#define CREATURE_MAX_SPELLS     8
+#define MAX_SPELL_CHARM         4
+#define MAX_SPELL_VEHICLE       6
+#define MAX_SPELL_POSSESS       8
+#define MAX_SPELL_CONTROL_BAR   10
+
+#define MAX_AGGRO_RESET_TIME 10 // in seconds
+#define MAX_AGGRO_RADIUS 45.0f  // yards
+
+enum Swing
+{
+    NOSWING                    = 0,
+    SINGLEHANDEDSWING          = 1,
+    TWOHANDEDSWING             = 2
+};
+
+enum VictimState
+{
+    VICTIMSTATE_INTACT         = 0, // set when attacker misses
+    VICTIMSTATE_HIT            = 1, // victim got clear/blocked hit
+    VICTIMSTATE_DODGE          = 2,
+    VICTIMSTATE_PARRY          = 3,
+    VICTIMSTATE_INTERRUPT      = 4,
+    VICTIMSTATE_BLOCKS         = 5, // unused? not set when blocked, even on full block
+    VICTIMSTATE_EVADES         = 6,
+    VICTIMSTATE_IS_IMMUNE      = 7,
+    VICTIMSTATE_DEFLECTS       = 8
+};
+
+enum HitInfo
+{
+    HITINFO_NORMALSWING         = 0x00000000,
+    HITINFO_UNK1                = 0x00000001,               // req correct packet structure
+    HITINFO_AFFECTS_VICTIM      = 0x00000002,
+    HITINFO_OFFHAND             = 0x00000004,
+    HITINFO_UNK2                = 0x00000008,
+    HITINFO_MISS                = 0x00000010,
+    HITINFO_FULL_ABSORB         = 0x00000020,
+    HITINFO_PARTIAL_ABSORB      = 0x00000040,
+    HITINFO_FULL_RESIST         = 0x00000080,
+    HITINFO_PARTIAL_RESIST      = 0x00000100,
+    HITINFO_CRITICALHIT         = 0x00000200,               // critical hit
+    // 0x00000400
+    // 0x00000800
+    // 0x00001000
+    HITINFO_BLOCK               = 0x00002000,               // blocked damage
+    // 0x00004000                                           // Hides worldtext for 0 damage
+    // 0x00008000                                           // Related to blood visual
+    HITINFO_GLANCING            = 0x00010000,
+    HITINFO_CRUSHING            = 0x00020000,
+    HITINFO_NO_ANIMATION        = 0x00040000,
+    // 0x00080000
+    // 0x00100000
+    HITINFO_SWINGNOHITSOUND     = 0x00200000,               // unused?
+    // 0x00400000
+    HITINFO_RAGE_GAIN           = 0x00800000
+};
+
+//i would like to remove this: (it is defined in item.h
+enum InventorySlot
+{
+    NULL_BAG                   = 0,
+    NULL_SLOT                  = 255
+};
+
+struct FactionTemplateEntry;
+struct SpellValue;
+
+class AuraApplication;
+class Aura;
+class UnitAura;
+class AuraEffect;
+class Creature;
+class Spell;
+class SpellInfo;
+class DynamicObject;
+class GameObject;
+class Item;
+class Pet;
+class PetAura;
+class Minion;
+class Guardian;
+class UnitAI;
+class Totem;
+class Transport;
+class Vehicle;
+class VehicleJoinEvent;
+class TransportBase;
+class SpellCastTargets;
+namespace Movement
+{
+	class ExtraMovementStatusElement;
+	class MoveSpline;
+}
+
+typedef std::list<Unit*> UnitList;
+typedef std::list< std::pair<Aura*, uint8> > DispelChargesList;
+
+struct PhaseDefinition;
+typedef std::list<PhaseDefinition> PhaseDefinitionContainer;
+typedef UNORDERED_MAP<uint32 /*zoneId*/, PhaseDefinitionContainer> PhaseDefinitionStore;
+
+struct SpellImmune
+{
+    uint32 type;
+    uint32 spellId;
+};
+
+typedef std::list<SpellImmune> SpellImmuneList;
+
+enum UnitModifierType
+{
+    BASE_VALUE = 0,
+    BASE_PCT = 1,
+    TOTAL_VALUE = 2,
+    TOTAL_PCT = 3,
+    MODIFIER_TYPE_END = 4
+};
+
+enum WeaponDamageRange
+{
+    MINDAMAGE,
+    MAXDAMAGE
+};
+
+enum DamageTypeToSchool
+{
+    RESISTANCE,
+    DAMAGE_DEALT,
+    DAMAGE_TAKEN
+};
+
+enum AuraRemoveMode
+{
+    AURA_REMOVE_NONE = 0,
+    AURA_REMOVE_BY_DEFAULT = 1,       // scripted remove, remove by stack with aura with different ids and sc aura remove
+    AURA_REMOVE_BY_CANCEL,
+    AURA_REMOVE_BY_ENEMY_SPELL,       // dispel and absorb aura destroy
+    AURA_REMOVE_BY_EXPIRE,            // aura duration has ended
+    AURA_REMOVE_BY_DEATH,
+    AURA_REMOVE_BY_DAMAGE
+};
+
+enum TriggerCastFlags
+{
+    TRIGGERED_NONE                                  = 0x00000000,   //! Not triggered
+    TRIGGERED_IGNORE_GCD                            = 0x00000001,   //! Will ignore GCD
+    TRIGGERED_IGNORE_SPELL_AND_CATEGORY_CD          = 0x00000002,   //! Will ignore Spell and Category cooldowns
+    TRIGGERED_IGNORE_POWER_AND_REAGENT_COST         = 0x00000004,   //! Will ignore power and reagent cost
+    TRIGGERED_IGNORE_CAST_ITEM                      = 0x00000008,   //! Will not take away cast item or update related achievement criteria
+    TRIGGERED_IGNORE_AURA_SCALING                   = 0x00000010,   //! Will ignore aura scaling
+    TRIGGERED_IGNORE_CAST_IN_PROGRESS               = 0x00000020,   //! Will not check if a current cast is in progress
+    TRIGGERED_IGNORE_COMBO_POINTS                   = 0x00000040,   //! Will ignore combo point requirement
+    TRIGGERED_CAST_DIRECTLY                         = 0x00000080,   //! In Spell::prepare, will be cast directly without setting containers for executed spell
+    TRIGGERED_IGNORE_AURA_INTERRUPT_FLAGS           = 0x00000100,   //! Will ignore interruptible aura's at cast
+    TRIGGERED_IGNORE_SET_FACING                     = 0x00000200,   //! Will not adjust facing to target (if any)
+    TRIGGERED_IGNORE_SHAPESHIFT                     = 0x00000400,   //! Will ignore shapeshift checks
+    TRIGGERED_IGNORE_CASTER_AURASTATE               = 0x00000800,   //! Will ignore caster aura states including combat requirements and death state
+    TRIGGERED_IGNORE_CASTER_MOUNTED_OR_ON_VEHICLE   = 0x00002000,   //! Will ignore mounted/on vehicle restrictions
+    TRIGGERED_IGNORE_CASTER_AURAS                   = 0x00010000,   //! Will ignore caster aura restrictions or requirements
+    TRIGGERED_DISALLOW_PROC_EVENTS                  = 0x00020000,   //! Disallows proc events from triggered spell (default)
+    TRIGGERED_DONT_REPORT_CAST_ERROR                = 0x00040000,   //! Will return SPELL_FAILED_DONT_REPORT in CheckCast functions
+    TRIGGERED_IGNORE_EQUIPPED_ITEM_REQUIREMENT      = 0x00080000,   //! Will ignore equipped item requirements
+    TRIGGERED_IGNORE_AURA_INTERFERE_TARGETING       = 0x00200000,   //! Will ignore effects like smoke bomb
+    TRIGGERED_FULL_MASK                             = 0xFFFFFFFF
+};
+
+enum UnitMods
+{
+    UNIT_MOD_STAT_STRENGTH,                                 // UNIT_MOD_STAT_STRENGTH..UNIT_MOD_STAT_SPIRIT must be in existed order, it's accessed by index values of Stats enum.
+    UNIT_MOD_STAT_AGILITY,
+    UNIT_MOD_STAT_STAMINA,
+    UNIT_MOD_STAT_INTELLECT,
+    UNIT_MOD_STAT_SPIRIT,
+    UNIT_MOD_HEALTH,
+    UNIT_MOD_MANA,                                          // UNIT_MOD_MANA..UNIT_MOD_RUNIC_POWER must be in existed order, it's accessed by index values of Powers enum.
+    UNIT_MOD_RAGE,
+    UNIT_MOD_FOCUS,
+    UNIT_MOD_ENERGY,
+    UNIT_MOD_UNUSED,                                        // Old UNIT_MOD_HAPPINESS
+    UNIT_MOD_RUNE,
+    UNIT_MOD_RUNIC_POWER,
+    UNIT_MOD_SOUL_SHARDS,
+    UNIT_MOD_ECLIPSE,
+    UNIT_MOD_HOLY_POWER,
+    UNIT_MOD_ALTERNATIVE,
+    UNIT_MOD_ARMOR,                                         // UNIT_MOD_ARMOR..UNIT_MOD_RESISTANCE_ARCANE must be in existed order, it's accessed by index values of SpellSchools enum.
+    UNIT_MOD_RESISTANCE_HOLY,
+    UNIT_MOD_RESISTANCE_FIRE,
+    UNIT_MOD_RESISTANCE_NATURE,
+    UNIT_MOD_RESISTANCE_FROST,
+    UNIT_MOD_RESISTANCE_SHADOW,
+    UNIT_MOD_RESISTANCE_ARCANE,
+    UNIT_MOD_ATTACK_POWER,
+    UNIT_MOD_ATTACK_POWER_RANGED,
+    UNIT_MOD_DAMAGE_MAINHAND,
+    UNIT_MOD_DAMAGE_OFFHAND,
+    UNIT_MOD_DAMAGE_RANGED,
+    UNIT_MOD_END,
+    // synonyms
+    UNIT_MOD_STAT_START = UNIT_MOD_STAT_STRENGTH,
+    UNIT_MOD_STAT_END = UNIT_MOD_STAT_SPIRIT + 1,
+    UNIT_MOD_RESISTANCE_START = UNIT_MOD_ARMOR,
+    UNIT_MOD_RESISTANCE_END = UNIT_MOD_RESISTANCE_ARCANE + 1,
+    UNIT_MOD_POWER_START = UNIT_MOD_MANA,
+    UNIT_MOD_POWER_END = UNIT_MOD_ALTERNATIVE + 1
+};
+
+enum BaseModGroup
+{
+    CRIT_PERCENTAGE,
+    RANGED_CRIT_PERCENTAGE,
+    OFFHAND_CRIT_PERCENTAGE,
+    SHIELD_BLOCK_VALUE,
+    BASEMOD_END
+};
+
+enum BaseModType
+{
+    FLAT_MOD,
+    PCT_MOD
+};
+
+#define MOD_END (PCT_MOD+1)
+
+enum DeathState
+{
+    ALIVE          = 0,
+    JUST_DIED      = 1,
+    CORPSE         = 2,
+    DEAD           = 3,
+    JUST_RESPAWNED = 4
+};
+
+enum UnitState
+{
+    UNIT_STATE_DIED            = 0x00000001,                     // player has fake death aura
+    UNIT_STATE_MELEE_ATTACKING = 0x00000002,                     // player is melee attacking someone
+    //UNIT_STATE_MELEE_ATTACK_BY = 0x00000004,                     // player is melee attack by someone
+    UNIT_STATE_STUNNED         = 0x00000008,
+    UNIT_STATE_ROAMING         = 0x00000010,
+    UNIT_STATE_CHASE           = 0x00000020,
+    //UNIT_STATE_SEARCHING       = 0x00000040,
+    UNIT_STATE_FLEEING         = 0x00000080,
+    UNIT_STATE_IN_FLIGHT       = 0x00000100,                     // player is in flight mode
+    UNIT_STATE_FOLLOW          = 0x00000200,
+    UNIT_STATE_ROOT            = 0x00000400,
+    UNIT_STATE_CONFUSED        = 0x00000800,
+    UNIT_STATE_DISTRACTED      = 0x00001000,
+    UNIT_STATE_ISOLATED        = 0x00002000,                     // area auras do not affect other players
+    UNIT_STATE_ATTACK_PLAYER   = 0x00004000,
+    UNIT_STATE_CASTING         = 0x00008000,
+    UNIT_STATE_POSSESSED       = 0x00010000,
+    UNIT_STATE_CHARGING        = 0x00020000,
+    UNIT_STATE_JUMPING         = 0x00040000,
+    UNIT_STATE_ONVEHICLE       = 0x00080000,
+    UNIT_STATE_MOVE            = 0x00100000,
+    UNIT_STATE_ROTATING        = 0x00200000,
+    UNIT_STATE_EVADE           = 0x00400000,
+    UNIT_STATE_ROAMING_MOVE    = 0x00800000,
+    UNIT_STATE_CONFUSED_MOVE   = 0x01000000,
+    UNIT_STATE_FLEEING_MOVE    = 0x02000000,
+    UNIT_STATE_CHASE_MOVE      = 0x04000000,
+    UNIT_STATE_FOLLOW_MOVE     = 0x08000000,
+    UNIT_STATE_IGNORE_PATHFINDING = 0x10000000,                 // do not use pathfinding in any MovementGenerator
+    UNIT_STATE_IGNORE_UNATTACKABLE = 0x20000000,                // Force allow attack target with flag: UNIT_STATE_UNATTACKABLE
+    UNIT_STATE_IGNORE_LOS      = 0x40000000,
+    UNIT_STATE_UNATTACKABLE    = (UNIT_STATE_IN_FLIGHT | UNIT_STATE_ONVEHICLE),
+    // for real move using movegen check and stop (except unstoppable flight)
+    UNIT_STATE_MOVING          = UNIT_STATE_ROAMING_MOVE | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE | UNIT_STATE_CHASE_MOVE | UNIT_STATE_FOLLOW_MOVE,
+    UNIT_STATE_CONTROLLED      = (UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING),
+    UNIT_STATE_LOST_CONTROL    = (UNIT_STATE_CONTROLLED | UNIT_STATE_JUMPING | UNIT_STATE_CHARGING),
+    UNIT_STATE_SIGHTLESS       = (UNIT_STATE_LOST_CONTROL | UNIT_STATE_EVADE),
+    UNIT_STATE_CANNOT_AUTOATTACK     = (UNIT_STATE_LOST_CONTROL | UNIT_STATE_CASTING),
+    UNIT_STATE_CANNOT_TURN     = (UNIT_STATE_LOST_CONTROL | UNIT_STATE_ROTATING),
+    // stay by different reasons
+    UNIT_STATE_NOT_MOVE        = UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DIED | UNIT_STATE_DISTRACTED,
+    UNIT_STATE_CONTROLLED_BY_SERVER = (UNIT_STATE_CONFUSED | UNIT_STATE_FLEEING | UNIT_STATE_CHARGING),
+    UNIT_STATE_ALL_STATE       = 0xffffffff                      //(UNIT_STATE_STOPPED | UNIT_STATE_MOVING | UNIT_STATE_IN_COMBAT | UNIT_STATE_IN_FLIGHT)
+};
+
+enum UnitMoveType
+{
+    MOVE_WALK           = 0,
+    MOVE_RUN            = 1,
+    MOVE_RUN_BACK       = 2,
+    MOVE_SWIM           = 3,
+    MOVE_SWIM_BACK      = 4,
+    MOVE_TURN_RATE      = 5,
+    MOVE_FLIGHT         = 6,
+    MOVE_FLIGHT_BACK    = 7,
+    MOVE_PITCH_RATE     = 8
+};
+
+#define MAX_MOVE_TYPE     9
+
+extern float baseMoveSpeed[MAX_MOVE_TYPE];
+extern float playerBaseMoveSpeed[MAX_MOVE_TYPE];
+
+enum WeaponAttackType
+{
+    BASE_ATTACK   = 0,
+    OFF_ATTACK    = 1,
+    RANGED_ATTACK = 2,
+    MAX_ATTACK
+};
+
+enum CombatRating
+{
+    CR_WEAPON_SKILL                     = 0,
+    CR_DEFENSE_SKILL                    = 1, // Removed in 4.0.1
+    CR_DODGE                            = 2,
+    CR_PARRY                            = 3,
+    CR_BLOCK                            = 4,
+    CR_HIT_MELEE                        = 5,
+    CR_HIT_RANGED                       = 6,
+    CR_HIT_SPELL                        = 7,
+    CR_CRIT_MELEE                       = 8,
+    CR_CRIT_RANGED                      = 9,
+    CR_CRIT_SPELL                       = 10,
+    CR_HIT_TAKEN_MELEE                  = 11, // Deprecated since Cataclysm
+    CR_HIT_TAKEN_RANGED                 = 12, // Deprecated since Cataclysm
+    CR_HIT_TAKEN_SPELL                  = 13, // Deprecated since Cataclysm
+    CR_RESILIENCE_CRIT_TAKEN            = 14,
+    CR_RESILIENCE_PLAYER_DAMAGE_TAKEN   = 15,
+    CR_CRIT_TAKEN_SPELL                 = 16, // Deprecated since Cataclysm
+    CR_HASTE_MELEE                      = 17,
+    CR_HASTE_RANGED                     = 18,
+    CR_HASTE_SPELL                      = 19,
+    CR_WEAPON_SKILL_MAINHAND            = 20,
+    CR_WEAPON_SKILL_OFFHAND             = 21,
+    CR_WEAPON_SKILL_RANGED              = 22,
+    CR_EXPERTISE                        = 23,
+    CR_ARMOR_PENETRATION                = 24,
+    CR_MASTERY                          = 25,
+};
+
+#define MAX_COMBAT_RATING         26
+
+enum DamageEffectType
+{
+    DIRECT_DAMAGE           = 0,                            // used for normal weapon damage (not for class abilities or spells)
+    SPELL_DIRECT_DAMAGE     = 1,                            // spell/class abilities damage
+    DOT                     = 2,
+    HEAL                    = 3,
+    NODAMAGE                = 4,                            // used also in case when damage applied to health but not applied to spell channelInterruptFlags/etc
+    SELF_DAMAGE             = 5
+};
+
+// Value masks for UNIT_FIELD_FLAGS
+enum UnitFlags
+{
+    UNIT_FLAG_SERVER_CONTROLLED     = 0x00000001,           // set only when unit movement is controlled by server - by SPLINE/MONSTER_MOVE packets, together with UNIT_FLAG_STUNNED; only set to units controlled by client; client function CGUnit_C::IsClientControlled returns false when set for owner
+    UNIT_FLAG_NON_ATTACKABLE        = 0x00000002,           // not attackable
+    UNIT_FLAG_DISABLE_MOVE          = 0x00000004,
+    UNIT_FLAG_PVP_ATTACKABLE        = 0x00000008,           // allow apply pvp rules to attackable state in addition to faction dependent state
+    UNIT_FLAG_RENAME                = 0x00000010,
+    UNIT_FLAG_PREPARATION           = 0x00000020,           // don't take reagents for spells with SPELL_ATTR5_NO_REAGENT_WHILE_PREP
+    UNIT_FLAG_UNK_6                 = 0x00000040,
+    UNIT_FLAG_NOT_ATTACKABLE_1      = 0x00000080,           // ?? (UNIT_FLAG_PVP_ATTACKABLE | UNIT_FLAG_NOT_ATTACKABLE_1) is NON_PVP_ATTACKABLE
+    UNIT_FLAG_IMMUNE_TO_PC          = 0x00000100,           // disables combat/assistance with PlayerCharacters (PC) - see Unit::_IsValidAttackTarget, Unit::_IsValidAssistTarget
+    UNIT_FLAG_IMMUNE_TO_NPC         = 0x00000200,           // disables combat/assistance with NonPlayerCharacters (NPC) - see Unit::_IsValidAttackTarget, Unit::_IsValidAssistTarget
+    UNIT_FLAG_LOOTING               = 0x00000400,           // loot animation
+    UNIT_FLAG_PET_IN_COMBAT         = 0x00000800,           // in combat?, 2.0.8
+    UNIT_FLAG_PVP                   = 0x00001000,           // changed in 3.0.3
+    UNIT_FLAG_SILENCED              = 0x00002000,           // silenced, 2.1.1
+    UNIT_FLAG_UNK_14                = 0x00004000,           // 2.0.8
+    UNIT_FLAG_UNK_15                = 0x00008000,
+    UNIT_FLAG_UNK_16                = 0x00010000,
+    UNIT_FLAG_PACIFIED              = 0x00020000,           // 3.0.3 ok
+    UNIT_FLAG_STUNNED               = 0x00040000,           // 3.0.3 ok
+    UNIT_FLAG_IN_COMBAT             = 0x00080000,
+    UNIT_FLAG_TAXI_FLIGHT           = 0x00100000,           // disable casting at client side spell not allowed by taxi flight (mounted?), probably used with 0x4 flag
+    UNIT_FLAG_DISARMED              = 0x00200000,           // 3.0.3, disable melee spells casting..., "Required melee weapon" added to melee spells tooltip.
+    UNIT_FLAG_CONFUSED              = 0x00400000,
+    UNIT_FLAG_FLEEING               = 0x00800000,
+    UNIT_FLAG_PLAYER_CONTROLLED     = 0x01000000,           // used in spell Eyes of the Beast for pet... let attack by controlled creature
+    UNIT_FLAG_NOT_SELECTABLE        = 0x02000000,
+    UNIT_FLAG_SKINNABLE             = 0x04000000,
+    UNIT_FLAG_MOUNT                 = 0x08000000,
+    UNIT_FLAG_UNK_28                = 0x10000000,
+    UNIT_FLAG_UNK_29                = 0x20000000,           // used in Feing Death spell
+    UNIT_FLAG_SHEATHE               = 0x40000000,
+    UNIT_FLAG_UNK_31                = 0x80000000
+};
+
+// Value masks for UNIT_FIELD_FLAGS_2
+enum UnitFlags2
+{
+    UNIT_FLAG2_FEIGN_DEATH                  = 0x00000001,
+    UNIT_FLAG2_UNK1                         = 0x00000002,   // Hide unit model (show only player equip)
+    UNIT_FLAG2_IGNORE_REPUTATION            = 0x00000004,
+    UNIT_FLAG2_COMPREHEND_LANG              = 0x00000008,
+    UNIT_FLAG2_MIRROR_IMAGE                 = 0x00000010,
+    UNIT_FLAG2_INSTANTLY_APPEAR_MODEL       = 0x00000020,   // Unit model instantly appears when summoned (does not fade in)
+    UNIT_FLAG2_FORCE_MOVEMENT               = 0x00000040,
+    UNIT_FLAG2_DISARM_OFFHAND               = 0x00000080,
+    UNIT_FLAG2_DISABLE_PRED_STATS           = 0x00000100,   // Player has disabled predicted stats (Used by raid frames)
+    UNIT_FLAG2_DISARM_RANGED                = 0x00000400,   // this does not disable ranged weapon display (maybe additional flag needed?)
+    UNIT_FLAG2_REGENERATE_POWER             = 0x00000800,
+    UNIT_FLAG2_RESTRICT_PARTY_INTERACTION   = 0x00001000,   // Restrict interaction to party or raid
+    UNIT_FLAG2_PREVENT_SPELL_CLICK          = 0x00002000,   // Prevent spellclick
+    UNIT_FLAG2_ALLOW_ENEMY_INTERACT         = 0x00004000,
+    UNIT_FLAG2_DISABLE_TURN                 = 0x00008000,
+    UNIT_FLAG2_UNK2                         = 0x00010000,
+    UNIT_FLAG2_PLAY_DEATH_ANIM              = 0x00020000,   // Plays special death animation upon death
+    UNIT_FLAG2_ALLOW_CHEAT_SPELLS           = 0x00040000    // Allows casting spells with AttributesEx7 & SPELL_ATTR7_IS_CHEAT_SPELL
+};
+
+/// Non Player Character flags
+enum NPCFlags
+{
+    UNIT_NPC_FLAG_NONE                  = 0x00000000,
+    UNIT_NPC_FLAG_GOSSIP                = 0x00000001,       // 100%
+    UNIT_NPC_FLAG_QUESTGIVER            = 0x00000002,       // 100%
+    UNIT_NPC_FLAG_UNK1                  = 0x00000004,
+    UNIT_NPC_FLAG_UNK2                  = 0x00000008,
+    UNIT_NPC_FLAG_TRAINER               = 0x00000010,       // 100%
+    UNIT_NPC_FLAG_TRAINER_CLASS         = 0x00000020,       // 100%
+    UNIT_NPC_FLAG_TRAINER_PROFESSION    = 0x00000040,       // 100%
+    UNIT_NPC_FLAG_VENDOR                = 0x00000080,       // 100%
+    UNIT_NPC_FLAG_VENDOR_AMMO           = 0x00000100,       // 100%, general goods vendor
+    UNIT_NPC_FLAG_VENDOR_FOOD           = 0x00000200,       // 100%
+    UNIT_NPC_FLAG_VENDOR_POISON         = 0x00000400,       // guessed
+    UNIT_NPC_FLAG_VENDOR_REAGENT        = 0x00000800,       // 100%
+    UNIT_NPC_FLAG_REPAIR                = 0x00001000,       // 100%
+    UNIT_NPC_FLAG_FLIGHTMASTER          = 0x00002000,       // 100%
+    UNIT_NPC_FLAG_SPIRITHEALER          = 0x00004000,       // guessed
+    UNIT_NPC_FLAG_SPIRITGUIDE           = 0x00008000,       // guessed
+    UNIT_NPC_FLAG_INNKEEPER             = 0x00010000,       // 100%
+    UNIT_NPC_FLAG_BANKER                = 0x00020000,       // 100%
+    UNIT_NPC_FLAG_PETITIONER            = 0x00040000,       // 100% 0xC0000 = guild petitions, 0x40000 = arena team petitions
+    UNIT_NPC_FLAG_TABARDDESIGNER        = 0x00080000,       // 100%
+    UNIT_NPC_FLAG_BATTLEMASTER          = 0x00100000,       // 100%
+    UNIT_NPC_FLAG_AUCTIONEER            = 0x00200000,       // 100%
+    UNIT_NPC_FLAG_STABLEMASTER          = 0x00400000,       // 100%
+    UNIT_NPC_FLAG_GUILD_BANKER          = 0x00800000,       // cause client to send 997 opcode
+    UNIT_NPC_FLAG_SPELLCLICK            = 0x01000000,       // cause client to send 1015 opcode (spell click)
+    UNIT_NPC_FLAG_PLAYER_VEHICLE        = 0x02000000,       // players with mounts that have vehicle data should have it set
+    UNIT_NPC_FLAG_REFORGER              = 0x08000000,       // reforging
+    UNIT_NPC_FLAG_TRANSMOGRIFIER        = 0x10000000,       // transmogrification
+    UNIT_NPC_FLAG_VAULTKEEPER           = 0x20000000        // void storage
+};
+
+enum MovementFlags
+{
+    MOVEMENTFLAG_NONE                  = 0x00000000,
+    MOVEMENTFLAG_FORWARD               = 0x00000001,
+    MOVEMENTFLAG_BACKWARD              = 0x00000002,
+    MOVEMENTFLAG_STRAFE_LEFT           = 0x00000004,
+    MOVEMENTFLAG_STRAFE_RIGHT          = 0x00000008,
+    MOVEMENTFLAG_LEFT                  = 0x00000010,
+    MOVEMENTFLAG_RIGHT                 = 0x00000020,
+    MOVEMENTFLAG_PITCH_UP              = 0x00000040,
+    MOVEMENTFLAG_PITCH_DOWN            = 0x00000080,
+    MOVEMENTFLAG_WALKING               = 0x00000100,               // Walking
+    MOVEMENTFLAG_DISABLE_GRAVITY       = 0x00000200,               // Former MOVEMENTFLAG_LEVITATING. This is used when walking is not possible.
+    MOVEMENTFLAG_ROOT                  = 0x00000400,               // Must not be set along with MOVEMENTFLAG_MASK_MOVING
+    MOVEMENTFLAG_FALLING               = 0x00000800,               // damage dealt on that type of falling
+    MOVEMENTFLAG_FALLING_FAR           = 0x00001000,
+    MOVEMENTFLAG_PENDING_STOP          = 0x00002000,
+    MOVEMENTFLAG_PENDING_STRAFE_STOP   = 0x00004000,
+    MOVEMENTFLAG_PENDING_FORWARD       = 0x00008000,
+    MOVEMENTFLAG_PENDING_BACKWARD      = 0x00010000,
+    MOVEMENTFLAG_PENDING_STRAFE_LEFT   = 0x00020000,
+    MOVEMENTFLAG_PENDING_STRAFE_RIGHT  = 0x00040000,
+    MOVEMENTFLAG_PENDING_ROOT          = 0x00080000,
+    MOVEMENTFLAG_SWIMMING              = 0x00100000,               // appears with fly flag also
+    MOVEMENTFLAG_ASCENDING             = 0x00200000,               // press "space" when flying
+    MOVEMENTFLAG_DESCENDING            = 0x00400000,
+    MOVEMENTFLAG_CAN_FLY               = 0x00800000,               // Appears when unit can fly AND also walk
+    MOVEMENTFLAG_FLYING                = 0x01000000,               // unit is actually flying. pretty sure this is only used for players. creatures use disable_gravity
+    MOVEMENTFLAG_SPLINE_ELEVATION      = 0x02000000,               // used for flight paths
+    MOVEMENTFLAG_WATERWALKING          = 0x04000000,               // prevent unit from falling through water
+    MOVEMENTFLAG_FALLING_SLOW          = 0x08000000,               // active rogue safe fall spell (passive)
+    MOVEMENTFLAG_HOVER                 = 0x10000000,               // hover, cannot jump
+    MOVEMENTFLAG_DISABLE_COLLISION     = 0x20000000,
+
+    // TODO: Check if PITCH_UP and PITCH_DOWN really belong here..
+    MOVEMENTFLAG_MASK_MOVING =
+        MOVEMENTFLAG_FORWARD | MOVEMENTFLAG_BACKWARD | MOVEMENTFLAG_STRAFE_LEFT | MOVEMENTFLAG_STRAFE_RIGHT |
+        MOVEMENTFLAG_PITCH_UP | MOVEMENTFLAG_PITCH_DOWN | MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR | MOVEMENTFLAG_ASCENDING | MOVEMENTFLAG_DESCENDING |
+        MOVEMENTFLAG_SPLINE_ELEVATION,
+
+    MOVEMENTFLAG_MASK_TURNING =
+        MOVEMENTFLAG_LEFT | MOVEMENTFLAG_RIGHT,
+
+    MOVEMENTFLAG_MASK_MOVING_FLY =
+        MOVEMENTFLAG_FLYING | MOVEMENTFLAG_ASCENDING | MOVEMENTFLAG_DESCENDING,
+
+    // Movement flags allowed for creature in CreateObject - we need to keep all other enabled serverside
+    // to properly calculate all movement
+    MOVEMENTFLAG_MASK_CREATURE_ALLOWED =
+        MOVEMENTFLAG_FORWARD | MOVEMENTFLAG_DISABLE_GRAVITY | MOVEMENTFLAG_ROOT | MOVEMENTFLAG_SWIMMING |
+        MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_WATERWALKING | MOVEMENTFLAG_FALLING_SLOW | MOVEMENTFLAG_HOVER,
+
+    //! TODO if needed: add more flags to this masks that are exclusive to players
+    MOVEMENTFLAG_MASK_PLAYER_ONLY =
+        MOVEMENTFLAG_FLYING
+};
+enum MovementFlags2
+{
+    MOVEMENTFLAG2_NONE                     = 0x00000000,
+    MOVEMENTFLAG2_NO_STRAFE                = 0x00000001,
+    MOVEMENTFLAG2_NO_JUMPING               = 0x00000002,
+    MOVEMENTFLAG2_FULL_SPEED_TURNING       = 0x00000004,
+    MOVEMENTFLAG2_FULL_SPEED_PITCHING      = 0x00000008,
+    MOVEMENTFLAG2_ALWAYS_ALLOW_PITCHING    = 0x00000010,
+    MOVEMENTFLAG2_UNK7                     = 0x00000020,
+    MOVEMENTFLAG2_UNK8                     = 0x00000040,
+    MOVEMENTFLAG2_UNK9                     = 0x00000080,
+    MOVEMENTFLAG2_UNK10                    = 0x00000100,
+    MOVEMENTFLAG2_INTERPOLATED_MOVEMENT    = 0x00000200,
+    MOVEMENTFLAG2_INTERPOLATED_TURNING     = 0x00000400,
+    MOVEMENTFLAG2_INTERPOLATED_PITCHING    = 0x00000800
+};
+
+enum UnitTypeMask
+{
+    UNIT_MASK_NONE                  = 0x00000000,
+    UNIT_MASK_SUMMON                = 0x00000001,
+    UNIT_MASK_MINION                = 0x00000002,
+    UNIT_MASK_GUARDIAN              = 0x00000004,
+    UNIT_MASK_TOTEM                 = 0x00000008,
+    UNIT_MASK_PET                   = 0x00000010,
+    UNIT_MASK_VEHICLE               = 0x00000020,
+    UNIT_MASK_PUPPET                = 0x00000040,
+    UNIT_MASK_HUNTER_PET            = 0x00000080,
+    UNIT_MASK_CONTROLABLE_GUARDIAN  = 0x00000100,
+    UNIT_MASK_ACCESSORY             = 0x00000200
+};
+
+namespace Movement{
+    class MoveSpline;
+}
+
+enum DiminishingLevels
+{
+    DIMINISHING_LEVEL_1             = 0,
+    DIMINISHING_LEVEL_2             = 1,
+    DIMINISHING_LEVEL_3             = 2,
+    DIMINISHING_LEVEL_IMMUNE        = 3,
+    DIMINISHING_LEVEL_4             = 3,
+    DIMINISHING_LEVEL_TAUNT_IMMUNE  = 4
+};
+
+struct DiminishingReturn
+{
+    DiminishingReturn(DiminishingGroup group, uint32 t, uint32 count)
+        : DRGroup(group), stack(0), hitTime(t), hitCount(count)
+    {}
+
+    DiminishingGroup        DRGroup:16;
+    uint16                  stack:16;
+    uint32                  hitTime;
+    uint32                  hitCount;
+};
+
+enum MeleeHitOutcome
+{
+    MELEE_HIT_EVADE, MELEE_HIT_MISS, MELEE_HIT_DODGE, MELEE_HIT_BLOCK, MELEE_HIT_PARRY,
+    MELEE_HIT_GLANCING, MELEE_HIT_CRIT, MELEE_HIT_CRUSHING, MELEE_HIT_NORMAL
+};
+
+class DispelInfo
+{
+public:
+    explicit DispelInfo(Unit* dispeller, uint32 dispellerSpellId, uint8 chargesRemoved) :
+    _dispellerUnit(dispeller), _dispellerSpell(dispellerSpellId), _chargesRemoved(chargesRemoved) {}
+
+    Unit* GetDispeller() const { return _dispellerUnit; }
+    uint32 GetDispellerSpellId() const { return _dispellerSpell; }
+    uint8 GetRemovedCharges() const { return _chargesRemoved; }
+    void SetRemovedCharges(uint8 amount)
+    {
+        _chargesRemoved = amount;
+    }
+private:
+    Unit* _dispellerUnit;
+    uint32 _dispellerSpell;
+    uint8 _chargesRemoved;
+};
+
+struct CleanDamage
+{
+    CleanDamage(uint32 mitigated, uint32 absorbed, WeaponAttackType _attackType, MeleeHitOutcome _hitOutCome) :
+    absorbed_damage(absorbed), mitigated_damage(mitigated), attackType(_attackType), hitOutCome(_hitOutCome) {}
+
+    uint32 absorbed_damage;
+    uint32 mitigated_damage;
+
+    WeaponAttackType attackType;
+    MeleeHitOutcome hitOutCome;
+};
+
+struct CalcDamageInfo;
+
+class DamageInfo
+{
+private:
+    Unit* const m_attacker;
+    Unit* const m_victim;
+    uint32 m_damage;
+    SpellInfo const* const m_spellInfo;
+    SpellSchoolMask const m_schoolMask;
+    DamageEffectType const m_damageType;
+    WeaponAttackType m_attackType;
+    uint32 m_absorb;
+    uint32 m_resist;
+    uint32 m_block;
+public:
+    explicit DamageInfo(Unit* _attacker, Unit* _victim, uint32 _damage, SpellInfo const* _spellInfo, SpellSchoolMask _schoolMask, DamageEffectType _damageType);
+    explicit DamageInfo(CalcDamageInfo& dmgInfo);
+
+    void ModifyDamage(int32 amount);
+    void AbsorbDamage(uint32 amount);
+    void ResistDamage(uint32 amount);
+    void BlockDamage(uint32 amount);
+
+    Unit* GetAttacker() const { return m_attacker; };
+    Unit* GetVictim() const { return m_victim; };
+    SpellInfo const* GetSpellInfo() const { return m_spellInfo; };
+    SpellSchoolMask GetSchoolMask() const { return m_schoolMask; };
+    DamageEffectType GetDamageType() const { return m_damageType; };
+    WeaponAttackType GetAttackType() const { return m_attackType; };
+    uint32 GetDamage() const { return m_damage; };
+    uint32 GetAbsorb() const { return m_absorb; };
+    uint32 GetResist() const { return m_resist; };
+    uint32 GetBlock() const { return m_block; };
+};
+
+class HealInfo
+{
+private:
+    Unit* const m_healer;
+    Unit* const m_target;
+    uint32 m_heal;
+    uint32 m_absorb;
+    SpellInfo const* const m_spellInfo;
+    SpellSchoolMask const m_schoolMask;
+public:
+    explicit HealInfo(Unit* _healer, Unit* _target, uint32 _heal, SpellInfo const* _spellInfo, SpellSchoolMask _schoolMask)
+        : m_healer(_healer), m_target(_target), m_heal(_heal), m_spellInfo(_spellInfo), m_schoolMask(_schoolMask)
+    {
+        m_absorb = 0;
+    }
+    void AbsorbHeal(uint32 amount)
+    {
+        amount = std::min(amount, GetHeal());
+        m_absorb += amount;
+        m_heal -= amount;
+    }
+
+    uint32 GetHeal() const { return m_heal; };
+};
+
+class ProcEventInfo
+{
+private:
+    Unit* const _actor;
+    Unit* const _actionTarget;
+    Unit* const _procTarget;
+    SpellInfo const* const _spellInfo;
+    uint32 _typeMask;
+    uint32 _spellTypeMask;
+    uint32 _spellPhaseMask;
+    uint32 _hitMask;
+    Spell* _spell;
+    DamageInfo* _damageInfo;
+    HealInfo* _healInfo;
+public:
+    explicit ProcEventInfo(Unit* actor, Unit* actionTarget, Unit* procTarget, uint32 typeMask, uint32 spellTypeMask, uint32 spellPhaseMask, uint32 hitMask, Spell* spell, DamageInfo* damageInfo, HealInfo* healInfo, SpellInfo const* spellInfo = NULL);
+    Unit* GetActor() { return _actor; };
+    Unit* GetActionTarget() const { return _actionTarget; }
+    Unit* GetProcTarget() const { return _procTarget; }
+    uint32 GetTypeMask() const { return _typeMask; }
+    uint32 GetSpellTypeMask() const { return _spellTypeMask; }
+    uint32 GetSpellPhaseMask() const { return _spellPhaseMask; }
+    uint32 GetHitMask() const { return _hitMask; }
+    SpellInfo const* GetSpellInfo() const { return _spellInfo; }
+    SpellSchoolMask GetSchoolMask() const;
+    DamageInfo* GetDamageInfo() const { return _damageInfo; }
+    HealInfo* GetHealInfo() const { return _healInfo; }
+};
+
+// Struct for use in Unit::CalculateMeleeDamage
+// Need create structure like in SMSG_ATTACKERSTATEUPDATE opcode
+struct CalcDamageInfo
+{
+    Unit  *attacker;             // Attacker
+    Unit  *target;               // Target for damage
+    uint32 damageSchoolMask;
+    uint32 damage;
+    uint32 absorb;
+    uint32 resist;
+    uint32 blocked_amount;
+    uint32 HitInfo;
+    uint32 TargetState;
+// Helper
+    WeaponAttackType attackType; //
+    uint32 procAttacker;
+    uint32 procVictim;
+    uint32 procEx;
+    uint32 cleanDamage;          // Used only for rage calculation
+    MeleeHitOutcome hitOutCome;  // TODO: remove this field (need use TargetState)
+};
+
+// Spell damage info structure based on structure sending in SMSG_SPELLNONMELEEDAMAGELOG opcode
+struct SpellNonMeleeDamage{
+    SpellNonMeleeDamage(Unit* _attacker, Unit* _target, uint32 _SpellID, uint32 _schoolMask)
+        : target(_target), attacker(_attacker), SpellID(_SpellID), damage(0), overkill(0), schoolMask(_schoolMask),
+        absorb(0), resist(0), physicalLog(false), unused(false), blocked(0), HitInfo(0), cleanDamage(0)
+    {}
+
+    Unit   *target;
+    Unit   *attacker;
+    uint32 SpellID;
+    uint32 damage;
+    uint32 overkill;
+    uint32 schoolMask;
+    uint32 absorb;
+    uint32 resist;
+    bool   physicalLog;
+    bool   unused;
+    uint32 blocked;
+    uint32 HitInfo;
+    // Used for help
+    uint32 cleanDamage;
+};
+
+struct SpellPeriodicAuraLogInfo
+{
+    SpellPeriodicAuraLogInfo(AuraEffect const* _auraEff, uint32 _damage, uint32 _overDamage, uint32 _absorb, uint32 _resist, float _multiplier, bool _critical)
+        : auraEff(_auraEff), damage(_damage), overDamage(_overDamage), absorb(_absorb), resist(_resist), multiplier(_multiplier), critical(_critical){}
+
+    AuraEffect const* auraEff;
+    uint32 damage;
+    uint32 overDamage;                                      // overkill/overheal
+    uint32 absorb;
+    uint32 resist;
+    float  multiplier;
+    bool   critical;
+};
+
+uint32 createProcExtendMask(SpellNonMeleeDamage* damageInfo, SpellMissInfo missCondition);
+
+struct RedirectThreatInfo
+{
+    RedirectThreatInfo() : _targetGUID(0), _threatPct(0) { }
+    uint64 _targetGUID;
+    uint32 _threatPct;
+
+    uint64 GetTargetGUID() { return _targetGUID; }
+    uint32 GetThreatPct() { return _threatPct; }
+
+    void Set(uint64 guid, uint32 pct)
+    {
+        _targetGUID = guid;
+        _threatPct = pct;
+    }
+
+    void ModifyThreatPct(int32 amount)
+    {
+        amount += _threatPct;
+        _threatPct = uint32(std::max(0, amount));
+    }
+};
+
+#define MAX_DECLINED_NAME_CASES 5
+
+struct DeclinedName
+{
+    std::string name[MAX_DECLINED_NAME_CASES];
+};
+
+enum CurrentSpellTypes
+{
+    CURRENT_MELEE_SPELL             = 0,
+    CURRENT_GENERIC_SPELL           = 1,
+    CURRENT_CHANNELED_SPELL         = 2,
+    CURRENT_AUTOREPEAT_SPELL        = 3
+};
+
+#define CURRENT_FIRST_NON_MELEE_SPELL 1
+#define CURRENT_MAX_SPELL             4
+
+struct GlobalCooldown
+{
+    explicit GlobalCooldown(uint32 _dur = 0, uint32 _time = 0) : duration(_dur), cast_time(_time) {}
+
+    uint32 duration;
+    uint32 cast_time;
+};
+
+typedef UNORDERED_MAP<uint32 /*category*/, GlobalCooldown> GlobalCooldownList;
+
+class GlobalCooldownMgr                                     // Shared by Player and CharmInfo
+{
+public:
+    GlobalCooldownMgr() {}
+
+public:
+    bool HasGlobalCooldown(SpellInfo const* spellInfo) const;
+    void AddGlobalCooldown(SpellInfo const* spellInfo, uint32 gcd);
+    void CancelGlobalCooldown(SpellInfo const* spellInfo);
+
+private:
+    GlobalCooldownList m_GlobalCooldowns;
+};
+
+enum ActiveStates
+{
+    ACT_PASSIVE  = 0x01,                                    // 0x01 - passive
+    ACT_DISABLED = 0x81,                                    // 0x80 - castable
+    ACT_ENABLED  = 0xC1,                                    // 0x40 | 0x80 - auto cast + castable
+    ACT_COMMAND  = 0x07,                                    // 0x01 | 0x02 | 0x04
+    ACT_REACTION = 0x06,                                    // 0x02 | 0x04
+    ACT_DECIDE   = 0x00                                     // custom
+};
+
+enum ReactStates
+{
+    REACT_PASSIVE    = 0,
+    REACT_DEFENSIVE  = 1,
+    REACT_AGGRESSIVE = 2,
+    REACT_ASSIST     = 3
+};
+
+enum CommandStates
+{
+    COMMAND_STAY    = 0,
+    COMMAND_FOLLOW  = 1,
+    COMMAND_ATTACK  = 2,
+    COMMAND_ABANDON = 3,
+    COMMAND_MOVE_TO = 4
+};
+
+#define UNIT_ACTION_BUTTON_ACTION(X) (uint32(X) & 0x00FFFFFF)
+#define UNIT_ACTION_BUTTON_TYPE(X)   ((uint32(X) & 0xFF000000) >> 24)
+#define MAKE_UNIT_ACTION_BUTTON(A, T) (uint32(A) | (uint32(T) << 24))
+
+struct UnitActionBarEntry
+{
+    UnitActionBarEntry() : packedData(uint32(ACT_DISABLED) << 24) {}
+
+    uint32 packedData;
+
+    // helper
+    ActiveStates GetType() const { return ActiveStates(UNIT_ACTION_BUTTON_TYPE(packedData)); }
+    uint32 GetAction() const { return UNIT_ACTION_BUTTON_ACTION(packedData); }
+    bool IsActionBarForSpell() const
+    {
+        ActiveStates Type = GetType();
+        return Type == ACT_DISABLED || Type == ACT_ENABLED || Type == ACT_PASSIVE;
+    }
+
+    void SetActionAndType(uint32 action, ActiveStates type)
+    {
+        packedData = MAKE_UNIT_ACTION_BUTTON(action, type);
+    }
+
+    void SetType(ActiveStates type)
+    {
+        packedData = MAKE_UNIT_ACTION_BUTTON(UNIT_ACTION_BUTTON_ACTION(packedData), type);
+    }
+
+    void SetAction(uint32 action)
+    {
+        packedData = (packedData & 0xFF000000) | UNIT_ACTION_BUTTON_ACTION(action);
+    }
+};
+
+typedef std::list<Player*> SharedVisionList;
+
+enum CharmType
+{
+    CHARM_TYPE_CHARM,
+    CHARM_TYPE_POSSESS,
+    CHARM_TYPE_VEHICLE,
+    CHARM_TYPE_CONVERT
+};
+
+typedef UnitActionBarEntry CharmSpellInfo;
+
+enum ActionBarIndex
+{
+    ACTION_BAR_INDEX_START = 0,
+    ACTION_BAR_INDEX_PET_SPELL_START = 3,
+    ACTION_BAR_INDEX_PET_SPELL_END = 7,
+    ACTION_BAR_INDEX_END = 10
+};
+
+#define MAX_UNIT_ACTION_BAR_INDEX (ACTION_BAR_INDEX_END-ACTION_BAR_INDEX_START)
+
+struct CharmInfo
+{
+    public:
+        explicit CharmInfo(Unit* unit);
+        ~CharmInfo();
+        void RestoreState();
+        uint32 GetPetNumber() const { return _petnumber; }
+        void SetPetNumber(uint32 petnumber, bool statwindow);
+
+        void SetCommandState(CommandStates st) { _CommandState = st; }
+        CommandStates GetCommandState() const { return _CommandState; }
+        bool HasCommandState(CommandStates state) const { return (_CommandState == state); }
+
+        void InitPossessCreateSpells();
+        void InitCharmCreateSpells();
+        void InitPetActionBar();
+        void InitEmptyActionBar(bool withAttack = true);
+
+                                                            //return true if successful
+        bool AddSpellToActionBar(SpellInfo const* spellInfo, ActiveStates newstate = ACT_DECIDE);
+        bool RemoveSpellFromActionBar(uint32 spell_id);
+        void LoadPetActionBar(const std::string& data);
+        void BuildActionBar(WorldPacket* data);
+        void SetSpellAutocast(SpellInfo const* spellInfo, bool state);
+        void SetActionBar(uint8 index, uint32 spellOrAction, ActiveStates type)
+        {
+            PetActionBar[index].SetActionAndType(spellOrAction, type);
+        }
+        UnitActionBarEntry const* GetActionBarEntry(uint8 index) const { return &(PetActionBar[index]); }
+
+        void ToggleCreatureAutocast(SpellInfo const* spellInfo, bool apply);
+
+        CharmSpellInfo* GetCharmSpell(uint8 index) { return &(_charmspells[index]); }
+
+        GlobalCooldownMgr& GetGlobalCooldownMgr() { return m_GlobalCooldownMgr; }
+
+        void SetIsCommandAttack(bool val);
+        bool IsCommandAttack();
+        void SetIsCommandFollow(bool val);
+        bool IsCommandFollow();
+        void SetIsAtStay(bool val);
+        bool IsAtStay();
+        void SetIsFollowing(bool val);
+        bool IsFollowing();
+        void SetIsReturning(bool val);
+        bool IsReturning();
+        void SetIsMovingForCast(bool val);
+        bool IsMovingForCast();
+        void SaveStayPosition();
+        void GetStayPosition(float &x, float &y, float &z);
+
+    private:
+
+        Unit* _unit;
+        UnitActionBarEntry PetActionBar[MAX_UNIT_ACTION_BAR_INDEX];
+        CharmSpellInfo _charmspells[4];
+        CommandStates _CommandState;
+        uint32 _petnumber;
+        bool _barInit;
+
+        //for restoration after charmed
+        ReactStates     _oldReactState;
+
+        bool _isCommandAttack;
+        bool _isCommandFollow;
+        bool _isAtStay;
+        bool _isFollowing;
+        bool _isReturning;
+        bool _isMovingForCast;
+        float _stayX;
+        float _stayY;
+        float _stayZ;
+
+        GlobalCooldownMgr m_GlobalCooldownMgr;
+};
+
+// for clearing special attacks
+#define REACTIVE_TIMER_START 4000
+
+enum ReactiveType
+{
+    REACTIVE_DEFENSE      = 0,
+    REACTIVE_HUNTER_PARRY = 1,
+    REACTIVE_OVERPOWER    = 2
+};
+
+#define MAX_REACTIVE 3
+#define SUMMON_SLOT_PET     0
+#define SUMMON_SLOT_TOTEM   1
+#define MAX_TOTEM_SLOT      5
+#define SUMMON_SLOT_MINIPET 5
+#define SUMMON_SLOT_QUEST   6
+#define MAX_SUMMON_SLOT     7
+
+#define MAX_GAMEOBJECT_SLOT 4
+
+enum PlayerTotemType
+{
+    SUMMON_TYPE_TOTEM_FIRE  = 63,
+    SUMMON_TYPE_TOTEM_EARTH = 81,
+    SUMMON_TYPE_TOTEM_WATER = 82,
+    SUMMON_TYPE_TOTEM_AIR   = 83
+};
+
+// delay time next attack to prevent client attack animation problems
+#define ATTACK_DISPLAY_DELAY 200
+#define MAX_PLAYER_STEALTH_DETECT_RANGE 30.0f               // max distance for detection targets by player
+
+struct SpellProcEventEntry;                                 // used only privately
+
+struct SpellCooldown
+{
+    time_t end;
+    uint16 itemid;
+};
+
+typedef std::map<uint32, SpellCooldown> SpellCooldowns;
+
+class Unit : public WorldObject
+{
+    public:
+        typedef std::set<Unit*> AttackerSet;
+        typedef std::set<Unit*> ControlList;
+
+        typedef std::multimap<uint32,  Aura*> AuraMap;
+        typedef std::pair<AuraMap::const_iterator, AuraMap::const_iterator> AuraMapBounds;
+        typedef std::pair<AuraMap::iterator, AuraMap::iterator> AuraMapBoundsNonConst;
+
+        typedef std::multimap<uint32,  AuraApplication*> AuraApplicationMap;
+        typedef std::pair<AuraApplicationMap::const_iterator, AuraApplicationMap::const_iterator> AuraApplicationMapBounds;
+        typedef std::pair<AuraApplicationMap::iterator, AuraApplicationMap::iterator> AuraApplicationMapBoundsNonConst;
+
+        typedef std::multimap<AuraStateType,  AuraApplication*> AuraStateAurasMap;
+        typedef std::pair<AuraStateAurasMap::const_iterator, AuraStateAurasMap::const_iterator> AuraStateAurasMapBounds;
+
+        typedef std::list<AuraEffect*> AuraEffectList;
+        typedef std::list<Aura*> AuraList;
+        typedef std::list<AuraApplication *> AuraApplicationList;
+        typedef std::list<DiminishingReturn> Diminishing;
+        typedef std::set<uint32> ComboPointHolderSet;
+
+        typedef std::map<uint8, AuraApplication*> VisibleAuraMap;
+
+        virtual ~Unit();
+
+        UnitAI* GetAI() { return i_AI; }
+        void SetAI(UnitAI* newAI) { i_AI = newAI; }
+
+        void AddToWorld();
+        void RemoveFromWorld();
+
+        void CleanupBeforeRemoveFromMap(bool finalCleanup);
+        void CleanupsBeforeDelete(bool finalCleanup = true);                        // used in ~Creature/~Player (or before mass creature delete to remove cross-references to already deleted units)
+
+        DiminishingLevels GetDiminishing(DiminishingGroup  group);
+        void IncrDiminishing(DiminishingGroup group);
+        float ApplyDiminishingToDuration(DiminishingGroup  group, int32 &duration, Unit* caster, DiminishingLevels Level, int32 limitduration);
+        void ApplyDiminishingAura(DiminishingGroup  group, bool apply);
+        void ClearDiminishings() { m_Diminishing.clear(); }
+
+        // target dependent range checks
+        float GetSpellMaxRangeForTarget(Unit const* target, SpellInfo const* spellInfo) const;
+        float GetSpellMinRangeForTarget(Unit const* target, SpellInfo const* spellInfo) const;
+
+        virtual void Update(uint32 time);
+
+        void setAttackTimer(WeaponAttackType type, uint32 time) { m_attackTimer[type] = time; }
+        void resetAttackTimer(WeaponAttackType type = BASE_ATTACK);
+        uint32 getAttackTimer(WeaponAttackType type) const { return m_attackTimer[type]; }
+        bool isAttackReady(WeaponAttackType type = BASE_ATTACK) const { return m_attackTimer[type] == 0; }
+        bool haveOffhandWeapon() const;
+        bool CanDualWield() const { return m_canDualWield; }
+        void SetCanDualWield(bool value) { m_canDualWield = value; }
+        float GetCombatReach() const { return m_floatValues[UNIT_FIELD_COMBATREACH]; }
+        float GetMeleeReach() const { float reach = m_floatValues[UNIT_FIELD_COMBATREACH]; return reach > MIN_MELEE_REACH ? reach : MIN_MELEE_REACH; }
+        bool IsWithinCombatRange(const Unit* obj, float dist2compare) const;
+        bool IsWithinMeleeRange(const Unit* obj, float dist = MELEE_RANGE) const;
+        void GetRandomContactPoint(const Unit* target, float &x, float &y, float &z, float distance2dMin, float distance2dMax) const;
+        uint32 m_extraAttacks;
+        bool m_canDualWield;
+
+        void _addAttacker(Unit* pAttacker)                  // must be called only from Unit::Attack(Unit*)
+        {
+            m_attackers.insert(pAttacker);
+        }
+        void _removeAttacker(Unit* pAttacker)               // must be called only from Unit::AttackStop()
+        {
+            m_attackers.erase(pAttacker);
+        }
+        Unit* getAttackerForHelper() const                 // If someone wants to help, who to give them
+        {
+            if (GetVictim() != NULL)
+                return GetVictim();
+
+            if (!m_attackers.empty())
+                return *(m_attackers.begin());
+
+            return NULL;
+        }
+        bool Attack(Unit* victim, bool meleeAttack);
+        void CastStop(uint32 except_spellid = 0);
+        bool AttackStop();
+        void RemoveAllAttackers();
+        AttackerSet const& getAttackers() const { return m_attackers; }
+        bool isAttackingPlayer() const;
+        Unit* GetVictim() const { return m_attacking; }
+
+        void CombatStop(bool includingCast = false);
+        void CombatStopWithPets(bool includingCast = false);
+        void StopAttackFaction(uint32 faction_id);
+        Unit* SelectNearbyTarget(Unit* exclude = NULL, float dist = NOMINAL_MELEE_RANGE) const;
+        void SendMeleeAttackStop(Unit* victim = NULL);
+        void SendMeleeAttackStart(Unit* victim);
+
+        void AddUnitState(uint32 f) { m_state |= f; }
+        bool HasUnitState(const uint32 f) const { return (m_state & f); }
+        void ClearUnitState(uint32 f) { m_state &= ~f; }
+        bool CanFreeMove() const
+        {
+            return !HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_FLEEING | UNIT_STATE_IN_FLIGHT |
+                UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DISTRACTED) && GetOwnerGUID() == 0;
+        }
+
+        uint32 HasUnitTypeMask(uint32 mask) const { return mask & m_unitTypeMask; }
+        void AddUnitTypeMask(uint32 mask) { m_unitTypeMask |= mask; }
+        bool isSummon() const   { return m_unitTypeMask & UNIT_MASK_SUMMON; }
+        bool isGuardian() const { return m_unitTypeMask & UNIT_MASK_GUARDIAN; }
+        bool isPet() const      { return m_unitTypeMask & UNIT_MASK_PET; }
+        bool isHunterPet() const{ return m_unitTypeMask & UNIT_MASK_HUNTER_PET; }
+        bool isTotem() const    { return m_unitTypeMask & UNIT_MASK_TOTEM; }
+        bool IsVehicle() const  { return m_unitTypeMask & UNIT_MASK_VEHICLE; }
+
+        uint8 getLevel() const { return uint8(GetUInt32Value(UNIT_FIELD_LEVEL)); }
+        uint8 getLevelForTarget(WorldObject const* /*target*/) const { return getLevel(); }
+        void SetLevel(uint8 lvl);
+        uint8 getRace() const { return GetByteValue(UNIT_FIELD_BYTES_0, 0); }
+        uint32 getRaceMask() const { return 1 << (getRace()-1); }
+        uint8 getClass() const { return GetByteValue(UNIT_FIELD_BYTES_0, 1); }
+        uint32 getClassMask() const { return 1 << (getClass()-1); }
+        uint8 getGender() const { return GetByteValue(UNIT_FIELD_BYTES_0, 2); }
+
+        float GetStat(Stats stat) const { return float(GetUInt32Value(UNIT_FIELD_STAT0+stat)); }
+        void SetStat(Stats stat, int32 val) { SetStatInt32Value(UNIT_FIELD_STAT0+stat, val); }
+        uint32 GetArmor() const { return GetResistance(SPELL_SCHOOL_NORMAL); }
+        void SetArmor(int32 val) { SetResistance(SPELL_SCHOOL_NORMAL, val); }
+
+        uint32 GetResistance(SpellSchools school) const { return GetUInt32Value(UNIT_FIELD_RESISTANCES+school); }
+        uint32 GetResistance(SpellSchoolMask mask) const;
+        void SetResistance(SpellSchools school, int32 val) { SetStatInt32Value(UNIT_FIELD_RESISTANCES+school, val); }
+
+        uint32 GetHealth()    const { return GetUInt32Value(UNIT_FIELD_HEALTH); }
+        uint32 GetMaxHealth() const { return GetUInt32Value(UNIT_FIELD_MAXHEALTH); }
+
+        bool IsFullHealth() const { return GetHealth() == GetMaxHealth(); }
+        bool HealthBelowPct(int32 pct) const { return GetHealth() < CountPctFromMaxHealth(pct); }
+        bool HealthBelowPctDamaged(int32 pct, uint32 damage) const { return int64(GetHealth()) - int64(damage) < int64(CountPctFromMaxHealth(pct)); }
+        bool HealthAbovePct(int32 pct) const { return GetHealth() > CountPctFromMaxHealth(pct); }
+        bool HealthAbovePctHealed(int32 pct, uint32 heal) const { return uint64(GetHealth()) + uint64(heal) > CountPctFromMaxHealth(pct); }
+        float GetHealthPct() const { return GetMaxHealth() ? 100.f * GetHealth() / GetMaxHealth() : 0.0f; }
+        uint32 CountPctFromMaxHealth(int32 pct) const { return CalculatePct(GetMaxHealth(), pct); }
+        uint32 CountPctFromCurHealth(int32 pct) const { return CalculatePct(GetHealth(), pct); }
+
+        void SetHealth(uint32 val);
+        void SetMaxHealth(uint32 val);
+        inline void SetFullHealth() { SetHealth(GetMaxHealth()); }
+        int32 ModifyHealth(int32 val);
+        int32 GetHealthGain(int32 dVal);
+
+        Powers getPowerType() const { return Powers(GetByteValue(UNIT_FIELD_BYTES_0, 3)); }
+        void setPowerType(Powers power);
+        int32 GetPower(Powers power) const;
+        int32 GetMinPower(Powers power) const { return power == POWER_ECLIPSE ? -100 : 0; }
+        int32 GetMaxPower(Powers power) const;
+        void SetPower(Powers power, int32 val);
+        void SetMaxPower(Powers power, int32 val);
+        // returns the change in power
+        int32 ModifyPower(Powers power, int32 val);
+        int32 ModifyPowerPct(Powers power, float pct, bool apply = true);
+
+        int32 GetHolyPoints() const;
+
+        void ResetAllPowers();
+
+        uint32 GetAttackTime(WeaponAttackType att) const
+        {
+           float f_BaseAttackTime = GetFloatValue(UNIT_FIELD_BASEATTACKTIME+att) / m_modAttackSpeedPct[att];
+           return (uint32)f_BaseAttackTime;
+        }
+
+        void SetAttackTime(WeaponAttackType att, uint32 val) { SetFloatValue(UNIT_FIELD_BASEATTACKTIME+att, val*m_modAttackSpeedPct[att]); }
+        void ApplyAttackTimePercentMod(WeaponAttackType att, float val, bool apply, bool applyRegenPct = true);
+        void ApplyCastTimePercentMod(float val, bool apply);
+
+        SheathState GetSheath() const { return SheathState(GetByteValue(UNIT_FIELD_BYTES_2, 0)); }
+        virtual void SetSheath(SheathState sheathed) { SetByteValue(UNIT_FIELD_BYTES_2, 0, sheathed); }
+
+        // faction template id
+        uint32 getFaction() const { return GetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE); }
+        void setFaction(uint32 faction) { SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, faction); }
+        FactionTemplateEntry const* getFactionTemplateEntry() const;
+
+        ReputationRank GetReactionTo(Unit const* target) const;
+        ReputationRank static GetFactionReactionTo(FactionTemplateEntry const* factionTemplateEntry, Unit const* target);
+
+        bool IsHostileTo(Unit const* unit) const;
+        bool IsHostileToPlayers() const;
+        bool IsFriendlyTo(Unit const* unit) const;
+        bool IsNeutralToAll() const;
+        bool IsInPartyWith(Unit const* unit) const;
+        bool IsInRaidWith(Unit const* unit) const;
+        void GetPartyMembers(std::list<Unit*> &units);
+        bool IsContestedGuard() const
+        {
+            if (FactionTemplateEntry const* entry = getFactionTemplateEntry())
+                return entry->IsContestedGuardFaction();
+
+            return false;
+        }
+        bool IsPvP() const { return HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_PVP); }
+        void SetPvP(bool state)
+        {
+            if (state)
+                SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_PVP);
+            else
+                RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_PVP);
+        }
+        uint32 GetCreatureType() const;
+        uint32 GetCreatureTypeMask() const
+        {
+            uint32 creatureType = GetCreatureType();
+            return (creatureType >= 1) ? (1 << (creatureType - 1)) : 0;
+        }
+
+        uint8 getStandState() const { return GetByteValue(UNIT_FIELD_BYTES_1, 0); }
+        bool IsSitState() const;
+        bool IsStandState() const;
+        void SetStandState(uint8 state);
+
+        void  SetStandFlags(uint8 flags) { SetByteFlag(UNIT_FIELD_BYTES_1, 2, flags); }
+        void  RemoveStandFlags(uint8 flags) { RemoveByteFlag(UNIT_FIELD_BYTES_1, 2, flags); }
+
+        bool IsMounted() const { return HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT); }
+        uint32 GetMountID() const { return GetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID); }
+        void Mount(uint32 mount, uint32 vehicleId = 0, uint32 creatureEntry = 0);
+        void Dismount();
+        MountCapabilityEntry const* GetMountCapability(uint32 mountType) const;
+
+        void SendDurabilityLoss(Player* receiver, uint32 percent);
+        void PlayOneShotAnimKit(uint32 id);
+
+        uint16 GetMaxSkillValueForLevel(Unit const* target = NULL) const { return (target ? getLevelForTarget(target) : getLevel()) * 5; }
+        void DealDamageMods(Unit* victim, uint32 &damage, uint32* absorb);
+        uint32 DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDamage = NULL, DamageEffectType damagetype = DIRECT_DAMAGE, SpellSchoolMask damageSchoolMask = SPELL_SCHOOL_MASK_NORMAL, SpellInfo const* spellProto = NULL, bool durabilityLoss = true, bool splitted = false);
+        void Kill(Unit* victim, bool durabilityLoss = true);
+        int32 DealHeal(Unit* victim, uint32 addhealth);
+
+        void ProcDamageAndSpell(Unit* victim, uint32 procAttacker, uint32 procVictim, uint32 procEx, uint32 amount, uint32 absorb, WeaponAttackType attType = BASE_ATTACK, SpellInfo const* procSpell = NULL, SpellInfo const* procAura = NULL, SpellInfo const* interruptedSpell = NULL, bool procSpellIsHeal = false, bool onCast = false);
+        void ProcDamageAndSpellFor(bool isVictim, Unit* target, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, SpellInfo const* procSpell, uint32 damage, uint32 absorb, SpellInfo const* procAura = NULL, SpellInfo const* interruptedSpell = NULL, bool procSpellIsHeal = false, bool onCast = false);
+
+        void GetProcAurasTriggeredOnEvent(std::list<AuraApplication*>& aurasTriggeringProc, std::list<AuraApplication*>* procAuras, ProcEventInfo eventInfo);
+        void TriggerAurasProcOnEvent(CalcDamageInfo& damageInfo);
+        void TriggerAurasProcOnEvent(std::list<AuraApplication*>* myProcAuras, std::list<AuraApplication*>* targetProcAuras, Unit* actionTarget, uint32 typeMaskActor, uint32 typeMaskActionTarget, uint32 spellTypeMask, uint32 spellPhaseMask, uint32 hitMask, Spell* spell, DamageInfo* damageInfo, HealInfo* healInfo);
+        void TriggerAurasProcOnEvent(ProcEventInfo& eventInfo, std::list<AuraApplication*>& procAuras);
+
+        void HandleEmoteCommand(uint32 anim_id);
+		void HandleEmote(uint32 emote_id);
+		void HandleEmoteState(uint32 emote_id);
+        void AttackerStateUpdate (Unit* victim, WeaponAttackType attType = BASE_ATTACK, bool extra = false);
+
+        void CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* damageInfo, WeaponAttackType attackType = BASE_ATTACK);
+        void DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss);
+        void HandleProcExtraAttackFor(Unit* victim);
+
+        void CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 damage, SpellInfo const* spellInfo, WeaponAttackType attackType = BASE_ATTACK, bool crit = false);
+        void DealSpellDamage(SpellNonMeleeDamage* damageInfo, bool durabilityLoss);
+
+        // player or player's pet resilience (-1%)
+        uint32 GetDamageReduction(uint32 damage) const { return GetCombatRatingDamageReduction(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, 1.0f, 100.0f, damage); }
+
+        void ApplyResilience(const Unit* victim, int32 * damage, bool isCrit) const;
+
+        float MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, uint32 spellId) const;
+        SpellMissInfo MeleeSpellHitResult(Unit* victim, SpellInfo const* spell);
+        SpellMissInfo MagicSpellHitResult(Unit* victim, SpellInfo const* spell);
+        SpellMissInfo SpellHitResult(Unit* victim, SpellInfo const* spell, bool canReflect = false);
+
+        float GetUnitDodgeChance()    const;
+        float GetUnitParryChance()    const;
+        float GetUnitBlockChance()    const;
+        float GetUnitMissChance(WeaponAttackType attType)     const;
+        float GetUnitCriticalChance(WeaponAttackType attackType, const Unit* victim) const;
+        int32 GetMechanicResistChance(const SpellInfo* spell);
+        bool CanUseAttackType(uint8 attacktype) const
+        {
+            switch (attacktype)
+            {
+                case BASE_ATTACK: return !HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED);
+                case OFF_ATTACK: return !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_DISARM_OFFHAND);
+                case RANGED_ATTACK: return !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_DISARM_RANGED);
+            }
+            return true;
+        }
+
+        virtual uint32 GetBlockPercent() { return 30; }
+
+        uint32 GetUnitMeleeSkill(Unit const* target = NULL) const { return (target ? getLevelForTarget(target) : getLevel()) * 5; }
+        float GetWeaponProcChance() const;
+        float GetPPMProcChance(uint32 WeaponSpeed, float PPM,  const SpellInfo* spellProto) const;
+
+        MeleeHitOutcome RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackType attType) const;
+        MeleeHitOutcome RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackType attType, int32 crit_chance, int32 miss_chance, int32 dodge_chance, int32 parry_chance, int32 block_chance) const;
+
+        bool IsVendor()       const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_VENDOR); }
+        bool IsTrainer()      const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_TRAINER); }
+        bool IsQuestGiver()   const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER); }
+        bool IsGossip()       const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP); }
+        bool IsTaxi()         const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_FLIGHTMASTER); }
+        bool IsGuildMaster()  const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_PETITIONER); }
+        bool IsBattleMaster() const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_BATTLEMASTER); }
+        bool IsBanker()       const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_BANKER); }
+        bool IsInnkeeper()    const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_INNKEEPER); }
+        bool IsSpiritHealer() const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPIRITHEALER); }
+        bool IsSpiritGuide()  const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPIRITGUIDE); }
+        bool IsTabardDesigner()const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_TABARDDESIGNER); }
+        bool IsAuctioner()    const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_AUCTIONEER); }
+        bool IsArmorer()      const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_REPAIR); }
+        bool IsServiceProvider() const
+        {
+            return HasFlag(UNIT_NPC_FLAGS,
+                UNIT_NPC_FLAG_VENDOR | UNIT_NPC_FLAG_TRAINER | UNIT_NPC_FLAG_FLIGHTMASTER |
+                UNIT_NPC_FLAG_PETITIONER | UNIT_NPC_FLAG_BATTLEMASTER | UNIT_NPC_FLAG_BANKER |
+                UNIT_NPC_FLAG_INNKEEPER | UNIT_NPC_FLAG_SPIRITHEALER |
+                UNIT_NPC_FLAG_SPIRITGUIDE | UNIT_NPC_FLAG_TABARDDESIGNER | UNIT_NPC_FLAG_AUCTIONEER);
+        }
+        bool isSpiritService() const { return HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPIRITHEALER | UNIT_NPC_FLAG_SPIRITGUIDE); }
+
+        bool isInFlight()  const { return HasUnitState(UNIT_STATE_IN_FLIGHT); }
+
+        bool isInCombat()  const { return HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT); }
+        bool IsInCombat(Unit* target) const;
+        void CombatStart(Unit* target, bool initialAggro = true);
+        void SetInCombatState(bool PvP, Unit* enemy = NULL);
+        void SetInCombatWith(Unit* enemy);
+        void ClearInCombat();
+        uint32 GetCombatTimer() const { return m_CombatTimer; }
+
+        bool HasAuraTypeWithFamilyFlags(AuraType auraType, uint32 familyName, uint32 familyFlags) const;
+        bool virtual HasSpell(uint32 /*spellID*/) const { return false; }
+        bool HasBreakableByDamageAuraType(AuraType type, uint32 excludeAura = 0) const;
+        bool HasBreakableByDamageCrowdControlAura(Unit* excludeCasterChannel = NULL) const;
+
+        bool HasStealthAura()      const { return HasAuraType(SPELL_AURA_MOD_STEALTH); }
+        bool HasInvisibilityAura() const { return HasAuraType(SPELL_AURA_MOD_INVISIBILITY); }
+        bool isFeared()  const { return HasAuraType(SPELL_AURA_MOD_FEAR); }
+        bool isInRoots() const { return HasAuraType(SPELL_AURA_MOD_ROOT); }
+        bool IsPolymorphed() const;
+
+        bool isFrozen() const;
+
+        bool isTargetableForAttack(bool checkFakeDeath = true) const;
+
+        bool IsValidAttackTarget(Unit const* target) const;
+        bool _IsValidAttackTarget(Unit const* target, SpellInfo const* bySpell, WorldObject const* obj = NULL) const;
+
+        bool IsValidAssistTarget(Unit const* target) const;
+        bool _IsValidAssistTarget(Unit const* target, SpellInfo const* bySpell) const;
+
+        virtual bool IsInWater() const { return false; }
+        virtual bool IsUnderWater() const { return false; }
+        virtual void UpdateUnderwaterState(Map* m, float x, float y, float z);
+        bool isInAccessiblePlaceFor(Creature const* c) const;
+
+        void SendHealSpellLog(Unit* victim, uint32 SpellID, uint32 Damage, uint32 OverHeal, uint32 Absorb, bool critical = false);
+        int32 HealBySpell(Unit* victim, SpellInfo const* spellInfo, uint32 addHealth, bool critical = false);
+        void SendEnergizeSpellLog(Unit* victim, uint32 SpellID, uint32 Damage, Powers powertype);
+        void EnergizeBySpell(Unit* victim, uint32 SpellID, int32 Damage, Powers powertype);
+        uint32 SpellNonMeleeDamageLog(Unit* victim, uint32 spellID, uint32 damage);
+
+        void CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo, CustomSpellValues const* value, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastSpell(Unit* victim, uint32 spellId, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastSpell(Unit* victim, uint32 spellId, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastSpell(Unit* victim, SpellInfo const* spellInfo, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastSpell(Unit* victim, SpellInfo const* spellInfo, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastSpell(float x, float y, float z, uint32 spellId, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastSpell(GameObject* go, uint32 spellId, bool triggered, Item* castItem = NULL, AuraEffect* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastCustomSpell(Unit* victim, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastCustomSpell(Unit* victim, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* victim, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* victim = NULL, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastCustomSpell(uint32 spellId, CustomSpellValues const &value, Unit* victim = NULL, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
+        void CastWithDelay(uint32 delay, Unit* victim, uint32 spellid, bool triggered = false, bool repeat = false);
+        Aura* AddAura(uint32 spellId, Unit* target);
+        Aura* AddAura(SpellInfo const* spellInfo, uint8 effMask, Unit* target);
+        Aura* AddAuraForTarget(Aura* aura, Unit* target);
+        void SetAuraStack(uint32 spellId, Unit* target, uint32 stack);
+        void SendPlaySpellVisualKit(uint32 id, uint32 unkParam);
+
+        void DeMorph();
+
+        void SendAttackStateUpdate(CalcDamageInfo* damageInfo);
+        void SendAttackStateUpdate(uint32 HitInfo, Unit* target, uint8 SwingType, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount);
+        void SendSpellNonMeleeDamageLog(SpellNonMeleeDamage* log);
+        void SendSpellNonMeleeDamageLog(Unit* target, uint32 SpellID, uint32 Damage, SpellSchoolMask damageSchoolMask, uint32 AbsorbedDamage, uint32 Resist, bool PhysicalDamage, uint32 Blocked, bool CriticalHit = false);
+        void SendPeriodicAuraLog(SpellPeriodicAuraLogInfo* pInfo);
+        void SendSpellMiss(Unit* target, uint32 spellID, SpellMissInfo missInfo);
+        void SendSpellDamageResist(Unit* target, uint32 spellId);
+        void SendSpellDamageImmune(Unit* target, uint32 spellId);
+
+        void NearTeleportTo(float x, float y, float z, float orientation, bool casting = false);
+        void NearTeleportTo(Position position, bool casting = false);
+        void SendTeleportPacket(Position& pos);
+        virtual bool UpdatePosition(float x, float y, float z, float ang, bool teleport = false);
+        // returns true if unit's position really changed
+        bool UpdatePosition(const Position &pos, bool teleport = false) { return UpdatePosition(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation(), teleport); }
+        void UpdateOrientation(float orientation);
+        void UpdateHeight(float newZ);
+
+        void SendMoveKnockBack(Player* player, float speedXY, float speedZ, float vcos, float vsin);
+        void KnockbackFrom(float x, float y, float speedXY, float speedZ);
+        void JumpTo(float speedXY, float speedZ, bool forward = true);
+        void JumpTo(WorldObject* obj, float speedZ);
+
+        void MonsterMoveWithSpeed(float x, float y, float z, float speed, bool generatePath = false, bool forceDestination = false);
+        //void SetFacing(float ori, WorldObject* obj = NULL);
+        //void SendMonsterMove(float NewPosX, float NewPosY, float NewPosZ, uint8 type, uint32 MovementFlags, uint32 Time, Player* player = NULL);
+        void SendMovementFlagUpdate(bool self = false);
+
+        /*! These methods send the same packet to the client in apply and unapply case.
+            The client-side interpretation of this packet depends on the presence of relevant movementflags
+            which are sent with movementinfo. Furthermore, these packets are broadcast to nearby players as well
+            as the current unit.
+        */
+        void SendMovementHover();
+        void SendMovementFeatherFall();
+        void SendMovementWaterWalking();
+        void SendMovementDisableGravity();
+        void SendMovementCanFlyChange();
+        void SendMovementSwimming();
+        void SendMovementWalkMode();
+
+        bool IsLevitating() const { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY);}
+        bool IsWalking() const { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_WALKING);}
+        virtual bool SetWalk(bool enable);
+        virtual bool SetDisableGravity(bool disable, bool packetOnly = false);
+        virtual bool SetHover(bool enable);
+
+        void SetInFront(Unit const* target);
+        void SetFacingTo(float ori);
+        void SetFacingToObject(WorldObject* object);
+
+        void SendChangeCurrentVictimOpcode(HostileReference* pHostileReference);
+        void SendClearThreatListOpcode();
+        void SendRemoveFromThreatListOpcode(HostileReference* pHostileReference);
+        void SendThreatListUpdate();
+
+        void BuildHeartBeatMsg(WorldPacket* data) const;
+
+        void SendClearTarget();
+
+        bool isAlive() const { return (m_deathState == ALIVE); };
+        bool isDying() const { return (m_deathState == JUST_DIED); };
+        bool isDead() const { return (m_deathState == DEAD || m_deathState == CORPSE); };
+        DeathState getDeathState() { return m_deathState; };
+        virtual void setDeathState(DeathState s);           // overwrited in Creature/Player/Pet
+
+        uint64 GetOwnerGUID() const { return  GetUInt64Value(UNIT_FIELD_SUMMONEDBY); }
+        void SetOwnerGUID(uint64 owner);
+        uint64 GetCreatorGUID() const { return GetUInt64Value(UNIT_FIELD_CREATEDBY); }
+        void SetCreatorGUID(uint64 creator) { SetUInt64Value(UNIT_FIELD_CREATEDBY, creator); }
+        uint64 GetMinionGUID() const { return GetUInt64Value(UNIT_FIELD_SUMMON); }
+        void SetMinionGUID(uint64 guid) { SetUInt64Value(UNIT_FIELD_SUMMON, guid); }
+        uint64 GetCharmerGUID() const { return GetUInt64Value(UNIT_FIELD_CHARMEDBY); }
+        void SetCharmerGUID(uint64 owner) { SetUInt64Value(UNIT_FIELD_CHARMEDBY, owner); }
+        uint64 GetCharmGUID() const { return  GetUInt64Value(UNIT_FIELD_CHARM); }
+        void SetPetGUID(uint64 guid) { m_SummonSlot[SUMMON_SLOT_PET] = guid; }
+        uint64 GetPetGUID() const { return m_SummonSlot[SUMMON_SLOT_PET]; }
+        void SetCritterGUID(uint64 guid) { SetUInt64Value(UNIT_FIELD_CRITTER, guid); }
+        uint64 GetCritterGUID() const { return GetUInt64Value(UNIT_FIELD_CRITTER); }
+
+        bool IsControlledByPlayer() const { return m_ControlledByPlayer; }
+        uint64 GetCharmerOrOwnerGUID() const { return GetCharmerGUID() ? GetCharmerGUID() : GetOwnerGUID(); }
+        uint64 GetCharmerOrOwnerOrOwnGUID() const
+        {
+            if (uint64 guid = GetCharmerOrOwnerGUID())
+                return guid;
+            return GetGUID();
+        }
+        bool isCharmedOwnedByPlayerOrPlayer() const { return IS_PLAYER_GUID(GetCharmerOrOwnerOrOwnGUID()); }
+
+        Player* GetSpellModOwner() const;
+
+        Unit* GetOwner() const;
+        Guardian *GetGuardianPet() const;
+        Minion *GetFirstMinion() const;
+        Unit* GetCharmer() const;
+        Unit* GetCharm() const;
+        Unit* GetCharmerOrOwner() const { return GetCharmerGUID() ? GetCharmer() : GetOwner(); }
+        Unit* GetCharmerOrOwnerOrSelf() const
+        {
+            if (Unit* u = GetCharmerOrOwner())
+                return u;
+
+            return (Unit*)this;
+        }
+        Player* GetCharmerOrOwnerPlayerOrPlayerItself() const;
+        Player* GetAffectingPlayer() const;
+
+        void RecalculatePetsScalingResistance(uint32 school);
+        void RecalculatePetsScalingStats(Stats stats);
+        void RecalculatePetsScalingAttackPower();
+        void RecalculatePetsScalingDamageDone();
+        void RecalculatePetsScalingDamageDonePct();
+        void RecalculatePetsScalingAttackSpeed(WeaponAttackType att);
+        void RecalculatePetsScalingHitRating();
+        void RecalculatePetsScalingCritRating();
+
+        void SetMinion(Minion *minion, bool apply, PetSlot slot);
+        void GetAllMinionsByEntry(std::list<Creature*>& Minions, uint32 entry);
+        void RemoveAllMinionsByEntry(uint32 entry);
+        void SetCharm(Unit* target, bool apply);
+        Unit* GetNextRandomRaidMemberOrPet(float radius);
+        bool SetCharmedBy(Unit* charmer, CharmType type, AuraApplication const* aurApp = NULL);
+        void RemoveCharmedBy(Unit* charmer);
+        void RestoreFaction();
+
+        ControlList m_Controlled;
+        Unit* GetFirstControlled() const;
+        void RemoveAllControlled();
+
+        bool isCharmed() const { return GetCharmerGUID() != 0; }
+        bool isPossessed() const { return HasUnitState(UNIT_STATE_POSSESSED); }
+        bool isPossessedByPlayer() const { return HasUnitState(UNIT_STATE_POSSESSED) && IS_PLAYER_GUID(GetCharmerGUID()); }
+        bool isPossessing() const
+        {
+            if (Unit* u = GetCharm())
+                return u->isPossessed();
+            else
+                return false;
+        }
+        bool isPossessing(Unit* u) const { return u->isPossessed() && GetCharmGUID() == u->GetGUID(); }
+
+        CharmInfo* GetCharmInfo() { return m_charmInfo; }
+        CharmInfo* InitCharmInfo();
+        void DeleteCharmInfo();
+        void UpdateCharmAI();
+		void EnableAI();
+        //Player* GetMoverSource() const;
+        Player* m_movedPlayer;
+        SharedVisionList const& GetSharedVisionList() { return m_sharedVision; }
+        void AddPlayerToVision(Player* player);
+        void RemovePlayerFromVision(Player* player);
+        bool HasSharedVision() const { return !m_sharedVision.empty(); }
+        void RemoveBindSightAuras();
+        void RemoveCharmAuras();
+
+        Pet* CreateTamedPetFrom(Creature* creatureTarget, uint32 spell_id = 0);
+        Pet* CreateTamedPetFrom(uint32 creatureEntry, uint32 spell_id = 0);
+        bool InitTamedPet(Pet* pet, uint8 level, uint32 spell_id);
+
+        // aura apply/remove helpers - you should better not use these
+        Aura* _TryStackingOrRefreshingExistingAura(SpellInfo const* newAura, uint8 effMask, Unit* caster, int32* baseAmount = NULL, Item* castItem = NULL, uint64 casterGUID = 0);
+        void _AddAura(UnitAura* aura, Unit* caster);
+        AuraApplication * _CreateAuraApplication(Aura* aura, uint8 effMask);
+        void _ApplyAuraEffect(Aura* aura, uint8 effIndex);
+        void _ApplyAura(AuraApplication * aurApp, uint8 effMask);
+        void _UnapplyAura(AuraApplicationMap::iterator &i, AuraRemoveMode removeMode);
+        void _UnapplyAura(AuraApplication * aurApp, AuraRemoveMode removeMode);
+        void _RemoveNoStackAuraApplicationsDueToAura(Aura* aura);
+        void _RemoveNoStackAurasDueToAura(Aura* aura);
+        bool _IsNoStackAuraDueToAura(Aura* appliedAura, Aura* existingAura) const;
+        void _RegisterAuraEffect(AuraEffect* aurEff, bool apply);
+
+        // m_ownedAuras container management
+        AuraMap      & GetOwnedAuras()       { return m_ownedAuras; }
+        AuraMap const& GetOwnedAuras() const { return m_ownedAuras; }
+
+        void RemoveOwnedAura(AuraMap::iterator &i, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);
+        void RemoveOwnedAura(uint32 spellId, uint64 casterGUID = 0, uint8 reqEffMask = 0, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);
+        void RemoveOwnedAura(Aura* aura, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);
+
+        Aura* GetOwnedAura(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0, Aura* except = NULL) const;
+
+        // m_appliedAuras container management
+        AuraApplicationMap      & GetAppliedAuras()       { return m_appliedAuras; }
+        AuraApplicationMap const& GetAppliedAuras() const { return m_appliedAuras; }
+        mutable ACE_Recursive_Thread_Mutex m_appliedAuraMutex;
+
+        typedef std::list<Aura*> appliedAurasList;
+        appliedAurasList appliedAuras;
+
+        void RemoveAura(AuraApplicationMap::iterator &i, AuraRemoveMode mode = AURA_REMOVE_BY_DEFAULT);
+        void RemoveAura(uint32 spellId, uint64 casterGUID = 0, uint8 reqEffMask = 0, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);
+        void RemoveAura(AuraApplication * aurApp, AuraRemoveMode mode = AURA_REMOVE_BY_DEFAULT);
+        void RemoveAura(Aura* aur, AuraRemoveMode mode = AURA_REMOVE_BY_DEFAULT);
+
+        void RemoveAurasDueToSpell(uint32 spellId, uint64 casterGUID = 0, uint8 reqEffMask = 0, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);
+        void RemoveAuraFromStack(uint32 spellId, uint64 casterGUID = 0, AuraRemoveMode removeMode = AURA_REMOVE_BY_DEFAULT);
+        void RemoveAurasDueToSpellByDispel(uint32 spellId, uint32 dispellerSpellId, uint64 casterGUID, Unit* dispeller, uint8 chargesRemoved = 1);
+        void RemoveAurasDueToSpellBySteal(uint32 spellId, uint64 casterGUID, Unit* stealer);
+        void RemoveAurasDueToItemSpell(uint32 spellId, uint64 castItemGuid);
+        void RemoveAurasByType(AuraType auraType, uint64 casterGUID = 0, Aura* except = NULL, bool negative = true, bool positive = true, SpellFamilyNames SpellFamilyName = SPELLFAMILY_GENERIC, uint32 schoolMask = 0);
+        void RemoveNotOwnSingleTargetAuras(uint32 newPhase = 0x0);
+        void RemoveAurasWithInterruptFlags(uint32 flag, uint32 except = 0, uint32 damage = 0);
+        void RemoveAurasWithAttribute(uint32 flags);
+        void RemoveAurasWithFamily(SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID);
+        void RemoveAurasWithMechanic(uint32 mechanic_mask, AuraRemoveMode removemode = AURA_REMOVE_BY_DEFAULT, uint32 except=0);
+        void RemoveMovementImpairingAuras();
+
+        void RemoveAreaAurasDueToLeaveWorld();
+        void RemoveAllAuras();
+        void RemoveArenaAuras();
+        void RemoveAllAurasOnDeath();
+        void RemoveAllAurasRequiringDeadTarget();
+        void RemoveAllAurasExceptType(AuraType type);
+        void RemoveAllNonPassiveAurasExceptType(AuraType type);
+        void DelayOwnedAuras(uint32 spellId, uint64 caster, int32 delaytime);
+
+        void _RemoveAllAuraStatMods();
+        void _ApplyAllAuraStatMods();
+
+        AuraEffectList const& GetAuraEffectsByType(AuraType type) const { return m_modAuras[type]; }
+        AuraList      & GetSingleCastAuras()       { return m_scAuras; }
+        AuraList const& GetSingleCastAuras() const { return m_scAuras; }
+
+        AuraEffect* GetAuraEffect(uint32 spellId, uint8 effIndex, uint64 casterGUID = 0) const;
+        AuraEffect* GetAuraEffectOfRankedSpell(uint32 spellId, uint8 effIndex, uint64 casterGUID = 0) const;
+        AuraEffect* GetAuraEffect(AuraType type, SpellFamilyNames name, uint32 iconId, uint8 effIndex) const; // spell mustn't have familyflags
+        AuraEffect* GetAuraEffect(AuraType type, SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID =0);
+        inline AuraEffect* GetDummyAuraEffect(SpellFamilyNames name, uint32 iconId, uint8 effIndex) const { return GetAuraEffect(SPELL_AURA_DUMMY, name, iconId, effIndex);}
+
+        AuraApplication * GetAuraApplication(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0, AuraApplication * except = NULL) const;
+        Aura* GetAura(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0) const;
+
+        AuraApplication * GetAuraApplicationOfRankedSpell(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0, AuraApplication * except = NULL) const;
+        Aura* GetAuraOfRankedSpell(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0) const;
+
+        void GetDispellableAuraList(Unit* caster, uint32 dispelMask, DispelChargesList& dispelList);
+
+        bool HasAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster = 0) const;
+        uint32 GetAuraCount(uint32 spellId) const;
+        bool HasAura(uint32 spellId, uint64 casterGUID = 0, uint64 itemCasterGUID = 0, uint8 reqEffMask = 0) const;
+        bool HasAuraWithDispelType(uint32 dispelType, uint64 casterGUID);
+        bool HasAuraType(AuraType auraType) const;
+        bool HasAuraTypeWithCaster(AuraType auratype, uint64 caster) const;
+        bool HasAuraTypeWithMiscvalue(AuraType auratype, int32 miscvalue) const;
+        bool HasAuraTypeWithAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const;
+        bool HasAuraTypeWithValue(AuraType auratype, int32 value) const;
+        bool HasNegativeAuraWithInterruptFlag(uint32 flag, uint64 guid = 0);
+        bool HasNegativeAuraWithAttribute(uint32 flag, uint64 guid = 0);
+        bool HasAuraWithMechanic(uint32 mechanicMask);
+
+        AuraEffect* IsScriptOverriden(SpellInfo const* spell, int32 script) const;
+        uint32 GetDiseasesByCaster(uint64 casterGUID, bool remove = false);
+        uint32 GetDoTsByCaster(uint64 casterGUID) const;
+
+        void SaveSoulSwapDotsListAndTarget(uint64 targetGUID, std::list<uint32> dotsList) { m_soulSwapTargetGuid = targetGUID; m_soulSwapDotsList = dotsList; }
+        std::list<uint32>  GetSoulSwapDotsList() const { return m_soulSwapDotsList; }
+        uint64 GetSoulSwapTarget() const { return m_soulSwapTargetGuid; }
+        void ClearSoulSwapDotsList() { m_soulSwapTargetGuid = 0; m_soulSwapDotsList.clear(); }
+        AuraEffectList GetAuraDotsByCaster(uint64 casterGUID) const;
+
+        int32 GetTotalAuraModifier(AuraType auratype) const;
+        float GetTotalAuraMultiplier(AuraType auratype) const;
+        int32 GetMaxPositiveAuraModifier(AuraType auratype);
+        int32 GetMaxNegativeAuraModifier(AuraType auratype) const;
+
+        int32 GetTotalAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const;
+        float GetTotalAuraMultiplierByMiscMask(AuraType auratype, uint32 misc_mask) const;
+        int32 GetMaxPositiveAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask, const AuraEffect* except = NULL) const;
+        int32 GetMaxNegativeAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const;
+
+        int32 GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const;
+        float GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_value) const;
+        int32 GetMaxPositiveAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const;
+        int32 GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const;
+
+        int32 GetTotalAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const;
+        float GetTotalAuraMultiplierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const;
+        int32 GetMaxPositiveAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const;
+        int32 GetMaxNegativeAuraModifierByAffectMask(AuraType auratype, SpellInfo const* affectedSpell) const;
+
+        float GetResistanceBuffMods(SpellSchools school, bool positive) const { return GetFloatValue(positive ? UNIT_FIELD_RESISTANCEBUFFMODSPOSITIVE+school : UNIT_FIELD_RESISTANCEBUFFMODSNEGATIVE+school); }
+        void SetResistanceBuffMods(SpellSchools school, bool positive, float val) { SetFloatValue(positive ? UNIT_FIELD_RESISTANCEBUFFMODSPOSITIVE+school : UNIT_FIELD_RESISTANCEBUFFMODSNEGATIVE+school, val); }
+        void ApplyResistanceBuffModsMod(SpellSchools school, bool positive, float val, bool apply) { ApplyModSignedFloatValue(positive ? UNIT_FIELD_RESISTANCEBUFFMODSPOSITIVE+school : UNIT_FIELD_RESISTANCEBUFFMODSNEGATIVE+school, val, apply); }
+        void ApplyResistanceBuffModsPercentMod(SpellSchools school, bool positive, float val, bool apply) { ApplyPercentModFloatValue(positive ? UNIT_FIELD_RESISTANCEBUFFMODSPOSITIVE+school : UNIT_FIELD_RESISTANCEBUFFMODSNEGATIVE+school, val, apply); }
+        void InitStatBuffMods()
+        {
+            for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i) SetFloatValue(UNIT_FIELD_POSSTAT0+i, 0);
+            for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i) SetFloatValue(UNIT_FIELD_NEGSTAT0+i, 0);
+        }
+        void ApplyStatBuffMod(Stats stat, float val, bool apply) { ApplyModSignedFloatValue((val > 0 ? UNIT_FIELD_POSSTAT0+stat : UNIT_FIELD_NEGSTAT0+stat), val, apply); }
+        void ApplyStatPercentBuffMod(Stats stat, float val, bool apply)
+        {
+            ApplyPercentModFloatValue(UNIT_FIELD_POSSTAT0+stat, val, apply);
+            ApplyPercentModFloatValue(UNIT_FIELD_NEGSTAT0+stat, val, apply);
+        }
+        void SetCreateStat(Stats stat, float val) { m_createStats[stat] = val; }
+        void SetCreateHealth(uint32 val) { SetUInt32Value(UNIT_FIELD_BASE_HEALTH, val); }
+        uint32 GetCreateHealth() const { return GetUInt32Value(UNIT_FIELD_BASE_HEALTH); }
+        void SetCreateMana(uint32 val) { SetUInt32Value(UNIT_FIELD_BASE_MANA, val); }
+        uint32 GetCreateMana() const { return GetUInt32Value(UNIT_FIELD_BASE_MANA); }
+        uint32 GetPowerIndex(uint32 powerType) const;
+        int32 GetCreatePowers(Powers power) const;
+        float GetPosStat(Stats stat) const { return GetFloatValue(UNIT_FIELD_POSSTAT0+stat); }
+        float GetNegStat(Stats stat) const { return GetFloatValue(UNIT_FIELD_NEGSTAT0+stat); }
+        float GetCreateStat(Stats stat) const { return m_createStats[stat]; }
+
+        void SetCurrentCastedSpell(Spell* pSpell);
+        virtual void ProhibitSpellSchool(SpellSchoolMask /*idSchoolMask*/, uint32 /*unTimeMs*/) { }
+        void InterruptSpell(CurrentSpellTypes spellType, bool withDelayed = true, bool withInstant = true);
+        void FinishSpell(CurrentSpellTypes spellType, bool ok = true);
+
+        // set withDelayed to true to account delayed spells as casted
+        // delayed+channeled spells are always accounted as casted
+        // we can skip channeled or delayed checks using flags
+        bool IsNonMeleeSpellCasted(bool withDelayed, bool skipChanneled = false, bool skipAutorepeat = false, bool isAutoshoot = false, bool skipInstant = true) const;
+
+        // set withDelayed to true to interrupt delayed spells too
+        // delayed+channeled spells are always interrupted
+        void InterruptNonMeleeSpells(bool withDelayed, uint32 spellid = 0, bool withInstant = true);
+
+        Spell* GetCurrentSpell(CurrentSpellTypes spellType) const { return m_currentSpells[spellType]; }
+        Spell* GetCurrentSpell(uint32 spellType) const { return m_currentSpells[spellType]; }
+        Spell* FindCurrentSpellBySpellId(uint32 spell_id) const;
+        int32 GetCurrentSpellCastTime(uint32 spell_id) const;
+
+        uint32 m_addDmgOnce;
+        uint64 m_SummonSlot[MAX_SUMMON_SLOT];
+        uint64 m_ObjectSlot[MAX_GAMEOBJECT_SLOT];
+
+        ShapeshiftForm GetShapeshiftForm() const { return ShapeshiftForm(GetByteValue(UNIT_FIELD_BYTES_2, 3)); }
+        void SetShapeshiftForm(ShapeshiftForm form)
+        {
+            SetByteValue(UNIT_FIELD_BYTES_2, 3, form);
+        }
+
+        inline bool IsInFeralForm() const
+        {
+            ShapeshiftForm form = GetShapeshiftForm();
+            return form == FORM_CAT || form == FORM_BEAR;
+        }
+
+        inline bool IsInDisallowedMountForm() const
+        {
+            ShapeshiftForm form = GetShapeshiftForm();
+            return form != FORM_NONE && form != FORM_BATTLESTANCE && form != FORM_BERSERKERSTANCE && form != FORM_DEFENSIVESTANCE &&
+                form != FORM_SHADOW && form != FORM_STEALTH && form != FORM_UNDEAD && form != FORM_SHADOW_DANCE;
+        }
+
+        float m_modMeleeHitChance;
+        float m_modRangedHitChance;
+        float m_modSpellHitChance;
+        int32 m_baseSpellCritChance;
+
+        float m_threatModifier[MAX_SPELL_SCHOOL];
+        float m_modAttackSpeedPct[3];
+
+        // Event handler
+        EventProcessor m_Events;
+
+        // stat system
+        bool HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, float amount, bool apply);
+        void SetModifierValue(UnitMods unitMod, UnitModifierType modifierType, float value) { m_auraModifiersGroup[unitMod][modifierType] = value; }
+        float GetModifierValue(UnitMods unitMod, UnitModifierType modifierType) const;
+        float GetTotalStatValue(Stats stat) const;
+        float GetTotalAuraModValue(UnitMods unitMod) const;
+        SpellSchools GetSpellSchoolByAuraGroup(UnitMods unitMod) const;
+        Stats GetStatByAuraGroup(UnitMods unitMod) const;
+        Powers GetPowerTypeByAuraGroup(UnitMods unitMod) const;
+        bool CanModifyStats() const { return m_canModifyStats; }
+        void SetCanModifyStats(bool modifyStats) { m_canModifyStats = modifyStats; }
+        virtual bool UpdateStats(Stats stat) = 0;
+        virtual bool UpdateAllStats() = 0;
+        virtual void UpdateResistances(uint32 school) = 0;
+        virtual void UpdateArmor() = 0;
+        virtual void UpdateMaxHealth() = 0;
+        virtual void UpdateMaxPower(Powers power) = 0;
+        virtual void UpdateAttackPowerAndDamage(bool ranged = false) = 0;
+        virtual void UpdateDamagePhysical(WeaponAttackType attType) = 0;
+        float GetTotalAttackPowerValue(WeaponAttackType attType) const;
+        float GetWeaponDamageRange(WeaponAttackType attType, WeaponDamageRange type) const;
+        void SetBaseWeaponDamage(WeaponAttackType attType, WeaponDamageRange damageRange, float value) { m_weaponDamage[attType][damageRange] = value; }
+
+        bool isInFrontInMap(Unit const* target, float distance, float arc = M_PI) const;
+        bool isInBackInMap(Unit const* target, float distance, float arc = M_PI) const;
+
+        // Visibility system
+        bool IsVisible() const { return (m_serverSideVisibility.GetValue(SERVERSIDE_VISIBILITY_GM) > SEC_PLAYER) ? false : true; }
+        void SetVisible(bool x);
+
+        // common function for visibility checks for player/creatures with detection code
+        void SetPhaseMask(uint32 newPhaseMask, bool update);// overwrite WorldObject::SetPhaseMask
+        void UpdateObjectVisibility(bool forced = true);
+
+        SpellImmuneList m_spellImmune[MAX_SPELL_IMMUNITY];
+        uint32 m_lastSanctuaryTime;
+
+        // Threat related methods
+        bool CanHaveThreatList() const;
+        void AddThreat(Unit* victim, float fThreat, SpellSchoolMask schoolMask = SPELL_SCHOOL_MASK_NORMAL, SpellInfo const* threatSpell = NULL);
+        float ApplyTotalThreatModifier(float fThreat, SpellSchoolMask schoolMask = SPELL_SCHOOL_MASK_NORMAL);
+        void DeleteThreatList();
+        void TauntApply(Unit* victim);
+        void TauntFadeOut(Unit* taunter);
+        ThreatManager& getThreatManager() { return m_ThreatManager; }
+        void addHatedBy(HostileReference* pHostileReference) { m_HostileRefManager.insertFirst(pHostileReference); };
+        void removeHatedBy(HostileReference* /*pHostileReference*/) { /* nothing to do yet */ }
+        HostileRefManager& getHostileRefManager() { return m_HostileRefManager; }
+
+        VisibleAuraMap const* GetVisibleAuras() { return &m_visibleAuras; }
+        AuraApplication * GetVisibleAura(uint8 slot)
+        {
+            VisibleAuraMap::iterator itr = m_visibleAuras.find(slot);
+            if (itr != m_visibleAuras.end())
+                return itr->second;
+            return 0;
+        }
+        void SetVisibleAura(uint8 slot, AuraApplication * aur){ m_visibleAuras[slot]=aur; UpdateAuraForGroup(slot);}
+        void RemoveVisibleAura(uint8 slot){ m_visibleAuras.erase(slot); UpdateAuraForGroup(slot);}
+
+        uint32 GetInterruptMask() const { return m_interruptMask; }
+        void AddInterruptMask(uint32 mask) { m_interruptMask |= mask; }
+        void UpdateInterruptMask();
+
+        uint32 GetDisplayId() { return GetUInt32Value(UNIT_FIELD_DISPLAYID); }
+        virtual void SetDisplayId(uint32 modelId);
+        uint32 GetNativeDisplayId() { return GetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID); }
+        void RestoreDisplayId();
+        void SetNativeDisplayId(uint32 modelId) { SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, modelId); }
+        void setTransForm(uint32 spellid) { m_transform = spellid;}
+        uint32 getTransForm() const { return m_transform;}
+
+        // DynamicObject management
+        void _RegisterDynObject(DynamicObject* dynObj);
+        void _UnregisterDynObject(DynamicObject* dynObj);
+        DynamicObject* GetDynObject(uint32 spellId);
+        void RemoveDynObject(uint32 spellId);
+        void RemoveAllDynObjects();
+
+        GameObject* GetGameObject(uint32 spellId) const;
+        void AddGameObject(GameObject* gameObj);
+        void RemoveGameObject(GameObject* gameObj, bool del);
+        void RemoveGameObject(uint32 spellid, bool del);
+        void RemoveAllGameObjects();
+
+        uint32 CalculateDamage(WeaponAttackType attType, bool normalized, bool addTotalPct);
+        float GetAPMultiplier(WeaponAttackType attType, bool normalized);
+        void ModifyAuraState(AuraStateType flag, bool apply);
+        uint32 BuildAuraStateUpdateForTarget(Unit* target) const;
+        bool HasAuraState(AuraStateType flag, SpellInfo const* spellProto = NULL, Unit const* Caster = NULL) const;
+        void UnsummonAllTotems();
+        Unit* GetMagicHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo);
+        Unit* GetMeleeHitRedirectTarget(Unit* victim, SpellInfo const* spellInfo = NULL);
+
+        int32 SpellBaseDamageBonusDone(SpellSchoolMask schoolMask);
+        int32 SpellBaseDamageBonusTaken(SpellSchoolMask schoolMask);
+        uint32 SpellDamageBonusDone(Unit* victim, SpellInfo const* spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack = 1);
+        uint32 SpellDamageBonusTaken(SpellInfo const* spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack = 1, uint64 casterGUID = 0);
+        int32 SpellBaseHealingBonusDone(SpellSchoolMask schoolMask);
+        int32 SpellBaseHealingBonusTaken(SpellSchoolMask schoolMask);
+        uint32 SpellHealingBonusDone(Unit* victim, SpellInfo const* spellProto, uint32 healamount, DamageEffectType damagetype, uint32 stack = 1);
+        uint32 SpellHealingBonusTaken(SpellInfo const* spellProto, uint32 healamount, DamageEffectType damagetype, uint32 stack = 1, uint64 casterGUID = 0);
+
+        uint32 MeleeDamageBonusDone(Unit* pVictim, uint32 damage, WeaponAttackType attType, SpellInfo const* spellProto = NULL);
+        uint32 MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage, WeaponAttackType attType, SpellInfo const* spellProto = NULL);
+
+
+        bool   isSpellBlocked(Unit* victim, SpellInfo const* spellProto, WeaponAttackType attackType = BASE_ATTACK);
+        bool   isBlockCritical();
+        bool   isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType = BASE_ATTACK, Spell* spell = NULL) const;
+        uint32 SpellCriticalDamageBonus(SpellInfo const* spellProto, uint32 damage, Unit* victim);
+        uint32 SpellCriticalHealingBonus(SpellInfo const* spellProto, uint32 damage, Unit* victim);
+
+        void SetContestedPvP(Player* attackedPlayer = NULL);
+
+        uint32 GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectType damagetype, uint32 CastingTime) const;
+        float CalculateDefaultCoefficient(SpellInfo const* spellInfo, DamageEffectType damagetype) const;
+
+        uint32 GetRemainingPeriodicAmount(uint64 caster, uint32 spellId, AuraType auraType, uint8 effectIndex = 0) const;
+
+        void ApplyUberImmune(uint32 spellid, bool apply);
+        void ApplySpellImmune(uint32 spellId, uint32 op, uint32 type, bool apply);
+        void ApplySpellDispelImmunity(const SpellInfo* spellProto, DispelType type, bool apply);
+        virtual bool IsImmunedToSpell(SpellInfo const* spellInfo, Unit* caster = NULL);
+                                                            // redefined in Creature
+        bool IsImmunedToDamage(SpellSchoolMask meleeSchoolMask);
+        bool IsImmunedToDamage(SpellInfo const* spellInfo, bool checkSchoolMask = true);
+        virtual bool IsImmunedToSpellEffect(SpellInfo const* spellInfo, uint32 index, Unit* caster = NULL) const;
+                                                            // redefined in Creature
+        static bool IsDamageReducedByArmor(SpellSchoolMask damageSchoolMask, SpellInfo const* spellInfo = NULL, uint8 effIndex = MAX_SPELL_EFFECTS);
+        uint32 CalcArmorReducedDamage(Unit* victim, const uint32 damage, SpellInfo const* spellInfo, WeaponAttackType attackType=MAX_ATTACK);
+        void CalcAbsorbResist(Unit* victim, SpellSchoolMask schoolMask, DamageEffectType damagetype, const uint32 damage, uint32 *absorb, uint32 *resist, SpellInfo const* spellInfo = NULL);
+        void CalcHealAbsorb(Unit* victim, const SpellInfo* spellProto, uint32 &healAmount, uint32 &absorb);
+
+        void  UpdateSpeed(UnitMoveType mtype, bool forced);
+        float GetSpeed(UnitMoveType mtype) const;
+        float GetSpeedRate(UnitMoveType mtype) const { return m_speed_rate[mtype]; }
+        void SetSpeed(UnitMoveType mtype, float rate, bool forced = false);
+        float m_TempSpeed;
+
+        bool isHover() const { return HasAuraType(SPELL_AURA_HOVER); }
+		bool isCamouflaged() const { return HasAuraType(SPELL_AURA_MOD_CAMOUFLAGE); }
+
+        float ApplyEffectModifiers(SpellInfo const* spellProto, uint8 effect_index, float value) const;
+        int32 CalculateSpellDamage(Unit const* target, SpellInfo const* spellProto, uint8 effect_index, int32 const* basePoints = NULL) const;
+        int32 CalcSpellDuration(SpellInfo const* spellProto);
+        int32 ModSpellDuration(SpellInfo const* spellProto, Unit const* target, int32 duration, bool positive, uint32 effectMask);
+        void  ModSpellCastTime(SpellInfo const* spellProto, int32 & castTime, Spell* spell=NULL);
+        float CalculateLevelPenalty(SpellInfo const* spellProto) const;
+
+        void addFollower(FollowerReference* pRef) { m_FollowingRefManager.insertFirst(pRef); }
+        void removeFollower(FollowerReference* /*pRef*/) { /* nothing to do yet */ }
+        static Unit* GetUnit(WorldObject& object, uint64 guid);
+        static Player* GetPlayer(WorldObject& object, uint64 guid);
+        static Player* GetPlayer(uint64 guid);
+        static Creature* GetCreature(WorldObject& object, uint64 guid);
+
+        MotionMaster* GetMotionMaster() { return &i_motionMaster; }
+        const MotionMaster* GetMotionMaster() const { return &i_motionMaster; }
+
+        bool IsStopped() const { return !(HasUnitState(UNIT_STATE_MOVING)); }
+        void StopMoving();
+
+        void AddUnitMovementFlag(uint32 f) { m_movementInfo.flags |= f; }
+        void RemoveUnitMovementFlag(uint32 f) { m_movementInfo.flags &= ~f; }
+        bool HasUnitMovementFlag(uint32 f) const { return (m_movementInfo.flags & f) == f; }
+        uint32 GetUnitMovementFlags() const { return m_movementInfo.flags; }
+        void SetUnitMovementFlags(uint32 f) { m_movementInfo.flags = f; }
+
+        void AddExtraUnitMovementFlag(uint16 f) { m_movementInfo.flags2 |= f; }
+        void RemoveExtraUnitMovementFlag(uint16 f) { m_movementInfo.flags2 &= ~f; }
+        uint16 HasExtraUnitMovementFlag(uint16 f) const { return m_movementInfo.flags2 & f; }
+        uint16 GetExtraUnitMovementFlags() const { return m_movementInfo.flags2; }
+        void SetExtraUnitMovementFlags(uint16 f) { m_movementInfo.flags2 = f; }
+        bool IsSplineEnabled() const;
+        uint32 GetSplineId() const;
+
+        float GetPositionZMinusOffset() const
+        {
+            float offset = 0.0f;
+            if (HasUnitMovementFlag(MOVEMENTFLAG_HOVER))
+                offset = GetFloatValue(UNIT_FIELD_HOVERHEIGHT);
+
+            return GetPositionZ() - offset;
+        }
+
+        void SetControlled(bool apply, UnitState state);
+
+        void AddComboPointHolder(uint32 lowguid) { m_ComboPointHolders.insert(lowguid); }
+        void RemoveComboPointHolder(uint32 lowguid) { m_ComboPointHolders.erase(lowguid); }
+        void ClearComboPointHolders();
+
+        ///----------Pet responses methods-----------------
+        void SendPetCastFail(uint8 castCount, SpellInfo const* spellInfo, SpellCastResult result);
+        void SendPetActionFeedback (uint8 msg);
+        void SendPetTalk (uint32 pettalk);
+        void SendPetAIReaction(uint64 guid);
+        ///----------End of Pet responses methods----------
+
+        void propagateSpeedChange() { GetMotionMaster()->propagateSpeedChange(); }
+
+        // reactive attacks
+        void ClearAllReactives();
+        void StartReactiveTimer(ReactiveType reactive) { m_reactiveTimer[reactive] = REACTIVE_TIMER_START;}
+        void UpdateReactives(uint32 p_time);
+
+        // group updates
+        void UpdateAuraForGroup(uint8 slot);
+
+        // proc trigger system
+        bool CanProc(){return !m_procDeep;}
+        void SetCantProc(bool apply)
+        {
+            if (apply)
+                ++m_procDeep;
+            else
+            {
+                ASSERT(m_procDeep);
+                --m_procDeep;
+            }
+        }
+
+        // pet auras
+        typedef std::set<PetAura const*> PetAuraSet;
+        PetAuraSet m_petAuras;
+        void AddPetAura(PetAura const* petSpell);
+        void RemovePetAura(PetAura const* petSpell);
+
+        uint32 GetModelForForm(ShapeshiftForm form) const;
+        uint32 GetModelForTotem(PlayerTotemType totemType);
+
+        // Redirect Threat
+        void SetRedirectThreat(uint64 guid, uint32 pct) { _redirectThreadInfo.Set(guid, pct); }
+        void ResetRedirectThreat() { SetRedirectThreat(0, 0); }
+        void ModifyRedirectThreat(int32 amount) { _redirectThreadInfo.ModifyThreatPct(amount); }
+        uint32 GetRedirectThreatPercent() { return _redirectThreadInfo.GetThreatPct(); }
+        Unit* GetRedirectThreatTarget() { return _redirectThreadInfo.GetTargetGUID() ? GetUnit(*this, _redirectThreadInfo.GetTargetGUID()) : NULL; }
+
+        friend class VehicleJoinEvent;
+        bool IsAIEnabled, NeedChangeAI;
+        bool CreateVehicleKit(uint32 id, uint32 creatureEntry);
+        void RemoveVehicleKit();
+        Vehicle* GetVehicleKit()const { return m_vehicleKit; }
+        Vehicle* GetVehicle()   const { return m_vehicle; }
+        bool IsOnVehicle(const Unit* vehicle) const { return m_vehicle && m_vehicle == vehicle->GetVehicleKit(); }
+        Unit* GetVehicleBase()  const;
+        Creature* GetVehicleCreatureBase() const;
+        float GetTransOffsetX() const { return m_movementInfo.t_pos.GetPositionX(); }
+        float GetTransOffsetY() const { return m_movementInfo.t_pos.GetPositionY(); }
+        float GetTransOffsetZ() const { return m_movementInfo.t_pos.GetPositionZ(); }
+        float GetTransOffsetO() const { return m_movementInfo.t_pos.GetOrientation(); }
+        uint32 GetTransTime()   const { return m_movementInfo.t_time; }
+        int8 GetTransSeat()     const { return m_movementInfo.t_seat; }
+        uint64 GetTransGUID()   const;
+        /// Returns the transport this unit is on directly (if on vehicle and transport, return vehicle)
+        TransportBase* GetDirectTransport() const;
+
+        bool m_ControlledByPlayer;
+
+        bool HandleSpellClick(Unit* clicker, int8 seatId = -1);
+        void EnterVehicle(Unit* base, int8 seatId = -1);
+        void ExitVehicle(Position const* exitPosition = NULL);
+        void ChangeSeat(int8 seatId, bool next = true);
+
+		void WriteMovementInfo(WorldPacket& data, Movement::ExtraMovementStatusElement* extras = NULL);
+
+        // Should only be called by AuraEffect::HandleAuraControlVehicle(AuraApplication const* auraApp, uint8 mode, bool apply) const;
+        void _ExitVehicle(Position const* exitPosition = NULL);
+        void _EnterVehicle(Vehicle* vehicle, int8 seatId, AuraApplication const* aurApp = NULL);
+        void Rio_EnterVehicle(Vehicle* vehicle, int8 seatId);
+
+        void BuildMovementPacket(ByteBuffer *data) const;
+
+        bool isMoving() const   { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_MASK_MOVING); }
+        bool isTurning() const  { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_MASK_TURNING); }
+        virtual bool CanFly() const = 0;
+        bool IsFlying() const   { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_FLYING | MOVEMENTFLAG_DISABLE_GRAVITY); }
+        void SetCanFly(bool apply);
+
+        void RewardRage(uint32 baseRage, bool attacker);
+
+        virtual float GetFollowAngle() const { return static_cast<float>(M_PI/2); }
+
+        void OutDebugInfo() const;
+        virtual bool isBeingLoaded() const { return false;}
+        bool IsDuringRemoveFromWorld() const {return m_duringRemoveFromWorld;}
+
+        Pet* ToPet() { if (isPet()) return reinterpret_cast<Pet*>(this); else return NULL; }
+        Pet const* ToPet() const { if (isPet()) return reinterpret_cast<Pet const*>(this); else return NULL; }
+
+        Totem* ToTotem() { if (isTotem()) return reinterpret_cast<Totem*>(this); else return NULL; }
+        Totem const* ToTotem() const { if (isTotem()) return reinterpret_cast<Totem const*>(this); else return NULL; }
+
+        TempSummon* ToTempSummon() { if (isSummon()) return reinterpret_cast<TempSummon*>(this); else return NULL; }
+        TempSummon const* ToTempSummon() const { if (isSummon()) return reinterpret_cast<TempSummon const*>(this); else return NULL; }
+
+        void SetTarget(uint64 guid)
+        {
+            if (!_focusSpell)
+                SetUInt64Value(UNIT_FIELD_TARGET, guid);
+        }
+
+        // Handling caster facing during spellcast
+        void FocusTarget(Spell const* focusSpell, uint64 target);
+        void ReleaseFocus(Spell const* focusSpell);
+
+        //bool IsVisionObscured(Unit* target, bool ranged = false);
+		bool IsVisionObscured(Unit* pVictim);
+
+        // Done priotiy to setCanFly in script fix visual bug with movementflag (creature took flying animation on ground, walkin animation in air etc...)
+        inline void DisableMovementFlagUpdate(bool s) { _disableMovementFlagUpdate = s; }
+        inline bool IsMovementFlagUpdateDisable() { return _disableMovementFlagUpdate; }
+
+        // MOVEMENTFLAG_HOVER in some case will be targetable by ground creatures (like nucleus for blood prince council ICC)
+        inline void SetHoverGroundTargetable(bool s) { _hoverGroundTargetable = s; }
+        inline bool IsHoverGroundTargetable() { return _hoverGroundTargetable; }
+
+        // Movement info
+        Movement::MoveSpline * movespline;
+
+        // Part of Evade mechanics
+        time_t GetLastDamagedTime() const { return _lastDamagedTime; }
+        void SetLastDamagedTime(time_t val) { _lastDamagedTime = val; }
+
+        uint32 GetGoType() const { return m_gameObjectType; }
+        void SetGoType(uint32 goType) {m_gameObjectType = goType;}
+
+        void UpdateRowCasts(uint32 spellId);
+        typedef std::map<uint32, uint8> rowCastsMap;
+        rowCastsMap _spellsCastedInRow;
+        SpellInfo const* lastSpell;
+
+		//alt power 10
+        int32 alt;
+        int32 GetAltPower() {return alt;};
+        void SetAltPower(int32 power);
+
+        inline Map const* GetBaseSwapMap() const { return _baseSwapMap; }
+
+        // Proc Target
+        uint64 GetProcTargetGuid() { return _procTargetGuid; }
+
+        // Recent damage taken
+        std::map<uint32, uint32> recentDamageTaken;
+
+        bool HasSpellCooldown(uint32 spell_id) const
+        {
+            SpellCooldowns::const_iterator itr = m_spellCooldowns.find(spell_id);
+            return itr != m_spellCooldowns.end() && itr->second.end > time(NULL);
+        }
+        void AddSpellCooldown(uint32 spellid, uint32 itemid, time_t end_time);
+        void AddSpellAndCategoryCooldowns(SpellInfo const* spellInfo, uint32 itemId, Spell* spell = NULL, bool infinityCooldown = false);
+        static uint32 const infinityCooldownDelay = MONTH;  // used for set "infinity cooldowns" for spells and check
+        static uint32 const infinityCooldownDelayCheck = MONTH/2;
+        uint32 GetSpellCooldownDelay(uint32 spell_id) const
+        {
+            SpellCooldowns::const_iterator itr = m_spellCooldowns.find(spell_id);
+            time_t t = time(NULL);
+            return uint32(itr != m_spellCooldowns.end() && itr->second.end > t ? itr->second.end - t : 0);
+        }
+        SpellCooldowns m_spellCooldowns;
+        SpellCooldowns const& GetSpellCooldownMap() const { return m_spellCooldowns; }
+        void SetRooted(bool apply);
+        void SetStunned(bool apply);
+
+    protected:
+        explicit Unit (bool isWorldObject);
+
+        UnitAI* i_AI, *i_disabledAI;
+
+        void _UpdateSpells(uint32 time);
+        void _DeleteRemovedAuras();
+
+        void _UpdateAutoRepeatSpell();
+
+        bool m_AutoRepeatFirstCast;
+
+        uint32 m_attackTimer[MAX_ATTACK];
+
+        float m_createStats[MAX_STATS];
+
+        AttackerSet m_attackers;
+        Unit* m_attacking;
+
+        DeathState m_deathState;
+
+        int32 m_procDeep;
+
+        typedef std::list<DynamicObject*> DynObjectList;
+        DynObjectList m_dynObj;
+
+        typedef std::list<GameObject*> GameObjectList;
+        GameObjectList m_gameObj;
+        bool m_isSorted;
+        uint32 m_transform;
+
+        Spell* m_currentSpells[CURRENT_MAX_SPELL];
+
+        AuraMap m_ownedAuras;
+        AuraApplicationMap m_appliedAuras;
+        AuraList m_removedAuras;
+        AuraMap::iterator m_auraUpdateIterator;
+        uint32 m_removedAurasCount;
+
+        AuraEffectList m_modAuras[TOTAL_AURAS];
+        AuraList m_scAuras;                        // casted singlecast auras
+        AuraApplicationList m_interruptableAuras;             // auras which have interrupt mask applied on unit
+        AuraStateAurasMap m_auraStateAuras;        // Used for improve performance of aura state checks on aura apply/remove
+        uint32 m_interruptMask;
+
+        float m_auraModifiersGroup[UNIT_MOD_END][MODIFIER_TYPE_END];
+        float m_weaponDamage[MAX_ATTACK][2];
+        bool m_canModifyStats;
+        VisibleAuraMap m_visibleAuras;
+
+        float m_speed_rate[MAX_MOVE_TYPE];
+
+        CharmInfo* m_charmInfo;
+        SharedVisionList m_sharedVision;
+
+        virtual SpellSchoolMask GetMeleeDamageSchoolMask() const;
+
+        MotionMaster i_motionMaster;
+
+        uint32 m_reactiveTimer[MAX_REACTIVE];
+        uint32 m_regenTimer;
+
+        ThreatManager m_ThreatManager;
+
+        Vehicle* m_vehicle;
+        Vehicle* m_vehicleKit;
+
+        uint32 m_unitTypeMask;
+        LiquidTypeEntry const* _lastLiquid;
+		
+        bool m_IsInKillingProcess;		
+
+        bool IsAlwaysVisibleFor(WorldObject const* seer) const;
+        bool IsAlwaysDetectableFor(WorldObject const* seer) const;
+
+        void DisableSpline();
+
+        PhaseDefinitionStore const* _PhaseDefinitionStore;
+        std::list<uint32> m_soulSwapDotsList;
+
+        uint64 m_soulSwapTargetGuid;
+
+        // ProcTarget
+        uint64 _procTargetGuid;
+
+    private:
+        bool IsTriggeredAtSpellProcEvent(Unit* victim, Aura* aura, SpellInfo const* procSpell, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, bool isVictim, bool active, SpellProcEventEntry const* & spellProcEvent);
+        bool HandleAuraProcOnPowerAmount(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown);
+        bool HandleDummyAuraProc(Unit* victim, uint32 damage, uint32 absorb, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown, SpellInfo const* interruptedSpell, bool procSpellIsHeal, bool onCast = false);
+        bool HandleAuraProc(Unit* victim, uint32 damage, Aura* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown, bool * handled);
+        bool HandleProcTriggerSpell(Unit* victim, uint32 damage, uint32 absorb, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown);
+        bool HandleOverrideClassScriptAuraProc(Unit* victim, uint32 damage, AuraEffect* triggeredByAura, SpellInfo const* procSpell, uint32 cooldown);
+        bool HandleAuraRaidProcFromChargeWithValue(AuraEffect* triggeredByAura);
+        bool HandleAuraRaidProcFromCharge(AuraEffect* triggeredByAura);
+
+        void UpdateSplineMovement(uint32 t_diff);
+        void UpdateSplinePosition();
+
+        // player or player's pet
+        float GetCombatRatingReduction(CombatRating cr) const;
+        uint32 GetCombatRatingDamageReduction(CombatRating cr, float rate, float cap, uint32 damage) const;
+
+    protected:
+        void SendMoveRoot();
+        void SendMoveUnroot();
+        void SetFeared(bool apply);
+        void SetConfused(bool apply);
+
+        uint32 m_movementCounter;       ///< Incrementing counter used in movement packets
+
+    private:
+        uint32 m_state;                                     // Even derived shouldn't modify
+        uint32 m_CombatTimer;
+        TimeTrackerSmall m_movesplineTimer;
+
+        Diminishing m_Diminishing;
+        // Manage all Units that are threatened by us
+        HostileRefManager m_HostileRefManager;
+
+        FollowerRefManager m_FollowingRefManager;
+
+        ComboPointHolderSet m_ComboPointHolders;
+
+        RedirectThreatInfo _redirectThreadInfo;
+
+        bool m_cleanupDone; // lock made to not add stuff after cleanup before delete
+        bool m_duringRemoveFromWorld; // lock made to not add stuff after begining removing from world
+
+        Spell const* _focusSpell;   ///> Locks the target during spell cast for proper facing
+        bool _isWalkingBeforeCharm; // Are we walking before we were charmed?
+
+        time_t _lastDamagedTime; // Part of Evade mechanics
+
+        bool _disableMovementFlagUpdate; // Disable dynamic update movementflag
+
+        bool _hoverGroundTargetable; // make hover creature targetable by ground player/creature
+
+        const Map *_baseSwapMap;
+
+        // used for triggers which cast spells for gos
+        uint32 m_gameObjectType;
+};
+
+namespace Trinity
+{
+    // Binary predicate for sorting Units based on percent value of a power
+    class PowerPctOrderPred
+    {
+        public:
+            PowerPctOrderPred(Powers power, bool ascending = true) : _power(power), _ascending(ascending) { }
+
+            bool operator()(WorldObject const* objA, WorldObject const* objB) const
+            {
+                Unit const* a = objA->ToUnit();
+                Unit const* b = objB->ToUnit();
+                float rA = (a && a->GetMaxPower(_power)) ? float(a->GetPower(_power)) / float(a->GetMaxPower(_power)) : 0.0f;
+                float rB = (b && b->GetMaxPower(_power)) ? float(b->GetPower(_power)) / float(b->GetMaxPower(_power)) : 0.0f;
+                return _ascending ? rA < rB : rA > rB;
+            }
+
+            bool operator()(Unit const* a, Unit const* b) const
+            {
+                float rA = a->GetMaxPower(_power) ? float(a->GetPower(_power)) / float(a->GetMaxPower(_power)) : 0.0f;
+                float rB = b->GetMaxPower(_power) ? float(b->GetPower(_power)) / float(b->GetMaxPower(_power)) : 0.0f;
+                return _ascending ? rA < rB : rA > rB;
+            }
+
+        private:
+            Powers const _power;
+            bool const _ascending;
+    };
+
+    // Binary predicate for sorting Units based on percent value of health
+    class HealthPctOrderPred
+    {
+        public:
+            HealthPctOrderPred(bool ascending = true) : _ascending(ascending) { }
+
+            bool operator()(WorldObject const* objA, WorldObject const* objB) const
+            {
+                Unit const* a = objA->ToUnit();
+                Unit const* b = objB->ToUnit();
+                float rA = (a && a->GetMaxHealth()) ? float(a->GetHealth()) / float(a->GetMaxHealth()) : 0.0f;
+                float rB = (b && b->GetMaxHealth()) ? float(b->GetHealth()) / float(b->GetMaxHealth()) : 0.0f;
+                return _ascending ? rA < rB : rA > rB;
+            }
+
+            bool operator() (Unit const* a, Unit const* b) const
+            {
+                float rA = a->GetMaxHealth() ? float(a->GetHealth()) / float(a->GetMaxHealth()) : 0.0f;
+                float rB = b->GetMaxHealth() ? float(b->GetHealth()) / float(b->GetMaxHealth()) : 0.0f;
+                return _ascending ? rA < rB : rA > rB;
+            }
+
+        private:
+            bool const _ascending;
+    };
+}
+#endif
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 1dec951..d93228b 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -1240,6 +1240,9 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     //
     // End of prepatch
     delete holder;
+
+    if (pCurrChar->GetTeam() != pCurrChar->GetOTeam())
+        pCurrChar->FitPlayerInTeam(pCurrChar->GetBattleground() && !pCurrChar->GetBattleground()->isArena() ? true : false, pCurrChar->GetBattleground());
 }
     // Prepatch by LordPsyan
     // 21
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index d1f7946..6b52f41 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -92,6 +92,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             return;
     }
 
+    if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) && lang != LANG_ADDON)
+    {
+        switch (type)
+        {
+        case CHAT_MSG_BATTLEGROUND:
+        case CHAT_MSG_BATTLEGROUND_LEADER:
+            lang = LANG_UNIVERSAL;
+        default:
+            break;
+        }
+    }
+
     if (type >= MAX_CHAT_MSG_TYPE)
     {
         sLog->outError(LOG_FILTER_NETWORKIO, "CHAT: Wrong message type received: %u", type);
@@ -305,6 +317,10 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
             }
 
+            if (!GetPlayer()->isGameMaster())
+                if (GetPlayer()->SendBattleGroundChat(type, msg))
+                    return;
+
             if (type == CHAT_MSG_SAY)
                 sender->Say(msg, lang);
             else if (type == CHAT_MSG_EMOTE)
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index f2f4230..76aa4c8 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -1483,6 +1483,21 @@ void WorldSession::HandleSetTitleOpcode(WorldPacket& recvData)
 
 void WorldSession::HandleTimeSyncResp(WorldPacket& recvData)
 {
+    Battleground* bg = _player->GetBattleground();
+    if (bg)
+    {
+        if (_player->ShouldForgetBGPlayers() && bg)
+        {
+            _player->DoForgetPlayersInBG(bg);
+            _player->SetForgetBGPlayers(false);
+        }
+    }
+    else if (_player->ShouldForgetInListPlayers())
+    {
+        _player->DoForgetPlayersInList();
+        _player->SetForgetInListPlayers(false);
+    }
+
     sLog->outDebug(LOG_FILTER_NETWORKIO, "CMSG_TIME_SYNC_RESP");
 
     uint32 counter, clientTicks;
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 06347ef..dc964c5 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1092,6 +1092,7 @@ void World::LoadConfigSettings(bool reload)
         m_int_configs[CONFIG_ARENA_SEASON_ID] = 1;
 
     m_bool_configs[CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN]            = ConfigMgr::GetBoolDefault("OffhandCheckAtSpellUnlearn", true);
+    m_bool_configs[BATTLEGROUND_CROSSFACTION_ENABLED]                = ConfigMgr::GetBoolDefault("CrossfactionBG.enable", true);
 
     if (int32 clientCacheId = ConfigMgr::GetIntDefault("ClientCacheVersion", 0))
     {
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 339f497..f2d75db 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -106,6 +106,7 @@ enum CronjobType
 enum WorldBoolConfigs
 {
     CONFIG_DURABILITY_LOSS_IN_PVP = 0,
+    BATTLEGROUND_CROSSFACTION_ENABLED,
     CONFIG_ADDON_CHANNEL,
     CONFIG_ALLOW_PLAYER_COMMANDS,
     CONFIG_CLEAN_CHARACTER_DB,
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index f0bef59..b28d05f 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -3219,6 +3219,18 @@ DuelReset.Area.Two = NULL
 #
 ###################################################################################################
 
+###################################################################################################
+#
+# CROSSFACTION BG CONFIG
+#
+#    CrossfactionBG.enable = 1 - Mixed battleground enabled.
+#    CrossfactionBG.enable = 0 - Mixed battleground disabled.
+
+CrossfactionBG.enable = 1
+
+#
+###################################################################################################
+
 #
 # Prepatch by LordPsyan.
 # See http://www.realmsofwarcraft.com/bb for forums and information.
-- 
1.7.10.4

