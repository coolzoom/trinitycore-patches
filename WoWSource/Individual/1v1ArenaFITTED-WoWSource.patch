From ab9ea8f73f586c0e4c3ac8481392c9189a9d6663 Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Sat, 5 Sep 2015 09:38:27 -0500
Subject: [PATCH] 1v1ArenaFITTED-WoWSource

---
 .../arena1v1/character_v2.0.sql                    |    2 +
 sql/TrinityCore-Patches/arena1v1/world_v1.0.sql    |    3 +
 src/server/game/Battlegrounds/ArenaTeam.cpp        |    2 +-
 src/server/game/Battlegrounds/ArenaTeam.cpp.orig   |  882 +
 src/server/game/Battlegrounds/ArenaTeam.h          |    2 +-
 src/server/game/Battlegrounds/ArenaTeam.h.orig     |  196 +
 src/server/game/Battlegrounds/Battleground.cpp     |    5 +
 .../game/Battlegrounds/Battleground.cpp.orig       | 2096 ++
 src/server/game/Battlegrounds/Battleground.h       |    2 +-
 src/server/game/Battlegrounds/Battleground.h.orig  |  682 +
 src/server/game/Battlegrounds/BattlegroundMgr.cpp  |    2 +-
 .../game/Battlegrounds/BattlegroundMgr.cpp.orig    | 1517 ++
 .../game/Battlegrounds/BattlegroundQueue.cpp       |    2 +
 .../game/Battlegrounds/BattlegroundQueue.cpp.orig  | 1076 +
 src/server/game/Entities/Player/Player.cpp         |    1 +
 src/server/game/Entities/Player/Player.cpp.orig    |28083 ++++++++++++++++++++
 src/server/game/Handlers/BattleGroundHandler.cpp   |    5 +
 .../game/Handlers/BattleGroundHandler.cpp.orig     |  911 +
 src/server/game/Handlers/PetitionsHandler.cpp      |    4 +-
 src/server/game/Handlers/PetitionsHandler.cpp.orig |  978 +
 src/server/game/Scripting/ScriptLoader.cpp         |    4 +
 src/server/game/Scripting/ScriptLoader.cpp.orig    | 1606 ++
 src/server/game/World/World.cpp                    |    7 +
 src/server/game/World/World.cpp.orig               | 3697 +++
 src/server/game/World/World.h                      |    7 +
 src/server/game/World/World.h.orig                 |  926 +
 src/server/scripts/Custom/npc_arena1v1.cpp         |  309 +
 src/server/scripts/Custom/npc_arena1v1.h           |   69 +
 src/server/worldserver/worldserver.conf.dist       |   65 +
 src/server/worldserver/worldserver.conf.dist.orig  | 3195 +++
 30 files changed, 46331 insertions(+), 5 deletions(-)
 create mode 100644 sql/TrinityCore-Patches/arena1v1/character_v2.0.sql
 create mode 100644 sql/TrinityCore-Patches/arena1v1/world_v1.0.sql
 create mode 100644 src/server/game/Battlegrounds/ArenaTeam.cpp.orig
 create mode 100644 src/server/game/Battlegrounds/ArenaTeam.h.orig
 create mode 100644 src/server/game/Battlegrounds/Battleground.cpp.orig
 create mode 100644 src/server/game/Battlegrounds/Battleground.h.orig
 create mode 100644 src/server/game/Battlegrounds/BattlegroundMgr.cpp.orig
 create mode 100644 src/server/game/Battlegrounds/BattlegroundQueue.cpp.orig
 create mode 100644 src/server/game/Entities/Player/Player.cpp.orig
 create mode 100644 src/server/game/Handlers/BattleGroundHandler.cpp.orig
 create mode 100644 src/server/game/Handlers/PetitionsHandler.cpp.orig
 create mode 100644 src/server/game/Scripting/ScriptLoader.cpp.orig
 create mode 100644 src/server/game/World/World.cpp.orig
 create mode 100644 src/server/game/World/World.h.orig
 create mode 100644 src/server/scripts/Custom/npc_arena1v1.cpp
 create mode 100644 src/server/scripts/Custom/npc_arena1v1.h
 create mode 100644 src/server/worldserver/worldserver.conf.dist.orig

diff --git a/sql/TrinityCore-Patches/arena1v1/character_v2.0.sql b/sql/TrinityCore-Patches/arena1v1/character_v2.0.sql
new file mode 100644
index 0000000..9f6e4a4
--- /dev/null
+++ b/sql/TrinityCore-Patches/arena1v1/character_v2.0.sql
@@ -0,0 +1,2 @@
+-- Delete all 5v5 teams and members (core will crash if any 5v5 team exist)
+DELETE arena_team_member, arena_team FROM arena_team_member, arena_team WHERE arena_team_member.arenaTeamId = arena_team.arenaTeamId AND arena_team.type = 5;
diff --git a/sql/TrinityCore-Patches/arena1v1/world_v1.0.sql b/sql/TrinityCore-Patches/arena1v1/world_v1.0.sql
new file mode 100644
index 0000000..75d4337
--- /dev/null
+++ b/sql/TrinityCore-Patches/arena1v1/world_v1.0.sql
@@ -0,0 +1,3 @@
+DELETE FROM `creature_template` WHERE `entry` = 535200;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES
+('535200','0','0','0','0','0','18','0','18','0','LordPsyan','1v1 Arena master','','0','59','61','0','35','1','1.48','1.14286','0','0','0','1500','1900','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','3','1','1','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','npc_1v1arena','1');
diff --git a/src/server/game/Battlegrounds/ArenaTeam.cpp b/src/server/game/Battlegrounds/ArenaTeam.cpp
index 6951436..922c357 100644
--- a/src/server/game/Battlegrounds/ArenaTeam.cpp
+++ b/src/server/game/Battlegrounds/ArenaTeam.cpp
@@ -406,7 +406,7 @@ void ArenaTeam::Query(WorldSession* session)
     WorldPacket data(SMSG_ARENA_TEAM_QUERY_RESPONSE, 4*7+GetName().size()+1);
     data << uint32(GetId());                                // team id
     data << GetName();                                      // team name
-    data << uint32(GetType());                              // arena team type (2=2x2, 3=3x3 or 5=5x5)
+    data << uint32(GetType() == 1 ? 5 : GetType());         // arena team type (2=2x2, 3=3x3 or 1=1x1(modify 1 to 5, so player can see arenateam in 5v5 slot))
     data << uint32(BackgroundColor);                        // background color
     data << uint32(EmblemStyle);                            // emblem style
     data << uint32(EmblemColor);                            // emblem color
diff --git a/src/server/game/Battlegrounds/ArenaTeam.cpp.orig b/src/server/game/Battlegrounds/ArenaTeam.cpp.orig
new file mode 100644
index 0000000..6951436
--- /dev/null
+++ b/src/server/game/Battlegrounds/ArenaTeam.cpp.orig
@@ -0,0 +1,882 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "ArenaTeam.h"
+#include "World.h"
+#include "Group.h"
+#include "ArenaTeamMgr.h"
+#include "Player.h"
+#include "WorldSession.h"
+#include "Opcodes.h"
+#include "InfoMgr.h"
+
+ArenaTeam::ArenaTeam()
+    : TeamId(0), Type(0), TeamName(), CaptainGuid(0), BackgroundColor(0), EmblemStyle(0), EmblemColor(0),
+    BorderStyle(0), BorderColor(0)
+{
+    Stats.WeekGames   = 0;
+    Stats.SeasonGames = 0;
+    Stats.Rank        = 0;
+    Stats.Rating      = sWorld->getIntConfig(CONFIG_ARENA_START_RATING);
+    Stats.WeekWins    = 0;
+    Stats.SeasonWins  = 0;
+}
+
+ArenaTeam::~ArenaTeam()
+{ }
+
+bool ArenaTeam::Create(uint64 captainGuid, uint8 type, std::string const& arenaTeamName,
+                                         uint32 backgroundColor, uint8 emblemStyle, uint32 emblemColor,
+                                         uint8 borderStyle, uint32 borderColor)
+{
+    // Check if captain is present
+    if (!ObjectAccessor::FindPlayer(captainGuid))
+        return false;
+
+    // Check if arena team name is already taken
+    if (sArenaTeamMgr->GetArenaTeamByName(arenaTeamName))
+        return false;
+
+    // Generate new arena team id
+    TeamId = sArenaTeamMgr->GenerateArenaTeamId();
+
+    // Assign member variables
+    CaptainGuid = captainGuid;
+    Type = type;
+    TeamName = arenaTeamName;
+    BackgroundColor = backgroundColor;
+    EmblemStyle = emblemStyle;
+    EmblemColor = emblemColor;
+    BorderStyle = borderStyle;
+    BorderColor = borderColor;
+    uint32 captainLowGuid = GUID_LOPART(captainGuid);
+
+    // Save arena team to db
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ARENA_TEAM);
+    stmt->setUInt32(0, TeamId);
+    stmt->setString(1, TeamName);
+    stmt->setUInt32(2, captainLowGuid);
+    stmt->setUInt8(3, Type);
+    stmt->setUInt16(4, Stats.Rating);
+    stmt->setUInt32(5, BackgroundColor);
+    stmt->setUInt8(6, EmblemStyle);
+    stmt->setUInt32(7, EmblemColor);
+    stmt->setUInt8(8, BorderStyle);
+    stmt->setUInt32(9, BorderColor);
+    CharacterDatabase.Execute(stmt);
+
+    // Add captain as member
+    AddMember(CaptainGuid);
+
+    sLog->outDebug(LOG_FILTER_ARENAS, "New ArenaTeam created [Id: %u] [Type: %u] [Captain low GUID: %u]", GetId(), GetType(), captainLowGuid);
+    return true;
+}
+
+bool ArenaTeam::AddMember(uint64 playerGuid)
+{
+    std::string playerName;
+    uint8 playerClass;
+
+    // Check if arena team is full (Can't have more than type * 2 players)
+    if (GetMembersSize() >= GetType() * 2)
+        return false;
+
+    // Get player name and class either from db or ObjectMgr
+    Player* player = ObjectAccessor::FindPlayer(playerGuid);
+    if (player)
+    {
+        playerClass = player->getClass();
+        playerName = player->GetName();
+    }
+    else
+    {
+        //          0     1
+        // SELECT name, class FROM characters WHERE guid = ?
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_NAME_CLASS);
+        stmt->setUInt32(0, GUID_LOPART(playerGuid));
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+        if (!result)
+            return false;
+
+        playerName = (*result)[0].GetString();
+        playerClass = (*result)[1].GetUInt8();
+    }
+
+    // Check if player is already in a similar arena team
+    if ((player && player->GetArenaTeamId(GetSlot())) || Player::GetArenaTeamIdFromDB(playerGuid, GetType()) != 0)
+    {
+        sLog->outDebug(LOG_FILTER_ARENAS, "Arena: Player %s (guid: %u) already has an arena team of type %u", playerName.c_str(), GUID_LOPART(playerGuid), GetType());
+        return false;
+    }
+
+    // Set player's personal rating
+    uint32 personalRating = 0;
+
+    if (sWorld->getIntConfig(CONFIG_ARENA_START_PERSONAL_RATING) > 0)
+        personalRating = sWorld->getIntConfig(CONFIG_ARENA_START_PERSONAL_RATING);
+    else if (GetRating() >= 1000)
+        personalRating = 1000;
+
+    // Try to get player's match maker rating from db and fall back to config setting if not found
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MATCH_MAKER_RATING);
+    stmt->setUInt32(0, GUID_LOPART(playerGuid));
+    stmt->setUInt8(1, GetSlot());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    uint32 matchMakerRating;
+    if (result)
+        matchMakerRating = (*result)[0].GetUInt16();
+    else
+        matchMakerRating = sWorld->getIntConfig(CONFIG_ARENA_START_MATCHMAKER_RATING);
+
+    // Remove all player signatures from other petitions
+    // This will prevent player from joining too many arena teams and corrupt arena team data integrity
+    Player::RemovePetitionsAndSigns(playerGuid, GetType());
+
+    // Feed data to the struct
+    ArenaTeamMember newMember;
+    newMember.Name             = playerName;
+    newMember.Guid             = playerGuid;
+    newMember.Class            = playerClass;
+    newMember.SeasonGames      = 0;
+    newMember.WeekGames        = 0;
+    newMember.SeasonWins       = 0;
+    newMember.WeekWins         = 0;
+    newMember.PersonalRating   = personalRating;
+    newMember.MatchMakerRating = matchMakerRating;
+
+    Members.push_back(newMember);
+
+    // Save player's arena team membership to db
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ARENA_TEAM_MEMBER);
+    stmt->setUInt32(0, TeamId);
+    stmt->setUInt32(1, GUID_LOPART(playerGuid));
+    CharacterDatabase.Execute(stmt);
+    sInfoMgr->UpdateCharArenaTeam(GUID_LOPART(playerGuid), TeamId, GetSlot());
+
+    // Inform player if online
+    if (player)
+    {
+        player->SetInArenaTeam(TeamId, GetSlot(), GetType());
+        player->SetArenaTeamIdInvited(0);
+
+        // Hide promote/remove buttons
+        if (CaptainGuid != playerGuid)
+            player->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_MEMBER, 1);
+    }
+
+    sLog->outDebug(LOG_FILTER_ARENAS, "Player: %s [GUID: %u] joined arena team type: %u [Id: %u, Name: %s].", playerName.c_str(), GUID_LOPART(playerGuid), GetType(), GetId(), GetName().c_str());
+
+    return true;
+}
+
+bool ArenaTeam::LoadArenaTeamFromDB(QueryResult result)
+{
+    if (!result)
+        return false;
+
+    Field* fields = result->Fetch();
+
+    TeamId            = fields[0].GetUInt32();
+    TeamName          = fields[1].GetString();
+    CaptainGuid       = MAKE_NEW_GUID(fields[2].GetUInt32(), 0, HIGHGUID_PLAYER);
+    Type              = fields[3].GetUInt8();
+    BackgroundColor   = fields[4].GetUInt32();
+    EmblemStyle       = fields[5].GetUInt8();
+    EmblemColor       = fields[6].GetUInt32();
+    BorderStyle       = fields[7].GetUInt8();
+    BorderColor       = fields[8].GetUInt32();
+    Stats.Rating      = fields[9].GetUInt16();
+    Stats.WeekGames   = fields[10].GetUInt16();
+    Stats.WeekWins    = fields[11].GetUInt16();
+    Stats.SeasonGames = fields[12].GetUInt16();
+    Stats.SeasonWins  = fields[13].GetUInt16();
+    Stats.Rank        = fields[14].GetUInt32();
+
+    return true;
+}
+
+bool ArenaTeam::LoadMembersFromDB(QueryResult result)
+{
+    if (!result)
+        return false;
+
+    bool captainPresentInTeam = false;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        // Prevent crash if db records are broken when all members in result are already processed and current team doesn't have any members
+        if (!fields)
+            break;
+
+        uint32 arenaTeamId = fields[0].GetUInt32();
+
+        // We loaded all members for this arena_team already, break cycle
+        if (arenaTeamId > TeamId)
+            break;
+
+        ArenaTeamMember newMember;
+        newMember.Guid             = MAKE_NEW_GUID(fields[1].GetUInt32(), 0, HIGHGUID_PLAYER);
+        newMember.WeekGames        = fields[2].GetUInt16();
+        newMember.WeekWins         = fields[3].GetUInt16();
+        newMember.SeasonGames      = fields[4].GetUInt16();
+        newMember.SeasonWins       = fields[5].GetUInt16();
+        newMember.Name             = fields[6].GetString();
+        newMember.Class            = fields[7].GetUInt8();
+        newMember.PersonalRating   = fields[8].GetUInt16();
+        newMember.MatchMakerRating = fields[9].GetUInt16() > 0 ? fields[9].GetUInt16() : 1500;
+
+        // Delete member if character information is missing
+        if (newMember.Name.empty())
+        {
+            sLog->outError(LOG_FILTER_SQL, "ArenaTeam %u has member with empty name - probably player %u doesn't exist, deleting him from memberlist!", arenaTeamId, GUID_LOPART(newMember.Guid));
+            DelMember(newMember.Guid, true);
+            continue;
+        }
+
+        // Check if team team has a valid captain
+        if (newMember.Guid == GetCaptain())
+            captainPresentInTeam = true;
+
+        // Put the player in the team
+        Members.push_back(newMember);
+    }
+    while (result->NextRow());
+
+    if (Empty() || !captainPresentInTeam)
+    {
+        // Arena team is empty or captain is not in team, delete from db
+        sLog->outDebug(LOG_FILTER_ARENAS, "ArenaTeam %u does not have any members or its captain is not in team, disbanding it...", TeamId);
+        return false;
+    }
+
+    return true;
+}
+
+void ArenaTeam::SetCaptain(uint64 guid)
+{
+    // Disable remove/promote buttons
+    Player* oldCaptain = ObjectAccessor::FindPlayer(GetCaptain());
+    if (oldCaptain)
+        oldCaptain->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_MEMBER, 1);
+
+    // Set new captain
+    CaptainGuid = guid;
+
+    // Update database
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ARENA_TEAM_CAPTAIN);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    stmt->setUInt32(1, GetId());
+    CharacterDatabase.Execute(stmt);
+
+    // Enable remove/promote buttons
+    if (Player* newCaptain = ObjectAccessor::FindPlayer(guid))
+    {
+        newCaptain->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_MEMBER, 0);
+        if (oldCaptain)
+        {
+            sLog->outDebug(LOG_FILTER_ARENAS, "Player: %s [GUID: %u] promoted player: %s [GUID: %u] to leader of arena team [Id: %u] [Type: %u].",
+                oldCaptain->GetName().c_str(), oldCaptain->GetGUIDLow(), newCaptain->GetName().c_str(),
+                newCaptain->GetGUIDLow(), GetId(), GetType());
+        }
+    }
+}
+
+void ArenaTeam::DelMember(uint64 guid, bool cleanDb)
+{
+    // Remove member from team
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
+        if (itr->Guid == guid)
+        {
+            Members.erase(itr);
+            break;
+        }
+
+    // Remove arena team info from player data
+    if (Player* player = ObjectAccessor::FindPlayer(guid))
+    {
+        // delete all info regarding this team
+        player->DeleteArenaTeam(GetSlot(), true);
+        sLog->outDebug(LOG_FILTER_ARENAS, "Player: %s [GUID: %u] left arena team type: %u [Id: %u].", player->GetName().c_str(), player->GetGUIDLow(), GetType(), GetId());
+    }
+
+    sInfoMgr->UpdateCharArenaTeam(GUID_LOPART(guid), 0, GetSlot());
+
+    // Only used for single member deletion, for arena team disband we use a single query for more efficiency
+    if (cleanDb)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ARENA_TEAM_MEMBER);
+        stmt->setUInt32(0, GetId());
+        stmt->setUInt32(1, GUID_LOPART(guid));
+        CharacterDatabase.Execute(stmt);
+    }
+}
+
+void ArenaTeam::Disband(WorldSession* session)
+{
+    // Broadcast update
+    if (session)
+    {
+        BroadcastEvent(ERR_ARENA_TEAM_DISBANDED_S, 0, 2, session->GetPlayerName(), GetName(), "");
+        if (Player* player = session->GetPlayer())
+            sLog->outDebug(LOG_FILTER_ARENAS, "Player: %s [GUID: %u] disbanded arena team type: %u [Id: %u].", player->GetName().c_str(), player->GetGUIDLow(), GetType(), GetId());
+    }
+
+    // Remove all members from arena team
+    while (!Members.empty())
+        DelMember(Members.front().Guid, false);
+
+    // Update database
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ARENA_TEAM);
+    stmt->setUInt32(0, TeamId);
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ARENA_TEAM_MEMBERS);
+    stmt->setUInt32(0, TeamId);
+    trans->Append(stmt);
+
+    CharacterDatabase.CommitTransaction(trans);
+
+    // Remove arena team from ObjectMgr
+    sArenaTeamMgr->RemoveArenaTeam(TeamId);
+}
+
+void ArenaTeam::Roster(WorldSession* session)
+{
+    Player* player = NULL;
+
+    uint8 unk308 = 0;
+
+    WorldPacket data(SMSG_ARENA_TEAM_ROSTER, 100);
+    data << uint32(GetId());                                // team id
+    data << uint8(unk308);                                  // 308 unknown value but affect packet structure
+    data << uint32(GetMembersSize());                       // members count
+    data << uint32(GetType());                              // arena team type?
+
+    for (MemberList::const_iterator itr = Members.begin(); itr != Members.end(); ++itr)
+    {
+        player = ObjectAccessor::FindPlayer(itr->Guid);
+
+        data << uint64(itr->Guid);                          // guid
+        data << uint8((player ? 1 : 0));                        // online flag
+        data << itr->Name;                                  // member name
+        data << uint32((itr->Guid == GetCaptain() ? 0 : 1));// captain flag 0 captain 1 member
+        data << uint8((player ? player->getLevel() : 0));           // unknown, level?
+        data << uint8(itr->Class);                          // class
+        data << uint32(itr->WeekGames);                    // played this week
+        data << uint32(itr->WeekWins);                     // wins this week
+        data << uint32(itr->SeasonGames);                  // played this season
+        data << uint32(itr->SeasonWins);                   // wins this season
+        data << uint32(itr->PersonalRating);               // personal rating
+        if (unk308)
+        {
+            data << float(0.0f);                           // 308 unk
+            data << float(0.0f);                           // 308 unk
+        }
+    }
+
+    session->SendPacket(&data);
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_ARENA_TEAM_ROSTER");
+}
+
+void ArenaTeam::Query(WorldSession* session)
+{
+    WorldPacket data(SMSG_ARENA_TEAM_QUERY_RESPONSE, 4*7+GetName().size()+1);
+    data << uint32(GetId());                                // team id
+    data << GetName();                                      // team name
+    data << uint32(GetType());                              // arena team type (2=2x2, 3=3x3 or 5=5x5)
+    data << uint32(BackgroundColor);                        // background color
+    data << uint32(EmblemStyle);                            // emblem style
+    data << uint32(EmblemColor);                            // emblem color
+    data << uint32(BorderStyle);                            // border style
+    data << uint32(BorderColor);                            // border color
+    session->SendPacket(&data);
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_ARENA_TEAM_QUERY_RESPONSE");
+}
+
+void ArenaTeam::SendStats(WorldSession* session)
+{
+    WorldPacket data(SMSG_ARENA_TEAM_STATS, 4*7);
+    data << uint32(GetId());                                // team id
+    data << uint32(Stats.Rating);                           // rating
+    data << uint32(Stats.WeekGames);                        // games this week
+    data << uint32(Stats.WeekWins);                         // wins this week
+    data << uint32(Stats.SeasonGames);                      // played this season
+    data << uint32(Stats.SeasonWins);                       // wins this season
+    data << uint32(Stats.Rank);                             // rank
+    session->SendPacket(&data);
+}
+
+void ArenaTeam::NotifyStatsChanged()
+{
+    // This is called after a rated match ended
+    // Updates arena team stats for every member of the team (not only the ones who participated!)
+    for (MemberList::const_iterator itr = Members.begin(); itr != Members.end(); ++itr)
+        if (Player* player = ObjectAccessor::FindPlayer(itr->Guid))
+            SendStats(player->GetSession());
+}
+
+void ArenaTeam::Inspect(WorldSession* session, uint64 guid)
+{
+    ArenaTeamMember* member = GetMember(guid);
+    if (!member)
+        return;
+
+    WorldPacket data(MSG_INSPECT_ARENA_TEAMS, 8+1+4*6);
+    data << uint64(guid);                                   // player guid
+    data << uint8(GetSlot());                               // slot (0...2)
+    data << uint32(GetId());                                // arena team id
+    data << uint32(Stats.Rating);                           // rating
+    data << uint32(Stats.SeasonGames);                      // season played
+    data << uint32(Stats.SeasonWins);                       // season wins
+    data << uint32(member->SeasonGames);                    // played (count of all games, that the inspected member participated...)
+    data << uint32(member->PersonalRating);                 // personal rating
+    session->SendPacket(&data);
+}
+
+void ArenaTeamMember::ModifyPersonalRating(Player* player, int32 mod, uint32 type)
+{
+    if (int32(PersonalRating) + mod < 0)
+        PersonalRating = 0;
+    else
+        PersonalRating += mod;
+
+    if (player)
+    {
+        player->SetArenaTeamInfoField(ArenaTeam::GetSlotByType(type), ARENA_TEAM_PERSONAL_RATING, PersonalRating);
+        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_PERSONAL_RATING, PersonalRating, type);
+    }
+}
+
+void ArenaTeamMember::ModifyMatchmakerRating(int32 mod, uint32 /*slot*/)
+{
+    if (int32(MatchMakerRating) + mod < 0)
+        MatchMakerRating = 0;
+    else
+        MatchMakerRating += mod;
+}
+
+void ArenaTeam::BroadcastPacket(WorldPacket* packet)
+{
+    for (MemberList::const_iterator itr = Members.begin(); itr != Members.end(); ++itr)
+        if (Player* player = ObjectAccessor::FindPlayer(itr->Guid))
+            player->GetSession()->SendPacket(packet);
+}
+
+void ArenaTeam::BroadcastEvent(ArenaTeamEvents event, uint64 guid, uint8 strCount, std::string const& str1, std::string const& str2, std::string const& str3)
+{
+    WorldPacket data(SMSG_ARENA_TEAM_EVENT, 1+1+1);
+    data << uint8(event);
+    data << uint8(strCount);
+    switch (strCount)
+    {
+        case 0:
+            break;
+        case 1:
+            data << str1;
+            break;
+        case 2:
+            data << str1 << str2;
+            break;
+        case 3:
+            data << str1 << str2 << str3;
+            break;
+        default:
+            sLog->outError(LOG_FILTER_ARENAS, "Unhandled strCount %u in ArenaTeam::BroadcastEvent", strCount);
+            return;
+    }
+
+    if (guid)
+        data << uint64(guid);
+
+    BroadcastPacket(&data);
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_ARENA_TEAM_EVENT");
+}
+
+void ArenaTeam::MassInviteToEvent(WorldSession* session)
+{
+    WorldPacket data(SMSG_CALENDAR_ARENA_TEAM, (Members.size() - 1) * (4 + 8 + 1));
+    data << uint32(Members.size() - 1);
+
+    for (MemberList::const_iterator itr = Members.begin(); itr != Members.end(); ++itr)
+    {
+        if (itr->Guid != session->GetPlayer()->GetGUID())
+        {
+            data.appendPackGUID(itr->Guid);
+            data << uint8(0); // unk
+        }
+    }
+
+    session->SendPacket(&data);
+}
+
+uint8 ArenaTeam::GetSlotByType(uint32 type)
+{
+    switch (type)
+    {
+        case ARENA_TEAM_2v2: return 0;
+        case ARENA_TEAM_3v3: return 1;
+        case ARENA_TEAM_5v5: return 2;
+        default:
+            break;
+    }
+    sLog->outError(LOG_FILTER_ARENAS, "FATAL: Unknown arena team type %u for some arena team", type);
+    return 0xFF;
+}
+
+uint8 ArenaTeam::GetTypeBySlot(uint8 slot)
+{
+    switch (slot)
+    {
+        case 0: return ARENA_TEAM_2v2;
+        case 1: return ARENA_TEAM_3v3;
+        case 2: return ARENA_TEAM_5v5;
+        default:
+            break;
+    }
+    sLog->outError(LOG_FILTER_ARENAS, "FATAL: Unknown arena team slot %u for some arena team", slot);
+    return 0xFF;
+}
+
+bool ArenaTeam::IsMember(uint64 guid) const
+{
+    for (MemberList::const_iterator itr = Members.begin(); itr != Members.end(); ++itr)
+        if (itr->Guid == guid)
+            return true;
+
+    return false;
+}
+
+uint32 ArenaTeam::GetAverageMMR(Group* group) const
+{
+    if (!group)
+        return 0;
+
+    uint32 matchMakerRating = 0;
+    uint32 playerDivider = 0;
+    for (MemberList::const_iterator itr = Members.begin(); itr != Members.end(); ++itr)
+    {
+        // Skip if player is not online
+        if (!ObjectAccessor::FindPlayer(itr->Guid))
+            continue;
+
+        // Skip if player is not a member of group
+        if (!group->IsMember(itr->Guid))
+            continue;
+
+        matchMakerRating += itr->MatchMakerRating;
+        ++playerDivider;
+    }
+
+    // x/0 = crash
+    if (playerDivider == 0)
+        playerDivider = 1;
+
+    matchMakerRating /= playerDivider;
+
+    return matchMakerRating;
+}
+
+float ArenaTeam::GetChanceAgainst(uint32 ownRating, uint32 opponentRating)
+{
+    // Returns the chance to win against a team with the given rating, used in the rating adjustment calculation
+    // ELO system
+    return 1.0f / (1.0f + exp(log(10.0f) * (float)((float)opponentRating - (float)ownRating) / 650.0f));
+}
+
+int32 ArenaTeam::GetMatchmakerRatingMod(uint32 ownRating, uint32 opponentRating, bool won)
+{
+    // 'Chance' calculation - to beat the opponent
+    // This is a simulation. Not much info on how it really works
+    float chance = GetChanceAgainst(ownRating, opponentRating);
+    float won_mod = (won) ? 1.0f : 0.0f;
+    float mod = won_mod - chance;
+
+    // Work in progress:
+    /*
+    // This is a simulation, as there is not much info on how it really works
+    float confidence_mod = min(1.0f - fabs(mod), 0.5f);
+
+    // Apply confidence factor to the mod:
+    mod *= confidence_factor
+
+    // And only after that update the new confidence factor
+    confidence_factor -= ((confidence_factor - 1.0f) * confidence_mod) / confidence_factor;
+    */
+
+    // Real rating modification
+    mod *= 48.0f;
+
+    return (int32)ceil(mod);
+}
+
+int32 ArenaTeam::GetRatingMod(uint32 ownRating, uint32 opponentRating, bool won /*, float confidence_factor*/)
+{
+    // 'Chance' calculation - to beat the opponent
+    // This is a simulation. Not much info on how it really works
+    float chance = GetChanceAgainst(ownRating, opponentRating);
+    float won_mod = (won) ? 1.0f : 0.0f;
+
+    // Calculate the rating modification
+    float mod;
+
+    // TODO: Replace this hack with using the confidence factor (limiting the factor to 2.0f)
+    if (won && ownRating < 1300)
+    {
+        if (ownRating < 1000)
+            mod = 96.0f * (won_mod - chance);
+        else
+            mod = (48.0f + (48.0f * (1300.0f - float(ownRating)) / 300.0f)) * (won_mod - chance);
+    }
+    else
+        mod = 48.0f * (won_mod - chance);
+
+    return (int32)ceil(mod);
+}
+
+void ArenaTeam::FinishGame(int32 mod, bool draw)
+{
+    // Rating can only drop to 0
+    if (int32(Stats.Rating) + mod < 0)
+        Stats.Rating = 0;
+    else
+    {
+        Stats.Rating += mod;
+
+        // Check if rating related achivements are met
+        for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
+            if (Player* member = ObjectAccessor::FindPlayer(itr->Guid))
+                member->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_TEAM_RATING, Stats.Rating, Type);
+    }
+
+    // Update number of games played per season or week
+    if (!draw)
+    {
+        Stats.WeekGames += 1;
+        Stats.SeasonGames += 1;
+    }
+
+    // Update team's rank, start with rank 1 and increase until no team with more rating was found
+    Stats.Rank = 1;
+    ArenaTeamMgr::ArenaTeamContainer::const_iterator i = sArenaTeamMgr->GetArenaTeamMapBegin();
+    for (; i != sArenaTeamMgr->GetArenaTeamMapEnd(); ++i)
+    {
+        if (i->second->GetType() == Type && i->second->GetStats().Rating > Stats.Rating)
+            ++Stats.Rank;
+    }
+}
+
+int32 ArenaTeam::WonAgainst(uint32 ownMMRating, uint32 opponentMMRating, int32& ratingChange)
+{
+    // Called when the team has won
+    // Change in Matchmaker rating
+    int32 mod = GetMatchmakerRatingMod(ownMMRating, opponentMMRating, true);
+
+    // Change in Team Rating
+    ratingChange = GetRatingMod(Stats.Rating, opponentMMRating, true);
+
+    // Modify the team stats accordingly
+    FinishGame(ratingChange);
+
+    // Update number of wins per season and week
+    Stats.WeekWins += 1;
+    Stats.SeasonWins += 1;
+
+    // Return the rating change, used to display it on the results screen
+    return mod;
+}
+
+int32 ArenaTeam::LostAgainst(uint32 ownMMRating, uint32 opponentMMRating, int32& ratingChange)
+{
+    // Called when the team has lost
+    // Change in Matchmaker Rating
+    int32 mod = GetMatchmakerRatingMod(ownMMRating, opponentMMRating, false);
+
+    // Change in Team Rating
+    ratingChange = GetRatingMod(Stats.Rating, opponentMMRating, false);
+
+    // Modify the team stats accordingly
+    FinishGame(ratingChange);
+
+    // return the rating change, used to display it on the results screen
+    return mod;
+}
+
+void ArenaTeam::MemberLost(Player* player, uint32 againstMatchmakerRating, int32 matchmakerRatingChange)
+{
+    // Called for each participant of a match after losing
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
+    {
+        if (itr->Guid == player->GetGUID())
+        {
+            // Update personal rating
+            int32 mod = GetRatingMod(itr->PersonalRating, againstMatchmakerRating, false);
+            itr->ModifyPersonalRating(player, mod, GetType());
+
+            // Update matchmaker rating
+            itr->ModifyMatchmakerRating(matchmakerRatingChange, GetSlot());
+
+            // Update personal played stats
+            itr->WeekGames +=1;
+            itr->SeasonGames +=1;
+
+            // update the unit fields
+            player->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_GAMES_WEEK,  itr->WeekGames);
+            player->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_GAMES_SEASON,  itr->SeasonGames);
+            return;
+        }
+    }
+}
+
+void ArenaTeam::OfflineMemberLost(uint64 guid, uint32 againstMatchmakerRating, int32 matchmakerRatingChange)
+{
+    // Called for offline player after ending rated arena match!
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
+    {
+        if (itr->Guid == guid)
+        {
+            // update personal rating
+            int32 mod = GetRatingMod(itr->PersonalRating, againstMatchmakerRating, false);
+            itr->ModifyPersonalRating(NULL, mod, GetType());
+
+            // update matchmaker rating
+            itr->ModifyMatchmakerRating(matchmakerRatingChange, GetSlot());
+
+            // update personal played stats
+            itr->WeekGames += 1;
+            itr->SeasonGames += 1;
+            return;
+        }
+    }
+}
+
+void ArenaTeam::MemberWon(Player* player, uint32 againstMatchmakerRating, int32 matchmakerRatingChange)
+{
+    // called for each participant after winning a match
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
+    {
+        if (itr->Guid == player->GetGUID())
+        {
+            // update personal rating
+            int32 mod = GetRatingMod(itr->PersonalRating, againstMatchmakerRating, true);
+            itr->ModifyPersonalRating(player, mod, GetType());
+
+            // update matchmaker rating
+            itr->ModifyMatchmakerRating(matchmakerRatingChange, GetSlot());
+
+            // update personal stats
+            itr->WeekGames +=1;
+            itr->SeasonGames +=1;
+            itr->SeasonWins += 1;
+            itr->WeekWins += 1;
+            // update unit fields
+            player->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_GAMES_WEEK, itr->WeekGames);
+            player->SetArenaTeamInfoField(GetSlot(), ARENA_TEAM_GAMES_SEASON, itr->SeasonGames);
+            return;
+        }
+    }
+}
+
+void ArenaTeam::SaveToDB()
+{
+    // Save team and member stats to db
+    // Called after a match has ended or when calculating arena_points
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ARENA_TEAM_STATS);
+    stmt->setUInt16(0, Stats.Rating);
+    stmt->setUInt16(1, Stats.WeekGames);
+    stmt->setUInt16(2, Stats.WeekWins);
+    stmt->setUInt16(3, Stats.SeasonGames);
+    stmt->setUInt16(4, Stats.SeasonWins);
+    stmt->setUInt32(5, Stats.Rank);
+    stmt->setUInt32(6, GetId());
+    trans->Append(stmt);
+
+    for (MemberList::const_iterator itr = Members.begin(); itr != Members.end(); ++itr)
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ARENA_TEAM_MEMBER);
+        stmt->setUInt16(0, itr->PersonalRating);
+        stmt->setUInt16(1, itr->WeekGames);
+        stmt->setUInt16(2, itr->WeekWins);
+        stmt->setUInt16(3, itr->SeasonGames);
+        stmt->setUInt16(4, itr->SeasonWins);
+        stmt->setUInt32(5, GetId());
+        stmt->setUInt32(6, GUID_LOPART(itr->Guid));
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHARACTER_ARENA_STATS);
+        stmt->setUInt32(0, GUID_LOPART(itr->Guid));
+        stmt->setUInt8(1, GetSlot());
+        stmt->setUInt16(2, itr->MatchMakerRating);
+        trans->Append(stmt);
+    }
+
+    CharacterDatabase.CommitTransaction(trans);
+}
+
+void ArenaTeam::FinishWeek()
+{
+    // Reset team stats
+    Stats.WeekGames = 0;
+    Stats.WeekWins = 0;
+
+    // Reset member stats
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
+    {
+        itr->WeekGames = 0;
+        itr->WeekWins = 0;
+    }
+}
+
+bool ArenaTeam::IsFighting() const
+{
+    for (MemberList::const_iterator itr = Members.begin(); itr != Members.end(); ++itr)
+        if (Player* player = ObjectAccessor::FindPlayer(itr->Guid))
+            if (player->GetMap()->IsBattleArena())
+                return true;
+
+    return false;
+}
+
+ArenaTeamMember* ArenaTeam::GetMember(const std::string& name)
+{
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
+        if (itr->Name == name)
+            return &(*itr);
+
+    return NULL;
+}
+
+ArenaTeamMember* ArenaTeam::GetMember(uint64 guid)
+{
+    for (MemberList::iterator itr = Members.begin(); itr != Members.end(); ++itr)
+        if (itr->Guid == guid)
+            return &(*itr);
+
+    return NULL;
+}
diff --git a/src/server/game/Battlegrounds/ArenaTeam.h b/src/server/game/Battlegrounds/ArenaTeam.h
index 97d316f..129f067 100644
--- a/src/server/game/Battlegrounds/ArenaTeam.h
+++ b/src/server/game/Battlegrounds/ArenaTeam.h
@@ -77,7 +77,7 @@ enum ArenaTeamTypes
 {
     ARENA_TEAM_2v2      = 2,
     ARENA_TEAM_3v3      = 3,
-    ARENA_TEAM_5v5      = 5
+    ARENA_TEAM_5v5      = 1 // 1v1 Arena - 5v5 doesn't exist anymore
 };
 
 struct ArenaTeamMember
diff --git a/src/server/game/Battlegrounds/ArenaTeam.h.orig b/src/server/game/Battlegrounds/ArenaTeam.h.orig
new file mode 100644
index 0000000..97d316f
--- /dev/null
+++ b/src/server/game/Battlegrounds/ArenaTeam.h.orig
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TRINITYCORE_ARENATEAM_H
+#define TRINITYCORE_ARENATEAM_H
+
+#include "Define.h"
+#include "QueryResult.h"
+#include <list>
+#include <string>
+#include <map>
+
+class WorldSession;
+class WorldPacket;
+class Player;
+class Group;
+
+enum ArenaTeamCommandTypes
+{
+    ERR_ARENA_TEAM_CREATE_S                 = 0x00,
+    ERR_ARENA_TEAM_INVITE_SS                = 0x01,
+    ERR_ARENA_TEAM_QUIT_S                   = 0x03,
+    ERR_ARENA_TEAM_FOUNDER_S                = 0x0E
+};
+
+enum ArenaTeamCommandErrors
+{
+    ERR_ARENA_TEAM_CREATED                  = 0x00,
+    ERR_ARENA_TEAM_INTERNAL                 = 0x01,
+    ERR_ALREADY_IN_ARENA_TEAM               = 0x02,
+    ERR_ALREADY_IN_ARENA_TEAM_S             = 0x03,
+    ERR_INVITED_TO_ARENA_TEAM               = 0x04,
+    ERR_ALREADY_INVITED_TO_ARENA_TEAM_S     = 0x05,
+    ERR_ARENA_TEAM_NAME_INVALID             = 0x06,
+    ERR_ARENA_TEAM_NAME_EXISTS_S            = 0x07,
+    ERR_ARENA_TEAM_LEADER_LEAVE_S           = 0x08,
+    ERR_ARENA_TEAM_PERMISSIONS              = 0x08,
+    ERR_ARENA_TEAM_PLAYER_NOT_IN_TEAM       = 0x09,
+    ERR_ARENA_TEAM_PLAYER_NOT_IN_TEAM_SS    = 0x0A,
+    ERR_ARENA_TEAM_PLAYER_NOT_FOUND_S       = 0x0B,
+    ERR_ARENA_TEAM_NOT_ALLIED               = 0x0C,
+    ERR_ARENA_TEAM_IGNORING_YOU_S           = 0x13,
+    ERR_ARENA_TEAM_TARGET_TOO_LOW_S         = 0x15,
+    ERR_ARENA_TEAM_TARGET_TOO_HIGH_S        = 0x16,
+    ERR_ARENA_TEAM_TOO_MANY_MEMBERS_S       = 0x17,
+    ERR_ARENA_TEAM_NOT_FOUND                = 0x1B,
+    ERR_ARENA_TEAMS_LOCKED                  = 0x1E,
+    ERR_ARENA_TEAM_TOO_MANY_CREATE          = 0x21,
+};
+
+enum ArenaTeamEvents
+{
+    ERR_ARENA_TEAM_JOIN_SS                  = 4,            // player name + arena team name
+    ERR_ARENA_TEAM_LEAVE_SS                 = 5,            // player name + arena team name
+    ERR_ARENA_TEAM_REMOVE_SSS               = 6,            // player name + arena team name + captain name
+    ERR_ARENA_TEAM_LEADER_IS_SS             = 7,            // player name + arena team name
+    ERR_ARENA_TEAM_LEADER_CHANGED_SSS       = 8,            // old captain + new captain + arena team name
+    ERR_ARENA_TEAM_DISBANDED_S              = 9             // captain name + arena team name
+};
+
+enum ArenaTeamTypes
+{
+    ARENA_TEAM_2v2      = 2,
+    ARENA_TEAM_3v3      = 3,
+    ARENA_TEAM_5v5      = 5
+};
+
+struct ArenaTeamMember
+{
+    uint64 Guid;
+    std::string Name;
+    uint8 Class;
+    uint16 WeekGames;
+    uint16 WeekWins;
+    uint16 SeasonGames;
+    uint16 SeasonWins;
+    uint16 PersonalRating;
+    uint16 MatchMakerRating;
+
+    void ModifyPersonalRating(Player* player, int32 mod, uint32 type);
+    void ModifyMatchmakerRating(int32 mod, uint32 slot);
+};
+
+struct ArenaTeamStats
+{
+    uint16 Rating;
+    uint16 WeekGames;
+    uint16 WeekWins;
+    uint16 SeasonGames;
+    uint16 SeasonWins;
+    uint32 Rank;
+};
+
+#define MAX_ARENA_SLOT 3                                    // 0..2 slots
+
+class ArenaTeam
+{
+    public:
+        ArenaTeam();
+        ~ArenaTeam();
+
+        bool Create(uint64 captainGuid, uint8 type, std::string const& teamName,
+                                      uint32 backgroundColor, uint8 emblemStyle, uint32 emblemColor,
+                                      uint8 borderStyle, uint32 borderColor);
+        void Disband(WorldSession* session);
+
+        typedef std::list<ArenaTeamMember> MemberList;
+
+        uint32 GetId() const { return TeamId; }
+        uint32 GetType() const { return Type; }
+        uint8  GetSlot() const { return GetSlotByType(GetType()); }
+        static uint8 GetSlotByType(uint32 type);
+        static uint8 GetTypeBySlot(uint8 slot);
+        uint64 GetCaptain() const { return CaptainGuid; }
+        std::string const& GetName() const { return TeamName; }
+        const ArenaTeamStats& GetStats() const { return Stats; }
+
+        uint32 GetRating() const          { return Stats.Rating; }
+        uint32 GetAverageMMR(Group* group) const;
+
+        void SetCaptain(uint64 guid);
+        bool AddMember(uint64 PlayerGuid);
+        void DelMember(uint64 guid, bool cleanDb);
+
+        size_t GetMembersSize() const         { return Members.size(); }
+        bool   Empty() const                  { return Members.empty(); }
+        bool IsMember(uint64 guid) const;
+
+        ArenaTeamMember* GetMember(uint64 guid);
+        ArenaTeamMember* GetMember(std::string const& name);
+
+        bool IsFighting() const;
+
+        bool LoadArenaTeamFromDB(QueryResult arenaTeamDataResult);
+        bool LoadMembersFromDB(QueryResult arenaTeamMembersResult);
+        void LoadStatsFromDB(uint32 ArenaTeamId);
+        void SaveToDB();
+
+        void BroadcastPacket(WorldPacket* packet);
+        void BroadcastEvent(ArenaTeamEvents event, uint64 guid, uint8 strCount, std::string const& str1, std::string const& str2, std::string const& str3);
+        void NotifyStatsChanged();
+
+        void MassInviteToEvent(WorldSession* session);
+
+        void Roster(WorldSession* session);
+        void Query(WorldSession* session);
+        void SendStats(WorldSession* session);
+        void Inspect(WorldSession* session, uint64 guid);
+
+        static int32 GetMatchmakerRatingMod(uint32 ownRating, uint32 opponentRating, bool won);
+        static int32 GetRatingMod(uint32 ownRating, uint32 opponentRating, bool won);
+        static float GetChanceAgainst(uint32 ownRating, uint32 opponentRating);
+
+        int32 WonAgainst(uint32 ownMMRating, uint32 opponentMMRating, int32& rating_change);
+        void MemberWon(Player* player, uint32 againstMatchmakerRating, int32 matchmakerRatingChange = 12);
+
+        int32 LostAgainst(uint32 ownMMRating, uint32 opponentMMRating, int32& rating_change);
+        void MemberLost(Player* player, uint32 againstMatchmakerRating, int32 matchmakerRatingChange = -12);
+        void OfflineMemberLost(uint64 guid, uint32 againstMatchmakerRating, int32 matchmakerRatingChange = -12);
+
+        void FinishWeek();
+        void FinishGame(int32 mod, bool draw = false);
+
+    protected:
+
+        uint32 TeamId;
+        uint8  Type;
+        std::string TeamName;
+        uint64 CaptainGuid;
+
+        uint32 BackgroundColor; // ARGB format
+        uint8  EmblemStyle;     // icon id
+        uint32 EmblemColor;     // ARGB format
+        uint8  BorderStyle;     // border image id
+        uint32 BorderColor;     // ARGB format
+
+        MemberList Members;
+        ArenaTeamStats Stats;
+};
+#endif
+
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index ff904a8..7072dde 100644
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -522,6 +522,11 @@ inline void Battleground::_ProcessJoin(uint32 diff)
         // First start warning - 2 or 1 minute
         SendMessageToAll(StartMessageIds[BG_STARTING_EVENT_FIRST], CHAT_MSG_BG_SYSTEM_NEUTRAL);
     }
+
+    // 1v1 Arena - Start arena after 15s, when all players are in arena
+    if(GetArenaType() == ARENA_TYPE_5v5 && GetStartDelayTime() > StartDelayTimes[BG_STARTING_EVENT_THIRD] && (m_PlayersCount[0] + m_PlayersCount[1]) == 2)
+        SetStartDelayTime(StartDelayTimes[BG_STARTING_EVENT_THIRD]);
+
     // After 1 minute or 30 seconds, warning is signaled
     else if (GetStartDelayTime() <= StartDelayTimes[BG_STARTING_EVENT_SECOND] && !(m_Events & BG_STARTING_EVENT_2))
     {
diff --git a/src/server/game/Battlegrounds/Battleground.cpp.orig b/src/server/game/Battlegrounds/Battleground.cpp.orig
new file mode 100644
index 0000000..ff904a8
--- /dev/null
+++ b/src/server/game/Battlegrounds/Battleground.cpp.orig
@@ -0,0 +1,2096 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ArenaTeam.h"
+#include "ArenaTeamMgr.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "Creature.h"
+#include "Formulas.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Guild.h"
+#include "GuildMgr.h"
+#include "MapManager.h"
+#include "Object.h"
+#include "ObjectMgr.h"
+#include "Pet.h"
+#include "Player.h"
+#include "ReputationMgr.h"
+#include "SpellAuraEffects.h"
+#include "SpellAuras.h"
+#include "Util.h"
+#include "World.h"
+#include "WorldPacket.h"
+
+namespace Trinity
+{
+    class BattlegroundChatBuilder
+    {
+        public:
+            BattlegroundChatBuilder(ChatMsg msgtype, int32 textId, Player const* source, va_list* args = NULL)
+                : _msgtype(msgtype), _textId(textId), _source(source), _args(args) { }
+
+            void operator()(WorldPacket& data, LocaleConstant loc_idx)
+            {
+                char const* text = sObjectMgr->GetTrinityString(_textId, loc_idx);
+                if (_args)
+                {
+                    // we need copy va_list before use or original va_list will corrupted
+                    va_list ap;
+                    va_copy(ap, *_args);
+
+                    char str[2048];
+                    vsnprintf(str, 2048, text, ap);
+                    va_end(ap);
+
+                    do_helper(data, &str[0]);
+                }
+                else
+                    do_helper(data, text);
+            }
+
+        private:
+            void do_helper(WorldPacket& data, char const* text)
+            {
+                uint64 target_guid = _source ? _source->GetGUID() : 0;
+
+                data << uint8 (_msgtype);
+                data << uint32(LANG_UNIVERSAL);
+                data << uint64(target_guid);                // there 0 for BG messages
+                data << uint32(0);                          // can be chat msg group or something
+                data << uint64(target_guid);
+                data << uint32(strlen(text) + 1);
+                data << text;
+                data << uint8 (_source ? _source->GetChatTag() : 0);
+            }
+
+            ChatMsg _msgtype;
+            int32 _textId;
+            Player const* _source;
+            va_list* _args;
+    };
+
+    class Battleground2ChatBuilder
+    {
+        public:
+            Battleground2ChatBuilder(ChatMsg msgtype, int32 textId, Player const* source, int32 arg1, int32 arg2)
+                : _msgtype(msgtype), _textId(textId), _source(source), _arg1(arg1), _arg2(arg2) {}
+
+            void operator()(WorldPacket& data, LocaleConstant loc_idx)
+            {
+                char const* text = sObjectMgr->GetTrinityString(_textId, loc_idx);
+                char const* arg1str = _arg1 ? sObjectMgr->GetTrinityString(_arg1, loc_idx) : "";
+                char const* arg2str = _arg2 ? sObjectMgr->GetTrinityString(_arg2, loc_idx) : "";
+
+                char str[2048];
+                snprintf(str, 2048, text, arg1str, arg2str);
+
+                uint64 target_guid = _source  ? _source->GetGUID() : 0;
+
+                data << uint8 (_msgtype);
+                data << uint32(LANG_UNIVERSAL);
+                data << uint64(target_guid);                // there 0 for BG messages
+                data << uint32(0);                          // can be chat msg group or something
+                data << uint64(target_guid);
+                data << uint32(strlen(str) + 1);
+                data << str;
+                data << uint8 (_source ? _source->GetChatTag() : uint8(0));
+            }
+
+        private:
+            ChatMsg _msgtype;
+            int32 _textId;
+            Player const* _source;
+            int32 _arg1;
+            int32 _arg2;
+    };
+}                                                           // namespace Trinity
+
+template<class Do>
+void Battleground::BroadcastWorker(Do& _do)
+{
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+        if (Player* player = ObjectAccessor::FindPlayer(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+            _do(player);
+}
+
+Battleground::Battleground()
+{
+    m_Guid              = 0;
+    m_TypeID            = BATTLEGROUND_TYPE_NONE;
+    m_RandomTypeID      = BATTLEGROUND_TYPE_NONE;
+    m_InstanceID        = 0;
+    m_Status            = STATUS_NONE;
+    m_ClientInstanceID  = 0;
+    m_EndTime           = 0;
+    m_LastResurrectTime = 0;
+    m_BracketId         = BG_BRACKET_ID_FIRST;
+    m_InvitedAlliance   = 0;
+    m_InvitedHorde      = 0;
+    m_ArenaType         = 0;
+    m_IsArena           = false;
+    m_Winner            = 2;
+    m_StartTime         = 0;
+    m_CountdownTimer    = 0;
+    m_ResetStatTimer    = 0;
+    m_ValidStartPositionTimer = 0;
+    m_Events            = 0;
+    m_IsRated           = false;
+    m_BuffChange        = false;
+    m_IsRandom          = false;
+    m_Name              = "";
+    m_LevelMin          = 0;
+    m_LevelMax          = 0;
+    m_InBGFreeSlotQueue = false;
+    m_SetDeleteThis     = false;
+
+    m_MaxPlayersPerTeam = 0;
+    m_MaxPlayers        = 0;
+    m_MinPlayersPerTeam = 0;
+    m_MinPlayers        = 0;
+
+    m_MapId             = 0;
+    m_Map               = NULL;
+    m_StartMaxDist      = 0.0f;
+
+    m_TeamStartLocX[TEAM_ALLIANCE]   = 0;
+    m_TeamStartLocX[TEAM_HORDE]      = 0;
+
+    m_TeamStartLocY[TEAM_ALLIANCE]   = 0;
+    m_TeamStartLocY[TEAM_HORDE]      = 0;
+
+    m_TeamStartLocZ[TEAM_ALLIANCE]   = 0;
+    m_TeamStartLocZ[TEAM_HORDE]      = 0;
+
+    m_TeamStartLocO[TEAM_ALLIANCE]   = 0;
+    m_TeamStartLocO[TEAM_HORDE]      = 0;
+
+    m_ArenaTeamIds[TEAM_ALLIANCE]   = 0;
+    m_ArenaTeamIds[TEAM_HORDE]      = 0;
+
+    m_ArenaTeamRatingChanges[TEAM_ALLIANCE]   = 0;
+    m_ArenaTeamRatingChanges[TEAM_HORDE]      = 0;
+
+    m_BgRaids[TEAM_ALLIANCE]         = NULL;
+    m_BgRaids[TEAM_HORDE]            = NULL;
+
+    m_PlayersCount[TEAM_ALLIANCE]    = 0;
+    m_PlayersCount[TEAM_HORDE]       = 0;
+
+    m_TeamScores[TEAM_ALLIANCE]      = 0;
+    m_TeamScores[TEAM_HORDE]         = 0;
+
+    m_PrematureCountDown = false;
+
+    m_HonorMode = BG_NORMAL;
+
+    StartDelayTimes[BG_STARTING_EVENT_FIRST]  = BG_START_DELAY_2M;
+    StartDelayTimes[BG_STARTING_EVENT_SECOND] = BG_START_DELAY_1M;
+    StartDelayTimes[BG_STARTING_EVENT_THIRD]  = BG_START_DELAY_30S;
+    StartDelayTimes[BG_STARTING_EVENT_FOURTH] = BG_START_DELAY_NONE;
+    //we must set to some default existing values
+    StartMessageIds[BG_STARTING_EVENT_FIRST]  = LANG_BG_WS_START_TWO_MINUTES;
+    StartMessageIds[BG_STARTING_EVENT_SECOND] = LANG_BG_WS_START_ONE_MINUTE;
+    StartMessageIds[BG_STARTING_EVENT_THIRD]  = LANG_BG_WS_START_HALF_MINUTE;
+    StartMessageIds[BG_STARTING_EVENT_FOURTH] = LANG_BG_WS_HAS_BEGUN;
+}
+
+Battleground::~Battleground()
+{
+    // remove objects and creatures
+    // (this is done automatically in mapmanager update, when the instance is reset after the reset time)
+    uint32 size = uint32(BgCreatures.size());
+    for (uint32 i = 0; i < size; ++i)
+        DelCreature(i);
+
+    size = uint32(BgObjects.size());
+    for (uint32 i = 0; i < size; ++i)
+        DelObject(i);
+
+    sBattlegroundMgr->RemoveBattleground(GetTypeID(), GetInstanceID());
+    // unload map
+    if (m_Map)
+    {
+        m_Map->SetUnload();
+        //unlink to prevent crash, always unlink all pointer reference before destruction
+        m_Map->SetBG(NULL);
+        m_Map = NULL;
+    }
+    // remove from bg free slot queue
+    RemoveFromBGFreeSlotQueue();
+
+    for (BattlegroundScoreMap::const_iterator itr = PlayerScores.begin(); itr != PlayerScores.end(); ++itr)
+        delete itr->second;
+}
+
+void Battleground::Update(uint32 diff)
+{
+    if (!PreUpdateImpl(diff))
+        return;
+
+    if (!GetPlayersSize())
+    {
+        //BG is empty
+        // if there are no players invited, delete BG
+        // this will delete arena or bg object, where any player entered
+        // [[   but if you use battleground object again (more battles possible to be played on 1 instance)
+        //      then this condition should be removed and code:
+        //      if (!GetInvitedCount(HORDE) && !GetInvitedCount(ALLIANCE))
+        //          this->AddToFreeBGObjectsQueue(); // not yet implemented
+        //      should be used instead of current
+        // ]]
+        // Battleground Template instance cannot be updated, because it would be deleted
+        if (!GetInvitedCount(HORDE) && !GetInvitedCount(ALLIANCE))
+            m_SetDeleteThis = true;
+        return;
+    }
+
+    switch (GetStatus())
+    {
+        case STATUS_WAIT_JOIN:
+            if (GetPlayersSize())
+            {
+                _ProcessJoin(diff);
+                _CheckSafePositions(diff);
+            }
+            break;
+        case STATUS_IN_PROGRESS:
+            _ProcessOfflineQueue();
+            // after 47 minutes without one team losing, the arena closes with no winner and no rating change
+            if (isArena())
+            {
+                if (GetElapsedTime() >= 47 * MINUTE*IN_MILLISECONDS)
+                {
+                    UpdateArenaWorldState();
+                    CheckArenaAfterTimerConditions();
+                    return;
+                }
+            }
+            else
+            {
+                _ProcessRessurect(diff);
+                if (sBattlegroundMgr->GetPrematureFinishTime() && (GetPlayersCountByTeam(ALLIANCE) < GetMinPlayersPerTeam() || GetPlayersCountByTeam(HORDE) < GetMinPlayersPerTeam()))
+                    _ProcessProgress(diff);
+                else if (m_PrematureCountDown)
+                    m_PrematureCountDown = false;
+            }
+            break;
+        case STATUS_WAIT_LEAVE:
+            _ProcessLeave(diff);
+            break;
+        default:
+            break;
+    }
+
+    // Update start time and reset stats timer
+    SetElapsedTime(GetElapsedTime() + diff);
+    if (GetStatus() == STATUS_WAIT_JOIN)
+    {
+        m_ResetStatTimer += diff;
+        m_CountdownTimer += diff;
+    }
+
+    PostUpdateImpl(diff);
+}
+
+inline void Battleground::_CheckSafePositions(uint32 diff)
+{
+    float maxDist = GetStartMaxDist();
+    if (!maxDist)
+        return;
+
+    m_ValidStartPositionTimer += diff;
+    if (m_ValidStartPositionTimer >= CHECK_PLAYER_POSITION_INVERVAL)
+    {
+        m_ValidStartPositionTimer = 0;
+
+        Position pos;
+        float x, y, z, o;
+        for (BattlegroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
+            if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+            {
+                player->GetPosition(&pos);
+                GetTeamStartLoc(player->GetBGTeam(), x, y, z, o);
+                if (pos.GetExactDistSq(x, y, z) > maxDist)
+                {
+                    sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BATTLEGROUND: Sending %s back to start location (map: %u) (possible exploit)", player->GetName().c_str(), GetMapId());
+                    player->TeleportTo(GetMapId(), x, y, z, o);
+                }
+            }
+    }
+}
+
+inline void Battleground::_ProcessOfflineQueue()
+{
+    // remove offline players from bg after 5 minutes
+    if (!m_OfflineQueue.empty())
+    {
+        BattlegroundPlayerMap::iterator itr = m_Players.find(*(m_OfflineQueue.begin()));
+        if (itr != m_Players.end())
+        {
+            if (itr->second.OfflineRemoveTime <= sWorld->GetGameTime())
+            {
+                RemovePlayerAtLeave(itr->first, true, true);// remove player from BG
+                m_OfflineQueue.pop_front();                 // remove from offline queue
+                //do not use itr for anything, because it is erased in RemovePlayerAtLeave()
+            }
+        }
+    }
+}
+
+inline void Battleground::_ProcessRessurect(uint32 diff)
+{
+    // *********************************************************
+    // ***        BATTLEGROUND RESSURECTION SYSTEM           ***
+    // *********************************************************
+    // this should be handled by spell system
+    m_LastResurrectTime += diff;
+    if (m_LastResurrectTime >= RESURRECTION_INTERVAL)
+    {
+        if (GetReviveQueueSize())
+        {
+            for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+            {
+                Creature* sh = NULL;
+                for (std::vector<uint64>::const_iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+                {
+                    Player* player = ObjectAccessor::FindPlayer(*itr2);
+                    if (!player)
+                        continue;
+
+                    if (!sh && player->IsInWorld())
+                    {
+                        sh = player->GetMap()->GetCreature(itr->first);
+                        // only for visual effect
+                        if (sh)
+                            // Spirit Heal, effect 117
+                            sh->CastSpell(sh, SPELL_SPIRIT_HEAL, true);
+                    }
+
+                    // Resurrection visual
+                    player->CastSpell(player, SPELL_RESURRECTION_VISUAL, true);
+                    m_ResurrectQueue.push_back(*itr2);
+                }
+                (itr->second).clear();
+            }
+
+            m_ReviveQueue.clear();
+            m_LastResurrectTime = 0;
+        }
+        else
+            // queue is clear and time passed, just update last resurrection time
+            m_LastResurrectTime = 0;
+    }
+    else if (m_LastResurrectTime > 500)    // Resurrect players only half a second later, to see spirit heal effect on NPC
+    {
+        for (std::vector<uint64>::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+        {
+            Player* player = ObjectAccessor::FindPlayer(*itr);
+            if (!player)
+                continue;
+            player->ResurrectPlayer(1.0f);
+            player->CastSpell(player, 6962, true);
+            player->CastSpell(player, SPELL_SPIRIT_HEAL_MANA, true);
+            sObjectAccessor->ConvertCorpseForPlayer(*itr);
+        }
+        m_ResurrectQueue.clear();
+    }
+}
+
+uint32 Battleground::GetPrematureWinner()
+{
+    uint32 winner = 0;
+    if (GetPlayersCountByTeam(ALLIANCE) >= GetMinPlayersPerTeam())
+        winner = ALLIANCE;
+    else if (GetPlayersCountByTeam(HORDE) >= GetMinPlayersPerTeam())
+        winner = HORDE;
+
+    return winner;
+}
+
+inline void Battleground::_ProcessProgress(uint32 diff)
+{
+    // *********************************************************
+    // ***           BATTLEGROUND BALLANCE SYSTEM            ***
+    // *********************************************************
+    // if less then minimum players are in on one side, then start premature finish timer
+    if (!m_PrematureCountDown)
+    {
+        m_PrematureCountDown = true;
+        m_PrematureCountDownTimer = sBattlegroundMgr->GetPrematureFinishTime();
+    }
+    else if (m_PrematureCountDownTimer < diff)
+    {
+        // time's up!
+        EndBattleground(GetPrematureWinner());
+        m_PrematureCountDown = false;
+    }
+    else if (!sBattlegroundMgr->isTesting())
+    {
+        uint32 newtime = m_PrematureCountDownTimer - diff;
+        // announce every minute
+        if (newtime > (MINUTE * IN_MILLISECONDS))
+        {
+            if (newtime / (MINUTE * IN_MILLISECONDS) != m_PrematureCountDownTimer / (MINUTE * IN_MILLISECONDS))
+                PSendMessageToAll(LANG_BATTLEGROUND_PREMATURE_FINISH_WARNING, CHAT_MSG_SYSTEM, NULL, (uint32)(m_PrematureCountDownTimer / (MINUTE * IN_MILLISECONDS)));
+        }
+        else
+        {
+            //announce every 15 seconds
+            if (newtime / (15 * IN_MILLISECONDS) != m_PrematureCountDownTimer / (15 * IN_MILLISECONDS))
+                PSendMessageToAll(LANG_BATTLEGROUND_PREMATURE_FINISH_WARNING_SECS, CHAT_MSG_SYSTEM, NULL, (uint32)(m_PrematureCountDownTimer / IN_MILLISECONDS));
+        }
+        m_PrematureCountDownTimer = newtime;
+    }
+}
+
+inline void Battleground::_ProcessJoin(uint32 diff)
+{
+    // *********************************************************
+    // ***           BATTLEGROUND STARTING SYSTEM            ***
+    // *********************************************************
+    ModifyStartDelayTime(diff);
+
+    if (!isArena())
+        SetRemainingTime(300000);
+
+    if (m_ResetStatTimer > 5000)
+    {
+        m_ResetStatTimer = 0;
+        for (BattlegroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
+            if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+            {
+                player->ResetAllPowers();
+                if (Pet* pet = player->GetPet())
+                    pet->ResetAllPowers();
+            }
+    }
+
+    // Send packet every 10 seconds until the 2nd field reach 0
+    if (m_CountdownTimer >= 10000 && !(isArena() && GetElapsedTime() < 45 * IN_MILLISECONDS))
+    {
+        uint32 countdownMaxForBGType = isArena() ? ARENA_COUNTDOWN_MAX : BATTLEGROUND_COUNTDOWN_MAX;
+
+        WorldPacket data(SMSG_START_TIMER, 4+4+4);
+        data << uint32(0); // unk
+        data << uint32(countdownMaxForBGType - (GetElapsedTime() / 1000));
+        data << uint32(countdownMaxForBGType);
+
+        for (BattlegroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
+            if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+                player->GetSession()->SendPacket(&data);
+
+        m_CountdownTimer = 0;
+    }
+
+    if (!(m_Events & BG_STARTING_EVENT_1))
+    {
+        m_Events |= BG_STARTING_EVENT_1;
+
+        if (!FindBgMap())
+        {
+            sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::_ProcessJoin: map (map id: %u, instance id: %u) is not created!", m_MapId, m_InstanceID);
+            EndNow();
+            return;
+        }
+
+        // Setup here, only when at least one player has ported to the map
+        if (!SetupBattleground())
+        {
+            EndNow();
+            return;
+        }
+
+        StartingEventCloseDoors();
+        SetStartDelayTime(StartDelayTimes[BG_STARTING_EVENT_FIRST]);
+        // First start warning - 2 or 1 minute
+        SendMessageToAll(StartMessageIds[BG_STARTING_EVENT_FIRST], CHAT_MSG_BG_SYSTEM_NEUTRAL);
+    }
+    // After 1 minute or 30 seconds, warning is signaled
+    else if (GetStartDelayTime() <= StartDelayTimes[BG_STARTING_EVENT_SECOND] && !(m_Events & BG_STARTING_EVENT_2))
+    {
+        m_Events |= BG_STARTING_EVENT_2;
+        SendMessageToAll(StartMessageIds[BG_STARTING_EVENT_SECOND], CHAT_MSG_BG_SYSTEM_NEUTRAL);
+    }
+    // After 30 or 15 seconds, warning is signaled
+    else if (GetStartDelayTime() <= StartDelayTimes[BG_STARTING_EVENT_THIRD] && !(m_Events & BG_STARTING_EVENT_3))
+    {
+        m_Events |= BG_STARTING_EVENT_3;
+        SendMessageToAll(StartMessageIds[BG_STARTING_EVENT_THIRD], CHAT_MSG_BG_SYSTEM_NEUTRAL);
+    }
+    // Delay expired (after 2 or 1 minute)
+    else if (GetStartDelayTime() <= 0 && !(m_Events & BG_STARTING_EVENT_4))
+    {
+        m_Events |= BG_STARTING_EVENT_4;
+
+        StartingEventOpenDoors();
+
+        SendWarningToAll(StartMessageIds[BG_STARTING_EVENT_FOURTH]);
+        SetStatus(STATUS_IN_PROGRESS);
+        SetStartDelayTime(StartDelayTimes[BG_STARTING_EVENT_FOURTH]);
+
+        // Remove preparation
+        if (isArena())
+        {
+            // TODO : add arena sound PlaySoundToAll(SOUND_ARENA_START);
+            for (BattlegroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
+                if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+                {
+                    // BG Status packet
+                    WorldPacket status;
+                    BattlegroundQueueTypeId bgQueueTypeId = sBattlegroundMgr->BGQueueTypeId(m_TypeID, GetArenaType());
+                    uint32 queueSlot = player->GetBattlegroundQueueIndex(bgQueueTypeId);
+                    sBattlegroundMgr->BuildBattlegroundStatusPacket(&status, this, player, queueSlot, STATUS_IN_PROGRESS, player->GetBattlegroundQueueJoinTime(m_TypeID), GetElapsedTime(), GetArenaType());
+                    player->GetSession()->SendPacket(&status);
+
+                    // Correctly display EnemyUnitFrame
+                    player->SetByteValue(PLAYER_BYTES_3, 3, player->GetBGTeam());
+
+                    player->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
+                    player->ResetAllPowers();
+                    if (!player->isGameMaster())
+                    {
+                        // remove auras with duration lower than 30s
+                        Unit::AuraApplicationMap & auraMap = player->GetAppliedAuras();
+                        for (Unit::AuraApplicationMap::iterator iter = auraMap.begin(); iter != auraMap.end();)
+                        {
+                            AuraApplication * aurApp = iter->second;
+                            Aura* aura = aurApp->GetBase();
+                            if (!aura->IsPermanent()
+                                && aura->GetDuration() <= 30*IN_MILLISECONDS
+                                && aurApp->IsPositive()
+                                && (!(aura->GetSpellInfo()->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY))
+                                && (!aura->HasEffectType(SPELL_AURA_MOD_INVISIBILITY)))
+                                player->RemoveAura(iter);
+                            else
+                                ++iter;
+                        }
+
+                        if (Pet* pet = player->GetPet())
+                        {
+                            // remove auras with duration lower than 30s
+                            Unit::AuraApplicationMap & auraMap = pet->GetAppliedAuras();
+                            for (Unit::AuraApplicationMap::iterator iter = auraMap.begin(); iter != auraMap.end();)
+                            {
+                                AuraApplication * aurApp = iter->second;
+                                Aura* aura = aurApp->GetBase();
+                                if (!aura->IsPermanent()
+                                    && aura->GetDuration() <= 30*IN_MILLISECONDS
+                                    && aurApp->IsPositive()
+                                    && (!(aura->GetSpellInfo()->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY))
+                                    && (!aura->HasEffectType(SPELL_AURA_MOD_INVISIBILITY)))
+                                    pet->RemoveAura(iter);
+                                else
+                                    ++iter;
+                            }
+                        }
+                    }
+                }
+
+            CheckArenaWinConditions();
+        }
+        else
+        {
+            PlaySoundToAll(SOUND_BG_START);
+
+            for (BattlegroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
+                if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+                {
+                    player->RemoveAurasDueToSpell(SPELL_PREPARATION);
+                    player->ResetAllPowers();
+                }
+            // Announce BG starting
+            if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_ENABLE))
+                sWorld->SendWorldText(LANG_BG_STARTED_ANNOUNCE_WORLD, GetName(), GetMinLevel(), GetMaxLevel());
+        }
+    }
+
+    if (GetRemainingTime() > 0 && (m_EndTime -= diff) > 0)
+        SetRemainingTime(GetRemainingTime() - diff);
+}
+
+inline void Battleground::_ProcessLeave(uint32 diff)
+{
+    // *********************************************************
+    // ***           BATTLEGROUND ENDING SYSTEM              ***
+    // *********************************************************
+    // remove all players from battleground after 2 minutes
+    SetRemainingTime(GetRemainingTime() - diff);
+    if (GetRemainingTime() <= 0)
+    {
+        SetRemainingTime(0);
+        BattlegroundPlayerMap::iterator itr, next;
+        for (itr = m_Players.begin(); itr != m_Players.end(); itr = next)
+        {
+            next = itr;
+            ++next;
+            //itr is erased here!
+            RemovePlayerAtLeave(itr->first, true, true);// remove player from BG
+            // do not change any battleground's private variables
+        }
+    }
+}
+
+inline Player* Battleground::_GetPlayer(uint64 guid, bool offlineRemove, char const* context) const
+{
+    Player* player = NULL;
+    if (!offlineRemove)
+    {
+        player = ObjectAccessor::FindPlayer(guid);
+        if (!player)
+            sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::%s: player (GUID: %u) not found for BG (map: %u, instance id: %u)!",
+                context, GUID_LOPART(guid), m_MapId, m_InstanceID);
+    }
+    return player;
+}
+
+inline Player* Battleground::_GetPlayer(BattlegroundPlayerMap::iterator itr, char const* context)
+{
+    return _GetPlayer(itr->first, itr->second.OfflineRemoveTime, context);
+}
+
+inline Player* Battleground::_GetPlayer(BattlegroundPlayerMap::const_iterator itr, char const* context) const
+{
+    return _GetPlayer(itr->first, itr->second.OfflineRemoveTime, context);
+}
+
+inline Player* Battleground::_GetPlayerForTeam(uint32 teamId, BattlegroundPlayerMap::const_iterator itr, char const* context) const
+{
+    Player* player = _GetPlayer(itr, context);
+    if (player)
+    {
+        uint32 team = itr->second.Team;
+        if (!team)
+            team = player->GetTeam();
+        if (team != teamId)
+            player = NULL;
+    }
+    return player;
+}
+
+void Battleground::SetTeamStartLoc(uint32 TeamID, float X, float Y, float Z, float O)
+{
+    TeamId idx = GetTeamIndexByTeamId(TeamID);
+    m_TeamStartLocX[idx] = X;
+    m_TeamStartLocY[idx] = Y;
+    m_TeamStartLocZ[idx] = Z;
+    m_TeamStartLocO[idx] = O;
+}
+
+void Battleground::SendPacketToAll(WorldPacket* packet)
+{
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+        if (Player* player = _GetPlayer(itr, "SendPacketToAll"))
+            player->GetSession()->SendPacket(packet);
+}
+
+void Battleground::SendPacketToTeam(uint32 TeamID, WorldPacket* packet, Player* sender, bool self)
+{
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+        if (Player* player = _GetPlayerForTeam(TeamID, itr, "SendPacketToTeam"))
+            if (self || sender != player)
+            {
+                WorldSession* session = player->GetSession();
+                sLog->outDebug(LOG_FILTER_BATTLEGROUND, "%s %s - SendPacketToTeam %u, Player: %s", GetOpcodeNameForLogging(packet->GetOpcode()).c_str(),
+                    session->GetPlayerInfo().c_str(), TeamID, sender ? sender->GetName().c_str() : "null");
+                session->SendPacket(packet);
+            }
+}
+
+void Battleground::PlaySoundToAll(uint32 SoundID)
+{
+    WorldPacket data;
+    sBattlegroundMgr->BuildPlaySoundPacket(&data, SoundID);
+    SendPacketToAll(&data);
+}
+
+void Battleground::PlaySoundToTeam(uint32 SoundID, uint32 TeamID)
+{
+    WorldPacket data;
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+        if (Player* player = _GetPlayerForTeam(TeamID, itr, "PlaySoundToTeam"))
+        {
+            sBattlegroundMgr->BuildPlaySoundPacket(&data, SoundID);
+            player->GetSession()->SendPacket(&data);
+        }
+}
+
+void Battleground::CastSpellOnTeam(uint32 SpellID, uint32 TeamID)
+{
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+        if (Player* player = _GetPlayerForTeam(TeamID, itr, "CastSpellOnTeam"))
+            player->CastSpell(player, SpellID, true);
+}
+
+void Battleground::RemoveAuraOnTeam(uint32 SpellID, uint32 TeamID)
+{
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+        if (Player* player = _GetPlayerForTeam(TeamID, itr, "RemoveAuraOnTeam"))
+            player->RemoveAura(SpellID);
+}
+
+void Battleground::YellToAll(Creature* creature, char const* text, uint32 language)
+{
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+        if (Player* player = _GetPlayer(itr, "YellToAll"))
+        {
+            WorldPacket data(SMSG_MESSAGECHAT, 200);
+            creature->BuildMonsterChat(&data, CHAT_MSG_MONSTER_YELL, text, language, creature->GetName(), itr->first);
+            player->GetSession()->SendPacket(&data);
+        }
+}
+
+void Battleground::RewardHonorToTeam(uint32 Honor, uint32 TeamID)
+{
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+        if (Player* player = _GetPlayerForTeam(TeamID, itr, "RewardHonorToTeam"))
+            UpdatePlayerScore(player, SCORE_BONUS_HONOR, Honor);
+}
+
+void Battleground::RewardReputationToTeam(uint32 faction_id, uint32 Reputation, uint32 TeamID)
+{
+    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction_id))
+        for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+            if (Player* player = _GetPlayerForTeam(TeamID, itr, "RewardReputationToTeam"))
+                player->GetReputationMgr().ModifyReputation(factionEntry, Reputation);
+}
+
+void Battleground::UpdateWorldState(uint32 Field, uint32 Value)
+{
+    WorldPacket data;
+    sBattlegroundMgr->BuildUpdateWorldStatePacket(&data, Field, Value);
+    SendPacketToAll(&data);
+}
+
+void Battleground::UpdateWorldStateForPlayer(uint32 Field, uint32 Value, Player* Source)
+{
+    WorldPacket data;
+    sBattlegroundMgr->BuildUpdateWorldStatePacket(&data, Field, Value);
+    Source->GetSession()->SendPacket(&data);
+}
+
+void Battleground::EndBattleground(uint32 winner)
+{
+    RemoveFromBGFreeSlotQueue();
+
+    ArenaTeam* winnerArenaTeam = NULL;
+    ArenaTeam* loserArenaTeam = NULL;
+
+    uint32 loserTeamRating = 0;
+    uint32 loserMatchmakerRating = 0;
+    int32  loserChange = 0;
+    int32  loserMatchmakerChange = 0;
+    uint32 winnerTeamRating = 0;
+    uint32 winnerMatchmakerRating = 0;
+    int32  winnerChange = 0;
+    int32  winnerMatchmakerChange = 0;
+
+    int32 winmsg_id = 0;
+
+    if (winner == ALLIANCE)
+    {
+        winmsg_id = isBattleground() ? LANG_BG_A_WINS : LANG_ARENA_GOLD_WINS;
+
+        PlaySoundToAll(SOUND_ALLIANCE_WINS);                // alliance wins sound
+
+        SetWinner(WINNER_ALLIANCE);
+    }
+    else if (winner == HORDE)
+    {
+        winmsg_id = isBattleground() ? LANG_BG_H_WINS : LANG_ARENA_GREEN_WINS;
+
+        PlaySoundToAll(SOUND_HORDE_WINS);                   // horde wins sound
+
+        SetWinner(WINNER_HORDE);
+    }
+    else
+    {
+        SetWinner(3);
+    }
+
+    SetStatus(STATUS_WAIT_LEAVE);
+    //we must set it this way, because end time is sent in packet!
+    SetRemainingTime(TIME_AUTOCLOSE_BATTLEGROUND);
+
+    // arena rating calculation
+    if (isArena() && isRated())
+    {
+        winnerArenaTeam = sArenaTeamMgr->GetArenaTeamById(GetArenaTeamIdForTeam(winner));
+        loserArenaTeam = sArenaTeamMgr->GetArenaTeamById(GetArenaTeamIdForTeam(GetOtherTeam(winner)));
+
+        if (winnerArenaTeam && loserArenaTeam && winnerArenaTeam != loserArenaTeam)
+        {
+            if (winner != WINNER_NONE)
+            {
+                loserTeamRating = loserArenaTeam->GetRating();
+                loserMatchmakerRating = GetArenaMatchmakerRating(GetOtherTeam(winner));
+                winnerTeamRating = winnerArenaTeam->GetRating();
+                winnerMatchmakerRating = GetArenaMatchmakerRating(winner);
+                winnerMatchmakerChange = winnerArenaTeam->WonAgainst(winnerMatchmakerRating, loserMatchmakerRating, winnerChange);
+                loserMatchmakerChange = loserArenaTeam->LostAgainst(loserMatchmakerRating, winnerMatchmakerRating, loserChange);
+                sLog->outDebug(LOG_FILTER_ARENAS, "match Type: %u --- Winner: old rating: %u, rating gain: %d, old MMR: %u, MMR gain: %d --- Loser: old rating: %u, rating loss: %d, old MMR: %u, MMR loss: %d ---", m_ArenaType, winnerTeamRating, winnerChange, winnerMatchmakerRating,
+                    winnerMatchmakerChange, loserTeamRating, loserChange, loserMatchmakerRating, loserMatchmakerChange);
+                SetArenaMatchmakerRating(winner, winnerMatchmakerRating + winnerMatchmakerChange);
+                SetArenaMatchmakerRating(GetOtherTeam(winner), loserMatchmakerRating + loserMatchmakerChange);
+                SetArenaTeamRatingChangeForTeam(winner, winnerChange);
+                SetArenaTeamRatingChangeForTeam(GetOtherTeam(winner), loserChange);
+                sLog->outDebug(LOG_FILTER_ARENAS, "Arena match Type: %u for Team1Id: %u - Team2Id: %u ended. WinnerTeamId: %u. Winner rating: +%d, Loser rating: %d", m_ArenaType, m_ArenaTeamIds[TEAM_ALLIANCE], m_ArenaTeamIds[TEAM_HORDE], winnerArenaTeam->GetId(), winnerChange, loserChange);
+                if (sWorld->getBoolConfig(CONFIG_ARENA_LOG_EXTENDED_INFO))
+                    for (Battleground::BattlegroundScoreMap::const_iterator itr = GetPlayerScoresBegin(); itr != GetPlayerScoresEnd(); ++itr)
+                        if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+                        {
+                            sLog->outDebug(LOG_FILTER_ARENAS, "Statistics match Type: %u for %s (GUID: " UI64FMTD ", Team: %d, IP: %s): %u damage, %u healing, %u killing blows",
+                                m_ArenaType, player->GetName().c_str(), itr->first, player->GetArenaTeamId(m_ArenaType == 5 ? 2 : m_ArenaType == 3),
+                                player->GetSession()->GetRemoteAddress().c_str(), itr->second->DamageDone, itr->second->HealingDone,
+                                itr->second->KillingBlows);
+                        }
+            }
+            // Deduct 16 points from each teams arena-rating if there are no winners after 45+2 minutes
+            else
+            {
+                SetArenaTeamRatingChangeForTeam(ALLIANCE, ARENA_TIMELIMIT_POINTS_LOSS);
+                SetArenaTeamRatingChangeForTeam(HORDE, ARENA_TIMELIMIT_POINTS_LOSS);
+                winnerArenaTeam->FinishGame(ARENA_TIMELIMIT_POINTS_LOSS, true);
+                loserArenaTeam->FinishGame(ARENA_TIMELIMIT_POINTS_LOSS, true);
+            }
+        }
+        else
+        {
+            SetArenaTeamRatingChangeForTeam(ALLIANCE, 0);
+            SetArenaTeamRatingChangeForTeam(HORDE, 0);
+        }
+    }
+
+    bool guildAwarded = false;
+    WorldPacket pvpLogData;
+    sBattlegroundMgr->BuildPvpLogDataPacket(&pvpLogData, this);
+
+    BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(GetTypeID(), GetArenaType());
+
+    uint8 aliveWinners = GetAlivePlayersCountByTeam(winner);
+    for (BattlegroundPlayerMap::iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+    {
+        uint32 team = itr->second.Team;
+
+        if (itr->second.OfflineRemoveTime)
+        {
+            //if rated arena match - make member lost!
+            if (isArena() && isRated() && winnerArenaTeam && loserArenaTeam && winnerArenaTeam != loserArenaTeam)
+            {
+                if (team == winner)
+                    winnerArenaTeam->OfflineMemberLost(itr->first, loserMatchmakerRating, winnerMatchmakerChange);
+                else
+                    loserArenaTeam->OfflineMemberLost(itr->first, winnerMatchmakerRating, loserMatchmakerChange);
+            }
+            continue;
+        }
+
+        Player* player = _GetPlayer(itr, "EndBattleground");
+        if (!player)
+            continue;
+
+        // should remove spirit of redemption
+        if (player->HasAuraType(SPELL_AURA_SPIRIT_OF_REDEMPTION))
+            player->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
+
+        // Last standing - Rated 5v5 arena & be solely alive player
+        if (team == winner && isArena() && isRated() && GetArenaType() == ARENA_TYPE_5v5 && aliveWinners == 1 && player->isAlive())
+            player->CastSpell(player, SPELL_THE_LAST_STANDING, true);
+
+        if (!player->isAlive())
+        {
+            player->ResurrectPlayer(1.0f);
+            player->SpawnCorpseBones();
+        }
+        else
+        {
+            //needed cause else in av some creatures will kill the players at the end
+            player->CombatStop();
+            player->getHostileRefManager().deleteReferences();
+        }
+
+        // per player calculation
+        if (isArena() && isRated() && winnerArenaTeam && loserArenaTeam && winnerArenaTeam != loserArenaTeam)
+        {
+            if (team == winner)
+            {
+                // Modify the guild reputation and xp - 62 rep on win, 27.9k guild xp. Only if group is guild group.
+                if (Guild* guild = sGuildMgr->GetGuildById(player->GetGuildId()))
+                {
+                    uint32 guildXP = uint32(27900);
+                    uint32 guildRep = uint32(guildXP / 450);
+                    guild->GiveXP(guildXP, player);
+                    guild->GainReputation(player->GetGUID(), 62);
+                }
+
+                // update achievement BEFORE personal rating update
+                uint32 rating = player->GetArenaPersonalRating(winnerArenaTeam->GetSlot());
+                player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_RATED_ARENA, rating ? rating : 1);
+                player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_ARENA, GetMapId());
+                player->ModifyCurrency(CURRENCY_TYPE_CONQUEST_META_ARENA, sWorld->getIntConfig(CONFIG_CURRENCY_CONQUEST_POINTS_ARENA_REWARD), true, true); // should give end of week
+
+				// Update max week rating
+				player->UpdateMaxWeekRating(CP_SOURCE_ARENA, winnerArenaTeam->GetSlot());
+
+                winnerArenaTeam->MemberWon(player, loserMatchmakerRating, winnerMatchmakerChange);
+
+                if (Guild *guild = player->GetGuild())
+                    if (Group *group = GetBgRaid(team))
+                        if (group->IsGuildGroupFor(player))
+                        {
+                            guild->GiveXP(sWorld->getIntConfig(CONFIG_GUILD_XP_REWARD_ARENA), player);
+                            uint32 guildRep = std::max(uint32(1), uint32(sWorld->getIntConfig(CONFIG_GUILD_XP_REWARD_ARENA)/450));
+                            guild->GiveReputation(guildRep, player);
+                        }
+            }
+            else
+            {
+                if (winnerArenaTeam->IsMember(player->GetGUID()))
+                    winnerArenaTeam->MemberLost(player, winnerMatchmakerRating, loserMatchmakerChange);
+                else if (loserArenaTeam->IsMember(player->GetGUID()))
+                    loserArenaTeam->MemberLost(player, winnerMatchmakerRating, loserMatchmakerChange);
+
+                // Arena lost => reset the win_rated_arena having the "no_lose" condition
+                player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_RATED_ARENA, ACHIEVEMENT_CRITERIA_CONDITION_NO_LOSE);
+            }
+        }
+
+        uint32 winner_honor = player->GetRandomWinner() ? BG_REWARD_WINNER_HONOR_LAST : BG_REWARD_WINNER_HONOR_FIRST;
+        uint32 loser_honor = player->GetRandomWinner() ? BG_REWARD_LOSER_HONOR_LAST : BG_REWARD_LOSER_HONOR_FIRST;
+
+        // remove temporary currency bonus auras before rewarding player
+        player->RemoveAura(SPELL_HONORABLE_DEFENDER_25Y);
+        player->RemoveAura(SPELL_HONORABLE_DEFENDER_60Y);
+
+        // Reward winner team
+        if (team == winner)
+        {
+            if (IsRandom() || BattlegroundMgr::IsBGWeekend(GetTypeID()))
+                UpdatePlayerScore(player, SCORE_BONUS_HONOR, winner_honor);
+
+            if (IsRandom())
+            {
+                if (BattlegroundMgr::IsBGWeekend(GetTypeID()))
+                {
+                    if (!player->GetRandomWinner())
+                    {
+                        // 100cp awarded for the first random battleground won each day
+                        player->ModifyCurrency(CURRENCY_TYPE_CONQUEST_META_RBG, BG_REWARD_WINNER_CONQUEST_FIRST, true, true);
+                        player->SetRandomWinner(true);
+                    }
+                }
+                else // 50cp awarded for each non-rated battleground won
+                    player->ModifyCurrency(CURRENCY_TYPE_CONQUEST_META_RBG, BG_REWARD_WINNER_CONQUEST_LAST, true, true);
+            }
+
+            // Modify the guild reputation and xp - 167 rep on win, 75k guild xp. Only if group is guild group.
+            if (Guild* guild = sGuildMgr->GetGuildById(player->GetGuildId()))
+            {
+                uint32 guildXP = uint32(75150);
+                uint32 guildRep = uint32(guildXP / 450);
+                guild->GiveXP(guildXP, player);
+                guild->GainReputation(player->GetGUID(), 167);
+            }
+
+            player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_BG, 1);
+            if (!guildAwarded)
+            {
+                guildAwarded = true;
+                if (uint32 guildId = GetBgMap()->GetOwnerGuildId(player->GetTeam()))
+                    if (Guild* guild = sGuildMgr->GetGuildById(guildId))
+                    {
+                        guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_BG, 1, 0, 0, NULL, player);
+                        if (isArena() && isRated() && winnerArenaTeam && loserArenaTeam && winnerArenaTeam != loserArenaTeam)
+                            guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_RATED_ARENA, std::max<uint32>(winnerArenaTeam->GetRating(), 1), 0, 0, NULL, player);
+                    }
+            }
+        }
+        else
+        {
+            if (IsRandom() || BattlegroundMgr::IsBGWeekend(GetTypeID()))
+                UpdatePlayerScore(player, SCORE_BONUS_HONOR, loser_honor);
+        }
+
+        if (isBattleground())
+            if(player->GetTeam() && m_BgRaids[player->GetTeam()])
+                if (Guild* guild = sGuildMgr->GetGuildById(player->GetGuildId()))
+                    guild->GetChallengesMgr()->CheckBattlegroundChallenge(this, m_BgRaids[player->GetTeam()]);
+
+        player->ResetAllPowers();
+        player->CombatStopWithPets(true);
+
+        BlockMovement(player);
+
+        player->GetSession()->SendPacket(&pvpLogData);
+
+        WorldPacket data;
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, player->GetBattlegroundQueueJoinTime(GetTypeID()), GetElapsedTime(), GetArenaType());
+        player->GetSession()->SendPacket(&data);
+
+        player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_BATTLEGROUND, 1);
+    }
+
+    if (isArena() && isRated() && winnerArenaTeam && loserArenaTeam && winnerArenaTeam != loserArenaTeam)
+    {
+        // save the stat changes
+        winnerArenaTeam->SaveToDB();
+        loserArenaTeam->SaveToDB();
+        // send updated arena team stats to players
+        // this way all arena team members will get notified, not only the ones who participated in this match
+        winnerArenaTeam->NotifyStatsChanged();
+        loserArenaTeam->NotifyStatsChanged();
+    }
+
+    if (winmsg_id)
+        SendMessageToAll(winmsg_id, CHAT_MSG_BG_SYSTEM_NEUTRAL);
+}
+
+uint32 Battleground::GetBonusHonorFromKill(uint32 kills) const
+{
+    //variable kills means how many honorable kills you scored (so we need kills * honor_for_one_kill)
+    uint32 maxLevel = std::min<uint32>(GetMaxLevel(), 80U);
+    return Trinity::Honor::hk_honor_at_level(maxLevel, float(kills));
+}
+
+void Battleground::BlockMovement(Player* player)
+{
+    player->SetClientControl(player, 0);                          // movement disabled NOTE: the effect will be automatically removed by client when the player is teleported from the battleground, so no need to send with uint8(1) in RemovePlayerAtLeave()
+}
+
+void Battleground::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPacket)
+{
+    uint32 team = GetPlayerTeam(guid);
+    bool participant = false;
+    // Remove from lists/maps
+    BattlegroundPlayerMap::iterator itr = m_Players.find(guid);
+    if (itr != m_Players.end())
+    {
+        UpdatePlayersCountByTeam(team, true);               // -1 player
+        m_Players.erase(itr);
+        // check if the player was a participant of the match, or only entered through gm command (goname)
+        participant = true;
+    }
+
+    BattlegroundScoreMap::iterator itr2 = PlayerScores.find(guid);
+    if (!isArena() && itr2 != PlayerScores.end())
+    {
+        delete itr2->second;                                // delete player's score
+        PlayerScores.erase(itr2);
+    }
+
+    RemovePlayerFromResurrectQueue(guid);
+
+    Player* player = ObjectAccessor::FindPlayer(guid);
+
+    // should remove spirit of redemption
+    if (player)
+    {
+        if (player->HasAuraType(SPELL_AURA_SPIRIT_OF_REDEMPTION))
+            player->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
+
+        if (!player->isAlive())                              // resurrect on exit
+        {
+            player->ResurrectPlayer(1.0f);
+            player->SpawnCorpseBones();
+        }
+    }
+
+    BattlegroundTypeId bgTypeId = GetTypeID();
+    BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(GetTypeID(), GetArenaType());
+
+    if (participant) // if the player was a match participant, remove auras, calc rating, update queue
+    {
+        if (player)
+        {
+            player->ClearAfkReports();
+
+            if (!team) team = player->GetTeam();
+
+            // if arena, remove the specific arena auras
+            if (isArena() && GetStatus() != STATUS_WAIT_LEAVE)
+            {
+                bgTypeId = BATTLEGROUND_AA;                   // set the bg type to all arenas (it will be used for queue refreshing)
+                if (isRated())
+                {
+                    //left a rated match while the encounter was in progress, consider as loser
+                    ArenaTeam* winnerArenaTeam = sArenaTeamMgr->GetArenaTeamById(GetArenaTeamIdForTeam(GetOtherTeam(team)));
+                    ArenaTeam* loserArenaTeam = sArenaTeamMgr->GetArenaTeamById(GetArenaTeamIdForTeam(team));
+                    if (winnerArenaTeam && loserArenaTeam && winnerArenaTeam != loserArenaTeam)
+                        loserArenaTeam->MemberLost(player, GetArenaMatchmakerRating(GetOtherTeam(team)));
+                }
+            }
+            if (SendPacket)
+            {
+                WorldPacket data;
+                sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_NONE, player->GetBattlegroundQueueJoinTime(bgTypeId), 0, m_ArenaType);
+                player->GetSession()->SendPacket(&data);
+            }
+
+            // this call is important, because player, when joins to battleground, this method is not called, so it must be called when leaving bg
+            player->RemoveBattlegroundQueueId(bgQueueTypeId);
+        }
+        else
+        // removing offline participant
+        {
+            if (isRated() && GetStatus() == STATUS_IN_PROGRESS)
+            {
+                //left a rated match while the encounter was in progress, consider as loser
+                ArenaTeam* others_arena_team = sArenaTeamMgr->GetArenaTeamById(GetArenaTeamIdForTeam(GetOtherTeam(team)));
+                ArenaTeam* players_arena_team = sArenaTeamMgr->GetArenaTeamById(GetArenaTeamIdForTeam(team));
+                if (others_arena_team && players_arena_team)
+                    players_arena_team->OfflineMemberLost(guid, GetArenaMatchmakerRating(GetOtherTeam(team)));
+            }
+        }
+
+        // remove from raid group if player is member
+        if (Group* group = GetBgRaid(team))
+        {
+            if (!group->RemoveMember(guid))                // group was disbanded
+            {
+                SetBgRaid(team, NULL);
+            }
+        }
+        DecreaseInvitedCount(team);
+        //we should update battleground queue, but only if bg isn't ending
+        if (isBattleground() && GetStatus() < STATUS_WAIT_LEAVE)
+        {
+            // a player has left the battleground, so there are free slots -> add to queue
+            AddToBGFreeSlotQueue();
+            sBattlegroundMgr->ScheduleQueueUpdate(0, 0, bgQueueTypeId, bgTypeId, GetBracketId());
+        }
+        // Let others know
+        WorldPacket data;
+        sBattlegroundMgr->BuildPlayerLeftBattlegroundPacket(&data, guid);
+        SendPacketToTeam(team, &data, player, false);
+    }
+
+    RemovePlayer(player, guid, team);                           // BG subclass specific code
+
+    if (player)
+    {
+        // Do next only if found in battleground
+        player->SetBattlegroundId(0, BATTLEGROUND_TYPE_NONE);  // We're not in BG.
+        // reset destination bg team
+        player->SetBGTeam(0);
+        player->RemoveBattlegroundQueueJoinTime(bgTypeId);
+
+        if (Transport)
+            player->TeleportToBGEntryPoint();
+
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Removed player %s from Battleground.", player->GetName().c_str());
+    }
+
+    //battleground object will be deleted next Battleground::Update() call
+}
+
+// this method is called when no players remains in battleground
+void Battleground::Reset()
+{
+    SetWinner(WINNER_NONE);
+    SetStatus(STATUS_WAIT_QUEUE);
+    SetElapsedTime(0);
+    SetRemainingTime(0);
+    SetLastResurrectTime(0);
+    m_Events = 0;
+
+    if (m_InvitedAlliance > 0 || m_InvitedHorde > 0)
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::Reset: one of the counters is not 0 (alliance: %u, horde: %u) for BG (map: %u, instance id: %u)!",
+            m_InvitedAlliance, m_InvitedHorde, m_MapId, m_InstanceID);
+
+    m_InvitedAlliance = 0;
+    m_InvitedHorde = 0;
+    m_InBGFreeSlotQueue = false;
+
+    m_Players.clear();
+
+    for (BattlegroundScoreMap::const_iterator itr = PlayerScores.begin(); itr != PlayerScores.end(); ++itr)
+        delete itr->second;
+    PlayerScores.clear();
+
+    ResetBGSubclass();
+}
+
+void Battleground::StartBattleground()
+{
+    SetElapsedTime(0);
+    SetLastResurrectTime(0);
+    // add BG to free slot queue
+    AddToBGFreeSlotQueue();
+
+    // add bg to update list
+    // This must be done here, because we need to have already invited some players when first BG::Update() method is executed
+    // and it doesn't matter if we call StartBattleground() more times, because m_Battlegrounds is a map and instance id never changes
+    sBattlegroundMgr->AddBattleground(this);
+
+    if (m_IsRated)
+        sLog->outDebug(LOG_FILTER_ARENAS, "Arena match type: %u for Team1Id: %u - Team2Id: %u started.", m_ArenaType, m_ArenaTeamIds[TEAM_ALLIANCE], m_ArenaTeamIds[TEAM_HORDE]);
+}
+
+void Battleground::AddPlayer(Player* player)
+{
+	if (player->getClass() == CLASS_DRUID)
+	{
+		//Check For Druid Flight form
+		if (player->HasAura(40120) || player->HasAura(33943))
+		{
+			player->RemoveAura(40120);
+			player->RemoveAura(33943);
+		}
+	}
+
+    // remove afk from player
+    if (player->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_AFK))
+        player->ToggleAFK();
+
+    // score struct must be created in inherited class
+
+    uint64 guid = player->GetGUID();
+    uint32 team = player->GetBGTeam();
+
+    BattlegroundPlayer bp;
+    bp.OfflineRemoveTime = 0;
+    bp.Team = team;
+
+    // Add to list/maps
+    m_Players[guid] = bp;
+
+    UpdatePlayersCountByTeam(team, false);                  // +1 player
+
+    WorldPacket data;
+    sBattlegroundMgr->BuildPlayerJoinedBattlegroundPacket(&data, player->GetGUID());
+    SendPacketToTeam(team, &data, player, false);
+
+    // BG Status packet
+    BattlegroundQueueTypeId bgQueueTypeId = sBattlegroundMgr->BGQueueTypeId(m_TypeID, GetArenaType());
+    uint32 queueSlot = player->GetBattlegroundQueueIndex(bgQueueTypeId);
+
+    sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player, queueSlot, STATUS_IN_PROGRESS, player->GetBattlegroundQueueJoinTime(m_TypeID), GetElapsedTime(), GetArenaType());
+    player->GetSession()->SendPacket(&data);
+
+    player->RemoveAurasByType(SPELL_AURA_MOUNTED);
+    player->_markedReady = false;
+
+    // add arena specific auras
+    if (isArena())
+    {
+        player->RemoveArenaEnchantments(TEMP_ENCHANTMENT_SLOT);
+        if (team == ALLIANCE)                                // gold
+        {
+            if (player->GetTeam() == HORDE)
+                player->CastSpell(player, SPELL_HORDE_GOLD_FLAG, true);
+            else
+                player->CastSpell(player, SPELL_ALLIANCE_GOLD_FLAG, true);
+        }
+        else                                                // green
+        {
+            if (player->GetTeam() == HORDE)
+                player->CastSpell(player, SPELL_HORDE_GREEN_FLAG, true);
+            else
+                player->CastSpell(player, SPELL_ALLIANCE_GREEN_FLAG, true);
+        }
+
+        player->DestroyConjuredItems(true);
+
+        if (GetStatus() == STATUS_WAIT_JOIN)                 // not started yet
+        {
+            player->CastSpell(player, SPELL_ARENA_PREPARATION, true);
+            player->ResetAllPowers();
+        }
+    }
+    else
+    {
+        if (GetStatus() == STATUS_WAIT_JOIN)                 // not started yet
+        {
+            player->CastSpell(player, SPELL_PREPARATION, true);   // reduces all mana cost of spells.
+
+            int32 countdownMaxForBGType = isArena() ? ARENA_COUNTDOWN_MAX : BATTLEGROUND_COUNTDOWN_MAX;
+            WorldPacket data(SMSG_START_TIMER, 4+4+4);
+            data << uint32(0); // unk
+            data << uint32(countdownMaxForBGType - (GetElapsedTime() / 1000));
+            data << uint32(countdownMaxForBGType);
+            player->GetSession()->SendPacket(&data);
+        }
+    }
+
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_BG, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DAMAGE_DONE, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_CAST_SPELL, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HEALING_DONE, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+    player->ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, ACHIEVEMENT_CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
+
+    // setup BG group membership
+    PlayerAddedToBGCheckIfBGIsRunning(player);
+    AddOrSetPlayerToCorrectBgGroup(player, team);
+}
+
+// this method adds player to his team's bg group, or sets his correct group if player is already in bg group
+void Battleground::AddOrSetPlayerToCorrectBgGroup(Player* player, uint32 team)
+{
+    uint64 playerGuid = player->GetGUID();
+    Group* group = GetBgRaid(team);
+    if (!group)                                      // first player joined
+    {
+        group = new Group;
+        SetBgRaid(team, group);
+        group->Create(player);
+    }
+    else                                            // raid already exist
+    {
+        if (group->IsMember(playerGuid))
+        {
+            uint8 subgroup = group->GetMemberGroup(playerGuid);
+            player->SetBattlegroundOrBattlefieldRaid(group, subgroup);
+        }
+        else
+        {
+            group->AddMember(player);
+            if (Group* originalGroup = player->GetOriginalGroup())
+                if (originalGroup->IsLeader(playerGuid))
+                {
+                    group->ChangeLeader(playerGuid);
+                    group->SendUpdate();
+                }
+        }
+    }
+}
+
+// This method should be called when player logs into running battleground
+void Battleground::EventPlayerLoggedIn(Player* player)
+{
+    uint64 guid = player->GetGUID();
+    // player is correct pointer
+    for (std::deque<uint64>::iterator itr = m_OfflineQueue.begin(); itr != m_OfflineQueue.end(); ++itr)
+    {
+        if (*itr == guid)
+        {
+            m_OfflineQueue.erase(itr);
+            break;
+        }
+    }
+    m_Players[guid].OfflineRemoveTime = 0;
+    PlayerAddedToBGCheckIfBGIsRunning(player);
+    // if battleground is starting, then add preparation aura
+    // we don't have to do that, because preparation aura isn't removed when player logs out
+}
+
+// This method should be called when player logs out from running battleground
+void Battleground::EventPlayerLoggedOut(Player* player)
+{
+    uint64 guid = player->GetGUID();
+    if (!IsPlayerInBattleground(guid))  // Check if this player really is in battleground (might be a GM who teleported inside)
+        return;
+
+    // player is correct pointer, it is checked in WorldSession::LogoutPlayer()
+    m_OfflineQueue.push_back(player->GetGUID());
+    m_Players[guid].OfflineRemoveTime = sWorld->GetGameTime() + MAX_OFFLINE_TIME;
+    if (GetStatus() == STATUS_IN_PROGRESS)
+    {
+        // drop flag and handle other cleanups
+        RemovePlayer(player, guid, GetPlayerTeam(guid));
+
+        // 1 player is logging out, if it is the last, then end arena!
+        if (isArena())
+            if (GetAlivePlayersCountByTeam(player->GetBGTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetBGTeam())))
+                EndBattleground(GetOtherTeam(player->GetBGTeam()));
+    }
+}
+
+// This method should be called only once ... it adds pointer to queue
+void Battleground::AddToBGFreeSlotQueue()
+{
+    if (!m_InBGFreeSlotQueue && isBattleground())
+    {
+        sBattlegroundMgr->AddToBGFreeSlotQueue(m_TypeID, this);
+        m_InBGFreeSlotQueue = true;
+    }
+}
+
+// This method removes this battleground from free queue - it must be called when deleting battleground
+void Battleground::RemoveFromBGFreeSlotQueue()
+{
+    if (m_InBGFreeSlotQueue)
+    {
+        sBattlegroundMgr->RemoveFromBGFreeSlotQueue(m_TypeID, m_InstanceID);
+        m_InBGFreeSlotQueue = false;
+    }
+}
+
+// get the number of free slots for team
+// returns the number how many players can join battleground to MaxPlayersPerTeam
+uint32 Battleground::GetFreeSlotsForTeam(uint32 Team) const
+{
+    // if BG is starting ... invite anyone
+    if (GetStatus() == STATUS_WAIT_JOIN)
+        return (GetInvitedCount(Team) < GetMaxPlayersPerTeam()) ? GetMaxPlayersPerTeam() - GetInvitedCount(Team) : 0;
+    // if BG is already started .. do not allow to join too much players of one faction
+    uint32 otherTeam;
+    uint32 otherIn;
+    if (Team == ALLIANCE)
+    {
+        otherTeam = GetInvitedCount(HORDE);
+        otherIn = GetPlayersCountByTeam(HORDE);
+    }
+    else
+    {
+        otherTeam = GetInvitedCount(ALLIANCE);
+        otherIn = GetPlayersCountByTeam(ALLIANCE);
+    }
+    if (GetStatus() == STATUS_IN_PROGRESS)
+    {
+        // difference based on ppl invited (not necessarily entered battle)
+        // default: allow 0
+        uint32 diff = 0;
+        // allow join one person if the sides are equal (to fill up bg to minplayersperteam)
+        if (otherTeam == GetInvitedCount(Team))
+            diff = 1;
+        // allow join more ppl if the other side has more players
+        else if (otherTeam > GetInvitedCount(Team))
+            diff = otherTeam - GetInvitedCount(Team);
+
+        // difference based on max players per team (don't allow inviting more)
+        uint32 diff2 = (GetInvitedCount(Team) < GetMaxPlayersPerTeam()) ? GetMaxPlayersPerTeam() - GetInvitedCount(Team) : 0;
+        // difference based on players who already entered
+        // default: allow 0
+        uint32 diff3 = 0;
+        // allow join one person if the sides are equal (to fill up bg minplayersperteam)
+        if (otherIn == GetPlayersCountByTeam(Team))
+            diff3 = 1;
+        // allow join more ppl if the other side has more players
+        else if (otherIn > GetPlayersCountByTeam(Team))
+            diff3 = otherIn - GetPlayersCountByTeam(Team);
+        // or other side has less than minPlayersPerTeam
+        else if (GetInvitedCount(Team) <= GetMinPlayersPerTeam())
+            diff3 = GetMinPlayersPerTeam() - GetInvitedCount(Team) + 1;
+
+        // return the minimum of the 3 differences
+
+        // min of diff and diff 2
+        diff = std::min(diff, diff2);
+        // min of diff, diff2 and diff3
+        return std::min(diff, diff3);
+    }
+    return 0;
+}
+
+bool Battleground::HasFreeSlots() const
+{
+    return GetPlayersSize() < GetMaxPlayers();
+}
+
+void Battleground::UpdatePlayerScore(Player* Source, uint32 type, uint32 value, bool doAddHonor)
+{
+    //this procedure is called from virtual function implemented in bg subclass
+    BattlegroundScoreMap::const_iterator itr = PlayerScores.find(Source->GetGUID());
+    if (itr == PlayerScores.end())                         // player not found...
+        return;
+
+    switch (type)
+    {
+        case SCORE_KILLING_BLOWS:                           // Killing blows
+            itr->second->KillingBlows += value;
+            break;
+        case SCORE_DEATHS:                                  // Deaths
+            itr->second->Deaths += value;
+            break;
+        case SCORE_HONORABLE_KILLS:                         // Honorable kills
+            itr->second->HonorableKills += value;
+            break;
+        case SCORE_BONUS_HONOR:                             // Honor bonus
+            // do not add honor in arenas
+            if (isBattleground())
+            {
+                // reward honor instantly
+                if (doAddHonor)
+                    Source->RewardHonor(NULL, 1, value);    // RewardHonor calls UpdatePlayerScore with doAddHonor = false
+                else
+                    itr->second->BonusHonor += value;
+            }
+            break;
+            // used only in EY, but in MSG_PVP_LOG_DATA opcode
+        case SCORE_DAMAGE_DONE:                             // Damage Done
+            itr->second->DamageDone += value;
+            break;
+        case SCORE_HEALING_DONE:                            // Healing Done
+            itr->second->HealingDone += value;
+            break;
+        default:
+            sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::UpdatePlayerScore: unknown score type (%u) for BG (map: %u, instance id: %u)!",
+                type, m_MapId, m_InstanceID);
+            break;
+    }
+}
+
+void Battleground::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    m_ReviveQueue[npc_guid].push_back(player_guid);
+
+    Player* player = ObjectAccessor::FindPlayer(player_guid);
+    if (!player)
+        return;
+
+    player->CastSpell(player, SPELL_WAITING_FOR_RESURRECT, true);
+}
+
+void Battleground::RemovePlayerFromResurrectQueue(uint64 player_guid)
+{
+    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+    {
+        for (std::vector<uint64>::iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+        {
+            if (*itr2 == player_guid)
+            {
+                (itr->second).erase(itr2);
+                if (Player* player = ObjectAccessor::FindPlayer(player_guid))
+                    player->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
+                return;
+            }
+        }
+    }
+}
+
+bool Battleground::AddObject(uint32 type, uint32 entry, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3, uint32 /*respawnTime*/)
+{
+    // If the assert is called, means that BgObjects must be resized!
+//    ASSERT(type < BgObjects.size()); // Just to be sure, if we know how to solve this crash
+
+    Map* map = FindBgMap();
+    if (!map)
+        return false;
+    // Must be created this way, adding to godatamap would add it to the base map of the instance
+    // and when loading it (in go::LoadFromDB()), a new guid would be assigned to the object, and a new object would be created
+    // So we must create it specific for this instance
+    GameObject* go = new GameObject;
+    if (!go->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT), entry, GetBgMap(),
+        PHASEMASK_NORMAL, x, y, z, o, rotation0, rotation1, rotation2, rotation3, 100, GO_STATE_READY))
+    {
+        sLog->outError(LOG_FILTER_SQL, "Battleground::AddObject: cannot create gameobject (entry: %u) for BG (map: %u, instance id: %u)!",
+                entry, m_MapId, m_InstanceID);
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::AddObject: cannot create gameobject (entry: %u) for BG (map: %u, instance id: %u)!",
+                entry, m_MapId, m_InstanceID);
+        delete go;
+        return false;
+    }
+/*
+    uint32 guid = go->GetGUIDLow();
+
+    // without this, UseButtonOrDoor caused the crash, since it tried to get go info from godata
+    // iirc that was changed, so adding to go data map is no longer required if that was the only function using godata from GameObject without checking if it existed
+    GameObjectData& data = sObjectMgr->NewGOData(guid);
+
+    data.id             = entry;
+    data.mapid          = GetMapId();
+    data.posX           = x;
+    data.posY           = y;
+    data.posZ           = z;
+    data.orientation    = o;
+    data.rotation0      = rotation0;
+    data.rotation1      = rotation1;
+    data.rotation2      = rotation2;
+    data.rotation3      = rotation3;
+    data.spawntimesecs  = respawnTime;
+    data.spawnMask      = 1;
+    data.animprogress   = 100;
+    data.go_state       = 1;
+*/
+    // Add to world, so it can be later looked up from HashMapHolder
+    if (!map->AddToMap(go))
+    {
+        delete go;
+        return false;
+    }
+    BgObjects[type] = go->GetGUID();
+    return true;
+}
+
+// Some doors aren't despawned so we cannot handle their closing in gameobject::update()
+// It would be nice to correctly implement GO_ACTIVATED state and open/close doors in gameobject code
+void Battleground::DoorClose(uint32 type)
+{
+    if (GameObject* obj = GetBgMap()->GetGameObject(BgObjects[type]))
+    {
+        // If doors are open, close it
+        if (obj->getLootState() == GO_ACTIVATED && obj->GetGoState() != GO_STATE_READY)
+        {
+            obj->SetLootState(GO_READY);
+            obj->SetGoState(GO_STATE_READY);
+        }
+    }
+    else
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::DoorClose: door gameobject (type: %u, GUID: %u) not found for BG (map: %u, instance id: %u)!",
+            type, GUID_LOPART(BgObjects[type]), m_MapId, m_InstanceID);
+}
+
+void Battleground::DoorOpen(uint32 type)
+{
+    if (GameObject* obj = GetBgMap()->GetGameObject(BgObjects[type]))
+    {
+        obj->SetLootState(GO_ACTIVATED);
+        obj->SetGoState(GO_STATE_ACTIVE);
+    }
+    else
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::DoorOpen: door gameobject (type: %u, GUID: %u) not found for BG (map: %u, instance id: %u)!",
+            type, GUID_LOPART(BgObjects[type]), m_MapId, m_InstanceID);
+}
+
+GameObject* Battleground::GetBGObject(uint32 type)
+{
+    GameObject* obj = GetBgMap()->GetGameObject(BgObjects[type]);
+    if (!obj)
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::GetBGObject: gameobject (type: %u, GUID: %u) not found for BG (map: %u, instance id: %u)!",
+            type, GUID_LOPART(BgObjects[type]), m_MapId, m_InstanceID);
+    return obj;
+}
+
+Creature* Battleground::GetBGCreature(uint32 type)
+{
+    Creature* creature = GetBgMap()->GetCreature(BgCreatures[type]);
+    if (!creature)
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::GetBGCreature: creature (type: %u, GUID: %u) not found for BG (map: %u, instance id: %u)!",
+            type, GUID_LOPART(BgCreatures[type]), m_MapId, m_InstanceID);
+    return creature;
+}
+
+void Battleground::SpawnBGObject(uint32 type, uint32 respawntime)
+{
+    if (Map* map = FindBgMap())
+        if (GameObject* obj = map->GetGameObject(BgObjects[type]))
+        {
+            if (respawntime)
+                obj->SetLootState(GO_JUST_DEACTIVATED);
+            else
+                if (obj->getLootState() == GO_JUST_DEACTIVATED)
+                    // Change state from GO_JUST_DEACTIVATED to GO_READY in case battleground is starting again
+                    obj->SetLootState(GO_READY);
+            obj->SetRespawnTime(respawntime);
+            map->AddToMap(obj);
+        }
+}
+
+Creature* Battleground::AddCreature(uint32 entry, uint32 type, uint32 teamval, float x, float y, float z, float o, uint32 respawntime)
+{
+    // If the assert is called, means that BgCreatures must be resized!
+    //ASSERT(type < BgCreatures.size());
+    if (type >= BgCreatures.size())
+        return NULL;
+
+    Map* map = FindBgMap();
+    if (!map)
+        return NULL;
+
+    Creature* creature = new Creature;
+    if (!creature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), map, PHASEMASK_NORMAL, entry, 0, teamval, x, y, z, o))
+    {
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::AddCreature: cannot create creature (entry: %u) for BG (map: %u, instance id: %u)!",
+            entry, m_MapId, m_InstanceID);
+        delete creature;
+        return NULL;
+    }
+
+    creature->SetHomePosition(x, y, z, o);
+
+    CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(entry);
+    if (!cinfo)
+    {
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::AddCreature: creature template (entry: %u) does not exist for BG (map: %u, instance id: %u)!",
+            entry, m_MapId, m_InstanceID);
+        delete creature;
+        return NULL;
+    }
+    // Force using DB speeds
+    creature->SetSpeed(MOVE_WALK,  cinfo->speed_walk);
+    creature->SetSpeed(MOVE_RUN,   cinfo->speed_run);
+
+    if (!map->AddToMap(creature))
+    {
+        delete creature;
+        return NULL;
+    }
+
+    BgCreatures[type] = creature->GetGUID();
+
+    if (respawntime)
+        creature->SetRespawnDelay(respawntime);
+
+    return  creature;
+}
+
+bool Battleground::DelCreature(uint32 type)
+{
+    if (!BgCreatures[type])
+        return true;
+
+    if (Creature* creature = GetBgMap()->GetCreature(BgCreatures[type]))
+    {
+        creature->AddObjectToRemoveList();
+        BgCreatures[type] = 0;
+        return true;
+    }
+
+    sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::DelCreature: creature (type: %u, GUID: %u) not found for BG (map: %u, instance id: %u)!",
+        type, GUID_LOPART(BgCreatures[type]), m_MapId, m_InstanceID);
+    BgCreatures[type] = 0;
+    return false;
+}
+
+bool Battleground::DelObject(uint32 type)
+{
+    if (!BgObjects[type])
+        return true;
+
+    if (GameObject* obj = GetBgMap()->GetGameObject(BgObjects[type]))
+    {
+        obj->SetRespawnTime(0);                                 // not save respawn time
+        obj->Delete();
+        BgObjects[type] = 0;
+        return true;
+    }
+    sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::DelObject: gameobject (type: %u, GUID: %u) not found for BG (map: %u, instance id: %u)!",
+        type, GUID_LOPART(BgObjects[type]), m_MapId, m_InstanceID);
+    BgObjects[type] = 0;
+    return false;
+}
+
+bool Battleground::AddSpiritGuide(uint32 type, float x, float y, float z, float o, uint32 team)
+{
+    uint32 entry = (team == ALLIANCE) ?
+        BG_CREATURE_ENTRY_A_SPIRITGUIDE :
+        BG_CREATURE_ENTRY_H_SPIRITGUIDE;
+
+    if (Creature* creature = AddCreature(entry, type, team, x, y, z, o))
+    {
+        creature->setDeathState(DEAD);
+        creature->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, creature->GetGUID());
+        // aura
+        // TODO: Fix display here
+        // creature->SetVisibleAura(0, SPELL_SPIRIT_HEAL_CHANNEL);
+        // casting visual effect
+        creature->SetUInt32Value(UNIT_CHANNEL_SPELL, SPELL_SPIRIT_HEAL_CHANNEL);
+        // correct cast speed
+        creature->SetFloatValue(UNIT_MOD_CAST_SPEED, 1.0f);
+        creature->SetFloatValue(UNIT_MOD_CAST_HASTE, 1.0f);
+        //creature->CastSpell(creature, SPELL_SPIRIT_HEAL_CHANNEL, true);
+        return true;
+    }
+    sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::AddSpiritGuide: cannot create spirit guide (type: %u, entry: %u) for BG (map: %u, instance id: %u)!",
+        type, entry, m_MapId, m_InstanceID);
+    EndNow();
+    return false;
+}
+
+void Battleground::SendMessageToAll(int32 entry, ChatMsg type, Player const* source)
+{
+    if (!entry)
+        return;
+
+    Trinity::BattlegroundChatBuilder bg_builder(type, entry, source);
+    Trinity::LocalizedPacketDo<Trinity::BattlegroundChatBuilder> bg_do(bg_builder);
+    BroadcastWorker(bg_do);
+}
+
+void Battleground::PSendMessageToAll(int32 entry, ChatMsg type, Player const* source, ...)
+{
+    if (!entry)
+        return;
+
+    va_list ap;
+    va_start(ap, source);
+
+    Trinity::BattlegroundChatBuilder bg_builder(type, entry, source, &ap);
+    Trinity::LocalizedPacketDo<Trinity::BattlegroundChatBuilder> bg_do(bg_builder);
+    BroadcastWorker(bg_do);
+
+    va_end(ap);
+}
+
+void Battleground::SendWarningToAll(int32 entry, ...)
+{
+    if (!entry)
+        return;
+
+    char const* format = sObjectMgr->GetTrinityStringForDBCLocale(entry);
+
+    char str[1024];
+    va_list ap;
+    va_start(ap, entry);
+    vsnprintf(str, 1024, format, ap);
+    va_end(ap);
+    std::string msg(str);
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+
+    data << (uint8)CHAT_MSG_RAID_BOSS_EMOTE;
+    data << (uint32)LANG_UNIVERSAL;
+    data << (uint64)0;
+    data << (uint32)0;                                     // 2.1.0
+    data << (uint32)1;
+    data << (uint8)0;
+    data << (uint64)0;
+    data << (uint32)(msg.length() + 1);
+    data << msg.c_str();
+    data << (uint8)0;
+    data << (float)0.0f;                                   // added in 4.2.0, unk
+    data << (uint8)0;                                      // added in 4.2.0, unk
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+        if (Player* player = ObjectAccessor::FindPlayer(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+            if (player->GetSession())
+                player->GetSession()->SendPacket(&data);
+}
+
+void Battleground::SendMessage2ToAll(int32 entry, ChatMsg type, Player const* source, int32 arg1, int32 arg2)
+{
+    Trinity::Battleground2ChatBuilder bg_builder(type, entry, source, arg1, arg2);
+    Trinity::LocalizedPacketDo<Trinity::Battleground2ChatBuilder> bg_do(bg_builder);
+    BroadcastWorker(bg_do);
+}
+
+void Battleground::EndNow()
+{
+    RemoveFromBGFreeSlotQueue();
+    SetStatus(STATUS_WAIT_LEAVE);
+    SetRemainingTime(0);
+}
+
+// To be removed
+char const* Battleground::GetTrinityString(int32 entry)
+{
+    // FIXME: now we have different DBC locales and need localized message for each target client
+    return sObjectMgr->GetTrinityStringForDBCLocale(entry);
+}
+
+// IMPORTANT NOTICE:
+// buffs aren't spawned/despawned when players captures anything
+// buffs are in their positions when battleground starts
+void Battleground::HandleTriggerBuff(uint64 go_guid)
+{
+    GameObject* obj = GetBgMap()->GetGameObject(go_guid);
+    if (!obj || obj->GetGoType() != GAMEOBJECT_TYPE_TRAP || !obj->isSpawned())
+        return;
+
+    // Change buff type, when buff is used:
+    int32 index = BgObjects.size() - 1;
+    while (index >= 0 && BgObjects[index] != go_guid)
+        index--;
+    if (index < 0)
+    {
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::HandleTriggerBuff: cannot find buff gameobject (GUID: %u, entry: %u, type: %u) in internal data for BG (map: %u, instance id: %u)!",
+            GUID_LOPART(go_guid), obj->GetEntry(), obj->GetGoType(), m_MapId, m_InstanceID);
+        return;
+    }
+
+    // Randomly select new buff
+    uint8 buff = urand(0, 2);
+    uint32 entry = obj->GetEntry();
+    if (m_BuffChange && entry != Buff_Entries[buff])
+    {
+        // Despawn current buff
+        SpawnBGObject(index, RESPAWN_ONE_DAY);
+        // Set index for new one
+        for (uint8 currBuffTypeIndex = 0; currBuffTypeIndex < 3; ++currBuffTypeIndex)
+            if (entry == Buff_Entries[currBuffTypeIndex])
+            {
+                index -= currBuffTypeIndex;
+                index += buff;
+            }
+    }
+
+    SpawnBGObject(index, BUFF_RESPAWN_TIME);
+}
+
+void Battleground::HandleKillPlayer(Player* victim, Player* killer)
+{
+    // Keep in mind that for arena this will have to be changed a bit
+
+    // Add +1 deaths
+    UpdatePlayerScore(victim, SCORE_DEATHS, 1);
+    // Add +1 kills to group and +1 killing_blows to killer
+    if (killer)
+    {
+        // Don't reward credit for killing ourselves, like fall damage of hellfire (warlock)
+        if (killer == victim)
+            return;
+
+        UpdatePlayerScore(killer, SCORE_HONORABLE_KILLS, 1);
+        UpdatePlayerScore(killer, SCORE_KILLING_BLOWS, 1);
+
+        for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+        {
+            Player* creditedPlayer = ObjectAccessor::FindPlayer(itr->first);
+            if (!creditedPlayer || creditedPlayer == killer)
+                continue;
+
+            if (creditedPlayer->GetTeam() == killer->GetTeam() && creditedPlayer->IsAtGroupRewardDistance(victim))
+                UpdatePlayerScore(creditedPlayer, SCORE_HONORABLE_KILLS, 1);
+        }
+    }
+
+    if (!isArena())
+    {
+        // To be able to remove insignia -- ONLY IN Battlegrounds
+        victim->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
+        RewardXPAtKill(killer, victim);
+    }
+}
+
+// Return the player's team based on battlegroundplayer info
+// Used in same faction arena matches mainly
+uint32 Battleground::GetPlayerTeam(uint64 guid) const
+{
+    BattlegroundPlayerMap::const_iterator itr = m_Players.find(guid);
+    if (itr != m_Players.end())
+        return itr->second.Team;
+    return 0;
+}
+
+uint32 Battleground::GetOtherTeam(uint32 teamId) const
+{
+    return teamId ? ((teamId == ALLIANCE) ? HORDE : ALLIANCE) : 0;
+}
+
+bool Battleground::IsPlayerInBattleground(uint64 guid) const
+{
+    BattlegroundPlayerMap::const_iterator itr = m_Players.find(guid);
+    if (itr != m_Players.end())
+        return true;
+    return false;
+}
+
+void Battleground::PlayerAddedToBGCheckIfBGIsRunning(Player* player)
+{
+    if (GetStatus() != STATUS_WAIT_LEAVE)
+        return;
+
+    WorldPacket data;
+    BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(GetTypeID(), GetArenaType());
+
+    BlockMovement(player);
+
+    sBattlegroundMgr->BuildPvpLogDataPacket(&data, this);
+    player->GetSession()->SendPacket(&data);
+
+    sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, player->GetBattlegroundQueueJoinTime(GetTypeID()), GetElapsedTime(), GetArenaType());
+    player->GetSession()->SendPacket(&data);
+}
+
+uint32 Battleground::GetAlivePlayersCountByTeam(uint32 Team) const
+{
+    int count = 0;
+    for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
+    {
+        if (itr->second.Team == Team)
+        {
+            Player* player = ObjectAccessor::FindPlayer(itr->first);
+            if (player && player->isAlive() && !player->HasByteFlag(UNIT_FIELD_BYTES_2, 3, FORM_SPIRITOFREDEMPTION))
+                ++count;
+        }
+    }
+    return count;
+}
+
+void Battleground::SetHoliday(bool is_holiday)
+{
+    m_HonorMode = is_holiday ? BG_HOLIDAY : BG_NORMAL;
+}
+
+int32 Battleground::GetObjectType(uint64 guid)
+{
+    for (uint32 i = 0; i < BgObjects.size(); ++i)
+        if (BgObjects[i] == guid)
+            return i;
+    sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground::GetObjectType: player used gameobject (GUID: %u) which is not in internal data for BG (map: %u, instance id: %u), cheating?",
+        GUID_LOPART(guid), m_MapId, m_InstanceID);
+    return -1;
+}
+
+void Battleground::HandleKillUnit(Creature* /*victim*/, Player* /*killer*/)
+{
+}
+
+void Battleground::CheckArenaAfterTimerConditions()
+{
+    EndBattleground(WINNER_NONE);
+}
+
+void Battleground::CheckArenaWinConditions()
+{
+    if (!GetAlivePlayersCountByTeam(ALLIANCE) && GetPlayersCountByTeam(HORDE))
+        EndBattleground(HORDE);
+    else if (GetPlayersCountByTeam(ALLIANCE) && !GetAlivePlayersCountByTeam(HORDE))
+        EndBattleground(ALLIANCE);
+}
+
+void Battleground::UpdateArenaWorldState()
+{
+    UpdateWorldState(0xe10, GetAlivePlayersCountByTeam(HORDE));
+    UpdateWorldState(0xe11, GetAlivePlayersCountByTeam(ALLIANCE));
+}
+
+void Battleground::SetBgRaid(uint32 TeamID, Group* bg_raid)
+{
+    Group*& old_raid = TeamID == ALLIANCE ? m_BgRaids[TEAM_ALLIANCE] : m_BgRaids[TEAM_HORDE];
+    if (old_raid)
+        old_raid->SetBattlegroundGroup(NULL);
+    if (bg_raid)
+        bg_raid->SetBattlegroundGroup(this);
+    old_raid = bg_raid;
+}
+
+WorldSafeLocsEntry const* Battleground::GetClosestGraveYard(Player* player)
+{
+    return sObjectMgr->GetClosestGraveYard(player->GetPositionX(), player->GetPositionY(), player->GetPositionZ(), player->GetMapId(), player->GetTeam());
+}
+
+void Battleground::StartTimedAchievement(AchievementCriteriaTimedTypes type, uint32 entry)
+{
+    for (BattlegroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end(); ++itr)
+        if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+            player->StartTimedAchievement(type, entry);
+}
+
+void Battleground::SetBracket(PvPDifficultyEntry const* bracketEntry)
+{
+    m_BracketId = bracketEntry->GetBracketId();
+    SetLevelRange(bracketEntry->minLevel, bracketEntry->maxLevel);
+}
+
+void Battleground::RewardXPAtKill(Player* killer, Player* victim)
+{
+    if (sWorld->getBoolConfig(CONFIG_BG_XP_FOR_KILL) && killer && victim)
+        killer->RewardPlayerAndGroupAtKill(victim, true);
+}
+
+uint32 Battleground::GetTeamScore(uint32 teamId) const
+{
+    if (teamId == TEAM_ALLIANCE || teamId == TEAM_HORDE)
+        return m_TeamScores[teamId];
+
+    sLog->outError(LOG_FILTER_BATTLEGROUND, "GetTeamScore with wrong Team %u for BG %u", teamId, GetTypeID());
+    return 0;
+}
+
+void Battleground::HandleAreaTrigger(Player* player, uint32 trigger)
+{
+    sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Unhandled AreaTrigger %u in Battleground %u. Player coords (x: %f, y: %f, z: %f)",
+                   trigger, player->GetMapId(), player->GetPositionX(), player->GetPositionY(), player->GetPositionZ());
+}
diff --git a/src/server/game/Battlegrounds/Battleground.h b/src/server/game/Battlegrounds/Battleground.h
index d142d18..374dd26 100644
--- a/src/server/game/Battlegrounds/Battleground.h
+++ b/src/server/game/Battlegrounds/Battleground.h
@@ -203,7 +203,7 @@ enum ArenaType
 {
     ARENA_TYPE_2v2          = 2,
     ARENA_TYPE_3v3          = 3,
-    ARENA_TYPE_5v5          = 5
+    ARENA_TYPE_5v5          = 1 // 1v1 Arena - 5v5 doesn't exist anymore
 };
 
 enum BattlegroundType
diff --git a/src/server/game/Battlegrounds/Battleground.h.orig b/src/server/game/Battlegrounds/Battleground.h.orig
new file mode 100644
index 0000000..d142d18
--- /dev/null
+++ b/src/server/game/Battlegrounds/Battleground.h.orig
@@ -0,0 +1,682 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __BATTLEGROUND_H
+#define __BATTLEGROUND_H
+
+#include "Common.h"
+#include "SharedDefines.h"
+#include "DBCEnums.h"
+
+class Creature;
+class GameObject;
+class Group;
+class Player;
+class WorldPacket;
+class BattlegroundMap;
+
+struct PvPDifficultyEntry;
+struct WorldSafeLocsEntry;
+
+enum BattlegroundSounds
+{
+    SOUND_HORDE_WINS                = 8454,
+    SOUND_ALLIANCE_WINS             = 8455,
+    SOUND_BG_START                  = 3439,
+    SOUND_BG_START_L70ETC           = 11803
+};
+
+enum BattlegroundQuests
+{
+    SPELL_WS_QUEST_REWARD           = 43483,
+    SPELL_AB_QUEST_REWARD           = 43484,
+    SPELL_AV_QUEST_REWARD           = 43475,
+    SPELL_AV_QUEST_KILLED_BOSS      = 23658,
+    SPELL_EY_QUEST_REWARD           = 43477,
+    SPELL_SA_QUEST_REWARD           = 61213,
+    SPELL_AB_QUEST_REWARD_4_BASES   = 24061,
+    SPELL_AB_QUEST_REWARD_5_BASES   = 24064
+};
+
+enum BattlegroundMarks
+{
+    SPELL_WS_MARK_LOSER             = 24950,
+    SPELL_WS_MARK_WINNER            = 24951,
+    SPELL_AB_MARK_LOSER             = 24952,
+    SPELL_AB_MARK_WINNER            = 24953,
+    SPELL_AV_MARK_LOSER             = 24954,
+    SPELL_AV_MARK_WINNER            = 24955,
+    SPELL_SA_MARK_WINNER            = 61160,
+    SPELL_SA_MARK_LOSER             = 61159,
+    ITEM_AV_MARK_OF_HONOR           = 20560,
+    ITEM_WS_MARK_OF_HONOR           = 20558,
+    ITEM_AB_MARK_OF_HONOR           = 20559,
+    ITEM_EY_MARK_OF_HONOR           = 29024,
+    ITEM_SA_MARK_OF_HONOR           = 42425
+};
+
+enum BattlegroundMarksCount
+{
+    ITEM_WINNER_COUNT               = 3,
+    ITEM_LOSER_COUNT                = 1
+};
+
+enum BattlegroundCreatures
+{
+    BG_CREATURE_ENTRY_A_SPIRITGUIDE      = 13116,           // alliance
+    BG_CREATURE_ENTRY_H_SPIRITGUIDE      = 13117            // horde
+};
+
+enum BattlegroundSpells
+{
+    SPELL_WAITING_FOR_RESURRECT     = 2584,                 // Waiting to Resurrect
+    SPELL_SPIRIT_HEAL_CHANNEL       = 22011,                // Spirit Heal Channel
+    SPELL_SPIRIT_HEAL               = 22012,                // Spirit Heal
+    SPELL_RESURRECTION_VISUAL       = 24171,                // Resurrection Impact Visual
+    SPELL_ARENA_PREPARATION         = 32727,                // use this one, 32728 not correct
+    SPELL_ALLIANCE_GOLD_FLAG        = 32724,
+    SPELL_ALLIANCE_GREEN_FLAG       = 32725,
+    SPELL_HORDE_GOLD_FLAG           = 35774,
+    SPELL_HORDE_GREEN_FLAG          = 35775,
+    SPELL_PREPARATION               = 44521,                // Preparation
+    SPELL_SPIRIT_HEAL_MANA          = 44535,                // Spirit Heal
+    SPELL_RECENTLY_DROPPED_FLAG     = 42792,                // Recently Dropped Flag
+    SPELL_AURA_PLAYER_INACTIVE      = 43681,                // Inactive
+    SPELL_HONORABLE_DEFENDER_25Y    = 68652,                // +50% honor when standing at a capture point that you control, 25yards radius (added in 3.2)
+    SPELL_HONORABLE_DEFENDER_60Y    = 66157,                // +50% honor when standing at a capture point that you control, 60yards radius (added in 3.2), probably for 40+ player battlegrounds
+    SPELL_THE_LAST_STANDING         = 26549                 // Arena achievement related
+};
+
+enum BattlegroundTimeIntervals
+{
+    CHECK_PLAYER_POSITION_INVERVAL  = 1000,                 // ms
+    RESURRECTION_INTERVAL           = 30000,                // ms
+    //REMIND_INTERVAL                 = 10000,                // ms
+    INVITATION_REMIND_TIME          = 20000,                // ms
+    INVITE_ACCEPT_WAIT_TIME         = 90000,                // ms
+    TIME_AUTOCLOSE_BATTLEGROUND     = 120000,               // ms
+    MAX_OFFLINE_TIME                = 300,                  // secs
+    RESPAWN_ONE_DAY                 = 86400,                // secs
+    RESPAWN_IMMEDIATELY             = 0,                    // secs
+    BUFF_RESPAWN_TIME               = 180,                  // secs
+    BATTLEGROUND_COUNTDOWN_MAX      = 120,                  // secs
+    ARENA_COUNTDOWN_MAX             = 60                    // secs
+};
+
+enum BattlegroundStartTimeIntervals
+{
+    BG_START_DELAY_2M               = 120000,               // ms (2 minutes)
+    BG_START_DELAY_1M               = 60000,                // ms (1 minute)
+    BG_START_DELAY_30S              = 30000,                // ms (30 seconds)
+    BG_START_DELAY_15S              = 15000,                // ms (15 seconds) Used only in arena
+    BG_START_DELAY_NONE             = 0                     // ms
+};
+
+enum BattlegroundBuffObjects
+{
+    BG_OBJECTID_SPEEDBUFF_ENTRY     = 179871,
+    BG_OBJECTID_REGENBUFF_ENTRY     = 179904,
+    BG_OBJECTID_BERSERKERBUFF_ENTRY = 179905
+};
+
+/// Battleground currency rewards. Should be with precision mod.
+enum BattlegroundRandomRewards
+{
+    BG_REWARD_WINNER_HONOR_FIRST    = 27000,
+    BG_REWARD_WINNER_CONQUEST_FIRST = 10000,
+    BG_REWARD_WINNER_HONOR_LAST     = 13500,
+    BG_REWARD_WINNER_CONQUEST_LAST  = 5000,
+    BG_REWARD_LOSER_HONOR_FIRST     = 4500,
+    BG_REWARD_LOSER_HONOR_LAST      = 3500
+};
+
+const uint32 Buff_Entries[3] = { BG_OBJECTID_SPEEDBUFF_ENTRY, BG_OBJECTID_REGENBUFF_ENTRY, BG_OBJECTID_BERSERKERBUFF_ENTRY };
+
+enum BattlegroundStatus
+{
+    STATUS_NONE         = 0,                                // first status, should mean bg is not instance
+    STATUS_WAIT_QUEUE   = 1,                                // means bg is empty and waiting for queue
+    STATUS_WAIT_JOIN    = 2,                                // this means, that BG has already started and it is waiting for more players
+    STATUS_IN_PROGRESS  = 3,                                // means bg is running
+    STATUS_WAIT_LEAVE   = 4                                 // means some faction has won BG and it is ending
+};
+
+struct BattlegroundPlayer
+{
+    time_t  OfflineRemoveTime;                              // for tracking and removing offline players from queue after 5 minutes
+    uint32  Team;                                           // Player's team
+};
+
+struct BattlegroundObjectInfo
+{
+    BattlegroundObjectInfo() : object(NULL), timer(0), spellid(0) {}
+
+    GameObject  *object;
+    int32       timer;
+    uint32      spellid;
+};
+
+enum ScoreType
+{
+    SCORE_KILLING_BLOWS         = 1,
+    SCORE_DEATHS                = 2,
+    SCORE_HONORABLE_KILLS       = 3,
+    SCORE_BONUS_HONOR           = 4,
+    //EY, but in MSG_PVP_LOG_DATA opcode!
+    SCORE_DAMAGE_DONE           = 5,
+    SCORE_HEALING_DONE          = 6,
+    //WS and TP
+    SCORE_FLAG_CAPTURES         = 7,
+    SCORE_FLAG_RETURNS          = 8,
+    //AB IC and BFG
+    SCORE_BASES_ASSAULTED       = 9,
+    SCORE_BASES_DEFENDED        = 10,
+    //AV
+    SCORE_GRAVEYARDS_ASSAULTED  = 11,
+    SCORE_GRAVEYARDS_DEFENDED   = 12,
+    SCORE_TOWERS_ASSAULTED      = 13,
+    SCORE_TOWERS_DEFENDED       = 14,
+    SCORE_MINES_CAPTURED        = 15,
+    SCORE_LEADERS_KILLED        = 16,
+    SCORE_SECONDARY_OBJECTIVES  = 17,
+    //SOTA
+    SCORE_DESTROYED_DEMOLISHER  = 18,
+    SCORE_DESTROYED_WALL        = 19
+};
+
+enum ArenaType
+{
+    ARENA_TYPE_2v2          = 2,
+    ARENA_TYPE_3v3          = 3,
+    ARENA_TYPE_5v5          = 5
+};
+
+enum BattlegroundType
+{
+    TYPE_BATTLEGROUND     = 3,
+    TYPE_ARENA            = 4
+};
+
+enum BattlegroundWinner
+{
+    WINNER_HORDE            = 0,
+    WINNER_ALLIANCE         = 1,
+    WINNER_NONE             = 2
+};
+
+enum BattlegroundTeamId
+{
+    BG_TEAM_ALLIANCE = 0,
+    BG_TEAM_HORDE = 1
+};
+
+#define BG_TEAMS_COUNT  2
+
+enum BattlegroundStartingEvents
+{
+    BG_STARTING_EVENT_NONE  = 0x00,
+    BG_STARTING_EVENT_1     = 0x01,
+    BG_STARTING_EVENT_2     = 0x02,
+    BG_STARTING_EVENT_3     = 0x04,
+    BG_STARTING_EVENT_4     = 0x08
+};
+
+enum BattlegroundStartingEventsIds
+{
+    BG_STARTING_EVENT_FIRST     = 0,
+    BG_STARTING_EVENT_SECOND    = 1,
+    BG_STARTING_EVENT_THIRD     = 2,
+    BG_STARTING_EVENT_FOURTH    = 3
+};
+#define BG_STARTING_EVENT_COUNT 4
+
+struct BattlegroundScore
+{
+    BattlegroundScore() : KillingBlows(0), Deaths(0), HonorableKills(0), BonusHonor(0),
+        DamageDone(0), HealingDone(0), BgTeam(0), TalentTree(0)
+    { }
+
+    virtual ~BattlegroundScore() { }                        //virtual destructor is used when deleting score from scores map
+
+    uint32 KillingBlows;
+    uint32 Deaths;
+    uint32 HonorableKills;
+    uint32 BonusHonor;
+    uint32 DamageDone;
+    uint32 HealingDone;
+    uint32 BgTeam;
+    uint32 TalentTree;
+};
+
+enum BGHonorMode
+{
+    BG_NORMAL = 0,
+    BG_HOLIDAY,
+    BG_HONOR_MODE_NUM
+};
+
+#define BG_AWARD_ARENA_POINTS_MIN_LEVEL 71
+#define ARENA_TIMELIMIT_POINTS_LOSS    -12
+
+/*
+This class is used to:
+1. Add player to battleground
+2. Remove player from battleground
+3. some certain cases, same for all battlegrounds
+4. It has properties same for all battlegrounds
+*/
+class Battleground
+{
+    public:
+        Battleground();
+        virtual ~Battleground();
+
+        void Update(uint32 diff);
+
+        virtual bool SetupBattleground()                    // must be implemented in BG subclass
+        {
+            return true;
+        }
+        virtual void Reset();                               // resets all common properties for battlegrounds, must be implemented and called in BG subclass
+        virtual void StartingEventCloseDoors() { }
+        virtual void StartingEventOpenDoors() { }
+        virtual void ResetBGSubclass() { }                  // must be implemented in BG subclass
+
+        virtual void DestroyGate(Player* /*player*/, GameObject* /*go*/) {}
+
+        /* achievement req. */
+        virtual bool IsAllNodesConrolledByTeam(uint32 /*team*/) const { return false; }
+        void StartTimedAchievement(AchievementCriteriaTimedTypes type, uint32 entry);
+
+        /* Battleground */
+        // Get methods:
+        char const* GetName() const         { return m_Name; }
+        uint64 GetGUID() { return m_Guid; }
+        BattlegroundTypeId GetTypeID(bool GetRandom = false) const { return GetRandom ? m_RandomTypeID : m_TypeID; }
+        BattlegroundBracketId GetBracketId() const { return m_BracketId; }
+        uint32 GetInstanceID() const        { return m_InstanceID; }
+        BattlegroundStatus GetStatus() const { return m_Status; }
+        uint32 GetClientInstanceID() const  { return m_ClientInstanceID; }
+        uint32 GetElapsedTime() const       { return m_StartTime; }
+        uint32 GetRemainingTime() const     { return m_EndTime; }
+        uint32 GetLastResurrectTime() const { return m_LastResurrectTime; }
+        uint32 GetMaxPlayers() const        { return m_MaxPlayers; }
+        uint32 GetMinPlayers() const        { return m_MinPlayers; }
+
+        uint32 GetMinLevel() const          { return m_LevelMin; }
+        uint32 GetMaxLevel() const          { return m_LevelMax; }
+
+        uint32 GetMaxPlayersPerTeam() const { return m_MaxPlayersPerTeam; }
+        uint32 GetMinPlayersPerTeam() const { return m_MinPlayersPerTeam; }
+
+        int32 GetStartDelayTime() const     { return m_StartDelayTime; }
+        uint8 GetArenaType() const          { return m_ArenaType; }
+        uint8 GetWinner() const             { return m_Winner; }
+        uint32 GetScriptId() const          { return ScriptId; }
+        uint32 GetBonusHonorFromKill(uint32 kills) const;
+        bool IsRandom() const { return m_IsRandom; }
+
+        // Set methods:
+        void SetGuid(uint64 newGuid)        { m_Guid = newGuid; }
+        void SetName(char const* Name)      { m_Name = Name; }
+        void SetTypeID(BattlegroundTypeId TypeID) { m_TypeID = TypeID; }
+        void SetRandomTypeID(BattlegroundTypeId TypeID) { m_RandomTypeID = TypeID; }
+        //here we can count minlevel and maxlevel for players
+        void SetBracket(PvPDifficultyEntry const* bracketEntry);
+        void SetInstanceID(uint32 InstanceID) { m_InstanceID = InstanceID; }
+        void SetStatus(BattlegroundStatus Status) { m_Status = Status; }
+        void SetClientInstanceID(uint32 InstanceID) { m_ClientInstanceID = InstanceID; }
+        void SetElapsedTime(uint32 Time)        { m_StartTime = Time; }
+        void SetRemainingTime(uint32 Time)      { m_EndTime = Time; }
+        void SetLastResurrectTime(uint32 Time) { m_LastResurrectTime = Time; }
+        void SetMaxPlayers(uint32 MaxPlayers) { m_MaxPlayers = MaxPlayers; }
+        void SetMinPlayers(uint32 MinPlayers) { m_MinPlayers = MinPlayers; }
+        void SetLevelRange(uint32 min, uint32 max) { m_LevelMin = min; m_LevelMax = max; }
+        void SetRated(bool state)           { m_IsRated = state; }
+        void SetArenaType(uint8 type)       { m_ArenaType = type; }
+        void SetArenaorBGType(bool _isArena) { m_IsArena = _isArena; }
+        void SetWinner(uint8 winner)        { m_Winner = winner; }
+        void SetScriptId(uint32 scriptId)   { ScriptId = scriptId; }
+
+        void ModifyStartDelayTime(int diff) { m_StartDelayTime -= diff; }
+        void SetStartDelayTime(int Time)    { m_StartDelayTime = Time; }
+
+        void SetMaxPlayersPerTeam(uint32 MaxPlayers) { m_MaxPlayersPerTeam = MaxPlayers; }
+        void SetMinPlayersPerTeam(uint32 MinPlayers) { m_MinPlayersPerTeam = MinPlayers; }
+
+        void AddToBGFreeSlotQueue();                        //this queue will be useful when more battlegrounds instances will be available
+        void RemoveFromBGFreeSlotQueue();                   //this method could delete whole BG instance, if another free is available
+
+        void DecreaseInvitedCount(uint32 team)      { (team == ALLIANCE) ? --m_InvitedAlliance : --m_InvitedHorde; }
+        void IncreaseInvitedCount(uint32 team)      { (team == ALLIANCE) ? ++m_InvitedAlliance : ++m_InvitedHorde; }
+
+        void SetRandom(bool isRandom) { m_IsRandom = isRandom; }
+        uint32 GetInvitedCount(uint32 team) const   { return (team == ALLIANCE) ? m_InvitedAlliance : m_InvitedHorde; }
+        bool HasFreeSlots() const;
+        uint32 GetFreeSlotsForTeam(uint32 Team) const;
+
+        bool isArena() const        { return m_IsArena; }
+        bool isBattleground() const { return !m_IsArena; }
+        bool isRated() const        { return m_IsRated; }
+
+        typedef std::map<uint64, BattlegroundPlayer> BattlegroundPlayerMap;
+        BattlegroundPlayerMap const& GetPlayers() const { return m_Players; }
+        uint32 GetPlayersSize() const { return m_Players.size(); }
+
+        typedef std::map<uint64, BattlegroundScore*> BattlegroundScoreMap;
+        BattlegroundScoreMap::const_iterator GetPlayerScoresBegin() const { return PlayerScores.begin(); }
+        BattlegroundScoreMap::const_iterator GetPlayerScoresEnd() const { return PlayerScores.end(); }
+        uint32 GetPlayerScoresSize() const { return PlayerScores.size(); }
+
+        uint32 GetReviveQueueSize() const { return m_ReviveQueue.size(); }
+
+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
+        void RemovePlayerFromResurrectQueue(uint64 player_guid);
+
+        void StartBattleground();
+
+        GameObject* GetBGObject(uint32 type);
+        Creature* GetBGCreature(uint32 type);
+
+        // Location
+        void SetMapId(uint32 MapID) { m_MapId = MapID; }
+        uint32 GetMapId() const { return m_MapId; }
+
+        // Map pointers
+        void SetBgMap(BattlegroundMap* map) { m_Map = map; }
+        BattlegroundMap* GetBgMap() const { ASSERT(m_Map); return m_Map; }
+        BattlegroundMap* FindBgMap() const { return m_Map; }
+
+        void SetTeamStartLoc(uint32 TeamID, float X, float Y, float Z, float O);
+        void GetTeamStartLoc(uint32 TeamID, float &X, float &Y, float &Z, float &O) const
+        {
+            TeamId idx = GetTeamIndexByTeamId(TeamID);
+            X = m_TeamStartLocX[idx];
+            Y = m_TeamStartLocY[idx];
+            Z = m_TeamStartLocZ[idx];
+            O = m_TeamStartLocO[idx];
+        }
+
+        void SetStartMaxDist(float startMaxDist) { m_StartMaxDist = startMaxDist; }
+        float GetStartMaxDist() const { return m_StartMaxDist; }
+
+        // Packet Transfer
+        // method that should fill worldpacket with actual world states (not yet implemented for all battlegrounds!)
+        virtual void FillInitialWorldStates(WorldPacket& /*data*/) {}
+        void SendPacketToTeam(uint32 TeamID, WorldPacket* packet, Player* sender = NULL, bool self = true);
+        void SendPacketToAll(WorldPacket* packet);
+        void YellToAll(Creature* creature, const char* text, uint32 language);
+
+        template<class Do>
+        void BroadcastWorker(Do& _do);
+
+        void PlaySoundToTeam(uint32 SoundID, uint32 TeamID);
+        void PlaySoundToAll(uint32 SoundID);
+        void CastSpellOnTeam(uint32 SpellID, uint32 TeamID);
+        void RemoveAuraOnTeam(uint32 SpellID, uint32 TeamID);
+        void RewardHonorToTeam(uint32 Honor, uint32 TeamID);
+        void RewardReputationToTeam(uint32 faction_id, uint32 Reputation, uint32 TeamID);
+        void UpdateWorldState(uint32 Field, uint32 Value);
+        void UpdateWorldStateForPlayer(uint32 Field, uint32 Value, Player* Source);
+        void EndBattleground(uint32 winner);
+        void BlockMovement(Player* player);
+
+        void SendWarningToAll(int32 entry, ...);
+        void SendMessageToAll(int32 entry, ChatMsg type, Player const* source = NULL);
+        void PSendMessageToAll(int32 entry, ChatMsg type, Player const* source, ...);
+
+        // specialized version with 2 string id args
+        void SendMessage2ToAll(int32 entry, ChatMsg type, Player const* source, int32 strId1 = 0, int32 strId2 = 0);
+
+        // Raid Group
+        Group* GetBgRaid(uint32 TeamID) const { return TeamID == ALLIANCE ? m_BgRaids[TEAM_ALLIANCE] : m_BgRaids[TEAM_HORDE]; }
+        void SetBgRaid(uint32 TeamID, Group* bg_raid);
+
+        virtual void UpdatePlayerScore(Player* Source, uint32 type, uint32 value, bool doAddHonor = true);
+
+        static TeamId GetTeamIndexByTeamId(uint32 Team) { return Team == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
+        uint32 GetPlayersCountByTeam(uint32 Team) const { return m_PlayersCount[GetTeamIndexByTeamId(Team)]; }
+        uint32 GetAlivePlayersCountByTeam(uint32 Team) const;   // used in arenas to correctly handle death in spirit of redemption / last stand etc. (killer = killed) cases
+        void UpdatePlayersCountByTeam(uint32 Team, bool remove)
+        {
+            if (remove)
+                --m_PlayersCount[GetTeamIndexByTeamId(Team)];
+            else
+                ++m_PlayersCount[GetTeamIndexByTeamId(Team)];
+        }
+
+        // used for rated arena battles
+        void SetArenaTeamIdForTeam(uint32 Team, uint32 ArenaTeamId) { m_ArenaTeamIds[GetTeamIndexByTeamId(Team)] = ArenaTeamId; }
+        uint32 GetArenaTeamIdForTeam(uint32 Team) const             { return m_ArenaTeamIds[GetTeamIndexByTeamId(Team)]; }
+        uint32 GetArenaTeamIdByIndex(uint32 index) const { return m_ArenaTeamIds[index]; }
+        void SetArenaTeamRatingChangeForTeam(uint32 Team, int32 RatingChange) { m_ArenaTeamRatingChanges[GetTeamIndexByTeamId(Team)] = RatingChange; }
+        int32 GetArenaTeamRatingChangeForTeam(uint32 Team) const    { return m_ArenaTeamRatingChanges[GetTeamIndexByTeamId(Team)]; }
+        int32 GetArenaTeamRatingChangeByIndex(uint32 index) const   { return m_ArenaTeamRatingChanges[index]; }
+        void SetArenaMatchmakerRating(uint32 Team, uint32 MMR){ m_ArenaTeamMMR[GetTeamIndexByTeamId(Team)] = MMR; }
+        uint32 GetArenaMatchmakerRating(uint32 Team) const          { return m_ArenaTeamMMR[GetTeamIndexByTeamId(Team)]; }
+        uint32 GetArenaMatchmakerRatingByIndex(uint32 index) const  { return m_ArenaTeamMMR[index]; }
+        void CheckArenaAfterTimerConditions();
+        void CheckArenaWinConditions();
+        void UpdateArenaWorldState();
+
+        // Triggers handle
+        // must be implemented in BG subclass
+        virtual void HandleAreaTrigger(Player* /*Source*/, uint32 /*Trigger*/);
+        // must be implemented in BG subclass if need AND call base class generic code
+        virtual void HandleKillPlayer(Player* player, Player* killer);
+        virtual void HandleKillUnit(Creature* /*unit*/, Player* /*killer*/);
+
+        // Battleground events
+        virtual void EventPlayerDroppedFlag(Player* /*player*/) {}
+        virtual void EventPlayerClickedOnFlag(Player* /*player*/, GameObject* /*target_obj*/) {}
+        void EventPlayerLoggedIn(Player* player);
+        void EventPlayerLoggedOut(Player* player);
+        virtual void EventPlayerDamagedGO(Player* /*player*/, GameObject* /*go*/, uint32 /*eventType*/) {}
+        virtual void EventPlayerUsedGO(Player* /*player*/, GameObject* /*go*/){}
+
+        // this function can be used by spell to interact with the BG map
+        virtual void DoAction(uint32 /*action*/, uint64 /*var*/) {}
+
+        virtual void HandlePlayerResurrect(Player* /*player*/) {}
+
+        // Death related
+        virtual WorldSafeLocsEntry const* GetClosestGraveYard(Player* player);
+
+        virtual void AddPlayer(Player* player);                // must be implemented in BG subclass
+
+        void AddOrSetPlayerToCorrectBgGroup(Player* player, uint32 team);
+
+        virtual void RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPacket);
+                                                            // can be extended in in BG subclass
+
+        void HandleTriggerBuff(uint64 go_guid);
+        void SetHoliday(bool is_holiday);
+
+        // TODO: make this protected:
+        typedef std::vector<uint64> BGObjects;
+        typedef std::vector<uint64> BGCreatures;
+        BGObjects BgObjects;
+        BGCreatures BgCreatures;
+        void SpawnBGObject(uint32 type, uint32 respawntime);
+        bool AddObject(uint32 type, uint32 entry, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3, uint32 respawnTime = 0);
+        Creature* AddCreature(uint32 entry, uint32 type, uint32 teamval, float x, float y, float z, float o, uint32 respawntime = 0);
+        bool DelCreature(uint32 type);
+        bool DelObject(uint32 type);
+        bool AddSpiritGuide(uint32 type, float x, float y, float z, float o, uint32 team);
+        int32 GetObjectType(uint64 guid);
+
+        void DoorOpen(uint32 type);
+        void DoorClose(uint32 type);
+        //to be removed
+        const char* GetTrinityString(int32 entry);
+
+        virtual bool HandlePlayerUnderMap(Player* /*player*/) { return false; }
+
+        // since arenas can be AvA or Hvh, we have to get the "temporary" team of a player
+        uint32 GetPlayerTeam(uint64 guid) const;
+        uint32 GetOtherTeam(uint32 teamId) const;
+        bool IsPlayerInBattleground(uint64 guid) const;
+
+        bool ToBeDeleted() const { return m_SetDeleteThis; }
+        void SetDeleteThis() { m_SetDeleteThis = true; }
+
+        void RewardXPAtKill(Player* killer, Player* victim);
+        bool CanAwardArenaPoints() const { return m_LevelMin >= BG_AWARD_ARENA_POINTS_MIN_LEVEL; }
+
+        virtual uint64 GetFlagPickerGUID(int32 /*team*/ = -1) const { return 0; }
+        virtual void SetDroppedFlagGUID(uint64 /*guid*/, int32 /*team*/ = -1) {}
+        uint32 GetTeamScore(uint32 TeamID) const;
+
+        virtual uint32 GetPrematureWinner();
+
+    protected:
+        // this method is called, when BG cannot spawn its own spirit guide, or something is wrong, It correctly ends Battleground
+        void EndNow();
+        void PlayerAddedToBGCheckIfBGIsRunning(Player* player);
+
+        Player* _GetPlayer(uint64 guid, bool offlineRemove, const char* context) const;
+        Player* _GetPlayer(BattlegroundPlayerMap::iterator itr, const char* context);
+        Player* _GetPlayer(BattlegroundPlayerMap::const_iterator itr, const char* context) const;
+        Player* _GetPlayerForTeam(uint32 teamId, BattlegroundPlayerMap::const_iterator itr, const char* context) const;
+
+        void _ProcessOfflineQueue();
+        void _ProcessRessurect(uint32 diff);
+        void _ProcessProgress(uint32 diff);
+        void _ProcessLeave(uint32 diff);
+        void _ProcessJoin(uint32 diff);
+        void _CheckSafePositions(uint32 diff);
+
+        // Scorekeeping
+        BattlegroundScoreMap PlayerScores;                // Player scores
+        // must be implemented in BG subclass
+        virtual void RemovePlayer(Player* /*player*/, uint64 /*guid*/, uint32 /*team*/) {}
+
+        // Player lists, those need to be accessible by inherited classes
+        BattlegroundPlayerMap  m_Players;
+        // Spirit Guide guid + Player list GUIDS
+        std::map<uint64, std::vector<uint64> >  m_ReviveQueue;
+
+        // these are important variables used for starting messages
+        uint8 m_Events;
+        BattlegroundStartTimeIntervals  StartDelayTimes[BG_STARTING_EVENT_COUNT];
+        // this must be filled in constructors!
+        uint32 StartMessageIds[BG_STARTING_EVENT_COUNT];
+
+        bool   m_BuffChange;
+        bool   m_IsRandom;
+
+        BGHonorMode m_HonorMode;
+        int32 m_TeamScores[BG_TEAMS_COUNT];
+
+    private:
+        // Battleground
+        BattlegroundTypeId m_TypeID;
+        BattlegroundTypeId m_RandomTypeID;
+        uint32 m_InstanceID;                                // Battleground Instance's GUID!
+        BattlegroundStatus m_Status;
+        uint32 m_ClientInstanceID;                          // the instance-id which is sent to the client and without any other internal use
+        uint32 m_StartTime;
+        uint32 m_CountdownTimer;
+        uint32 m_ResetStatTimer;
+        uint32 m_ValidStartPositionTimer;
+        int32 m_EndTime;                                    // it is set to 120000 when bg is ending and it decreases itself
+        uint32 m_LastResurrectTime;
+        BattlegroundBracketId m_BracketId;
+        uint8  m_ArenaType;                                 // 2=2v2, 3=3v3, 5=5v5
+        bool   m_InBGFreeSlotQueue;                         // used to make sure that BG is only once inserted into the BattlegroundMgr.BGFreeSlotQueue[bgTypeId] deque
+        bool   m_SetDeleteThis;                             // used for safe deletion of the bg after end / all players leave
+        bool   m_IsArena;
+        uint8  m_Winner;                                    // 0=alliance, 1=horde, 2=none
+        int32  m_StartDelayTime;
+        bool   m_IsRated;                                   // is this battle rated?
+        bool   m_PrematureCountDown;
+        uint32 m_PrematureCountDownTimer;
+        char const* m_Name;
+        uint64 m_Guid;
+
+        /* Pre- and post-update hooks */
+
+        /**
+         * @brief Pre-update hook.
+         *
+         * Will be called before battleground update is started. Depending on
+         * the result of this call actual update body may be skipped.
+         *
+         * @param diff a time difference between two worldserver update loops in
+         * milliseconds.
+         *
+         * @return @c true if update must be performed, @c false otherwise.
+         *
+         * @see Update(), PostUpdateImpl().
+         */
+        virtual bool PreUpdateImpl(uint32 /* diff */) { return true; }
+
+        /**
+         * @brief Post-update hook.
+         *
+         * Will be called after battleground update has passed. May be used to
+         * implement custom update effects in subclasses.
+         *
+         * @param diff a time difference between two worldserver update loops in
+         * milliseconds.
+         *
+         * @see Update(), PreUpdateImpl().
+         */
+        virtual void PostUpdateImpl(uint32 /* diff */) { }
+
+        // Player lists
+        std::vector<uint64> m_ResurrectQueue;               // Player GUID
+        std::deque<uint64> m_OfflineQueue;                  // Player GUID
+
+        // Invited counters are useful for player invitation to BG - do not allow, if BG is started to one faction to have 2 more players than another faction
+        // Invited counters will be changed only when removing already invited player from queue, removing player from battleground and inviting player to BG
+        // Invited players counters
+        uint32 m_InvitedAlliance;
+        uint32 m_InvitedHorde;
+
+        // Raid Group
+        Group* m_BgRaids[BG_TEAMS_COUNT];                   // 0 - alliance, 1 - horde
+
+        // Players count by team
+        uint32 m_PlayersCount[BG_TEAMS_COUNT];
+
+        // Arena team ids by team
+        uint32 m_ArenaTeamIds[BG_TEAMS_COUNT];
+
+        int32 m_ArenaTeamRatingChanges[BG_TEAMS_COUNT];
+        uint32 m_ArenaTeamMMR[BG_TEAMS_COUNT];
+
+        // Limits
+        uint32 m_LevelMin;
+        uint32 m_LevelMax;
+        uint32 m_MaxPlayersPerTeam;
+        uint32 m_MaxPlayers;
+        uint32 m_MinPlayersPerTeam;
+        uint32 m_MinPlayers;
+
+        // Start location
+        uint32 m_MapId;
+        BattlegroundMap* m_Map;
+        float m_TeamStartLocX[BG_TEAMS_COUNT];
+        float m_TeamStartLocY[BG_TEAMS_COUNT];
+        float m_TeamStartLocZ[BG_TEAMS_COUNT];
+        float m_TeamStartLocO[BG_TEAMS_COUNT];
+        float m_StartMaxDist;
+        uint32 ScriptId;
+};
+#endif
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.cpp b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
index b7014f3..9845010 100644
--- a/src/server/game/Battlegrounds/BattlegroundMgr.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
@@ -906,7 +906,7 @@ Battleground* BattlegroundMgr::CreateNewBattleground(BattlegroundTypeId original
                 maxPlayersPerTeam = 3;
                 break;
             case ARENA_TYPE_5v5:
-                maxPlayersPerTeam = 5;
+                maxPlayersPerTeam = 1; // 1v1 Arena
                 break;
         }
 
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.cpp.orig b/src/server/game/Battlegrounds/BattlegroundMgr.cpp.orig
new file mode 100644
index 0000000..b7014f3
--- /dev/null
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.cpp.orig
@@ -0,0 +1,1517 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Common.h"
+#include "ObjectMgr.h"
+#include "ArenaTeamMgr.h"
+#include "World.h"
+#include "WorldPacket.h"
+
+#include "ArenaTeam.h"
+#include "BattlegroundMgr.h"
+#include "BattlegroundAV.h"
+#include "BattlegroundAB.h"
+#include "BattlegroundEY.h"
+#include "BattlegroundWS.h"
+#include "BattlegroundNA.h"
+#include "BattlegroundBE.h"
+#include "BattlegroundRL.h"
+#include "BattlegroundSA.h"
+#include "BattlegroundDS.h"
+#include "BattlegroundRV.h"
+#include "BattlegroundIC.h"
+#include "BattlegroundTP.h"
+#include "BattlegroundBFG.h"
+#include "Chat.h"
+#include "Map.h"
+#include "MapInstanced.h"
+#include "MapManager.h"
+#include "Player.h"
+#include "GameEventMgr.h"
+#include "SharedDefines.h"
+#include "Formulas.h"
+#include "DisableMgr.h"
+#include "Opcodes.h"
+
+/*********************************************************/
+/***            BATTLEGROUND MANAGER                   ***/
+/*********************************************************/
+
+BattlegroundMgr::BattlegroundMgr() :
+    m_NextRatedArenaUpdate(sWorld->getIntConfig(CONFIG_ARENA_RATED_UPDATE_TIMER)),
+    m_ArenaTesting(false), m_Testing(false)
+{ }
+
+BattlegroundMgr::~BattlegroundMgr()
+{
+    DeleteAllBattlegrounds();
+}
+
+void BattlegroundMgr::DeleteAllBattlegrounds()
+{
+    for (BattlegroundDataContainer::iterator itr1 = bgDataStore.begin(); itr1 != bgDataStore.end(); ++itr1)
+    {
+        BattlegroundData& data = itr1->second;
+
+        while (!data.m_Battlegrounds.empty())
+            delete data.m_Battlegrounds.begin()->second;
+        data.m_Battlegrounds.clear();
+
+        while (!data.BGFreeSlotQueue.empty())
+            delete data.BGFreeSlotQueue.front();
+    }
+
+    bgDataStore.clear();
+}
+
+// used to update running battlegrounds, and delete finished ones
+void BattlegroundMgr::Update(uint32 diff)
+{
+    for (BattlegroundDataContainer::iterator itr1 = bgDataStore.begin(); itr1 != bgDataStore.end(); ++itr1)
+    {
+        BattlegroundContainer& bgs = itr1->second.m_Battlegrounds;
+        BattlegroundContainer::iterator itrDelete = bgs.begin();
+        // first one is template and should not be deleted
+        for (BattlegroundContainer::iterator itr = ++itrDelete; itr != bgs.end();)
+        {
+            itrDelete = itr++;
+            Battleground* bg = itrDelete->second;
+
+            bg->Update(diff);
+            if (bg->ToBeDeleted())
+            {
+                itrDelete->second = NULL;
+                bgs.erase(itrDelete);
+                BattlegroundClientIdsContainer& clients = itr1->second.m_ClientBattlegroundIds[bg->GetBracketId()];
+                if (!clients.empty())
+                     clients.erase(bg->GetClientInstanceID());
+
+                delete bg;
+            }
+        }
+    }
+
+    // update events timer
+    for (int qtype = BATTLEGROUND_QUEUE_NONE; qtype < MAX_BATTLEGROUND_QUEUE_TYPES; ++qtype)
+        m_BattlegroundQueues[qtype].UpdateEvents(diff);
+
+    // update scheduled queues
+    if (!m_QueueUpdateScheduler.empty())
+    {
+        std::vector<uint64> scheduled;
+        std::swap(scheduled, m_QueueUpdateScheduler);
+
+        for (uint8 i = 0; i < scheduled.size(); i++)
+        {
+            uint32 arenaMMRating = scheduled[i] >> 32;
+            uint8 arenaType = scheduled[i] >> 24 & 255;
+            BattlegroundQueueTypeId bgQueueTypeId = BattlegroundQueueTypeId(scheduled[i] >> 16 & 255);
+            BattlegroundTypeId bgTypeId = BattlegroundTypeId((scheduled[i] >> 8) & 255);
+            BattlegroundBracketId bracket_id = BattlegroundBracketId(scheduled[i] & 255);
+            m_BattlegroundQueues[bgQueueTypeId].BattlegroundQueueUpdate(diff, bgTypeId, bracket_id, arenaType, arenaMMRating > 0, arenaMMRating);
+        }
+    }
+
+    // if rating difference counts, maybe force-update queues
+    if (sWorld->getIntConfig(CONFIG_ARENA_MAX_RATING_DIFFERENCE) && sWorld->getIntConfig(CONFIG_ARENA_RATED_UPDATE_TIMER))
+    {
+        // it's time to force update
+        if (m_NextRatedArenaUpdate < diff)
+        {
+            // forced update for rated arenas (scan all, but skipped non rated)
+            sLog->outTrace(LOG_FILTER_ARENAS, "BattlegroundMgr: UPDATING ARENA QUEUES");
+            for (int qtype = BATTLEGROUND_QUEUE_2v2; qtype <= BATTLEGROUND_QUEUE_5v5; ++qtype)
+                for (int bracket = BG_BRACKET_ID_FIRST; bracket < MAX_BATTLEGROUND_BRACKETS; ++bracket)
+                    m_BattlegroundQueues[qtype].BattlegroundQueueUpdate(diff,
+                        BATTLEGROUND_AA, BattlegroundBracketId(bracket),
+                        BattlegroundMgr::BGArenaType(BattlegroundQueueTypeId(qtype)), true, 0);
+
+            m_NextRatedArenaUpdate = sWorld->getIntConfig(CONFIG_ARENA_RATED_UPDATE_TIMER);
+        }
+        else
+            m_NextRatedArenaUpdate -= diff;
+    }
+}
+
+void BattlegroundMgr::BuildBattlegroundStatusPacket(WorldPacket* data, Battleground* bg, Player* player, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2, uint8 arenatype)
+{
+    ObjectGuid playerGuid = player->GetGUID();
+    ObjectGuid bgGuid;
+
+    if (bg)
+        bgGuid = bg->GetGUID();
+    else
+        StatusID = STATUS_NONE;
+
+    switch (StatusID)
+    {
+        case STATUS_NONE:
+        {
+            data->Initialize(SMSG_BATTLEFIELD_STATUS);
+
+            data->WriteBit(playerGuid[0]);
+            data->WriteBit(playerGuid[4]);
+            data->WriteBit(playerGuid[7]);
+            data->WriteBit(playerGuid[1]);
+            data->WriteBit(playerGuid[6]);
+            data->WriteBit(playerGuid[3]);
+            data->WriteBit(playerGuid[5]);
+            data->WriteBit(playerGuid[2]);
+
+            data->WriteByteSeq(playerGuid[5]);
+            data->WriteByteSeq(playerGuid[6]);
+            data->WriteByteSeq(playerGuid[7]);
+            data->WriteByteSeq(playerGuid[2]);
+            *data << uint32(arenatype ? arenatype : 1); // Player count, 1 for bgs, 2-3-5 for arena (2v2, 3v3, 5v5)
+            data->WriteByteSeq(playerGuid[3]);
+            data->WriteByteSeq(playerGuid[1]);
+            *data << uint32(QueueSlot);                 // Queue slot
+            *data << uint32(Time1);                     // Join Time
+            data->WriteByteSeq(playerGuid[0]);
+            data->WriteByteSeq(playerGuid[4]);
+            break;
+        }
+        case STATUS_WAIT_QUEUE:
+        {
+            data->Initialize(SMSG_BATTLEFIELD_STATUS_QUEUED);
+
+            data->WriteBit(playerGuid[3]);
+            data->WriteBit(playerGuid[0]);
+            data->WriteBit(bgGuid[3]);
+            data->WriteBit(playerGuid[2]);
+            data->WriteBit(1);                          // Eligible In Queue
+            data->WriteBit(0);                          // Join Failed, 1 when it's arena ...
+            data->WriteBit(bgGuid[2]);
+            data->WriteBit(playerGuid[1]);
+            data->WriteBit(bgGuid[0]);
+            data->WriteBit(bgGuid[6]);
+            data->WriteBit(bgGuid[4]);
+            data->WriteBit(playerGuid[6]);
+            data->WriteBit(playerGuid[7]);
+            data->WriteBit(bgGuid[7]);
+            data->WriteBit(bgGuid[5]);
+            data->WriteBit(playerGuid[4]);
+            data->WriteBit(playerGuid[5]);
+            data->WriteBit(bg->isRated());              // Is Rated
+            data->WriteBit(0);                          // Waiting On Other Activity
+            data->WriteBit(bgGuid[1]);
+
+            data->FlushBits();
+
+            data->WriteByteSeq(playerGuid[0]);
+            *data << uint32(bg->isArena() ? arenatype : 1); // Player count, 1 for bgs, 2-3-5 for arena (2v2, 3v3, 5v5)
+            data->WriteByteSeq(bgGuid[5]);
+            data->WriteByteSeq(playerGuid[3]);
+            *data << uint32(Time1);                     // Estimated Wait Time
+            data->WriteByteSeq(bgGuid[7]);
+            data->WriteByteSeq(bgGuid[1]);
+            data->WriteByteSeq(bgGuid[2]);
+            *data << uint8(0);                          // unk
+            data->WriteByteSeq(bgGuid[4]);
+            data->WriteByteSeq(playerGuid[2]);
+            *data << uint8(0);                          // unk
+            data->WriteByteSeq(bgGuid[6]);
+            data->WriteByteSeq(playerGuid[7]);
+            data->WriteByteSeq(bgGuid[3]);
+            data->WriteByteSeq(playerGuid[6]);
+            data->WriteByteSeq(bgGuid[0]);
+            *data << uint32(Time2);                     // Join Time
+            *data << uint32(QueueSlot);                 // Queue slot
+            *data << uint8(bg->GetMinLevel());          // Min Level
+            *data << uint32(GetMSTimeDiffToNow(Time2)); // Time since joined
+            data->WriteByteSeq(playerGuid[1]);
+            data->WriteByteSeq(playerGuid[5]);
+            *data << uint32(bg->GetClientInstanceID()); // Client Instance ID
+            data->WriteByteSeq(playerGuid[4]);
+            break;
+        }
+        case STATUS_WAIT_JOIN:
+        {
+            data->Initialize(SMSG_BATTLEFIELD_STATUS_NEEDCONFIRMATION);
+
+            *data << uint32(bg->GetClientInstanceID()); // Client Instance ID
+            *data << uint32(Time1);                     // Time until closed
+            *data << uint8(0);                          // unk
+            *data << uint32(QueueSlot);                 // Queue slot
+            *data << uint32(Time2);                     // Join Time
+            *data << uint8(bg->GetMinLevel());          // Min Level
+            *data << uint32(bg->isArena() ? arenatype : 1); // Player count, 1 for bgs, 2-3-5 for arena (2v2, 3v3, 5v5)
+            *data << uint32(bg->GetMapId());            // Map Id
+            *data << uint8(0);                          // unk
+
+            data->WriteBit(playerGuid[5]);
+            data->WriteBit(playerGuid[2]);
+            data->WriteBit(playerGuid[1]);
+            data->WriteBit(bgGuid[2]);
+            data->WriteBit(playerGuid[4]);
+            data->WriteBit(bgGuid[6]);
+            data->WriteBit(bgGuid[3]);
+            data->WriteBit(bg->isRated());              // Is Rated
+            data->WriteBit(playerGuid[7]);
+            data->WriteBit(playerGuid[3]);
+            data->WriteBit(bgGuid[7]);
+            data->WriteBit(bgGuid[0]);
+            data->WriteBit(bgGuid[4]);
+            data->WriteBit(playerGuid[6]);
+            data->WriteBit(bgGuid[1]);
+            data->WriteBit(bgGuid[5]);
+            data->WriteBit(playerGuid[0]);
+
+            data->WriteByteSeq(bgGuid[6]);
+            data->WriteByteSeq(bgGuid[5]);
+            data->WriteByteSeq(bgGuid[7]);
+            data->WriteByteSeq(bgGuid[2]);
+            data->WriteByteSeq(playerGuid[0]);
+            data->WriteByteSeq(playerGuid[7]);
+            data->WriteByteSeq(bgGuid[4]);
+            data->WriteByteSeq(playerGuid[1]);
+            data->WriteByteSeq(bgGuid[0]);
+            data->WriteByteSeq(playerGuid[4]);
+            data->WriteByteSeq(bgGuid[1]);
+            data->WriteByteSeq(playerGuid[5]);
+            data->WriteByteSeq(bgGuid[3]);
+            data->WriteByteSeq(playerGuid[6]);
+            data->WriteByteSeq(playerGuid[2]);
+            data->WriteByteSeq(playerGuid[3]);
+            break;
+        }
+        case STATUS_IN_PROGRESS:
+        {
+            data->Initialize(SMSG_BATTLEFIELD_STATUS_ACTIVE);
+
+            data->WriteBit(playerGuid[2]);
+            data->WriteBit(playerGuid[7]);
+            data->WriteBit(bgGuid[7]);
+            data->WriteBit(bgGuid[1]);
+            data->WriteBit(playerGuid[5]);
+            data->WriteBit(player->GetBGTeam() == HORDE ? 0 : 1);
+            data->WriteBit(bgGuid[0]);
+            data->WriteBit(playerGuid[1]);
+            data->WriteBit(bgGuid[3]);
+            data->WriteBit(playerGuid[6]);
+            data->WriteBit(bgGuid[5]);
+            data->WriteBit(bg->isRated());              // Is Rated
+            data->WriteBit(playerGuid[4]);
+            data->WriteBit(bgGuid[6]);
+            data->WriteBit(bgGuid[4]);
+            data->WriteBit(bgGuid[2]);
+            data->WriteBit(playerGuid[3]);
+            data->WriteBit(playerGuid[0]);
+
+            data->FlushBits();
+
+            data->WriteByteSeq(bgGuid[4]);
+            data->WriteByteSeq(bgGuid[5]);
+            data->WriteByteSeq(playerGuid[5]);
+            data->WriteByteSeq(bgGuid[1]);
+            data->WriteByteSeq(bgGuid[6]);
+            data->WriteByteSeq(bgGuid[3]);
+            data->WriteByteSeq(bgGuid[7]);
+            data->WriteByteSeq(playerGuid[6]);
+
+            *data << uint32(Time1);                     // Join Time
+            *data << uint8(0);                          // unk
+
+            data->WriteByteSeq(playerGuid[4]);
+            data->WriteByteSeq(playerGuid[1]);
+
+            *data << uint32(QueueSlot);                 // Queue slot
+            *data << uint8(0);                          // unk
+            *data << uint32(bg->isArena() ? arenatype : 1); // Player count, 1 for bgs, 2-3-5 for arena (2v2, 3v3, 5v5)
+            *data << uint32(bg->GetMapId());            // Map Id
+            *data << uint8(bg->GetMinLevel());          // Min Level
+            *data << uint32(Time2);                     // Elapsed Time
+
+            data->WriteByteSeq(playerGuid[2]);
+            *data << uint32(bg->GetRemainingTime());    // Remaining Time
+
+            data->WriteByteSeq(playerGuid[0]);
+            data->WriteByteSeq(playerGuid[3]);
+            data->WriteByteSeq(bgGuid[2]);
+
+            *data << uint32(bg->GetClientInstanceID()); // Client Instance ID or faction ?
+
+            data->WriteByteSeq(bgGuid[0]);
+            data->WriteByteSeq(playerGuid[7]);
+            break;
+        }
+        case STATUS_WAIT_LEAVE:
+            break;
+    }
+}
+
+void BattlegroundMgr::BuildPvpLogDataPacket(WorldPacket* data, Battleground* bg)
+{
+    ByteBuffer buff;
+    uint8 isRated = (bg->isRated() ? 1 : 0);               // type (normal=0/rated=1) -- ATM arena or bg, RBG NYI
+    uint8 isArena = (bg->isArena() ? 1 : 0);               // Arena names
+
+    data->Initialize(SMSG_PVP_LOG_DATA, (1+1+4+40*bg->GetPlayerScoresSize()));
+    data->WriteBit(isArena);
+    data->WriteBit(isRated);
+
+    if (isArena)
+    {
+        for (int8 i = 0; i < BG_TEAMS_COUNT; ++i)
+        {
+            if (ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(bg->GetArenaTeamIdByIndex(i)))
+                data->WriteBits(at->GetName().length(), 8);
+            else
+                data->WriteBits(0, 8);
+        }
+    }
+
+    data->WriteBits(bg->GetPlayerScoresSize(), 21);
+    for (Battleground::BattlegroundScoreMap::const_iterator itr = bg->GetPlayerScoresBegin(); itr != bg->GetPlayerScoresEnd(); ++itr)
+    {
+        if (!isArena && !bg->IsPlayerInBattleground(itr->first))
+        {
+            sLog->outError(LOG_FILTER_BATTLEGROUND, "Player " UI64FMTD " has scoreboard entry for battleground %u but is not in battleground!", itr->first, bg->GetTypeID(true));
+            continue;
+        }
+
+        ObjectGuid playerGUID = itr->first;
+        data->WriteBit(0);              // Unk 1
+        data->WriteBit(0);              // Unk 2
+        data->WriteBit(playerGUID[2]);
+        data->WriteBit(!isArena);
+        data->WriteBit(0);              // Unk 4
+        data->WriteBit(isRated);        // Show rating gain?
+        data->WriteBit(0);              // Unk 6
+        data->WriteBit(playerGUID[3]);
+        data->WriteBit(playerGUID[0]);
+        data->WriteBit(playerGUID[5]);
+        data->WriteBit(playerGUID[1]);
+        data->WriteBit(playerGUID[6]);
+        data->WriteBit(itr->second->BgTeam == HORDE ? 0 : 1);
+        data->WriteBit(playerGUID[7]);
+
+        buff << uint32(itr->second->HealingDone);             // healing done
+        buff << uint32(itr->second->DamageDone);              // damage done
+
+        if (!isArena)
+        {
+            buff << uint32(itr->second->BonusHonor / 100);
+            buff << uint32(itr->second->Deaths);
+            buff << uint32(itr->second->HonorableKills);
+        }
+
+        buff.WriteByteSeq(playerGUID[4]);
+        buff << uint32(itr->second->KillingBlows);
+        if (isRated)
+        {
+            int32 rating_change = bg->GetArenaTeamRatingChangeForTeam(itr->second->BgTeam);
+            buff << uint32(rating_change);
+        }
+        buff.WriteByteSeq(playerGUID[5]);
+        // if (unk 6) << uint32() unk
+        // if (unk 2) << uint32() unk
+        buff.WriteByteSeq(playerGUID[1]);
+        buff.WriteByteSeq(playerGUID[6]);
+
+
+        buff << int32(itr->second->TalentTree);
+
+        switch (bg->GetTypeID(true))                             // Custom values
+        {
+            case BATTLEGROUND_RB:
+                switch (bg->GetMapId())
+                {
+                    case 489:
+                        data->WriteBits(0x00000002, 24);
+                        buff << uint32(((BattlegroundWGScore*)itr->second)->FlagCaptures);        // flag captures
+                        buff << uint32(((BattlegroundWGScore*)itr->second)->FlagReturns);         // flag returns
+                        break;
+                    case 566:
+                        data->WriteBits(0x00000001, 24);
+                        buff << uint32(((BattlegroundEYScore*)itr->second)->FlagCaptures);        // flag captures
+                        break;
+                    case 529:
+                        data->WriteBits(0x00000002, 24);
+                        buff << uint32(((BattlegroundABScore*)itr->second)->BasesAssaulted);      // bases assaulted
+                        buff << uint32(((BattlegroundABScore*)itr->second)->BasesDefended);       // bases defended
+                        break;
+                    case 30:
+                        data->WriteBits(0x00000005, 24);
+                        buff << uint32(((BattlegroundAVScore*)itr->second)->GraveyardsAssaulted); // GraveyardsAssaulted
+                        buff << uint32(((BattlegroundAVScore*)itr->second)->GraveyardsDefended);  // GraveyardsDefended
+                        buff << uint32(((BattlegroundAVScore*)itr->second)->TowersAssaulted);     // TowersAssaulted
+                        buff << uint32(((BattlegroundAVScore*)itr->second)->TowersDefended);      // TowersDefended
+                        buff << uint32(((BattlegroundAVScore*)itr->second)->MinesCaptured);       // MinesCaptured
+                        break;
+                    case 607:
+                        data->WriteBits(0x00000002, 24);
+                        buff << uint32(((BattlegroundSAScore*)itr->second)->demolishers_destroyed);
+                        buff << uint32(((BattlegroundSAScore*)itr->second)->gates_destroyed);
+                        break;
+                    case 628:                                                                      // IC
+                        data->WriteBits(0x00000002, 24);
+                        buff << uint32(((BattlegroundICScore*)itr->second)->BasesAssaulted);       // bases assaulted
+                        buff << uint32(((BattlegroundICScore*)itr->second)->BasesDefended);        // bases defended
+                        break;
+                    case 726:
+                        data->WriteBits(0x00000002, 24);
+                        buff << uint32(((BattlegroundTPScore*)itr->second)->FlagCaptures);         // flag captures
+                        buff << uint32(((BattlegroundTPScore*)itr->second)->FlagReturns);          // flag returns
+                        break;
+                    case 761:
+                        data->WriteBits(0x00000002, 24);
+                        buff << uint32(((BattlegroundBFGScore*)itr->second)->BasesAssaulted);      // bases assaulted
+                        buff << uint32(((BattlegroundBFGScore*)itr->second)->BasesDefended);       // bases defended
+                        break;
+                    default:
+                        data->WriteBits(0, 24);
+                        break;
+                }
+                break;
+            case BATTLEGROUND_AV:
+                data->WriteBits(0x00000005, 24);
+                buff << uint32(((BattlegroundAVScore*)itr->second)->GraveyardsAssaulted); // GraveyardsAssaulted
+                buff << uint32(((BattlegroundAVScore*)itr->second)->GraveyardsDefended);  // GraveyardsDefended
+                buff << uint32(((BattlegroundAVScore*)itr->second)->TowersAssaulted);     // TowersAssaulted
+                buff << uint32(((BattlegroundAVScore*)itr->second)->TowersDefended);      // TowersDefended
+                buff << uint32(((BattlegroundAVScore*)itr->second)->MinesCaptured);       // MinesCaptured
+                break;
+            case BATTLEGROUND_WS:
+                data->WriteBits(0x00000002, 24);
+                buff << uint32(((BattlegroundWGScore*)itr->second)->FlagCaptures);        // flag captures
+                buff << uint32(((BattlegroundWGScore*)itr->second)->FlagReturns);         // flag returns
+                break;
+            case BATTLEGROUND_AB:
+                data->WriteBits(0x00000002, 24);
+                buff << uint32(((BattlegroundABScore*)itr->second)->BasesAssaulted);      // bases assaulted
+                buff << uint32(((BattlegroundABScore*)itr->second)->BasesDefended);       // bases defended
+                break;
+            case BATTLEGROUND_EY:
+                data->WriteBits(0x00000001, 24);
+                buff << uint32(((BattlegroundEYScore*)itr->second)->FlagCaptures);        // flag captures
+                break;
+            case BATTLEGROUND_SA:
+                data->WriteBits(0x00000002, 24);
+                buff << uint32(((BattlegroundSAScore*)itr->second)->demolishers_destroyed);
+                buff << uint32(((BattlegroundSAScore*)itr->second)->gates_destroyed);
+                break;
+            case BATTLEGROUND_IC:
+                data->WriteBits(0x00000002, 24);
+                buff << uint32(((BattlegroundICScore*)itr->second)->BasesAssaulted);       // bases assaulted
+                buff << uint32(((BattlegroundICScore*)itr->second)->BasesDefended);        // bases defended
+                break;
+            case BATTLEGROUND_TP:
+                data->WriteBits(0x00000002, 24);
+                buff << uint32(((BattlegroundTPScore*)itr->second)->FlagCaptures);         // flag captures
+                buff << uint32(((BattlegroundTPScore*)itr->second)->FlagReturns);          // flag returns
+                break;
+            case BATTLEGROUND_BFG:
+                data->WriteBits(0x00000002, 24);
+                buff << uint32(((BattlegroundBFGScore*)itr->second)->BasesAssaulted);      // bases assaulted
+                buff << uint32(((BattlegroundBFGScore*)itr->second)->BasesDefended);       // bases defended
+                break;
+            case BATTLEGROUND_NA:
+            case BATTLEGROUND_BE:
+            case BATTLEGROUND_AA:
+            case BATTLEGROUND_RL:
+            case BATTLEGROUND_DS:
+            case BATTLEGROUND_RV:
+                data->WriteBits(0, 24);
+                break;
+            default:
+                data->WriteBits(0, 24);
+                break;
+        }
+
+        data->WriteBit(playerGUID[4]);
+
+        buff.WriteByteSeq(playerGUID[0]);
+        buff.WriteByteSeq(playerGUID[3]);
+        // if (unk 4) << uint32() unk
+        buff.WriteByteSeq(playerGUID[7]);
+        buff.WriteByteSeq(playerGUID[2]);
+    }
+
+    data->WriteBit(bg->GetStatus() == STATUS_WAIT_LEAVE);    // If Ended
+
+    if (isRated)                                             // arena
+    {
+        // it seems this must be according to BG_WINNER_A/H and _NOT_ BG_TEAM_A/H
+        for (int8 i = 1; i >= 0; --i)
+        {
+            int32 rating_change = bg->GetArenaTeamRatingChangeByIndex(i);
+
+            uint32 pointsLost = rating_change < 0 ? -rating_change : 0;
+            uint32 pointsGained = rating_change > 0 ? rating_change : 0;
+            uint32 MatchmakerRating = bg->GetArenaMatchmakerRatingByIndex(i);
+
+            *data << uint32(MatchmakerRating);              // Matchmaking Value
+            *data << uint32(pointsLost);                    // Rating Lost
+            *data << uint32(pointsGained);                  // Rating gained
+            sLog->outDebug(LOG_FILTER_BATTLEGROUND, "rating change: %d", rating_change);
+        }
+    }
+
+    data->FlushBits();
+    data->append(buff);
+
+    if (isArena)
+        for (int8 i = 0; i < BG_TEAMS_COUNT; ++i)
+            if (ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(bg->GetArenaTeamIdByIndex(i)))
+                data->WriteString(at->GetName());
+
+    *data << uint8(bg->GetPlayersCountByTeam(HORDE));
+
+    if (bg->GetStatus() == STATUS_WAIT_LEAVE)
+        *data << uint8(bg->GetWinner());
+
+    *data << uint8(bg->GetPlayersCountByTeam(ALLIANCE));
+}
+
+void BattlegroundMgr::BuildStatusFailedPacket(WorldPacket* data, Battleground* bg, Player* player, uint8 QueueSlot, GroupJoinBattlegroundResult result)
+{
+    ObjectGuid guidBytes1 = player->GetGUID(); // player who caused the error
+    ObjectGuid guidBytes2 = bg->GetGUID();
+    ObjectGuid unkGuid3 = 0;
+
+    data->Initialize(SMSG_BATTLEFIELD_STATUS_FAILED);
+
+    data->WriteBit(guidBytes2[3]);
+    data->WriteBit(unkGuid3[3]);
+    data->WriteBit(guidBytes1[3]);
+    data->WriteBit(unkGuid3[0]);
+    data->WriteBit(guidBytes2[6]);
+    data->WriteBit(guidBytes1[5]);
+    data->WriteBit(guidBytes1[6]);
+    data->WriteBit(guidBytes1[4]);
+
+    data->WriteBit(guidBytes1[2]);
+    data->WriteBit(unkGuid3[1]);
+    data->WriteBit(guidBytes2[1]);
+    data->WriteBit(unkGuid3[5]);
+    data->WriteBit(unkGuid3[6]);
+    data->WriteBit(guidBytes1[1]);
+    data->WriteBit(guidBytes2[7]);
+    data->WriteBit(unkGuid3[4]);
+
+    data->WriteBit(guidBytes2[2]);
+    data->WriteBit(guidBytes2[5]);
+    data->WriteBit(unkGuid3[7]);
+    data->WriteBit(guidBytes2[4]);
+    data->WriteBit(guidBytes2[0]);
+    data->WriteBit(guidBytes1[0]);
+    data->WriteBit(unkGuid3[2]);
+    data->WriteBit(guidBytes1[7]);
+
+    data->WriteByteSeq(guidBytes2[1]);
+
+    *data << uint32(1);                         // Unk, always 1
+    *data << uint32(QueueSlot);                 // Queue slot
+
+    data->WriteByteSeq(guidBytes1[6]);
+    data->WriteByteSeq(guidBytes1[3]);
+    data->WriteByteSeq(guidBytes1[7]);
+    data->WriteByteSeq(guidBytes1[4]);
+    data->WriteByteSeq(guidBytes2[0]);
+    data->WriteByteSeq(guidBytes1[5]);
+    data->WriteByteSeq(guidBytes2[7]);
+    data->WriteByteSeq(guidBytes2[6]);
+    data->WriteByteSeq(guidBytes2[2]);
+    data->WriteByteSeq(unkGuid3[6]);
+    data->WriteByteSeq(unkGuid3[3]);
+    data->WriteByteSeq(guidBytes1[1]);
+    data->WriteByteSeq(guidBytes2[3]);
+    data->WriteByteSeq(unkGuid3[0]);
+    data->WriteByteSeq(unkGuid3[1]);
+    data->WriteByteSeq(unkGuid3[4]);
+    data->WriteByteSeq(guidBytes1[0]);
+    data->WriteByteSeq(guidBytes2[5]);
+    data->WriteByteSeq(unkGuid3[7]);
+    data->WriteByteSeq(guidBytes2[4]);
+    data->WriteByteSeq(guidBytes1[2]);
+
+    *data << uint32(result);                    // Result
+
+    data->WriteByteSeq(unkGuid3[2]);
+
+    *data << uint32(player->GetBattlegroundQueueJoinTime(bg->GetTypeID())); // Join Time
+
+    data->WriteByteSeq(unkGuid3[5]);
+}
+
+void BattlegroundMgr::BuildUpdateWorldStatePacket(WorldPacket* data, uint32 field, uint32 value)
+{
+    data->Initialize(SMSG_UPDATE_WORLD_STATE, 4+4);
+    *data << uint32(field);
+    *data << uint32(value);
+}
+
+void BattlegroundMgr::BuildPlaySoundPacket(WorldPacket* data, uint32 soundid)
+{
+    data->Initialize(SMSG_PLAY_SOUND, 4);
+    *data << uint32(soundid);
+}
+
+void BattlegroundMgr::BuildPlayerLeftBattlegroundPacket(WorldPacket* data, uint64 guid)
+{
+    ObjectGuid guidBytes = guid;
+
+    data->Initialize(SMSG_BATTLEGROUND_PLAYER_LEFT, 8);
+
+    data->WriteBit(guidBytes[7]);
+    data->WriteBit(guidBytes[6]);
+    data->WriteBit(guidBytes[2]);
+    data->WriteBit(guidBytes[4]);
+    data->WriteBit(guidBytes[5]);
+    data->WriteBit(guidBytes[1]);
+    data->WriteBit(guidBytes[3]);
+    data->WriteBit(guidBytes[0]);
+
+    data->WriteByteSeq(guidBytes[4]);
+    data->WriteByteSeq(guidBytes[2]);
+    data->WriteByteSeq(guidBytes[5]);
+    data->WriteByteSeq(guidBytes[7]);
+    data->WriteByteSeq(guidBytes[0]);
+    data->WriteByteSeq(guidBytes[6]);
+    data->WriteByteSeq(guidBytes[1]);
+    data->WriteByteSeq(guidBytes[3]);
+}
+
+void BattlegroundMgr::BuildPlayerJoinedBattlegroundPacket(WorldPacket* data, uint64 guid)
+{
+    ObjectGuid guidBytes = guid;
+
+    data->Initialize(SMSG_BATTLEGROUND_PLAYER_JOINED, 8);
+
+    data->WriteBit(guidBytes[0]);
+    data->WriteBit(guidBytes[4]);
+    data->WriteBit(guidBytes[3]);
+    data->WriteBit(guidBytes[5]);
+    data->WriteBit(guidBytes[7]);
+    data->WriteBit(guidBytes[6]);
+    data->WriteBit(guidBytes[2]);
+    data->WriteBit(guidBytes[1]);
+
+    data->WriteByteSeq(guidBytes[1]);
+    data->WriteByteSeq(guidBytes[5]);
+    data->WriteByteSeq(guidBytes[3]);
+    data->WriteByteSeq(guidBytes[2]);
+    data->WriteByteSeq(guidBytes[0]);
+    data->WriteByteSeq(guidBytes[7]);
+    data->WriteByteSeq(guidBytes[4]);
+    data->WriteByteSeq(guidBytes[6]);
+}
+
+Battleground* BattlegroundMgr::GetBattlegroundThroughClientInstance(uint32 instanceId, BattlegroundTypeId bgTypeId)
+{
+    //cause at HandleBattlegroundJoinOpcode the clients sends the instanceid he gets from
+    //SMSG_BATTLEFIELD_LIST we need to find the battleground with this clientinstance-id
+    Battleground* bg = GetBattlegroundTemplate(bgTypeId);
+    if (!bg)
+        return NULL;
+
+    if (bg->isArena())
+        return GetBattleground(instanceId, bgTypeId);
+
+    BattlegroundDataContainer::const_iterator it = bgDataStore.find(bgTypeId);
+    if (it == bgDataStore.end())
+        return NULL;
+
+    for (BattlegroundContainer::const_iterator itr = it->second.m_Battlegrounds.begin(); itr != it->second.m_Battlegrounds.end(); ++itr)
+    {
+        if (itr->second->GetClientInstanceID() == instanceId)
+            return itr->second;
+    }
+
+    return NULL;
+}
+
+Battleground* BattlegroundMgr::GetBattleground(uint32 instanceId, BattlegroundTypeId bgTypeId)
+{
+    if (!instanceId)
+        return NULL;
+
+    BattlegroundDataContainer::const_iterator begin, end;
+
+    if (bgTypeId == BATTLEGROUND_TYPE_NONE)
+    {
+        begin = bgDataStore.begin();
+        end = bgDataStore.end();
+    }
+    else
+    {
+        end = bgDataStore.find(bgTypeId);
+        if (end == bgDataStore.end())
+            return NULL;
+        begin = end++;
+    }
+
+    for (BattlegroundDataContainer::const_iterator it = begin; it != end; ++it)
+    {
+        BattlegroundContainer const& bgs = it->second.m_Battlegrounds;
+        BattlegroundContainer::const_iterator itr = bgs.find(instanceId);
+        if (itr != bgs.end())
+           return itr->second;
+    }
+
+    return NULL;
+}
+
+Battleground* BattlegroundMgr::GetBattlegroundTemplate(BattlegroundTypeId bgTypeId)
+{
+    BattlegroundDataContainer::const_iterator itr = bgDataStore.find(bgTypeId);
+    if (itr == bgDataStore.end())
+        return NULL;
+
+    BattlegroundContainer const& bgs = itr->second.m_Battlegrounds;
+    // map is sorted and we can be sure that lowest instance id has only BG template
+    return bgs.empty() ? NULL : bgs.begin()->second;
+}
+
+uint32 BattlegroundMgr::CreateClientVisibleInstanceId(BattlegroundTypeId bgTypeId, BattlegroundBracketId bracket_id)
+{
+    if (IsArenaType(bgTypeId))
+        return 0;                                           //arenas don't have client-instanceids
+
+    // we create here an instanceid, which is just for
+    // displaying this to the client and without any other use..
+    // the client-instanceIds are unique for each battleground-type
+    // the instance-id just needs to be as low as possible, beginning with 1
+    // the following works, because std::set is default ordered with "<"
+    // the optimalization would be to use as bitmask std::vector<uint32> - but that would only make code unreadable
+
+    BattlegroundClientIdsContainer& clientIds = bgDataStore[bgTypeId].m_ClientBattlegroundIds[bracket_id];
+    uint32 lastId = 0;
+    for (BattlegroundClientIdsContainer::const_iterator itr = clientIds.begin(); itr != clientIds.end();)
+    {
+        if ((++lastId) != *itr)                             //if there is a gap between the ids, we will break..
+            break;
+        lastId = *itr;
+    }
+
+    clientIds.insert(++lastId);
+    return lastId;
+}
+
+// create a new battleground that will really be used to play
+Battleground* BattlegroundMgr::CreateNewBattleground(BattlegroundTypeId originalBgTypeId, PvPDifficultyEntry const* bracketEntry, uint8 arenaType, bool isRated)
+{
+    BattlegroundTypeId bgTypeId = originalBgTypeId;
+    bool isRandom = false;
+
+    switch (originalBgTypeId)
+    {
+        case BATTLEGROUND_RB:
+            isRandom = true;
+        case BATTLEGROUND_AA:
+            bgTypeId = GetRandomBG(originalBgTypeId);
+            break;
+        default:
+            break;
+    }
+
+    // get the template BG
+    Battleground* bg_template = GetBattlegroundTemplate(bgTypeId);
+
+    if (!bg_template)
+    {
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground: CreateNewBattleground - bg template not found for %u", bgTypeId);
+        return NULL;
+    }
+
+    Battleground* bg = NULL;
+    // create a copy of the BG template
+    switch (bgTypeId)
+    {
+        case BATTLEGROUND_AV:
+            bg = new BattlegroundAV(*(BattlegroundAV*)bg_template);
+            break;
+        case BATTLEGROUND_WS:
+            bg = new BattlegroundWS(*(BattlegroundWS*)bg_template);
+            break;
+        case BATTLEGROUND_AB:
+            bg = new BattlegroundAB(*(BattlegroundAB*)bg_template);
+            break;
+        case BATTLEGROUND_NA:
+            bg = new BattlegroundNA(*(BattlegroundNA*)bg_template);
+            break;
+        case BATTLEGROUND_BE:
+            bg = new BattlegroundBE(*(BattlegroundBE*)bg_template);
+            break;
+        case BATTLEGROUND_EY:
+            bg = new BattlegroundEY(*(BattlegroundEY*)bg_template);
+            break;
+        case BATTLEGROUND_RL:
+            bg = new BattlegroundRL(*(BattlegroundRL*)bg_template);
+            break;
+        case BATTLEGROUND_SA:
+            bg = new BattlegroundSA(*(BattlegroundSA*)bg_template);
+            break;
+        case BATTLEGROUND_DS:
+            bg = new BattlegroundDS(*(BattlegroundDS*)bg_template);
+            break;
+        case BATTLEGROUND_RV:
+            bg = new BattlegroundRV(*(BattlegroundRV*)bg_template);
+            break;
+        case BATTLEGROUND_IC:
+            bg = new BattlegroundIC(*(BattlegroundIC*)bg_template);
+            break;
+        case BATTLEGROUND_TP:
+            bg = new BattlegroundTP(*(BattlegroundTP*)bg_template);
+            break;
+        case BATTLEGROUND_BFG:
+            bg = new BattlegroundBFG(*(BattlegroundBFG*)bg_template);
+            break;
+        case BATTLEGROUND_RB:
+        case BATTLEGROUND_AA:
+            bg = new Battleground(*bg_template);
+            break;
+        default:
+            return NULL;
+    }
+
+    bg->SetBracket(bracketEntry);
+    bg->SetInstanceID(sMapMgr->GenerateInstanceId());
+    bg->SetClientInstanceID(CreateClientVisibleInstanceId(isRandom ? BATTLEGROUND_RB : bgTypeId, bracketEntry->GetBracketId()));
+    bg->Reset();                     // reset the new bg (set status to status_wait_queue from status_none)
+    bg->SetStatus(STATUS_WAIT_JOIN); // start the joining of the bg
+    bg->SetArenaType(arenaType);
+    bg->SetTypeID(originalBgTypeId);
+    bg->SetRandomTypeID(bgTypeId);
+    bg->SetRated(isRated);
+    bg->SetRandom(isRandom);
+    bg->SetGuid(MAKE_NEW_GUID(bgTypeId, 0, HIGHGUID_BATTLEGROUND));
+
+    // Set up correct min/max player counts for scoreboards
+    if (bg->isArena())
+    {
+        uint32 maxPlayersPerTeam = 0;
+        switch (arenaType)
+        {
+            case ARENA_TYPE_2v2:
+                maxPlayersPerTeam = 2;
+                break;
+            case ARENA_TYPE_3v3:
+                maxPlayersPerTeam = 3;
+                break;
+            case ARENA_TYPE_5v5:
+                maxPlayersPerTeam = 5;
+                break;
+        }
+
+        bg->SetMaxPlayersPerTeam(maxPlayersPerTeam);
+        bg->SetMaxPlayers(maxPlayersPerTeam * 2);
+    }
+
+    return bg;
+}
+
+// used to create the BG templates
+bool BattlegroundMgr::CreateBattleground(CreateBattlegroundData& data)
+{
+    // Create the BG
+    Battleground* bg = NULL;
+    switch (data.bgTypeId)
+    {
+        case BATTLEGROUND_AV:
+            bg = new BattlegroundAV;
+            break;
+        case BATTLEGROUND_WS:
+            bg = new BattlegroundWS;
+            break;
+        case BATTLEGROUND_AB:
+            bg = new BattlegroundAB;
+            break;
+        case BATTLEGROUND_NA:
+            bg = new BattlegroundNA;
+            break;
+        case BATTLEGROUND_BE:
+            bg = new BattlegroundBE;
+            break;
+        case BATTLEGROUND_EY:
+            bg = new BattlegroundEY;
+            break;
+        case BATTLEGROUND_RL:
+            bg = new BattlegroundRL;
+            break;
+        case BATTLEGROUND_SA:
+            bg = new BattlegroundSA;
+            break;
+        case BATTLEGROUND_DS:
+            bg = new BattlegroundDS;
+            break;
+        case BATTLEGROUND_RV:
+            bg = new BattlegroundRV;
+            break;
+        case BATTLEGROUND_IC:
+            bg = new BattlegroundIC;
+            break;
+        case BATTLEGROUND_AA:
+            bg = new Battleground;
+            break;
+        case BATTLEGROUND_RB:
+            bg = new Battleground;
+            bg->SetRandom(true);
+            break;
+        case BATTLEGROUND_TP:
+            bg = new BattlegroundTP;
+            break;
+        case BATTLEGROUND_BFG:
+            bg = new BattlegroundBFG;
+            break;
+        default:
+            return false;
+    }
+
+    bg->SetMapId(data.MapID);
+    bg->SetTypeID(data.bgTypeId);
+    bg->SetInstanceID(0);
+    bg->SetArenaorBGType(data.IsArena);
+    bg->SetMinPlayersPerTeam(data.MinPlayersPerTeam);
+    bg->SetMaxPlayersPerTeam(data.MaxPlayersPerTeam);
+    bg->SetMinPlayers(data.MinPlayersPerTeam * 2);
+    bg->SetMaxPlayers(data.MaxPlayersPerTeam * 2);
+    bg->SetName(data.BattlegroundName);
+    bg->SetTeamStartLoc(ALLIANCE, data.Team1StartLocX, data.Team1StartLocY, data.Team1StartLocZ, data.Team1StartLocO);
+    bg->SetTeamStartLoc(HORDE,    data.Team2StartLocX, data.Team2StartLocY, data.Team2StartLocZ, data.Team2StartLocO);
+    bg->SetStartMaxDist(data.StartMaxDist);
+    bg->SetLevelRange(data.LevelMin, data.LevelMax);
+    bg->SetScriptId(data.scriptId);
+    bg->SetGuid(MAKE_NEW_GUID(data.bgTypeId, 0, HIGHGUID_BATTLEGROUND));
+
+    AddBattleground(bg);
+
+    return true;
+}
+
+void BattlegroundMgr::CreateInitialBattlegrounds()
+{
+    uint32 oldMSTime = getMSTime();
+    //                                               0   1                  2                  3       4       5                 6               7              8            9             10      11
+    QueryResult result = WorldDatabase.Query("SELECT id, MinPlayersPerTeam, MaxPlayersPerTeam, MinLvl, MaxLvl, AllianceStartLoc, AllianceStartO, HordeStartLoc, HordeStartO, StartMaxDist, Weight, ScriptName FROM battleground_template");
+
+    if (!result)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, ">> Loaded 0 battlegrounds. DB table `battleground_template` is empty.");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 bgTypeId = fields[0].GetUInt32();
+        if (DisableMgr::IsDisabledFor(DISABLE_TYPE_BATTLEGROUND, bgTypeId, NULL))
+            continue;
+
+        // can be overwrite by values from DB
+        BattlemasterListEntry const* bl = sBattlemasterListStore.LookupEntry(bgTypeId);
+        if (!bl)
+        {
+            sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground ID %u not found in BattlemasterList.dbc. Battleground not created.", bgTypeId);
+            continue;
+        }
+
+        CreateBattlegroundData data;
+        data.bgTypeId = BattlegroundTypeId(bgTypeId);
+        data.IsArena = (bl->type == TYPE_ARENA);
+        data.MinPlayersPerTeam = fields[1].GetUInt16();
+        data.MaxPlayersPerTeam = fields[2].GetUInt16();
+        data.LevelMin = fields[3].GetUInt8();
+        data.LevelMax = fields[4].GetUInt8();
+        float dist = fields[9].GetFloat();
+        data.StartMaxDist = dist * dist;
+
+        data.scriptId = sObjectMgr->GetScriptId(fields[11].GetCString());
+        data.BattlegroundName = bl->name;
+        data.MapID = bl->mapid[0];
+
+        if (data.MaxPlayersPerTeam == 0 || data.MinPlayersPerTeam > data.MaxPlayersPerTeam)
+        {
+            sLog->outError(LOG_FILTER_SQL, "Table `battleground_template` for id %u has bad values for MinPlayersPerTeam (%u) and MaxPlayersPerTeam(%u)",
+                data.bgTypeId, data.MinPlayersPerTeam, data.MaxPlayersPerTeam);
+            continue;
+        }
+
+        if (data.LevelMin == 0 || data.LevelMax == 0 || data.LevelMin > data.LevelMax)
+        {
+            sLog->outError(LOG_FILTER_SQL, "Table `battleground_template` for id %u has bad values for LevelMin (%u) and LevelMax(%u)",
+                data.bgTypeId, data.LevelMin, data.LevelMax);
+            continue;
+        }
+
+        if (data.bgTypeId == BATTLEGROUND_AA || data.bgTypeId == BATTLEGROUND_RB)
+        {
+            data.Team1StartLocX = 0;
+            data.Team1StartLocY = 0;
+            data.Team1StartLocZ = 0;
+            data.Team1StartLocO = fields[6].GetFloat();
+            data.Team2StartLocX = 0;
+            data.Team2StartLocY = 0;
+            data.Team2StartLocZ = 0;
+            data.Team2StartLocO = fields[8].GetFloat();
+        }
+        else
+        {
+            uint32 startId = fields[5].GetUInt32();
+            if (WorldSafeLocsEntry const* start = sWorldSafeLocsStore.LookupEntry(startId))
+            {
+                data.Team1StartLocX = start->x;
+                data.Team1StartLocY = start->y;
+                data.Team1StartLocZ = start->z;
+                data.Team1StartLocO = fields[6].GetFloat();
+            }
+            else
+            {
+                sLog->outError(LOG_FILTER_SQL, "Table `battleground_template` for id %u have non-existed WorldSafeLocs.dbc id %u in field `AllianceStartLoc`. BG not created.", data.bgTypeId, startId);
+                continue;
+            }
+
+            startId = fields[7].GetUInt32();
+            if (WorldSafeLocsEntry const* start = sWorldSafeLocsStore.LookupEntry(startId))
+            {
+                data.Team2StartLocX = start->x;
+                data.Team2StartLocY = start->y;
+                data.Team2StartLocZ = start->z;
+                data.Team2StartLocO = fields[8].GetFloat();
+            }
+            else
+            {
+                sLog->outError(LOG_FILTER_SQL, "Table `battleground_template` for id %u have non-existed WorldSafeLocs.dbc id %u in field `HordeStartLoc`. BG not created.", data.bgTypeId, startId);
+                continue;
+            }
+        }
+
+        if (!CreateBattleground(data))
+            continue;
+
+        if (data.IsArena)
+        {
+            if (data.bgTypeId != BATTLEGROUND_AA)
+                m_ArenaSelectionWeights[data.bgTypeId] = fields[10].GetUInt8();
+        }
+        else if (data.bgTypeId != BATTLEGROUND_RB)
+            m_BGSelectionWeights[data.bgTypeId] = fields[10].GetUInt8();
+
+        ++count;
+    }
+    while (result->NextRow());
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">> Loaded %u battlegrounds in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
+void BattlegroundMgr::BuildBattlegroundListPacket(WorldPacket* data, uint64 guid, Player* player, BattlegroundTypeId bgTypeId)
+{
+    if (!player)
+        return;
+
+    BattlegroundDataContainer::iterator it = bgDataStore.find(bgTypeId);
+    if (it == bgDataStore.end())
+        return;
+
+    PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(it->second.m_Battlegrounds.begin()->second->GetMapId(), player->getLevel());
+    if (!bracketEntry)
+        return;
+
+    uint32 winner_conquest = (player->GetRandomWinner() ? BG_REWARD_WINNER_CONQUEST_LAST : BG_REWARD_WINNER_CONQUEST_FIRST) / CURRENCY_PRECISION;
+    uint32 winner_honor = (player->GetRandomWinner() ? BG_REWARD_WINNER_HONOR_LAST : BG_REWARD_WINNER_HONOR_FIRST) / CURRENCY_PRECISION;
+    uint32 loser_honor = (player->GetRandomWinner() ? BG_REWARD_LOSER_HONOR_LAST : BG_REWARD_LOSER_HONOR_FIRST) / CURRENCY_PRECISION;
+
+    ObjectGuid guidBytes = guid;
+
+    data->Initialize(SMSG_BATTLEFIELD_LIST);
+    *data << uint32(winner_conquest)                        // Winner Conquest Reward or Random Winner Conquest Reward
+          << uint32(winner_conquest)                        // Winner Conquest Reward or Random Winner Conquest Reward
+          << uint32(loser_honor)                            // Loser Honor Reward or Random Loser Honor Reward
+          << uint32(bgTypeId)                               // battleground id
+          << uint32(loser_honor)                            // Loser Honor Reward or Random Loser Honor Reward
+          << uint32(winner_honor)                           // Winner Honor Reward or Random Winner Honor Reward
+          << uint32(winner_honor)                           // Winner Honor Reward or Random Winner Honor Reward
+          << uint8(bracketEntry->maxLevel)                  // max level
+          << uint8(bracketEntry->minLevel);                 // min level
+
+    data->WriteBit(guidBytes[0]);
+    data->WriteBit(guidBytes[1]);
+    data->WriteBit(guidBytes[7]);
+    data->WriteBit(0);                                      // unk
+    data->WriteBit(0);                                      // unk
+
+    data->FlushBits();
+    size_t count_pos = data->bitwpos();
+    data->WriteBits(0, 24);                                 // placeholder
+
+    data->WriteBit(guidBytes[6]);
+    data->WriteBit(guidBytes[4]);
+    data->WriteBit(guidBytes[2]);
+    data->WriteBit(guidBytes[3]);
+    data->WriteBit(0);                                      // unk
+    data->WriteBit(guidBytes[5]);
+    data->WriteBit(0);                                      // unk
+
+    data->FlushBits();
+
+    data->WriteByteSeq(guidBytes[6]);
+    data->WriteByteSeq(guidBytes[1]);
+    data->WriteByteSeq(guidBytes[7]);
+    data->WriteByteSeq(guidBytes[5]);
+
+    uint32 count = 0;
+    BattlegroundBracketId bracketId = bracketEntry->GetBracketId();
+    BattlegroundClientIdsContainer& clientIds = it->second.m_ClientBattlegroundIds[bracketId];
+    for (BattlegroundClientIdsContainer::const_iterator itr = clientIds.begin(); itr != clientIds.end(); ++itr)
+    {
+        *data << uint32(*itr);
+        ++count;
+    }
+    data->PutBits(count_pos, count, 24);                    // bg instance count
+
+    data->WriteByteSeq(guidBytes[0]);
+    data->WriteByteSeq(guidBytes[2]);
+    data->WriteByteSeq(guidBytes[4]);
+    data->WriteByteSeq(guidBytes[3]);
+}
+
+void BattlegroundMgr::SendToBattleground(Player* player, uint32 instanceId, BattlegroundTypeId bgTypeId)
+{
+    if (Battleground* bg = GetBattleground(instanceId, bgTypeId))
+    {
+        float x, y, z, O;
+        uint32 mapid = bg->GetMapId();
+        uint32 team = player->GetBGTeam();
+
+        bg->GetTeamStartLoc(team, x, y, z, O);
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BattlegroundMgr::SendToBattleground: Sending %s to map %u, X %f, Y %f, Z %f, O %f (bgType %u)", player->GetName().c_str(), mapid, x, y, z, O, bgTypeId);
+        player->TeleportTo(mapid, x, y, z, O);
+    }
+    else
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "BattlegroundMgr::SendToBattleground: Instance %u (bgType %u) not found while trying to teleport player %s", instanceId, bgTypeId, player->GetName().c_str());
+}
+
+void BattlegroundMgr::SendAreaSpiritHealerQueryOpcode(Player* player, Battleground* bg, uint64 guid)
+{
+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+    uint32 time_ = 30000 - bg->GetLastResurrectTime();      // resurrect every 30 seconds
+    if (time_ == uint32(-1))
+        time_ = 0;
+    data << guid << time_;
+    player->GetSession()->SendPacket(&data);
+}
+
+bool BattlegroundMgr::IsArenaType(BattlegroundTypeId bgTypeId)
+{
+    return bgTypeId == BATTLEGROUND_AA
+            || bgTypeId == BATTLEGROUND_BE
+            || bgTypeId == BATTLEGROUND_NA
+            || bgTypeId == BATTLEGROUND_DS
+            || bgTypeId == BATTLEGROUND_RV
+            || bgTypeId == BATTLEGROUND_RL;
+}
+
+BattlegroundQueueTypeId BattlegroundMgr::BGQueueTypeId(BattlegroundTypeId bgTypeId, uint8 arenaType)
+{
+    switch (bgTypeId)
+    {
+        case BATTLEGROUND_AB:
+            return BATTLEGROUND_QUEUE_AB;
+        case BATTLEGROUND_AV:
+            return BATTLEGROUND_QUEUE_AV;
+        case BATTLEGROUND_EY:
+            return BATTLEGROUND_QUEUE_EY;
+        case BATTLEGROUND_IC:
+            return BATTLEGROUND_QUEUE_IC;
+        case BATTLEGROUND_TP:
+            return BATTLEGROUND_QUEUE_TP;
+        case BATTLEGROUND_BFG:
+            return BATTLEGROUND_QUEUE_BFG;
+        case BATTLEGROUND_RB:
+            return BATTLEGROUND_QUEUE_RB;
+        case BATTLEGROUND_SA:
+            return BATTLEGROUND_QUEUE_SA;
+        case BATTLEGROUND_WS:
+            return BATTLEGROUND_QUEUE_WS;
+        case BATTLEGROUND_AA:
+        case BATTLEGROUND_BE:
+        case BATTLEGROUND_DS:
+        case BATTLEGROUND_NA:
+        case BATTLEGROUND_RL:
+        case BATTLEGROUND_RV:
+            switch (arenaType)
+            {
+                case ARENA_TYPE_2v2:
+                    return BATTLEGROUND_QUEUE_2v2;
+                case ARENA_TYPE_3v3:
+                    return BATTLEGROUND_QUEUE_3v3;
+                case ARENA_TYPE_5v5:
+                    return BATTLEGROUND_QUEUE_5v5;
+                default:
+                    return BATTLEGROUND_QUEUE_NONE;
+            }
+        default:
+            return BATTLEGROUND_QUEUE_NONE;
+    }
+}
+
+BattlegroundTypeId BattlegroundMgr::BGTemplateId(BattlegroundQueueTypeId bgQueueTypeId)
+{
+    switch (bgQueueTypeId)
+    {
+        case BATTLEGROUND_QUEUE_WS:
+            return BATTLEGROUND_WS;
+        case BATTLEGROUND_QUEUE_AB:
+            return BATTLEGROUND_AB;
+        case BATTLEGROUND_QUEUE_AV:
+            return BATTLEGROUND_AV;
+        case BATTLEGROUND_QUEUE_EY:
+            return BATTLEGROUND_EY;
+        case BATTLEGROUND_QUEUE_SA:
+            return BATTLEGROUND_SA;
+        case BATTLEGROUND_QUEUE_IC:
+            return BATTLEGROUND_IC;
+        case BATTLEGROUND_QUEUE_TP:
+            return BATTLEGROUND_TP;
+        case BATTLEGROUND_QUEUE_BFG:
+            return BATTLEGROUND_BFG;
+        case BATTLEGROUND_QUEUE_RB:
+            return BATTLEGROUND_RB;
+        case BATTLEGROUND_QUEUE_2v2:
+        case BATTLEGROUND_QUEUE_3v3:
+        case BATTLEGROUND_QUEUE_5v5:
+            return BATTLEGROUND_AA;
+        default:
+            return BattlegroundTypeId(0);                   // used for unknown template (it existed and do nothing)
+    }
+}
+
+uint8 BattlegroundMgr::BGArenaType(BattlegroundQueueTypeId bgQueueTypeId)
+{
+    switch (bgQueueTypeId)
+    {
+        case BATTLEGROUND_QUEUE_2v2:
+            return ARENA_TYPE_2v2;
+        case BATTLEGROUND_QUEUE_3v3:
+            return ARENA_TYPE_3v3;
+        case BATTLEGROUND_QUEUE_5v5:
+            return ARENA_TYPE_5v5;
+        default:
+            return 0;
+    }
+}
+
+void BattlegroundMgr::ToggleTesting()
+{
+    m_Testing = !m_Testing;
+    sWorld->SendWorldText(m_Testing ? LANG_DEBUG_BG_ON : LANG_DEBUG_BG_OFF);
+}
+
+void BattlegroundMgr::ToggleArenaTesting()
+{
+    m_ArenaTesting = !m_ArenaTesting;
+    sWorld->SendWorldText(m_ArenaTesting ? LANG_DEBUG_ARENA_ON : LANG_DEBUG_ARENA_OFF);
+}
+
+void BattlegroundMgr::SetHolidayWeekends(uint32 mask)
+{
+    for (uint32 bgtype = 1; bgtype < MAX_BATTLEGROUND_TYPE_ID; ++bgtype)
+    {
+        if (Battleground* bg = GetBattlegroundTemplate(BattlegroundTypeId(bgtype)))
+        {
+            bg->SetHoliday(mask & (1 << bgtype));
+        }
+    }
+}
+
+void BattlegroundMgr::ScheduleQueueUpdate(uint32 arenaMatchmakerRating, uint8 arenaType, BattlegroundQueueTypeId bgQueueTypeId, BattlegroundTypeId bgTypeId, BattlegroundBracketId bracket_id)
+{
+    //This method must be atomic, TODO add mutex
+    //we will use only 1 number created of bgTypeId and bracket_id
+    uint64 const scheduleId = ((uint64)arenaMatchmakerRating << 32) | (arenaType << 24) | (bgQueueTypeId << 16) | (bgTypeId << 8) | bracket_id;
+    if (std::find(m_QueueUpdateScheduler.begin(), m_QueueUpdateScheduler.end(), scheduleId) == m_QueueUpdateScheduler.end())
+        m_QueueUpdateScheduler.push_back(scheduleId);
+}
+
+uint32 BattlegroundMgr::GetMaxRatingDifference() const
+{
+    // this is for stupid people who can't use brain and set max rating difference to 0
+    uint32 diff = sWorld->getIntConfig(CONFIG_ARENA_MAX_RATING_DIFFERENCE);
+    if (diff == 0)
+        diff = 5000;
+    return diff;
+}
+
+uint32 BattlegroundMgr::GetRatingDiscardTimer() const
+{
+    return sWorld->getIntConfig(CONFIG_ARENA_RATING_DISCARD_TIMER);
+}
+
+uint32 BattlegroundMgr::GetPrematureFinishTime() const
+{
+    return sWorld->getIntConfig(CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER);
+}
+
+void BattlegroundMgr::LoadBattleMastersEntry()
+{
+    uint32 oldMSTime = getMSTime();
+
+    mBattleMastersMap.clear();                                  // need for reload case
+
+    QueryResult result = WorldDatabase.Query("SELECT entry, bg_template FROM battlemaster_entry");
+
+    if (!result)
+    {
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">> Loaded 0 battlemaster entries. DB table `battlemaster_entry` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        ++count;
+
+        Field* fields = result->Fetch();
+
+        uint32 entry = fields[0].GetUInt32();
+        uint32 bgTypeId  = fields[1].GetUInt32();
+        if (!sBattlemasterListStore.LookupEntry(bgTypeId))
+        {
+            sLog->outError(LOG_FILTER_SQL, "Table `battlemaster_entry` contain entry %u for not existed battleground type %u, ignored.", entry, bgTypeId);
+            continue;
+        }
+
+        mBattleMastersMap[entry] = BattlegroundTypeId(bgTypeId);
+    }
+    while (result->NextRow());
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">> Loaded %u battlemaster entries in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
+HolidayIds BattlegroundMgr::BGTypeToWeekendHolidayId(BattlegroundTypeId bgTypeId)
+{
+    switch (bgTypeId)
+    {
+        case BATTLEGROUND_AV: return HOLIDAY_CALL_TO_ARMS_AV;
+        case BATTLEGROUND_EY: return HOLIDAY_CALL_TO_ARMS_EY;
+        case BATTLEGROUND_WS: return HOLIDAY_CALL_TO_ARMS_WS;
+        case BATTLEGROUND_SA: return HOLIDAY_CALL_TO_ARMS_SA;
+        case BATTLEGROUND_AB: return HOLIDAY_CALL_TO_ARMS_AB;
+        case BATTLEGROUND_IC: return HOLIDAY_CALL_TO_ARMS_IC;
+        case BATTLEGROUND_TP: return HOLIDAY_CALL_TO_ARMS_TP;
+        case BATTLEGROUND_BFG: return HOLIDAY_CALL_TO_ARMS_BFG;
+        default: return HOLIDAY_NONE;
+    }
+}
+
+BattlegroundTypeId BattlegroundMgr::WeekendHolidayIdToBGType(HolidayIds holiday)
+{
+    switch (holiday)
+    {
+        case HOLIDAY_CALL_TO_ARMS_AV: return BATTLEGROUND_AV;
+        case HOLIDAY_CALL_TO_ARMS_EY: return BATTLEGROUND_EY;
+        case HOLIDAY_CALL_TO_ARMS_WS: return BATTLEGROUND_WS;
+        case HOLIDAY_CALL_TO_ARMS_SA: return BATTLEGROUND_SA;
+        case HOLIDAY_CALL_TO_ARMS_AB: return BATTLEGROUND_AB;
+        case HOLIDAY_CALL_TO_ARMS_IC: return BATTLEGROUND_IC;
+        case HOLIDAY_CALL_TO_ARMS_TP: return BATTLEGROUND_TP;
+        case HOLIDAY_CALL_TO_ARMS_BFG: return BATTLEGROUND_BFG;
+        default: return BATTLEGROUND_TYPE_NONE;
+    }
+}
+
+bool BattlegroundMgr::IsBGWeekend(BattlegroundTypeId bgTypeId)
+{
+    return IsHolidayActive(BGTypeToWeekendHolidayId(bgTypeId));
+}
+
+BattlegroundTypeId BattlegroundMgr::GetRandomBG(BattlegroundTypeId bgTypeId)
+{
+    uint32 weight = 0;
+    BattlegroundTypeId returnBgTypeId = BATTLEGROUND_TYPE_NONE;
+    BattlegroundSelectionWeightMap selectionWeights;
+
+    if (bgTypeId == BATTLEGROUND_AA)
+    {
+        for (BattlegroundSelectionWeightMap::const_iterator it = m_ArenaSelectionWeights.begin(); it != m_ArenaSelectionWeights.end(); ++it)
+        {
+            if (it->second)
+            {
+                weight += it->second;
+                selectionWeights[it->first] = it->second;
+            }
+        }
+    }
+    else if (bgTypeId == BATTLEGROUND_RB)
+    {
+        for (BattlegroundSelectionWeightMap::const_iterator it = m_BGSelectionWeights.begin(); it != m_BGSelectionWeights.end(); ++it)
+        {
+            if (it->second)
+            {
+                weight += it->second;
+                selectionWeights[it->first] = it->second;
+            }
+        }
+    }
+
+    if (weight)
+    {
+        // Select a random value
+        uint32 selectedWeight = urand(0, weight - 1);
+        // Select the correct bg (if we have in DB A(10), B(20), C(10), D(15) --> [0---A---9|10---B---29|30---C---39|40---D---54])
+        weight = 0;
+        for (BattlegroundSelectionWeightMap::const_iterator it = selectionWeights.begin(); it != selectionWeights.end(); ++it)
+        {
+            weight += it->second;
+            if (selectedWeight < weight)
+            {
+                returnBgTypeId = it->first;
+                break;
+            }
+        }
+    }
+
+    return returnBgTypeId;
+}
+
+BGFreeSlotQueueContainer& BattlegroundMgr::GetBGFreeSlotQueueStore(BattlegroundTypeId bgTypeId)
+{
+    return bgDataStore[bgTypeId].BGFreeSlotQueue;
+}
+
+void BattlegroundMgr::AddToBGFreeSlotQueue(BattlegroundTypeId bgTypeId, Battleground* bg)
+{
+    bgDataStore[bgTypeId].BGFreeSlotQueue.push_front(bg);
+}
+
+void BattlegroundMgr::RemoveFromBGFreeSlotQueue(BattlegroundTypeId bgTypeId, uint32 instanceId)
+{
+    BGFreeSlotQueueContainer& queues = bgDataStore[bgTypeId].BGFreeSlotQueue;
+    for (BGFreeSlotQueueContainer::iterator itr = queues.begin(); itr != queues.end(); ++itr)
+        if ((*itr)->GetInstanceID() == instanceId)
+        {
+            queues.erase(itr);
+            return;
+        }
+}
+
+void BattlegroundMgr::AddBattleground(Battleground* bg)
+{
+    if (bg)
+        bgDataStore[bg->GetTypeID()].m_Battlegrounds[bg->GetInstanceID()] = bg;
+}
+
+void BattlegroundMgr::RemoveBattleground(BattlegroundTypeId bgTypeId, uint32 instanceId)
+{
+    bgDataStore[bgTypeId].m_Battlegrounds.erase(instanceId);
+}
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.cpp b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
index 0526e2d..8e7d654 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
@@ -167,6 +167,7 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
     {
         ArenaTeam* Team = sArenaTeamMgr->GetArenaTeamById(arenateamid);
         if (Team)
+            if ((Team->GetType() == ARENA_TYPE_5v5 && sWorld->getBoolConfig(CONFIG_ARENA_1V1_ANNOUNCER)) || Team->GetType() != ARENA_TYPE_5v5)
             sWorld->SendWorldText(LANG_ARENA_QUEUE_ANNOUNCE_WORLD_JOIN, Team->GetName().c_str(), ginfo->ArenaType, ginfo->ArenaType, ginfo->ArenaTeamRating);
     }
 
@@ -359,6 +360,7 @@ void BattlegroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
     // announce to world if arena team left queue for rated match, show only once
     if (group->ArenaType && group->IsRated && group->Players.empty() && sWorld->getBoolConfig(CONFIG_ARENA_QUEUE_ANNOUNCER_ENABLE))
         if (ArenaTeam* Team = sArenaTeamMgr->GetArenaTeamById(group->ArenaTeamId))
+            if (Team && ((Team->GetType() == ARENA_TYPE_5v5 && sWorld->getBoolConfig(CONFIG_ARENA_1V1_ANNOUNCER)) || Team->GetType() != ARENA_TYPE_5v5))
             sWorld->SendWorldText(LANG_ARENA_QUEUE_ANNOUNCE_WORLD_EXIT, Team->GetName().c_str(), group->ArenaType, group->ArenaType, group->ArenaTeamRating);
 
     // if player leaves queue and he is invited to rated arena match, then he have to lose
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.cpp.orig b/src/server/game/Battlegrounds/BattlegroundQueue.cpp.orig
new file mode 100644
index 0000000..0526e2d
--- /dev/null
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.cpp.orig
@@ -0,0 +1,1076 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ArenaTeam.h"
+#include "ArenaTeamMgr.h"
+#include "BattlegroundMgr.h"
+#include "BattlegroundQueue.h"
+#include "Chat.h"
+#include "Group.h"
+#include "Log.h"
+#include "Language.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+
+/*********************************************************/
+/***            BATTLEGROUND QUEUE SYSTEM              ***/
+/*********************************************************/
+
+BattlegroundQueue::BattlegroundQueue()
+{
+    for (uint32 i = 0; i < BG_TEAMS_COUNT; ++i)
+    {
+        for (uint32 j = 0; j < MAX_BATTLEGROUND_BRACKETS; ++j)
+        {
+            m_SumOfWaitTimes[i][j] = 0;
+            m_WaitTimeLastPlayer[i][j] = 0;
+            for (uint32 k = 0; k < COUNT_OF_PLAYERS_TO_AVERAGE_WAIT_TIME; ++k)
+                m_WaitTimes[i][j][k] = 0;
+        }
+    }
+}
+
+BattlegroundQueue::~BattlegroundQueue()
+{
+    m_events.KillAllEvents(false);
+
+    m_QueuedPlayers.clear();
+    for (int i = 0; i < MAX_BATTLEGROUND_BRACKETS; ++i)
+    {
+        for (uint32 j = 0; j < BG_QUEUE_GROUP_TYPES_COUNT; ++j)
+        {
+            for (GroupsQueueType::iterator itr = m_QueuedGroups[i][j].begin(); itr!= m_QueuedGroups[i][j].end(); ++itr)
+                delete (*itr);
+            m_QueuedGroups[i][j].clear();
+        }
+    }
+}
+
+/*********************************************************/
+/***      BATTLEGROUND QUEUE SELECTION POOLS           ***/
+/*********************************************************/
+
+// selection pool initialization, used to clean up from prev selection
+void BattlegroundQueue::SelectionPool::Init()
+{
+    SelectedGroups.clear();
+    PlayerCount = 0;
+}
+
+// remove group info from selection pool
+// returns true when we need to try to add new group to selection pool
+// returns false when selection pool is ok or when we kicked smaller group than we need to kick
+// sometimes it can be called on empty selection pool
+bool BattlegroundQueue::SelectionPool::KickGroup(uint32 size)
+{
+    //find maxgroup or LAST group with size == size and kick it
+    bool found = false;
+    GroupsQueueType::iterator groupToKick = SelectedGroups.begin();
+    for (GroupsQueueType::iterator itr = groupToKick; itr != SelectedGroups.end(); ++itr)
+    {
+        if (abs((int32)((*itr)->Players.size() - size)) <= 1)
+        {
+            groupToKick = itr;
+            found = true;
+        }
+        else if (!found && (*itr)->Players.size() >= (*groupToKick)->Players.size())
+            groupToKick = itr;
+    }
+    //if pool is empty, do nothing
+    if (GetPlayerCount())
+    {
+        //update player count
+        GroupQueueInfo* ginfo = (*groupToKick);
+        SelectedGroups.erase(groupToKick);
+        PlayerCount -= ginfo->Players.size();
+        //return false if we kicked smaller group or there are enough players in selection pool
+        if (ginfo->Players.size() <= size + 1)
+            return false;
+    }
+    return true;
+}
+
+// add group to selection pool
+// used when building selection pools
+// returns true if we can invite more players, or when we added group to selection pool
+// returns false when selection pool is full
+bool BattlegroundQueue::SelectionPool::AddGroup(GroupQueueInfo* ginfo, uint32 desiredCount)
+{
+    //if group is larger than desired count - don't allow to add it to pool
+    if (!ginfo->IsInvitedToBGInstanceGUID && desiredCount >= PlayerCount + ginfo->Players.size())
+    {
+        SelectedGroups.push_back(ginfo);
+        // increase selected players count
+        PlayerCount += ginfo->Players.size();
+        return true;
+    }
+    if (PlayerCount < desiredCount)
+        return true;
+    return false;
+}
+
+/*********************************************************/
+/***               BATTLEGROUND QUEUES                 ***/
+/*********************************************************/
+
+// add group or player (grp == NULL) to bg queue with the given leader and bg specifications
+GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, BattlegroundTypeId BgTypeId, PvPDifficultyEntry const*  bracketEntry, uint8 ArenaType, bool isRated, bool isPremade, uint32 ArenaRating, uint32 MatchmakerRating, uint32 arenateamid)
+{
+    BattlegroundBracketId bracketId = bracketEntry->GetBracketId();
+
+    // create new ginfo
+    GroupQueueInfo* ginfo            = new GroupQueueInfo;
+    ginfo->BgTypeId                  = BgTypeId;
+    ginfo->ArenaType                 = ArenaType;
+    ginfo->ArenaTeamId               = arenateamid;
+    ginfo->IsRated                   = isRated;
+    ginfo->IsInvitedToBGInstanceGUID = 0;
+    ginfo->JoinTime                  = getMSTime();
+    ginfo->RemoveInviteTime          = 0;
+    ginfo->Team                      = leader->GetTeam();
+    ginfo->ArenaTeamRating           = ArenaRating;
+    ginfo->ArenaMatchmakerRating     = MatchmakerRating;
+    ginfo->OpponentsTeamRating       = 0;
+    ginfo->OpponentsMatchmakerRating = 0;
+    ginfo->ratingRange               = 0;
+    ginfo->ratingRangeIncreaseCounter= 0;
+
+    ginfo->Players.clear();
+
+    //compute index (if group is premade or joined a rated match) to queues
+    uint32 index = 0;
+    if (!isRated && !isPremade)
+        index += BG_TEAMS_COUNT;
+    if (ginfo->Team == HORDE)
+        index++;
+    sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Adding Group to BattlegroundQueue bgTypeId : %u, bracket_id : %u, index : %u", BgTypeId, bracketId, index);
+
+    uint32 lastOnlineTime = getMSTime();
+
+    //announce world (this don't need mutex)
+    if (isRated && sWorld->getBoolConfig(CONFIG_ARENA_QUEUE_ANNOUNCER_ENABLE))
+    {
+        ArenaTeam* Team = sArenaTeamMgr->GetArenaTeamById(arenateamid);
+        if (Team)
+            sWorld->SendWorldText(LANG_ARENA_QUEUE_ANNOUNCE_WORLD_JOIN, Team->GetName().c_str(), ginfo->ArenaType, ginfo->ArenaType, ginfo->ArenaTeamRating);
+    }
+
+    //add players from group to ginfo
+    if (grp)
+    {
+        for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* member = itr->getSource();
+            if (!member)
+                continue;   // this should never happen
+            PlayerQueueInfo& pl_info = m_QueuedPlayers[member->GetGUID()];
+            pl_info.LastOnlineTime   = lastOnlineTime;
+            pl_info.GroupInfo        = ginfo;
+            // add the pinfo to ginfo's list
+            ginfo->Players[member->GetGUID()]  = &pl_info;
+        }
+    }
+    else
+    {
+        PlayerQueueInfo& pl_info = m_QueuedPlayers[leader->GetGUID()];
+        pl_info.LastOnlineTime   = lastOnlineTime;
+        pl_info.GroupInfo        = ginfo;
+        ginfo->Players[leader->GetGUID()]  = &pl_info;
+    }
+
+    //add GroupInfo to m_QueuedGroups
+    {
+        //ACE_Guard<ACE_Recursive_Thread_Mutex> guard(m_Lock);
+        m_QueuedGroups[bracketId][index].push_back(ginfo);
+
+        //announce to world, this code needs mutex
+        if (!isRated && !isPremade && sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_ENABLE))
+        {
+            if (Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(ginfo->BgTypeId))
+            {
+                char const* bgName = bg->GetName();
+                uint32 MinPlayers = bg->GetMinPlayersPerTeam();
+                uint32 qHorde = 0;
+                uint32 qAlliance = 0;
+                uint32 q_min_level = bracketEntry->minLevel;
+                uint32 q_max_level = bracketEntry->maxLevel;
+                GroupsQueueType::const_iterator itr;
+                for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].end(); ++itr)
+                    if (!(*itr)->IsInvitedToBGInstanceGUID)
+                        qAlliance += (*itr)->Players.size();
+                for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].end(); ++itr)
+                    if (!(*itr)->IsInvitedToBGInstanceGUID)
+                        qHorde += (*itr)->Players.size();
+
+                // Show queue status to player only (when joining queue)
+                if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                {
+                    ChatHandler(leader->GetSession()).PSendSysMessage(LANG_BG_QUEUE_ANNOUNCE_SELF, bgName, q_min_level, q_max_level,
+                        qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                }
+                // System message
+                else
+                {
+                    sWorld->SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD, bgName, q_min_level, q_max_level,
+                        qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                }
+            }
+        }
+        //release mutex
+    }
+
+    return ginfo;
+}
+
+void BattlegroundQueue::PlayerInvitedToBGUpdateAverageWaitTime(GroupQueueInfo* ginfo, BattlegroundBracketId bracket_id)
+{
+    uint32 timeInQueue = getMSTimeDiff(ginfo->JoinTime, getMSTime());
+    uint8 team_index = TEAM_ALLIANCE;                    //default set to TEAM_ALLIANCE - or non rated arenas!
+    if (!ginfo->ArenaType)
+    {
+        if (ginfo->Team == HORDE)
+            team_index = TEAM_HORDE;
+    }
+    else
+    {
+        if (ginfo->IsRated)
+            team_index = TEAM_HORDE;                     //for rated arenas use TEAM_HORDE
+    }
+
+    //store pointer to arrayindex of player that was added first
+    uint32* lastPlayerAddedPointer = &(m_WaitTimeLastPlayer[team_index][bracket_id]);
+    //remove his time from sum
+    m_SumOfWaitTimes[team_index][bracket_id] -= m_WaitTimes[team_index][bracket_id][(*lastPlayerAddedPointer)];
+    //set average time to new
+    m_WaitTimes[team_index][bracket_id][(*lastPlayerAddedPointer)] = timeInQueue;
+    //add new time to sum
+    m_SumOfWaitTimes[team_index][bracket_id] += timeInQueue;
+    //set index of last player added to next one
+    (*lastPlayerAddedPointer)++;
+    (*lastPlayerAddedPointer) %= COUNT_OF_PLAYERS_TO_AVERAGE_WAIT_TIME;
+}
+
+uint32 BattlegroundQueue::GetAverageQueueWaitTime(GroupQueueInfo* ginfo, BattlegroundBracketId bracket_id) const
+{
+    uint8 team_index = TEAM_ALLIANCE;                    //default set to TEAM_ALLIANCE - or non rated arenas!
+    if (!ginfo->ArenaType)
+    {
+        if (ginfo->Team == HORDE)
+            team_index = TEAM_HORDE;
+    }
+    else
+    {
+        if (ginfo->IsRated)
+            team_index = TEAM_HORDE;                     //for rated arenas use TEAM_HORDE
+    }
+    //check if there is enought values(we always add values > 0)
+    if (m_WaitTimes[team_index][bracket_id][COUNT_OF_PLAYERS_TO_AVERAGE_WAIT_TIME - 1])
+        return (m_SumOfWaitTimes[team_index][bracket_id] / COUNT_OF_PLAYERS_TO_AVERAGE_WAIT_TIME);
+    else
+        //if there aren't enough values return 0 - not available
+        return 0;
+}
+
+//remove player from queue and from group info, if group info is empty then remove it too
+void BattlegroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
+{
+    //Player* player = ObjectAccessor::FindPlayer(guid);
+
+    int32 bracket_id = -1;                                     // signed for proper for-loop finish
+    QueuedPlayersMap::iterator itr;
+
+    //remove player from map, if he's there
+    itr = m_QueuedPlayers.find(guid);
+    if (itr == m_QueuedPlayers.end())
+    {
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "BattlegroundQueue: couldn't find player to remove GUID: %u", GUID_LOPART(guid));
+        return;
+    }
+
+    GroupQueueInfo* group = itr->second.GroupInfo;
+    GroupsQueueType::iterator group_itr;
+    // mostly people with the highest levels are in battlegrounds, thats why
+    // we count from MAX_BATTLEGROUND_QUEUES - 1 to 0
+
+    uint32 index = (group->Team == HORDE) ? BG_QUEUE_PREMADE_HORDE : BG_QUEUE_PREMADE_ALLIANCE;
+
+    for (int32 bracket_id_tmp = MAX_BATTLEGROUND_BRACKETS - 1; bracket_id_tmp >= 0 && bracket_id == -1; --bracket_id_tmp)
+    {
+        //we must check premade and normal team's queue - because when players from premade are joining bg,
+        //they leave groupinfo so we can't use its players size to find out index
+        for (uint32 j = index; j < BG_QUEUE_GROUP_TYPES_COUNT; j += BG_TEAMS_COUNT)
+        {
+            GroupsQueueType::iterator k = m_QueuedGroups[bracket_id_tmp][j].begin();
+            for (; k != m_QueuedGroups[bracket_id_tmp][j].end(); ++k)
+            {
+                if ((*k) == group)
+                {
+                    bracket_id = bracket_id_tmp;
+                    group_itr = k;
+                    //we must store index to be able to erase iterator
+                    index = j;
+                    break;
+                }
+            }
+        }
+    }
+
+    //player can't be in queue without group, but just in case
+    if (bracket_id == -1)
+    {
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "BattlegroundQueue: ERROR Cannot find groupinfo for player GUID: %u", GUID_LOPART(guid));
+        return;
+    }
+    sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BattlegroundQueue: Removing player GUID %u, from bracket_id %u", GUID_LOPART(guid), (uint32)bracket_id);
+
+    // ALL variables are correctly set
+    // We can ignore leveling up in queue - it should not cause crash
+    // remove player from group
+    // if only one player there, remove group
+
+    // remove player queue info from group queue info
+    std::map<uint64, PlayerQueueInfo*>::iterator pitr = group->Players.find(guid);
+    if (pitr != group->Players.end())
+        group->Players.erase(pitr);
+
+    // if invited to bg, and should decrease invited count, then do it
+    if (decreaseInvitedCount && group->IsInvitedToBGInstanceGUID)
+        if (Battleground* bg = sBattlegroundMgr->GetBattleground(group->IsInvitedToBGInstanceGUID, group->BgTypeId))
+            bg->DecreaseInvitedCount(group->Team);
+
+    // remove player queue info
+    m_QueuedPlayers.erase(itr);
+
+    // announce to world if arena team left queue for rated match, show only once
+    if (group->ArenaType && group->IsRated && group->Players.empty() && sWorld->getBoolConfig(CONFIG_ARENA_QUEUE_ANNOUNCER_ENABLE))
+        if (ArenaTeam* Team = sArenaTeamMgr->GetArenaTeamById(group->ArenaTeamId))
+            sWorld->SendWorldText(LANG_ARENA_QUEUE_ANNOUNCE_WORLD_EXIT, Team->GetName().c_str(), group->ArenaType, group->ArenaType, group->ArenaTeamRating);
+
+    // if player leaves queue and he is invited to rated arena match, then he have to lose
+    if (group->IsInvitedToBGInstanceGUID && group->IsRated && decreaseInvitedCount)
+    {
+        if (ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(group->ArenaTeamId))
+        {
+            sLog->outDebug(LOG_FILTER_BATTLEGROUND, "UPDATING memberLost's personal arena rating for %u by opponents rating: %u", GUID_LOPART(guid), group->OpponentsTeamRating);
+            if (Player* player = ObjectAccessor::FindPlayer(guid))
+                at->MemberLost(player, group->OpponentsMatchmakerRating);
+            else
+                at->OfflineMemberLost(guid, group->OpponentsMatchmakerRating);
+            at->SaveToDB();
+        }
+    }
+
+    // remove group queue info if needed
+    if (group->Players.empty())
+    {
+        m_QueuedGroups[bracket_id][index].erase(group_itr);
+        delete group;
+        return;
+    }
+
+    // if group wasn't empty, so it wasn't deleted, and player have left a rated
+    // queue -> everyone from the group should leave too
+    // don't remove recursively if already invited to bg!
+    if (!group->IsInvitedToBGInstanceGUID && group->IsRated)
+    {
+        // remove next player, this is recursive
+        // first send removal information
+        if (Player* plr2 = ObjectAccessor::FindPlayer(group->Players.begin()->first))
+        {
+            Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(group->BgTypeId);
+            BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(group->BgTypeId, group->ArenaType);
+            uint32 queueSlot = plr2->GetBattlegroundQueueIndex(bgQueueTypeId);
+
+            plr2->RemoveBattlegroundQueueId(bgQueueTypeId); // must be called this way, because if you move this call to
+                                                            // queue->removeplayer, it causes bugs
+            WorldPacket data;
+            sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, plr2, queueSlot, STATUS_NONE, plr2->GetBattlegroundQueueJoinTime(group->BgTypeId), 0, group->ArenaType);
+            plr2->GetSession()->SendPacket(&data);
+        }
+        // then actually delete, this may delete the group as well!
+        RemovePlayer(group->Players.begin()->first, decreaseInvitedCount);
+    }
+}
+
+//returns true when player pl_guid is in queue and is invited to bgInstanceGuid
+bool BattlegroundQueue::IsPlayerInvited(uint64 pl_guid, const uint32 bgInstanceGuid, const uint32 removeTime)
+{
+    QueuedPlayersMap::const_iterator qItr = m_QueuedPlayers.find(pl_guid);
+    return (qItr != m_QueuedPlayers.end()
+        && qItr->second.GroupInfo->IsInvitedToBGInstanceGUID == bgInstanceGuid
+        && qItr->second.GroupInfo->RemoveInviteTime == removeTime);
+}
+
+bool BattlegroundQueue::GetPlayerGroupInfoData(uint64 guid, GroupQueueInfo* ginfo)
+{
+    QueuedPlayersMap::const_iterator qItr = m_QueuedPlayers.find(guid);
+    if (qItr == m_QueuedPlayers.end())
+        return false;
+    *ginfo = *(qItr->second.GroupInfo);
+    return true;
+}
+
+uint32 BattlegroundQueue::GetPlayersInQueue(TeamId id)
+{
+    return m_SelectionPools[id].GetPlayerCount();
+}
+
+bool BattlegroundQueue::InviteGroupToBG(GroupQueueInfo* ginfo, Battleground* bg, uint32 side)
+{
+    // set side if needed
+    if (side)
+        ginfo->Team = side;
+
+    if (!ginfo->IsInvitedToBGInstanceGUID)
+    {
+        // not yet invited
+        // set invitation
+        ginfo->IsInvitedToBGInstanceGUID = bg->GetInstanceID();
+        BattlegroundTypeId bgTypeId = bg->GetTypeID();
+        BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(bgTypeId, bg->GetArenaType());
+        BattlegroundBracketId bracket_id = bg->GetBracketId();
+
+        // set ArenaTeamId for rated matches
+        if (bg->isArena() && bg->isRated())
+            bg->SetArenaTeamIdForTeam(ginfo->Team, ginfo->ArenaTeamId);
+
+        ginfo->RemoveInviteTime = getMSTime() + INVITE_ACCEPT_WAIT_TIME;
+
+        // loop through the players
+        for (std::map<uint64, PlayerQueueInfo*>::iterator itr = ginfo->Players.begin(); itr != ginfo->Players.end(); ++itr)
+        {
+            // get the player
+            Player* player = ObjectAccessor::FindPlayer(itr->first);
+            // if offline, skip him, this should not happen - player is removed from queue when he logs out
+            if (!player)
+                continue;
+
+            // invite the player
+            PlayerInvitedToBGUpdateAverageWaitTime(ginfo, bracket_id);
+            //sBattlegroundMgr->InvitePlayer(player, bg, ginfo->Team);
+
+            // set invited player counters
+            bg->IncreaseInvitedCount(ginfo->Team);
+
+            player->SetInviteForBattlegroundQueueType(bgQueueTypeId, ginfo->IsInvitedToBGInstanceGUID);
+
+            // create remind invite events
+            BGQueueInviteEvent* inviteEvent = new BGQueueInviteEvent(player->GetGUID(), ginfo->IsInvitedToBGInstanceGUID, bgTypeId, ginfo->ArenaType, ginfo->RemoveInviteTime);
+            m_events.AddEvent(inviteEvent, m_events.CalculateTime(INVITATION_REMIND_TIME));
+            // create automatic remove events
+            BGQueueRemoveEvent* removeEvent = new BGQueueRemoveEvent(player->GetGUID(), ginfo->IsInvitedToBGInstanceGUID, bgTypeId, ginfo->ArenaType, bgQueueTypeId, ginfo->RemoveInviteTime);
+            m_events.AddEvent(removeEvent, m_events.CalculateTime(INVITE_ACCEPT_WAIT_TIME));
+
+            WorldPacket data;
+
+            uint32 queueSlot = player->GetBattlegroundQueueIndex(bgQueueTypeId);
+
+            sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Battleground: invited player %s (%u) to BG instance %u queueindex %u bgtype %u",
+                 player->GetName().c_str(), player->GetGUIDLow(), bg->GetInstanceID(), queueSlot, bg->GetTypeID());
+
+            // send status packet
+            sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, player, queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME, player->GetBattlegroundQueueJoinTime(bgTypeId), ginfo->ArenaType);
+            player->GetSession()->SendPacket(&data);
+        }
+        return true;
+    }
+
+    return false;
+}
+
+/*
+This function is inviting players to already running battlegrounds
+Invitation type is based on config file
+large groups are disadvantageous, because they will be kicked first if invitation type = 1
+*/
+void BattlegroundQueue::FillPlayersToBG(Battleground* bg, BattlegroundBracketId bracket_id)
+{
+    int32 hordeFree = bg->GetFreeSlotsForTeam(HORDE);
+    int32 aliFree   = bg->GetFreeSlotsForTeam(ALLIANCE);
+
+    //iterator for iterating through bg queue
+    GroupsQueueType::const_iterator Ali_itr = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].begin();
+    //count of groups in queue - used to stop cycles
+    uint32 aliCount = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].size();
+    //index to queue which group is current
+    uint32 aliIndex = 0;
+    for (; aliIndex < aliCount && m_SelectionPools[TEAM_ALLIANCE].AddGroup((*Ali_itr), aliFree); aliIndex++)
+        ++Ali_itr;
+    //the same thing for horde
+    GroupsQueueType::const_iterator Horde_itr = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].begin();
+    uint32 hordeCount = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].size();
+    uint32 hordeIndex = 0;
+    for (; hordeIndex < hordeCount && m_SelectionPools[TEAM_HORDE].AddGroup((*Horde_itr), hordeFree); hordeIndex++)
+        ++Horde_itr;
+
+    //if ofc like BG queue invitation is set in config, then we are happy
+    if (sWorld->getIntConfig(CONFIG_BATTLEGROUND_INVITATION_TYPE) == 0)
+        return;
+
+    /*
+    if we reached this code, then we have to solve NP - complete problem called Subset sum problem
+    So one solution is to check all possible invitation subgroups, or we can use these conditions:
+    1. Last time when BattlegroundQueue::Update was executed we invited all possible players - so there is only small possibility
+        that we will invite now whole queue, because only 1 change has been made to queues from the last BattlegroundQueue::Update call
+    2. Other thing we should consider is group order in queue
+    */
+
+    // At first we need to compare free space in bg and our selection pool
+    int32 diffAli   = aliFree   - int32(m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount());
+    int32 diffHorde = hordeFree - int32(m_SelectionPools[TEAM_HORDE].GetPlayerCount());
+    while (abs(diffAli - diffHorde) > 1 && (m_SelectionPools[TEAM_HORDE].GetPlayerCount() > 0 || m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() > 0))
+    {
+        //each cycle execution we need to kick at least 1 group
+        if (diffAli < diffHorde)
+        {
+            //kick alliance group, add to pool new group if needed
+            if (m_SelectionPools[TEAM_ALLIANCE].KickGroup(diffHorde - diffAli))
+            {
+                for (; aliIndex < aliCount && m_SelectionPools[TEAM_ALLIANCE].AddGroup((*Ali_itr), (aliFree >= diffHorde) ? aliFree - diffHorde : 0); aliIndex++)
+                    ++Ali_itr;
+            }
+            //if ali selection is already empty, then kick horde group, but if there are less horde than ali in bg - break;
+            if (!m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount())
+            {
+                if (aliFree <= diffHorde + 1)
+                    break;
+                m_SelectionPools[TEAM_HORDE].KickGroup(diffHorde - diffAli);
+            }
+        }
+        else
+        {
+            //kick horde group, add to pool new group if needed
+            if (m_SelectionPools[TEAM_HORDE].KickGroup(diffAli - diffHorde))
+            {
+                for (; hordeIndex < hordeCount && m_SelectionPools[TEAM_HORDE].AddGroup((*Horde_itr), (hordeFree >= diffAli) ? hordeFree - diffAli : 0); hordeIndex++)
+                    ++Horde_itr;
+            }
+            if (!m_SelectionPools[TEAM_HORDE].GetPlayerCount())
+            {
+                if (hordeFree <= diffAli + 1)
+                    break;
+                m_SelectionPools[TEAM_ALLIANCE].KickGroup(diffAli - diffHorde);
+            }
+        }
+        //count diffs after small update
+        diffAli   = aliFree   - int32(m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount());
+        diffHorde = hordeFree - int32(m_SelectionPools[TEAM_HORDE].GetPlayerCount());
+    }
+}
+
+// this method checks if premade versus premade battleground is possible
+// then after 30 mins (default) in queue it moves premade group to normal queue
+// it tries to invite as much players as it can - to MaxPlayersPerTeam, because premade groups have more than MinPlayersPerTeam players
+bool BattlegroundQueue::CheckPremadeMatch(BattlegroundBracketId bracket_id, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam)
+{
+    //check match
+    if (!m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].empty() && !m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].empty())
+    {
+        //start premade match
+        //if groups aren't invited
+        GroupsQueueType::const_iterator ali_group, horde_group;
+        for (ali_group = m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].begin(); ali_group != m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].end(); ++ali_group)
+            if (!(*ali_group)->IsInvitedToBGInstanceGUID)
+                break;
+        for (horde_group = m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].begin(); horde_group != m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].end(); ++horde_group)
+            if (!(*horde_group)->IsInvitedToBGInstanceGUID)
+                break;
+
+        if (ali_group != m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].end() && horde_group != m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].end())
+        {
+            m_SelectionPools[TEAM_ALLIANCE].AddGroup((*ali_group), MaxPlayersPerTeam);
+            m_SelectionPools[TEAM_HORDE].AddGroup((*horde_group), MaxPlayersPerTeam);
+            //add groups/players from normal queue to size of bigger group
+            uint32 maxPlayers = std::min(m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount(), m_SelectionPools[TEAM_HORDE].GetPlayerCount());
+            GroupsQueueType::const_iterator itr;
+            for (uint32 i = 0; i < BG_TEAMS_COUNT; i++)
+            {
+                for (itr = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + i].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + i].end(); ++itr)
+                {
+                    //if itr can join BG and player count is less that maxPlayers, then add group to selectionpool
+                    if (!(*itr)->IsInvitedToBGInstanceGUID && !m_SelectionPools[i].AddGroup((*itr), maxPlayers))
+                        break;
+                }
+            }
+            //premade selection pools are set
+            return true;
+        }
+    }
+    // now check if we can move group from Premade queue to normal queue (timer has expired) or group size lowered!!
+    // this could be 2 cycles but i'm checking only first team in queue - it can cause problem -
+    // if first is invited to BG and seconds timer expired, but we can ignore it, because players have only 80 seconds to click to enter bg
+    // and when they click or after 80 seconds the queue info is removed from queue
+    uint32 time_before = getMSTime() - sWorld->getIntConfig(CONFIG_BATTLEGROUND_PREMADE_GROUP_WAIT_FOR_MATCH);
+    for (uint32 i = 0; i < BG_TEAMS_COUNT; i++)
+    {
+        if (!m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE + i].empty())
+        {
+            GroupsQueueType::iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE + i].begin();
+            if (!(*itr)->IsInvitedToBGInstanceGUID && ((*itr)->JoinTime < time_before || (*itr)->Players.size() < MinPlayersPerTeam))
+            {
+                //we must insert group to normal queue and erase pointer from premade queue
+                m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + i].push_front((*itr));
+                m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE + i].erase(itr);
+            }
+        }
+    }
+    //selection pools are not set
+    return false;
+}
+
+// this method tries to create battleground or arena with MinPlayersPerTeam against MinPlayersPerTeam
+bool BattlegroundQueue::CheckNormalMatch(Battleground* /*bg_template*/, BattlegroundBracketId bracket_id, uint32 minPlayers, uint32 maxPlayers)
+{
+    GroupsQueueType::const_iterator itr_team[BG_TEAMS_COUNT];
+    for (uint32 i = 0; i < BG_TEAMS_COUNT; i++)
+    {
+        itr_team[i] = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + i].begin();
+        for (; itr_team[i] != m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + i].end(); ++(itr_team[i]))
+        {
+            if (!(*(itr_team[i]))->IsInvitedToBGInstanceGUID)
+            {
+                m_SelectionPools[i].AddGroup(*(itr_team[i]), maxPlayers);
+                if (m_SelectionPools[i].GetPlayerCount() >= minPlayers)
+                    break;
+            }
+        }
+    }
+    //try to invite same number of players - this cycle may cause longer wait time even if there are enough players in queue, but we want ballanced bg
+    uint32 j = TEAM_ALLIANCE;
+    if (m_SelectionPools[TEAM_HORDE].GetPlayerCount() < m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount())
+        j = TEAM_HORDE;
+    if (sWorld->getIntConfig(CONFIG_BATTLEGROUND_INVITATION_TYPE) != 0
+        && m_SelectionPools[TEAM_HORDE].GetPlayerCount() >= minPlayers && m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() >= minPlayers)
+    {
+        //we will try to invite more groups to team with less players indexed by j
+        ++(itr_team[j]);                                         //this will not cause a crash, because for cycle above reached break;
+        for (; itr_team[j] != m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + j].end(); ++(itr_team[j]))
+        {
+            if (!(*(itr_team[j]))->IsInvitedToBGInstanceGUID)
+                if (!m_SelectionPools[j].AddGroup(*(itr_team[j]), m_SelectionPools[(j + 1) % BG_TEAMS_COUNT].GetPlayerCount()))
+                    break;
+        }
+        // do not allow to start bg with more than 2 players more on 1 faction
+        if (abs((int32)(m_SelectionPools[TEAM_HORDE].GetPlayerCount() - m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount())) > 2)
+            return false;
+    }
+    //allow 1v0 if debug bg
+    if (sBattlegroundMgr->isTesting() && (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() || m_SelectionPools[TEAM_HORDE].GetPlayerCount()))
+        return true;
+    //return true if there are enough players in selection pools - enable to work .debug bg command correctly
+    return m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() >= minPlayers && m_SelectionPools[TEAM_HORDE].GetPlayerCount() >= minPlayers;
+}
+
+// this method will check if we can invite players to same faction skirmish match
+bool BattlegroundQueue::CheckSkirmishForSameFaction(BattlegroundBracketId bracket_id, uint32 minPlayersPerTeam)
+{
+    if (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() < minPlayersPerTeam && m_SelectionPools[TEAM_HORDE].GetPlayerCount() < minPlayersPerTeam)
+        return false;
+    uint32 teamIndex = TEAM_ALLIANCE;
+    uint32 otherTeam = TEAM_HORDE;
+    uint32 otherTeamId = HORDE;
+    if (m_SelectionPools[TEAM_HORDE].GetPlayerCount() == minPlayersPerTeam)
+    {
+        teamIndex = TEAM_HORDE;
+        otherTeam = TEAM_ALLIANCE;
+        otherTeamId = ALLIANCE;
+    }
+    //clear other team's selection
+    m_SelectionPools[otherTeam].Init();
+    //store last ginfo pointer
+    GroupQueueInfo* ginfo = m_SelectionPools[teamIndex].SelectedGroups.back();
+    //set itr_team to group that was added to selection pool latest
+    GroupsQueueType::iterator itr_team = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + teamIndex].begin();
+    for (; itr_team != m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + teamIndex].end(); ++itr_team)
+        if (ginfo == *itr_team)
+            break;
+    if (itr_team == m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + teamIndex].end())
+        return false;
+    GroupsQueueType::iterator itr_team2 = itr_team;
+    ++itr_team2;
+    //invite players to other selection pool
+    for (; itr_team2 != m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + teamIndex].end(); ++itr_team2)
+    {
+        //if selection pool is full then break;
+        if (!(*itr_team2)->IsInvitedToBGInstanceGUID && !m_SelectionPools[otherTeam].AddGroup(*itr_team2, minPlayersPerTeam))
+            break;
+    }
+    if (m_SelectionPools[otherTeam].GetPlayerCount() != minPlayersPerTeam)
+        return false;
+
+    //here we have correct 2 selections and we need to change one teams team and move selection pool teams to other team's queue
+    for (GroupsQueueType::iterator itr = m_SelectionPools[otherTeam].SelectedGroups.begin(); itr != m_SelectionPools[otherTeam].SelectedGroups.end(); ++itr)
+    {
+        //set correct team
+        (*itr)->Team = otherTeamId;
+        //add team to other queue
+        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + otherTeam].push_front(*itr);
+        //remove team from old queue
+        GroupsQueueType::iterator itr2 = itr_team;
+        ++itr2;
+        for (; itr2 != m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + teamIndex].end(); ++itr2)
+        {
+            if (*itr2 == *itr)
+            {
+                m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE + teamIndex].erase(itr2);
+                break;
+            }
+        }
+    }
+    return true;
+}
+
+void BattlegroundQueue::UpdateEvents(uint32 diff)
+{
+    m_events.Update(diff);
+}
+
+void BattlegroundQueue::IncreaseTeamMMrRange(GroupQueueInfo* ginfo)
+{
+    if (ginfo->ratingRangeIncreaseCounter > 0)
+    {
+        ginfo->ratingRange += 100;
+        uint32 completeRange = sBattlegroundMgr->GetMaxRatingDifference() + ginfo->ratingRange;
+        for (std::map<uint64, PlayerQueueInfo*>::iterator itr = ginfo->Players.begin(); itr != ginfo->Players.end(); ++itr)
+        {
+            uint32 minRating = std::max(0, int32(ginfo->ArenaMatchmakerRating - completeRange));
+            uint32 maxRating = std::min(int32(ginfo->ArenaMatchmakerRating + completeRange), 4000);
+            if (Player* plr = sObjectAccessor->FindPlayer(itr->first))
+                ChatHandler(plr->GetSession()).PSendSysMessage("The Matchmaking system will now try to find enemy teams between %i and %i Matchmaking Rating", minRating, maxRating);
+        }
+    }
+    ginfo->ratingRangeIncreaseCounter += 1;
+}
+
+/*
+this method is called when group is inserted, or player / group is removed from BG Queue - there is only one player's status changed, so we don't use while (true) cycles to invite whole queue
+it must be called after fully adding the members of a group to ensure group joining
+should be called from Battleground::RemovePlayer function in some cases
+*/
+void BattlegroundQueue::BattlegroundQueueUpdate(uint32 /*diff*/, BattlegroundTypeId bgTypeId, BattlegroundBracketId bracket_id, uint8 arenaType, bool isRated, uint32 arenaRating)
+{
+    //if no players in queue - do nothing
+    if (m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].empty() &&
+        m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].empty() &&
+        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].empty() &&
+        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].empty())
+        return;
+
+    // battleground with free slot for player should be always in the beggining of the queue
+    // maybe it would be better to create bgfreeslotqueue for each bracket_id
+    BGFreeSlotQueueContainer& bgQueues = sBattlegroundMgr->GetBGFreeSlotQueueStore(bgTypeId);
+    for (BGFreeSlotQueueContainer::iterator itr = bgQueues.begin(); itr != bgQueues.end();)
+    {
+        Battleground* bg = *itr; ++itr;
+        // DO NOT allow queue manager to invite new player to rated games
+        if (!bg->isRated() && bg->GetTypeID() == bgTypeId && bg->GetBracketId() == bracket_id &&
+            bg->GetStatus() > STATUS_WAIT_QUEUE && bg->GetStatus() < STATUS_WAIT_LEAVE)
+        {
+            // clear selection pools
+            m_SelectionPools[TEAM_ALLIANCE].Init();
+            m_SelectionPools[TEAM_HORDE].Init();
+
+            // call a function that does the job for us
+            FillPlayersToBG(bg, bracket_id);
+
+            // now everything is set, invite players
+            for (GroupsQueueType::const_iterator citr = m_SelectionPools[TEAM_ALLIANCE].SelectedGroups.begin(); citr != m_SelectionPools[TEAM_ALLIANCE].SelectedGroups.end(); ++citr)
+                InviteGroupToBG((*citr), bg, (*citr)->Team);
+
+            for (GroupsQueueType::const_iterator citr = m_SelectionPools[TEAM_HORDE].SelectedGroups.begin(); citr != m_SelectionPools[TEAM_HORDE].SelectedGroups.end(); ++citr)
+                InviteGroupToBG((*citr), bg, (*citr)->Team);
+
+            if (!bg->HasFreeSlots())
+                bg->RemoveFromBGFreeSlotQueue();
+        }
+    }
+
+    // finished iterating through the bgs with free slots, maybe we need to create a new bg
+
+    Battleground* bg_template = sBattlegroundMgr->GetBattlegroundTemplate(bgTypeId);
+    if (!bg_template)
+    {
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground: Update: bg template not found for %u", bgTypeId);
+        return;
+    }
+
+    PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketById(bg_template->GetMapId(), bracket_id);
+    if (!bracketEntry)
+    {
+        sLog->outError(LOG_FILTER_BATTLEGROUND, "Battleground: Update: bg bracket entry not found for map %u bracket id %u", bg_template->GetMapId(), bracket_id);
+        return;
+    }
+
+    // get the min. players per team, properly for larger arenas as well. (must have full teams for arena matches!)
+    uint32 MinPlayersPerTeam = bg_template->GetMinPlayersPerTeam();
+    uint32 MaxPlayersPerTeam = bg_template->GetMaxPlayersPerTeam();
+
+    if (bg_template->isArena())
+    {
+        MaxPlayersPerTeam = arenaType;
+        MinPlayersPerTeam = sBattlegroundMgr->isArenaTesting() ? 1 : arenaType;
+    }
+    else if (sBattlegroundMgr->isTesting())
+        MinPlayersPerTeam = 1;
+
+    m_SelectionPools[TEAM_ALLIANCE].Init();
+    m_SelectionPools[TEAM_HORDE].Init();
+
+    if (bg_template->isBattleground())
+    {
+        if (CheckPremadeMatch(bracket_id, MinPlayersPerTeam, MaxPlayersPerTeam))
+        {
+            // create new battleground
+            Battleground* bg2 = sBattlegroundMgr->CreateNewBattleground(bgTypeId, bracketEntry, 0, false);
+            if (!bg2)
+            {
+                sLog->outError(LOG_FILTER_BATTLEGROUND, "BattlegroundQueue::Update - Cannot create battleground: %u", bgTypeId);
+                return;
+            }
+            // invite those selection pools
+            for (uint32 i = 0; i < BG_TEAMS_COUNT; i++)
+                for (GroupsQueueType::const_iterator citr = m_SelectionPools[TEAM_ALLIANCE + i].SelectedGroups.begin(); citr != m_SelectionPools[TEAM_ALLIANCE + i].SelectedGroups.end(); ++citr)
+                    InviteGroupToBG((*citr), bg2, (*citr)->Team);
+
+            bg2->StartBattleground();
+            //clear structures
+            m_SelectionPools[TEAM_ALLIANCE].Init();
+            m_SelectionPools[TEAM_HORDE].Init();
+        }
+    }
+
+    // now check if there are in queues enough players to start new game of (normal battleground, or non-rated arena)
+    if (!isRated)
+    {
+        // if there are enough players in pools, start new battleground or non rated arena
+        if (CheckNormalMatch(bg_template, bracket_id, MinPlayersPerTeam, MaxPlayersPerTeam)
+            || (bg_template->isArena() && CheckSkirmishForSameFaction(bracket_id, MinPlayersPerTeam)))
+        {
+            // we successfully created a pool
+            Battleground* bg2 = sBattlegroundMgr->CreateNewBattleground(bgTypeId, bracketEntry, arenaType, false);
+            if (!bg2)
+            {
+                sLog->outError(LOG_FILTER_BATTLEGROUND, "BattlegroundQueue::Update - Cannot create battleground: %u", bgTypeId);
+                return;
+            }
+
+            // invite those selection pools
+            for (uint32 i = 0; i < BG_TEAMS_COUNT; i++)
+                for (GroupsQueueType::const_iterator citr = m_SelectionPools[TEAM_ALLIANCE + i].SelectedGroups.begin(); citr != m_SelectionPools[TEAM_ALLIANCE + i].SelectedGroups.end(); ++citr)
+                    InviteGroupToBG((*citr), bg2, (*citr)->Team);
+            // start bg
+            bg2->StartBattleground();
+        }
+    }
+    else if (bg_template->isArena())
+    {
+        // Check if Queues are empty
+        if (m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].empty() && m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].empty())
+            return;
+
+        // found out the minimum and maximum ratings the newly added team should battle against
+        // arenaRating is the rating of the latest joined team, or 0
+        // 0 is on (automatic update call) and we must set it to team's with longest wait time
+        if (!arenaRating)
+        {
+            for (uint8 queueGroupType = BG_QUEUE_PREMADE_ALLIANCE; queueGroupType < BG_QUEUE_NORMAL_ALLIANCE; queueGroupType++)
+            {                
+                GroupsQueueType::iterator citr = m_QueuedGroups[bracket_id][queueGroupType].begin();
+                while (citr != m_QueuedGroups[bracket_id][queueGroupType].end())
+                {
+                    GroupQueueInfo* front1 = *citr;
+                    if (front1->IsInvitedToBGInstanceGUID)
+                    {
+                        citr++;
+                        continue;
+                    }
+
+                    if (getMSTimeDiff(front1->JoinTime, getMSTime()) > (30 * IN_MILLISECONDS * (front1->ratingRangeIncreaseCounter + 1)))
+                        IncreaseTeamMMrRange(front1);
+
+                    arenaRating = front1->ArenaMatchmakerRating;
+                    //set rating range
+                    uint32 arenaMinRating = (arenaRating <= sBattlegroundMgr->GetMaxRatingDifference()) ? 0 : arenaRating - sBattlegroundMgr->GetMaxRatingDifference();
+                    arenaMinRating = std::max(0, int32(arenaMinRating - front1->ratingRange));
+                    uint32 arenaMaxRating = arenaRating + sBattlegroundMgr->GetMaxRatingDifference();
+                    arenaMaxRating = std::min(int32(arenaMaxRating + front1->ratingRange), 4000);
+                    // if max rating difference is set and the time past since server startup is greater than the rating discard time
+                    // (after what time the ratings aren't taken into account when making teams) then
+                    // the discard time is current_time - time_to_discard, teams that joined after that, will have their ratings taken into account
+                    // else leave the discard time on 0, this way all ratings will be discarded
+                    uint32 discardTime = getMSTime() - sBattlegroundMgr->GetRatingDiscardTimer();
+
+                    // we need to find 2 teams which will play next game
+                    GroupsQueueType::iterator itr_teams[BG_TEAMS_COUNT];
+                    uint8 found = 0;
+                    itr_teams[found++] = citr;
+                    citr++;
+
+                    for (uint8 i = BG_QUEUE_PREMADE_ALLIANCE; i < BG_QUEUE_NORMAL_ALLIANCE && found < 2; i++)
+                    {
+                        // take the group that joined first
+                        GroupsQueueType::iterator itr2 = m_QueuedGroups[bracket_id][i].begin();
+                        for (; itr2 != m_QueuedGroups[bracket_id][i].end(); ++itr2)
+                        {
+                            // if group match conditions, then add it to pool
+                            if (!(*itr2)->IsInvitedToBGInstanceGUID
+                                && (((*itr2)->ArenaMatchmakerRating >= arenaMinRating && (*itr2)->ArenaMatchmakerRating <= arenaMaxRating)
+                                || (*itr2)->JoinTime < discardTime)
+                                && (*itr_teams[0])->ArenaTeamId != (*itr2)->ArenaTeamId)
+                            {
+                                itr_teams[found++] = itr2;
+                                break;
+                            }
+                        }
+                    }
+
+                    //if we have 2 teams, then start new arena and invite players!
+                    if (found == 2)
+                    {
+                        GroupQueueInfo* aTeam = *itr_teams[TEAM_ALLIANCE];
+                        GroupQueueInfo* hTeam = *itr_teams[TEAM_HORDE];
+                        if (citr != m_QueuedGroups[bracket_id][queueGroupType].end() && itr_teams[TEAM_HORDE] == citr)
+                            citr++;
+
+                        Battleground* arena = sBattlegroundMgr->CreateNewBattleground(bgTypeId, bracketEntry, arenaType, true);
+                        if (!arena)
+                        {
+                            sLog->outError(LOG_FILTER_BATTLEGROUND, "BattlegroundQueue::Update couldn't create arena instance for rated arena match!");
+                            return;
+                        }
+
+                        aTeam->OpponentsTeamRating = hTeam->ArenaTeamRating;
+                        hTeam->OpponentsTeamRating = aTeam->ArenaTeamRating;
+                        aTeam->OpponentsMatchmakerRating = hTeam->ArenaMatchmakerRating;
+                        hTeam->OpponentsMatchmakerRating = aTeam->ArenaMatchmakerRating;
+                        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "setting oposite teamrating for team %u to %u", aTeam->ArenaTeamId, aTeam->OpponentsTeamRating);
+                        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "setting oposite teamrating for team %u to %u", hTeam->ArenaTeamId, hTeam->OpponentsTeamRating);
+
+                        // now we must move team if we changed its faction to another faction queue, because then we will spam log by errors in Queue::RemovePlayer
+                        if (aTeam->Team != ALLIANCE)
+                        {
+                            m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].push_front(aTeam);
+                            m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].erase(itr_teams[TEAM_ALLIANCE]);
+                        }
+                        if (hTeam->Team != HORDE)
+                        {
+                            m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].push_front(hTeam);
+                            m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].erase(itr_teams[TEAM_HORDE]);
+                        }
+
+                        arena->SetArenaMatchmakerRating(ALLIANCE, aTeam->ArenaMatchmakerRating);
+                        arena->SetArenaMatchmakerRating(   HORDE, hTeam->ArenaMatchmakerRating);
+                        InviteGroupToBG(aTeam, arena, ALLIANCE);
+                        InviteGroupToBG(hTeam, arena, HORDE);
+
+                        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Starting rated arena match!");
+                        arena->StartBattleground();
+                    }
+                }
+            }
+        }
+    }
+}
+
+/*********************************************************/
+/***            BATTLEGROUND QUEUE EVENTS              ***/
+/*********************************************************/
+
+bool BGQueueInviteEvent::Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+{
+    Player* player = ObjectAccessor::FindPlayer(m_PlayerGuid);
+    // player logged off (we should do nothing, he is correctly removed from queue in another procedure)
+    if (!player)
+        return true;
+
+    Battleground* bg = sBattlegroundMgr->GetBattleground(m_BgInstanceGUID, m_BgTypeId);
+    //if battleground ended and its instance deleted - do nothing
+    if (!bg)
+        return true;
+
+    BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+    uint32 queueSlot = player->GetBattlegroundQueueIndex(bgQueueTypeId);
+    if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES)         // player is in queue or in battleground
+    {
+        // check if player is invited to this bg
+        BattlegroundQueue &bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+        if (bgQueue.IsPlayerInvited(m_PlayerGuid, m_BgInstanceGUID, m_RemoveTime))
+        {
+            WorldPacket data;
+            //we must send remaining time in queue
+            sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, player, queueSlot, STATUS_WAIT_JOIN, INVITE_ACCEPT_WAIT_TIME - INVITATION_REMIND_TIME, player->GetBattlegroundQueueJoinTime(m_BgTypeId), m_ArenaType);
+            player->GetSession()->SendPacket(&data);
+        }
+    }
+    return true;                                            //event will be deleted
+}
+
+void BGQueueInviteEvent::Abort(uint64 /*e_time*/)
+{
+    //do nothing
+}
+
+/*
+    this event has many possibilities when it is executed:
+    1. player is in battleground (he clicked enter on invitation window)
+    2. player left battleground queue and he isn't there any more
+    3. player left battleground queue and he joined it again and IsInvitedToBGInstanceGUID = 0
+    4. player left queue and he joined again and he has been invited to same battleground again -> we should not remove him from queue yet
+    5. player is invited to bg and he didn't choose what to do and timer expired - only in this condition we should call queue::RemovePlayer
+    we must remove player in the 5. case even if battleground object doesn't exist!
+*/
+bool BGQueueRemoveEvent::Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+{
+    Player* player = ObjectAccessor::FindPlayer(m_PlayerGuid);
+    if (!player)
+        // player logged off (we should do nothing, he is correctly removed from queue in another procedure)
+        return true;
+
+    Battleground* bg = sBattlegroundMgr->GetBattleground(m_BgInstanceGUID, m_BgTypeId);
+    //battleground can be deleted already when we are removing queue info
+    //bg pointer can be NULL! so use it carefully!
+
+    uint32 queueSlot = player->GetBattlegroundQueueIndex(m_BgQueueTypeId);
+    if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES)         // player is in queue, or in Battleground
+    {
+        // check if player is in queue for this BG and if we are removing his invite event
+        BattlegroundQueue &bgQueue = sBattlegroundMgr->GetBattlegroundQueue(m_BgQueueTypeId);
+        if (bgQueue.IsPlayerInvited(m_PlayerGuid, m_BgInstanceGUID, m_RemoveTime))
+        {
+            sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Battleground: removing player %u from bg queue for instance %u because of not pressing enter battle in time.", player->GetGUIDLow(), m_BgInstanceGUID);
+
+            player->RemoveBattlegroundQueueId(m_BgQueueTypeId);
+            bgQueue.RemovePlayer(m_PlayerGuid, true);
+            //update queues if battleground isn't ended
+            if (bg && bg->isBattleground() && bg->GetStatus() != STATUS_WAIT_LEAVE)
+                sBattlegroundMgr->ScheduleQueueUpdate(0, 0, m_BgQueueTypeId, m_BgTypeId, bg->GetBracketId());
+
+            WorldPacket data;
+            sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, player, queueSlot, STATUS_NONE, player->GetBattlegroundQueueJoinTime(m_BgTypeId), 0, m_ArenaType);
+            player->GetSession()->SendPacket(&data);
+        }
+    }
+
+    //event will be deleted
+    return true;
+}
+
+void BGQueueRemoveEvent::Abort(uint64 /*e_time*/)
+{
+    //do nothing
+}
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index ce24b33..a0107bf 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -22489,6 +22489,7 @@ uint32 Player::GetMaxPersonalArenaRatingRequirement(uint32 minarenaslot) const
     uint32 max_personal_rating = 0;
     for (uint8 i = minarenaslot; i < MAX_ARENA_SLOT; ++i)
     {
+        if(i == 2 && sWorld->getBoolConfig(CONFIG_ARENA_1V1_VENDOR_RATING) == false) continue;
         if (ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(GetArenaTeamId(i)))
         {
             uint32 p_rating = GetArenaPersonalRating(i);
diff --git a/src/server/game/Entities/Player/Player.cpp.orig b/src/server/game/Entities/Player/Player.cpp.orig
new file mode 100644
index 0000000..ce24b33
--- /dev/null
+++ b/src/server/game/Entities/Player/Player.cpp.orig
@@ -0,0 +1,28083 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Player.h"
+#include "AccountMgr.h"
+#include "AchievementMgr.h"
+#include "ArcheologyMgr.h"
+#include "ArenaTeam.h"
+#include "ArenaTeamMgr.h"
+#include "Battlefield.h"
+#include "BattlefieldMgr.h"
+#include "BattlefieldWG.h"
+#include "BattlegroundAV.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "CellImpl.h"
+#include "Channel.h"
+#include "ChannelMgr.h"
+#include "CharacterDatabaseCleaner.h"
+#include "Chat.h"
+#include <cmath>
+#include "Common.h"
+#include "ConditionMgr.h"
+#include "CreatureAI.h"
+#include "DatabaseEnv.h"
+#include "DB2Stores.h"
+#include "DisableMgr.h"
+#include "Formulas.h"
+#include "GameEventMgr.h"
+#include "GossipDef.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "GroupMgr.h"
+#include "Guild.h"
+#include "GuildMgr.h"
+#include "InstanceSaveMgr.h"
+#include "InstanceScript.h"
+#include "Language.h"
+#include "LFGMgr.h"
+#include "Log.h"
+#include "MapInstanced.h"
+#include "MapManager.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Opcodes.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
+#include "ReputationMgr.h"
+#include "Pet.h"
+#include "QuestDef.h"
+#include "revision.h"
+#include "SkillDiscovery.h"
+#include "SocialMgr.h"
+#include "SpellAuraEffects.h"
+#include "SpellAuras.h"
+#include "Spell.h"
+#include "SpellMgr.h"
+#include "Transport.h"
+#include "UpdateData.h"
+#include "UpdateMask.h"
+#include "Util.h"
+#include "Vehicle.h"
+#include "Weather.h"
+#include "WeatherMgr.h"
+#include "World.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+#include "MovementStructures.h"
+#include "MoveSplineInit.h"
+#include "InfoMgr.h"
+#include "AnticheatMgr.h"
+
+#define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
+
+enum CharacterFlags
+{
+    CHARACTER_FLAG_NONE                 = 0x00000000,
+    CHARACTER_FLAG_UNK1                 = 0x00000001,
+    CHARACTER_FLAG_UNK2                 = 0x00000002,
+    CHARACTER_LOCKED_FOR_TRANSFER       = 0x00000004,
+    CHARACTER_FLAG_UNK4                 = 0x00000008,
+    CHARACTER_FLAG_UNK5                 = 0x00000010,
+    CHARACTER_FLAG_UNK6                 = 0x00000020,
+    CHARACTER_FLAG_UNK7                 = 0x00000040,
+    CHARACTER_FLAG_UNK8                 = 0x00000080,
+    CHARACTER_FLAG_UNK9                 = 0x00000100,
+    CHARACTER_FLAG_UNK10                = 0x00000200,
+    CHARACTER_FLAG_HIDE_HELM            = 0x00000400,
+    CHARACTER_FLAG_HIDE_CLOAK           = 0x00000800,
+    CHARACTER_FLAG_UNK13                = 0x00001000,
+    CHARACTER_FLAG_GHOST                = 0x00002000,
+    CHARACTER_FLAG_RENAME               = 0x00004000,
+    CHARACTER_FLAG_UNK16                = 0x00008000,
+    CHARACTER_FLAG_UNK17                = 0x00010000,
+    CHARACTER_FLAG_UNK18                = 0x00020000,
+    CHARACTER_FLAG_UNK19                = 0x00040000,
+    CHARACTER_FLAG_UNK20                = 0x00080000,
+    CHARACTER_FLAG_UNK21                = 0x00100000,
+    CHARACTER_FLAG_UNK22                = 0x00200000,
+    CHARACTER_FLAG_UNK23                = 0x00400000,
+    CHARACTER_FLAG_UNK24                = 0x00800000,
+    CHARACTER_FLAG_LOCKED_BY_BILLING    = 0x01000000,
+    CHARACTER_FLAG_DECLINED             = 0x02000000,
+    CHARACTER_FLAG_UNK27                = 0x04000000,
+    CHARACTER_FLAG_UNK28                = 0x08000000,
+    CHARACTER_FLAG_UNK29                = 0x10000000,
+    CHARACTER_FLAG_UNK30                = 0x20000000,
+    CHARACTER_FLAG_UNK31                = 0x40000000,
+    CHARACTER_FLAG_UNK32                = 0x80000000
+};
+
+enum CharacterCustomizeFlags
+{
+    CHAR_CUSTOMIZE_FLAG_NONE            = 0x00000000,
+    CHAR_CUSTOMIZE_FLAG_CUSTOMIZE       = 0x00000001,       // name, gender, etc...
+    CHAR_CUSTOMIZE_FLAG_FACTION         = 0x00010000,       // name, gender, faction, etc...
+    CHAR_CUSTOMIZE_FLAG_RACE            = 0x00100000        // name, gender, race, etc...
+};
+
+// corpse reclaim times
+#define DEATH_EXPIRE_STEP (5*MINUTE)
+#define MAX_DEATH_COUNT 3
+
+static uint32 copseReclaimDelay[MAX_DEATH_COUNT] = { 30, 60, 120 };
+
+// == PlayerTaxi ================================================
+
+PlayerTaxi::PlayerTaxi()
+{
+    memset(m_taximask, 0, sizeof(m_taximask));
+}
+
+void PlayerTaxi::InitTaxiNodesForLevel(uint32 race, uint32 chrClass, uint8 level)
+{
+    // class specific initial known nodes
+    switch (chrClass)
+    {
+        case CLASS_DEATH_KNIGHT:
+        {
+            for (uint8 i = 0; i < TaxiMaskSize; ++i)
+                m_taximask[i] |= sOldContinentsNodesMask[i];
+            break;
+        }
+    }
+
+    // race specific initial known nodes: capital and taxi hub masks
+    switch (race)
+    {
+        case RACE_HUMAN:    SetTaximaskNode(2);  break;     // Human
+        case RACE_ORC:      SetTaximaskNode(23); break;     // Orc
+        case RACE_DWARF:    SetTaximaskNode(6);  break;     // Dwarf
+        case RACE_NIGHTELF: SetTaximaskNode(26);
+                            SetTaximaskNode(27); break;     // Night Elf
+        case RACE_UNDEAD_PLAYER: SetTaximaskNode(11); break;// Undead
+        case RACE_TAUREN:   SetTaximaskNode(22); break;     // Tauren
+        case RACE_GNOME:    SetTaximaskNode(6);  break;     // Gnome
+        case RACE_TROLL:    SetTaximaskNode(23); break;     // Troll
+        case RACE_BLOODELF: SetTaximaskNode(82); break;     // Blood Elf
+        case RACE_DRAENEI:  SetTaximaskNode(94); break;     // Draenei
+    }
+
+    // new continent starting masks (It will be accessible only at new map)
+    switch (Player::TeamForRace(race))
+    {
+        case ALLIANCE: SetTaximaskNode(100); break;
+        case HORDE:    SetTaximaskNode(99);  break;
+    }
+    // level dependent taxi hubs
+    if (level >= 68)
+        SetTaximaskNode(213);                               //Shattered Sun Staging Area
+}
+
+void PlayerTaxi::LoadTaxiMask(std::string const &data)
+{
+    Tokenizer tokens(data, ' ');
+
+    uint8 index = 0;
+    for (Tokenizer::const_iterator iter = tokens.begin(); index < TaxiMaskSize && iter != tokens.end(); ++iter, ++index)
+    {
+        // load and set bits only for existing taxi nodes
+        m_taximask[index] = sTaxiNodesMask[index] & uint32(atol(*iter));
+    }
+}
+
+void PlayerTaxi::AppendTaximaskTo(ByteBuffer& data, bool all)
+{
+    data << uint32(TaxiMaskSize);
+    if (all)
+    {
+        for (uint8 i = 0; i < TaxiMaskSize; ++i)
+            data << uint8(sTaxiNodesMask[i]);              // all existed nodes
+    }
+    else
+    {
+        for (uint8 i = 0; i < TaxiMaskSize; ++i)
+            data << uint8(m_taximask[i]);                  // known nodes
+    }
+}
+
+bool PlayerTaxi::LoadTaxiDestinationsFromString(const std::string& values, uint32 team)
+{
+    ClearTaxiDestinations();
+
+    Tokenizer Tokenizer(values, ' ');
+
+    for (Tokenizer::const_iterator iter = Tokenizer.begin(); iter != Tokenizer.end(); ++iter)
+    {
+        uint32 node = uint32(atol(*iter));
+        AddTaxiDestination(node);
+    }
+
+    if (m_TaxiDestinations.empty())
+        return true;
+
+    // Check integrity
+    if (m_TaxiDestinations.size() < 2)
+        return false;
+
+    for (size_t i = 1; i < m_TaxiDestinations.size(); ++i)
+    {
+        uint32 cost;
+        uint32 path;
+        sObjectMgr->GetTaxiPath(m_TaxiDestinations[i-1], m_TaxiDestinations[i], path, cost);
+        if (!path)
+            return false;
+    }
+
+    // can't load taxi path without mount set (quest taxi path?)
+    if (!sObjectMgr->GetTaxiMountDisplayId(GetTaxiSource(), team, true))
+        return false;
+
+    return true;
+}
+
+std::string PlayerTaxi::SaveTaxiDestinationsToString()
+{
+    if (m_TaxiDestinations.empty())
+        return "";
+
+    std::ostringstream ss;
+
+    for (size_t i=0; i < m_TaxiDestinations.size(); ++i)
+        ss << m_TaxiDestinations[i] << ' ';
+
+    return ss.str();
+}
+
+uint32 PlayerTaxi::GetCurrentTaxiPath() const
+{
+    if (m_TaxiDestinations.size() < 2)
+        return 0;
+
+    uint32 path;
+    uint32 cost;
+
+    sObjectMgr->GetTaxiPath(m_TaxiDestinations[0], m_TaxiDestinations[1], path, cost);
+
+    return path;
+}
+
+std::ostringstream& operator<< (std::ostringstream& ss, PlayerTaxi const& taxi)
+{
+    for (uint8 i = 0; i < TaxiMaskSize; ++i)
+        ss << uint32(taxi.m_taximask[i]) << ' ';
+    return ss;
+}
+
+//== TradeData =================================================
+
+TradeData* TradeData::GetTraderData() const
+{
+    return m_trader->GetTradeData();
+}
+
+Item* TradeData::GetItem(TradeSlots slot) const
+{
+    return m_items[slot] ? m_player->GetItemByGuid(m_items[slot]) : NULL;
+}
+
+bool TradeData::HasItem(uint64 itemGuid) const
+{
+    for (uint8 i = 0; i < TRADE_SLOT_COUNT; ++i)
+        if (m_items[i] == itemGuid)
+            return true;
+
+    return false;
+}
+
+TradeSlots TradeData::GetTradeSlotForItem(uint64 itemGuid) const
+{
+    for (uint8 i = 0; i < TRADE_SLOT_COUNT; ++i)
+        if (m_items[i] == itemGuid)
+            return TradeSlots(i);
+
+    return TRADE_SLOT_INVALID;
+}
+
+Item* TradeData::GetSpellCastItem() const
+{
+    return m_spellCastItem ? m_player->GetItemByGuid(m_spellCastItem) : NULL;
+}
+
+void TradeData::SetItem(TradeSlots slot, Item* item)
+{
+    uint64 itemGuid = item ? item->GetGUID() : 0;
+
+    if (m_items[slot] == itemGuid)
+        return;
+
+    m_items[slot] = itemGuid;
+
+    SetAccepted(false);
+    GetTraderData()->SetAccepted(false);
+
+    Update();
+
+    // need remove possible trader spell applied to changed item
+    if (slot == TRADE_SLOT_NONTRADED)
+        GetTraderData()->SetSpell(0);
+
+    // need remove possible player spell applied (possible move reagent)
+    SetSpell(0);
+}
+
+void TradeData::SetSpell(uint32 spell_id, Item* castItem /*= NULL*/)
+{
+    uint64 itemGuid = castItem ? castItem->GetGUID() : 0;
+
+    if (m_spell == spell_id && m_spellCastItem == itemGuid)
+        return;
+
+    m_spell = spell_id;
+    m_spellCastItem = itemGuid;
+
+    SetAccepted(false);
+    GetTraderData()->SetAccepted(false);
+
+    Update(true);                                           // send spell info to item owner
+    Update(false);                                          // send spell info to caster self
+}
+
+void TradeData::SetMoney(uint64 money)
+{
+    if (m_money == money)
+        return;
+
+    m_money = money;
+
+    SetAccepted(false);
+    GetTraderData()->SetAccepted(false);
+
+    Update(true);
+}
+
+void TradeData::Update(bool forTarget /*= true*/)
+{
+    if (forTarget)
+        m_trader->GetSession()->SendUpdateTrade(true);      // player state for trader
+    else
+        m_player->GetSession()->SendUpdateTrade(false);     // player state for player
+}
+
+void TradeData::SetAccepted(bool state, bool crosssend /*= false*/)
+{
+    m_accepted = state;
+
+    if (!state)
+    {
+        if (crosssend)
+            m_trader->GetSession()->SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
+        else
+            m_player->GetSession()->SendTradeStatus(TRADE_STATUS_BACK_TO_TRADE);
+    }
+}
+
+// == KillRewarder ====================================================
+// KillRewarder incapsulates logic of rewarding player upon kill with:
+// * XP;
+// * honor;
+// * reputation;
+// * kill credit (for quest objectives).
+// Rewarding is initiated in two cases: when player kills unit in Unit::Kill()
+// and on battlegrounds in Battleground::RewardXPAtKill().
+//
+// Rewarding algorithm is:
+// 1. Initialize internal variables to default values.
+// 2. In case when player is in group, initialize variables necessary for group calculations:
+// 2.1. _count - number of alive group members within reward distance;
+// 2.2. _sumLevel - sum of levels of alive group members within reward distance;
+// 2.3. _maxLevel - maximum level of alive group member within reward distance;
+// 2.4. _maxNotGrayMember - maximum level of alive group member within reward distance,
+//      for whom victim is not gray;
+// 2.5. _isFullXP - flag identifying that for all group members victim is not gray,
+//      so 100% XP will be rewarded (50% otherwise).
+// 3. Reward killer (and group, if necessary).
+// 3.1. If killer is in group, reward group.
+// 3.1.1. Initialize initial XP amount based on maximum level of group member,
+//        for whom victim is not gray.
+// 3.1.2. Alter group rate if group is in raid (not for battlegrounds).
+// 3.1.3. Reward each group member (even dead) within reward distance (see 4. for more details).
+// 3.2. Reward single killer (not group case).
+// 3.2.1. Initialize initial XP amount based on killer's level.
+// 3.2.2. Reward killer (see 4. for more details).
+// 4. Reward player.
+// 4.1. Give honor (player must be alive and not on BG).
+// 4.2. Give XP.
+// 4.2.1. If player is in group, adjust XP:
+//        * set to 0 if player's level is more than maximum level of not gray member;
+//        * cut XP in half if _isFullXP is false.
+// 4.2.2. Apply auras modifying rewarded XP.
+// 4.2.3. Give XP to player.
+// 4.2.4. If player has pet, reward pet with XP (100% for single player, 50% for group case).
+// 4.3. Give reputation (player must not be on BG).
+// 4.4. Give kill credit (player must not be in group, or he must be alive or without corpse).
+// 5. Credit instance encounter.
+// 6. Update guild achievements.
+KillRewarder::KillRewarder(Player* killer, Unit* victim, bool isBattleGround) :
+    // 1. Initialize internal variables to default values.
+    _killer(killer), _victim(victim), _group(killer->GetGroup()),
+    _groupRate(1.0f), _maxNotGrayMember(NULL), _count(0), _sumLevel(0), _xp(0),
+    _isFullXP(false), _maxLevel(0), _isBattleGround(isBattleGround), _isPvP(false)
+{
+    // mark the credit as pvp if victim is player
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+        _isPvP = true;
+    // or if its owned by player and its not a vehicle
+    else if (IS_PLAYER_GUID(victim->GetCharmerOrOwnerGUID()))
+        _isPvP = !victim->IsVehicle();
+
+    _InitGroupData();
+    _isHonnor = false;
+}
+
+inline void KillRewarder::_InitGroupData()
+{
+    if (_group)
+    {
+        // 2. In case when player is in group, initialize variables necessary for group calculations:
+        for (GroupReference* itr = _group->GetFirstMember(); itr != NULL; itr = itr->next())
+            if (Player* member = itr->getSource())
+                if (member->isAlive() && member->IsAtGroupRewardDistance(_victim))
+                {
+                    const uint8 lvl = member->getLevel();
+                    // 2.1. _count - number of alive group members within reward distance;
+                    ++_count;
+                    // 2.2. _sumLevel - sum of levels of alive group members within reward distance;
+                    _sumLevel += lvl;
+                    // 2.3. _maxLevel - maximum level of alive group member within reward distance;
+                    if (_maxLevel < lvl)
+                        _maxLevel = lvl;
+                    // 2.4. _maxNotGrayMember - maximum level of alive group member within reward distance,
+                    //      for whom victim is not gray;
+                    uint32 grayLevel = Trinity::XP::GetGrayLevel(lvl);
+                    if (_victim->getLevel() > grayLevel && (!_maxNotGrayMember || _maxNotGrayMember->getLevel() < lvl))
+                        _maxNotGrayMember = member;
+                }
+        // 2.5. _isFullXP - flag identifying that for all group members victim is not gray,
+        //      so 100% XP will be rewarded (50% otherwise).
+        _isFullXP = _maxNotGrayMember && (_maxLevel == _maxNotGrayMember->getLevel());
+    }
+    else
+        _count = 1;
+}
+
+inline void KillRewarder::_InitXP(Player* player)
+{
+    // Get initial value of XP for kill.
+    // XP is given:
+    // * on battlegrounds;
+    // * otherwise, not in PvP;
+    // * not if killer is on vehicle.
+    if (_isBattleGround || (!_isPvP && !_killer->GetVehicle()))
+        _xp = Trinity::XP::Gain(player, _victim);
+}
+
+inline void KillRewarder::_RewardHonor(Player* player)
+{
+    // Rewarded player must be alive.
+    if (player->isAlive())
+        _isHonnor = player->RewardHonor(_victim, _count, -1, true);
+}
+
+inline void KillRewarder::_RewardGuildXP(Player* player)
+{
+    Guild *guild = player->GetGuild();
+    Group* group = player->GetGroup();
+    if (!guild || ! group)
+        return;
+
+    if (!group->IsGuildGroupFor(player))
+        return;
+
+    float base = float(_xp) * sWorld->getRate(RATE_XP_BASEKILL_GUILD_MODIFIER);
+
+    if (player->GetMap()->IsHeroic())
+    {
+        if (player->GetMap()->IsNonRaidDungeon())
+            base *= sWorld->getRate(RATE_XP_HEROIC_DUNGEON_GUILD_MODIFIER);
+        else if (player->GetMap()->IsRaid())
+            base *= sWorld->getRate(RATE_XP_HEROIC_RAID_GUILD_MODIFIER);
+    }
+
+    base *= group->GetGuildXpRateForPlayer(player);
+
+    guild->GiveXP(uint32(base), player);
+
+    uint32 guildRep = std::max(uint32(1), uint32(base/450));
+    guild->GiveReputation(guildRep, player);
+}
+
+inline void KillRewarder::_RewardXP(Player* player, float rate)
+{
+    uint32 xp(_xp);
+    if (_group)
+    {
+        // 4.2.1. If player is in group, adjust XP:
+        //        * set to 0 if player's level is more than maximum level of not gray member;
+        //        * cut XP in half if _isFullXP is false.
+        if (_maxNotGrayMember && player->isAlive() &&
+            _maxNotGrayMember->getLevel() >= player->getLevel())
+            xp = _isFullXP ?
+                uint32(xp * rate) :             // Reward FULL XP if all group members are not gray.
+                uint32(xp * rate / 2) + 1;      // Reward only HALF of XP if some of group members are gray.
+        else
+            xp = 0;
+    }
+    if (xp)
+    {
+        // 4.2.2. Apply auras modifying rewarded XP (SPELL_AURA_MOD_XP_PCT).
+        Unit::AuraEffectList const& auras = player->GetAuraEffectsByType(SPELL_AURA_MOD_XP_PCT);
+        for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            AddPct(xp, (*i)->GetAmount());
+
+        // 4.2.3. Calculate expansion penalty, Not used right now due to missing Cata content.
+        /*if (_victim->GetTypeId() == TYPEID_UNIT && player->getLevel() >= GetMaxLevelForExpansion(_victim->ToCreature()->GetCreatureTemplate()->expansion))
+            xp = CalculatePct(xp, 10); // Players get only 10% xp for killing creatures of lower expansion levels than himself*/
+
+        // 4.2.4. Give XP to player.
+        player->GiveXP(xp, _victim, _groupRate);
+        if (Pet* pet = player->GetPet())
+            // 4.2.5. If player has pet, reward pet with XP (100% for single player, 50% for group case).
+            pet->GivePetXP(_group ? xp / 2 : xp);
+    }
+}
+
+inline void KillRewarder::_RewardOnKill(Player* player, float rate)
+{
+    // 4.3. Give reputation and currency (player must not be on BG).
+    // Even dead players and corpses are rewarded.
+    player->RewardOnKill(_victim, rate);
+}
+
+inline void KillRewarder::_RewardCurrency(Player* player)
+{
+    // 4.3.2 Give currency
+    // Even dead players and corpses are rewarded.
+    player->RewardCurrency(_victim);
+}
+inline void KillRewarder::_RewardKillCredit(Player* player)
+{
+    // 4.4. Give kill credit (player must not be in group, or he must be alive or without corpse).
+    if (!_group || player->isAlive() || !player->GetCorpse())
+        if (_victim->GetTypeId() == TYPEID_UNIT)
+            player->KilledMonster(_victim->ToCreature()->GetCreatureTemplate(), _victim->GetGUID());
+}
+
+void KillRewarder::_RewardPlayer(Player* player, bool isDungeon)
+{
+    // 4. Reward player.
+    if (!_isBattleGround)
+    {
+        // 4.1. Give honor (player must be alive and not on BG).
+        _RewardHonor(player);
+        // 4.1.1 Send player killcredit for quests with PlayerSlain
+        if (_victim->GetTypeId() == TYPEID_PLAYER)
+            player->KilledPlayerCredit();
+    }
+    // Give XP only in PvE or in battlegrounds.
+    // Give reputation and kill credit only in PvE.
+    if (!_isPvP || _isBattleGround)
+    {
+        const float rate = _group ?
+            _groupRate * float(player->getLevel()) / _sumLevel : // Group rate depends on summary level.
+            1.0f;                                                // Personal rate is 100%.
+        if (_xp)
+        {
+            // 4.2. Give XP.
+            _RewardXP(player, rate);
+            // Give Guild XP.
+            if (player->GetGuild())
+                if (_victim->ToCreature() && _victim->ToCreature()->IsDungeonBoss())
+                    _RewardGuildXP(player);
+        }
+        if (!_isBattleGround)
+        {
+            // If killer is in dungeon then all members receive full reputation at kill.
+            _RewardOnKill(player, isDungeon ? 1.0f : rate);
+            _RewardKillCredit(player);
+        }
+    }
+}
+
+void KillRewarder::_RewardGroup()
+{
+    if (_maxLevel)
+    {
+        if (_maxNotGrayMember)
+            // 3.1.1. Initialize initial XP amount based on maximum level of group member,
+            //        for whom victim is not gray.
+            _InitXP(_maxNotGrayMember);
+        // To avoid unnecessary calculations and calls,
+        // proceed only if XP is not ZERO or player is not on battleground
+        // (battleground rewards only XP, that's why).
+        if (!_isBattleGround || _xp)
+        {
+            const bool isDungeon = !_isPvP && sMapStore.LookupEntry(_killer->GetMapId())->IsDungeon();
+            if (!_isBattleGround)
+            {
+                // 3.1.2. Alter group rate if group is in raid (not for battlegrounds).
+                const bool isRaid = !_isPvP && sMapStore.LookupEntry(_killer->GetMapId())->IsRaid() && _group->isRaidGroup();
+                _groupRate = Trinity::XP::xp_in_group_rate(_count, isRaid);
+            }
+
+            // 3.1.3. Reward each group member (even dead or corpse) within reward distance.
+            // 3.1.4. Update guild achievements.
+
+            std::vector<uint32> guildList;
+            for (GroupReference* itr = _group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                if (Player* member = itr->getSource())
+                {
+                    if (member->IsAtGroupRewardDistance(_victim))
+                    {
+                        _RewardPlayer(member, isDungeon);
+                        member->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, 1, 0, 0, _victim);
+
+                        bool guildAlreadyUpdate = false;
+                        for (std::vector<uint32>::const_iterator guildItr = guildList.begin(); guildItr != guildList.end(); guildItr++)
+                            if (*guildItr == member->GetGuildId())
+                                guildAlreadyUpdate = true;
+                        
+                        if (!guildAlreadyUpdate)
+                        {
+                            if (Creature* victim = _victim->ToCreature())
+                                if (Guild* guild = member->GetGuild())
+                                {
+                                    guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE, victim->GetEntry(), 1, 0, victim, member);
+                                    guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE_TYPE_GUILD, 0, 0, 0, victim, member);
+                                    guildList.push_back(member->GetGuildId());
+                                }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+void KillRewarder::Reward()
+{
+    // 3. Reward killer (and group, if necessary).
+    if (_group)
+        // 3.1. If killer is in group, reward group.
+        _RewardGroup();
+    else
+    {
+        // 3.2. Reward single killer (not group case).
+        // 3.2.1. Initialize initial XP amount based on killer's level.
+        _InitXP(_killer);
+        // To avoid unnecessary calculations and calls,
+        // proceed only if XP is not ZERO or player is not on battleground
+        // (battleground rewards only XP, that's why).
+        if (!_isBattleGround || _xp)
+            // 3.2.2. Reward killer.
+            _RewardPlayer(_killer, false);
+    }
+    
+    // 5. Credit instance encounter.
+    if (Creature* victim = _victim->ToCreature())
+    {
+        if (victim->IsDungeonBoss())
+            if (InstanceScript* instance = _victim->GetInstanceScript())
+                instance->UpdateEncounterState(ENCOUNTER_CREDIT_KILL_CREATURE, _victim->GetEntry(), _victim);
+    }
+
+    // 6. Update guild achievements.
+    if (_isPvP)
+    {
+        if (Group* pGroup = _killer->GetGroup())
+        {
+            if (_isHonnor)
+            {
+                pGroup->UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_RACE, 1, 0, 0, _victim, _victim);
+                pGroup->UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILLS_GUILD, 1, 0, 0, _victim, _victim);
+            }
+            pGroup->UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, 1, 0, 0, _victim, _victim);
+        }
+        else
+        {
+            if (_isHonnor)
+            {
+                _killer->UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_RACE, 1, 0, 0, _victim);
+                _killer->UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILLS_GUILD, 1, 0, 0, _victim);
+            }
+            _killer->UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, 1, 0, 0, _victim);
+        }
+    }
+    else
+    {
+        if (Group* pGroup = _killer->GetGroup())
+        {
+            pGroup->UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE, _victim->GetEntry(), 1, 0, _victim, _victim);
+            pGroup->UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE_TYPE_GUILD, _victim->GetEntry(), 1, 0, _victim, _victim);
+        }
+        else
+        {
+            _killer->UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE, _victim->GetEntry(), 1, 0, _victim);
+            _killer->UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE_TYPE_GUILD, _victim->GetEntry(), 1, 0, _victim);
+        }
+    }
+
+}
+
+// == Player ====================================================
+
+// we can disable this warning for this since it only
+// causes undefined behavior when passed to the base class constructor
+#ifdef _MSC_VER
+#pragma warning(disable:4355)
+#endif
+Player::Player(WorldSession* session): Unit(true), phaseMgr(this)
+{
+#ifdef _MSC_VER
+#pragma warning(default:4355)
+#endif
+
+    m_speakTime = 0;
+    m_speakCount = 0;
+
+    m_objectType |= TYPEMASK_PLAYER;
+    m_objectTypeId = TYPEID_PLAYER;
+
+    m_valuesCount = PLAYER_END;
+
+    m_session = session;
+
+    m_divider = 0;
+
+    m_ExtraFlags = 0;
+
+    m_spellModTakingSpell = NULL;
+
+    m_lastCombatspell = 0;
+    //m_pad = 0;
+
+    // players always accept
+    if (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
+        SetAcceptWhispers(true);
+
+    m_curSelection = 0;
+    m_lootGuid = 0;
+
+    m_comboTarget = 0;
+    m_comboPoints = 0;
+
+    _markedReady = false;
+
+    m_regenTimer = 0;
+    m_regenTimerCount = 0;
+    m_holyPowerRegenTimerCount = 0;
+    m_focusRegenTimerCount = 0;
+    m_weaponChangeTimer = 0;
+
+    m_zoneUpdateId = 0;
+    m_zoneUpdateTimer = 0;
+
+    m_areaUpdateId = 0;
+
+    m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);
+
+    _resurrectionData = NULL;
+
+    memset(m_items, 0, sizeof(Item*)*PLAYER_SLOTS_COUNT);
+
+    m_social = NULL;
+
+    // group is initialized in the reference constructor
+    SetGroupInvite(NULL);
+    m_groupUpdateMask = 0;
+    m_auraRaidUpdateMask = 0;
+    m_bPassOnGroupLoot = false;
+
+    duel = NULL;
+
+    m_GuildIdInvited = 0;
+    m_ArenaTeamIdInvited = 0;
+
+    m_atLoginFlags = AT_LOGIN_NONE;
+
+    mSemaphoreTeleport_Near = false;
+    mSemaphoreTeleport_Far = false;
+
+    m_DelayedOperations = 0;
+    m_bCanDelayTeleport = false;
+    m_bHasDelayedTeleport = false;
+    m_teleport_options = 0;
+
+    m_trade = NULL;
+
+    m_cinematic = 0;
+
+    PlayerTalkClass = new PlayerMenu(GetSession());
+    m_currentBuybackSlot = BUYBACK_SLOT_START;
+
+    m_DailyQuestChanged = false;
+    m_lastDailyQuestTime = 0;
+
+    m_MirrorTimerFlags = UNDERWATER_NONE;
+    m_MirrorTimerFlagsLast = UNDERWATER_NONE;
+    m_isInWater = false;
+    m_drunkTimer = 0;
+    m_restTime = 0;
+    m_deathTimer = 0;
+    m_deathExpireTime = 0;
+
+    m_swingErrorMsg = 0;
+
+    for (uint8 j = 0; j < PLAYER_MAX_BATTLEGROUND_QUEUES; ++j)
+    {
+        m_bgBattlegroundQueueID[j].bgQueueTypeId = BATTLEGROUND_QUEUE_NONE;
+        m_bgBattlegroundQueueID[j].invitedToInstance = 0;
+    }
+
+    m_logintime = time(NULL);
+    m_Last_tick = m_logintime;
+    m_WeaponProficiency = 0;
+    m_ArmorProficiency = 0;
+    m_canParry = false;
+    m_canBlock = false;
+    m_canDualWield = false;
+    m_canTitanGrip = false;
+
+    m_temporaryUnsummonedPetNumber = 0;
+    //cache for UNIT_CREATED_BY_SPELL to allow
+    //returning reagents for temporarily removed pets
+    //when dying/logging out
+    m_oldpetspell = 0;
+    m_lastpetnumber = 0;
+
+    ////////////////////Rest System/////////////////////
+    time_inn_enter=0;
+    inn_pos_mapid=0;
+    inn_pos_x=0;
+    inn_pos_y=0;
+    inn_pos_z=0;
+    m_rest_bonus=0;
+    rest_type=REST_TYPE_NO;
+    ////////////////////Rest System/////////////////////
+
+    m_mailsLoaded = false;
+    m_mailsUpdated = false;
+    unReadMails = 0;
+    m_nextMailDelivereTime = 0;
+
+    m_itemUpdateQueueBlocked = false;
+
+    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
+        m_forced_speed_changes[i] = 0;
+
+    for (uint8 i = 0; i < ACK_TYPE_MAX; ++i)
+        m_movement_ack[i] = 0;
+
+
+    /////////////////// Instance System /////////////////////
+
+    m_HomebindTimer = 0;
+    m_InstanceValid = true;
+    m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
+    m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
+
+    m_lastPotionId = 0;
+    _talentMgr = new PlayerTalentInfo();
+
+    for (uint8 i = 0; i < BASEMOD_END; ++i)
+    {
+        m_auraBaseMod[i][FLAT_MOD] = 0.0f;
+        m_auraBaseMod[i][PCT_MOD] = 1.0f;
+    }
+
+    for (uint8 i = 0; i < MAX_COMBAT_RATING; i++)
+        m_baseRatingValue[i] = 0;
+
+    _currentPetSlot = PET_SLOT_DEFAULT;
+
+    m_baseSpellPower = 0;
+    m_baseManaRegen = 0;
+    m_baseHealthRegen = 0;
+    m_spellPenetrationItemMod = 0;
+
+    // Honor System
+    m_lastHonorUpdateTime = time(NULL);
+
+	// Currency Week Cap
+	m_maxWeekRating[CP_SOURCE_ARENA] = 0;
+	m_maxWeekRating[CP_SOURCE_RATED_BG] = 0;
+	m_conquestPointsWeekCap[CP_SOURCE_ARENA] = 1350;
+	m_conquestPointsWeekCap[CP_SOURCE_RATED_BG] = 1650;
+
+    m_IsBGRandomWinner = false;
+
+    // Player summoning
+    m_summon_expire = 0;
+    m_summon_mapid = 0;
+    m_summon_x = 0.0f;
+    m_summon_y = 0.0f;
+    m_summon_z = 0.0f;
+
+    m_mover = this;
+    m_movedPlayer = this;
+    m_seer = this;
+
+    m_contestedPvPTimer = 0;
+
+    m_declinedname = NULL;
+
+    m_isActive = true;
+
+    m_runes = NULL;
+
+    m_lastFallTime = 0;
+    m_lastFallZ = 0;
+
+    m_grantableLevels = 0;
+
+    m_ControlledByPlayer = true;
+
+    sWorld->IncreasePlayerCount();
+
+    m_ChampioningFaction = 0;
+
+    for (uint8 i = 0; i < MAX_POWERS_PER_CLASS; ++i)
+        m_powerFraction[i] = 0;
+
+    isDebugAreaTriggers = false;
+
+    m_WeeklyQuestChanged = false;
+
+    m_SeasonalQuestChanged = false;
+
+    SetPendingBind(0, 0);
+
+    _activeCheats = CHEAT_NONE;
+    _maxPersonalArenaRate = 0;
+    _ConquestCurrencyTotalWeekCap = 0;
+
+    memset(_voidStorageItems, 0, VOID_STORAGE_MAX_SLOT * sizeof(VoidStorageItem*));
+    memset(_CUFProfiles, 0, MAX_CUF_PROFILES * sizeof(CUFProfile*));
+
+    m_achievementMgr = new AchievementMgr<Player>(this);
+    m_reputationMgr = new ReputationMgr(this);
+    m_archeologyMgr = new ArcheologyMgr(this);
+
+    m_IsWatchingCinematic = false;
+
+    _groupOutOfRangeUpdateTime = 1000;
+}
+
+Player::~Player()
+{
+    // it must be unloaded already in PlayerLogout and accessed only for loggined player
+    //m_social = NULL;
+
+    // Note: buy back item already deleted from DB when player was saved
+    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; ++i)
+        delete m_items[i];
+
+    for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
+        delete itr->second;
+
+    delete _talentMgr;
+
+    //all mailed items should be deleted, also all mail should be deallocated
+    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
+        delete *itr;
+
+    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
+        delete iter->second;                                //if item is duplicated... then server may crash ... but that item should be deallocated
+
+    delete PlayerTalkClass;
+
+    for (size_t x = 0; x < ItemSetEff.size(); x++)
+        delete ItemSetEff[x];
+
+    delete m_declinedname;
+    delete m_runes;
+    delete m_achievementMgr;
+    delete m_reputationMgr;
+    delete m_archeologyMgr;
+
+    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
+        delete _voidStorageItems[i];
+
+    for (uint8 i = 0; i < MAX_CUF_PROFILES; ++i)
+        delete _CUFProfiles[i];
+
+    ClearResurrectRequestData();
+
+    sWorld->DecreasePlayerCount();
+}
+
+void Player::CleanupsBeforeDelete(bool finalCleanup)
+{
+    TradeCancel(false);
+    DuelComplete(DUEL_INTERRUPTED);
+
+    Unit::CleanupsBeforeDelete(finalCleanup);
+
+    if (m_transport)
+        m_transport->RemovePassenger(this);
+
+    // clean up player-instance binds, may unload some instance saves
+    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
+            itr->second.save->RemovePlayer(this);
+}
+
+bool Player::Create(uint32 guidlow, CharacterCreateInfo* createInfo)
+{
+    //FIXME: outfitId not used in player creating
+    // TODO: need more checks against packet modifications
+    // should check that skin, face, hair* are valid via DBC per race/class
+    // also do it in Player::BuildEnumData, Player::LoadFromDB
+
+    Object::_Create(guidlow, 0, HIGHGUID_PLAYER);
+
+    m_name = createInfo->Name;
+
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(createInfo->Race, createInfo->Class);
+    if (!info)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid race/class pair (%u/%u) - refusing to do so.",
+                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Race, createInfo->Class);
+        return false;
+    }
+
+    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
+        m_items[i] = NULL;
+
+    Relocate(info->positionX, info->positionY, info->positionZ, info->orientation);
+
+    ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(createInfo->Class);
+    if (!cEntry)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid character class (%u) - refusing to do so (wrong DBC-files?)",
+                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Class);
+        return false;
+    }
+
+    SetMap(sMapMgr->CreateMap(info->mapId, this));
+
+    uint8 powertype = cEntry->powerType;
+
+    SetObjectScale(1.0f); 
+
+    setFactionForRace(createInfo->Race);
+
+    if (!IsValidGender(createInfo->Gender))
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid gender (%hu) - refusing to do so",
+                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Gender);
+        return false;
+    }
+
+    uint32 RaceClassGender = (createInfo->Race) | (createInfo->Class << 8) | (createInfo->Gender << 16);
+
+    SetUInt32Value(UNIT_FIELD_BYTES_0, (RaceClassGender | (powertype << 24)));
+    InitDisplayIds();
+    if (sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_PVP || sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_RPPVP)
+    {
+        SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_PVP);
+        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+    }
+
+    SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);
+    SetFloatValue(UNIT_FIELD_HOVERHEIGHT, 1.0f);            // default for players in 3.0.3
+
+    SetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, uint32(-1));  // -1 is default value
+
+    SetUInt32Value(PLAYER_BYTES, (createInfo->Skin | (createInfo->Face << 8) | (createInfo->HairStyle << 16) | (createInfo->HairColor << 24)));
+    SetUInt32Value(PLAYER_BYTES_2, (createInfo->FacialHair |
+                                   (0x00 << 8) |
+                                   (0x00 << 16) |
+                                   (((GetSession()->IsARecruiter() || GetSession()->GetRecruiterId() != 0) ? REST_STATE_RAF_LINKED : REST_STATE_NOT_RAF_LINKED) << 24)));
+    SetByteValue(PLAYER_BYTES_3, 0, createInfo->Gender);
+    SetByteValue(PLAYER_BYTES_3, 3, GetTeam() == ALLIANCE);      // BattlefieldArenaFaction (0 or 1) set standart
+
+    SetUInt64Value(OBJECT_FIELD_DATA, 0);
+    SetUInt32Value(PLAYER_GUILDRANK, 0);
+    SetGuildLevel(0);
+    SetUInt32Value(PLAYER_GUILD_TIMESTAMP, 0);
+
+    for (int i = 0; i < KNOWN_TITLES_SIZE; ++i)
+        SetUInt64Value(PLAYER__FIELD_KNOWN_TITLES + i, 0);  // 0=disabled
+    SetUInt32Value(PLAYER_CHOSEN_TITLE, 0);
+
+    SetUInt32Value(PLAYER_FIELD_KILLS, 0);
+    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 0);
+
+    // set starting level
+    uint32 start_level = getClass() != CLASS_DEATH_KNIGHT
+        ? sWorld->getIntConfig(CONFIG_START_PLAYER_LEVEL)
+        : sWorld->getIntConfig(CONFIG_START_HEROIC_PLAYER_LEVEL);
+
+    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
+    {
+        uint32 gm_level = sWorld->getIntConfig(CONFIG_START_GM_LEVEL);
+        if (gm_level > start_level)
+            start_level = gm_level;
+    }
+
+    SetUInt32Value(UNIT_FIELD_LEVEL, start_level);
+
+    InitRunes();
+
+
+	SetUInt32Value(PLAYER_FIELD_COINAGE, sWorld->getIntConfig(CONFIG_START_PLAYER_MONEY));
+	SetCurrency(CURRENCY_TYPE_HONOR_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_HONOR_POINTS));
+	SetCurrency(CURRENCY_TYPE_JUSTICE_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_JUSTICE_POINTS));
+	SetCurrency(CURRENCY_TYPE_CONQUEST_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_CONQUEST_POINTS));
+
+    // start with every map explored
+    if (sWorld->getBoolConfig(CONFIG_START_ALL_EXPLORED))
+    {
+        for (uint8 i=0; i<PLAYER_EXPLORED_ZONES_SIZE; i++)
+            SetFlag(PLAYER_EXPLORED_ZONES_1+i, 0xFFFFFFFF);
+    }
+
+    //Reputations if "StartAllReputation" is enabled, -- TODO: Fix this in a better way
+    if (sWorld->getBoolConfig(CONFIG_START_ALL_REP))
+    {
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(942), 42999);
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(935), 42999);
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(936), 42999);
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1011), 42999);
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(970), 42999);
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(967), 42999);
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(989), 42999);
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(932), 42999);
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(934), 42999);
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1038), 42999);
+        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1077), 42999);
+
+        // Factions depending on team, like cities and some more stuff
+        switch (GetTeam())
+        {
+        case ALLIANCE:
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(72), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(47), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(69), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(930), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(730), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(978), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(54), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(946), 42999);
+            break;
+        case HORDE:
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(76), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(68), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(81), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(911), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(729), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(941), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(530), 42999);
+            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(947), 42999);
+            break;
+        default:
+            break;
+        }
+    }
+
+    // Played time
+    m_Last_tick = time(NULL);
+    m_Played_time[PLAYED_TIME_TOTAL] = 0;
+    m_Played_time[PLAYED_TIME_LEVEL] = 0;
+
+    // base stats and related field values
+    InitStatsForLevel();
+    InitTaxiNodesForLevel();
+    InitGlyphsForLevel();
+    InitTalentForLevel();
+    InitPrimaryProfessions();                               // to max set before any spell added
+
+    // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()
+    UpdateMaxHealth();                                      // Update max Health (for add bonus from stamina)
+    SetFullHealth();
+    if (getPowerType() == POWER_MANA)
+    {
+        UpdateMaxPower(POWER_MANA);                         // Update max Mana (for add bonus from intellect)
+        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+    }
+
+    if (getPowerType() == POWER_RUNIC_POWER)
+    {
+        SetPower(POWER_RUNES, 8);
+        SetMaxPower(POWER_RUNES, 8);
+        SetPower(POWER_RUNIC_POWER, 0);
+        SetMaxPower(POWER_RUNIC_POWER, 1000);
+    }
+
+    learnDefaultSpells();
+    // original action bar
+    for (PlayerCreateInfoActions::const_iterator action_itr = info->action.begin(); action_itr != info->action.end(); ++action_itr)
+        addActionButton(action_itr->button, action_itr->action, action_itr->type);
+
+    // original items
+    if (CharStartOutfitEntry const* oEntry = GetCharStartOutfitEntry(createInfo->Race, createInfo->Class, createInfo->Gender))
+    {
+        for (int j = 0; j < MAX_OUTFIT_ITEMS; ++j)
+        {
+            if (oEntry->ItemId[j] <= 0)
+                continue;
+
+            uint32 itemId = oEntry->ItemId[j];
+
+            // just skip, reported in ObjectMgr::LoadItemTemplates
+            ItemTemplate const* iProto = sObjectMgr->GetItemTemplate(itemId);
+            if (!iProto)
+                continue;
+
+            // BuyCount by default
+            uint32 count = iProto->BuyCount;
+
+            // special amount for food/drink
+            if (iProto->Class == ITEM_CLASS_CONSUMABLE && iProto->SubClass == ITEM_SUBCLASS_FOOD_DRINK)
+            {
+                switch (iProto->Spells[0].SpellCategory)
+                {
+                    case SPELL_CATEGORY_FOOD:                                // food
+                        count = getClass() == CLASS_DEATH_KNIGHT ? 10 : 4;
+                        break;
+                    case SPELL_CATEGORY_DRINK:                                // drink
+                        count = 2;
+                        break;
+                }
+                if (iProto->GetMaxStackSize() < count)
+                    count = iProto->GetMaxStackSize();
+            }
+            StoreNewItemInBestSlots(itemId, count);
+        }
+    }
+
+    for (PlayerCreateInfoItems::const_iterator item_id_itr = info->item.begin(); item_id_itr != info->item.end(); ++item_id_itr)
+        StoreNewItemInBestSlots(item_id_itr->item_id, item_id_itr->item_amount);
+
+    // bags and main-hand weapon must equipped at this moment
+    // now second pass for not equipped (offhand weapon/shield if it attempt equipped before main-hand weapon)
+    // or ammo not equipped in special bag
+    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+    {
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+        {
+            uint16 eDest;
+            // equip offhand weapon/shield if it attempt equipped before main-hand weapon
+            InventoryResult msg = CanEquipItem(NULL_SLOT, eDest, pItem, false);
+            if (msg == EQUIP_ERR_OK)
+            {
+                RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
+                EquipItem(eDest, pItem, true);
+            }
+            // move other items to more appropriate slots
+            else
+            {
+                ItemPosCountVec sDest;
+                msg = CanStoreItem(NULL_BAG, NULL_SLOT, sDest, pItem, false);
+                if (msg == EQUIP_ERR_OK)
+                {
+                    RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
+                    pItem = StoreItem(sDest, pItem, true);
+                }
+            }
+        }
+    }
+    // all item positions resolved
+
+    return true;
+}
+
+bool Player::StoreNewItemInBestSlots(uint32 titem_id, uint32 titem_amount)
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: Creating initial item, itemId = %u, count = %u", titem_id, titem_amount);
+
+    // attempt equip by one
+    while (titem_amount > 0)
+    {
+        uint16 eDest;
+        InventoryResult msg = CanEquipNewItem(NULL_SLOT, eDest, titem_id, false);
+        if (msg != EQUIP_ERR_OK)
+            break;
+
+        EquipNewItem(eDest, titem_id, true);
+        AutoUnequipOffhandIfNeed();
+        --titem_amount;
+    }
+
+    if (titem_amount == 0)
+        return true;                                        // equipped
+
+    // attempt store
+    ItemPosCountVec sDest;
+    // store in main bag to simplify second pass (special bags can be not equipped yet at this moment)
+    InventoryResult msg = CanStoreNewItem(INVENTORY_SLOT_BAG_0, NULL_SLOT, sDest, titem_id, titem_amount);
+    if (msg == EQUIP_ERR_OK)
+    {
+        StoreNewItem(sDest, titem_id, true, Item::GenerateItemRandomPropertyId(titem_id));
+        return true;                                        // stored
+    }
+
+    // item can't be added
+    sLog->outError(LOG_FILTER_PLAYER_ITEMS, "STORAGE: Can't equip or store initial item %u for race %u class %u, error msg = %u", titem_id, getRace(), getClass(), msg);
+    return false;
+}
+
+void Player::SendMirrorTimer(MirrorTimerType Type, uint32 MaxValue, uint32 CurrentValue, int32 Regen)
+{
+    if (int(MaxValue) == DISABLED_MIRROR_TIMER)
+    {
+        if (int(CurrentValue) != DISABLED_MIRROR_TIMER)
+            StopMirrorTimer(Type);
+        return;
+    }
+    WorldPacket data(SMSG_START_MIRROR_TIMER, (21));
+    data << (uint32)Type;
+    data << CurrentValue;
+    data << MaxValue;
+    data << Regen;
+    data << (uint8)0;
+    data << (uint32)0;                                      // spell id
+    GetSession()->SendPacket(&data);
+}
+
+void Player::StopMirrorTimer(MirrorTimerType Type)
+{
+    m_MirrorTimer[Type] = DISABLED_MIRROR_TIMER;
+    WorldPacket data(SMSG_STOP_MIRROR_TIMER, 4);
+    data << (uint32)Type;
+    GetSession()->SendPacket(&data);
+}
+
+bool Player::IsImmuneToEnvironmentalDamage()
+{
+    // check for GM and death state included in isAttackableByAOE
+    return (!isTargetableForAttack(false));
+}
+
+uint32 Player::EnvironmentalDamage(EnviromentalDamage type, uint32 damage)
+{
+    if (IsImmuneToEnvironmentalDamage())
+        return 0;
+
+    // Absorb, resist some environmental damage type
+    uint32 absorb = 0;
+    uint32 resist = 0;
+    if (type == DAMAGE_LAVA)
+        CalcAbsorbResist(this, SPELL_SCHOOL_MASK_FIRE, DIRECT_DAMAGE, damage, &absorb, &resist);
+    else if (type == DAMAGE_SLIME)
+        CalcAbsorbResist(this, SPELL_SCHOOL_MASK_NATURE, DIRECT_DAMAGE, damage, &absorb, &resist);
+
+    damage -= absorb + resist;
+
+    DealDamageMods(this, damage, &absorb);
+
+    WorldPacket data(SMSG_ENVIRONMENTALDAMAGELOG, (21));
+    data << uint64(GetGUID());
+    data << uint8(type != DAMAGE_FALL_TO_VOID ? type : DAMAGE_FALL);
+    data << uint32(damage);
+    data << uint32(absorb);
+    data << uint32(resist);
+    SendMessageToSet(&data, true);
+
+    uint32 final_damage = DealDamage(this, damage, NULL, SELF_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+
+    if (!isAlive())
+    {
+        if (type == DAMAGE_FALL)                               // DealDamage not apply item durability loss at self damage
+        {
+            sLog->outDebug(LOG_FILTER_PLAYER, "We are fall to death, loosing 10 percents durability");
+            DurabilityLossAll(0.10f, false);
+            // durability lost message
+            SendDurabilityLoss(this, 10);
+        }
+
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATHS_FROM, 1, type);
+    }
+
+    return final_damage;
+}
+
+int32 Player::getMaxTimer(MirrorTimerType timer)
+{
+    switch (timer)
+    {
+        case FATIGUE_TIMER:
+            return MINUTE * IN_MILLISECONDS;
+        case BREATH_TIMER:
+        {
+            if (!isAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) || GetSession()->GetSecurity() >= AccountTypes(sWorld->getIntConfig(CONFIG_DISABLE_BREATHING)))
+                return DISABLED_MIRROR_TIMER;
+            int32 UnderWaterTime = 3 * MINUTE * IN_MILLISECONDS;
+            AuraEffectList const& mModWaterBreathing = GetAuraEffectsByType(SPELL_AURA_MOD_WATER_BREATHING);
+            for (AuraEffectList::const_iterator i = mModWaterBreathing.begin(); i != mModWaterBreathing.end(); ++i)
+                AddPct(UnderWaterTime, (*i)->GetAmount());
+            return UnderWaterTime;
+        }
+        case FIRE_TIMER:
+        {
+            if (!isAlive())
+                return DISABLED_MIRROR_TIMER;
+            return 1 * IN_MILLISECONDS;
+        }
+        default:
+            return 0;
+    }
+}
+
+void Player::UpdateMirrorTimers()
+{
+    // Desync flags for update on next HandleDrowning
+    if (m_MirrorTimerFlags)
+        m_MirrorTimerFlagsLast = ~m_MirrorTimerFlags;
+}
+
+void Player::HandleDrowning(uint32 time_diff)
+{
+    if (!m_MirrorTimerFlags)
+        return;
+
+    // In water
+    if (m_MirrorTimerFlags & UNDERWATER_INWATER)
+    {
+        switch (m_zoneUpdateId)
+        {
+            case 5144:
+            case 5007:
+            case 5145:
+            case 4815:
+            case 4816:
+            case 5042:
+            case 5146:
+                return;
+            default:
+                break;
+        }
+
+        // Breath timer not activated - activate it
+        if (m_MirrorTimer[BREATH_TIMER] == DISABLED_MIRROR_TIMER)
+        {
+            m_MirrorTimer[BREATH_TIMER] = getMaxTimer(BREATH_TIMER);
+            SendMirrorTimer(BREATH_TIMER, m_MirrorTimer[BREATH_TIMER], m_MirrorTimer[BREATH_TIMER], -1);
+        }
+        else                                                              // If activated - do tick
+        {
+            m_MirrorTimer[BREATH_TIMER]-=time_diff;
+            // Timer limit - need deal damage
+            if (m_MirrorTimer[BREATH_TIMER] < 0)
+            {
+                m_MirrorTimer[BREATH_TIMER]+= 1*IN_MILLISECONDS;
+                // Calculate and deal damage
+                // TODO: Check this formula
+                uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel()-1);
+                EnvironmentalDamage(DAMAGE_DROWNING, damage);
+            }
+            else if (!(m_MirrorTimerFlagsLast & UNDERWATER_INWATER))      // Update time in client if need
+                SendMirrorTimer(BREATH_TIMER, getMaxTimer(BREATH_TIMER), m_MirrorTimer[BREATH_TIMER], -1);
+        }
+    }
+    else if (m_MirrorTimer[BREATH_TIMER] != DISABLED_MIRROR_TIMER)        // Regen timer
+    {
+        int32 UnderWaterTime = getMaxTimer(BREATH_TIMER);
+        // Need breath regen
+        m_MirrorTimer[BREATH_TIMER]+=10*time_diff;
+        if (m_MirrorTimer[BREATH_TIMER] >= UnderWaterTime || !isAlive())
+            StopMirrorTimer(BREATH_TIMER);
+        else if (m_MirrorTimerFlagsLast & UNDERWATER_INWATER)
+            SendMirrorTimer(BREATH_TIMER, UnderWaterTime, m_MirrorTimer[BREATH_TIMER], 10);
+    }
+
+    // In dark water
+    if (m_MirrorTimerFlags & UNDERWARER_INDARKWATER)
+    {
+        switch (m_zoneUpdateId)
+        {
+            case 5144:
+            case 5007:
+            case 5145:
+            case 4815:
+            case 4816:
+            case 5042:
+            case 4922:
+                return;
+            default:
+                break;
+        }
+
+        // Fatigue timer not activated - activate it
+        if (m_MirrorTimer[FATIGUE_TIMER] == DISABLED_MIRROR_TIMER)
+        {
+            m_MirrorTimer[FATIGUE_TIMER] = getMaxTimer(FATIGUE_TIMER);
+            SendMirrorTimer(FATIGUE_TIMER, m_MirrorTimer[FATIGUE_TIMER], m_MirrorTimer[FATIGUE_TIMER], -1);
+        }
+        else
+        {
+            m_MirrorTimer[FATIGUE_TIMER]-=time_diff;
+            // Timer limit - need deal damage or teleport ghost to graveyard
+            if (m_MirrorTimer[FATIGUE_TIMER] < 0)
+            {
+                m_MirrorTimer[FATIGUE_TIMER]+= 1*IN_MILLISECONDS;
+                if (isAlive())                                            // Calculate and deal damage
+                {
+                    uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel()-1);
+                    EnvironmentalDamage(DAMAGE_EXHAUSTED, damage);
+                }
+                else if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))       // Teleport ghost to graveyard
+                    RepopAtGraveyard();
+            }
+            else if (!(m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER))
+                SendMirrorTimer(FATIGUE_TIMER, getMaxTimer(FATIGUE_TIMER), m_MirrorTimer[FATIGUE_TIMER], -1);
+        }
+    }
+    else if (m_MirrorTimer[FATIGUE_TIMER] != DISABLED_MIRROR_TIMER)       // Regen timer
+    {
+        int32 DarkWaterTime = getMaxTimer(FATIGUE_TIMER);
+        m_MirrorTimer[FATIGUE_TIMER]+=10*time_diff;
+        if (m_MirrorTimer[FATIGUE_TIMER] >= DarkWaterTime || !isAlive())
+            StopMirrorTimer(FATIGUE_TIMER);
+        else if (m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER)
+            SendMirrorTimer(FATIGUE_TIMER, DarkWaterTime, m_MirrorTimer[FATIGUE_TIMER], 10);
+    }
+
+    if (m_MirrorTimerFlags & (UNDERWATER_INLAVA /*| UNDERWATER_INSLIME*/) && !(_lastLiquid && _lastLiquid->SpellId))
+    {
+        // Breath timer not activated - activate it
+        if (m_MirrorTimer[FIRE_TIMER] == DISABLED_MIRROR_TIMER)
+            m_MirrorTimer[FIRE_TIMER] = getMaxTimer(FIRE_TIMER);
+        else
+        {
+            m_MirrorTimer[FIRE_TIMER] -= time_diff;
+            if (m_MirrorTimer[FIRE_TIMER] < 0)
+            {
+                m_MirrorTimer[FIRE_TIMER]+= 1*IN_MILLISECONDS;
+                // Calculate and deal damage
+                // TODO: Check this formula
+                uint32 damage = urand(600, 700);
+                if (m_MirrorTimerFlags & UNDERWATER_INLAVA)
+                    EnvironmentalDamage(DAMAGE_LAVA, damage);
+                // need to skip Slime damage in Undercity,
+                // maybe someone can find better way to handle environmental damage
+                //else if (m_zoneUpdateId != 1497)
+                //    EnvironmentalDamage(DAMAGE_SLIME, damage);
+            }
+        }
+    }
+    else
+        m_MirrorTimer[FIRE_TIMER] = DISABLED_MIRROR_TIMER;
+
+    // Recheck timers flag
+    m_MirrorTimerFlags&=~UNDERWATER_EXIST_TIMERS;
+    for (uint8 i = 0; i< MAX_TIMERS; ++i)
+        if (m_MirrorTimer[i] != DISABLED_MIRROR_TIMER)
+        {
+            m_MirrorTimerFlags|=UNDERWATER_EXIST_TIMERS;
+            break;
+        }
+    m_MirrorTimerFlagsLast = m_MirrorTimerFlags;
+}
+
+///The player sobers by 1% every 9 seconds
+void Player::HandleSobering()
+{
+    m_drunkTimer = 0;
+
+    uint8 currentDrunkValue = GetDrunkValue();
+    uint8 drunk = currentDrunkValue ? --currentDrunkValue : 0;
+    SetDrunkValue(drunk);
+}
+
+DrunkenState Player::GetDrunkenstateByValue(uint8 value)
+{
+    if (value >= 90)
+        return DRUNKEN_SMASHED;
+    if (value >= 50)
+        return DRUNKEN_DRUNK;
+    if (value)
+        return DRUNKEN_TIPSY;
+    return DRUNKEN_SOBER;
+}
+
+void Player::SetDrunkValue(uint8 newDrunkValue, uint32 itemId /*= 0*/)
+{
+    bool isSobering = newDrunkValue < GetDrunkValue();
+    uint32 oldDrunkenState = Player::GetDrunkenstateByValue(GetDrunkValue());
+    if (newDrunkValue > 100)
+        newDrunkValue = 100;
+
+    // select drunk percent or total SPELL_AURA_MOD_FAKE_INEBRIATE amount, whichever is higher for visibility updates
+    int32 drunkPercent = std::max<int32>(newDrunkValue, GetTotalAuraModifier(SPELL_AURA_MOD_FAKE_INEBRIATE));
+    if (drunkPercent)
+    {
+        m_invisibilityDetect.AddFlag(INVISIBILITY_DRUNK);
+        m_invisibilityDetect.SetValue(INVISIBILITY_DRUNK, drunkPercent);
+    }
+    else if (!HasAuraType(SPELL_AURA_MOD_FAKE_INEBRIATE) && !newDrunkValue)
+        m_invisibilityDetect.DelFlag(INVISIBILITY_DRUNK);
+
+    uint32 newDrunkenState = Player::GetDrunkenstateByValue(newDrunkValue);
+    SetByteValue(PLAYER_BYTES_3, 1, newDrunkValue);
+    UpdateObjectVisibility();
+
+    if (!isSobering)
+        m_drunkTimer = 0;   // reset sobering timer
+
+    if (newDrunkenState == oldDrunkenState)
+        return;
+
+    WorldPacket data(SMSG_CROSSED_INEBRIATION_THRESHOLD, (8+4+4));
+    data << uint64(GetGUID());
+    data << uint32(newDrunkenState);
+    data << uint32(itemId);
+    SendMessageToSet(&data, true);
+}
+
+void Player::Update(uint32 p_time)
+{
+    if (!IsInWorld())
+        return;
+
+    // undelivered mail
+    if (m_nextMailDelivereTime && m_nextMailDelivereTime <= time(NULL))
+    {
+        SendNewMail();
+        ++unReadMails;
+
+        // It will be recalculate at mailbox open (for unReadMails important non-0 until mailbox open, it also will be recalculated)
+        m_nextMailDelivereTime = 0;
+    }
+
+    // If this is set during update SetSpellModTakingSpell call is missing somewhere in the code
+    // Having this would prevent more aura charges to be dropped, so let's crash
+    //ASSERT (!m_spellModTakingSpell);
+    if (m_spellModTakingSpell)
+    {
+        //sLog->outFatal(LOG_FILTER_PLAYER, "Player has m_pad %u during update!", m_pad);
+        //if (m_spellModTakingSpell)
+        sLog->outFatal(LOG_FILTER_SPELLS_AURAS, "Player has m_spellModTakingSpell %u during update!", m_spellModTakingSpell->m_spellInfo->Id);
+        m_spellModTakingSpell = NULL;
+    }
+
+	if ((GetMap()->IsRaid()) && (GetGroup() == NULL) && (GetSession()->GetSecurity() < 1))
+	{
+	    TeleportTo(530,-1890.4f,5398.62f,-12.42f,4.04241f);
+	}
+
+	if ((GetMap()->IsRaid()) && (GetGroup() != NULL) && GetMap()->Is25ManRaid() && (GetGroup()->GetMembersCount() > 25))
+	{
+	    TeleportTo(530,-1890.4f,5398.62f,-12.42f,4.04241f);
+	}
+	if ((GetMap()->IsRaid()) && (GetGroup() != NULL) && !GetMap()->Is25ManRaid()  && (GetGroup()->GetMembersCount() > 10))
+	{
+	    TeleportTo(530,-1890.4f,5398.62f,-12.42f,4.04241f);
+	}
+
+    //used to implement delayed far teleports
+    SetCanDelayTeleport(true);
+    Unit::Update(p_time);
+    SetCanDelayTeleport(false);
+
+    time_t now = time(NULL);
+
+    UpdatePvPFlag(now);
+
+    UpdateContestedPvP(p_time);
+
+    UpdateDuelFlag(now);
+
+    CheckDuelDistance(now);
+
+    UpdateAfkReport(now);
+
+    if (isCharmed())
+        if (Unit* charmer = GetCharmer())
+            if (charmer->GetTypeId() == TYPEID_UNIT && charmer->isAlive())
+                UpdateCharmedAI();
+
+    // Update items that have just a limited lifetime
+    if (now > m_Last_tick)
+        UpdateItemDuration(uint32(now - m_Last_tick));
+
+    // check every second
+    if (now > m_Last_tick + 1)
+        UpdateSoulboundTradeItems();
+
+    // If mute expired, remove it from the DB
+    if (GetSession()->m_muteTime && GetSession()->m_muteTime < now)
+    {
+        GetSession()->m_muteTime = 0;
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_MUTE_TIME);
+        stmt->setInt64(0, 0); // Set the mute time to 0
+        stmt->setUInt32(1, GetSession()->GetAccountId());
+        LoginDatabase.Execute(stmt);
+    }
+
+    if (!m_timedquests.empty())
+    {
+        QuestSet::iterator iter = m_timedquests.begin();
+        while (iter != m_timedquests.end())
+        {
+            QuestStatusData& q_status = m_QuestStatus[*iter];
+            if (q_status.Timer <= p_time)
+            {
+                uint32 quest_id  = *iter;
+                ++iter;                                     // current iter will be removed in FailQuest
+                FailQuest(quest_id);
+            }
+            else
+            {
+                q_status.Timer -= p_time;
+                m_QuestStatusSave[*iter] = true;
+                ++iter;
+            }
+        }
+    }
+
+    m_achievementMgr->UpdateTimedAchievements(p_time);
+
+    if (HasUnitState(UNIT_STATE_MELEE_ATTACKING) && !HasUnitState(UNIT_STATE_CASTING))
+    {
+        if (Unit* victim = GetVictim())
+        {
+            // default combat reach 10
+            // TODO add weapon, skill check
+
+            if (isAttackReady(BASE_ATTACK))
+            {
+                if (!IsWithinMeleeRange(victim))
+                {
+                    setAttackTimer(BASE_ATTACK, 100);
+                    if (m_swingErrorMsg != 1)               // send single time (client auto repeat)
+                    {
+                        SendAttackSwingNotInRange();
+                        m_swingErrorMsg = 1;
+                    }
+                }
+                //120 degrees of radiant range
+                else if (!HasInArc(2*M_PI/3, victim))
+                {
+                    setAttackTimer(BASE_ATTACK, 100);
+                    if (m_swingErrorMsg != 2)               // send single time (client auto repeat)
+                    {
+                        SendAttackSwingBadFacingAttack();
+                        m_swingErrorMsg = 2;
+                    }
+                }
+                else
+                {
+                    m_swingErrorMsg = 0;                    // reset swing error state
+
+                    // prevent base and off attack in same time, delay attack at 0.2 sec
+                    if (haveOffhandWeapon())
+                        if (getAttackTimer(OFF_ATTACK) < ATTACK_DISPLAY_DELAY)
+                            setAttackTimer(OFF_ATTACK, ATTACK_DISPLAY_DELAY);
+
+                    // do attack
+                    AttackerStateUpdate(victim, BASE_ATTACK);
+                    resetAttackTimer(BASE_ATTACK);
+                }
+            }
+
+            if (haveOffhandWeapon() && isAttackReady(OFF_ATTACK))
+            {
+                if (!IsWithinMeleeRange(victim))
+                    setAttackTimer(OFF_ATTACK, 100);
+                else if (!HasInArc(2*M_PI/3, victim))
+                    setAttackTimer(OFF_ATTACK, 100);
+                else
+                {
+                    // prevent base and off attack in same time, delay attack at 0.2 sec
+                    if (getAttackTimer(BASE_ATTACK) < ATTACK_DISPLAY_DELAY)
+                        setAttackTimer(BASE_ATTACK, ATTACK_DISPLAY_DELAY);
+
+                    // do attack
+                    AttackerStateUpdate(victim, OFF_ATTACK);
+                    resetAttackTimer(OFF_ATTACK);
+                }
+            }
+
+            /*Unit* owner = victim->GetOwner();
+            Unit* u = owner ? owner : victim;
+            if (u->IsPvP() && (!duel || duel->opponent != u))
+            {
+                UpdatePvP(true);
+                RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT);
+            }*/
+        }
+    }
+
+    if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
+    {
+        if (roll_chance_i(3) && GetTimeInnEnter() > 0)      // freeze update
+        {
+            time_t time_inn = time(NULL)-GetTimeInnEnter();
+            if (time_inn >= 10)                             // freeze update
+            {
+                float bubble = 0.125f*sWorld->getRate(RATE_REST_INGAME);
+                                                            // speed collect rest bonus (section/in hour)
+                SetRestBonus(GetRestBonus()+ time_inn*((float)GetUInt32Value(PLAYER_NEXT_LEVEL_XP)/72000)*bubble);
+                UpdateInnerTime(time(NULL));
+            }
+        }
+    }
+
+    if (m_weaponChangeTimer > 0)
+    {
+        if (p_time >= m_weaponChangeTimer)
+            m_weaponChangeTimer = 0;
+        else
+            m_weaponChangeTimer -= p_time;
+    }
+
+    if (m_zoneUpdateTimer > 0)
+    {
+        if (p_time >= m_zoneUpdateTimer)
+        {
+            uint32 newzone, newarea;
+            GetZoneAndAreaId(newzone, newarea);
+
+            if (m_zoneUpdateId != newzone)
+                UpdateZone(newzone, newarea);                // also update area
+            else
+            {
+                // use area updates as well
+                // needed for free far all arenas for example
+                if (m_areaUpdateId != newarea)
+                    UpdateArea(newarea);
+
+                m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;
+            }
+        }
+        else
+            m_zoneUpdateTimer -= p_time;
+    }
+
+    if (m_timeSyncTimer > 0)
+    {
+        if (p_time >= m_timeSyncTimer)
+            SendTimeSync();
+        else
+            m_timeSyncTimer -= p_time;
+    }
+
+    if (isAlive())
+    {
+        m_regenTimer += p_time;
+        RegenerateAll();
+    }
+
+    if (m_deathState == JUST_DIED)
+        KillPlayer();
+
+    if (m_nextSave > 0)
+    {
+        if (p_time >= m_nextSave)
+        {
+            // m_nextSave reset in SaveToDB call
+            sScriptMgr->OnPlayerSave(this);
+            SaveToDB();
+            sLog->outDebug(LOG_FILTER_PLAYER, "Player '%s' (GUID: %u) saved", GetName().c_str(), GetGUIDLow());
+        }
+        else
+            m_nextSave -= p_time;
+    }
+
+    //Handle Water/drowning
+    HandleDrowning(p_time);
+
+    // Played time
+    if (now > m_Last_tick)
+    {
+        uint32 elapsed = uint32(now - m_Last_tick);
+        m_Played_time[PLAYED_TIME_TOTAL] += elapsed;        // Total played time
+        m_Played_time[PLAYED_TIME_LEVEL] += elapsed;        // Level played time
+        m_Last_tick = now;
+    }
+
+    if (GetDrunkValue())
+    {
+        m_drunkTimer += p_time;
+        if (m_drunkTimer > 9 * IN_MILLISECONDS)
+            HandleSobering();
+    }
+
+    if (HasPendingBind())
+    {
+        if (_pendingBindTimer <= p_time)
+        {
+            // Player left the instance
+            if (_pendingBindId == GetInstanceId())
+                BindToInstance();
+            SetPendingBind(0, 0);
+        }
+        else
+            _pendingBindTimer -= p_time;
+    }
+
+    // not auto-free ghost from body in instances
+    if (m_deathTimer > 0 && !GetBaseMap()->Instanceable() && !HasAuraType(SPELL_AURA_PREVENT_RESURRECTION))
+    {
+        if (p_time >= m_deathTimer)
+        {
+            m_deathTimer = 0;
+            BuildPlayerRepop();
+            RepopAtGraveyard();
+        }
+        else
+            m_deathTimer -= p_time;
+    }
+
+    UpdateEnchantTime(p_time);
+    UpdateHomebindTime(p_time);
+
+    if (!_instanceResetTimes.empty())
+    {
+        for (InstanceTimeMap::iterator itr = _instanceResetTimes.begin(); itr != _instanceResetTimes.end();)
+        {
+            if (itr->second < now)
+                _instanceResetTimes.erase(itr++);
+            else
+                ++itr;
+        }
+    }
+
+    // group update
+    if (_groupOutOfRangeUpdateTime <= p_time)
+    {
+        SendUpdateToOutOfRangeGroupMembers();
+        _groupOutOfRangeUpdateTime = 1000;
+    }
+    else
+        _groupOutOfRangeUpdateTime -= p_time;
+
+    Pet* pet = GetPet();
+    if (pet && !pet->IsWithinDistInMap(this, GetMap()->GetVisibilityRange()) && !pet->isPossessed())
+    //if (pet && !pet->IsWithinDistInMap(this, GetMap()->GetVisibilityDistance()) && (GetCharmGUID() && (pet->GetGUID() != GetCharmGUID())))
+        RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT, true);
+
+    //we should execute delayed teleports only for alive(!) players
+    //because we don't want player's ghost teleported from graveyard
+    if (IsHasDelayedTeleport() && isAlive())
+        TeleportTo(m_teleport_dest, m_teleport_options);
+}
+
+void Player::setDeathState(DeathState s)
+{
+    uint32 ressSpellId = 0;
+
+    bool cur = isAlive();
+
+    if (s == JUST_DIED)
+    {
+        if (!cur)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "setDeathState: attempt to kill a dead player %s(%d)", GetName().c_str(), GetGUIDLow());
+            return;
+        }
+
+        // drunken state is cleared on death
+        SetDrunkValue(0);
+        // lost combo points at any target (targeted combo points clear in Unit::setDeathState)
+        ClearComboPoints();
+
+        ClearResurrectRequestData();
+
+        //FIXME: is pet dismissed at dying or releasing spirit? if second, add setDeathState(DEAD) to HandleRepopRequestOpcode and define pet unsummon here with (s == DEAD)
+        RemovePet(NULL, PET_SLOT_ACTUAL_PET_SLOT, true);
+
+        // save value before aura remove in Unit::setDeathState
+        ressSpellId = GetUInt32Value(PLAYER_SELF_RES_SPELL);
+
+        // passive spell
+        if (!ressSpellId)
+            ressSpellId = GetResurrectionSpellId();
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATH_AT_MAP, 1);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATH, 1);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATH_IN_DUNGEON, 1);
+        ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE, ACHIEVEMENT_CRITERIA_CONDITION_NO_DEATH);
+        ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, ACHIEVEMENT_CRITERIA_CONDITION_NO_DEATH);
+        ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS, ACHIEVEMENT_CRITERIA_CONDITION_NO_DEATH);
+    }
+
+    Unit::setDeathState(s);
+
+    // restore resurrection spell id for player after aura remove
+    if (s == JUST_DIED && cur && ressSpellId)
+        SetUInt32Value(PLAYER_SELF_RES_SPELL, ressSpellId);
+
+    if (isAlive() && !cur)
+        //clear aura case after resurrection by another way (spells will be applied before next death)
+        SetUInt32Value(PLAYER_SELF_RES_SPELL, 0);
+}
+
+bool Player::BuildEnumData(PreparedQueryResult result, ByteBuffer* dataBuffer, ByteBuffer* bitBuffer)
+{
+    //             0               1                2                3                 4                  5                       6                        7
+    //    "SELECT characters.guid, characters.name, characters.race, characters.class, characters.gender, characters.playerBytes, characters.playerBytes2, characters.level, "
+    //     8                9               10                     11                     12                     13                    14
+    //    "characters.zone, characters.map, characters.position_x, characters.position_y, characters.position_z, guild_member.guildid, characters.playerFlags, "
+    //    15                    16                   17                     18                   19               20                     21               22
+    //    "characters.at_login, character_pet.entry, character_pet.modelid, character_pet.level, characters.data, character_banned.guid, characters.slot, character_declinedname.genitive"
+
+    Field* fields = result->Fetch();
+
+    ObjectGuid guid = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+    std::string name = fields[1].GetString();
+    uint8 plrRace = fields[2].GetUInt8();
+    uint8 plrClass = fields[3].GetUInt8();
+    uint8 gender = fields[4].GetUInt8();
+    uint8 skin = uint8(fields[5].GetUInt32() & 0xFF);
+    uint8 face = uint8((fields[5].GetUInt32() >> 8) & 0xFF);
+    uint8 hairStyle = uint8((fields[5].GetUInt32() >> 16) & 0xFF);
+    uint8 hairColor = uint8((fields[5].GetUInt32() >> 24) & 0xFF);
+    uint8 facialHair = uint8(fields[6].GetUInt32() & 0xFF);
+    uint8 level = fields[7].GetUInt8();
+    uint32 zone = fields[8].GetUInt16();
+    uint32 mapId = uint32(fields[9].GetUInt16());
+    float x = fields[10].GetFloat();
+    float y = fields[11].GetFloat();
+    float z = fields[12].GetFloat();
+    uint32 guildId = fields[13].GetUInt32();
+    ObjectGuid guildGuid = MAKE_NEW_GUID(guildId, 0, guildId ? uint32(HIGHGUID_GUILD) : 0);
+    uint32 playerFlags = fields[14].GetUInt32();
+    uint32 atLoginFlags = fields[15].GetUInt16();
+    Tokenizer equipment(fields[19].GetString(), ' ');
+    uint8 slot = fields[21].GetUInt8();
+
+    uint32 charFlags = 0;
+    if (playerFlags & PLAYER_FLAGS_HIDE_HELM)
+        charFlags |= CHARACTER_FLAG_HIDE_HELM;
+
+    if (playerFlags & PLAYER_FLAGS_HIDE_CLOAK)
+        charFlags |= CHARACTER_FLAG_HIDE_CLOAK;
+
+    if (playerFlags & PLAYER_FLAGS_GHOST)
+        charFlags |= CHARACTER_FLAG_GHOST;
+
+    if (atLoginFlags & AT_LOGIN_RENAME)
+        charFlags |= CHARACTER_FLAG_RENAME;
+
+    if (fields[20].GetUInt32())
+        charFlags |= CHARACTER_FLAG_LOCKED_BY_BILLING;
+
+    if (sWorld->getBoolConfig(CONFIG_DECLINED_NAMES_USED) && !fields[22].GetString().empty())
+        charFlags |= CHARACTER_FLAG_DECLINED;
+
+    uint32 customizationFlag = 0;
+    if (atLoginFlags & AT_LOGIN_CUSTOMIZE)
+        customizationFlag = CHAR_CUSTOMIZE_FLAG_CUSTOMIZE;
+    else if (atLoginFlags & AT_LOGIN_CHANGE_FACTION)
+        customizationFlag = CHAR_CUSTOMIZE_FLAG_FACTION;
+    else if (atLoginFlags & AT_LOGIN_CHANGE_RACE)
+        customizationFlag = CHAR_CUSTOMIZE_FLAG_RACE;
+
+    uint32 petDisplayId = 0;
+    uint32 petLevel   = 0;
+    uint32 petFamily  = 0;
+    // show pet at selection character in character list only for non-ghost character
+    if (result && !(playerFlags & PLAYER_FLAGS_GHOST) && (plrClass == CLASS_WARLOCK || plrClass == CLASS_HUNTER || plrClass == CLASS_DEATH_KNIGHT))
+    {
+        uint32 entry = fields[16].GetUInt32();
+        CreatureTemplate const* creatureInfo = sObjectMgr->GetCreatureTemplate(entry);
+        if (creatureInfo)
+        {
+            petDisplayId = fields[17].GetUInt32();
+            petLevel     = fields[18].GetUInt16();
+            petFamily    = creatureInfo->family;
+        }
+    }
+
+    // Packet content flags
+    bitBuffer->WriteBit(guid[3]);
+    bitBuffer->WriteBit(guildGuid[1]);
+    bitBuffer->WriteBit(guildGuid[7]);
+    bitBuffer->WriteBit(guildGuid[2]);
+    bitBuffer->WriteBits(uint32(name.length()), 7);
+    bitBuffer->WriteBit(guid[4]);
+    bitBuffer->WriteBit(guid[7]);
+    bitBuffer->WriteBit(guildGuid[3]);
+    bitBuffer->WriteBit(guid[5]);
+    bitBuffer->WriteBit(guildGuid[6]);
+    bitBuffer->WriteBit(guid[1]);
+    bitBuffer->WriteBit(guildGuid[5]);
+    bitBuffer->WriteBit(guildGuid[4]);
+    bitBuffer->WriteBit(atLoginFlags & AT_LOGIN_FIRST);
+    bitBuffer->WriteBit(guid[0]);
+    bitBuffer->WriteBit(guid[2]);
+    bitBuffer->WriteBit(guid[6]);
+    bitBuffer->WriteBit(guildGuid[0]);
+
+    // Character data
+    *dataBuffer << uint8(plrClass);                             // Class
+    for (uint8 slot = 0; slot < INVENTORY_SLOT_BAG_END; ++slot)
+    {
+        uint32 visualbase = slot * 2;
+        uint32 itemId = GetUInt32ValueFromArray(equipment, visualbase);
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+        {
+            *dataBuffer << uint8(0);
+            *dataBuffer << uint32(0);
+            *dataBuffer << uint32(0);
+            continue;
+        }
+
+        SpellItemEnchantmentEntry const* enchant = NULL;
+        uint32 enchants = GetUInt32ValueFromArray(equipment, visualbase + 1);
+        for (uint8 enchantSlot = PERM_ENCHANTMENT_SLOT; enchantSlot <= TEMP_ENCHANTMENT_SLOT; ++enchantSlot)
+        {
+            // values stored in 2 uint16
+            uint32 enchantId = 0x0000FFFF & (enchants >> enchantSlot*16);
+            if (!enchantId)
+                continue;
+
+            enchant = sSpellItemEnchantmentStore.LookupEntry(enchantId);
+            if (enchant)
+                break;
+        }
+
+        *dataBuffer << uint8(proto->InventoryType);
+        *dataBuffer << uint32(proto->DisplayInfoID);
+        *dataBuffer << uint32(enchant ? enchant->aura_id : 0);
+    }
+
+    *dataBuffer << uint32(petFamily);                           // Pet family
+    dataBuffer->WriteByteSeq(guildGuid[2]);
+    *dataBuffer << uint8(slot);                                 // List order
+    *dataBuffer << uint8(hairStyle);                            // Hair style
+    dataBuffer->WriteByteSeq(guildGuid[3]);
+    *dataBuffer << uint32(petDisplayId);                        // Pet DisplayID
+    *dataBuffer << uint32(charFlags);                           // Character flags
+    *dataBuffer << uint8(hairColor);                            // Hair color
+    dataBuffer->WriteByteSeq(guid[4]);
+    *dataBuffer << uint32(mapId);                               // Map Id
+    dataBuffer->WriteByteSeq(guildGuid[5]);
+    *dataBuffer << float(z);                                    // Z
+    dataBuffer->WriteByteSeq(guildGuid[6]);
+    *dataBuffer << uint32(petLevel);                            // Pet level
+    dataBuffer->WriteByteSeq(guid[3]);
+    *dataBuffer << float(y);                                    // Y
+    *dataBuffer << uint32(customizationFlag);                   // Character customization flags
+    *dataBuffer << uint8(facialHair);                           // Facial hair
+    dataBuffer->WriteByteSeq(guid[7]);
+    *dataBuffer << uint8(gender);                               // Gender
+    dataBuffer->append(name.c_str(), name.length());            // Name
+    *dataBuffer << uint8(face);                                 // Face
+    dataBuffer->WriteByteSeq(guid[0]);
+    dataBuffer->WriteByteSeq(guid[2]);
+    dataBuffer->WriteByteSeq(guildGuid[1]);
+    dataBuffer->WriteByteSeq(guildGuid[7]);
+    *dataBuffer << float(x);                                    // X
+    *dataBuffer << uint8(skin);                                 // Skin
+    *dataBuffer << uint8(plrRace);                              // Race
+    *dataBuffer << uint8(level);                                // Level
+    dataBuffer->WriteByteSeq(guid[6]);
+    dataBuffer->WriteByteSeq(guildGuid[4]);
+    dataBuffer->WriteByteSeq(guildGuid[0]);
+    dataBuffer->WriteByteSeq(guid[5]);
+    dataBuffer->WriteByteSeq(guid[1]);
+    *dataBuffer << uint32(zone);                                // Zone id
+    return true;
+}
+
+void Player::ToggleAFK()
+{
+    ToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_AFK);
+
+    // afk player not allowed in battleground
+    if (isAFK() && InBattleground() && !InArena())
+        LeaveBattleground();
+}
+
+void Player::ToggleDND()
+{
+    ToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_DND);
+}
+
+uint8 Player::GetChatTag() const
+{
+    uint8 tag = CHAT_TAG_NONE;
+
+    if (isGMChat())
+        tag |= CHAT_TAG_GM;
+    if (isDND())
+        tag |= CHAT_TAG_DND;
+    if (isAFK())
+        tag |= CHAT_TAG_AFK;
+    if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_DEVELOPER))
+        tag |= CHAT_TAG_DEV;
+
+    return tag;
+}
+
+bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientation, uint32 options)
+{
+    if (!MapManager::IsValidMapCoord(mapid, x, y, z, orientation))
+    {
+        sLog->outError(LOG_FILTER_MAPS, "TeleportTo: invalid map (%d) or invalid coordinates (X: %f, Y: %f, Z: %f, O: %f) given when teleporting player (GUID: %u, name: %s, map: %d, X: %f, Y: %f, Z: %f, O: %f).",
+            mapid, x, y, z, orientation, GetGUIDLow(), GetName().c_str(), GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
+        return false;
+    }
+
+    if (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()) && DisableMgr::IsDisabledFor(DISABLE_TYPE_MAP, mapid, this))
+    {
+        sLog->outError(LOG_FILTER_MAPS, "Player (GUID: %u, name: %s) tried to enter a forbidden map %u", GetGUIDLow(), GetName().c_str(), mapid);
+        SendTransferAborted(mapid, TRANSFER_ABORT_MAP_NOT_ALLOWED);
+        return false;
+    }
+
+    // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
+    Pet* pet = GetPet();
+
+    MapEntry const* mEntry = sMapStore.LookupEntry(mapid);
+
+    // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
+    // don't let gm level > 1 either
+    if (!InBattleground() && mEntry->IsBattlegroundOrArena())
+        return false;
+
+    // client without expansion support
+    if (GetSession()->Expansion() < mEntry->Expansion())
+    {
+        sLog->outDebug(LOG_FILTER_MAPS, "Player %s using client without required expansion tried teleport to non accessible map %u", GetName().c_str(), mapid);
+
+        if (GetTransport())
+        {
+            m_transport->RemovePassenger(this);
+            m_transport = NULL;
+            m_movementInfo.t_pos.Relocate(0.0f, 0.0f, 0.0f, 0.0f);
+            m_movementInfo.t_time = 0;
+            m_movementInfo.t_seat = -1;
+            RepopAtGraveyard();                             // teleport to near graveyard if on transport, looks blizz like :)
+        }
+
+        SendTransferAborted(mapid, TRANSFER_ABORT_INSUF_EXPAN_LVL, mEntry->Expansion());
+
+        return false;                                       // normal client can't teleport to this map...
+    }
+    else
+        sLog->outDebug(LOG_FILTER_MAPS, "Player %s is being teleported to map %u", GetName().c_str(), mapid);
+
+    if (m_vehicle)
+        ExitVehicle();
+
+    // reset movement flags at teleport, because player will continue move with these flags after teleport
+    SetUnitMovementFlags(0);
+    DisableSpline();
+
+    if (m_transport)
+    {
+        if (!(options & TELE_TO_NOT_LEAVE_TRANSPORT))
+        {
+            m_transport->RemovePassenger(this);
+            m_transport = NULL;
+            m_movementInfo.t_pos.Relocate(0.0f, 0.0f, 0.0f, 0.0f);
+            m_movementInfo.t_time = 0;
+            m_movementInfo.t_seat = -1;
+            m_movementInfo.t_guid = 0;
+        }
+    }
+
+    // The player was ported to another map and loses the duel immediately.
+    // We have to perform this check before the teleport, otherwise the
+    // ObjectAccessor won't find the flag.
+    if (duel && GetMapId() != mapid && GetMap()->GetGameObject(GetUInt64Value(PLAYER_DUEL_ARBITER)))
+        DuelComplete(DUEL_FLED);
+
+    if (GetMapId() == mapid)
+    {
+        //lets reset far teleport flag if it wasn't reset during chained teleports
+        SetSemaphoreTeleportFar(false);
+        //setup delayed teleport flag
+        SetDelayedTeleportFlag(IsCanDelayTeleport());
+        //if teleport spell is casted in Unit::Update() func
+        //then we need to delay it until update process will be finished
+        if (IsHasDelayedTeleport())
+        {
+            SetSemaphoreTeleportNear(true);
+            //lets save teleport destination for player
+            m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
+            m_teleport_options = options;
+            return true;
+        }
+
+        if (!(options & TELE_TO_NOT_UNSUMMON_PET))
+        {
+            //same map, only remove pet if out of range for new position
+            if (pet && !pet->IsWithinDist3d(x, y, z, GetMap()->GetVisibilityRange()))
+                UnsummonPetTemporaryIfAny();
+        }
+
+        if (!(options & TELE_TO_NOT_LEAVE_COMBAT))
+            CombatStop();
+
+        // this will be used instead of the current location in SaveToDB
+        m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
+        SetFallInformation(0, z);
+
+        // code for finish transfer called in WorldSession::HandleMovementOpcodes()
+        // at client packet CMSG_MOVE_TELEPORT_ACK
+        SetSemaphoreTeleportNear(true);
+        // near teleport, triggering send CMSG_MOVE_TELEPORT_ACK from client at landing
+        if (!GetSession()->PlayerLogout())
+        {
+            Position pos = {x, y, z, orientation};
+            SendTeleportPacket(pos); // this automatically relocates to oldPos in order to broadcast the packet in the right place
+        }
+    }
+    else
+    {
+        if (getClass() == CLASS_DEATH_KNIGHT && GetMapId() == 609 && !isGameMaster() && !HasSpell(50977))
+            return false;
+
+        // far teleport to another map
+        Map* oldmap = IsInWorld() ? GetMap() : NULL;
+        // check if we can enter before stopping combat / removing pet / totems / interrupting spells
+
+        // Check enter rights before map getting to avoid creating instance copy for player
+        // this check not dependent from map instance copy and same for all instance copies of selected map
+        if (!sMapMgr->CanPlayerEnter(mapid, this, false))
+            return false;
+
+        //I think this always returns true. Correct me if I am wrong.
+        // If the map is not created, assume it is possible to enter it.
+        // It will be created in the WorldPortAck.
+        //Map* map = sMapMgr->FindBaseNonInstanceMap(mapid);
+        //if (!map || map->CanEnter(this))
+        {
+            //lets reset near teleport flag if it wasn't reset during chained teleports
+            SetSemaphoreTeleportNear(false);
+            //setup delayed teleport flag
+            SetDelayedTeleportFlag(IsCanDelayTeleport());
+            //if teleport spell is casted in Unit::Update() func
+            //then we need to delay it until update process will be finished
+            if (IsHasDelayedTeleport())
+            {
+                SetSemaphoreTeleportFar(true);
+                //lets save teleport destination for player
+                m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
+                m_teleport_options = options;
+                return true;
+            }
+
+            SetSelection(0);
+
+            CombatStop();
+
+            ResetContestedPvP();
+
+            // remove player from battleground on far teleport (when changing maps)
+            if (Battleground const* bg = GetBattleground())
+            {
+                // Note: at battleground join battleground id set before teleport
+                // and we already will found "current" battleground
+                // just need check that this is targeted map or leave
+                if (bg->GetMapId() != mapid)
+                    LeaveBattleground(false);                   // don't teleport to entry point
+            }
+
+            // remove arena spell coldowns/buffs now to also remove pet's cooldowns before it's temporarily unsummoned
+            if (mEntry->IsBattleArena())
+            {
+                RemoveArenaSpellCooldowns(true);
+                RemoveArenaAuras();
+                if (pet = GetPet())
+                {
+                    pet->RemoveArenaAuras();
+                    // Remove current pet & remove any temporarily unsummoned ones
+                    RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT);
+                }
+                m_temporaryUnsummonedPetNumber = 0;
+            }
+
+            // remove pet on map change
+            if (pet)
+                UnsummonPetTemporaryIfAny();
+
+            // remove all dyn objects
+            RemoveAllDynObjects();
+
+            // stop spellcasting
+            // not attempt interrupt teleportation spell at caster teleport
+            if (!(options & TELE_TO_SPELL))
+                if (IsNonMeleeSpellCasted(true))
+                    InterruptNonMeleeSpells(true);
+
+            //remove auras before removing from map...
+            RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_CHANGE_MAP | AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING);
+
+            SetPower(POWER_ECLIPSE, 0);
+
+            if (!GetSession()->PlayerLogout())
+            {
+                // send transfer packets
+                WorldPacket data(SMSG_TRANSFER_PENDING, 4 + 4 + 4);
+                data.WriteBit(0);       // unknown
+                if (m_transport)
+                {
+                    data.WriteBit(1);   // has transport
+                    data << GetMapId() << m_transport->GetEntry();
+                }
+                else
+                    data.WriteBit(0);   // has transport
+
+                data << uint32(mapid);
+                GetSession()->SendPacket(&data);
+            }
+
+            // remove from old map now
+            if (oldmap)
+                oldmap->RemovePlayerFromMap(this, false);
+
+            // new final coordinates
+            float final_x = x;
+            float final_y = y;
+            float final_z = z;
+            float final_o = orientation;
+
+            if (m_transport)
+            {
+                final_x += m_movementInfo.t_pos.GetPositionX();
+                final_y += m_movementInfo.t_pos.GetPositionY();
+                final_z += m_movementInfo.t_pos.GetPositionZ();
+                final_o += m_movementInfo.t_pos.GetOrientation();
+            }
+
+            m_teleport_dest = WorldLocation(mapid, final_x, final_y, final_z, final_o);
+            SetFallInformation(0, final_z);
+            // if the player is saved before worldportack (at logout for example)
+            // this will be used instead of the current location in SaveToDB
+
+            if (!GetSession()->PlayerLogout())
+            {
+                WorldPacket data(SMSG_NEW_WORLD, 4 + 4 + 4 + 4 + 4);
+                data << float(m_teleport_dest.GetPositionX());
+                data << float(m_teleport_dest.GetOrientation());
+                data << float(m_teleport_dest.GetPositionZ());
+                data << uint32(mapid);
+                data << float(m_teleport_dest.GetPositionY());
+
+                GetSession()->SendPacket(&data);
+                SendSavedInstances();
+            }
+
+            // move packet sent by client always after far teleport
+            // code for finish transfer to new map called in WorldSession::HandleMoveWorldportAckOpcode at client packet
+            SetSemaphoreTeleportFar(true);
+        }
+        //else
+        //    return false;
+    }
+    return true;
+}
+
+bool Player::TeleportToBGEntryPoint()
+{
+    if (m_bgData.joinPos.m_mapId == MAPID_INVALID)
+        return false;
+
+    ScheduleDelayedOperation(DELAYED_BG_MOUNT_RESTORE);
+    ScheduleDelayedOperation(DELAYED_BG_TAXI_RESTORE);
+    ScheduleDelayedOperation(DELAYED_BG_GROUP_RESTORE);
+    return TeleportTo(m_bgData.joinPos);
+}
+
+void Player::ProcessDelayedOperations()
+{
+    if (m_DelayedOperations == 0)
+        return;
+
+    if (m_DelayedOperations & DELAYED_RESURRECT_PLAYER)
+    {
+        ResurrectPlayer(0.0f, false);
+
+        if (GetMaxHealth() > _resurrectionData->Health)
+            SetHealth(_resurrectionData->Health);
+        else
+            SetFullHealth();
+
+        if (uint32(GetMaxPower(POWER_MANA)) > _resurrectionData->Mana)
+            SetPower(POWER_MANA, _resurrectionData->Mana);
+        else
+            SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+
+        SetPower(POWER_RAGE, 0);
+        SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
+        SetPower(POWER_ECLIPSE, 0);
+
+        if (uint32 aura = _resurrectionData->Aura)
+            CastSpell(this, aura, true, NULL, NULL, _resurrectionData->GUID);
+
+        SpawnCorpseBones();
+    }
+
+    if (m_DelayedOperations & DELAYED_SAVE_PLAYER)
+        SaveToDB();
+
+    if (m_DelayedOperations & DELAYED_SPELL_CAST_DESERTER)
+        CastSpell(this, 26013, true);               // Deserter
+
+    if (m_DelayedOperations & DELAYED_BG_MOUNT_RESTORE)
+    {
+        if (m_bgData.mountSpell)
+        {
+            CastSpell(this, m_bgData.mountSpell, true);
+            m_bgData.mountSpell = 0;
+        }
+    }
+
+    if (m_DelayedOperations & DELAYED_BG_TAXI_RESTORE)
+    {
+        if (m_bgData.HasTaxiPath())
+        {
+            m_taxi.AddTaxiDestination(m_bgData.taxiPath[0]);
+            m_taxi.AddTaxiDestination(m_bgData.taxiPath[1]);
+            m_bgData.ClearTaxiPath();
+
+            ContinueTaxiFlight();
+        }
+    }
+
+    if (m_DelayedOperations & DELAYED_BG_GROUP_RESTORE)
+    {
+        if (Group* g = GetGroup())
+            g->SendUpdateToPlayer(GetGUID());
+    }
+
+    //we have executed ALL delayed ops, so clear the flag
+    m_DelayedOperations = 0;
+}
+
+void Player::AddToWorld()
+{
+    ///- Do not add/remove the player from the object storage
+    ///- It will crash when updating the ObjectAccessor
+    ///- The player should only be added when logging in
+    Unit::AddToWorld();
+
+    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
+        if (m_items[i])
+            m_items[i]->AddToWorld();
+}
+
+void Player::RemoveFromWorld()
+{
+    // cleanup
+    if (IsInWorld())
+    {
+        ///- Release charmed creatures, unsummon totems and remove pets/guardians
+        StopCastingCharm();
+        StopCastingBindSight();
+        UnsummonPetTemporaryIfAny();
+        sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
+        sBattlefieldMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
+    }
+
+    ///- Do not add/remove the player from the object storage
+    ///- It will crash when updating the ObjectAccessor
+    ///- The player should only be removed when logging out
+    Unit::RemoveFromWorld();
+
+    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
+    {
+        if (m_items[i])
+            m_items[i]->RemoveFromWorld();
+    }
+
+    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
+        iter->second->RemoveFromWorld();
+
+    if (m_uint32Values)
+    {
+        if (WorldObject* viewpoint = GetViewpoint())
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player %s has viewpoint %u %u when removed from world",
+                GetName().c_str(), viewpoint->GetEntry(), viewpoint->GetTypeId());
+            SetViewpoint(viewpoint, false);
+        }
+    }
+}
+
+void Player::RegenerateAll()
+{
+    //if (m_regenTimer <= 500)
+    //    return;
+
+    m_regenTimerCount += m_regenTimer;
+
+    if (getClass() == CLASS_PALADIN)
+        m_holyPowerRegenTimerCount += m_regenTimer;
+
+    if (getClass() == CLASS_HUNTER)
+        m_focusRegenTimerCount += m_regenTimer;
+
+    Regenerate(POWER_ENERGY);
+    Regenerate(POWER_MANA);
+    Regenerate(POWER_FOCUS);
+
+    // Runes act as cooldowns, and they don't need to send any data
+    if (getClass() == CLASS_DEATH_KNIGHT)
+    {
+        for (uint8 i = 0; i < MAX_RUNES; i += 2)
+        {
+            uint8 runeToRegen = i;
+            uint32 cd = GetRuneCooldown(i);
+            uint32 secondRuneCd = GetRuneCooldown(i + 1);
+            float cdmod = GetFloatValue(PLAYER_RUNE_REGEN_1) * 10.0f;
+            // Regenerate second rune of the same type only after first rune is off the cooldown
+            if (secondRuneCd && (cd > secondRuneCd || !cd))
+            {
+                runeToRegen = i + 1;
+                cd = secondRuneCd;
+            }
+
+            if (cd)
+                SetRuneCooldown(runeToRegen, (cd > (m_regenTimer * cdmod)) ? cd - (m_regenTimer * cdmod) : 0);
+        }
+    }
+
+    if (m_regenTimerCount >= 2000)
+    {
+        // Not in combat or they have regeneration
+        if (!isInCombat() || IsPolymorphed() || m_baseHealthRegen ||
+            HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT) ||
+            HasAuraType(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT))
+        {
+            RegenerateHealth();
+        }
+
+        Regenerate(POWER_RAGE);
+        if (getClass() == CLASS_DEATH_KNIGHT)
+            Regenerate(POWER_RUNIC_POWER);
+
+        m_regenTimerCount -= 2000;
+    }
+
+    if (m_holyPowerRegenTimerCount >= 10000 && getClass() == CLASS_PALADIN)
+    {
+        Regenerate(POWER_HOLY_POWER);
+        m_holyPowerRegenTimerCount = 0;
+    }
+
+    m_regenTimer = 0;
+}
+
+void Player::Regenerate(Powers power)
+{
+    uint32 maxValue = GetMaxPower(power);
+    if (!maxValue)
+        return;
+
+    uint32 curValue = GetPower(power);
+
+    // TODO: possible use of miscvalueb instead of amount
+    if (HasAuraTypeWithValue(SPELL_AURA_PREVENT_REGENERATE_POWER, power))
+        return;
+
+    // Skip regeneration for power type we cannot have
+    uint32 powerIndex = GetPowerIndex(power);
+    if (powerIndex == MAX_POWERS)
+        return;
+
+    float addvalue = 0.0f;
+
+    // Powers now benefit from haste.
+    float rangedHaste = GetFloatValue(PLAYER_FIELD_MOD_RANGED_HASTE);
+    float meleeHaste = GetFloatValue(PLAYER_FIELD_MOD_HASTE);
+    float spellHaste = GetFloatValue(UNIT_MOD_CAST_SPEED);
+
+    switch (power)
+    {
+        case POWER_MANA:
+        {
+            float ManaIncreaseRate = sWorld->getRate(RATE_POWER_MANA);
+
+            if (isInCombat()) // Trinity Updates Mana in intervals of 2s, which is correct
+                addvalue += GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER) *  ManaIncreaseRate * ((0.001f * m_regenTimer) + CalculatePct(0.001f, spellHaste));
+            else
+                addvalue += GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER) *  ManaIncreaseRate * ((0.001f * m_regenTimer) + CalculatePct(0.001f, spellHaste));
+        }
+        break;
+        case POWER_RAGE:                                                // Regenerate rage
+        {
+            if (!isInCombat() && !HasAuraType(SPELL_AURA_INTERRUPT_REGEN))
+            {
+                float RageDecreaseRate = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+                addvalue += -25 * RageDecreaseRate / meleeHaste;                // 2.5 rage by tick (= 2 seconds => 1.25 rage/sec)
+            }
+        }
+        break;
+        case POWER_FOCUS:
+        {
+            float haste = (1.0f / GetFloatValue(PLAYER_FIELD_MOD_HASTE_REGEN) - 1.0f) * 100.0f;
+            addvalue += (5.0f + CalculatePct(5.0f, haste)) * (m_regenTimer / 1000.0f);
+            break;
+        }
+        case POWER_ENERGY:                                              // Regenerate energy (rogue)
+        {
+            float haste = (1.0f / GetFloatValue(PLAYER_FIELD_MOD_HASTE_REGEN) - 1.0f) * 100.0f;
+            addvalue += (10.0f  + CalculatePct(10.0f, haste)) * (m_regenTimer / 1000.0f);
+            break;
+        }
+        case POWER_RUNIC_POWER:
+        {
+            if (!isInCombat() && !HasAuraType(SPELL_AURA_INTERRUPT_REGEN))
+            {
+                float RunicPowerDecreaseRate = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
+                addvalue += -30 * RunicPowerDecreaseRate;         // 3 RunicPower by tick
+            }
+        }
+        break;
+        case POWER_HOLY_POWER:                                          // Regenerate holy power
+        {
+            if (!isInCombat())
+                addvalue += -1.0f;      // remove 1 each 10 sec
+        }
+        break;
+        case POWER_RUNES:
+        case POWER_HEALTH:
+            break;
+        default:
+            break;
+    }
+
+    // Mana regen calculated in Player::UpdateManaRegen()
+    if (power != POWER_MANA && power != POWER_FOCUS && power != POWER_ENERGY)
+    {
+        AuraEffectList const& ModPowerRegenPCTAuras = GetAuraEffectsByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
+        for (AuraEffectList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
+            if (Powers((*i)->GetMiscValue()) == power)
+                AddPct(addvalue, (*i)->GetAmount());
+
+        // Butchery requires combat for this effect
+        if (power != POWER_RUNIC_POWER || isInCombat())
+            addvalue += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, power) * ((power != POWER_ENERGY) ? m_regenTimerCount : m_regenTimer) / (5 * IN_MILLISECONDS);
+    }
+
+    if (addvalue < 0.0f)
+    {
+        if (curValue == 0)
+            return;
+    }
+    else if (addvalue > 0.0f)
+    {
+        if (curValue == maxValue)
+            return;
+    }
+    else
+        return;
+
+    addvalue += m_powerFraction[powerIndex];
+    uint32 integerValue = uint32(fabs(addvalue));
+
+    if (addvalue < 0.0f)
+    {
+        if (curValue > integerValue)
+        {
+            curValue -= integerValue;
+            m_powerFraction[powerIndex] = addvalue + integerValue;
+        }
+        else
+        {
+            curValue = 0;
+            m_powerFraction[powerIndex] = 0;
+        }
+    }
+    else
+    {
+        curValue += integerValue;
+
+        if (curValue > maxValue)
+        {
+            curValue = maxValue;
+            m_powerFraction[powerIndex] = 0;
+        }
+        else
+            m_powerFraction[powerIndex] = addvalue - integerValue;
+    }
+    SetInt32Value(UNIT_FIELD_POWER1 + powerIndex, curValue);
+
+    if (GetGroup())
+        SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);
+}
+
+void Player::RegenerateHealth()
+{
+    uint32 curValue = GetHealth();
+    uint32 maxValue = GetMaxHealth();
+
+    if (curValue >= maxValue)
+        return;
+
+    float HealthIncreaseRate = sWorld->getRate(RATE_HEALTH);
+    float addvalue = 0.0f;
+
+    // polymorphed case
+    if (IsPolymorphed())
+        addvalue = (float)GetMaxHealth()/3;
+    // normal regen case (maybe partly in combat case)
+    else if (!isInCombat() || HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+    {
+        addvalue = HealthIncreaseRate;
+        if (!isInCombat())
+        {
+            if (getLevel() < 15)
+                addvalue = (0.20f*((float)GetMaxHealth())/getLevel()*HealthIncreaseRate);
+            else
+                addvalue = 0.015f*((float)GetMaxHealth())*HealthIncreaseRate;
+
+            AuraEffectList const& mModHealthRegenPct = GetAuraEffectsByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
+            for (AuraEffectList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
+                AddPct(addvalue, (*i)->GetAmount());
+
+            addvalue += GetTotalAuraModifier(SPELL_AURA_MOD_REGEN) * 2 * IN_MILLISECONDS / (5 * IN_MILLISECONDS);
+        }
+        else if (HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+            ApplyPct(addvalue, GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT));
+
+        if (!IsStandState())
+            addvalue *= 1.5f;
+    }
+
+    // always regeneration bonus (including combat)
+    addvalue += GetTotalAuraModifier(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT);
+    addvalue += m_baseHealthRegen / 2.5f;
+
+    if (addvalue < 0)
+        addvalue = 0;
+
+    ModifyHealth(int32(addvalue));
+}
+
+bool Player::CanInteractWithQuestGiver(Object* questGiver)
+{
+    switch (questGiver->GetTypeId())
+    {
+        case TYPEID_UNIT:
+            return GetNPCIfCanInteractWith(questGiver->GetGUID(), UNIT_NPC_FLAG_QUESTGIVER) != NULL;
+        case TYPEID_GAMEOBJECT:
+            return GetGameObjectIfCanInteractWith(questGiver->GetGUID(), GAMEOBJECT_TYPE_QUESTGIVER) != NULL;
+        case TYPEID_PLAYER:
+            return isAlive() && questGiver->ToPlayer()->isAlive();
+        case TYPEID_ITEM:
+            return isAlive();
+        default:
+            break;
+    }
+    return false;
+}
+
+Creature* Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
+{
+    // unit checks
+    if (!guid)
+        return NULL;
+
+    if (!IsInWorld())
+        return NULL;
+
+    if (isInFlight())
+        return NULL;
+
+    // exist (we need look pets also for some interaction (quest/etc)
+    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
+    if (!creature)
+        return NULL;
+
+    // Deathstate checks
+    if (!isAlive() && !(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_GHOST))
+        return NULL;
+
+    // alive or spirit healer
+    if (!creature->isAlive() && !(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_DEAD_INTERACT))
+        return NULL;
+
+    // appropriate npc type
+    if (npcflagmask && !creature->HasFlag(UNIT_NPC_FLAGS, npcflagmask))
+        return NULL;
+
+    // not allow interaction under control, but allow with own pets
+    if (creature->GetCharmerGUID())
+        return NULL;
+
+    // not enemy
+    if (creature->IsHostileTo(this))
+        return NULL;
+
+    // not unfriendly
+    if (FactionTemplateEntry const* factionTemplate = sFactionTemplateStore.LookupEntry(creature->getFaction()))
+        if (factionTemplate->faction)
+            if (FactionEntry const* faction = sFactionStore.LookupEntry(factionTemplate->faction))
+                if (faction->reputationListID >= 0 && GetReputationMgr().GetRank(faction) <= REP_UNFRIENDLY)
+                    return NULL;
+
+    // not too far
+    if (!creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
+        return NULL;
+
+    return creature;
+}
+
+GameObject* Player::GetGameObjectIfCanInteractWith(uint64 guid, GameobjectTypes type) const
+{
+    if (GameObject* go = GetMap()->GetGameObject(guid))
+    {
+        if (go->GetGoType() == type)
+        {
+            float maxdist;
+            switch (type)
+            {
+                // TODO: find out how the client calculates the maximal usage distance to spellless working
+                // gameobjects like guildbanks and mailboxes - 10.0 is a just an abitrary choosen number
+                case GAMEOBJECT_TYPE_GUILD_BANK:
+                case GAMEOBJECT_TYPE_MAILBOX:
+                    maxdist = 10.0f;
+                    break;
+                case GAMEOBJECT_TYPE_FISHINGHOLE:
+                    maxdist = 20.0f + CONTACT_DISTANCE;       // max spell range
+                    break;
+                case GAMEOBJECT_TYPE_QUESTGIVER:
+                    maxdist = INTERACTION_DISTANCE + go->GetFloatValue(OBJECT_FIELD_SCALE_X);
+                    break;
+                default:
+                    maxdist = INTERACTION_DISTANCE;
+                    break;
+            }
+
+            if (go->IsWithinDistInMap(this, maxdist))
+                return go;
+
+            sLog->outDebug(LOG_FILTER_MAPS, "IsGameObjectOfTypeInRange: GameObject '%s' [GUID: %u] is too far away from player %s [GUID: %u] to be used by him (distance=%f, maximal 10 is allowed)",
+                           go->GetGOInfo()->name.c_str(),
+                           go->GetGUIDLow(), GetName().c_str(), GetGUIDLow(), go->GetDistance(this));
+        }
+    }
+    return NULL;
+}
+
+bool Player::IsUnderWater() const
+{
+    return IsInWater() &&
+        GetPositionZ() < (GetBaseMap()->GetWaterLevel(GetPositionX(), GetPositionY())-2);
+}
+
+void Player::SetInWater(bool apply)
+{
+    if (m_isInWater == apply)
+        return;
+
+    //define player in water by opcodes
+    //move player's guid into HateOfflineList of those mobs
+    //which can't swim and move guid back into ThreatList when
+    //on surface.
+    //TODO: exist also swimming mobs, and function must be symmetric to enter/leave water
+    m_isInWater = apply;
+
+    // remove auras that need water/land
+    RemoveAurasWithInterruptFlags(apply ? AURA_INTERRUPT_FLAG_NOT_ABOVEWATER : AURA_INTERRUPT_FLAG_NOT_UNDERWATER);
+
+    getHostileRefManager().updateThreatTables();
+}
+
+void Player::SetGameMaster(bool on)
+{
+    if (on)
+    {
+        m_ExtraFlags |= PLAYER_EXTRA_GM_ON;
+        setFaction(35);
+        SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_GM);
+        SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);
+
+        if (Pet* pet = GetPet())
+        {
+            pet->setFaction(35);
+            pet->getHostileRefManager().setOnlineOfflineState(false);
+        }
+
+        RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+        ResetContestedPvP();
+
+        getHostileRefManager().setOnlineOfflineState(false);
+        CombatStopWithPets();
+
+        SetPhaseMask(uint32(PHASEMASK_ANYWHERE), false);    // see and visible in all phases
+        m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, GetSession()->GetSecurity());
+    }
+    else
+    {
+        m_ExtraFlags &= ~ PLAYER_EXTRA_GM_ON;
+        setFactionForRace(getRace());
+        RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_GM);
+        RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);
+
+        if (Pet* pet = GetPet())
+        {
+            pet->setFaction(getFaction());
+            pet->getHostileRefManager().setOnlineOfflineState(true);
+        }
+
+        // restore FFA PvP Server state
+        if (sWorld->IsFFAPvPRealm())
+            SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+
+        // restore FFA PvP area state, remove not allowed for GM mounts
+        UpdateArea(m_areaUpdateId);
+
+        getHostileRefManager().setOnlineOfflineState(true);
+        m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
+
+        phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_SERVERSIDE_CHANGED);
+        phaseMgr.Update();
+    }
+
+    UpdateObjectVisibility();
+}
+
+void Player::SetGMVisible(bool on)
+{
+    if (on)
+    {
+        m_ExtraFlags &= ~PLAYER_EXTRA_GM_INVISIBLE;         //remove flag
+        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
+    }
+    else
+    {
+        m_ExtraFlags |= PLAYER_EXTRA_GM_INVISIBLE;          //add flag
+
+        SetAcceptWhispers(false);
+        SetGameMaster(true);
+
+        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, GetSession()->GetSecurity());
+    }
+}
+
+bool Player::IsGroupVisibleFor(Player const* p) const
+{
+    switch (sWorld->getIntConfig(CONFIG_GROUP_VISIBILITY))
+    {
+        default: return IsInSameGroupWith(p);
+        case 1:  return IsInSameRaidWith(p);
+        case 2:  return GetTeam() == p->GetTeam();
+    }
+}
+
+bool Player::IsInSameGroupWith(Player const* p) const
+{
+    return p == this || (GetGroup() != NULL &&
+        GetGroup() == p->GetGroup() &&
+        GetGroup()->SameSubGroup(this, p));
+}
+
+///- If the player is invited, remove him. If the group if then only 1 person, disband the group.
+/// \todo Shouldn't we also check if there is no other invitees before disbanding the group?
+void Player::UninviteFromGroup()
+{
+    Group* group = GetGroupInvite();
+    if (!group)
+        return;
+
+    group->RemoveInvite(this);
+
+    if (group->GetMembersCount() <= 1)                       // group has just 1 member => disband
+    {
+        if (group->IsCreated())
+        {
+            group->Disband(true);
+        }
+        else
+        {
+            group->RemoveAllInvites();
+            delete group;
+        }
+    }
+}
+
+void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* = GROUP_REMOVEMETHOD_DEFAULT*/, uint64 kicker /* = 0 */, const char* reason /* = NULL */)
+{
+    if (group)
+    {
+        group->RemoveMember(guid, method, kicker, reason);
+        group = NULL;
+    }
+}
+
+void Player::SendLogXPGain(uint32 GivenXP, Unit* victim, uint32 BonusXP, bool recruitAFriend, float /*group_rate*/)
+{
+    WorldPacket data(SMSG_LOG_XPGAIN, 21); // guess size?
+    data << uint64(victim ? victim->GetGUID() : 0);         // guid
+    data << uint32(GivenXP + BonusXP);                      // given experience
+    data << uint8(victim ? 0 : 1);                          // 00-kill_xp type, 01-non_kill_xp type
+
+    if (victim)
+    {
+        data << uint32(GivenXP);                            // experience without bonus
+
+        // should use group_rate here but can't figure out how
+        data << float(1);                                   // 1 - none 0 - 100% group bonus output
+    }
+
+    data << uint8(recruitAFriend ? 1 : 0);                  // does the GivenXP include a RaF bonus?
+    GetSession()->SendPacket(&data);
+}
+
+void Player::GiveXP(uint32 xp, Unit* victim, float group_rate)
+{
+    if (xp < 1)
+        return;
+
+    if (!isAlive() && !GetBattlegroundId())
+        return;
+
+    if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_NO_XP_GAIN))
+        return;
+
+    if (victim && victim->GetTypeId() == TYPEID_UNIT && !victim->ToCreature()->hasLootRecipient())
+        return;
+
+    uint8 level = getLevel();
+
+    sScriptMgr->OnGivePlayerXP(this, xp, victim);
+
+    // Favored experience increase START
+    uint32 zone = GetZoneId();
+    float favored_exp_mult = 0;
+    if ((HasAura(32096) || HasAura(32098)) && (zone == 3483 || zone == 3562 || zone == 3836 || zone == 3713 || zone == 3714))
+        favored_exp_mult = 0.05f; // Thrallmar's Favor and Honor Hold's Favor
+    xp = uint32(xp * (1 + favored_exp_mult));
+    // Favored experience increase END
+
+    // XP to money conversion processed in Player::RewardQuest
+    if (level >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        return;
+
+    uint32 bonus_xp = 0;
+    bool recruitAFriend = GetsRecruitAFriendBonus(true);
+
+    // RaF does NOT stack with rested experience
+    if (recruitAFriend)
+        bonus_xp = 2 * xp; // xp + bonus_xp must add up to 3 * xp for RaF; calculation for quests done client-side
+    else
+        bonus_xp = victim ? GetXPRestBonus(xp) : 0; // XP resting bonus
+
+    SendLogXPGain(xp, victim, bonus_xp, recruitAFriend, group_rate);
+
+    uint32 curXP = GetUInt32Value(PLAYER_XP);
+    uint32 nextLvlXP = GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+    uint32 newXP = curXP + xp + bonus_xp;
+
+    while (newXP >= nextLvlXP && level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+    {
+        newXP -= nextLvlXP;
+
+        if (level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+            GiveLevel(level + 1);
+
+        level = getLevel();
+        nextLvlXP = GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+    }
+
+    SetUInt32Value(PLAYER_XP, newXP);
+}
+
+// Update player to next level
+// Current player experience not update (must be update by caller)
+void Player::GiveLevel(uint8 level)
+{
+    uint8 oldLevel = getLevel();
+    if (level == oldLevel)
+        return;
+
+    if (Guild* guild = GetGuild())
+        guild->UpdateMemberData(this, GUILD_MEMBER_DATA_LEVEL, level);
+
+    PlayerLevelInfo info;
+    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), level, &info);
+
+    uint32 basehp = 0, basemana = 0;
+    sObjectMgr->GetPlayerClassLevelInfo(getClass(), level, basehp, basemana);
+
+    // send levelup info to client
+    WorldPacket data(SMSG_LEVELUP_INFO, (4+4+MAX_POWERS_PER_CLASS*4+MAX_STATS*4));
+    data << uint32(level);
+    data << uint32(int32(basehp) - int32(GetCreateHealth()));
+    // for (int i = 0; i < MAX_STORED_POWERS; ++i)          // Powers loop (0-10)
+    data << uint32(int32(basemana)   - int32(GetCreateMana()));
+    data << uint32(0);
+    data << uint32(0);
+    data << uint32(0);
+    data << uint32(0);
+    // end for
+    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)       // Stats loop (0-4)
+        data << uint32(int32(info.stats[i]) - GetCreateStat(Stats(i)));
+
+    GetSession()->SendPacket(&data);
+
+    SetUInt32Value(PLAYER_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(level));
+
+    //update level, max level of skills
+    m_Played_time[PLAYED_TIME_LEVEL] = 0;                   // Level Played Time reset
+
+    _ApplyAllLevelScaleItemMods(false);
+
+    SetLevel(level);
+
+    UpdateSkillsForLevel();
+
+    // save base values (bonuses already included in stored stats
+    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
+        SetCreateStat(Stats(i), info.stats[i]);
+
+    SetCreateHealth(basehp);
+    SetCreateMana(basemana);
+
+    InitTalentForLevel();
+    InitTaxiNodesForLevel();
+    InitGlyphsForLevel();
+
+    UpdateAllStats();
+
+    if (sWorld->getBoolConfig(CONFIG_ALWAYS_MAXSKILL)) // Max weapon skill when leveling up
+        UpdateSkillsToMaxSkillsForLevel();
+
+    _ApplyAllLevelScaleItemMods(true); // Moved to above SetFullHealth so player will have full health from Heirlooms
+
+    // set current level health and mana/energy to maximum after applying all mods.
+    SetFullHealth();
+    SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
+    if (GetPower(POWER_RAGE) > GetMaxPower(POWER_RAGE))
+        SetPower(POWER_RAGE, GetMaxPower(POWER_RAGE));
+    SetPower(POWER_FOCUS, 0);
+
+    // update level to hunter/summon pet
+    if (Pet* pet = GetPet())
+        pet->SynchronizeLevelWithOwner();
+
+    if (MailLevelReward const* mailReward = sObjectMgr->GetMailLevelReward(level, getRaceMask()))
+    {
+        //- TODO: Poor design of mail system
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        MailDraft(mailReward->mailTemplateId).SendMailTo(trans, this, MailSender(MAIL_CREATURE, mailReward->senderEntry));
+        CharacterDatabase.CommitTransaction(trans);
+    }
+
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_LEVEL);
+    UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_LEVEL);
+
+    PhaseUpdateData phaseUdateData;
+    phaseUdateData.AddConditionType(CONDITION_LEVEL);
+
+    // Learn Running wild and Apprentice Riding to worgens that reach level 20
+    if (level == 20 && getRace() == RACE_WORGEN)
+    {
+        learnSpell(87840, false); // Running wild
+        learnSpell(33388, false); // Apprentice Riding
+    }
+
+    phaseMgr.NotifyConditionChanged(phaseUdateData);
+
+    // Refer-A-Friend
+    if (GetSession()->GetRecruiterId())
+        if (level < sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL))
+            if (level % 2 == 0)
+            {
+                ++m_grantableLevels;
+
+                if (!HasByteFlag(PLAYER_FIELD_BYTES, 1, 0x01))
+                    SetByteFlag(PLAYER_FIELD_BYTES, 1, 0x01);
+            }
+
+    sScriptMgr->OnPlayerLevelChanged(this, oldLevel);
+}
+
+void Player::InitTalentForLevel()
+{
+    uint8 level = getLevel();
+    // talents base at level diff (talents = level - 9 but some can be used already)
+    if (level < 10)
+    {
+        // Remove all talent points
+        if (GetUsedTalentCount() > 0)                           // Free any used talents
+        {
+            ResetTalents(true);
+            SetFreeTalentPoints(0);
+        }
+    }
+    else
+    {
+        if (level < sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL) || GetSpecsCount() == 0)
+        {
+            SetSpecsCount(1);
+            SetActiveSpec(0);
+        }
+
+        uint32 talentPointsForLevel = CalculateTalentsPoints();
+
+        // if used more that have then reset
+        if (GetUsedTalentCount() > talentPointsForLevel)
+        {
+            if (!AccountMgr::IsAdminAccount(GetSession()->GetSecurity()))
+                ResetTalents(true);
+            else
+                SetFreeTalentPoints(0);
+        }
+        // else update amount of free points
+        else
+            SetFreeTalentPoints(talentPointsForLevel - GetUsedTalentCount());
+    }
+
+    if (!GetSession()->PlayerLoading())
+        SendTalentsInfoData(false);                         // update at client
+}
+
+// Horrible implementation
+void Player::CheckLevelDependantSpells()
+{
+    uint8 level = getLevel();
+    // Learn Proper Glyph unlearn spell
+    if (level >= 80)
+    {
+        removeSpell(89964);
+        learnSpell(90647, false);
+    }
+}
+
+void Player::InitStatsForLevel(bool reapplyMods)
+{
+    if (reapplyMods)                                        //reapply stats values only on .reset stats (level) command
+        _RemoveAllStatBonuses();
+
+    uint32 basehp = 0, basemana = 0;
+    sObjectMgr->GetPlayerClassLevelInfo(getClass(), getLevel(), basehp, basemana);
+
+    PlayerLevelInfo info;
+    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), getLevel(), &info);
+
+    SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
+    SetUInt32Value(PLAYER_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(getLevel()));
+
+    // reset before any aura state sources (health set/aura apply)
+    SetUInt32Value(UNIT_FIELD_AURASTATE, 0);
+
+    UpdateSkillsForLevel();
+
+    // set default cast time multiplier
+    SetFloatValue(UNIT_MOD_CAST_SPEED, 1.0f);
+    SetFloatValue(UNIT_MOD_CAST_HASTE, 1.0f);
+    SetFloatValue(PLAYER_FIELD_MOD_HASTE, 1.0f);
+    SetFloatValue(PLAYER_FIELD_MOD_RANGED_HASTE, 1.0f);
+
+    // reset size before reapply auras
+    SetObjectScale(1.0f);
+
+    // save base values (bonuses already included in stored stats
+    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
+        SetCreateStat(Stats(i), info.stats[i]);
+
+    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
+        SetStat(Stats(i), info.stats[i]);
+
+    SetCreateHealth(basehp);
+
+    //set create powers
+    SetCreateMana(basemana);
+
+    SetArmor(int32(m_createStats[STAT_AGILITY]*2));
+
+    InitStatBuffMods();
+
+    //reset rating fields values
+    for (uint16 index = PLAYER_FIELD_COMBAT_RATING_1; index < PLAYER_FIELD_COMBAT_RATING_1 + MAX_COMBAT_RATING; ++index)
+        SetUInt32Value(index, 0);
+
+    SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, 0);
+    SetFloatValue(PLAYER_FIELD_MOD_HEALING_PCT, 1.0f);
+    SetFloatValue(PLAYER_FIELD_MOD_HEALING_DONE_PCT, 1.0f);
+    for (uint8 i = 0; i < 7; ++i)
+    {
+        SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+i, 0);
+        SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i, 0);
+        SetFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PCT+i, 1.0f);
+    }
+
+    SetFloatValue(PLAYER_FIELD_MOD_SPELL_POWER_PCT, 1.0f);
+    SetFloatValue(PLAYER_FIELD_OVERRIDE_SPELL_POWER_BY_AP_PCT, 0.0f);
+    SetFloatValue(PLAYER_FIELD_MOD_HASTE_REGEN, 1.0f);
+
+    //reset attack power, damage and attack speed fields
+    SetFloatValue(UNIT_FIELD_BASEATTACKTIME, 2000.0f);
+    SetFloatValue(UNIT_FIELD_BASEATTACKTIME + 1, 2000.0f); // offhand attack time
+    SetFloatValue(UNIT_FIELD_RANGEDATTACKTIME, 2000.0f);
+
+    SetFloatValue(UNIT_FIELD_MINDAMAGE, 0.0f);
+    SetFloatValue(UNIT_FIELD_MAXDAMAGE, 0.0f);
+    SetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE, 0.0f);
+    SetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE, 0.0f);
+    SetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE, 0.0f);
+    SetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE, 0.0f);
+    SetFloatValue(PLAYER_FIELD_WEAPON_DMG_MULTIPLIERS, 1.0f);
+
+    SetInt32Value(UNIT_FIELD_ATTACK_POWER,            0);
+    SetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER, 0.0f);
+    SetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER,     0);
+    SetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER, 0.0f);
+
+    // Base crit values (will be recalculated in UpdateAllStats() at loading and in _ApplyAllStatBonuses() at reset
+    SetFloatValue(PLAYER_CRIT_PERCENTAGE, 0.0f);
+    SetFloatValue(PLAYER_OFFHAND_CRIT_PERCENTAGE, 0.0f);
+    SetFloatValue(PLAYER_RANGED_CRIT_PERCENTAGE, 0.0f);
+
+    // Init spell schools (will be recalculated in UpdateAllStats() at loading and in _ApplyAllStatBonuses() at reset
+    for (uint8 i = 0; i < 7; ++i)
+        SetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1+i, 0.0f);
+
+    SetFloatValue(PLAYER_PARRY_PERCENTAGE, 0.0f);
+    SetFloatValue(PLAYER_BLOCK_PERCENTAGE, 0.0f);
+
+    // Static 30% damage blocked
+    SetUInt32Value(PLAYER_SHIELD_BLOCK, 30);
+
+    // Dodge percentage
+    SetFloatValue(PLAYER_DODGE_PERCENTAGE, 0.0f);
+
+    // set armor (resistance 0) to original value (create_agility*2)
+    SetArmor(int32(m_createStats[STAT_AGILITY]*2));
+    SetResistanceBuffMods(SpellSchools(0), true, 0.0f);
+    SetResistanceBuffMods(SpellSchools(0), false, 0.0f);
+    // set other resistance to original value (0)
+    for (uint8 i = 1; i < MAX_SPELL_SCHOOL; ++i)
+    {
+        SetResistance(SpellSchools(i), 0);
+        SetResistanceBuffMods(SpellSchools(i), true, 0.0f);
+        SetResistanceBuffMods(SpellSchools(i), false, 0.0f);
+    }
+
+    SetUInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, 0);
+    SetUInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE, 0);
+    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
+    {
+        SetUInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i, 0);
+        SetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+i, 0.0f);
+    }
+    // Reset no reagent cost field
+    for (uint8 i = 0; i < 3; ++i)
+        SetUInt32Value(PLAYER_NO_REAGENT_COST_1 + i, 0);
+    // Init data for form but skip reapply item mods for form
+    InitDataForForm(reapplyMods);
+
+    // save new stats
+    for (uint8 i = POWER_MANA; i < MAX_POWERS; ++i)
+        SetMaxPower(Powers(i), GetCreatePowers(Powers(i)));
+
+    SetMaxHealth(basehp);                     // stamina bonus will applied later
+
+    // cleanup mounted state (it will set correctly at aura loading if player saved at mount.
+    SetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID, 0);
+
+    // cleanup unit flags (will be re-applied if need at aura load).
+    RemoveFlag(UNIT_FIELD_FLAGS,
+        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_ATTACKABLE_1 |
+        UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC  | UNIT_FLAG_LOOTING          |
+        UNIT_FLAG_PET_IN_COMBAT  | UNIT_FLAG_SILENCED     | UNIT_FLAG_PACIFIED         |
+        UNIT_FLAG_STUNNED        | UNIT_FLAG_IN_COMBAT    | UNIT_FLAG_DISARMED         |
+        UNIT_FLAG_CONFUSED       | UNIT_FLAG_FLEEING      | UNIT_FLAG_NOT_SELECTABLE   |
+        UNIT_FLAG_SKINNABLE      | UNIT_FLAG_MOUNT        | UNIT_FLAG_TAXI_FLIGHT      );
+    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);   // must be set
+
+    SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);// must be set
+
+    // cleanup player flags (will be re-applied if need at aura load), to avoid have ghost flag without ghost aura, for example.
+    RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_AFK | PLAYER_FLAGS_DND | PLAYER_FLAGS_GM | PLAYER_FLAGS_GHOST | PLAYER_ALLOW_ONLY_ABILITY);
+
+    RemoveStandFlags(UNIT_STAND_FLAGS_ALL);                 // one form stealth modified bytes
+    RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP | UNIT_BYTE2_FLAG_SANCTUARY);
+
+    // restore if need some important flags
+    SetUInt32Value(PLAYER_FIELD_BYTES2, 0);                 // flags empty by default
+
+    if (reapplyMods)                                        // reapply stats values only on .reset stats (level) command
+        _ApplyAllStatBonuses();
+
+    // set current level health and mana/energy to maximum after applying all mods.
+    SetFullHealth();
+    SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
+    if (GetPower(POWER_RAGE) > GetMaxPower(POWER_RAGE))
+        SetPower(POWER_RAGE, GetMaxPower(POWER_RAGE));
+    SetPower(POWER_FOCUS, GetMaxPower(POWER_FOCUS));
+    SetPower(POWER_RUNIC_POWER, 0);
+
+    // update level to hunter/summon pet
+    if (Pet* pet = GetPet())
+        pet->SynchronizeLevelWithOwner();
+}
+
+void Player::SendInitialSpells()
+{
+    time_t curTime = time(NULL);
+    time_t infTime = curTime + infinityCooldownDelayCheck;
+
+    uint16 spellCount = 0;
+
+    WorldPacket data(SMSG_INITIAL_SPELLS, (1+2+4*m_spells.size()+2+m_spellCooldowns.size()*(2+2+2+4+4)));
+    data << uint8(0);
+
+    size_t countPos = data.wpos();
+    data << uint16(spellCount);                             // spell count placeholder
+
+    for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
+    {
+        if (itr->second->state == PLAYERSPELL_REMOVED)
+            continue;
+
+        if (!itr->second->active || itr->second->disabled)
+            continue;
+
+        data << uint32(itr->first);
+        data << uint16(0);                                  // it's not slot id
+
+        ++spellCount;
+    }
+
+    data.put<uint16>(countPos, spellCount);                  // write real count value
+
+    uint16 spellCooldowns = m_spellCooldowns.size();
+    data << uint16(spellCooldowns);
+    for (SpellCooldowns::const_iterator itr = m_spellCooldowns.begin(); itr != m_spellCooldowns.end(); ++itr)
+    {
+        SpellInfo const* sEntry = sSpellMgr->GetSpellInfo(itr->first);
+        if (!sEntry)
+            continue;
+
+        data << uint32(itr->first);
+
+        data << uint32(itr->second.itemid);                 // cast item id
+        data << uint16(sEntry->Category);                   // spell category
+
+        // send infinity cooldown in special format
+        if (itr->second.end >= infTime)
+        {
+            data << uint32(1);                              // cooldown
+            data << uint32(0x80000000);                     // category cooldown
+            continue;
+        }
+
+        time_t cooldown = itr->second.end > curTime ? (itr->second.end-curTime)*IN_MILLISECONDS : 0;
+
+        if (sEntry->Category)                                // may be wrong, but anyway better than nothing...
+        {
+            data << uint32(0);                              // cooldown
+            data << uint32(cooldown);                       // category cooldown
+        }
+        else
+        {
+            data << uint32(cooldown);                       // cooldown
+            data << uint32(0);                              // category cooldown
+        }
+    }
+
+    GetSession()->SendPacket(&data);
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "CHARACTER: Sent Initial Spells");
+}
+
+void Player::RemoveMail(uint32 id)
+{
+    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
+    {
+        if ((*itr)->messageID == id)
+        {
+            //do not delete item, because Player::removeMail() is called when returning mail to sender.
+            m_mail.erase(itr);
+            return;
+        }
+    }
+}
+
+void Player::SendMailResult(uint32 mailId, MailResponseType mailAction, MailResponseResult mailError, uint32 equipError, uint32 item_guid, uint32 item_count)
+{
+    WorldPacket data(SMSG_SEND_MAIL_RESULT, (4+4+4+(mailError == MAIL_ERR_EQUIP_ERROR?4:(mailAction == MAIL_ITEM_TAKEN?4+4:0))));
+    data << uint32(mailId);
+    data << uint32(mailAction);
+    data << uint32(mailError);
+    if (mailError == MAIL_ERR_EQUIP_ERROR)
+        data << uint32(equipError);
+    else if (mailAction == MAIL_ITEM_TAKEN)
+    {
+        data << uint32(item_guid);                         // item guid low?
+        data << uint32(item_count);                        // item count?
+    }
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendNewMail()
+{
+    // deliver undelivered mail
+    WorldPacket data(SMSG_RECEIVED_MAIL, 4);
+    data << (uint32) 0;
+    GetSession()->SendPacket(&data);
+}
+
+void Player::UpdateNextMailTimeAndUnreads()
+{
+    // calculate next delivery time (min. from non-delivered mails
+    // and recalculate unReadMail
+    time_t cTime = time(NULL);
+    m_nextMailDelivereTime = 0;
+    unReadMails = 0;
+    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
+    {
+        if ((*itr)->deliver_time > cTime)
+        {
+            if (!m_nextMailDelivereTime || m_nextMailDelivereTime > (*itr)->deliver_time)
+                m_nextMailDelivereTime = (*itr)->deliver_time;
+        }
+        else if (((*itr)->checked & MAIL_CHECK_MASK_READ) == 0)
+            ++unReadMails;
+    }
+}
+
+void Player::AddNewMailDeliverTime(time_t deliver_time)
+{
+    if (deliver_time <= time(NULL))                          // ready now
+    {
+        ++unReadMails;
+        SendNewMail();
+    }
+    else                                                    // not ready and no have ready mails
+    {
+        if (!m_nextMailDelivereTime || m_nextMailDelivereTime > deliver_time)
+            m_nextMailDelivereTime = deliver_time;
+    }
+}
+
+void DeleteSpellFromAllPlayers(uint32 spellId)
+{
+    CharacterDatabaseStatements stmts[2] = {CHAR_DEL_INVALID_SPELL_SPELLS, CHAR_DEL_INVALID_SPELL_TALENTS};
+    for (uint8 i = 0; i < 2; i++)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(stmts[i]);
+
+        stmt->setUInt32(0, spellId);
+
+        CharacterDatabase.Execute(stmt);
+    }
+}
+
+bool Player::AddTalent(uint32 spellId, uint8 spec, bool learning)
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        // do character spell book cleanup (all characters)
+        if (!IsInWorld() && !learning)                       // spell load case
+        {
+            sLog->outError(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Non-existed in SpellStore spell #%u request, deleting for all characters in `character_spell`.", spellId);
+
+            DeleteSpellFromAllPlayers(spellId);
+        }
+        else
+            sLog->outError(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Non-existed in SpellStore spell #%u request.", spellId);
+
+        return false;
+    }
+
+    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
+    {
+        // do character spell book cleanup (all characters)
+        if (!IsInWorld() && !learning)                       // spell load case
+        {
+            sLog->outError(LOG_FILTER_SPELLS_AURAS, "Player::addTalent: Broken spell #%u learning not allowed, deleting for all characters in `character_talent`.", spellId);
+
+            DeleteSpellFromAllPlayers(spellId);
+        }
+        else
+            sLog->outError(LOG_FILTER_SPELLS_AURAS, "Player::addTalent: Broken spell #%u learning not allowed.", spellId);
+
+        return false;
+    }
+
+    PlayerTalentMap::iterator itr = GetTalentMap(spec)->find(spellId);
+    if (itr != GetTalentMap(spec)->end())
+        itr->second->state = PLAYERSPELL_UNCHANGED;
+    else if (TalentSpellPos const* talentPos = GetTalentSpellPos(spellId))
+    {
+        if (TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentPos->talent_id))
+        {
+            for (uint8 rank = 0; rank < MAX_TALENT_RANK; ++rank)
+            {
+                // skip learning spell and no rank spell case
+                uint32 rankSpellId = talentInfo->RankID[rank];
+                if (!rankSpellId || rankSpellId == spellId)
+                    continue;
+
+                itr = GetTalentMap(spec)->find(rankSpellId);
+                if (itr != GetTalentMap(spec)->end())
+                    itr->second->state = PLAYERSPELL_REMOVED;
+            }
+        }
+
+        PlayerSpellState state = learning ? PLAYERSPELL_NEW : PLAYERSPELL_UNCHANGED;
+        PlayerTalent* newtalent = new PlayerTalent();
+
+        newtalent->state = state;
+        newtalent->spec = spec;
+
+        (*GetTalentMap(spec))[spellId] = newtalent;
+        return true;
+    }
+    return false;
+}
+
+bool Player::addSpell(uint32 spellId, bool active, bool learning, bool dependent, bool disabled, bool loading /*= false*/)
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        // do character spell book cleanup (all characters)
+        if (!IsInWorld() && !learning)                       // spell load case
+        {
+            sLog->outError(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Non-existed in SpellStore spell #%u request, deleting for all characters in `character_spell`.", spellId);
+
+            DeleteSpellFromAllPlayers(spellId);
+        }
+        else
+            sLog->outError(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Non-existed in SpellStore spell #%u request.", spellId);
+
+        return false;
+    }
+
+    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
+    {
+        // do character spell book cleanup (all characters)
+        if (!IsInWorld() && !learning)                       // spell load case
+        {
+            sLog->outError(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Broken spell #%u learning not allowed, deleting for all characters in `character_spell`.", spellId);
+
+            DeleteSpellFromAllPlayers(spellId);
+        }
+        else
+            sLog->outError(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Broken spell #%u learning not allowed.", spellId);
+
+        return false;
+    }
+
+    PlayerSpellState state = learning ? PLAYERSPELL_NEW : PLAYERSPELL_UNCHANGED;
+
+    bool dependent_set = false;
+    bool disabled_case = false;
+    bool superceded_old = false;
+
+    PlayerSpellMap::iterator itr = m_spells.find(spellId);
+
+    // Remove temporary spell if found to prevent conflicts
+    if (itr != m_spells.end() && itr->second->state == PLAYERSPELL_TEMPORARY)
+        RemoveTemporarySpell(spellId);
+    else if (itr != m_spells.end())
+    {
+        uint32 next_active_spell_id = 0;
+        // fix activate state for non-stackable low rank (and find next spell for !active case)
+        if (!spellInfo->IsStackableWithRanks() && spellInfo->IsRanked())
+        {
+            if (uint32 next = sSpellMgr->GetNextSpellInChain(spellId))
+            {
+                if (HasSpell(next))
+                {
+                    // high rank already known so this must !active
+                    active = false;
+                    next_active_spell_id = next;
+                }
+            }
+        }
+
+        // not do anything if already known in expected state
+        if (itr->second->state != PLAYERSPELL_REMOVED && itr->second->active == active &&
+            itr->second->dependent == dependent && itr->second->disabled == disabled)
+        {
+            if (!IsInWorld() && !learning)                   // explicitly load from DB and then exist in it already and set correctly
+                itr->second->state = PLAYERSPELL_UNCHANGED;
+
+            return false;
+        }
+
+        // dependent spell known as not dependent, overwrite state
+        if (itr->second->state != PLAYERSPELL_REMOVED && !itr->second->dependent && dependent)
+        {
+            itr->second->dependent = dependent;
+            if (itr->second->state != PLAYERSPELL_NEW)
+                itr->second->state = PLAYERSPELL_CHANGED;
+            dependent_set = true;
+        }
+
+        // update active state for known spell
+        if (itr->second->active != active && itr->second->state != PLAYERSPELL_REMOVED && !itr->second->disabled)
+        {
+            itr->second->active = active;
+
+            if (!IsInWorld() && !learning && !dependent_set) // explicitly load from DB and then exist in it already and set correctly
+                itr->second->state = PLAYERSPELL_UNCHANGED;
+            else if (itr->second->state != PLAYERSPELL_NEW)
+                itr->second->state = PLAYERSPELL_CHANGED;
+
+            if (active)
+            {
+                if (spellInfo->IsPassive() && IsNeedCastPassiveSpellAtLearn(spellInfo))
+                    CastSpell (this, spellId, true);
+            }
+            else if (IsInWorld())
+            {
+                if (next_active_spell_id)
+                {
+                    // update spell ranks in spellbook and action bar
+                    WorldPacket data(SMSG_SUPERCEDED_SPELL, 4 + 4);
+                    data << uint32(next_active_spell_id);
+                    data << uint32(spellId);
+                    GetSession()->SendPacket(&data);
+                }
+                else
+                {
+                    WorldPacket data(SMSG_REMOVED_SPELL, 4);
+                    data << uint32(spellId);
+                    GetSession()->SendPacket(&data);
+                }
+            }
+
+            return active;                                  // learn (show in spell book if active now)
+        }
+
+        if (itr->second->disabled != disabled && itr->second->state != PLAYERSPELL_REMOVED)
+        {
+            if (itr->second->state != PLAYERSPELL_NEW)
+                itr->second->state = PLAYERSPELL_CHANGED;
+            itr->second->disabled = disabled;
+
+            if (disabled)
+                return false;
+
+            disabled_case = true;
+        }
+        else switch (itr->second->state)
+        {
+            case PLAYERSPELL_UNCHANGED:                     // known saved spell
+                return false;
+            case PLAYERSPELL_REMOVED:                       // re-learning removed not saved spell
+            {
+                delete itr->second;
+                m_spells.erase(itr);
+                state = PLAYERSPELL_CHANGED;
+                break;                                      // need re-add
+            }
+            default:                                        // known not saved yet spell (new or modified)
+            {
+                // can be in case spell loading but learned at some previous spell loading
+                if (!IsInWorld() && !learning && !dependent_set)
+                    itr->second->state = PLAYERSPELL_UNCHANGED;
+
+                return false;
+            }
+        }
+    }
+
+    if (!disabled_case) // skip new spell adding if spell already known (disabled spells case)
+    {
+        // talent: unlearn all other talent ranks (high and low)
+        if (TalentSpellPos const* talentPos = GetTalentSpellPos(spellId))
+        {
+            if (TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentPos->talent_id))
+            {
+                for (uint8 rank = 0; rank < MAX_TALENT_RANK; ++rank)
+                {
+                    // skip learning spell and no rank spell case
+                    uint32 rankSpellId = talentInfo->RankID[rank];
+                    if (!rankSpellId || rankSpellId == spellId)
+                        continue;
+
+                    removeSpell(rankSpellId, false, false);
+                }
+            }
+        }
+        // non talent spell: learn low ranks (recursive call)
+        else if (uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(spellId))
+        {
+            if (!IsInWorld() || disabled)                    // at spells loading, no output, but allow save
+                addSpell(prev_spell, active, true, true, disabled);
+            else                                            // at normal learning
+                learnSpell(prev_spell, true);
+        }
+
+        PlayerSpell* newspell = new PlayerSpell;
+        newspell->state     = state;
+        newspell->active    = active;
+        newspell->dependent = dependent;
+        newspell->disabled  = disabled;
+
+        // replace spells in action bars and spellbook to bigger rank if only one spell rank must be accessible
+        if (newspell->active && !newspell->disabled && !spellInfo->IsStackableWithRanks() && spellInfo->IsRanked() != 0)
+        {
+            for (PlayerSpellMap::iterator itr2 = m_spells.begin(); itr2 != m_spells.end(); ++itr2)
+            {
+                if (itr2->second->state == PLAYERSPELL_REMOVED)
+                    continue;
+
+                SpellInfo const* i_spellInfo = sSpellMgr->GetSpellInfo(itr2->first);
+                if (!i_spellInfo)
+                    continue;
+
+                if (spellInfo->IsDifferentRankOf(i_spellInfo))
+                {
+                    if (itr2->second->active)
+                    {
+                        if (spellInfo->IsHighRankOf(i_spellInfo))
+                        {
+                            if (IsInWorld())                 // not send spell (re-/over-)learn packets at loading
+                            {
+                                WorldPacket data(SMSG_SUPERCEDED_SPELL, 4 + 4);
+                                data << uint32(spellId);
+                                data << uint32(itr2->first);
+                                GetSession()->SendPacket(&data);
+                            }
+
+                            // mark old spell as disable (SMSG_SUPERCEDED_SPELL replace it in client by new)
+                            itr2->second->active = false;
+                            if (itr2->second->state != PLAYERSPELL_NEW)
+                                itr2->second->state = PLAYERSPELL_CHANGED;
+                            superceded_old = true;          // new spell replace old in action bars and spell book.
+                        }
+                        else
+                        {
+                            if (IsInWorld())                 // not send spell (re-/over-)learn packets at loading
+                            {
+                                WorldPacket data(SMSG_SUPERCEDED_SPELL, 4 + 4);
+                                data << uint32(itr2->first);
+                                data << uint32(spellId);
+                                GetSession()->SendPacket(&data);
+                            }
+
+                            // mark new spell as disable (not learned yet for client and will not learned)
+                            newspell->active = false;
+                            if (newspell->state != PLAYERSPELL_NEW)
+                                newspell->state = PLAYERSPELL_CHANGED;
+                        }
+                    }
+                }
+            }
+        }
+
+        m_spells[spellId] = newspell;
+
+        // return false if spell disabled
+        if (newspell->disabled)
+            return false;
+    }
+
+    uint32 talentCost = GetTalentSpellCost(spellId);
+
+    // cast talents with SPELL_EFFECT_LEARN_SPELL (other dependent spells will learned later as not auto-learned)
+    // note: all spells with SPELL_EFFECT_LEARN_SPELL isn't passive
+    if (!loading && talentCost > 0 && spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL))
+    {
+        // ignore stance requirement for talent learn spell (stance set for spell only for client spell description show)
+        CastSpell(this, spellId, true);
+    }
+    // also cast passive spells (including all talents without SPELL_EFFECT_LEARN_SPELL) with additional checks
+    else if (spellInfo->IsPassive())
+    {
+        if (IsNeedCastPassiveSpellAtLearn(spellInfo))
+            CastSpell(this, spellId, true);
+    }
+    else if (spellInfo->HasEffect(SPELL_EFFECT_SKILL_STEP))
+    {
+        CastSpell(this, spellId, true);
+        return false;
+    }
+
+    // update used talent points count
+    SetUsedTalentCount(GetUsedTalentCount() + talentCost);
+
+    // update free primary prof.points (if any, can be none in case GM .learn prof. learning)
+    if (uint32 freeProfs = GetFreePrimaryProfessionPoints())
+    {
+        if (spellInfo->IsPrimaryProfessionFirstRank())
+            SetFreePrimaryProfessions(freeProfs-1);
+    }
+
+    // add dependent skills
+    uint16 maxskill     = GetMaxSkillValueForLevel();
+
+    SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(spellId);
+
+    SkillLineAbilityMapBounds skill_bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellId);
+
+    if (spellLearnSkill)
+    {
+        uint32 skill_value = GetPureSkillValue(spellLearnSkill->skill);
+        uint32 skill_max_value = GetPureMaxSkillValue(spellLearnSkill->skill);
+
+        if (skill_value < spellLearnSkill->value)
+            skill_value = spellLearnSkill->value;
+
+        uint32 new_skill_max_value = spellLearnSkill->maxvalue == 0 ? maxskill : spellLearnSkill->maxvalue;
+
+        if (skill_max_value < new_skill_max_value)
+            skill_max_value = new_skill_max_value;
+
+        SetSkill(spellLearnSkill->skill, spellLearnSkill->step, skill_value, skill_max_value);
+    }
+    else
+    {
+        // not ranked skills
+        for (SkillLineAbilityMap::const_iterator _spell_idx = skill_bounds.first; _spell_idx != skill_bounds.second; ++_spell_idx)
+        {
+            SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(_spell_idx->second->skillId);
+            if (!pSkill)
+                continue;
+
+            if (HasSkill(pSkill->id))
+                continue;
+
+            if (_spell_idx->second->learnOnGetSkill == ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL ||
+                // lockpicking/runeforging special case, not have ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL
+                ((pSkill->id == SKILL_LOCKPICKING || pSkill->id == SKILL_RUNEFORGING) && _spell_idx->second->max_value == 0))
+            {
+                switch (GetSkillRangeType(pSkill, _spell_idx->second->racemask != 0))
+                {
+                    case SKILL_RANGE_LANGUAGE:
+                        SetSkill(pSkill->id, GetSkillStep(pSkill->id), 300, 300);
+                        break;
+                    case SKILL_RANGE_LEVEL:
+                        SetSkill(pSkill->id, GetSkillStep(pSkill->id), 1, GetMaxSkillValueForLevel());
+                        break;
+                    case SKILL_RANGE_MONO:
+                        SetSkill(pSkill->id, GetSkillStep(pSkill->id), 1, 1);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+    }
+
+    // learn dependent spells
+    SpellLearnSpellMapBounds spell_bounds = sSpellMgr->GetSpellLearnSpellMapBounds(spellId);
+
+    for (SpellLearnSpellMap::const_iterator itr2 = spell_bounds.first; itr2 != spell_bounds.second; ++itr2)
+    {
+        if (!itr2->second.autoLearned)
+        {
+            if (!IsInWorld() || !itr2->second.active)       // at spells loading, no output, but allow save
+                addSpell(itr2->second.spell, itr2->second.active, true, true, false);
+            else                                            // at normal learning
+                learnSpell(itr2->second.spell, true);
+        }
+    }
+
+    if (!GetSession()->PlayerLoading())
+    {
+        // not ranked skills
+        for (SkillLineAbilityMap::const_iterator _spell_idx = skill_bounds.first; _spell_idx != skill_bounds.second; ++_spell_idx)
+        {
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILL_LINE, _spell_idx->second->skillId);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILLLINE_SPELLS, _spell_idx->second->skillId);
+        }
+
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SPELL, spellId);
+    }
+
+    // return true (for send learn packet) only if spell active (in case ranked spells) and not replace old spell
+    return active && !disabled && !superceded_old;
+}
+
+void Player::AddTemporarySpell(uint32 spellId)
+{
+    PlayerSpellMap::iterator itr = m_spells.find(spellId);
+    // spell already added - do not do anything
+    if (itr != m_spells.end())
+        return;
+    PlayerSpell* newspell = new PlayerSpell;
+    newspell->state     = PLAYERSPELL_TEMPORARY;
+    newspell->active    = true;
+    newspell->dependent = false;
+    newspell->disabled  = false;
+    m_spells[spellId]   = newspell;
+}
+
+void Player::RemoveTemporarySpell(uint32 spellId)
+{
+    PlayerSpellMap::iterator itr = m_spells.find(spellId);
+    // spell already not in list - do not do anything
+    if (itr == m_spells.end())
+        return;
+    // spell has other state than temporary - do not change it
+    if (itr->second->state != PLAYERSPELL_TEMPORARY)
+        return;
+    delete itr->second;
+    m_spells.erase(itr);
+}
+
+bool Player::IsNeedCastPassiveSpellAtLearn(SpellInfo const* spellInfo) const
+{
+    // note: form passives activated with shapeshift spells be implemented by HandleShapeshiftBoosts instead of spell_learn_spell
+    // talent dependent passives activated at form apply have proper stance data
+    ShapeshiftForm form = GetShapeshiftForm();
+    bool need_cast = (!spellInfo->Stances || (form && (spellInfo->Stances & (1 << (form - 1)))) ||
+        (!form && (spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_NEED_SHAPESHIFT)));
+
+    //Check CasterAuraStates
+    return need_cast && (!spellInfo->CasterAuraState || HasAuraState(AuraStateType(spellInfo->CasterAuraState)));
+}
+
+void Player::learnSpell(uint32 spell_id, bool dependent)
+{
+    PlayerSpellMap::iterator itr = m_spells.find(spell_id);
+
+    bool disabled = (itr != m_spells.end()) ? itr->second->disabled : false;
+    bool active = disabled ? itr->second->active : true;
+
+    bool learning = addSpell(spell_id, active, true, dependent, false);
+
+    // prevent duplicated entires in spell book, also not send if not in world (loading)
+    if (learning && IsInWorld())
+    {
+        WorldPacket data(SMSG_LEARNED_SPELL, 8);
+        data << uint32(spell_id);
+        data << uint32(0);
+        GetSession()->SendPacket(&data);
+    }
+
+    // learn all disabled higher ranks and required spells (recursive)
+    if (disabled)
+    {
+        if (uint32 nextSpell = sSpellMgr->GetNextSpellInChain(spell_id))
+        {
+            PlayerSpellMap::iterator iter = m_spells.find(nextSpell);
+            if (iter != m_spells.end() && iter->second->disabled)
+                learnSpell(nextSpell, false);
+        }
+
+        SpellsRequiringSpellMapBounds spellsRequiringSpell = sSpellMgr->GetSpellsRequiringSpellBounds(spell_id);
+        for (SpellsRequiringSpellMap::const_iterator itr2 = spellsRequiringSpell.first; itr2 != spellsRequiringSpell.second; ++itr2)
+        {
+            PlayerSpellMap::iterator iter2 = m_spells.find(itr2->second);
+            if (iter2 != m_spells.end() && iter2->second->disabled)
+                learnSpell(itr2->second, false);
+        }
+    }
+}
+
+void Player::removeSpell(uint32 spell_id, bool disabled, bool learn_low_rank)
+{
+    PlayerSpellMap::iterator itr = m_spells.find(spell_id);
+    if (itr == m_spells.end())
+        return;
+
+    if (itr->second->state == PLAYERSPELL_REMOVED || (disabled && itr->second->disabled) || itr->second->state == PLAYERSPELL_TEMPORARY)
+        return;
+
+    // unlearn non talent higher ranks (recursive)
+    if (uint32 nextSpell = sSpellMgr->GetNextSpellInChain(spell_id))
+    {
+        if (HasSpell(nextSpell) && !GetTalentSpellPos(nextSpell))
+            removeSpell(nextSpell, disabled, false);
+    }
+    //unlearn spells dependent from recently removed spells
+    SpellsRequiringSpellMapBounds spellsRequiringSpell = sSpellMgr->GetSpellsRequiringSpellBounds(spell_id);
+    for (SpellsRequiringSpellMap::const_iterator itr2 = spellsRequiringSpell.first; itr2 != spellsRequiringSpell.second; ++itr2)
+        removeSpell(itr2->second, disabled);
+
+    // re-search, it can be corrupted in prev loop
+    itr = m_spells.find(spell_id);
+    if (itr == m_spells.end())
+        return;                                             // already unleared
+
+    bool giveTalentPoints = disabled || !itr->second->disabled;
+
+    bool cur_active    = itr->second->active;
+    bool cur_dependent = itr->second->dependent;
+
+    if (disabled)
+    {
+        itr->second->disabled = disabled;
+        if (itr->second->state != PLAYERSPELL_NEW)
+            itr->second->state = PLAYERSPELL_CHANGED;
+    }
+    else
+    {
+        if (itr->second->state == PLAYERSPELL_NEW)
+        {
+            delete itr->second;
+            m_spells.erase(itr);
+        }
+        else
+            itr->second->state = PLAYERSPELL_REMOVED;
+    }
+
+    RemoveAurasDueToSpell(spell_id);
+
+    // remove pet auras
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        if (PetAura const* petSpell = sSpellMgr->GetPetAura(spell_id, i))
+            RemovePetAura(petSpell);
+
+    // free talent points
+    uint32 talentCosts = GetTalentSpellCost(spell_id);
+    if (talentCosts > 0 && giveTalentPoints)
+    {
+        if (talentCosts < GetUsedTalentCount())
+            SetUsedTalentCount(GetUsedTalentCount() - talentCosts);
+        else
+            SetUsedTalentCount(0);
+    }
+
+    // update free primary prof.points (if not overflow setting, can be in case GM use before .learn prof. learning)
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
+    if (spellInfo && spellInfo->IsPrimaryProfessionFirstRank())
+    {
+        uint32 freeProfs = GetFreePrimaryProfessionPoints()+1;
+        if (freeProfs <= sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL))
+            SetFreePrimaryProfessions(freeProfs);
+    }
+
+    // remove dependent skill
+    SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(spell_id);
+    if (spellLearnSkill)
+    {
+        uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(spell_id);
+        if (!prev_spell)                                    // first rank, remove skill
+            SetSkill(spellLearnSkill->skill, 0, 0, 0);
+        else
+        {
+            // search prev. skill setting by spell ranks chain
+            SpellLearnSkillNode const* prevSkill = sSpellMgr->GetSpellLearnSkill(prev_spell);
+            while (!prevSkill && prev_spell)
+            {
+                prev_spell = sSpellMgr->GetPrevSpellInChain(prev_spell);
+                prevSkill = sSpellMgr->GetSpellLearnSkill(sSpellMgr->GetFirstSpellInChain(prev_spell));
+            }
+
+            if (!prevSkill)                                 // not found prev skill setting, remove skill
+                SetSkill(spellLearnSkill->skill, 0, 0, 0);
+            else                                            // set to prev. skill setting values
+            {
+                uint32 skill_value = GetPureSkillValue(prevSkill->skill);
+                uint32 skill_max_value = GetPureMaxSkillValue(prevSkill->skill);
+
+                if (skill_value > prevSkill->value)
+                    skill_value = prevSkill->value;
+
+                uint32 new_skill_max_value = prevSkill->maxvalue == 0 ? GetMaxSkillValueForLevel() : prevSkill->maxvalue;
+
+                if (skill_max_value > new_skill_max_value)
+                    skill_max_value = new_skill_max_value;
+
+                SetSkill(prevSkill->skill, prevSkill->step, skill_value, skill_max_value);
+            }
+        }
+    }
+    else
+    {
+        // not ranked skills
+        SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spell_id);
+
+        for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
+        {
+            SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(_spell_idx->second->skillId);
+            if (!pSkill)
+                continue;
+
+            if ((_spell_idx->second->learnOnGetSkill == ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL &&
+                pSkill->categoryId != SKILL_CATEGORY_CLASS) ||// not unlearn class skills (spellbook/talent pages)
+                // lockpicking/runeforging special case, not have ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL
+                ((pSkill->id == SKILL_LOCKPICKING || pSkill->id == SKILL_RUNEFORGING) && _spell_idx->second->max_value == 0))
+            {
+                // not reset skills for professions and racial abilities
+                if ((pSkill->categoryId == SKILL_CATEGORY_SECONDARY || pSkill->categoryId == SKILL_CATEGORY_PROFESSION) &&
+                    (IsProfessionSkill(pSkill->id) || _spell_idx->second->racemask != 0))
+                    continue;
+
+                SetSkill(pSkill->id, GetSkillStep(pSkill->id), 0, 0);
+            }
+        }
+    }
+
+    // remove dependent spells
+    SpellLearnSpellMapBounds spell_bounds = sSpellMgr->GetSpellLearnSpellMapBounds(spell_id);
+
+    for (SpellLearnSpellMap::const_iterator itr2 = spell_bounds.first; itr2 != spell_bounds.second; ++itr2)
+        removeSpell(itr2->second.spell, disabled);
+
+    // activate lesser rank in spellbook/action bar, and cast it if need
+    bool prev_activate = false;
+
+    if (uint32 prev_id = sSpellMgr->GetPrevSpellInChain(spell_id))
+    {
+        // if talent then lesser rank also talent and need learn
+        if (talentCosts)
+        {
+            // I cannot see why mangos has these lines.
+            //if (learn_low_rank)
+            //    learnSpell(prev_id, false);
+        }
+        // if ranked non-stackable spell: need activate lesser rank and update dendence state
+        else if (cur_active && !spellInfo->IsStackableWithRanks() && spellInfo->IsRanked())
+        {
+            // need manually update dependence state (learn spell ignore like attempts)
+            PlayerSpellMap::iterator prev_itr = m_spells.find(prev_id);
+            if (prev_itr != m_spells.end())
+            {
+                if (prev_itr->second->dependent != cur_dependent)
+                {
+                    prev_itr->second->dependent = cur_dependent;
+                    if (prev_itr->second->state != PLAYERSPELL_NEW)
+                        prev_itr->second->state = PLAYERSPELL_CHANGED;
+                }
+
+                // now re-learn if need re-activate
+                if (cur_active && !prev_itr->second->active && learn_low_rank)
+                {
+                    if (addSpell(prev_id, true, false, prev_itr->second->dependent, prev_itr->second->disabled))
+                    {
+                        // downgrade spell ranks in spellbook and action bar
+                        WorldPacket data(SMSG_SUPERCEDED_SPELL, 4 + 4);
+                        data << uint32(prev_id);
+                        data << uint32(spell_id);
+                        GetSession()->SendPacket(&data);
+                        prev_activate = true;
+                    }
+                }
+            }
+        }
+    }
+
+    if (spell_id == 46917 && m_canTitanGrip)
+        SetCanTitanGrip(false);
+
+    if (m_canDualWield)
+    {
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
+        if (spellInfo->IsPassive())
+        {
+            for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
+                if (spellInfo->Effects[i].Effect == SPELL_EFFECT_DUAL_WIELD)
+                {
+                    SetCanDualWield(false);
+                    break;
+                }
+        }
+    }
+
+    if (sWorld->getBoolConfig(CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN))
+        AutoUnequipOffhandIfNeed();
+
+    // remove from spell book if not replaced by lesser rank
+    if (!prev_activate)
+    {
+        WorldPacket data(SMSG_REMOVED_SPELL, 4);
+        data << uint32(spell_id);
+        GetSession()->SendPacket(&data);
+    }
+}
+
+void Player::RemoveSpellCooldown(uint32 spell_id, bool update /* = false */)
+{
+    m_spellCooldowns.erase(spell_id);
+
+    if (update)
+        SendClearCooldown(spell_id, this);
+}
+
+// I am not sure which one is more efficient
+void Player::RemoveCategoryCooldown(uint32 cat)
+{
+    SpellCategoryStore::const_iterator i_scstore = sSpellCategoryStore.find(cat);
+    if (i_scstore != sSpellCategoryStore.end())
+        for (SpellCategorySet::const_iterator i_scset = i_scstore->second.begin(); i_scset != i_scstore->second.end(); ++i_scset)
+            RemoveSpellCooldown(*i_scset, true);
+}
+
+void Player::RemoveSpellCategoryCooldown(uint32 cat, bool update /* = false */)
+{
+    SpellCategoryStore::const_iterator ct = sSpellCategoryStore.find(cat);
+    if (ct == sSpellCategoryStore.end())
+        return;
+
+    const SpellCategorySet& ct_set = ct->second;
+    for (SpellCooldowns::const_iterator i = m_spellCooldowns.begin(); i != m_spellCooldowns.end();)
+    {
+        if (ct_set.find(i->first) != ct_set.end())
+            RemoveSpellCooldown((i++)->first, update);
+        else
+            ++i;
+    }
+}
+
+void Player::RemoveArenaSpellCooldowns(bool removeActivePetCooldowns)
+{
+    // remove cooldowns on spells that have <= 10 min CD
+
+    SpellCooldowns::iterator itr, next;
+    for (itr = m_spellCooldowns.begin(); itr != m_spellCooldowns.end(); itr = next)
+    {
+        next = itr;
+        ++next;
+        SpellInfo const* entry = sSpellMgr->GetSpellInfo(itr->first);
+        // check if spellentry is present and if the cooldown is less or equal to 10 min
+        if (entry &&
+            entry->RecoveryTime <= 10 * MINUTE * IN_MILLISECONDS &&
+            entry->CategoryRecoveryTime <= 10 * MINUTE * IN_MILLISECONDS)
+        {
+            // remove & notify
+            RemoveSpellCooldown(itr->first, true);
+        }
+    }
+
+    // pet cooldowns
+    if (removeActivePetCooldowns)
+        if (Pet* pet = GetPet())
+        {
+            // notify player
+            for (SpellCooldowns::const_iterator itr2 = pet->GetSpellCooldownMap().begin(); itr2 != pet->GetSpellCooldownMap().end(); ++itr2)
+                SendClearCooldown(itr2->first, pet);
+
+            // actually clear cooldowns
+            pet->m_spellCooldowns.clear();
+        }
+}
+
+void Player::RemoveAllSpellCooldown()
+{
+    if (!m_spellCooldowns.empty())
+    {
+        SendClearAllCooldowns(this);
+        m_spellCooldowns.clear();
+    }
+}
+
+void Player::_LoadSpellCooldowns(PreparedQueryResult result)
+{
+    // some cooldowns can be already set at aura loading...
+
+    //QueryResult* result = CharacterDatabase.PQuery("SELECT spell, item, time FROM character_spell_cooldown WHERE guid = '%u'", GetGUIDLow());
+
+    if (result)
+    {
+        time_t curTime = time(NULL);
+
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 spell_id = fields[0].GetUInt32();
+            uint32 item_id  = fields[1].GetUInt32();
+            time_t db_time  = time_t(fields[2].GetUInt32());
+
+            if (!sSpellMgr->GetSpellInfo(spell_id))
+            {
+                sLog->outError(LOG_FILTER_PLAYER_LOADING, "Player %u has unknown spell %u in `character_spell_cooldown`, skipping.", GetGUIDLow(), spell_id);
+                continue;
+            }
+
+            // skip outdated cooldown
+            if (db_time <= curTime)
+                continue;
+
+            AddSpellCooldown(spell_id, item_id, db_time);
+
+            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player (GUID: %u) spell %u, item %u cooldown loaded (%u secs).", GetGUIDLow(), spell_id, item_id, uint32(db_time-curTime));
+        }
+        while (result->NextRow());
+    }
+}
+
+void Player::_SaveSpellCooldowns(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+
+    time_t curTime = time(NULL);
+    time_t infTime = curTime + infinityCooldownDelayCheck;
+
+    bool first_round = true;
+    std::ostringstream ss;
+
+    // remove outdated and save active
+    for (SpellCooldowns::iterator itr = m_spellCooldowns.begin(); itr != m_spellCooldowns.end();)
+    {
+        if (itr->second.end <= curTime)
+            m_spellCooldowns.erase(itr++);
+        else if (itr->second.end <= infTime)                 // not save locked cooldowns, it will be reset or set at reload
+        {
+            if (first_round)
+            {
+                ss << "INSERT INTO character_spell_cooldown (guid, spell, item, time) VALUES ";
+                first_round = false;
+            }
+            // next new/changed record prefix
+            else
+                ss << ',';
+            ss << '(' << GetGUIDLow() << ',' << itr->first << ',' << itr->second.itemid << ',' << uint64(itr->second.end) << ')';
+            ++itr;
+        }
+        else
+            ++itr;
+    }
+    // if something changed execute
+    if (!first_round)
+        trans->Append(ss.str().c_str());
+}
+
+uint32 Player::GetNextResetTalentsCost() const
+{
+    // The first time reset costs 1 gold
+    if (GetTalentResetCost() < 1*GOLD)
+        return 1*GOLD;
+    // then 5 gold
+    else if (GetTalentResetCost() < 5*GOLD)
+        return 5*GOLD;
+    // After that it increases in increments of 5 gold
+    else if (GetTalentResetCost() < 10*GOLD)
+        return 10*GOLD;
+    else
+    {
+        uint64 months = (sWorld->GetGameTime() - GetTalentResetTime())/MONTH;
+        if (months > 0)
+        {
+            // This cost will be reduced by a rate of 5 gold per month
+            int32 new_cost = int32(GetTalentResetCost() - 5*GOLD*months);
+            // to a minimum of 10 gold.
+            return (new_cost < 10*GOLD ? 10*GOLD : new_cost);
+        }
+        else
+        {
+            // After that it increases in increments of 5 gold
+            int32 new_cost = GetTalentResetCost() + 5*GOLD;
+            // until it hits a cap of 50 gold.
+            if (new_cost > 50*GOLD)
+                new_cost = 50*GOLD;
+            return new_cost;
+        }
+    }
+}
+
+bool Player::ResetTalents(bool no_cost)
+{
+    sScriptMgr->OnPlayerTalentsReset(this, no_cost);
+
+    // not need after this call
+    if (HasAtLoginFlag(AT_LOGIN_RESET_TALENTS))
+        RemoveAtLoginFlag(AT_LOGIN_RESET_TALENTS, true);
+
+    uint32 talentPointsForLevel = CalculateTalentsPoints();
+
+    if (!GetUsedTalentCount())
+    {
+        SetFreeTalentPoints(talentPointsForLevel);
+        return false;
+    }
+
+    uint32 cost = 0;
+
+    if (!no_cost && !sWorld->getBoolConfig(CONFIG_NO_RESET_TALENT_COST))
+    {
+        cost = GetNextResetTalentsCost();
+
+        if (!HasEnoughMoney(uint64(cost)))
+        {
+            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+            return false;
+        }
+    }
+
+    Pet* pet = GetPet();
+    if (pet && pet->isHunterPet())
+        RemovePet(NULL, PET_SLOT_ACTUAL_PET_SLOT, true);
+    else
+        RemovePet(NULL, PET_SLOT_DELETED, true);
+
+    for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
+    {
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+
+        if (!talentInfo)
+            continue;
+
+        TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
+
+        if (!talentTabInfo)
+            continue;
+
+        // unlearn only talents for character class
+        // some spell learned by one class as normal spells or know at creation but another class learn it as talent,
+        // to prevent unexpected lost normal learned spell skip another class talents
+        if ((getClassMask() & talentTabInfo->ClassMask) == 0)
+            continue;
+
+        for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+        {
+            // skip non-existant talent ranks
+            if (talentInfo->RankID[rank] == 0)
+                continue;
+            const SpellInfo* _spellEntry = sSpellMgr->GetSpellInfo(talentInfo->RankID[rank]);
+            if (!_spellEntry)
+                continue;
+            removeSpell(talentInfo->RankID[rank], true);
+            // search for spells that the talent teaches and unlearn them
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+                if (_spellEntry->Effects[i].TriggerSpell > 0 && _spellEntry->Effects[i].Effect == SPELL_EFFECT_LEARN_SPELL)
+                    removeSpell(_spellEntry->Effects[i].TriggerSpell, true);
+            // if this talent rank can be found in the PlayerTalentMap, mark the talent as removed so it gets deleted
+            PlayerTalentMap::iterator plrTalent = GetTalentMap(GetActiveSpec())->find(talentInfo->RankID[rank]);
+            if (plrTalent != GetTalentMap(GetActiveSpec())->end())
+                plrTalent->second->state = PLAYERSPELL_REMOVED;
+        }
+    }
+
+    // Remove spec specific spells
+    for (uint32 i = 0; i < MAX_TALENT_TABS; ++i)
+    {
+        std::vector<uint32> const* specSpells = GetTalentTreePrimarySpells(GetTalentTabPages(getClass())[i]);
+        if (specSpells)
+            for (size_t i = 0; i < specSpells->size(); ++i)
+                removeSpell(specSpells->at(i), true);
+
+        TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(GetTalentTabPages(getClass())[i]);
+        for (uint32 j = 0; j < MAX_MASTERY_SPELLS; ++j)
+            if (uint32 mastery = talentTabInfo->MasterySpells[j])
+                removeSpell(mastery, true);
+    }
+
+    SetPrimaryTalentTree(GetActiveSpec(), 0);
+    SetFreeTalentPoints(talentPointsForLevel);
+    UpdateMastery();
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    _SaveTalents(trans);
+    _SaveSpells(trans);
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!no_cost)
+    {
+        ModifyMoney(-(int64)cost);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_SPENT_FOR_TALENTS, cost);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_NUMBER_OF_TALENT_RESETS, 1);
+
+        SetTalentResetCost(cost);
+        SetTalentResetTime(time(NULL));
+    }
+
+    /* when prev line will dropped use next line
+    if (Pet* pet = GetPet())
+    {
+        if (pet->getPetType() == HUNTER_PET && !pet->GetCreatureTemplate()->isTameable(CanTameExoticPets()))
+            RemovePet(NULL, PET_SAVE_NOT_IN_SLOT, true);
+    }
+    */
+
+    return true;
+}
+
+Mail* Player::GetMail(uint32 id)
+{
+    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
+        if ((*itr)->messageID == id)
+            return (*itr);
+
+    return NULL;
+}
+
+void Player::BuildCreateUpdateBlockForPlayer(UpdateData* data, Player* target) const
+{
+    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        if (m_items[i] == NULL)
+            continue;
+
+        m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);
+    }
+
+    if (target == this)
+    {
+        for (uint8 i = INVENTORY_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        {
+            if (m_items[i] == NULL)
+                continue;
+
+            m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);
+        }
+    }
+
+    Unit::BuildCreateUpdateBlockForPlayer(data, target);
+}
+
+void Player::DestroyForPlayer(Player* target, bool onDeath) const
+{
+    Unit::DestroyForPlayer(target, onDeath);
+
+    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (m_items[i] == NULL)
+            continue;
+
+        m_items[i]->DestroyForPlayer(target);
+    }
+
+    if (target == this)
+    {
+        for (uint8 i = INVENTORY_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        {
+            if (m_items[i] == NULL)
+                continue;
+
+            m_items[i]->DestroyForPlayer(target);
+        }
+    }
+}
+
+bool Player::HasSpell(uint32 spell) const
+{
+    PlayerSpellMap::const_iterator itr = m_spells.find(spell);
+    return (itr != m_spells.end() && itr->second->state != PLAYERSPELL_REMOVED &&
+        !itr->second->disabled);
+}
+
+bool Player::HasTalent(uint32 spell, uint8 spec) const
+{
+    PlayerTalentMap::const_iterator itr = GetTalentMap(spec)->find(spell);
+    return (itr != GetTalentMap(spec)->end() && itr->second->state != PLAYERSPELL_REMOVED);
+}
+
+bool Player::HasActiveSpell(uint32 spell) const
+{
+    PlayerSpellMap::const_iterator itr = m_spells.find(spell);
+    return (itr != m_spells.end() && itr->second->state != PLAYERSPELL_REMOVED &&
+        itr->second->active && !itr->second->disabled);
+}
+
+TrainerSpellState Player::GetTrainerSpellState(TrainerSpell const* trainer_spell) const
+{
+    if (!trainer_spell)
+        return TRAINER_SPELL_RED;
+
+    bool hasSpell = true;
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (!trainer_spell->learnedSpell[i])
+            continue;
+
+        if (!HasSpell(trainer_spell->learnedSpell[i]))
+        {
+            hasSpell = false;
+            break;
+        }
+    }
+    // known spell
+    if (hasSpell)
+        return TRAINER_SPELL_GRAY;
+
+    // check skill requirement
+    if (trainer_spell->reqSkill && GetBaseSkillValue(trainer_spell->reqSkill) < trainer_spell->reqSkillValue)
+        return TRAINER_SPELL_RED;
+
+    // check level requirement
+    if (getLevel() < trainer_spell->reqLevel)
+        return TRAINER_SPELL_RED;
+
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (!trainer_spell->learnedSpell[i])
+            continue;
+
+        // check race/class requirement
+        if (!IsSpellFitByClassAndRace(trainer_spell->learnedSpell[i]))
+            return TRAINER_SPELL_RED;
+
+        if (uint32 prevSpell = sSpellMgr->GetPrevSpellInChain(trainer_spell->learnedSpell[i]))
+        {
+            // check prev.rank requirement
+            if (prevSpell && !HasSpell(prevSpell))
+                return TRAINER_SPELL_RED;
+        }
+
+        SpellsRequiringSpellMapBounds spellsRequired = sSpellMgr->GetSpellsRequiredForSpellBounds(trainer_spell->learnedSpell[i]);
+        for (SpellsRequiringSpellMap::const_iterator itr = spellsRequired.first; itr != spellsRequired.second; ++itr)
+        {
+            // check additional spell requirement
+            if (!HasSpell(itr->second))
+                return TRAINER_SPELL_RED;
+        }
+    }
+
+    // check primary prof. limit
+    // first rank of primary profession spell when there are no proffesions avalible is disabled
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (!trainer_spell->learnedSpell[i])
+            continue;
+        SpellInfo const* learnedSpellInfo = sSpellMgr->GetSpellInfo(trainer_spell->learnedSpell[i]);
+        if (learnedSpellInfo && learnedSpellInfo->IsPrimaryProfessionFirstRank() && (GetFreePrimaryProfessionPoints() == 0))
+            return TRAINER_SPELL_GREEN_DISABLED;
+    }
+
+    return TRAINER_SPELL_GREEN;
+}
+
+/**
+ * Deletes a character from the database
+ *
+ * The way, how the characters will be deleted is decided based on the config option.
+ *
+ * @see Player::DeleteOldCharacters
+ *
+ * @param playerguid       the low-GUID from the player which should be deleted
+ * @param accountId        the account id from the player
+ * @param updateRealmChars when this flag is set, the amount of characters on that realm will be updated in the realmlist
+ * @param deleteFinally    if this flag is set, the config option will be ignored and the character will be permanently removed from the database
+ */
+void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmChars, bool deleteFinally)
+{
+    // for not existed account avoid update realm
+    if (accountId == 0)
+        updateRealmChars = false;
+
+    uint32 charDelete_method = sWorld->getIntConfig(CONFIG_CHARDELETE_METHOD);
+    uint32 charDelete_minLvl = sWorld->getIntConfig(CONFIG_CHARDELETE_MIN_LEVEL);
+
+    // if we want to finally delete the character or the character does not meet the level requirement,
+    // we set it to mode CHAR_DELETE_REMOVE
+    if (deleteFinally || Player::GetLevelFromDB(playerguid) < charDelete_minLvl)
+        charDelete_method = CHAR_DELETE_REMOVE;
+
+    uint32 guid = GUID_LOPART(playerguid);
+
+    // convert corpse to bones if exist (to prevent exiting Corpse in World without DB entry)
+    // bones will be deleted by corpse/bones deleting thread shortly
+    sObjectAccessor->ConvertCorpseForPlayer(playerguid);
+
+    if (uint32 guildId = GetGuildIdFromDB(playerguid))
+        if (Guild* guild = sGuildMgr->GetGuildById(guildId))
+            guild->DeleteMember(guid);
+
+    // remove from arena teams
+    LeaveAllArenaTeams(playerguid);
+
+    // the player was uninvited already on logout so just remove from group
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GROUP_MEMBER);
+    stmt->setUInt32(0, guid);
+    PreparedQueryResult resultGroup = CharacterDatabase.Query(stmt);
+
+    if (resultGroup)
+        if (Group* group = sGroupMgr->GetGroupByDbStoreId((*resultGroup)[0].GetUInt32()))
+            RemoveFromGroup(group, playerguid);
+
+    // Remove signs from petitions (also remove petitions if owner);
+    RemovePetitionsAndSigns(playerguid, 10);
+
+    switch (charDelete_method)
+    {
+        // Completely remove from the database
+        case CHAR_DELETE_REMOVE:
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_COD_ITEM_MAIL);
+            stmt->setUInt32(0, guid);
+            PreparedQueryResult resultMail = CharacterDatabase.Query(stmt);
+
+            if (resultMail)
+            {
+                do
+                {
+                    Field* mailFields = resultMail->Fetch();
+
+                    uint32 mail_id       = mailFields[0].GetUInt32();
+                    uint8 mailType       = mailFields[1].GetUInt8();
+                    uint16 mailTemplateId= mailFields[2].GetUInt16();
+                    uint32 sender        = mailFields[3].GetUInt32();
+                    std::string subject  = mailFields[4].GetString();
+                    std::string body     = mailFields[5].GetString();
+                    uint64 money         = mailFields[6].GetUInt64();
+                    bool has_items       = mailFields[7].GetBool();
+
+                    // We can return mail now
+                    // So firstly delete the old one
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
+                    stmt->setUInt32(0, mail_id);
+                    trans->Append(stmt);
+
+                    // Mail is not from player
+                    if (mailType != MAIL_NORMAL)
+                    {
+                        if (has_items)
+                        {
+                            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
+                            stmt->setUInt32(0, mail_id);
+                            trans->Append(stmt);
+                        }
+                        continue;
+                    }
+
+                    MailDraft draft(subject, body);
+                    if (mailTemplateId)
+                        draft = MailDraft(mailTemplateId, false);    // items are already included
+
+                    if (has_items)
+                    {
+                        // Data needs to be at first place for Item::LoadFromDB
+                        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAILITEMS);
+                        stmt->setUInt32(0, mail_id);
+                        PreparedQueryResult resultItems = CharacterDatabase.Query(stmt);
+                        if (resultItems)
+                        {
+                            do
+                            {
+                                Field* itemFields = resultItems->Fetch();
+                                uint32 item_guidlow = itemFields[11].GetUInt32();
+                                uint32 item_template = itemFields[12].GetUInt32();
+
+                                ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(item_template);
+                                if (!itemProto)
+                                {
+                                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
+                                    stmt->setUInt32(0, item_guidlow);
+                                    trans->Append(stmt);
+                                    continue;
+                                }
+
+                                Item* pItem = NewItemOrBag(itemProto);
+                                if (!pItem->LoadFromDB(item_guidlow, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER), itemFields, item_template))
+                                {
+                                    pItem->FSetState(ITEM_REMOVED);
+                                    pItem->SaveToDB(trans);              // it also deletes item object!
+                                    continue;
+                                }
+
+                                draft.AddItem(pItem);
+                            }
+                            while (resultItems->NextRow());
+                        }
+                    }
+
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
+                    stmt->setUInt32(0, mail_id);
+                    trans->Append(stmt);
+
+                    draft.AddMoney(money).SendReturnToSender(accountId, guid, sender, trans);
+                }
+                while (resultMail->NextRow());
+            }
+
+            // Unsummon and delete for pets in world is not required: player deleted from CLI or character list with not loaded pet.
+            // NOW we can finally clear other DB data related to character
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PETS);
+            stmt->setUInt32(0, guid);
+            PreparedQueryResult resultPets = CharacterDatabase.Query(stmt);
+
+            if (resultPets)
+            {
+                do
+                {
+                    uint32 petguidlow = (*resultPets)[0].GetUInt32();
+                    Pet::DeleteFromDB(petguidlow);
+                } while (resultPets->NextRow());
+            }
+
+            // Delete char from social list of online chars
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_SOCIAL);
+            stmt->setUInt32(0, guid);
+            PreparedQueryResult resultFriends = CharacterDatabase.Query(stmt);
+
+            if (resultFriends)
+            {
+                do
+                {
+                    if (Player* pFriend = ObjectAccessor::FindPlayer(MAKE_NEW_GUID((*resultFriends)[0].GetUInt32(), 0, HIGHGUID_PLAYER)))
+                    {
+                        if (pFriend->IsInWorld())
+                        {
+                            pFriend->GetSocial()->RemoveFromSocialList(guid, false);
+                            sSocialMgr->SendFriendStatus(pFriend, FRIEND_REMOVED, guid, false);
+                        }
+                    }
+                } while (resultFriends->NextRow());
+            }
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_ACCOUNT_DATA);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_DECLINED_NAME);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GIFT);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REPUTATION);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_GM_TICKETS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE_BY_OWNER);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_FRIEND);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_GUID);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEMS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_OWNER);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_DECLINEDNAME_BY_OWNER);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENTS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENT_PROGRESS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_EQUIPMENTSETS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_EVENTLOG_BY_PLAYER);
+            stmt->setUInt32(0, guid);
+            stmt->setUInt32(1, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_BANK_EVENTLOG_BY_PLAYER);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_DAILY);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILLS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+
+            CharacterDatabase.CommitTransaction(trans);
+            break;
+        }
+        // The character gets unlinked from the account, the name gets freed up and appears as deleted ingame
+        case CHAR_DELETE_UNLINK:
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_DELETE_INFO);
+
+            stmt->setUInt32(0, guid);
+
+            CharacterDatabase.Execute(stmt);
+            break;
+        }
+        default:
+            sLog->outError(LOG_FILTER_PLAYER, "Player::DeleteFromDB: Unsupported delete method: %u.", charDelete_method);
+    }
+
+    if (updateRealmChars)
+        sWorld->UpdateRealmCharCount(accountId);
+}
+
+/**
+ * Characters which were kept back in the database after being deleted and are now too old (see config option "CharDelete.KeepDays"), will be completely deleted.
+ *
+ * @see Player::DeleteFromDB
+ */
+void Player::DeleteOldCharacters()
+{
+    uint32 keepDays = sWorld->getIntConfig(CONFIG_CHARDELETE_KEEP_DAYS);
+    if (!keepDays)
+        return;
+
+    Player::DeleteOldCharacters(keepDays);
+}
+
+/**
+ * Characters which were kept back in the database after being deleted and are older than the specified amount of days, will be completely deleted.
+ *
+ * @see Player::DeleteFromDB
+ *
+ * @param keepDays overrite the config option by another amount of days
+ */
+void Player::DeleteOldCharacters(uint32 keepDays)
+{
+    sLog->outInfo(LOG_FILTER_PLAYER, "Player::DeleteOldChars: Deleting all characters which have been deleted %u days before...", keepDays);
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_OLD_CHARS);
+    stmt->setUInt32(0, uint32(time(NULL) - time_t(keepDays * DAY)));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+    {
+         sLog->outDebug(LOG_FILTER_PLAYER, "Player::DeleteOldChars: Found " UI64FMTD " character(s) to delete", result->GetRowCount());
+         do
+         {
+            Field* fields = result->Fetch();
+            Player::DeleteFromDB(fields[0].GetUInt32(), fields[1].GetUInt32(), true, true);
+         }
+         while (result->NextRow());
+    }
+}
+
+/* Preconditions:
+  - a resurrectable corpse must not be loaded for the player (only bones)
+  - the player must be in world
+*/
+void Player::BuildPlayerRepop()
+{
+    WorldPacket data(SMSG_PRE_RESURRECT, GetPackGUID().size());
+    data.append(GetPackGUID());
+    GetSession()->SendPacket(&data);
+
+    if (getRace() == RACE_NIGHTELF)
+        CastSpell(this, 20584, true);
+    CastSpell(this, 8326, true);
+
+    // there must be SMSG.FORCE_RUN_SPEED_CHANGE, SMSG.FORCE_SWIM_SPEED_CHANGE, SMSG.MOVE_WATER_WALK
+    // there must be SMSG.STOP_MIRROR_TIMER
+    // there we must send 888 opcode
+
+    // the player cannot have a corpse already, only bones which are not returned by GetCorpse
+    if (GetCorpse())
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "BuildPlayerRepop: player %s(%d) already has a corpse", GetName().c_str(), GetGUIDLow());
+        return;
+    }
+
+    // create a corpse and place it at the player's location
+    CreateCorpse();
+    Corpse* corpse = GetCorpse();
+    if (!corpse)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Error creating corpse for Player %s [%u]", GetName().c_str(), GetGUIDLow());
+        return;
+    }
+    GetMap()->AddToMap(corpse);
+
+    // convert player body to ghost
+    SetHealth(1);
+
+    AddUnitMovementFlag(MOVEMENTFLAG_WATERWALKING);
+    SendMovementWaterWalking();
+    if (!GetSession()->isLogingOut())
+        SetRooted(false);
+
+    // BG - remove insignia related
+    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
+
+//    SendCorpseReclaimDelay();
+
+    // to prevent cheating
+    corpse->ResetGhostTime();
+
+    StopMirrorTimers();                                     //disable timers(bars)
+
+    // set and clear other
+    SetByteValue(UNIT_FIELD_BYTES_1, 3, UNIT_BYTE1_FLAG_ALWAYS_STAND);
+}
+
+void Player::ResurrectPlayer(float restore_percent, bool applySickness)
+{
+    WorldPacket data(SMSG_DEATH_RELEASE_LOC, 4*4);          // remove spirit healer position
+    data << uint32(-1);
+    data << float(0);
+    data << float(0);
+    data << float(0);
+    GetSession()->SendPacket(&data);
+
+    // speed change, land walk
+
+    // remove death flag + set aura
+    SetByteValue(UNIT_FIELD_BYTES_1, 3, 0x00);
+    if (getRace() == RACE_NIGHTELF)
+        RemoveAurasDueToSpell(20584);                       // speed bonuses
+    RemoveAurasDueToSpell(8326);                            // SPELL_AURA_GHOST
+
+    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
+        SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);
+
+    setDeathState(ALIVE);
+
+    RemoveUnitMovementFlag(MOVEMENTFLAG_WATERWALKING);
+    SendMovementWaterWalking();
+    SetRooted(false);
+
+    m_deathTimer = 0;
+
+    // set health/powers (0- will be set in caller)
+    if (restore_percent > 0.0f)
+    {
+        SetHealth(uint32(GetMaxHealth()*restore_percent));
+        SetPower(POWER_MANA, uint32(GetMaxPower(POWER_MANA)*restore_percent));
+        SetPower(POWER_RAGE, 0);
+        SetPower(POWER_ENERGY, uint32(GetMaxPower(POWER_ENERGY)*restore_percent));
+        SetPower(POWER_FOCUS, uint32(GetMaxPower(POWER_FOCUS)*restore_percent));
+        SetPower(POWER_ECLIPSE, 0);
+    }
+
+    // trigger update zone for alive state zone updates
+    uint32 newzone, newarea;
+    GetZoneAndAreaId(newzone, newarea);
+    UpdateZone(newzone, newarea);
+    sOutdoorPvPMgr->HandlePlayerResurrects(this, newzone);
+
+    if (InBattleground())
+    {
+        if (Battleground* bg = GetBattleground())
+            bg->HandlePlayerResurrect(this);
+    }
+
+    // update visibility
+    UpdateObjectVisibility();
+
+    if (!applySickness)
+        return;
+
+    //Characters from level 1-10 are not affected by resurrection sickness.
+    //Characters from level 11-19 will suffer from one minute of sickness
+    //for each level they are above 10.
+    //Characters level 20 and up suffer from ten minutes of sickness.
+    int32 startLevel = sWorld->getIntConfig(CONFIG_DEATH_SICKNESS_LEVEL);
+
+    if (int32(getLevel()) >= startLevel)
+    {
+        // set resurrection sickness
+        CastSpell(this, 15007, true);
+
+        // not full duration
+        if (int32(getLevel()) < startLevel+9)
+        {
+            int32 delta = (int32(getLevel()) - startLevel + 1)*MINUTE;
+
+            if (Aura* aur = GetAura(15007, GetGUID()))
+            {
+                aur->SetDuration(delta*IN_MILLISECONDS);
+            }
+        }
+    }
+}
+
+void Player::KillPlayer()
+{
+    if (IsFlying() && !GetTransport())
+        i_motionMaster.MoveFall();
+
+    SetRooted(true);
+
+    StopMirrorTimers();                                     //disable timers(bars)
+
+    setDeathState(CORPSE);
+    //SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_IN_PVP);
+
+    SetUInt32Value(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_NONE);
+    ApplyModFlag(PLAYER_FIELD_BYTES, PLAYER_FIELD_BYTE_RELEASE_TIMER, !sMapStore.LookupEntry(GetMapId())->Instanceable() && !HasAuraType(SPELL_AURA_PREVENT_RESURRECTION));
+
+    // 6 minutes until repop at graveyard
+    m_deathTimer = 6 * MINUTE * IN_MILLISECONDS;
+
+    UpdateCorpseReclaimDelay();                             // dependent at use SetDeathPvP() call before kill
+    SendCorpseReclaimDelay();
+
+    // don't create corpse at this moment, player might be falling
+
+    // update visibility
+    UpdateObjectVisibility();
+}
+
+void Player::CreateCorpse()
+{
+    // prevent existence 2 corpse for player
+    SpawnCorpseBones();
+
+    uint32 _uf, _pb, _pb2, _cfb1, _cfb2;
+
+    Corpse* corpse = new Corpse((m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH) ? CORPSE_RESURRECTABLE_PVP : CORPSE_RESURRECTABLE_PVE);
+    SetPvPDeath(false);
+
+    if (!corpse->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_CORPSE), this))
+    {
+        delete corpse;
+        return;
+    }
+
+    _uf = GetUInt32Value(UNIT_FIELD_BYTES_0);
+    _pb = GetUInt32Value(PLAYER_BYTES);
+    _pb2 = GetUInt32Value(PLAYER_BYTES_2);
+
+    uint8 race       = (uint8)(_uf);
+    uint8 skin       = (uint8)(_pb);
+    uint8 face       = (uint8)(_pb >> 8);
+    uint8 hairstyle  = (uint8)(_pb >> 16);
+    uint8 haircolor  = (uint8)(_pb >> 24);
+    uint8 facialhair = (uint8)(_pb2);
+
+    _cfb1 = ((0x00) | (race << 8) | (getGender() << 16) | (skin << 24));
+    _cfb2 = ((face) | (hairstyle << 8) | (haircolor << 16) | (facialhair << 24));
+
+    corpse->SetUInt32Value(CORPSE_FIELD_BYTES_1, _cfb1);
+    corpse->SetUInt32Value(CORPSE_FIELD_BYTES_2, _cfb2);
+
+    uint32 flags = CORPSE_FLAG_UNK2;
+    if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_HELM))
+        flags |= CORPSE_FLAG_HIDE_HELM;
+    if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK))
+        flags |= CORPSE_FLAG_HIDE_CLOAK;
+    if (InBattleground() && !InArena())
+        flags |= CORPSE_FLAG_LOOTABLE;                      // to be able to remove insignia
+
+    corpse->SetUInt32Value(CORPSE_FIELD_FLAGS, flags);
+    corpse->SetUInt32Value(CORPSE_FIELD_DISPLAY_ID, GetNativeDisplayId());
+
+    uint32 iDisplayID;
+    uint32 iIventoryType;
+    uint32 _cfi;
+    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; i++)
+    {
+        if (m_items[i])
+        {
+            iDisplayID = m_items[i]->GetTemplate()->DisplayInfoID;
+            iIventoryType = m_items[i]->GetTemplate()->InventoryType;
+
+            _cfi = iDisplayID | (iIventoryType << 24);
+            corpse->SetUInt32Value(CORPSE_FIELD_ITEM + i, _cfi);
+        }
+    }
+
+    // we do not need to save corpses for BG/arenas
+    if (!GetMap()->IsBattlegroundOrArena())
+        corpse->SaveToDB();
+
+    // register for player, but not show
+    sObjectAccessor->AddCorpse(corpse);
+}
+
+void Player::SpawnCorpseBones()
+{
+    if (sObjectAccessor->ConvertCorpseForPlayer(GetGUID()))
+        if (!GetSession()->PlayerLogoutWithSave())          // at logout we will already store the player
+            SaveToDB();                                     // prevent loading as ghost without corpse
+}
+
+Corpse* Player::GetCorpse() const
+{
+    return sObjectAccessor->GetCorpseForPlayerGUID(GetGUID());
+}
+
+void Player::DurabilityLossAll(double percent, bool inventory)
+{
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            DurabilityLoss(pItem, percent);
+
+    if (inventory)
+    {
+        // bags not have durability
+        // for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+
+        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                DurabilityLoss(pItem, percent);
+
+        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+            if (Bag* pBag = GetBagByPos(i))
+                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+                    if (Item* pItem = GetItemByPos(i, j))
+                        DurabilityLoss(pItem, percent);
+    }
+}
+
+void Player::DurabilityLoss(Item* item, double percent)
+{
+    if (!item)
+        return;
+
+    uint32 pMaxDurability = item ->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+
+    if (!pMaxDurability)
+        return;
+
+    percent /= GetTotalAuraMultiplier(SPELL_AURA_MOD_DURABILITY_LOSS);
+
+    uint32 pDurabilityLoss = uint32(pMaxDurability*percent);
+
+    if (pDurabilityLoss < 1)
+        pDurabilityLoss = 1;
+
+    DurabilityPointsLoss(item, pDurabilityLoss);
+}
+
+void Player::DurabilityPointsLossAll(int32 points, bool inventory)
+{
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            DurabilityPointsLoss(pItem, points);
+
+    if (inventory)
+    {
+        // bags not have durability
+        // for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+
+        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                DurabilityPointsLoss(pItem, points);
+
+        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+            if (Bag* pBag = (Bag*)GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+                    if (Item* pItem = GetItemByPos(i, j))
+                        DurabilityPointsLoss(pItem, points);
+    }
+}
+
+void Player::DurabilityPointsLoss(Item* item, int32 points)
+{
+    int32 pMaxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    int32 pOldDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+    int32 pNewDurability = pOldDurability - points;
+
+    if (pNewDurability < 0)
+        pNewDurability = 0;
+    else if (pNewDurability > pMaxDurability)
+        pNewDurability = pMaxDurability;
+
+    if (pOldDurability != pNewDurability)
+    {
+        // modify item stats _before_ Durability set to 0 to pass _ApplyItemMods internal check
+        if (pNewDurability == 0 && pOldDurability > 0 && item->IsEquipped())
+            _ApplyItemMods(item, item->GetSlot(), false);
+
+        item->SetUInt32Value(ITEM_FIELD_DURABILITY, pNewDurability);
+
+        // modify item stats _after_ restore durability to pass _ApplyItemMods internal check
+        if (pNewDurability > 0 && pOldDurability == 0 && item->IsEquipped())
+            _ApplyItemMods(item, item->GetSlot(), true);
+
+        item->SetState(ITEM_CHANGED, this);
+    }
+}
+
+void Player::DurabilityPointLossForEquipSlot(EquipmentSlots slot)
+{
+    if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        DurabilityPointsLoss(pItem, 1);
+}
+
+uint32 Player::DurabilityRepairAll(bool cost, float discountMod, bool guildBank)
+{
+    uint32 TotalCost = 0;
+    // equipped, backpack, bags itself
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
+        TotalCost += DurabilityRepair(((INVENTORY_SLOT_BAG_0 << 8) | i), cost, discountMod, guildBank);
+
+    // bank, buyback and keys not repaired
+
+    // items in inventory bags
+    for (uint8 j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; j++)
+        for (uint8 i = 0; i < MAX_BAG_SIZE; i++)
+            TotalCost += DurabilityRepair(((j << 8) | i), cost, discountMod, guildBank);
+    return TotalCost;
+}
+
+uint32 Player::DurabilityRepair(uint16 pos, bool cost, float discountMod, bool guildBank)
+{
+    Item* item = GetItemByPos(pos);
+
+    uint32 TotalCost = 0;
+    if (!item)
+        return TotalCost;
+
+    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    if (!maxDurability)
+        return TotalCost;
+
+    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+
+    if (cost)
+    {
+        uint32 LostDurability = maxDurability - curDurability;
+        if (LostDurability>0)
+        {
+            ItemTemplate const* ditemProto = item->GetTemplate();
+
+            DurabilityCostsEntry const* dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
+            if (!dcost)
+            {
+                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+                return TotalCost;
+            }
+
+            uint32 dQualitymodEntryId = (ditemProto->Quality+1)*2;
+            DurabilityQualityEntry const* dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
+            if (!dQualitymodEntry)
+            {
+                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+                return TotalCost;
+            }
+
+            uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class, ditemProto->SubClass)];
+            uint32 costs = uint32(LostDurability*dmultiplier*double(dQualitymodEntry->quality_mod));
+
+            costs = uint32(costs * discountMod * sWorld->getRate(RATE_REPAIRCOST));
+
+            if (costs == 0)                                   //fix for ITEM_QUALITY_ARTIFACT
+                costs = 1;
+
+            if (guildBank)
+            {
+                if (GetGuildId() == 0)
+                {
+                    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "You are not member of a guild");
+                    return TotalCost;
+                }
+
+                Guild* guild = sGuildMgr->GetGuildById(GetGuildId());
+                if (!guild)
+                    return TotalCost;
+
+                if (!guild->HandleMemberWithdrawMoney(GetSession(), costs, true))
+                    return TotalCost;
+
+                TotalCost = costs;
+            }
+            else if (!HasEnoughMoney(uint64(costs)))
+            {
+                sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "You do not have enough money");
+                return TotalCost;
+            }
+            else
+                ModifyMoney(-int64(costs));
+        }
+    }
+
+    item->SetUInt32Value(ITEM_FIELD_DURABILITY, maxDurability);
+    item->SetState(ITEM_CHANGED, this);
+
+    // reapply mods for total broken and repaired item if equipped
+    if (IsEquipmentPos(pos) && !curDurability)
+        _ApplyItemMods(item, pos & 255, true);
+    return TotalCost;
+}
+
+void Player::RepopAtGraveyard()
+{
+    // note: this can be called also when the player is alive
+    // for example from WorldSession::HandleMovementOpcodes
+
+    AreaTableEntry const* zone = GetAreaEntryByAreaID(GetAreaId());
+
+    // Such zones are considered unreachable as a ghost and the player must be automatically revived
+    if ((!isAlive() && zone && zone->flags & AREA_FLAG_NEED_FLY) || GetTransport() || GetPositionZ() < (zone ? zone->MaxDepth : -500.0f))
+    {
+        ResurrectPlayer(0.5f);
+        SpawnCorpseBones();
+    }
+
+    WorldSafeLocsEntry const* ClosestGrave = NULL;
+
+    // Special handle for battleground maps
+    if (Battleground* bg = GetBattleground())
+        ClosestGrave = bg->GetClosestGraveYard(this);
+    else
+    {
+        if (Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(GetZoneId()))
+            ClosestGrave = bf->GetClosestGraveYard(this);
+        else
+            ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
+    }
+
+    // stop countdown until repop
+    m_deathTimer = 0;
+
+    // if no grave found, stay at the current location
+    // and don't show spirit healer location
+    if (ClosestGrave)
+    {
+        TeleportTo(ClosestGrave->map_id, ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, GetOrientation());
+        if (isDead())                                        // not send if alive, because it used in TeleportTo()
+        {
+            WorldPacket data(SMSG_DEATH_RELEASE_LOC, 4*4);  // show spirit healer position on minimap
+            data << ClosestGrave->map_id;
+            data << ClosestGrave->x;
+            data << ClosestGrave->y;
+            data << ClosestGrave->z;
+            GetSession()->SendPacket(&data);
+        }
+    }
+    else if (GetPositionZ() < zone->MaxDepth)
+        TeleportTo(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, GetOrientation());
+}
+
+bool Player::CanJoinConstantChannelInZone(ChatChannelsEntry const* channel, AreaTableEntry const* zone)
+{
+    // Allow joining Lfg wherever aslong as restricted lfg config is turned off
+    if (channel->ChannelID == 26 && !sWorld->getBoolConfig(CONFIG_RESTRICTED_LFG_CHANNEL))
+        return true;
+
+    if (channel->flags & CHANNEL_DBC_FLAG_ZONE_DEP && zone->flags & AREA_FLAG_ARENA_INSTANCE)
+        return false;
+
+    if ((channel->flags & CHANNEL_DBC_FLAG_CITY_ONLY) && (!(zone->flags & AREA_FLAG_SLAVE_CAPITAL)))
+        return false;
+
+    if ((channel->flags & CHANNEL_DBC_FLAG_GUILD_REQ) && GetGuildId())
+        return false;
+
+    return true;
+}
+
+void Player::JoinedChannel(Channel* c)
+{
+    m_channels.push_back(c);
+}
+
+void Player::LeftChannel(Channel* c)
+{
+    m_channels.remove(c);
+}
+
+void Player::CleanupChannels()
+{
+    while (!m_channels.empty())
+    {
+        Channel* ch = *m_channels.begin();
+        m_channels.erase(m_channels.begin());               // remove from player's channel list
+        ch->LeaveChannel(this, false);                     // not send to client, not remove from player's channel list
+        if (ChannelMgr* cMgr = ChannelMgr::forTeam(GetTeam()))
+            cMgr->LeftChannel(ch->GetName());               // deleted channel if empty
+    }
+    sLog->outDebug(LOG_FILTER_CHATSYS, "Player %s: channels cleaned up!", GetName().c_str());
+}
+
+void Player::UpdateLocalChannels(uint32 newZone)
+{
+    if (GetSession()->PlayerLoading() && !IsBeingTeleportedFar())
+        return;                                              // The client handles it automatically after loading, but not after teleporting
+
+    AreaTableEntry const* current_zone = GetAreaEntryByAreaID(newZone);
+    if (!current_zone)
+        return;
+
+    ChannelMgr* cMgr = ChannelMgr::forTeam(GetTeam());
+    if (!cMgr)
+        return;
+
+    std::string current_zone_name = current_zone->area_name;
+
+    for (uint32 i = 0; i < sChatChannelsStore.GetNumRows(); ++i)
+    {
+        if (ChatChannelsEntry const* channel = sChatChannelsStore.LookupEntry(i))
+        {
+            Channel* usedChannel = NULL;
+
+            for (JoinedChannelsList::iterator itr = m_channels.begin(); itr != m_channels.end(); ++itr)
+            {
+                if ((*itr)->GetChannelId() == i)
+                {
+                    usedChannel = *itr;
+                    break;
+                }
+            }
+
+            Channel* removeChannel = NULL;
+            Channel* joinChannel = NULL;
+            bool sendRemove = true;
+
+            if (CanJoinConstantChannelInZone(channel, current_zone))
+            {
+                if (!(channel->flags & CHANNEL_DBC_FLAG_GLOBAL))
+                {
+                    if (channel->flags & CHANNEL_DBC_FLAG_CITY_ONLY && usedChannel)
+                        continue;                            // Already on the channel, as city channel names are not changing
+
+                    char new_channel_name_buf[100];
+                    char const* currentNameExt;
+
+                    if (channel->flags & CHANNEL_DBC_FLAG_CITY_ONLY)
+                        currentNameExt = sObjectMgr->GetTrinityStringForDBCLocale(LANG_CHANNEL_CITY);
+                    else
+                        currentNameExt = current_zone_name.c_str();
+
+                    snprintf(new_channel_name_buf, 100, channel->pattern, currentNameExt);
+
+                    joinChannel = cMgr->GetJoinChannel(new_channel_name_buf, channel->ChannelID);
+                    if (usedChannel)
+                    {
+                        if (joinChannel != usedChannel)
+                        {
+                            removeChannel = usedChannel;
+                            sendRemove = false;              // Do not send leave channel, it already replaced at client
+                        }
+                        else
+                            joinChannel = NULL;
+                    }
+                }
+                else
+                    joinChannel = cMgr->GetJoinChannel(channel->pattern, channel->ChannelID);
+            }
+            else
+                removeChannel = usedChannel;
+
+            if (joinChannel)
+                joinChannel->JoinChannel(this, "");          // Changed Channel: ... or Joined Channel: ...
+
+            if (removeChannel)
+            {
+                removeChannel->LeaveChannel(this, sendRemove); // Leave old channel
+                std::string name = removeChannel->GetName(); // Store name, (*i)erase in LeftChannel
+                LeftChannel(removeChannel);                  // Remove from player's channel list
+                cMgr->LeftChannel(name);                     // Delete if empty
+            }
+        }
+    }
+}
+
+void Player::LeaveLFGChannel()
+{
+    for (JoinedChannelsList::iterator i = m_channels.begin(); i != m_channels.end(); ++i)
+    {
+        if ((*i)->IsLFG())
+        {
+            (*i)->LeaveChannel(this);
+            break;
+        }
+    }
+}
+
+void Player::HandleBaseModValue(BaseModGroup modGroup, BaseModType modType, float amount, bool apply)
+{
+    if (modGroup >= BASEMOD_END || modType >= MOD_END)
+    {
+        sLog->outError(LOG_FILTER_SPELLS_AURAS, "ERROR in HandleBaseModValue(): non existed BaseModGroup of wrong BaseModType!");
+        return;
+    }
+
+    switch (modType)
+    {
+        case FLAT_MOD:
+            m_auraBaseMod[modGroup][modType] += apply ? amount : -amount;
+            break;
+        case PCT_MOD:
+            ApplyPercentModFloatVar(m_auraBaseMod[modGroup][modType], amount, apply);
+            break;
+    }
+
+    if (!CanModifyStats())
+        return;
+
+    switch (modGroup)
+    {
+        case CRIT_PERCENTAGE:              UpdateCritPercentage(BASE_ATTACK);                          break;
+        case RANGED_CRIT_PERCENTAGE:       UpdateCritPercentage(RANGED_ATTACK);                        break;
+        case OFFHAND_CRIT_PERCENTAGE:      UpdateCritPercentage(OFF_ATTACK);                           break;
+        default: break;
+    }
+}
+
+float Player::GetBaseModValue(BaseModGroup modGroup, BaseModType modType) const
+{
+    if (modGroup >= BASEMOD_END || modType >= MOD_END)
+    {
+        sLog->outError(LOG_FILTER_SPELLS_AURAS, "trial to access non existed BaseModGroup or wrong BaseModType!");
+        return 0.0f;
+    }
+
+    if (modType == PCT_MOD && m_auraBaseMod[modGroup][PCT_MOD] <= 0.0f)
+        return 0.0f;
+
+    return m_auraBaseMod[modGroup][modType];
+}
+
+float Player::GetTotalBaseModValue(BaseModGroup modGroup) const
+{
+    if (modGroup >= BASEMOD_END)
+    {
+        sLog->outError(LOG_FILTER_SPELLS_AURAS, "wrong BaseModGroup in GetTotalBaseModValue()!");
+        return 0.0f;
+    }
+
+    if (m_auraBaseMod[modGroup][PCT_MOD] <= 0.0f)
+        return 0.0f;
+
+    return m_auraBaseMod[modGroup][FLAT_MOD] * m_auraBaseMod[modGroup][PCT_MOD];
+}
+
+float Player::GetMeleeCritFromAgility()
+{
+    uint8 level = getLevel();
+    uint32 pclass = getClass();
+
+    if (level > GT_MAX_LEVEL)
+        level = GT_MAX_LEVEL;
+
+    GtChanceToMeleeCritBaseEntry const* critBase  = sGtChanceToMeleeCritBaseStore.LookupEntry(pclass-1);
+    GtChanceToMeleeCritEntry     const* critRatio = sGtChanceToMeleeCritStore.LookupEntry((pclass-1)*GT_MAX_LEVEL + level-1);
+    if (critBase == NULL || critRatio == NULL)
+        return 0.0f;
+
+    float crit = critBase->base + GetStat(STAT_AGILITY)*critRatio->ratio;
+    return crit*100.0f;
+}
+
+void Player::GetDodgeFromAgility(float &diminishing, float &nondiminishing)
+{
+    // 4.2.0: these classes no longer receive dodge from agility and have 5% base
+    if (getClass() == CLASS_WARRIOR || getClass() == CLASS_PALADIN || getClass() == CLASS_DEATH_KNIGHT)
+    {
+        nondiminishing += 5.0f;
+        return;
+    }
+
+    // Table for base dodge values
+    const float dodge_base[MAX_CLASSES] =
+    {
+         0.037580f, // Warrior
+         0.036520f, // Paladin
+        -0.054500f, // Hunter
+        -0.005900f, // Rogue
+         0.031830f, // Priest
+         0.036640f, // DK
+         0.016750f, // Shaman
+         0.034575f, // Mage
+         0.020350f, // Warlock
+         0.0f,      // ??
+         0.049510f  // Druid
+    };
+    // Crit/agility to dodge/agility coefficient multipliers; 3.2.0 increased required agility by 15%
+    const float crit_to_dodge[MAX_CLASSES] =
+    {
+         0.85f/1.15f,    // Warrior
+         1.00f/1.15f,    // Paladin
+         0.74f,          // Hunter
+         1.33f,          // Rogue
+         0.67f,          // Priest
+         0.85f/1.15f,    // DK
+         1.07f,          // Shaman
+         0.66f,          // Mage
+         0.65f,          // Warlock (?)
+         0.0f,           // ??
+         1.32f           // Druid
+    };
+
+    uint8 level = getLevel();
+    uint32 pclass = getClass();
+
+    if (level > GT_MAX_LEVEL)
+        level = GT_MAX_LEVEL;
+
+    // Dodge per agility is proportional to crit per agility, which is available from DBC files
+    GtChanceToMeleeCritEntry  const* dodgeRatio = sGtChanceToMeleeCritStore.LookupEntry((pclass-1)*GT_MAX_LEVEL + level-1);
+    if (dodgeRatio == NULL || pclass > MAX_CLASSES)
+        return;
+
+    // TODO: research if talents/effects that increase total agility by x% should increase non-diminishing part
+    float base_agility = GetCreateStat(STAT_AGILITY) * m_auraModifiersGroup[UNIT_MOD_STAT_START + STAT_AGILITY][BASE_PCT];
+    float bonus_agility = GetStat(STAT_AGILITY) - base_agility;
+
+    // calculate diminishing (green in char screen) and non-diminishing (white) contribution
+    diminishing = 100.0f * bonus_agility * dodgeRatio->ratio * crit_to_dodge[pclass-1];
+    nondiminishing = 100.0f * (dodge_base[pclass-1] + base_agility * dodgeRatio->ratio * crit_to_dodge[pclass-1]);
+}
+
+float Player::GetSpellCritFromIntellect()
+{
+    uint8 level = getLevel();
+    uint32 pclass = getClass();
+
+    if (level > GT_MAX_LEVEL)
+        level = GT_MAX_LEVEL;
+
+    GtChanceToSpellCritBaseEntry const* critBase = sGtChanceToSpellCritBaseStore.LookupEntry(pclass - 1);
+    GtChanceToSpellCritEntry const* critRatio = sGtChanceToSpellCritStore.LookupEntry((pclass - 1) * GT_MAX_LEVEL + level - 1);
+    if (critBase == NULL || critRatio == NULL)
+        return 0.0f;
+
+    float crit = critBase->base + GetStat(STAT_INTELLECT) * critRatio->ratio;
+    return crit * 100.0f;
+}
+
+float Player::GetRatingMultiplier(CombatRating cr) const
+{
+    uint8 level = getLevel();
+
+    if (level > GT_MAX_LEVEL)
+        level = GT_MAX_LEVEL;
+
+    GtCombatRatingsEntry const* Rating = sGtCombatRatingsStore.LookupEntry(cr*GT_MAX_LEVEL+level-1);
+    // gtOCTClassCombatRatingScalarStore.dbc starts with 1, CombatRating with zero, so cr+1
+    GtOCTClassCombatRatingScalarEntry const* classRating = sGtOCTClassCombatRatingScalarStore.LookupEntry((getClass()-1)*GT_MAX_RATING+cr+1);
+    if (!Rating || !classRating)
+        return 1.0f;                                        // By default use minimum coefficient (not must be called)
+
+    return classRating->ratio / Rating->ratio;
+}
+
+float Player::GetRatingBonusValue(CombatRating cr) const
+{
+    float baseResult = float(GetUInt32Value(PLAYER_FIELD_COMBAT_RATING_1 + cr)) * GetRatingMultiplier(cr);
+    if (cr != CR_RESILIENCE_PLAYER_DAMAGE_TAKEN)
+        return baseResult;
+    return float(1.0f - pow(0.99f, baseResult)) * 100.0f;
+}
+
+float Player::GetExpertiseDodgeOrParryReduction(WeaponAttackType attType) const
+{
+    switch (attType)
+    {
+        case BASE_ATTACK:
+            return GetUInt32Value(PLAYER_EXPERTISE) / 4.0f;
+        case OFF_ATTACK:
+            return GetUInt32Value(PLAYER_OFFHAND_EXPERTISE) / 4.0f;
+        default:
+            break;
+    }
+    return 0.0f;
+}
+
+float Player::OCTRegenMPPerSpirit()
+{
+    uint8 level = getLevel();
+    uint32 pclass = getClass();
+
+    if (level > GT_MAX_LEVEL)
+        level = GT_MAX_LEVEL;
+
+//    GtOCTRegenMPEntry     const* baseRatio = sGtOCTRegenMPStore.LookupEntry((pclass-1)*GT_MAX_LEVEL + level-1);
+    GtRegenMPPerSptEntry  const* moreRatio = sGtRegenMPPerSptStore.LookupEntry((pclass-1)*GT_MAX_LEVEL + level-1);
+    if (moreRatio == NULL)
+        return 0.0f;
+
+    // Formula get from PaperDollFrame script
+    float spirit    = GetStat(STAT_SPIRIT);
+    float regen     = spirit * moreRatio->ratio;
+    return regen;
+}
+
+void Player::ApplyRatingMod(CombatRating cr, int32 value, bool apply)
+{
+    m_baseRatingValue[cr] +=(apply ? value : -value);
+
+    // explicit affected values
+    switch (cr)
+    {
+        case CR_HASTE_MELEE:
+        {
+            float RatingChange = value * GetRatingMultiplier(cr);
+            ApplyAttackTimePercentMod(BASE_ATTACK, RatingChange, apply);
+            ApplyAttackTimePercentMod(OFF_ATTACK, RatingChange, apply);
+            break;
+        }
+        case CR_HASTE_RANGED:
+        {
+            ApplyAttackTimePercentMod(RANGED_ATTACK, value * GetRatingMultiplier(cr), apply);
+            break;
+        }
+        case CR_HASTE_SPELL:
+        {
+            ApplyCastTimePercentMod(value * GetRatingMultiplier(cr), apply);
+            break;
+        }
+        default:
+            break;
+    }
+
+    UpdateRating(cr);
+}
+
+void Player::UpdateRating(CombatRating cr)
+{
+    int32 amount = m_baseRatingValue[cr];
+    // Apply bonus from SPELL_AURA_MOD_RATING_FROM_STAT
+    // stat used stored in miscValueB for this aura
+    AuraEffectList const& modRatingFromStat = GetAuraEffectsByType(SPELL_AURA_MOD_RATING_FROM_STAT);
+    for (AuraEffectList::const_iterator i = modRatingFromStat.begin(); i != modRatingFromStat.end(); ++i)
+        if ((*i)->GetMiscValue() & (1<<cr))
+        {
+            amount += int32(CalculatePct(GetStat(Stats((*i)->GetMiscValueB())), (*i)->GetAmount()));
+            amount -= m_createStats[Stats((*i)->GetMiscValueB())];
+        }
+    if (amount < 0)
+        amount = 0;
+    SetUInt32Value(PLAYER_FIELD_COMBAT_RATING_1 + cr, uint32(amount));
+
+    bool affectStats = CanModifyStats();
+
+    switch (cr)
+    {
+        case CR_WEAPON_SKILL:
+        case CR_DEFENSE_SKILL:
+            break;
+        case CR_DODGE:
+            UpdateDodgePercentage();
+            break;
+        case CR_PARRY:
+            UpdateParryPercentage();
+            break;
+        case CR_BLOCK:
+            UpdateBlockPercentage();
+            break;
+        case CR_HIT_MELEE:
+            UpdateMeleeHitChances();
+            break;
+        case CR_HIT_RANGED:
+            UpdateRangedHitChances();
+            break;
+        case CR_HIT_SPELL:
+            UpdateSpellHitChances();
+            break;
+        case CR_CRIT_MELEE:
+            if (affectStats)
+            {
+                UpdateCritPercentage(BASE_ATTACK);
+                UpdateCritPercentage(OFF_ATTACK);
+            }
+            break;
+        case CR_CRIT_RANGED:
+            if (affectStats)
+                UpdateCritPercentage(RANGED_ATTACK);
+            break;
+        case CR_CRIT_SPELL:
+            if (affectStats)
+                UpdateAllSpellCritChances();
+            break;
+        case CR_HIT_TAKEN_MELEE:                            // Deprecated since Cataclysm
+        case CR_HIT_TAKEN_RANGED:                           // Deprecated since Cataclysm
+        case CR_HIT_TAKEN_SPELL:                            // Deprecated since Cataclysm
+        case CR_RESILIENCE_PLAYER_DAMAGE_TAKEN:
+        case CR_RESILIENCE_CRIT_TAKEN:
+        case CR_CRIT_TAKEN_SPELL:                           // Deprecated since Cataclysm
+            break;
+        case CR_HASTE_MELEE:                                // Implemented in Player::ApplyRatingMod
+        case CR_HASTE_RANGED:
+        case CR_HASTE_SPELL:
+            break;
+        case CR_WEAPON_SKILL_MAINHAND:                      // Implemented in Unit::RollMeleeOutcomeAgainst
+        case CR_WEAPON_SKILL_OFFHAND:
+        case CR_WEAPON_SKILL_RANGED:
+            break;
+        case CR_EXPERTISE:
+            if (affectStats)
+            {
+                UpdateExpertise(BASE_ATTACK);
+                UpdateExpertise(OFF_ATTACK);
+            }
+            break;
+        case CR_ARMOR_PENETRATION:
+            if (affectStats)
+                UpdateArmorPenetration(amount);
+            break;
+        case CR_MASTERY:
+            UpdateMastery();
+            break;
+        default:
+            break;
+    }
+}
+
+void Player::UpdateAllRatings()
+{
+    for (int cr = 0; cr < MAX_COMBAT_RATING; ++cr)
+        UpdateRating(CombatRating(cr));
+}
+
+void Player::SetRegularAttackTime()
+{
+    for (uint8 i = 0; i < MAX_ATTACK; ++i)
+    {
+        Item* tmpitem = GetWeaponForAttack(WeaponAttackType(i), true);
+        if (tmpitem && !tmpitem->IsBroken())
+        {
+            ItemTemplate const* proto = tmpitem->GetTemplate();
+            if (proto->Delay)
+                SetAttackTime(WeaponAttackType(i), proto->Delay);
+        }
+        else
+            SetAttackTime(WeaponAttackType(i), BASE_ATTACK_TIME);  // If there is no weapon reset attack time to base (might have been changed from forms)
+    }
+}
+
+//skill+step, checking for max value
+bool Player::UpdateSkill(uint32 skill_id, uint32 step)
+{
+    if (!skill_id)
+        return false;
+
+    if (skill_id == SKILL_FIST_WEAPONS)
+        skill_id = SKILL_UNARMED;
+
+    SkillStatusMap::iterator itr = mSkillStatus.find(skill_id);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return false;
+
+    uint16 field = itr->second.pos / 2;
+    uint8 offset = itr->second.pos & 1; // itr->second.pos % 2
+
+    uint16 value = GetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset);
+    uint16 max = GetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset);
+
+    if (!max || !value || value >= max)
+        return false;
+
+    if (value < max)
+    {
+        uint16 new_value = value + step;
+        if (new_value > max)
+            new_value = max;
+
+        SetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset, new_value);
+        if (itr->second.uState != SKILL_NEW)
+            itr->second.uState = SKILL_CHANGED;
+
+        UpdateSkillEnchantments(skill_id, value, new_value);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, skill_id);
+        UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, skill_id);
+        return true;
+    }
+
+    return false;
+}
+
+inline int SkillGainChance(uint32 SkillValue, uint32 GrayLevel, uint32 GreenLevel, uint32 YellowLevel)
+{
+    if (SkillValue >= GrayLevel)
+        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_GREY)*10;
+    if (SkillValue >= GreenLevel)
+        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_GREEN)*10;
+    if (SkillValue >= YellowLevel)
+        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_YELLOW)*10;
+    return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_ORANGE)*10;
+}
+
+bool Player::UpdateCraftSkill(uint32 spellid)
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateCraftSkill spellid %d", spellid);
+
+    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellid);
+
+    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
+    {
+        if (_spell_idx->second->skillId)
+        {
+            uint32 SkillValue = GetPureSkillValue(_spell_idx->second->skillId);
+
+            // Alchemy Discoveries here
+            SpellInfo const* spellEntry = sSpellMgr->GetSpellInfo(spellid);
+            if (spellEntry && spellEntry->Mechanic == MECHANIC_DISCOVERY)
+            {
+                if (uint32 discoveredSpell = GetSkillDiscoverySpell(_spell_idx->second->skillId, spellid, this))
+                    learnSpell(discoveredSpell, false);
+            }
+
+            uint32 craft_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_CRAFTING);
+
+            return UpdateSkillPro(_spell_idx->second->skillId, SkillGainChance(SkillValue,
+                _spell_idx->second->max_value,
+                (_spell_idx->second->max_value + _spell_idx->second->min_value)/2,
+                _spell_idx->second->min_value),
+                craft_skill_gain);
+        }
+    }
+    return false;
+}
+
+bool Player::UpdateGatherSkill(uint32 SkillId, uint32 SkillValue, uint32 RedLevel, uint32 Multiplicator)
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateGatherSkill(SkillId %d SkillLevel %d RedLevel %d)", SkillId, SkillValue, RedLevel);
+
+    uint32 gathering_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_GATHERING);
+
+    // For skinning and Mining chance decrease with level. 1-74 - no decrease, 75-149 - 2 times, 225-299 - 8 times
+    switch (SkillId)
+    {
+        case SKILL_HERBALISM:
+        case SKILL_LOCKPICKING:
+        case SKILL_JEWELCRAFTING:
+        case SKILL_INSCRIPTION:
+            return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
+        case SKILL_SKINNING:
+            if (sWorld->getIntConfig(CONFIG_SKILL_CHANCE_SKINNING_STEPS) == 0)
+                return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
+            else
+                return UpdateSkillPro(SkillId, (SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator) >> (SkillValue/sWorld->getIntConfig(CONFIG_SKILL_CHANCE_SKINNING_STEPS)), gathering_skill_gain);
+        case SKILL_MINING:
+            if (sWorld->getIntConfig(CONFIG_SKILL_CHANCE_MINING_STEPS) == 0)
+                return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
+            else
+                return UpdateSkillPro(SkillId, (SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator) >> (SkillValue/sWorld->getIntConfig(CONFIG_SKILL_CHANCE_MINING_STEPS)), gathering_skill_gain);
+        case SKILL_ARCHAEOLOGY:
+            if (sWorld->getIntConfig(CONFIG_SKILL_CHANCE_ARCHAEOLOGY_STEPS) == 0)
+                return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25) * Multiplicator,gathering_skill_gain);
+            else
+                return UpdateSkillPro(SkillId, (SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25) * Multiplicator) >> (SkillValue / sWorld->getIntConfig(CONFIG_SKILL_CHANCE_ARCHAEOLOGY_STEPS)), gathering_skill_gain);
+        default :
+            break;
+    }
+    return false;
+}
+
+bool Player::UpdateFishingSkill()
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateFishingSkill");
+
+    uint32 SkillValue = GetPureSkillValue(SKILL_FISHING);
+
+    int32 chance = SkillValue < 75 ? 100 : 2500/(SkillValue-50);
+
+    uint32 gathering_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_GATHERING);
+
+    return UpdateSkillPro(SKILL_FISHING, chance*10, gathering_skill_gain);
+}
+
+void Player::GiveXpForGather(uint32 const& skillId, uint32 const& reqSkillValue)
+{
+    // Skip if the profession is no gather profession
+    if (skillId != SKILL_HERBALISM && skillId != SKILL_MINING && skillId != SKILL_ARCHAEOLOGY)
+        return;
+
+    AreaTableEntry const* areaEntry = GetAreaEntryByAreaFlagAndMap(GetBaseMap()->GetAreaFlag(GetPositionX(), GetPositionY(), GetPositionZ()), GetMapId());
+    if (areaEntry == NULL)
+    {
+        sLog->outError(LOG_FILTER_GENERAL, "Player::GiveXpForGather for non existing areaEntry : x %f | y: %f | z: %f | map : %u", GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId());
+        return;
+    }
+    uint8 const levelDiff = abs(areaEntry->area_level - getLevel());
+
+    uint8 level;
+    if(levelDiff >= 10 && levelDiff < 20)
+        level = Trinity::XP::GetGrayLevel(getLevel()) + 1;
+    else if(levelDiff >= 20)
+        level = Trinity::XP::GetGrayLevel(getLevel());
+    else
+        level = getLevel() + 3;
+
+    uint32 xp = Trinity::XP::BaseGain(level, areaEntry->area_level, GetContentLevelsForMapAndZone(GetMapId(), GetZoneId())) * 2;
+
+    if(!xp || levelDiff >= 20)
+        return;
+    else if(levelDiff >= 15 && levelDiff < 25)
+        xp = uint32(xp * (1 - (levelDiff / 24)));
+
+    xp *= sWorld->getRate(RATE_XP_KILL);
+
+    GiveXP(xp, NULL);
+}
+
+bool Player::UpdateSkillPro(uint16 skillId, int32 chance, uint32 step)
+{
+    // levels sync. with spell requirement for skill levels to learn
+    // bonus abilities in sSkillLineAbilityStore
+    // Used only to avoid scan DBC at each skill grow
+    static uint32 bonusSkillLevels[] = { 75, 150, 225, 300, 375, 450, 525 };
+    static const size_t bonusSkillLevelsSize = sizeof(bonusSkillLevels) / sizeof(uint32);
+
+    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateSkillPro(SkillId %d, Chance %3.1f%%)", skillId, chance / 10.0f);
+    if (!skillId)
+        return false;
+
+    if (chance <= 0)                                         // speedup in 0 chance case
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% missed", chance / 10.0f);
+        return false;
+    }
+
+    SkillStatusMap::iterator itr = mSkillStatus.find(skillId);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return false;
+
+    uint16 field = itr->second.pos / 2;
+    uint8 offset = itr->second.pos & 1; // itr->second.pos % 2
+
+    uint16 value = GetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset);
+    uint16 max = GetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset);
+
+    if (!max || !value || value >= max)
+        return false;
+
+    if (irand(1, 1000) > chance)
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% missed", chance / 10.0f);
+        return false;
+    }
+
+    uint16 new_value = value + step;
+    if (new_value > max)
+        new_value = max;
+
+    SetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset, new_value);
+    if (itr->second.uState != SKILL_NEW)
+        itr->second.uState = SKILL_CHANGED;
+
+    for (size_t i = 0; i < bonusSkillLevelsSize; ++i)
+    {
+        uint32 bsl = bonusSkillLevels[i];
+        if (value < bsl && new_value >= bsl)
+        {
+            learnSkillRewardedSpells(skillId, new_value);
+            break;
+        }
+    }
+
+    UpdateSkillEnchantments(skillId, value, new_value);
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, skillId);
+    UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, skillId);
+    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% taken", chance / 10.0f);
+    return true;
+}
+
+void Player::ModifySkillBonus(uint32 skillid, int32 val, bool talent)
+{
+    SkillStatusMap::const_iterator itr = mSkillStatus.find(skillid);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return;
+
+    uint16 field = itr->second.pos / 2 + (talent ? PLAYER_SKILL_TALENT_0 : PLAYER_SKILL_MODIFIER_0);
+    uint8 offset = itr->second.pos & 1; // itr->second.pos % 2
+
+    uint16 bonus = GetUInt16Value(field, offset);
+
+    SetUInt16Value(field, offset, bonus + val);
+}
+
+void Player::UpdateSkillsForLevel()
+{
+    uint32 maxSkill = GetMaxSkillValueForLevel();
+
+    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
+    {
+        if (itr->second.uState == SKILL_DELETED)
+            continue;
+
+        uint32 pskill = itr->first;
+        SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(pskill);
+        if (!pSkill)
+            continue;
+
+        if (GetSkillRangeType(pSkill, false) != SKILL_RANGE_LEVEL)
+            continue;
+
+        if (IsWeaponSkill(pSkill->id))
+            continue;
+
+        uint16 field = itr->second.pos / 2;
+        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2
+
+        //uint16 val = GetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset);
+        uint16 max = GetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset);
+
+        /// update only level dependent max skill values
+        if (max != 1)
+        {
+            SetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset, maxSkill);
+            SetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset, maxSkill);
+            if (itr->second.uState != SKILL_NEW)
+                itr->second.uState = SKILL_CHANGED;
+        }
+    }
+}
+
+void Player::UpdateSkillsToMaxSkillsForLevel()
+{
+    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
+    {
+        if (itr->second.uState == SKILL_DELETED)
+            continue;
+
+        uint32 pskill = itr->first;
+        if (IsProfessionOrRidingSkill(pskill))
+            continue;
+
+        if (IsWeaponSkill(pskill))
+            continue;
+
+        uint16 field = itr->second.pos / 2;
+        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2
+
+        uint16 max = GetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset);
+
+        if (max > 1)
+        {
+            SetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset, max);
+
+            if (itr->second.uState != SKILL_NEW)
+                itr->second.uState = SKILL_CHANGED;
+        }
+    }
+}
+
+// This functions sets a skill line value (and adds if doesn't exist yet)
+// To "remove" a skill line, set it's values to zero
+void Player::SetSkill(uint16 id, uint16 step, uint16 newVal, uint16 maxVal)
+{
+    if (!id)
+        return;
+
+    uint16 currVal;
+    SkillStatusMap::iterator itr = mSkillStatus.find(id);
+
+    //has skill
+    if (itr != mSkillStatus.end() && itr->second.uState != SKILL_DELETED)
+    {
+        uint16 field = itr->second.pos / 2;
+        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2
+        currVal = GetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset);
+        if (newVal)
+        {
+            // if skill value is going down, update enchantments before setting the new value
+            if (newVal < currVal)
+                UpdateSkillEnchantments(id, currVal, newVal);
+
+            // update step
+            SetUInt16Value(PLAYER_SKILL_STEP_0 + field, offset, step);
+            // update value
+            SetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset, newVal);
+            SetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset, maxVal);
+
+            if (itr->second.uState != SKILL_NEW)
+                itr->second.uState = SKILL_CHANGED;
+
+            learnSkillRewardedSpells(id, newVal);
+            // if skill value is going up, update enchantments after setting the new value
+            if (newVal > currVal)
+                UpdateSkillEnchantments(id, currVal, newVal);
+
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILL_LEVEL, id);
+            UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
+        }
+        else                                                //remove
+        {
+            //remove enchantments needing this skill
+            UpdateSkillEnchantments(id, currVal, 0);
+            // clear skill fields
+            SetUInt16Value(PLAYER_SKILL_LINEID_0 + field, offset, 0);
+            SetUInt16Value(PLAYER_SKILL_STEP_0 + field, offset, 0);
+            SetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset, 0);
+            SetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset, 0);
+            SetUInt16Value(PLAYER_SKILL_MODIFIER_0 + field, offset, 0);
+            SetUInt16Value(PLAYER_SKILL_TALENT_0 + field, offset, 0);
+
+            // mark as deleted or simply remove from map if not saved yet
+            if (itr->second.uState != SKILL_NEW)
+                itr->second.uState = SKILL_DELETED;
+            else
+                mSkillStatus.erase(itr);
+
+            // remove all spells that related to this skill
+            for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                if (SkillLineAbilityEntry const* pAbility = sSkillLineAbilityStore.LookupEntry(j))
+                    if (pAbility->skillId == id)
+                        removeSpell(sSpellMgr->GetFirstSpellInChain(pAbility->spellId));
+
+            // Clear profession lines
+            if (GetUInt32Value(PLAYER_PROFESSION_SKILL_LINE_1) == id)
+                SetUInt32Value(PLAYER_PROFESSION_SKILL_LINE_1, 0);
+            else if (GetUInt32Value(PLAYER_PROFESSION_SKILL_LINE_1 + 1) == id)
+                SetUInt32Value(PLAYER_PROFESSION_SKILL_LINE_1 + 1, 0);
+        }
+    }
+    else if (newVal)                                        //add
+    {
+        currVal = 0;
+        for (uint32 i = 0; i < PLAYER_MAX_SKILLS; ++i)
+        {
+            uint16 field = i / 2;
+            uint8 offset = i & 1; // i % 2
+
+            if (!GetUInt16Value(PLAYER_SKILL_LINEID_0 + field, offset))
+            {
+                SkillLineEntry const* skillEntry = sSkillLineStore.LookupEntry(id);
+                if (!skillEntry)
+                {
+                    sLog->outError(LOG_FILTER_GENERAL, "Skill not found in SkillLineStore: skill #%u", id);
+                    return;
+                }
+
+                SetUInt16Value(PLAYER_SKILL_LINEID_0 + field, offset, id);
+                if (skillEntry->categoryId == SKILL_CATEGORY_PROFESSION)
+                {
+                    if (!GetUInt32Value(PLAYER_PROFESSION_SKILL_LINE_1))
+                        SetUInt32Value(PLAYER_PROFESSION_SKILL_LINE_1, id);
+                    else if (!GetUInt32Value(PLAYER_PROFESSION_SKILL_LINE_1 + 1))
+                        SetUInt32Value(PLAYER_PROFESSION_SKILL_LINE_1 + 1, id);
+                }
+
+                SetUInt16Value(PLAYER_SKILL_STEP_0 + field, offset, step);
+                SetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset, newVal);
+                SetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset, maxVal);
+
+                UpdateSkillEnchantments(id, currVal, newVal);
+                UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
+                UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILL_LEVEL, id);
+
+                // insert new entry or update if not deleted old entry yet
+                if (itr != mSkillStatus.end())
+                {
+                    itr->second.pos = i;
+                    itr->second.uState = SKILL_CHANGED;
+                }
+                else
+                    mSkillStatus.insert(SkillStatusMap::value_type(id, SkillStatusData(i, SKILL_NEW)));
+
+                // apply skill bonuses
+                SetUInt16Value(PLAYER_SKILL_MODIFIER_0 + field, offset, 0);
+                SetUInt16Value(PLAYER_SKILL_TALENT_0 + field, offset, 0);
+
+                // temporary bonuses
+                AuraEffectList const& mModSkill = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL);
+                for (AuraEffectList::const_iterator j = mModSkill.begin(); j != mModSkill.end(); ++j)
+                    if ((*j)->GetMiscValue() == int32(id))
+                        (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);
+
+                // permanent bonuses
+                AuraEffectList const& mModSkillTalent = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL_TALENT);
+                for (AuraEffectList::const_iterator j = mModSkillTalent.begin(); j != mModSkillTalent.end(); ++j)
+                    if ((*j)->GetMiscValue() == int32(id))
+                        (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);
+
+                // Learn all spells for skill
+                learnSkillRewardedSpells(id, newVal);
+                return;
+            }
+        }
+    }
+}
+
+bool Player::HasSkill(uint32 skill) const
+{
+    if (!skill)
+        return false;
+
+    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
+    return (itr != mSkillStatus.end() && itr->second.uState != SKILL_DELETED);
+}
+
+uint16 Player::GetSkillStep(uint16 skill) const
+{
+    if (!skill)
+        return 0;
+
+    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return 0;
+
+    return GetUInt16Value(PLAYER_SKILL_STEP_0 + itr->second.pos / 2, itr->second.pos & 1);
+}
+
+uint16 Player::GetSkillValue(uint32 skill) const
+{
+    if (!skill)
+        return 0;
+
+    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return 0;
+
+    uint16 field = itr->second.pos / 2;
+    uint8 offset = itr->second.pos & 1;
+
+    int32 result = int32(GetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset));
+    result += int32(GetUInt16Value(PLAYER_SKILL_MODIFIER_0 + field, offset));
+    result += int32(GetUInt16Value(PLAYER_SKILL_TALENT_0 + field, offset));
+    return result < 0 ? 0 : result;
+}
+
+uint16 Player::GetMaxSkillValue(uint32 skill) const
+{
+    if (!skill)
+        return 0;
+
+    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return 0;
+
+    uint16 field = itr->second.pos / 2;
+    uint8 offset = itr->second.pos & 1;
+
+    int32 result = int32(GetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset));
+    result += int32(GetUInt16Value(PLAYER_SKILL_MODIFIER_0 + field, offset));
+    result += int32(GetUInt16Value(PLAYER_SKILL_TALENT_0 + field, offset));
+    return result < 0 ? 0 : result;
+}
+
+uint16 Player::GetPureMaxSkillValue(uint32 skill) const
+{
+    if (!skill)
+        return 0;
+
+    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return 0;
+
+    uint16 field = itr->second.pos / 2;
+    uint8 offset = itr->second.pos & 1;
+
+    return GetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset);
+}
+
+uint16 Player::GetBaseSkillValue(uint32 skill) const
+{
+    if (!skill)
+        return 0;
+
+    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return 0;
+
+    uint16 field = itr->second.pos / 2;
+    uint8 offset = itr->second.pos & 1;
+
+    int32 result = int32(GetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset));
+    result += int32(GetUInt16Value(PLAYER_SKILL_TALENT_0 + field, offset));
+    return result < 0 ? 0 : result;
+}
+
+uint16 Player::GetPureSkillValue(uint32 skill) const
+{
+    if (!skill)
+        return 0;
+
+    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return 0;
+
+    uint16 field = itr->second.pos / 2;
+    uint8 offset = itr->second.pos & 1;
+
+    return GetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset);
+}
+
+int16 Player::GetSkillPermBonusValue(uint32 skill) const
+{
+    if (!skill)
+        return 0;
+
+    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return 0;
+
+    uint16 field = itr->second.pos / 2;
+    uint8 offset = itr->second.pos & 1;
+
+    return GetUInt16Value(PLAYER_SKILL_TALENT_0 + field, offset);
+}
+
+int16 Player::GetSkillTempBonusValue(uint32 skill) const
+{
+    if (!skill)
+        return 0;
+
+    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
+    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
+        return 0;
+
+    uint16 field = itr->second.pos / 2;
+    uint8 offset = itr->second.pos & 1;
+
+    return GetUInt16Value(PLAYER_SKILL_MODIFIER_0 + field, offset);
+}
+
+void Player::SendActionButtons(uint32 state) const
+{
+    WorldPacket data(SMSG_ACTION_BUTTONS, 1+(MAX_ACTION_BUTTONS*4));
+    /*
+        state can be 0, 1, 2
+        0 - Sends initial action buttons, client does not validate if we have the spell or not
+        1 - Used used after spec swaps, client validates if a spell is known.
+        2 - Clears the action bars client sided. This is sent during spec swap before unlearning and before sending the new buttons
+    */
+    if (state != 2)
+    {
+        for (uint8 button = 0; button < MAX_ACTION_BUTTONS; ++button)
+        {
+            ActionButtonList::const_iterator itr = m_actionButtons.find(button);
+            if (itr != m_actionButtons.end() && itr->second.uState != ACTIONBUTTON_DELETED)
+                data << uint32(itr->second.packedData);
+            else
+                data << uint32(0);
+        }
+    }
+    else
+        data.resize(MAX_ACTION_BUTTONS * 4);    // insert crap, client doesnt even parse this for state == 2
+
+    data << uint8(state);
+    GetSession()->SendPacket(&data);
+    sLog->outInfo(LOG_FILTER_NETWORKIO, "Action Buttons for '%u' spec '%u' Sent", GetGUIDLow(), GetActiveSpec());
+}
+
+bool Player::IsActionButtonDataValid(uint8 button, uint32 action, uint8 type)
+{
+    if (button >= MAX_ACTION_BUTTONS)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Action %u not added into button %u for player %s: button must be < %u", action, button, GetName().c_str(), MAX_ACTION_BUTTONS );
+        return false;
+    }
+
+    if (action >= MAX_ACTION_BUTTON_ACTION_VALUE)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Action %u not added into button %u for player %s: action must be < %u", action, button, GetName().c_str(), MAX_ACTION_BUTTON_ACTION_VALUE);
+        return false;
+    }
+
+    switch (type)
+    {
+        case ACTION_BUTTON_SPELL:
+            if (!sSpellMgr->GetSpellInfo(action))
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Spell action %u not added into button %u for player %s: spell not exist", action, button, GetName().c_str());
+                return false;
+            }
+
+            if (!HasSpell(action))
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Spell action %u not added into button %u for player %s: player don't known this spell", action, button, GetName().c_str());
+                return false;
+            }
+            break;
+        case ACTION_BUTTON_ITEM:
+            if (!sObjectMgr->GetItemTemplate(action))
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Item action %u not added into button %u for player %s: item not exist", action, button, GetName().c_str());
+                return false;
+            }
+            break;
+        case ACTION_BUTTON_FLYOUT: // TODO: check if it's valid flyout for the class (SpellFlyout.dbc)
+        case ACTION_BUTTON_C:
+        case ACTION_BUTTON_CMACRO:
+        case ACTION_BUTTON_MACRO:
+        case ACTION_BUTTON_EQSET:
+            break;
+        default:
+            sLog->outError(LOG_FILTER_PLAYER, "Unknown action type %u", type);
+            return false;                                          // other cases not checked at this moment
+    }
+
+    return true;
+}
+
+ActionButton* Player::addActionButton(uint8 button, uint32 action, uint8 type)
+{
+    if (!IsActionButtonDataValid(button, action, type))
+        return NULL;
+
+    // it create new button (NEW state) if need or return existed
+    ActionButton& ab = m_actionButtons[button];
+
+    // set data and update to CHANGED if not NEW
+    ab.SetActionAndType(action, ActionButtonType(type));
+
+    sLog->outDebug(LOG_FILTER_PLAYER, "Player '%u' Added Action '%u' (type %u) to Button '%u'", GetGUIDLow(), action, type, button);
+    return &ab;
+}
+
+void Player::removeActionButton(uint8 button)
+{
+    ActionButtonList::iterator buttonItr = m_actionButtons.find(button);
+    if (buttonItr == m_actionButtons.end() || buttonItr->second.uState == ACTIONBUTTON_DELETED)
+        return;
+
+    if (buttonItr->second.uState == ACTIONBUTTON_NEW)
+        m_actionButtons.erase(buttonItr);                   // new and not saved
+    else
+        buttonItr->second.uState = ACTIONBUTTON_DELETED;    // saved, will deleted at next save
+
+    sLog->outDebug(LOG_FILTER_PLAYER, "Action Button '%u' Removed from Player '%u'", button, GetGUIDLow());
+}
+
+ActionButton const* Player::GetActionButton(uint8 button)
+{
+    ActionButtonList::iterator buttonItr = m_actionButtons.find(button);
+    if (buttonItr == m_actionButtons.end() || buttonItr->second.uState == ACTIONBUTTON_DELETED)
+        return NULL;
+
+    return &buttonItr->second;
+}
+
+bool Player::UpdatePosition(float x, float y, float z, float orientation, bool teleport)
+{
+    if (!Unit::UpdatePosition(x, y, z, orientation, teleport))
+        return false;
+
+    if (IsVehicle())
+        GetVehicleKit()->RelocatePassengers();
+
+    //if (movementInfo.flags & MOVEMENTFLAG_MOVING)
+    //    mover->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOVE);
+    //if (movementInfo.flags & MOVEMENTFLAG_TURNING)
+    //    mover->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TURNING);
+    //AURA_INTERRUPT_FLAG_JUMP not sure
+
+    // group update
+    if (GetGroup())
+        SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POSITION);
+
+    if (GetTrader() && !IsWithinDistInMap(GetTrader(), INTERACTION_DISTANCE))
+        GetSession()->SendCancelTrade();
+
+    CheckAreaExploreAndOutdoor();
+
+    return true;
+}
+
+void Player::SaveRecallPosition()
+{
+    m_recallMap = GetMapId();
+    m_recallX = GetPositionX();
+    m_recallY = GetPositionY();
+    m_recallZ = GetPositionZ();
+    m_recallO = GetOrientation();
+}
+
+void Player::SendMessageToSetInRange(WorldPacket* data, float dist, bool self)
+{
+    if (self)
+        GetSession()->SendPacket(data);
+
+    Trinity::MessageDistDeliverer notifier(this, data, dist);
+    VisitNearbyWorldObject(dist, notifier);
+}
+
+void Player::SendMessageToSetInRange(WorldPacket* data, float dist, bool self, bool own_team_only)
+{
+    if (self)
+        GetSession()->SendPacket(data);
+
+    Trinity::MessageDistDeliverer notifier(this, data, dist, own_team_only);
+    VisitNearbyWorldObject(dist, notifier);
+}
+
+void Player::SendMessageToSet(WorldPacket* data, Player const* skipped_rcvr)
+{
+    if (skipped_rcvr != this)
+        GetSession()->SendPacket(data);
+
+    // we use World::GetMaxVisibleDistance() because i cannot see why not use a distance
+    // update: replaced by GetMap()->GetVisibilityDistance()
+    Trinity::MessageDistDeliverer notifier(this, data, GetVisibilityRange(), false, skipped_rcvr);
+    VisitNearbyWorldObject(GetVisibilityRange(), notifier);
+}
+
+void Player::SendDirectMessage(WorldPacket* data)
+{
+    m_session->SendPacket(data);
+}
+
+void Player::SendCinematicStart(uint32 CinematicSequenceId)
+{
+    SetWatchingCinematic(true);
+    WorldPacket data(SMSG_TRIGGER_CINEMATIC, 4);
+    data << uint32(CinematicSequenceId);
+    SendDirectMessage(&data);
+}
+
+void Player::SendMovieStart(uint32 MovieId)
+{
+    WorldPacket data(SMSG_TRIGGER_MOVIE, 4);
+    data << uint32(MovieId);
+    SendDirectMessage(&data);
+}
+
+void Player::CheckAreaExploreAndOutdoor()
+{
+    if (!isAlive())
+        return;
+
+    if (isInFlight())
+        return;
+
+    bool isOutdoor;
+    uint16 areaFlag = GetBaseMap()->GetAreaFlag(GetPositionX(), GetPositionY(), GetPositionZ(), &isOutdoor);
+
+    if (sWorld->getBoolConfig(CONFIG_VMAP_INDOOR_CHECK) && !isOutdoor)
+        RemoveAurasWithAttribute(SPELL_ATTR0_OUTDOORS_ONLY);
+
+    if (areaFlag == 0xffff)
+        return;
+    int offset = areaFlag / 32;
+
+    if (offset >= PLAYER_EXPLORED_ZONES_SIZE)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Wrong area flag %u in map data for (X: %f Y: %f) point to field PLAYER_EXPLORED_ZONES_1 + %u ( %u must be < %u ).", areaFlag, GetPositionX(), GetPositionY(), offset, offset, PLAYER_EXPLORED_ZONES_SIZE);
+        return;
+    }
+
+    uint32 val = (uint32)(1 << (areaFlag % 32));
+    uint32 currFields = GetUInt32Value(PLAYER_EXPLORED_ZONES_1 + offset);
+
+    if (!(currFields & val))
+    {
+        SetUInt32Value(PLAYER_EXPLORED_ZONES_1 + offset, (uint32)(currFields | val));
+
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EXPLORE_AREA);
+
+        AreaTableEntry const* areaEntry = GetAreaEntryByAreaFlagAndMap(areaFlag, GetMapId());
+        if (!areaEntry)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player %u discovered unknown area (x: %f y: %f z: %f map: %u", GetGUIDLow(), GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId());
+            return;
+        }
+
+        if (areaEntry->area_level > 0)
+        {
+            uint32 area = areaEntry->ID;
+            if (getLevel() >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+            {
+                SendExplorationExperience(area, 0);
+            }
+            else
+            {
+                int32 diff = int32(getLevel()) - areaEntry->area_level;
+                uint32 XP = 0;
+                if (diff < -5)
+                {
+                    XP = uint32(sObjectMgr->GetBaseXP(getLevel()+5)*sWorld->getRate(RATE_XP_EXPLORE));
+                }
+                else if (diff > 5)
+                {
+                    int32 exploration_percent = (100-((diff-5)*5));
+                    if (exploration_percent > 100)
+                        exploration_percent = 100;
+                    else if (exploration_percent < 0)
+                        exploration_percent = 0;
+
+                    XP = uint32(sObjectMgr->GetBaseXP(areaEntry->area_level)*exploration_percent/100*sWorld->getRate(RATE_XP_EXPLORE));
+                }
+                else
+                {
+                    XP = uint32(sObjectMgr->GetBaseXP(areaEntry->area_level)*sWorld->getRate(RATE_XP_EXPLORE));
+                }
+
+                GiveXP(XP, NULL);
+                SendExplorationExperience(area, XP);
+            }
+            sLog->outInfo(LOG_FILTER_PLAYER, "Player %u discovered a new area: %u", GetGUIDLow(), area);
+        }
+    }
+}
+
+uint32 Player::TeamForRace(uint8 race)
+{
+    if (ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race))
+    {
+        switch (rEntry->TeamID)
+        {
+            case 1: return HORDE;
+            case 7: return ALLIANCE;
+        }
+        sLog->outError(LOG_FILTER_PLAYER, "Race (%u) has wrong teamid (%u) in DBC: wrong DBC files?", uint32(race), rEntry->TeamID);
+    }
+    else
+        sLog->outError(LOG_FILTER_PLAYER, "Race (%u) not found in DBC: wrong DBC files?", uint32(race));
+
+    return ALLIANCE;
+}
+
+void Player::setFactionForRace(uint8 race)
+{
+    m_team = TeamForRace(race);
+
+    ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
+    setFaction(rEntry ? rEntry->FactionID : 0);
+}
+
+ReputationRank Player::GetReputationRank(uint32 faction) const
+{
+    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction);
+    return GetReputationMgr().GetRank(factionEntry);
+}
+
+// Calculate total reputation percent player gain with quest/creature level
+int32 Player::CalculateReputationGain(ReputationSource source, uint32 creatureOrQuestLevel, int32 rep, int32 faction, bool noQuestBonus)
+{
+    float percent = 100.0f;
+
+    float repMod = noQuestBonus ? 0.0f : float(GetTotalAuraModifier(SPELL_AURA_MOD_REPUTATION_GAIN));
+
+    // faction specific auras only seem to apply to kills
+    if (source == REPUTATION_SOURCE_KILL)
+        repMod += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_FACTION_REPUTATION_GAIN, faction);
+
+    percent += rep > 0 ? repMod : -repMod;
+
+    float rate;
+    switch (source)
+    {
+        case REPUTATION_SOURCE_KILL:
+            rate = sWorld->getRate(RATE_REPUTATION_LOWLEVEL_KILL);
+            break;
+        case REPUTATION_SOURCE_QUEST:
+        case REPUTATION_SOURCE_DAILY_QUEST:
+        case REPUTATION_SOURCE_WEEKLY_QUEST:
+        case REPUTATION_SOURCE_MONTHLY_QUEST:
+            rate = sWorld->getRate(RATE_REPUTATION_LOWLEVEL_QUEST);
+            break;
+        case REPUTATION_SOURCE_SPELL:
+        default:
+            rate = 1.0f;
+            break;
+    }
+
+    if (rate != 1.0f && creatureOrQuestLevel <= Trinity::XP::GetGrayLevel(getLevel()))
+        percent *= rate;
+
+    if (percent <= 0.0f)
+        return 0;
+
+    // Multiply result with the faction specific rate
+    if (RepRewardRate const* repData = sObjectMgr->GetRepRewardRate(faction))
+    {
+        float repRate = 0.0f;
+        switch (source)
+        {
+            case REPUTATION_SOURCE_KILL:
+                repRate = repData->creatureRate;
+                break;
+            case REPUTATION_SOURCE_QUEST:
+                repRate = repData->questRate;
+                break;
+            case REPUTATION_SOURCE_DAILY_QUEST:
+                repRate = repData->questDailyRate;
+                break;
+            case REPUTATION_SOURCE_WEEKLY_QUEST:
+                repRate = repData->questWeeklyRate;
+                break;
+            case REPUTATION_SOURCE_MONTHLY_QUEST:
+                repRate = repData->questMonthlyRate;
+                break;
+            case REPUTATION_SOURCE_SPELL:
+                repRate = repData->spellRate;
+                break;
+        }
+
+        // for custom, a rate of 0.0 will totally disable reputation gain for this faction/type
+        if (repRate <= 0.0f)
+            return 0;
+
+        percent *= repRate;
+    }
+
+    if (source != REPUTATION_SOURCE_SPELL && GetsRecruitAFriendBonus(false))
+        percent *= 1.0f + sWorld->getRate(RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS);
+
+    return CalculatePct(rep, percent);
+}
+
+//Calculates how many reputation points player gains in victim's enemy factions
+void Player::RewardOnKill (Unit *victim, float rate)
+{
+    if (!victim || victim->GetTypeId() == TYPEID_PLAYER)
+        return;
+
+    if (victim->ToCreature()->IsReputationGainDisabled())
+        return;
+
+    RewardOnKillEntry const* Rew = sObjectMgr->GetRewardOnKillEntry(victim->ToCreature()->GetCreatureTemplate()->Entry);
+
+    RewardOnKillEntry const* addRew = NULL;
+
+    // All mob in level 85 dungeons give championing Rewutation && All bosses give guild Rewutation
+    if (!Rew)
+    {
+        if (Map* map = victim->GetMap())
+        {
+            if (map->IsDungeon())
+            {
+                // Dungeon & Raid trashes
+                if (victim->getLevel() >= 82 && victim->GetMaxHealth() >= 45000)
+                {
+                    if (!map->IsHeroic())
+                        Rew = sObjectMgr->GetRewardOnKillEntry(42696);
+                    else
+                        Rew = sObjectMgr->GetRewardOnKillEntry(49667);
+                }
+
+                // Dungeon & Raid Bosses 
+                if (victim->getLevel() >= 86 && victim->GetMaxHealth() >= 2000000)
+                {
+                    if (!map->IsHeroic())
+                        Rew = sObjectMgr->GetRewardOnKillEntry(43296);
+                    else
+                        Rew = sObjectMgr->GetRewardOnKillEntry(47775);
+
+                    if (!map->IsHeroic())
+                        addRew = sObjectMgr->GetRewardOnKillEntry(43438);
+                    else
+                        addRew = sObjectMgr->GetRewardOnKillEntry(49642);
+                }
+            }
+        }
+    }
+
+    if (!Rew)
+        return;
+
+    uint32 ChampioningFaction = 0;
+
+    if (GetChampioningFaction())
+    {
+        // support for: Championing - http://www.wowwiki.com/Championing
+
+        Map const* map = GetMap();
+        if (map && map->IsNonRaidDungeon())
+        {
+            if (AccessRequirement const* accessRequirement = sObjectMgr->GetAccessRequirement(map->GetId(), map->GetDifficulty()))
+                if (accessRequirement->levelMin >= 80)
+                    ChampioningFaction = GetChampioningFaction();
+        }
+    }
+
+    uint32 team = GetTeam();
+
+    // Skip Guild rep from championing if we are in a guild group
+    if (Rew->RepFaction1 == 1168 || Rew->RepFaction2 == 1168)
+    {
+        if (GetGroup() && GetGroup()->IsGuildGroup(GetGuildId()))
+            ChampioningFaction = 0;
+    }
+
+    if (Rew->RepFaction1 && (!Rew->TeamDependent || team == ALLIANCE))
+    {
+        int32 donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rew->RepValue1, ChampioningFaction ? ChampioningFaction : Rew->RepFaction1);
+        donerep1 = int32(donerep1 * rate);
+
+        FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rew->RepFaction1);
+        uint32 current_reputation_rank1 = GetReputationMgr().GetRank(factionEntry1);
+        if (factionEntry1 && current_reputation_rank1 <= Rew->ReputationMaxCap1)
+            GetReputationMgr().ModifyReputation(factionEntry1, donerep1);
+    }
+
+    if (Rew->RepFaction2 && (!Rew->TeamDependent || team == HORDE))
+    {
+        int32 donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rew->RepValue2, ChampioningFaction ? ChampioningFaction : Rew->RepFaction2);
+        donerep2 = int32(donerep2 * rate);
+
+        FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rew->RepFaction2);
+        uint32 current_reputation_rank2 = GetReputationMgr().GetRank(factionEntry2);
+        if (factionEntry2 && current_reputation_rank2 <= Rew->ReputationMaxCap2)
+            GetReputationMgr().ModifyReputation(factionEntry2, donerep2);
+    }
+
+    // Give Additional Rep
+    if (addRew)
+    {
+
+        if (addRew->RepFaction1)
+        {
+            int32 donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), addRew->RepValue1, addRew->RepFaction1);
+            donerep1 = int32(donerep1 * rate);
+            FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(addRew->RepFaction1);
+            uint32 current_reputation_rank1 = GetReputationMgr().GetRank(factionEntry1);
+            if (factionEntry1 && current_reputation_rank1 <= addRew->ReputationMaxCap1)
+                GetReputationMgr().ModifyReputation(factionEntry1, donerep1);
+        }
+
+        if (addRew->RepFaction2)
+        {
+            int32 donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), addRew->RepValue2, addRew->RepFaction2);
+            donerep2 = int32(donerep2 * rate);
+            FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(addRew->RepFaction2);
+            uint32 current_reputation_rank2 = GetReputationMgr().GetRank(factionEntry2);
+            if (factionEntry2 && current_reputation_rank2 <= addRew->ReputationMaxCap2)
+                GetReputationMgr().ModifyReputation(factionEntry2, donerep2);
+        }
+    }
+	
+    if (Rew->CurrencyId1 && Rew->CurrencyCount1)
+    {
+        ModifyCurrency(Rew->CurrencyId1, Rew->CurrencyCount1);
+    }
+
+    if (Rew->CurrencyId2 && Rew->CurrencyCount2)
+    {
+        ModifyCurrency(Rew->CurrencyId2, Rew->CurrencyCount2);
+    }
+
+    if (Rew->CurrencyId3 && Rew->CurrencyCount3)
+    {
+        ModifyCurrency(Rew->CurrencyId3, Rew->CurrencyCount3);
+    }	
+	
+}
+
+
+// Calculate how many reputation points player gain with the quest
+void Player::RewardReputation(Quest const* quest)
+{
+    for (uint8 i = 0; i < QUEST_REPUTATIONS_COUNT; ++i)
+    {
+        if (!quest->RewardFactionId[i])
+            continue;
+
+        int32 rep = 0;
+        bool noQuestBonus = false;
+
+        if (quest->RewardFactionValueIdOverride[i])
+        {
+            rep = quest->RewardFactionValueIdOverride[i] / 100;
+            noQuestBonus = true;
+        }
+        else
+        {
+            uint32 row = ((quest->RewardFactionValueId[i] < 0) ? 1 : 0) + 1;
+            if (QuestFactionRewEntry const* questFactionRewEntry = sQuestFactionRewardStore.LookupEntry(row))
+            {
+                uint32 field = abs(quest->RewardFactionValueId[i]);
+                rep = questFactionRewEntry->QuestRewFactionValue[field];
+            }
+        }
+
+        if (!rep)
+            continue;
+
+        if (quest->IsDaily())
+            rep = CalculateReputationGain(REPUTATION_SOURCE_DAILY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
+        else if (quest->IsWeekly())
+            rep = CalculateReputationGain(REPUTATION_SOURCE_WEEKLY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
+        else if (quest->IsMonthly())
+            rep = CalculateReputationGain(REPUTATION_SOURCE_MONTHLY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
+        else
+            rep = CalculateReputationGain(REPUTATION_SOURCE_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
+
+        if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(quest->RewardFactionId[i]))
+            GetReputationMgr().ModifyReputation(factionEntry, rep);
+
+			// Give guild rep on completed quest
+        if (Guild * pGuild = sGuildMgr->GetGuildById(GetGuildId()))
+        {
+            if (uint32 exp = quest->XPValue(this))
+            {
+                uint32 gRep = exp / 450;
+                if (gRep <= 0)
+                    gRep = 1;
+
+                if (FactionEntry const* guildEntry = sFactionStore.LookupEntry(1168))
+                    GetReputationMgr().ModifyReputation(guildEntry, gRep);
+            }
+        } 
+    }
+}
+
+void Player::UpdateHonorFields()
+{
+    /// called when rewarding honor and at each save
+    time_t now = time_t(time(NULL));
+    time_t today = time_t(time(NULL) / DAY) * DAY;
+
+    if (m_lastHonorUpdateTime < today)
+    {
+        time_t yesterday = today - DAY;
+
+        uint16 kills_today = PAIR32_LOPART(GetUInt32Value(PLAYER_FIELD_KILLS));
+
+        // update yesterday's contribution
+        if (m_lastHonorUpdateTime >= yesterday)
+        {
+            // this is the first update today, reset today's contribution
+            SetUInt32Value(PLAYER_FIELD_KILLS, MAKE_PAIR32(0, kills_today));
+        }
+        else
+        {
+            // no honor/kills yesterday or today, reset
+            SetUInt32Value(PLAYER_FIELD_KILLS, 0);
+        }
+    }
+
+    m_lastHonorUpdateTime = now;
+}
+
+///Calculate the amount of honor gained based on the victim
+///and the size of the group for which the honor is divided
+///An exact honor value can also be given (overriding the calcs)
+bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvptoken)
+{
+    // do not reward honor in arenas, but enable onkill spellproc
+    if (InArena())
+    {
+        if (!victim || victim == this || victim->GetTypeId() != TYPEID_PLAYER)
+            return false;
+
+        if (GetBGTeam() == victim->ToPlayer()->GetBGTeam())
+            return false;
+
+        return true;
+    }
+
+    // 'Inactive' this aura prevents the player from gaining honor points and battleground Tokenizer
+    if (HasAura(SPELL_AURA_PLAYER_INACTIVE))
+        return false;
+
+    uint64 victim_guid = 0;
+    uint32 victim_rank = 0;
+
+    // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
+    UpdateHonorFields();
+
+    // do not reward honor in arenas, but return true to enable onkill spellproc
+    if (InBattleground() && GetBattleground() && GetBattleground()->isArena())
+        return true;
+
+    // Promote to float for calculations
+    float honor_f = (float)honor;
+
+    if (honor_f <= 0)
+    {
+        if (!victim || victim == this || victim->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
+            return false;
+
+        victim_guid = victim->GetGUID();
+
+        if (Player* plrVictim = victim->ToPlayer())
+        {
+            if (GetTeam() == plrVictim->GetTeam() && !sWorld->IsFFAPvPRealm())
+                return false;
+
+            uint8 k_level = getLevel();
+            uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
+            uint8 v_level = victim->getLevel();
+
+            if (v_level <= k_grey)
+                return false;
+
+            // PLAYER_CHOSEN_TITLE VALUES DESCRIPTION
+            //  [0]      Just name
+            //  [1..14]  Alliance honor titles and player name
+            //  [15..28] Horde honor titles and player name
+            //  [29..38] Other title and player name
+            //  [39+]    Nothing
+            uint32 victim_title = victim->GetUInt32Value(PLAYER_CHOSEN_TITLE);
+                                                        // Get Killer titles, CharTitlesEntry::bit_index
+            // Ranks:
+            //  title[1..14]  -> rank[5..18]
+            //  title[15..28] -> rank[5..18]
+            //  title[other]  -> 0
+            if (victim_title == 0)
+                victim_guid = 0;                        // Don't show HK: <rank> message, only log.
+            else if (victim_title < 15)
+                victim_rank = victim_title + 4;
+            else if (victim_title < 29)
+                victim_rank = victim_title - 14 + 4;
+            else
+                victim_guid = 0;                        // Don't show HK: <rank> message, only log.
+
+            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
+
+            // count the number of playerkills in one day
+            ApplyModUInt32Value(PLAYER_FIELD_KILLS, 1, true);
+            // and those in a lifetime
+            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_CLASS, victim->getClass());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_RACE, victim->getRace());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, 1, 0, 0, victim);
+            if (Guild *guild = GetGuild())
+                guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILLS_GUILD, 0, 0, 0, victim, this);
+        }
+        else
+        {
+            if (!victim->ToCreature()->isRacialLeader())
+                return false;
+
+            honor_f = 100.0f;                               // ??? need more info
+            victim_rank = 19;                               // HK: Leader
+        }
+    }
+
+    if (victim != NULL)
+    {
+        if (groupsize > 1)
+            honor_f /= groupsize;
+
+        // apply honor multiplier from aura (not stacking-get highest)
+        AddPct(honor_f, GetMaxPositiveAuraModifier(SPELL_AURA_MOD_HONOR_GAIN_PCT));
+    }
+
+    honor_f *= sWorld->getRate(RATE_HONOR);
+    // Back to int now
+    honor = int32(honor_f);
+    // honor - for show honor points in log
+    // victim_guid - for show victim name in log
+    // victim_rank [1..4]  HK: <dishonored rank>
+    // victim_rank [5..19] HK: <alliance\horde rank>
+    // victim_rank [0, 20+] HK: <>
+    WorldPacket data(SMSG_PVP_CREDIT, 4+8+4);
+    data << uint32(honor);
+    data << uint64(victim_guid);
+    data << uint32(victim_rank);
+
+    GetSession()->SendPacket(&data);
+
+    // add honor points
+    ModifyCurrency(CURRENCY_TYPE_HONOR_POINTS, int32(honor), true, true);
+
+    // Add guild XP
+    if (Guild *guild = GetGuild())
+        guild->GiveXP(uint32(float(honor) * sWorld->getRate(RATE_XP_HONOR_EARNED_GUILD_MODIFIER)), this);
+
+    if (InBattleground() && honor > 0)
+    {
+        if (Battleground* bg = GetBattleground())
+        {
+            bg->UpdatePlayerScore(this, SCORE_BONUS_HONOR, honor, false); //false: prevent looping
+        }
+    }
+
+    if (sWorld->getBoolConfig(CONFIG_PVP_TOKEN_ENABLE) && pvptoken)
+    {
+        if (!victim || victim == this || victim->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
+            return true;
+
+        if (victim->GetTypeId() == TYPEID_PLAYER)
+        {
+            // Check if allowed to receive it in current map
+            uint8 MapType = sWorld->getIntConfig(CONFIG_PVP_TOKEN_MAP_TYPE);
+            if ((MapType == 1 && !InBattleground() && !HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+                || (MapType == 2 && !HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+                || (MapType == 3 && !InBattleground()))
+                return true;
+
+            uint32 itemId = sWorld->getIntConfig(CONFIG_PVP_TOKEN_ID);
+            int32 count = sWorld->getIntConfig(CONFIG_PVP_TOKEN_COUNT);
+
+            if (AddItem(itemId, count))
+                ChatHandler(GetSession()).PSendSysMessage("You have been awarded a token for slaying another player.");
+        }
+    }
+
+    return true;
+}
+
+void Player::_LoadCurrency(PreparedQueryResult result)
+{
+	if (!result)
+		return;
+
+	do
+	{
+		Field* fields = result->Fetch();
+
+		uint16 currencyID = fields[0].GetUInt16();
+
+		CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(currencyID);
+		if (!currency)
+			continue;
+
+		PlayerCurrency cur;
+		cur.state = PLAYERCURRENCY_UNCHANGED;
+		cur.weekCount = fields[1].GetUInt32();
+		cur.totalCount = fields[2].GetUInt32();
+		cur.seasonCount = fields[3].GetUInt32();
+
+		_currencyStorage.insert(PlayerCurrenciesMap::value_type(currencyID, cur));
+
+	} while (result->NextRow());
+}
+
+void Player::_LoadCurrencyWeekCap(PreparedQueryResult result)
+{
+	//           0         1            2
+	// "SELECT source, maxWeekRating, weekCap FROM character_cp_weekcap WHERE guid = ?"
+
+	if (!result)
+		return;
+
+	do
+	{
+		Field *fields = result->Fetch();
+
+		uint16 source = fields[0].GetUInt16();
+		if (source != CP_SOURCE_ARENA && source != CP_SOURCE_RATED_BG)
+			continue;
+
+		m_maxWeekRating[source] = fields[1].GetUInt16();
+		m_conquestPointsWeekCap[source] = fields[2].GetUInt16();
+	} while (result->NextRow());
+}
+
+
+void Player::_SaveCurrency(SQLTransaction& trans)
+{
+	PreparedStatement* stmt = NULL;
+	for (PlayerCurrenciesMap::iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
+	{
+		CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(itr->first);
+		if (!entry) // should never happen
+			continue;
+
+		switch (itr->second.state)
+		{
+		case PLAYERCURRENCY_NEW:
+			stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_PLAYER_CURRENCY);
+			stmt->setUInt32(0, GetGUIDLow());
+			stmt->setUInt16(1, itr->first);
+			stmt->setUInt32(2, itr->second.weekCount);
+			stmt->setUInt32(3, itr->second.totalCount);
+			stmt->setUInt32(4, itr->second.seasonCount);
+			trans->Append(stmt);
+			break;
+		case PLAYERCURRENCY_CHANGED:
+			stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_CURRENCY);
+			stmt->setUInt32(0, itr->second.weekCount);
+			stmt->setUInt32(1, itr->second.totalCount);
+			stmt->setUInt32(2, itr->second.seasonCount);
+			stmt->setUInt32(3, GetGUIDLow());
+			stmt->setUInt16(4, itr->first);
+			trans->Append(stmt);
+			break;
+		default:
+			break;
+		}
+
+		itr->second.state = PLAYERCURRENCY_UNCHANGED;
+	}
+}
+
+void Player::_SaveCurrencyWeekCap(SQLTransaction& trans)
+{
+	PreparedStatement* stmt = NULL;
+
+	for (uint8 source = 0; source < CP_SOURCE_MAX; source++)
+	{
+		stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_PLAYER_CURRENCY_WEEK_CAP);
+		stmt->setUInt32(0, GetGUIDLow());
+		stmt->setUInt8(1, source);
+		stmt->setUInt16(2, m_maxWeekRating[source]);
+		stmt->setUInt16(3, m_conquestPointsWeekCap[source]);
+		trans->Append(stmt);
+	}
+}
+
+void Player::SendNewCurrency(uint32 id) const
+{
+	PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
+	if (itr == _currencyStorage.end())
+		return;
+
+	ByteBuffer currencyData;
+	WorldPacket packet(SMSG_INIT_CURRENCY, 4 + (5 * 4 + 1));
+	packet.WriteBits(1, 23);
+
+	CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(id);
+	if (!entry) // should never happen
+		return;
+
+	uint32 precision = (entry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
+	uint32 weekCount = itr->second.weekCount / precision;
+	uint32 weekCap = GetCurrencyWeekCap(entry) / precision;
+
+	packet.WriteBit(weekCount);
+	packet.WriteBits(0, 4); // some flags
+	packet.WriteBit(weekCap);
+	packet.WriteBit(itr->second.seasonCount > 0 ? 1 : 0);     // season total earned
+
+	currencyData << uint32(itr->second.totalCount / precision);
+	if (weekCap)
+		currencyData << uint32(weekCap);
+
+	if (itr->second.seasonCount > 0)
+		currencyData << uint32(itr->second.seasonCount / precision);
+
+	currencyData << uint32(entry->ID);
+	if (weekCount)
+		currencyData << uint32(weekCount);
+
+	packet.FlushBits();
+	packet.append(currencyData);
+	GetSession()->SendPacket(&packet);
+}
+
+void Player::SendCurrencies() const
+{
+	ByteBuffer currencyData;
+	WorldPacket packet(SMSG_INIT_CURRENCY, 4 + _currencyStorage.size()*(5 * 4 + 1));
+	size_t count_pos = packet.bitwpos();
+	packet.WriteBits(_currencyStorage.size(), 23);
+
+	size_t count = 0;
+	for (PlayerCurrenciesMap::const_iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
+	{
+		CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(itr->first);
+
+		// not send init meta currencies.
+		if (!entry || entry->Category == CURRENCY_CATEGORY_META_CONQUEST)
+			continue;
+
+		uint32 precision = (entry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
+		uint32 weekCount = itr->second.weekCount / precision;
+		uint32 weekCap = GetCurrencyWeekCap(entry) / precision;
+
+		packet.WriteBit(weekCount);
+		packet.WriteBits(0, 4); // some flags
+		packet.WriteBit(weekCap);
+		packet.WriteBit(itr->second.seasonCount > 0 ? 1 : 0);     // season total earned
+
+		currencyData << uint32(itr->second.totalCount / precision);
+		if (weekCap)
+			currencyData << uint32(weekCap);
+
+		if (itr->second.seasonCount > 0)
+			currencyData << uint32(itr->second.seasonCount / precision);
+
+		currencyData << uint32(entry->ID);
+		if (weekCount)
+			currencyData << uint32(weekCount);
+
+		++count;
+	}
+
+	packet.FlushBits();
+	packet.append(currencyData);
+	packet.PutBits(count_pos, count, 23);
+	GetSession()->SendPacket(&packet);
+}
+
+void Player::SendPvpRewards() const
+{
+	WorldPacket packet(SMSG_REQUEST_PVP_REWARDS_RESPONSE, 24);
+	packet << GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_POINTS, true);
+	packet << GetCurrencyOnWeek(CURRENCY_TYPE_CONQUEST_POINTS, true);
+	packet << GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_ARENA, true);
+	packet << GetCurrencyOnWeek(CURRENCY_TYPE_CONQUEST_META_ARENA, true);
+	packet << GetCurrencyOnWeek(CURRENCY_TYPE_CONQUEST_META_RBG, true);
+	packet << GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_POINTS, true);
+	packet << GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_RBG, true);
+	GetSession()->SendPacket(&packet);
+}
+
+uint32 Player::GetCurrency(uint32 id, bool usePrecision) const
+{
+	PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
+	if (itr == _currencyStorage.end())
+		return 0;
+
+	CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
+	uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
+
+	return itr->second.totalCount / precision;
+}
+
+uint32 Player::GetCurrencyOnWeek(uint32 id, bool usePrecision) const
+{
+	PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
+	if (itr == _currencyStorage.end())
+		return 0;
+
+	CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
+	uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
+
+	return itr->second.weekCount / precision;
+}
+
+
+bool Player::HasCurrency(uint32 id, uint32 count) const
+{
+	PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
+	return itr != _currencyStorage.end() && itr->second.totalCount >= count;
+}
+
+bool Player::HasCurrencySeasonCount(uint32 id, uint32 count) const
+{
+	PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
+	return itr != _currencyStorage.end() && itr->second.seasonCount >= count;
+}
+
+void Player::ModifyCurrency(uint32 id, int32 count, bool printLog/* = true*/, bool ignoreMultipliers/* = false*/, bool refund/* = false*/, bool ignoreCap/* = false*/)
+{
+	if (!count)
+		return;
+
+	CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
+	ASSERT(currency);
+
+	if (!ignoreMultipliers)
+		count *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_CURRENCY_GAIN, id);
+
+	int32 precision = currency->Flags & CURRENCY_FLAG_HIGH_PRECISION ? CURRENCY_PRECISION : 1;
+	uint32 oldTotalCount = 0;
+	uint32 oldWeekCount = 0;
+	uint32 oldSeasonCount = 0;
+
+	PlayerCurrenciesMap::iterator itr = _currencyStorage.find(id);
+	if (itr == _currencyStorage.end())
+	{
+		PlayerCurrency cur;
+		cur.state = PLAYERCURRENCY_NEW;
+		cur.totalCount = 0;
+		cur.weekCount = 0;
+		cur.seasonCount = 0;
+		_currencyStorage[id] = cur;
+		itr = _currencyStorage.find(id);
+	}
+	else
+	{
+		oldTotalCount = itr->second.totalCount;
+		oldWeekCount = itr->second.weekCount;
+		oldSeasonCount = itr->second.seasonCount;
+	}
+
+	// seasonCount
+	int32 newSeasonCount = int32(oldSeasonCount) + (!refund ? (count > 0 ? count : 0) : 0);
+
+	// count can't be more then weekCap if used (weekCap > 0)
+	uint32 weekCap = GetCurrencyWeekCap(currency);
+	if (!ignoreCap && weekCap && count > int32(weekCap))
+		count = weekCap;
+
+	// count can't be more then totalCap if used (totalCap > 0)
+	uint32 totalCap = GetCurrencyTotalCap(currency);
+	if (totalCap && count > int32(totalCap))
+		count = totalCap;
+
+	int32 newTotalCount = int32(oldTotalCount) + count;
+	if (newTotalCount < 0)
+		newTotalCount = 0;
+
+	int32 newWeekCount = int32(oldWeekCount) + (count > 0 ? count : 0);
+	if (newWeekCount < 0)
+		newWeekCount = 0;
+
+	// if we get more then weekCap just set to limit
+	if (weekCap && int32(weekCap) < newWeekCount)
+	{
+		newWeekCount = int32(weekCap);
+		// weekCap - oldWeekCount always >= 0 as we set limit before!
+		if (!ignoreCap)
+			newTotalCount = oldTotalCount + (weekCap - oldWeekCount);
+	}
+
+	// if we get more then totalCap set to maximum;
+	if (totalCap && int32(totalCap) < newTotalCount)
+	{
+		newTotalCount = int32(totalCap);
+		newWeekCount = weekCap;
+	}
+
+	if (uint32(newTotalCount) != oldTotalCount)
+	{
+		if (itr->second.state != PLAYERCURRENCY_NEW)
+			itr->second.state = PLAYERCURRENCY_CHANGED;
+
+		itr->second.totalCount = newTotalCount;
+		itr->second.weekCount = newWeekCount;
+		itr->second.seasonCount = newSeasonCount;
+
+		if (count > 0)
+			UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_CURRENCY, id, count);
+
+		if (currency->Category == CURRENCY_CATEGORY_META_CONQUEST)
+		{
+			// count was changed to week limit, now we can modify original points.
+			ModifyCurrency(CURRENCY_TYPE_CONQUEST_POINTS, count, printLog);
+			return;
+		}
+
+		WorldPacket packet(SMSG_UPDATE_CURRENCY, 12);
+
+		packet.WriteBit(weekCap != 0);
+		packet.WriteBit(itr->second.seasonCount > 0 ? 1 : 0); // hasSeasonCount
+		packet.WriteBit(!printLog); // print in log
+
+		if (itr->second.seasonCount > 0)
+			packet << uint32(itr->second.seasonCount / CURRENCY_PRECISION);
+
+		packet << uint32(newTotalCount / precision);
+		packet << uint32(id);
+		if (weekCap)
+			packet << uint32(newWeekCount / precision);
+
+		GetSession()->SendPacket(&packet);
+	}
+}
+
+void Player::SetCurrency(uint32 id, uint32 count, bool /*printLog*/ /*= true*/)
+{
+	PlayerCurrenciesMap::iterator itr = _currencyStorage.find(id);
+	if (itr == _currencyStorage.end())
+	{
+		PlayerCurrency cur;
+		cur.state = PLAYERCURRENCY_NEW;
+		cur.totalCount = count;
+		cur.weekCount = 0;
+		cur.seasonCount = count;
+		_currencyStorage[id] = cur;
+	}
+}
+
+uint32 Player::GetCurrencyWeekCap(uint32 id, bool usePrecision) const
+{
+	CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(id);
+	if (!entry)
+		return 0;
+
+	uint32 precision = (usePrecision && entry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
+
+	return GetCurrencyWeekCap(entry) / precision;
+}
+
+void Player::ResetCurrencyWeekCap()
+{
+	// How nice it's this Formula ? *_*
+	uint32 newCap = Trinity::Currency::ConquestRatingCalculator(m_maxWeekRating[CP_SOURCE_ARENA]);
+	m_conquestPointsWeekCap[CP_SOURCE_ARENA] = uint16(newCap);
+
+	// Our players must be skilled every week u.u
+	m_maxWeekRating[CP_SOURCE_ARENA] = 0;
+
+	// Update database!
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+	_SaveCurrencyWeekCap(trans);
+	_SaveCurrency(trans);
+	CharacterDatabase.CommitTransaction(trans);
+
+	// Let know players what the fuck i'm doing :V
+	SendCurrencies();
+
+	for (uint32 arenaSlot = 0; arenaSlot < MAX_ARENA_SLOT; arenaSlot++)
+	{
+		if (uint32 arenaTeamId = GetArenaTeamId(arenaSlot))
+		{
+			ArenaTeam* arenaTeam = sArenaTeamMgr->GetArenaTeamById(arenaTeamId);
+			arenaTeam->FinishWeek();                              // set played this week etc values to 0 in memory, too
+			arenaTeam->SaveToDB();                                // save changes
+			arenaTeam->NotifyStatsChanged();                      // notify the players of the changes
+		}
+	}
+
+	for (PlayerCurrenciesMap::iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
+	{
+		itr->second.weekCount = 0;
+		itr->second.state = PLAYERCURRENCY_CHANGED;
+	}
+
+	WorldPacket data(SMSG_WEEKLY_RESET_CURRENCY, 0);
+	SendDirectMessage(&data);
+}
+
+
+uint32 Player::GetCurrencyWeekCap(CurrencyTypesEntry const* currency) const
+{
+	switch (currency->ID)
+	{
+		//original conquest not have week cap
+	case CURRENCY_TYPE_CONQUEST_POINTS:
+		return std::max(GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_ARENA, false), GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_RBG, false));
+	case CURRENCY_TYPE_CONQUEST_META_ARENA:
+		// should add precision mod = 100
+		return m_conquestPointsWeekCap[CP_SOURCE_ARENA] * CURRENCY_PRECISION;
+	case CURRENCY_TYPE_CONQUEST_META_RBG:
+		// should add precision mod = 100
+		return m_conquestPointsWeekCap[CP_SOURCE_RATED_BG] * CURRENCY_PRECISION;
+	}
+
+	return currency->WeekCap;
+}
+
+uint32 Player::GetCurrencyTotalCap(CurrencyTypesEntry const* currency) const
+{
+    uint32 cap = currency->TotalCap;
+
+    switch (currency->ID)
+    {
+        case CURRENCY_TYPE_HONOR_POINTS:
+        {
+            uint32 honorcap = sWorld->getIntConfig(CONFIG_CURRENCY_MAX_HONOR_POINTS);
+            if (honorcap > 0)
+                cap = honorcap;
+            break;
+        }
+        case CURRENCY_TYPE_JUSTICE_POINTS:
+        {
+            uint32 justicecap = sWorld->getIntConfig(CONFIG_CURRENCY_MAX_JUSTICE_POINTS);
+            if (justicecap > 0)
+                cap = justicecap;
+            break;
+        }
+        case CURRENCY_TYPE_ARCHEAOLOGY_DWARF:
+        case CURRENCY_TYPE_ARCHEAOLOGY_DRAENEI:
+        case CURRENCY_TYPE_ARCHEAOLOGY_FOSSIL:
+        case CURRENCY_TYPE_ARCHEAOLOGY_NERUBIAN:
+        case CURRENCY_TYPE_ARCHEAOLOGY_NIGHT_ELF:
+        case CURRENCY_TYPE_ARCHEAOLOGY_ORC:
+        case CURRENCY_TYPE_ARCHEAOLOGY_TOLVIR:
+        case CURRENCY_TYPE_ARCHEAOLOGY_VRYKUL:
+           cap = 1500;
+           break;
+    }
+
+    return cap;
+}
+
+void Player::UpdateConquestCurrencyCap(uint32 currency)
+{
+	uint32 currenciesToUpdate[2] = { currency, CURRENCY_TYPE_CONQUEST_POINTS };
+
+	for (uint32 i = 0; i < 2; ++i)
+	{
+		CurrencyTypesEntry const* currencyEntry = sCurrencyTypesStore.LookupEntry(currenciesToUpdate[i]);
+		if (!currencyEntry)
+			continue;
+
+		uint32 precision = (currencyEntry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? 100 : 1;
+		uint32 cap = GetCurrencyWeekCap(currencyEntry);
+
+		WorldPacket packet(SMSG_UPDATE_CURRENCY_WEEK_LIMIT, 8);
+		packet << uint32(cap / precision);
+		packet << uint32(currenciesToUpdate[i]);
+		GetSession()->SendPacket(&packet);
+	}
+}
+
+void Player::SetInGuild(uint32 guildId)
+{
+    if (guildId)
+        SetUInt64Value(OBJECT_FIELD_DATA, MAKE_NEW_GUID(guildId, 0, HIGHGUID_GUILD));
+    else
+        SetUInt64Value(OBJECT_FIELD_DATA, 0);
+
+    ApplyModFlag(PLAYER_FLAGS, PLAYER_FLAGS_GUILD_LEVEL_ENABLED, guildId != 0 && sWorld->getBoolConfig(CONFIG_GUILD_LEVELING_ENABLED));
+    SetUInt16Value(OBJECT_FIELD_TYPE, 1, guildId != 0);
+}
+
+uint32 Player::GetGuildIdFromDB(uint64 guid)
+{
+    InfoCharEntry info;
+    if (sInfoMgr->GetCharInfo(GUID_LOPART(guid), info))
+        return info.Guild;
+
+    return 0;
+}
+
+uint8 Player::GetRankFromDB(uint64 guid)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
+        return result->Fetch()[1].GetUInt8();
+
+    return 0;
+}
+
+void Player::SetArenaTeamInfoField(uint8 slot, ArenaTeamInfoType type, uint32 value)
+{
+    SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (slot * ARENA_TEAM_END) + type, value);
+    if (type == ARENA_TEAM_PERSONAL_RATING && value > _maxPersonalArenaRate)
+        _maxPersonalArenaRate = value;
+	    UpdateConquestCurrencyCap(CURRENCY_TYPE_CONQUEST_META_ARENA);
+}
+
+uint32 Player::GetArenaTeamIdFromDB(uint64 guid, uint8 type)
+{
+    InfoCharEntry info;
+    if (sInfoMgr->GetCharInfo(GUID_LOPART(guid), info))
+        return info.ArenaTeam[ArenaTeam::GetSlotByType(type)];
+
+    return 0;
+}
+
+uint32 Player::GetZoneIdFromDB(uint64 guid)
+{
+    uint32 guidLow = GUID_LOPART(guid);
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_ZONE);
+    stmt->setUInt32(0, guidLow);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (!result)
+        return 0;
+    Field* fields = result->Fetch();
+    uint32 zone = fields[0].GetUInt16();
+
+    if (!zone)
+    {
+        // stored zone is zero, use generic and slow zone detection
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION_XYZ);
+        stmt->setUInt32(0, guidLow);
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+        if (!result)
+            return 0;
+        fields = result->Fetch();
+        uint32 map = fields[0].GetUInt16();
+        float posx = fields[1].GetFloat();
+        float posy = fields[2].GetFloat();
+        float posz = fields[3].GetFloat();
+
+        zone = sMapMgr->GetZoneId(map, posx, posy, posz);
+
+        if (zone > 0)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ZONE);
+
+            stmt->setUInt16(0, uint16(zone));
+            stmt->setUInt32(1, guidLow);
+
+            CharacterDatabase.Execute(stmt);
+        }
+    }
+
+    return zone;
+}
+
+uint32 Player::GetLevelFromDB(uint64 guid)
+{
+    InfoCharEntry info;
+    if (sInfoMgr->GetCharInfo(GUID_LOPART(guid), info))
+        return info.Level;
+
+
+    return 0;
+}
+
+void Player::UpdateArea(uint32 newArea)
+{
+    // FFA_PVP flags are area and not zone id dependent
+    // so apply them accordingly
+    m_areaUpdateId    = newArea;
+
+    phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_AREA_UPDATE);
+
+    AreaTableEntry const* area = GetAreaEntryByAreaID(newArea);
+    pvpInfo.inFFAPvPArea = area && (area->flags & AREA_FLAG_ARENA);
+    UpdatePvPState(true);
+
+    UpdateAreaDependentAuras(newArea);
+
+    // previously this was in UpdateZone (but after UpdateArea) so nothing will break
+    pvpInfo.inNoPvPArea = false;
+    if (area && area->IsSanctuary())    // in sanctuary
+    {
+        SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
+        pvpInfo.inNoPvPArea = true;
+        CombatStopWithPets();
+    }
+    else
+        RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
+
+    phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_AREA_UPDATE);
+}
+
+void Player::UpdateZone(uint32 newZone, uint32 newArea)
+{
+    phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
+
+    if (m_zoneUpdateId != newZone)
+    {
+        sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
+        sOutdoorPvPMgr->HandlePlayerEnterZone(this, newZone);
+        sBattlefieldMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
+        sBattlefieldMgr->HandlePlayerEnterZone(this, newZone);
+        SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
+        if (Guild* guild = GetGuild())
+            guild->UpdateMemberData(this, GUILD_MEMBER_DATA_ZONEID, newZone);
+    }
+
+    // group update
+   if (GetGroup())
+        SetGroupUpdateFlag(GROUP_UPDATE_FULL);
+
+    m_zoneUpdateId    = newZone;
+    m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;
+
+    // zone changed, so area changed as well, update it
+    UpdateArea(newArea);
+
+    if (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity())) // Don't Update Speed for Gameasters. This fixes the problem that .mod speed is overridden when you walk a few meters, which sucks.
+        UpdateSpeed(MOVE_RUN, true);
+
+    AreaTableEntry const* zone = GetAreaEntryByAreaID(newZone);
+    if (!zone)
+        return;
+
+    if (sWorld->getBoolConfig(CONFIG_WEATHER) && !HasAuraType(SPELL_AURA_FORCE_WEATHER))
+    {
+        if (Weather* weather = WeatherMgr::FindWeather(zone->ID))
+            weather->SendWeatherUpdateToPlayer(this);
+        else
+        {
+            if (!WeatherMgr::AddWeather(zone->ID))
+            {
+                // send fine weather packet to remove old zone's weather
+                WeatherMgr::SendFineWeatherUpdateToPlayer(this);
+            }
+        }
+    }
+
+    sScriptMgr->OnPlayerUpdateZone(this, newZone, newArea);
+
+    // in PvP, any not controlled zone (except zone->team == 6, default case)
+    // in PvE, only opposition team capital
+    switch (zone->team)
+    {
+        case AREATEAM_ALLY:
+            pvpInfo.inHostileArea = GetTeam() != ALLIANCE && (sWorld->IsPvPRealm() || zone->flags & AREA_FLAG_CAPITAL);
+            break;
+        case AREATEAM_HORDE:
+            pvpInfo.inHostileArea = GetTeam() != HORDE && (sWorld->IsPvPRealm() || zone->flags & AREA_FLAG_CAPITAL);
+            break;
+        case AREATEAM_NONE:
+            // overwrite for battlegrounds, maybe batter some zone flags but current known not 100% fit to this
+            pvpInfo.inHostileArea = sWorld->IsPvPRealm() || InBattleground() || zone->flags & AREA_FLAG_WINTERGRASP;
+            break;
+        default:                                            // 6 in fact
+            pvpInfo.inHostileArea = false;
+            break;
+    }
+
+    if (zone->flags & AREA_FLAG_CAPITAL)                     // Is in a capital city
+    {
+        if (!pvpInfo.inHostileArea || zone->IsSanctuary())
+        {
+            SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
+            SetRestType(REST_TYPE_IN_CITY);
+            InnEnter(time(0), GetMapId(), 0, 0, 0);
+        }
+        pvpInfo.inNoPvPArea = true;
+    }
+    else
+    {
+        if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
+        {
+            if (GetRestType() == REST_TYPE_IN_TAVERN)        // Still inside a tavern or has recently left
+            {
+                // Remove rest state if we have recently left a tavern.
+                if (GetMapId() != GetInnPosMapId() || GetExactDist(GetInnPosX(), GetInnPosY(), GetInnPosZ()) > 1.0f)
+                {
+                    RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
+                    SetRestType(REST_TYPE_NO);
+                }
+            }
+            else                                             // Recently left a capital city
+            {
+                RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
+                SetRestType(REST_TYPE_NO);
+            }
+        }
+    }
+
+    UpdatePvPState();
+
+    // remove items with area/map limitations (delete only for alive player to allow back in ghost mode)
+    // if player resurrected at teleport this will be applied in resurrect code
+    if (isAlive())
+        DestroyZoneLimitedItem(true, newZone);
+
+    // check some item equip limitations (in result lost CanTitanGrip at talent reset, for example)
+    AutoUnequipOffhandIfNeed();
+
+    // recent client version not send leave/join channel packets for built-in local channels
+    UpdateLocalChannels(newZone);
+
+    UpdateZoneDependentAuras(newZone);
+
+    phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
+}
+
+//If players are too far away from the duel flag... they lose the duel
+void Player::CheckDuelDistance(time_t currTime)
+{
+    if (!duel)
+        return;
+
+    uint64 duelFlagGUID = GetUInt64Value(PLAYER_DUEL_ARBITER);
+    GameObject* obj = GetMap()->GetGameObject(duelFlagGUID);
+    if (!obj)
+        return;
+
+    if (duel->outOfBound == 0)
+    {
+        if (!IsWithinDistInMap(obj, 80))
+        {
+            duel->outOfBound = currTime;
+
+            WorldPacket data(SMSG_DUEL_OUTOFBOUNDS, 0);
+            GetSession()->SendPacket(&data);
+        }
+    }
+    else
+    {
+        if (IsWithinDistInMap(obj, 70))
+        {
+            duel->outOfBound = 0;
+
+            WorldPacket data(SMSG_DUEL_INBOUNDS, 0);
+            GetSession()->SendPacket(&data);
+        }
+        else if (currTime >= (duel->outOfBound+10))
+            DuelComplete(DUEL_FLED);
+    }
+}
+
+bool Player::IsOutdoorPvPActive()
+{
+    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP() && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
+}
+
+void Player::DuelComplete(DuelCompleteType type)
+{
+    // duel not requested
+    if (!duel)
+        return;
+
+    sLog->outDebug(LOG_FILTER_UNITS, "Duel Complete %s %s", GetName().c_str(), duel->opponent->GetName().c_str());
+
+    WorldPacket data(SMSG_DUEL_COMPLETE, (1));
+    data << (uint8)((type != DUEL_INTERRUPTED) ? 1 : 0);
+    GetSession()->SendPacket(&data);
+
+    if (duel->opponent->GetSession())
+        duel->opponent->GetSession()->SendPacket(&data);
+
+    if (type != DUEL_INTERRUPTED)
+    {
+        data.Initialize(SMSG_DUEL_WINNER, (1+20));          // we guess size
+        data << uint8(type == DUEL_WON ? 0 : 1);            // 0 = just won; 1 = fled
+        data << duel->opponent->GetName();
+        data << GetName();
+        SendMessageToSet(&data, true);
+    }
+
+    sScriptMgr->OnPlayerDuelEnd(duel->opponent, this, type);
+
+    switch (type)
+    {
+        case DUEL_FLED:
+            // if initiator and opponent are on the same team
+            // or initiator and opponent are not PvP enabled, forcibly stop attacking
+            if (duel->initiator->GetTeam() == duel->opponent->GetTeam())
+            {
+                duel->initiator->AttackStop();
+                duel->opponent->AttackStop();
+            }
+            else
+            {
+                if (!duel->initiator->IsPvP())
+                    duel->initiator->AttackStop();
+                if (!duel->opponent->IsPvP())
+                    duel->opponent->AttackStop();
+            }
+            break;
+        case DUEL_WON:
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOSE_DUEL, 1);
+            duel->opponent->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_DUEL, 1);
+
+            // Credit for quest Death's Challenge
+            if (getClass() == CLASS_DEATH_KNIGHT && duel->opponent->GetQuestStatus(12733) == QUEST_STATUS_INCOMPLETE)
+                duel->opponent->CastSpell(duel->opponent, 52994, true);
+
+            break;
+        default:
+            break;
+    }
+
+    // Victory emote spell
+    if (type != DUEL_INTERRUPTED)
+        duel->opponent->CastSpell(duel->opponent, 52852, true);
+
+    //Remove Duel Flag object
+    GameObject* obj = GetMap()->GetGameObject(GetUInt64Value(PLAYER_DUEL_ARBITER));
+    if (obj)
+        duel->initiator->RemoveGameObject(obj, true);
+
+    /* remove auras */
+    AuraApplicationMap &itsAuras = duel->opponent->GetAppliedAuras();
+    for (AuraApplicationMap::iterator i = itsAuras.begin(); i != itsAuras.end();)
+    {
+        Aura const* aura = i->second->GetBase();
+        if (!i->second->IsPositive() && aura->GetCasterGUID() == GetGUID() && aura->GetApplyTime() >= duel->startTime)
+            duel->opponent->RemoveAura(i);
+        else
+            ++i;
+    }
+
+    AuraApplicationMap &myAuras = GetAppliedAuras();
+    for (AuraApplicationMap::iterator i = myAuras.begin(); i != myAuras.end();)
+    {
+        Aura const* aura = i->second->GetBase();
+        if (!i->second->IsPositive() && aura->GetCasterGUID() == duel->opponent->GetGUID() && aura->GetApplyTime() >= duel->startTime)
+            RemoveAura(i);
+        else
+            ++i;
+    }
+
+    // cleanup combo points
+    if (GetComboTarget() == duel->opponent->GetGUID())
+        ClearComboPoints();
+    else if (GetComboTarget() == duel->opponent->GetPetGUID())
+        ClearComboPoints();
+
+    if (duel->opponent->GetComboTarget() == GetGUID())
+        duel->opponent->ClearComboPoints();
+    else if (duel->opponent->GetComboTarget() == GetPetGUID())
+        duel->opponent->ClearComboPoints();
+
+    // Honor points after duel (the winner) - ImpConfig
+    if (uint32 amount = sWorld->getIntConfig(CONFIG_HONOR_AFTER_DUEL))
+        duel->opponent->RewardHonor(NULL, 1, amount);
+
+    //cleanups
+    SetUInt64Value(PLAYER_DUEL_ARBITER, 0);
+    SetUInt32Value(PLAYER_DUEL_TEAM, 0);
+    duel->opponent->SetUInt64Value(PLAYER_DUEL_ARBITER, 0);
+    duel->opponent->SetUInt32Value(PLAYER_DUEL_TEAM, 0);
+    UpdateSpeed(MOVE_RUN, true);
+    duel->opponent->UpdateSpeed(MOVE_RUN, true);
+
+    delete duel->opponent->duel;
+    duel->opponent->duel = NULL;
+    delete duel;
+    duel = NULL;
+}
+
+//---------------------------------------------------------//
+
+void Player::_ApplyItemMods(Item* item, uint8 slot, bool apply)
+{
+    if (slot >= INVENTORY_SLOT_BAG_END || !item)
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+
+    if (!proto)
+        return;
+
+    // not apply/remove mods for broken item
+    if (item->IsBroken())
+        return;
+
+    sLog->outInfo(LOG_FILTER_PLAYER_ITEMS, "applying mods for item %u ", item->GetGUIDLow());
+
+    uint8 attacktype = Player::GetAttackBySlot(slot);
+
+    if (proto->Socket[0].Color)                              //only (un)equipping of items with sockets can influence metagems, so no need to waste time with normal items
+        CorrectMetaGemEnchants(slot, apply);
+
+    if (attacktype < MAX_ATTACK)
+        _ApplyWeaponDependentAuraMods(item, WeaponAttackType(attacktype), apply);
+
+    _ApplyItemBonuses(proto, slot, apply);
+    ApplyItemEquipSpell(item, apply);
+    ApplyEnchantment(item, apply);
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_ApplyItemMods complete.");
+}
+
+void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply, bool only_level_scale /*= false*/)
+{
+    if (slot >= INVENTORY_SLOT_BAG_END || !proto)
+        return;
+
+    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : NULL;
+    if (only_level_scale && !ssd)
+        return;
+
+    // req. check at equip, but allow use for extended range if range limit max level, set proper level
+    uint32 ssd_level = getLevel();
+    if (ssd && ssd_level > ssd->MaxLevel)
+        ssd_level = ssd->MaxLevel;
+
+    ScalingStatValuesEntry const* ssv = ssd ? sScalingStatValuesStore.LookupEntry(ssd_level) : NULL;
+    if (only_level_scale && !ssv)
+        return;
+
+    for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+    {
+        uint32 statType = 0;
+        int32  val = 0;
+        // If set ScalingStatDistribution need get stats and values from it
+        if (ssd && ssv)
+        {
+            if (ssd->StatMod[i] < 0)
+                continue;
+            statType = ssd->StatMod[i];
+            val = (ssv->GetStatMultiplier(proto->InventoryType) * ssd->Modifier[i]) / 10000;
+        }
+        else
+        {
+            statType = proto->ItemStat[i].ItemStatType;
+            val = proto->ItemStat[i].ItemStatValue;
+        }
+
+        if (val == 0)
+            continue;
+
+        switch (statType)
+        {
+            case ITEM_MOD_MANA:
+                HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(val), apply);
+                break;
+            case ITEM_MOD_HEALTH:                           // modify HP
+                HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(val), apply);
+                break;
+            case ITEM_MOD_AGILITY:                          // modify agility
+                HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
+                ApplyStatBuffMod(STAT_AGILITY, float(val), apply);
+                break;
+            case ITEM_MOD_STRENGTH:                         //modify strength
+                HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
+                ApplyStatBuffMod(STAT_STRENGTH, float(val), apply);
+                break;
+            case ITEM_MOD_INTELLECT:                        //modify intellect
+                HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
+                ApplyStatBuffMod(STAT_INTELLECT, float(val), apply);
+                break;
+            case ITEM_MOD_SPIRIT:                           //modify spirit
+                HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(val), apply);
+                ApplyStatBuffMod(STAT_SPIRIT, float(val), apply);
+                break;
+            case ITEM_MOD_STAMINA:                          //modify stamina
+                HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(val), apply);
+                ApplyStatBuffMod(STAT_STAMINA, float(val), apply);
+                break;
+            case ITEM_MOD_DEFENSE_SKILL_RATING:
+                ApplyRatingMod(CR_DEFENSE_SKILL, int32(val), apply);
+                break;
+            case ITEM_MOD_DODGE_RATING:
+                ApplyRatingMod(CR_DODGE, int32(val), apply);
+                break;
+            case ITEM_MOD_PARRY_RATING:
+                ApplyRatingMod(CR_PARRY, int32(val), apply);
+                break;
+            case ITEM_MOD_BLOCK_RATING:
+                ApplyRatingMod(CR_BLOCK, int32(val), apply);
+                break;
+            case ITEM_MOD_HIT_MELEE_RATING:
+                ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
+                break;
+            case ITEM_MOD_HIT_RANGED_RATING:
+                ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
+                break;
+            case ITEM_MOD_HIT_SPELL_RATING:
+                ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
+                break;
+            case ITEM_MOD_CRIT_MELEE_RATING:
+                ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
+                break;
+            case ITEM_MOD_CRIT_RANGED_RATING:
+                ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
+                break;
+            case ITEM_MOD_CRIT_SPELL_RATING:
+                ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
+                break;
+            // case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+            //     ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
+            //     break;
+            // case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+            //     ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
+            //     break;
+            // case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+            //     ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
+            //     break;
+            // case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+            //     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+            //     break;
+            case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+                ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, int32(val), apply);
+                break;
+            // case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+            //     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+            //     break;
+            case ITEM_MOD_HASTE_MELEE_RATING:
+                ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
+                break;
+            case ITEM_MOD_HASTE_RANGED_RATING:
+                ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
+                break;
+            case ITEM_MOD_HASTE_SPELL_RATING:
+                ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
+                break;
+            case ITEM_MOD_HIT_RATING:
+                ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
+                ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
+                ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
+                break;
+            case ITEM_MOD_CRIT_RATING:
+                ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
+                ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
+                ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
+                break;
+            // case ITEM_MOD_HIT_TAKEN_RATING: // Unused since 3.3.5
+            //     ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
+            //     ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
+            //     ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
+            //     break;
+            // case ITEM_MOD_CRIT_TAKEN_RATING: // Unused since 3.3.5
+            //     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+            //     ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+            //     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+            //     break;
+            case ITEM_MOD_RESILIENCE_RATING:
+                ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, int32(val), apply);
+                break;
+            case ITEM_MOD_HASTE_RATING:
+                ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
+                ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
+                ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
+                break;
+            case ITEM_MOD_EXPERTISE_RATING:
+                ApplyRatingMod(CR_EXPERTISE, int32(val), apply);
+                break;
+            case ITEM_MOD_ATTACK_POWER:
+                HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(val), apply);
+                HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
+                break;
+            case ITEM_MOD_RANGED_ATTACK_POWER:
+                HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
+                break;
+            case ITEM_MOD_MANA_REGENERATION:
+                ApplyManaRegenBonus(int32(val), apply);
+                break;
+            case ITEM_MOD_ARMOR_PENETRATION_RATING:
+                ApplyRatingMod(CR_ARMOR_PENETRATION, int32(val), apply);
+                break;
+            case ITEM_MOD_SPELL_POWER:
+                ApplySpellPowerBonus(int32(val), apply);
+                break;
+            case ITEM_MOD_HEALTH_REGEN:
+                ApplyHealthRegenBonus(int32(val), apply);
+                break;
+            case ITEM_MOD_SPELL_PENETRATION:
+                ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, -val, apply);
+                m_spellPenetrationItemMod += apply ? val : -val;
+                break;
+            case ITEM_MOD_MASTERY_RATING:
+                ApplyRatingMod(CR_MASTERY, int32(val), apply);
+                break;
+            case ITEM_MOD_FIRE_RESISTANCE:
+                HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(val), apply);
+                break;
+            case ITEM_MOD_FROST_RESISTANCE:
+                HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(val), apply);
+                break;
+            case ITEM_MOD_HOLY_RESISTANCE:
+                HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(val), apply);
+                break;
+            case ITEM_MOD_SHADOW_RESISTANCE:
+                HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(val), apply);
+                break;
+            case ITEM_MOD_NATURE_RESISTANCE:
+                HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(val), apply);
+                break;
+            case ITEM_MOD_ARCANE_RESISTANCE:
+                HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(val), apply);
+                break;
+        }
+    }
+
+    // Apply Spell Power from ScalingStatValue if set
+    if (ssv && proto->Flags2 & ITEM_FLAGS_EXTRA_CASTER_WEAPON)
+        if (int32 spellbonus = int32(ssv->Spellpower))
+            ApplySpellPowerBonus(spellbonus, apply);
+
+    // If set ScalingStatValue armor get it or use item armor
+    uint32 armor = proto->Armor;
+    if (ssv && proto->Class == ITEM_CLASS_ARMOR)
+        armor = ssv->GetArmor(proto->InventoryType, proto->SubClass - 1);
+    else if (armor && proto->ArmorDamageModifier)
+        armor -= uint32(proto->ArmorDamageModifier);
+
+    if (armor)
+    {
+        UnitModifierType modType = TOTAL_VALUE;
+        if (proto->Class == ITEM_CLASS_ARMOR)
+        {
+            switch (proto->SubClass)
+            {
+                case ITEM_SUBCLASS_ARMOR_CLOTH:
+                case ITEM_SUBCLASS_ARMOR_LEATHER:
+                case ITEM_SUBCLASS_ARMOR_MAIL:
+                case ITEM_SUBCLASS_ARMOR_PLATE:
+                case ITEM_SUBCLASS_ARMOR_SHIELD:
+                    modType = BASE_VALUE;
+                break;
+            }
+        }
+        HandleStatModifier(UNIT_MOD_ARMOR, modType, float(armor), apply);
+    }
+
+    // Add armor bonus from ArmorDamageModifier if > 0
+    if (proto->ArmorDamageModifier > 0)
+        HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(proto->ArmorDamageModifier), apply);
+
+    WeaponAttackType attType = BASE_ATTACK;
+
+    if (slot == EQUIPMENT_SLOT_RANGED && (
+        proto->InventoryType == INVTYPE_RANGED || proto->InventoryType == INVTYPE_THROWN ||
+        proto->InventoryType == INVTYPE_RANGEDRIGHT))
+    {
+        attType = RANGED_ATTACK;
+    }
+    else if (slot == EQUIPMENT_SLOT_OFFHAND)
+    {
+        attType = OFF_ATTACK;
+    }
+
+    if (CanUseAttackType(attType))
+        _ApplyWeaponDamage(slot, proto, ssv, apply);
+}
+
+void Player::_ApplyWeaponDamage(uint8 slot, ItemTemplate const* proto, ScalingStatValuesEntry const* ssv, bool apply)
+{
+    WeaponAttackType attType = BASE_ATTACK;
+    float damage = 0.0f;
+
+    if (slot == EQUIPMENT_SLOT_RANGED && (
+        proto->InventoryType == INVTYPE_RANGED || proto->InventoryType == INVTYPE_THROWN ||
+        proto->InventoryType == INVTYPE_RANGEDRIGHT))
+    {
+        attType = RANGED_ATTACK;
+    }
+    else if (slot == EQUIPMENT_SLOT_OFFHAND)
+    {
+        attType = OFF_ATTACK;
+    }
+
+    float minDamage = proto->DamageMin;
+    float maxDamage = proto->DamageMax;
+
+    // If set dpsMod in ScalingStatValue use it for min (70% from average), max (130% from average) damage
+    int32 extraDPS = 0;
+    if (ssv)
+    {
+        float damageMultiplier = 0.0f;
+        extraDPS = ssv->GetDPSAndDamageMultiplier(proto->SubClass, proto->Flags2 & ITEM_FLAGS_EXTRA_CASTER_WEAPON, &damageMultiplier);
+        if (extraDPS)
+        {
+            float average = extraDPS * proto->Delay / 1000.0f;
+            minDamage = (1.0f - damageMultiplier) * average;
+            maxDamage = (1.0f + damageMultiplier) * average;
+        }
+    }
+
+    if (minDamage > 0)
+    {
+        damage = apply ? minDamage : BASE_MINDAMAGE;
+        SetBaseWeaponDamage(attType, MINDAMAGE, damage);
+    }
+
+    if (maxDamage  > 0)
+    {
+        damage = apply ? maxDamage : BASE_MAXDAMAGE;
+        SetBaseWeaponDamage(attType, MAXDAMAGE, damage);
+    }
+
+    if (proto->Delay && !IsInFeralForm())
+    {
+        if (slot == EQUIPMENT_SLOT_RANGED)
+            SetAttackTime(RANGED_ATTACK, apply ? proto->Delay: BASE_ATTACK_TIME);
+        else if (slot == EQUIPMENT_SLOT_MAINHAND)
+            SetAttackTime(BASE_ATTACK, apply ? proto->Delay: BASE_ATTACK_TIME);
+        else if (slot == EQUIPMENT_SLOT_OFFHAND)
+            SetAttackTime(OFF_ATTACK, apply ? proto->Delay: BASE_ATTACK_TIME);
+    }
+
+    if (CanModifyStats() && (damage || proto->Delay))
+        UpdateDamagePhysical(attType);
+}
+
+void Player::_ApplyWeaponDependentAuraMods(Item* item, WeaponAttackType attackType, bool apply)
+{
+    AuraEffectList const& auraCritList = GetAuraEffectsByType(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
+    for (AuraEffectList::const_iterator itr = auraCritList.begin(); itr != auraCritList.end(); ++itr)
+        _ApplyWeaponDependentAuraCritMod(item, attackType, *itr, apply);
+
+    AuraEffectList const& auraDamageFlatList = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
+    for (AuraEffectList::const_iterator itr = auraDamageFlatList.begin(); itr != auraDamageFlatList.end(); ++itr)
+        _ApplyWeaponDependentAuraDamageMod(item, attackType, *itr, apply);
+
+    AuraEffectList const& auraDamagePctList = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
+    for (AuraEffectList::const_iterator itr = auraDamagePctList.begin(); itr != auraDamagePctList.end(); ++itr)
+        _ApplyWeaponDependentAuraDamageMod(item, attackType, *itr, apply);
+}
+
+void Player::_ApplyWeaponDependentAuraCritMod(Item* item, WeaponAttackType attackType, AuraEffect const* aura, bool apply)
+{
+    // don't apply mod if item is broken or cannot be used
+    if (item->IsBroken() || !CanUseAttackType(attackType))
+        return;
+
+    // generic not weapon specific case processes in aura code
+    if (aura->GetSpellInfo()->EquippedItemClass == -1)
+        return;
+
+    BaseModGroup mod = BASEMOD_END;
+    switch (attackType)
+    {
+        case BASE_ATTACK:   mod = CRIT_PERCENTAGE;        break;
+        case OFF_ATTACK:    mod = OFFHAND_CRIT_PERCENTAGE;break;
+        case RANGED_ATTACK: mod = RANGED_CRIT_PERCENTAGE; break;
+        default: return;
+    }
+
+    if (item->IsFitToSpellRequirements(aura->GetSpellInfo()))
+        HandleBaseModValue(mod, FLAT_MOD, float (aura->GetAmount()), apply);
+}
+
+void Player::_ApplyWeaponDependentAuraDamageMod(Item* item, WeaponAttackType attackType, AuraEffect const* aura, bool apply)
+{
+    // don't apply mod if item is broken or cannot be used
+    if (item->IsBroken() || !CanUseAttackType(attackType))
+        return;
+
+    // ignore spell mods for not wands
+    if ((aura->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL) == 0 && (getClassMask() & CLASSMASK_WAND_USERS) == 0)
+        return;
+
+    // generic not weapon specific case processes in aura code
+    if (aura->GetSpellInfo()->EquippedItemClass == -1)
+        return;
+
+    UnitMods unitMod = UNIT_MOD_END;
+    switch (attackType)
+    {
+        case BASE_ATTACK:   unitMod = UNIT_MOD_DAMAGE_MAINHAND; break;
+        case OFF_ATTACK:    unitMod = UNIT_MOD_DAMAGE_OFFHAND;  break;
+        case RANGED_ATTACK: unitMod = UNIT_MOD_DAMAGE_RANGED;   break;
+        default: return;
+    }
+
+    UnitModifierType unitModType = TOTAL_VALUE;
+    switch (aura->GetAuraType())
+    {
+        case SPELL_AURA_MOD_DAMAGE_DONE:         unitModType = TOTAL_VALUE; break;
+        case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE: unitModType = TOTAL_PCT;   break;
+        default: return;
+    }
+
+    if (item->IsFitToSpellRequirements(aura->GetSpellInfo()))
+    {
+        HandleStatModifier(unitMod, unitModType, float(aura->GetAmount()), apply);
+        if (unitModType == TOTAL_VALUE)
+            ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS, aura->GetAmount(), apply);
+    }
+}
+
+void Player::ApplyItemEquipSpell(Item* item, bool apply, bool form_change)
+{
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+
+        // no spell
+        if (!spellData.SpellId)
+            continue;
+
+        // wrong triggering type
+        if (apply && spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_EQUIP)
+            continue;
+
+        // check if it is valid spell
+        SpellInfo const* spellproto = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellproto)
+            continue;
+
+        ApplyEquipSpell(spellproto, item, apply, form_change);
+    }
+}
+
+void Player::ApplyEquipSpell(SpellInfo const* spellInfo, Item* item, bool apply, bool form_change)
+{
+    if (apply)
+    {
+        // Cannot be used in this stance/form
+        if (spellInfo->CheckShapeshift(GetShapeshiftForm()) != SPELL_CAST_OK)
+            return;
+
+        if (form_change)                                    // check aura active state from other form
+        {
+            AuraApplicationMapBounds range = GetAppliedAuras().equal_range(spellInfo->Id);
+            for (AuraApplicationMap::const_iterator itr = range.first; itr != range.second; ++itr)
+                if (!item || itr->second->GetBase()->GetCastItemGUID() == item->GetGUID())
+                    return;
+        }
+
+        sLog->outDebug(LOG_FILTER_PLAYER, "WORLD: cast %s Equip spellId - %i", (item ? "item" : "itemset"), spellInfo->Id);
+
+        CastSpell(this, spellInfo, true, item);
+    }
+    else
+    {
+        if (form_change)                                     // check aura compatibility
+        {
+            // Cannot be used in this stance/form
+            if (spellInfo->CheckShapeshift(GetShapeshiftForm()) == SPELL_CAST_OK)
+                return;                                     // and remove only not compatible at form change
+        }
+
+        if (item)
+            RemoveAurasDueToItemSpell(spellInfo->Id, item->GetGUID());  // un-apply all spells, not only at-equipped
+        else
+            RemoveAura(spellInfo->Id);           // un-apply spell (item set case)
+    }
+}
+
+void Player::UpdateEquipSpellsAtFormChange()
+{
+    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (m_items[i] && !m_items[i]->IsBroken() && CanUseAttackType(GetAttackBySlot(i)))
+        {
+            ApplyItemEquipSpell(m_items[i], false, true);     // remove spells that not fit to form
+            ApplyItemEquipSpell(m_items[i], true, true);      // add spells that fit form but not active
+        }
+    }
+
+    // item set bonuses not dependent from item broken state
+    for (size_t setindex = 0; setindex < ItemSetEff.size(); ++setindex)
+    {
+        ItemSetEffect* eff = ItemSetEff[setindex];
+        if (!eff)
+            continue;
+
+        for (uint32 y = 0; y < MAX_ITEM_SET_SPELLS; ++y)
+        {
+            SpellInfo const* spellInfo = eff->spells[y];
+            if (!spellInfo)
+                continue;
+
+            ApplyEquipSpell(spellInfo, NULL, false, true);       // remove spells that not fit to form
+            ApplyEquipSpell(spellInfo, NULL, true, true);        // add spells that fit form but not active
+        }
+    }
+}
+void Player::CastItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx)
+{
+    if (!target || !target->isAlive() || target == this)
+        return;
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        // If usable, try to cast item spell
+        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (!item->IsBroken() && CanUseAttackType(attType))
+                if (ItemTemplate const* proto = item->GetTemplate())
+                {
+                    // Additional check for weapons
+                    if (proto->Class == ITEM_CLASS_WEAPON)
+                    {
+                        // offhand item cannot proc from main hand hit etc
+                        EquipmentSlots slot;
+                        switch (attType)
+                        {
+                            case BASE_ATTACK:   slot = EQUIPMENT_SLOT_MAINHAND; break;
+                            case OFF_ATTACK:    slot = EQUIPMENT_SLOT_OFFHAND;  break;
+                            case RANGED_ATTACK: slot = EQUIPMENT_SLOT_RANGED;   break;
+                            default: slot = EQUIPMENT_SLOT_END; break;
+                        }
+                        if (slot != i)
+                            continue;
+                        // Check if item is useable (forms or disarm)
+                        if (attType == BASE_ATTACK)
+                            if (!IsUseEquipedWeapon(true) && !IsInFeralForm())
+                                continue;
+                    }
+                    CastItemCombatSpell(target, attType, procVictim, procEx, item, proto);
+                }
+    }
+}
+
+void Player::CastItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto)
+{
+    // Can do effect if any damage done to target
+    if (procVictim & PROC_FLAG_TAKEN_DAMAGE)
+    //if (damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_SPELLS; ++i)
+        {
+            _Spell const& spellData = proto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            // wrong triggering type
+            if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+            if (!spellInfo)
+            {
+                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "WORLD: unknown Item spellid %i", spellData.SpellId);
+                continue;
+            }
+
+            // not allow proc extra attack spell at extra attack
+            if (m_extraAttacks && spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
+                return;
+
+            float chance = (float)spellInfo->ProcChance;
+
+            if (proto->SpellPPMRate)
+            {
+                uint32 WeaponSpeed = GetAttackTime(attType);
+                chance = GetPPMProcChance(WeaponSpeed, proto->SpellPPMRate, spellInfo);
+            }
+            else if (chance > 100.0f)
+                chance = GetWeaponProcChance();
+
+            if (roll_chance_f(chance))
+                CastSpell(target, spellInfo->Id, true, item);
+        }
+    }
+
+    // item combat enchantments
+    for (uint8 e_slot = 0; e_slot < MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+
+        for (uint8 s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            if (pEnchant->type[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
+                continue;
+
+            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);
+
+            if (entry && entry->procEx)
+            {
+                // Check hit/crit/dodge/parry requirement
+                if ((entry->procEx & procEx) == 0)
+                    continue;
+            }
+            else
+            {
+                // Can do effect if any damage done to target
+                if (!(procVictim & PROC_FLAG_TAKEN_DAMAGE))
+                //if (!(damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE))
+                    continue;
+            }
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->spellid[s]);
+            if (!spellInfo)
+            {
+                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "Player::CastItemCombatSpell(GUID: %u, name: %s, enchant: %i): unknown spell %i is casted, ignoring...",
+                    GetGUIDLow(), GetName().c_str(), pEnchant->ID, pEnchant->spellid[s]);
+                continue;
+            }
+
+            float chance = pEnchant->amount[s] != 0 ? float(pEnchant->amount[s]) : GetWeaponProcChance();
+
+            if (entry)
+            {
+                if (entry->PPMChance)
+                    chance = GetPPMProcChance(proto->Delay, entry->PPMChance, spellInfo);
+                else if (entry->customChance)
+                    chance = (float)entry->customChance;
+            }
+
+            // Apply spell mods
+            ApplySpellMod(pEnchant->spellid[s], SPELLMOD_CHANCE_OF_SUCCESS, chance);
+
+            // Shiv has 100% chance to apply the poison
+            if (FindCurrentSpellBySpellId(5938) && e_slot == TEMP_ENCHANTMENT_SLOT)
+                chance = 100.0f;
+
+            if (roll_chance_f(chance))
+            {
+                if (spellInfo->IsPositive())
+                    CastSpell(this, spellInfo, true, item);
+                else
+                    CastSpell(target, spellInfo, true, item);
+            }
+        }
+    }
+}
+
+void Player::CastItemUseSpell(Item* item, SpellCastTargets const& targets, uint8 cast_count, uint32 glyphIndex)
+{
+	ItemTemplate const* proto = item->GetTemplate();
+	// special learning case
+	if (proto->Spells[0].SpellId == 483 || proto->Spells[0].SpellId == 55884)
+	{
+		uint32 learn_spell_id = proto->Spells[0].SpellId;
+		uint32 learning_spell_id = proto->Spells[1].SpellId;
+
+		SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(learn_spell_id);
+		if (!spellInfo)
+		{
+			sLog->outError(LOG_FILTER_PLAYER, "Player::CastItemUseSpell: Item (Entry: %u) in have wrong spell id %u, ignoring ", proto->ItemId, learn_spell_id);
+			SendEquipError(EQUIP_ERR_INTERNAL_BAG_ERROR, item, NULL);
+			return;
+		}
+
+		Spell* spell = new Spell(this, spellInfo, TRIGGERED_NONE);
+		spell->m_CastItem = item;
+		spell->m_cast_count = cast_count;                   //set count of casts
+		spell->SetSpellValue(SPELLVALUE_BASE_POINT0, learning_spell_id);
+		spell->prepare(&targets);
+		return;
+	}
+
+	// use triggered flag only for items with many spell casts and for not first cast
+	uint8 count = 0;
+
+	// item spells cast at use
+	for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+	{
+		_Spell const& spellData = proto->Spells[i];
+
+		// no spell
+		if (!spellData.SpellId)
+			continue;
+
+		// wrong triggering type
+		if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
+			continue;
+
+		SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+		if (!spellInfo)
+		{
+			sLog->outError(LOG_FILTER_PLAYER, "Player::CastItemUseSpell: Item (Entry: %u) in have wrong spell id %u, ignoring", proto->ItemId, spellData.SpellId);
+			continue;
+		}
+
+		Spell* spell = new Spell(this, spellInfo, (count > 0) ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+		spell->m_CastItem = item;
+		spell->m_cast_count = cast_count;                   // set count of casts
+		spell->m_glyphIndex = glyphIndex;                   // glyph index
+		spell->prepare(&targets);
+
+		++count;
+	}
+
+	// Item enchantments spells cast at use
+	for (uint8 e_slot = 0; e_slot < MAX_ENCHANTMENT_SLOT; ++e_slot)
+	{
+		if (e_slot > PRISMATIC_ENCHANTMENT_SLOT && e_slot < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
+			continue;
+
+		uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+		SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+		if (!pEnchant)
+			continue;
+		for (uint8 s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+		{
+			if (pEnchant->type[s] != ITEM_ENCHANTMENT_TYPE_USE_SPELL)
+				continue;
+
+			SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->spellid[s]);
+			if (!spellInfo)
+			{
+				sLog->outError(LOG_FILTER_PLAYER, "Player::CastItemUseSpell Enchant %i, cast unknown spell %i", pEnchant->ID, pEnchant->spellid[s]);
+				continue;
+			}
+
+			Spell* spell = new Spell(this, spellInfo, (count > 0) ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+			spell->m_CastItem = item;
+			spell->m_cast_count = cast_count;               // set count of casts
+			spell->m_glyphIndex = glyphIndex;               // glyph index
+			spell->prepare(&targets);
+
+			++count;
+		}
+	}
+}
+
+
+void Player::_RemoveAllItemMods()
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_RemoveAllItemMods start.");
+
+    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (m_items[i])
+        {
+            ItemTemplate const* proto = m_items[i]->GetTemplate();
+            if (!proto)
+                continue;
+
+            // item set bonuses not dependent from item broken state
+            if (proto->ItemSet)
+                RemoveItemsSetItem(this, proto);
+
+            if (m_items[i]->IsBroken() || !CanUseAttackType(GetAttackBySlot(i)))
+                continue;
+
+            ApplyItemEquipSpell(m_items[i], false);
+            ApplyEnchantment(m_items[i], false);
+        }
+    }
+
+    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (m_items[i])
+        {
+            if (m_items[i]->IsBroken() || !CanUseAttackType(GetAttackBySlot(i)))
+                continue;
+            ItemTemplate const* proto = m_items[i]->GetTemplate();
+            if (!proto)
+                continue;
+
+            uint32 attacktype = Player::GetAttackBySlot(i);
+            if (attacktype < MAX_ATTACK)
+                _ApplyWeaponDependentAuraMods(m_items[i], WeaponAttackType(attacktype), false);
+
+            _ApplyItemBonuses(proto, i, false);
+        }
+    }
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_RemoveAllItemMods complete.");
+}
+
+void Player::_ApplyAllItemMods()
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_ApplyAllItemMods start.");
+
+    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (m_items[i])
+        {
+            if (m_items[i]->IsBroken() || !CanUseAttackType(GetAttackBySlot(i)))
+                continue;
+
+            ItemTemplate const* proto = m_items[i]->GetTemplate();
+            if (!proto)
+                continue;
+
+            uint32 attacktype = Player::GetAttackBySlot(i);
+            if (attacktype < MAX_ATTACK)
+                _ApplyWeaponDependentAuraMods(m_items[i], WeaponAttackType(attacktype), true);
+
+            _ApplyItemBonuses(proto, i, true);
+        }
+    }
+
+    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (m_items[i])
+        {
+            ItemTemplate const* proto = m_items[i]->GetTemplate();
+            if (!proto)
+                continue;
+
+            // item set bonuses not dependent from item broken state
+            if (proto->ItemSet)
+                AddItemsSetItem(this, m_items[i]);
+
+            if (m_items[i]->IsBroken() || !CanUseAttackType(GetAttackBySlot(i)))
+                continue;
+
+            ApplyItemEquipSpell(m_items[i], true);
+            ApplyEnchantment(m_items[i], true);
+        }
+    }
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_ApplyAllItemMods complete.");
+}
+
+void Player::_ApplyAllLevelScaleItemMods(bool apply)
+{
+    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (m_items[i])
+        {
+            if (m_items[i]->IsBroken() || !CanUseAttackType(GetAttackBySlot(i)))
+                continue;
+
+            ItemTemplate const* proto = m_items[i]->GetTemplate();
+            if (!proto)
+                continue;
+
+            _ApplyItemBonuses(proto, i, apply, true);
+        }
+    }
+}
+
+/*  If in a battleground a player dies, and an enemy removes the insignia, the player's bones is lootable
+    Called by remove insignia spell effect    */
+void Player::RemovedInsignia(Player* looterPlr)
+{
+    if (!GetBattlegroundId())
+        return;
+
+    // If not released spirit, do it !
+    if (m_deathTimer > 0)
+    {
+        m_deathTimer = 0;
+        BuildPlayerRepop();
+        RepopAtGraveyard();
+    }
+
+    // We have to convert player corpse to bones, not to be able to resurrect there
+    // SpawnCorpseBones isn't handy, 'cos it saves player while he in BG
+    Corpse* bones = sObjectAccessor->ConvertCorpseForPlayer(GetGUID(), true);
+    if (!bones)
+        return;
+
+    // Now we must make bones lootable, and send player loot
+    bones->SetFlag(CORPSE_FIELD_DYNAMIC_FLAGS, CORPSE_DYNFLAG_LOOTABLE);
+
+    // We store the level of our player in the gold field
+    // We retrieve this information at Player::SendLoot()
+    bones->loot.gold = getLevel();
+    bones->lootRecipient = looterPlr;
+    looterPlr->SendLoot(bones->GetGUID(), LOOT_INSIGNIA);
+}
+
+void Player::SendLootRelease(uint64 guid)
+{
+    WorldPacket data(SMSG_LOOT_RELEASE_RESPONSE, (8+1));
+    data << uint64(guid) << uint8(1);
+    SendDirectMessage(&data);
+}
+
+void Player::SendLoot(uint64 guid, LootType loot_type)
+{
+    if (uint64 lguid = GetLootGUID())
+        m_session->DoLootRelease(lguid);
+
+    Loot* loot = 0;
+    PermissionTypes permission = ALL_PERMISSION;
+
+    sLog->outDebug(LOG_FILTER_LOOT, "Player::SendLoot");
+    if (IS_GAMEOBJECT_GUID(guid))
+    {
+        sLog->outDebug(LOG_FILTER_LOOT, "IS_GAMEOBJECT_GUID(guid)");
+        GameObject* go = GetMap()->GetGameObject(guid);
+
+        // not check distance for GO in case owned GO (fishing bobber case, for example)
+        // And permit out of range GO with no owner in case fishing hole
+        if (!go || (loot_type != LOOT_FISHINGHOLE && (loot_type != LOOT_FISHING || go->GetOwnerGUID() != GetGUID()) && !go->IsWithinDistInMap(this, INTERACTION_DISTANCE)) || (loot_type == LOOT_CORPSE && go->GetRespawnTime() && go->isSpawnedByDefault()))
+        {
+            SendLootRelease(guid);
+            return;
+        }
+
+        loot = &go->loot;
+
+        if (go->getLootState() == GO_READY)
+        {
+            uint32 lootid = go->GetGOInfo()->GetLootId();
+
+            //TODO: fix this big hack
+            if ((go->GetEntry() == BG_AV_OBJECTID_MINE_N || go->GetEntry() == BG_AV_OBJECTID_MINE_S))
+                if (Battleground* bg = GetBattleground())
+                    if (bg->GetTypeID(true) == BATTLEGROUND_AV)
+                        if (!(((BattlegroundAV*)bg)->PlayerCanDoMineQuest(go->GetEntry(), GetTeam())))
+                        {
+                            SendLootRelease(guid);
+                            return;
+                        }
+
+            if (lootid)
+            {
+                loot->clear();
+
+                Group* group = GetGroup();
+                bool groupRules = (group && go->GetGOInfo()->type == GAMEOBJECT_TYPE_CHEST && go->GetGOInfo()->chest.groupLootRules);
+
+                // check current RR player and get next if necessary
+                if (groupRules)
+                    group->UpdateLooterGuid(go, true);
+
+                loot->FillLoot(lootid, LootTemplates_Gameobject, this, !groupRules, false, go->GetLootMode());
+
+                // get next RR player (for next loot)
+                if (groupRules)
+                    group->UpdateLooterGuid(go);
+            }
+
+            if (loot_type == LOOT_FISHING)
+                go->getFishLoot(loot, this);
+
+            if (go->GetGOInfo()->type == GAMEOBJECT_TYPE_CHEST && go->GetGOInfo()->chest.groupLootRules)
+            {
+                if (Group* group = GetGroup())
+                {
+                    switch (group->GetLootMethod())
+                    {
+                        case GROUP_LOOT:
+                            // GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
+                            group->GroupLoot(loot, go);
+                            break;
+                        case NEED_BEFORE_GREED:
+                            group->NeedBeforeGreed(loot, go);
+                            break;
+                        case MASTER_LOOT:
+                            group->MasterLoot(loot, go);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+
+            go->SetLootState(GO_ACTIVATED, this);
+        }
+
+        if (go->getLootState() == GO_ACTIVATED)
+        {
+            if (Group* group = GetGroup())
+            {
+                switch (group->GetLootMethod())
+                {
+                    case MASTER_LOOT:
+                        permission = MASTER_PERMISSION;
+                        break;
+                    case FREE_FOR_ALL:
+                        permission = ALL_PERMISSION;
+                        break;
+                    case ROUND_ROBIN:
+                        permission = ROUND_ROBIN_PERMISSION;
+                        break;
+                    default:
+                        permission = GROUP_PERMISSION;
+                        break;
+                }
+            }
+            else
+                permission = ALL_PERMISSION;
+        }
+    }
+    else if (IS_ITEM_GUID(guid))
+    {
+        Item* item = GetItemByGuid(guid);
+
+        if (!item)
+        {
+            SendLootRelease(guid);
+            return;
+        }
+
+        permission = OWNER_PERMISSION;
+
+        loot = &item->loot;
+
+        // If item doesn't already have loot, attempt to load it. If that
+        //  fails then this is first time opening, generate loot
+        if (!item->m_lootGenerated && !item->ItemContainerLoadLootFromDB())
+        {
+            item->m_lootGenerated = true;
+            loot->clear();
+
+            switch (loot_type)
+            {
+                case LOOT_DISENCHANTING:
+                    loot->FillLoot(item->GetTemplate()->DisenchantID, LootTemplates_Disenchant, this, true);
+                    break;
+                case LOOT_PROSPECTING:
+                    loot->FillLoot(item->GetEntry(), LootTemplates_Prospecting, this, true);
+                    break;
+                case LOOT_MILLING:
+                    loot->FillLoot(item->GetEntry(), LootTemplates_Milling, this, true);
+                    break;
+                default:
+                    loot->generateMoneyLoot(item->GetTemplate()->MinMoneyLoot, item->GetTemplate()->MaxMoneyLoot);
+                    loot->FillLoot(item->GetEntry(), LootTemplates_Item, this, true, loot->gold != 0);
+
+                    // Force save the loot and money items that were just rolled
+                    //  Also saves the container item ID in Loot struct (not to DB)
+                    if (loot->gold > 0 || loot->unlootedCount > 0)
+                        item->ItemContainerSaveLootToDB();
+
+                    break;
+            }
+        }
+    }
+    else if (IS_CORPSE_GUID(guid))                          // remove insignia
+    {
+        Corpse* bones = ObjectAccessor::GetCorpse(*this, guid);
+
+        if (!bones || !(loot_type == LOOT_CORPSE || loot_type == LOOT_INSIGNIA) || bones->GetType() != CORPSE_BONES)
+        {
+            SendLootRelease(guid);
+            return;
+        }
+
+        loot = &bones->loot;
+
+        if (!bones->lootForBody)
+        {
+            bones->lootForBody = true;
+            uint32 pLevel = bones->loot.gold;
+            bones->loot.clear();
+            if (Battleground* bg = GetBattleground())
+                if (bg->GetTypeID(true) == BATTLEGROUND_AV)
+                    loot->FillLoot(1, LootTemplates_Creature, this, true);
+            // It may need a better formula
+            // Now it works like this: lvl10: ~6copper, lvl70: ~9silver
+            bones->loot.gold = uint32(urand(50, 150) * 0.016f * pow(float(pLevel)/5.76f, 2.5f) * sWorld->getRate(RATE_DROP_MONEY));
+        }
+
+        if (bones->lootRecipient != this)
+            permission = NONE_PERMISSION;
+        else
+            permission = OWNER_PERMISSION;
+    }
+    else
+    {
+        Creature* creature = GetMap()->GetCreature(guid);
+
+        // must be in range and creature must be alive for pickpocket and must be dead for another loot
+        if (!creature || creature->isAlive() != (loot_type == LOOT_PICKPOCKETING) || !creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
+        {
+            SendLootRelease(guid);
+            return;
+        }
+
+        if (loot_type == LOOT_PICKPOCKETING && IsFriendlyTo(creature))
+        {
+            SendLootRelease(guid);
+            return;
+        }
+
+        loot = &creature->loot;
+
+        if (loot_type == LOOT_PICKPOCKETING)
+        {
+            if (!creature->lootForPickPocketed)
+            {
+                creature->lootForPickPocketed = true;
+                loot->clear();
+
+                if (uint32 lootid = creature->GetCreatureTemplate()->pickpocketLootId)
+                    loot->FillLoot(lootid, LootTemplates_Pickpocketing, this, true);
+
+                // Generate extra money for pick pocket loot
+                const uint32 a = urand(0, creature->getLevel()/2);
+                const uint32 b = urand(0, getLevel()/2);
+                loot->gold = uint32(10 * (a + b) * sWorld->getRate(RATE_DROP_MONEY));
+                permission = OWNER_PERMISSION;
+            }
+        }
+        else
+        {
+            // the player whose group may loot the corpse
+            Player* recipient = creature->GetLootRecipient();
+            if (!recipient)
+                return;
+
+            if (!creature->lootForBody)
+            {
+                creature->lootForBody = true;
+
+                // for creature, loot is filled when creature is killed.
+
+                if (Group* group = recipient->GetGroup())
+                {
+                    switch (group->GetLootMethod())
+                    {
+                        case GROUP_LOOT:
+                            // GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
+                            group->GroupLoot(loot, creature);
+                            break;
+                        case NEED_BEFORE_GREED:
+                            group->NeedBeforeGreed(loot, creature);
+                            break;
+                        case MASTER_LOOT:
+                            group->MasterLoot(loot, creature);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+
+            // possible only if creature->lootForBody && loot->empty() at spell cast check
+            if (loot_type == LOOT_SKINNING)
+            {
+                loot->clear();
+                loot->FillLoot(creature->GetCreatureTemplate()->SkinLootId, LootTemplates_Skinning, this, true);
+                permission = OWNER_PERMISSION;
+            }
+            // set group rights only for loot_type != LOOT_SKINNING
+            else
+            {
+                if (Group* group = GetGroup())
+                {
+                    if (group == recipient->GetGroup())
+                    {
+                        switch (group->GetLootMethod())
+                        {
+                            case MASTER_LOOT:
+                                permission = MASTER_PERMISSION;
+                                break;
+                            case FREE_FOR_ALL:
+                                permission = ALL_PERMISSION;
+                                break;
+                            case ROUND_ROBIN:
+                                permission = ROUND_ROBIN_PERMISSION;
+                                break;
+                            default:
+                                permission = GROUP_PERMISSION;
+                                break;
+                        }
+                    }
+                    else
+                        permission = NONE_PERMISSION;
+                }
+                else if (recipient == this)
+                    permission = OWNER_PERMISSION;
+                else
+                    permission = NONE_PERMISSION;
+            }
+        }
+    }
+
+    SetLootGUID(guid);
+
+    // LOOT_INSIGNIA and LOOT_FISHINGHOLE unsupported by client
+    switch (loot_type)
+    {
+        case LOOT_INSIGNIA:    loot_type = LOOT_SKINNING; break;
+        case LOOT_FISHINGHOLE: loot_type = LOOT_FISHING; break;
+        default: break;
+    }
+
+    // need know merged fishing/corpse loot type for achievements
+    loot->loot_type = loot_type;
+
+    WorldPacket data(SMSG_LOOT_RESPONSE, 8 + 1 + 50 + 1 + 1);           // we guess size
+    data << uint64(guid);
+    data << uint8(loot_type);
+    data << LootView(*loot, this, permission);
+
+    SendDirectMessage(&data);
+
+    // add 'this' player as one of the players that are looting 'loot'
+    if (permission != NONE_PERMISSION)
+        loot->AddLooter(GetGUID());
+
+    if (loot_type == LOOT_CORPSE && !IS_ITEM_GUID(guid))
+        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
+}
+
+void Player::SendNotifyLootMoneyRemoved()
+{
+    WorldPacket data(SMSG_LOOT_CLEAR_MONEY, 0);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendNotifyLootItemRemoved(uint8 lootSlot)
+{
+    WorldPacket data(SMSG_LOOT_REMOVED, 1);
+    data << uint8(lootSlot);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendUpdateWorldState(uint32 Field, uint32 Value)
+{
+    WorldPacket data(SMSG_UPDATE_WORLD_STATE, 4+4+1);
+    data << Field;
+    data << Value;
+    data << uint8(0);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
+{
+    // data depends on zoneid/mapid...
+    Battleground* bg = GetBattleground();
+    uint32 mapid = GetMapId();
+    OutdoorPvP* pvp = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(zoneid);
+    InstanceScript* instance = GetInstanceScript();
+    Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(zoneid);
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Sending SMSG_INIT_WORLD_STATES to Map: %u, Zone: %u", mapid, zoneid);
+
+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(12*8)));
+    data << uint32(mapid);                                  // mapid
+    data << uint32(zoneid);                                 // zone id
+    data << uint32(areaid);                                 // area id, new 2.1.0
+    size_t countPos = data.wpos();
+    data << uint16(0);                                      // count of uint64 blocks
+    data << uint32(0x8d8) << uint32(0x0);                   // 1
+    data << uint32(0x8d7) << uint32(0x0);                   // 2
+    data << uint32(0x8d6) << uint32(0x0);                   // 3
+    data << uint32(0x8d5) << uint32(0x0);                   // 4
+    data << uint32(0x8d4) << uint32(0x0);                   // 5
+    data << uint32(0x8d3) << uint32(0x0);                   // 6
+                                                            // 7 Arena season id (if 0 end of season)
+    data << uint32(0xC77) << uint32(sWorld->getBoolConfig(CONFIG_ARENA_SEASON_IN_PROGRESS) ?
+        sWorld->getIntConfig(CONFIG_ARENA_SEASON_ID) : 0);
+                                                            // 8 Previous arena season id
+    data << uint32(0xf3d) << uint32(sWorld->getIntConfig(CONFIG_ARENA_SEASON_ID) - 1);
+                                                            // 9 Rated BattleGround Enabled
+    data << uint32(0x1584) << uint32(sWorld->getBoolConfig(CONFIG_RATED_BATTLEGROUND_ENABLED));
+
+    if (mapid == 530)                                       // Outland
+    {
+        data << uint32(0x9bf) << uint32(0x0);               // 7
+        data << uint32(0x9bd) << uint32(0xF);               // 8
+        data << uint32(0x9bb) << uint32(0xF);               // 9
+    }
+
+    // insert <field> <value>
+    switch (zoneid)
+    {
+        case 1:                                             // Dun Morogh
+        case 11:                                            // Wetlands
+        case 12:                                            // Elwynn Forest
+        case 38:                                            // Loch Modan
+        case 40:                                            // Westfall
+        case 51:                                            // Searing Gorge
+        case 1519:                                          // Stormwind City
+        case 1537:                                          // Ironforge
+        case 2257:                                          // Deeprun Tram
+        case 3703:                                          // Shattrath City
+            break;
+        case 1377:                                          // Silithus
+            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_SI)
+                pvp->FillInitialWorldStates(data);
+            else
+            {
+                // states are always shown
+                data << uint32(2313) << uint32(0x0); // 7 ally silityst gathered
+                data << uint32(2314) << uint32(0x0); // 8 horde silityst gathered
+                data << uint32(2317) << uint32(0x0); // 9 max silithyst
+            }
+            // dunno about these... aq opening event maybe?
+            data << uint32(2322) << uint32(0x0); // 10 sandworm N
+            data << uint32(2323) << uint32(0x0); // 11 sandworm S
+            data << uint32(2324) << uint32(0x0); // 12 sandworm SW
+            data << uint32(2325) << uint32(0x0); // 13 sandworm E
+            break;
+        case 2597:                                          // Alterac Valley
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AV)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x7ae) << uint32(0x1);           // 7 snowfall n
+                data << uint32(0x532) << uint32(0x1);           // 8 frostwolfhut hc
+                data << uint32(0x531) << uint32(0x0);           // 9 frostwolfhut ac
+                data << uint32(0x52e) << uint32(0x0);           // 10 stormpike firstaid a_a
+                data << uint32(0x571) << uint32(0x0);           // 11 east frostwolf tower horde assaulted -unused
+                data << uint32(0x570) << uint32(0x0);           // 12 west frostwolf tower horde assaulted - unused
+                data << uint32(0x567) << uint32(0x1);           // 13 frostwolfe c
+                data << uint32(0x566) << uint32(0x1);           // 14 frostwolfw c
+                data << uint32(0x550) << uint32(0x1);           // 15 irondeep (N) ally
+                data << uint32(0x544) << uint32(0x0);           // 16 ice grave a_a
+                data << uint32(0x536) << uint32(0x0);           // 17 stormpike grave h_c
+                data << uint32(0x535) << uint32(0x1);           // 18 stormpike grave a_c
+                data << uint32(0x518) << uint32(0x0);           // 19 stoneheart grave a_a
+                data << uint32(0x517) << uint32(0x0);           // 20 stoneheart grave h_a
+                data << uint32(0x574) << uint32(0x0);           // 21 1396 unk
+                data << uint32(0x573) << uint32(0x0);           // 22 iceblood tower horde assaulted -unused
+                data << uint32(0x572) << uint32(0x0);           // 23 towerpoint horde assaulted - unused
+                data << uint32(0x56f) << uint32(0x0);           // 24 1391 unk
+                data << uint32(0x56e) << uint32(0x0);           // 25 iceblood a
+                data << uint32(0x56d) << uint32(0x0);           // 26 towerp a
+                data << uint32(0x56c) << uint32(0x0);           // 27 frostwolfe a
+                data << uint32(0x56b) << uint32(0x0);           // 28 froswolfw a
+                data << uint32(0x56a) << uint32(0x1);           // 29 1386 unk
+                data << uint32(0x569) << uint32(0x1);           // 30 iceblood c
+                data << uint32(0x568) << uint32(0x1);           // 31 towerp c
+                data << uint32(0x565) << uint32(0x0);           // 32 stoneh tower a
+                data << uint32(0x564) << uint32(0x0);           // 33 icewing tower a
+                data << uint32(0x563) << uint32(0x0);           // 34 dunn a
+                data << uint32(0x562) << uint32(0x0);           // 35 duns a
+                data << uint32(0x561) << uint32(0x0);           // 36 stoneheart bunker alliance assaulted - unused
+                data << uint32(0x560) << uint32(0x0);           // 37 icewing bunker alliance assaulted - unused
+                data << uint32(0x55f) << uint32(0x0);           // 38 dunbaldar south alliance assaulted - unused
+                data << uint32(0x55e) << uint32(0x0);           // 39 dunbaldar north alliance assaulted - unused
+                data << uint32(0x55d) << uint32(0x0);           // 40 stone tower d
+                data << uint32(0x3c6) << uint32(0x0);           // 41 966 unk
+                data << uint32(0x3c4) << uint32(0x0);           // 42 964 unk
+                data << uint32(0x3c2) << uint32(0x0);           // 43 962 unk
+                data << uint32(0x516) << uint32(0x1);           // 44 stoneheart grave a_c
+                data << uint32(0x515) << uint32(0x0);           // 45 stonheart grave h_c
+                data << uint32(0x3b6) << uint32(0x0);           // 46 950 unk
+                data << uint32(0x55c) << uint32(0x0);           // 47 icewing tower d
+                data << uint32(0x55b) << uint32(0x0);           // 48 dunn d
+                data << uint32(0x55a) << uint32(0x0);           // 49 duns d
+                data << uint32(0x559) << uint32(0x0);           // 50 1369 unk
+                data << uint32(0x558) << uint32(0x0);           // 51 iceblood d
+                data << uint32(0x557) << uint32(0x0);           // 52 towerp d
+                data << uint32(0x556) << uint32(0x0);           // 53 frostwolfe d
+                data << uint32(0x555) << uint32(0x0);           // 54 frostwolfw d
+                data << uint32(0x554) << uint32(0x1);           // 55 stoneh tower c
+                data << uint32(0x553) << uint32(0x1);           // 56 icewing tower c
+                data << uint32(0x552) << uint32(0x1);           // 57 dunn c
+                data << uint32(0x551) << uint32(0x1);           // 58 duns c
+                data << uint32(0x54f) << uint32(0x0);           // 59 irondeep (N) horde
+                data << uint32(0x54e) << uint32(0x0);           // 60 irondeep (N) ally
+                data << uint32(0x54d) << uint32(0x1);           // 61 mine (S) neutral
+                data << uint32(0x54c) << uint32(0x0);           // 62 mine (S) horde
+                data << uint32(0x54b) << uint32(0x0);           // 63 mine (S) ally
+                data << uint32(0x545) << uint32(0x0);           // 64 iceblood h_a
+                data << uint32(0x543) << uint32(0x1);           // 65 iceblod h_c
+                data << uint32(0x542) << uint32(0x0);           // 66 iceblood a_c
+                data << uint32(0x540) << uint32(0x0);           // 67 snowfall h_a
+                data << uint32(0x53f) << uint32(0x0);           // 68 snowfall a_a
+                data << uint32(0x53e) << uint32(0x0);           // 69 snowfall h_c
+                data << uint32(0x53d) << uint32(0x0);           // 70 snowfall a_c
+                data << uint32(0x53c) << uint32(0x0);           // 71 frostwolf g h_a
+                data << uint32(0x53b) << uint32(0x0);           // 72 frostwolf g a_a
+                data << uint32(0x53a) << uint32(0x1);           // 73 frostwolf g h_c
+                data << uint32(0x539) << uint32(0x0);           // 74 frostwolf g a_c
+                data << uint32(0x538) << uint32(0x0);           // 75 stormpike grave h_a
+                data << uint32(0x537) << uint32(0x0);           // 76 stormpike grave a_a
+                data << uint32(0x534) << uint32(0x0);           // 77 frostwolf hut h_a
+                data << uint32(0x533) << uint32(0x0);           // 78 frostwolf hut a_a
+                data << uint32(0x530) << uint32(0x0);           // 79 stormpike first aid h_a
+                data << uint32(0x52f) << uint32(0x0);           // 80 stormpike first aid h_c
+                data << uint32(0x52d) << uint32(0x1);           // 81 stormpike first aid a_c
+            }
+            break;
+        case 3277:                                          // Warsong Gulch
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_WS)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x62d) << uint32(0x0);       // 7 1581 alliance flag captures
+                data << uint32(0x62e) << uint32(0x0);       // 8 1582 horde flag captures
+                data << uint32(0x609) << uint32(0x0);       // 9 1545 unk, set to 1 on alliance flag pickup...
+                data << uint32(0x60a) << uint32(0x0);       // 10 1546 unk, set to 1 on horde flag pickup, after drop it's -1
+                data << uint32(0x60b) << uint32(0x2);       // 11 1547 unk
+                data << uint32(0x641) << uint32(0x3);       // 12 1601 unk (max flag captures?)
+                data << uint32(0x922) << uint32(0x1);       // 13 2338 horde (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
+                data << uint32(0x923) << uint32(0x1);       // 14 2339 alliance (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
+            }
+            break;
+        case 3358:                                          // Arathi Basin
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AB)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x6e7) << uint32(0x0);       // 7 1767 stables alliance
+                data << uint32(0x6e8) << uint32(0x0);       // 8 1768 stables horde
+                data << uint32(0x6e9) << uint32(0x0);       // 9 1769 unk, ST?
+                data << uint32(0x6ea) << uint32(0x0);       // 10 1770 stables (show/hide)
+                data << uint32(0x6ec) << uint32(0x0);       // 11 1772 farm (0 - horde controlled, 1 - alliance controlled)
+                data << uint32(0x6ed) << uint32(0x0);       // 12 1773 farm (show/hide)
+                data << uint32(0x6ee) << uint32(0x0);       // 13 1774 farm color
+                data << uint32(0x6ef) << uint32(0x0);       // 14 1775 gold mine color, may be FM?
+                data << uint32(0x6f0) << uint32(0x0);       // 15 1776 alliance resources
+                data << uint32(0x6f1) << uint32(0x0);       // 16 1777 horde resources
+                data << uint32(0x6f2) << uint32(0x0);       // 17 1778 horde bases
+                data << uint32(0x6f3) << uint32(0x0);       // 18 1779 alliance bases
+                data << uint32(0x6f4) << uint32(0x7d0);     // 19 1780 max resources (2000)
+                data << uint32(0x6f6) << uint32(0x0);       // 20 1782 blacksmith color
+                data << uint32(0x6f7) << uint32(0x0);       // 21 1783 blacksmith (show/hide)
+                data << uint32(0x6f8) << uint32(0x0);       // 22 1784 unk, bs?
+                data << uint32(0x6f9) << uint32(0x0);       // 23 1785 unk, bs?
+                data << uint32(0x6fb) << uint32(0x0);       // 24 1787 gold mine (0 - horde contr, 1 - alliance contr)
+                data << uint32(0x6fc) << uint32(0x0);       // 25 1788 gold mine (0 - conflict, 1 - horde)
+                data << uint32(0x6fd) << uint32(0x0);       // 26 1789 gold mine (1 - show/0 - hide)
+                data << uint32(0x6fe) << uint32(0x0);       // 27 1790 gold mine color
+                data << uint32(0x700) << uint32(0x0);       // 28 1792 gold mine color, wtf?, may be LM?
+                data << uint32(0x701) << uint32(0x0);       // 29 1793 lumber mill color (0 - conflict, 1 - horde contr)
+                data << uint32(0x702) << uint32(0x0);       // 30 1794 lumber mill (show/hide)
+                data << uint32(0x703) << uint32(0x0);       // 31 1795 lumber mill color color
+                data << uint32(0x732) << uint32(0x1);       // 32 1842 stables (1 - uncontrolled)
+                data << uint32(0x733) << uint32(0x1);       // 33 1843 gold mine (1 - uncontrolled)
+                data << uint32(0x734) << uint32(0x1);       // 34 1844 lumber mill (1 - uncontrolled)
+                data << uint32(0x735) << uint32(0x1);       // 35 1845 farm (1 - uncontrolled)
+                data << uint32(0x736) << uint32(0x1);       // 36 1846 blacksmith (1 - uncontrolled)
+                data << uint32(0x745) << uint32(0x2);       // 37 1861 unk
+                data << uint32(0x7a3) << uint32(0x708);     // 38 1955 warning limit (1800)
+            }
+            break;
+        case 3820:                                          // Eye of the Storm
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_EY)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0xac1) << uint32(0x0);       // 7  2753 Horde Bases
+                data << uint32(0xac0) << uint32(0x0);       // 8  2752 Alliance Bases
+                data << uint32(0xab6) << uint32(0x0);       // 9  2742 Mage Tower - Horde conflict
+                data << uint32(0xab5) << uint32(0x0);       // 10 2741 Mage Tower - Alliance conflict
+                data << uint32(0xab4) << uint32(0x0);       // 11 2740 Fel Reaver - Horde conflict
+                data << uint32(0xab3) << uint32(0x0);       // 12 2739 Fel Reaver - Alliance conflict
+                data << uint32(0xab2) << uint32(0x0);       // 13 2738 Draenei - Alliance conflict
+                data << uint32(0xab1) << uint32(0x0);       // 14 2737 Draenei - Horde conflict
+                data << uint32(0xab0) << uint32(0x0);       // 15 2736 unk // 0 at start
+                data << uint32(0xaaf) << uint32(0x0);       // 16 2735 unk // 0 at start
+                data << uint32(0xaad) << uint32(0x0);       // 17 2733 Draenei - Horde control
+                data << uint32(0xaac) << uint32(0x0);       // 18 2732 Draenei - Alliance control
+                data << uint32(0xaab) << uint32(0x1);       // 19 2731 Draenei uncontrolled (1 - yes, 0 - no)
+                data << uint32(0xaaa) << uint32(0x0);       // 20 2730 Mage Tower - Alliance control
+                data << uint32(0xaa9) << uint32(0x0);       // 21 2729 Mage Tower - Horde control
+                data << uint32(0xaa8) << uint32(0x1);       // 22 2728 Mage Tower uncontrolled (1 - yes, 0 - no)
+                data << uint32(0xaa7) << uint32(0x0);       // 23 2727 Fel Reaver - Horde control
+                data << uint32(0xaa6) << uint32(0x0);       // 24 2726 Fel Reaver - Alliance control
+                data << uint32(0xaa5) << uint32(0x1);       // 25 2725 Fel Reaver uncontrolled (1 - yes, 0 - no)
+                data << uint32(0xaa4) << uint32(0x0);       // 26 2724 Boold Elf - Horde control
+                data << uint32(0xaa3) << uint32(0x0);       // 27 2723 Boold Elf - Alliance control
+                data << uint32(0xaa2) << uint32(0x1);       // 28 2722 Boold Elf uncontrolled (1 - yes, 0 - no)
+                data << uint32(0xac5) << uint32(0x1);       // 29 2757 Flag (1 - show, 0 - hide) - doesn't work exactly this way!
+                data << uint32(0xad2) << uint32(0x1);       // 30 2770 Horde top-stats (1 - show, 0 - hide) // 02 -> horde picked up the flag
+                data << uint32(0xad1) << uint32(0x1);       // 31 2769 Alliance top-stats (1 - show, 0 - hide) // 02 -> alliance picked up the flag
+                data << uint32(0xabe) << uint32(0x0);       // 32 2750 Horde resources
+                data << uint32(0xabd) << uint32(0x0);       // 33 2749 Alliance resources
+                data << uint32(0xa05) << uint32(0x8e);      // 34 2565 unk, constant?
+                data << uint32(0xaa0) << uint32(0x0);       // 35 2720 Capturing progress-bar (100 -> empty (only grey), 0 -> blue|red (no grey), default 0)
+                data << uint32(0xa9f) << uint32(0x0);       // 36 2719 Capturing progress-bar (0 - left, 100 - right)
+                data << uint32(0xa9e) << uint32(0x0);       // 37 2718 Capturing progress-bar (1 - show, 0 - hide)
+                data << uint32(0xc0d) << uint32(0x17b);     // 38 3085 unk
+                // and some more ... unknown
+            }
+            break;
+        // any of these needs change! the client remembers the prev setting!
+        // ON EVERY ZONE LEAVE, RESET THE OLD ZONE'S WORLD STATE, BUT AT LEAST THE UI STUFF!
+        case 3483:                                          // Hellfire Peninsula
+            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_HP)
+                pvp->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x9ba) << uint32(0x1);           // 10 // add ally tower main gui icon       // maybe should be sent only on login?
+                data << uint32(0x9b9) << uint32(0x1);           // 11 // add horde tower main gui icon      // maybe should be sent only on login?
+                data << uint32(0x9b5) << uint32(0x0);           // 12 // show neutral broken hill icon      // 2485
+                data << uint32(0x9b4) << uint32(0x1);           // 13 // show icon above broken hill        // 2484
+                data << uint32(0x9b3) << uint32(0x0);           // 14 // show ally broken hill icon         // 2483
+                data << uint32(0x9b2) << uint32(0x0);           // 15 // show neutral overlook icon         // 2482
+                data << uint32(0x9b1) << uint32(0x1);           // 16 // show the overlook arrow            // 2481
+                data << uint32(0x9b0) << uint32(0x0);           // 17 // show ally overlook icon            // 2480
+                data << uint32(0x9ae) << uint32(0x0);           // 18 // horde pvp objectives captured      // 2478
+                data << uint32(0x9ac) << uint32(0x0);           // 19 // ally pvp objectives captured       // 2476
+                data << uint32(2475)  << uint32(100); //: ally / horde slider grey area                              // show only in direct vicinity!
+                data << uint32(2474)  << uint32(50);  //: ally / horde slider percentage, 100 for ally, 0 for horde  // show only in direct vicinity!
+                data << uint32(2473)  << uint32(0);   //: ally / horde slider display                                // show only in direct vicinity!
+                data << uint32(0x9a8) << uint32(0x0);           // 20 // show the neutral stadium icon      // 2472
+                data << uint32(0x9a7) << uint32(0x0);           // 21 // show the ally stadium icon         // 2471
+                data << uint32(0x9a6) << uint32(0x1);           // 22 // show the horde stadium icon        // 2470
+            }
+            break;
+        case 3518:                                          // Nagrand
+            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_NA)
+                pvp->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(2503) << uint32(0x0);    // 10
+                data << uint32(2502) << uint32(0x0);    // 11
+                data << uint32(2493) << uint32(0x0);    // 12
+                data << uint32(2491) << uint32(0x0);    // 13
+
+                data << uint32(2495) << uint32(0x0);    // 14
+                data << uint32(2494) << uint32(0x0);    // 15
+                data << uint32(2497) << uint32(0x0);    // 16
+
+                data << uint32(2762) << uint32(0x0);    // 17
+                data << uint32(2662) << uint32(0x0);    // 18
+                data << uint32(2663) << uint32(0x0);    // 19
+                data << uint32(2664) << uint32(0x0);    // 20
+
+                data << uint32(2760) << uint32(0x0);    // 21
+                data << uint32(2670) << uint32(0x0);    // 22
+                data << uint32(2668) << uint32(0x0);    // 23
+                data << uint32(2669) << uint32(0x0);    // 24
+
+                data << uint32(2761) << uint32(0x0);    // 25
+                data << uint32(2667) << uint32(0x0);    // 26
+                data << uint32(2665) << uint32(0x0);    // 27
+                data << uint32(2666) << uint32(0x0);    // 28
+
+                data << uint32(2763) << uint32(0x0);    // 29
+                data << uint32(2659) << uint32(0x0);    // 30
+                data << uint32(2660) << uint32(0x0);    // 31
+                data << uint32(2661) << uint32(0x0);    // 32
+
+                data << uint32(2671) << uint32(0x0);    // 33
+                data << uint32(2676) << uint32(0x0);    // 34
+                data << uint32(2677) << uint32(0x0);    // 35
+                data << uint32(2672) << uint32(0x0);    // 36
+                data << uint32(2673) << uint32(0x0);    // 37
+            }
+            break;
+        case 3519:                                          // Terokkar Forest
+            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_TF)
+                pvp->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0xa41) << uint32(0x0);           // 10 // 2625 capture bar pos
+                data << uint32(0xa40) << uint32(0x14);          // 11 // 2624 capture bar neutral
+                data << uint32(0xa3f) << uint32(0x0);           // 12 // 2623 show capture bar
+                data << uint32(0xa3e) << uint32(0x0);           // 13 // 2622 horde towers controlled
+                data << uint32(0xa3d) << uint32(0x5);           // 14 // 2621 ally towers controlled
+                data << uint32(0xa3c) << uint32(0x0);           // 15 // 2620 show towers controlled
+                data << uint32(0xa88) << uint32(0x0);           // 16 // 2696 SE Neu
+                data << uint32(0xa87) << uint32(0x0);           // 17 // SE Horde
+                data << uint32(0xa86) << uint32(0x0);           // 18 // SE Ally
+                data << uint32(0xa85) << uint32(0x0);           // 19 //S Neu
+                data << uint32(0xa84) << uint32(0x0);           // 20 S Horde
+                data << uint32(0xa83) << uint32(0x0);           // 21 S Ally
+                data << uint32(0xa82) << uint32(0x0);           // 22 NE Neu
+                data << uint32(0xa81) << uint32(0x0);           // 23 NE Horde
+                data << uint32(0xa80) << uint32(0x0);           // 24 NE Ally
+                data << uint32(0xa7e) << uint32(0x0);           // 25 // 2686 N Neu
+                data << uint32(0xa7d) << uint32(0x0);           // 26 N Horde
+                data << uint32(0xa7c) << uint32(0x0);           // 27 N Ally
+                data << uint32(0xa7b) << uint32(0x0);           // 28 NW Ally
+                data << uint32(0xa7a) << uint32(0x0);           // 29 NW Horde
+                data << uint32(0xa79) << uint32(0x0);           // 30 NW Neutral
+                data << uint32(0x9d0) << uint32(0x5);           // 31 // 2512 locked time remaining seconds first digit
+                data << uint32(0x9ce) << uint32(0x0);           // 32 // 2510 locked time remaining seconds second digit
+                data << uint32(0x9cd) << uint32(0x0);           // 33 // 2509 locked time remaining minutes
+                data << uint32(0x9cc) << uint32(0x0);           // 34 // 2508 neutral locked time show
+                data << uint32(0xad0) << uint32(0x0);           // 35 // 2768 horde locked time show
+                data << uint32(0xacf) << uint32(0x1);           // 36 // 2767 ally locked time show
+            }
+            break;
+        case 3521:                                          // Zangarmarsh
+            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_ZM)
+                pvp->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x9e1) << uint32(0x0);           // 10 //2529
+                data << uint32(0x9e0) << uint32(0x0);           // 11
+                data << uint32(0x9df) << uint32(0x0);           // 12
+                data << uint32(0xa5d) << uint32(0x1);           // 13 //2653
+                data << uint32(0xa5c) << uint32(0x0);           // 14 //2652 east beacon neutral
+                data << uint32(0xa5b) << uint32(0x1);           // 15 horde
+                data << uint32(0xa5a) << uint32(0x0);           // 16 ally
+                data << uint32(0xa59) << uint32(0x1);           // 17 // 2649 Twin spire graveyard horde  12???
+                data << uint32(0xa58) << uint32(0x0);           // 18 ally     14 ???
+                data << uint32(0xa57) << uint32(0x0);           // 19 neutral  7???
+                data << uint32(0xa56) << uint32(0x0);           // 20 // 2646 west beacon neutral
+                data << uint32(0xa55) << uint32(0x1);           // 21 horde
+                data << uint32(0xa54) << uint32(0x0);           // 22 ally
+                data << uint32(0x9e7) << uint32(0x0);           // 23 // 2535
+                data << uint32(0x9e6) << uint32(0x0);           // 24
+                data << uint32(0x9e5) << uint32(0x0);           // 25
+                data << uint32(0xa00) << uint32(0x0);           // 26 // 2560
+                data << uint32(0x9ff) << uint32(0x1);           // 27
+                data << uint32(0x9fe) << uint32(0x0);           // 28
+                data << uint32(0x9fd) << uint32(0x0);           // 29
+                data << uint32(0x9fc) << uint32(0x1);           // 30
+                data << uint32(0x9fb) << uint32(0x0);           // 31
+                data << uint32(0xa62) << uint32(0x0);           // 32 // 2658
+                data << uint32(0xa61) << uint32(0x1);           // 33
+                data << uint32(0xa60) << uint32(0x1);           // 34
+                data << uint32(0xa5f) << uint32(0x0);           // 35
+            }
+            break;
+        case 3698:                                          // Nagrand Arena
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_NA)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0xa0f) << uint32(0x0);           // 7
+                data << uint32(0xa10) << uint32(0x0);           // 8
+                data << uint32(0xa11) << uint32(0x0);           // 9 show
+            }
+            break;
+        case 3702:                                          // Blade's Edge Arena
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_BE)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x9f0) << uint32(0x0);           // 7 gold
+                data << uint32(0x9f1) << uint32(0x0);           // 8 green
+                data << uint32(0x9f3) << uint32(0x0);           // 9 show
+            }
+            break;
+        case 3968:                                          // Ruins of Lordaeron
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_RL)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0xbb8) << uint32(0x0);           // 7 gold
+                data << uint32(0xbb9) << uint32(0x0);           // 8 green
+                data << uint32(0xbba) << uint32(0x0);           // 9 show
+            }
+            break;
+        case 4378:                                          // Dalaran Sewers
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_DS)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(3601) << uint32(0x0);           // 7 gold
+                data << uint32(3600) << uint32(0x0);           // 8 green
+                data << uint32(3610) << uint32(0x0);           // 9 show
+            }
+            break;
+        case 4384:                                          // Strand of the Ancients
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_SA)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                // 1-3 A defend, 4-6 H defend, 7-9 unk defend, 1 - ok, 2 - half destroyed, 3 - destroyed
+                data << uint32(0xf09) << uint32(0x0);       // 7  3849 Gate of Temple
+                data << uint32(0xe36) << uint32(0x0);       // 8  3638 Gate of Yellow Moon
+                data << uint32(0xe27) << uint32(0x0);       // 9  3623 Gate of Green Emerald
+                data << uint32(0xe24) << uint32(0x0);       // 10 3620 Gate of Blue Sapphire
+                data << uint32(0xe21) << uint32(0x0);       // 11 3617 Gate of Red Sun
+                data << uint32(0xe1e) << uint32(0x0);       // 12 3614 Gate of Purple Ametyst
+
+                data << uint32(0xdf3) << uint32(0x0);       // 13 3571 bonus timer (1 - on, 0 - off)
+                data << uint32(0xded) << uint32(0x0);       // 14 3565 Horde Attacker
+                data << uint32(0xdec) << uint32(0x0);       // 15 3564 Alliance Attacker
+                // End Round (timer), better explain this by example, eg. ends in 19:59 -> A:BC
+                data << uint32(0xde9) << uint32(0x0);       // 16 3561 C
+                data << uint32(0xde8) << uint32(0x0);       // 17 3560 B
+                data << uint32(0xde7) << uint32(0x0);       // 18 3559 A
+                data << uint32(0xe35) << uint32(0x0);       // 19 3637 East g - Horde control
+                data << uint32(0xe34) << uint32(0x0);       // 20 3636 West g - Horde control
+                data << uint32(0xe33) << uint32(0x0);       // 21 3635 South g - Horde control
+                data << uint32(0xe32) << uint32(0x0);       // 22 3634 East g - Alliance control
+                data << uint32(0xe31) << uint32(0x0);       // 23 3633 West g - Alliance control
+                data << uint32(0xe30) << uint32(0x0);       // 24 3632 South g - Alliance control
+                data << uint32(0xe2f) << uint32(0x0);       // 25 3631 Chamber of Ancients - Horde control
+                data << uint32(0xe2e) << uint32(0x0);       // 26 3630 Chamber of Ancients - Alliance control
+                data << uint32(0xe2d) << uint32(0x0);       // 27 3629 Beach1 - Horde control
+                data << uint32(0xe2c) << uint32(0x0);       // 28 3628 Beach2 - Horde control
+                data << uint32(0xe2b) << uint32(0x0);       // 29 3627 Beach1 - Alliance control
+                data << uint32(0xe2a) << uint32(0x0);       // 30 3626 Beach2 - Alliance control
+                // and many unks...
+            }
+            break;
+        case 4406:                                          // Ring of Valor
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_RV)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0xe10) << uint32(0x0);           // 7 gold
+                data << uint32(0xe11) << uint32(0x0);           // 8 green
+                data << uint32(0xe1a) << uint32(0x0);           // 9 show
+            }
+            break;
+        case 4710:
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_IC)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(4221) << uint32(1); // 7 BG_IC_ALLIANCE_RENFORT_SET
+                data << uint32(4222) << uint32(1); // 8 BG_IC_HORDE_RENFORT_SET
+                data << uint32(4226) << uint32(300); // 9 BG_IC_ALLIANCE_RENFORT
+                data << uint32(4227) << uint32(300); // 10 BG_IC_HORDE_RENFORT
+                data << uint32(4322) << uint32(1); // 11 BG_IC_GATE_FRONT_H_WS_OPEN
+                data << uint32(4321) << uint32(1); // 12 BG_IC_GATE_WEST_H_WS_OPEN
+                data << uint32(4320) << uint32(1); // 13 BG_IC_GATE_EAST_H_WS_OPEN
+                data << uint32(4323) << uint32(1); // 14 BG_IC_GATE_FRONT_A_WS_OPEN
+                data << uint32(4324) << uint32(1); // 15 BG_IC_GATE_WEST_A_WS_OPEN
+                data << uint32(4325) << uint32(1); // 16 BG_IC_GATE_EAST_A_WS_OPEN
+                data << uint32(4317) << uint32(1); // 17 unknown
+
+                data << uint32(4301) << uint32(1); // 18 BG_IC_DOCKS_UNCONTROLLED
+                data << uint32(4296) << uint32(1); // 19 BG_IC_HANGAR_UNCONTROLLED
+                data << uint32(4306) << uint32(1); // 20 BG_IC_QUARRY_UNCONTROLLED
+                data << uint32(4311) << uint32(1); // 21 BG_IC_REFINERY_UNCONTROLLED
+                data << uint32(4294) << uint32(1); // 22 BG_IC_WORKSHOP_UNCONTROLLED
+                data << uint32(4243) << uint32(1); // 23 unknown
+                data << uint32(4345) << uint32(1); // 24 unknown
+            }
+            break;
+        // The Ruby Sanctum
+        case 4987:
+            if (instance && mapid == 724)
+                instance->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(5049) << uint32(50);             // 9  WORLDSTATE_CORPOREALITY_MATERIAL
+                data << uint32(5050) << uint32(50);             // 10 WORLDSTATE_CORPOREALITY_TWILIGHT
+                data << uint32(5051) << uint32(0);              // 11 WORLDSTATE_CORPOREALITY_TOGGLE
+            }
+            break;
+        // Icecrown Citadel
+        case 4812:
+            if (instance && mapid == 631)
+                instance->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(4903) << uint32(0);              // 9  WORLDSTATE_SHOW_TIMER (Blood Quickening weekly)
+                data << uint32(4904) << uint32(30);             // 10 WORLDSTATE_EXECUTION_TIME
+                data << uint32(4940) << uint32(0);              // 11 WORLDSTATE_SHOW_ATTEMPTS
+                data << uint32(4941) << uint32(50);             // 12 WORLDSTATE_ATTEMPTS_REMAINING
+                data << uint32(4942) << uint32(50);             // 13 WORLDSTATE_ATTEMPTS_MAX
+            }
+            break;
+        // The Culling of Stratholme
+        case 4100:
+            if (instance && mapid == 595)
+                instance->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(3479) << uint32(0);              // 9  WORLDSTATE_SHOW_CRATES
+                data << uint32(3480) << uint32(0);              // 10 WORLDSTATE_CRATES_REVEALED
+                data << uint32(3504) << uint32(0);              // 11 WORLDSTATE_WAVE_COUNT
+                data << uint32(3931) << uint32(25);             // 12 WORLDSTATE_TIME_GUARDIAN
+                data << uint32(3932) << uint32(0);              // 13 WORLDSTATE_TIME_GUARDIAN_SHOW
+            }
+            break;
+        // Ulduar
+        case 4273:
+            if (instance && mapid == 603)
+                instance->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(4132) << uint32(0);              // 9  WORLDSTATE_ALGALON_TIMER_ENABLED
+                data << uint32(4131) << uint32(0);              // 10 WORLDSTATE_ALGALON_DESPAWN_TIMER
+            }
+            break;
+        // Twin Peaks
+        case 5031:
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_TP)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x62d) << uint32(0x0);       //  7 1581 alliance flag captures
+                data << uint32(0x62e) << uint32(0x0);       //  8 1582 horde flag captures
+                data << uint32(0x609) << uint32(0x0);       //  9 1545 unk
+                data << uint32(0x60a) << uint32(0x0);       // 10 1546 unk
+                data << uint32(0x60b) << uint32(0x2);       // 11 1547 unk
+                data << uint32(0x641) << uint32(0x3);       // 12 1601 unk
+                data << uint32(0x922) << uint32(0x1);       // 13 2338 horde (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
+                data << uint32(0x923) << uint32(0x1);       // 14 2339 alliance (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
+            }
+            break;
+        // Battle for Gilneas
+        case 5449:
+            if (bg && bg->GetTypeID(true) == BATTLEGROUND_BFG)
+                bg->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(0x6ec) << uint32(0x0);       // 11 1772 farm (0 - horde controlled, 1 - alliance controlled)
+                data << uint32(0x6ed) << uint32(0x0);       // 12 1773 farm (show/hide)
+                data << uint32(0x6ee) << uint32(0x0);       // 13 1774 farm color
+                data << uint32(0x6ef) << uint32(0x0);       // 14 1775 gold mine color, may be FM?
+                data << uint32(0x6f0) << uint32(0x0);       // 15 1776 alliance resources
+                data << uint32(0x6f1) << uint32(0x0);       // 16 1777 horde resources
+                data << uint32(0x6f2) << uint32(0x0);       // 17 1778 horde bases
+                data << uint32(0x6f3) << uint32(0x0);       // 18 1779 alliance bases
+                data << uint32(0x6f4) << uint32(0x7d0);     // 19 1780 max resources (2000)
+                data << uint32(0x6f6) << uint32(0x0);       // 20 1782 blacksmith color
+                data << uint32(0x6f7) << uint32(0x0);       // 21 1783 blacksmith (show/hide)
+                data << uint32(0x6f8) << uint32(0x0);       // 22 1784 unk, bs?
+                data << uint32(0x6f9) << uint32(0x0);       // 23 1785 unk, bs?
+                data << uint32(0x6fb) << uint32(0x0);       // 24 1787 gold mine (0 - horde contr, 1 - alliance contr)
+                data << uint32(0x6fc) << uint32(0x0);       // 25 1788 gold mine (0 - conflict, 1 - horde)
+                data << uint32(0x6fd) << uint32(0x0);       // 26 1789 gold mine (1 - show/0 - hide)
+                data << uint32(0x6fe) << uint32(0x0);       // 27 1790 gold mine color
+                data << uint32(0x700) << uint32(0x0);       // 28 1792 gold mine color, wtf?, may be LM?
+                data << uint32(0x733) << uint32(0x1);       // 33 1843 gold mine (1 - uncontrolled)
+                data << uint32(0x735) << uint32(0x1);       // 35 1845 farm (1 - uncontrolled)
+                data << uint32(0x736) << uint32(0x1);       // 36 1846 blacksmith (1 - uncontrolled)
+                data << uint32(0x745) << uint32(0x2);       // 37 1861 unk
+                data << uint32(0x7a3) << uint32(0x708);     // 38 1955 warning limit (1800)
+            }
+            break;
+        // Wintergrasp
+        case 4197:
+            if (bf && bf->GetTypeId() == BATTLEFIELD_WG)
+            {
+                bf->FillInitialWorldStates(data);
+                break;
+            }
+
+        case 4820:
+            if (instance && mapid == 668)
+                instance->FillInitialWorldStates(data);
+            else
+            {
+                data << uint32(4884) << uint32(0);              // 9  WORLD_STATE_HOR_WAVES_ENABLED
+                data << uint32(4882) << uint32(0);              // 10 WORLD_STATE_HOR_WAVE_COUNT
+            }
+            break;
+
+            // No break here, intended.
+        default:
+            data << uint32(0x914) << uint32(0x0);           // 7
+            data << uint32(0x913) << uint32(0x0);           // 8
+            data << uint32(0x912) << uint32(0x0);           // 9
+            data << uint32(0x915) << uint32(0x0);           // 10
+            break;
+    }
+
+    uint16 length = (data.wpos() - countPos) / 8;
+    data.put<uint16>(countPos, length);
+
+    GetSession()->SendPacket(&data);
+    SendBGWeekendWorldStates();
+    SendBattlefieldWorldStates();
+}
+
+void Player::SendBGWeekendWorldStates()
+{
+    for (uint32 i = 1; i < sBattlemasterListStore.GetNumRows(); ++i)
+    {
+        BattlemasterListEntry const* bl = sBattlemasterListStore.LookupEntry(i);
+        if (bl && bl->HolidayWorldStateId)
+        {
+            if (BattlegroundMgr::IsBGWeekend((BattlegroundTypeId)bl->id))
+                SendUpdateWorldState(bl->HolidayWorldStateId, 1);
+            else
+                SendUpdateWorldState(bl->HolidayWorldStateId, 0);
+        }
+    }
+}
+
+void Player::SendBattlefieldWorldStates()
+{
+    /// Send misc stuff that needs to be sent on every login, like the battle timers.
+    if (sWorld->getBoolConfig(CONFIG_WINTERGRASP_ENABLE))
+    {
+        if (BattlefieldWG* wg = (BattlefieldWG*)sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG))
+        {
+            if (wg->IsWarTime())
+                SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL)));
+            else // Time to next battle
+            {
+                uint32 timer = wg->GetTimer() / 1000;
+                SendUpdateWorldState(ClockWorldState[1], time(NULL) + timer);
+            }
+        }
+    }
+}
+
+uint32 Player::GetXPRestBonus(uint32 xp)
+{
+    uint32 rested_bonus = (uint32)GetRestBonus();           // xp for each rested bonus
+
+    if (rested_bonus > xp)                                   // max rested_bonus == xp or (r+x) = 200% xp
+        rested_bonus = xp;
+
+    SetRestBonus(GetRestBonus() - rested_bonus);
+
+    sLog->outInfo(LOG_FILTER_PLAYER, "Player gain %u xp (+ %u Rested Bonus). Rested points=%f", xp+rested_bonus, rested_bonus, GetRestBonus());
+    return rested_bonus;
+}
+
+void Player::SetBindPoint(uint64 guid)
+{
+    WorldPacket data(SMSG_BINDER_CONFIRM, 8);
+    data << uint64(guid);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendTalentWipeConfirm(uint64 guid)
+{
+    WorldPacket data(MSG_TALENT_WIPE_CONFIRM, (8+4));
+    data << uint64(guid);
+    uint32 cost = sWorld->getBoolConfig(CONFIG_NO_RESET_TALENT_COST) ? 0 : GetNextResetTalentsCost();
+    data << cost;
+    GetSession()->SendPacket(&data);
+}
+
+void Player::ResetPetTalents()
+{
+    // This needs another gossip option + NPC text as a confirmation.
+    // The confirmation gossip listid has the text: "Yes, please do."
+    Pet* pet = GetPet();
+
+    if (!pet || pet->getPetType() != HUNTER_PET || pet->m_usedTalentCount == 0)
+        return;
+
+    CharmInfo* charmInfo = pet->GetCharmInfo();
+    if (!charmInfo)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Object (GUID: %u TypeId: %u) is considered pet-like but doesn't have a charminfo!", pet->GetGUIDLow(), pet->GetTypeId());
+        return;
+    }
+    pet->resetTalents();
+    SendTalentsInfoData(true);
+}
+
+/*********************************************************/
+/***                    STORAGE SYSTEM                 ***/
+/*********************************************************/
+
+void Player::SetVirtualItemSlot(uint8 i, Item* item)
+{
+    ASSERT(i < 3);
+    if (i < 2 && item)
+    {
+        if (!item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+            return;
+        uint32 charges = item->GetEnchantmentCharges(TEMP_ENCHANTMENT_SLOT);
+        if (charges == 0)
+            return;
+        if (charges > 1)
+            item->SetEnchantmentCharges(TEMP_ENCHANTMENT_SLOT, charges-1);
+        else if (charges <= 1)
+        {
+            ApplyEnchantment(item, TEMP_ENCHANTMENT_SLOT, false);
+            item->ClearEnchantment(TEMP_ENCHANTMENT_SLOT);
+        }
+    }
+}
+
+void Player::SetSheath(SheathState sheathed)
+{
+    switch (sheathed)
+    {
+        case SHEATH_STATE_UNARMED:                          // no prepared weapon
+            SetVirtualItemSlot(0, NULL);
+            SetVirtualItemSlot(1, NULL);
+            SetVirtualItemSlot(2, NULL);
+            break;
+        case SHEATH_STATE_MELEE:                            // prepared melee weapon
+            SetVirtualItemSlot(0, GetWeaponForAttack(BASE_ATTACK, true));
+            SetVirtualItemSlot(1, GetWeaponForAttack(OFF_ATTACK, true));
+            SetVirtualItemSlot(2, NULL);
+            break;
+        case SHEATH_STATE_RANGED:                           // prepared ranged weapon
+            SetVirtualItemSlot(0, NULL);
+            SetVirtualItemSlot(1, NULL);
+            SetVirtualItemSlot(2, GetWeaponForAttack(RANGED_ATTACK, true));
+            break;
+        default:
+            SetVirtualItemSlot(0, NULL);
+            SetVirtualItemSlot(1, NULL);
+            SetVirtualItemSlot(2, NULL);
+            break;
+    }
+    Unit::SetSheath(sheathed);                              // this must visualize Sheath changing for other players...
+}
+
+uint8 Player::FindEquipSlot(ItemTemplate const* proto, uint32 slot, bool swap) const
+{
+    uint8 playerClass = getClass();
+
+    uint8 slots[4];
+    slots[0] = NULL_SLOT;
+    slots[1] = NULL_SLOT;
+    slots[2] = NULL_SLOT;
+    slots[3] = NULL_SLOT;
+    switch (proto->InventoryType)
+    {
+        case INVTYPE_HEAD:
+            slots[0] = EQUIPMENT_SLOT_HEAD;
+            break;
+        case INVTYPE_NECK:
+            slots[0] = EQUIPMENT_SLOT_NECK;
+            break;
+        case INVTYPE_SHOULDERS:
+            slots[0] = EQUIPMENT_SLOT_SHOULDERS;
+            break;
+        case INVTYPE_BODY:
+            slots[0] = EQUIPMENT_SLOT_BODY;
+            break;
+        case INVTYPE_CHEST:
+            slots[0] = EQUIPMENT_SLOT_CHEST;
+            break;
+        case INVTYPE_ROBE:
+            slots[0] = EQUIPMENT_SLOT_CHEST;
+            break;
+        case INVTYPE_WAIST:
+            slots[0] = EQUIPMENT_SLOT_WAIST;
+            break;
+        case INVTYPE_LEGS:
+            slots[0] = EQUIPMENT_SLOT_LEGS;
+            break;
+        case INVTYPE_FEET:
+            slots[0] = EQUIPMENT_SLOT_FEET;
+            break;
+        case INVTYPE_WRISTS:
+            slots[0] = EQUIPMENT_SLOT_WRISTS;
+            break;
+        case INVTYPE_HANDS:
+            slots[0] = EQUIPMENT_SLOT_HANDS;
+            break;
+        case INVTYPE_FINGER:
+            slots[0] = EQUIPMENT_SLOT_FINGER1;
+            slots[1] = EQUIPMENT_SLOT_FINGER2;
+            break;
+        case INVTYPE_TRINKET:
+            slots[0] = EQUIPMENT_SLOT_TRINKET1;
+            slots[1] = EQUIPMENT_SLOT_TRINKET2;
+            break;
+        case INVTYPE_CLOAK:
+            slots[0] = EQUIPMENT_SLOT_BACK;
+            break;
+        case INVTYPE_WEAPON:
+        {
+            slots[0] = EQUIPMENT_SLOT_MAINHAND;
+
+            // suggest offhand slot only if know dual wielding
+            // (this will be replace mainhand weapon at auto equip instead unwonted "you don't known dual wielding" ...
+            if (CanDualWield())
+                slots[1] = EQUIPMENT_SLOT_OFFHAND;
+            break;
+        }
+        case INVTYPE_SHIELD:
+            slots[0] = EQUIPMENT_SLOT_OFFHAND;
+            break;
+        case INVTYPE_RANGED:
+            slots[0] = EQUIPMENT_SLOT_RANGED;
+            break;
+        case INVTYPE_2HWEAPON:
+            slots[0] = EQUIPMENT_SLOT_MAINHAND;
+            if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
+            {
+                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
+                {
+                    if (mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
+                    {
+                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
+                        break;
+                    }
+                }
+            }
+
+            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
+            {
+                if (proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
+                {
+                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
+                    break;
+                }
+            }
+            if (CanDualWield() && CanTitanGrip() && proto->SubClass != ITEM_SUBCLASS_WEAPON_POLEARM && proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+                slots[1] = EQUIPMENT_SLOT_OFFHAND;
+            break;
+        case INVTYPE_TABARD:
+            slots[0] = EQUIPMENT_SLOT_TABARD;
+            break;
+        case INVTYPE_WEAPONMAINHAND:
+            slots[0] = EQUIPMENT_SLOT_MAINHAND;
+            break;
+        case INVTYPE_WEAPONOFFHAND:
+            slots[0] = EQUIPMENT_SLOT_OFFHAND;
+            break;
+        case INVTYPE_HOLDABLE:
+            slots[0] = EQUIPMENT_SLOT_OFFHAND;
+            break;
+        case INVTYPE_THROWN:
+            slots[0] = EQUIPMENT_SLOT_RANGED;
+            break;
+        case INVTYPE_RANGEDRIGHT:
+            slots[0] = EQUIPMENT_SLOT_RANGED;
+            break;
+        case INVTYPE_BAG:
+            slots[0] = INVENTORY_SLOT_BAG_START + 0;
+            slots[1] = INVENTORY_SLOT_BAG_START + 1;
+            slots[2] = INVENTORY_SLOT_BAG_START + 2;
+            slots[3] = INVENTORY_SLOT_BAG_START + 3;
+            break;
+        case INVTYPE_RELIC:
+        {
+           if (playerClass == CLASS_PALADIN || playerClass == CLASS_DRUID ||
+               playerClass == CLASS_SHAMAN || playerClass == CLASS_DEATH_KNIGHT)
+               slots[0] = EQUIPMENT_SLOT_RANGED;
+           break;
+        }
+        default:
+            return NULL_SLOT;
+    }
+
+    if (slot != NULL_SLOT)
+    {
+        if (swap || !GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+            for (uint8 i = 0; i < 4; ++i)
+                if (slots[i] == slot)
+                    return slot;
+    }
+    else
+    {
+        // search free slot at first
+        for (uint8 i = 0; i < 4; ++i)
+            if (slots[i] != NULL_SLOT && !GetItemByPos(INVENTORY_SLOT_BAG_0, slots[i]))
+                // in case 2hand equipped weapon (without titan grip) offhand slot empty but not free
+                if (slots[i] != EQUIPMENT_SLOT_OFFHAND || !IsTwoHandUsed())
+                    return slots[i];
+
+        // if not found free and can swap return first appropriate from used
+        for (uint8 i = 0; i < 4; ++i)
+            if (slots[i] != NULL_SLOT && swap)
+                return slots[i];
+    }
+
+    // no free position
+    return NULL_SLOT;
+}
+
+InventoryResult Player::CanUnequipItems(uint32 item, uint32 count) const
+{
+    uint32 tempcount = 0;
+
+    InventoryResult res = EQUIP_ERR_OK;
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->GetEntry() == item)
+            {
+                InventoryResult ires = CanUnequipItem(INVENTORY_SLOT_BAG_0 << 8 | i, false);
+                if (ires == EQUIP_ERR_OK)
+                {
+                    tempcount += pItem->GetCount();
+                    if (tempcount >= count)
+                        return EQUIP_ERR_OK;
+                }
+                else
+                    res = ires;
+            }
+
+    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->GetEntry() == item)
+            {
+                tempcount += pItem->GetCount();
+                if (tempcount >= count)
+                    return EQUIP_ERR_OK;
+            }
+
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = GetItemByPos(i, j))
+                    if (pItem->GetEntry() == item)
+                    {
+                        tempcount += pItem->GetCount();
+                        if (tempcount >= count)
+                            return EQUIP_ERR_OK;
+                    }
+
+    // not found req. item count and have unequippable items
+    return res;
+}
+
+uint32 Player::GetItemCount(uint32 item, bool inBankAlso, Item* skipItem) const
+{
+    uint32 count = 0;
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem != skipItem &&  pItem->GetEntry() == item)
+                count += pItem->GetCount();
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = GetBagByPos(i))
+            count += pBag->GetItemCount(item, skipItem);
+
+    if (skipItem && skipItem->GetTemplate()->GemProperties)
+        for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                if (pItem != skipItem && pItem->GetTemplate()->Socket[0].Color)
+                    count += pItem->GetGemCountWithID(item);
+
+    if (inBankAlso)
+    {
+        // checking every item from 39 to 74 (including bank bags)
+        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                if (pItem != skipItem && pItem->GetEntry() == item)
+                    count += pItem->GetCount();
+
+        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+            if (Bag* pBag = GetBagByPos(i))
+                count += pBag->GetItemCount(item, skipItem);
+
+        if (skipItem && skipItem->GetTemplate()->GemProperties)
+            for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; ++i)
+                if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                    if (pItem != skipItem && pItem->GetTemplate()->Socket[0].Color)
+                        count += pItem->GetGemCountWithID(item);
+    }
+
+    return count;
+}
+
+uint32 Player::GetItemCountWithLimitCategory(uint32 limitCategory, Item* skipItem) const
+{
+    uint32 count = 0;
+    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem != skipItem)
+                if (ItemTemplate const* pProto = pItem->GetTemplate())
+                    if (pProto->ItemLimitCategory == limitCategory)
+                        count += pItem->GetCount();
+
+    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = GetBagByPos(i))
+            count += pBag->GetItemCountWithLimitCategory(limitCategory, skipItem);
+
+    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem != skipItem)
+                if (ItemTemplate const* pProto = pItem->GetTemplate())
+                    if (pProto->ItemLimitCategory == limitCategory)
+                        count += pItem->GetCount();
+
+    for (int i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Bag* pBag = GetBagByPos(i))
+            count += pBag->GetItemCountWithLimitCategory(limitCategory, skipItem);
+
+    return count;
+}
+
+Item* Player::GetItemByGuid(uint64 guid) const
+{
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->GetGUID() == guid)
+                return pItem;
+
+    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->GetGUID() == guid)
+                return pItem;
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    if (pItem->GetGUID() == guid)
+                        return pItem;
+
+    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Bag* pBag = GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    if (pItem->GetGUID() == guid)
+                        return pItem;
+
+    return NULL;
+}
+
+Item* Player::GetItemByPos(uint16 pos) const
+{
+    uint8 bag = pos >> 8;
+    uint8 slot = pos & 255;
+    return GetItemByPos(bag, slot);
+}
+
+Item* Player::GetItemByPos(uint8 bag, uint8 slot) const
+{
+    if (bag == INVENTORY_SLOT_BAG_0 && slot < BANK_SLOT_BAG_END)
+        return m_items[slot];
+    else if (Bag* pBag = GetBagByPos(bag))
+        return pBag->GetItemByPos(slot);
+    return NULL;
+}
+
+Bag* Player::GetBagByPos(uint8 bag) const
+{
+    if ((bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END)
+        || (bag >= BANK_SLOT_BAG_START && bag < BANK_SLOT_BAG_END))
+        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
+            return item->ToBag();
+    return NULL;
+}
+
+Item* Player::GetWeaponForAttack(WeaponAttackType attackType, bool useable /*= false*/) const
+{
+    uint8 slot;
+    switch (attackType)
+    {
+        case BASE_ATTACK:   slot = EQUIPMENT_SLOT_MAINHAND; break;
+        case OFF_ATTACK:    slot = EQUIPMENT_SLOT_OFFHAND;  break;
+        case RANGED_ATTACK: slot = EQUIPMENT_SLOT_RANGED;   break;
+        default: return NULL;
+    }
+
+    Item* item = NULL;
+    if (useable)
+        item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, slot);
+    else
+        item = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+    if (!item || item->GetTemplate()->Class != ITEM_CLASS_WEAPON)
+        return NULL;
+
+    if (!useable)
+        return item;
+
+    if (item->IsBroken() || IsInFeralForm())
+        return NULL;
+
+    return item;
+}
+
+Item* Player::GetShield(bool useable) const
+{
+    Item* item = NULL;
+    if (useable)
+        item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+    else
+        item = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+    if (!item || item->GetTemplate()->Class != ITEM_CLASS_ARMOR)
+        return NULL;
+
+    if (!useable)
+        return item;
+
+    if (item->IsBroken())
+        return NULL;
+
+    return item;
+}
+
+uint8 Player::GetAttackBySlot(uint8 slot)
+{
+    switch (slot)
+    {
+        case EQUIPMENT_SLOT_MAINHAND: return BASE_ATTACK;
+        case EQUIPMENT_SLOT_OFFHAND:  return OFF_ATTACK;
+        case EQUIPMENT_SLOT_RANGED:   return RANGED_ATTACK;
+        default:                      return MAX_ATTACK;
+    }
+}
+
+bool Player::IsInventoryPos(uint8 bag, uint8 slot)
+{
+    if (bag == INVENTORY_SLOT_BAG_0 && slot == NULL_SLOT)
+        return true;
+    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_ITEM_START && slot < INVENTORY_SLOT_ITEM_END))
+        return true;
+    if (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END)
+        return true;
+    return false;
+}
+
+bool Player::IsEquipmentPos(uint8 bag, uint8 slot)
+{
+    if (bag == INVENTORY_SLOT_BAG_0 && (slot < EQUIPMENT_SLOT_END))
+        return true;
+    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END))
+        return true;
+    return false;
+}
+
+bool Player::IsBankPos(uint8 bag, uint8 slot)
+{
+    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_ITEM_START && slot < BANK_SLOT_ITEM_END))
+        return true;
+    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END))
+        return true;
+    if (bag >= BANK_SLOT_BAG_START && bag < BANK_SLOT_BAG_END)
+        return true;
+    return false;
+}
+
+bool Player::IsBagPos(uint16 pos)
+{
+    uint8 bag = pos >> 8;
+    uint8 slot = pos & 255;
+    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END))
+        return true;
+    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END))
+        return true;
+    return false;
+}
+
+bool Player::IsValidPos(uint8 bag, uint8 slot, bool explicit_pos)
+{
+    // post selected
+    if (bag == NULL_BAG && !explicit_pos)
+        return true;
+
+    if (bag == INVENTORY_SLOT_BAG_0)
+    {
+        // any post selected
+        if (slot == NULL_SLOT && !explicit_pos)
+            return true;
+
+        // equipment
+        if (slot < EQUIPMENT_SLOT_END)
+            return true;
+
+        // bag equip slots
+        if (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END)
+            return true;
+
+        // backpack slots
+        if (slot >= INVENTORY_SLOT_ITEM_START && slot < INVENTORY_SLOT_ITEM_END)
+            return true;
+
+        // bank main slots
+        if (slot >= BANK_SLOT_ITEM_START && slot < BANK_SLOT_ITEM_END)
+            return true;
+
+        // bank bag slots
+        if (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END)
+            return true;
+
+        return false;
+    }
+
+    // bag content slots
+    // bank bag content slots
+    if (Bag* pBag = GetBagByPos(bag))
+    {
+        // any post selected
+        if (slot == NULL_SLOT && !explicit_pos)
+            return true;
+
+        return slot < pBag->GetBagSize();
+    }
+
+    // where this?
+    return false;
+}
+
+bool Player::HasItemCount(uint32 item, uint32 count, bool inBankAlso) const
+{
+    uint32 tempcount = 0;
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
+    {
+        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
+        {
+            tempcount += pItem->GetCount();
+            if (tempcount >= count)
+                return true;
+        }
+    }
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+    {
+        if (Bag* pBag = GetBagByPos(i))
+        {
+            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+            {
+                Item* pItem = GetItemByPos(i, j);
+                if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
+                {
+                    tempcount += pItem->GetCount();
+                    if (tempcount >= count)
+                        return true;
+                }
+            }
+        }
+    }
+
+    if (inBankAlso)
+    {
+        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
+        {
+            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+            if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
+            {
+                tempcount += pItem->GetCount();
+                if (tempcount >= count)
+                    return true;
+            }
+        }
+        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
+        {
+            if (Bag* pBag = GetBagByPos(i))
+            {
+                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+                {
+                    Item* pItem = GetItemByPos(i, j);
+                    if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
+                    {
+                        tempcount += pItem->GetCount();
+                        if (tempcount >= count)
+                            return true;
+                    }
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+bool Player::HasItemOrGemWithIdEquipped(uint32 item, uint32 count, uint8 except_slot) const
+{
+    uint32 tempcount = 0;
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        if (i == except_slot)
+            continue;
+
+        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pItem && pItem->GetEntry() == item)
+        {
+            tempcount += pItem->GetCount();
+            if (tempcount >= count)
+                return true;
+        }
+    }
+
+    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
+    if (pProto && pProto->GemProperties)
+    {
+        for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+        {
+            if (i == except_slot)
+                continue;
+
+            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+            if (pItem && pItem->GetTemplate()->Socket[0].Color)
+            {
+                tempcount += pItem->GetGemCountWithID(item);
+                if (tempcount >= count)
+                    return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+bool Player::HasItemOrGemWithLimitCategoryEquipped(uint32 limitCategory, uint32 count, uint8 except_slot) const
+{
+    uint32 tempcount = 0;
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        if (i == except_slot)
+            continue;
+
+        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (!pItem)
+            continue;
+
+        ItemTemplate const* pProto = pItem->GetTemplate();
+        if (!pProto)
+            continue;
+
+        if (pProto->ItemLimitCategory == limitCategory)
+        {
+            tempcount += pItem->GetCount();
+            if (tempcount >= count)
+                return true;
+        }
+
+        if (pProto->Socket[0].Color || pItem->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT))
+        {
+            tempcount += pItem->GetGemCountWithLimitCategory(limitCategory);
+            if (tempcount >= count)
+                return true;
+        }
+    }
+
+    return false;
+}
+
+InventoryResult Player::CanTakeMoreSimilarItems(uint32 entry, uint32 count, Item* pItem, uint32* no_space_count) const
+{
+    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
+    if (!pProto)
+    {
+        if (no_space_count)
+            *no_space_count = count;
+        return EQUIP_ERR_ITEM_MAX_COUNT;
+    }
+
+    if (pItem && pItem->m_lootGenerated)
+        return EQUIP_ERR_LOOT_GONE;
+
+    // no maximum
+    if ((pProto->MaxCount <= 0 && pProto->ItemLimitCategory == 0) || pProto->MaxCount == 2147483647)
+        return EQUIP_ERR_OK;
+
+    if (pProto->MaxCount > 0)
+    {
+        uint32 curcount = GetItemCount(pProto->ItemId, true, pItem);
+        if (curcount + count > uint32(pProto->MaxCount))
+        {
+            if (no_space_count)
+                *no_space_count = count + curcount - pProto->MaxCount;
+            return EQUIP_ERR_ITEM_MAX_COUNT;
+        }
+    }
+
+    // check unique-equipped limit
+    if (pProto->ItemLimitCategory)
+    {
+        ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(pProto->ItemLimitCategory);
+        if (!limitEntry)
+        {
+            if (no_space_count)
+                *no_space_count = count;
+            return EQUIP_ERR_NOT_EQUIPPABLE;
+        }
+
+        if (limitEntry->mode == ITEM_LIMIT_CATEGORY_MODE_HAVE)
+        {
+            uint32 curcount = GetItemCountWithLimitCategory(pProto->ItemLimitCategory, pItem);
+            if (curcount + count > uint32(limitEntry->maxCount))
+            {
+                if (no_space_count)
+                    *no_space_count = count + curcount - limitEntry->maxCount;
+                return EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED_IS;
+            }
+        }
+    }
+
+    return EQUIP_ERR_OK;
+}
+
+InventoryResult Player::CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const
+{
+    Item* pItem2 = GetItemByPos(bag, slot);
+
+    // ignore move item (this slot will be empty at move)
+    if (pItem2 == pSrcItem)
+        pItem2 = NULL;
+
+    uint32 need_space;
+
+    if (pSrcItem && pSrcItem->IsNotEmptyBag() && !IsBagPos(uint16(bag) << 8 | slot))
+        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;
+
+    // empty specific slot - check item fit to slot
+    if (!pItem2 || swap)
+    {
+        if (bag == INVENTORY_SLOT_BAG_0)
+        {
+            // prevent cheating
+            if ((slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END) || slot >= PLAYER_SLOT_END)
+                return EQUIP_ERR_WRONG_BAG_TYPE;
+        }
+        else
+        {
+            Bag* pBag = GetBagByPos(bag);
+            if (!pBag)
+                return EQUIP_ERR_WRONG_BAG_TYPE;
+
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (!pBagProto)
+                return EQUIP_ERR_WRONG_BAG_TYPE;
+
+            if (slot >= pBagProto->ContainerSlots)
+                return EQUIP_ERR_WRONG_BAG_TYPE;
+
+            if (!ItemCanGoIntoBag(pProto, pBagProto))
+                return EQUIP_ERR_WRONG_BAG_TYPE;
+        }
+
+        // non empty stack with space
+        need_space = pProto->GetMaxStackSize();
+    }
+    // non empty slot, check item type
+    else
+    {
+        // can be merged at least partly
+        InventoryResult res  = pItem2->CanBeMergedPartlyWith(pProto);
+        if (res != EQUIP_ERR_OK)
+            return res;
+
+        // free stack space or infinity
+        need_space = pProto->GetMaxStackSize() - pItem2->GetCount();
+    }
+
+    if (need_space > count)
+        need_space = count;
+
+    ItemPosCount newPosition = ItemPosCount((bag << 8) | slot, need_space);
+    if (!newPosition.isContainedIn(dest))
+    {
+        dest.push_back(newPosition);
+        count -= need_space;
+    }
+    return EQUIP_ERR_OK;
+}
+
+InventoryResult Player::CanStoreItem_InBag(uint8 bag, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const
+{
+    // skip specific bag already processed in first called CanStoreItem_InBag
+    if (bag == skip_bag)
+        return EQUIP_ERR_WRONG_BAG_TYPE;
+
+    // skip not existed bag or self targeted bag
+    Bag* pBag = GetBagByPos(bag);
+    if (!pBag || pBag == pSrcItem)
+        return EQUIP_ERR_WRONG_BAG_TYPE;
+
+    if (pSrcItem && pSrcItem->IsNotEmptyBag())
+        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;
+
+    ItemTemplate const* pBagProto = pBag->GetTemplate();
+    if (!pBagProto)
+        return EQUIP_ERR_WRONG_BAG_TYPE;
+
+    // specialized bag mode or non-specilized
+    if (non_specialized != (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER))
+        return EQUIP_ERR_WRONG_BAG_TYPE;
+
+    if (!ItemCanGoIntoBag(pProto, pBagProto))
+        return EQUIP_ERR_WRONG_BAG_TYPE;
+
+    for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+    {
+        // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
+        if (j == skip_slot)
+            continue;
+
+        Item* pItem2 = GetItemByPos(bag, j);
+
+        // ignore move item (this slot will be empty at move)
+        if (pItem2 == pSrcItem)
+            pItem2 = NULL;
+
+        // if merge skip empty, if !merge skip non-empty
+        if ((pItem2 != NULL) != merge)
+            continue;
+
+        uint32 need_space = pProto->GetMaxStackSize();
+
+        if (pItem2)
+        {
+            // can be merged at least partly
+            uint8 res  = pItem2->CanBeMergedPartlyWith(pProto);
+            if (res != EQUIP_ERR_OK)
+                continue;
+
+            // descrease at current stacksize
+            need_space -= pItem2->GetCount();
+        }
+
+        if (need_space > count)
+            need_space = count;
+
+        ItemPosCount newPosition = ItemPosCount((bag << 8) | j, need_space);
+        if (!newPosition.isContainedIn(dest))
+        {
+            dest.push_back(newPosition);
+            count -= need_space;
+
+            if (count==0)
+                return EQUIP_ERR_OK;
+        }
+    }
+    return EQUIP_ERR_OK;
+}
+
+InventoryResult Player::CanStoreItem_InInventorySlots(uint8 slot_begin, uint8 slot_end, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool merge, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const
+{
+    //this is never called for non-bag slots so we can do this
+    if (pSrcItem && pSrcItem->IsNotEmptyBag())
+        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;
+
+    for (uint32 j = slot_begin; j < slot_end; j++)
+    {
+        // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
+        if (INVENTORY_SLOT_BAG_0 == skip_bag && j == skip_slot)
+            continue;
+
+        Item* pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, j);
+
+        // ignore move item (this slot will be empty at move)
+        if (pItem2 == pSrcItem)
+            pItem2 = NULL;
+
+        // if merge skip empty, if !merge skip non-empty
+        if ((pItem2 != NULL) != merge)
+            continue;
+
+        uint32 need_space = pProto->GetMaxStackSize();
+
+        if (pItem2)
+        {
+            // can be merged at least partly
+            uint8 res  = pItem2->CanBeMergedPartlyWith(pProto);
+            if (res != EQUIP_ERR_OK)
+                continue;
+
+            // descrease at current stacksize
+            need_space -= pItem2->GetCount();
+        }
+
+        if (need_space > count)
+            need_space = count;
+
+        ItemPosCount newPosition = ItemPosCount((INVENTORY_SLOT_BAG_0 << 8) | j, need_space);
+        if (!newPosition.isContainedIn(dest))
+        {
+            dest.push_back(newPosition);
+            count -= need_space;
+
+            if (count==0)
+                return EQUIP_ERR_OK;
+        }
+    }
+    return EQUIP_ERR_OK;
+}
+
+InventoryResult Player::CanStoreItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, uint32 entry, uint32 count, Item* pItem, bool swap, uint32* no_space_count) const
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanStoreItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, entry, count);
+
+    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
+    if (!pProto)
+    {
+        if (no_space_count)
+            *no_space_count = count;
+        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;
+    }
+
+    if (pItem)
+    {
+        // item used
+        if (pItem->m_lootGenerated)
+        {
+            if (no_space_count)
+                *no_space_count = count;
+            return EQUIP_ERR_LOOT_GONE;
+        }
+
+        if (pItem->IsBindedNotWith(this))
+        {
+            if (no_space_count)
+                *no_space_count = count;
+            return EQUIP_ERR_NOT_OWNER;
+        }
+    }
+
+    // check count of items (skip for auto move for same player from bank)
+    uint32 no_similar_count = 0;                            // can't store this amount similar items
+    InventoryResult res = CanTakeMoreSimilarItems(entry, count, pItem, &no_similar_count);
+    if (res != EQUIP_ERR_OK)
+    {
+        if (count == no_similar_count)
+        {
+            if (no_space_count)
+                *no_space_count = no_similar_count;
+            return res;
+        }
+        count -= no_similar_count;
+    }
+
+    // in specific slot
+    if (bag != NULL_BAG && slot != NULL_SLOT)
+    {
+        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);
+        if (res != EQUIP_ERR_OK)
+        {
+            if (no_space_count)
+                *no_space_count = count + no_similar_count;
+            return res;
+        }
+
+        if (count == 0)
+        {
+            if (no_similar_count == 0)
+                return EQUIP_ERR_OK;
+
+            if (no_space_count)
+                *no_space_count = count + no_similar_count;
+            return EQUIP_ERR_ITEM_MAX_COUNT;
+        }
+    }
+
+    // not specific slot or have space for partly store only in specific slot
+
+    // in specific bag
+    if (bag != NULL_BAG)
+    {
+        // search stack in bag for merge to
+        if (pProto->Stackable != 1)
+        {
+            if (bag == INVENTORY_SLOT_BAG_0)               // inventory
+            {
+                res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
+                if (res != EQUIP_ERR_OK)
+                {
+                    if (no_space_count)
+                        *no_space_count = count + no_similar_count;
+                    return res;
+                }
+
+                if (count == 0)
+                {
+                    if (no_similar_count == 0)
+                        return EQUIP_ERR_OK;
+
+                    if (no_space_count)
+                        *no_space_count = count + no_similar_count;
+                    return EQUIP_ERR_ITEM_MAX_COUNT;
+                }
+            }
+            else                                            // equipped bag
+            {
+                // we need check 2 time (specialized/non_specialized), use NULL_BAG to prevent skipping bag
+                res = CanStoreItem_InBag(bag, dest, pProto, count, true, false, pItem, NULL_BAG, slot);
+                if (res != EQUIP_ERR_OK)
+                    res = CanStoreItem_InBag(bag, dest, pProto, count, true, true, pItem, NULL_BAG, slot);
+
+                if (res != EQUIP_ERR_OK)
+                {
+                    if (no_space_count)
+                        *no_space_count = count + no_similar_count;
+                    return res;
+                }
+
+                if (count == 0)
+                {
+                    if (no_similar_count == 0)
+                        return EQUIP_ERR_OK;
+
+                    if (no_space_count)
+                        *no_space_count = count + no_similar_count;
+                    return EQUIP_ERR_ITEM_MAX_COUNT;
+                }
+            }
+        }
+
+        // search free slot in bag for place to
+        if (bag == INVENTORY_SLOT_BAG_0)                     // inventory
+        {
+            res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
+            if (res != EQUIP_ERR_OK)
+            {
+                if (no_space_count)
+                    *no_space_count = count + no_similar_count;
+                return res;
+            }
+
+            if (count == 0)
+            {
+                if (no_similar_count == 0)
+                    return EQUIP_ERR_OK;
+
+                if (no_space_count)
+                    *no_space_count = count + no_similar_count;
+                return EQUIP_ERR_ITEM_MAX_COUNT;
+            }
+        }
+        else                                                // equipped bag
+        {
+            res = CanStoreItem_InBag(bag, dest, pProto, count, false, false, pItem, NULL_BAG, slot);
+            if (res != EQUIP_ERR_OK)
+                res = CanStoreItem_InBag(bag, dest, pProto, count, false, true, pItem, NULL_BAG, slot);
+
+            if (res != EQUIP_ERR_OK)
+            {
+                if (no_space_count)
+                    *no_space_count = count + no_similar_count;
+                return res;
+            }
+
+            if (count == 0)
+            {
+                if (no_similar_count == 0)
+                    return EQUIP_ERR_OK;
+
+                if (no_space_count)
+                    *no_space_count = count + no_similar_count;
+                return EQUIP_ERR_ITEM_MAX_COUNT;
+            }
+        }
+    }
+
+    // not specific bag or have space for partly store only in specific bag
+
+    // search stack for merge to
+    if (pProto->Stackable != 1)
+    {
+        res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
+        if (res != EQUIP_ERR_OK)
+        {
+            if (no_space_count)
+                *no_space_count = count + no_similar_count;
+            return res;
+        }
+
+        if (count == 0)
+        {
+            if (no_similar_count == 0)
+                return EQUIP_ERR_OK;
+
+            if (no_space_count)
+                *no_space_count = count + no_similar_count;
+            return EQUIP_ERR_ITEM_MAX_COUNT;
+        }
+
+        if (pProto->BagFamily)
+        {
+            for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+            {
+                res = CanStoreItem_InBag(i, dest, pProto, count, true, false, pItem, bag, slot);
+                if (res != EQUIP_ERR_OK)
+                    continue;
+
+                if (count == 0)
+                {
+                    if (no_similar_count == 0)
+                        return EQUIP_ERR_OK;
+
+                    if (no_space_count)
+                        *no_space_count = count + no_similar_count;
+                    return EQUIP_ERR_ITEM_MAX_COUNT;
+                }
+            }
+        }
+
+        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+        {
+            res = CanStoreItem_InBag(i, dest, pProto, count, true, true, pItem, bag, slot);
+            if (res != EQUIP_ERR_OK)
+                continue;
+
+            if (count == 0)
+            {
+                if (no_similar_count == 0)
+                    return EQUIP_ERR_OK;
+
+                if (no_space_count)
+                    *no_space_count = count + no_similar_count;
+                return EQUIP_ERR_ITEM_MAX_COUNT;
+            }
+        }
+    }
+
+    // search free slot - special bag case
+    if (pProto->BagFamily)
+    {
+        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+        {
+            res = CanStoreItem_InBag(i, dest, pProto, count, false, false, pItem, bag, slot);
+            if (res != EQUIP_ERR_OK)
+                continue;
+
+            if (count == 0)
+            {
+                if (no_similar_count == 0)
+                    return EQUIP_ERR_OK;
+
+                if (no_space_count)
+                    *no_space_count = count + no_similar_count;
+                return EQUIP_ERR_ITEM_MAX_COUNT;
+            }
+        }
+    }
+
+    if (pItem && pItem->IsNotEmptyBag())
+        return EQUIP_ERR_BAG_IN_BAG;
+
+    // search free slot
+    res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
+    if (res != EQUIP_ERR_OK)
+    {
+        if (no_space_count)
+            *no_space_count = count + no_similar_count;
+        return res;
+    }
+
+    if (count == 0)
+    {
+        if (no_similar_count == 0)
+            return EQUIP_ERR_OK;
+
+        if (no_space_count)
+            *no_space_count = count + no_similar_count;
+        return EQUIP_ERR_ITEM_MAX_COUNT;
+    }
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+    {
+        res = CanStoreItem_InBag(i, dest, pProto, count, false, true, pItem, bag, slot);
+        if (res != EQUIP_ERR_OK)
+            continue;
+
+        if (count == 0)
+        {
+            if (no_similar_count == 0)
+                return EQUIP_ERR_OK;
+
+            if (no_space_count)
+                *no_space_count = count + no_similar_count;
+            return EQUIP_ERR_ITEM_MAX_COUNT;
+        }
+    }
+
+    if (no_space_count)
+        *no_space_count = count + no_similar_count;
+
+    return EQUIP_ERR_INV_FULL;
+}
+
+//////////////////////////////////////////////////////////////////////////
+InventoryResult Player::CanStoreItems(Item** pItems, int count) const
+{
+    Item* pItem2;
+
+    // fill space table
+    int inv_slot_items[INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START];
+    int inv_bags[INVENTORY_SLOT_BAG_END - INVENTORY_SLOT_BAG_START][MAX_BAG_SIZE];
+
+    memset(inv_slot_items, 0, sizeof(int) * (INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START));
+    memset(inv_bags, 0, sizeof(int) * (INVENTORY_SLOT_BAG_END - INVENTORY_SLOT_BAG_START) * MAX_BAG_SIZE);
+
+    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+    {
+        pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pItem2 && !pItem2->IsInTrade())
+            inv_slot_items[i - INVENTORY_SLOT_ITEM_START] = pItem2->GetCount();
+    }
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+        if (Bag* pBag = GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+            {
+                pItem2 = GetItemByPos(i, j);
+                if (pItem2 && !pItem2->IsInTrade())
+                    inv_bags[i - INVENTORY_SLOT_BAG_START][j] = pItem2->GetCount();
+            }
+
+    // check free space for all items
+    for (int k = 0; k < count; ++k)
+    {
+        Item* pItem = pItems[k];
+
+        // no item
+        if (!pItem)
+            continue;
+
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanStoreItems %i. item = %u, count = %u", k + 1, pItem->GetEntry(), pItem->GetCount());
+        ItemTemplate const* pProto = pItem->GetTemplate();
+
+        // strange item
+        if (!pProto)
+            return EQUIP_ERR_ITEM_NOT_FOUND;
+
+        // item used
+        if (pItem->m_lootGenerated)
+            return EQUIP_ERR_LOOT_GONE;
+
+        // item it 'bind'
+        if (pItem->IsBindedNotWith(this))
+            return EQUIP_ERR_NOT_OWNER;
+
+        ItemTemplate const* pBagProto;
+
+        // item is 'one item only'
+        InventoryResult res = CanTakeMoreSimilarItems(pItem);
+        if (res != EQUIP_ERR_OK)
+            return res;
+
+        // search stack for merge to
+        if (pProto->Stackable != 1)
+        {
+            bool b_found = false;
+
+            for (int t = INVENTORY_SLOT_ITEM_START; t < INVENTORY_SLOT_ITEM_END; ++t)
+            {
+                pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, t);
+                if (pItem2 && pItem2->CanBeMergedPartlyWith(pProto) == EQUIP_ERR_OK && inv_slot_items[t-INVENTORY_SLOT_ITEM_START] + pItem->GetCount() <= pProto->GetMaxStackSize())
+                {
+                    inv_slot_items[t-INVENTORY_SLOT_ITEM_START] += pItem->GetCount();
+                    b_found = true;
+                    break;
+                }
+            }
+            if (b_found)
+                continue;
+
+            for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
+            {
+                if (Bag* bag = GetBagByPos(t))
+                {
+                    if (ItemCanGoIntoBag(pItem->GetTemplate(), bag->GetTemplate()))
+                    {
+                        for (uint32 j = 0; j < bag->GetBagSize(); j++)
+                        {
+                            pItem2 = GetItemByPos(t, j);
+                            if (pItem2 && pItem2->CanBeMergedPartlyWith(pProto) == EQUIP_ERR_OK && inv_bags[t-INVENTORY_SLOT_BAG_START][j] + pItem->GetCount() <= pProto->GetMaxStackSize())
+                            {
+                                inv_bags[t-INVENTORY_SLOT_BAG_START][j] += pItem->GetCount();
+                                b_found = true;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+            if (b_found)
+                continue;
+        }
+
+        // special bag case
+        if (pProto->BagFamily)
+        {
+            bool b_found = false;
+
+            for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
+            {
+                if (Bag* bag = GetBagByPos(t))
+                {
+                    pBagProto = bag->GetTemplate();
+
+                    // not plain container check
+                    if (pBagProto && (pBagProto->Class != ITEM_CLASS_CONTAINER || pBagProto->SubClass != ITEM_SUBCLASS_CONTAINER) &&
+                        ItemCanGoIntoBag(pProto, pBagProto))
+                    {
+                        for (uint32 j = 0; j < bag->GetBagSize(); j++)
+                        {
+                            if (inv_bags[t-INVENTORY_SLOT_BAG_START][j] == 0)
+                            {
+                                inv_bags[t-INVENTORY_SLOT_BAG_START][j] = 1;
+                                b_found = true;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+            if (b_found)
+                continue;
+        }
+
+        // search free slot
+        bool b_found = false;
+        for (int t = INVENTORY_SLOT_ITEM_START; t < INVENTORY_SLOT_ITEM_END; ++t)
+        {
+            if (inv_slot_items[t-INVENTORY_SLOT_ITEM_START] == 0)
+            {
+                inv_slot_items[t-INVENTORY_SLOT_ITEM_START] = 1;
+                b_found = true;
+                break;
+            }
+        }
+        if (b_found)
+            continue;
+
+        // search free slot in bags
+        for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
+        {
+            if (Bag* bag = GetBagByPos(t))
+            {
+                pBagProto = bag->GetTemplate();
+
+                // special bag already checked
+                if (pBagProto && (pBagProto->Class != ITEM_CLASS_CONTAINER || pBagProto->SubClass != ITEM_SUBCLASS_CONTAINER))
+                    continue;
+
+                for (uint32 j = 0; j < bag->GetBagSize(); j++)
+                {
+                    if (inv_bags[t-INVENTORY_SLOT_BAG_START][j] == 0)
+                    {
+                        inv_bags[t-INVENTORY_SLOT_BAG_START][j] = 1;
+                        b_found = true;
+                        break;
+                    }
+                }
+            }
+        }
+
+        // no free slot found?
+        if (!b_found)
+            return EQUIP_ERR_INV_FULL;
+    }
+
+    return EQUIP_ERR_OK;
+}
+
+//////////////////////////////////////////////////////////////////////////
+InventoryResult Player::CanEquipNewItem(uint8 slot, uint16 &dest, uint32 item, bool swap) const
+{
+    dest = 0;
+    Item* pItem = Item::CreateItem(item, 1, this);
+    if (pItem)
+    {
+        InventoryResult result = CanEquipItem(slot, dest, pItem, swap);
+        delete pItem;
+        return result;
+    }
+
+    return EQUIP_ERR_ITEM_NOT_FOUND;
+}
+
+InventoryResult Player::CanEquipItem(uint8 slot, uint16 &dest, Item* pItem, bool swap, bool not_loading) const
+{
+    dest = 0;
+    if (pItem)
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanEquipItem slot = %u, item = %u, count = %u", slot, pItem->GetEntry(), pItem->GetCount());
+        ItemTemplate const* pProto = pItem->GetTemplate();
+        if (pProto)
+        {
+            // item used
+            if (pItem->m_lootGenerated)
+                return EQUIP_ERR_LOOT_GONE;
+
+            if (pItem->IsBindedNotWith(this))
+                return EQUIP_ERR_NOT_OWNER;
+
+            // check count of items (skip for auto move for same player from bank)
+            InventoryResult res = CanTakeMoreSimilarItems(pItem);
+            if (res != EQUIP_ERR_OK)
+                return res;
+
+            // check this only in game
+            if (not_loading)
+            {
+                // May be here should be more stronger checks; STUNNED checked
+                // ROOT, CONFUSED, DISTRACTED, FLEEING this needs to be checked.
+                if (HasUnitState(UNIT_STATE_STUNNED))
+                    return EQUIP_ERR_GENERIC_STUNNED;
+
+                // do not allow equipping gear except weapons, offhands, projectiles, relics in
+                // - combat
+                // - in-progress arenas
+                if (!pProto->CanChangeEquipStateInCombat())
+                {
+                    if (isInCombat())
+                        return EQUIP_ERR_NOT_IN_COMBAT;
+
+                    if (Battleground* bg = GetBattleground())
+                        if (bg->isArena() && bg->GetStatus() == STATUS_IN_PROGRESS)
+                            return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
+                }
+
+                if (isInCombat()&& (pProto->Class == ITEM_CLASS_WEAPON || pProto->InventoryType == INVTYPE_RELIC) && m_weaponChangeTimer != 0)
+                    return EQUIP_ERR_CLIENT_LOCKED_OUT;         // maybe exist better err
+
+                if (IsNonMeleeSpellCasted(false))
+                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
+            }
+
+            ScalingStatDistributionEntry const* ssd = pProto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(pProto->ScalingStatDistribution) : 0;
+            // check allowed level (extend range to upper values if MaxLevel more or equal max player level, this let GM set high level with 1...max range items)
+            if (ssd && ssd->MaxLevel < DEFAULT_MAX_LEVEL && ssd->MaxLevel < getLevel())
+                return EQUIP_ERR_NOT_EQUIPPABLE;
+
+            uint8 eslot = FindEquipSlot(pProto, slot, swap);
+            if (eslot == NULL_SLOT)
+                return EQUIP_ERR_NOT_EQUIPPABLE;
+
+            res = CanUseItem(pItem, not_loading);
+            if (res != EQUIP_ERR_OK)
+                return res;
+
+            if (!swap && GetItemByPos(INVENTORY_SLOT_BAG_0, eslot))
+                return EQUIP_ERR_NO_SLOT_AVAILABLE;
+
+            // if we are swapping 2 equiped items, CanEquipUniqueItem check
+            // should ignore the item we are trying to swap, and not the
+            // destination item. CanEquipUniqueItem should ignore destination
+            // item only when we are swapping weapon from bag
+            uint8 ignore = uint8(NULL_SLOT);
+            switch (eslot)
+            {
+                case EQUIPMENT_SLOT_MAINHAND:
+                    ignore = EQUIPMENT_SLOT_OFFHAND;
+                    break;
+                case EQUIPMENT_SLOT_OFFHAND:
+                    ignore = EQUIPMENT_SLOT_MAINHAND;
+                    break;
+                case EQUIPMENT_SLOT_FINGER1:
+                    ignore = EQUIPMENT_SLOT_FINGER2;
+                    break;
+                case EQUIPMENT_SLOT_FINGER2:
+                    ignore = EQUIPMENT_SLOT_FINGER1;
+                    break;
+                case EQUIPMENT_SLOT_TRINKET1:
+                    ignore = EQUIPMENT_SLOT_TRINKET2;
+                    break;
+                case EQUIPMENT_SLOT_TRINKET2:
+                    ignore = EQUIPMENT_SLOT_TRINKET1;
+                    break;
+            }
+
+            if (ignore == uint8(NULL_SLOT) || pItem != GetItemByPos(INVENTORY_SLOT_BAG_0, ignore))
+                ignore = eslot;
+
+            InventoryResult res2 = CanEquipUniqueItem(pItem, swap ? ignore : uint8(NULL_SLOT));
+            if (res2 != EQUIP_ERR_OK)
+                return res2;
+
+            // check unique-equipped special item classes
+            if (pProto->Class == ITEM_CLASS_QUIVER)
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+                    if (Item* pBag = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                        if (pBag != pItem)
+                            if (ItemTemplate const* pBagProto = pBag->GetTemplate())
+                                if (pBagProto->Class == pProto->Class && (!swap || pBag->GetSlot() != eslot))
+                                    return (pBagProto->SubClass == ITEM_SUBCLASS_AMMO_POUCH)
+                                        ? EQUIP_ERR_ONLY_ONE_AMMO
+                                        : EQUIP_ERR_ONLY_ONE_QUIVER;
+
+            uint32 type = pProto->InventoryType;
+
+            if (eslot == EQUIPMENT_SLOT_OFFHAND)
+            {
+                // Do not allow polearm to be equipped in the offhand (rare case for the only 1h polearm 41750)
+                if (type == INVTYPE_WEAPON && pProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                    return EQUIP_ERR_2HSKILLNOTFOUND;
+                else if (type == INVTYPE_WEAPON || type == INVTYPE_WEAPONOFFHAND)
+                {
+                    if (!CanDualWield())
+                        return EQUIP_ERR_2HSKILLNOTFOUND;
+                }
+                else if (type == INVTYPE_2HWEAPON)
+                {
+                    if (!CanDualWield() || !CanTitanGrip())
+                        return EQUIP_ERR_2HSKILLNOTFOUND;
+                }
+
+                if (IsTwoHandUsed())
+                    return EQUIP_ERR_2HANDED_EQUIPPED;
+            }
+
+            // equip two-hand weapon case (with possible unequip 2 items)
+            if (type == INVTYPE_2HWEAPON)
+            {
+                if (eslot == EQUIPMENT_SLOT_OFFHAND)
+                {
+                    if (!CanTitanGrip())
+                        return EQUIP_ERR_NOT_EQUIPPABLE;
+                }
+                else if (eslot != EQUIPMENT_SLOT_MAINHAND)
+                    return EQUIP_ERR_NOT_EQUIPPABLE;
+
+                if (!CanTitanGrip())
+                {
+                    // offhand item must can be stored in inventory for offhand item and it also must be unequipped
+                    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+                    ItemPosCountVec off_dest;
+                    if (offItem && (!not_loading ||
+                        CanUnequipItem(uint16(INVENTORY_SLOT_BAG_0) << 8 | EQUIPMENT_SLOT_OFFHAND, false) != EQUIP_ERR_OK ||
+                        CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false) != EQUIP_ERR_OK))
+                        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_INV_FULL;
+                }
+            }
+            dest = ((INVENTORY_SLOT_BAG_0 << 8) | eslot);
+            return EQUIP_ERR_OK;
+        }
+    }
+
+    return !swap ? EQUIP_ERR_ITEM_NOT_FOUND : EQUIP_ERR_CANT_SWAP;
+}
+
+InventoryResult Player::CanUnequipItem(uint16 pos, bool swap) const
+{
+    // Applied only to equipped items and bank bags
+    if (!IsEquipmentPos(pos) && !IsBagPos(pos))
+        return EQUIP_ERR_OK;
+
+    Item* pItem = GetItemByPos(pos);
+
+    // Applied only to existed equipped item
+    if (!pItem)
+        return EQUIP_ERR_OK;
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanUnequipItem slot = %u, item = %u, count = %u", pos, pItem->GetEntry(), pItem->GetCount());
+
+    ItemTemplate const* pProto = pItem->GetTemplate();
+    if (!pProto)
+        return EQUIP_ERR_ITEM_NOT_FOUND;
+
+    // item used
+    if (pItem->m_lootGenerated)
+        return EQUIP_ERR_LOOT_GONE;
+
+    // do not allow unequipping gear except weapons, offhands, projectiles, relics in
+    // - combat
+    // - in-progress arenas
+    if (!pProto->CanChangeEquipStateInCombat())
+    {
+        if (isInCombat())
+            return EQUIP_ERR_NOT_IN_COMBAT;
+
+        if (Battleground* bg = GetBattleground())
+            if (bg->isArena() && bg->GetStatus() == STATUS_IN_PROGRESS)
+                return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
+    }
+
+    if (!swap && pItem->IsNotEmptyBag())
+        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;
+
+    return EQUIP_ERR_OK;
+}
+
+InventoryResult Player::CanBankItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, Item* pItem, bool swap, bool not_loading) const
+{
+    if (!pItem)
+        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;
+
+    uint32 count = pItem->GetCount();
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanBankItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, pItem->GetEntry(), pItem->GetCount());
+    ItemTemplate const* pProto = pItem->GetTemplate();
+    if (!pProto)
+        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;
+
+    // item used
+    if (pItem->m_lootGenerated)
+        return EQUIP_ERR_LOOT_GONE;
+
+    if (pItem->IsBindedNotWith(this))
+        return EQUIP_ERR_NOT_OWNER;
+
+    // Currency Tokenizer are not supposed to be swapped out of their hidden bag
+    if (pItem->IsCurrencyToken())
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Possible hacking attempt: Player %s [guid: %u] tried to move token [guid: %u, entry: %u] out of the currency bag!",
+                GetName().c_str(), GetGUIDLow(), pItem->GetGUIDLow(), pProto->ItemId);
+        return EQUIP_ERR_CANT_SWAP;
+    }
+
+    // check count of items (skip for auto move for same player from bank)
+    InventoryResult res = CanTakeMoreSimilarItems(pItem);
+    if (res != EQUIP_ERR_OK)
+        return res;
+
+    // in specific slot
+    if (bag != NULL_BAG && slot != NULL_SLOT)
+    {
+        if (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END)
+        {
+            if (!pItem->IsBag())
+                return EQUIP_ERR_WRONG_SLOT;
+
+            if (slot - BANK_SLOT_BAG_START >= GetBankBagSlotCount())
+                return EQUIP_ERR_NO_BANK_SLOT;
+
+            res = CanUseItem(pItem, not_loading);
+            if (res != EQUIP_ERR_OK)
+                return res;
+        }
+
+        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);
+        if (res != EQUIP_ERR_OK)
+            return res;
+
+        if (count == 0)
+            return EQUIP_ERR_OK;
+    }
+
+    // not specific slot or have space for partly store only in specific slot
+
+    // in specific bag
+    if (bag != NULL_BAG)
+    {
+        if (pItem->IsNotEmptyBag())
+            return EQUIP_ERR_BAG_IN_BAG;
+
+        // search stack in bag for merge to
+        if (pProto->Stackable != 1)
+        {
+            if (bag == INVENTORY_SLOT_BAG_0)
+            {
+                res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
+                if (res != EQUIP_ERR_OK)
+                    return res;
+
+                if (count == 0)
+                    return EQUIP_ERR_OK;
+            }
+            else
+            {
+                res = CanStoreItem_InBag(bag, dest, pProto, count, true, false, pItem, NULL_BAG, slot);
+                if (res != EQUIP_ERR_OK)
+                    res = CanStoreItem_InBag(bag, dest, pProto, count, true, true, pItem, NULL_BAG, slot);
+
+                if (res != EQUIP_ERR_OK)
+                    return res;
+
+                if (count == 0)
+                    return EQUIP_ERR_OK;
+            }
+        }
+
+        // search free slot in bag
+        if (bag == INVENTORY_SLOT_BAG_0)
+        {
+            res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
+            if (res != EQUIP_ERR_OK)
+                return res;
+
+            if (count == 0)
+                return EQUIP_ERR_OK;
+        }
+        else
+        {
+            res = CanStoreItem_InBag(bag, dest, pProto, count, false, false, pItem, NULL_BAG, slot);
+            if (res != EQUIP_ERR_OK)
+                res = CanStoreItem_InBag(bag, dest, pProto, count, false, true, pItem, NULL_BAG, slot);
+
+            if (res != EQUIP_ERR_OK)
+                return res;
+
+            if (count == 0)
+                return EQUIP_ERR_OK;
+        }
+    }
+
+    // not specific bag or have space for partly store only in specific bag
+
+    // search stack for merge to
+    if (pProto->Stackable != 1)
+    {
+        // in slots
+        res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
+        if (res != EQUIP_ERR_OK)
+            return res;
+
+        if (count == 0)
+            return EQUIP_ERR_OK;
+
+        // in special bags
+        if (pProto->BagFamily)
+        {
+            for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
+            {
+                res = CanStoreItem_InBag(i, dest, pProto, count, true, false, pItem, bag, slot);
+                if (res != EQUIP_ERR_OK)
+                    continue;
+
+                if (count == 0)
+                    return EQUIP_ERR_OK;
+            }
+        }
+
+        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
+        {
+            res = CanStoreItem_InBag(i, dest, pProto, count, true, true, pItem, bag, slot);
+            if (res != EQUIP_ERR_OK)
+                continue;
+
+            if (count == 0)
+                return EQUIP_ERR_OK;
+        }
+    }
+
+    // search free place in special bag
+    if (pProto->BagFamily)
+    {
+        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
+        {
+            res = CanStoreItem_InBag(i, dest, pProto, count, false, false, pItem, bag, slot);
+            if (res != EQUIP_ERR_OK)
+                continue;
+
+            if (count == 0)
+                return EQUIP_ERR_OK;
+        }
+    }
+
+    // search free space
+    res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
+    if (res != EQUIP_ERR_OK)
+        return res;
+
+    if (count == 0)
+        return EQUIP_ERR_OK;
+
+    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
+    {
+        res = CanStoreItem_InBag(i, dest, pProto, count, false, true, pItem, bag, slot);
+        if (res != EQUIP_ERR_OK)
+            continue;
+
+        if (count == 0)
+            return EQUIP_ERR_OK;
+    }
+    return EQUIP_ERR_BANK_FULL;
+}
+
+InventoryResult Player::CanUseItem(Item* pItem, bool not_loading) const
+{
+    if (pItem)
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanUseItem item = %u", pItem->GetEntry());
+
+        if (!isAlive() && not_loading)
+            return EQUIP_ERR_PLAYER_DEAD;
+
+        //if (isStunned())
+        //    return EQUIP_ERR_GENERIC_STUNNED;
+
+        ItemTemplate const* pProto = pItem->GetTemplate();
+        if (pProto)
+        {
+            if (pItem->IsBindedNotWith(this))
+                return EQUIP_ERR_NOT_OWNER;
+
+            InventoryResult res = CanUseItem(pProto);
+            if (res != EQUIP_ERR_OK)
+                return res;
+
+            if (pItem->GetSkill() != 0)
+            {
+                bool allowEquip = false;
+                uint32 itemSkill = pItem->GetSkill();
+                // Armor that is binded to account can "morph" from plate to mail, etc. if skill is not learned yet.
+                if (pProto->Quality == ITEM_QUALITY_HEIRLOOM && pProto->Class == ITEM_CLASS_ARMOR && !HasSkill(itemSkill))
+                {
+                    // TODO: when you right-click already equipped item it throws EQUIP_ERR_PROFICIENCY_NEEDED.
+
+                    // In fact it's a visual bug, everything works properly... I need sniffs of operations with
+                    // binded to account items from off server.
+
+                    switch (getClass())
+                    {
+                        case CLASS_HUNTER:
+                        case CLASS_SHAMAN:
+                            allowEquip = (itemSkill == SKILL_MAIL);
+                            break;
+                        case CLASS_PALADIN:
+                        case CLASS_WARRIOR:
+                            allowEquip = (itemSkill == SKILL_PLATE_MAIL);
+                            break;
+                    }
+                }
+                if (!allowEquip && GetSkillValue(itemSkill) == 0)
+                    return EQUIP_ERR_PROFICIENCY_NEEDED;
+            }
+
+            if (pProto->RequiredReputationFaction && uint32(GetReputationRank(pProto->RequiredReputationFaction)) < pProto->RequiredReputationRank)
+                return EQUIP_ERR_CANT_EQUIP_REPUTATION;
+
+            return EQUIP_ERR_OK;
+        }
+    }
+    return EQUIP_ERR_ITEM_NOT_FOUND;
+}
+
+InventoryResult Player::CanUseItem(ItemTemplate const* proto) const
+{
+    // Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player
+
+    if (proto)
+    {
+        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetTeam() != HORDE)
+            return EQUIP_ERR_CANT_EQUIP_EVER;
+
+        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetTeam() != ALLIANCE)
+            return EQUIP_ERR_CANT_EQUIP_EVER;
+
+        if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
+            return EQUIP_ERR_CANT_EQUIP_EVER;
+
+        if (proto->RequiredSkill != 0)
+        {
+            if (GetSkillValue(proto->RequiredSkill) == 0)
+                return EQUIP_ERR_PROFICIENCY_NEEDED;
+            else if (GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
+                return EQUIP_ERR_CANT_EQUIP_SKILL;
+        }
+
+        if (proto->RequiredSpell != 0 && !HasSpell(proto->RequiredSpell))
+            return EQUIP_ERR_PROFICIENCY_NEEDED;
+
+        if (getLevel() < proto->RequiredLevel)
+            return EQUIP_ERR_CANT_EQUIP_LEVEL_I;
+
+        // If World Event is not active, prevent using event dependant items
+        if (proto->HolidayId && !IsHolidayActive((HolidayIds)proto->HolidayId))
+            return EQUIP_ERR_CLIENT_LOCKED_OUT;
+
+        return EQUIP_ERR_OK;
+    }
+
+    return EQUIP_ERR_ITEM_NOT_FOUND;
+}
+
+InventoryResult Player::CanRollForItemInLFG(ItemTemplate const* proto, WorldObject const* lootedObject) const
+{
+	if (!GetGroup() || !GetGroup()->isLFGGroup())
+		return EQUIP_ERR_OK;    // not in LFG group
+
+	// check if looted object is inside the lfg dungeon
+	Map const* map = lootedObject->GetMap();
+	if (!sLFGMgr->inLfgDungeonMap(GetGroup()->GetGUID(), map->GetId(), map->GetDifficulty()))
+		return EQUIP_ERR_OK;
+
+	if (!proto)
+		return EQUIP_ERR_ITEM_NOT_FOUND;
+    // Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player
+
+    const static uint32 item_weapon_skills[MAX_ITEM_SUBCLASS_WEAPON] =
+    {
+        SKILL_AXES,     SKILL_2H_AXES,  SKILL_BOWS,          SKILL_GUNS,      SKILL_MACES,
+        SKILL_2H_MACES, SKILL_POLEARMS, SKILL_SWORDS,        SKILL_2H_SWORDS, 0,
+        SKILL_STAVES,   0,              0,                   SKILL_FIST_WEAPONS,   0,
+        SKILL_DAGGERS,  SKILL_THROWN,   SKILL_ASSASSINATION, SKILL_CROSSBOWS, SKILL_WANDS,
+        SKILL_FISHING
+    }; //Copy from function Item::GetSkill()
+
+    if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
+        return EQUIP_ERR_CANT_EQUIP_EVER;
+
+    if (proto->RequiredSpell != 0 && !HasSpell(proto->RequiredSpell))
+        return EQUIP_ERR_PROFICIENCY_NEEDED;
+
+    if (proto->RequiredSkill != 0)
+    {
+        if (!GetSkillValue(proto->RequiredSkill))
+            return EQUIP_ERR_PROFICIENCY_NEEDED;
+        else if (GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
+            return EQUIP_ERR_CANT_EQUIP_SKILL;
+    }
+
+    uint8 _class = getClass();
+
+    if (proto->Class == ITEM_CLASS_WEAPON && GetSkillValue(item_weapon_skills[proto->SubClass]) == 0)
+        return EQUIP_ERR_PROFICIENCY_NEEDED;
+
+    if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass > ITEM_SUBCLASS_ARMOR_MISCELLANEOUS && proto->SubClass < ITEM_SUBCLASS_ARMOR_BUCKLER && proto->InventoryType != INVTYPE_CLOAK)
+    {
+        if (_class == CLASS_WARRIOR || _class == CLASS_PALADIN || _class == CLASS_DEATH_KNIGHT)
+        {
+            if (getLevel() < 40)
+            {
+                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
+                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
+            }
+            else if (proto->SubClass != ITEM_SUBCLASS_ARMOR_PLATE)
+                return EQUIP_ERR_CLIENT_LOCKED_OUT;
+        }
+        else if (_class == CLASS_HUNTER || _class == CLASS_SHAMAN)
+        {
+            if (getLevel() < 40)
+            {
+                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
+                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
+            }
+            else if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
+                return EQUIP_ERR_CLIENT_LOCKED_OUT;
+        }
+
+        if (_class == CLASS_ROGUE || _class == CLASS_DRUID)
+            if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
+                return EQUIP_ERR_CLIENT_LOCKED_OUT;
+
+        if (_class == CLASS_MAGE || _class == CLASS_PRIEST || _class == CLASS_WARLOCK)
+            if (proto->SubClass != ITEM_SUBCLASS_ARMOR_CLOTH)
+                return EQUIP_ERR_CLIENT_LOCKED_OUT;
+    }
+
+    return EQUIP_ERR_OK;
+}
+
+Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update, int32 randomPropertyId)
+{
+    AllowedLooterSet allowedLooters;
+    return StoreNewItem(dest, item, update, randomPropertyId, allowedLooters);
+}
+
+// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
+Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update, int32 randomPropertyId, AllowedLooterSet& allowedLooters)
+{
+    uint32 count = 0;
+    for (ItemPosCountVec::const_iterator itr = dest.begin(); itr != dest.end(); ++itr)
+        count += itr->count;
+
+    Item* pItem = Item::CreateItem(item, count, this);
+    if (pItem)
+    {
+        ItemAddedQuestCheck(item, count);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, count);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_OWN_ITEM, item, 1);
+        UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_OWN_ITEM, item, 1);
+        if (randomPropertyId)
+            pItem->SetItemRandomProperties(randomPropertyId);
+        pItem = StoreItem(dest, pItem, update);
+
+        if (allowedLooters.size() > 1 && pItem->GetTemplate()->GetMaxStackSize() == 1 && pItem->IsSoulBound())
+        {
+            pItem->SetSoulboundTradeable(allowedLooters);
+            pItem->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, GetTotalPlayedTime());
+            AddTradeableItem(pItem);
+
+            // save data
+            std::ostringstream ss;
+            AllowedLooterSet::const_iterator itr = allowedLooters.begin();
+            ss << *itr;
+            for (++itr; itr != allowedLooters.end(); ++itr)
+                ss << ' ' << *itr;
+
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ITEM_BOP_TRADE);
+            stmt->setUInt32(0, pItem->GetGUIDLow());
+            stmt->setString(1, ss.str());
+            CharacterDatabase.Execute(stmt);
+        }
+    }
+    return pItem;
+}
+
+Item* Player::StoreItem(ItemPosCountVec const& dest, Item* pItem, bool update)
+{
+    if (!pItem)
+        return NULL;
+
+    Item* lastItem = pItem;
+    for (ItemPosCountVec::const_iterator itr = dest.begin(); itr != dest.end();)
+    {
+        uint16 pos = itr->pos;
+        uint32 count = itr->count;
+
+        ++itr;
+
+        if (itr == dest.end())
+        {
+            lastItem = _StoreItem(pos, pItem, count, false, update);
+            break;
+        }
+
+        lastItem = _StoreItem(pos, pItem, count, true, update);
+    }
+    return lastItem;
+}
+
+// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
+Item* Player::_StoreItem(uint16 pos, Item* pItem, uint32 count, bool clone, bool update)
+{
+    if (!pItem)
+        return NULL;
+
+    uint8 bag = pos >> 8;
+    uint8 slot = pos & 255;
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: StoreItem bag = %u, slot = %u, item = %u, count = %u, guid = %u", bag, slot, pItem->GetEntry(), count, pItem->GetGUIDLow());
+
+    Item* pItem2 = GetItemByPos(bag, slot);
+
+    if (!pItem2)
+    {
+        if (clone)
+            pItem = pItem->CloneItem(count, this);
+        else
+            pItem->SetCount(count);
+
+        if (!pItem)
+            return NULL;
+
+        if (pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP ||
+            pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM ||
+            (pItem->GetTemplate()->Bonding == BIND_WHEN_EQUIPED && IsBagPos(pos)))
+            pItem->SetBinding(true);
+
+        Bag* pBag = (bag == INVENTORY_SLOT_BAG_0) ? NULL : GetBagByPos(bag);
+        if (!pBag)
+        {
+            m_items[slot] = pItem;
+            SetUInt64Value(PLAYER_FIELD_INV_SLOT_HEAD + (slot * 2), pItem->GetGUID());
+            pItem->SetUInt64Value(ITEM_FIELD_CONTAINED, GetGUID());
+            pItem->SetUInt64Value(ITEM_FIELD_OWNER, GetGUID());
+
+            pItem->SetSlot(slot);
+            pItem->SetContainer(NULL);
+        }
+        else
+            pBag->StoreItem(slot, pItem, update);
+
+        if (IsInWorld() && update)
+        {
+            pItem->AddToWorld();
+            pItem->SendUpdateToPlayer(this);
+        }
+
+        pItem->SetState(ITEM_CHANGED, this);
+        if (pBag)
+            pBag->SetState(ITEM_CHANGED, this);
+
+        AddEnchantmentDurations(pItem);
+        AddItemDurations(pItem);
+
+
+        const ItemTemplate* proto = pItem->GetTemplate();
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+            if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && proto->Spells[i].SpellId > 0) // On obtain trigger
+                if (bag == INVENTORY_SLOT_BAG_0 || (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END))
+                    if (!HasAura(proto->Spells[i].SpellId))
+                        CastSpell(this, proto->Spells[i].SpellId, true, pItem);
+
+        return pItem;
+    }
+    else
+    {
+        if (pItem2->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP ||
+            pItem2->GetTemplate()->Bonding == BIND_QUEST_ITEM ||
+            (pItem2->GetTemplate()->Bonding == BIND_WHEN_EQUIPED && IsBagPos(pos)))
+            pItem2->SetBinding(true);
+
+        pItem2->SetCount(pItem2->GetCount() + count);
+        if (IsInWorld() && update)
+            pItem2->SendUpdateToPlayer(this);
+
+        if (!clone)
+        {
+            // delete item (it not in any slot currently)
+            if (IsInWorld() && update)
+            {
+                pItem->RemoveFromWorld();
+                pItem->DestroyForPlayer(this);
+            }
+
+            RemoveEnchantmentDurations(pItem);
+            RemoveItemDurations(pItem);
+
+            pItem->SetOwnerGUID(GetGUID());                 // prevent error at next SetState in case trade/mail/buy from vendor
+            pItem->SetNotRefundable(this);
+            pItem->ClearSoulboundTradeable(this);
+            RemoveTradeableItem(pItem);
+            pItem->SetState(ITEM_REMOVED, this);
+        }
+
+        AddEnchantmentDurations(pItem2);
+
+        pItem2->SetState(ITEM_CHANGED, this);
+
+        const ItemTemplate* proto = pItem2->GetTemplate();
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+            if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && proto->Spells[i].SpellId > 0) // On obtain trigger
+                if (bag == INVENTORY_SLOT_BAG_0 || (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END))
+                    if (!HasAura(proto->Spells[i].SpellId))
+                        CastSpell(this, proto->Spells[i].SpellId, true, pItem2);
+
+        return pItem2;
+    }
+}
+
+Item* Player::EquipNewItem(uint16 pos, uint32 item, bool update)
+{
+    if (Item* pItem = Item::CreateItem(item, 1, this))
+    {
+        ItemAddedQuestCheck(item, 1);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, 1);
+        return EquipItem(pos, pItem, update);
+    }
+
+    return NULL;
+}
+
+Item* Player::EquipItem(uint16 pos, Item* pItem, bool update)
+{
+    AddEnchantmentDurations(pItem);
+    AddItemDurations(pItem);
+
+    uint8 bag = pos >> 8;
+    uint8 slot = pos & 255;
+
+    Item* pItem2 = GetItemByPos(bag, slot);
+
+    if (!pItem2)
+    {
+        VisualizeItem(slot, pItem);
+
+        if (isAlive())
+        {
+            ItemTemplate const* pProto = pItem->GetTemplate();
+
+            // item set bonuses applied only at equip and removed at unequip, and still active for broken items
+            if (pProto && pProto->ItemSet)
+                AddItemsSetItem(this, pItem);
+
+            _ApplyItemMods(pItem, slot, true);
+
+            if (pProto && isInCombat() && (pProto->Class == ITEM_CLASS_WEAPON || pProto->InventoryType == INVTYPE_RELIC) && m_weaponChangeTimer == 0)
+            {
+                uint32 cooldownSpell = getClass() == CLASS_ROGUE ? 6123 : 6119;
+                SpellInfo const* spellProto = sSpellMgr->GetSpellInfo(cooldownSpell);
+
+                if (!spellProto)
+                    sLog->outError(LOG_FILTER_PLAYER, "Weapon switch cooldown spell %u couldn't be found in Spell.dbc", cooldownSpell);
+                else
+                {
+                    m_weaponChangeTimer = spellProto->StartRecoveryTime;
+
+                    GetGlobalCooldownMgr().AddGlobalCooldown(spellProto, m_weaponChangeTimer);
+
+                    WorldPacket data(SMSG_SPELL_COOLDOWN, 8+1+4);
+                    data << uint64(GetGUID());
+                    data << uint8(1);
+                    data << uint32(cooldownSpell);
+                    data << uint32(0);
+                    GetSession()->SendPacket(&data);
+                }
+            }
+        }
+
+        if (IsInWorld() && update)
+        {
+            pItem->AddToWorld();
+            pItem->SendUpdateToPlayer(this);
+        }
+
+        ApplyEquipCooldown(pItem);
+
+         // update expertise and armor penetration - passive auras may need it
+
+        if (slot == EQUIPMENT_SLOT_MAINHAND)
+            UpdateExpertise(BASE_ATTACK);
+
+        else if (slot == EQUIPMENT_SLOT_OFFHAND)
+            UpdateExpertise(OFF_ATTACK);
+
+        UpdateArmorSpecialization();
+
+        switch (slot)
+        {
+            case EQUIPMENT_SLOT_MAINHAND:
+            case EQUIPMENT_SLOT_OFFHAND:
+            case EQUIPMENT_SLOT_RANGED:
+                RecalculateRating(CR_ARMOR_PENETRATION);
+            default:
+                break;
+        }
+    }
+    else
+    {
+        pItem2->SetCount(pItem2->GetCount() + pItem->GetCount());
+        if (IsInWorld() && update)
+            pItem2->SendUpdateToPlayer(this);
+
+        // delete item (it not in any slot currently)
+        //pItem->DeleteFromDB();
+        if (IsInWorld() && update)
+        {
+            pItem->RemoveFromWorld();
+            pItem->DestroyForPlayer(this);
+        }
+
+        RemoveEnchantmentDurations(pItem);
+        RemoveItemDurations(pItem);
+
+        pItem->SetOwnerGUID(GetGUID());                     // prevent error at next SetState in case trade/mail/buy from vendor
+        pItem->SetNotRefundable(this);
+        pItem->ClearSoulboundTradeable(this);
+        RemoveTradeableItem(pItem);
+        pItem->SetState(ITEM_REMOVED, this);
+        pItem2->SetState(ITEM_CHANGED, this);
+
+        ApplyEquipCooldown(pItem2);
+
+        UpdateArmorSpecialization();
+
+        return pItem2;
+    }
+
+    // only for full equip instead adding to stack
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);
+    if (Guild *guild = GetGuild())
+        guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_OWN_ITEM, pItem->GetEntry(), 1, 0, NULL, this);
+
+    return pItem;
+}
+
+void Player::QuickEquipItem(uint16 pos, Item* pItem)
+{
+    if (pItem)
+    {
+        AddEnchantmentDurations(pItem);
+        AddItemDurations(pItem);
+
+        uint8 slot = pos & 255;
+        VisualizeItem(slot, pItem);
+
+        if (IsInWorld())
+        {
+            pItem->AddToWorld();
+            pItem->SendUpdateToPlayer(this);
+        }
+
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);
+    }
+}
+
+void Player::SetVisibleItemSlot(uint8 slot, Item* pItem)
+{
+    if (pItem)
+    {
+        SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), pItem->GetVisibleEntry());
+        SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 0, pItem->GetEnchantmentId(PERM_ENCHANTMENT_SLOT));
+        SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 1, pItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
+    }
+    else
+    {
+        SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), 0);
+        SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 0);
+    }
+}
+
+void Player::VisualizeItem(uint8 slot, Item* pItem)
+{
+    if (!pItem)
+        return;
+
+    // check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
+    if (pItem->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP || pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM)
+        pItem->SetBinding(true);
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: EquipItem slot = %u, item = %u", slot, pItem->GetEntry());
+
+    m_items[slot] = pItem;
+    SetUInt64Value(PLAYER_FIELD_INV_SLOT_HEAD + (slot * 2), pItem->GetGUID());
+    pItem->SetUInt64Value(ITEM_FIELD_CONTAINED, GetGUID());
+    pItem->SetUInt64Value(ITEM_FIELD_OWNER, GetGUID());
+    pItem->SetSlot(slot);
+    pItem->SetContainer(NULL);
+
+    if (slot < EQUIPMENT_SLOT_END)
+        SetVisibleItemSlot(slot, pItem);
+
+    pItem->SetState(ITEM_CHANGED, this);
+}
+
+void Player::RemoveItem(uint8 bag, uint8 slot, bool update)
+{
+    // note: removeitem does not actually change the item
+    // it only takes the item out of storage temporarily
+    // note2: if removeitem is to be used for delinking
+    // the item must be removed from the player's updatequeue
+
+    Item* pItem = GetItemByPos(bag, slot);
+    if (pItem)
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: RemoveItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());
+
+        RemoveEnchantmentDurations(pItem);
+        RemoveItemDurations(pItem);
+        RemoveTradeableItem(pItem);
+
+        if (bag == INVENTORY_SLOT_BAG_0)
+        {
+            if (slot < INVENTORY_SLOT_BAG_END)
+            {
+                ItemTemplate const* pProto = pItem->GetTemplate();
+                // item set bonuses applied only at equip and removed at unequip, and still active for broken items
+
+                if (pProto && pProto->ItemSet)
+                    RemoveItemsSetItem(this, pProto);
+
+                _ApplyItemMods(pItem, slot, false);
+
+                // remove item dependent auras and casts (only weapon and armor slots)
+                if (slot < EQUIPMENT_SLOT_END)
+                {
+                    RemoveItemDependentAurasAndCasts(pItem);
+
+                    // remove held enchantments, update expertise
+                    if (slot == EQUIPMENT_SLOT_MAINHAND)
+                    {
+                        if (pItem->GetItemSuffixFactor())
+                        {
+                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_3);
+                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_4);
+                        }
+                        else
+                        {
+                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_0);
+                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_1);
+                        }
+
+                        UpdateExpertise(BASE_ATTACK);
+                    }
+                    else if (slot == EQUIPMENT_SLOT_OFFHAND)
+                        UpdateExpertise(OFF_ATTACK);
+                    // update armor penetration - passive auras may need it
+                    switch (slot)
+                    {
+                        case EQUIPMENT_SLOT_MAINHAND:
+                        case EQUIPMENT_SLOT_OFFHAND:
+                        case EQUIPMENT_SLOT_RANGED:
+                            RecalculateRating(CR_ARMOR_PENETRATION);
+                        default:
+                            break;
+                    }
+                }
+            }
+
+            m_items[slot] = NULL;
+            SetUInt64Value(PLAYER_FIELD_INV_SLOT_HEAD + (slot * 2), 0);
+
+            if (slot < EQUIPMENT_SLOT_END)
+                SetVisibleItemSlot(slot, NULL);
+        }
+        else if (Bag* pBag = GetBagByPos(bag))
+            pBag->RemoveItem(slot, update);
+
+        pItem->SetUInt64Value(ITEM_FIELD_CONTAINED, 0);
+        // pItem->SetUInt64Value(ITEM_FIELD_OWNER, 0); not clear owner at remove (it will be set at store). This used in mail and auction code
+        pItem->SetSlot(NULL_SLOT);
+        UpdateArmorSpecialization();
+        if (IsInWorld() && update)
+            pItem->SendUpdateToPlayer(this);
+    }
+}
+
+// Common operation need to remove item from inventory without delete in trade, auction, guild bank, mail....
+void Player::MoveItemFromInventory(uint8 bag, uint8 slot, bool update)
+{
+    if (Item* it = GetItemByPos(bag, slot))
+    {
+        ItemRemovedQuestCheck(it->GetEntry(), it->GetCount());
+        RemoveItem(bag, slot, update);
+        it->SetNotRefundable(this, false);
+        it->RemoveFromUpdateQueueOf(this);
+        if (it->IsInWorld())
+        {
+            it->RemoveFromWorld();
+            it->DestroyForPlayer(this);
+        }
+    }
+}
+
+// Common operation need to add item from inventory without delete in trade, guild bank, mail....
+void Player::MoveItemToInventory(ItemPosCountVec const& dest, Item* pItem, bool update, bool in_characterInventoryDB)
+{
+    // update quest counters
+    ItemAddedQuestCheck(pItem->GetEntry(), pItem->GetCount());
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, pItem->GetEntry(), pItem->GetCount());
+
+    // store item
+    Item* pLastItem = StoreItem(dest, pItem, update);
+
+    // only set if not merged to existed stack (pItem can be deleted already but we can compare pointers any way)
+    if (pLastItem == pItem)
+    {
+        // update owner for last item (this can be original item with wrong owner
+        if (pLastItem->GetOwnerGUID() != GetGUID())
+            pLastItem->SetOwnerGUID(GetGUID());
+
+        // if this original item then it need create record in inventory
+        // in case trade we already have item in other player inventory
+        pLastItem->SetState(in_characterInventoryDB ? ITEM_CHANGED : ITEM_NEW, this);
+
+        if (pLastItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_BOP_TRADEABLE))
+            AddTradeableItem(pLastItem);
+    }
+}
+
+void Player::DestroyItem(uint8 bag, uint8 slot, bool update)
+{
+    Item* pItem = GetItemByPos(bag, slot);
+    if (pItem)
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());
+        // Also remove all contained items if the item is a bag.
+        // This if () prevents item saving crashes if the condition for a bag to be empty before being destroyed was bypassed somehow.
+        if (pItem->IsNotEmptyBag())
+            for (uint8 i = 0; i < MAX_BAG_SIZE; ++i)
+                DestroyItem(slot, i, update);
+
+        if (pItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_WRAPPED))
+        {
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GIFT);
+
+            stmt->setUInt32(0, pItem->GetGUIDLow());
+
+            CharacterDatabase.Execute(stmt);
+        }
+
+        RemoveEnchantmentDurations(pItem);
+        RemoveItemDurations(pItem);
+
+        pItem->SetNotRefundable(this);
+        pItem->ClearSoulboundTradeable(this);
+        RemoveTradeableItem(pItem);
+
+        const ItemTemplate* proto = pItem->GetTemplate();
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+            if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && proto->Spells[i].SpellId > 0) // On obtain trigger
+                RemoveAurasDueToSpell(proto->Spells[i].SpellId);
+
+        ItemRemovedQuestCheck(pItem->GetEntry(), pItem->GetCount());
+
+        if (bag == INVENTORY_SLOT_BAG_0)
+        {
+            SetUInt64Value(PLAYER_FIELD_INV_SLOT_HEAD + (slot * 2), 0);
+
+            // equipment and equipped bags can have applied bonuses
+            if (slot < INVENTORY_SLOT_BAG_END)
+            {
+                ItemTemplate const* pProto = pItem->GetTemplate();
+
+                // item set bonuses applied only at equip and removed at unequip, and still active for broken items
+                if (pProto && pProto->ItemSet)
+                    RemoveItemsSetItem(this, pProto);
+
+                _ApplyItemMods(pItem, slot, false);
+            }
+
+            if (slot < EQUIPMENT_SLOT_END)
+            {
+                // remove item dependent auras and casts (only weapon and armor slots)
+                RemoveItemDependentAurasAndCasts(pItem);
+
+                // update expertise and armor penetration - passive auras may need it
+                switch (slot)
+                {
+                    case EQUIPMENT_SLOT_MAINHAND:
+                    case EQUIPMENT_SLOT_OFFHAND:
+                    case EQUIPMENT_SLOT_RANGED:
+                        RecalculateRating(CR_ARMOR_PENETRATION);
+                    default:
+                        break;
+                }
+
+                if (slot == EQUIPMENT_SLOT_MAINHAND)
+                    UpdateExpertise(BASE_ATTACK);
+                else if (slot == EQUIPMENT_SLOT_OFFHAND)
+                    UpdateExpertise(OFF_ATTACK);
+
+                // equipment visual show
+                SetVisibleItemSlot(slot, NULL);
+            }
+
+            m_items[slot] = NULL;
+        }
+        else if (Bag* pBag = GetBagByPos(bag))
+            pBag->RemoveItem(slot, update);
+
+        // Delete rolled money / loot from db.
+        // MUST be done before RemoveFromWorld() or GetTemplate() fails
+        if (ItemTemplate const* pTmp = pItem->GetTemplate())
+            if (pTmp->Flags & ITEM_PROTO_FLAG_OPENABLE)
+                pItem->ItemContainerDeleteLootMoneyAndLootItemsFromDB();
+
+        if (IsInWorld() && update)
+        {
+            pItem->RemoveFromWorld();
+            pItem->DestroyForPlayer(this);
+        }
+
+        //pItem->SetOwnerGUID(0);
+        pItem->SetUInt64Value(ITEM_FIELD_CONTAINED, 0);
+        pItem->SetSlot(NULL_SLOT);
+        pItem->SetState(ITEM_REMOVED, this);
+    }
+}
+
+void Player::DestroyItemCount(uint32 itemEntry, uint32 count, bool update, bool unequip_check)
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItemCount item = %u, count = %u", itemEntry, count);
+    uint32 remcount = 0;
+
+    // in inventory
+    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+    {
+        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+        {
+            if (item->GetEntry() == itemEntry && !item->IsInTrade())
+            {
+                if (item->GetCount() + remcount <= count)
+                {
+                    // all items in inventory can unequipped
+                    remcount += item->GetCount();
+                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
+
+                    if (remcount >= count)
+                        return;
+                }
+                else
+                {
+                    ItemRemovedQuestCheck(item->GetEntry(), count - remcount);
+                    item->SetCount(item->GetCount() - count + remcount);
+                    if (IsInWorld() && update)
+                        item->SendUpdateToPlayer(this);
+                    item->SetState(ITEM_CHANGED, this);
+                    return;
+                }
+            }
+        }
+    }
+
+    // in inventory bags
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+    {
+        if (Bag* bag = GetBagByPos(i))
+        {
+            for (uint32 j = 0; j < bag->GetBagSize(); j++)
+            {
+                if (Item* item = bag->GetItemByPos(j))
+                {
+                    if (item->GetEntry() == itemEntry && !item->IsInTrade())
+                    {
+                        // all items in bags can be unequipped
+                        if (item->GetCount() + remcount <= count)
+                        {
+                            remcount += item->GetCount();
+                            DestroyItem(i, j, update);
+
+                            if (remcount >= count)
+                                return;
+                        }
+                        else
+                        {
+                            ItemRemovedQuestCheck(item->GetEntry(), count - remcount);
+                            item->SetCount(item->GetCount() - count + remcount);
+                            if (IsInWorld() && update)
+                                item->SendUpdateToPlayer(this);
+                            item->SetState(ITEM_CHANGED, this);
+                            return;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // in equipment and bag list
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
+    {
+        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+        {
+            if (item && item->GetEntry() == itemEntry && !item->IsInTrade())
+            {
+                if (item->GetCount() + remcount <= count)
+                {
+                    if (!unequip_check || CanUnequipItem(INVENTORY_SLOT_BAG_0 << 8 | i, false) == EQUIP_ERR_OK)
+                    {
+                        remcount += item->GetCount();
+                        DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
+
+                        if (remcount >= count)
+                            return;
+                    }
+                }
+                else
+                {
+                    ItemRemovedQuestCheck(item->GetEntry(), count - remcount);
+                    item->SetCount(item->GetCount() - count + remcount);
+                    if (IsInWorld() && update)
+                        item->SendUpdateToPlayer(this);
+                    item->SetState(ITEM_CHANGED, this);
+                    return;
+                }
+            }
+        }
+    }
+
+    // in bank
+    for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
+    {
+        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+        {
+            if (item->GetEntry() == itemEntry && !item->IsInTrade())
+            {
+                if (item->GetCount() + remcount <= count)
+                {
+                    remcount += item->GetCount();
+                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
+                    if (remcount >= count)
+                        return;
+                }
+                else
+                {
+                    ItemRemovedQuestCheck(item->GetEntry(), count - remcount);
+                    item->SetCount(item->GetCount() - count + remcount);
+                    if (IsInWorld() && update)
+                        item->SendUpdateToPlayer(this);
+                    item->SetState(ITEM_CHANGED, this);
+                    return;
+                }
+            }
+        }
+    }
+
+    // in bank bags
+    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
+    {
+        if (Bag* bag = GetBagByPos(i))
+        {
+            for (uint32 j = 0; j < bag->GetBagSize(); j++)
+            {
+                if (Item* item = bag->GetItemByPos(j))
+                {
+                    if (item->GetEntry() == itemEntry && !item->IsInTrade())
+                    {
+                        // all items in bags can be unequipped
+                        if (item->GetCount() + remcount <= count)
+                        {
+                            remcount += item->GetCount();
+                            DestroyItem(i, j, update);
+
+                            if (remcount >= count)
+                                return;
+                        }
+                        else
+                        {
+                            ItemRemovedQuestCheck(item->GetEntry(), count - remcount);
+                            item->SetCount(item->GetCount() - count + remcount);
+                            if (IsInWorld() && update)
+                                item->SendUpdateToPlayer(this);
+                            item->SetState(ITEM_CHANGED, this);
+                            return;
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+void Player::DestroyZoneLimitedItem(bool update, uint32 new_zone)
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyZoneLimitedItem in map %u and area %u", GetMapId(), new_zone);
+
+    // in inventory
+    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
+                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
+
+    // in inventory bags
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+        if (Bag* pBag = GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
+                        DestroyItem(i, j, update);
+
+    // in equipment and bag list
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
+                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
+}
+
+void Player::DestroyConjuredItems(bool update)
+{
+    // used when entering arena
+    // destroys all conjured items
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyConjuredItems");
+
+    // in inventory
+    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->IsConjuredConsumable())
+                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
+
+    // in inventory bags
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+        if (Bag* pBag = GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    if (pItem->IsConjuredConsumable())
+                        DestroyItem(i, j, update);
+
+    // in equipment and bag list
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->IsConjuredConsumable())
+                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
+}
+
+Item* Player::GetItemByEntry(uint32 entry) const
+{
+    // in inventory
+    for (int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->GetEntry() == entry)
+                return pItem;
+
+    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    if (pItem->GetEntry() == entry)
+                        return pItem;
+
+    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->GetEntry() == entry)
+                return pItem;
+
+    return NULL;
+}
+
+void Player::DestroyItemCount(Item* pItem, uint32 &count, bool update)
+{
+    if (!pItem)
+        return;
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItemCount item (GUID: %u, Entry: %u) count = %u", pItem->GetGUIDLow(), pItem->GetEntry(), count);
+
+    if (pItem->GetCount() <= count)
+    {
+        count -= pItem->GetCount();
+
+        DestroyItem(pItem->GetBagSlot(), pItem->GetSlot(), update);
+    }
+    else
+    {
+        ItemRemovedQuestCheck(pItem->GetEntry(), count);
+        pItem->SetCount(pItem->GetCount() - count);
+        count = 0;
+        if (IsInWorld() && update)
+            pItem->SendUpdateToPlayer(this);
+        pItem->SetState(ITEM_CHANGED, this);
+    }
+}
+
+void Player::SplitItem(uint16 src, uint16 dst, uint32 count)
+{
+    uint8 srcbag = src >> 8;
+    uint8 srcslot = src & 255;
+
+    uint8 dstbag = dst >> 8;
+    uint8 dstslot = dst & 255;
+
+    Item* pSrcItem = GetItemByPos(srcbag, srcslot);
+    if (!pSrcItem)
+    {
+        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, pSrcItem, NULL);
+        return;
+    }
+
+    if (pSrcItem->m_lootGenerated)                           // prevent split looting item (item
+    {
+        //best error message found for attempting to split while looting
+        SendEquipError(EQUIP_ERR_SPLIT_FAILED, pSrcItem, NULL);
+        return;
+    }
+
+    // not let split all items (can be only at cheating)
+    if (pSrcItem->GetCount() == count)
+    {
+        SendEquipError(EQUIP_ERR_SPLIT_FAILED, pSrcItem, NULL);
+        return;
+    }
+
+    // not let split more existed items (can be only at cheating)
+    if (pSrcItem->GetCount() < count)
+    {
+        SendEquipError(EQUIP_ERR_TOO_FEW_TO_SPLIT, pSrcItem, NULL);
+        return;
+    }
+
+    //! If trading
+    if (TradeData* tradeData = GetTradeData())
+    {
+        //! If current item is in trade window (only possible with packet spoofing - silent return)
+        if (tradeData->GetTradeSlotForItem(pSrcItem->GetGUID()) != TRADE_SLOT_INVALID)
+            return;
+    }
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: SplitItem bag = %u, slot = %u, item = %u, count = %u", dstbag, dstslot, pSrcItem->GetEntry(), count);
+    Item* pNewItem = pSrcItem->CloneItem(count, this);
+    if (!pNewItem)
+    {
+        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, pSrcItem, NULL);
+        return;
+    }
+
+    if (IsInventoryPos(dst))
+    {
+        // change item amount before check (for unique max count check)
+        pSrcItem->SetCount(pSrcItem->GetCount() - count);
+
+        ItemPosCountVec dest;
+        InventoryResult msg = CanStoreItem(dstbag, dstslot, dest, pNewItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            delete pNewItem;
+            pSrcItem->SetCount(pSrcItem->GetCount() + count);
+            SendEquipError(msg, pSrcItem, NULL);
+            return;
+        }
+
+        if (IsInWorld())
+            pSrcItem->SendUpdateToPlayer(this);
+        pSrcItem->SetState(ITEM_CHANGED, this);
+        StoreItem(dest, pNewItem, true);
+    }
+    else if (IsBankPos(dst))
+    {
+        // change item amount before check (for unique max count check)
+        pSrcItem->SetCount(pSrcItem->GetCount() - count);
+
+        ItemPosCountVec dest;
+        InventoryResult msg = CanBankItem(dstbag, dstslot, dest, pNewItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            delete pNewItem;
+            pSrcItem->SetCount(pSrcItem->GetCount() + count);
+            SendEquipError(msg, pSrcItem, NULL);
+            return;
+        }
+
+        if (IsInWorld())
+            pSrcItem->SendUpdateToPlayer(this);
+        pSrcItem->SetState(ITEM_CHANGED, this);
+        BankItem(dest, pNewItem, true);
+    }
+    else if (IsEquipmentPos(dst))
+    {
+        // change item amount before check (for unique max count check), provide space for splitted items
+        pSrcItem->SetCount(pSrcItem->GetCount() - count);
+
+        uint16 dest;
+        InventoryResult msg = CanEquipItem(dstslot, dest, pNewItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            delete pNewItem;
+            pSrcItem->SetCount(pSrcItem->GetCount() + count);
+            SendEquipError(msg, pSrcItem, NULL);
+            return;
+        }
+
+        if (IsInWorld())
+            pSrcItem->SendUpdateToPlayer(this);
+        pSrcItem->SetState(ITEM_CHANGED, this);
+        EquipItem(dest, pNewItem, true);
+        AutoUnequipOffhandIfNeed();
+    }
+}
+
+void Player::SwapItem(uint16 src, uint16 dst)
+{
+    uint8 srcbag = src >> 8;
+    uint8 srcslot = src & 255;
+
+    uint8 dstbag = dst >> 8;
+    uint8 dstslot = dst & 255;
+
+    Item* pSrcItem = GetItemByPos(srcbag, srcslot);
+    Item* pDstItem = GetItemByPos(dstbag, dstslot);
+
+    if (!pSrcItem)
+        return;
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: SwapItem bag = %u, slot = %u, item = %u", dstbag, dstslot, pSrcItem->GetEntry());
+
+    if (!isAlive())
+    {
+        SendEquipError(EQUIP_ERR_PLAYER_DEAD, pSrcItem, pDstItem);
+        return;
+    }
+
+    // SRC checks
+
+    if (pSrcItem->m_lootGenerated)                           // prevent swap looting item
+    {
+        //best error message found for attempting to swap while looting
+        SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, pSrcItem, NULL);
+        return;
+    }
+
+    // check unequip potability for equipped items and bank bags
+    if (IsEquipmentPos(src) || IsBagPos(src))
+    {
+        // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
+        InventoryResult msg = CanUnequipItem(src, !IsBagPos(src) || IsBagPos(dst) || (pDstItem && pDstItem->ToBag() && pDstItem->ToBag()->IsEmpty()));
+        if (msg != EQUIP_ERR_OK)
+        {
+            SendEquipError(msg, pSrcItem, pDstItem);
+            return;
+        }
+    }
+
+    // prevent put equipped/bank bag in self
+    if (IsBagPos(src) && srcslot == dstbag)
+    {
+        SendEquipError(EQUIP_ERR_BAG_IN_BAG, pSrcItem, pDstItem);
+        return;
+    }
+
+    // prevent equipping bag in the same slot from its inside
+    if (IsBagPos(dst) && srcbag == dstslot)
+    {
+        SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
+        return;
+    }
+
+    // DST checks
+
+    if (pDstItem)
+    {
+        if (pDstItem->m_lootGenerated)                       // prevent swap looting item
+        {
+            //best error message found for attempting to swap while looting
+            SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, pDstItem, NULL);
+            return;
+        }
+
+        // check unequip potability for equipped items and bank bags
+        if (IsEquipmentPos(dst) || IsBagPos(dst))
+        {
+            // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
+            InventoryResult msg = CanUnequipItem(dst, !IsBagPos(dst) || IsBagPos(src) || (pSrcItem->ToBag() && pSrcItem->ToBag()->IsEmpty()));
+            if (msg != EQUIP_ERR_OK)
+            {
+                SendEquipError(msg, pSrcItem, pDstItem);
+                return;
+            }
+        }
+    }
+
+    // NOW this is or item move (swap with empty), or swap with another item (including bags in bag possitions)
+    // or swap empty bag with another empty or not empty bag (with items exchange)
+
+    // Move case
+    if (!pDstItem)
+    {
+        if (IsInventoryPos(dst))
+        {
+            ItemPosCountVec dest;
+            InventoryResult msg = CanStoreItem(dstbag, dstslot, dest, pSrcItem, false);
+            if (msg != EQUIP_ERR_OK)
+            {
+                SendEquipError(msg, pSrcItem, NULL);
+                return;
+            }
+
+            RemoveItem(srcbag, srcslot, true);
+            StoreItem(dest, pSrcItem, true);
+            if (IsBankPos(src))
+                ItemAddedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
+        }
+        else if (IsBankPos(dst))
+        {
+            ItemPosCountVec dest;
+            InventoryResult msg = CanBankItem(dstbag, dstslot, dest, pSrcItem, false);
+            if (msg != EQUIP_ERR_OK)
+            {
+                SendEquipError(msg, pSrcItem, NULL);
+                return;
+            }
+
+            RemoveItem(srcbag, srcslot, true);
+            BankItem(dest, pSrcItem, true);
+            ItemRemovedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
+        }
+        else if (IsEquipmentPos(dst))
+        {
+            uint16 dest;
+            InventoryResult msg = CanEquipItem(dstslot, dest, pSrcItem, false);
+            if (msg != EQUIP_ERR_OK)
+            {
+                SendEquipError(msg, pSrcItem, NULL);
+                return;
+            }
+
+            RemoveItem(srcbag, srcslot, true);
+            EquipItem(dest, pSrcItem, true);
+            AutoUnequipOffhandIfNeed();
+        }
+
+        return;
+    }
+
+    // attempt merge to / fill target item
+    if (!pSrcItem->IsBag() && !pDstItem->IsBag())
+    {
+        InventoryResult msg;
+        ItemPosCountVec sDest;
+        uint16 eDest = 0;
+        if (IsInventoryPos(dst))
+            msg = CanStoreItem(dstbag, dstslot, sDest, pSrcItem, false);
+        else if (IsBankPos(dst))
+            msg = CanBankItem(dstbag, dstslot, sDest, pSrcItem, false);
+        else if (IsEquipmentPos(dst))
+            msg = CanEquipItem(dstslot, eDest, pSrcItem, false);
+        else
+            return;
+
+        // can be merge/fill
+        if (msg == EQUIP_ERR_OK)
+        {
+            if (pSrcItem->GetCount() + pDstItem->GetCount() <= pSrcItem->GetTemplate()->GetMaxStackSize())
+            {
+                RemoveItem(srcbag, srcslot, true);
+
+                if (IsInventoryPos(dst))
+                    StoreItem(sDest, pSrcItem, true);
+                else if (IsBankPos(dst))
+                    BankItem(sDest, pSrcItem, true);
+                else if (IsEquipmentPos(dst))
+                {
+                    EquipItem(eDest, pSrcItem, true);
+                    AutoUnequipOffhandIfNeed();
+                }
+            }
+            else
+            {
+                pSrcItem->SetCount(pSrcItem->GetCount() + pDstItem->GetCount() - pSrcItem->GetTemplate()->GetMaxStackSize());
+                pDstItem->SetCount(pSrcItem->GetTemplate()->GetMaxStackSize());
+                pSrcItem->SetState(ITEM_CHANGED, this);
+                pDstItem->SetState(ITEM_CHANGED, this);
+                if (IsInWorld())
+                {
+                    pSrcItem->SendUpdateToPlayer(this);
+                    pDstItem->SendUpdateToPlayer(this);
+                }
+            }
+            SendRefundInfo(pDstItem);
+            return;
+        }
+    }
+
+    // impossible merge/fill, do real swap
+    InventoryResult msg = EQUIP_ERR_OK;
+
+    // check src->dest move possibility
+    ItemPosCountVec sDest;
+    uint16 eDest = 0;
+    if (IsInventoryPos(dst))
+        msg = CanStoreItem(dstbag, dstslot, sDest, pSrcItem, true);
+    else if (IsBankPos(dst))
+        msg = CanBankItem(dstbag, dstslot, sDest, pSrcItem, true);
+    else if (IsEquipmentPos(dst))
+    {
+        msg = CanEquipItem(dstslot, eDest, pSrcItem, true);
+        if (msg == EQUIP_ERR_OK)
+            msg = CanUnequipItem(eDest, true);
+    }
+
+    if (msg != EQUIP_ERR_OK)
+    {
+        SendEquipError(msg, pSrcItem, pDstItem);
+        return;
+    }
+
+    // check dest->src move possibility
+    ItemPosCountVec sDest2;
+    uint16 eDest2 = 0;
+    if (IsInventoryPos(src))
+        msg = CanStoreItem(srcbag, srcslot, sDest2, pDstItem, true);
+    else if (IsBankPos(src))
+        msg = CanBankItem(srcbag, srcslot, sDest2, pDstItem, true);
+    else if (IsEquipmentPos(src))
+    {
+        msg = CanEquipItem(srcslot, eDest2, pDstItem, true);
+        if (msg == EQUIP_ERR_OK)
+            msg = CanUnequipItem(eDest2, true);
+    }
+
+    if (msg != EQUIP_ERR_OK)
+    {
+        SendEquipError(msg, pDstItem, pSrcItem);
+        return;
+    }
+
+    // Check bag swap with item exchange (one from empty in not bag possition (equipped (not possible in fact) or store)
+    if (Bag* srcBag = pSrcItem->ToBag())
+    {
+        if (Bag* dstBag = pDstItem->ToBag())
+        {
+            Bag* emptyBag = NULL;
+            Bag* fullBag = NULL;
+            if (srcBag->IsEmpty() && !IsBagPos(src))
+            {
+                emptyBag = srcBag;
+                fullBag  = dstBag;
+            }
+            else if (dstBag->IsEmpty() && !IsBagPos(dst))
+            {
+                emptyBag = dstBag;
+                fullBag  = srcBag;
+            }
+
+            // bag swap (with items exchange) case
+            if (emptyBag && fullBag)
+            {
+                ItemTemplate const* emptyProto = emptyBag->GetTemplate();
+
+                uint32 count = 0;
+
+                for (uint32 i=0; i < fullBag->GetBagSize(); ++i)
+                {
+                    Item* bagItem = fullBag->GetItemByPos(i);
+                    if (!bagItem)
+                        continue;
+
+                    ItemTemplate const* bagItemProto = bagItem->GetTemplate();
+                    if (!bagItemProto || !ItemCanGoIntoBag(bagItemProto, emptyProto))
+                    {
+                        // one from items not go to empty target bag
+                        SendEquipError(EQUIP_ERR_BAG_IN_BAG, pSrcItem, pDstItem);
+                        return;
+                    }
+
+                    ++count;
+                }
+
+                if (count > emptyBag->GetBagSize())
+                {
+                    // too small targeted bag
+                    SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
+                    return;
+                }
+
+                // Items swap
+                count = 0;                                      // will pos in new bag
+                for (uint32 i = 0; i< fullBag->GetBagSize(); ++i)
+                {
+                    Item* bagItem = fullBag->GetItemByPos(i);
+                    if (!bagItem)
+                        continue;
+
+                    fullBag->RemoveItem(i, true);
+                    emptyBag->StoreItem(count, bagItem, true);
+                    bagItem->SetState(ITEM_CHANGED, this);
+
+                    ++count;
+                }
+            }
+        }
+    }
+
+    // now do moves, remove...
+    RemoveItem(dstbag, dstslot, false);
+    RemoveItem(srcbag, srcslot, false);
+
+    // add to dest
+    if (IsInventoryPos(dst))
+        StoreItem(sDest, pSrcItem, true);
+    else if (IsBankPos(dst))
+        BankItem(sDest, pSrcItem, true);
+    else if (IsEquipmentPos(dst))
+        EquipItem(eDest, pSrcItem, true);
+
+    // add to src
+    if (IsInventoryPos(src))
+        StoreItem(sDest2, pDstItem, true);
+    else if (IsBankPos(src))
+        BankItem(sDest2, pDstItem, true);
+    else if (IsEquipmentPos(src))
+        EquipItem(eDest2, pDstItem, true);
+
+    // if player is moving bags and is looting an item inside this bag
+    // release the loot
+    if (GetLootGUID())
+    {
+        bool released = false;
+        if (IsBagPos(src))
+        {
+            Bag* bag = pSrcItem->ToBag();
+            for (uint32 i = 0; i < bag->GetBagSize(); ++i)
+            {
+                if (Item* bagItem = bag->GetItemByPos(i))
+                {
+                    if (bagItem->m_lootGenerated)
+                    {
+                        m_session->DoLootRelease(GetLootGUID());
+                        released = true;                    // so we don't need to look at dstBag
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (!released && IsBagPos(dst) && pDstItem)
+        {
+            Bag* bag = pDstItem->ToBag();
+            for (uint32 i = 0; i < bag->GetBagSize(); ++i)
+            {
+                if (Item* bagItem = bag->GetItemByPos(i))
+                {
+                    if (bagItem->m_lootGenerated)
+                    {
+                        m_session->DoLootRelease(GetLootGUID());
+                        released = true;                    // not realy needed here
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    AutoUnequipOffhandIfNeed();
+}
+
+void Player::AddItemToBuyBackSlot(Item* pItem)
+{
+    if (pItem)
+    {
+        uint32 slot = m_currentBuybackSlot;
+        // if current back slot non-empty search oldest or free
+        if (m_items[slot])
+        {
+            uint32 oldest_time = GetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP_1);
+            uint32 oldest_slot = BUYBACK_SLOT_START;
+
+            for (uint32 i = BUYBACK_SLOT_START+1; i < BUYBACK_SLOT_END; ++i)
+            {
+                // found empty
+                if (!m_items[i])
+                {
+                    slot = i;
+                    break;
+                }
+
+                uint32 i_time = GetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP_1 + i - BUYBACK_SLOT_START);
+
+                if (oldest_time > i_time)
+                {
+                    oldest_time = i_time;
+                    oldest_slot = i;
+                }
+            }
+
+            // find oldest
+            slot = oldest_slot;
+        }
+
+        RemoveItemFromBuyBackSlot(slot, true);
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: AddItemToBuyBackSlot item = %u, slot = %u", pItem->GetEntry(), slot);
+
+        m_items[slot] = pItem;
+        time_t base = time(NULL);
+        uint32 etime = uint32(base - m_logintime + (30 * 3600));
+        uint32 eslot = slot - BUYBACK_SLOT_START;
+
+        SetUInt64Value(PLAYER_FIELD_VENDORBUYBACK_SLOT_1 + (eslot * 2), pItem->GetGUID());
+        if (ItemTemplate const* proto = pItem->GetTemplate())
+            SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE_1 + eslot, proto->SellPrice * pItem->GetCount());
+        else
+            SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE_1 + eslot, 0);
+        SetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP_1 + eslot, (uint32)etime);
+
+        // move to next (for non filled list is move most optimized choice)
+        if (m_currentBuybackSlot < BUYBACK_SLOT_END - 1)
+            ++m_currentBuybackSlot;
+    }
+}
+
+Item* Player::GetItemFromBuyBackSlot(uint32 slot)
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: GetItemFromBuyBackSlot slot = %u", slot);
+    if (slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END)
+        return m_items[slot];
+    return NULL;
+}
+
+void Player::RemoveItemFromBuyBackSlot(uint32 slot, bool del)
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: RemoveItemFromBuyBackSlot slot = %u", slot);
+    if (slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END)
+    {
+        Item* pItem = m_items[slot];
+        if (pItem)
+        {
+            pItem->RemoveFromWorld();
+            if (del)
+                pItem->SetState(ITEM_REMOVED, this);
+        }
+
+        m_items[slot] = NULL;
+
+        uint32 eslot = slot - BUYBACK_SLOT_START;
+        SetUInt64Value(PLAYER_FIELD_VENDORBUYBACK_SLOT_1 + (eslot * 2), 0);
+        SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE_1 + eslot, 0);
+        SetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP_1 + eslot, 0);
+
+        // if current backslot is filled set to now free slot
+        if (m_items[m_currentBuybackSlot])
+            m_currentBuybackSlot = slot;
+    }
+}
+
+void Player::SendEquipError(InventoryResult msg, Item* pItem, Item* pItem2, uint32 itemid)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_INVENTORY_CHANGE_FAILURE (%u)", msg);
+    WorldPacket data(SMSG_INVENTORY_CHANGE_FAILURE, (msg == EQUIP_ERR_CANT_EQUIP_LEVEL_I ? 22 : 18));
+    data << uint8(msg);
+
+    if (msg != EQUIP_ERR_OK)
+    {
+        data << uint64(pItem ? pItem->GetGUID() : 0);
+        data << uint64(pItem2 ? pItem2->GetGUID() : 0);
+        data << uint8(0);                                   // bag type subclass, used with EQUIP_ERR_EVENT_AUTOEQUIP_BIND_CONFIRM and EQUIP_ERR_ITEM_DOESNT_GO_INTO_BAG2
+
+        switch (msg)
+        {
+            case EQUIP_ERR_CANT_EQUIP_LEVEL_I:
+            case EQUIP_ERR_PURCHASE_LEVEL_TOO_LOW:
+            {
+                ItemTemplate const* proto = pItem ? pItem->GetTemplate() : sObjectMgr->GetItemTemplate(itemid);
+                data << uint32(proto ? proto->RequiredLevel : 0);
+                break;
+            }
+            case EQUIP_ERR_NO_OUTPUT:    // no idea about this one...
+            {
+                data << uint64(0); // item guid
+                data << uint32(0); // slot
+                data << uint64(0); // container
+                break;
+            }
+            case EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED_IS:
+            case EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_SOCKETED_EXCEEDED_IS:
+            case EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS:
+            {
+                ItemTemplate const* proto = pItem ? pItem->GetTemplate() : sObjectMgr->GetItemTemplate(itemid);
+                data << uint32(proto ? proto->ItemLimitCategory : 0);
+                break;
+            }
+            default:
+                break;
+        }
+    }
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendBuyError(BuyResult msg, Creature* creature, uint32 item, uint32 /*param*/)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_BUY_FAILED");
+    WorldPacket data(SMSG_BUY_FAILED, (8+4+4+1));
+    data << uint64(creature ? creature->GetGUID() : 0);
+    data << uint32(item);
+    data << uint8(msg);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendSellError(SellResult msg, Creature* creature, uint64 guid)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_SELL_ITEM");
+    WorldPacket data(SMSG_SELL_ITEM, (8+8+1));  // last check 4.3.4
+    data << uint64(creature ? creature->GetGUID() : 0);
+    data << uint64(guid);
+    data << uint8(msg);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::TradeCancel(bool sendback)
+{
+    if (m_trade)
+    {
+        Player* trader = m_trade->GetTrader();
+
+        // send yellow "Trade canceled" message to both traders
+        if (sendback)
+            GetSession()->SendCancelTrade();
+
+        trader->GetSession()->SendCancelTrade();
+
+        // cleanup
+        delete m_trade;
+        m_trade = NULL;
+        delete trader->m_trade;
+        trader->m_trade = NULL;
+    }
+}
+
+void Player::UpdateSoulboundTradeItems()
+{
+    if (m_itemSoulboundTradeable.empty())
+        return;
+
+    // also checks for garbage data
+    for (ItemDurationList::iterator itr = m_itemSoulboundTradeable.begin(); itr != m_itemSoulboundTradeable.end();)
+    {
+        ASSERT(*itr);
+        if ((*itr)->GetOwnerGUID() != GetGUID())
+        {
+            m_itemSoulboundTradeable.erase(itr++);
+            continue;
+        }
+        if ((*itr)->CheckSoulboundTradeExpire())
+        {
+            m_itemSoulboundTradeable.erase(itr++);
+            continue;
+        }
+        ++itr;
+    }
+}
+
+void Player::AddTradeableItem(Item* item)
+{
+    m_itemSoulboundTradeable.push_back(item);
+}
+
+//TODO: should never allow an item to be added to m_itemSoulboundTradeable twice
+void Player::RemoveTradeableItem(Item* item)
+{
+    m_itemSoulboundTradeable.remove(item);
+}
+
+void Player::UpdateItemDuration(uint32 time, bool realtimeonly)
+{
+    if (m_itemDuration.empty())
+        return;
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Player::UpdateItemDuration(%u, %u)", time, realtimeonly);
+
+    for (ItemDurationList::const_iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end();)
+    {
+        Item* item = *itr;
+        ++itr;                                              // current element can be erased in UpdateDuration
+
+        if (!realtimeonly || item->GetTemplate()->FlagsCu & ITEM_FLAGS_CU_DURATION_REAL_TIME)
+            item->UpdateDuration(this, time);
+    }
+}
+
+void Player::UpdateEnchantTime(uint32 time)
+{
+    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(), next; itr != m_enchantDuration.end(); itr=next)
+    {
+        ASSERT(itr->item);
+        next = itr;
+        if (!itr->item->GetEnchantmentId(itr->slot))
+        {
+            next = m_enchantDuration.erase(itr);
+        }
+        else if (itr->leftduration <= time)
+        {
+            ApplyEnchantment(itr->item, itr->slot, false, false);
+            itr->item->ClearEnchantment(itr->slot);
+            next = m_enchantDuration.erase(itr);
+        }
+        else if (itr->leftduration > time)
+        {
+            itr->leftduration -= time;
+            ++next;
+        }
+    }
+}
+
+void Player::AddEnchantmentDurations(Item* item)
+{
+    for (int x = 0; x < MAX_ENCHANTMENT_SLOT; ++x)
+    {
+        if (x > PRISMATIC_ENCHANTMENT_SLOT || x < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
+            continue;
+
+        if (!item->GetEnchantmentId(EnchantmentSlot(x)))
+            continue;
+
+        uint32 duration = item->GetEnchantmentDuration(EnchantmentSlot(x));
+        if (duration > 0)
+            AddEnchantmentDuration(item, EnchantmentSlot(x), duration);
+    }
+}
+
+void Player::RemoveEnchantmentDurations(Item* item)
+{
+    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end();)
+    {
+        if (itr->item == item)
+        {
+            // save duration in item
+            item->SetEnchantmentDuration(EnchantmentSlot(itr->slot), itr->leftduration, this);
+            itr = m_enchantDuration.erase(itr);
+        }
+        else
+            ++itr;
+    }
+}
+
+void Player::RemoveArenaEnchantments(EnchantmentSlot slot)
+{
+    // remove enchantments from equipped items first to clean up the m_enchantDuration list
+    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(), next; itr != m_enchantDuration.end(); itr = next)
+    {
+        next = itr;
+        if (itr->slot == slot)
+        {
+            if (itr->item && itr->item->GetEnchantmentId(slot))
+            {
+                // Poisons and DK runes are enchants which are allowed on arenas
+                if (sSpellMgr->IsArenaAllowedEnchancment(itr->item->GetEnchantmentId(slot)))
+                {
+                    ++next;
+                    continue;
+                }
+                // remove from stats
+                ApplyEnchantment(itr->item, slot, false, false);
+                // remove visual
+                itr->item->ClearEnchantment(slot);
+            }
+            // remove from update list
+            next = m_enchantDuration.erase(itr);
+        }
+        else
+            ++next;
+    }
+
+    // remove enchants from inventory items
+    // NOTE: no need to remove these from stats, since these aren't equipped
+    // in inventory
+    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->GetEnchantmentId(slot) && !sSpellMgr->IsArenaAllowedEnchancment(pItem->GetEnchantmentId(slot)))
+                pItem->ClearEnchantment(slot);
+
+    // in inventory bags
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    if (pItem->GetEnchantmentId(slot) && !sSpellMgr->IsArenaAllowedEnchancment(pItem->GetEnchantmentId(slot)))
+                        pItem->ClearEnchantment(slot);
+}
+
+// duration == 0 will remove item enchant
+void Player::AddEnchantmentDuration(Item* item, EnchantmentSlot slot, uint32 duration)
+{
+    if (!item)
+        return;
+
+    if (slot >= MAX_ENCHANTMENT_SLOT)
+        return;
+
+    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
+    {
+        if (itr->item == item && itr->slot == slot)
+        {
+            itr->item->SetEnchantmentDuration(itr->slot, itr->leftduration, this);
+            m_enchantDuration.erase(itr);
+            break;
+        }
+    }
+    if (item && duration > 0)
+    {
+        GetSession()->SendItemEnchantTimeUpdate(GetGUID(), item->GetGUID(), slot, uint32(duration/1000));
+        m_enchantDuration.push_back(EnchantDuration(item, slot, duration));
+    }
+}
+
+void Player::ApplyReforgeEnchantment(Item* item, bool apply)
+{
+    if (!item)
+        return;
+
+    ItemReforgeEntry const* reforge = sItemReforgeStore.LookupEntry(item->GetEnchantmentId(REFORGE_ENCHANTMENT_SLOT));
+    if (!reforge)
+        return;
+
+    float removeValue = item->GetReforgableStat(ItemModType(reforge->SourceStat)) * reforge->SourceMultiplier;
+    float addValue = removeValue * reforge->FinalMultiplier;
+
+    switch (reforge->SourceStat)
+    {
+        case ITEM_MOD_MANA:
+            HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, -removeValue, apply);
+            break;
+        case ITEM_MOD_HEALTH:
+            HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, -removeValue, apply);
+            break;
+        case ITEM_MOD_AGILITY:
+            HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, -removeValue, apply);
+            ApplyStatBuffMod(STAT_AGILITY, -removeValue, apply);
+            break;
+        case ITEM_MOD_STRENGTH:
+            HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, -removeValue, apply);
+            ApplyStatBuffMod(STAT_STRENGTH, -removeValue, apply);
+            break;
+        case ITEM_MOD_INTELLECT:
+            HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, -removeValue, apply);
+            ApplyStatBuffMod(STAT_INTELLECT, -removeValue, apply);
+            break;
+        case ITEM_MOD_SPIRIT:
+            HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, -removeValue, apply);
+            ApplyStatBuffMod(STAT_SPIRIT, -removeValue, apply);
+            break;
+        case ITEM_MOD_STAMINA:
+            HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, -removeValue, apply);
+            ApplyStatBuffMod(STAT_STAMINA, -removeValue, apply);
+            break;
+        case ITEM_MOD_DEFENSE_SKILL_RATING:
+            ApplyRatingMod(CR_DEFENSE_SKILL, -int32(removeValue), apply);
+            break;
+        case  ITEM_MOD_DODGE_RATING:
+            ApplyRatingMod(CR_DODGE, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_PARRY_RATING:
+            ApplyRatingMod(CR_PARRY, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_BLOCK_RATING:
+            ApplyRatingMod(CR_BLOCK, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_HIT_MELEE_RATING:
+            ApplyRatingMod(CR_HIT_MELEE, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_HIT_RANGED_RATING:
+            ApplyRatingMod(CR_HIT_RANGED, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_HIT_SPELL_RATING:
+            ApplyRatingMod(CR_HIT_SPELL, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_CRIT_MELEE_RATING:
+            ApplyRatingMod(CR_CRIT_MELEE, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_CRIT_RANGED_RATING:
+            ApplyRatingMod(CR_CRIT_RANGED, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_CRIT_SPELL_RATING:
+            ApplyRatingMod(CR_CRIT_SPELL, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_HASTE_SPELL_RATING:
+            ApplyRatingMod(CR_HASTE_SPELL, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_HIT_RATING:
+            ApplyRatingMod(CR_HIT_MELEE, -int32(removeValue), apply);
+            ApplyRatingMod(CR_HIT_RANGED, -int32(removeValue), apply);
+            ApplyRatingMod(CR_HIT_SPELL, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_CRIT_RATING:
+            ApplyRatingMod(CR_CRIT_MELEE, -int32(removeValue), apply);
+            ApplyRatingMod(CR_CRIT_RANGED, -int32(removeValue), apply);
+            ApplyRatingMod(CR_CRIT_SPELL, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_RESILIENCE_RATING:
+            ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_HASTE_RATING:
+            ApplyRatingMod(CR_HASTE_MELEE, -int32(removeValue), apply);
+            ApplyRatingMod(CR_HASTE_RANGED, -int32(removeValue), apply);
+            ApplyRatingMod(CR_HASTE_SPELL, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_EXPERTISE_RATING:
+            ApplyRatingMod(CR_EXPERTISE, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_ATTACK_POWER:
+            HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, -removeValue, apply);
+            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, -removeValue, apply);
+            break;
+        case ITEM_MOD_RANGED_ATTACK_POWER:
+            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, -removeValue, apply);
+            break;
+        case ITEM_MOD_MANA_REGENERATION:
+            ApplyManaRegenBonus(-int32(removeValue), apply);
+            break;
+        case ITEM_MOD_ARMOR_PENETRATION_RATING:
+            ApplyRatingMod(CR_ARMOR_PENETRATION, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_SPELL_POWER:
+            ApplySpellPowerBonus(-int32(removeValue), apply);
+            break;
+        case ITEM_MOD_HEALTH_REGEN:
+            ApplyHealthRegenBonus(-int32(removeValue), apply);
+            break;
+        case ITEM_MOD_MASTERY_RATING:
+            ApplyRatingMod(CR_MASTERY, -int32(removeValue), apply);
+            break;
+        case ITEM_MOD_SPELL_PENETRATION:
+            ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, -int32(removeValue), apply);
+            m_spellPenetrationItemMod += apply ? -int32(removeValue) : int32(removeValue);
+            break;
+        case ITEM_MOD_BLOCK_VALUE:
+            HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, -removeValue, apply);
+            break;
+    }
+
+    switch (reforge->FinalStat)
+    {
+        case ITEM_MOD_MANA:
+            HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, addValue, apply);
+            break;
+        case ITEM_MOD_HEALTH:
+            HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, addValue, apply);
+            break;
+        case ITEM_MOD_AGILITY:
+            HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, addValue, apply);
+            ApplyStatBuffMod(STAT_AGILITY, addValue, apply);
+            break;
+        case ITEM_MOD_STRENGTH:
+            HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, addValue, apply);
+            ApplyStatBuffMod(STAT_STRENGTH, addValue, apply);
+            break;
+        case ITEM_MOD_INTELLECT:
+            HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, addValue, apply);
+            ApplyStatBuffMod(STAT_INTELLECT, addValue, apply);
+            break;
+        case ITEM_MOD_SPIRIT:
+            HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, addValue, apply);
+            ApplyStatBuffMod(STAT_SPIRIT, addValue, apply);
+            break;
+        case ITEM_MOD_STAMINA:
+            HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, addValue, apply);
+            ApplyStatBuffMod(STAT_STAMINA, addValue, apply);
+            break;
+        case ITEM_MOD_DEFENSE_SKILL_RATING:
+            ApplyRatingMod(CR_DEFENSE_SKILL, int32(addValue), apply);
+            break;
+        case  ITEM_MOD_DODGE_RATING:
+            ApplyRatingMod(CR_DODGE, int32(addValue), apply);
+            break;
+        case ITEM_MOD_PARRY_RATING:
+            ApplyRatingMod(CR_PARRY, int32(addValue), apply);
+            break;
+        case ITEM_MOD_BLOCK_RATING:
+            ApplyRatingMod(CR_BLOCK, int32(addValue), apply);
+            break;
+        case ITEM_MOD_HIT_MELEE_RATING:
+            ApplyRatingMod(CR_HIT_MELEE, int32(addValue), apply);
+            break;
+        case ITEM_MOD_HIT_RANGED_RATING:
+            ApplyRatingMod(CR_HIT_RANGED, int32(addValue), apply);
+            break;
+        case ITEM_MOD_HIT_SPELL_RATING:
+            ApplyRatingMod(CR_HIT_SPELL, int32(addValue), apply);
+            break;
+        case ITEM_MOD_CRIT_MELEE_RATING:
+            ApplyRatingMod(CR_CRIT_MELEE, int32(addValue), apply);
+            break;
+        case ITEM_MOD_CRIT_RANGED_RATING:
+            ApplyRatingMod(CR_CRIT_RANGED, int32(addValue), apply);
+            break;
+        case ITEM_MOD_CRIT_SPELL_RATING:
+            ApplyRatingMod(CR_CRIT_SPELL, int32(addValue), apply);
+            break;
+        case ITEM_MOD_HASTE_SPELL_RATING:
+            ApplyRatingMod(CR_HASTE_SPELL, int32(addValue), apply);
+            break;
+        case ITEM_MOD_HIT_RATING:
+            ApplyRatingMod(CR_HIT_MELEE, int32(addValue), apply);
+            ApplyRatingMod(CR_HIT_RANGED, int32(addValue), apply);
+            ApplyRatingMod(CR_HIT_SPELL, int32(addValue), apply);
+            break;
+        case ITEM_MOD_CRIT_RATING:
+            ApplyRatingMod(CR_CRIT_MELEE, int32(addValue), apply);
+            ApplyRatingMod(CR_CRIT_RANGED, int32(addValue), apply);
+            ApplyRatingMod(CR_CRIT_SPELL, int32(addValue), apply);
+            break;
+        case ITEM_MOD_RESILIENCE_RATING:
+            ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, int32(addValue), apply);
+            break;
+        case ITEM_MOD_HASTE_RATING:
+            ApplyRatingMod(CR_HASTE_MELEE, int32(addValue), apply);
+            ApplyRatingMod(CR_HASTE_RANGED, int32(addValue), apply);
+            ApplyRatingMod(CR_HASTE_SPELL, int32(addValue), apply);
+            break;
+        case ITEM_MOD_EXPERTISE_RATING:
+            ApplyRatingMod(CR_EXPERTISE, int32(addValue), apply);
+            break;
+        case ITEM_MOD_ATTACK_POWER:
+            HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, addValue, apply);
+            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, addValue, apply);
+            break;
+        case ITEM_MOD_RANGED_ATTACK_POWER:
+            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, addValue, apply);
+            break;
+        case ITEM_MOD_MANA_REGENERATION:
+            ApplyManaRegenBonus(int32(addValue), apply);
+            break;
+        case ITEM_MOD_ARMOR_PENETRATION_RATING:
+            ApplyRatingMod(CR_ARMOR_PENETRATION, int32(addValue), apply);
+            break;
+        case ITEM_MOD_SPELL_POWER:
+            ApplySpellPowerBonus(int32(addValue), apply);
+            break;
+        case ITEM_MOD_HEALTH_REGEN:
+            ApplyHealthRegenBonus(int32(addValue), apply);
+            break;
+        case ITEM_MOD_MASTERY_RATING:
+            ApplyRatingMod(CR_MASTERY, int32(addValue), apply);
+            break;
+        case ITEM_MOD_SPELL_PENETRATION:
+            ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, int32(addValue), apply);
+            m_spellPenetrationItemMod += apply ? int32(addValue) : -int32(addValue);
+            break;
+        case ITEM_MOD_BLOCK_VALUE:
+            HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, addValue, apply);
+            break;
+    }
+}
+
+void Player::ApplyEnchantment(Item* item, bool apply)
+{
+    for (uint32 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
+    {
+        // Apply reforge as last enchant
+        if (slot == REFORGE_ENCHANTMENT_SLOT)
+            continue;
+
+        ApplyEnchantment(item, EnchantmentSlot(slot), apply);
+    }
+
+    ApplyEnchantment(item, REFORGE_ENCHANTMENT_SLOT, apply);
+}
+
+void Player::ApplyEnchantment(Item* item, EnchantmentSlot slot, bool apply, bool apply_dur, bool ignore_condition)
+{
+    if (!item || !item->IsEquipped())
+        return;
+
+    if (slot >= MAX_ENCHANTMENT_SLOT)
+        return;
+
+    if (slot == TRANSMOGRIFY_ENCHANTMENT_SLOT)
+        return;
+
+    if (slot == REFORGE_ENCHANTMENT_SLOT)
+    {
+        ApplyReforgeEnchantment(item, apply);
+        return;
+    }
+
+    uint32 enchant_id = item->GetEnchantmentId(slot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    if (!ignore_condition && pEnchant->EnchantmentCondition && !EnchantmentFitsRequirements(pEnchant->EnchantmentCondition, -1))
+        return;
+
+    if (pEnchant->requiredLevel > getLevel())
+        return;
+
+    if (pEnchant->requiredSkill > 0 && pEnchant->requiredSkillValue > GetSkillValue(pEnchant->requiredSkill))
+        return;
+
+    // Cogwheel gems dont have requirement data set in SpellItemEnchantment.dbc, but they do have it in Item-sparse.db2
+    if (ItemTemplate const* gem = sObjectMgr->GetItemTemplate(pEnchant->GemID))
+        if (gem->RequiredSkill && GetSkillValue(gem->RequiredSkill) < gem->RequiredSkillRank)
+            return;
+
+    // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
+    // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
+    if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3)
+        && !item->GetTemplate()->Socket[slot-SOCK_ENCHANTMENT_SLOT].Color)
+    {
+        // Check if the requirements for the prismatic socket are met before applying the gem stats
+         SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(item->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));
+         if (!pPrismaticEnchant || (pPrismaticEnchant->requiredSkill > 0 && pPrismaticEnchant->requiredSkillValue > GetSkillValue(pPrismaticEnchant->requiredSkill)))
+             return;
+    }
+
+    if (!item->IsBroken())
+    {
+        for (int s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            uint32 enchant_display_type = pEnchant->type[s];
+            uint32 enchant_amount = pEnchant->amount[s];
+            uint32 enchant_spell_id = pEnchant->spellid[s];
+
+            switch (enchant_display_type)
+            {
+                case ITEM_ENCHANTMENT_TYPE_NONE:
+                    break;
+                case ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL:
+                    // processed in Player::CastItemCombatSpell
+                    break;
+                case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                    if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
+                        HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(enchant_amount), apply);
+                    else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
+                        HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(enchant_amount), apply);
+                    else if (item->GetSlot() == EQUIPMENT_SLOT_RANGED)
+                        HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
+                    break;
+                case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                    if (enchant_spell_id)
+                    {
+                        if (apply)
+                        {
+                            int32 basepoints = 0;
+                            // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+                            if (item->GetItemRandomPropertyId() < 0)
+                            {
+                                ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                                if (item_rand)
+                                {
+                                    // Search enchant_amount
+                                    for (int k = 0; k < 5; ++k)
+                                    {
+                                        if (item_rand->enchant_id[k] == enchant_id)
+                                        {
+                                            basepoints = int32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                            break;
+                                        }
+                                    }
+                                }
+                            }
+                            // Cast custom spell vs all equal basepoints got from enchant_amount
+                            if (basepoints)
+                                CastCustomSpell(this, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, item);
+                            else
+                                CastSpell(this, enchant_spell_id, true, item);
+                        }
+                        else
+                            RemoveAurasDueToItemSpell(enchant_spell_id, item->GetGUID());
+                    }
+                    break;
+                case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                    if (!enchant_amount)
+                    {
+                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand)
+                        {
+                            for (int k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand->enchant_id[k] == enchant_id)
+                                {
+                                    enchant_amount = uint32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+
+                    HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + enchant_spell_id), TOTAL_VALUE, float(enchant_amount), apply);
+                    break;
+                case ITEM_ENCHANTMENT_TYPE_STAT:
+                {
+                    if (!enchant_amount)
+                    {
+                        ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand_suffix)
+                        {
+                            for (int k = 0; k < 5; ++k)
+                            {
+                                if (item_rand_suffix->enchant_id[k] == enchant_id)
+                                {
+                                    enchant_amount = uint32((item_rand_suffix->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+
+                    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Adding %u to stat nb %u", enchant_amount, enchant_spell_id);
+                    switch (enchant_spell_id)
+                    {
+                        case ITEM_MOD_MANA:
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MANA", enchant_amount);
+                            HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(enchant_amount), apply);
+                            break;
+                        case ITEM_MOD_HEALTH:
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HEALTH", enchant_amount);
+                            HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(enchant_amount), apply);
+                            break;
+                        case ITEM_MOD_AGILITY:
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u AGILITY", enchant_amount);
+                            HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, float(enchant_amount), apply);
+                            ApplyStatBuffMod(STAT_AGILITY, (float)enchant_amount, apply);
+                            break;
+                        case ITEM_MOD_STRENGTH:
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u STRENGTH", enchant_amount);
+                            HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, float(enchant_amount), apply);
+                            ApplyStatBuffMod(STAT_STRENGTH, (float)enchant_amount, apply);
+                            break;
+                        case ITEM_MOD_INTELLECT:
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u INTELLECT", enchant_amount);
+                            HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, float(enchant_amount), apply);
+                            ApplyStatBuffMod(STAT_INTELLECT, (float)enchant_amount, apply);
+                            break;
+                        case ITEM_MOD_SPIRIT:
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SPIRIT", enchant_amount);
+                            HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, float(enchant_amount), apply);
+                            ApplyStatBuffMod(STAT_SPIRIT, (float)enchant_amount, apply);
+                            break;
+                        case ITEM_MOD_STAMINA:
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u STAMINA", enchant_amount);
+                            HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, float(enchant_amount), apply);
+                            ApplyStatBuffMod(STAT_STAMINA, (float)enchant_amount, apply);
+                            break;
+                        case ITEM_MOD_DEFENSE_SKILL_RATING:
+                            ApplyRatingMod(CR_DEFENSE_SKILL, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u DEFENCE", enchant_amount);
+                            break;
+                        case  ITEM_MOD_DODGE_RATING:
+                            ApplyRatingMod(CR_DODGE, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u DODGE", enchant_amount);
+                            break;
+                        case ITEM_MOD_PARRY_RATING:
+                            ApplyRatingMod(CR_PARRY, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u PARRY", enchant_amount);
+                            break;
+                        case ITEM_MOD_BLOCK_RATING:
+                            ApplyRatingMod(CR_BLOCK, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SHIELD_BLOCK", enchant_amount);
+                            break;
+                        case ITEM_MOD_HIT_MELEE_RATING:
+                            ApplyRatingMod(CR_HIT_MELEE, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MELEE_HIT", enchant_amount);
+                            break;
+                        case ITEM_MOD_HIT_RANGED_RATING:
+                            ApplyRatingMod(CR_HIT_RANGED, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u RANGED_HIT", enchant_amount);
+                            break;
+                        case ITEM_MOD_HIT_SPELL_RATING:
+                            ApplyRatingMod(CR_HIT_SPELL, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SPELL_HIT", enchant_amount);
+                            break;
+                        case ITEM_MOD_CRIT_MELEE_RATING:
+                            ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MELEE_CRIT", enchant_amount);
+                            break;
+                        case ITEM_MOD_CRIT_RANGED_RATING:
+                            ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u RANGED_CRIT", enchant_amount);
+                            break;
+                        case ITEM_MOD_CRIT_SPELL_RATING:
+                            ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SPELL_CRIT", enchant_amount);
+                            break;
+                        // Values from ITEM_STAT_MELEE_HA_RATING to ITEM_MOD_HASTE_RANGED_RATING are never used
+                        // in Enchantments
+                        // case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+                        //     ApplyRatingMod(CR_HIT_TAKEN_MELEE, enchant_amount, apply);
+                        //     break;
+                        // case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+                        //     ApplyRatingMod(CR_HIT_TAKEN_RANGED, enchant_amount, apply);
+                        //     break;
+                        // case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+                        //     ApplyRatingMod(CR_HIT_TAKEN_SPELL, enchant_amount, apply);
+                        //     break;
+                        // case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+                        //     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
+                        //     break;
+                        // case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+                        //     ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
+                        //     break;
+                        // case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+                        //     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
+                        //     break;
+                        // case ITEM_MOD_HASTE_MELEE_RATING:
+                        //     ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
+                        //     break;
+                        // case ITEM_MOD_HASTE_RANGED_RATING:
+                        //     ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
+                        //     break;
+                        case ITEM_MOD_HASTE_SPELL_RATING:
+                            ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
+                            break;
+                        case ITEM_MOD_HIT_RATING:
+                            ApplyRatingMod(CR_HIT_MELEE, enchant_amount, apply);
+                            ApplyRatingMod(CR_HIT_RANGED, enchant_amount, apply);
+                            ApplyRatingMod(CR_HIT_SPELL, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HIT", enchant_amount);
+                            break;
+                        case ITEM_MOD_CRIT_RATING:
+                            ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
+                            ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
+                            ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u CRITICAL", enchant_amount);
+                            break;
+                        // case ITEM_MOD_HIT_TAKEN_RATING: // Unused since 3.3.5
+                        //     ApplyRatingMod(CR_HIT_TAKEN_MELEE, enchant_amount, apply);
+                        //     ApplyRatingMod(CR_HIT_TAKEN_RANGED, enchant_amount, apply);
+                        //     ApplyRatingMod(CR_HIT_TAKEN_SPELL, enchant_amount, apply);
+                        //     break;
+                        // case ITEM_MOD_CRIT_TAKEN_RATING: // Unused since 3.3.5
+                        //     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
+                        //     ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
+                        //     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
+                        //     break;
+                        case ITEM_MOD_RESILIENCE_RATING:
+                            ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u RESILIENCE", enchant_amount);
+                            break;
+                        case ITEM_MOD_HASTE_RATING:
+                            ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
+                            ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
+                            ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HASTE", enchant_amount);
+                            break;
+                        case ITEM_MOD_EXPERTISE_RATING:
+                            ApplyRatingMod(CR_EXPERTISE, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u EXPERTISE", enchant_amount);
+                            break;
+                        case ITEM_MOD_ATTACK_POWER:
+                            HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(enchant_amount), apply);
+                            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u ATTACK_POWER", enchant_amount);
+                            break;
+                        case ITEM_MOD_RANGED_ATTACK_POWER:
+                            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u RANGED_ATTACK_POWER", enchant_amount);
+                            break;
+                        case ITEM_MOD_MANA_REGENERATION:
+                            ApplyManaRegenBonus(enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MANA_REGENERATION", enchant_amount);
+                            break;
+                        case ITEM_MOD_ARMOR_PENETRATION_RATING:
+                            ApplyRatingMod(CR_ARMOR_PENETRATION, enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u ARMOR PENETRATION", enchant_amount);
+                            break;
+                        case ITEM_MOD_SPELL_POWER:
+                            ApplySpellPowerBonus(enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SPELL_POWER", enchant_amount);
+                            break;
+                        case ITEM_MOD_HEALTH_REGEN:
+                            ApplyHealthRegenBonus(enchant_amount, apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HEALTH_REGENERATION", enchant_amount);
+                            break;
+                        case ITEM_MOD_SPELL_PENETRATION:
+                            ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, -int32(enchant_amount), apply);
+                            m_spellPenetrationItemMod += apply ? int32(enchant_amount) : -int32(enchant_amount);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SPELL_PENETRATION", enchant_amount);
+                            break;
+                        case ITEM_MOD_BLOCK_VALUE:
+                            HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(enchant_amount), apply);
+                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u BLOCK_VALUE", enchant_amount);
+                            break;
+                        case ITEM_MOD_MASTERY_RATING:
+                            ApplyRatingMod(CR_MASTERY, int32(enchant_amount), apply);
+                            break;
+                        default:
+                            break;
+                    }
+                    break;
+                }
+                case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+                {
+                    if (getClass() == CLASS_SHAMAN)
+                    {
+                        float addValue = 0.0f;
+                        if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
+                        {
+                            addValue = float(enchant_amount * item->GetTemplate()->Delay / 1000.0f);
+                            HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, addValue, apply);
+                        }
+                        else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
+                        {
+                            addValue = float(enchant_amount * item->GetTemplate()->Delay / 1000.0f);
+                            HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, addValue, apply);
+                        }
+                    }
+                    break;
+                }
+                case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+                    // processed in Player::CastItemUseSpell
+                    break;
+                case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                    // nothing do..
+                    break;
+                default:
+                    sLog->outError(LOG_FILTER_PLAYER, "Unknown item enchantment (id = %d) display type: %d", enchant_id, enchant_display_type);
+                    break;
+            }                                               /*switch (enchant_display_type)*/
+        }                                                   /*for*/
+    }
+
+    // visualize enchantment at player and equipped items
+    if (slot == PERM_ENCHANTMENT_SLOT)
+        SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (item->GetSlot() * 2), 0, apply ? item->GetEnchantmentId(slot) : 0);
+
+    if (slot == TEMP_ENCHANTMENT_SLOT)
+        SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (item->GetSlot() * 2), 1, apply ? item->GetEnchantmentId(slot) : 0);
+
+    if (apply_dur)
+    {
+        if (apply)
+        {
+            // set duration
+            uint32 duration = item->GetEnchantmentDuration(slot);
+            if (duration > 0)
+                AddEnchantmentDuration(item, slot, duration);
+        }
+        else
+        {
+            // duration == 0 will remove EnchantDuration
+            AddEnchantmentDuration(item, slot, 0);
+        }
+    }
+}
+
+void Player::UpdateSkillEnchantments(uint16 skill_id, uint16 curr_value, uint16 new_value)
+{
+    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (m_items[i])
+        {
+            for (uint8 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
+            {
+                if (slot > PRISMATIC_ENCHANTMENT_SLOT || slot < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
+                    continue;
+
+                uint32 ench_id = m_items[i]->GetEnchantmentId(EnchantmentSlot(slot));
+                if (!ench_id)
+                    continue;
+
+                SpellItemEnchantmentEntry const* Enchant = sSpellItemEnchantmentStore.LookupEntry(ench_id);
+                if (!Enchant)
+                    return;
+
+                if (Enchant->requiredSkill == skill_id)
+                {
+                    // Checks if the enchantment needs to be applied or removed
+                    if (curr_value < Enchant->requiredSkillValue && new_value >= Enchant->requiredSkillValue)
+                        ApplyEnchantment(m_items[i], EnchantmentSlot(slot), true);
+                    else if (new_value < Enchant->requiredSkillValue && curr_value >= Enchant->requiredSkillValue)
+                        ApplyEnchantment(m_items[i], EnchantmentSlot(slot), false);
+                }
+
+                // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
+                // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
+                if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3)
+                    && !m_items[i]->GetTemplate()->Socket[slot-SOCK_ENCHANTMENT_SLOT].Color)
+                {
+                    SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(m_items[i]->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));
+
+                    if (pPrismaticEnchant && pPrismaticEnchant->requiredSkill == skill_id)
+                    {
+                        if (curr_value < pPrismaticEnchant->requiredSkillValue && new_value >= pPrismaticEnchant->requiredSkillValue)
+                            ApplyEnchantment(m_items[i], EnchantmentSlot(slot), true);
+                        else if (new_value < pPrismaticEnchant->requiredSkillValue && curr_value >= pPrismaticEnchant->requiredSkillValue)
+                            ApplyEnchantment(m_items[i], EnchantmentSlot(slot), false);
+                    }
+                }
+            }
+        }
+    }
+}
+
+void Player::SendEnchantmentDurations()
+{
+    for (EnchantDurationList::const_iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
+        GetSession()->SendItemEnchantTimeUpdate(GetGUID(), itr->item->GetGUID(), itr->slot, uint32(itr->leftduration) / 1000);
+}
+
+void Player::SendItemDurations()
+{
+    for (ItemDurationList::const_iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end(); ++itr)
+        (*itr)->SendTimeUpdate(this);
+}
+
+void Player::SendNewItem(Item* item, uint32 count, bool received, bool created, bool broadcast)
+{
+    if (!item)                                               // prevent crash
+        return;
+
+                                                            // last check 2.0.10
+    WorldPacket data(SMSG_ITEM_PUSH_RESULT, (8+4+4+4+1+4+4+4+4+4));
+    data << uint64(GetGUID());                              // player GUID
+    data << uint32(received);                               // 0=looted, 1=from npc
+    data << uint32(created);                                // 0=received, 1=created
+    data << uint32(1);                                      // bool print error to chat
+    data << uint8(item->GetBagSlot());                      // bagslot
+                                                            // item slot, but when added to stack: 0xFFFFFFFF
+    data << uint32((item->GetCount() == count) ? item->GetSlot() : -1);
+    data << uint32(item->GetEntry());                       // item id
+    data << uint32(item->GetItemSuffixFactor());            // SuffixFactor
+    data << int32(item->GetItemRandomPropertyId());         // random item property id
+    data << uint32(count);                                  // count of items
+    data << uint32(GetItemCount(item->GetEntry()));         // count of items in inventory
+
+    if (broadcast && GetGroup())
+        GetGroup()->BroadcastPacket(&data, true);
+    else
+        GetSession()->SendPacket(&data);
+}
+
+/*********************************************************/
+/***                    GOSSIP SYSTEM                  ***/
+/*********************************************************/
+
+void Player::PrepareGossipMenu(WorldObject* source, uint32 menuId /*= 0*/, bool showQuests /*= false*/)
+{
+    PlayerMenu* menu = PlayerTalkClass;
+    menu->ClearMenus();
+
+    menu->GetGossipMenu().SetMenuId(menuId);
+
+    GossipMenuItemsMapBounds menuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(menuId);
+
+    // if default menuId and no menu options exist for this, use options from default options
+    if (menuItemBounds.first == menuItemBounds.second && menuId == GetDefaultGossipMenuForSource(source))
+        menuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(0);
+
+    uint32 npcflags = 0;
+
+    if (source->GetTypeId() == TYPEID_UNIT)
+    {
+        npcflags = source->GetUInt32Value(UNIT_NPC_FLAGS);
+        if (npcflags & UNIT_NPC_FLAG_QUESTGIVER && showQuests)
+            PrepareQuestMenu(source->GetGUID());
+    }
+
+    if (source->GetTypeId() == TYPEID_GAMEOBJECT)
+        if (source->ToGameObject()->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+            PrepareQuestMenu(source->GetGUID());
+
+    for (GossipMenuItemsContainer::const_iterator itr = menuItemBounds.first; itr != menuItemBounds.second; ++itr)
+    {
+        bool canTalk = true;
+        if (!sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.Conditions))
+            continue;
+
+        if (Creature* creature = source->ToCreature())
+        {
+            if (!(itr->second.OptionNpcflag & npcflags))
+                continue;
+
+            switch (itr->second.OptionType)
+            {
+                case GOSSIP_OPTION_ARMORER:
+                    canTalk = false;                       // added in special mode
+                    break;
+                case GOSSIP_OPTION_SPIRITHEALER:
+                    if (!isDead())
+                        canTalk = false;
+                    break;
+                case GOSSIP_OPTION_VENDOR:
+                {
+                    VendorItemData const* vendorItems = creature->GetVendorItems();
+                    if (!vendorItems || vendorItems->Empty())
+                    {
+                        sLog->outError(LOG_FILTER_SQL, "Creature (GUID: %u, Entry: %u) have UNIT_NPC_FLAG_VENDOR but have empty trading item list.", creature->GetGUIDLow(), creature->GetEntry());
+                        canTalk = false;
+                    }
+                    break;
+                }
+                case GOSSIP_OPTION_TRAINER:
+                    if (!creature->isCanTrainingOf(this, false))
+                        canTalk = false;
+                    break;
+                case GOSSIP_OPTION_LEARNDUALSPEC:
+                    if (!(GetSpecsCount() == 1 && creature->isCanTrainingAndResetTalentsOf(this) && !(getLevel() < sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL))))
+                        canTalk = false;
+                    break;
+                case GOSSIP_OPTION_UNLEARNTALENTS:
+                    if (!creature->isCanTrainingAndResetTalentsOf(this))
+                        canTalk = false;
+                    break;
+                case GOSSIP_OPTION_UNLEARNPETTALENTS:
+                    if (!GetPet() || GetPet()->getPetType() != HUNTER_PET || GetPet()->m_spells.size() <= 1 || creature->GetCreatureTemplate()->trainer_type != TRAINER_TYPE_PETS || creature->GetCreatureTemplate()->trainer_class != CLASS_HUNTER)
+                        canTalk = false;
+                    break;
+                case GOSSIP_OPTION_TAXIVENDOR:
+                    if (GetSession()->SendLearnNewTaxiNode(creature))
+                        return;
+                    break;
+                case GOSSIP_OPTION_BATTLEFIELD:
+                    if (!creature->isCanInteractWithBattleMaster(this, false))
+                        canTalk = false;
+                    break;
+                case GOSSIP_OPTION_STABLEPET:
+                    if (getClass() != CLASS_HUNTER)
+                        canTalk = false;
+                    break;
+                case GOSSIP_OPTION_QUESTGIVER:
+                    canTalk = false;
+                    break;
+                case GOSSIP_OPTION_GOSSIP:
+                case GOSSIP_OPTION_SPIRITGUIDE:
+                case GOSSIP_OPTION_INNKEEPER:
+                case GOSSIP_OPTION_BANKER:
+                case GOSSIP_OPTION_PETITIONER:
+                case GOSSIP_OPTION_TABARDDESIGNER:
+                case GOSSIP_OPTION_AUCTIONEER:
+                    break;                                  // no checks
+                case GOSSIP_OPTION_OUTDOORPVP:
+                    if (!sOutdoorPvPMgr->CanTalkTo(this, creature, itr->second))
+                        canTalk = false;
+                    break;
+                default:
+                    sLog->outError(LOG_FILTER_SQL, "Creature entry %u have unknown gossip option %u for menu %u", creature->GetEntry(), itr->second.OptionType, itr->second.MenuId);
+                    canTalk = false;
+                    break;
+            }
+        }
+        else if (GameObject* go = source->ToGameObject())
+        {
+            switch (itr->second.OptionType)
+            {
+                case GOSSIP_OPTION_GOSSIP:
+                    if (go->GetGoType() != GAMEOBJECT_TYPE_QUESTGIVER && go->GetGoType() != GAMEOBJECT_TYPE_GOOBER)
+                        canTalk = false;
+                    break;
+                default:
+                    canTalk = false;
+                    break;
+            }
+        }
+
+        if (canTalk)
+        {
+            std::string strOptionText = itr->second.OptionText;
+            std::string strBoxText = itr->second.BoxText;
+
+            int32 locale = GetSession()->GetSessionDbLocaleIndex();
+            if (locale >= 0)
+            {
+                uint32 idxEntry = MAKE_PAIR32(menuId, itr->second.OptionIndex);
+                if (GossipMenuItemsLocale const* no = sObjectMgr->GetGossipMenuItemsLocale(idxEntry))
+                {
+                    ObjectMgr::GetLocaleString(no->OptionText, locale, strOptionText);
+                    ObjectMgr::GetLocaleString(no->BoxText, locale, strBoxText);
+                }
+            }
+
+            menu->GetGossipMenu().AddMenuItem(itr->second.OptionIndex, itr->second.OptionIcon, strOptionText, 0, itr->second.OptionType, strBoxText, itr->second.BoxMoney, itr->second.BoxCoded);
+            menu->GetGossipMenu().AddGossipMenuItemData(itr->second.OptionIndex, itr->second.ActionMenuId, itr->second.ActionPoiId);
+        }
+    }
+}
+
+void Player::SendPreparedGossip(WorldObject* source)
+{
+    if (!source)
+        return;
+
+    if (source->GetTypeId() == TYPEID_UNIT)
+    {
+        // in case no gossip flag and quest menu not empty, open quest menu (client expect gossip menu with this flag)
+        if (!source->ToCreature()->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP) && !PlayerTalkClass->GetQuestMenu().Empty())
+        {
+            SendPreparedQuest(source->GetGUID());
+            return;
+        }
+    }
+    else if (source->GetTypeId() == TYPEID_GAMEOBJECT)
+    {
+        // probably need to find a better way here
+        if (!PlayerTalkClass->GetGossipMenu().GetMenuId() && !PlayerTalkClass->GetQuestMenu().Empty())
+        {
+            SendPreparedQuest(source->GetGUID());
+            return;
+        }
+    }
+
+    // in case non empty gossip menu (that not included quests list size) show it
+    // (quest entries from quest menu will be included in list)
+
+    uint32 textId = GetGossipTextId(source);
+
+    if (uint32 menuId = PlayerTalkClass->GetGossipMenu().GetMenuId())
+        textId = GetGossipTextId(menuId, source);
+
+    PlayerTalkClass->SendGossipMenu(textId, source->GetGUID());
+}
+
+void Player::OnGossipSelect(WorldObject* source, uint32 gossipListId, uint32 menuId)
+{
+    GossipMenu& gossipMenu = PlayerTalkClass->GetGossipMenu();
+
+    // if not same, then something funky is going on
+    if (menuId != gossipMenu.GetMenuId())
+        return;
+
+    GossipMenuItem const* item = gossipMenu.GetItem(gossipListId);
+    if (!item)
+        return;
+
+    uint32 gossipOptionId = item->OptionType;
+    uint64 guid = source->GetGUID();
+
+    if (source->GetTypeId() == TYPEID_GAMEOBJECT)
+    {
+        if (gossipOptionId > GOSSIP_OPTION_QUESTGIVER)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player guid %u request invalid gossip option for GameObject entry %u", GetGUIDLow(), source->GetEntry());
+            return;
+        }
+    }
+
+    GossipMenuItemData const* menuItemData = gossipMenu.GetItemData(gossipListId);
+    if (!menuItemData)
+        return;
+
+    int32 cost = int32(item->BoxMoney);
+    if (!HasEnoughMoney(int64(cost)))
+    {
+        SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+        PlayerTalkClass->SendCloseGossip();
+        return;
+    }
+
+    switch (gossipOptionId)
+    {
+        case GOSSIP_OPTION_GOSSIP:
+        {
+            if (menuItemData->GossipActionPoi)
+                PlayerTalkClass->SendPointOfInterest(menuItemData->GossipActionPoi);
+
+            if (menuItemData->GossipActionMenuId)
+            {
+                PrepareGossipMenu(source, menuItemData->GossipActionMenuId);
+                SendPreparedGossip(source);
+            }
+
+            break;
+        }
+        case GOSSIP_OPTION_OUTDOORPVP:
+            sOutdoorPvPMgr->HandleGossipOption(this, source->GetGUID(), gossipListId);
+            break;
+        case GOSSIP_OPTION_SPIRITHEALER:
+            if (isDead())
+                source->ToCreature()->CastSpell(source->ToCreature(), 17251, true, NULL, NULL, GetGUID());
+            break;
+        case GOSSIP_OPTION_QUESTGIVER:
+            PrepareQuestMenu(guid);
+            SendPreparedQuest(guid);
+            break;
+        case GOSSIP_OPTION_VENDOR:
+        case GOSSIP_OPTION_ARMORER:
+            GetSession()->SendListInventory(guid);
+            break;
+        case GOSSIP_OPTION_STABLEPET:
+            GetSession()->SendStablePet(guid);
+            break;
+        case GOSSIP_OPTION_TRAINER:
+            GetSession()->SendTrainerList(guid);
+            break;
+        case GOSSIP_OPTION_LEARNDUALSPEC:
+            if (GetSpecsCount() == 1 && getLevel() >= sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL))
+            {
+                // Cast spells that teach dual spec
+                // Both are also ImplicitTarget self and must be cast by player
+                CastSpell(this, 63680, true, NULL, NULL, GetGUID());
+                CastSpell(this, 63624, true, NULL, NULL, GetGUID());
+
+                // Should show another Gossip text with "Congratulations..."
+                PlayerTalkClass->SendCloseGossip();
+            }
+            break;
+        case GOSSIP_OPTION_UNLEARNTALENTS:
+            PlayerTalkClass->SendCloseGossip();
+            SendTalentWipeConfirm(guid);
+            break;
+        case GOSSIP_OPTION_UNLEARNPETTALENTS:
+            PlayerTalkClass->SendCloseGossip();
+            ResetPetTalents();
+            break;
+        case GOSSIP_OPTION_TAXIVENDOR:
+            GetSession()->SendTaxiMenu(source->ToCreature());
+            break;
+        case GOSSIP_OPTION_INNKEEPER:
+            PlayerTalkClass->SendCloseGossip();
+            SetBindPoint(guid);
+            break;
+        case GOSSIP_OPTION_BANKER:
+            GetSession()->SendShowBank(guid);
+            break;
+        case GOSSIP_OPTION_PETITIONER:
+            PlayerTalkClass->SendCloseGossip();
+            GetSession()->SendPetitionShowList(guid);
+            break;
+        case GOSSIP_OPTION_TABARDDESIGNER:
+            PlayerTalkClass->SendCloseGossip();
+            GetSession()->SendTabardVendorActivate(guid);
+            break;
+        case GOSSIP_OPTION_AUCTIONEER:
+            GetSession()->SendAuctionHello(guid, source->ToCreature());
+            break;
+        case GOSSIP_OPTION_SPIRITGUIDE:
+            PrepareGossipMenu(source);
+            SendPreparedGossip(source);
+            break;
+        case GOSSIP_OPTION_BATTLEFIELD:
+        {
+            BattlegroundTypeId bgTypeId = sBattlegroundMgr->GetBattleMasterBG(source->GetEntry());
+
+            if (bgTypeId == BATTLEGROUND_TYPE_NONE)
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "a user (guid %u) requested battlegroundlist from a npc who is no battlemaster", GetGUIDLow());
+                return;
+            }
+
+            GetSession()->SendBattleGroundList(guid, bgTypeId);
+            break;
+        }
+    }
+
+    ModifyMoney(-cost);
+}
+
+uint32 Player::GetGossipTextId(WorldObject* source)
+{
+    if (!source)
+        return DEFAULT_GOSSIP_MESSAGE;
+
+    return GetGossipTextId(GetDefaultGossipMenuForSource(source), source);
+}
+
+uint32 Player::GetGossipTextId(uint32 menuId, WorldObject* source)
+{
+    uint32 textId = DEFAULT_GOSSIP_MESSAGE;
+
+    if (!menuId)
+        return textId;
+
+    GossipMenusMapBounds menuBounds = sObjectMgr->GetGossipMenusMapBounds(menuId);
+
+    for (GossipMenusContainer::const_iterator itr = menuBounds.first; itr != menuBounds.second; ++itr)
+    {
+        if (sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.conditions))
+            textId = itr->second.text_id;
+    }
+
+    return textId;
+}
+
+uint32 Player::GetDefaultGossipMenuForSource(WorldObject* source)
+{
+    switch (source->GetTypeId())
+    {
+        case TYPEID_UNIT:
+            return source->ToCreature()->GetCreatureTemplate()->GossipMenuId;
+        case TYPEID_GAMEOBJECT:
+            return source->ToGameObject()->GetGOInfo()->GetGossipMenuId();
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+/*********************************************************/
+/***                    QUEST SYSTEM                   ***/
+/*********************************************************/
+
+void Player::PrepareQuestMenu(uint64 guid)
+{
+    QuestRelationBounds objectQR;
+    QuestRelationBounds objectQIR;
+
+    // pets also can have quests
+    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
+    if (creature)
+    {
+        objectQR  = sObjectMgr->GetCreatureQuestRelationBounds(creature->GetEntry());
+        objectQIR = sObjectMgr->GetCreatureQuestInvolvedRelationBounds(creature->GetEntry());
+    }
+    else
+    {
+        //we should obtain map pointer from GetMap() in 99% of cases. Special case
+        //only for quests which cast teleport spells on player
+        Map* _map = IsInWorld() ? GetMap() : sMapMgr->FindMap(GetMapId(), GetInstanceId());
+        ASSERT(_map);
+        GameObject* gameObject = _map->GetGameObject(guid);
+        if (gameObject)
+        {
+            objectQR  = sObjectMgr->GetGOQuestRelationBounds(gameObject->GetEntry());
+            objectQIR = sObjectMgr->GetGOQuestInvolvedRelationBounds(gameObject->GetEntry());
+        }
+        else
+            return;
+    }
+
+    QuestMenu &qm = PlayerTalkClass->GetQuestMenu();
+    qm.ClearMenu();
+
+    for (QuestRelations::const_iterator i = objectQIR.first; i != objectQIR.second; ++i)
+    {
+        uint32 quest_id = i->second;
+        QuestStatus status = GetQuestStatus(quest_id);
+        if (status == QUEST_STATUS_COMPLETE)
+            qm.AddMenuItem(quest_id, 4);
+        else if (status == QUEST_STATUS_INCOMPLETE)
+            qm.AddMenuItem(quest_id, 4);
+        //else if (status == QUEST_STATUS_AVAILABLE)
+        //    qm.AddMenuItem(quest_id, 2);
+    }
+
+    for (QuestRelations::const_iterator i = objectQR.first; i != objectQR.second; ++i)
+    {
+        uint32 quest_id = i->second;
+        Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
+        if (!quest)
+            continue;
+
+        if (!CanTakeQuest(quest, false))
+            continue;
+
+        if (quest->IsAutoComplete())
+            qm.AddMenuItem(quest_id, 4);
+        else if (GetQuestStatus(quest_id) == QUEST_STATUS_NONE)
+            qm.AddMenuItem(quest_id, 2);
+    }
+}
+
+void Player::SendPreparedQuest(uint64 guid)
+{
+    QuestMenu& questMenu = PlayerTalkClass->GetQuestMenu();
+    if (questMenu.Empty())
+        return;
+
+    QuestMenuItem const& qmi0 = questMenu.GetItem(0);
+
+    uint32 icon = qmi0.QuestIcon;
+
+    // single element case
+    if (questMenu.GetMenuItemCount() == 1)
+    {
+        // Auto open -- maybe also should verify there is no greeting
+        uint32 questId = qmi0.QuestId;
+        Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
+
+        if (quest)
+        {
+            if (icon == 4 && !GetQuestRewardStatus(questId))
+                PlayerTalkClass->SendQuestGiverRequestItems(quest, guid, CanRewardQuest(quest, false), true);
+            else if (icon == 4)
+                PlayerTalkClass->SendQuestGiverRequestItems(quest, guid, CanRewardQuest(quest, false), true);
+            // Send completable on repeatable and autoCompletable quest if player don't have quest
+            // TODO: verify if check for !quest->IsDaily() is really correct (possibly not)
+            else
+            {
+                Object* object = ObjectAccessor::GetObjectByTypeMask(*this, guid, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT | TYPEMASK_ITEM);
+                if (!object || (!object->hasQuest(questId) && !object->hasInvolvedQuest(questId)))
+                {
+                    PlayerTalkClass->SendCloseGossip();
+                    return;
+                }
+
+                if (quest->IsAutoAccept() && CanAddQuest(quest, true) && CanTakeQuest(quest, true))
+                {
+                    AddQuest(quest, object);
+                    if (CanCompleteQuest(questId))
+                        CompleteQuest(questId);
+                }
+
+                if ((quest->IsAutoComplete() && quest->IsRepeatable() && !quest->IsDailyOrWeekly()) || (quest->HasFlag(QUEST_FLAGS_AUTOCOMPLETE) && !quest->IsAutoAccept()))
+                    PlayerTalkClass->SendQuestGiverRequestItems(quest, guid, CanCompleteRepeatableQuest(quest), true);
+                else
+                    PlayerTalkClass->SendQuestGiverQuestDetails(quest, guid, true);
+            }
+        }
+    }
+    // multiple entries
+    else
+    {
+        QEmote qe;
+        qe._Delay = 0;
+        qe._Emote = 0;
+        std::string title = "";
+
+        // need pet case for some quests
+        Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
+        if (creature)
+        {
+            uint32 textid = GetGossipTextId(creature);
+            GossipText const* gossiptext = sObjectMgr->GetGossipText(textid);
+            if (!gossiptext)
+            {
+                qe._Delay = 0;                              //TEXTEMOTE_MESSAGE;              //zyg: player emote
+                qe._Emote = 0;                              //TEXTEMOTE_HELLO;                //zyg: NPC emote
+                title = "";
+            }
+            else
+            {
+                qe = gossiptext->Options[0].Emotes[0];
+
+                if (!gossiptext->Options[0].Text_0.empty())
+                {
+                    title = gossiptext->Options[0].Text_0;
+
+                    int loc_idx = GetSession()->GetSessionDbLocaleIndex();
+                    if (loc_idx >= 0)
+                        if (NpcTextLocale const* nl = sObjectMgr->GetNpcTextLocale(textid))
+                            ObjectMgr::GetLocaleString(nl->Text_0[0], loc_idx, title);
+                }
+                else
+                {
+                    title = gossiptext->Options[0].Text_1;
+
+                    int loc_idx = GetSession()->GetSessionDbLocaleIndex();
+                    if (loc_idx >= 0)
+                        if (NpcTextLocale const* nl = sObjectMgr->GetNpcTextLocale(textid))
+                            ObjectMgr::GetLocaleString(nl->Text_1[0], loc_idx, title);
+                }
+            }
+        }
+        PlayerTalkClass->SendQuestGiverQuestList(qe, title, guid);
+    }
+}
+
+bool Player::IsActiveQuest(uint32 quest_id) const
+{
+    return m_QuestStatus.find(quest_id) != m_QuestStatus.end();
+}
+
+Quest const* Player::GetNextQuest(uint64 guid, Quest const* quest)
+{
+    QuestRelationBounds objectQR;
+    uint32 nextQuestID = quest->GetNextQuestInChain();
+
+    switch (GUID_HIPART(guid))
+    {
+        case HIGHGUID_PLAYER:
+            ASSERT(quest->HasFlag(QUEST_FLAGS_AUTO_SUBMIT) || quest->HasFlag(QUEST_FLAGS_AUTO_REWARDED));
+            return sObjectMgr->GetQuestTemplate(nextQuestID);
+        case HIGHGUID_UNIT:
+        case HIGHGUID_PET:
+        case HIGHGUID_VEHICLE:
+        {
+            if (Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid))
+                objectQR  = sObjectMgr->GetCreatureQuestRelationBounds(creature->GetEntry());
+            else
+                return NULL;
+            break;
+        }
+        case HIGHGUID_GAMEOBJECT:
+        {
+            //we should obtain map pointer from GetMap() in 99% of cases. Special case
+            //only for quests which cast teleport spells on player
+            Map* _map = IsInWorld() ? GetMap() : sMapMgr->FindMap(GetMapId(), GetInstanceId());
+            ASSERT(_map);
+            if (GameObject* gameObject = _map->GetGameObject(guid))
+                objectQR = sObjectMgr->GetGOQuestRelationBounds(gameObject->GetEntry());
+            else
+                return NULL;
+            break;
+        }
+        default:
+            return NULL;
+    }
+
+    // for unit and go state
+    for (QuestRelations::const_iterator itr = objectQR.first; itr != objectQR.second; ++itr)
+    {
+        if (itr->second == nextQuestID)
+            return sObjectMgr->GetQuestTemplate(nextQuestID);
+    }
+
+    return NULL;
+}
+
+bool Player::CanSeeStartQuest(Quest const* quest)
+{
+    if (!DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, quest->GetQuestId(), this) && SatisfyQuestClass(quest, false) && SatisfyQuestRace(quest, false) &&
+        SatisfyQuestSkill(quest, false) && SatisfyQuestExclusiveGroup(quest, false) && SatisfyQuestReputation(quest, false) &&
+        SatisfyQuestPreviousQuest(quest, false) && SatisfyQuestNextChain(quest, false) &&
+        SatisfyQuestPrevChain(quest, false) && SatisfyQuestDay(quest, false) && SatisfyQuestWeek(quest, false) &&
+        SatisfyQuestMonth(quest, false) && SatisfyQuestSeasonal(quest, false))
+    {
+        return getLevel() + sWorld->getIntConfig(CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF) >= quest->GetMinLevel();
+    }
+
+    return false;
+}
+
+bool Player::CanTakeQuest(Quest const* quest, bool msg, bool prevQuestAutoReward)
+{
+    return !DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, quest->GetQuestId(), this)
+        && SatisfyQuestStatus(quest, msg) && SatisfyQuestExclusiveGroup(quest, msg)
+        && SatisfyQuestClass(quest, msg) && SatisfyQuestRace(quest, msg) && SatisfyQuestLevel(quest, msg)
+        && SatisfyQuestSkill(quest, msg) && SatisfyQuestReputation(quest, msg)
+        && (prevQuestAutoReward || SatisfyQuestPreviousQuest(quest, msg)) && SatisfyQuestTimed(quest, msg)
+        && (prevQuestAutoReward || (SatisfyQuestNextChain(quest, msg) && SatisfyQuestPrevChain(quest, msg)))
+        && SatisfyQuestDay(quest, msg) && SatisfyQuestWeek(quest, msg)
+        && SatisfyQuestMonth(quest, msg) && SatisfyQuestSeasonal(quest, msg)
+        && SatisfyQuestConditions(quest, msg);
+}
+
+bool Player::CanAddQuest(Quest const* quest, bool msg)
+{
+    if (!SatisfyQuestLog(msg))
+        return false;
+
+    uint32 srcitem = quest->GetSrcItemId();
+    if (srcitem > 0)
+    {
+        uint32 count = quest->GetSrcItemCount();
+        ItemPosCountVec dest;
+        InventoryResult msg2 = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, srcitem, count);
+
+        // player already have max number (in most case 1) source item, no additional item needed and quest can be added.
+        if (msg2 == EQUIP_ERR_ITEM_MAX_COUNT)
+            return true;
+        else if (msg2 != EQUIP_ERR_OK)
+        {
+            SendEquipError(msg2, NULL, NULL, srcitem);
+            return false;
+        }
+    }
+    return true;
+}
+
+bool Player::CanCompleteQuest(uint32 quest_id)
+{
+    if (quest_id)
+    {
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
+        if (!qInfo)
+            return false;
+
+        if (!qInfo->IsRepeatable() && m_RewardedQuests.find(quest_id) != m_RewardedQuests.end())
+            return false;                                   // not allow re-complete quest
+
+        // auto complete quest
+        if ((qInfo->IsAutoComplete() || qInfo->GetFlags() & QUEST_FLAGS_AUTOCOMPLETE) && !qInfo->IsAutoAccept() && CanTakeQuest(qInfo, false))
+            return true;
+
+        QuestStatusMap::iterator itr = m_QuestStatus.find(quest_id);
+        if (itr == m_QuestStatus.end())
+            return false;
+
+        QuestStatusData &q_status = itr->second;
+
+        if (q_status.Status == QUEST_STATUS_INCOMPLETE)
+        {
+            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
+            {
+                for (uint8 i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+                {
+                    if (qInfo->RequiredItemCount[i]!= 0 && q_status.ItemCount[i] < qInfo->RequiredItemCount[i])
+                        return false;
+                }
+            }
+
+            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_KILL_OR_CAST | QUEST_SPECIAL_FLAGS_SPEAKTO))
+            {
+                for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+                {
+                    if (qInfo->RequiredNpcOrGo[i] == 0)
+                        continue;
+
+                    if (qInfo->RequiredNpcOrGoCount[i] != 0 && q_status.CreatureOrGOCount[i] < qInfo->RequiredNpcOrGoCount[i])
+                        return false;
+                }
+            }
+
+            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_PLAYER_KILL))
+                if (qInfo->GetPlayersSlain() != 0 && q_status.PlayerCount < qInfo->GetPlayersSlain())
+                    return false;
+
+            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_EXPLORATION_OR_EVENT) && !q_status.Explored)
+                return false;
+
+            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED) && q_status.Timer == 0)
+                return false;
+
+            if (qInfo->GetRewOrReqMoney() < 0)
+            {
+                if (!HasEnoughMoney(-int64(qInfo->GetRewOrReqMoney())))
+                    return false;
+            }
+
+            uint32 repFacId = qInfo->GetRepObjectiveFaction();
+            if (repFacId && GetReputationMgr().GetReputation(repFacId) < qInfo->GetRepObjectiveValue())
+                return false;
+
+            return true;
+        }
+    }
+    return false;
+}
+
+bool Player::CanCompleteRepeatableQuest(Quest const* quest)
+{
+    // Solve problem that player don't have the quest and try complete it.
+    // if repeatable she must be able to complete event if player don't have it.
+    // Seem that all repeatable quest are DELIVER Flag so, no need to add more.
+    if (!CanTakeQuest(quest, false))
+        return false;
+
+    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
+        for (uint8 i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+            if (quest->RequiredItemId[i] && quest->RequiredItemCount[i] && !HasItemCount(quest->RequiredItemId[i], quest->RequiredItemCount[i]))
+                return false;
+
+    if (!CanRewardQuest(quest, false))
+        return false;
+
+    return true;
+}
+
+bool Player::CanRewardQuest(Quest const* quest, bool msg)
+{
+    // not auto complete quest and not completed quest (only cheating case, then ignore without message)
+    if (!quest->IsDFQuest() && !quest->IsAutoComplete() && (!(quest->GetFlags() & QUEST_FLAGS_AUTOCOMPLETE) || quest->IsAutoAccept()) && GetQuestStatus(quest->GetQuestId()) != QUEST_STATUS_COMPLETE)
+        return false;
+
+    // daily quest can't be rewarded (25 daily quest already completed)
+    if (!SatisfyQuestDay(quest, true) || !SatisfyQuestWeek(quest, true) || !SatisfyQuestMonth(quest, true) || !SatisfyQuestSeasonal(quest, true))
+        return false;
+
+    // rewarded and not repeatable quest (only cheating case, then ignore without message)
+    if (GetQuestRewardStatus(quest->GetQuestId()))
+        return false;
+
+    // prevent receive reward with quest items in bank
+    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
+    {
+        for (uint8 i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+        {
+            if (quest->RequiredItemCount[i]!= 0 &&
+                GetItemCount(quest->RequiredItemId[i]) < quest->RequiredItemCount[i])
+            {
+                if (msg)
+                    SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL, quest->RequiredItemId[i]);
+                return false;
+            }
+        }
+    }
+
+    for (uint8 i = 0; i < QUEST_REQUIRED_CURRENCY_COUNT; i++)
+    if (quest->RequiredCurrencyId[i] && !HasCurrency(quest->RequiredCurrencyId[i], quest->RequiredCurrencyCount[i]))
+    return false;
+
+// prevent receive reward with low money and GetRewOrReqMoney() < 0
+    if (quest->GetRewOrReqMoney() < 0 && !HasEnoughMoney(-int64(quest->GetRewOrReqMoney())))
+        return false;
+
+    return true;
+}
+
+bool Player::CanRewardQuest(Quest const* quest, uint32 reward, bool msg)
+{
+    // prevent receive reward with quest items in bank or for not completed quest
+    if (!CanRewardQuest(quest, msg))
+        return false;
+
+    if (quest->GetRewChoiceItemsCount() > 0)
+    {
+        if (quest->RewardChoiceItemId[reward])
+        {
+            ItemPosCountVec dest;
+            InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->RewardChoiceItemId[reward], quest->RewardChoiceItemCount[reward]);
+            if (res != EQUIP_ERR_OK)
+            {
+                SendEquipError(res, NULL, NULL, quest->RewardChoiceItemId[reward]);
+                return false;
+            }
+        }
+    }
+
+    if (quest->GetRewItemsCount() > 0)
+    {
+        for (uint32 i = 0; i < quest->GetRewItemsCount(); ++i)
+        {
+            if (quest->RewardItemId[i])
+            {
+                ItemPosCountVec dest;
+                InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->RewardItemId[i], quest->RewardItemIdCount[i]);
+                if (res != EQUIP_ERR_OK)
+                {
+                    SendEquipError(res, NULL, NULL, quest->RewardItemId[i]);
+                    return false;
+                }
+            }
+        }
+    }
+
+    return true;
+}
+
+void Player::AddQuest(Quest const* quest, Object* questGiver)
+{
+    uint16 log_slot = FindQuestSlot(0);
+
+    if (log_slot >= MAX_QUEST_LOG_SIZE) // Player does not have any free slot in the quest log
+        return;
+
+    uint32 quest_id = quest->GetQuestId();
+
+    // if not exist then created with set uState == NEW and rewarded=false
+    QuestStatusData& questStatusData = m_QuestStatus[quest_id];
+
+    // check for repeatable quests status reset
+    questStatusData.Status = QUEST_STATUS_INCOMPLETE;
+    questStatusData.Explored = false;
+
+    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
+    {
+        for (uint8 i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; ++i)
+            questStatusData.ItemCount[i] = 0;
+    }
+
+    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_KILL_OR_CAST | QUEST_SPECIAL_FLAGS_SPEAKTO))
+    {
+        for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
+            questStatusData.CreatureOrGOCount[i] = 0;
+    }
+
+    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_PLAYER_KILL))
+        questStatusData.PlayerCount = 0;
+
+    GiveQuestSourceItem(quest);
+    AdjustQuestReqItemCount(quest, questStatusData);
+
+    if (quest->GetRepObjectiveFaction())
+        if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(quest->GetRepObjectiveFaction()))
+            GetReputationMgr().SetVisible(factionEntry);
+
+    if (quest->GetRepObjectiveFaction2())
+        if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(quest->GetRepObjectiveFaction2()))
+            GetReputationMgr().SetVisible(factionEntry);
+
+    uint32 qtime = 0;
+    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
+    {
+        uint32 limittime = quest->GetLimitTime();
+
+        // shared timed quest
+        if (questGiver && questGiver->GetTypeId() == TYPEID_PLAYER)
+            limittime = questGiver->ToPlayer()->getQuestStatusMap()[quest_id].Timer / IN_MILLISECONDS;
+
+        AddTimedQuest(quest_id);
+        questStatusData.Timer = limittime * IN_MILLISECONDS;
+        qtime = static_cast<uint32>(time(NULL)) + limittime;
+    }
+    else
+        questStatusData.Timer = 0;
+
+    SetQuestSlot(log_slot, quest_id, qtime);
+
+    m_QuestStatusSave[quest_id] = true;
+
+    StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_QUEST, quest_id);
+
+    UpdateForQuestWorldObjects();
+
+	if (sWorld->getBoolConfig(CONFIG_QUEST_ENABLE_QUEST_TRACKER)) // check if Quest Tracker is enabled
+
+		{   
+		    // prepare Quest Tracker datas
+			PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_QUEST_TRACK);
+		    stmt->setUInt32(0, quest_id);
+		    stmt->setUInt32(1, GetGUIDLow());
+		    stmt->setString(2, _HASH);
+		    stmt->setString(3, _DATE);
+			 
+			// add to Quest Tracker
+			CharacterDatabase.Execute(stmt);
+		}
+
+    if (questGiver != NULL)
+    {
+        switch(questGiver->GetTypeId())
+        {
+            case TYPEID_PLAYER:
+                break;
+            case TYPEID_UNIT:
+                sScriptMgr->OnQuestAccept(this, (questGiver->ToCreature()), quest);
+                break;
+            case TYPEID_ITEM:
+            case TYPEID_CONTAINER:
+                sScriptMgr->OnQuestAccept(this, ((Item*)questGiver), quest);
+                break;
+            case TYPEID_GAMEOBJECT:
+                sScriptMgr->OnQuestAccept(this, ((GameObject*)questGiver), quest);
+                break;
+            default:
+                break;
+        }
+    }
+
+    if (quest->IsAutoAccept())
+        PlayerTalkClass->SendCloseGossip();
+}
+
+void Player::CompleteQuest(uint32 quest_id)
+{
+    if (quest_id)
+    {
+        SetQuestStatus(quest_id, QUEST_STATUS_COMPLETE);
+
+        uint16 log_slot = FindQuestSlot(quest_id);
+        if (log_slot < MAX_QUEST_LOG_SIZE)
+            SetQuestSlotState(log_slot, QUEST_STATE_COMPLETE);
+
+        if (Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id))
+        {
+            if (qInfo->HasFlag(QUEST_FLAGS_AUTO_REWARDED))
+            {
+                //PlayerTalkClass->SendQuestGiverOfferReward(qInfo, GetGUID(), false); // NOT GOOD BUT MORE BLIZZLIKE, NEED TO UNDERSTAND HOW CLIENT CAN POP THE RIGHT BUTTON AUTO_REWARD...
+                RewardQuest(qInfo, 0, this, false);
+                //temp hack to allow auto reward and distribute next auto_accept quests
+                //need to find how making client gui work with new auto accept / auto reward system
+                uint32 nextQuestId = qInfo->GetNextQuestInChain();
+                if (Quest const* nextQuest = sObjectMgr->GetQuestTemplate(nextQuestId))
+                {
+                    if (CanAddQuest(nextQuest, true) && CanTakeQuest(nextQuest, true, true) && (nextQuest->HasFlag(QUEST_FLAGS_AUTO_SUBMIT) || nextQuest->HasFlag(QUEST_FLAGS_AUTO_TAKE)))
+                    {
+                        if (nextQuest->IsAutoAccept())
+                        {
+                            AddQuest(nextQuest, this);
+                            if (CanCompleteQuest(nextQuest->GetQuestId()))
+                                CompleteQuest(nextQuest->GetQuestId());
+                        }
+                        PlayerTalkClass->SendQuestGiverQuestDetails(nextQuest, GetGUID(), true);
+                    }
+                }
+            }
+            else
+                SendQuestComplete(qInfo);
+            sScriptMgr->OnQuestComplete(this, qInfo);
+        }
+    }
+	if (sWorld->getBoolConfig(CONFIG_QUEST_ENABLE_QUEST_TRACKER)) // check if Quest Tracker is enabled
+		{
+		    // prepare Quest Tracker datas
+	        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_QUEST_TRACK_COMPLETE_TIME);
+		    stmt->setUInt32(0, quest_id);
+		    stmt->setUInt32(1, GetGUIDLow());
+		    
+		    // add to Quest Tracker
+		    CharacterDatabase.Execute(stmt);
+		}
+}
+
+void Player::IncompleteQuest(uint32 quest_id)
+{
+    if (quest_id)
+    {
+        SetQuestStatus(quest_id, QUEST_STATUS_INCOMPLETE);
+
+        uint16 log_slot = FindQuestSlot(quest_id);
+        if (log_slot < MAX_QUEST_LOG_SIZE)
+            RemoveQuestSlotState(log_slot, QUEST_STATE_COMPLETE);
+    }
+}
+
+void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver, bool announce)
+{
+    //this THING should be here to protect code from quest, which cast on player far teleport as a reward
+    //should work fine, cause far teleport will be executed in Player::Update()
+
+    SetCanDelayTeleport(true);
+
+    uint32 quest_id = quest->GetQuestId();
+    uint32 next_quest_id = quest->GetNextQuestId();
+
+    for (uint8 i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; ++i)
+        if (quest->RequiredItemId[i])
+            DestroyItemCount(quest->RequiredItemId[i], quest->RequiredItemCount[i], true);
+			
+    for (uint8 i = 0; i < QUEST_REQUIRED_CURRENCY_COUNT; ++i)
+        if (quest->RequiredCurrencyId[i])
+            ModifyCurrency(quest->RequiredCurrencyId[i], -int32(quest->RequiredCurrencyCount[i]));
+
+    for (uint8 i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
+    {
+        if (quest->RequiredSourceItemId[i])
+        {
+            uint32 count = quest->RequiredSourceItemCount[i];
+            DestroyItemCount(quest->RequiredSourceItemId[i], count ? count : 9999, true);
+        }
+    }
+
+    RemoveTimedQuest(quest_id);
+
+    if (quest->GetRewChoiceItemsCount() > 0)
+    {
+        if (uint32 itemId = quest->RewardChoiceItemId[reward])
+        {
+            ItemPosCountVec dest;
+            if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, quest->RewardChoiceItemCount[reward]) == EQUIP_ERR_OK)
+            {
+                Item* item = StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+                SendNewItem(item, quest->RewardChoiceItemCount[reward], true, false);
+            }
+        }
+    }
+
+    if (quest->GetRewItemsCount() > 0)
+    {
+        for (uint32 i = 0; i < quest->GetRewItemsCount(); ++i)
+        {
+            if (uint32 itemId = quest->RewardItemId[i])
+            {
+                ItemPosCountVec dest;
+                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, quest->RewardItemIdCount[i]) == EQUIP_ERR_OK)
+                {
+                    Item* item = StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+                    SendNewItem(item, quest->RewardItemIdCount[i], true, false);
+                }
+            }
+        }
+    }
+
+    for (uint8 i = 0; i < QUEST_REWARD_CURRENCY_COUNT; ++i)
+        if (quest->RewardCurrencyId[i])
+            ModifyCurrency(quest->RewardCurrencyId[i], quest->RewardCurrencyCount[i]);
+
+    if (uint32 skill = quest->GetRewardSkillId())
+        UpdateSkill(skill, quest->GetRewardSkillPoints());
+
+    RewardReputation(quest);
+
+    uint16 log_slot = FindQuestSlot(quest_id);
+    if (log_slot < MAX_QUEST_LOG_SIZE)
+        SetQuestSlot(log_slot, 0);
+
+    bool rewarded = (m_RewardedQuests.find(quest_id) != m_RewardedQuests.end());
+
+    // Not give XP in case already completed once repeatable quest
+    uint32 XP = rewarded ? 0 : uint32(quest->XPValue(this) * sWorld->getRate(RATE_XP_QUEST));
+
+    // handle SPELL_AURA_MOD_XP_QUEST_PCT auras
+    Unit::AuraEffectList const& ModXPPctAuras = GetAuraEffectsByType(SPELL_AURA_MOD_XP_QUEST_PCT);
+    for (Unit::AuraEffectList::const_iterator i = ModXPPctAuras.begin(); i != ModXPPctAuras.end(); ++i)
+        AddPct(XP, (*i)->GetAmount());
+
+    int32 moneyRew = 0;
+    if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        GiveXP(XP, NULL);
+    else
+        moneyRew = int32(quest->GetRewMoneyMaxLevel() * sWorld->getRate(RATE_DROP_MONEY));
+
+    if (Guild* guild = GetGuild())
+    {
+        uint32 _xp = quest->XPValue(this);
+        uint32 guildRep = std::max(uint32(1), uint32(_xp/450));
+        guild->GiveXP(uint32(_xp * sWorld->getRate(RATE_XP_QUEST) * sWorld->getRate(RATE_XP_QUEST_GUILD_MODIFIER)), this);
+        guild->GiveReputation(guildRep, this);
+        guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUESTS_GUILD, 0, 0, 0, NULL, this);
+    }
+
+    // Give player extra money if GetRewOrReqMoney > 0 and get ReqMoney if negative
+    if (quest->GetRewOrReqMoney())
+        moneyRew += quest->GetRewOrReqMoney();
+
+    if (moneyRew)
+    {
+        ModifyMoney(moneyRew);
+
+        if (moneyRew > 0)
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_MONEY_FROM_QUEST_REWARD, uint32(moneyRew));
+    }
+
+    // honor reward
+    if (uint32 honor = quest->CalculateHonorGain(getLevel()))
+        RewardHonor(NULL, 0, honor);
+
+    // title reward
+    if (quest->GetCharTitleId())
+    {
+        if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(quest->GetCharTitleId()))
+            SetTitle(titleEntry);
+    }
+
+    if (uint32 talents = quest->GetBonusTalents())
+    {
+        AddQuestRewardedTalentCount(talents);
+        InitTalentForLevel();
+    }
+
+    // Send reward mail
+    if (uint32 mail_template_id = quest->GetRewMailTemplateId())
+    {
+        //- TODO: Poor design of mail system
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        MailDraft(mail_template_id).SendMailTo(trans, this, questGiver, MAIL_CHECK_MASK_HAS_BODY, quest->GetRewMailDelaySecs());
+        CharacterDatabase.CommitTransaction(trans);
+    }
+
+    if (quest->IsDaily() || quest->IsDFQuest())
+    {
+        SetDailyQuestStatus(quest_id);
+        if (quest->IsDaily())
+        {
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST, quest_id);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST_DAILY, quest_id);
+            UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST, quest_id);
+        }
+    }
+    else if (quest->IsWeekly())
+        SetWeeklyQuestStatus(quest_id);
+    else if (quest->IsMonthly())
+        SetMonthlyQuestStatus(quest_id);
+    else if (quest->IsSeasonal())
+        SetSeasonalQuestStatus(quest_id);
+
+    RemoveActiveQuest(quest_id);
+    m_RewardedQuests.insert(quest_id);
+    m_RewardedQuestsSave[quest_id] = true;
+
+    PhaseUpdateData phaseUdateData;
+    phaseUdateData.AddQuestUpdate(quest_id);
+    phaseMgr.NotifyConditionChanged(phaseUdateData);
+
+    // StoreNewItem, mail reward, etc. save data directly to the database
+    // to prevent exploitable data desynchronisation we save the quest status to the database too
+    // (to prevent rewarding this quest another time while rewards were already given out)
+    SQLTransaction trans = SQLTransaction(NULL);
+    _SaveQuestStatus(trans);
+
+    if (announce)
+        SendQuestReward(quest, XP);
+
+    // cast spells after mark quest complete (some spells have quest completed state requirements in spell_area data)
+    if (quest->GetRewSpellCast() > 0)
+        CastSpell(this, quest->GetRewSpellCast(), true);
+    else if (quest->GetRewSpell() > 0)
+        CastSpell(this, quest->GetRewSpell(), true);
+
+    if (quest->GetZoneOrSort() > 0)
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUESTS_IN_ZONE, quest->GetZoneOrSort());
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUEST_COUNT);
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUEST, quest->GetQuestId());
+    UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUESTS_GUILD, 1);
+
+    //lets remove flag for delayed teleports
+    SetCanDelayTeleport(false);
+    if (next_quest_id)
+    {
+        if (Quest const* nextQuest = sObjectMgr->GetQuestTemplate(next_quest_id))
+            if (nextQuest)
+                PlayerTalkClass->SendQuestGiverQuestDetails(nextQuest, questGiver->GetGUID(), true);
+    } else PlayerTalkClass->SendCloseGossip();
+}
+
+void Player::FailQuest(uint32 questId)
+{
+    if (Quest const* quest = sObjectMgr->GetQuestTemplate(questId))
+    {
+        SetQuestStatus(questId, QUEST_STATUS_FAILED);
+
+        uint16 log_slot = FindQuestSlot(questId);
+
+        if (log_slot < MAX_QUEST_LOG_SIZE)
+        {
+            SetQuestSlotTimer(log_slot, 1);
+            SetQuestSlotState(log_slot, QUEST_STATE_FAIL);
+        }
+
+        if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
+        {
+            QuestStatusData& q_status = m_QuestStatus[questId];
+
+            RemoveTimedQuest(questId);
+            q_status.Timer = 0;
+
+            SendQuestTimerFailed(questId);
+        }
+        else
+            SendQuestFailed(questId);
+
+        // Destroy quest items on quest failure.
+        for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
+            if (quest->RequiredItemId[i] > 0 && quest->RequiredItemCount[i] > 0)
+                // Destroy items received on starting the quest.
+                DestroyItemCount(quest->RequiredItemId[i], quest->RequiredItemCount[i], true, true);
+        for (uint8 i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
+            if (quest->RequiredSourceItemId[i] > 0 && quest->RequiredSourceItemCount[i] > 0)
+                // Destroy items received during the quest.
+                DestroyItemCount(quest->RequiredSourceItemId[i], quest->RequiredSourceItemCount[i], true, true);
+    }
+}
+
+bool Player::SatisfyQuestSkill(Quest const* qInfo, bool msg) const
+{
+    uint32 skill = qInfo->GetRequiredSkill();
+
+    // skip 0 case RequiredSkill
+    if (skill == 0)
+        return true;
+
+    // check skill value
+    if (GetSkillValue(skill) < qInfo->GetRequiredSkillValue())
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+
+        return false;
+    }
+
+    return true;
+}
+
+bool Player::SatisfyQuestLevel(Quest const* qInfo, bool msg)
+{
+    if (getLevel() < qInfo->GetMinLevel())
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_QUEST_FAILED_LOW_LEVEL);
+        return false;
+    }
+    else if (qInfo->GetMaxLevel() > 0 && getLevel() > qInfo->GetMaxLevel())
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ); // There doesn't seem to be a specific response for too high player level
+        return false;
+    }
+    return true;
+}
+
+bool Player::SatisfyQuestLog(bool msg)
+{
+    // exist free slot
+    if (FindQuestSlot(0) < MAX_QUEST_LOG_SIZE)
+        return true;
+
+    if (msg)
+    {
+        WorldPacket data(SMSG_QUESTLOG_FULL, 0);
+        GetSession()->SendPacket(&data);
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_QUESTLOG_FULL");
+    }
+    return false;
+}
+
+bool Player::SatisfyQuestPreviousQuest(Quest const* qInfo, bool msg)
+{
+    // No previous quest (might be first quest in a series)
+    if (qInfo->prevQuests.empty())
+        return true;
+
+    for (Quest::PrevQuests::const_iterator iter = qInfo->prevQuests.begin(); iter != qInfo->prevQuests.end(); ++iter)
+    {
+        uint32 prevId = abs(*iter);
+
+        Quest const* qPrevInfo = sObjectMgr->GetQuestTemplate(prevId);
+
+        if (qPrevInfo)
+        {
+            // If any of the positive previous quests completed, return true
+            if (*iter > 0 && m_RewardedQuests.find(prevId) != m_RewardedQuests.end())
+            {
+                // skip one-from-all exclusive group
+                if (qPrevInfo->GetExclusiveGroup() >= 0)
+                    return true;
+
+                // each-from-all exclusive group (< 0)
+                // can be start if only all quests in prev quest exclusive group completed and rewarded
+                ObjectMgr::ExclusiveQuestGroupsBounds range(sObjectMgr->mExclusiveQuestGroups.equal_range(qPrevInfo->GetExclusiveGroup()));
+
+                // always must be found if qPrevInfo->ExclusiveGroup != 0
+                ASSERT(range.first != range.second);
+
+                for (; range.first != range.second; ++range.first)
+                {
+                    uint32 exclude_Id = range.first->second;
+
+                    // skip checked quest id, only state of other quests in group is interesting
+                    if (exclude_Id == prevId)
+                        continue;
+
+                    // alternative quest from group also must be completed and rewarded(reported)
+                    if (m_RewardedQuests.find(exclude_Id) == m_RewardedQuests.end())
+                    {
+                        if (msg)
+                            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+                        return false;
+                    }
+                }
+                return true;
+            }
+
+            // If any of the negative previous quests active, return true
+            if (*iter < 0 && GetQuestStatus(prevId) != QUEST_STATUS_NONE)
+            {
+                // skip one-from-all exclusive group
+                if (qPrevInfo->GetExclusiveGroup() >= 0)
+                    return true;
+
+                // each-from-all exclusive group (< 0)
+                // can be start if only all quests in prev quest exclusive group active
+                ObjectMgr::ExclusiveQuestGroupsBounds range(sObjectMgr->mExclusiveQuestGroups.equal_range(qPrevInfo->GetExclusiveGroup()));
+
+                // always must be found if qPrevInfo->ExclusiveGroup != 0
+                ASSERT(range.first != range.second);
+
+                for (; range.first != range.second; ++range.first)
+                {
+                    uint32 exclude_Id = range.first->second;
+
+                    // skip checked quest id, only state of other quests in group is interesting
+                    if (exclude_Id == prevId)
+                        continue;
+
+                    // alternative quest from group also must be active
+                    if (GetQuestStatus(exclude_Id) != QUEST_STATUS_NONE)
+                    {
+                        if (msg)
+                            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+                        return false;
+                    }
+                }
+                return true;
+            }
+        }
+    }
+
+    // Has only positive prev. quests in non-rewarded state
+    // and negative prev. quests in non-active state
+    if (msg)
+        SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+
+    return false;
+}
+
+bool Player::SatisfyQuestClass(Quest const* qInfo, bool msg) const
+{
+    uint32 reqClass = qInfo->GetRequiredClasses();
+
+    if (reqClass == 0)
+        return true;
+
+    if ((reqClass & getClassMask()) == 0)
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+
+        return false;
+    }
+
+    return true;
+}
+
+bool Player::SatisfyQuestRace(Quest const* qInfo, bool msg)
+{
+    uint32 reqraces = qInfo->GetRequiredRaces();
+    if (reqraces == 0)
+        return true;
+    if ((reqraces & getRaceMask()) == 0)
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_QUEST_FAILED_WRONG_RACE);
+        return false;
+    }
+    return true;
+}
+
+bool Player::SatisfyQuestReputation(Quest const* qInfo, bool msg)
+{
+    uint32 fIdMin = qInfo->GetRequiredMinRepFaction();      //Min required rep
+    if (fIdMin && GetReputationMgr().GetReputation(fIdMin) < qInfo->GetRequiredMinRepValue())
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+        return false;
+    }
+
+    uint32 fIdMax = qInfo->GetRequiredMaxRepFaction();      //Max required rep
+    if (fIdMax && GetReputationMgr().GetReputation(fIdMax) >= qInfo->GetRequiredMaxRepValue())
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+        return false;
+    }
+
+    // ReputationObjective2 does not seem to be an objective requirement but a requirement
+    // to be able to accept the quest
+    uint32 fIdObj = qInfo->GetRepObjectiveFaction2();
+    if (fIdObj && GetReputationMgr().GetReputation(fIdObj) >= qInfo->GetRepObjectiveValue2())
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+        return false;
+    }
+
+    return true;
+}
+
+bool Player::SatisfyQuestStatus(Quest const* qInfo, bool msg)
+{
+    if (GetQuestStatus(qInfo->GetQuestId()) != QUEST_STATUS_NONE)
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_QUEST_ALREADY_ON);
+        return false;
+    }
+    return true;
+}
+
+bool Player::SatisfyQuestConditions(Quest const* qInfo, bool msg)
+{
+    ConditionList conditions = sConditionMgr->GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_QUEST_ACCEPT, qInfo->GetQuestId());
+    if (!sConditionMgr->IsObjectMeetToConditions(this, conditions))
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+        sLog->outDebug(LOG_FILTER_CONDITIONSYS, "Player::SatisfyQuestConditions: conditions not met for quest %u", qInfo->GetQuestId());
+        return false;
+    }
+    return true;
+}
+
+bool Player::SatisfyQuestTimed(Quest const* qInfo, bool msg)
+{
+    if (!m_timedquests.empty() && qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_QUEST_ONLY_ONE_TIMED);
+        return false;
+    }
+    return true;
+}
+
+bool Player::SatisfyQuestExclusiveGroup(Quest const* qInfo, bool msg)
+{
+    // non positive exclusive group, if > 0 then can be start if any other quest in exclusive group already started/completed
+    if (qInfo->GetExclusiveGroup() <= 0)
+        return true;
+
+    ObjectMgr::ExclusiveQuestGroupsBounds range(sObjectMgr->mExclusiveQuestGroups.equal_range(qInfo->GetExclusiveGroup()));
+
+
+    // always must be found if qInfo->ExclusiveGroup != 0
+    if (range.first == range.second)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player::SatisfyQuestExclusiveGroup for quest %u with invalide ExclusiveGroup value %d. Skipping.", qInfo->GetQuestId(), qInfo->GetExclusiveGroup());
+        return true;
+    }
+
+    for (; range.first != range.second; ++range.first)
+    {
+        uint32 exclude_Id = range.first->second;
+
+        // skip checked quest id, only state of other quests in group is interesting
+        if (exclude_Id == qInfo->GetQuestId())
+            continue;
+
+        // not allow have daily quest if daily quest from exclusive group already recently completed
+        Quest const* Nquest = sObjectMgr->GetQuestTemplate(exclude_Id);
+        if (!SatisfyQuestDay(Nquest, false) || !SatisfyQuestWeek(Nquest, false) || !SatisfyQuestSeasonal(Nquest, false))
+        {
+            if (msg)
+                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+
+            return false;
+        }
+
+        // alternative quest already started or completed - but don't check rewarded states if both are repeatable
+        if (GetQuestStatus(exclude_Id) != QUEST_STATUS_NONE || (!(qInfo->IsRepeatable() && Nquest->IsRepeatable()) && (m_RewardedQuests.find(exclude_Id) != m_RewardedQuests.end())))
+        {
+            if (msg)
+                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+            return false;
+        }
+    }
+    return true;
+}
+
+bool Player::SatisfyQuestNextChain(Quest const* qInfo, bool msg)
+{
+    uint32 nextQuest = qInfo->GetNextQuestInChain();
+    if (!nextQuest)
+        return true;
+
+    // next quest in chain already started or completed
+    if (GetQuestStatus(nextQuest) != QUEST_STATUS_NONE) // GetQuestStatus returns QUEST_STATUS_COMPLETED for rewarded quests
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+        return false;
+    }
+
+    // check for all quests further up the chain
+    // only necessary if there are quest chains with more than one quest that can be skipped
+    //return SatisfyQuestNextChain(qInfo->GetNextQuestInChain(), msg);
+    return true;
+}
+
+bool Player::SatisfyQuestPrevChain(Quest const* qInfo, bool msg)
+{
+    // No previous quest in chain
+    if (qInfo->prevChainQuests.empty())
+        return true;
+
+    for (Quest::PrevChainQuests::const_iterator iter = qInfo->prevChainQuests.begin(); iter != qInfo->prevChainQuests.end(); ++iter)
+    {
+        QuestStatusMap::const_iterator itr = m_QuestStatus.find(*iter);
+
+        // If any of the previous quests in chain active, return false
+        if (itr != m_QuestStatus.end() && itr->second.Status != QUEST_STATUS_NONE)
+        {
+            if (msg)
+                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
+            return false;
+        }
+
+        // check for all quests further down the chain
+        // only necessary if there are quest chains with more than one quest that can be skipped
+        //if (!SatisfyQuestPrevChain(prevId, msg))
+        //    return false;
+    }
+
+    // No previous quest in chain active
+    return true;
+}
+
+bool Player::SatisfyQuestDay(Quest const* qInfo, bool msg)
+{
+    if (!qInfo->IsDaily() && !qInfo->IsDFQuest())
+        return true;
+
+    if (qInfo->IsDFQuest())
+    {
+        if (!m_DFQuests.empty())
+            return false;
+
+        return true;
+    }
+
+    bool have_slot = false;
+    for (uint32 quest_daily_idx = 0; quest_daily_idx < PLAYER_MAX_DAILY_QUESTS; ++quest_daily_idx)
+    {
+        uint32 id = GetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx);
+        if (qInfo->GetQuestId() == id)
+            return false;
+
+        if (!id)
+            have_slot = true;
+    }
+
+    if (!have_slot)
+    {
+        if (msg)
+            SendCanTakeQuestResponse(INVALIDREASON_DAILY_QUESTS_REMAINING);
+        return false;
+    }
+
+    return true;
+}
+
+bool Player::SatisfyQuestWeek(Quest const* qInfo, bool /*msg*/)
+{
+    if (!qInfo->IsWeekly() || m_weeklyquests.empty())
+        return true;
+
+    // if not found in cooldown list
+    return m_weeklyquests.find(qInfo->GetQuestId()) == m_weeklyquests.end();
+}
+
+bool Player::SatisfyQuestSeasonal(Quest const* qInfo, bool /*msg*/)
+{
+    if (!qInfo->IsSeasonal() || m_seasonalquests.empty())
+        return true;
+
+    uint16 eventId = sGameEventMgr->GetEventIdForQuest(qInfo);
+    if (m_seasonalquests.find(eventId) == m_seasonalquests.end() || m_seasonalquests[eventId].empty())
+        return true;
+
+    // if not found in cooldown list
+    return m_seasonalquests[eventId].find(qInfo->GetQuestId()) == m_seasonalquests[eventId].end();
+}
+
+bool Player::SatisfyQuestMonth(Quest const* qInfo, bool /*msg*/)
+{
+    if (!qInfo->IsMonthly() || m_monthlyquests.empty())
+        return true;
+
+    // if not found in cooldown list
+    return m_monthlyquests.find(qInfo->GetQuestId()) == m_monthlyquests.end();
+}
+
+bool Player::GiveQuestSourceItem(Quest const* quest)
+{
+    uint32 srcitem = quest->GetSrcItemId();
+    if (srcitem > 0)
+    {
+        uint32 count = quest->GetSrcItemCount();
+        if (count <= 0)
+            count = 1;
+
+        ItemPosCountVec dest;
+        InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, srcitem, count);
+        if (msg == EQUIP_ERR_OK)
+        {
+            Item* item = StoreNewItem(dest, srcitem, true);
+            SendNewItem(item, count, true, false);
+            return true;
+        }
+        // player already have max amount required item, just report success
+        else if (msg == EQUIP_ERR_ITEM_MAX_COUNT)
+            return true;
+        else
+            SendEquipError(msg, NULL, NULL, srcitem);
+        return false;
+    }
+
+    return true;
+}
+
+bool Player::TakeQuestSourceItem(uint32 questId, bool msg)
+{
+    Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
+    if (quest)
+    {
+        uint32 srcItemId = quest->GetSrcItemId();
+        ItemTemplate const* item = sObjectMgr->GetItemTemplate(srcItemId);
+
+        if (srcItemId > 0)
+        {
+            uint32 count = quest->GetSrcItemCount();
+            if (count <= 0)
+                count = 1;
+
+            // exist two cases when destroy source quest item not possible:
+            // a) non un-equippable item (equipped non-empty bag, for example)
+            // b) when quest is started from an item and item also is needed in
+            // the end as RequiredItemId
+            InventoryResult res = CanUnequipItems(srcItemId, count);
+            if (res != EQUIP_ERR_OK)
+            {
+                if (msg)
+                    SendEquipError(res, NULL, NULL, srcItemId);
+                return false;
+            }
+
+            bool destroyItem = true;
+            for (uint8 n = 0; n < QUEST_ITEM_OBJECTIVES_COUNT; ++n)
+                if (item->StartQuest == questId && srcItemId == quest->RequiredItemId[n])
+                    destroyItem = false;
+
+            if (destroyItem)
+                DestroyItemCount(srcItemId, count, true, true);
+        }
+    }
+
+    return true;
+}
+
+bool Player::GetQuestRewardStatus(uint32 quest_id) const
+{
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
+    if (qInfo)
+    {
+        // for repeatable quests: rewarded field is set after first reward only to prevent getting XP more than once
+        if (!qInfo->IsRepeatable())
+            return m_RewardedQuests.find(quest_id) != m_RewardedQuests.end();
+
+        return false;
+    }
+    return false;
+}
+
+QuestStatus Player::GetQuestStatus(uint32 quest_id) const
+{
+    if (quest_id)
+    {
+        QuestStatusMap::const_iterator itr = m_QuestStatus.find(quest_id);
+        if (itr != m_QuestStatus.end())
+            return itr->second.Status;
+
+        if (Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id))
+            if (!qInfo->IsRepeatable() && m_RewardedQuests.find(quest_id) != m_RewardedQuests.end())
+                return QUEST_STATUS_REWARDED;
+    }
+    return QUEST_STATUS_NONE;
+}
+
+bool Player::CanShareQuest(uint32 quest_id) const
+{
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
+    if (qInfo && qInfo->HasFlag(QUEST_FLAGS_SHARABLE))
+    {
+        QuestStatusMap::const_iterator itr = m_QuestStatus.find(quest_id);
+        if (itr != m_QuestStatus.end())
+            return itr->second.Status == QUEST_STATUS_INCOMPLETE;
+    }
+    return false;
+}
+
+void Player::SetQuestStatus(uint32 quest_id, QuestStatus status)
+{
+    if (sObjectMgr->GetQuestTemplate(quest_id))
+    {
+        m_QuestStatus[quest_id].Status = status;
+        m_QuestStatusSave[quest_id] = true;
+    }
+
+    PhaseUpdateData phaseUdateData;
+    phaseUdateData.AddQuestUpdate(quest_id);
+
+    phaseMgr.NotifyConditionChanged(phaseUdateData);
+
+    uint32 zone = 0, area = 0;
+
+    SpellAreaForQuestMapBounds saBounds = sSpellMgr->GetSpellAreaForQuestMapBounds(quest_id);
+    if (saBounds.first != saBounds.second)
+    {
+        GetZoneAndAreaId(zone, area);
+
+        for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
+            if (itr->second->autocast && itr->second->IsFitToRequirements(this, zone, area))
+                if (!HasAura(itr->second->spellId))
+                    CastSpell(this, itr->second->spellId, true);
+    }
+
+    saBounds = sSpellMgr->GetSpellAreaForQuestEndMapBounds(quest_id);
+    if (saBounds.first != saBounds.second)
+    {
+        if (!zone || !area)
+            GetZoneAndAreaId(zone, area);
+
+        for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
+            if (!itr->second->IsFitToRequirements(this, zone, area))
+                RemoveAurasDueToSpell(itr->second->spellId);
+    }
+
+    UpdateForQuestWorldObjects();
+}
+
+void Player::RemoveActiveQuest(uint32 quest_id)
+{
+    QuestStatusMap::iterator itr = m_QuestStatus.find(quest_id);
+    if (itr != m_QuestStatus.end())
+    {
+        m_QuestStatus.erase(itr);
+        m_QuestStatusSave[quest_id] = false;
+
+        PhaseUpdateData phaseUdateData;
+        phaseUdateData.AddQuestUpdate(quest_id);
+
+        phaseMgr.NotifyConditionChanged(phaseUdateData);
+        return;
+    }
+}
+
+void Player::RemoveRewardedQuest(uint32 quest_id)
+{
+    RewardedQuestSet::iterator rewItr = m_RewardedQuests.find(quest_id);
+    if (rewItr != m_RewardedQuests.end())
+    {
+        m_RewardedQuests.erase(rewItr);
+        m_RewardedQuestsSave[quest_id] = false;
+
+        PhaseUpdateData phaseUdateData;
+        phaseUdateData.AddQuestUpdate(quest_id);
+
+        phaseMgr.NotifyConditionChanged(phaseUdateData);
+    }
+}
+
+// not used in Trinity, but used in scripting code
+uint16 Player::GetReqKillOrCastCurrentCount(uint32 quest_id, int32 entry)
+{
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
+    if (!qInfo)
+        return 0;
+
+    for (uint8 j = 0; j < QUEST_OBJECTIVES_COUNT; ++j)
+        if (qInfo->RequiredNpcOrGo[j] == entry)
+            return m_QuestStatus[quest_id].CreatureOrGOCount[j];
+
+    return 0;
+}
+
+void Player::AdjustQuestReqItemCount(Quest const* quest, QuestStatusData& questStatusData)
+{
+    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
+    {
+        for (uint8 i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; ++i)
+        {
+            uint32 reqitemcount = quest->RequiredItemCount[i];
+            if (reqitemcount != 0)
+            {
+                uint32 curitemcount = GetItemCount(quest->RequiredItemId[i], true);
+
+                questStatusData.ItemCount[i] = std::min(curitemcount, reqitemcount);
+                m_QuestStatusSave[quest->GetQuestId()] = true;
+            }
+        }
+    }
+}
+
+uint16 Player::FindQuestSlot(uint32 quest_id) const
+{
+    for (uint16 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+        if (GetQuestSlotQuestId(i) == quest_id)
+            return i;
+
+    return MAX_QUEST_LOG_SIZE;
+}
+
+void Player::AreaExploredOrEventHappens(uint32 questId)
+{
+    if (questId)
+    {
+        uint16 log_slot = FindQuestSlot(questId);
+        if (log_slot < MAX_QUEST_LOG_SIZE)
+        {
+            QuestStatusData& q_status = m_QuestStatus[questId];
+
+            if (!q_status.Explored)
+            {
+                q_status.Explored = true;
+                m_QuestStatusSave[questId] = true;
+            }
+        }
+        if (CanCompleteQuest(questId))
+            CompleteQuest(questId);
+    }
+}
+
+//not used in Trinityd, function for external script library
+void Player::GroupEventHappens(uint32 questId, WorldObject const* pEventObject)
+{
+    if (Group* group = GetGroup())
+    {
+        for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* player = itr->getSource();
+
+            // for any leave or dead (with not released body) group member at appropriate distance
+            if (player && player->IsAtGroupRewardDistance(pEventObject) && !player->GetCorpse())
+                player->AreaExploredOrEventHappens(questId);
+        }
+    }
+    else
+        AreaExploredOrEventHappens(questId);
+}
+
+void Player::ItemAddedQuestCheck(uint32 entry, uint32 count)
+{
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        uint32 questid = GetQuestSlotQuestId(i);
+        if (questid == 0)
+            continue;
+
+        QuestStatusData& q_status = m_QuestStatus[questid];
+
+        if (q_status.Status != QUEST_STATUS_INCOMPLETE)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo || !qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
+            continue;
+
+        for (uint8 j = 0; j < QUEST_ITEM_OBJECTIVES_COUNT; ++j)
+        {
+            uint32 reqitem = qInfo->RequiredItemId[j];
+            if (reqitem == entry)
+            {
+                uint32 reqitemcount = qInfo->RequiredItemCount[j];
+                uint16 curitemcount = q_status.ItemCount[j];
+                if (curitemcount < reqitemcount)
+                {
+                    uint16 additemcount = curitemcount + count <= reqitemcount ? count : reqitemcount - curitemcount;
+                    q_status.ItemCount[j] += additemcount;
+
+                    m_QuestStatusSave[questid] = true;
+
+                    //SendQuestUpdateAddItem(qInfo, j, additemcount);
+                    // FIXME: verify if there's any packet sent updating item
+                }
+                if (CanCompleteQuest(questid))
+                    CompleteQuest(questid);
+                return;
+            }
+        }
+    }
+    UpdateForQuestWorldObjects();
+}
+
+void Player::ItemRemovedQuestCheck(uint32 entry, uint32 count)
+{
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        uint32 questid = GetQuestSlotQuestId(i);
+        if (!questid)
+            continue;
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+        if (!qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
+            continue;
+
+        for (uint8 j = 0; j < QUEST_ITEM_OBJECTIVES_COUNT; ++j)
+        {
+            uint32 reqitem = qInfo->RequiredItemId[j];
+            if (reqitem == entry)
+            {
+                QuestStatusData& q_status = m_QuestStatus[questid];
+
+                uint32 reqitemcount = qInfo->RequiredItemCount[j];
+                uint16 curitemcount;
+                if (q_status.Status != QUEST_STATUS_COMPLETE)
+                    curitemcount = q_status.ItemCount[j];
+                else
+                    curitemcount = GetItemCount(entry, true);
+                if (curitemcount < reqitemcount + count)
+                {
+                    uint16 remitemcount = curitemcount <= reqitemcount ? count : count + reqitemcount - curitemcount;
+                    q_status.ItemCount[j] = (curitemcount <= remitemcount) ? 0 : curitemcount - remitemcount;
+
+                    m_QuestStatusSave[questid] = true;
+
+                    IncompleteQuest(questid);
+                }
+                return;
+            }
+        }
+    }
+    UpdateForQuestWorldObjects();
+}
+
+void Player::KilledMonster(CreatureTemplate const* cInfo, uint64 guid)
+{
+    ASSERT(cInfo);
+
+    if (cInfo->Entry)
+        KilledMonsterCredit(cInfo->Entry, guid);
+
+    for (uint8 i = 0; i < MAX_KILL_CREDIT; ++i)
+        if (cInfo->KillCredit[i])
+            KilledMonsterCredit(cInfo->KillCredit[i], 0);
+}
+
+void Player::KilledMonsterCredit(uint32 entry, uint64 guid /*= 0*/)
+{
+    uint16 addkillcount = 1;
+    uint32 real_entry = entry;
+    if (guid)
+    {
+        Creature* killed = GetMap()->GetCreature(guid);
+        if (killed && killed->GetEntry())
+            real_entry = killed->GetEntry();
+    }
+
+    StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_CREATURE, real_entry);   // MUST BE CALLED FIRST
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE, real_entry, addkillcount, 0, guid ? GetMap()->GetCreature(guid) : NULL);
+
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        uint32 questid = GetQuestSlotQuestId(i);
+        if (!questid)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+        // just if !ingroup || !noraidgroup || raidgroup
+        QuestStatusData& q_status = m_QuestStatus[questid];
+        if (q_status.Status == QUEST_STATUS_INCOMPLETE && (!GetGroup() || !GetGroup()->isRaidGroup() || qInfo->IsAllowedInRaid(GetMap()->GetDifficulty())))
+        {
+            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_KILL_OR_CAST))
+            {
+                for (uint8 j = 0; j < QUEST_OBJECTIVES_COUNT; ++j)
+                {
+                    // skip GO activate objective or none
+                    if (qInfo->RequiredNpcOrGo[j] <= 0)
+                        continue;
+
+                    // skip Cast at creature objective
+                    if (qInfo->RequiredSpellCast[j] != 0)
+                        continue;
+
+                    uint32 reqkill = qInfo->RequiredNpcOrGo[j];
+
+                    if (reqkill == real_entry)
+                    {
+                        uint32 reqkillcount = qInfo->RequiredNpcOrGoCount[j];
+                        uint16 curkillcount = q_status.CreatureOrGOCount[j];
+                        if (curkillcount < reqkillcount)
+                        {
+                            q_status.CreatureOrGOCount[j] = curkillcount + addkillcount;
+
+                            m_QuestStatusSave[questid] = true;
+
+                            SendQuestUpdateAddCreatureOrGo(qInfo, guid, j, curkillcount, addkillcount);
+                        }
+                        if (CanCompleteQuest(questid))
+                            CompleteQuest(questid);
+
+                        // same objective target can be in many active quests, but not in 2 objectives for single quest (code optimization).
+                        break;
+                    }
+                }
+            }
+        }
+    }
+}
+
+void Player::KilledPlayerCredit()
+{
+    uint16 addkillcount = 1;
+
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        uint32 questid = GetQuestSlotQuestId(i);
+        if (!questid)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+        // just if !ingroup || !noraidgroup || raidgroup
+        QuestStatusData& q_status = m_QuestStatus[questid];
+        if (q_status.Status == QUEST_STATUS_INCOMPLETE && (!GetGroup() || !GetGroup()->isRaidGroup() || qInfo->IsAllowedInRaid(GetMap()->GetDifficulty())))
+        {
+            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_PLAYER_KILL))
+            {
+                uint32 reqkill = qInfo->GetPlayersSlain();
+                uint16 curkill = q_status.PlayerCount;
+
+                if (curkill < reqkill)
+                {
+                    q_status.PlayerCount = curkill + addkillcount;
+
+                    m_QuestStatusSave[questid] = true;
+
+                    SendQuestUpdateAddPlayer(qInfo, curkill, addkillcount);
+                }
+
+                if (CanCompleteQuest(questid))
+                    CompleteQuest(questid);
+
+                break;
+            }
+        }
+    }
+}
+
+void Player::CastedCreatureOrGO(uint32 entry, uint64 guid, uint32 spell_id)
+{
+    bool isCreature = IS_CRE_OR_VEH_GUID(guid);
+
+    uint16 addCastCount = 1;
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        uint32 questid = GetQuestSlotQuestId(i);
+        if (!questid)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+
+        QuestStatusData& q_status = m_QuestStatus[questid];
+
+        if (q_status.Status == QUEST_STATUS_INCOMPLETE)
+        {
+            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_KILL_OR_CAST))
+            {
+                for (uint8 j = 0; j < QUEST_OBJECTIVES_COUNT; ++j)
+                {
+                    // skip kill creature objective (0) or wrong spell casts
+                    if (qInfo->RequiredSpellCast[j] != spell_id)
+                        continue;
+
+                    uint32 reqTarget = 0;
+
+                    if (isCreature)
+                    {
+                        // creature activate objectives
+                        if (qInfo->RequiredNpcOrGo[j] > 0)
+                        {
+                            // checked at quest_template loading
+                            reqTarget = qInfo->RequiredNpcOrGo[j];
+                            if (reqTarget != entry) // if entry doesn't match, check for killcredits referenced in template
+                            {
+                                CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(entry);
+                                if (!cinfo)
+                                {
+                                    sLog->outError(LOG_FILTER_PLAYER, "Player::CastedCreatureOrGO: GetCreatureTemplate failed for entry %u. Skipping.", entry);
+                                    continue;
+                                }
+
+                                for (uint8 k = 0; k < MAX_KILL_CREDIT; ++k)
+                                    if (cinfo->KillCredit[k] == reqTarget)
+                                        entry = cinfo->KillCredit[k];
+                            }
+                         }
+                    }
+                    else
+                    {
+                        // GO activate objective
+                        if (qInfo->RequiredNpcOrGo[j] < 0)
+                            // checked at quest_template loading
+                            reqTarget = - qInfo->RequiredNpcOrGo[j];
+                    }
+
+                    // other not this creature/GO related objectives
+                    if (reqTarget != entry)
+                        continue;
+
+                    uint32 reqCastCount = qInfo->RequiredNpcOrGoCount[j];
+                    uint16 curCastCount = q_status.CreatureOrGOCount[j];
+                    if (curCastCount < reqCastCount)
+                    {
+                        q_status.CreatureOrGOCount[j] = curCastCount + addCastCount;
+
+                        m_QuestStatusSave[questid] = true;
+
+                        SendQuestUpdateAddCreatureOrGo(qInfo, guid, j, curCastCount, addCastCount);
+                    }
+
+                    if (CanCompleteQuest(questid))
+                        CompleteQuest(questid);
+
+                    // same objective target can be in many active quests, but not in 2 objectives for single quest (code optimization).
+                    break;
+                }
+            }
+        }
+    }
+}
+
+void Player::TalkedToCreature(uint32 entry, uint64 guid)
+{
+    uint16 addTalkCount = 1;
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        uint32 questid = GetQuestSlotQuestId(i);
+        if (!questid)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+
+        QuestStatusData& q_status = m_QuestStatus[questid];
+
+        if (q_status.Status == QUEST_STATUS_INCOMPLETE)
+        {
+            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_KILL_OR_CAST | QUEST_SPECIAL_FLAGS_SPEAKTO))
+            {
+                for (uint8 j = 0; j < QUEST_OBJECTIVES_COUNT; ++j)
+                {
+                                                            // skip spell casts and Gameobject objectives
+                    if (qInfo->RequiredSpellCast[j] > 0 || qInfo->RequiredNpcOrGo[j] < 0)
+                        continue;
+
+                    uint32 reqTarget = 0;
+
+                    if (qInfo->RequiredNpcOrGo[j] > 0)    // creature activate objectives
+                                                            // checked at quest_template loading
+                        reqTarget = qInfo->RequiredNpcOrGo[j];
+                    else
+                        continue;
+
+                    if (reqTarget == entry)
+                    {
+                        uint32 reqTalkCount = qInfo->RequiredNpcOrGoCount[j];
+                        uint16 curTalkCount = q_status.CreatureOrGOCount[j];
+                        if (curTalkCount < reqTalkCount)
+                        {
+                            q_status.CreatureOrGOCount[j] = curTalkCount + addTalkCount;
+
+                            m_QuestStatusSave[questid] = true;
+
+                            SendQuestUpdateAddCreatureOrGo(qInfo, guid, j, curTalkCount, addTalkCount);
+                        }
+                        if (CanCompleteQuest(questid))
+                            CompleteQuest(questid);
+
+                        // same objective target can be in many active quests, but not in 2 objectives for single quest (code optimization).
+                        continue;
+                    }
+                }
+            }
+        }
+    }
+}
+
+void Player::MoneyChanged(uint32 count)
+{
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        uint32 questid = GetQuestSlotQuestId(i);
+        if (!questid)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (qInfo && qInfo->GetRewOrReqMoney() < 0)
+        {
+            QuestStatusData& q_status = m_QuestStatus[questid];
+
+            if (q_status.Status == QUEST_STATUS_INCOMPLETE)
+            {
+                if (int32(count) >= -qInfo->GetRewOrReqMoney())
+                {
+                    if (CanCompleteQuest(questid))
+                        CompleteQuest(questid);
+                }
+            }
+            else if (q_status.Status == QUEST_STATUS_COMPLETE)
+            {
+                if (int32(count) < -qInfo->GetRewOrReqMoney())
+                    IncompleteQuest(questid);
+            }
+        }
+    }
+}
+
+void Player::ReputationChanged(FactionEntry const* factionEntry)
+{
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        if (uint32 questid = GetQuestSlotQuestId(i))
+        {
+            if (Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid))
+            {
+                if (qInfo->GetRepObjectiveFaction() == factionEntry->ID)
+                {
+                    QuestStatusData& q_status = m_QuestStatus[questid];
+                    if (q_status.Status == QUEST_STATUS_INCOMPLETE)
+                    {
+                        if (GetReputationMgr().GetReputation(factionEntry) >= qInfo->GetRepObjectiveValue())
+                            if (CanCompleteQuest(questid))
+                                CompleteQuest(questid);
+                    }
+                    else if (q_status.Status == QUEST_STATUS_COMPLETE)
+                    {
+                        if (GetReputationMgr().GetReputation(factionEntry) < qInfo->GetRepObjectiveValue())
+                            IncompleteQuest(questid);
+                    }
+                }
+            }
+        }
+    }
+}
+
+void Player::ReputationChanged2(FactionEntry const* factionEntry)
+{
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        if (uint32 questid = GetQuestSlotQuestId(i))
+        {
+            if (Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid))
+            {
+                if (qInfo->GetRepObjectiveFaction2() == factionEntry->ID)
+                {
+                    QuestStatusData& q_status = m_QuestStatus[questid];
+                    if (q_status.Status == QUEST_STATUS_INCOMPLETE)
+                    {
+                        if (GetReputationMgr().GetReputation(factionEntry) >= qInfo->GetRepObjectiveValue2())
+                            if (CanCompleteQuest(questid))
+                                CompleteQuest(questid);
+                    }
+                    else if (q_status.Status == QUEST_STATUS_COMPLETE)
+                    {
+                        if (GetReputationMgr().GetReputation(factionEntry) < qInfo->GetRepObjectiveValue2())
+                            IncompleteQuest(questid);
+                    }
+                }
+            }
+        }
+    }
+}
+
+bool Player::HasQuestForItem(uint32 itemid) const
+{
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        uint32 questid = GetQuestSlotQuestId(i);
+        if (questid == 0)
+            continue;
+
+        QuestStatusMap::const_iterator qs_itr = m_QuestStatus.find(questid);
+        if (qs_itr == m_QuestStatus.end())
+            continue;
+
+        QuestStatusData const& q_status = qs_itr->second;
+
+        if (q_status.Status == QUEST_STATUS_INCOMPLETE)
+        {
+            Quest const* qinfo = sObjectMgr->GetQuestTemplate(questid);
+            if (!qinfo)
+                continue;
+
+            // hide quest if player is in raid-group and quest is no raid quest
+            if (GetGroup() && GetGroup()->isRaidGroup() && !qinfo->IsAllowedInRaid(GetMap()->GetDifficulty()))
+                if (!InBattleground()) //there are two ways.. we can make every bg-quest a raidquest, or add this code here.. i don't know if this can be exploited by other quests, but i think all other quests depend on a specific area.. but keep this in mind, if something strange happens later
+                    continue;
+
+            // There should be no mixed ReqItem/ReqSource drop
+            // This part for ReqItem drop
+            for (uint8 j = 0; j < QUEST_ITEM_OBJECTIVES_COUNT; ++j)
+            {
+                if (itemid == qinfo->RequiredItemId[j] && q_status.ItemCount[j] < qinfo->RequiredItemCount[j])
+                    return true;
+            }
+            // This part - for ReqSource
+            for (uint8 j = 0; j < QUEST_SOURCE_ITEM_IDS_COUNT; ++j)
+            {
+                // examined item is a source item
+                if (qinfo->RequiredSourceItemId[j] == itemid)
+                {
+                    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itemid);
+
+                    // 'unique' item
+                    if (pProto->MaxCount && int32(GetItemCount(itemid, true)) < pProto->MaxCount)
+                        return true;
+
+                    // allows custom amount drop when not 0
+                    if (qinfo->RequiredSourceItemCount[j])
+                    {
+                        if (GetItemCount(itemid, true) < qinfo->RequiredSourceItemCount[j])
+                            return true;
+                    } else if (GetItemCount(itemid, true) < pProto->GetMaxStackSize())
+                        return true;
+                }
+            }
+        }
+    }
+    return false;
+}
+
+void Player::SendQuestComplete(Quest const* quest)
+{
+    if (quest)
+    {
+        WorldPacket data(SMSG_QUESTUPDATE_COMPLETE, 4);
+        data << uint32(quest->GetQuestId());
+        GetSession()->SendPacket(&data);
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_QUESTUPDATE_COMPLETE quest = %u", quest->GetQuestId());
+    }
+}
+
+void Player::SendQuestReward(Quest const* quest, uint32 XP)
+{
+    uint32 questId = quest->GetQuestId();
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_QUESTGIVER_QUEST_COMPLETE quest = %u", questId);
+    sGameEventMgr->HandleQuestComplete(questId);
+
+    uint32 xp;
+    uint32 moneyReward;
+
+    if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+    {
+        xp = XP;
+        moneyReward = quest->GetRewOrReqMoney();
+    }
+    else // At max level, increase gold reward
+    {
+        xp = 0;
+        moneyReward = uint32(quest->GetRewOrReqMoney() + int32(quest->GetRewMoneyMaxLevel() * sWorld->getRate(RATE_DROP_MONEY)));
+    }
+
+    WorldPacket data(SMSG_QUESTGIVER_QUEST_COMPLETE, (4+4+4+4+4));
+
+    data << uint32(quest->GetBonusTalents());              // bonus talents (not verified for 4.x)
+    data << uint32(quest->GetRewardSkillPoints());         // 4.x bonus skill points
+    data << uint32(moneyReward);
+    data << uint32(xp);
+    data << uint32(questId);
+    data << uint32(quest->GetRewardSkillId());             // 4.x bonus skill id
+
+    data.WriteBit(0);                                      // FIXME: unknown bits, common values sent
+    data.WriteBit(1);
+    data.FlushBits();
+
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendQuestFailed(uint32 questId, InventoryResult reason)
+{
+    if (questId)
+    {
+        WorldPacket data(SMSG_QUESTGIVER_QUEST_FAILED, 4 + 4);
+        data << uint32(questId);
+        data << uint32(reason);                             // failed reason (valid reasons: 4, 16, 50, 17, 74, other values show default message)
+        GetSession()->SendPacket(&data);
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_QUESTGIVER_QUEST_FAILED");
+    }
+}
+
+void Player::SendQuestTimerFailed(uint32 quest_id)
+{
+    if (quest_id)
+    {
+        WorldPacket data(SMSG_QUESTUPDATE_FAILEDTIMER, 4);
+        data << uint32(quest_id);
+        GetSession()->SendPacket(&data);
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_QUESTUPDATE_FAILEDTIMER");
+    }
+}
+
+void Player::SendCanTakeQuestResponse(uint32 msg) const
+{
+    WorldPacket data(SMSG_QUESTGIVER_QUEST_INVALID, 4);
+    data << uint32(msg);
+    GetSession()->SendPacket(&data);
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_QUESTGIVER_QUEST_INVALID");
+}
+
+void Player::SendQuestConfirmAccept(const Quest* quest, Player* pReceiver)
+{
+    if (pReceiver)
+    {
+        std::string strTitle = quest->GetTitle();
+
+        int loc_idx = pReceiver->GetSession()->GetSessionDbLocaleIndex();
+        if (loc_idx >= 0)
+            if (const QuestLocale* pLocale = sObjectMgr->GetQuestLocale(quest->GetQuestId()))
+                ObjectMgr::GetLocaleString(pLocale->Title, loc_idx, strTitle);
+
+        WorldPacket data(SMSG_QUEST_CONFIRM_ACCEPT, (4 + strTitle.size() + 8));
+        data << uint32(quest->GetQuestId());
+        data << strTitle;
+        data << uint64(GetGUID());
+        pReceiver->GetSession()->SendPacket(&data);
+
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_QUEST_CONFIRM_ACCEPT");
+    }
+}
+
+void Player::SendPushToPartyResponse(Player* player, uint32 msg)
+{
+    if (player)
+    {
+        WorldPacket data(MSG_QUEST_PUSH_RESULT, (8+1));
+        data << uint64(player->GetGUID());
+        data << uint8(msg);                                 // valid values: 0-8
+        GetSession()->SendPacket(&data);
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent MSG_QUEST_PUSH_RESULT");
+    }
+}
+
+void Player::SendQuestUpdateAddCreatureOrGo(Quest const* quest, uint64 guid, uint32 creatureOrGO_idx, uint16 old_count, uint16 add_count)
+{
+    ASSERT(old_count + add_count < 65536 && "mob/GO count store in 16 bits 2^16 = 65536 (0..65536)");
+
+    int32 entry = quest->RequiredNpcOrGo[ creatureOrGO_idx ];
+    if (entry < 0)
+        // client expected gameobject template id in form (id|0x80000000)
+        entry = (-entry) | 0x80000000;
+
+    WorldPacket data(SMSG_QUESTUPDATE_ADD_KILL, (4*4+8));
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_QUESTUPDATE_ADD_KILL");
+    data << uint32(quest->GetQuestId());
+    data << uint32(entry);
+    data << uint32(old_count + add_count);
+    data << uint32(quest->RequiredNpcOrGoCount[ creatureOrGO_idx ]);
+    data << uint64(guid);
+    GetSession()->SendPacket(&data);
+
+    uint16 log_slot = FindQuestSlot(quest->GetQuestId());
+    if (log_slot < MAX_QUEST_LOG_SIZE)
+        SetQuestSlotCounter(log_slot, creatureOrGO_idx, GetQuestSlotCounter(log_slot, creatureOrGO_idx)+add_count);
+}
+
+void Player::SendQuestUpdateAddPlayer(Quest const* quest, uint16 old_count, uint16 add_count)
+{
+    ASSERT(old_count + add_count < 65536 && "player count store in 16 bits");
+
+    WorldPacket data(SMSG_QUESTUPDATE_ADD_PVP_KILL, (3*4));
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_QUESTUPDATE_ADD_PVP_KILL");
+    data << uint32(quest->GetQuestId());
+    data << uint32(old_count + add_count);
+    data << uint32(quest->GetPlayersSlain());
+    GetSession()->SendPacket(&data);
+
+    uint16 log_slot = FindQuestSlot(quest->GetQuestId());
+    if (log_slot < MAX_QUEST_LOG_SIZE)
+        SetQuestSlotCounter(log_slot, QUEST_PVP_KILL_SLOT, GetQuestSlotCounter(log_slot, QUEST_PVP_KILL_SLOT) + add_count);
+}
+
+/*********************************************************/
+/***                   LOAD SYSTEM                     ***/
+/*********************************************************/
+
+void Player::Initialize(uint32 guid)
+{
+    Object::_Create(guid, 0, HIGHGUID_PLAYER);
+}
+
+void Player::_LoadDeclinedNames(PreparedQueryResult result)
+{
+    if (!result)
+        return;
+
+    delete m_declinedname;
+    m_declinedname = new DeclinedName;
+    for (uint8 i = 0; i < MAX_DECLINED_NAME_CASES; ++i)
+        m_declinedname->name[i] = (*result)[i].GetString();
+}
+
+void Player::_LoadArenaTeamInfo(PreparedQueryResult result)
+{
+    // arenateamid, played_week, played_season, personal_rating
+    memset((void*)&m_uint32Values[PLAYER_FIELD_ARENA_TEAM_INFO_1_1], 0, sizeof(uint32) * MAX_ARENA_SLOT * ARENA_TEAM_END);
+
+    for (uint8 i = 0; i < MAX_ARENA_SLOT; i++)
+        _arenaTeamInfoSlot[i] = 0;
+
+    uint16 teamInfoCache[MAX_ARENA_SLOT][ARENA_TEAM_END];
+    for (uint8 slot = 0; slot < MAX_ARENA_SLOT; slot++)
+        for (uint8 info = 0; info < MAX_ARENA_SLOT; info++)
+            teamInfoCache[slot][info] = 0;
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+
+            uint32 arenaTeamId = fields[0].GetUInt32();
+
+            ArenaTeam* arenaTeam = sArenaTeamMgr->GetArenaTeamById(arenaTeamId);
+            if (!arenaTeam)
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadArenaTeamInfo: couldn't load arenateam %u", arenaTeamId);
+                continue;
+            }
+
+            uint8 arenaSlot = arenaTeam->GetSlot();
+
+            teamInfoCache[arenaSlot][ARENA_TEAM_ID] = arenaTeamId;
+            teamInfoCache[arenaSlot][ARENA_TEAM_TYPE] =  arenaTeam->GetType();
+            teamInfoCache[arenaSlot][ARENA_TEAM_MEMBER] = (arenaTeam->GetCaptain() == GetGUID()) ? 0 : 1;
+            teamInfoCache[arenaSlot][ARENA_TEAM_GAMES_WEEK] = uint32(fields[1].GetUInt16());
+            teamInfoCache[arenaSlot][ARENA_TEAM_GAMES_SEASON] = uint32(fields[2].GetUInt16());
+            teamInfoCache[arenaSlot][ARENA_TEAM_WINS_SEASON] = uint32(fields[3].GetUInt16());
+            teamInfoCache[arenaSlot][ARENA_TEAM_PERSONAL_RATING] = fields[4].GetUInt16();
+        }
+        while (result->NextRow());
+    }
+
+    uint8 realSlot = 0;
+    uint8 lastSlot = 2;
+    for (uint8 currSlot = 0;  currSlot < MAX_ARENA_SLOT; currSlot++)
+    {
+        if (teamInfoCache[currSlot][ARENA_TEAM_TYPE] > 0)
+        {
+            _arenaTeamInfoSlot[currSlot] = realSlot++;
+            for (uint8 info = 0; info < ARENA_TEAM_END; info++)
+                SetArenaTeamInfoField(currSlot, ArenaTeamInfoType(info), teamInfoCache[currSlot][info]);
+        }
+        else
+            _arenaTeamInfoSlot[currSlot] = lastSlot--;
+    }
+}
+
+void Player::SetInArenaTeam(uint32 ArenaTeamId, uint8 slot, uint8 type)
+{
+    for (uint8 currSlot = 0;  currSlot < MAX_ARENA_SLOT; currSlot++)
+    {
+        uint8 currSlotType = GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (currSlot * ARENA_TEAM_END) + ARENA_TEAM_TYPE);
+        if (currSlotType == 0)
+        {
+            for (uint8 currRealSlot = 0; currRealSlot < MAX_ARENA_SLOT; currRealSlot++)
+                if (_arenaTeamInfoSlot[currRealSlot] == currSlot)
+                    _arenaTeamInfoSlot[currRealSlot] = _arenaTeamInfoSlot[slot];
+
+            _arenaTeamInfoSlot[slot] = currSlot;
+            SetArenaTeamInfoField(slot, ARENA_TEAM_ID, ArenaTeamId);
+            SetArenaTeamInfoField(slot, ARENA_TEAM_TYPE, type);
+            break;
+        }
+    }
+}
+
+void Player::DeleteArenaTeam(uint8 slot, bool update)
+{
+    if (_arenaTeamInfoSlot[slot] == 2)
+    {
+        for (uint8 info = 0; info < ARENA_TEAM_END; info++)
+            SetArenaTeamInfoField(slot, ArenaTeamInfoType(info), 0);
+
+        return;
+    }
+
+    for (uint8 currSlot = _arenaTeamInfoSlot[slot];  currSlot < 2; currSlot++)
+    {
+        for (uint8 info = 0; info < ARENA_TEAM_END; info++)
+        {
+            uint32 value = GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + ((currSlot+1) * ARENA_TEAM_END) + info);
+            SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (currSlot * ARENA_TEAM_END) + info, value);
+        }
+    }
+
+    for (uint8 currSlot = 0;  currSlot < MAX_ARENA_SLOT; currSlot++)
+        if (_arenaTeamInfoSlot[currSlot] > _arenaTeamInfoSlot[slot])
+            --_arenaTeamInfoSlot[currSlot];
+
+    _arenaTeamInfoSlot[slot] = 2;
+    for (uint8 info = 0; info < ARENA_TEAM_END; info++)
+        SetArenaTeamInfoField(slot, ArenaTeamInfoType(info), 0);
+
+    if (!update)
+        return;
+
+    UpdateData udata(GetMapId());
+    WorldPacket packet;
+    BuildValuesUpdateBlockForPlayer(&udata, this);
+    udata.BuildPacket(&packet);
+    GetSession()->SendPacket(&packet);
+
+    for (uint8 currSlot = 0;  currSlot < MAX_ARENA_SLOT; currSlot++)
+    {
+        if (ArenaTeam* arenaTeam = sArenaTeamMgr->GetArenaTeamById(GetArenaTeamId(currSlot)))
+        {
+            arenaTeam->Query(GetSession());
+            arenaTeam->SendStats(GetSession());
+        }
+    }
+}
+
+void Player::_LoadEquipmentSets(PreparedQueryResult result)
+{
+    // SetPQuery(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS,   "SELECT setguid, setindex, name, iconname, item0, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10, item11, item12, item13, item14, item15, item16, item17, item18 FROM character_equipmentsets WHERE guid = '%u' ORDER BY setindex", GUID_LOPART(m_guid));
+    if (!result)
+        return;
+
+    uint32 count = 0;
+    do
+    {
+        Field* fields = result->Fetch();
+        EquipmentSet eqSet;
+
+        eqSet.Guid      = fields[0].GetUInt64();
+        uint8 index    = fields[1].GetUInt8();
+        eqSet.Name      = fields[2].GetString();
+        eqSet.IconName  = fields[3].GetString();
+        eqSet.IgnoreMask = fields[4].GetUInt32();
+        eqSet.state     = EQUIPMENT_SET_UNCHANGED;
+
+        for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
+            eqSet.Items[i] = fields[5+i].GetUInt32();
+
+        m_EquipmentSets[index] = eqSet;
+
+        ++count;
+
+        if (count >= MAX_EQUIPMENT_SET_INDEX)                // client limit
+            break;
+    }
+    while (result->NextRow());
+}
+
+void Player::_LoadBGData(PreparedQueryResult result)
+{
+    if (!result)
+        return;
+
+    Field* fields = result->Fetch();
+    // Expecting only one row
+    //        0           1     2      3      4      5      6          7          8        9
+    // SELECT instanceId, team, joinX, joinY, joinZ, joinO, joinMapId, taxiStart, taxiEnd, mountSpell FROM character_battleground_data WHERE guid = ?
+
+    m_bgData.bgInstanceID = fields[0].GetUInt32();
+    m_bgData.bgTeam       = fields[1].GetUInt16();
+    m_bgData.joinPos      = WorldLocation(fields[6].GetUInt16(),    // Map
+                                          fields[2].GetFloat(),     // X
+                                          fields[3].GetFloat(),     // Y
+                                          fields[4].GetFloat(),     // Z
+                                          fields[5].GetFloat());    // Orientation
+    m_bgData.taxiPath[0]  = fields[7].GetUInt32();
+    m_bgData.taxiPath[1]  = fields[8].GetUInt32();
+    m_bgData.mountSpell   = fields[9].GetUInt32();
+}
+
+bool Player::LoadPositionFromDB(uint32& mapid, float& x, float& y, float& z, float& o, bool& in_flight, uint64 guid)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (!result)
+        return false;
+
+    Field* fields = result->Fetch();
+
+    x = fields[0].GetFloat();
+    y = fields[1].GetFloat();
+    z = fields[2].GetFloat();
+    o = fields[3].GetFloat();
+    mapid = fields[4].GetUInt16();
+    in_flight = !fields[5].GetString().empty();
+
+    return true;
+}
+
+void Player::SetHomebind(WorldLocation const& loc, uint32 areaId)
+{
+    loc.GetPosition(m_homebindX, m_homebindY, m_homebindZ);
+    m_homebindMapId = loc.GetMapId();
+    m_homebindAreaId = areaId;
+
+    // update sql homebind
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_HOMEBIND);
+    stmt->setUInt16(0, m_homebindMapId);
+    stmt->setUInt16(1, m_homebindAreaId);
+    stmt->setFloat (2, m_homebindX);
+    stmt->setFloat (3, m_homebindY);
+    stmt->setFloat (4, m_homebindZ);
+    stmt->setUInt32(5, GetGUIDLow());
+    CharacterDatabase.Execute(stmt);
+}
+
+uint32 Player::GetUInt32ValueFromArray(Tokenizer const& data, uint16 index)
+{
+    if (index >= data.size())
+        return 0;
+
+    return (uint32)atoi(data[index]);
+}
+
+float Player::GetFloatValueFromArray(Tokenizer const& data, uint16 index)
+{
+    float result;
+    uint32 temp = Player::GetUInt32ValueFromArray(data, index);
+    memcpy(&result, &temp, sizeof(result));
+
+    return result;
+}
+
+bool Player::isBeingLoaded() const
+{
+    return GetSession()->PlayerLoading();
+}
+
+bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
+{
+    ////                                                     0     1        2     3     4        5      6    7      8     9           10              11
+    //QueryResult* result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, gender, level, xp, money, playerBytes, playerBytes2, playerFlags, "
+     // 12          13          14          15   16           17        18        19         20         21          22           23                 24
+    //"position_x, position_y, position_z, map, orientation, taximask, cinematic, totaltime, leveltime, rest_bonus, logout_time, is_logout_resting, resettalents_cost, "
+    // 25                 26          27       28       29       30       31         32           33            34        35    36      37                 38         39
+    //"resettalents_time, talentTree, trans_x, trans_y, trans_z, trans_o, transguid, extra_flags, stable_slots, at_login, zone, online, death_expire_time, taxi_path, instance_mode_mask, "
+    //    40           41          42              43           44            45
+    //"totalKills, todayKills, yesterdayKills, chosenTitle, watchedFaction, drunk, "
+    // 46      47      48      49      50      51      52           53         54          55             56
+    //"health, power1, power2, power3, power4, power5, instance_id, speccount, activespec, exploredZones, equipmentCache, "
+    // 57           58          59
+    //"knownTitles, actionBars, grantableLevels FROM characters WHERE guid = '%u'", guid);
+    PreparedQueryResult result = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_FROM);
+    if (!result)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) not found in table `characters`, can't load. ", guid);
+        return false;
+    }
+
+    Field* fields = result->Fetch();
+
+    uint32 dbAccountId = fields[1].GetUInt32();
+
+    // check if the character's account in the db and the logged in account match.
+    // player should be able to load/delete character only with correct account!
+    if (dbAccountId != GetSession()->GetAccountId())
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) loading from wrong account (is: %u, should be: %u)", guid, GetSession()->GetAccountId(), dbAccountId);
+        return false;
+    }
+
+    if (holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_BANNED))
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) is banned, can't load.", guid);
+        return false;
+    }
+
+    Object::_Create(guid, 0, HIGHGUID_PLAYER);
+
+    m_name = fields[2].GetString();
+
+    // check name limitations
+    if (ObjectMgr::CheckPlayerName(m_name) != CHAR_NAME_SUCCESS ||
+        (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()) && sObjectMgr->IsReservedName(m_name)))
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ADD_AT_LOGIN_FLAG);
+        stmt->setUInt16(0, uint16(AT_LOGIN_RENAME));
+        stmt->setUInt32(1, guid);
+        CharacterDatabase.Execute(stmt);
+        return false;
+    }
+
+    GetArcheologyMgr().LoadArcheologyDigSites(guid);
+
+    // overwrite possible wrong/corrupted guid
+    SetUInt64Value(OBJECT_FIELD_GUID, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER));
+
+    uint8 Gender = fields[5].GetUInt8();
+    if (!IsValidGender(Gender))
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) has wrong gender (%hu), can't be loaded.", guid, Gender);
+        return false;
+    }
+
+    // overwrite some data fields
+    uint32 bytes0 = 0;
+    bytes0 |= fields[3].GetUInt8();                         // race
+    bytes0 |= fields[4].GetUInt8() << 8;                    // class
+    bytes0 |= Gender << 16;                                 // gender
+    SetUInt32Value(UNIT_FIELD_BYTES_0, bytes0);
+
+    SetUInt32Value(UNIT_FIELD_LEVEL, fields[6].GetUInt8());
+    SetUInt32Value(PLAYER_XP, fields[7].GetUInt32());
+
+    _LoadIntoDataField(fields[55].GetCString(), PLAYER_EXPLORED_ZONES_1, PLAYER_EXPLORED_ZONES_SIZE);
+    _LoadIntoDataField(fields[57].GetCString(), PLAYER__FIELD_KNOWN_TITLES, KNOWN_TITLES_SIZE*2);
+
+    SetObjectScale(1.0f); 
+    SetFloatValue(UNIT_FIELD_HOVERHEIGHT, 1.0f);
+
+    // load achievements before anything else to prevent multiple gains for the same achievement/criteria on every loading (as loading does call UpdateAchievementCriteria)
+    m_achievementMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ACHIEVEMENTS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CRITERIA_PROGRESS));
+
+    uint64 money = fields[8].GetUInt64();
+    if (money > MAX_MONEY_AMOUNT)
+        money = MAX_MONEY_AMOUNT;
+    SetMoney(money);
+
+    SetUInt32Value(PLAYER_BYTES, fields[9].GetUInt32());
+    SetUInt32Value(PLAYER_BYTES_2, fields[10].GetUInt32());
+    SetByteValue(PLAYER_BYTES_3, 0, fields[5].GetUInt8());
+    SetByteValue(PLAYER_BYTES_3, 1, fields[45].GetUInt8());
+    SetUInt32Value(PLAYER_FLAGS, fields[11].GetUInt32());
+    SetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, fields[44].GetUInt32());
+
+    // set which actionbars the client has active - DO NOT REMOVE EVER AGAIN (can be changed though, if it does change fieldwise)
+    SetByteValue(PLAYER_FIELD_BYTES, 2, fields[58].GetUInt8());
+
+	_currentPetSlot = (PetSlot)fields[60].GetUInt8();
+    InitDisplayIds();
+
+    // cleanup inventory related item value fields (its will be filled correctly in _LoadInventory)
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        SetUInt64Value(PLAYER_FIELD_INV_SLOT_HEAD + (slot * 2), 0);
+        SetVisibleItemSlot(slot, NULL);
+
+        delete m_items[slot];
+        m_items[slot] = NULL;
+    }
+
+    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Load Basic value of player %s is: ", m_name.c_str());
+    outDebugValues();
+
+    //Need to call it to initialize m_team (m_team can be calculated from race)
+    //Other way is to saves m_team into characters table.
+    setFactionForRace(getRace());
+    SetByteValue(PLAYER_BYTES_3, 3, GetTeam() == ALLIANCE);      // BattlefieldArenaFaction (0 or 1) set standart
+
+    // load home bind and check in same time class/race pair, it used later for restore broken positions
+    if (!_LoadHomeBind(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_HOME_BIND)))
+        return false;
+
+    InitPrimaryProfessions();                               // to max set before any spell loaded
+
+    // init saved position, and fix it later if problematic
+    uint32 transGUID = uint32(fields[31].GetUInt32());
+
+    Relocate(fields[12].GetFloat(), fields[13].GetFloat(), fields[14].GetFloat(), fields[16].GetFloat());
+
+    uint32 mapId = fields[15].GetUInt16();
+    uint32 instanceId = fields[52].GetUInt32();
+
+    uint32 dungeonDiff = fields[39].GetUInt8() & 0x0F;
+    if (dungeonDiff >= MAX_DUNGEON_DIFFICULTY)
+        dungeonDiff = DUNGEON_DIFFICULTY_NORMAL;
+    uint32 raidDiff = (fields[39].GetUInt8() >> 4) & 0x0F;
+    if (raidDiff >= MAX_RAID_DIFFICULTY)
+        raidDiff = RAID_DIFFICULTY_10MAN_NORMAL;
+    SetDungeonDifficulty(Difficulty(dungeonDiff));          // may be changed in _LoadGroup
+    SetRaidDifficulty(Difficulty(raidDiff));                // may be changed in _LoadGroup
+
+    std::string taxi_nodes = fields[38].GetString();
+
+#define RelocateToHomebind(){ mapId = m_homebindMapId; instanceId = 0; Relocate(m_homebindX, m_homebindY, m_homebindZ); }
+
+    _LoadGroup(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GROUP));
+
+    _LoadArenaTeamInfo(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARENA_INFO));
+
+    // check arena teams integrity
+    for (uint32 arena_slot = 0; arena_slot < MAX_ARENA_SLOT; ++arena_slot)
+    {
+        uint32 arena_team_id = GetArenaTeamId(arena_slot);
+        if (!arena_team_id)
+            continue;
+
+        if (ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(arena_team_id))
+            if (at->IsMember(GetGUID()))
+                continue;
+
+        // arena team not exist or not member, cleanup fields
+        DeleteArenaTeam(arena_slot);
+    }
+
+    _LoadCurrency(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CURRENCY));
+    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, fields[40].GetUInt32());
+    SetUInt16Value(PLAYER_FIELD_KILLS, 0, fields[41].GetUInt16());
+    SetUInt16Value(PLAYER_FIELD_KILLS, 1, fields[42].GetUInt16());
+
+    _LoadBoundInstances(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_BOUND_INSTANCES));
+    _LoadInstanceTimeRestrictions(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_INSTANCE_LOCK_TIMES));
+    _LoadBGData(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_BG_DATA));
+
+    GetSession()->SetPlayer(this);
+    MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);
+    if (!mapEntry || !IsPositionValid())
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid coordinates (MapId: %u X: %f Y: %f Z: %f O: %f). Teleport to default race/class locations.", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
+        RelocateToHomebind();
+    }
+    // Player was saved in Arena or Bg
+    else if (mapEntry && mapEntry->IsBattlegroundOrArena())
+    {
+        Battleground* currentBg = NULL;
+        if (m_bgData.bgInstanceID)                                                //saved in Battleground
+            currentBg = sBattlegroundMgr->GetBattleground(m_bgData.bgInstanceID, BATTLEGROUND_TYPE_NONE);
+
+        bool player_at_bg = currentBg && currentBg->IsPlayerInBattleground(GetGUID());
+
+        if (player_at_bg && currentBg->GetStatus() != STATUS_WAIT_LEAVE)
+        {
+            BattlegroundQueueTypeId bgQueueTypeId = sBattlegroundMgr->BGQueueTypeId(currentBg->GetTypeID(), currentBg->GetArenaType());
+            AddBattlegroundQueueId(bgQueueTypeId);
+
+            m_bgData.bgTypeID = currentBg->GetTypeID();
+
+            //join player to battleground group
+            currentBg->EventPlayerLoggedIn(this);
+            currentBg->AddOrSetPlayerToCorrectBgGroup(this, m_bgData.bgTeam);
+
+            SetInviteForBattlegroundQueueType(bgQueueTypeId, currentBg->GetInstanceID());
+        }
+        // Bg was not found - go to Entry Point
+        else
+        {
+            // leave bg
+            if (player_at_bg)
+                currentBg->RemovePlayerAtLeave(GetGUID(), false, true);
+
+            // Do not look for instance if bg not found
+            const WorldLocation& _loc = GetBattlegroundEntryPoint();
+            mapId = _loc.GetMapId(); instanceId = 0;
+
+            // Db field type is type int16, so it can never be MAPID_INVALID
+            //if (mapId == MAPID_INVALID) -- code kept for reference
+            if (int16(mapId) == int16(-1)) // Battleground Entry Point not found (???)
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) was in BG in database, but BG was not found, and entry point was invalid! Teleport to default race/class locations.", guid);
+                RelocateToHomebind();
+            }
+            else
+                Relocate(&_loc);
+
+            // We are not in BG anymore
+            m_bgData.bgInstanceID = 0;
+        }
+    }
+    // currently we do not support transport in bg
+    else if (transGUID)
+    {
+        m_movementInfo.t_guid = MAKE_NEW_GUID(transGUID, 0, HIGHGUID_MO_TRANSPORT);
+        m_movementInfo.t_pos.Relocate(fields[27].GetFloat(), fields[28].GetFloat(), fields[29].GetFloat(), fields[30].GetFloat());
+
+        if (!Trinity::IsValidMapCoord(
+            GetPositionX()+m_movementInfo.t_pos.m_positionX, GetPositionY()+m_movementInfo.t_pos.m_positionY,
+            GetPositionZ()+m_movementInfo.t_pos.m_positionZ, GetOrientation()+m_movementInfo.t_pos.GetOrientation()) ||
+            // transport size limited
+            m_movementInfo.t_pos.m_positionX > 250 || m_movementInfo.t_pos.m_positionY > 250 || m_movementInfo.t_pos.m_positionZ > 250)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid transport coordinates (X: %f Y: %f Z: %f O: %f). Teleport to bind location.",
+                guid, GetPositionX()+m_movementInfo.t_pos.m_positionX, GetPositionY()+m_movementInfo.t_pos.m_positionY,
+                GetPositionZ()+m_movementInfo.t_pos.m_positionZ, GetOrientation()+m_movementInfo.t_pos.GetOrientation());
+
+            RelocateToHomebind();
+        }
+        else
+        {
+            for (MapManager::TransportSet::iterator iter = sMapMgr->m_Transports.begin(); iter != sMapMgr->m_Transports.end(); ++iter)
+            {
+                if ((*iter)->GetGUIDLow() == transGUID)
+                {
+                    m_transport = *iter;
+                    m_transport->AddPassenger(this);
+                    mapId = (m_transport->GetMapId());
+                    break;
+                }
+            }
+            if (!m_transport)
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have problems with transport guid (%u). Teleport to bind location.",
+                    guid, transGUID);
+
+                RelocateToHomebind();
+            }
+        }
+    }
+    // currently we do not support taxi in instance
+    else if (!taxi_nodes.empty())
+    {
+        instanceId = 0;
+
+        // Not finish taxi flight path
+        if (m_bgData.HasTaxiPath())
+        {
+            for (int i = 0; i < 2; ++i)
+                m_taxi.AddTaxiDestination(m_bgData.taxiPath[i]);
+        }
+        else if (!m_taxi.LoadTaxiDestinationsFromString(taxi_nodes, GetTeam()))
+        {
+            // problems with taxi path loading
+            TaxiNodesEntry const* nodeEntry = NULL;
+            if (uint32 node_id = m_taxi.GetTaxiSource())
+                nodeEntry = sTaxiNodesStore.LookupEntry(node_id);
+
+            if (!nodeEntry)                                      // don't know taxi start node, to homebind
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Character %u have wrong data in taxi destination list, teleport to homebind.", GetGUIDLow());
+                RelocateToHomebind();
+            }
+            else                                                // have start node, to it
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Character %u have too short taxi destination list, teleport to original node.", GetGUIDLow());
+                mapId = nodeEntry->map_id;
+                Relocate(nodeEntry->x, nodeEntry->y, nodeEntry->z, 0.0f);
+            }
+            m_taxi.ClearTaxiDestinations();
+        }
+
+        if (uint32 node_id = m_taxi.GetTaxiSource())
+        {
+            // save source node as recall coord to prevent recall and fall from sky
+            TaxiNodesEntry const* nodeEntry = sTaxiNodesStore.LookupEntry(node_id);
+            if (nodeEntry && nodeEntry->map_id == GetMapId())
+            {
+                ASSERT(nodeEntry);                                  // checked in m_taxi.LoadTaxiDestinationsFromString
+                mapId = nodeEntry->map_id;
+                Relocate(nodeEntry->x, nodeEntry->y, nodeEntry->z, 0.0f);
+            }
+
+            // flight will started later
+        }
+    }
+
+    // Map could be changed before
+    mapEntry = sMapStore.LookupEntry(mapId);
+    // client without expansion support
+    if (mapEntry)
+    {
+        if (GetSession()->Expansion() < mapEntry->Expansion())
+        {
+            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player %s using client without required expansion tried login at non accessible map %u", GetName().c_str(), mapId);
+            RelocateToHomebind();
+        }
+
+        // fix crash (because of if (Map* map = _FindMap(instanceId)) in MapInstanced::CreateInstance)
+        if (instanceId)
+            if (InstanceSave* save = GetInstanceSave(mapId, mapEntry->IsRaid()))
+                if (save->GetInstanceId() != instanceId)
+                    instanceId = 0;
+    }
+
+    // NOW player must have valid map
+    // load the player's map here if it's not already loaded
+    Map* map = sMapMgr->CreateMap(mapId, this);
+
+    if (!map)
+    {
+        instanceId = 0;
+        AreaTriggerStruct const* at = sObjectMgr->GetGoBackTrigger(mapId);
+        if (at)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) is teleported to gobacktrigger (Map: %u X: %f Y: %f Z: %f O: %f).", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
+            Relocate(at->target_X, at->target_Y, at->target_Z, GetOrientation());
+            mapId = at->target_mapId;
+        }
+        else
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) is teleported to home (Map: %u X: %f Y: %f Z: %f O: %f).", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
+            RelocateToHomebind();
+        }
+
+        map = sMapMgr->CreateMap(mapId, this);
+        if (!map)
+        {
+            PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+            mapId = info->mapId;
+            Relocate(info->positionX, info->positionY, info->positionZ, 0.0f);
+            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid coordinates (X: %f Y: %f Z: %f O: %f). Teleport to default race/class locations.", guid, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
+            map = sMapMgr->CreateMap(mapId, this);
+            if (!map)
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) has invalid default map coordinates (X: %f Y: %f Z: %f O: %f). or instance couldn't be created", guid, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
+                return false;
+            }
+        }
+    }
+
+    // if the player is in an instance and it has been reset in the meantime teleport him to the entrance
+    if (instanceId && !sInstanceSaveMgr->GetInstanceSave(instanceId) && !map->IsBattlegroundOrArena())
+    {
+        AreaTriggerStruct const* at = sObjectMgr->GetMapEntranceTrigger(mapId);
+        if (at)
+            Relocate(at->target_X, at->target_Y, at->target_Z, at->target_Orientation);
+        else
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player %s(GUID: %u) logged in to a reset instance (map: %u) and there is no area-trigger leading to this map. Thus he can't be ported back to the entrance. This _might_ be an exploit attempt.", GetName().c_str(), GetGUIDLow(), mapId);
+            RelocateToHomebind();
+        }
+    }
+
+    SetMap(map);
+    StoreRaidMapDifficulty();
+
+    // randomize first save time in range [CONFIG_INTERVAL_SAVE] around [CONFIG_INTERVAL_SAVE]
+    // this must help in case next save after mass player load after server startup
+    m_nextSave = urand(m_nextSave/2, m_nextSave*3/2);
+
+    SaveRecallPosition();
+
+    time_t now = time(NULL);
+    time_t logoutTime = time_t(fields[22].GetUInt32());
+
+    // since last logout (in seconds)
+    uint32 time_diff = uint32(now - logoutTime); //uint64 is excessive for a time_diff in seconds.. uint32 allows for 136~ year difference.
+
+    // set value, including drunk invisibility detection
+    // calculate sobering. after 15 minutes logged out, the player will be sober again
+    uint8 newDrunkValue = 0;
+    if (time_diff < uint32(GetDrunkValue()) * 9)
+        newDrunkValue = GetDrunkValue() - time_diff / 9;
+
+    SetDrunkValue(newDrunkValue);
+
+    m_cinematic = fields[18].GetUInt8();
+    m_Played_time[PLAYED_TIME_TOTAL]= fields[19].GetUInt32();
+    m_Played_time[PLAYED_TIME_LEVEL]= fields[20].GetUInt32();
+
+    SetTalentResetCost(fields[24].GetUInt32());
+    SetTalentResetTime(time_t(fields[25].GetUInt32()));
+
+    m_taxi.LoadTaxiMask(fields[17].GetString());                // must be before InitTaxiNodesForLevel
+
+    uint32 extraflags = fields[32].GetUInt16();
+
+    m_atLoginFlags = fields[34].GetUInt16();
+
+    // Honor system
+    // Update Honor kills data
+    m_lastHonorUpdateTime = logoutTime;
+    UpdateHonorFields();
+
+    m_deathExpireTime = time_t(fields[37].GetUInt32());
+    if (m_deathExpireTime > now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP)
+        m_deathExpireTime = now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP-1;
+
+    // clear channel spell data (if saved at channel spell casting)
+    SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, 0);
+    SetUInt32Value(UNIT_CHANNEL_SPELL, 0);
+
+    // clear charm/summon related fields
+    SetOwnerGUID(0);
+    SetUInt64Value(UNIT_FIELD_CHARMEDBY, 0);
+    SetUInt64Value(UNIT_FIELD_CHARM, 0);
+    SetUInt64Value(UNIT_FIELD_SUMMON, 0);
+    SetUInt64Value(PLAYER_FARSIGHT, 0);
+    SetCreatorGUID(0);
+
+    RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FORCE_MOVEMENT);
+
+    // reset some aura modifiers before aura apply
+    SetUInt32Value(PLAYER_TRACK_CREATURES, 0);
+    SetUInt32Value(PLAYER_TRACK_RESOURCES, 0);
+
+    // make sure the unit is considered out of combat for proper loading
+    ClearInCombat();
+
+    // make sure the unit is considered not in duel for proper loading
+    SetUInt64Value(PLAYER_DUEL_ARBITER, 0);
+    SetUInt32Value(PLAYER_DUEL_TEAM, 0);
+
+    // reset stats before loading any modifiers
+    InitStatsForLevel();
+    InitGlyphsForLevel();
+    InitTaxiNodesForLevel();
+    InitRunes();
+
+    // rest bonus can only be calculated after InitStatsForLevel()
+    m_rest_bonus = fields[21].GetFloat();
+
+    if (time_diff > 0)
+    {
+        //speed collect rest bonus in offline, in logout, far from tavern, city (section/in hour)
+        float bubble0 = 0.031f;
+        //speed collect rest bonus in offline, in logout, in tavern, city (section/in hour)
+        float bubble1 = 0.125f;
+        float bubble = fields[23].GetUInt8() > 0
+            ? bubble1*sWorld->getRate(RATE_REST_OFFLINE_IN_TAVERN_OR_CITY)
+            : bubble0*sWorld->getRate(RATE_REST_OFFLINE_IN_WILDERNESS);
+
+        SetRestBonus(GetRestBonus()+ time_diff*((float)GetUInt32Value(PLAYER_NEXT_LEVEL_XP)/72000)*bubble);
+    }
+
+    // load skills after InitStatsForLevel because it triggering aura apply also
+    _LoadSkills(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SKILLS));
+    UpdateSkillsForLevel(); //update skills after load, to make sure they are correctly update at player load
+
+    // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()
+
+    //mails are loaded only when needed ;-) - when player in game click on mailbox.
+    //_LoadMail();
+
+    SetSpecsCount(fields[53].GetUInt8());
+    SetActiveSpec(fields[54].GetUInt8());
+
+    // sanity check
+    if (GetSpecsCount() > MAX_TALENT_SPECS || GetActiveSpec() > MAX_TALENT_SPEC || GetSpecsCount() < MIN_TALENT_SPECS)
+    {
+        SetActiveSpec(0);
+        sLog->outError(LOG_FILTER_PLAYER, "Player %s(GUID: %u) has SpecCount = %u and ActiveSpec = %u.", GetName().c_str(), GetGUIDLow(), GetSpecsCount(), GetActiveSpec());
+    }
+
+    learnDefaultSpells();
+    _LoadTalents(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_TALENTS));
+    _LoadSpells(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SPELLS));
+
+    _LoadGlyphs(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GLYPHS));
+    _LoadAuras(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_AURAS), time_diff);
+    _LoadGlyphAuras();
+    // add ghost flag (must be after aura load: PLAYER_FLAGS_GHOST set in aura)
+    if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+        m_deathState = DEAD;
+
+    // after spell load, learn rewarded spell if need also
+    _LoadQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_QUEST_STATUS));
+    _LoadQuestStatusRewarded(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_QUEST_STATUS_REW));
+    _LoadDailyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_DAILY_QUEST_STATUS));
+    _LoadWeeklyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_WEEKLY_QUEST_STATUS));
+    _LoadSeasonalQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SEASONAL_QUEST_STATUS));
+    _LoadMonthlyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_MONTHLY_QUEST_STATUS));
+    _LoadRandomBGStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_RANDOM_BG));
+
+    _LoadPets(holder);
+
+    // after spell and quest load
+    InitTalentForLevel();
+    CheckLevelDependantSpells();
+
+    // must be before inventory (some items required reputation check)
+    m_reputationMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_REPUTATION));
+
+    _LoadInventory(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_INVENTORY), time_diff);
+
+    if (IsVoidStorageUnlocked())
+        _LoadVoidStorage(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_VOID_STORAGE));
+
+    // update items with duration and realtime
+    UpdateItemDuration(time_diff, true);
+
+    _LoadActions(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ACTIONS));
+
+    // unread mails and next delivery time, actual mails not loaded
+    _LoadMailInit(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_MAIL_COUNT), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_MAIL_DATE));
+
+    m_social = sSocialMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SOCIAL_LIST), GetGUIDLow());
+
+    // check PLAYER_CHOSEN_TITLE compatibility with PLAYER__FIELD_KNOWN_TITLES
+    // note: PLAYER__FIELD_KNOWN_TITLES updated at quest status loaded
+    uint32 curTitle = fields[43].GetUInt32();
+    if (curTitle && !HasTitle(curTitle))
+        curTitle = 0;
+
+    SetUInt32Value(PLAYER_CHOSEN_TITLE, curTitle);
+
+    // has to be called after last Relocate() in Player::LoadFromDB
+    SetFallInformation(0, GetPositionZ());
+
+    _LoadSpellCooldowns(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SPELL_COOLDOWNS));
+
+    // Spell code allow apply any auras to dead character in load time in aura/spell/item loading
+    // Do now before stats re-calculation cleanup for ghost state unexpected auras
+    if (!isAlive())
+        RemoveAllAurasOnDeath();
+    else
+        RemoveAllAurasRequiringDeadTarget();
+
+    //apply all stat bonuses from items and auras
+    SetCanModifyStats(true);
+    UpdateAllStats();
+
+    // restore remembered power/health values (but not more max values)
+    uint32 savedHealth = fields[46].GetUInt32();
+    SetHealth(savedHealth > GetMaxHealth() ? GetMaxHealth() : savedHealth);
+    uint32 loadedPowers = 0;
+    for (uint32 i = 0; i < MAX_POWERS; ++i)
+    {
+        if (GetPowerIndex(i) != MAX_POWERS)
+        {
+            uint32 savedPower = fields[47+loadedPowers].GetUInt32();
+            uint32 maxPower = GetUInt32Value(UNIT_FIELD_MAXPOWER1 + loadedPowers);
+            SetPower(Powers(i), (savedPower > maxPower) ? maxPower : savedPower);
+            if (++loadedPowers >= MAX_POWERS_PER_CLASS)
+                break;
+        }
+    }
+
+    for (; loadedPowers < MAX_POWERS_PER_CLASS; ++loadedPowers)
+        SetUInt32Value(UNIT_FIELD_POWER1 + loadedPowers, 0);
+
+    SetPower(POWER_ECLIPSE, 0);
+
+    // must be after loading spells and talents
+    Tokenizer talentTrees(fields[26].GetString(), ' ', MAX_TALENT_SPECS);
+    for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
+    {
+        if (i >= talentTrees.size())
+            break;
+
+        uint32 talentTree = atol(talentTrees[i]);
+        if (sTalentTabStore.LookupEntry(talentTree))
+            SetPrimaryTalentTree(i, talentTree);
+        else if (i == GetActiveSpec() && talentTree != 0)
+            SetAtLoginFlag(AT_LOGIN_RESET_TALENTS); // invalid tree, reset talents
+    }
+
+    UpdateMastery();
+
+    // We neeed to update the armor specialization after the talenttree was set
+    UpdateArmorSpecialization();
+
+    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "The value of player %s after load item and aura is: ", m_name.c_str());
+    outDebugValues();
+
+    // GM state
+    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
+    {
+        switch (sWorld->getIntConfig(CONFIG_GM_LOGIN_STATE))
+        {
+            default:
+            case 0:                      break;             // disable
+            case 1: SetGameMaster(true); break;             // enable
+            case 2:                                         // save state
+                if (extraflags & PLAYER_EXTRA_GM_ON)
+                    SetGameMaster(true);
+                break;
+        }
+
+        switch (sWorld->getIntConfig(CONFIG_GM_VISIBLE_STATE))
+        {
+            default:
+            case 0: SetGMVisible(false); break;             // invisible
+            case 1:                      break;             // visible
+            case 2:                                         // save state
+                if (extraflags & PLAYER_EXTRA_GM_INVISIBLE)
+                    SetGMVisible(false);
+                break;
+        }
+
+        switch (sWorld->getIntConfig(CONFIG_GM_CHAT))
+        {
+            default:
+            case 0:                  break;                 // disable
+            case 1: SetGMChat(true); break;                 // enable
+            case 2:                                         // save state
+                if (extraflags & PLAYER_EXTRA_GM_CHAT)
+                    SetGMChat(true);
+                break;
+        }
+
+        switch (sWorld->getIntConfig(CONFIG_GM_WHISPERING_TO))
+        {
+            default:
+            case 0:                          break;         // disable
+            case 1: SetAcceptWhispers(true); break;         // enable
+            case 2:                                         // save state
+                if (extraflags & PLAYER_EXTRA_ACCEPT_WHISPERS)
+                    SetAcceptWhispers(true);
+                break;
+        }
+    }
+
+    // RaF stuff.
+    m_grantableLevels = fields[59].GetUInt8();
+    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
+        SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);
+
+    if (m_grantableLevels > 0)
+        SetByteValue(PLAYER_FIELD_BYTES, 1, 0x01);
+
+    _LoadDeclinedNames(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_DECLINED_NAMES));
+
+    m_achievementMgr->CheckAllAchievementCriteria(this);
+
+    _LoadEquipmentSets(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_EQUIPMENT_SETS));
+
+    _LoadCUFProfiles(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CUF_PROFILES));
+
+    return true;
+}
+
+void Player::_LoadCUFProfiles(PreparedQueryResult result)
+{
+    if (!result)
+        return;
+
+    do
+    {
+        // SELECT id, name, frameHeight, frameWidth, sortBy, healthText, boolOptions, unk146, unk147, unk148, unk150, unk152, unk154 FROM character_cuf_profiles WHERE guid = ?
+        Field* fields = result->Fetch();
+
+        uint8 id           = fields[0].GetUInt8();
+        std::string name   = fields[1].GetString();
+        uint16 frameHeight = fields[2].GetUInt16();
+        uint16 frameWidth  = fields[3].GetUInt16();
+        uint8 sortBy       = fields[4].GetUInt8();
+        uint8 healthText   = fields[5].GetUInt8();
+        uint32 boolOptions = fields[6].GetUInt32();
+        uint8 unk146       = fields[7].GetUInt8();
+        uint8 unk147       = fields[8].GetUInt8();
+        uint8 unk148       = fields[9].GetUInt8();
+        uint16 unk150      = fields[10].GetUInt16();
+        uint16 unk152      = fields[11].GetUInt16();
+        uint16 unk154      = fields[12].GetUInt16();
+
+        if (id > MAX_CUF_PROFILES)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadCUFProfiles - Player (GUID: %u, name: %s) has an CUF profile with invalid id (id: %u), max is %i.", GetGUIDLow(), GetName().c_str(), id, MAX_CUF_PROFILES);
+            continue;
+        }
+
+        _CUFProfiles[id] = new CUFProfile(name, frameHeight, frameWidth, sortBy, healthText, boolOptions, unk146, unk147, unk148, unk150, unk152, unk154);
+    }
+    while (result->NextRow());
+}
+
+bool Player::isAllowedToLoot(const Creature* creature)
+{
+    if (!creature->isDead() || !creature->IsDamageEnoughForLootingAndReward())
+        return false;
+
+    if (HasPendingBind())
+        return false;
+
+    const Loot* loot = &creature->loot;
+    if (loot->isLooted()) // nothing to loot or everything looted.
+        return false;
+
+    Group* thisGroup = GetGroup();
+    if (!thisGroup)
+        return this == creature->GetLootRecipient();
+    else if (thisGroup != creature->GetLootRecipientGroup())
+        return false;
+
+    switch (thisGroup->GetLootMethod())
+    {
+        case FREE_FOR_ALL:
+            return true;
+        case ROUND_ROBIN:
+        case MASTER_LOOT:
+            // may only loot if the player is the loot roundrobin player
+            // or if there are free/quest/conditional item for the player
+            if (loot->roundRobinPlayer == 0 || loot->roundRobinPlayer == GetGUID())
+                return true;
+
+            return loot->hasItemFor(this);
+        case GROUP_LOOT:
+        case NEED_BEFORE_GREED:
+            // may only loot if the player is the loot roundrobin player
+            // or item over threshold (so roll(s) can be launched)
+            // or if there are free/quest/conditional item for the player
+            if (loot->roundRobinPlayer == 0 || loot->roundRobinPlayer == GetGUID())
+                return true;
+
+            if (loot->hasOverThresholdItem())
+                return true;
+
+            return loot->hasItemFor(this);
+    }
+
+    return false;
+}
+
+void Player::_LoadActions(PreparedQueryResult result)
+{
+    m_actionButtons.clear();
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            uint8 button = fields[0].GetUInt8();
+            uint32 action = fields[1].GetUInt32();
+            uint8 type = fields[2].GetUInt8();
+
+            if (ActionButton* ab = addActionButton(button, action, type))
+                ab->uState = ACTIONBUTTON_UNCHANGED;
+            else
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "  ...at loading, and will deleted in DB also");
+
+                // Will deleted in DB at next save (it can create data until save but marked as deleted)
+                m_actionButtons[button].uState = ACTIONBUTTON_DELETED;
+            }
+        } while (result->NextRow());
+    }
+}
+
+void Player::_LoadAuras(PreparedQueryResult result, uint32 timediff)
+{
+    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Loading auras for player %u", GetGUIDLow());
+
+    /*                                                           0       1        2         3                 4         5      6       7         8              9            10
+    QueryResult* result = CharacterDatabase.PQuery("SELECT caster_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, base_amount0, base_amount1, base_amount2,
+                                                        11          12          13
+                                                    maxduration, remaintime, remaincharges FROM character_aura WHERE guid = '%u'", GetGUIDLow());
+    */
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            int32 damage[3];
+            int32 baseDamage[3];
+            uint64 caster_guid = fields[0].GetUInt64();
+            uint32 spellid = fields[1].GetUInt32();
+            uint8 effmask = fields[2].GetUInt8();
+            uint8 recalculatemask = fields[3].GetUInt8();
+            uint8 stackcount = fields[4].GetUInt8();
+            damage[0] = fields[5].GetInt32();
+            damage[1] = fields[6].GetInt32();
+            damage[2] = fields[7].GetInt32();
+            baseDamage[0] = fields[8].GetInt32();
+            baseDamage[1] = fields[9].GetInt32();
+            baseDamage[2] = fields[10].GetInt32();
+            int32 maxduration = fields[11].GetInt32();
+            int32 remaintime = fields[12].GetInt32();
+            uint8 remaincharges = fields[13].GetUInt8();
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellid);
+            if (!spellInfo)
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Unknown aura (spellid %u), ignore.", spellid);
+                continue;
+            }
+
+            // negative effects should continue counting down after logout
+            if (remaintime != -1 && !spellInfo->IsPositive())
+            {
+                if (remaintime/IN_MILLISECONDS <= int32(timediff))
+                    continue;
+
+                remaintime -= timediff*IN_MILLISECONDS;
+            }
+
+            // prevent wrong values of remaincharges
+            if (spellInfo->ProcCharges)
+            {
+                // we have no control over the order of applying auras and modifiers allow auras
+                // to have more charges than value in SpellInfo
+                if (remaincharges <= 0/* || remaincharges > spellproto->procCharges*/)
+                    remaincharges = spellInfo->ProcCharges;
+            }
+            else
+                remaincharges = 0;
+
+            if (Aura* aura = Aura::TryCreate(spellInfo, effmask, this, NULL, &baseDamage[0], NULL, caster_guid))
+            {
+                if (!aura->CanBeSaved())
+                {
+                    aura->Remove();
+                    continue;
+                }
+
+                aura->SetLoadedState(maxduration, remaintime, remaincharges, stackcount, recalculatemask, &damage[0]);
+                aura->ApplyForTargets();
+                sLog->outInfo(LOG_FILTER_PLAYER, "Added aura spellid %u, effectmask %u", spellInfo->Id, effmask);
+            }
+        }
+        while (result->NextRow());
+    }
+}
+
+void Player::_LoadGlyphAuras()
+{
+    for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
+    {
+        if (uint32 glyph = GetGlyph(GetActiveSpec(), i))
+        {
+            if (GlyphPropertiesEntry const* gp = sGlyphPropertiesStore.LookupEntry(glyph))
+            {
+                if (GlyphSlotEntry const* gs = sGlyphSlotStore.LookupEntry(GetGlyphSlot(i)))
+                {
+                    if (gp->TypeFlags == gs->TypeFlags)
+                    {
+                        CastSpell(this, gp->SpellId, true);
+                        continue;
+                    }
+                    else
+                        sLog->outError(LOG_FILTER_PLAYER, "Player %s has glyph with typeflags %u in slot with typeflags %u, removing.", m_name.c_str(), gp->TypeFlags, gs->TypeFlags);
+                }
+                else
+                    sLog->outError(LOG_FILTER_PLAYER, "Player %s has not existing glyph slot entry %u on index %u", m_name.c_str(), GetGlyphSlot(i), i);
+            }
+            else
+                sLog->outError(LOG_FILTER_PLAYER, "Player %s has not existing glyph entry %u on index %u", m_name.c_str(), glyph, i);
+
+            // On any error remove glyph
+            SetGlyph(i, 0);
+        }
+    }
+}
+
+void Player::LoadCorpse()
+{
+    if (isAlive())
+        sObjectAccessor->ConvertCorpseForPlayer(GetGUID());
+    else
+    {
+        if (Corpse* corpse = GetCorpse())
+            ApplyModFlag(PLAYER_FIELD_BYTES, PLAYER_FIELD_BYTE_RELEASE_TIMER, corpse && !sMapStore.LookupEntry(corpse->GetMapId())->Instanceable());
+        else
+            //Prevent Dead Player login without corpse
+            ResurrectPlayer(0.5f);
+    }
+}
+
+void Player::_LoadInventory(PreparedQueryResult result, uint32 timeDiff)
+{
+    //QueryResult* result = CharacterDatabase.PQuery("SELECT data, text, bag, slot, item, item_template FROM character_inventory JOIN item_instance ON character_inventory.item = item_instance.guid WHERE character_inventory.guid = '%u' ORDER BY bag, slot", GetGUIDLow());
+    //NOTE: the "order by `bag`" is important because it makes sure
+    //the bagMap is filled before items in the bags are loaded
+    //NOTE2: the "order by `slot`" is needed because mainhand weapons are (wrongly?)
+    //expected to be equipped before offhand items (TODO: fixme)
+
+    if (result)
+    {
+        uint32 zoneId = GetZoneId();
+
+        std::map<uint32, Bag*> bagMap;                               // fast guid lookup for bags
+        std::map<uint32, Item*> invalidBagMap;                       // fast guid lookup for bags
+        std::list<Item*> problematicItems;
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+        // Prevent items from being added to the queue while loading
+        m_itemUpdateQueueBlocked = true;
+        do
+        {
+            Field* fields = result->Fetch();
+            if (Item* item = _LoadItem(trans, zoneId, timeDiff, fields))
+            {
+                uint32 bagGuid  = fields[11].GetUInt32();
+                uint8  slot     = fields[12].GetUInt8();
+
+                uint8 err = EQUIP_ERR_OK;
+                // Item is not in bag
+                if (!bagGuid)
+                {
+                    item->SetContainer(NULL);
+                    item->SetSlot(slot);
+
+                    if (IsInventoryPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        ItemPosCountVec dest;
+                        err = CanStoreItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false);
+                        if (err == EQUIP_ERR_OK)
+                            item = StoreItem(dest, item, true);
+                    }
+                    else if (IsEquipmentPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        uint16 dest;
+                        err = CanEquipItem(slot, dest, item, false, false);
+                        if (err == EQUIP_ERR_OK)
+                            QuickEquipItem(dest, item);
+                    }
+                    else if (IsBankPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        ItemPosCountVec dest;
+                        err = CanBankItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false, false);
+                        if (err == EQUIP_ERR_OK)
+                            item = BankItem(dest, item, true);
+                    }
+
+                    // Remember bags that may contain items in them
+                    if (err == EQUIP_ERR_OK)
+                    {
+                        if (IsBagPos(item->GetPos()))
+                            if (Bag* pBag = item->ToBag())
+                                bagMap[item->GetGUIDLow()] = pBag;
+                    }
+                    else
+                        if (IsBagPos(item->GetPos()))
+                            if (item->IsBag())
+                                invalidBagMap[item->GetGUIDLow()] = item;
+                }
+                else
+                {
+                    item->SetSlot(NULL_SLOT);
+                    // Item is in the bag, find the bag
+                    std::map<uint32, Bag*>::iterator itr = bagMap.find(bagGuid);
+                    if (itr != bagMap.end())
+                    {
+                        ItemPosCountVec dest;
+                        err = CanStoreItem(itr->second->GetSlot(), slot, dest, item);
+                        if (err == EQUIP_ERR_OK)
+                            item = StoreItem(dest, item, true);
+                    }
+                    else if (invalidBagMap.find(bagGuid) != invalidBagMap.end())
+                    {
+                        std::map<uint32, Item*>::iterator itr = invalidBagMap.find(bagGuid);
+                        if (std::find(problematicItems.begin(), problematicItems.end(), itr->second) != problematicItems.end())
+                            err = EQUIP_ERR_INTERNAL_BAG_ERROR;
+                    }
+                    else
+                    {
+                        sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) which doesnt have a valid bag (Bag GUID: %u, slot: %u). Possible cheat?",
+                            GetGUIDLow(), GetName().c_str(), item->GetGUIDLow(), item->GetEntry(), bagGuid, slot);
+                        item->DeleteFromInventoryDB(trans);
+                        delete item;
+                        continue;
+                    }
+
+                }
+
+                // Item's state may have changed after storing
+                if (err == EQUIP_ERR_OK)
+                    item->SetState(ITEM_UNCHANGED, this);
+                else
+                {
+                    sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) which can't be loaded into inventory (Bag GUID: %u, slot: %u) by reason %u. Item will be sent by mail.",
+                        GetGUIDLow(), GetName().c_str(), item->GetGUIDLow(), item->GetEntry(), bagGuid, slot, err);
+                    item->DeleteFromInventoryDB(trans);
+                    problematicItems.push_back(item);
+                }
+            }
+        } while (result->NextRow());
+
+        m_itemUpdateQueueBlocked = false;
+
+        // Send problematic items by mail
+        while (!problematicItems.empty())
+        {
+            std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);
+
+            MailDraft draft(subject, "There were problems with equipping item(s).");
+            for (uint8 i = 0; !problematicItems.empty() && i < MAX_MAIL_ITEMS; ++i)
+            {
+                draft.AddItem(problematicItems.front());
+                problematicItems.pop_front();
+            }
+            draft.SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
+        }
+        CharacterDatabase.CommitTransaction(trans);
+    }
+    //if (isAlive())
+    _ApplyAllItemMods();
+}
+
+void Player::_LoadVoidStorage(PreparedQueryResult result)
+{
+    if (!result)
+        return;
+
+    do
+    {
+        // SELECT itemid, itemEntry, slot, creatorGuid FROM character_void_storage WHERE playerGuid = ?
+        Field* fields = result->Fetch();
+
+        uint64 itemId = fields[0].GetUInt64();
+        uint32 itemEntry = fields[1].GetUInt32();
+        uint8 slot = fields[2].GetUInt8();
+        uint32 creatorGuid = fields[3].GetUInt32();
+        uint32 randomProperty = fields[4].GetUInt32();
+        uint32 suffixFactor = fields[5].GetUInt32();
+
+        if (!itemId)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid id (item id: " UI64FMTD ", entry: %u).", GetGUIDLow(), GetName().c_str(), itemId, itemEntry);
+            continue;
+        }
+
+        if (!sObjectMgr->GetItemTemplate(itemEntry))
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid entry (item id: " UI64FMTD ", entry: %u).", GetGUIDLow(), GetName().c_str(), itemId, itemEntry);
+            continue;
+        }
+
+        if (slot >= VOID_STORAGE_MAX_SLOT)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid slot (item id: " UI64FMTD ", entry: %u, slot: %u).", GetGUIDLow(), GetName().c_str(), itemId, itemEntry, slot);
+            continue;
+        }
+
+        std::string name;
+        if (creatorGuid && !sObjectMgr->GetPlayerNameByGUID(creatorGuid, name)) 
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid creator guid, set to 0 (item id: " UI64FMTD ", entry: %u, creatorGuid: %u).", GetGUIDLow(), GetName().c_str(), itemId, itemEntry, creatorGuid);
+            creatorGuid = 0;
+        }
+
+        _voidStorageItems[slot] = new VoidStorageItem(itemId, itemEntry, creatorGuid, randomProperty, suffixFactor);
+    }
+    while (result->NextRow());
+}
+
+Item* Player::_LoadItem(SQLTransaction& trans, uint32 zoneId, uint32 timeDiff, Field* fields)
+{
+    Item* item = NULL;
+    uint32 itemGuid  = fields[13].GetUInt32();
+    uint32 itemEntry = fields[14].GetUInt32();
+    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemEntry))
+    {
+        bool remove = false;
+        item = NewItemOrBag(proto);
+        if (item->LoadFromDB(itemGuid, GetGUID(), fields, itemEntry))
+        {
+            PreparedStatement* stmt = NULL;
+
+            // Do not allow to have item limited to another map/zone in alive state
+            if (isAlive() && item->IsLimitedToAnotherMapOrZone(GetMapId(), zoneId))
+            {
+                sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s', map: %u) has item (GUID: %u, entry: %u) limited to another map (%u). Deleting item.",
+                    GetGUIDLow(), GetName().c_str(), GetMapId(), item->GetGUIDLow(), item->GetEntry(), zoneId);
+                remove = true;
+            }
+            // "Conjured items disappear if you are logged out for more than 15 minutes"
+            else if (timeDiff > 15 * MINUTE && proto->Flags & ITEM_PROTO_FLAG_CONJURED)
+            {
+                sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s', diff: %u) has conjured item (GUID: %u, entry: %u) with expired lifetime (15 minutes). Deleting item.",
+                    GetGUIDLow(), GetName().c_str(), timeDiff, item->GetGUIDLow(), item->GetEntry());
+                remove = true;
+            }
+            else if (item->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_REFUNDABLE))
+            {
+                if (item->GetPlayedTime() > (2 * HOUR))
+                {
+                    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with expired refund time (%u). Deleting refund data and removing refundable flag.",
+                        GetGUIDLow(), GetName().c_str(), item->GetGUIDLow(), item->GetEntry(), item->GetPlayedTime());
+
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_REFUND_INSTANCE);
+                    stmt->setUInt32(0, item->GetGUIDLow());
+                    trans->Append(stmt);
+
+                    item->RemoveFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_REFUNDABLE);
+                }
+                else
+                {
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ITEM_REFUNDS);
+                    stmt->setUInt32(0, item->GetGUIDLow());
+                    stmt->setUInt32(1, GetGUIDLow());
+                    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
+                    {
+                        item->SetRefundRecipient((*result)[0].GetUInt32());
+                        item->SetPaidMoney((*result)[1].GetUInt32());
+                        item->SetPaidExtendedCost((*result)[2].GetUInt16());
+                        AddRefundReference(item->GetGUIDLow());
+                    }
+                    else
+                    {
+                        sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with refundable flags, but without data in item_refund_instance. Removing flag.",
+                            GetGUIDLow(), GetName().c_str(), item->GetGUIDLow(), item->GetEntry());
+                        item->RemoveFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_REFUNDABLE);
+                    }
+                }
+            }
+            else if (item->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_BOP_TRADEABLE))
+            {
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ITEM_BOP_TRADE);
+                stmt->setUInt32(0, item->GetGUIDLow());
+                if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
+                {
+                    std::string strGUID = (*result)[0].GetString();
+                    Tokenizer GUIDlist(strGUID, ' ');
+                    AllowedLooterSet looters;
+                    for (Tokenizer::const_iterator itr = GUIDlist.begin(); itr != GUIDlist.end(); ++itr)
+                        looters.insert(atol(*itr));
+
+                    if (looters.size() > 1 && item->GetTemplate()->GetMaxStackSize() == 1 && item->IsSoulBound())
+                    {
+                        item->SetSoulboundTradeable(looters);
+                        AddTradeableItem(item);
+                    }
+                    else
+                        item->ClearSoulboundTradeable(this);
+                }
+                else
+                {
+                    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with ITEM_FLAG_BOP_TRADEABLE flag, but without data in item_soulbound_trade_data. Removing flag.",
+                        GetGUIDLow(), GetName().c_str(), item->GetGUIDLow(), item->GetEntry());
+                    item->RemoveFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_BOP_TRADEABLE);
+                }
+            }
+            else if (proto->HolidayId)
+            {
+                remove = true;
+                GameEventMgr::GameEventDataMap const& events = sGameEventMgr->GetEventMap();
+                GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr->GetActiveEventList();
+                for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
+                {
+                    if (uint32(events[*itr].holiday_id) == proto->HolidayId)
+                    {
+                        remove = false;
+                        break;
+                    }
+                }
+            }
+        }
+        else
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has broken item (GUID: %u, entry: %u) in inventory. Deleting item.",
+                GetGUIDLow(), GetName().c_str(), itemGuid, itemEntry);
+            remove = true;
+        }
+        // Remove item from inventory if necessary
+        if (remove)
+        {
+            Item::DeleteFromInventoryDB(trans, itemGuid);
+            item->FSetState(ITEM_REMOVED);
+            item->SaveToDB(trans);                           // it also deletes item object!
+            item = NULL;
+        }
+    }
+    else
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has unknown item (entry: %u) in inventory. Deleting item.",
+            GetGUIDLow(), GetName().c_str(), itemEntry);
+        Item::DeleteFromInventoryDB(trans, itemGuid);
+        Item::DeleteFromDB(trans, itemGuid);
+    }
+    return item;
+}
+
+// load mailed item which should receive current player
+void Player::_LoadMailedItems(Mail* mail)
+{
+    // data needs to be at first place for Item::LoadFromDB
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAILITEMS);
+    stmt->setUInt32(0, mail->messageID);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    if (!result)
+        return;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 itemGuid = fields[11].GetUInt32();
+        uint32 itemTemplate = fields[12].GetUInt32();
+
+        mail->AddItem(itemGuid, itemTemplate);
+
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemTemplate);
+
+        if (!proto)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player %u has unknown item_template (ProtoType) in mailed items(GUID: %u template: %u) in mail (%u), deleted.", GetGUIDLow(), itemGuid, itemTemplate, mail->messageID);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_MAIL_ITEM);
+            stmt->setUInt32(0, itemGuid);
+            CharacterDatabase.Execute(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
+            stmt->setUInt32(0, itemGuid);
+            CharacterDatabase.Execute(stmt);
+            continue;
+        }
+
+        Item* item = NewItemOrBag(proto);
+
+        if (!item->LoadFromDB(itemGuid, MAKE_NEW_GUID(fields[13].GetUInt32(), 0, HIGHGUID_PLAYER), fields, itemTemplate))
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadMailedItems - Item in mail (%u) doesn't exist !!!! - item guid: %u, deleted from mail", mail->messageID, itemGuid);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
+            stmt->setUInt32(0, itemGuid);
+            CharacterDatabase.Execute(stmt);
+
+            item->FSetState(ITEM_REMOVED);
+
+            SQLTransaction temp = SQLTransaction(NULL);
+            item->SaveToDB(temp);                               // it also deletes item object !
+            continue;
+        }
+
+        AddMItem(item);
+    }
+    while (result->NextRow());
+}
+
+void Player::_LoadMailInit(PreparedQueryResult resultUnread, PreparedQueryResult resultDelivery)
+{
+    //set a count of unread mails
+    //QueryResult* resultMails = CharacterDatabase.PQuery("SELECT COUNT(id) FROM mail WHERE receiver = '%u' AND (checked & 1)=0 AND deliver_time <= '" UI64FMTD "'", GUID_LOPART(playerGuid), (uint64)cTime);
+    if (resultUnread)
+        unReadMails = uint8((*resultUnread)[0].GetUInt64());
+
+    // store nearest delivery time (it > 0 and if it < current then at next player update SendNewMaill will be called)
+    //resultMails = CharacterDatabase.PQuery("SELECT MIN(deliver_time) FROM mail WHERE receiver = '%u' AND (checked & 1)=0", GUID_LOPART(playerGuid));
+    if (resultDelivery)
+        m_nextMailDelivereTime = time_t((*resultDelivery)[0].GetUInt32());
+}
+
+void Player::_LoadMail()
+{
+    m_mail.clear();
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAIL);
+    stmt->setUInt32(0, GetGUIDLow());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            Mail* m = new Mail;
+
+            m->messageID      = fields[0].GetUInt32();
+            m->messageType    = fields[1].GetUInt8();
+            m->sender         = fields[2].GetUInt32();
+            m->receiver       = fields[3].GetUInt32();
+            m->subject        = fields[4].GetString();
+            m->body           = fields[5].GetString();
+            bool has_items    = fields[6].GetBool();
+            m->expire_time    = time_t(fields[7].GetUInt32());
+            m->deliver_time   = time_t(fields[8].GetUInt32());
+            m->money          = fields[9].GetUInt64();
+            m->COD            = fields[10].GetUInt64();
+            m->checked        = fields[11].GetUInt8();
+            m->stationery     = fields[12].GetUInt8();
+            m->mailTemplateId = fields[13].GetInt16();
+
+            if (m->mailTemplateId && !sMailTemplateStore.LookupEntry(m->mailTemplateId))
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadMail - Mail (%u) have not existed MailTemplateId (%u), remove at load", m->messageID, m->mailTemplateId);
+                m->mailTemplateId = 0;
+            }
+
+            m->state = MAIL_STATE_UNCHANGED;
+
+            if (has_items)
+                _LoadMailedItems(m);
+
+            m_mail.push_back(m);
+        }
+        while (result->NextRow());
+    }
+    m_mailsLoaded = true;
+}
+
+void Player::LoadPets()
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT currentPetSlot FROM characters WHERE guid = '%u'", this->GetGUIDLow());
+	Field* fields = result->Fetch();
+	PetSlot petslot = (PetSlot)fields[0].GetUInt8();
+	
+    //Spawn Pet maybe Lastpetentry save in database
+    if (IsInWorld())
+    {
+        Pet* pet = new Pet(this);
+
+        PetData* t_pet = GetPetDatabySlot(petslot);
+        if (!pet->LoadPet(this, t_pet, true))
+            delete pet;
+    }
+
+    if (getClass() == CLASS_HUNTER)
+        GetSession()->SendStablePet(0);
+}
+
+void Player::_LoadQuestStatus(PreparedQueryResult result)
+{
+    uint16 slot = 0;
+
+    ////                                                       0      1       2        3        4           5          6         7           8           9           10
+    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, status, explored, timer, mobcount1, mobcount2, mobcount3, mobcount4, itemcount1, itemcount2, itemcount3,
+    //                                                    11           12
+    //                                                itemcount4, playercount FROM character_queststatus WHERE guid = '%u'", GetGUIDLow());
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+
+            uint32 quest_id = fields[0].GetUInt32();
+                                                            // used to be new, no delete?
+            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
+            if (quest)
+            {
+                // find or create
+                QuestStatusData& questStatusData = m_QuestStatus[quest_id];
+
+                uint8 qstatus = fields[1].GetUInt8();
+                if (qstatus < MAX_QUEST_STATUS)
+                    questStatusData.Status = QuestStatus(qstatus);
+                else
+                {
+                    questStatusData.Status = QUEST_STATUS_INCOMPLETE;
+                    sLog->outError(LOG_FILTER_PLAYER, "Player %s (GUID: %u) has invalid quest %d status (%u), replaced by QUEST_STATUS_INCOMPLETE(3).",
+                        GetName().c_str(), GetGUIDLow(), quest_id, qstatus);
+                }
+
+                questStatusData.Explored = (fields[2].GetUInt8() > 0);
+
+                time_t quest_time = time_t(fields[3].GetUInt32());
+
+                if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED) && !GetQuestRewardStatus(quest_id))
+                {
+                    AddTimedQuest(quest_id);
+
+                    if (quest_time <= sWorld->GetGameTime())
+                        questStatusData.Timer = 1;
+                    else
+                        questStatusData.Timer = uint32((quest_time - sWorld->GetGameTime()) * IN_MILLISECONDS);
+                }
+                else
+                    quest_time = 0;
+
+                questStatusData.CreatureOrGOCount[0] = fields[4].GetUInt16();
+                questStatusData.CreatureOrGOCount[1] = fields[5].GetUInt16();
+                questStatusData.CreatureOrGOCount[2] = fields[6].GetUInt16();
+                questStatusData.CreatureOrGOCount[3] = fields[7].GetUInt16();
+                questStatusData.ItemCount[0] = fields[8].GetUInt16();
+                questStatusData.ItemCount[1] = fields[9].GetUInt16();
+                questStatusData.ItemCount[2] = fields[10].GetUInt16();
+                questStatusData.ItemCount[3] = fields[11].GetUInt16();
+                questStatusData.PlayerCount = fields[12].GetUInt16();
+
+                // add to quest log
+                if (slot < MAX_QUEST_LOG_SIZE && questStatusData.Status != QUEST_STATUS_NONE)
+                {
+                    SetQuestSlot(slot, quest_id, uint32(quest_time)); // cast can't be helped
+
+                    if (questStatusData.Status == QUEST_STATUS_COMPLETE)
+                        SetQuestSlotState(slot, QUEST_STATE_COMPLETE);
+                    else if (questStatusData.Status == QUEST_STATUS_FAILED)
+                        SetQuestSlotState(slot, QUEST_STATE_FAIL);
+
+                    for (uint8 idx = 0; idx < QUEST_OBJECTIVES_COUNT; ++idx)
+                        if (questStatusData.CreatureOrGOCount[idx])
+                            SetQuestSlotCounter(slot, idx, questStatusData.CreatureOrGOCount[idx]);
+
+                    if (questStatusData.PlayerCount)
+                        SetQuestSlotCounter(slot, QUEST_PVP_KILL_SLOT, questStatusData.PlayerCount);
+
+                    ++slot;
+                }
+
+                sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Quest status is {%u} for quest {%u} for player (GUID: %u)", questStatusData.Status, quest_id, GetGUIDLow());
+            }
+        }
+        while (result->NextRow());
+    }
+
+    // clear quest log tail
+    for (uint16 i = slot; i < MAX_QUEST_LOG_SIZE; ++i)
+        SetQuestSlot(i, 0);
+}
+
+void Player::_LoadQuestStatusRewarded(PreparedQueryResult result)
+{
+    // SELECT quest FROM character_queststatus_rewarded WHERE guid = ?
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+
+            uint32 quest_id = fields[0].GetUInt32();
+                                                            // used to be new, no delete?
+            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
+            if (quest)
+            {
+                // learn rewarded spell if unknown
+                learnQuestRewardedSpells(quest);
+
+                // set rewarded title if any
+                if (quest->GetCharTitleId())
+                {
+                    if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(quest->GetCharTitleId()))
+                        SetTitle(titleEntry);
+                }
+
+                if (uint32 talents = quest->GetBonusTalents())
+                    AddQuestRewardedTalentCount(talents);
+            }
+
+            m_RewardedQuests.insert(quest_id);
+        }
+        while (result->NextRow());
+    }
+}
+
+void Player::_LoadDailyQuestStatus(PreparedQueryResult result)
+{
+    for (uint32 quest_daily_idx = 0; quest_daily_idx < PLAYER_MAX_DAILY_QUESTS; ++quest_daily_idx)
+        SetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx, 0);
+
+    m_DFQuests.clear();
+
+    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, time FROM character_queststatus_daily WHERE guid = '%u'", GetGUIDLow());
+
+    if (result)
+    {
+        uint32 quest_daily_idx = 0;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            if (Quest const* qQuest = sObjectMgr->GetQuestTemplate(fields[0].GetUInt32()))
+            {
+                if (qQuest->IsDFQuest())
+                {
+                    m_DFQuests.insert(qQuest->GetQuestId());
+                    m_lastDailyQuestTime = time_t(fields[1].GetUInt32());
+                    continue;
+                }
+            }
+
+            if (quest_daily_idx >= PLAYER_MAX_DAILY_QUESTS)  // max amount with exist data in query
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) have more 25 daily quest records in `charcter_queststatus_daily`", GetGUIDLow());
+                break;
+            }
+
+            uint32 quest_id = fields[0].GetUInt32();
+
+            // save _any_ from daily quest times (it must be after last reset anyway)
+            m_lastDailyQuestTime = time_t(fields[1].GetUInt32());
+
+            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
+            if (!quest)
+                continue;
+
+            SetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx, quest_id);
+            ++quest_daily_idx;
+
+            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Daily quest (%u) cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
+        }
+        while (result->NextRow());
+    }
+
+    m_DailyQuestChanged = false;
+}
+
+void Player::_LoadWeeklyQuestStatus(PreparedQueryResult result)
+{
+    m_weeklyquests.clear();
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 quest_id = fields[0].GetUInt32();
+            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
+            if (!quest)
+                continue;
+
+            m_weeklyquests.insert(quest_id);
+            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Weekly quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
+        }
+        while (result->NextRow());
+    }
+
+    m_WeeklyQuestChanged = false;
+}
+
+void Player::_LoadSeasonalQuestStatus(PreparedQueryResult result)
+{
+    m_seasonalquests.clear();
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 quest_id = fields[0].GetUInt32();
+            uint32 event_id = fields[1].GetUInt32();
+            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
+            if (!quest)
+                continue;
+
+            m_seasonalquests[event_id].insert(quest_id);
+            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Seasonal quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
+        }
+        while (result->NextRow());
+    }
+
+    m_SeasonalQuestChanged = false;
+}
+
+void Player::_LoadMonthlyQuestStatus(PreparedQueryResult result)
+{
+    m_monthlyquests.clear();
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 quest_id = fields[0].GetUInt32();
+            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
+            if (!quest)
+                continue;
+
+            m_monthlyquests.insert(quest_id);
+            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Monthly quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
+        }
+        while (result->NextRow());
+    }
+
+    m_MonthlyQuestChanged = false;
+}
+
+void Player::_LoadSpells(PreparedQueryResult result)
+{
+    //QueryResult* result = CharacterDatabase.PQuery("SELECT spell, active, disabled FROM character_spell WHERE guid = '%u'", GetGUIDLow());
+
+    if (result)
+    {
+        do
+            addSpell((*result)[0].GetUInt32(), (*result)[1].GetBool(), false, false, (*result)[2].GetBool(), true);
+        while (result->NextRow());
+    }
+}
+
+void Player::_LoadGroup(PreparedQueryResult result)
+{
+    //QueryResult* result = CharacterDatabase.PQuery("SELECT guid FROM group_member WHERE memberGuid=%u", GetGUIDLow());
+    if (result)
+    {
+        if (Group* group = sGroupMgr->GetGroupByDbStoreId((*result)[0].GetUInt32()))
+        {
+            if (group->IsLeader(GetGUID()))
+                SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_GROUP_LEADER);
+
+            uint8 subgroup = group->GetMemberGroup(GetGUID());
+            SetGroup(group, subgroup);
+            if (getLevel() >= LEVELREQUIREMENT_HEROIC)
+            {
+                // the group leader may change the instance difficulty while the player is offline
+                SetDungeonDifficulty(group->GetDungeonDifficulty());
+                SetRaidDifficulty(group->GetRaidDifficulty());
+            }
+        }
+    }
+
+    if (!GetGroup() || !GetGroup()->IsLeader(GetGUID()))
+        RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_GROUP_LEADER);
+}
+
+void Player::_LoadBoundInstances(PreparedQueryResult result)
+{
+    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+        m_boundInstances[i].clear();
+
+    Group* group = GetGroup();
+
+    //QueryResult* result = CharacterDatabase.PQuery("SELECT id, permanent, map, difficulty, resettime FROM character_instance LEFT JOIN instance ON instance = id WHERE guid = '%u'", GUID_LOPART(m_guid));
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+
+            bool perm = fields[1].GetBool();
+            uint32 mapId = fields[2].GetUInt16();
+            uint32 instanceId = fields[0].GetUInt32();
+            uint8 difficulty = fields[3].GetUInt8();
+
+            time_t resetTime = time_t(fields[4].GetUInt32());
+            // the resettime for normal instances is only saved when the InstanceSave is unloaded
+            // so the value read from the DB may be wrong here but only if the InstanceSave is loaded
+            // and in that case it is not used
+
+            bool deleteInstance = false;
+
+            MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);
+            if (!mapEntry || !mapEntry->IsDungeon())
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed or not dungeon map %d", GetName().c_str(), GetGUIDLow(), mapId);
+                deleteInstance = true;
+            }
+            else if (difficulty >= MAX_DIFFICULTY)
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed difficulty %d instance for map %u", GetName().c_str(), GetGUIDLow(), difficulty, mapId);
+                deleteInstance = true;
+            }
+            else
+            {
+                MapDifficulty const* mapDiff = GetMapDifficultyData(mapId, Difficulty(difficulty));
+                if (!mapDiff)
+                {
+                    sLog->outError(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed difficulty %d instance for map %u", GetName().c_str(), GetGUIDLow(), difficulty, mapId);
+                    deleteInstance = true;
+                }
+                else if (!perm && group)
+                {
+                    sLog->outError(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) is in group %d but has a non-permanent character bind to map %d, %d, %d", GetName().c_str(), GetGUIDLow(), GUID_LOPART(group->GetGUID()), mapId, instanceId, difficulty);
+                    deleteInstance = true;
+                }
+            }
+
+            if (deleteInstance)
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);
+
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt32(1, instanceId);
+
+                CharacterDatabase.Execute(stmt);
+
+                continue;
+            }
+
+            // since non permanent binds are always solo bind, they can always be reset
+            if (InstanceSave* save = sInstanceSaveMgr->AddInstanceSave(mapId, instanceId, Difficulty(difficulty), resetTime, !perm, true))
+               BindToInstance(save, perm, true);
+        }
+        while (result->NextRow());
+    }
+}
+
+InstancePlayerBind* Player::GetBoundInstance(uint32 mapid, Difficulty difficulty)
+{
+    // some instances only have one difficulty
+    MapDifficulty const* mapDiff = GetDownscaledMapDifficultyData(mapid, difficulty);
+    if (!mapDiff)
+        return NULL;
+
+    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapid);
+    if (itr != m_boundInstances[difficulty].end())
+        return &itr->second;
+    else
+        return NULL;
+}
+
+InstanceSave* Player::GetInstanceSave(uint32 mapid, bool raid)
+{
+    InstancePlayerBind* pBind = GetBoundInstance(mapid, GetDifficulty(raid));
+    InstanceSave* pSave = pBind ? pBind->save : NULL;
+    if (!pBind || !pBind->perm)
+        if (Group* group = GetGroup())
+            if (InstanceGroupBind* groupBind = group->GetBoundInstance(this))
+                pSave = groupBind->save;
+
+    return pSave;
+}
+
+void Player::UnbindInstance(uint32 mapid, Difficulty difficulty, bool unload)
+{
+    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapid);
+    UnbindInstance(itr, difficulty, unload);
+}
+
+void Player::UnbindInstance(BoundInstancesMap::iterator &itr, Difficulty difficulty, bool unload)
+{
+    if (itr != m_boundInstances[difficulty].end())
+    {
+        if (!unload)
+        {
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);
+
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, itr->second.save->GetInstanceId());
+
+            CharacterDatabase.Execute(stmt);
+        }
+
+        if (itr->second.perm)
+            GetSession()->SendCalendarRaidLockout(itr->second.save, false);
+
+        itr->second.save->RemovePlayer(this);               // save can become invalid
+        m_boundInstances[difficulty].erase(itr++);
+    }
+}
+
+InstancePlayerBind* Player::BindToInstance(InstanceSave* save, bool permanent, bool load)
+{
+    if (save)
+    {
+        InstancePlayerBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
+        if (!load)
+        {
+            if (bind.save)
+            {
+                // update the save when the group kills a boss
+                if (permanent != bind.perm || save != bind.save)
+                {
+                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_INSTANCE);
+
+                    stmt->setUInt32(0, save->GetInstanceId());
+                    stmt->setBool(1, permanent);
+                    stmt->setUInt32(2, GetGUIDLow());
+                    stmt->setUInt32(3, bind.save->GetInstanceId());
+
+                    CharacterDatabase.Execute(stmt);
+                }
+            }
+            else
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_INSTANCE);
+
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt32(1, save->GetInstanceId());
+                stmt->setBool(2, permanent);
+
+                CharacterDatabase.Execute(stmt);
+            }
+        }
+
+        if (bind.save != save)
+        {
+            if (bind.save)
+                bind.save->RemovePlayer(this);
+            save->AddPlayer(this);
+        }
+
+        if (permanent)
+            save->SetCanReset(false);
+
+        bind.save = save;
+        bind.perm = permanent;
+        if (!load)
+            sLog->outDebug(LOG_FILTER_MAPS, "Player::BindToInstance: %s(%d) is now bound to map %d, instance %d, difficulty %d", GetName().c_str(), GetGUIDLow(), save->GetMapId(), save->GetInstanceId(), save->GetDifficulty());
+        sScriptMgr->OnPlayerBindToInstance(this, save->GetDifficulty(), save->GetMapId(), permanent);
+        return &bind;
+    }
+
+    return NULL;
+}
+
+void Player::BindToInstance()
+{
+    InstanceSave* mapSave = sInstanceSaveMgr->GetInstanceSave(_pendingBindId);
+    if (!mapSave) //it seems sometimes mapSave is NULL, but I did not check why
+        return;
+
+    WorldPacket data(SMSG_INSTANCE_SAVE_CREATED, 4);
+    data << uint32(0);
+    GetSession()->SendPacket(&data);
+    BindToInstance(mapSave, true);
+
+    GetSession()->SendCalendarRaidLockout(mapSave, true);
+}
+
+void Player::SendRaidInfo()
+{
+    uint32 counter = 0;
+
+    WorldPacket data(SMSG_RAID_INSTANCE_INFO, 4);
+
+    size_t p_counter = data.wpos();
+    data << uint32(counter);                                // placeholder
+
+    time_t now = time(NULL);
+
+    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+    {
+        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
+        {
+            if (itr->second.perm)
+            {
+                InstanceSave* save = itr->second.save;
+                bool isHeroic = save->GetDifficulty() == RAID_DIFFICULTY_10MAN_HEROIC || save->GetDifficulty() == RAID_DIFFICULTY_25MAN_HEROIC;
+                uint32 completedEncounters = 0;
+                if (Map* map = sMapMgr->FindMap(save->GetMapId(), save->GetInstanceId()))
+                    if (InstanceScript* instanceScript = ((InstanceMap*)map)->GetInstanceScript())
+                        completedEncounters = instanceScript->GetCompletedEncounterMask();
+
+                data << uint32(save->GetMapId());           // map id
+                data << uint32(save->GetDifficulty());      // difficulty
+                data << uint32(isHeroic);                   // heroic
+                data << uint64(save->GetInstanceId());      // instance id
+                data << uint8(1);                           // expired = 0
+                data << uint8(0);                           // extended = 1
+                data << uint32(save->GetResetTime() - now); // reset time
+                data << uint32(completedEncounters);        // completed encounters mask
+                ++counter;
+            }
+        }
+    }
+
+    data.put<uint32>(p_counter, counter);
+    GetSession()->SendPacket(&data);
+}
+
+/*
+- called on every successful teleportation to a map
+*/
+void Player::SendSavedInstances()
+{
+    bool hasBeenSaved = false;
+    WorldPacket data;
+
+    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+    {
+        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
+        {
+            if (itr->second.perm)                               // only permanent binds are sent
+            {
+                hasBeenSaved = true;
+                break;
+            }
+        }
+    }
+
+    //Send opcode SMSG_UPDATE_INSTANCE_OWNERSHIP. true or false means, whether you have current raid/heroic instances
+    data.Initialize(SMSG_UPDATE_INSTANCE_OWNERSHIP, 4);
+    data << uint32(hasBeenSaved);
+    GetSession()->SendPacket(&data);
+
+    if (!hasBeenSaved)
+        return;
+
+    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+    {
+        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
+        {
+            if (itr->second.perm)
+            {
+                data.Initialize(SMSG_UPDATE_LAST_INSTANCE, 4);
+                data << uint32(itr->second.save->GetMapId());
+                GetSession()->SendPacket(&data);
+            }
+        }
+    }
+}
+
+/// convert the player's binds to the group
+void Player::ConvertInstancesToGroup(Player* player, Group* group, bool switchLeader)
+{
+    // copy all binds to the group, when changing leader it's assumed the character
+    // will not have any solo binds
+
+    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+    {
+        for (BoundInstancesMap::iterator itr = player->m_boundInstances[i].begin(); itr != player->m_boundInstances[i].end();)
+        {
+            group->BindToInstance(itr->second.save, itr->second.perm, false);
+            // permanent binds are not removed
+            if (switchLeader && !itr->second.perm)
+            {
+                // increments itr in call
+                player->UnbindInstance(itr, Difficulty(i), false);
+            }
+            else
+                ++itr;
+        }
+    }
+}
+
+bool Player::Satisfy(AccessRequirement const* ar, uint32 target_map, bool report)
+{
+    if (!isGameMaster() && ar)
+    {
+        uint8 LevelMin = 0;
+        uint8 LevelMax = 0;
+
+        MapEntry const* mapEntry = sMapStore.LookupEntry(target_map);
+        if (!mapEntry)
+            return false;
+
+        if (!sWorld->getBoolConfig(CONFIG_INSTANCE_IGNORE_LEVEL))
+        {
+            if (ar->levelMin && getLevel() < ar->levelMin)
+                LevelMin = ar->levelMin;
+            if (ar->levelMax && getLevel() > ar->levelMax)
+                LevelMax = ar->levelMax;
+        }
+
+        uint32 missingItem = 0;
+        if (ar->item)
+        {
+            if (!HasItemCount(ar->item) &&
+                (!ar->item2 || !HasItemCount(ar->item2)))
+                missingItem = ar->item;
+        }
+        else if (ar->item2 && !HasItemCount(ar->item2))
+            missingItem = ar->item2;
+
+        if (DisableMgr::IsDisabledFor(DISABLE_TYPE_MAP, target_map, this))
+        {
+            GetSession()->SendAreaTriggerMessage("%s", GetSession()->GetTrinityString(LANG_INSTANCE_CLOSED));
+            return false;
+        }
+
+        uint32 missingQuest = 0;
+        if (GetTeam() == ALLIANCE && ar->quest_A && !GetQuestRewardStatus(ar->quest_A))
+            missingQuest = ar->quest_A;
+        else if (GetTeam() == HORDE && ar->quest_H && !GetQuestRewardStatus(ar->quest_H))
+            missingQuest = ar->quest_H;
+
+        uint32 missingAchievement = 0;
+        Player* leader = this;
+        uint64 leaderGuid = GetGroup() ? GetGroup()->GetLeaderGUID() : GetGUID();
+        if (leaderGuid != GetGUID())
+            leader = ObjectAccessor::FindPlayer(leaderGuid);
+
+        if (ar->achievement)
+            if (!leader || !leader->HasAchieved(ar->achievement))
+                missingAchievement = ar->achievement;
+
+        Difficulty target_difficulty = GetDifficulty(mapEntry->IsRaid());
+        MapDifficulty const* mapDiff = GetDownscaledMapDifficultyData(target_map, target_difficulty);
+        if (LevelMin || LevelMax || missingItem || missingQuest || missingAchievement)
+        {
+            if (report)
+            {
+                if (missingQuest && !ar->questFailedText.empty())
+                    ChatHandler(GetSession()).PSendSysMessage("%s", ar->questFailedText.c_str());
+                else if (mapDiff->hasErrorMessage) // if (missingAchievement) covered by this case
+                    SendTransferAborted(target_map, TRANSFER_ABORT_DIFFICULTY, target_difficulty);
+                else if (missingItem)
+                    GetSession()->SendAreaTriggerMessage(GetSession()->GetTrinityString(LANG_LEVEL_MINREQUIRED_AND_ITEM), LevelMin, sObjectMgr->GetItemTemplate(missingItem)->Name1.c_str());
+                else if (LevelMin)
+                    GetSession()->SendAreaTriggerMessage(GetSession()->GetTrinityString(LANG_LEVEL_MINREQUIRED), LevelMin);
+            }
+            return false;
+        }
+    }
+    return true;
+}
+
+bool Player::CheckInstanceLoginValid()
+{
+    if (!GetMap())
+        return false;
+
+    if (!GetMap()->IsDungeon() || isGameMaster())
+        return true;
+
+    if (GetMap()->IsRaid())
+    {
+        // cannot be in raid instance without a group
+        if (!GetGroup())
+            return false;
+    }
+    else
+    {
+        // cannot be in normal instance without a group and more players than 1 in instance
+        if (!GetGroup() && GetMap()->GetPlayersCountExceptGMs() > 1)
+            return false;
+    }
+
+    // do checks for satisfy accessreqs, instance full, encounter in progress (raid), perm bind group != perm bind player
+    return sMapMgr->CanPlayerEnter(GetMap()->GetId(), this, true);
+}
+
+bool Player::CheckInstanceCount(uint32 instanceId) const
+{
+    if (_instanceResetTimes.size() < sWorld->getIntConfig(CONFIG_MAX_INSTANCES_PER_HOUR))
+        return true;
+    return _instanceResetTimes.find(instanceId) != _instanceResetTimes.end();
+}
+
+
+bool Player::_LoadHomeBind(PreparedQueryResult result)
+{
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+    if (!info)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player (Name %s) has incorrect race/class (%u/%u) pair. Can't be loaded.",
+            GetName().c_str(), uint32(getRace()), uint32(getClass()));
+        return false;
+    }
+
+    bool ok = false;
+    // SELECT mapId, zoneId, posX, posY, posZ FROM character_homebind WHERE guid = ?
+    if (result)
+    {
+        Field* fields = result->Fetch();
+
+        m_homebindMapId = fields[0].GetUInt16();
+        m_homebindAreaId = fields[1].GetUInt16();
+        m_homebindX = fields[2].GetFloat();
+        m_homebindY = fields[3].GetFloat();
+        m_homebindZ = fields[4].GetFloat();
+
+        MapEntry const* bindMapEntry = sMapStore.LookupEntry(m_homebindMapId);
+
+        // accept saved data only for valid position (and non instanceable), and accessable
+        if (MapManager::IsValidMapCoord(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ) &&
+            !bindMapEntry->Instanceable() && GetSession()->Expansion() >= bindMapEntry->Expansion())
+            ok = true;
+        else
+        {
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
+            stmt->setUInt32(0, GetGUIDLow());
+            CharacterDatabase.Execute(stmt);
+        }
+    }
+
+    if (!ok)
+    {
+        m_homebindMapId = info->mapId;
+        m_homebindAreaId = info->areaId;
+        m_homebindX = info->positionX;
+        m_homebindY = info->positionY;
+        m_homebindZ = info->positionZ;
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PLAYER_HOMEBIND);
+        stmt->setUInt32(0, GetGUIDLow());
+        stmt->setUInt16(1, m_homebindMapId);
+        stmt->setUInt16(2, m_homebindAreaId);
+        stmt->setFloat (3, m_homebindX);
+        stmt->setFloat (4, m_homebindY);
+        stmt->setFloat (5, m_homebindZ);
+        CharacterDatabase.Execute(stmt);
+    }
+
+    sLog->outDebug(LOG_FILTER_PLAYER, "Setting player home position - mapid: %u, areaid: %u, X: %f, Y: %f, Z: %f",
+        m_homebindMapId, m_homebindAreaId, m_homebindX, m_homebindY, m_homebindZ);
+
+    return true;
+}
+
+/*********************************************************/
+/***                   SAVE SYSTEM                     ***/
+/*********************************************************/
+
+void Player::SaveToDB(bool create /*=false*/)
+{
+    // delay auto save at any saves (manual, in code, or autosave)
+    m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);
+
+    //lets allow only players in world to be saved
+    if (IsBeingTeleportedFar())
+    {
+        ScheduleDelayedOperation(DELAYED_SAVE_PLAYER);
+        return;
+    }
+
+    // first save/honor gain after midnight will also update the player's honor fields
+    UpdateHonorFields();
+
+    sLog->outDebug(LOG_FILTER_UNITS, "The value of player %s at save: ", m_name.c_str());
+    outDebugValues();
+
+    PreparedStatement* stmt = NULL;
+    uint8 index = 0;
+
+    if (create)
+    {
+        //! Insert query
+        //! TO DO: Filter out more redundant fields that can take their default value at player create
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER);
+        stmt->setUInt32(index++, GetGUIDLow());
+        stmt->setUInt32(index++, GetSession()->GetAccountId());
+        stmt->setString(index++, GetName());
+        stmt->setUInt8(index++, getRace());
+        stmt->setUInt8(index++, getClass());
+        stmt->setUInt8(index++, getGender());
+        stmt->setUInt8(index++, getLevel());
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_XP));
+        stmt->setUInt64(index++, GetMoney());
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_BYTES));
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_BYTES_2));
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FLAGS));
+        stmt->setUInt16(index++, (uint16)GetMapId());
+        stmt->setUInt32(index++, (uint32)GetInstanceId());
+        stmt->setUInt8(index++, (uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4));
+        stmt->setFloat(index++, finiteAlways(GetPositionX()));
+        stmt->setFloat(index++, finiteAlways(GetPositionY()));
+        stmt->setFloat(index++, finiteAlways(GetPositionZ()));
+        stmt->setFloat(index++, finiteAlways(GetOrientation()));
+
+        std::ostringstream ss;
+        ss << m_taxi;
+        stmt->setString(index++, ss.str());
+        stmt->setUInt8(index++, m_cinematic);
+        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_TOTAL]);
+        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_LEVEL]);
+        stmt->setFloat(index++, finiteAlways(m_rest_bonus));
+        stmt->setUInt32(index++, uint32(time(NULL)));
+        stmt->setUInt8(index++,  (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0));
+        //save, far from tavern/city
+        //save, but in tavern/city
+        stmt->setUInt32(index++, GetTalentResetCost());
+        stmt->setUInt32(index++, GetTalentResetTime());
+
+        ss.str("");
+        for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
+            ss << GetPrimaryTalentTree(i) << " ";
+        stmt->setString(index++, ss.str());
+        stmt->setUInt16(index++, (uint16)m_ExtraFlags);
+        stmt->setUInt8(index++,  0/*m_stableSlots*/);
+        stmt->setUInt16(index++, (uint16)m_atLoginFlags);
+        stmt->setUInt16(index++, GetZoneId());
+        stmt->setUInt32(index++, uint32(m_deathExpireTime));
+
+        ss.str("");
+        ss << m_taxi.SaveTaxiDestinationsToString();
+
+        stmt->setString(index++, ss.str());
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
+        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_KILLS, 0));
+        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_KILLS, 1));
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_CHOSEN_TITLE));
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX));
+        stmt->setUInt8(index++, GetDrunkValue());
+        stmt->setUInt32(index++, GetHealth());
+
+        uint32 storedPowers = 0;
+        for (uint32 i = 0; i < MAX_POWERS; ++i)
+        {
+            if (GetPowerIndex(i) != MAX_POWERS)
+            {
+                stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_POWER1 + storedPowers));
+                if (++storedPowers >= MAX_POWERS_PER_CLASS)
+                    break;
+            }
+        }
+
+        for (; storedPowers < MAX_POWERS_PER_CLASS; ++storedPowers)
+            stmt->setUInt32(index++, 0);
+
+        stmt->setUInt32(index++, GetSession()->GetLatency());
+
+        stmt->setUInt8(index++, GetSpecsCount());
+        stmt->setUInt8(index++, GetActiveSpec());
+
+        ss.str("");
+        for (uint32 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
+            ss << GetUInt32Value(PLAYER_EXPLORED_ZONES_1 + i) << ' ';
+        stmt->setString(index++, ss.str());
+
+        ss.str("");
+        // cache equipment...
+        for (uint32 i = 0; i < EQUIPMENT_SLOT_END * 2; ++i)
+            ss << GetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + i) << ' ';
+
+        // ...and bags for enum opcode
+        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        {
+            if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                ss << item->GetEntry();
+            else
+                ss << '0';
+            ss << " 0 ";
+        }
+        stmt->setString(index++, ss.str());
+
+        ss.str("");
+        for (uint32 i = 0; i < KNOWN_TITLES_SIZE*2; ++i)
+            ss << GetUInt32Value(PLAYER__FIELD_KNOWN_TITLES + i) << ' ';
+        stmt->setString(index++, ss.str());
+
+        stmt->setUInt8(index++, GetByteValue(PLAYER_FIELD_BYTES, 2));
+        stmt->setUInt32(index++, m_grantableLevels);
+        stmt->setUInt32(index++, GetAchievementPoints());
+		stmt->setUInt8(index++, _currentPetSlot);
+    }
+    else
+    {
+        // Update query
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER);
+        stmt->setString(index++, GetName());
+        stmt->setUInt8(index++, getRace());
+        stmt->setUInt8(index++, getClass());
+        stmt->setUInt8(index++, getGender());
+        stmt->setUInt8(index++, getLevel());
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_XP));
+        stmt->setUInt64(index++, GetMoney());
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_BYTES));
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_BYTES_2));
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FLAGS));
+
+        if (!IsBeingTeleported())
+        {
+            stmt->setUInt16(index++, (uint16)GetMapId());
+            stmt->setUInt32(index++, (uint32)GetInstanceId());
+            stmt->setUInt8(index++, (uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4));
+            stmt->setFloat(index++, finiteAlways(GetPositionX()));
+            stmt->setFloat(index++, finiteAlways(GetPositionY()));
+            stmt->setFloat(index++, finiteAlways(GetPositionZ()));
+            stmt->setFloat(index++, finiteAlways(GetOrientation()));
+        }
+        else
+        {
+            stmt->setUInt16(index++, (uint16)GetTeleportDest().GetMapId());
+            stmt->setUInt32(index++, (uint32)0);
+            stmt->setUInt8(index++, (uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4));
+            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionX()));
+            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionY()));
+            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionZ()));
+            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetOrientation()));
+        }
+
+        std::ostringstream ss;
+        ss << m_taxi;
+        stmt->setString(index++, ss.str());
+        stmt->setUInt8(index++, m_cinematic);
+        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_TOTAL]);
+        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_LEVEL]);
+        stmt->setFloat(index++, finiteAlways(m_rest_bonus));
+        stmt->setUInt32(index++, uint32(time(NULL)));
+        stmt->setUInt8(index++,  (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0));
+        //save, far from tavern/city
+        //save, but in tavern/city
+        stmt->setUInt32(index++, GetTalentResetCost());
+        stmt->setUInt32(index++, GetTalentResetTime());
+
+        ss.str("");
+        for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
+            ss << GetPrimaryTalentTree(i) << " ";
+        stmt->setString(index++, ss.str());
+        stmt->setUInt16(index++, (uint16)m_ExtraFlags);
+        stmt->setUInt8(index++,  0/*m_stableSlots*/);
+        stmt->setUInt16(index++, (uint16)m_atLoginFlags);
+        stmt->setUInt16(index++, GetZoneId());
+        stmt->setUInt32(index++, uint32(m_deathExpireTime));
+
+        ss.str("");
+        ss << m_taxi.SaveTaxiDestinationsToString();
+
+        stmt->setString(index++, ss.str());
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
+        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_KILLS, 0));
+        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_KILLS, 1));
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_CHOSEN_TITLE));
+        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX));
+        stmt->setUInt8(index++, GetDrunkValue());
+        stmt->setUInt32(index++, GetHealth());
+
+        uint32 storedPowers = 0;
+        for (uint32 i = 0; i < MAX_POWERS; ++i)
+        {
+            if (GetPowerIndex(i) != MAX_POWERS)
+            {
+                stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_POWER1 + storedPowers));
+                if (++storedPowers >= MAX_POWERS_PER_CLASS)
+                    break;
+            }
+        }
+
+        for (; storedPowers < MAX_POWERS_PER_CLASS; ++storedPowers)
+            stmt->setUInt32(index++, 0);
+
+        stmt->setUInt32(index++, GetSession()->GetLatency());
+
+        stmt->setUInt8(index++, GetSpecsCount());
+        stmt->setUInt8(index++, GetActiveSpec());
+
+        ss.str("");
+        for (uint32 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
+            ss << GetUInt32Value(PLAYER_EXPLORED_ZONES_1 + i) << ' ';
+        stmt->setString(index++, ss.str());
+
+        ss.str("");
+        // cache equipment...
+        for (uint32 i = 0; i < EQUIPMENT_SLOT_END * 2; ++i)
+            ss << GetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + i) << ' ';
+
+        // ...and bags for enum opcode
+        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        {
+            if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                ss << item->GetEntry();
+            else
+                ss << '0';
+            ss << " 0 ";
+        }
+
+        stmt->setString(index++, ss.str());
+
+        ss.str("");
+        for (uint32 i = 0; i < KNOWN_TITLES_SIZE*2; ++i)
+            ss << GetUInt32Value(PLAYER__FIELD_KNOWN_TITLES + i) << ' ';
+
+        stmt->setString(index++, ss.str());
+        stmt->setUInt8(index++, GetByteValue(PLAYER_FIELD_BYTES, 2));
+        stmt->setUInt32(index++, m_grantableLevels);
+        stmt->setUInt32(index++, GetAchievementPoints());
+
+        stmt->setUInt8(index++, IsInWorld() ? 1 : 0);
+		stmt->setUInt8(index++, _currentPetSlot);
+        // Index
+        stmt->setUInt32(index++, GetGUIDLow());
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    trans->Append(stmt);
+
+    if (m_mailsUpdated)                                     //save mails only when needed
+        _SaveMail(trans);
+
+    _SaveBGData(trans);
+    _SaveInventory(trans);
+    _SaveVoidStorage(trans);
+    _SaveQuestStatus(trans);
+    _SaveDailyQuestStatus(trans);
+    _SaveWeeklyQuestStatus(trans);
+    _SaveSeasonalQuestStatus(trans);
+    _SaveMonthlyQuestStatus(trans);
+    _SaveTalents(trans);
+    _SaveSpells(trans);
+    _SaveSpellCooldowns(trans);
+    _SaveActions(trans);
+    _SaveAuras(trans);
+    _SaveSkills(trans);
+    m_achievementMgr->SaveToDB(trans);
+    m_reputationMgr->SaveToDB(trans);
+    _SaveEquipmentSets(trans);
+    GetSession()->SaveTutorialsData(trans);                 // changed only while character in game
+    _SaveGlyphs(trans);
+    _SaveInstanceTimeRestrictions(trans);
+    _SaveCurrency(trans);
+    _SaveCUFProfiles(trans);
+
+    if (Pet* pet = GetPet())
+        pet->SavePet(PET_SLOT_ACTUAL_PET_SLOT);
+    _SavePets(trans);
+
+    // check if stats should only be saved on logout
+    // save stats can be out of transaction
+    if (m_session->isLogingOut() || !sWorld->getBoolConfig(CONFIG_STATS_SAVE_ONLY_ON_LOGOUT))
+        _SaveStats(trans);
+
+    CharacterDatabase.CommitTransaction(trans);
+    GetArcheologyMgr().SaveArcheology();
+
+
+
+
+
+}
+
+// fast save function for item/money cheating preventing - save only inventory and money state
+void Player::SaveInventoryAndGoldToDB(SQLTransaction& trans)
+{
+    _SaveInventory(trans);
+    _SaveCurrency(trans);
+    SaveGoldToDB(trans);
+}
+
+void Player::SaveGoldToDB(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_MONEY);
+    stmt->setUInt64(0, GetMoney());
+    stmt->setUInt32(1, GetGUIDLow());
+    trans->Append(stmt);
+}
+
+void Player::_SaveActions(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = NULL;
+
+    for (ActionButtonList::iterator itr = m_actionButtons.begin(); itr != m_actionButtons.end();)
+    {
+        switch (itr->second.uState)
+        {
+            case ACTIONBUTTON_NEW:
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_ACTION);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt8(1, GetActiveSpec());
+                stmt->setUInt8(2, itr->first);
+                stmt->setUInt32(3, itr->second.GetAction());
+                stmt->setUInt8(4, uint8(itr->second.GetType()));
+                trans->Append(stmt);
+
+                itr->second.uState = ACTIONBUTTON_UNCHANGED;
+                ++itr;
+                break;
+            case ACTIONBUTTON_CHANGED:
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ACTION);
+                stmt->setUInt32(0, itr->second.GetAction());
+                stmt->setUInt8(1, uint8(itr->second.GetType()));
+                stmt->setUInt32(2,  GetGUIDLow());
+                stmt->setUInt8(3, itr->first);
+                stmt->setUInt8(4, GetActiveSpec());
+                trans->Append(stmt);
+
+                itr->second.uState = ACTIONBUTTON_UNCHANGED;
+                ++itr;
+                break;
+            case ACTIONBUTTON_DELETED:
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION_BY_BUTTON_SPEC);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt8(1, itr->first);
+                stmt->setUInt8(2, GetActiveSpec());
+                trans->Append(stmt);
+
+                m_actionButtons.erase(itr++);
+                break;
+            default:
+                ++itr;
+                break;
+        }
+    }
+}
+
+void Player::_SaveAuras(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+
+    for (AuraMap::const_iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end(); ++itr)
+    {
+        if (!itr->second->CanBeSaved())
+            continue;
+
+        Aura* aura = itr->second;
+
+        int32 damage[MAX_SPELL_EFFECTS];
+        int32 baseDamage[MAX_SPELL_EFFECTS];
+        uint8 effMask = 0;
+        uint8 recalculateMask = 0;
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (AuraEffect const* effect = aura->GetEffect(i))
+            {
+                baseDamage[i] = effect->GetBaseAmount();
+                damage[i] = effect->GetAmount();
+                effMask |= 1 << i;
+                if (effect->CanBeRecalculated())
+                    recalculateMask |= 1 << i;
+            }
+            else
+            {
+                baseDamage[i] = 0;
+                damage[i] = 0;
+            }
+        }
+
+        uint8 index = 0;
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_AURA);
+        stmt->setUInt32(index++, GetGUIDLow());
+        stmt->setUInt64(index++, itr->second->GetCasterGUID());
+        stmt->setUInt64(index++, itr->second->GetCastItemGUID());
+        stmt->setUInt32(index++, itr->second->GetId());
+        stmt->setUInt8(index++, effMask);
+        stmt->setUInt8(index++, recalculateMask);
+        stmt->setUInt8(index++, itr->second->GetStackAmount());
+        stmt->setInt32(index++, damage[0]);
+        stmt->setInt32(index++, damage[1]);
+        stmt->setInt32(index++, damage[2]);
+        stmt->setInt32(index++, baseDamage[0]);
+        stmt->setInt32(index++, baseDamage[1]);
+        stmt->setInt32(index++, baseDamage[2]);
+        stmt->setInt32(index++, itr->second->GetMaxDuration());
+        stmt->setInt32(index++, itr->second->GetDuration());
+        stmt->setUInt8(index, itr->second->GetCharges());
+        trans->Append(stmt);
+    }
+}
+
+void Player::_SaveInventory(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = NULL;
+    // force items in buyback slots to new state
+    // and remove those that aren't already
+    for (uint8 i = BUYBACK_SLOT_START; i < BUYBACK_SLOT_END; ++i)
+    {
+        Item* item = m_items[i];
+        if (!item || item->GetState() == ITEM_NEW)
+            continue;
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
+        stmt->setUInt32(0, item->GetGUIDLow());
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
+        stmt->setUInt32(0, item->GetGUIDLow());
+        trans->Append(stmt);
+        m_items[i]->FSetState(ITEM_NEW);
+    }
+
+    // Updated played time for refundable items. We don't do this in Player::Update because there's simply no need for it,
+    // the client auto counts down in real time after having received the initial played time on the first
+    // SMSG_ITEM_REFUND_INFO_RESPONSE packet.
+    // Item::UpdatePlayedTime is only called when needed, which is in DB saves, and item refund info requests.
+    std::set<uint32>::iterator i_next;
+    for (std::set<uint32>::iterator itr = m_refundableItems.begin(); itr!= m_refundableItems.end(); itr = i_next)
+    {
+        // use copy iterator because itr may be invalid after operations in this loop
+        i_next = itr;
+        ++i_next;
+
+        Item* iPtr = GetItemByGuid(MAKE_NEW_GUID(*itr, 0, HIGHGUID_ITEM));
+        if (iPtr)
+        {
+            iPtr->UpdatePlayedTime(this);
+            continue;
+        }
+        else
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Can't find item guid %u but is in refundable storage for player %u ! Removing.", *itr, GetGUIDLow());
+            m_refundableItems.erase(itr);
+        }
+    }
+
+    // update enchantment durations
+    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
+        itr->item->SetEnchantmentDuration(itr->slot, itr->leftduration, this);
+
+    // if no changes
+    if (m_itemUpdateQueue.empty())
+        return;
+
+    uint32 lowGuid = GetGUIDLow();
+    for (size_t i = 0; i < m_itemUpdateQueue.size(); ++i)
+    {
+        Item* item = m_itemUpdateQueue[i];
+        if (!item)
+            continue;
+
+        Bag* container = item->GetContainer();
+        uint32 bag_guid = container ? container->GetGUIDLow() : 0;
+
+        if (item->GetState() != ITEM_REMOVED)
+        {
+            Item* test = GetItemByPos(item->GetBagSlot(), item->GetSlot());
+            if (test == NULL)
+            {
+                uint32 bagTestGUID = 0;
+                if (Item* test2 = GetItemByPos(INVENTORY_SLOT_BAG_0, item->GetBagSlot()))
+                    bagTestGUID = test2->GetGUIDLow();
+                sLog->outError(LOG_FILTER_PLAYER, "Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u (state %d) are incorrect, the player doesn't have an item at that position!", lowGuid, GetName().c_str(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), (int32)item->GetState());
+                // according to the test that was just performed nothing should be in this slot, delete
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_BAG_SLOT);
+                stmt->setUInt32(0, bagTestGUID);
+                stmt->setUInt8(1, item->GetSlot());
+                stmt->setUInt32(2, lowGuid);
+                trans->Append(stmt);
+
+                // also THIS item should be somewhere else, cheat attempt
+                item->FSetState(ITEM_REMOVED); // we are IN updateQueue right now, can't use SetState which modifies the queue
+                DeleteRefundReference(item->GetGUIDLow());
+                // don't skip, let the switch delete it
+                //continue;
+            }
+            else if (test != item)
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u are incorrect, the item with guid %u is there instead!", lowGuid, GetName().c_str(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), test->GetGUIDLow());
+                // save all changes to the item...
+                if (item->GetState() != ITEM_NEW) // only for existing items, no dupes
+                    item->SaveToDB(trans);
+                // ...but do not save position in inventory
+                continue;
+            }
+        }
+
+        switch (item->GetState())
+        {
+            case ITEM_NEW:
+            case ITEM_CHANGED:
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_INVENTORY_ITEM);
+                stmt->setUInt32(0, lowGuid);
+                stmt->setUInt32(1, bag_guid);
+                stmt->setUInt8 (2, item->GetSlot());
+                stmt->setUInt32(3, item->GetGUIDLow());
+                trans->Append(stmt);
+                break;
+            case ITEM_REMOVED:
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
+                stmt->setUInt32(0, item->GetGUIDLow());
+                trans->Append(stmt);
+            case ITEM_UNCHANGED:
+                break;
+        }
+
+        item->SaveToDB(trans);                                   // item have unchanged inventory record and can be save standalone
+    }
+    m_itemUpdateQueue.clear();
+}
+
+void Player::_SaveVoidStorage(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = NULL;
+    uint32 lowGuid = GetGUIDLow();
+
+    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
+    {
+        if (!_voidStorageItems[i]) // unused item
+        {
+            // DELETE FROM void_storage WHERE slot = ? AND playerGuid = ?
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_VOID_STORAGE_ITEM_BY_SLOT);
+            stmt->setUInt8(0, i);
+            stmt->setUInt32(1, lowGuid);
+        }
+        else
+        {
+            // REPLACE INTO character_inventory (itemId, playerGuid, itemEntry, slot, creatorGuid) VALUES (?, ?, ?, ?, ?)
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_VOID_STORAGE_ITEM);
+            stmt->setUInt64(0, _voidStorageItems[i]->ItemId);
+            stmt->setUInt32(1, lowGuid);
+            stmt->setUInt32(2, _voidStorageItems[i]->ItemEntry);
+            stmt->setUInt8(3, i);
+            stmt->setUInt32(4, _voidStorageItems[i]->CreatorGuid);
+            stmt->setUInt32(5, _voidStorageItems[i]->ItemRandomPropertyId);
+            stmt->setUInt32(6, _voidStorageItems[i]->ItemSuffixFactor);
+        }
+
+        trans->Append(stmt);
+    }
+}
+
+
+void Player::_SaveCUFProfiles(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = NULL;
+    uint32 lowGuid = GetGUIDLow();
+
+    for (uint8 i = 0; i < MAX_CUF_PROFILES; ++i)
+    {
+        if (!_CUFProfiles[i]) // unused profile
+        {
+            // DELETE FROM character_cuf_profiles WHERE guid = ? and id = ?
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_CUF_PROFILES);
+            stmt->setUInt32(0, lowGuid);
+            stmt->setUInt8(1, i);
+        }
+        else
+        {
+            // REPLACE INTO character_cuf_profiles (guid, id, name, frameHeight, frameWidth, sortBy, healthText, boolOptions, unk146, unk147, unk148, unk150, unk152, unk154) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_CUF_PROFILES);
+            stmt->setUInt32(0, lowGuid);
+            stmt->setUInt8(1, i);
+            stmt->setString(2, _CUFProfiles[i]->ProfileName);
+            stmt->setUInt16(3, _CUFProfiles[i]->FrameHeight);
+            stmt->setUInt16(4, _CUFProfiles[i]->FrameWidth);
+            stmt->setUInt8(5, _CUFProfiles[i]->SortBy);
+            stmt->setUInt8(6, _CUFProfiles[i]->HealthText);
+            stmt->setUInt32(7, _CUFProfiles[i]->BoolOptions.to_ulong()); // 27 of 32 fields used, fits in an int
+            stmt->setUInt8(8, _CUFProfiles[i]->Unk146);
+            stmt->setUInt8(9, _CUFProfiles[i]->Unk147);
+            stmt->setUInt8(10, _CUFProfiles[i]->Unk148);
+            stmt->setUInt16(11, _CUFProfiles[i]->Unk150);
+            stmt->setUInt16(12, _CUFProfiles[i]->Unk152);
+            stmt->setUInt16(13, _CUFProfiles[i]->Unk154);
+        }
+
+        trans->Append(stmt);
+    }
+}
+
+void Player::_SaveMail(SQLTransaction& trans)
+{
+    if (!m_mailsLoaded)
+        return;
+
+    PreparedStatement* stmt = NULL;
+
+    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
+    {
+        Mail* m = (*itr);
+        if (m->state == MAIL_STATE_CHANGED)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_MAIL);
+            stmt->setUInt8(0, uint8(m->HasItems() ? 1 : 0));
+            stmt->setUInt32(1, uint32(m->expire_time));
+            stmt->setUInt32(2, uint32(m->deliver_time));
+            stmt->setUInt32(3, m->money);
+            stmt->setUInt32(4, m->COD);
+            stmt->setUInt8(5, uint8(m->checked));
+            stmt->setUInt32(6, m->messageID);
+
+            trans->Append(stmt);
+
+            if (!m->removedItems.empty())
+            {
+                for (std::vector<uint32>::iterator itr2 = m->removedItems.begin(); itr2 != m->removedItems.end(); ++itr2)
+                {
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
+                    stmt->setUInt32(0, *itr2);
+                    trans->Append(stmt);
+                }
+                m->removedItems.clear();
+            }
+            m->state = MAIL_STATE_UNCHANGED;
+        }
+        else if (m->state == MAIL_STATE_DELETED)
+        {
+            if (m->HasItems())
+            {
+                for (MailItemInfoVec::iterator itr2 = m->items.begin(); itr2 != m->items.end(); ++itr2)
+                {
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
+                    stmt->setUInt32(0, itr2->item_guid);
+                    trans->Append(stmt);
+                }
+            }
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
+            stmt->setUInt32(0, m->messageID);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
+            stmt->setUInt32(0, m->messageID);
+            trans->Append(stmt);
+        }
+    }
+
+    //deallocate deleted mails...
+    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end();)
+    {
+        if ((*itr)->state == MAIL_STATE_DELETED)
+        {
+            Mail* m = *itr;
+            m_mail.erase(itr);
+            delete m;
+            itr = m_mail.begin();
+        }
+        else
+            ++itr;
+    }
+
+    m_mailsUpdated = false;
+}
+
+void Player::_SaveQuestStatus(SQLTransaction& trans)
+{
+    bool isTransaction = !trans.null();
+    if (!isTransaction)
+        trans = CharacterDatabase.BeginTransaction();
+
+    QuestStatusSaveMap::iterator saveItr;
+    QuestStatusMap::iterator statusItr;
+    PreparedStatement* stmt = NULL;
+
+    bool keepAbandoned = !(sWorld->GetCleaningFlags() & CharacterDatabaseCleaner::CLEANING_FLAG_QUESTSTATUS);
+
+    for (saveItr = m_QuestStatusSave.begin(); saveItr != m_QuestStatusSave.end(); ++saveItr)
+    {
+        if (saveItr->second)
+        {
+            statusItr = m_QuestStatus.find(saveItr->first);
+            if (statusItr != m_QuestStatus.end() && (keepAbandoned || statusItr->second.Status != QUEST_STATUS_NONE))
+            {
+                uint8 index = 0;
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_QUESTSTATUS);
+
+                stmt->setUInt32(index++, GetGUIDLow());
+                stmt->setUInt32(index++, statusItr->first);
+                stmt->setUInt8(index++, uint8(statusItr->second.Status));
+                stmt->setBool(index++, statusItr->second.Explored);
+                stmt->setUInt32(index++, uint32(statusItr->second.Timer / IN_MILLISECONDS+ sWorld->GetGameTime()));
+
+                for (uint8 i = 0; i < 4; i++)
+                    stmt->setUInt16(index++, statusItr->second.CreatureOrGOCount[i]);
+
+                for (uint8 i = 0; i < 4; i++)
+                    stmt->setUInt16(index++, statusItr->second.ItemCount[i]);
+
+                stmt->setUInt16(index, statusItr->second.PlayerCount);
+                trans->Append(stmt);
+            }
+        }
+        else
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_BY_QUEST);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, saveItr->first);
+            trans->Append(stmt);
+        }
+    }
+
+    m_QuestStatusSave.clear();
+
+    for (saveItr = m_RewardedQuestsSave.begin(); saveItr != m_RewardedQuestsSave.end(); ++saveItr)
+    {
+        if (saveItr->second)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_QUESTSTATUS);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, saveItr->first);
+            trans->Append(stmt);
+
+        }
+        else if (!keepAbandoned)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED_BY_QUEST);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, saveItr->first);
+            trans->Append(stmt);
+        }
+    }
+
+    m_RewardedQuestsSave.clear();
+
+    if (!isTransaction)
+        CharacterDatabase.CommitTransaction(trans);
+}
+
+void Player::_SaveDailyQuestStatus(SQLTransaction& trans)
+{
+    if (!m_DailyQuestChanged)
+        return;
+
+    m_DailyQuestChanged = false;
+
+    // save last daily quest time for all quests: we need only mostly reset time for reset check anyway
+
+    // we don't need transactions here.
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_DAILY_CHAR);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+    for (uint32 quest_daily_idx = 0; quest_daily_idx < PLAYER_MAX_DAILY_QUESTS; ++quest_daily_idx)
+    {
+        if (GetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx))
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_DAILYQUESTSTATUS);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, GetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx));
+            stmt->setUInt64(2, uint64(m_lastDailyQuestTime));
+            trans->Append(stmt);
+        }
+    }
+
+    if (!m_DFQuests.empty())
+    {
+        for (DFQuestsDoneList::iterator itr = m_DFQuests.begin(); itr != m_DFQuests.end(); ++itr)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_DAILYQUESTSTATUS);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, (*itr));
+            stmt->setUInt64(2, uint64(m_lastDailyQuestTime));
+            trans->Append(stmt);
+        }
+    }
+}
+
+void Player::_SaveWeeklyQuestStatus(SQLTransaction& trans)
+{
+    if (!m_WeeklyQuestChanged || m_weeklyquests.empty())
+        return;
+
+    // we don't need transactions here.
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_WEEKLY_CHAR);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+
+    for (QuestSet::const_iterator iter = m_weeklyquests.begin(); iter != m_weeklyquests.end(); ++iter)
+    {
+        uint32 quest_id  = *iter;
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_WEEKLYQUESTSTATUS);
+        stmt->setUInt32(0, GetGUIDLow());
+        stmt->setUInt32(1, quest_id);
+        trans->Append(stmt);
+    }
+
+    m_WeeklyQuestChanged = false;
+}
+
+void Player::_SaveSeasonalQuestStatus(SQLTransaction& trans)
+{
+    if (!m_SeasonalQuestChanged || m_seasonalquests.empty())
+        return;
+
+    // we don't need transactions here.
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_SEASONAL_CHAR);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+
+    for (SeasonalEventQuestMap::const_iterator iter = m_seasonalquests.begin(); iter != m_seasonalquests.end(); ++iter)
+    {
+        uint16 event_id = iter->first;
+        for (SeasonalQuestSet::const_iterator itr = iter->second.begin(); itr != iter->second.end(); ++itr)
+        {
+            uint32 quest_id = (*itr);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_SEASONALQUESTSTATUS);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, quest_id);
+            stmt->setUInt32(2, event_id);
+            trans->Append(stmt);
+        }
+    }
+
+    m_SeasonalQuestChanged = false;
+}
+
+void Player::_SaveMonthlyQuestStatus(SQLTransaction& trans)
+{
+    if (!m_MonthlyQuestChanged || m_monthlyquests.empty())
+        return;
+
+    // we don't need transactions here.
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_MONTHLY_CHAR);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+
+    for (QuestSet::const_iterator iter = m_monthlyquests.begin(); iter != m_monthlyquests.end(); ++iter)
+    {
+        uint32 quest_id = *iter;
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_MONTHLYQUESTSTATUS);
+        stmt->setUInt32(0, GetGUIDLow());
+        stmt->setUInt32(1, quest_id);
+        trans->Append(stmt);
+    }
+
+    m_MonthlyQuestChanged = false;
+}
+
+void Player::_SaveSkills(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = NULL;
+    // we don't need transactions here.
+    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end();)
+    {
+        if (itr->second.uState == SKILL_UNCHANGED)
+        {
+            ++itr;
+            continue;
+        }
+
+        if (itr->second.uState == SKILL_DELETED)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILL_BY_SKILL);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, itr->first);
+            trans->Append(stmt);
+
+            mSkillStatus.erase(itr++);
+            continue;
+        }
+
+        uint16 field = itr->second.pos / 2;
+        uint8 offset = itr->second.pos & 1;
+
+        uint16 value = GetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset);
+        uint16 max = GetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset);
+
+        switch (itr->second.uState)
+        {
+            case SKILL_NEW:
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SKILLS);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt16(1, uint16(itr->first));
+                stmt->setUInt16(2, value);
+                stmt->setUInt16(3, max);
+                trans->Append(stmt);
+                break;
+            case SKILL_CHANGED:
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_SKILLS);
+                stmt->setUInt16(0, value);
+                stmt->setUInt16(1, max);
+                stmt->setUInt32(2, GetGUIDLow());
+                stmt->setUInt16(3, uint16(itr->first));
+                trans->Append(stmt);
+                break;
+            default:
+                break;
+        }
+
+        itr->second.uState = SKILL_UNCHANGED;
+        ++itr;
+    }
+}
+
+void Player::_SaveSpells(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = NULL;
+
+    for (PlayerSpellMap::iterator itr = m_spells.begin(); itr != m_spells.end();)
+    {
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->state == PLAYERSPELL_CHANGED)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_BY_SPELL);
+            stmt->setUInt32(0, itr->first);
+            stmt->setUInt32(1, GetGUIDLow());
+            trans->Append(stmt);
+        }
+
+        // add only changed/new not dependent spells
+        if (!itr->second->dependent && (itr->second->state == PLAYERSPELL_NEW || itr->second->state == PLAYERSPELL_CHANGED))
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SPELL);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt32(1, itr->first);
+            stmt->setBool(2, itr->second->active);
+            stmt->setBool(3, itr->second->disabled);
+            trans->Append(stmt);
+        }
+
+        if (itr->second->state == PLAYERSPELL_REMOVED)
+        {
+            delete itr->second;
+            m_spells.erase(itr++);
+        }
+        else
+        {
+            itr->second->state = PLAYERSPELL_UNCHANGED;
+            ++itr;
+        }
+    }
+}
+
+// save player stats -- only for external usage
+// real stats will be recalculated on player login
+void Player::_SaveStats(SQLTransaction& trans)
+{
+    // check if stat saving is enabled and if char level is high enough
+    if (!sWorld->getIntConfig(CONFIG_MIN_LEVEL_STAT_SAVE) || getLevel() < sWorld->getIntConfig(CONFIG_MIN_LEVEL_STAT_SAVE))
+        return;
+
+    PreparedStatement* stmt = NULL;
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_STATS);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+
+    uint8 index = 0;
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_STATS);
+    stmt->setUInt32(index++, GetGUIDLow());
+    stmt->setUInt32(index++, GetMaxHealth());
+
+    for (uint8 i = 0; i < MAX_POWERS_PER_CLASS; ++i)
+        stmt->setUInt32(index++, GetMaxPower(Powers(i)));
+
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+        stmt->setUInt32(index++, GetStat(Stats(i)));
+
+    for (int i = 0; i < MAX_SPELL_SCHOOL; ++i)
+        stmt->setUInt32(index++, GetResistance(SpellSchools(i)));
+
+    stmt->setFloat(index++, GetFloatValue(PLAYER_BLOCK_PERCENTAGE));
+    stmt->setFloat(index++, GetFloatValue(PLAYER_DODGE_PERCENTAGE));
+    stmt->setFloat(index++, GetFloatValue(PLAYER_PARRY_PERCENTAGE));
+    stmt->setFloat(index++, GetFloatValue(PLAYER_CRIT_PERCENTAGE));
+    stmt->setFloat(index++, GetFloatValue(PLAYER_RANGED_CRIT_PERCENTAGE));
+    stmt->setFloat(index++, GetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1));
+    stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_ATTACK_POWER));
+    stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER));
+    stmt->setUInt32(index++, GetBaseSpellPowerBonus());
+    stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_COMBAT_RATING_1 + CR_RESILIENCE_PLAYER_DAMAGE_TAKEN));
+
+    trans->Append(stmt);
+}
+
+void Player::outDebugValues() const
+{
+    if (!sLog->ShouldLog(LOG_FILTER_UNITS, LOG_LEVEL_DEBUG))
+        return;
+
+    sLog->outDebug(LOG_FILTER_UNITS, "HP is: \t\t\t%u\t\tMP is: \t\t\t%u", GetMaxHealth(), GetMaxPower(POWER_MANA));
+    sLog->outDebug(LOG_FILTER_UNITS, "AGILITY is: \t\t%f\t\tSTRENGTH is: \t\t%f", GetStat(STAT_AGILITY), GetStat(STAT_STRENGTH));
+    sLog->outDebug(LOG_FILTER_UNITS, "INTELLECT is: \t\t%f\t\tSPIRIT is: \t\t%f", GetStat(STAT_INTELLECT), GetStat(STAT_SPIRIT));
+    sLog->outDebug(LOG_FILTER_UNITS, "STAMINA is: \t\t%f", GetStat(STAT_STAMINA));
+    sLog->outDebug(LOG_FILTER_UNITS, "Armor is: \t\t%u\t\tBlock is: \t\t%f", GetArmor(), GetFloatValue(PLAYER_BLOCK_PERCENTAGE));
+    sLog->outDebug(LOG_FILTER_UNITS, "HolyRes is: \t\t%u\t\tFireRes is: \t\t%u", GetResistance(SPELL_SCHOOL_HOLY), GetResistance(SPELL_SCHOOL_FIRE));
+    sLog->outDebug(LOG_FILTER_UNITS, "NatureRes is: \t\t%u\t\tFrostRes is: \t\t%u", GetResistance(SPELL_SCHOOL_NATURE), GetResistance(SPELL_SCHOOL_FROST));
+    sLog->outDebug(LOG_FILTER_UNITS, "ShadowRes is: \t\t%u\t\tArcaneRes is: \t\t%u", GetResistance(SPELL_SCHOOL_SHADOW), GetResistance(SPELL_SCHOOL_ARCANE));
+    sLog->outDebug(LOG_FILTER_UNITS, "MIN_DAMAGE is: \t\t%f\tMAX_DAMAGE is: \t\t%f", GetFloatValue(UNIT_FIELD_MINDAMAGE), GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    sLog->outDebug(LOG_FILTER_UNITS, "MIN_OFFHAND_DAMAGE is: \t%f\tMAX_OFFHAND_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+    sLog->outDebug(LOG_FILTER_UNITS, "MIN_RANGED_DAMAGE is: \t%f\tMAX_RANGED_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+    sLog->outDebug(LOG_FILTER_UNITS, "ATTACK_TIME is: \t%u\t\tRANGE_ATTACK_TIME is: \t%u", GetAttackTime(BASE_ATTACK), GetAttackTime(RANGED_ATTACK));
+}
+
+/*********************************************************/
+/***               FLOOD FILTER SYSTEM                 ***/
+/*********************************************************/
+
+void Player::UpdateSpeakTime()
+{
+    // ignore chat spam protection for GMs in any mode
+    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
+        return;
+
+    time_t current = time (NULL);
+    if (m_speakTime > current)
+    {
+        uint32 max_count = sWorld->getIntConfig(CONFIG_CHATFLOOD_MESSAGE_COUNT);
+        if (!max_count)
+            return;
+
+        ++m_speakCount;
+        if (m_speakCount >= max_count)
+        {
+            // prevent overwrite mute time, if message send just before mutes set, for example.
+            time_t new_mute = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_MUTE_TIME);
+            if (GetSession()->m_muteTime < new_mute)
+                GetSession()->m_muteTime = new_mute;
+
+            m_speakCount = 0;
+        }
+    }
+    else
+        m_speakCount = 0;
+
+    m_speakTime = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_MESSAGE_DELAY);
+}
+
+bool Player::CanSpeak() const
+{
+    return  GetSession()->m_muteTime <= time (NULL);
+}
+
+/*********************************************************/
+/***              LOW LEVEL FUNCTIONS:Notifiers        ***/
+/*********************************************************/
+
+void Player::SendAttackSwingNotInRange()
+{
+    WorldPacket data(SMSG_ATTACKSWING_NOTINRANGE, 0);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SavePositionInDB(uint32 mapid, float x, float y, float z, float o, uint32 zone, uint64 guid)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER_POSITION);
+
+    stmt->setFloat(0, x);
+    stmt->setFloat(1, y);
+    stmt->setFloat(2, z);
+    stmt->setFloat(3, o);
+    stmt->setUInt16(4, uint16(mapid));
+    stmt->setUInt16(5, uint16(zone));
+    stmt->setUInt32(6, GUID_LOPART(guid));
+
+    CharacterDatabase.Execute(stmt);
+}
+
+void Player::SetUInt32ValueInArray(Tokenizer& Tokenizer, uint16 index, uint32 value)
+{
+    char buf[11];
+    snprintf(buf, 11, "%u", value);
+
+    if (index >= Tokenizer.size())
+        return;
+
+    Tokenizer[index] = buf;
+}
+
+void Player::Customize(uint64 guid, uint8 gender, uint8 skin, uint8 face, uint8 hairStyle, uint8 hairColor, uint8 facialHair)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PLAYERBYTES2);
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (!result)
+        return;
+
+    Field* fields = result->Fetch();
+
+    uint32 playerBytes2 = fields[0].GetUInt32();
+    playerBytes2 &= ~0xFF;
+    playerBytes2 |= facialHair;
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GENDER_PLAYERBYTES);
+
+    stmt->setUInt8(0, gender);
+    stmt->setUInt32(1, skin | (face << 8) | (hairStyle << 16) | (hairColor << 24));
+    stmt->setUInt32(2, playerBytes2);
+    stmt->setUInt32(3, GUID_LOPART(guid));
+
+    CharacterDatabase.Execute(stmt);
+}
+
+void Player::SendAttackSwingDeadTarget()
+{
+    WorldPacket data(SMSG_ATTACKSWING_DEADTARGET, 0);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendAttackSwingCantAttack()
+{
+    WorldPacket data(SMSG_ATTACKSWING_CANT_ATTACK, 0);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendAttackSwingCancelAttack()
+{
+    WorldPacket data(SMSG_CANCEL_COMBAT, 0);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendAttackSwingBadFacingAttack()
+{
+    WorldPacket data(SMSG_ATTACKSWING_BADFACING, 0);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendAutoRepeatCancel(Unit* target)
+{
+    WorldPacket data(SMSG_CANCEL_AUTO_REPEAT, target->GetPackGUID().size());
+    data.append(target->GetPackGUID());                     // may be it's target guid
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendExplorationExperience(uint32 Area, uint32 Experience)
+{
+    WorldPacket data(SMSG_EXPLORATION_EXPERIENCE, 8);
+    data << uint32(Area);
+    data << uint32(Experience);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendDungeonDifficulty(bool IsInGroup)
+{
+    uint8 val = 0x00000001;
+    WorldPacket data(MSG_SET_DUNGEON_DIFFICULTY, 12);
+    data << (uint32)GetDungeonDifficulty();
+    data << uint32(val);
+    data << uint32(IsInGroup);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendRaidDifficulty(bool IsInGroup, int32 forcedDifficulty)
+{
+    uint8 val = 0x00000001;
+    WorldPacket data(MSG_SET_RAID_DIFFICULTY, 12);
+    data << uint32(forcedDifficulty == -1 ? GetRaidDifficulty() : forcedDifficulty);
+    data << uint32(val);
+    data << uint32(IsInGroup);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendResetFailedNotify(uint32 /*mapid*/)
+{
+    WorldPacket data(SMSG_RESET_FAILED_NOTIFY, 4);
+    GetSession()->SendPacket(&data);
+}
+
+/// Reset all solo instances and optionally send a message on success for each
+void Player::ResetInstances(uint8 method, bool isRaid)
+{
+    // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_JOIN
+
+    // we assume that when the difficulty changes, all instances that can be reset will be
+    Difficulty diff = GetDifficulty(isRaid);
+
+    for (BoundInstancesMap::iterator itr = m_boundInstances[diff].begin(); itr != m_boundInstances[diff].end();)
+    {
+        InstanceSave* p = itr->second.save;
+        const MapEntry* entry = sMapStore.LookupEntry(itr->first);
+        if (!entry || entry->IsRaid() != isRaid || !p->CanReset())
+        {
+            ++itr;
+            continue;
+        }
+
+        if (method == INSTANCE_RESET_ALL)
+        {
+            // the "reset all instances" method can only reset normal maps
+            if (entry->map_type == MAP_RAID || diff == DUNGEON_DIFFICULTY_HEROIC)
+            {
+                ++itr;
+                continue;
+            }
+        }
+
+        // if the map is loaded, reset it
+        Map* map = sMapMgr->FindMap(p->GetMapId(), p->GetInstanceId());
+        if (map && map->IsDungeon())
+            if (!((InstanceMap*)map)->Reset(method))
+            {
+                ++itr;
+                continue;
+            }
+
+        // since this is a solo instance there should not be any players inside
+        if (method == INSTANCE_RESET_ALL || method == INSTANCE_RESET_CHANGE_DIFFICULTY)
+            SendResetInstanceSuccess(p->GetMapId());
+
+        p->DeleteFromDB();
+        m_boundInstances[diff].erase(itr++);
+
+        // the following should remove the instance save from the manager and delete it as well
+        p->RemovePlayer(this);
+    }
+}
+
+void Player::SendResetInstanceSuccess(uint32 MapId)
+{
+    WorldPacket data(SMSG_INSTANCE_RESET, 4);
+    data << uint32(MapId);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendResetInstanceFailed(uint32 reason, uint32 MapId)
+{
+    /*reasons for instance reset failure:
+    // 0: There are players inside the instance.
+    // 1: There are players offline in your party.
+    // 2>: There are players in your party attempting to zone into an instance.
+    */
+    WorldPacket data(SMSG_INSTANCE_RESET_FAILED, 8);
+    data << uint32(reason);
+    data << uint32(MapId);
+    GetSession()->SendPacket(&data);
+}
+
+/*********************************************************/
+/***              Update timers                        ***/
+/*********************************************************/
+
+///checks the 15 afk reports per 5 minutes limit
+void Player::UpdateAfkReport(time_t currTime)
+{
+    if (m_bgData.bgAfkReportedTimer <= currTime)
+    {
+        m_bgData.bgAfkReportedCount = 0;
+        m_bgData.bgAfkReportedTimer = currTime+5*MINUTE;
+    }
+}
+
+void Player::UpdateContestedPvP(uint32 diff)
+{
+    if (!m_contestedPvPTimer||isInCombat())
+        return;
+    if (m_contestedPvPTimer <= diff)
+    {
+        ResetContestedPvP();
+    }
+    else
+        m_contestedPvPTimer -= diff;
+}
+
+void Player::UpdatePvPFlag(time_t currTime)
+{
+    if (!IsPvP())
+        return;
+    if (pvpInfo.endTimer == 0 || currTime < (pvpInfo.endTimer + 300) || pvpInfo.inHostileArea)
+        return;
+
+    UpdatePvP(false);
+}
+
+void Player::UpdateDuelFlag(time_t currTime)
+{
+    if (!duel || duel->startTimer == 0 ||currTime < duel->startTimer + 3)
+        return;
+
+    sScriptMgr->OnPlayerDuelStart(this, duel->opponent);
+
+    SetUInt32Value(PLAYER_DUEL_TEAM, 1);
+    duel->opponent->SetUInt32Value(PLAYER_DUEL_TEAM, 2);
+
+    duel->startTimer = 0;
+    duel->startTime  = currTime;
+    duel->opponent->duel->startTimer = 0;
+    duel->opponent->duel->startTime  = currTime;
+}
+
+Pet* Player::GetPet() const
+{
+    if (uint64 pet_guid = GetPetGUID())
+    {
+        if (!IS_PET_GUID(pet_guid))
+            return NULL;
+
+        Pet* pet = ObjectAccessor::GetPet(*this, pet_guid);
+
+        if (!pet)
+            return NULL;
+
+        if (IsInWorld() && pet)
+            return pet;
+
+        //there may be a guardian in slot
+        //sLog->outError(LOG_FILTER_PLAYER, "Player::GetPet: Pet %u not exist.", GUID_LOPART(pet_guid));
+        //const_cast<Player*>(this)->SetPetGUID(0);
+    }
+
+    return NULL;
+}
+
+void Player::RemovePet(Pet* pet, PetSlot mode, bool returnreagent, bool logout)
+{
+    if (!pet)
+        pet = GetPet();
+
+    if (pet)
+    {
+        sLog->outDebug(LOG_FILTER_PETS, "RemovePet %u, %u, %u", pet->GetEntry(), mode, returnreagent);
+
+        if (pet->m_removed)
+            return;
+    }
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT currentPetSlot FROM characters WHERE guid = '%u'", this->GetGUIDLow());
+	Field* fields = result->Fetch();
+	PetSlot petslot = (PetSlot)fields[0].GetUInt8();
+
+    if (mode == PET_SAVE_AS_CURRENT)
+        mode = petslot;
+
+/*
+    if (returnreagent && (pet || m_temporaryUnsummonedPetNumber) && !InBattleground())
+    {
+        //returning of reagents only for players, so best done here
+        uint32 spellId = pet ? pet->GetUInt32Value(UNIT_CREATED_BY_SPELL) : m_oldpetspell;
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+
+        if (spellInfo)
+        {
+            for (uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
+            {
+                if (spellInfo->Reagent[i] > 0)
+                {
+                    ItemPosCountVec dest;                   //for succubus, voidwalker, felhunter and felguard credit soulshard when despawn reason other than death (out of range, logout)
+                    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, spellInfo->Reagent[i], spellInfo->ReagentCount[i]);
+                    if (msg == EQUIP_ERR_OK)
+                    {
+                        Item* item = StoreNewItem(dest, spellInfo->Reagent[i], true);
+                        if (IsInWorld())
+                            SendNewItem(item, spellInfo->ReagentCount[i], true, false);
+                    }
+                }
+            }
+        }
+        m_temporaryUnsummonedPetNumber = 0;
+    }
+*/
+
+    if (!pet || pet->GetOwnerGUID() != GetGUID())
+        return;
+
+    pet->CombatStop();
+
+    /*if (returnreagent)
+    {
+        switch (pet->GetEntry())
+        {
+            //warlock pets except imp are removed(?) when logging out
+            case 1860:
+            case 1863:
+            case 417:
+            case 17252:
+                mode = PET_SLOT_ACTUAL_PET_SLOT;
+                break;
+        }
+    }*/
+
+
+    // only if current pet in slot
+    pet->SavePet(mode, logout);
+
+    if (pet->getPetType() != HUNTER_PET)
+        SetMinion(pet, false, mode);
+    else
+        SetMinion(pet, false, petslot);
+
+    pet->AddObjectToRemoveList();
+    pet->m_removed = true;
+
+    if (pet->isControlled())
+    {
+        WorldPacket data(SMSG_PET_SPELLS, 8);
+        data << uint64(0);
+        GetSession()->SendPacket(&data);
+
+        if (GetGroup())
+            SetGroupUpdateFlag(GROUP_UPDATE_PET);
+    }
+}
+
+void Player::StopCastingCharm()
+{
+    Unit* charm = GetCharm();
+    if (!charm)
+        return;
+
+    if (charm->GetTypeId() == TYPEID_UNIT)
+    {
+        if (charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_PUPPET))
+            ((Puppet*)charm)->UnSummon();
+        else if (charm->IsVehicle())
+            ExitVehicle();
+    }
+    if (GetCharmGUID())
+        charm->RemoveCharmAuras();
+
+    if (GetCharmGUID())
+    {
+        sLog->outFatal(LOG_FILTER_PLAYER, "Player %s (GUID: " UI64FMTD " is not able to uncharm unit (GUID: " UI64FMTD " Entry: %u, Type: %u)", GetName().c_str(), GetGUID(), GetCharmGUID(), charm->GetEntry(), charm->GetTypeId());
+        if (charm->GetCharmerGUID())
+        {
+            sLog->outFatal(LOG_FILTER_PLAYER, "Charmed unit has charmer guid " UI64FMTD, charm->GetCharmerGUID());
+            //            ASSERT(false); why is there an ASSERT here ????
+        }
+        else
+            SetCharm(charm, false);
+    }
+}
+
+inline void Player::BuildPlayerChat(WorldPacket* data, uint8 msgtype, const std::string& text, uint32 language, const char* addonPrefix /*= NULL*/) const
+{
+    *data << uint8(msgtype);
+    *data << uint32(language);
+    *data << uint64(GetGUID());
+    *data << uint32(0);                                      // constant unknown time
+    if (addonPrefix)
+        *data << addonPrefix;
+    else
+        *data << uint64(GetGUID());
+    *data << uint32(text.length() + 1);
+    *data << text;
+    *data << uint8(GetChatTag());
+}
+
+void Player::Say(const std::string& text, const uint32 language)
+{
+    std::string _text(text);
+    sScriptMgr->OnPlayerChat(this, CHAT_MSG_SAY, language, _text);
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    BuildPlayerChat(&data, CHAT_MSG_SAY, _text, language);
+    SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true);
+}
+
+void Player::Yell(const std::string& text, const uint32 language)
+{
+    std::string _text(text);
+    sScriptMgr->OnPlayerChat(this, CHAT_MSG_YELL, language, _text);
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    BuildPlayerChat(&data, CHAT_MSG_YELL, _text, language);
+    SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL), true);
+}
+
+void Player::TextEmote(const std::string& text)
+{
+    std::string _text(text);
+    sScriptMgr->OnPlayerChat(this, CHAT_MSG_EMOTE, LANG_UNIVERSAL, _text);
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    BuildPlayerChat(&data, CHAT_MSG_EMOTE, _text, LANG_UNIVERSAL);
+    SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_TEXTEMOTE), true, !sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHAT));
+}
+
+void Player::WhisperAddon(const std::string& text, const std::string& prefix, Player* receiver)
+{
+    std::string _text(text);
+    sScriptMgr->OnPlayerChat(this, CHAT_MSG_WHISPER, LANG_UNIVERSAL, _text, receiver);
+
+    if (!receiver->GetSession()->IsAddonRegistered(prefix))
+        return;
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    BuildPlayerChat(&data, CHAT_MSG_WHISPER, _text, LANG_UNIVERSAL, prefix.c_str());
+    receiver->GetSession()->SendPacket(&data);
+}
+
+void Player::Whisper(const std::string& text, uint32 language, uint64 receiver)
+{
+    bool isAddonMessage = language == LANG_ADDON;
+
+    if (!isAddonMessage) // if not addon data
+        language = LANG_UNIVERSAL; // whispers should always be readable
+
+    Player* rPlayer = ObjectAccessor::FindPlayer(receiver);
+
+    std::string _text(text);
+    sScriptMgr->OnPlayerChat(this, CHAT_MSG_WHISPER, language, _text, rPlayer);
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    BuildPlayerChat(&data, CHAT_MSG_WHISPER, _text, language);
+    rPlayer->GetSession()->SendPacket(&data);
+
+    // rest stuff shouldn't happen in case of addon message
+    if (isAddonMessage)
+        return;
+
+    data.Initialize(SMSG_MESSAGECHAT, 200);
+    rPlayer->BuildPlayerChat(&data, CHAT_MSG_WHISPER_INFORM, _text, language);
+    GetSession()->SendPacket(&data);
+
+    if (!isAcceptWhispers() && !isGameMaster() && !rPlayer->isGameMaster())
+    {
+        SetAcceptWhispers(true);
+        ChatHandler(GetSession()).SendSysMessage(LANG_COMMAND_WHISPERON);
+    }
+
+    // announce afk or dnd message
+    if (rPlayer->isAFK())
+        ChatHandler(GetSession()).PSendSysMessage(LANG_PLAYER_AFK, rPlayer->GetName().c_str(), rPlayer->autoReplyMsg.c_str());
+    else if (rPlayer->isDND())
+        ChatHandler(GetSession()).PSendSysMessage(LANG_PLAYER_DND, rPlayer->GetName().c_str(), rPlayer->autoReplyMsg.c_str());
+}
+
+void Player::PetSpellInitialize()
+{
+    Pet* pet = GetPet();
+
+    if (!pet)
+        return;
+
+    sLog->outDebug(LOG_FILTER_PETS, "Pet Spells Groups");
+
+    CharmInfo* charmInfo = pet->GetCharmInfo();
+
+    WorldPacket data(SMSG_PET_SPELLS, 8+2+4+4+4*MAX_UNIT_ACTION_BAR_INDEX+1+1);
+    data << uint64(pet->GetGUID());
+    data << uint16(pet->GetCreatureTemplate()->family);         // creature family (required for pet talents)
+    data << uint32(pet->GetDuration());
+    data << uint8(pet->GetReactState());
+    data << uint8(charmInfo->GetCommandState());
+    data << uint16(0); // Flags, mostly unknown
+
+    // action bar loop
+    charmInfo->BuildActionBar(&data);
+
+    size_t spellsCountPos = data.wpos();
+
+    // spells count
+    uint8 addlist = 0;
+    data << uint8(addlist);                                 // placeholder
+
+    if (pet->IsPermanentPetFor(this))
+    {
+        // spells loop
+        for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+        {
+            if (itr->second._state == DATA_REMOVED)
+                continue;
+
+            data << uint32(MAKE_UNIT_ACTION_BUTTON(itr->first, itr->second.active));
+            ++addlist;
+        }
+    }
+
+    data.put<uint8>(spellsCountPos, addlist);
+
+    uint8 cooldownsCount = pet->GetSpellCooldownMap().size();
+    data << uint8(cooldownsCount);
+
+    time_t curTime = time(NULL);
+
+    for (SpellCooldowns::const_iterator itr = pet->GetSpellCooldownMap().begin(); itr != pet->GetSpellCooldownMap().end(); ++itr)
+    {
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);
+        if (!spellInfo)
+        {
+            data << uint32(0);
+            data << uint16(0);
+            data << uint32(0);
+            data << uint32(0);
+            continue;
+        }
+
+        time_t cooldown = (itr->second.end > curTime) ? (itr->second.end - curTime) * IN_MILLISECONDS : 0;
+        data << uint32(itr->first);                 // spell ID
+        data << uint16(0);
+        data << uint32(cooldown);
+        data << uint32(0);
+    }
+
+    GetSession()->SendPacket(&data);
+}
+
+void Player::PossessSpellInitialize()
+{
+    Unit* charm = GetCharm();
+    if (!charm)
+        return;
+
+    CharmInfo* charmInfo = charm->GetCharmInfo();
+
+    if (!charmInfo)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player::PossessSpellInitialize(): charm ("UI64FMTD") has no charminfo!", charm->GetGUID());
+        return;
+    }
+
+    WorldPacket data(SMSG_PET_SPELLS, 8+2+4+4+4*MAX_UNIT_ACTION_BAR_INDEX+1+1);
+    data << uint64(charm->GetGUID());
+    data << uint16(0);
+    data << uint32(0);
+    data << uint32(0);
+
+    charmInfo->BuildActionBar(&data);
+
+    data << uint8(0);                                       // spells count
+    data << uint8(0);                                       // cooldowns count
+
+    GetSession()->SendPacket(&data);
+}
+
+void Player::VehicleSpellInitialize()
+{
+    Creature* vehicle = GetVehicleCreatureBase();
+    if (!vehicle)
+        return;
+
+    uint8 cooldownCount = vehicle->GetSpellCooldownMap().size();
+
+    WorldPacket data(SMSG_PET_SPELLS, 8 + 2 + 4 + 4 + 4 * 10 + 1 + 1 + cooldownCount * (4 + 2 + 4 + 4));
+    data << uint64(vehicle->GetGUID());                     // Guid
+    data << uint16(0);                                      // Pet Family (0 for all vehicles)
+    data << uint32(vehicle->isSummon() ? vehicle->ToTempSummon()->GetTimer() : 0); // Duration
+    // The following three segments are read by the client as one uint32
+    data << uint8(vehicle->GetReactState());                // React State
+    data << uint8(0);                                       // Command State
+    data << uint16(0x800);                                  // DisableActions (set for all vehicles)
+
+    for (uint32 i = 0; i < CREATURE_MAX_SPELLS; ++i)
+    {
+        uint32 spellId = vehicle->m_spells[i];
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!spellInfo)
+        {
+            data << uint16(0) << uint8(0) << uint8(i+8);
+            continue;
+        }
+
+        ConditionList conditions = sConditionMgr->GetConditionsForVehicleSpell(vehicle->GetEntry(), spellId);
+        if (!sConditionMgr->IsObjectMeetToConditions(this, vehicle, conditions))
+        {
+            sLog->outDebug(LOG_FILTER_CONDITIONSYS, "VehicleSpellInitialize: conditions not met for Vehicle entry %u spell %u", vehicle->ToCreature()->GetEntry(), spellId);
+            data << uint16(0) << uint8(0) << uint8(i+8);
+            continue;
+        }
+
+        if (spellInfo->IsPassive())
+            vehicle->CastSpell(vehicle, spellId, true);
+
+        data << uint32(MAKE_UNIT_ACTION_BUTTON(spellId, i+8));
+    }
+
+    for (uint32 i = CREATURE_MAX_SPELLS; i < MAX_SPELL_CONTROL_BAR; ++i)
+        data << uint32(0);
+
+    data << uint8(0); // Auras?
+
+    // Cooldowns
+    data << uint8(cooldownCount);
+
+    time_t now = sWorld->GetGameTime();
+
+    for (SpellCooldowns::const_iterator itr = vehicle->GetSpellCooldownMap().begin(); itr != vehicle->GetSpellCooldownMap().end(); ++itr)
+    {
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);
+        if (!spellInfo)
+        {
+            data << uint32(0);
+            data << uint16(0);
+            data << uint32(0);
+            data << uint32(0);
+            continue;
+        }
+
+        time_t cooldown = (itr->second.end > now) ? (itr->second.end - now) * IN_MILLISECONDS : 0;
+        data << uint32(itr->first);                 // spell ID
+        data << uint16(0);
+        data << uint32(cooldown);
+        data << uint32(0);
+    }
+
+    GetSession()->SendPacket(&data);
+}
+
+void Player::CharmSpellInitialize()
+{
+    Unit* charm = GetFirstControlled();
+    if (!charm)
+        return;
+
+    CharmInfo* charmInfo = charm->GetCharmInfo();
+    if (!charmInfo)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player::CharmSpellInitialize(): the player's charm ("UI64FMTD") has no charminfo!", charm->GetGUID());
+        return;
+    }
+
+    uint8 addlist = 0;
+    if (charm->GetTypeId() != TYPEID_PLAYER)
+    {
+        //CreatureInfo const* cinfo = charm->ToCreature()->GetCreatureTemplate();
+        //if (cinfo && cinfo->type == CREATURE_TYPE_DEMON && getClass() == CLASS_WARLOCK)
+        {
+            for (uint32 i = 0; i < MAX_SPELL_CHARM; ++i)
+                if (charmInfo->GetCharmSpell(i)->GetAction())
+                    ++addlist;
+        }
+    }
+
+    WorldPacket data(SMSG_PET_SPELLS, 8+2+4+4+4*MAX_UNIT_ACTION_BAR_INDEX+1+4*addlist+1);
+    data << uint64(charm->GetGUID());
+    data << uint16(0);
+    data << uint32(0);
+
+    if (charm->GetTypeId() != TYPEID_PLAYER)
+        data << uint8(charm->ToCreature()->GetReactState()) << uint8(charmInfo->GetCommandState()) << uint16(0);
+    else
+        data << uint32(0);
+
+    charmInfo->BuildActionBar(&data);
+
+    data << uint8(addlist);
+
+    if (addlist)
+    {
+        for (uint32 i = 0; i < MAX_SPELL_CHARM; ++i)
+        {
+            CharmSpellInfo* cspell = charmInfo->GetCharmSpell(i);
+            if (cspell->GetAction())
+                data << uint32(cspell->packedData);
+        }
+    }
+
+    data << uint8(0);                                       // cooldowns count
+
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendRemoveControlBar()
+{
+    WorldPacket data(SMSG_PET_SPELLS, 8);
+    data << uint64(0);
+    GetSession()->SendPacket(&data);
+}
+
+bool Player::IsAffectedBySpellmod(SpellInfo const* spellInfo, SpellModifier* mod, Spell* spell)
+{
+    if (!mod || !spellInfo)
+        return false;
+
+    // Mod out of charges
+    if (spell && mod->charges == -1 && spell->m_appliedMods.find(mod) == spell->m_appliedMods.end())
+        return false;
+
+    // +duration to infinite duration spells making them limited
+    if (mod->op == SPELLMOD_DURATION && spellInfo->GetDuration() == -1)
+        return false;
+
+    return spellInfo->IsAffectedBySpellMod(mod);
+}
+
+void Player::AddSpellMod(SpellModifier* mod, bool apply)
+{
+    sLog->outDebug(LOG_FILTER_SPELLS_AURAS, "Player::AddSpellMod %d", mod->spellId);
+    Opcodes opcode = Opcodes((mod->type == SPELLMOD_FLAT) ? SMSG_SET_FLAT_SPELL_MODIFIER : SMSG_SET_PCT_SPELL_MODIFIER);
+
+    int i = 0;
+    flag96 _mask = 0;
+    uint32 modTypeCount = 0; // count of mods per one mod->op
+    WorldPacket data(opcode);
+    data << uint32(1);  // count of different mod->op's in packet
+    size_t writePos = data.wpos();
+    data << uint32(modTypeCount);
+    data << uint8(mod->op);
+    for (int eff = 0; eff < 96; ++eff)
+    {
+        if (eff != 0 && (eff % 32) == 0)
+            _mask[i++] = 0;
+
+        _mask[i] = uint32(1) << (eff - (32 * i));
+        if (mod->mask & _mask)
+        {
+            int32 val = 0;
+            for (SpellModList::iterator itr = m_spellMods[mod->op].begin(); itr != m_spellMods[mod->op].end(); ++itr)
+                if ((*itr)->type == mod->type && (*itr)->mask & _mask)
+                    val += (*itr)->value;
+            val += apply ? mod->value : -(mod->value);
+
+            data << uint8(eff);
+            data << float(val);
+            ++modTypeCount;
+        }
+    }
+    data.put<uint32>(writePos, modTypeCount);
+    SendDirectMessage(&data);
+    if (apply)
+        m_spellMods[mod->op].push_back(mod);
+    else
+    {
+        m_spellMods[mod->op].remove(mod);
+        // mods bound to aura will be removed in AuraEffect::~AuraEffect
+        if (!mod->ownerAura)
+            delete mod;
+    }
+}
+
+// Restore spellmods in case of failed cast
+void Player::RestoreSpellMods(Spell* spell, uint32 ownerAuraId, Aura* aura)
+{
+    if (!spell || spell->m_appliedMods.empty())
+        return;
+
+    for (uint8 i=0; i<MAX_SPELLMOD; ++i)
+    {
+        for (SpellModList::iterator itr = m_spellMods[i].begin(); itr != m_spellMods[i].end(); ++itr)
+        {
+            SpellModifier* mod = *itr;
+
+            // spellmods without aura set cannot be charged
+            if (!mod->ownerAura || !mod->ownerAura->IsUsingCharges())
+                continue;
+
+            // Restore only specific owner aura mods
+            if (ownerAuraId && (ownerAuraId != mod->ownerAura->GetSpellInfo()->Id))
+                continue;
+
+            if (aura && mod->ownerAura != aura)
+                continue;
+
+            // Check each mod seperately
+            Spell::UsedSpellMods::iterator iterMod = spell->m_appliedMods.find(mod);
+            if (iterMod == spell->m_appliedMods.end())
+                continue;
+
+            Spell::UsedSpellAuras::iterator iterAura = spell->m_appliedauras.find(mod->ownerAura);
+            if (iterAura != spell->m_appliedauras.end())
+                spell->m_appliedauras.erase(iterAura);
+
+            // secondly, check if the current mod is one of the spellmods applied by the mod aura
+            if (!(mod->mask & spell->m_spellInfo->SpellFamilyFlags))
+                continue;
+
+            // remove from list
+            spell->m_appliedMods.erase(iterMod);
+
+            // add mod charges back to mod
+            if (mod->charges == -1)
+                mod->charges = 1;
+            else
+                mod->charges++;
+
+            // Do not set more spellmods than avalible
+            if (mod->ownerAura->GetCharges() < mod->charges)
+                mod->charges = mod->ownerAura->GetCharges();
+
+            // Skip this check for now - aura charges may change due to various reason
+            // TODO: trac these changes correctly
+            //ASSERT (mod->ownerAura->GetCharges() <= mod->charges);
+        }
+    }
+}
+
+void Player::RestoreAllSpellMods(uint32 ownerAuraId, Aura* aura)
+{
+    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
+        if (m_currentSpells[i])
+            RestoreSpellMods(m_currentSpells[i], ownerAuraId, aura);
+}
+
+void Player::RemoveSpellMods(Spell* spell)
+{
+    if (!spell)
+        return;
+
+    if (spell->m_appliedauras.empty())
+        return;
+
+    for (uint8 i=0; i<MAX_SPELLMOD; ++i)
+    {
+        for (SpellModList::const_iterator itr = m_spellMods[i].begin(); itr != m_spellMods[i].end();)
+        {
+            SpellModifier* mod = *itr;
+            ++itr;
+
+            // spellmods without aura set cannot be charged
+            if (!mod->ownerAura)
+                continue;
+
+            // check if mod affected this spell
+            Spell::UsedSpellMods::iterator iterMod = spell->m_appliedMods.find(mod);
+            if (iterMod == spell->m_appliedMods.end())
+                continue;
+
+            spell->m_appliedMods.erase(iterMod);
+
+            Spell::UsedSpellAuras::iterator iterAura = spell->m_appliedauras.find(mod->ownerAura);
+            if (iterAura == spell->m_appliedauras.end())
+                continue;
+
+            spell->m_appliedauras.erase(iterAura);
+
+            if (mod->ownerAura->IsUsingCharges())
+            {
+                if (mod->ownerAura->DropCharge(AURA_REMOVE_BY_EXPIRE))
+                    itr = m_spellMods[i].begin();
+            }
+            else
+                RemoveAuraFromStack(mod->ownerAura->GetId());
+        }
+    }
+}
+
+void Player::DropModCharge(SpellModifier* mod, Spell* spell)
+{
+    // don't handle spells with proc_event entry defined
+    // this is a temporary workaround, because all spellmods should be handled like that
+    if (sSpellMgr->GetSpellProcEvent(mod->spellId))
+        return;
+
+    if (spell && mod->ownerAura)
+    {
+        spell->m_appliedAuras.insert(mod->spellId);
+        if (mod->charges > 0)
+        {
+            if (--mod->charges == 0)
+                mod->charges = -1;
+
+            spell->m_appliedMods.insert(mod);
+            spell->m_appliedauras.insert(mod->ownerAura);
+        }
+        else
+        {
+            // Guessed rule
+            if (const SpellInfo* _spellEntry = sSpellMgr->GetSpellInfo(mod->spellId))
+                if (_spellEntry->Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE)
+                {
+                    spell->m_appliedMods.insert(mod);
+                    spell->m_appliedauras.insert(mod->ownerAura);
+                }
+        }
+    }
+}
+
+void Player::SetSpellModTakingSpell(Spell* spell, bool apply)
+{
+    if (!spell || (m_spellModTakingSpell && m_spellModTakingSpell != spell))
+        return;
+
+    if (apply && spell->getState() == SPELL_STATE_FINISHED)
+        return;
+
+    m_spellModTakingSpell = apply ? spell : NULL;
+}
+
+// send Proficiency
+void Player::SendProficiency(ItemClass itemClass, uint32 itemSubclassMask)
+{
+    WorldPacket data(SMSG_SET_PROFICIENCY, 1 + 4);
+    data << uint8(itemClass) << uint32(itemSubclassMask);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::RemovePetitionsAndSigns(uint64 guid, uint32 type)
+{
+    PreparedStatement* stmt;
+
+    if (type == 10)
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID);
+    else
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID_TYPE);
+        stmt->setUInt8(1, uint8(type));
+    }
+
+    stmt->setUInt32(0, GUID_LOPART(guid));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+    {
+        do                                                  // this part effectively does nothing, since the deletion / modification only takes place _after_ the PetitionQuery. Though I don't know if the result remains intact if I execute the delete query beforehand.
+        {                                                   // and SendPetitionQueryOpcode reads data from the DB
+            Field* fields = result->Fetch();
+            uint64 ownerguid   = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+            uint64 petitionguid = MAKE_NEW_GUID(fields[1].GetUInt32(), 0, HIGHGUID_ITEM);
+
+            // send update if charter owner in game
+            Player* owner = ObjectAccessor::FindPlayer(ownerguid);
+            if (owner)
+                owner->GetSession()->SendPetitionQueryOpcode(petitionguid);
+        } while (result->NextRow());
+
+        if (type == 10)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ALL_PETITION_SIGNATURES);
+
+            stmt->setUInt32(0, GUID_LOPART(guid));
+
+            CharacterDatabase.Execute(stmt);
+        }
+        else
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE);
+
+            stmt->setUInt32(0, GUID_LOPART(guid));
+            stmt->setUInt8(1, uint8(type));
+
+            CharacterDatabase.Execute(stmt);
+        }
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    if (type == 10)
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER);
+        stmt->setUInt32(0, GUID_LOPART(guid));
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER);
+        stmt->setUInt32(0, GUID_LOPART(guid));
+        trans->Append(stmt);
+    }
+    else
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER_AND_TYPE);
+        stmt->setUInt32(0, GUID_LOPART(guid));
+        stmt->setUInt8(1, uint8(type));
+        trans->Append(stmt);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER_AND_TYPE);
+        stmt->setUInt32(0, GUID_LOPART(guid));
+        stmt->setUInt8(1, uint8(type));
+        trans->Append(stmt);
+    }
+    CharacterDatabase.CommitTransaction(trans);
+}
+
+void Player::LeaveAllArenaTeams(uint64 guid)
+{
+    InfoCharEntry info;
+    if (sInfoMgr->GetCharInfo(GUID_LOPART(guid), info))
+        for (uint8 i = 0; i < 3; ++i)
+            if (info.ArenaTeam[i])
+                if (ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(info.ArenaTeam[i]))
+                    at->DelMember(guid, true);
+}
+
+uint32 Player::GetRBGPersonalRating() const
+{
+    return 0;
+}
+
+void Player::SetRestBonus(float rest_bonus_new)
+{
+    // Prevent resting on max level
+    if (getLevel() >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        rest_bonus_new = 0;
+
+    if (rest_bonus_new < 0)
+        rest_bonus_new = 0;
+
+    float rest_bonus_max = (float)GetUInt32Value(PLAYER_NEXT_LEVEL_XP)*1.5f/2;
+
+    if (rest_bonus_new > rest_bonus_max)
+        m_rest_bonus = rest_bonus_max;
+    else
+        m_rest_bonus = rest_bonus_new;
+
+    // update data for client
+    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
+        SetByteValue(PLAYER_BYTES_2, 3, REST_STATE_RAF_LINKED);
+    else if (m_rest_bonus > 10)
+        SetByteValue(PLAYER_BYTES_2, 3, REST_STATE_RESTED);              // Set Reststate = Rested
+    else if (m_rest_bonus <= 1)
+        SetByteValue(PLAYER_BYTES_2, 3, REST_STATE_NOT_RAF_LINKED);              // Set Reststate = Normal
+
+    //RestTickUpdate
+    SetUInt32Value(PLAYER_REST_STATE_EXPERIENCE, uint32(m_rest_bonus));
+}
+
+bool Player::ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc /*= NULL*/, uint32 spellid /*= 0*/)
+{
+    if (nodes.size() < 2)
+        return false;
+
+    // not let cheating with start flight in time of logout process || while in combat || has type state: stunned || has type state: root
+    if (GetSession()->isLogingOut() || isInCombat() || HasUnitState(UNIT_STATE_STUNNED) || HasUnitState(UNIT_STATE_ROOT))
+    {
+        GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERBUSY);
+        return false;
+    }
+
+    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE))
+        return false;
+
+    // taximaster case
+    if (npc)
+    {
+        // not let cheating with start flight mounted
+        if (IsMounted())
+        {
+            GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERALREADYMOUNTED);
+            return false;
+        }
+
+        if (IsInDisallowedMountForm())
+        {
+            GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERSHAPESHIFTED);
+            return false;
+        }
+
+        // not let cheating with start flight in time of logout process || if casting not finished || while in combat || if not use Spell's with EffectSendTaxi
+        if (IsNonMeleeSpellCasted(false))
+        {
+            GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERBUSY);
+            return false;
+        }
+    }
+    // cast case or scripted call case
+    else
+    {
+        RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+        if (IsInDisallowedMountForm())
+            RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
+
+        if (Spell* spell = GetCurrentSpell(CURRENT_GENERIC_SPELL))
+            if (spell->m_spellInfo->Id != spellid)
+                InterruptSpell(CURRENT_GENERIC_SPELL, false);
+
+        InterruptSpell(CURRENT_AUTOREPEAT_SPELL, false);
+
+        if (Spell* spell = GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+            if (spell->m_spellInfo->Id != spellid)
+                InterruptSpell(CURRENT_CHANNELED_SPELL, true);
+    }
+
+    uint32 sourcenode = nodes[0];
+
+    // starting node too far away (cheat?)
+    TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(sourcenode);
+    if (!node)
+    {
+        GetSession()->SendActivateTaxiReply(ERR_TAXINOSUCHPATH);
+        return false;
+    }
+
+    // check node starting pos data set case if provided
+    if (node->x != 0.0f || node->y != 0.0f || node->z != 0.0f)
+    {
+        if (node->map_id != GetMapId() ||
+            (node->x - GetPositionX())*(node->x - GetPositionX())+
+            (node->y - GetPositionY())*(node->y - GetPositionY())+
+            (node->z - GetPositionZ())*(node->z - GetPositionZ()) >
+            (2*INTERACTION_DISTANCE)*(2*INTERACTION_DISTANCE)*(2*INTERACTION_DISTANCE))
+        {
+            GetSession()->SendActivateTaxiReply(ERR_TAXITOOFARAWAY);
+            return false;
+        }
+    }
+    // node must have pos if taxi master case (npc != NULL)
+    else if (npc)
+    {
+        GetSession()->SendActivateTaxiReply(ERR_TAXIUNSPECIFIEDSERVERERROR);
+        return false;
+    }
+
+    // Prepare to flight start now
+
+    // stop combat at start taxi flight if any
+    CombatStop();
+
+    StopCastingCharm();
+    StopCastingBindSight();
+    ExitVehicle();
+
+    // stop trade (client cancel trade at taxi map open but cheating tools can be used for reopen it)
+    TradeCancel(true);
+
+    // clean not finished taxi path if any
+    m_taxi.ClearTaxiDestinations();
+
+    // 0 element current node
+    m_taxi.AddTaxiDestination(sourcenode);
+
+    // fill destinations path tail
+    uint32 sourcepath = 0;
+    uint32 totalcost = 0;
+
+    uint32 prevnode = sourcenode;
+    uint32 lastnode = 0;
+
+    for (uint32 i = 1; i < nodes.size(); ++i)
+    {
+        uint32 path, cost;
+
+        lastnode = nodes[i];
+        sObjectMgr->GetTaxiPath(prevnode, lastnode, path, cost);
+
+        if (!path)
+        {
+            m_taxi.ClearTaxiDestinations();
+            return false;
+        }
+
+        totalcost += cost;
+
+        if (prevnode == sourcenode)
+            sourcepath = path;
+
+        m_taxi.AddTaxiDestination(lastnode);
+
+        prevnode = lastnode;
+    }
+
+    // get mount model (in case non taximaster (npc == NULL) allow more wide lookup)
+    //
+    // Hack-Fix for Alliance not being able to use Acherus taxi. There is
+    // only one mount ID for both sides. Probably not good to use 315 in case DBC nodes
+    // change but I couldn't find a suitable alternative. OK to use class because only DK
+    // can use this taxi.
+    uint32 mount_display_id = sObjectMgr->GetTaxiMountDisplayId(sourcenode, GetTeam(), npc == NULL || (sourcenode == 315 && getClass() == CLASS_DEATH_KNIGHT));
+
+    // in spell case allow 0 model
+    if ((mount_display_id == 0 && spellid == 0) || sourcepath == 0)
+    {
+        GetSession()->SendActivateTaxiReply(ERR_TAXIUNSPECIFIEDSERVERERROR);
+        m_taxi.ClearTaxiDestinations();
+        return false;
+    }
+
+    uint64 money = GetMoney();
+
+    if (npc)
+        totalcost = (uint32)ceil(totalcost*GetReputationPriceDiscount(npc));
+
+    if (money < totalcost)
+    {
+        GetSession()->SendActivateTaxiReply(ERR_TAXINOTENOUGHMONEY);
+        m_taxi.ClearTaxiDestinations();
+        return false;
+    }
+
+    //Checks and preparations done, DO FLIGHT
+    ModifyMoney(-int64(totalcost));
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_SPENT_FOR_TRAVELLING, totalcost);
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_FLIGHT_PATHS_TAKEN, 1);
+
+    // prevent stealth flight
+    //RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TALK);
+
+    if (sWorld->getBoolConfig(CONFIG_INSTANT_TAXI))
+    {
+        TaxiNodesEntry const* lastPathNode = sTaxiNodesStore.LookupEntry(nodes[nodes.size()-1]);
+        m_taxi.ClearTaxiDestinations();
+        TeleportTo(lastPathNode->map_id, lastPathNode->x, lastPathNode->y, lastPathNode->z, GetOrientation());
+        return false;
+    }
+    else
+    {
+        GetSession()->SendActivateTaxiReply(ERR_TAXIOK);
+        GetSession()->SendDoFlight(mount_display_id, sourcepath);
+    }
+    return true;
+}
+
+bool Player::ActivateTaxiPathTo(uint32 taxi_path_id, uint32 spellid /*= 0*/)
+{
+    TaxiPathEntry const* entry = sTaxiPathStore.LookupEntry(taxi_path_id);
+    if (!entry)
+        return false;
+
+    std::vector<uint32> nodes;
+
+    nodes.resize(2);
+    nodes[0] = entry->from;
+    nodes[1] = entry->to;
+
+    return ActivateTaxiPathTo(nodes, NULL, spellid);
+}
+
+void Player::CleanupAfterTaxiFlight()
+{
+    m_taxi.ClearTaxiDestinations();        // not destinations, clear source node
+    Dismount();
+    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_TAXI_FLIGHT);
+    getHostileRefManager().setOnlineOfflineState(true);
+}
+
+void Player::ContinueTaxiFlight()
+{
+    uint32 sourceNode = m_taxi.GetTaxiSource();
+    if (!sourceNode)
+        return;
+
+    sLog->outDebug(LOG_FILTER_UNITS, "WORLD: Restart character %u taxi flight", GetGUIDLow());
+
+    uint32 mountDisplayId = sObjectMgr->GetTaxiMountDisplayId(sourceNode, GetTeam(), true);
+    if (!mountDisplayId)
+        return;
+
+    uint32 path = m_taxi.GetCurrentTaxiPath();
+
+    // search appropriate start path node
+    uint32 startNode = 0;
+
+    TaxiPathNodeList const& nodeList = sTaxiPathNodesByPath[path];
+
+    float distPrev = MAP_SIZE*MAP_SIZE;
+    float distNext =
+        (nodeList[0].x-GetPositionX())*(nodeList[0].x-GetPositionX())+
+        (nodeList[0].y-GetPositionY())*(nodeList[0].y-GetPositionY())+
+        (nodeList[0].z-GetPositionZ())*(nodeList[0].z-GetPositionZ());
+
+    for (uint32 i = 1; i < nodeList.size(); ++i)
+    {
+        TaxiPathNodeEntry const& node = nodeList[i];
+        TaxiPathNodeEntry const& prevNode = nodeList[i-1];
+
+        // skip nodes at another map
+        if (node.mapid != GetMapId())
+            continue;
+
+        distPrev = distNext;
+
+        distNext =
+            (node.x-GetPositionX())*(node.x-GetPositionX())+
+            (node.y-GetPositionY())*(node.y-GetPositionY())+
+            (node.z-GetPositionZ())*(node.z-GetPositionZ());
+
+        float distNodes =
+            (node.x-prevNode.x)*(node.x-prevNode.x)+
+            (node.y-prevNode.y)*(node.y-prevNode.y)+
+            (node.z-prevNode.z)*(node.z-prevNode.z);
+
+        if (distNext + distPrev < distNodes)
+        {
+            startNode = i;
+            break;
+        }
+    }
+
+    GetSession()->SendDoFlight(mountDisplayId, path, startNode);
+}
+
+void Player::ProhibitSpellSchool(SpellSchoolMask idSchoolMask, uint32 unTimeMs)
+{
+    uint8 schools = 0;
+    // Check how many schools the interrupted spell owns to see which spells need to be locked
+    for (int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; ++i)
+        if (idSchoolMask & (1 << i))
+            schools++;
+
+    WorldPacket data(SMSG_SPELL_COOLDOWN, 8+1+m_spells.size()*8);
+    data << uint64(GetGUID());
+    data << uint8(0x0);                                     // flags (0x1, 0x2)
+    time_t curTime = time(NULL);
+    for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
+    {
+        if (itr->second->state == PLAYERSPELL_REMOVED)
+            continue;
+        uint32 unSpellId = itr->first;
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(unSpellId);
+        if (!spellInfo)
+        {
+            ASSERT(spellInfo);
+            continue;
+        }
+
+        // Not send cooldown for this spells
+        if (spellInfo->Attributes & SPELL_ATTR0_DISABLED_WHILE_ACTIVE)
+            continue;
+
+        if (spellInfo->PreventionType != SPELL_PREVENTION_TYPE_SILENCE)
+            continue;
+
+        if (schools <= 1)
+        {
+            bool skipLockout = false;
+            for (int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; ++i)
+            {
+                SpellSchoolMask temp = SpellSchoolMask(1 << i);
+                if (spellInfo->GetSchoolMask() & temp)
+                    if (!(temp & idSchoolMask))
+                        skipLockout = true;
+            }
+            if (skipLockout)
+                continue;
+        }
+
+        if ((spellInfo->GetSchoolMask() & idSchoolMask) && (GetSpellCooldownDelay(unSpellId) * IN_MILLISECONDS) < unTimeMs)
+        {
+            data << uint32(unSpellId);
+            data << uint32(unTimeMs);                       // in m.secs
+            AddSpellCooldown(unSpellId, 0, curTime + unTimeMs/IN_MILLISECONDS);
+        }
+    }
+    GetSession()->SendPacket(&data);
+}
+
+void Player::InitDataForForm(bool reapplyMods)
+{
+    ShapeshiftForm form = GetShapeshiftForm();
+
+    SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(form);
+    if (ssEntry && ssEntry->attackSpeed)
+    {
+        SetAttackTime(BASE_ATTACK, ssEntry->attackSpeed);
+        SetAttackTime(OFF_ATTACK, ssEntry->attackSpeed);
+        SetAttackTime(RANGED_ATTACK, BASE_ATTACK_TIME);
+    }
+    else
+        SetRegularAttackTime();
+
+    switch (form)
+    {
+        case FORM_GHOUL:
+        case FORM_CAT:
+        {
+            if (getPowerType() != POWER_ENERGY)
+                setPowerType(POWER_ENERGY);
+            break;
+        }
+        case FORM_BEAR:
+        {
+            if (getPowerType() != POWER_RAGE)
+                setPowerType(POWER_RAGE);
+            break;
+        }
+        default:                                            // 0, for example
+        {
+            ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(getClass());
+            if (cEntry && cEntry->powerType < MAX_POWERS && uint32(getPowerType()) != cEntry->powerType)
+                setPowerType(Powers(cEntry->powerType));
+            break;
+        }
+    }
+
+    // update auras at form change, ignore this at mods reapply (.reset stats/etc) when form not change.
+    if (!reapplyMods)
+        UpdateEquipSpellsAtFormChange();
+
+    UpdateAttackPowerAndDamage();
+    UpdateAttackPowerAndDamage(true);
+}
+
+void Player::InitDisplayIds()
+{
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+    if (!info)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Player %u has incorrect race/class pair. Can't init display ids.", GetGUIDLow());
+        return;
+    }
+
+    uint8 gender = getGender();
+    switch (gender)
+    {
+        case GENDER_FEMALE:
+            SetDisplayId(info->displayId_f);
+            SetNativeDisplayId(info->displayId_f);
+            break;
+        case GENDER_MALE:
+            SetDisplayId(info->displayId_m);
+            SetNativeDisplayId(info->displayId_m);
+            break;
+        default:
+            sLog->outError(LOG_FILTER_PLAYER, "Invalid gender %u for player", gender);
+            return;
+    }
+}
+
+inline bool Player::_StoreOrEquipNewItem(uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot, int32 price, ItemTemplate const* pProto, Creature* pVendor, VendorItem const* crItem, bool bStore)
+{
+    uint32 stacks = count / pProto->BuyCount;
+    ItemPosCountVec vDest;
+    uint16 uiDest = 0;
+    InventoryResult msg = bStore ?
+        CanStoreNewItem(bag, slot, vDest, item, count) :
+        CanEquipNewItem(slot, uiDest, item, false);
+    if (msg != EQUIP_ERR_OK)
+    {
+        SendEquipError(msg, NULL, NULL, item);
+        return false;
+    }
+
+    ModifyMoney(-price);
+
+	if (crItem->ExtendedCost) // case for new honor system
+	{
+		ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
+		for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
+		{
+			if (iece->RequiredItem[i])
+				DestroyItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * stacks, true);
+		}
+
+		for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
+		{
+			CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
+			if (!entry)
+				continue;
+
+			// Skip check only currencies.. 
+			uint32 checkValue = entry->TotalCap;
+			if (entry->ID == CURRENCY_TYPE_CONQUEST_POINTS)
+				checkValue = 600000;
+
+			if (checkValue > 0 && iece->RequiredCurrencyCount[i] * stacks > checkValue)
+				continue;
+
+			if (iece->RequiredCurrency[i])
+				ModifyCurrency(iece->RequiredCurrency[i], -int32(iece->RequiredCurrencyCount[i] * stacks), true, true);
+		}
+	}
+
+    Item* it = bStore ?
+        StoreNewItem(vDest, item, true) :
+        EquipNewItem(uiDest, item, true);
+    if (it)
+    {
+        uint32 new_count = pVendor->UpdateVendorItemCurrentCount(crItem, count);
+
+        WorldPacket data(SMSG_BUY_ITEM, (8+4+4+4));
+        data << uint64(pVendor->GetGUID());
+        data << uint32(vendorslot + 1);                   // numbered from 1 at client
+        data << int32(crItem->maxcount > 0 ? new_count : 0xFFFFFFFF);
+        data << uint32(count);
+        GetSession()->SendPacket(&data);
+        SendNewItem(it, count, true, false, false);
+
+        if (!bStore)
+            AutoUnequipOffhandIfNeed();
+
+        if (pProto->Flags & ITEM_PROTO_FLAG_REFUNDABLE && crItem->ExtendedCost && pProto->GetMaxStackSize() == 1)
+        {
+            it->SetFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_REFUNDABLE);
+            it->SetRefundRecipient(GetGUIDLow());
+            it->SetPaidMoney(price);
+            it->SetPaidExtendedCost(crItem->ExtendedCost);
+            it->SaveRefundDataToDB();
+            AddRefundReference(it->GetGUIDLow());
+        }
+    }
+    return true;
+}
+
+bool Player::BuyCurrencyFromVendorSlot(uint64 vendorGuid, uint32 vendorSlot, uint32 currency, uint32 count)
+{
+    // cheating attempt
+    if (count < 1) count = 1;
+
+    if (!isAlive())
+        return false;
+
+    CurrencyTypesEntry const* proto = sCurrencyTypesStore.LookupEntry(currency);
+    if (!proto)
+    {
+        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, currency, 0);
+        return false;
+    }
+
+    Creature* creature = GetNPCIfCanInteractWith(vendorGuid, UNIT_NPC_FLAG_VENDOR);
+    if (!creature)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: BuyCurrencyFromVendorSlot - Unit (GUID: %u) not found or you can't interact with him.", GUID_LOPART(vendorGuid));
+        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, currency, 0);
+        return false;
+    }
+
+    VendorItemData const* vItems = creature->GetVendorItems();
+    if (!vItems || vItems->Empty())
+    {
+        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
+        return false;
+    }
+
+    if (vendorSlot >= vItems->GetItemCount())
+    {
+        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
+        return false;
+    }
+
+    VendorItem const* crItem = vItems->GetItem(vendorSlot);
+    // store diff item (cheating)
+    if (!crItem || crItem->item != currency || crItem->Type != ITEM_VENDOR_TYPE_CURRENCY)
+    {
+        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
+        return false;
+    }
+
+    if (count && crItem->maxcount && count % crItem->maxcount != 0)
+    {
+        SendEquipError(EQUIP_ERR_CANT_BUY_QUANTITY, NULL, NULL);
+        return false;
+    }
+
+    uint32 stacks = count / crItem->maxcount;
+    ItemExtendedCostEntry const* iece = NULL;
+    if (crItem->ExtendedCost)
+    {
+        iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
+        if (!iece)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Currency %u have wrong ExtendedCost field value %u", currency, crItem->ExtendedCost);
+            return false;
+        }
+
+		for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
+		{
+			if (iece->RequiredItem[i] && !HasItemCount(iece->RequiredItem[i], (iece->RequiredItemCount[i] * stacks)))
+			{
+				SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
+				return false;
+			}
+		}
+
+		for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
+		{
+			if (!iece->RequiredCurrency[i])
+				continue;
+
+			CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
+			if (!entry)
+			{
+				SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0); // Find correct error
+				return false;
+			}
+
+			if (!HasCurrency(iece->RequiredCurrency[i], (iece->RequiredCurrencyCount[i])))
+			{
+				SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
+				return false;
+			}
+		}
+
+        // check for personal arena rating requirement
+        if (GetMaxPersonalArenaRatingRequirement(iece->RequiredArenaSlot) < iece->RequiredPersonalArenaRating)
+        {
+            // probably not the proper equip err
+            SendEquipError(EQUIP_ERR_CANT_EQUIP_RANK, NULL, NULL);
+            return false;
+        }
+
+        if (iece->RequiredFactionId && GetReputationRank(iece->RequiredFactionId) << iece->RequiredFactionStanding)
+        {
+            SendBuyError(BUY_ERR_REPUTATION_REQUIRE, creature, currency, 0);
+            return false;
+        }
+
+        if (iece->RequirementFlags & ITEM_EXT_COST_FLAG_REQUIRE_GUILD && !GetGuildId())
+        {
+            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
+            return false;
+        }
+
+        if (iece->RequiredGuildLevel && iece->RequiredGuildLevel < GetGuildLevel())
+        {
+            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
+            return false;
+        }
+
+        if (iece->RequiredAchievement && !HasAchieved(iece->RequiredAchievement))
+        {
+            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
+            return false;
+        } 
+    }
+    else // currencies have no price defined, can only be bought with ExtendedCost
+    {
+        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, currency, 0);
+        return false;
+    }
+
+    ModifyCurrency(currency, count, true, true);
+    if (iece)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
+        {
+            if (!iece->RequiredItem[i])
+                continue;
+
+            DestroyItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * stacks, true);
+        }
+
+        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
+        {
+            if (!iece->RequiredCurrency[i])
+                continue;
+
+            if (iece->RequirementFlags & (ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_1 << i))
+                continue; 
+
+            ModifyCurrency(iece->RequiredCurrency[i], -int32(iece->RequiredCurrencyCount[i]) * stacks, false, true);
+        }
+    }
+
+    return true;
+}
+
+// Return true is the bought item has a max count to force refresh of window by caller
+bool Player::BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot)
+{
+    // cheating attempt
+    if (count < 1) count = 1;
+
+    // cheating attempt
+    if (slot > MAX_BAG_SIZE && slot != NULL_SLOT)
+        return false;
+
+    if (!isAlive())
+        return false;
+
+    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
+    if (!pProto)
+    {
+        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, item, 0);
+        return false;
+    }
+
+    Creature* creature = GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
+    if (!creature)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: BuyItemFromVendor - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(vendorguid)));
+        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, item, 0);
+        return false;
+    }
+
+    VendorItemData const* vItems = creature->GetVendorItems();
+    if (!vItems || vItems->Empty())
+    {
+        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
+        return false;
+    }
+
+    if (vendorslot >= vItems->GetItemCount())
+    {
+        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
+        return false;
+    }
+
+    VendorItem const* crItem = vItems->GetItem(vendorslot);
+    // store diff item (cheating)
+    if (!crItem || crItem->item != item)
+    {
+        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
+        return false;
+    }
+
+    // check current item amount if it limited
+    if (crItem->maxcount != 0)
+    {
+        if (creature->GetVendorItemCurrentCount(crItem) < pProto->BuyCount * count)
+        {
+            SendBuyError(BUY_ERR_ITEM_ALREADY_SOLD, creature, item, 0);
+            return false;
+        }
+    }
+
+    if (pProto->RequiredReputationFaction && (uint32(GetReputationRank(pProto->RequiredReputationFaction)) < pProto->RequiredReputationRank))
+    {
+        SendBuyError(BUY_ERR_REPUTATION_REQUIRE, creature, item, 0);
+        return false;
+    }
+
+    if (crItem->ExtendedCost)
+    {
+        // Can only buy full stacks for extended cost
+        if (count % pProto->BuyCount)
+        {
+            SendEquipError(EQUIP_ERR_CANT_BUY_QUANTITY, NULL, NULL);
+            return false;
+        }
+
+        uint32 stacks = count / pProto->BuyCount;
+        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
+        if (!iece)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Item %u have wrong ExtendedCost field value %u", pProto->ItemId, crItem->ExtendedCost);
+            return false;
+        }
+
+        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
+        {
+            if (iece->RequiredItem[i] && !HasItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * stacks))
+            {
+                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
+                return false;
+            }
+        }
+
+		for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
+		{
+			if (!iece->RequiredCurrency[i])
+				continue;
+
+			CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
+			if (!entry)
+			{
+				SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
+				return false;
+			}
+
+			// See if we mush check CurrentAmount or TotalSeasonAmount
+			uint32 checkValue = entry->TotalCap;
+			if (entry->ID == CURRENCY_TYPE_CONQUEST_POINTS)
+				checkValue = 600000;
+
+			if (checkValue != 0 && iece->RequiredCurrencyCount[i] * stacks > checkValue)
+			{
+				// Check for total season amount
+				if (!HasCurrencySeasonCount(iece->RequiredCurrency[i], iece->RequiredCurrencyCount[i] * stacks))
+				{
+					SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
+					return false;
+				}
+			}
+			else
+			{
+				// Check for current amount
+				if (!HasCurrency(iece->RequiredCurrency[i], iece->RequiredCurrencyCount[i] * stacks))
+				{
+					SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
+					return false;
+				}
+			}
+		}
+
+        // check for personal arena rating requirement
+        if (GetMaxPersonalArenaRatingRequirement(iece->RequiredArenaSlot) < iece->RequiredPersonalArenaRating)
+        {
+            // probably not the proper equip err
+            SendEquipError(EQUIP_ERR_CANT_EQUIP_RANK, NULL, NULL);
+            return false;
+        }
+
+        if (iece->RequiredFactionId && GetReputationRank(iece->RequiredFactionId) << iece->RequiredFactionStanding)
+        {
+            SendBuyError(BUY_ERR_REPUTATION_REQUIRE, creature, item, 0);
+            return false;
+        }
+
+        if (iece->RequirementFlags & ITEM_EXT_COST_FLAG_REQUIRE_GUILD && !GetGuildId())
+        {
+            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
+            return false;
+        }
+
+        if (iece->RequiredGuildLevel && iece->RequiredGuildLevel < GetGuildLevel())
+        {
+            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
+            return false;
+        }
+
+        if (iece->RequiredAchievement && !HasAchieved(iece->RequiredAchievement))
+        {
+            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
+            return false;
+        } 
+    }
+
+    uint32 price = 0;
+    if (crItem->IsGoldRequired(pProto) && pProto->BuyPrice > 0) //Assume price cannot be negative (do not know why it is int32)
+    {
+        uint32 maxCount = MAX_MONEY_AMOUNT / pProto->BuyPrice;
+        if ((uint32)count > maxCount)
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player %s tried to buy %u item id %u, causing overflow", GetName().c_str(), (uint32)count, pProto->ItemId);
+            count = (uint8)maxCount;
+        }
+        price = pProto->BuyPrice * count; //it should not exceed MAX_MONEY_AMOUNT
+
+        // reputation discount
+        price = uint32(floor(price * GetReputationPriceDiscount(creature)));
+
+        if (int32 priceMod = GetTotalAuraModifier(SPELL_AURA_MOD_VENDOR_ITEMS_PRICES))
+            price -= CalculatePct(price, priceMod);
+
+        if (!HasEnoughMoney(uint64(price)))
+        {
+            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, item, 0);
+            return false;
+        }
+    }
+
+    if ((bag == NULL_BAG && slot == NULL_SLOT) || IsInventoryPos(bag, slot))
+    {
+        if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, price, pProto, creature, crItem, true))
+            return false;
+    }
+    else if (IsEquipmentPos(bag, slot))
+    {
+        if (count != 1)
+        {
+            SendEquipError(EQUIP_ERR_NOT_EQUIPPABLE, NULL, NULL);
+            return false;
+        }
+        if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, price, pProto, creature, crItem, false))
+            return false;
+    }
+    else
+    {
+        SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
+        return false;
+    }
+
+    if (crItem->maxcount != 0) // bought
+    {
+        if (pProto->Quality > ITEM_QUALITY_EPIC || (pProto->Quality == ITEM_QUALITY_EPIC && pProto->ItemLevel >= MinNewsItemLevel[sWorld->getIntConfig(CONFIG_EXPANSION)]))
+            if (Guild* guild = GetGuild())
+                guild->AddGuildNews(GUILD_NEWS_ITEM_PURCHASED, GetGUID(), 0, item);
+        return true;
+    }
+
+    return false;
+}
+
+uint32 Player::GetMaxPersonalArenaRatingRequirement(uint32 minarenaslot) const
+{
+    // returns the maximal personal arena rating that can be used to purchase items requiring this condition
+    // the personal rating of the arena team must match the required limit as well
+    // so return max[in arenateams](min(personalrating[teamtype], teamrating[teamtype]))
+    uint32 max_personal_rating = 0;
+    for (uint8 i = minarenaslot; i < MAX_ARENA_SLOT; ++i)
+    {
+        if (ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(GetArenaTeamId(i)))
+        {
+            uint32 p_rating = GetArenaPersonalRating(i);
+            uint32 t_rating = at->GetRating();
+            p_rating = p_rating < t_rating ? p_rating : t_rating;
+            if (max_personal_rating < p_rating)
+                max_personal_rating = p_rating;
+        }
+    }
+    return max_personal_rating;
+}
+
+void Player::UpdateHomebindTime(uint32 time)
+{
+    // GMs never get homebind timer online
+    if (m_InstanceValid || isGameMaster())
+    {
+        if (m_HomebindTimer)                                 // instance valid, but timer not reset
+        {
+            // hide reminder
+            WorldPacket data(SMSG_RAID_GROUP_ONLY, 4+4);
+            data << uint32(0);
+            data << uint32(0);
+            GetSession()->SendPacket(&data);
+        }
+        // instance is valid, reset homebind timer
+        m_HomebindTimer = 0;
+    }
+    else if (m_HomebindTimer > 0)
+    {
+        if (time >= m_HomebindTimer)
+        {
+            // teleport to nearest graveyard
+            RepopAtGraveyard();
+        }
+        else
+            m_HomebindTimer -= time;
+    }
+    else
+    {
+        // instance is invalid, start homebind timer
+        m_HomebindTimer = 60000;
+        // send message to player
+        WorldPacket data(SMSG_RAID_GROUP_ONLY, 4+4);
+        data << uint32(m_HomebindTimer);
+        data << uint32(1);
+        GetSession()->SendPacket(&data);
+        sLog->outDebug(LOG_FILTER_MAPS, "PLAYER: Player '%s' (GUID: %u) will be teleported to homebind in 60 seconds", GetName().c_str(), GetGUIDLow());
+    }
+}
+
+void Player::UpdatePvPState(bool onlyFFA)
+{
+    // TODO: should we always synchronize UNIT_FIELD_BYTES_2, 1 of controller and controlled?
+    // no, we shouldn't, those are checked for affecting player by client
+    if (!pvpInfo.inNoPvPArea && !isGameMaster()
+        && (pvpInfo.inFFAPvPArea || sWorld->IsFFAPvPRealm()))
+    {
+        if (!HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+        {
+            SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+            for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+                (*itr)->SetByteValue(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+        }
+    }
+    else if (HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+    {
+        RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+        for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+            (*itr)->RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+    }
+
+    if (onlyFFA)
+        return;
+
+    if (pvpInfo.inHostileArea)                               // in hostile area
+    {
+        if (!IsPvP() || pvpInfo.endTimer != 0)
+            UpdatePvP(true, true);
+    }
+    else                                                    // in friendly area
+    {
+        if (IsPvP() && !HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP) && pvpInfo.endTimer == 0)
+            pvpInfo.endTimer = time(0);                     // start toggle-off
+    }
+}
+
+void Player::UpdatePvP(bool state, bool override)
+{
+    if (!state || override)
+    {
+        SetPvP(state);
+        pvpInfo.endTimer = 0;
+    }
+    else
+    {
+        pvpInfo.endTimer = time(NULL);
+        SetPvP(state);
+    }
+}
+
+void Player::ModifySpellCooldown(uint32 spellId, int32 cooldown)
+{
+    SpellCooldowns::iterator itr = m_spellCooldowns.find(spellId);
+    if (itr == m_spellCooldowns.end())
+        return;
+
+    time_t now = time(NULL);
+    if (itr->second.end + (cooldown / IN_MILLISECONDS) > now)
+        itr->second.end += (cooldown / IN_MILLISECONDS);
+    else
+        m_spellCooldowns.erase(itr);
+
+    WorldPacket data(SMSG_MODIFY_COOLDOWN, 4 + 8 + 4);
+    data << uint32(spellId);            // Spell ID
+    data << uint64(GetGUID());          // Player GUID
+    data << int32(cooldown);            // Cooldown mod in milliseconds
+    GetSession()->SendPacket(&data);
+
+    sLog->outDebug(LOG_FILTER_GENERAL, "ModifySpellCooldown:: Player: %s (GUID: %u) Spell: %u cooldown: %u", GetName().c_str(), GetGUIDLow(), spellId, GetSpellCooldownDelay(spellId));
+}
+
+void Player::SendCooldownEvent(SpellInfo const* spellInfo, uint32 itemId /*= 0*/, Spell* spell /*= NULL*/, bool setCooldown /*= true*/)
+{
+    // start cooldowns at server side, if any
+    if (setCooldown)
+        AddSpellAndCategoryCooldowns(spellInfo, itemId, spell);
+
+    // Send activate cooldown timer (possible 0) at client side
+    WorldPacket data(SMSG_COOLDOWN_EVENT, 4 + 8);
+    data << uint32(spellInfo->Id);
+    data << uint64(GetGUID());
+    SendDirectMessage(&data);
+}
+
+void Player::UpdatePotionCooldown(Spell* spell)
+{
+    // no potion used i combat or still in combat
+    if (!m_lastPotionId || isInCombat())
+        return;
+
+    // Call not from spell cast, send cooldown event for item spells if no in combat
+    if (!spell)
+    {
+        // spell/item pair let set proper cooldown (except not existed charged spell cooldown spellmods for potions)
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(m_lastPotionId))
+            for (uint8 idx = 0; idx < MAX_ITEM_SPELLS; ++idx)
+                if (proto->Spells[idx].SpellId && proto->Spells[idx].SpellTrigger == ITEM_SPELLTRIGGER_ON_USE)
+                    if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[idx].SpellId))
+                        SendCooldownEvent(spellInfo, m_lastPotionId);
+    }
+    // from spell cases (m_lastPotionId set in Spell::SendSpellCooldown)
+    else
+        SendCooldownEvent(spell->m_spellInfo, m_lastPotionId, spell);
+
+    m_lastPotionId = 0;
+}
+
+                                                           //slot to be excluded while counting
+bool Player::EnchantmentFitsRequirements(uint32 enchantmentcondition, int8 slot)
+{
+    if (!enchantmentcondition)
+        return true;
+
+    SpellItemEnchantmentConditionEntry const* Condition = sSpellItemEnchantmentConditionStore.LookupEntry(enchantmentcondition);
+
+    if (!Condition)
+        return true;
+
+    uint8 curcount[4] = {0, 0, 0, 0};
+
+    //counting current equipped gem colors
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        if (i == slot)
+            continue;
+        Item* pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pItem2 && !pItem2->IsBroken() && pItem2->GetTemplate()->Socket[0].Color)
+        {
+            for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
+            {
+                uint32 enchant_id = pItem2->GetEnchantmentId(EnchantmentSlot(enchant_slot));
+                if (!enchant_id)
+                    continue;
+
+                SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+                if (!enchantEntry)
+                    continue;
+
+                uint32 gemid = enchantEntry->GemID;
+                if (!gemid)
+                    continue;
+
+                ItemTemplate const* gemProto = sObjectMgr->GetItemTemplate(gemid);
+                if (!gemProto)
+                    continue;
+
+                GemPropertiesEntry const* gemProperty = sGemPropertiesStore.LookupEntry(gemProto->GemProperties);
+                if (!gemProperty)
+                    continue;
+
+                uint8 GemColor = gemProperty->color;
+
+                for (uint8 b = 0, tmpcolormask = 1; b < 4; b++, tmpcolormask <<= 1)
+                {
+                    if (tmpcolormask & GemColor)
+                        ++curcount[b];
+                }
+            }
+        }
+    }
+
+    bool activate = true;
+
+    for (uint8 i = 0; i < 3; i++)
+    {
+        if (!Condition->Color[i])
+            continue;
+
+        uint32 _cur_gem = curcount[Condition->Color[i] - 1];
+
+        // if have <CompareColor> use them as count, else use <value> from Condition
+        uint32 _cmp_gem = Condition->CompareColor[i] ? curcount[Condition->CompareColor[i] - 1] : Condition->Value[i];
+
+        switch (Condition->Comparator[i])
+        {
+            case 2:                                         // requires less <color> than (<value> || <comparecolor>) gems
+                activate &= (_cur_gem < _cmp_gem) ? true : false;
+                break;
+            case 3:                                         // requires more <color> than (<value> || <comparecolor>) gems
+                activate &= (_cur_gem > _cmp_gem) ? true : false;
+                break;
+            case 5:                                         // requires at least <color> than (<value> || <comparecolor>) gems
+                activate &= (_cur_gem >= _cmp_gem) ? true : false;
+                break;
+        }
+    }
+
+    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Checking Condition %u, there are %u Meta Gems, %u Red Gems, %u Yellow Gems and %u Blue Gems, Activate:%s", enchantmentcondition, curcount[0], curcount[1], curcount[2], curcount[3], activate ? "yes" : "no");
+
+    return activate;
+}
+
+void Player::CorrectMetaGemEnchants(uint8 exceptslot, bool apply)
+{
+                                                            //cycle all equipped items
+    for (uint32 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        //enchants for the slot being socketed are handled by Player::ApplyItemMods
+        if (slot == exceptslot)
+            continue;
+
+        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+
+        if (!pItem || !pItem->GetTemplate()->Socket[0].Color)
+            continue;
+
+        for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
+        {
+            uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
+            if (!enchant_id)
+                continue;
+
+            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+            if (!enchantEntry)
+                continue;
+
+            uint32 condition = enchantEntry->EnchantmentCondition;
+            if (condition)
+            {
+                                                            //was enchant active with/without item?
+                bool wasactive = EnchantmentFitsRequirements(condition, apply ? exceptslot : -1);
+                                                            //should it now be?
+                if (wasactive ^ EnchantmentFitsRequirements(condition, apply ? -1 : exceptslot))
+                {
+                    // ignore item gem conditions
+                                                            //if state changed, (dis)apply enchant
+                    ApplyEnchantment(pItem, EnchantmentSlot(enchant_slot), !wasactive, true, true);
+                }
+            }
+        }
+    }
+}
+
+                                                            //if false -> then toggled off if was on| if true -> toggled on if was off AND meets requirements
+void Player::ToggleMetaGemsActive(uint8 exceptslot, bool apply)
+{
+    //cycle all equipped items
+    for (int slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        //enchants for the slot being socketed are handled by WorldSession::HandleSocketOpcode(WorldPacket& recvData)
+        if (slot == exceptslot)
+            continue;
+
+        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+
+        if (!pItem || !pItem->GetTemplate()->Socket[0].Color)   //if item has no sockets or no item is equipped go to next item
+            continue;
+
+        //cycle all (gem)enchants
+        for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
+        {
+            uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
+            if (!enchant_id)                                 //if no enchant go to next enchant(slot)
+                continue;
+
+            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+            if (!enchantEntry)
+                continue;
+
+            //only metagems to be (de)activated, so only enchants with condition
+            uint32 condition = enchantEntry->EnchantmentCondition;
+            if (condition)
+                ApplyEnchantment(pItem, EnchantmentSlot(enchant_slot), apply);
+        }
+    }
+}
+
+void Player::SetBattlegroundEntryPoint()
+{
+    // Taxi path store
+    if (!m_taxi.empty())
+    {
+        m_bgData.mountSpell  = 0;
+        m_bgData.taxiPath[0] = m_taxi.GetTaxiSource();
+        m_bgData.taxiPath[1] = m_taxi.GetTaxiDestination();
+
+        // On taxi we don't need check for dungeon
+        m_bgData.joinPos = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
+    }
+    else
+    {
+        m_bgData.ClearTaxiPath();
+
+        // Mount spell id storing
+        if (IsMounted())
+        {
+            AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+            if (!auras.empty())
+                m_bgData.mountSpell = (*auras.begin())->GetId();
+        }
+        else
+            m_bgData.mountSpell = 0;
+
+        // If map is dungeon find linked graveyard
+        if (GetMap()->IsDungeon())
+        {
+            if (const WorldSafeLocsEntry* entry = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam()))
+                m_bgData.joinPos = WorldLocation(entry->map_id, entry->x, entry->y, entry->z, 0.0f);
+            else
+                sLog->outError(LOG_FILTER_PLAYER, "SetBattlegroundEntryPoint: Dungeon map %u has no linked graveyard, setting home location as entry point.", GetMapId());
+        }
+        // If new entry point is not BG or arena set it
+        else if (!GetMap()->IsBattlegroundOrArena())
+            m_bgData.joinPos = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
+    }
+
+    if (m_bgData.joinPos.m_mapId == MAPID_INVALID) // In error cases use homebind position
+        m_bgData.joinPos = WorldLocation(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, 0.0f);
+}
+
+void Player::LeaveBattleground(bool teleportToEntryPoint)
+{
+    if (Battleground* bg = GetBattleground())
+    {
+        bg->RemovePlayerAtLeave(GetGUID(), teleportToEntryPoint, true);
+
+        // call after remove to be sure that player resurrected for correct cast
+        if (bg->isBattleground() && !isGameMaster() && sWorld->getBoolConfig(CONFIG_BATTLEGROUND_CAST_DESERTER))
+        {
+            if (bg->GetStatus() == STATUS_IN_PROGRESS || bg->GetStatus() == STATUS_WAIT_JOIN)
+            {
+                //lets check if player was teleported from BG and schedule delayed Deserter spell cast
+                if (IsBeingTeleportedFar())
+                {
+                    ScheduleDelayedOperation(DELAYED_SPELL_CAST_DESERTER);
+                    return;
+                }
+
+                CastSpell(this, 26013, true);               // Deserter
+            }
+        }
+    }
+}
+
+bool Player::CanJoinToBattleground(Battleground const* /*bg*/) const
+{
+    // check Deserter debuff
+    if (HasAura(26013))
+        return false;
+
+    return true;
+}
+
+bool Player::CanReportAfkDueToLimit()
+{
+    // a player can complain about 15 people per 5 minutes
+    if (m_bgData.bgAfkReportedCount++ >= 15)
+        return false;
+
+    return true;
+}
+
+///This player has been blamed to be inactive in a battleground
+void Player::ReportedAfkBy(Player* reporter)
+{
+    Battleground* bg = GetBattleground();
+    // Battleground also must be in progress!
+    if (!bg || bg != reporter->GetBattleground() || GetTeam() != reporter->GetTeam() || bg->GetStatus() != STATUS_IN_PROGRESS)
+        return;
+
+    // check if player has 'Idle' or 'Inactive' debuff
+    if (m_bgData.bgAfkReporter.find(reporter->GetGUIDLow()) == m_bgData.bgAfkReporter.end() && !HasAura(43680) && !HasAura(43681) && reporter->CanReportAfkDueToLimit())
+    {
+        m_bgData.bgAfkReporter.insert(reporter->GetGUIDLow());
+        // 3 players have to complain to apply debuff
+        if (m_bgData.bgAfkReporter.size() >= 3)
+        {
+            // cast 'Idle' spell
+            CastSpell(this, 43680, true);
+            m_bgData.bgAfkReporter.clear();
+        }
+    }
+}
+
+WorldLocation Player::GetStartPosition() const
+{
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+    uint32 mapId = info->mapId;
+    if (getClass() == CLASS_DEATH_KNIGHT && HasSpell(50977))
+        mapId = 0;
+    return WorldLocation(mapId, info->positionX, info->positionY, info->positionZ, 0);
+}
+
+bool Player::IsNeverVisible() const
+{
+    if (Unit::IsNeverVisible())
+        return true;
+
+    if (GetSession()->PlayerLogout() || GetSession()->PlayerLoading())
+        return true;
+
+    return false;
+}
+
+bool Player::CanAlwaysSee(WorldObject const* obj) const
+{
+    // Always can see self
+    if (m_mover == obj)
+        return true;
+
+    if (uint64 guid = GetUInt64Value(PLAYER_FARSIGHT))
+        if (obj->GetGUID() == guid)
+            return true;
+
+    return false;
+}
+
+bool Player::IsAlwaysDetectableFor(WorldObject const* seer) const
+{
+    if (Unit::IsAlwaysDetectableFor(seer))
+        return true;
+
+    if (const Player* seerPlayer = seer->ToPlayer())
+        if (IsGroupVisibleFor(seerPlayer))
+            return true;
+
+     return false;
+ }
+
+bool Player::IsVisibleGloballyFor(Player const* u) const
+{
+    if (!u)
+        return false;
+
+    // Always can see self
+    if (u == this)
+        return true;
+
+    // Visible units, always are visible for all players
+    if (IsVisible())
+        return true;
+
+    // GMs are visible for higher gms (or players are visible for gms)
+    if (!AccountMgr::IsPlayerAccount(u->GetSession()->GetSecurity()))
+        return GetSession()->GetSecurity() <= u->GetSession()->GetSecurity();
+
+    // non faction visibility non-breakable for non-GMs
+    if (!IsVisible())
+        return false;
+
+    // non-gm stealth/invisibility not hide from global player lists
+    return true;
+}
+
+template<class T>
+inline void UpdateVisibilityOf_helper(std::set<uint64>& s64, T* target, std::set<Unit*>& /*v*/)
+{
+    s64.insert(target->GetGUID());
+}
+
+template<>
+inline void UpdateVisibilityOf_helper(std::set<uint64>& s64, GameObject* target, std::set<Unit*>& /*v*/)
+{
+    // Don't update only GAMEOBJECT_TYPE_TRANSPORT (or all transports and destructible buildings?)
+    if ((target->GetGOInfo()->type != GAMEOBJECT_TYPE_TRANSPORT))
+        s64.insert(target->GetGUID());
+}
+
+template<>
+inline void UpdateVisibilityOf_helper(std::set<uint64>& s64, Creature* target, std::set<Unit*>& v)
+{
+    s64.insert(target->GetGUID());
+    v.insert(target);
+}
+
+template<>
+inline void UpdateVisibilityOf_helper(std::set<uint64>& s64, Player* target, std::set<Unit*>& v)
+{
+    s64.insert(target->GetGUID());
+    v.insert(target);
+}
+
+template<class T>
+inline void BeforeVisibilityDestroy(T* /*t*/, Player* /*p*/)
+{
+}
+
+template<>
+inline void BeforeVisibilityDestroy<Creature>(Creature* t, Player* p)
+{
+    if (p->GetPetGUID() == t->GetGUID() && t->ToCreature()->isPet())
+        ((Pet*)t)->Remove(PET_SLOT_ACTUAL_PET_SLOT, true);
+}
+
+void Player::UpdateVisibilityOf(WorldObject* target)
+{
+    if (HaveAtClient(target))
+    {
+        if (!canSeeOrDetect(target, false, true))
+        {
+            if (target->GetTypeId() == TYPEID_UNIT)
+                BeforeVisibilityDestroy<Creature>(target->ToCreature(), this);
+
+            target->DestroyForPlayer(this);
+            m_clientGUIDs.erase(target->GetGUID());
+
+            #ifdef TRINITY_DEBUG
+                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u) out of range for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), GetGUIDLow(), GetDistance(target));
+            #endif
+        }
+    }
+    else
+    {
+        if (canSeeOrDetect(target, false, true))
+        {
+            //if (target->isType(TYPEMASK_UNIT) && ((Unit*)target)->m_Vehicle)
+            //    UpdateVisibilityOf(((Unit*)target)->m_Vehicle);
+
+            target->SendUpdateToPlayer(this);
+            m_clientGUIDs.insert(target->GetGUID());
+
+            #ifdef TRINITY_DEBUG
+                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u) is visible now for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), GetGUIDLow(), GetDistance(target));
+            #endif
+
+            // target aura duration for caster show only if target exist at caster client
+            // send data at target visibility change (adding to client)
+            if (target->isType(TYPEMASK_UNIT))
+                SendInitialVisiblePackets((Unit*)target);
+        }
+    }
+}
+
+void Player::UpdateTriggerVisibility()
+{
+    if (m_clientGUIDs.empty())
+        return;
+
+    if (!IsInWorld())
+        return;
+
+    UpdateData udata(GetMapId());
+    WorldPacket packet;
+    for (ClientGUIDs::iterator itr = m_clientGUIDs.begin(); itr != m_clientGUIDs.end(); ++itr)
+    {
+        if (IS_CREATURE_GUID(*itr))
+        {
+            Creature* obj = GetMap()->GetCreature(*itr);
+            if (!obj || !(obj->isTrigger() || obj->HasAuraType(SPELL_AURA_TRANSFORM)))  // can transform into triggers
+                continue;
+
+            obj->BuildCreateUpdateBlockForPlayer(&udata, this);
+        }
+    }
+
+    udata.BuildPacket(&packet);
+    GetSession()->SendPacket(&packet);
+}
+
+void Player::SendInitialVisiblePackets(Unit* target)
+{
+    SendAurasForTarget(target);
+    if (target->isAlive())
+    {
+        if (target->HasUnitState(UNIT_STATE_MELEE_ATTACKING) && target->GetVictim())
+            target->SendMeleeAttackStart(target->GetVictim());
+    }
+}
+
+template<class T>
+void Player::UpdateVisibilityOf(T* target, UpdateData& data, std::set<Unit*>& visibleNow)
+{
+    if (HaveAtClient(target))
+    {
+        if (!canSeeOrDetect(target, false, true))
+        {
+            BeforeVisibilityDestroy<T>(target, this);
+
+            target->BuildOutOfRangeUpdateBlock(&data);
+            m_clientGUIDs.erase(target->GetGUID());
+
+            #ifdef TRINITY_DEBUG
+                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u, Entry: %u) is out of range for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), target->GetEntry(), GetGUIDLow(), GetDistance(target));
+            #endif
+        }
+    }
+    else //if (visibleNow.size() < 30 || target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsVehicle())
+    {
+        if (canSeeOrDetect(target, false, true))
+        {
+            //if (target->isType(TYPEMASK_UNIT) && ((Unit*)target)->m_Vehicle)
+            //    UpdateVisibilityOf(((Unit*)target)->m_Vehicle, data, visibleNow);
+
+            target->BuildCreateUpdateBlockForPlayer(&data, this);
+            UpdateVisibilityOf_helper(m_clientGUIDs, target, visibleNow);
+
+            #ifdef TRINITY_DEBUG
+                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u, Entry: %u) is visible now for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), target->GetEntry(), GetGUIDLow(), GetDistance(target));
+            #endif
+        }
+    }
+}
+
+template void Player::UpdateVisibilityOf(Player*        target, UpdateData& data, std::set<Unit*>& visibleNow);
+template void Player::UpdateVisibilityOf(Creature*      target, UpdateData& data, std::set<Unit*>& visibleNow);
+template void Player::UpdateVisibilityOf(Corpse*        target, UpdateData& data, std::set<Unit*>& visibleNow);
+template void Player::UpdateVisibilityOf(GameObject*    target, UpdateData& data, std::set<Unit*>& visibleNow);
+template void Player::UpdateVisibilityOf(DynamicObject* target, UpdateData& data, std::set<Unit*>& visibleNow);
+
+void Player::UpdateObjectVisibility(bool forced)
+{
+    if (!forced)
+        AddToNotify(NOTIFY_VISIBILITY_CHANGED);
+    else
+    {
+        Unit::UpdateObjectVisibility(true);
+        UpdateVisibilityForPlayer();
+    }
+}
+
+void Player::UpdateVisibilityForPlayer()
+{
+    // updates visibility of all objects around point of view for current player
+    Trinity::VisibleNotifier notifier(*this);
+    m_seer->VisitNearbyObject(GetSightRange(), notifier);
+    notifier.SendToSelf();   // send gathered data
+}
+
+void Player::InitPrimaryProfessions()
+{
+    SetFreePrimaryProfessions(sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL));
+}
+
+void Player::ModifyMoney(int64 d)
+{
+    sScriptMgr->OnPlayerMoneyChanged(this, d);
+
+    if (d < 0)
+        SetMoney (GetMoney() > uint64(-d) ? GetMoney() + d : 0);
+    else
+    {
+        uint64 newAmount = 0;
+        if (GetMoney() < uint64(MAX_MONEY_AMOUNT - d))
+            newAmount = GetMoney() + d;
+        else
+        {
+            // "At Gold Limit"
+            newAmount = MAX_MONEY_AMOUNT;
+            if (d)
+                SendEquipError(EQUIP_ERR_TOO_MUCH_GOLD, NULL, NULL);
+        }
+        SetMoney(newAmount);
+    }
+}
+
+Unit* Player::GetSelectedUnit() const
+{
+    if (m_curSelection)
+        return ObjectAccessor::GetUnit(*this, m_curSelection);
+    return NULL;
+}
+
+Player* Player::GetSelectedPlayer() const
+{
+    if (m_curSelection)
+        return ObjectAccessor::GetPlayer(*this, m_curSelection);
+    return NULL;
+}
+
+void Player::SendComboPoints()
+{
+    Unit* combotarget = ObjectAccessor::GetUnit(*this, m_comboTarget);
+    if (combotarget)
+    {
+        WorldPacket data;
+        if (m_mover != this)
+        {
+            data.Initialize(SMSG_PET_UPDATE_COMBO_POINTS, m_mover->GetPackGUID().size()+combotarget->GetPackGUID().size()+1);
+            data.append(m_mover->GetPackGUID());
+        }
+        else
+            data.Initialize(SMSG_UPDATE_COMBO_POINTS, combotarget->GetPackGUID().size()+1);
+        data.append(combotarget->GetPackGUID());
+        data << uint8(m_comboPoints);
+        GetSession()->SendPacket(&data);
+    }
+}
+
+void Player::AddComboPoints(Unit* target, int8 count, Spell* spell)
+{
+    if (!count)
+        return;
+
+    int8 * comboPoints = spell ? &spell->m_comboPointGain : &m_comboPoints;
+
+    // without combo points lost (duration checked in aura)
+    RemoveAurasByType(SPELL_AURA_RETAIN_COMBO_POINTS);
+
+    if (target->GetGUID() == m_comboTarget)
+        *comboPoints += count;
+    else
+    {
+        if (m_comboTarget)
+            if (Unit* target2 = ObjectAccessor::GetUnit(*this, m_comboTarget))
+                target2->RemoveComboPointHolder(GetGUIDLow());
+
+        // Spells will always add value to m_comboPoints eventualy, so it must be cleared first
+        if (spell)
+            m_comboPoints = 0;
+
+        m_comboTarget = target->GetGUID();
+        *comboPoints = count;
+
+        target->AddComboPointHolder(GetGUIDLow());
+    }
+
+    if (*comboPoints > 5)
+        *comboPoints = 5;
+    else if (*comboPoints < 0)
+        *comboPoints = 0;
+
+    if (!spell)
+        SendComboPoints();
+}
+
+void Player::GainSpellComboPoints(int8 count)
+{
+    if (!count)
+        return;
+
+    m_comboPoints += count;
+    if (m_comboPoints > 5) m_comboPoints = 5;
+    else if (m_comboPoints < 0) m_comboPoints = 0;
+
+    SendComboPoints();
+}
+
+void Player::ClearComboPoints()
+{
+    if (!m_comboTarget)
+        return;
+
+    // without combopoints lost (duration checked in aura)
+    RemoveAurasByType(SPELL_AURA_RETAIN_COMBO_POINTS);
+
+    m_comboPoints = 0;
+
+    SendComboPoints();
+
+    if (Unit* target = ObjectAccessor::GetUnit(*this, m_comboTarget))
+        target->RemoveComboPointHolder(GetGUIDLow());
+
+    m_comboTarget = 0;
+}
+
+void Player::SetGroup(Group* group, int8 subgroup)
+{
+    if (group == NULL)
+        m_group.unlink();
+    else
+    {
+        // never use SetGroup without a subgroup unless you specify NULL for group
+        ASSERT(subgroup >= 0);
+        m_group.link(group, this);
+        m_group.setSubGroup((uint8)subgroup);
+    }
+
+    UpdateObjectVisibility(false);
+}
+
+void Player::SendInitialPacketsBeforeAddToMap()
+{
+    /// Pass 'this' as argument because we're not stored in ObjectAccessor yet
+    GetSocial()->SendSocialList(this);
+
+    // guild bank list wtf?
+
+    // Homebind
+    WorldPacket data(SMSG_BINDPOINTUPDATE, 5*4);
+    data << m_homebindX << m_homebindY << m_homebindZ;
+    data << (uint32) m_homebindMapId;
+    data << (uint32) m_homebindAreaId;
+    GetSession()->SendPacket(&data);
+
+    // SMSG_SET_PROFICIENCY
+    // SMSG_SET_PCT_SPELL_MODIFIER
+    // SMSG_SET_FLAT_SPELL_MODIFIER
+    // SMSG_UPDATE_AURA_DURATION
+
+    SendTalentsInfoData(false);
+
+    data.Initialize(SMSG_WORLD_SERVER_INFO, 1 + 1 + 4 + 4);
+    data.WriteBit(0);                                               // HasRestrictedLevel
+    data.WriteBit(0);                                               // HasRestrictedMoney
+    data.WriteBit(0);                                               // IneligibleForLoot
+    data.FlushBits();
+    //if (IneligibleForLoot)
+    //    data << uint32(0);                                        // EncounterMask
+
+    data << uint8(0);                                               // IsOnTournamentRealm
+    //if (HasRestrictedMoney)
+    //    data << uint32(100000);                                   // RestrictedMoney (starter accounts)
+    //if (HasRestrictedLevel)
+    //    data << uint32(20);                                       // RestrictedLevel (starter accounts)
+
+    data << uint32(sWorld->GetNextWeeklyQuestsResetTime() - WEEK);  // LastWeeklyReset (not instance reset)
+    data << uint32(GetMap()->GetDifficulty());
+    GetSession()->SendPacket(&data);
+
+    SendInitialSpells();
+
+    data.Initialize(SMSG_SEND_UNLEARN_SPELLS, 4);
+    data << uint32(0);                                      // count, for (count) uint32;
+    GetSession()->SendPacket(&data);
+
+    SendInitialActionButtons();
+    m_reputationMgr->SendInitialReputations();
+    m_achievementMgr->SendAllAchievementData(this);
+
+    SendEquipmentSetList();
+
+    data.Initialize(SMSG_LOGIN_SETTIMESPEED, 4 + 4 + 4);
+    data.AppendPackedTime(sWorld->GetGameTime());
+    data << float(0.01666667f);                             // game speed
+    data << uint32(0);                                      // added in 3.1.2
+    GetSession()->SendPacket(&data);
+
+    GetReputationMgr().SendForceReactions();                // SMSG_SET_FORCED_REACTIONS
+
+    // SMSG_TALENTS_INFO x 2 for pet (unspent points and talents in separate packets...)
+    // SMSG_PET_GUIDS
+    // SMSG_UPDATE_WORLD_STATE
+    // SMSG_POWER_UPDATE
+
+    // Clear spline before add to map
+    Movement::MoveSplineInit init(this);
+    init.ForceDone();
+
+    SendCurrencies();
+    SetMover(this);
+}
+
+void Player::SendInitialPacketsAfterAddToMap()
+{
+    UpdateVisibilityForPlayer();
+
+    // update zone
+    uint32 newzone, newarea;
+    GetZoneAndAreaId(newzone, newarea);
+    UpdateZone(newzone, newarea);                            // also call SendInitWorldStates();
+
+    ResetTimeSync();
+    SendTimeSync();
+
+    GetSession()->SendLoadCUFProfiles();
+
+    CastSpell(this, 836, true);                             // LOGINEFFECT
+
+    // set some aura effects that send packet to player client after add player to map
+    // SendMessageToSet not send it to player not it map, only for aura that not changed anything at re-apply
+    // same auras state lost at far teleport, send it one more time in this case also
+    static const AuraType auratypes[] =
+    {
+        SPELL_AURA_MOD_FEAR,     SPELL_AURA_TRANSFORM,                 SPELL_AURA_WATER_WALK,
+        SPELL_AURA_FEATHER_FALL, SPELL_AURA_HOVER,                     SPELL_AURA_SAFE_FALL,
+        SPELL_AURA_FLY,          SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED, SPELL_AURA_NONE
+    };
+    for (AuraType const* itr = &auratypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
+    {
+        Unit::AuraEffectList const& auraList = GetAuraEffectsByType(*itr);
+        if (!auraList.empty())
+            auraList.front()->HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true);
+    }
+
+    if (HasAuraType(SPELL_AURA_MOUNTED))
+    {
+        Unit::AuraEffectList const& auraList = GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        if (!auraList.empty())
+        {
+            AuraEffect *mountEffect = auraList.front();
+            if (MountCapabilityEntry const* mountCapability = mountEffect->GetBase()->GetUnitOwner()->GetMountCapability(uint32(mountEffect->GetMiscValueB())))
+            {
+                if (mountCapability->Id != mountEffect->GetAmount())
+                {
+                    Unit *target = mountEffect->GetBase()->GetApplicationOfTarget(GetGUID())->GetTarget();
+                    if (MountCapabilityEntry const* oldMountCapability = sMountCapabilityStore.LookupEntry(mountEffect->GetAmount()))
+                        RemoveAurasDueToSpell(oldMountCapability->SpeedModSpell, target->GetGUID());
+
+                    CastSpell(target, mountCapability->SpeedModSpell, true);
+                    mountEffect->SetAmount(mountCapability->Id);
+                }
+            }
+        }
+    }
+
+    if (HasAuraType(SPELL_AURA_MOD_STUN))
+        SetRooted(true);
+
+    // manual send package (have code in HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true); that must not be re-applied.
+    if (HasAuraType(SPELL_AURA_MOD_ROOT))
+        SendMoveRoot();
+
+    SendAurasForTarget(this);
+    SendEnchantmentDurations();                             // must be after add to map
+    SendItemDurations();                                    // must be after add to map
+    if (getClass() == CLASS_DEATH_KNIGHT)
+    {
+        for (uint8 i = 0; i < MAX_RUNES; i++)
+        {
+            WorldPacket data(SMSG_CONVERT_RUNE, 2);
+            data << uint8(i);
+            data << uint8(GetCurrentRune(i));
+            GetSession()->SendPacket(&data);
+        }
+    }
+
+    UpdateSpeed(MOVE_WALK, true);
+    UpdateSpeed(MOVE_RUN, true);
+    UpdateSpeed(MOVE_RUN_BACK, true);
+    UpdateSpeed(MOVE_SWIM, true);
+    UpdateSpeed(MOVE_SWIM_BACK, true);
+    UpdateSpeed(MOVE_FLIGHT, true);
+    UpdateSpeed(MOVE_FLIGHT_BACK, true);
+
+    // raid downscaling - send difficulty to player
+    if (GetMap()->IsRaid())
+    {
+        if (GetMap()->GetDifficulty() != GetRaidDifficulty())
+        {
+            StoreRaidMapDifficulty();
+            SendRaidDifficulty(GetGroup() != NULL, GetStoredRaidDifficulty());
+        }
+    }
+    else if (GetRaidDifficulty() != GetStoredRaidDifficulty())
+        SendRaidDifficulty(GetGroup() != NULL);
+}
+
+void Player::SendUpdateToOutOfRangeGroupMembers()
+{
+    if (m_groupUpdateMask == GROUP_UPDATE_FLAG_NONE)
+        return;
+    if (Group* group = GetGroup())
+        group->UpdatePlayerOutOfRange(this);
+
+    m_groupUpdateMask = GROUP_UPDATE_FLAG_NONE;
+    m_auraRaidUpdateMask = 0;
+    if (Pet* pet = GetPet())
+        pet->ResetAuraUpdateMaskForRaid();
+}
+
+void Player::SendTransferAborted(uint32 mapid, TransferAbortReason reason, uint8 arg)
+{
+    WorldPacket data(SMSG_TRANSFER_ABORTED, 4+2);
+    data << uint32(mapid);
+    data << uint8(reason); // transfer abort reason
+    data << uint8(arg);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SendInstanceResetWarning(uint32 mapid, Difficulty difficulty, uint32 time)
+{
+    // type of warning, based on the time remaining until reset
+    uint32 type;
+    if (time > 3600)
+        type = RAID_INSTANCE_WELCOME;
+    else if (time > 900 && time <= 3600)
+        type = RAID_INSTANCE_WARNING_HOURS;
+    else if (time > 300 && time <= 900)
+        type = RAID_INSTANCE_WARNING_MIN;
+    else
+        type = RAID_INSTANCE_WARNING_MIN_SOON;
+
+    WorldPacket data(SMSG_RAID_INSTANCE_MESSAGE, 4+4+4+4);
+    data << uint32(type);
+    data << uint32(mapid);
+    data << uint32(difficulty);                             // difficulty
+    data << uint32(time);
+    if (type == RAID_INSTANCE_WELCOME)
+    {
+        data << uint8(0);                                   // is locked
+        data << uint8(0);                                   // is extended, ignored if prev field is 0
+    }
+    GetSession()->SendPacket(&data);
+}
+
+void Player::ApplyEquipCooldown(Item* pItem)
+{
+	if (pItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_PROTO_FLAG_NO_EQUIP_COOLDOWN))
+		return;
+
+	for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+	{
+		_Spell const& spellData = pItem->GetTemplate()->Spells[i];
+
+		// no spell
+		if (!spellData.SpellId)
+			continue;
+
+		// wrong triggering type (note: ITEM_SPELLTRIGGER_ON_NO_DELAY_USE not have cooldown)
+		if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
+			continue;
+
+		// Don't replace longer cooldowns by equip cooldown if we have any.
+		SpellCooldowns::iterator itr = m_spellCooldowns.find(spellData.SpellId);
+		if (itr != m_spellCooldowns.end() && itr->second.itemid == pItem->GetEntry() && itr->second.end > time(NULL) + 30)
+			continue;
+
+		AddSpellCooldown(spellData.SpellId, pItem->GetEntry(), time(NULL) + 30);
+
+		WorldPacket data(SMSG_ITEM_COOLDOWN, 12);
+		data << pItem->GetGUID();
+		data << uint32(spellData.SpellId);
+		GetSession()->SendPacket(&data);
+	}
+}
+
+
+void Player::resetSpells(bool myClassOnly)
+{
+    // not need after this call
+    if (HasAtLoginFlag(AT_LOGIN_RESET_SPELLS))
+    {
+        myClassOnly = true;
+        RemoveAtLoginFlag(AT_LOGIN_RESET_SPELLS, true);
+    }
+
+    // make full copy of map (spells removed and marked as deleted at another spell remove
+    // and we can't use original map for safe iterative with visit each spell at loop end
+    PlayerSpellMap smap = GetSpellMap();
+
+    uint32 family;
+
+    if (myClassOnly)
+    {
+        ChrClassesEntry const* clsEntry = sChrClassesStore.LookupEntry(getClass());
+        if (!clsEntry)
+            return;
+        family = clsEntry->spellfamily;
+
+        for (PlayerSpellMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+        {
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(iter->first);
+            if (!spellInfo)
+                continue;
+
+            // skip server-side/triggered spells
+            if (spellInfo->SpellLevel == 0)
+                continue;
+
+            // skip wrong class/race skills
+            if (!IsSpellFitByClassAndRace(spellInfo->Id))
+                continue;
+
+            // skip other spell families
+            if (spellInfo->SpellFamilyName != family)
+                continue;
+
+            // skip spells with first rank learned as talent (and all talents then also)
+            uint32 first_rank = sSpellMgr->GetFirstSpellInChain(spellInfo->Id);
+            if (GetTalentSpellCost(first_rank) > 0)
+                continue;
+
+            // skip broken spells
+            if (!SpellMgr::IsSpellValid(spellInfo, this, false))
+                continue;
+        }
+    }
+    else
+        for (PlayerSpellMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+            removeSpell(iter->first, false, false);           // only iter->first can be accessed, object by iter->second can be deleted already
+
+    learnDefaultSpells();
+    learnQuestRewardedSpells();
+}
+
+void Player::learnDefaultSpells()
+{
+    // learn default race/class spells
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+    for (PlayerCreateInfoSpells::const_iterator itr = info->spell.begin(); itr != info->spell.end(); ++itr)
+    {
+        uint32 tspell = *itr;
+        sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "PLAYER (Class: %u Race: %u): Adding initial spell, id = %u", uint32(getClass()), uint32(getRace()), tspell);
+        if (!IsInWorld())                                    // will send in INITIAL_SPELLS in list anyway at map add
+            addSpell(tspell, true, true, true, false);
+        else                                                // but send in normal spell in game learn case
+            learnSpell(tspell, true);
+    }
+}
+
+void Player::learnQuestRewardedSpells(Quest const* quest)
+{
+    int32 spell_id = quest->GetRewSpellCast();
+    uint32 src_spell_id = quest->GetSrcSpell();
+
+    // skip quests without rewarded spell
+    if (!spell_id)
+        return;
+
+    // if RewSpellCast = -1 we remove aura do to SrcSpell from player.
+    if (spell_id == -1 && src_spell_id)
+    {
+        RemoveAurasDueToSpell(src_spell_id);
+        return;
+    }
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
+    if (!spellInfo)
+        return;
+
+    // check learned spells state
+    bool found = false;
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellInfo->Effects[i].Effect == SPELL_EFFECT_LEARN_SPELL && !HasSpell(spellInfo->Effects[i].TriggerSpell))
+        {
+            found = true;
+            break;
+        }
+    }
+
+    // skip quests with not teaching spell or already known spell
+    if (!found)
+        return;
+
+    // prevent learn non first rank unknown profession and second specialization for same profession)
+    uint32 learned_0 = spellInfo->Effects[0].TriggerSpell;
+    if (sSpellMgr->GetSpellRank(learned_0) > 1 && !HasSpell(learned_0))
+    {
+        // not have first rank learned (unlearned prof?)
+        uint32 first_spell = sSpellMgr->GetFirstSpellInChain(learned_0);
+        if (!HasSpell(first_spell))
+            return;
+
+        SpellInfo const* learnedInfo = sSpellMgr->GetSpellInfo(learned_0);
+        if (!learnedInfo)
+            return;
+
+        SpellsRequiringSpellMapBounds spellsRequired = sSpellMgr->GetSpellsRequiredForSpellBounds(learned_0);
+        for (SpellsRequiringSpellMap::const_iterator itr2 = spellsRequired.first; itr2 != spellsRequired.second; ++itr2)
+        {
+            uint32 profSpell = itr2->second;
+
+            // specialization
+            if (learnedInfo->Effects[0].Effect == SPELL_EFFECT_TRADE_SKILL && learnedInfo->Effects[1].Effect == 0 && profSpell)
+            {
+                // search other specialization for same prof
+                for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
+                {
+                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->first == learned_0)
+                        continue;
+
+                    SpellInfo const* itrInfo = sSpellMgr->GetSpellInfo(itr->first);
+                    if (!itrInfo)
+                        return;
+
+                    // compare only specializations
+                    if (itrInfo->Effects[0].Effect != SPELL_EFFECT_TRADE_SKILL || itrInfo->Effects[1].Effect != 0)
+                        continue;
+
+                    // compare same chain spells
+                    if (sSpellMgr->IsSpellRequiringSpell(itr->first, profSpell))
+                        return;
+                }
+            }
+        }
+    }
+
+    CastSpell(this, spell_id, true);
+}
+
+void Player::learnQuestRewardedSpells()
+{
+    // learn spells received from quest completing
+    for (RewardedQuestSet::const_iterator itr = m_RewardedQuests.begin(); itr != m_RewardedQuests.end(); ++itr)
+    {
+        Quest const* quest = sObjectMgr->GetQuestTemplate(*itr);
+        if (!quest)
+            continue;
+
+        learnQuestRewardedSpells(quest);
+    }
+}
+
+void Player::learnSkillRewardedSpells(uint32 skill_id, uint32 skill_value)
+{
+    uint32 raceMask  = getRaceMask();
+    uint32 classMask = getClassMask();
+    for (uint32 j=0; j<sSkillLineAbilityStore.GetNumRows(); ++j)
+    {
+        SkillLineAbilityEntry const* pAbility = sSkillLineAbilityStore.LookupEntry(j);
+        if (!pAbility || pAbility->skillId != skill_id || pAbility->learnOnGetSkill != ABILITY_LEARNED_ON_GET_PROFESSION_SKILL)
+            continue;
+        // Check race if set
+        if (pAbility->racemask && !(pAbility->racemask & raceMask))
+            continue;
+        // Check class if set
+        if (pAbility->classmask && !(pAbility->classmask & classMask))
+            continue;
+
+        if (sSpellMgr->GetSpellInfo(pAbility->spellId))
+        {
+            // need unlearn spell
+            if (skill_value < pAbility->req_skill_value)
+                removeSpell(pAbility->spellId);
+            // need learn
+            else if (!IsInWorld())
+                addSpell(pAbility->spellId, true, true, true, false);
+            else
+                learnSpell(pAbility->spellId, true);
+        }
+    }
+}
+
+void Player::SendAurasForTarget(Unit* target)
+{
+    if (!target || target->GetVisibleAuras()->empty())                  // speedup things
+        return;
+
+    /*! Blizz sends certain movement packets sometimes even before CreateObject
+        These movement packets are usually found in SMSG_COMPRESSED_MOVES
+    */
+    if (target->HasAuraType(SPELL_AURA_FEATHER_FALL))
+        target->SendMovementFeatherFall();
+
+    if (target->HasAuraType(SPELL_AURA_WATER_WALK))
+        target->SendMovementWaterWalking();
+
+    if (target->HasAuraType(SPELL_AURA_HOVER))
+        target->SendMovementHover();
+
+    WorldPacket data(SMSG_AURA_UPDATE_ALL);
+    data.append(target->GetPackGUID());
+
+    Unit::VisibleAuraMap const* visibleAuras = target->GetVisibleAuras();
+    for (Unit::VisibleAuraMap::const_iterator itr = visibleAuras->begin(); itr != visibleAuras->end(); ++itr)
+    {
+        AuraApplication * auraApp = itr->second;
+        auraApp->BuildUpdatePacket(data, false);
+    }
+
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SetDailyQuestStatus(uint32 quest_id)
+{
+    if (Quest const* qQuest = sObjectMgr->GetQuestTemplate(quest_id))
+    {
+        if (!qQuest->IsDFQuest())
+        {
+            for (uint32 quest_daily_idx = 0; quest_daily_idx < PLAYER_MAX_DAILY_QUESTS; ++quest_daily_idx)
+            {
+                if (!GetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx))
+                {
+                    SetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx, quest_id);
+                    m_lastDailyQuestTime = time(NULL);              // last daily quest time
+                    m_DailyQuestChanged = true;
+                    break;
+                }
+            }
+        } else
+        {
+            m_DFQuests.insert(quest_id);
+            m_lastDailyQuestTime = time(NULL);
+            m_DailyQuestChanged = true;
+        }
+    }
+}
+
+void Player::SetWeeklyQuestStatus(uint32 quest_id)
+{
+    m_weeklyquests.insert(quest_id);
+    m_WeeklyQuestChanged = true;
+}
+
+void Player::SetSeasonalQuestStatus(uint32 quest_id)
+{
+    Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
+    if (!quest)
+        return;
+
+    m_seasonalquests[sGameEventMgr->GetEventIdForQuest(quest)].insert(quest_id);
+    m_SeasonalQuestChanged = true;
+}
+
+void Player::SetMonthlyQuestStatus(uint32 quest_id)
+{
+    m_monthlyquests.insert(quest_id);
+    m_MonthlyQuestChanged = true;
+}
+
+void Player::ResetDailyQuestStatus()
+{
+    for (uint32 quest_daily_idx = 0; quest_daily_idx < PLAYER_MAX_DAILY_QUESTS; ++quest_daily_idx)
+        SetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx, 0);
+
+    m_DFQuests.clear(); // Dungeon Finder Quests.
+
+    // DB data deleted in caller
+    m_DailyQuestChanged = false;
+    m_lastDailyQuestTime = 0;
+}
+
+void Player::ResetWeeklyQuestStatus()
+{
+    if (m_weeklyquests.empty())
+        return;
+
+    m_weeklyquests.clear();
+    // DB data deleted in caller
+    m_WeeklyQuestChanged = false;
+
+}
+
+void Player::ResetSeasonalQuestStatus(uint16 event_id)
+{
+    if (m_seasonalquests.empty() || m_seasonalquests[event_id].empty())
+        return;
+
+    m_seasonalquests.erase(event_id);
+    // DB data deleted in caller
+    m_SeasonalQuestChanged = false;
+}
+
+void Player::ResetMonthlyQuestStatus()
+{
+    if (m_monthlyquests.empty())
+        return;
+
+    m_monthlyquests.clear();
+    // DB data deleted in caller
+    m_MonthlyQuestChanged = false;
+}
+
+void Player::UpdateMaxWeekRating(ConquestPointsSources source, uint8 slot)
+{
+	m_maxWeekRating[source] = std::max(m_maxWeekRating[source], (uint16)GetArenaPersonalRating(slot));
+}
+
+Battleground* Player::GetBattleground() const
+{
+    if (GetBattlegroundId() == 0)
+        return NULL;
+
+    return sBattlegroundMgr->GetBattleground(GetBattlegroundId(), m_bgData.bgTypeID);
+}
+
+bool Player::InArena() const
+{
+    Battleground* bg = GetBattleground();
+    if (!bg || !bg->isArena())
+        return false;
+
+    return true;
+}
+
+bool Player::GetBGAccessByLevel(BattlegroundTypeId bgTypeId) const
+{
+    // get a template bg instead of running one
+    Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(bgTypeId);
+    if (!bg)
+        return false;
+
+    // limit check leel to dbc compatible level range
+    uint32 level = getLevel();
+    if (level > DEFAULT_MAX_LEVEL)
+        level = DEFAULT_MAX_LEVEL;
+
+    if (level < bg->GetMinLevel() || level > bg->GetMaxLevel())
+        return false;
+
+    return true;
+}
+
+float Player::GetReputationPriceDiscount(Creature const* creature) const
+{
+    FactionTemplateEntry const* vendor_faction = creature->getFactionTemplateEntry();
+    if (!vendor_faction || !vendor_faction->faction)
+        return 1.0f;
+
+    ReputationRank rank = GetReputationRank(vendor_faction->faction);
+    if (rank <= REP_NEUTRAL)
+        return 1.0f;
+
+    return 1.0f - 0.05f* (rank - REP_NEUTRAL);
+}
+
+bool Player::IsSpellFitByClassAndRace(uint32 spell_id) const
+{
+    uint32 racemask  = getRaceMask();
+    uint32 classmask = getClassMask();
+
+    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spell_id);
+    if (bounds.first == bounds.second)
+        return true;
+
+    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
+    {
+        // skip wrong race skills
+        if (_spell_idx->second->racemask && (_spell_idx->second->racemask & racemask) == 0)
+            continue;
+
+        // skip wrong class skills
+        if (_spell_idx->second->classmask && (_spell_idx->second->classmask & classmask) == 0)
+            continue;
+
+        return true;
+    }
+
+    return false;
+}
+
+bool Player::HasQuestForGO(int32 GOId) const
+{
+    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
+    {
+        uint32 questid = GetQuestSlotQuestId(i);
+        if (questid == 0)
+            continue;
+
+        QuestStatusMap::const_iterator qs_itr = m_QuestStatus.find(questid);
+        if (qs_itr == m_QuestStatus.end())
+            continue;
+
+        QuestStatusData const& qs = qs_itr->second;
+
+        if (qs.Status == QUEST_STATUS_INCOMPLETE)
+        {
+            Quest const* qinfo = sObjectMgr->GetQuestTemplate(questid);
+            if (!qinfo)
+                continue;
+
+            if (GetGroup() && GetGroup()->isRaidGroup() && !qinfo->IsAllowedInRaid(GetMap()->GetDifficulty()))
+                continue;
+
+            for (uint8 j = 0; j < QUEST_OBJECTIVES_COUNT; ++j)
+            {
+                if (qinfo->RequiredNpcOrGo[j] >= 0)       //skip non GO case
+                    continue;
+
+                if ((-1)*GOId == qinfo->RequiredNpcOrGo[j] && qs.CreatureOrGOCount[j] < qinfo->RequiredNpcOrGoCount[j])
+                    return true;
+            }
+        }
+    }
+    return false;
+}
+
+void Player::UpdateForQuestWorldObjects()
+{
+    if (m_clientGUIDs.empty())
+        return;
+
+    UpdateData udata(GetMapId());
+    WorldPacket packet;
+    for (ClientGUIDs::iterator itr=m_clientGUIDs.begin(); itr != m_clientGUIDs.end(); ++itr)
+    {
+        if (IS_GAMEOBJECT_GUID(*itr))
+        {
+            if (GameObject* obj = HashMapHolder<GameObject>::Find(*itr))
+                obj->BuildValuesUpdateBlockForPlayer(&udata, this);
+        }
+        else if (IS_CRE_OR_VEH_GUID(*itr))
+        {
+            Creature* obj = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, *itr);
+            if (!obj)
+                continue;
+
+            // check if this unit requires quest specific flags
+            if (!obj->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK))
+                continue;
+
+            SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(obj->GetEntry());
+            for (SpellClickInfoContainer::const_iterator _itr = clickPair.first; _itr != clickPair.second; ++_itr)
+            {
+                //! This code doesn't look right, but it was logically converted to condition system to do the exact
+                //! same thing it did before. It definitely needs to be overlooked for intended functionality.
+                ConditionList conds = sConditionMgr->GetConditionsForSpellClickEvent(obj->GetEntry(), _itr->second.spellId);
+                bool buildUpdateBlock = false;
+                for (ConditionList::const_iterator jtr = conds.begin(); jtr != conds.end() && !buildUpdateBlock; ++jtr)
+                    if ((*jtr)->ConditionType == CONDITION_QUESTREWARDED || (*jtr)->ConditionType == CONDITION_QUESTTAKEN)
+                        buildUpdateBlock = true;
+
+                if (buildUpdateBlock)
+                {
+                    obj->BuildCreateUpdateBlockForPlayer(&udata, this);
+                    break;
+                }
+            }
+        }
+    }
+    udata.BuildPacket(&packet);
+    GetSession()->SendPacket(&packet);
+}
+
+void Player::SummonIfPossible(bool agree)
+{
+    if (!agree)
+    {
+        m_summon_expire = 0;
+        return;
+    }
+
+    // expire and auto declined
+    if (m_summon_expire < time(NULL))
+        return;
+
+    // stop taxi flight at summon
+    if (isInFlight())
+    {
+        GetMotionMaster()->MovementExpired();
+        CleanupAfterTaxiFlight();
+    }
+
+    // drop flag at summon
+    // this code can be reached only when GM is summoning player who carries flag, because player should be immune to summoning spells when he carries flag
+    if (Battleground* bg = GetBattleground())
+        bg->EventPlayerDroppedFlag(this);
+
+    m_summon_expire = 0;
+
+    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ACCEPTED_SUMMONINGS, 1);
+
+    TeleportTo(m_summon_mapid, m_summon_x, m_summon_y, m_summon_z, GetOrientation());
+}
+
+void Player::RemoveItemDurations(Item* item)
+{
+    for (ItemDurationList::iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end(); ++itr)
+    {
+        if (*itr == item)
+        {
+            m_itemDuration.erase(itr);
+            break;
+        }
+    }
+}
+
+void Player::AddItemDurations(Item* item)
+{
+    if (item->GetUInt32Value(ITEM_FIELD_DURATION))
+    {
+        m_itemDuration.push_back(item);
+        item->SendTimeUpdate(this);
+    }
+}
+
+void Player::AutoUnequipOffhandIfNeed(bool force /*= false*/)
+{
+    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+    if (!offItem)
+        return;
+
+     // unequip offhand weapon if player doesn't have dual wield anymore
+     if (!CanDualWield() && (offItem->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND || offItem->GetTemplate()->InventoryType == INVTYPE_WEAPON))
+          force = true;
+
+    // need unequip offhand for 2h-weapon without TitanGrip (in any from hands)
+    if (!force && (CanTitanGrip() || (offItem->GetTemplate()->InventoryType != INVTYPE_2HWEAPON && !IsTwoHandUsed())))
+        return;
+
+    ItemPosCountVec off_dest;
+    uint8 off_msg = CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false);
+    if (off_msg == EQUIP_ERR_OK)
+    {
+        RemoveItem(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND, true);
+        StoreItem(off_dest, offItem, true);
+    }
+    else
+    {
+        MoveItemFromInventory(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND, true);
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        offItem->DeleteFromInventoryDB(trans);                   // deletes item from character's inventory
+        offItem->SaveToDB(trans);                                // recursive and not have transaction guard into self, item not in inventory and can be save standalone
+
+        std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);
+        MailDraft(subject, "There were problems with equipping one or several items").AddItem(offItem).SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
+
+        CharacterDatabase.CommitTransaction(trans);
+    }
+}
+
+OutdoorPvP* Player::GetOutdoorPvP() const
+{
+    return sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId());
+}
+
+bool Player::HasItemFitToSpellRequirements(SpellInfo const* spellInfo, Item const* ignoreItem)
+{
+    if (spellInfo->EquippedItemClass < 0)
+        return true;
+
+    // scan other equipped items for same requirements (mostly 2 daggers/etc)
+    // for optimize check 2 used cases only
+    switch (spellInfo->EquippedItemClass)
+    {
+        case ITEM_CLASS_WEAPON:
+        {
+            for (uint8 i= EQUIPMENT_SLOT_MAINHAND; i < EQUIPMENT_SLOT_TABARD; ++i)
+                if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
+                    if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
+                        return true;
+            break;
+        }
+        case ITEM_CLASS_ARMOR:
+        {
+            // tabard not have dependent spells
+            for (uint8 i= EQUIPMENT_SLOT_START; i< EQUIPMENT_SLOT_MAINHAND; ++i)
+                if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
+                    if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
+                        return true;
+
+            // shields can be equipped to offhand slot
+            if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
+                if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
+                    return true;
+
+            // ranged slot can have some armor subclasses
+            if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED))
+                if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
+                    return true;
+
+            break;
+        }
+        default:
+            sLog->outError(LOG_FILTER_PLAYER, "HasItemFitToSpellRequirements: Not handled spell requirement for item class %u", spellInfo->EquippedItemClass);
+            break;
+    }
+
+    return false;
+}
+
+bool Player::HasAllItemsToFitToSpellRequirements(SpellInfo const* spellInfo)
+{
+    uint8 count = 0;
+
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot <= EQUIPMENT_SLOT_HANDS; ++slot)
+        if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, slot))
+            if (item->IsFitToSpellRequirements(spellInfo))
+                ++count;
+
+    if (count >= 8)
+        return true;
+
+    return false;
+}
+
+bool Player::CanNoReagentCast(SpellInfo const* spellInfo) const
+{
+    // don't take reagents for spells with SPELL_ATTR5_NO_REAGENT_WHILE_PREP
+    if (spellInfo->AttributesEx5 & SPELL_ATTR5_NO_REAGENT_WHILE_PREP &&
+        HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PREPARATION))
+        return true;
+
+    // Check no reagent use mask
+    flag96 noReagentMask;
+    noReagentMask[0] = GetUInt32Value(PLAYER_NO_REAGENT_COST_1);
+    noReagentMask[1] = GetUInt32Value(PLAYER_NO_REAGENT_COST_1+1);
+    noReagentMask[2] = GetUInt32Value(PLAYER_NO_REAGENT_COST_1+2);
+    if (spellInfo->SpellFamilyFlags  & noReagentMask)
+        return true;
+
+    return false;
+}
+
+void Player::RemoveItemDependentAurasAndCasts(Item* pItem)
+{
+    for (AuraMap::iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end();)
+    {
+        Aura* aura = itr->second;
+
+        // skip passive (passive item dependent spells work in another way) and not self applied auras
+        SpellInfo const* spellInfo = aura->GetSpellInfo();
+        if (aura->IsPassive() ||  aura->GetCasterGUID() != GetGUID() || aura->GetId() == 46924)
+        {
+            ++itr;
+            continue;
+        }
+
+        // skip if not item dependent or have alternative item
+        if (HasItemFitToSpellRequirements(spellInfo, pItem))
+        {
+            ++itr;
+            continue;
+        }
+
+        // no alt item, remove aura, restart check
+        RemoveOwnedAura(itr);
+    }
+
+    // currently casted spells can be dependent from item
+    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
+        if (Spell* spell = GetCurrentSpell(CurrentSpellTypes(i)))
+            if (spell->getState() != SPELL_STATE_DELAYED && !HasItemFitToSpellRequirements(spell->m_spellInfo, pItem))
+                InterruptSpell(CurrentSpellTypes(i));
+}
+
+uint32 Player::GetResurrectionSpellId()
+{
+    // search priceless resurrection possibilities
+    uint32 prio = 0;
+    uint32 spell_id = 0;
+    AuraEffectList const& dummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+    for (AuraEffectList::const_iterator itr = dummyAuras.begin(); itr != dummyAuras.end(); ++itr)
+    {
+        // Soulstone Resurrection                           // prio: 3 (max, non death persistent)
+        if (prio < 2 && (*itr)->GetSpellInfo()->SpellVisual[0] == 99 && (*itr)->GetSpellInfo()->SpellIconID == 92)
+        {
+            switch ((*itr)->GetId())
+            {
+                case 20707: spell_id =  3026; break;        // rank 1
+                case 20762: spell_id = 20758; break;        // rank 2
+                case 20763: spell_id = 20759; break;        // rank 3
+                case 20764: spell_id = 20760; break;        // rank 4
+                case 20765: spell_id = 20761; break;        // rank 5
+                case 27239: spell_id = 27240; break;        // rank 6
+                case 47883: spell_id = 47882; break;        // rank 7
+                default:
+                    sLog->outError(LOG_FILTER_PLAYER, "Unhandled spell %u: S.Resurrection", (*itr)->GetId());
+                    continue;
+            }
+
+            prio = 3;
+        }
+        // Twisting Nether                                  // prio: 2 (max)
+        else if ((*itr)->GetId() == 23701 && roll_chance_i(10))
+        {
+            prio = 2;
+            spell_id = 23700;
+        }
+    }
+
+    // Reincarnation (passive spell)  // prio: 1                  // Glyph of Renewed Life
+    if (prio < 1 && HasSpell(20608) && !HasSpellCooldown(21169) && (HasAura(58059) || HasItemCount(17030)))
+        spell_id = 21169;
+
+    return spell_id;
+}
+
+// Used in triggers for check "Only to targets that grant experience or honor" req
+bool Player::isHonorOrXPTarget(Unit const* victim)
+{
+    uint8 v_level = victim->getLevel();
+    uint8 k_grey  = Trinity::XP::GetGrayLevel(getLevel());
+
+    // Victim level less gray level
+    if (v_level <= k_grey)
+        return false;
+
+    if (Creature const* const creature = victim->ToCreature())
+    {
+        if ((creature->isTotem() ||
+            creature->isPet() ||
+            creature->isSummon() ||
+            creature->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_XP_AT_KILL)
+            && !creature->isHunterPet())
+                return false;
+    }
+    return true;
+}
+
+bool Player::GetsRecruitAFriendBonus(bool forXP)
+{
+    bool recruitAFriend = false;
+    if (getLevel() <= sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL) || !forXP)
+    {
+        if (Group* group = this->GetGroup())
+        {
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* player = itr->getSource();
+                if (!player)
+                    continue;
+
+                if (!player->IsAtRecruitAFriendDistance(this))
+                    continue;                               // member (alive or dead) or his corpse at req. distance
+
+                if (forXP)
+                {
+                    // level must be allowed to get RaF bonus
+                    if (player->getLevel() > sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL))
+                        continue;
+
+                    // level difference must be small enough to get RaF bonus, UNLESS we are lower level
+                    if (player->getLevel() < getLevel())
+                        if (uint8(getLevel() - player->getLevel()) > sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL_DIFFERENCE))
+                            continue;
+                }
+
+                bool ARecruitedB = (player->GetSession()->GetRecruiterId() == GetSession()->GetAccountId());
+                bool BRecruitedA = (GetSession()->GetRecruiterId() == player->GetSession()->GetAccountId());
+                if (ARecruitedB || BRecruitedA)
+                {
+                    recruitAFriend = true;
+                    break;
+                }
+            }
+        }
+    }
+    return recruitAFriend;
+}
+
+void Player::RewardPlayerAndGroupAtKill(Unit* victim, bool isBattleGround)
+{
+    KillRewarder(this, victim, isBattleGround).Reward();
+}
+
+void Player::RewardPlayerAndGroupAtEvent(uint32 creature_id, WorldObject* pRewardSource)
+{
+    if (!pRewardSource)
+        return;
+    uint64 creature_guid = (pRewardSource->GetTypeId() == TYPEID_UNIT) ? pRewardSource->GetGUID() : uint64(0);
+
+    // prepare data for near group iteration
+    if (Group* group = GetGroup())
+    {
+        for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* player = itr->getSource();
+            if (!player)
+                continue;
+
+            if (!player->IsAtGroupRewardDistance(pRewardSource))
+                continue;                               // member (alive or dead) or his corpse at req. distance
+
+            // quest objectives updated only for alive group member or dead but with not released body
+            if (player->isAlive()|| !player->GetCorpse())
+                player->KilledMonsterCredit(creature_id, creature_guid);
+        }
+    }
+    else                                                    // if (!group)
+        KilledMonsterCredit(creature_id, creature_guid);
+}
+
+bool Player::IsAtGroupRewardDistance(WorldObject const* pRewardSource) const
+{
+    if (!pRewardSource)
+        return false;
+    const WorldObject* player = GetCorpse();
+    if (!player || isAlive())
+        player = this;
+
+    if (player->GetMapId() != pRewardSource->GetMapId() || player->GetInstanceId() != pRewardSource->GetInstanceId())
+        return false;
+
+    return pRewardSource->GetDistance(player) <= sWorld->getFloatConfig(CONFIG_GROUP_XP_DISTANCE);
+}
+
+bool Player::IsAtRecruitAFriendDistance(WorldObject const* pOther) const
+{
+    if (!pOther)
+        return false;
+    const WorldObject* player = GetCorpse();
+    if (!player || isAlive())
+        player = this;
+
+    if (player->GetMapId() != pOther->GetMapId() || player->GetInstanceId() != pOther->GetInstanceId())
+        return false;
+
+    return pOther->GetDistance(player) <= sWorld->getFloatConfig(CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE);
+}
+
+void Player::ResurectUsingRequestData()
+{
+    /// Teleport before resurrecting by player, otherwise the player might get attacked from creatures near his corpse
+    float x, y, z, o;
+    _resurrectionData->Location.GetPosition(x, y, z, o);
+    TeleportTo(_resurrectionData->Location.GetMapId(), x, y, z, o);
+
+    if (IsBeingTeleported())
+    {
+        ScheduleDelayedOperation(DELAYED_RESURRECT_PLAYER);
+        return;
+    }
+
+    ResurrectPlayer(0.0f, false);
+
+    if (GetMaxHealth() > _resurrectionData->Health)
+        SetHealth(_resurrectionData->Health);
+    else
+        SetFullHealth();
+
+    if (uint32(GetMaxPower(POWER_MANA)) > _resurrectionData->Mana)
+        SetPower(POWER_MANA, _resurrectionData->Mana);
+    else
+        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+
+    SetPower(POWER_RAGE, 0);
+    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
+    SetPower(POWER_FOCUS, GetMaxPower(POWER_FOCUS));
+    SetPower(POWER_ECLIPSE, 0);
+
+    if (uint32 aura = _resurrectionData->Aura)
+        CastSpell(this, aura, true, NULL, NULL, _resurrectionData->GUID);
+
+    SpawnCorpseBones();
+}
+
+void Player::SetClientControl(Unit* target, uint8 allowMove)
+{
+    if (allowMove && target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_POSSESSED | UNIT_STATE_FLEEING))
+        return;
+
+    WorldPacket data(SMSG_CLIENT_CONTROL_UPDATE, target->GetPackGUID().size()+1);
+    data.append(target->GetPackGUID());
+    data << uint8(allowMove);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SetMover(Unit* target)
+{
+    m_mover->m_movedPlayer = NULL;
+    m_mover = target;
+    m_mover->m_movedPlayer = this;
+
+    ObjectGuid guid = target->GetGUID();
+
+    WorldPacket data(SMSG_MOVE_SET_ACTIVE_MOVER, 9);
+    data.WriteBit(guid[5]);
+    data.WriteBit(guid[7]);
+    data.WriteBit(guid[3]);
+    data.WriteBit(guid[6]);
+    data.WriteBit(guid[0]);
+    data.WriteBit(guid[4]);
+    data.WriteBit(guid[1]);
+    data.WriteBit(guid[2]);
+
+    data.WriteByteSeq(guid[6]);
+    data.WriteByteSeq(guid[2]);
+    data.WriteByteSeq(guid[3]);
+    data.WriteByteSeq(guid[0]);
+    data.WriteByteSeq(guid[5]);
+    data.WriteByteSeq(guid[7]);
+    data.WriteByteSeq(guid[1]);
+    data.WriteByteSeq(guid[4]);
+
+    SendDirectMessage(&data);
+}
+
+void Player::UpdateZoneDependentAuras(uint32 newZone)
+{
+    // Some spells applied at enter into zone (with subzones), aura removed in UpdateAreaDependentAuras that called always at zone->area update
+    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(newZone);
+    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
+        if (itr->second->autocast && itr->second->IsFitToRequirements(this, newZone, 0))
+            if (!HasAura(itr->second->spellId))
+                CastSpell(this, itr->second->spellId, true);
+}
+
+void Player::UpdateAreaDependentAuras(uint32 newArea)
+{
+    // remove auras from spells with area limitations
+    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
+    {
+        // use m_zoneUpdateId for speed: UpdateArea called from UpdateZone or instead UpdateZone in both cases m_zoneUpdateId up-to-date
+        if (iter->second->GetSpellInfo()->CheckLocation(GetMapId(), m_zoneUpdateId, newArea, this) != SPELL_CAST_OK)
+            RemoveOwnedAura(iter);
+        else
+            ++iter;
+    }
+
+    // some auras applied at subzone enter
+    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(newArea);
+    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
+        if (itr->second->autocast && itr->second->IsFitToRequirements(this, m_zoneUpdateId, newArea))
+            if (!HasAura(itr->second->spellId))
+                CastSpell(this, itr->second->spellId, true);
+
+    if (newArea == 4273 && GetVehicleCreatureBase() && GetPositionX() > 400) // Ulduar
+    {
+        switch (GetVehicleBase()->GetEntry())
+        {
+            case 33062:
+            case 33109:
+            case 33060:
+                GetVehicleCreatureBase()->DespawnOrUnsummon();
+                break;
+        }
+    }
+}
+
+uint32 Player::GetCorpseReclaimDelay(bool pvp) const
+{
+    if (pvp)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP))
+            return copseReclaimDelay[0];
+    }
+    else if (!sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE))
+        return 0;
+
+    time_t now = time(NULL);
+    // 0..2 full period
+    // should be ceil(x)-1 but not floor(x)
+    uint64 count = (now < m_deathExpireTime - 1) ? (m_deathExpireTime - 1 - now)/DEATH_EXPIRE_STEP : 0;
+    return copseReclaimDelay[count];
+}
+
+void Player::UpdateCorpseReclaimDelay()
+{
+    bool pvp = m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH;
+
+    if ((pvp && !sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
+        (!pvp && !sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
+        return;
+
+    time_t now = time(NULL);
+    if (now < m_deathExpireTime)
+    {
+        // full and partly periods 1..3
+        uint64 count = (m_deathExpireTime - now)/DEATH_EXPIRE_STEP +1;
+        if (count < MAX_DEATH_COUNT)
+            m_deathExpireTime = now+(count+1)*DEATH_EXPIRE_STEP;
+        else
+            m_deathExpireTime = now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP;
+    }
+    else
+        m_deathExpireTime = now+DEATH_EXPIRE_STEP;
+}
+
+void Player::SendCorpseReclaimDelay(bool load)
+{
+    Corpse* corpse = GetCorpse();
+    if (load && !corpse)
+        return;
+
+    bool pvp;
+    if (corpse)
+        pvp = (corpse->GetType() == CORPSE_RESURRECTABLE_PVP);
+    else
+        pvp = (m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH);
+
+    time_t delay;
+    if (load)
+    {
+        if (corpse->GetGhostTime() > m_deathExpireTime)
+            return;
+
+        uint64 count;
+        if ((pvp && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
+           (!pvp && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
+        {
+            count = (m_deathExpireTime-corpse->GetGhostTime())/DEATH_EXPIRE_STEP;
+            if (count >= MAX_DEATH_COUNT)
+                count = MAX_DEATH_COUNT-1;
+        }
+        else
+            count=0;
+
+        time_t expected_time = corpse->GetGhostTime()+copseReclaimDelay[count];
+
+        time_t now = time(NULL);
+        if (now >= expected_time)
+            return;
+
+        delay = expected_time-now;
+    }
+    else
+        delay = GetCorpseReclaimDelay(pvp);
+
+    if (!delay)
+        return;
+
+    //! corpse reclaim delay 30 * 1000ms or longer at often deaths
+    WorldPacket data(SMSG_CORPSE_RECLAIM_DELAY, 4);
+    data << uint32(delay*IN_MILLISECONDS);
+    GetSession()->SendPacket(&data);
+}
+
+Player* Player::GetNextRandomRaidMember(float radius)
+{
+    Group* group = GetGroup();
+    if (!group)
+        return NULL;
+
+    std::vector<Player*> nearMembers;
+    nearMembers.reserve(group->GetMembersCount());
+
+    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* Target = itr->getSource();
+
+        // IsHostileTo check duel and controlled by enemy
+        if (Target && Target != this && IsWithinDistInMap(Target, radius) &&
+            !Target->HasInvisibilityAura() && !IsHostileTo(Target))
+            nearMembers.push_back(Target);
+    }
+
+    if (nearMembers.empty())
+        return NULL;
+
+    uint32 randTarget = urand(0, nearMembers.size()-1);
+    return nearMembers[randTarget];
+}
+
+PartyResult Player::CanUninviteFromGroup() const
+{
+	Group const* grp = GetGroup();
+	if (!grp)
+		return ERR_NOT_IN_GROUP;
+
+	if (grp->isLFGGroup())
+	{
+		uint64 gguid = grp->GetGUID();
+		if (!sLFGMgr->GetKicksLeft(gguid))
+			return ERR_PARTY_LFG_BOOT_LIMIT;
+
+		lfg::LfgState state = sLFGMgr->GetState(gguid);
+		if (state == lfg::LFG_STATE_BOOT)
+			return ERR_PARTY_LFG_BOOT_IN_PROGRESS;
+
+		if (grp->GetMembersCount() <= lfg::LFG_GROUP_KICK_VOTES_NEEDED)
+			return ERR_PARTY_LFG_BOOT_TOO_FEW_PLAYERS;
+
+		if (state == lfg::LFG_STATE_FINISHED_DUNGEON)
+			return ERR_PARTY_LFG_BOOT_DUNGEON_COMPLETE;
+
+		if (grp->isRollLootActive())
+			return ERR_PARTY_LFG_BOOT_LOOT_ROLLS;
+
+		/// @todo Should also be sent when anyone has recently left combat, with an aprox ~5 seconds timer.
+		for (GroupReference const* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+		if (itr->getSource() && itr->getSource()->isInCombat())
+			return ERR_PARTY_LFG_BOOT_IN_COMBAT;
+
+		/* Missing support for these types
+		return ERR_PARTY_LFG_BOOT_COOLDOWN_S;
+		return ERR_PARTY_LFG_BOOT_NOT_ELIGIBLE_S;
+		*/
+	}
+	else
+	{
+		if (!grp->IsLeader(GetGUID()) && !grp->IsAssistant(GetGUID()))
+			return ERR_NOT_LEADER;
+
+		if (InBattleground())
+			return ERR_INVITE_RESTRICTED;
+	}
+
+	return ERR_PARTY_RESULT_OK;
+}
+
+bool Player::isUsingLfg()
+{
+	return sLFGMgr->GetState(GetGUID()) != lfg::LFG_STATE_NONE;
+}
+
+void Player::SetBattlegroundOrBattlefieldRaid(Group* group, int8 subgroup)
+{
+    //we must move references from m_group to m_originalGroup
+    SetOriginalGroup(GetGroup(), GetSubGroup());
+
+    m_group.unlink();
+    m_group.link(group, this);
+    m_group.setSubGroup((uint8)subgroup);
+}
+
+void Player::RemoveFromBattlegroundOrBattlefieldRaid()
+{
+    //remove existing reference
+    m_group.unlink();
+    if (Group* group = GetOriginalGroup())
+    {
+        m_group.link(group, this);
+        m_group.setSubGroup(GetOriginalSubGroup());
+    }
+    SetOriginalGroup(NULL);
+}
+
+void Player::SetOriginalGroup(Group* group, int8 subgroup)
+{
+    if (group == NULL)
+        m_originalGroup.unlink();
+    else
+    {
+        // never use SetOriginalGroup without a subgroup unless you specify NULL for group
+        ASSERT(subgroup >= 0);
+        m_originalGroup.link(group, this);
+        m_originalGroup.setSubGroup((uint8)subgroup);
+    }
+}
+
+void Player::UpdateUnderwaterState(Map* m, float x, float y, float z)
+{
+    LiquidData liquid_status;
+    ZLiquidStatus res = m->getLiquidStatus(x, y, z, MAP_ALL_LIQUIDS, &liquid_status);
+    if (!res)
+    {
+        m_MirrorTimerFlags &= ~(UNDERWATER_INWATER | UNDERWATER_INLAVA | UNDERWATER_INSLIME | UNDERWARER_INDARKWATER);
+        if (_lastLiquid && _lastLiquid->SpellId)
+            RemoveAurasDueToSpell(_lastLiquid->SpellId);
+
+        _lastLiquid = NULL;
+        return;
+    }
+
+    if (uint32 liqEntry = liquid_status.entry)
+    {
+        LiquidTypeEntry const* liquid = sLiquidTypeStore.LookupEntry(liqEntry);
+        if (_lastLiquid && _lastLiquid->SpellId && _lastLiquid->Id != liqEntry)
+            RemoveAurasDueToSpell(_lastLiquid->SpellId);
+
+        if (liquid && liquid->SpellId)
+        {
+            if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER))
+            {
+                if (!HasAura(liquid->SpellId))
+                    CastSpell(this, liquid->SpellId, true);
+            }
+            else
+                RemoveAurasDueToSpell(liquid->SpellId);
+        }
+
+        _lastLiquid = liquid;
+    }
+    else if (_lastLiquid && _lastLiquid->SpellId)
+    {
+        RemoveAurasDueToSpell(_lastLiquid->SpellId);
+        _lastLiquid = NULL;
+    }
+
+
+    // All liquids type - check under water position
+    if (liquid_status.type_flags & (MAP_LIQUID_TYPE_WATER | MAP_LIQUID_TYPE_OCEAN | MAP_LIQUID_TYPE_MAGMA | MAP_LIQUID_TYPE_SLIME))
+    {
+        if (res & LIQUID_MAP_UNDER_WATER)
+            m_MirrorTimerFlags |= UNDERWATER_INWATER;
+        else
+            m_MirrorTimerFlags &= ~UNDERWATER_INWATER;
+    }
+
+    // Allow travel in dark water on taxi or transport
+    if ((liquid_status.type_flags & MAP_LIQUID_TYPE_DARK_WATER) && !isInFlight() && !GetTransport())
+        m_MirrorTimerFlags |= UNDERWARER_INDARKWATER;
+    else
+        m_MirrorTimerFlags &= ~UNDERWARER_INDARKWATER;
+
+    // in lava check, anywhere in lava level
+    if (liquid_status.type_flags & MAP_LIQUID_TYPE_MAGMA)
+    {
+        if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
+            m_MirrorTimerFlags |= UNDERWATER_INLAVA;
+        else
+            m_MirrorTimerFlags &= ~UNDERWATER_INLAVA;
+    }
+    // in slime check, anywhere in slime level
+    if (liquid_status.type_flags & MAP_LIQUID_TYPE_SLIME)
+    {
+        if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
+            m_MirrorTimerFlags |= UNDERWATER_INSLIME;
+        else
+            m_MirrorTimerFlags &= ~UNDERWATER_INSLIME;
+    }
+}
+
+void Player::SetCanParry(bool value)
+{
+    if (m_canParry == value)
+        return;
+
+    m_canParry = value;
+    UpdateParryPercentage();
+}
+
+void Player::SetCanBlock(bool value)
+{
+    if (m_canBlock == value)
+        return;
+
+    m_canBlock = value;
+    UpdateBlockPercentage();
+}
+
+bool ItemPosCount::isContainedIn(ItemPosCountVec const& vec) const
+{
+    for (ItemPosCountVec::const_iterator itr = vec.begin(); itr != vec.end(); ++itr)
+        if (itr->pos == pos)
+            return true;
+    return false;
+}
+
+void Player::StopCastingBindSight()
+{
+    if (WorldObject* target = GetViewpoint())
+    {
+        if (target->isType(TYPEMASK_UNIT))
+        {
+            ((Unit*)target)->RemoveAurasByType(SPELL_AURA_BIND_SIGHT, GetGUID());
+            ((Unit*)target)->RemoveAurasByType(SPELL_AURA_MOD_POSSESS, GetGUID());
+            ((Unit*)target)->RemoveAurasByType(SPELL_AURA_MOD_POSSESS_PET, GetGUID());
+        }
+    }
+}
+
+void Player::SetViewpoint(WorldObject* target, bool apply)
+{
+    if (apply)
+    {
+        sLog->outDebug(LOG_FILTER_MAPS, "Player::CreateViewpoint: Player %s create seer %u (TypeId: %u).", GetName().c_str(), target->GetEntry(), target->GetTypeId());
+
+        if (!AddUInt64Value(PLAYER_FARSIGHT, target->GetGUID()))
+        {
+            sLog->outFatal(LOG_FILTER_PLAYER, "Player::CreateViewpoint: Player %s cannot add new viewpoint!", GetName().c_str());
+            return;
+        }
+
+        // farsight dynobj or puppet may be very far away
+        UpdateVisibilityOf(target);
+
+        if (target->isType(TYPEMASK_UNIT) && !GetVehicle())
+            ((Unit*)target)->AddPlayerToVision(this);
+    }
+    else
+    {
+        sLog->outDebug(LOG_FILTER_MAPS, "Player::CreateViewpoint: Player %s remove seer", GetName().c_str());
+
+        if (!RemoveUInt64Value(PLAYER_FARSIGHT, target->GetGUID()))
+        {
+            sLog->outFatal(LOG_FILTER_PLAYER, "Player::CreateViewpoint: Player %s cannot remove current viewpoint!", GetName().c_str());
+            return;
+        }
+
+        if (target->isType(TYPEMASK_UNIT) && !GetVehicle())
+            ((Unit*)target)->RemovePlayerFromVision(this);
+
+        //must immediately set seer back otherwise may crash
+        m_seer = this;
+
+        //WorldPacket data(SMSG_CLEAR_FAR_SIGHT_IMMEDIATE, 0);
+        //GetSession()->SendPacket(&data);
+    }
+}
+
+WorldObject* Player::GetViewpoint() const
+{
+    if (uint64 guid = GetUInt64Value(PLAYER_FARSIGHT))
+        return (WorldObject*)ObjectAccessor::GetObjectByTypeMask(*this, guid, TYPEMASK_SEER);
+    return NULL;
+}
+
+bool Player::CanUseBattlegroundObject(GameObject* gameobject)
+{
+    // It is possible to call this method with a null pointer, only skipping faction check.
+    if (gameobject)
+    {
+        FactionTemplateEntry const* playerFaction = getFactionTemplateEntry();
+        FactionTemplateEntry const* faction = sFactionTemplateStore.LookupEntry(gameobject->GetUInt32Value(GAMEOBJECT_FACTION));
+
+        if (playerFaction && faction && !playerFaction->IsFriendlyTo(*faction))
+            return false;
+    }
+
+    // BUG: sometimes when player clicks on flag in AB - client won't send gameobject_use, only gameobject_report_use packet
+    // Note: Mount, stealth and invisibility will be removed when used
+    return (!isTotalImmune() &&                            // Damage immune
+            !HasAura(SPELL_RECENTLY_DROPPED_FLAG) &&       // Still has recently held flag debuff
+            isAlive());                                    // Alive
+}
+
+bool Player::CanCaptureTowerPoint()
+{
+    return (!HasStealthAura() &&                            // not stealthed
+            !HasInvisibilityAura() &&                       // not invisible
+            isAlive());                                     // live player
+}
+
+uint32 Player::GetBarberShopCost(uint8 newhairstyle, uint8 newhaircolor, uint8 newfacialhair, BarberShopStyleEntry const* newSkin)
+{
+    uint8 level = getLevel();
+
+    if (level > GT_MAX_LEVEL)
+        level = GT_MAX_LEVEL;                               // max level in this dbc
+
+    uint8 hairstyle = GetByteValue(PLAYER_BYTES, 2);
+    uint8 haircolor = GetByteValue(PLAYER_BYTES, 3);
+    uint8 facialhair = GetByteValue(PLAYER_BYTES_2, 0);
+    uint8 skincolor = GetByteValue(PLAYER_BYTES, 0);
+
+    if ((hairstyle == newhairstyle) && (haircolor == newhaircolor) && (facialhair == newfacialhair) && (!newSkin || (newSkin->hair_id == skincolor)))
+        return 0;
+
+    GtBarberShopCostBaseEntry const* bsc = sGtBarberShopCostBaseStore.LookupEntry(level - 1);
+
+    if (!bsc)                                                // shouldn't happen
+        return 0xFFFFFFFF;
+
+    float cost = 0;
+
+    if (hairstyle != newhairstyle)
+        cost += bsc->cost;                                  // full price
+
+    if ((haircolor != newhaircolor) && (hairstyle == newhairstyle))
+        cost += bsc->cost * 0.5f;                           // +1/2 of price
+
+    if (facialhair != newfacialhair)
+        cost += bsc->cost * 0.75f;                          // +3/4 of price
+
+    if (newSkin && skincolor != newSkin->hair_id)
+        cost += bsc->cost * 0.75f;                          // +5/6 of price
+
+    return uint32(cost);
+}
+
+void Player::InitGlyphsForLevel()
+{
+    uint32 slot = 0;
+    for (uint32 i = 0; i < sGlyphSlotStore.GetNumRows() && slot < MAX_GLYPH_SLOT_INDEX; ++i)
+        if (GlyphSlotEntry const* gs = sGlyphSlotStore.LookupEntry(i))
+            SetGlyphSlot(slot++, gs->Id);
+
+    uint8 level = getLevel();
+    uint32 slotMask = 0;
+
+    if (level >= 25)
+        slotMask |= 0x01 | 0x02 | 0x40;
+    if (level >= 50)
+        slotMask |= 0x04 | 0x08 | 0x80;
+    if (level >= 75)
+        slotMask |= 0x10 | 0x20 | 0x100;
+
+    SetUInt32Value(PLAYER_GLYPHS_ENABLED, slotMask);
+}
+
+bool Player::isTotalImmune()
+{
+    AuraEffectList const& immune = GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);
+
+    uint32 immuneMask = 0;
+    for (AuraEffectList::const_iterator itr = immune.begin(); itr != immune.end(); ++itr)
+    {
+        immuneMask |= (*itr)->GetMiscValue();
+        if (immuneMask & SPELL_SCHOOL_MASK_ALL)            // total immunity
+            return true;
+    }
+    return false;
+}
+
+bool Player::HasTitle(uint32 bitIndex)
+{
+    if (bitIndex > MAX_TITLE_INDEX)
+        return false;
+
+    uint32 fieldIndexOffset = bitIndex / 32;
+    uint32 flag = 1 << (bitIndex % 32);
+    return HasFlag(PLAYER__FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
+}
+
+void Player::SetTitle(CharTitlesEntry const* title, bool lost)
+{
+    uint32 fieldIndexOffset = title->bit_index / 32;
+    uint32 flag = 1 << (title->bit_index % 32);
+
+    if (lost)
+    {
+        if (!HasFlag(PLAYER__FIELD_KNOWN_TITLES + fieldIndexOffset, flag))
+            return;
+
+        RemoveFlag(PLAYER__FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
+    }
+    else
+    {
+        if (HasFlag(PLAYER__FIELD_KNOWN_TITLES + fieldIndexOffset, flag))
+            return;
+
+        SetFlag(PLAYER__FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
+    }
+
+    WorldPacket data(SMSG_TITLE_EARNED, 4 + 4);
+    data << uint32(title->bit_index);
+    data << uint32(lost ? 0 : 1);                           // 1 - earned, 0 - lost
+    GetSession()->SendPacket(&data);
+}
+
+bool Player::isTotalImmunity()
+{
+    AuraEffectList const& immune = GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);
+
+    for (AuraEffectList::const_iterator itr = immune.begin(); itr != immune.end(); ++itr)
+    {
+        if (((*itr)->GetMiscValue() & SPELL_SCHOOL_MASK_ALL) !=0)   // total immunity
+        {
+            return true;
+        }
+        if (((*itr)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL) !=0)   // physical damage immunity
+        {
+            for (AuraEffectList::const_iterator i = immune.begin(); i != immune.end(); ++i)
+            {
+                if (((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_MAGIC) !=0)   // magic immunity
+                {
+                    return true;
+                }
+            }
+        }
+    }
+    return false;
+}
+
+void Player::UpdateCharmedAI()
+{
+    //This should only called in Player::Update
+  Creature* charmer = GetCharmer()->ToCreature();
+
+    //kill self if charm aura has infinite duration
+    if (charmer->IsInEvadeMode())
+    {
+        AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_MOD_CHARM);
+        for (AuraEffectList::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
+            if ((*iter)->GetCasterGUID() == charmer->GetGUID() && (*iter)->GetBase()->IsPermanent())
+            {
+                charmer->DealDamage(this, GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                return;
+            }
+    }
+
+    if (!charmer->isInCombat())
+        GetMotionMaster()->MoveFollow(charmer, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+
+    Unit* target = GetVictim();
+    if (!target || !charmer->IsValidAttackTarget(target))
+    {
+        target = charmer->SelectNearestTarget();
+        if (!target)
+            return;
+
+        GetMotionMaster()->MoveChase(target);
+        Attack(target, true);
+    }
+}
+
+uint32 Player::GetRuneTypeBaseCooldown(RuneType runeType) const
+{
+    return RUNE_BASE_COOLDOWN;
+}
+
+void Player::RemoveRunesByAuraEffect(AuraEffect const* aura)
+{
+    for (uint8 i = 0; i < MAX_RUNES; ++i)
+    {
+        if (m_runes->runes[i].ConvertAura == aura)
+        {
+            ConvertRune(i, GetBaseRune(i));
+            SetRuneConvertAura(i, NULL, SPELL_AURA_NONE, NULL);
+        }
+    }
+}
+
+void Player::RestoreBaseRune(uint8 index)
+{
+    SpellInfo const* spellInfo = m_runes->runes[index].ConvertAuraInfo;
+    AuraType type = m_runes->runes[index].ConvertAuraType;
+    // If rune was converted by a non-pasive aura that still active we should keep it converted
+    if (spellInfo)
+    {
+       if (!(spellInfo->Attributes & SPELL_ATTR0_PASSIVE))
+           return;
+
+       // Don't even convert aura for passive convertion
+       if (spellInfo->IsPassive() && type == SPELL_AURA_CONVERT_RUNE)
+           return;
+    }
+
+    ConvertRune(index, GetBaseRune(index));
+    SetRuneConvertAura(index, NULL, SPELL_AURA_NONE, NULL);
+}
+
+void Player::ConvertRune(uint8 index, RuneType newType)
+{
+    if (newType == RUNE_DEATH)
+        if (HasAura(90459)) //T11 4P
+            CastSpell(this, 90507, true);
+
+    SetCurrentRune(index, newType);
+
+    WorldPacket data(SMSG_CONVERT_RUNE, 2);
+    data << uint8(index);
+    data << uint8(newType);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::ResyncRunes(uint8 count)
+{
+    WorldPacket data(SMSG_RESYNC_RUNES, 4 + count * 2);
+    data << uint32(count);
+    for (uint32 i = 0; i < count; ++i)
+    {
+        float baseCd = float(GetRuneBaseCooldown(i));
+
+        data << uint8(GetCurrentRune(i));                   // rune type
+        data << uint8((baseCd - float(GetRuneCooldown(i))) / baseCd * 255); // rune cooldown passed
+    }
+    GetSession()->SendPacket(&data);
+}
+
+void Player::AddRunePower(uint8 mask)
+{
+    WorldPacket data(SMSG_ADD_RUNE_POWER, 4);
+    data << uint32(mask);                             // mask (0x00-0x3F probably)
+    GetSession()->SendPacket(&data);
+}
+
+static RuneType runeSlotTypes[MAX_RUNES] =
+{
+    /*0*/ RUNE_BLOOD,
+    /*1*/ RUNE_BLOOD,
+    /*2*/ RUNE_UNHOLY,
+    /*3*/ RUNE_UNHOLY,
+    /*4*/ RUNE_FROST,
+    /*5*/ RUNE_FROST
+};
+
+void Player::InitRunes()
+{
+    if (getClass() != CLASS_DEATH_KNIGHT)
+        return;
+
+    m_runes = new Runes;
+
+    m_runes->runeState = 0;
+    m_runes->lastUsedRune = RUNE_BLOOD;
+    m_runes->lastUsedRuneMask = 0;
+
+    for (uint8 i = 0; i < MAX_RUNES; ++i)
+    {
+        SetBaseRune(i, runeSlotTypes[i]);                              // init base types
+        SetCurrentRune(i, runeSlotTypes[i]);                           // init current types
+        SetRuneCooldown(i, 0);                                         // reset cooldowns
+        SetRuneConvertAura(i, NULL, SPELL_AURA_NONE, NULL);
+        m_runes->SetRuneState(i);
+    }
+
+    for (uint8 i = 0; i < NUM_RUNE_TYPES; ++i)
+        SetFloatValue(PLAYER_RUNE_REGEN_1 + i, 0.1f);                  // set a base regen timer equal to 10 sec
+}
+
+bool Player::IsBaseRuneSlotsOnCooldown(RuneType runeType) const
+{
+    for (uint8 i = 0; i < MAX_RUNES; ++i)
+        if (GetBaseRune(i) == runeType && GetRuneCooldown(i) == 0)
+            return false;
+
+    return true;
+}
+
+void Player::AutoStoreLoot(uint8 bag, uint8 slot, uint32 loot_id, LootStore const& store, bool broadcast)
+{
+    Loot loot;
+    loot.FillLoot (loot_id, store, this, true);
+
+    uint32 max_slot = loot.GetMaxSlotInLootFor(this);
+    for (uint32 i = 0; i < max_slot; ++i)
+    {
+        LootItem* lootItem = loot.LootItemInSlot(i, this);
+
+        ItemPosCountVec dest;
+        InventoryResult msg = CanStoreNewItem(bag, slot, dest, lootItem->itemid, lootItem->count);
+        if (msg != EQUIP_ERR_OK && slot != NULL_SLOT)
+            msg = CanStoreNewItem(bag, NULL_SLOT, dest, lootItem->itemid, lootItem->count);
+        if (msg != EQUIP_ERR_OK && bag != NULL_BAG)
+            msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, lootItem->itemid, lootItem->count);
+        if (msg != EQUIP_ERR_OK)
+        {
+            SendEquipError(msg, NULL, NULL, lootItem->itemid);
+            continue;
+        }
+
+        Item* pItem = StoreNewItem(dest, lootItem->itemid, true, lootItem->randomPropertyId);
+        SendNewItem(pItem, lootItem->count, false, false, broadcast);
+    }
+}
+
+void Player::StoreLootItem(uint8 lootSlot, Loot* loot)
+{
+    QuestItem* qitem = NULL;
+    QuestItem* ffaitem = NULL;
+    QuestItem* conditem = NULL;
+
+    LootItem* item = loot->LootItemInSlot(lootSlot, this, &qitem, &ffaitem, &conditem);
+
+    if (!item)
+    {
+        SendEquipError(EQUIP_ERR_LOOT_GONE, NULL, NULL);
+        return;
+    }
+
+    // questitems use the blocked field for other purposes
+    if (!qitem && item->is_blocked)
+    {
+        SendLootRelease(GetLootGUID());
+        return;
+    }
+
+    ItemPosCountVec dest;
+    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count);
+    if (msg == EQUIP_ERR_OK)
+    {
+        AllowedLooterSet looters = item->GetAllowedLooters();
+        Item* newitem = StoreNewItem(dest, item->itemid, true, item->randomPropertyId, looters);
+
+        if (qitem)
+        {
+            qitem->is_looted = true;
+            //freeforall is 1 if everyone's supposed to get the quest item.
+            if (item->freeforall || loot->GetPlayerQuestItems().size() == 1)
+                SendNotifyLootItemRemoved(lootSlot);
+            else
+                loot->NotifyQuestItemRemoved(qitem->index);
+        }
+        else
+        {
+            if (ffaitem)
+            {
+                //freeforall case, notify only one player of the removal
+                ffaitem->is_looted = true;
+                SendNotifyLootItemRemoved(lootSlot);
+            }
+            else
+            {
+                //not freeforall, notify everyone
+                if (conditem)
+                    conditem->is_looted = true;
+                loot->NotifyItemRemoved(lootSlot);
+            }
+        }
+
+        //if only one person is supposed to loot the item, then set it to looted
+        if (!item->freeforall)
+            item->is_looted = true;
+
+        --loot->unlootedCount;
+
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->itemid))
+            if (proto->Quality > ITEM_QUALITY_EPIC || (proto->Quality == ITEM_QUALITY_EPIC && proto->ItemLevel >= MinNewsItemLevel[sWorld->getIntConfig(CONFIG_EXPANSION)]))
+                if (Guild* guild = GetGuild())
+                    guild->AddGuildNews(GUILD_NEWS_ITEM_LOOTED, GetGUID(), 0, item->itemid);
+
+        SendNewItem(newitem, uint32(item->count), false, false, true);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_TYPE, item->itemid, item->count, loot->loot_type);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_EPIC_ITEM, item->itemid, item->count);
+        UpdateGuildAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_EPIC_ITEM, item->itemid, item->count);
+
+        // LootItem is being removed (looted) from the container, delete it from the DB.
+        if (loot->containerID > 0)
+            loot->DeleteLootItemFromContainerItemDB(item->itemid);
+
+    }
+    else
+        SendEquipError(msg, NULL, NULL, item->itemid);
+}
+
+uint32 Player::CalculateTalentsPoints() const
+{
+    // this dbc file has entries only up to level 100
+    NumTalentsAtLevelEntry const* count = sNumTalentsAtLevelStore.LookupEntry(std::min<uint32>(getLevel(), 100));
+    if (!count)
+        return 0;
+
+    float baseForLevel = count->Talents;
+
+    if (getClass() != CLASS_DEATH_KNIGHT || GetMapId() != 609)
+        return uint32(baseForLevel * sWorld->getRate(RATE_TALENT));
+
+    // Death Knight starting level
+    // hardcoded here - number of quest awarded talents is equal to number of talents any other class would have at level 55
+    if (getLevel() < 55)
+        return 0;
+
+    NumTalentsAtLevelEntry const* dkBase = sNumTalentsAtLevelStore.LookupEntry(55);
+    if (!dkBase)
+        return 0;
+
+    float talentPointsForLevel = count->Talents - dkBase->Talents;
+    talentPointsForLevel += float(GetQuestRewardedTalentCount());
+
+    if (talentPointsForLevel > baseForLevel)
+        talentPointsForLevel = baseForLevel;
+
+    return uint32(talentPointsForLevel * sWorld->getRate(RATE_TALENT));
+}
+
+bool Player::IsKnowHowFlyIn(uint32 mapid, uint32 zone) const
+{
+    // continent checked in SpellInfo::CheckLocation at cast and area update
+    uint32 v_map = GetVirtualMapForMapAndZone(mapid, zone);
+    return v_map != 571 || HasSpell(54197); // Cold Weather Flying
+}
+
+void Player::learnSpellHighRank(uint32 spellid)
+{
+    learnSpell(spellid, false);
+
+    if (uint32 next = sSpellMgr->GetNextSpellInChain(spellid))
+        learnSpellHighRank(next);
+}
+
+void Player::_LoadSkills(PreparedQueryResult result)
+{
+    //                                                           0      1      2
+    // SetPQuery(PLAYER_LOGIN_QUERY_LOADSKILLS,          "SELECT skill, value, max FROM character_skills WHERE guid = '%u'", GUID_LOPART(m_guid));
+
+    uint32 count = 0;
+    uint8 professionCount = 0;
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            uint16 skill    = fields[0].GetUInt16();
+            uint16 value    = fields[1].GetUInt16();
+            uint16 max      = fields[2].GetUInt16();
+            SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(skill);
+            if (!pSkill)
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Character %u has skill %u that does not exist.", GetGUIDLow(), skill);
+                continue;
+            }
+
+            // set fixed skill ranges
+            switch (GetSkillRangeType(pSkill, false))
+            {
+                case SKILL_RANGE_LANGUAGE:                      // 300..300
+                    value = max = 300;
+                    break;
+                case SKILL_RANGE_MONO:                          // 1..1, grey monolite bar
+                    value = max = 1;
+                    break;
+                default:
+                    break;
+            }
+            if (value == 0)
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Character %u has skill %u with value 0. Will be deleted.", GetGUIDLow(), skill);
+
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_SKILL);
+
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt16(1, skill);
+
+                CharacterDatabase.Execute(stmt);
+
+                continue;
+            }
+
+            uint16 field = count / 2;
+            uint8 offset = count & 1;
+
+            SetUInt16Value(PLAYER_SKILL_LINEID_0 + field, offset, skill);
+            uint16 step = 0;
+
+            if (pSkill->categoryId == SKILL_CATEGORY_SECONDARY)
+                step = max / 75;
+
+            if (pSkill->categoryId == SKILL_CATEGORY_PROFESSION)
+            {
+                step = max / 75;
+
+                if (professionCount < 2)
+                    SetUInt32Value(PLAYER_PROFESSION_SKILL_LINE_1 + professionCount++, skill);
+            }
+
+            SetUInt16Value(PLAYER_SKILL_STEP_0 + field, offset, step);
+            SetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset, value);
+            SetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset, max);
+            SetUInt16Value(PLAYER_SKILL_MODIFIER_0 + field, offset, 0);
+            SetUInt16Value(PLAYER_SKILL_TALENT_0 + field, offset, 0);
+
+            mSkillStatus.insert(SkillStatusMap::value_type(skill, SkillStatusData(count, SKILL_UNCHANGED)));
+
+            learnSkillRewardedSpells(skill, value);
+
+            ++count;
+
+            if (count >= PLAYER_MAX_SKILLS)                      // client limit
+            {
+                sLog->outError(LOG_FILTER_PLAYER, "Character %u has more than %u skills.", GetGUIDLow(), PLAYER_MAX_SKILLS);
+                break;
+            }
+        }
+        while (result->NextRow());
+    }
+
+    for (; count < PLAYER_MAX_SKILLS; ++count)
+    {
+        uint16 field = count / 2;
+        uint8 offset = count & 1;
+
+        SetUInt16Value(PLAYER_SKILL_LINEID_0 + field, offset, 0);
+        SetUInt16Value(PLAYER_SKILL_STEP_0 + field, offset, 0);
+        SetUInt16Value(PLAYER_SKILL_RANK_0 + field, offset, 0);
+        SetUInt16Value(PLAYER_SKILL_MAX_RANK_0 + field, offset, 0);
+        SetUInt16Value(PLAYER_SKILL_MODIFIER_0 + field, offset, 0);
+        SetUInt16Value(PLAYER_SKILL_TALENT_0 + field, offset, 0);
+    }
+
+    // special settings
+    if (getClass() == CLASS_DEATH_KNIGHT)
+    {
+        uint8 base_level = std::min(getLevel(), uint8(sWorld->getIntConfig(CONFIG_START_HEROIC_PLAYER_LEVEL)));
+        if (base_level < 1)
+            base_level = 1;
+        uint16 base_skill = (base_level-1)*5;               // 270 at starting level 55
+        if (base_skill < 1)
+            base_skill = 1;                                 // skill mast be known and then > 0 in any case
+
+        if (GetPureSkillValue(SKILL_FIRST_AID) < base_skill)
+            SetSkill(SKILL_FIRST_AID, 4 /*artisan*/, base_skill, 300);
+        if (GetPureSkillValue(SKILL_AXES) < base_skill)
+            SetSkill(SKILL_AXES, 0, base_skill, base_skill);
+        if (GetPureSkillValue(SKILL_DEFENSE) < base_skill)
+            SetSkill(SKILL_DEFENSE, 0, base_skill, base_skill);
+        if (GetPureSkillValue(SKILL_POLEARMS) < base_skill)
+            SetSkill(SKILL_POLEARMS, 0, base_skill, base_skill);
+        if (GetPureSkillValue(SKILL_SWORDS) < base_skill)
+            SetSkill(SKILL_SWORDS, 0, base_skill, base_skill);
+        if (GetPureSkillValue(SKILL_2H_AXES) < base_skill)
+            SetSkill(SKILL_2H_AXES, 0, base_skill, base_skill);
+        if (GetPureSkillValue(SKILL_2H_SWORDS) < base_skill)
+            SetSkill(SKILL_2H_SWORDS, 0, base_skill, base_skill);
+        if (GetPureSkillValue(SKILL_UNARMED) < base_skill)
+            SetSkill(SKILL_UNARMED, 0, base_skill, base_skill);
+    }
+}
+
+InventoryResult Player::CanEquipUniqueItem(Item* pItem, uint8 eslot, uint32 limit_count) const
+{
+    ItemTemplate const* pProto = pItem->GetTemplate();
+
+    // proto based limitations
+    if (InventoryResult res = CanEquipUniqueItem(pProto, eslot, limit_count))
+        return res;
+
+    // check unique-equipped on gems
+    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
+    {
+        uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
+        if (!enchant_id)
+            continue;
+        SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!enchantEntry)
+            continue;
+
+        ItemTemplate const* pGem = sObjectMgr->GetItemTemplate(enchantEntry->GemID);
+        if (!pGem)
+            continue;
+
+        // include for check equip another gems with same limit category for not equipped item (and then not counted)
+        uint32 gem_limit_count = !pItem->IsEquipped() && pGem->ItemLimitCategory
+            ? pItem->GetGemCountWithLimitCategory(pGem->ItemLimitCategory) : 1;
+
+        if (InventoryResult res = CanEquipUniqueItem(pGem, eslot, gem_limit_count))
+            return res;
+    }
+
+    return EQUIP_ERR_OK;
+}
+
+InventoryResult Player::CanEquipUniqueItem(ItemTemplate const* itemProto, uint8 except_slot, uint32 limit_count) const
+{
+    // check unique-equipped on item
+    if (itemProto->Flags & ITEM_PROTO_FLAG_UNIQUE_EQUIPPED)
+    {
+        // there is an equip limit on this item
+        if (HasItemOrGemWithIdEquipped(itemProto->ItemId, 1, except_slot))
+            return EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE;
+    }
+
+    // check unique-equipped limit
+    if (itemProto->ItemLimitCategory)
+    {
+        ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(itemProto->ItemLimitCategory);
+        if (!limitEntry)
+            return EQUIP_ERR_NOT_EQUIPPABLE;
+
+        // NOTE: limitEntry->mode not checked because if item have have-limit then it applied and to equip case
+
+        if (limit_count > limitEntry->maxCount)
+            return EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS;
+
+        // there is an equip limit on this item
+        if (HasItemOrGemWithLimitCategoryEquipped(itemProto->ItemLimitCategory, limitEntry->maxCount - limit_count + 1, except_slot))
+            return EQUIP_ERR_ITEM_MAX_COUNT_EQUIPPED_SOCKETED;
+    }
+
+    return EQUIP_ERR_OK;
+}
+
+void Player::HandleFall(MovementInfo const& movementInfo)
+{
+    // calculate total z distance of the fall
+    float z_diff = m_lastFallZ - movementInfo.pos.GetPositionZ();
+    //sLog->outDebug(LOG_FILTER_GENERAL, "zDiff = %f", z_diff);
+
+    //Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
+    // 14.57 can be calculated by resolving damageperc formula below to 0
+    if (z_diff >= 14.57f && !isDead() && !isGameMaster() &&
+        !HasAuraType(SPELL_AURA_HOVER) && !HasAuraType(SPELL_AURA_FEATHER_FALL) &&
+        !HasAuraType(SPELL_AURA_FLY) && !IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
+    {
+        //Safe fall, fall height reduction
+        int32 safe_fall = GetTotalAuraModifier(SPELL_AURA_SAFE_FALL);
+
+        float damageperc = 0.018f*(z_diff-safe_fall)-0.2426f;
+
+        if (damageperc > 0)
+        {
+            uint32 damage = (uint32)(damageperc * GetMaxHealth()*sWorld->getRate(RATE_DAMAGE_FALL));
+
+            float height = movementInfo.pos.m_positionZ;
+            UpdateGroundPositionZ(movementInfo.pos.m_positionX, movementInfo.pos.m_positionY, height);
+
+            if (damage > 0)
+            {
+                //Prevent fall damage from being more than the player maximum health
+                if (damage > GetMaxHealth())
+                    damage = GetMaxHealth();
+
+                // Gust of Wind
+                if (HasAura(43621))
+                    damage = GetMaxHealth()/2;
+
+                uint32 original_health = GetHealth();
+                uint32 final_damage = EnvironmentalDamage(DAMAGE_FALL, damage);
+
+                // recheck alive, might have died of EnvironmentalDamage, avoid cases when player die in fact like Spirit of Redemption case
+                if (isAlive() && final_damage < original_health)
+                    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_FALL_WITHOUT_DYING, uint32(z_diff*100));
+            }
+
+            //Z given by moveinfo, LastZ, FallTime, WaterZ, MapZ, Damage, Safefall reduction
+            sLog->outDebug(LOG_FILTER_PLAYER, "FALLDAMAGE z=%f sz=%f pZ=%f FallTime=%d mZ=%f damage=%d SF=%d", movementInfo.pos.GetPositionZ(), height, GetPositionZ(), movementInfo.fallTime, height, damage, safe_fall);
+        }
+    }
+    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LANDING); // No fly zone - Parachute
+}
+
+void Player::ResetAchievements()
+{
+    m_achievementMgr->Reset();
+}
+
+void Player::SendRespondInspectAchievements(Player* player) const
+{
+    m_achievementMgr->SendAchievementInfo(player);
+}
+
+uint32 Player::GetAchievementPoints() const
+{
+    return m_achievementMgr->GetAchievementPoints();
+}
+
+bool Player::HasAchieved(uint32 achievementId) const
+{
+    return m_achievementMgr->HasAchieved(achievementId);
+}
+
+void Player::StartTimedAchievement(AchievementCriteriaTimedTypes type, uint32 entry, uint32 timeLost/* = 0*/)
+{
+    m_achievementMgr->StartTimedAchievement(type, entry, timeLost);
+}
+
+void Player::RemoveTimedAchievement(AchievementCriteriaTimedTypes type, uint32 entry)
+{
+    m_achievementMgr->RemoveTimedAchievement(type, entry);
+}
+
+void Player::ResetAchievementCriteria(AchievementCriteriaTypes type, uint64 miscValue1 /*= 0*/, uint64 miscValue2 /*= 0*/, bool evenIfCriteriaComplete /* = false*/)
+{
+    m_achievementMgr->ResetAchievementCriteria(type, miscValue1, miscValue2, evenIfCriteriaComplete);
+}
+
+void Player::UpdateAchievementCriteria(AchievementCriteriaTypes type, uint64 miscValue1 /*= 0*/, uint64 miscValue2 /*= 0*/, uint64 miscValue3 /*= 0*/, Unit* unit /*= NULL*/)
+{
+    m_achievementMgr->UpdateAchievementCriteria(type, miscValue1, miscValue2, miscValue3, unit, this);
+    //Guild* guild = sGuildMgr->GetGuildById(GetGuildId());
+    //if (!guild)
+    //    return;
+
+    //// Update only individual achievement criteria here, otherwise we may get multiple updates
+    //// from a single boss kill
+    //if (sAchievementMgr->IsGroupCriteriaType(type))
+    //    return;
+
+    //guild->UpdateAchievementCriteria(type, miscValue1, miscValue2, miscValue3, unit, this);
+}
+
+void Player::UpdateGuildAchievementCriteria(AchievementCriteriaTypes type, uint64 miscValue1 /*= 0*/, uint64 miscValue2 /*= 0*/, uint64 miscValue3 /*= 0*/, Unit* unit /*= NULL*/)
+{
+     Guild* guild = sGuildMgr->GetGuildById(GetGuildId());
+     if (!guild)
+         return;
+
+    guild->GetAchievementMgr().UpdateAchievementCriteria(type, miscValue1, miscValue2, miscValue3, unit, this);
+ }
+
+void Player::CompletedAchievement(AchievementEntry const* entry)
+{
+    m_achievementMgr->CompletedAchievement(entry, this);
+}
+
+bool Player::LearnTalent(uint32 talentId, uint32 talentRank)
+{
+    uint32 CurTalentPoints = GetFreeTalentPoints();
+
+    if (CurTalentPoints == 0)
+        return false;
+
+    if (talentRank >= MAX_TALENT_RANK)
+        return false;
+
+    TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+
+    if (!talentInfo)
+        return false;
+
+    TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
+
+    if (!talentTabInfo)
+        return false;
+
+    // prevent learn talent for different class (cheating)
+    if ((getClassMask() & talentTabInfo->ClassMask) == 0)
+        return false;
+
+    // find current max talent rank (0~5)
+    uint8 curtalent_maxrank = 0; // 0 = not learned any rank
+    for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+    {
+        if (talentInfo->RankID[rank] && HasSpell(talentInfo->RankID[rank]))
+        {
+            curtalent_maxrank = (rank + 1);
+            break;
+        }
+    }
+
+    // we already have same or higher talent rank learned
+    if (curtalent_maxrank >= (talentRank + 1))
+        return false;
+
+    // check if we have enough talent points
+    if (CurTalentPoints < (talentRank - curtalent_maxrank + 1))
+        return false;
+
+    // Check if it requires another talent
+    if (talentInfo->DependsOn > 0)
+    {
+        if (TalentEntry const* depTalentInfo = sTalentStore.LookupEntry(talentInfo->DependsOn))
+        {
+            bool hasEnoughRank = false;
+            for (uint8 rank = talentInfo->DependsOnRank; rank < MAX_TALENT_RANK; rank++)
+            {
+                if (depTalentInfo->RankID[rank] != 0)
+                    if (HasSpell(depTalentInfo->RankID[rank]))
+                        hasEnoughRank = true;
+            }
+            if (!hasEnoughRank)
+                return false;
+        }
+    }
+
+    // Find out how many points we have in this field
+    uint32 spentPoints = 0;
+    uint32 primaryTreeTalents = 0;
+    uint32 tTab = talentInfo->TalentTab;
+    bool isMainTree = GetPrimaryTalentTree(GetActiveSpec()) == tTab || !GetPrimaryTalentTree(GetActiveSpec());
+
+    if (talentInfo->Row > 0 || !isMainTree)
+    {
+        for (uint32 i = 0; i < sTalentStore.GetNumRows(); i++)              // Loop through all talents.
+        {
+            if (TalentEntry const* tmpTalent = sTalentStore.LookupEntry(i)) // Someday, someone needs to revamp the way talents are tracked
+            {
+                for (uint8 rank = 0; rank < MAX_TALENT_RANK; rank++)
+                {
+                    if (tmpTalent->RankID[rank] != 0)
+                    {
+                        if (HasSpell(tmpTalent->RankID[rank]))
+                        {
+                            if (tmpTalent->TalentTab == tTab)
+                                spentPoints += (rank + 1);
+                            if (tmpTalent->TalentTab == GetPrimaryTalentTree(GetActiveSpec()))
+                                primaryTreeTalents += (rank + 1);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // not have required min points spent in talent tree
+    if (spentPoints < (talentInfo->Row * MAX_TALENT_RANK))
+        return false;
+
+    // player has not spent 31 talents in main tree before attempting to learn other tree's talents
+    if (!isMainTree && primaryTreeTalents < REQ_PRIMARY_TREE_TALENTS)
+        return false;
+
+    // spell not set in talent.dbc
+    uint32 spellid = talentInfo->RankID[talentRank];
+    if (spellid == 0)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Talent.dbc have for talent: %u Rank: %u spell id = 0", talentId, talentRank);
+        return false;
+    }
+
+    // already known
+    if (HasSpell(spellid))
+        return false;
+
+    // learn! (other talent ranks will unlearned at learning)
+    learnSpell(spellid, false);
+    AddTalent(spellid, GetActiveSpec(), true);
+
+    sLog->outInfo(LOG_FILTER_GENERAL, "TalentID: %u Rank: %u Spell: %u Spec: %u\n", talentId, talentRank, spellid, GetActiveSpec());
+
+    // set talent tree for player
+    if (!GetPrimaryTalentTree(GetActiveSpec()))
+    {
+        SetPrimaryTalentTree(GetActiveSpec(), talentInfo->TalentTab);
+        std::vector<uint32> const* specSpells = GetTalentTreePrimarySpells(talentInfo->TalentTab);
+        if (specSpells)
+            for (size_t i = 0; i < specSpells->size(); ++i)
+                learnSpell(specSpells->at(i), false);
+
+        if (IsMasteryLearned())
+            for (uint32 i = 0; i < MAX_MASTERY_SPELLS; ++i)
+                if (uint32 mastery = talentTabInfo->MasterySpells[i])
+                    learnSpell(mastery, false);
+    }
+
+    // update free talent points
+    SetFreeTalentPoints(CurTalentPoints - (talentRank - curtalent_maxrank + 1));
+
+    UpdateMastery();
+    return true;
+}
+
+void Player::LearnPetTalent(uint64 petGuid, uint32 talentId, uint32 talentRank)
+{
+    Pet* pet = GetPet();
+
+    if (!pet)
+        return;
+
+    if (petGuid != pet->GetGUID())
+        return;
+
+    uint32 CurTalentPoints = pet->GetFreeTalentPoints();
+
+    if (CurTalentPoints == 0)
+        return;
+
+    if (talentRank >= MAX_PET_TALENT_RANK)
+        return;
+
+    TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+
+    if (!talentInfo)
+        return;
+
+    TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
+
+    if (!talentTabInfo)
+        return;
+
+    CreatureTemplate const* ci = pet->GetCreatureTemplate();
+
+    if (!ci)
+        return;
+
+    CreatureFamilyEntry const* pet_family = sCreatureFamilyStore.LookupEntry(ci->family);
+
+    if (!pet_family)
+        return;
+
+    if (pet_family->petTalentType < 0)                       // not hunter pet
+        return;
+
+    // prevent learn talent for different family (cheating)
+    if (!((1 << pet_family->petTalentType) & talentTabInfo->petTalentMask))
+        return;
+
+    // find current max talent rank (0~5)
+    uint8 curtalent_maxrank = 0; // 0 = not learned any rank
+    for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+    {
+        if (talentInfo->RankID[rank] && pet->HasSpell(talentInfo->RankID[rank]))
+        {
+            curtalent_maxrank = (rank + 1);
+            break;
+        }
+    }
+
+    // we already have same or higher talent rank learned
+    if (curtalent_maxrank >= (talentRank + 1))
+        return;
+
+    // check if we have enough talent points
+    if (CurTalentPoints < (talentRank - curtalent_maxrank + 1))
+        return;
+
+    // Check if it requires another talent
+    if (talentInfo->DependsOn > 0)
+    {
+        if (TalentEntry const* depTalentInfo = sTalentStore.LookupEntry(talentInfo->DependsOn))
+        {
+            bool hasEnoughRank = false;
+            for (uint8 rank = talentInfo->DependsOnRank; rank < MAX_TALENT_RANK; rank++)
+            {
+                if (depTalentInfo->RankID[rank] != 0)
+                    if (pet->HasSpell(depTalentInfo->RankID[rank]))
+                        hasEnoughRank = true;
+            }
+            if (!hasEnoughRank)
+                return;
+        }
+    }
+
+    // Find out how many points we have in this field
+    uint32 spentPoints = 0;
+
+    uint32 tTab = talentInfo->TalentTab;
+    if (talentInfo->Row > 0)
+    {
+        uint32 numRows = sTalentStore.GetNumRows();
+        for (uint32 i = 0; i < numRows; ++i)          // Loop through all talents.
+        {
+            // Someday, someone needs to revamp
+            const TalentEntry* tmpTalent = sTalentStore.LookupEntry(i);
+            if (tmpTalent)                                  // the way talents are tracked
+            {
+                if (tmpTalent->TalentTab == tTab)
+                {
+                    for (uint8 rank = 0; rank < MAX_TALENT_RANK; rank++)
+                    {
+                        if (tmpTalent->RankID[rank] != 0)
+                        {
+                            if (pet->HasSpell(tmpTalent->RankID[rank]))
+                            {
+                                spentPoints += (rank + 1);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // not have required min points spent in talent tree
+    if (spentPoints < (talentInfo->Row * MAX_PET_TALENT_RANK))
+        return;
+
+    // spell not set in talent.dbc
+    uint32 spellid = talentInfo->RankID[talentRank];
+    if (spellid == 0)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Talent.dbc have for talent: %u Rank: %u spell id = 0", talentId, talentRank);
+        return;
+    }
+
+    // already known
+    if (pet->HasSpell(spellid))
+        return;
+
+    // learn! (other talent ranks will unlearned at learning)
+    pet->learnSpell(spellid);
+    sLog->outInfo(LOG_FILTER_PLAYER, "PetTalentID: %u Rank: %u Spell: %u\n", talentId, talentRank, spellid);
+
+    // update free talent points
+    pet->SetFreeTalentPoints(CurTalentPoints - (talentRank - curtalent_maxrank + 1));
+}
+
+void Player::AddKnownCurrency(uint32 itemId)
+{
+    if (CurrencyTypesEntry const* ctEntry = sCurrencyTypesStore.LookupEntry(itemId))
+        SetFlag64(0, (1LL << (ctEntry->ID-1)));
+}
+
+void Player::UpdateFallInformationIfNeed(MovementInfo const& minfo, uint16 opcode)
+{
+    if (m_lastFallTime >= minfo.fallTime || m_lastFallZ <= minfo.pos.GetPositionZ() || opcode == MSG_MOVE_FALL_LAND)
+        SetFallInformation(minfo.fallTime, minfo.pos.GetPositionZ());
+}
+
+void Player::UnsummonPetTemporaryIfAny()
+{
+    Pet* pet = GetPet();
+    if (!pet)
+        return;
+
+    if (!m_temporaryUnsummonedPetNumber && pet->isControlled() && !pet->isTemporarySummoned())
+    {
+        m_temporaryUnsummonedPetNumber = pet->GetCharmInfo()->GetPetNumber();
+        m_oldpetspell = pet->GetUInt32Value(UNIT_CREATED_BY_SPELL);
+    }
+
+    RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT);
+}
+
+void Player::ResummonPetTemporaryUnSummonedIfAny()
+{
+    if (!m_temporaryUnsummonedPetNumber)
+        return;
+
+    // not resummon in not appropriate state
+    if (IsPetNeedBeTemporaryUnsummoned())
+        return;
+
+    if (GetPetGUID())
+        return;
+
+    Pet* NewPet = new Pet(this);
+
+    PetData* t_pet = GetPetDatabyGuid(m_temporaryUnsummonedPetNumber);
+    if (!NewPet->LoadPet(this, t_pet, 0))
+        delete NewPet;
+
+    m_temporaryUnsummonedPetNumber = 0;
+}
+
+bool Player::canSeeSpellClickOn(Creature const* c) const
+{
+    if (!c->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK))
+        return false;
+
+    SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(c->GetEntry());
+    if (clickPair.first == clickPair.second)
+        return true;
+
+    for (SpellClickInfoContainer::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)
+    {
+        if (!itr->second.IsFitToRequirements(this, c))
+            return false;
+
+        ConditionList conds = sConditionMgr->GetConditionsForSpellClickEvent(c->GetEntry(), itr->second.spellId);
+        ConditionSourceInfo info = ConditionSourceInfo(const_cast<Player*>(this), const_cast<Creature*>(c));
+        if (sConditionMgr->IsObjectMeetToConditions(info, conds))
+            return true;
+    }
+
+    return false;
+}
+
+void Player::BuildPlayerTalentsInfoData(WorldPacket* data)
+{
+    *data << uint32(GetFreeTalentPoints());                 // unspentTalentPoints
+    *data << uint8(GetSpecsCount());                        // talent group count (0, 1 or 2)
+    *data << uint8(GetActiveSpec());                        // talent group index (0 or 1)
+
+    if (GetSpecsCount())
+    {
+        if (GetSpecsCount() > MAX_TALENT_SPECS)
+            SetSpecsCount(MAX_TALENT_SPECS);
+
+        // loop through all specs (only 1 for now)
+        for (uint8 specIdx = 0; specIdx < GetSpecsCount(); ++specIdx)
+        {
+            *data << uint32(GetPrimaryTalentTree(specIdx));
+            uint8 talentIdCount = 0;
+            size_t pos = data->wpos();
+            *data << uint8(talentIdCount);                  // [PH], talentIdCount
+
+            // find class talent tabs (all players have 3 talent tabs)
+            uint32 const* talentTabIds = GetTalentTabPages(getClass());
+
+            for (uint8 i = 0; i < MAX_TALENT_TABS; ++i)
+            {
+                uint32 talentTabId = talentTabIds[i];
+
+                for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
+                {
+                    TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+                    if (!talentInfo)
+                        continue;
+
+                    // skip another tab talents
+                    if (talentInfo->TalentTab != talentTabId)
+                        continue;
+
+                    // find max talent rank (0~4)
+                    int8 curtalent_maxrank = -1;
+                    for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+                    {
+                        if (talentInfo->RankID[rank] && HasTalent(talentInfo->RankID[rank], specIdx))
+                        {
+                            curtalent_maxrank = rank;
+                            break;
+                        }
+                    }
+
+                    // not learned talent
+                    if (curtalent_maxrank < 0)
+                        continue;
+
+                    *data << uint32(talentInfo->TalentID);  // Talent.dbc
+                    *data << uint8(curtalent_maxrank);      // talentMaxRank (0-4)
+
+                    ++talentIdCount;
+                }
+            }
+
+            data->put<uint8>(pos, talentIdCount);           // put real count
+
+            *data << uint8(MAX_GLYPH_SLOT_INDEX);           // glyphs count
+
+            for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
+                *data << uint16(GetGlyph(specIdx, i));               // GlyphProperties.dbc
+        }
+    }
+}
+
+void Player::BuildPetTalentsInfoData(WorldPacket* data)
+{
+    uint32 unspentTalentPoints = 0;
+    size_t pointsPos = data->wpos();
+    *data << uint32(unspentTalentPoints);                   // [PH], unspentTalentPoints
+
+    uint8 talentIdCount = 0;
+    size_t countPos = data->wpos();
+    *data << uint8(talentIdCount);                          // [PH], talentIdCount
+
+    Pet* pet = GetPet();
+    if (!pet)
+        return;
+
+    unspentTalentPoints = pet->GetFreeTalentPoints();
+
+    data->put<uint32>(pointsPos, unspentTalentPoints);      // put real points
+
+    CreatureTemplate const* ci = pet->GetCreatureTemplate();
+    if (!ci)
+        return;
+
+    CreatureFamilyEntry const* pet_family = sCreatureFamilyStore.LookupEntry(ci->family);
+    if (!pet_family || pet_family->petTalentType < 0)
+        return;
+
+    for (uint32 talentTabId = 1; talentTabId < sTalentTabStore.GetNumRows(); ++talentTabId)
+    {
+        TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentTabId);
+        if (!talentTabInfo)
+            continue;
+
+        if (!((1 << pet_family->petTalentType) & talentTabInfo->petTalentMask))
+            continue;
+
+        for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
+        {
+            TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+            if (!talentInfo)
+                continue;
+
+            // skip another tab talents
+            if (talentInfo->TalentTab != talentTabId)
+                continue;
+
+            // find max talent rank (0~4)
+            int8 curtalent_maxrank = -1;
+            for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+            {
+                if (talentInfo->RankID[rank] && pet->HasSpell(talentInfo->RankID[rank]))
+                {
+                    curtalent_maxrank = rank;
+                    break;
+                }
+            }
+
+            // not learned talent
+            if (curtalent_maxrank < 0)
+                continue;
+
+            *data << uint32(talentInfo->TalentID);          // Talent.dbc
+            *data << uint8(curtalent_maxrank);              // talentMaxRank (0-4)
+
+            ++talentIdCount;
+        }
+
+        data->put<uint8>(countPos, talentIdCount);          // put real count
+
+        break;
+    }
+}
+
+void Player::SendTalentsInfoData(bool pet)
+{
+    WorldPacket data(SMSG_TALENTS_INFO, 50);
+    data << uint8(pet ? 1 : 0);
+    if (pet)
+        BuildPetTalentsInfoData(&data);
+    else
+        BuildPlayerTalentsInfoData(&data);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::BuildEnchantmentsInfoData(WorldPacket* data)
+{
+    uint32 slotUsedMask = 0;
+    size_t slotUsedMaskPos = data->wpos();
+    *data << uint32(slotUsedMask);                          // slotUsedMask < 0x80000
+
+    for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+
+        if (!item)
+            continue;
+
+        slotUsedMask |= (1 << i);
+
+        *data << uint32(item->GetEntry());                  // item entry
+
+        uint16 enchantmentMask = 0;
+        size_t enchantmentMaskPos = data->wpos();
+        *data << uint16(enchantmentMask);                   // enchantmentMask < 0x1000
+
+        for (uint32 j = 0; j < MAX_ENCHANTMENT_SLOT; ++j)
+        {
+            uint32 enchId = item->GetEnchantmentId(EnchantmentSlot(j));
+
+            if (!enchId)
+                continue;
+
+            enchantmentMask |= (1 << j);
+
+            *data << uint16(enchId);                        // enchantmentId?
+        }
+
+        data->put<uint16>(enchantmentMaskPos, enchantmentMask);
+
+        *data << uint16(0);                                 // unknown
+        data->appendPackGUID(item->GetUInt64Value(ITEM_FIELD_CREATOR)); // item creator
+        *data << uint32(0);                                 // seed?
+    }
+
+    data->put<uint32>(slotUsedMaskPos, slotUsedMask);
+}
+
+void Player::SendEquipmentSetList()
+{
+    uint32 count = 0;
+    WorldPacket data(SMSG_EQUIPMENT_SET_LIST, 4);
+    size_t count_pos = data.wpos();
+    data << uint32(count);                                  // count placeholder
+    for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
+    {
+        if (itr->second.state == EQUIPMENT_SET_DELETED)
+            continue;
+        data.appendPackGUID(itr->second.Guid);
+        data << uint32(itr->first);
+        data << itr->second.Name;
+        data << itr->second.IconName;
+        for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
+        {
+            // ignored slots stored in IgnoreMask, client wants "1" as raw GUID, so no HIGHGUID_ITEM
+            if (itr->second.IgnoreMask & (1 << i))
+                data.appendPackGUID(uint64(1));
+            else
+                data.appendPackGUID(MAKE_NEW_GUID(itr->second.Items[i], 0, HIGHGUID_ITEM));
+        }
+
+        ++count;                                            // client have limit but it checked at loading and set
+    }
+    data.put<uint32>(count_pos, count);
+    GetSession()->SendPacket(&data);
+}
+
+void Player::SetEquipmentSet(uint32 index, EquipmentSet eqset)
+{
+    if (eqset.Guid != 0)
+    {
+        bool found = false;
+
+        for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
+        {
+            if ((itr->second.Guid == eqset.Guid) && (itr->first == index))
+            {
+                found = true;
+                break;
+            }
+        }
+
+        if (!found)                                          // something wrong...
+        {
+            sLog->outError(LOG_FILTER_PLAYER, "Player %s tried to save equipment set "UI64FMTD" (index %u), but that equipment set not found!", GetName().c_str(), eqset.Guid, index);
+            return;
+        }
+    }
+
+    EquipmentSet& eqslot = m_EquipmentSets[index];
+
+    EquipmentSetUpdateState old_state = eqslot.state;
+
+    eqslot = eqset;
+
+    if (eqset.Guid == 0)
+    {
+        eqslot.Guid = sObjectMgr->GenerateEquipmentSetGuid();
+
+        WorldPacket data(SMSG_EQUIPMENT_SET_SAVED, 4 + 1);
+        data << uint32(index);
+        data.appendPackGUID(eqslot.Guid);
+        GetSession()->SendPacket(&data);
+    }
+
+    eqslot.state = old_state == EQUIPMENT_SET_NEW ? EQUIPMENT_SET_NEW : EQUIPMENT_SET_CHANGED;
+}
+
+void Player::_SaveEquipmentSets(SQLTransaction& trans)
+{
+    for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end();)
+    {
+        uint32 index = itr->first;
+        EquipmentSet& eqset = itr->second;
+        PreparedStatement* stmt = NULL;
+        uint8 j = 0;
+        switch (eqset.state)
+        {
+            case EQUIPMENT_SET_UNCHANGED:
+                ++itr;
+                break;                                      // nothing do
+            case EQUIPMENT_SET_CHANGED:
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_EQUIP_SET);
+                stmt->setString(j++, eqset.Name.c_str());
+                stmt->setString(j++, eqset.IconName.c_str());
+                stmt->setUInt32(j++, eqset.IgnoreMask);
+                for (uint8 i=0; i<EQUIPMENT_SLOT_END; ++i)
+                    stmt->setUInt32(j++, eqset.Items[i]);
+                stmt->setUInt32(j++, GetGUIDLow());
+                stmt->setUInt64(j++, eqset.Guid);
+                stmt->setUInt32(j, index);
+                trans->Append(stmt);
+                eqset.state = EQUIPMENT_SET_UNCHANGED;
+                ++itr;
+                break;
+            case EQUIPMENT_SET_NEW:
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_EQUIP_SET);
+                stmt->setUInt32(j++, GetGUIDLow());
+                stmt->setUInt64(j++, eqset.Guid);
+                stmt->setUInt32(j++, index);
+                stmt->setString(j++, eqset.Name.c_str());
+                stmt->setString(j++, eqset.IconName.c_str());
+                stmt->setUInt32(j++, eqset.IgnoreMask);
+                for (uint8 i=0; i<EQUIPMENT_SLOT_END; ++i)
+                    stmt->setUInt32(j++, eqset.Items[i]);
+                trans->Append(stmt);
+                eqset.state = EQUIPMENT_SET_UNCHANGED;
+                ++itr;
+                break;
+            case EQUIPMENT_SET_DELETED:
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_EQUIP_SET);
+                stmt->setUInt64(0, eqset.Guid);
+                trans->Append(stmt);
+                m_EquipmentSets.erase(itr++);
+                break;
+        }
+    }
+}
+
+void Player::_SaveBGData(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+    /* guid, bgInstanceID, bgTeam, x, y, z, o, map, taxi[0], taxi[1], mountSpell */
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PLAYER_BGDATA);
+    stmt->setUInt32(0, GetGUIDLow());
+    stmt->setUInt32(1, m_bgData.bgInstanceID);
+    stmt->setUInt16(2, m_bgData.bgTeam);
+    stmt->setFloat (3, m_bgData.joinPos.GetPositionX());
+    stmt->setFloat (4, m_bgData.joinPos.GetPositionY());
+    stmt->setFloat (5, m_bgData.joinPos.GetPositionZ());
+    stmt->setFloat (6, m_bgData.joinPos.GetOrientation());
+    stmt->setUInt16(7, m_bgData.joinPos.GetMapId());
+    stmt->setUInt16(8, m_bgData.taxiPath[0]);
+    stmt->setUInt16(9, m_bgData.taxiPath[1]);
+    stmt->setUInt16(10, m_bgData.mountSpell);
+    trans->Append(stmt);
+}
+
+void Player::DeleteEquipmentSet(uint64 setGuid)
+{
+    for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
+    {
+        if (itr->second.Guid == setGuid)
+        {
+            if (itr->second.state == EQUIPMENT_SET_NEW)
+                m_EquipmentSets.erase(itr);
+            else
+                itr->second.state = EQUIPMENT_SET_DELETED;
+            break;
+        }
+    }
+}
+
+void Player::RemoveAtLoginFlag(AtLoginFlags flags, bool persist /*= false*/)
+{
+    m_atLoginFlags &= ~flags;
+
+    if (persist)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_REM_AT_LOGIN_FLAG);
+
+        stmt->setUInt16(0, uint16(flags));
+        stmt->setUInt32(1, GetGUIDLow());
+
+        CharacterDatabase.Execute(stmt);
+    }
+}
+
+void Player::SendClearCooldown(uint32 spell_id, Unit* target)
+{
+    WorldPacket data(SMSG_CLEAR_COOLDOWN, 4+8);
+    data << uint32(spell_id);
+    data << uint64(target->GetGUID());
+    SendDirectMessage(&data);
+}
+
+void Player::SendClearAllCooldowns(Unit* target)
+{
+    uint32 spellCount = m_spellCooldowns.size();
+    ObjectGuid guid = target ? target->GetGUID() : 0;
+
+    WorldPacket data(SMSG_CLEAR_COOLDOWNS, 4+8);
+    data.WriteBit(guid[1]);
+    data.WriteBit(guid[3]);
+    data.WriteBit(guid[6]);
+    data.WriteBits(spellCount, 24); // Spell Count
+    data.WriteBit(guid[7]);
+    data.WriteBit(guid[5]);
+    data.WriteBit(guid[2]);
+    data.WriteBit(guid[4]);
+    data.WriteBit(guid[0]);
+
+    data.FlushBits();
+
+    data.WriteByteSeq(guid[7]);
+    data.WriteByteSeq(guid[2]);
+    data.WriteByteSeq(guid[4]);
+    data.WriteByteSeq(guid[5]);
+    data.WriteByteSeq(guid[1]);
+    data.WriteByteSeq(guid[3]);
+    for (SpellCooldowns::const_iterator itr = m_spellCooldowns.begin(); itr != m_spellCooldowns.end(); ++itr)
+        data << uint32(itr->first); // Spell ID
+
+    data.WriteByteSeq(guid[0]);
+    data.WriteByteSeq(guid[6]);
+
+    SendDirectMessage(&data);
+}
+
+void Player::ResetMap()
+{
+    // this may be called during Map::Update
+    // after decrement+unlink, ++m_mapRefIter will continue correctly
+    // when the first element of the list is being removed
+    // nocheck_prev will return the padding element of the RefManager
+    // instead of NULL in the case of prev
+    GetMap()->UpdateIteratorBack(this);
+    Unit::ResetMap();
+    GetMapRef().unlink();
+}
+
+void Player::SetMap(Map* map)
+{
+    Unit::SetMap(map);
+    m_mapRef.link(map, this);
+}
+
+void Player::_LoadGlyphs(PreparedQueryResult result)
+{
+    // SELECT spec, glyph1, glyph2, glyph3, glyph4, glyph5, glyph6, glyph7, glyph8, glyph9 FROM character_glyphs WHERE guid = '%u'
+    if (!result)
+        return;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint8 spec = fields[0].GetUInt8();
+        if (spec >= GetSpecsCount())
+            continue;
+
+        for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
+            _talentMgr->SpecInfo[spec].Glyphs[i] = fields[i + 1].GetUInt16();
+    }
+    while (result->NextRow());
+}
+
+void Player::_SaveGlyphs(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
+    stmt->setUInt32(0, GetGUIDLow());
+    trans->Append(stmt);
+
+
+    for (uint8 spec = 0; spec < GetSpecsCount(); ++spec)
+    {
+        uint8 index = 0;
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_GLYPHS);
+        stmt->setUInt32(index++, GetGUIDLow());
+
+        stmt->setUInt8(index++, spec);
+
+        for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
+            stmt->setUInt16(index++, uint16(GetGlyph(spec, i)));
+
+        trans->Append(stmt);
+    }
+}
+
+void Player::_LoadTalents(PreparedQueryResult result)
+{
+    // SetPQuery(PLAYER_LOGIN_QUERY_LOADTALENTS, "SELECT spell, spec FROM character_talent WHERE guid = '%u'", GUID_LOPART(m_guid));
+    if (result)
+    {
+        do
+            AddTalent((*result)[0].GetUInt32(), (*result)[1].GetUInt8(), false);
+        while (result->NextRow());
+    }
+}
+
+void Player::_SaveTalents(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = NULL;
+
+    for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
+    {
+        for (PlayerTalentMap::iterator itr = GetTalentMap(i)->begin(); itr != GetTalentMap(i)->end();)
+        {
+            if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->state == PLAYERSPELL_CHANGED)
+            {
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT_BY_SPELL_SPEC);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt32(1, itr->first);
+                stmt->setUInt8(2, itr->second->spec);
+                trans->Append(stmt);
+            }
+
+            if (itr->second->state == PLAYERSPELL_NEW || itr->second->state == PLAYERSPELL_CHANGED)
+            {
+                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_TALENT);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt32(1, itr->first);
+                stmt->setUInt8(2, itr->second->spec);
+                trans->Append(stmt);
+            }
+
+            if (itr->second->state == PLAYERSPELL_REMOVED)
+            {
+                delete itr->second;
+                GetTalentMap(i)->erase(itr++);
+            }
+            else
+            {
+                itr->second->state = PLAYERSPELL_UNCHANGED;
+                ++itr;
+            }
+        }
+    }
+}
+
+void Player::UpdateSpecCount(uint8 count)
+{
+    uint32 curCount = GetSpecsCount();
+    if (curCount == count)
+        return;
+
+    if (GetActiveSpec() >= count)
+        ActivateSpec(0);
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    PreparedStatement* stmt = NULL;
+
+    // Copy spec data
+    if (count > curCount)
+    {
+        _SaveActions(trans); // make sure the button list is cleaned up
+        for (ActionButtonList::iterator itr = m_actionButtons.begin(); itr != m_actionButtons.end(); ++itr)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_ACTION);
+            stmt->setUInt32(0, GetGUIDLow());
+            stmt->setUInt8(1, 1);
+            stmt->setUInt8(2, itr->first);
+            stmt->setUInt32(3, itr->second.GetAction());
+            stmt->setUInt8(4, uint8(itr->second.GetType()));
+            trans->Append(stmt);
+        }
+    }
+    // Delete spec data for removed spec.
+    else if (count < curCount)
+    {
+        _SaveActions(trans);
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION_EXCEPT_SPEC);
+        stmt->setUInt8(0, GetActiveSpec());
+        stmt->setUInt32(1, GetGUIDLow());
+        trans->Append(stmt);
+
+    }
+
+    CharacterDatabase.CommitTransaction(trans);
+
+    SetSpecsCount(count);
+
+    SendTalentsInfoData(false);
+}
+
+void Player::ActivateSpec(uint8 spec)
+{
+    if (GetActiveSpec() == spec)
+        return;
+
+    if (spec > GetSpecsCount())
+        return;
+
+    if (IsNonMeleeSpellCasted(false))
+        InterruptNonMeleeSpells(false);
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    _SaveActions(trans);
+    CharacterDatabase.CommitTransaction(trans);
+
+    // TO-DO: We need more research to know what happens with warlock's reagent
+    if (Pet* pet = GetPet())
+        RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT);
+
+    ClearComboPointHolders();
+    ClearAllReactives();
+    UnsummonAllTotems();
+    ExitVehicle();
+    RemoveAllControlled();
+    /*RemoveAllAurasOnDeath();
+    if (GetPet())
+        GetPet()->RemoveAllAurasOnDeath();*/
+
+    //RemoveAllAuras(GetGUID(), NULL, false, true); // removes too many auras
+    //ExitVehicle(); // should be impossible to switch specs from inside a vehicle..
+
+    // Let client clear his current Actions
+    SendActionButtons(2);
+    // m_actionButtons.clear() is called in the next _LoadActionButtons
+    for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
+    {
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+
+        if (!talentInfo)
+            continue;
+
+        TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
+
+        if (!talentTabInfo)
+            continue;
+
+        // unlearn only talents for character class
+        // some spell learned by one class as normal spells or know at creation but another class learn it as talent,
+        // to prevent unexpected lost normal learned spell skip another class talents
+        if ((getClassMask() & talentTabInfo->ClassMask) == 0)
+            continue;
+
+        for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+        {
+            // skip non-existant talent ranks
+            if (talentInfo->RankID[rank] == 0)
+                continue;
+            removeSpell(talentInfo->RankID[rank], true); // removes the talent, and all dependant, learned, and chained spells..
+            if (const SpellInfo* _spellEntry = sSpellMgr->GetSpellInfo(talentInfo->RankID[rank]))
+                for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)                  // search through the SpellInfo for valid trigger spells
+                    if (_spellEntry->Effects[i].TriggerSpell > 0 && _spellEntry->Effects[i].Effect == SPELL_EFFECT_LEARN_SPELL)
+                        removeSpell(_spellEntry->Effects[i].TriggerSpell, true); // and remove any spells that the talent teaches
+            // if this talent rank can be found in the PlayerTalentMap, mark the talent as removed so it gets deleted
+            //PlayerTalentMap::iterator plrTalent = m_talents[m_activeSpec]->find(talentInfo->RankID[rank]);
+            //if (plrTalent != m_talents[m_activeSpec]->end())
+            //    plrTalent->second->state = PLAYERSPELL_REMOVED;
+        }
+    }
+
+    // Remove spec specific spells
+    for (uint32 i = 0; i < MAX_TALENT_TABS; ++i)
+    {
+        std::vector<uint32> const* specSpells = GetTalentTreePrimarySpells(GetTalentTabPages(getClass())[i]);
+        if (specSpells)
+            for (size_t i = 0; i < specSpells->size(); ++i)
+                removeSpell(specSpells->at(i), true);
+
+        TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(GetTalentTabPages(getClass())[i]);
+        for (uint32 j = 0; j < MAX_MASTERY_SPELLS; ++j)
+            if (uint32 mastery = talentTabInfo->MasterySpells[j])
+                removeSpell(mastery, true);
+    }
+
+    // set glyphs
+    for (uint8 slot = 0; slot < MAX_GLYPH_SLOT_INDEX; ++slot)
+        // remove secondary glyph
+        if (uint32 oldglyph = GetGlyph(GetActiveSpec(), slot))
+            if (GlyphPropertiesEntry const* old_gp = sGlyphPropertiesStore.LookupEntry(oldglyph))
+                RemoveAurasDueToSpell(old_gp->SpellId);
+
+    SetActiveSpec(spec);
+    uint32 spentTalents = 0;
+
+    for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
+    {
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+
+        if (!talentInfo)
+            continue;
+
+        TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
+
+        if (!talentTabInfo)
+            continue;
+
+        // learn only talents for character class
+        if ((getClassMask() & talentTabInfo->ClassMask) == 0)
+            continue;
+
+        // learn highest talent rank that exists in newly activated spec
+        for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+        {
+            // skip non-existant talent ranks
+            if (talentInfo->RankID[rank] == 0)
+                continue;
+            // if the talent can be found in the newly activated PlayerTalentMap
+            if (HasTalent(talentInfo->RankID[rank], GetActiveSpec()))
+            {
+                learnSpell(talentInfo->RankID[rank], false); // add the talent to the PlayerSpellMap
+                spentTalents += (rank + 1);                  // increment the spentTalents count
+            }
+        }
+    }
+
+    std::vector<uint32> const* specSpells = GetTalentTreePrimarySpells(GetPrimaryTalentTree(GetActiveSpec()));
+    if (specSpells)
+        for (size_t i = 0; i < specSpells->size(); ++i)
+            learnSpell(specSpells->at(i), false);
+
+    if (IsMasteryLearned())
+        if (TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(GetPrimaryTalentTree(GetActiveSpec())))
+            for (uint32 i = 0; i < MAX_MASTERY_SPELLS; ++i)
+                if (uint32 mastery = talentTabInfo->MasterySpells[i])
+                    learnSpell(mastery, false);
+
+    // set glyphs
+    for (uint8 slot = 0; slot < MAX_GLYPH_SLOT_INDEX; ++slot)
+    {
+        uint32 glyph = GetGlyph(GetActiveSpec(), slot);
+
+        // apply primary glyph
+        if (glyph)
+            if (GlyphPropertiesEntry const* gp = sGlyphPropertiesStore.LookupEntry(glyph))
+                CastSpell(this, gp->SpellId, true);
+
+        SetGlyph(slot, glyph);
+    }
+
+    SetUsedTalentCount(spentTalents);
+    InitTalentForLevel();
+
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_ACTIONS_SPEC);
+        stmt->setUInt32(0, GetGUIDLow());
+        stmt->setUInt8(1, GetActiveSpec());
+        if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
+            _LoadActions(result);
+    }
+
+    SendActionButtons(1);
+
+    Powers pw = getPowerType();
+    if (pw != POWER_MANA)
+        SetPower(POWER_MANA, 0); // Mana must be 0 even if it isn't the active power type.
+
+    SetPower(pw, 0);
+
+    if (!sTalentTabStore.LookupEntry(GetPrimaryTalentTree(GetActiveSpec())))
+        ResetTalents(true);
+
+    UpdateMastery();
+}
+
+void Player::ResetTimeSync()
+{
+    m_timeSyncTimer = 0;
+    m_timeSyncClient = 0;
+    m_timeSyncServer = getMSTime();
+}
+
+void Player::SendTimeSync()
+{
+    m_timeSyncQueue.push(m_movementCounter++);
+
+    WorldPacket data(SMSG_TIME_SYNC_REQ, 4);
+    data << uint32(m_timeSyncQueue.back());
+    GetSession()->SendPacket(&data);
+
+    // Schedule next sync in 10 sec
+    m_timeSyncTimer = 10000;
+    m_timeSyncServer = getMSTime();
+
+    if (m_timeSyncQueue.size() > 3)
+        sLog->outError(LOG_FILTER_NETWORKIO, "Not received CMSG_TIME_SYNC_RESP for over 30 seconds from player %u (%s), possible cheater", GetGUIDLow(), GetName().c_str());
+
+}
+
+void Player::SetReputation(uint32 factionentry, uint32 value)
+{
+    GetReputationMgr().SetReputation(sFactionStore.LookupEntry(factionentry), value);
+}
+uint32 Player::GetReputation(uint32 factionentry) const
+{
+    return GetReputationMgr().GetReputation(sFactionStore.LookupEntry(factionentry));
+}
+
+std::string Player::GetGuildName()
+{
+    return GetGuildId() ? sGuildMgr->GetGuildById(GetGuildId())->GetName() : "";
+}
+
+void Player::SendDuelCountdown(uint32 counter)
+{
+    WorldPacket data(SMSG_DUEL_COUNTDOWN, 4);
+    data << uint32(counter);                                // seconds
+    GetSession()->SendPacket(&data);
+}
+
+void Player::AddRefundReference(uint32 it)
+{
+    m_refundableItems.insert(it);
+}
+
+void Player::DeleteRefundReference(uint32 it)
+{
+    std::set<uint32>::iterator itr = m_refundableItems.find(it);
+    if (itr != m_refundableItems.end())
+    {
+        m_refundableItems.erase(itr);
+    }
+}
+
+void Player::SendRefundInfo(Item* item)
+{
+    // This function call unsets ITEM_FLAGS_REFUNDABLE if played time is over 2 hours.
+    item->UpdatePlayedTime(this);
+
+    if (!item->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_REFUNDABLE))
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Item refund: item not refundable!");
+        return;
+    }
+
+    if (GetGUIDLow() != item->GetRefundRecipient()) // Formerly refundable item got traded
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Item refund: item was traded!");
+        item->SetNotRefundable(this);
+        return;
+    }
+
+    ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(item->GetPaidExtendedCost());
+    if (!iece)
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Item refund: cannot find extendedcost data.");
+        return;
+    }
+
+    ObjectGuid guid = item->GetGUID();
+    WorldPacket data(SMSG_ITEM_REFUND_INFO_RESPONSE, 8+4+4+4+4*4+4*4+4+4);
+    data.WriteBit(guid[3]);
+    data.WriteBit(guid[5]);
+    data.WriteBit(guid[7]);
+    data.WriteBit(guid[6]);
+    data.WriteBit(guid[2]);
+    data.WriteBit(guid[4]);
+    data.WriteBit(guid[0]);
+    data.WriteBit(guid[1]);
+    data.FlushBits();
+
+    data.WriteByteSeq(guid[7]);
+    data << uint32(GetTotalPlayedTime() - item->GetPlayedTime());
+    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)                             // item cost data
+    {
+        data << uint32(iece->RequiredItemCount[i]);
+        data << uint32(iece->RequiredItem[i]);
+    }
+
+    data.WriteByteSeq(guid[6]);
+    data.WriteByteSeq(guid[4]);
+    data.WriteByteSeq(guid[3]);
+    data.WriteByteSeq(guid[2]);
+    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)                       // currency cost data
+    {
+        if (iece->RequirementFlags & (ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_1 << i))
+        {
+            data << uint32(0);
+            data << uint32(0);
+            continue;
+        } 
+
+        CurrencyTypesEntry const* currencyType = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
+        uint32 precision = (currencyType && currencyType->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
+
+        data << uint32(iece->RequiredCurrencyCount[i] / precision);
+        data << uint32(iece->RequiredCurrency[i]);
+    }
+
+    data.WriteByteSeq(guid[1]);
+    data.WriteByteSeq(guid[5]);
+    data << uint32(0);
+    data.WriteByteSeq(guid[0]);
+    data << uint32(item->GetPaidMoney());               // money cost
+    GetSession()->SendPacket(&data);
+}
+
+bool Player::AddItem(uint32 itemId, uint32 count)
+{
+    uint32 noSpaceForCount = 0;
+    ItemPosCountVec dest;
+    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &noSpaceForCount);
+    if (msg != EQUIP_ERR_OK)
+        count -= noSpaceForCount;
+
+    if (count == 0 || dest.empty())
+    {
+        // -- TODO: Send to mailbox if no space
+        ChatHandler(GetSession()).PSendSysMessage("You don't have any space in your bags.");
+        return false;
+    }
+
+    Item* item = StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+    if (item)
+        SendNewItem(item, count, true, false);
+    else
+        return false;
+    return true;
+}
+
+void Player::SendItemRefundResult(Item* item, ItemExtendedCostEntry const* iece, uint8 error)
+{
+    ObjectGuid guid = item->GetGUID();
+    WorldPacket data(SMSG_ITEM_REFUND_RESULT, 1 + 1 + 8 + 4*8 + 4 + 4*8 + 1);
+    data.WriteBit(guid[4]);
+    data.WriteBit(guid[5]);
+    data.WriteBit(guid[1]);
+    data.WriteBit(guid[6]);
+    data.WriteBit(guid[7]);
+    data.WriteBit(guid[0]);
+    data.WriteBit(guid[3]);
+    data.WriteBit(guid[2]);
+    data.WriteBit(!error);
+    data.WriteBit(item->GetPaidMoney() > 0);
+    data.FlushBits();
+    if (!error)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
+        {
+            if (iece->RequirementFlags & (ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_1 << i))
+            {
+                data << uint32(0);
+                data << uint32(0);
+                continue;
+            } 
+
+            CurrencyTypesEntry const* currencyType = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
+            uint32 precision = (currencyType && currencyType->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
+
+            data << uint32(iece->RequiredCurrencyCount[i] / precision);
+            data << uint32(iece->RequiredCurrency[i]);
+        }
+
+        data << uint32(item->GetPaidMoney());               // money cost
+
+        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i) // item cost data
+        {
+            data << uint32(iece->RequiredItemCount[i]);
+            data << uint32(iece->RequiredItem[i]);
+        }
+    }
+
+    data.WriteByteSeq(guid[0]);
+    data.WriteByteSeq(guid[3]);
+    data.WriteByteSeq(guid[1]);
+    data.WriteByteSeq(guid[6]);
+    data.WriteByteSeq(guid[4]);
+    data.WriteByteSeq(guid[2]);
+    data.WriteByteSeq(guid[7]);
+    data.WriteByteSeq(guid[5]);
+
+    data << uint8(error);                              // error code
+    GetSession()->SendPacket(&data);
+}
+
+void Player::RefundItem(Item* item)
+{
+    if (!item->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_REFUNDABLE))
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Item refund: item not refundable!");
+        return;
+    }
+
+    if (item->IsRefundExpired())    // item refund has expired
+    {
+        item->SetNotRefundable(this);
+        SendItemRefundResult(item, NULL, 10);
+        return;
+    }
+
+    if (GetGUIDLow() != item->GetRefundRecipient()) // Formerly refundable item got traded
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Item refund: item was traded!");
+        item->SetNotRefundable(this);
+        return;
+    }
+
+    ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(item->GetPaidExtendedCost());
+    if (!iece)
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Item refund: cannot find extendedcost data.");
+        return;
+    }
+
+    bool store_error = false;
+    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
+    {
+        uint32 count = iece->RequiredItemCount[i];
+        uint32 itemid = iece->RequiredItem[i];
+
+        if (count && itemid)
+        {
+            ItemPosCountVec dest;
+            InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemid, count);
+            if (msg != EQUIP_ERR_OK)
+            {
+                store_error = true;
+                break;
+            }
+         }
+    }
+
+    if (store_error)
+    {
+        SendItemRefundResult(item, iece, 10);
+        return;
+    }
+
+    SendItemRefundResult(item, iece, 0);
+
+    uint32 moneyRefund = item->GetPaidMoney();  // item-> will be invalidated in DestroyItem
+
+    // Save all relevant data to DB to prevent desynchronisation exploits
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    // Delete any references to the refund data
+    item->SetNotRefundable(this, true, &trans);
+
+    // Destroy item
+    DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+
+    // Grant back extendedcost items
+    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
+    {
+        uint32 count = iece->RequiredItemCount[i];
+        uint32 itemid = iece->RequiredItem[i];
+        if (count && itemid)
+        {
+            ItemPosCountVec dest;
+            InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemid, count);
+            ASSERT(msg == EQUIP_ERR_OK) /// Already checked before
+            Item* it = StoreNewItem(dest, itemid, true);
+            SendNewItem(it, count, true, false, true);
+        }
+    }
+
+    // Grant back currencies
+    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
+    {
+        if (iece->RequirementFlags & (ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_1 << i))
+            continue; 
+
+        uint32 count = iece->RequiredCurrencyCount[i];
+        uint32 currencyid = iece->RequiredCurrency[i];
+        if (count && currencyid)
+            ModifyCurrency(currencyid, count, true, true, true);
+    }
+
+    // Grant back money
+    if (moneyRefund)
+        ModifyMoney(moneyRefund); // Saved in SaveInventoryAndGoldToDB
+
+    SaveInventoryAndGoldToDB(trans);
+
+    CharacterDatabase.CommitTransaction(trans);
+	
+    // we save the data here to prevent spamming
+    sAnticheatMgr->SavePlayerData(this);
+
+    // in this way we prevent to spam the db by each report made!
+    // sAnticheatMgr->SavePlayerData(this);
+}
+
+void Player::SetRandomWinner(bool isWinner)
+{
+    m_IsBGRandomWinner = isWinner;
+    if (m_IsBGRandomWinner)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_BATTLEGROUND_RANDOM);
+
+        stmt->setUInt32(0, GetGUIDLow());
+
+        CharacterDatabase.Execute(stmt);
+    }
+}
+
+void Player::_LoadRandomBGStatus(PreparedQueryResult result)
+{
+    //QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM character_battleground_random WHERE guid = '%u'", GetGUIDLow());
+
+    if (result)
+        m_IsBGRandomWinner = true;
+}
+
+void Player::_LoadPets(SQLQueryHolder *holder)
+{
+    PreparedQueryResult result = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_PETS);
+    if(!result)
+        return;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    do
+    {
+        Field* fields = result->Fetch();
+        PetData* t_Pet = new PetData();
+
+        t_Pet->id                  = fields[0].GetUInt32();
+        t_Pet->entry               = fields[1].GetUInt32();
+        t_Pet->owner               = fields[2].GetUInt32();
+        t_Pet->modelid             = fields[3].GetUInt32();
+        t_Pet->level               = fields[4].GetUInt16();
+        t_Pet->exp                 = fields[5].GetUInt32();
+        t_Pet->reactstate          = ReactStates(fields[6].GetUInt8());
+        t_Pet->slot                = fields[7].GetUInt8();
+        t_Pet->name                = fields[8].GetString();
+        t_Pet->renamed             = fields[9].GetBool();
+        t_Pet->curhealth           = fields[10].GetUInt32();
+        t_Pet->curmana             = fields[11].GetUInt32();
+        t_Pet->abdata              = fields[12].GetString();
+        t_Pet->savetime            = fields[13].GetUInt32();
+        t_Pet->summon_spell_id     = fields[14].GetUInt32();
+        t_Pet->pet_type            = PetType(fields[15].GetUInt8());
+        t_Pet->state               = PET_STATE_ALIVE;
+        t_Pet->_state              = DATA_UNCHANGED;
+
+        m_Stables[t_Pet->id]        = t_Pet;
+    }
+    while (result->NextRow());
+
+    result = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_PETS_SPELLS);
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+
+            uint32 guid         = fields[0].GetUInt32();
+            uint32 spellID      = fields[1].GetUInt32();
+            uint32 active       = fields[2].GetUInt8();
+
+            if(m_Stables[guid])
+            {
+                PetSpellData t_spell;
+
+                t_spell.active = ActiveStates(active);
+                t_spell.type   = PETSPELL_NONE;
+                t_spell._state = DATA_LOADED;
+                t_spell.Id     = spellID;
+                m_Stables[guid]->m_learnSpells.push_back(t_spell);
+            }
+            else
+                sLog->outError(LOG_FILTER_PLAYER, "Loading PetSpells (GUID: %u) Pet doesn't exist on PlayerSlots Clean Up?.", guid);
+        }
+        while (result->NextRow());
+    }
+
+    result = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_PETS_AURA);
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            PetAuraData t_aura;
+
+            uint32 guid             = fields[0].GetUInt32();
+
+            if(m_Stables[guid])
+            {
+                t_aura.caster_guid      = fields[1].GetUInt64();
+                t_aura.spellid          = fields[2].GetUInt32();
+                t_aura.effmask          = fields[3].GetUInt8();
+                t_aura.recalculatemask  = fields[4].GetUInt8();
+                t_aura.stackcount       = fields[5].GetUInt8();
+                t_aura.damage[0]        = fields[6].GetInt32();
+                t_aura.damage[1]        = fields[7].GetInt32();
+                t_aura.damage[2]        = fields[8].GetInt32();
+                t_aura.baseDamage[0]    = fields[9].GetInt32();
+                t_aura.baseDamage[1]    = fields[10].GetInt32();
+                t_aura.baseDamage[2]    = fields[11].GetInt32();
+                t_aura.maxduration      = fields[12].GetInt32();
+                t_aura.remaintime       = fields[13].GetInt32();
+                t_aura.remaincharges    = fields[14].GetUInt8();
+
+                m_Stables[guid]->m_auras.push_back(t_aura);
+            }
+            else
+                sLog->outError(LOG_FILTER_PLAYER, "Loading PetCooldowns (GUID: %u) Pet doesn't exist on PlayerSlots Clean Up?.", guid);
+        }
+        while (result->NextRow());
+    }
+
+    result = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_PETS_COOLDOWN);
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+
+            uint32 guid             = fields[0].GetUInt32();
+            uint32 spellid          = fields[1].GetUInt32();
+
+            if(m_Stables[guid])
+            {
+                PetSpellCooldownData t_cooldown;
+                t_cooldown._state       = DATA_LOADED;
+                t_cooldown.time         = fields[2].GetUInt32();
+
+                m_Stables[guid]->m_spellscooldown[spellid] = t_cooldown;
+            }
+            else
+                sLog->outError(LOG_FILTER_PLAYER, "Loading PetCooldown (GUID: %u) Pet doesn't exist on PlayerSlots Clean Up?.", guid);
+        }
+        while (result->NextRow());
+    }
+
+}
+
+float Player::GetAverageItemLevel()
+{
+    float sum = 0;
+    uint32 count = 0;
+
+    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        // don't check tabard, ranged, offhand or shirt
+        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_OFFHAND || i == EQUIPMENT_SLOT_BODY)
+            continue;
+
+        if (m_items[i] && m_items[i]->GetTemplate())
+            sum += m_items[i]->GetTemplate()->GetItemLevelIncludingQuality();
+
+        ++count;
+    }
+
+    return ((float)sum) / count;
+}
+
+void Player::_LoadInstanceTimeRestrictions(PreparedQueryResult result)
+{
+    if (!result)
+        return;
+
+    do
+    {
+        Field* fields = result->Fetch();
+        _instanceResetTimes.insert(InstanceTimeMap::value_type(fields[0].GetUInt32(), fields[1].GetUInt64()));
+    } while (result->NextRow());
+}
+
+void Player::_SaveInstanceTimeRestrictions(SQLTransaction& trans)
+{
+    if (_instanceResetTimes.empty())
+        return;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ACCOUNT_INSTANCE_LOCK_TIMES);
+    stmt->setUInt32(0, GetSession()->GetAccountId());
+    trans->Append(stmt);
+
+    for (InstanceTimeMap::const_iterator itr = _instanceResetTimes.begin(); itr != _instanceResetTimes.end(); ++itr)
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ACCOUNT_INSTANCE_LOCK_TIMES);
+        stmt->setUInt32(0, GetSession()->GetAccountId());
+        stmt->setUInt32(1, itr->first);
+        stmt->setUInt64(2, itr->second);
+        trans->Append(stmt);
+    }
+}
+
+bool Player::IsInWhisperWhiteList(uint64 guid)
+{
+    for (WhisperListContainer::const_iterator itr = WhisperList.begin(); itr != WhisperList.end(); ++itr)
+    {
+        if (*itr == guid)
+            return true;
+    }
+    return false;
+}
+
+void Player::UpdateArmorSpecialization()
+{
+    // Remove Auras  with SPELL_ATTR8_ARMOR_SPECIALIZATION
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        SpellInfo const* spell = iter->second->GetBase()->GetSpellInfo();
+        if (spell->AttributesEx8 & SPELL_ATTR8_ARMOR_SPECIALIZATION)
+            RemoveAura(iter);
+        else
+            ++iter;
+    }
+
+    for (uint8 id = 0; id < MAX_ARMOR_SPECIALIZATION_IDS; ++id)
+        if (HasSpell(ArmorSpecializationIds[id]))
+        {
+            CastSpell(this, ArmorSpecializationIds[id], TRIGGERED_FULL_MASK);
+            break;
+        }
+}
+
+uint8 Player::GetNextVoidStorageFreeSlot() const
+{
+    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
+        if (!_voidStorageItems[i]) // unused item
+            return i;
+
+    return VOID_STORAGE_MAX_SLOT;
+}
+
+uint8 Player::GetNumOfVoidStorageFreeSlots() const
+{
+    uint8 count = 0;
+
+    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
+        if (!_voidStorageItems[i])
+            count++;
+
+    return count;
+}
+
+uint8 Player::AddVoidStorageItem(const VoidStorageItem& item)
+{
+    int8 slot = GetNextVoidStorageFreeSlot();
+
+    if (slot >= VOID_STORAGE_MAX_SLOT)
+    {
+        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_FULL);
+        return 255;
+    }
+
+    _voidStorageItems[slot] = new VoidStorageItem(item.ItemId, item.ItemEntry,
+        item.CreatorGuid, item.ItemRandomPropertyId, item.ItemSuffixFactor);
+    return slot;
+}
+
+void Player::AddVoidStorageItemAtSlot(uint8 slot, const VoidStorageItem& item)
+{
+    if (slot >= VOID_STORAGE_MAX_SLOT)
+    {
+        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_FULL);
+        return;
+    }
+
+    if (_voidStorageItems[slot])
+    {
+        sLog->outError(LOG_FILTER_GENERAL, "Player::AddVoidStorageItemAtSlot - Player (GUID: %u, name: %s) tried to add an item to an used slot (item id: " UI64FMTD ", entry: %u, slot: %u).", GetGUIDLow(), GetName().c_str(), _voidStorageItems[slot]->ItemId, _voidStorageItems[slot]->ItemEntry, slot);
+        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
+        return;
+    }
+
+    _voidStorageItems[slot] = new VoidStorageItem(item.ItemId, item.ItemId,
+        item.CreatorGuid, item.ItemRandomPropertyId, item.ItemSuffixFactor);
+}
+
+void Player::DeleteVoidStorageItem(uint8 slot)
+{
+    if (slot >= VOID_STORAGE_MAX_SLOT)
+    {
+        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
+        return;
+    }
+
+    delete _voidStorageItems[slot];
+    _voidStorageItems[slot] = NULL;
+}
+
+bool Player::SwapVoidStorageItem(uint8 oldSlot, uint8 newSlot)
+{
+    if (oldSlot >= VOID_STORAGE_MAX_SLOT || newSlot >= VOID_STORAGE_MAX_SLOT || oldSlot == newSlot)
+        return false;
+
+    std::swap(_voidStorageItems[newSlot], _voidStorageItems[oldSlot]);
+    return true;
+}
+
+VoidStorageItem* Player::GetVoidStorageItem(uint8 slot) const
+{
+    if (slot >= VOID_STORAGE_MAX_SLOT)
+    {
+        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
+        return NULL;
+    }
+
+    return _voidStorageItems[slot];
+}
+
+VoidStorageItem* Player::GetVoidStorageItem(uint64 id, uint8& slot) const
+{
+    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
+    {
+        if (_voidStorageItems[i] && _voidStorageItems[i]->ItemId == id)
+        {
+            slot = i;
+            return _voidStorageItems[i];
+        }
+    }
+
+    return NULL;
+}
+
+void Player::SendMovementSetCanTransitionBetweenSwimAndFly(bool apply)
+{
+    WorldPacket data(apply ?
+        SMSG_MOVE_SET_CAN_FLY_TO_SWIM :
+        SMSG_MOVE_UNSET_CAN_FLY_TO_SWIM, 12);
+    data.append(GetPackGUID());
+    data << uint32(0);          //! movement counter
+    SendDirectMessage(&data);
+}
+
+void Player::SendMovementSetCollisionHeight(float height)
+{
+    m_movement_ack[ACK_COLLISION_HEIGHT] = m_movementCounter;
+
+    MovementInfo info = MovementInfo(m_movementInfo);
+    info.ackCount = m_movementCounter++;
+    info.guid = GetGUID();
+    info.height = height;
+
+    Movement::PacketSender(this, SMSG_MOVE_SET_COLLISION_HEIGHT, SMSG_MOVE_SET_COLLISION_HEIGHT, &info, false, false).Send();
+}
+
+Guild* Player::GetGuild()
+{
+    uint32 guildId = GetGuildId();
+    return guildId ? sGuildMgr->GetGuildById(guildId) : NULL;
+}
+
+Pet* Player::SummonPet(uint32 entry, float x, float y, float z, float ang, PetType petType, uint32 duration)
+{
+    Pet* pet = new Pet(this, petType);
+    // petentry == 0 for hunter "call pet" (current pet summoned if any)
+    if (!entry)
+    {
+        delete pet;
+        return NULL;
+    }
+
+    PetData* data = GetPetDatabyEntry(entry);
+    if (data && petType == SUMMON_PET && pet->LoadPet(this,data))
+    {
+        // Remove Demonic Sacrifice auras (known pet)
+        Unit::AuraEffectList const& auraClassScripts = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+        for (Unit::AuraEffectList::const_iterator itr = auraClassScripts.begin(); itr != auraClassScripts.end();)
+        {
+            if ((*itr)->GetMiscValue() == 2228)
+            {
+                RemoveAurasDueToSpell((*itr)->GetId());
+                itr = auraClassScripts.begin();
+            }
+            else
+                ++itr;
+        }
+
+        if (duration > 0)
+            pet->SetDuration(duration);
+
+        return NULL;
+    }
+
+    pet->Relocate(x, y, z, ang);
+    if (!pet->IsPositionValid())
+    {
+        sLog->outError(LOG_FILTER_GENERAL, "Pet (guidlow %d, entry %d) not summoned. Suggested coordinates isn't valid (X: %f Y: %f)", pet->GetGUIDLow(), pet->GetEntry(), pet->GetPositionX(), pet->GetPositionY());
+        delete pet;
+        return NULL;
+    }
+
+    Map* map = GetMap();
+    uint32 pet_number = sObjectMgr->GeneratePetNumber();
+    if (!pet->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_PET), map, GetPhaseMask(), entry, pet_number))
+    {
+        sLog->outError(LOG_FILTER_GENERAL, "no such creature entry %u", entry);
+        delete pet;
+        return NULL;
+    }
+
+    pet->SetCreatorGUID(GetGUID());
+    pet->SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, getFaction());
+
+    pet->setPowerType(POWER_MANA);
+    pet->SetUInt32Value(UNIT_NPC_FLAGS, 0);
+    pet->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+    pet->InitStatsForLevel(getLevel());
+
+    switch (petType)
+    {
+        case SUMMON_PET:
+            // this enables pet details window (Shift+P)
+            pet->GetCharmInfo()->SetPetNumber(pet_number, true);
+            if (!pet->IsPetGhoul())
+                pet->SetUInt32Value(UNIT_FIELD_BYTES_0, 2048);
+            pet->SetUInt32Value(UNIT_FIELD_PETEXPERIENCE, 0);
+            pet->SetUInt32Value(UNIT_FIELD_PETNEXTLEVELEXP, 1000);
+            pet->SetFullHealth();
+            pet->SetPower(POWER_MANA, pet->GetMaxPower(POWER_MANA));
+            pet->SetUInt32Value(UNIT_FIELD_PET_NAME_TIMESTAMP, uint32(time(NULL))); // cast can't be helped in this case
+            break;
+        default:
+            break;
+    }
+
+    SetMinion(pet, true, PET_SLOT_OTHER_PET);
+
+    map->AddToMap(pet->ToCreature());
+
+    switch (petType)
+    {
+        case SUMMON_PET:
+            pet->InitPetCreateSpells();
+            pet->InitTalentForLevel();
+            pet->SavePet(PET_SLOT_ACTUAL_PET_SLOT);
+            PetSpellInitialize();
+            break;
+        default:
+            break;
+    }
+
+    if (petType == SUMMON_PET)
+    {
+        // Remove Demonic Sacrifice auras (known pet)
+        Unit::AuraEffectList const& auraClassScripts = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+        for (Unit::AuraEffectList::const_iterator itr = auraClassScripts.begin(); itr != auraClassScripts.end();)
+        {
+            if ((*itr)->GetMiscValue() == 2228)
+            {
+                RemoveAurasDueToSpell((*itr)->GetId());
+                itr = auraClassScripts.begin();
+            }
+            else
+                ++itr;
+        }
+    }
+
+    if (duration > 0)
+        pet->SetDuration(duration);
+
+    //ObjectAccessor::UpdateObjectVisibility(pet);
+
+    return pet;
+}
+
+bool Player::HavePetSummoned(uint32 petEntry)
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        if ((*itr)->GetEntry() == petEntry)
+            return true;
+
+    return false;
+}
+
+bool Player::IsMasteryLearned()
+{
+    uint32 spell_id = 0;
+
+    switch (getClass())
+    {
+        case CLASS_WARRIOR:
+        {
+            spell_id = 86479;
+            break;
+        }
+        case CLASS_PALADIN:
+        {
+            spell_id = 86474;
+            break;
+        }
+        case CLASS_HUNTER:
+        {
+            spell_id = 86472;
+            break;
+        }
+        case CLASS_ROGUE:
+        {
+            spell_id = 86476;
+            break;
+        }
+        case CLASS_PRIEST:
+        {
+            spell_id = 86475;
+            break;
+        }
+        case CLASS_DEATH_KNIGHT:
+        {
+            spell_id = 86471;
+            break;
+        }
+        case CLASS_SHAMAN:
+        {
+            spell_id = 86477;
+            break;
+        }
+        case CLASS_MAGE:
+        {
+            spell_id = 86473;
+            break;
+        }
+        case CLASS_WARLOCK:
+        {
+            spell_id = 86478;
+            break;
+        }
+        case CLASS_DRUID:
+        {
+            spell_id = 86470;
+            break;
+        }
+        default:
+            return false;
+    }
+
+    return HasAura(spell_id);
+}
+
+void Player::ReadMovementInfo(WorldPacket& data, MovementInfo* mi, Movement::ExtraMovementStatusElement* extras /*= NULL*/)
+{
+	MovementStatusElements const* sequence = GetMovementStatusElementsSequence(data.GetOpcode());
+	if (!sequence)
+	{
+		sLog->outError(LOG_FILTER_NETWORKIO, "Player::ReadMovementInfo: No movement sequence found for opcode %s", GetOpcodeNameForLogging(data.GetOpcode()).c_str());
+		return;
+	}
+
+	bool hasMovementFlags = false;
+	bool hasMovementFlags2 = false;
+	bool hasTimestamp = false;
+	bool hasOrientation = false;
+	bool hasTransportData = false;
+	bool hasTransportTime2 = false;
+	bool hasTransportTime3 = false;
+	bool hasPitch = false;
+	bool hasFallData = false;
+	bool hasFallDirection = false;
+	bool hasSplineElevation = false;
+
+	ObjectGuid guid; //Not 100% Sure about this
+	ObjectGuid tguid; //Not 100% Sure about this
+
+	for (; *sequence != MSEEnd; ++sequence)
+	{
+		MovementStatusElements const& element = *sequence;
+
+		switch (element)
+		{
+		case MSEHasGuidByte0:
+		case MSEHasGuidByte1:
+		case MSEHasGuidByte2:
+		case MSEHasGuidByte3:
+		case MSEHasGuidByte4:
+		case MSEHasGuidByte5:
+		case MSEHasGuidByte6:
+		case MSEHasGuidByte7:
+			guid[element - MSEHasGuidByte0] = data.ReadBit();
+			break;
+		case MSEHasTransportGuidByte0:
+		case MSEHasTransportGuidByte1:
+		case MSEHasTransportGuidByte2:
+		case MSEHasTransportGuidByte3:
+		case MSEHasTransportGuidByte4:
+		case MSEHasTransportGuidByte5:
+		case MSEHasTransportGuidByte6:
+		case MSEHasTransportGuidByte7:
+			if (hasTransportData)
+				tguid[element - MSEHasTransportGuidByte0] = data.ReadBit();
+			break;
+		case MSEGuidByte0:
+		case MSEGuidByte1:
+		case MSEGuidByte2:
+		case MSEGuidByte3:
+		case MSEGuidByte4:
+		case MSEGuidByte5:
+		case MSEGuidByte6:
+		case MSEGuidByte7:
+			data.ReadByteSeq(guid[element - MSEGuidByte0]);
+			break;
+		case MSETransportGuidByte0:
+		case MSETransportGuidByte1:
+		case MSETransportGuidByte2:
+		case MSETransportGuidByte3:
+		case MSETransportGuidByte4:
+		case MSETransportGuidByte5:
+		case MSETransportGuidByte6:
+		case MSETransportGuidByte7:
+			if (hasTransportData)
+				data.ReadByteSeq(tguid[element - MSETransportGuidByte0]);
+			break;
+		case MSEHasMovementFlags:
+			hasMovementFlags = !data.ReadBit();
+			break;
+		case MSEHasMovementFlags2:
+			hasMovementFlags2 = !data.ReadBit();
+			break;
+		case MSEHasTimestamp:
+			hasTimestamp = !data.ReadBit();
+			break;
+		case MSEHasOrientation:
+			hasOrientation = !data.ReadBit();
+			break;
+		case MSEHasTransportData:
+			hasTransportData = data.ReadBit();
+			break;
+		case MSEHasTransportTime2:
+			if (hasTransportData)
+				hasTransportTime2 = data.ReadBit();
+			break;
+		case MSEHasTransportTime3:
+			if (hasTransportData)
+				hasTransportTime3 = data.ReadBit();
+			break;
+		case MSEHasPitch:
+			hasPitch = !data.ReadBit();
+			break;
+		case MSEHasFallData:
+			hasFallData = data.ReadBit();
+			break;
+		case MSEHasFallDirection:
+			if (hasFallData)
+				hasFallDirection = data.ReadBit();
+			break;
+		case MSEHasSplineElevation:
+			hasSplineElevation = !data.ReadBit();
+			break;
+		case MSEHasSpline:
+			data.ReadBit();
+			break;
+		case MSEMovementFlags:
+			if (hasMovementFlags)
+				mi->flags = data.ReadBits(30);
+			break;
+		case MSEMovementFlags2:
+			if (hasMovementFlags2)
+				mi->flags2 = data.ReadBits(12);
+			break;
+		case MSETimestamp:
+			if (hasTimestamp)
+				data >> mi->time;
+			break;
+		case MSEPositionX:
+			data >> mi->pos.m_positionX;
+			break;
+		case MSEPositionY:
+			data >> mi->pos.m_positionY;
+			break;
+		case MSEPositionZ:
+			data >> mi->pos.m_positionZ;
+			break;
+		case MSEOrientation:
+			if (hasOrientation)
+				mi->pos.SetOrientation(data.read<float>());
+			break;
+		case MSETransportPositionX:
+			if (hasTransportData)
+				data >> mi->pos.m_positionX;
+			break;
+		case MSETransportPositionY:
+			if (hasTransportData)
+				data >> mi->pos.m_positionY;
+			break;
+		case MSETransportPositionZ:
+			if (hasTransportData)
+				data >> mi->pos.m_positionZ;
+			break;
+		case MSETransportOrientation:
+			if (hasTransportData)
+				mi->pos.SetOrientation(data.read<float>());
+			break;
+		case MSETransportSeat:
+			if (hasTransportData)
+				data >> mi->t_seat;
+			break;
+		case MSETransportTime:
+			if (hasTransportData)
+				data >> mi->t_time;
+			break;
+		case MSETransportTime2:
+			if (hasTransportData && hasTransportTime2)
+				data >> mi->t_time2;
+			break;
+		case MSETransportTime3:
+			if (hasTransportData && hasTransportTime3)
+				data >> mi->t_time3;
+			break;
+		case MSEPitch:
+			if (hasPitch)
+				mi->pitch = G3D::wrap(data.read<float>(), float(-M_PI), float(M_PI));
+			break;
+		case MSEFallTime:
+			if (hasFallData)
+				data >> mi->fallTime;
+			break;
+		case MSEFallVerticalSpeed:
+			if (hasFallData)
+				data >> mi->j_zspeed;
+			break;
+		case MSEFallCosAngle:
+			if (hasFallData && hasFallDirection)
+				data >> mi->j_cosAngle;
+			break;
+		case MSEFallSinAngle:
+			if (hasFallData && hasFallDirection)
+				data >> mi->j_sinAngle;
+			break;
+		case MSEFallHorizontalSpeed:
+			if (hasFallData && hasFallDirection)
+				data >> mi->j_xyspeed;
+			break;
+		case MSESplineElevation:
+			if (hasSplineElevation)
+				data >> mi->splineElevation;
+			break;
+		case MSECounter:
+			data.read_skip<uint32>();   /// @TODO: Maybe compare it with m_movementCounter to verify that packets are sent & received in order?
+			break;
+		case MSEZeroBit:
+		case MSEOneBit:
+			data.ReadBit();
+			break;
+		/*case MSEExtraElement:
+			extras->ReadNextElement(data);
+			break;
+		default:
+			ASSERT(Movement::PrintInvalidSequenceElement(element, __FUNCTION__));
+			break;*/
+		}
+	}
+
+	mi->guid = guid;
+	mi->t_guid = tguid;
+
+	//! Anti-cheat checks. Please keep them in seperate if () blocks to maintain a clear overview.
+	//! Might be subject to latency, so just remove improper flags.
+#ifdef TRINITY_DEBUG
+#define REMOVE_VIOLATING_FLAGS(check, maskToRemove)\
+	{\
+	if (check)\
+	{\
+	sLog->outDebug(LOG_FILTER_UNITS, "WorldSession::ReadMovementInfo: Violation of MovementFlags found (%s). "\
+	"MovementFlags: %u, MovementFlags2: %u for player GUID: %u. Mask %u will be removed.",\
+	STRINGIZE(check), mi->GetMovementFlags(), mi->GetExtraMovementFlags(), GetGUIDLow(), maskToRemove);\
+	mi->RemoveMovementFlag((maskToRemove));\
+	}\
+	}
+#else
+#define REMOVE_VIOLATING_FLAGS(check, maskToRemove)\
+	if (check)\
+	mi->RemoveMovementFlag((maskToRemove));
+#endif
+
+	/*! This must be a packet spoofing attempt. MOVEMENTFLAG_ROOT sent from the client is not valid
+	in conjunction with any of the moving movement flags such as MOVEMENTFLAG_FORWARD.
+	It will freeze clients that receive this player's movement info.
+	*/
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_ROOT),
+		MOVEMENTFLAG_ROOT);
+
+	//! Cannot hover without SPELL_AURA_HOVER
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_HOVER) && !HasAuraType(SPELL_AURA_HOVER),
+		MOVEMENTFLAG_HOVER);
+
+	//! Cannot ascend and descend at the same time
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_ASCENDING) && mi->HasMovementFlag(MOVEMENTFLAG_DESCENDING),
+		MOVEMENTFLAG_ASCENDING | MOVEMENTFLAG_DESCENDING);
+
+	//! Cannot move left and right at the same time
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_LEFT) && mi->HasMovementFlag(MOVEMENTFLAG_RIGHT),
+		MOVEMENTFLAG_LEFT | MOVEMENTFLAG_RIGHT);
+
+	//! Cannot strafe left and right at the same time
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_STRAFE_LEFT) && mi->HasMovementFlag(MOVEMENTFLAG_STRAFE_RIGHT),
+		MOVEMENTFLAG_STRAFE_LEFT | MOVEMENTFLAG_STRAFE_RIGHT);
+
+	//! Cannot pitch up and down at the same time
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_PITCH_UP) && mi->HasMovementFlag(MOVEMENTFLAG_PITCH_DOWN),
+		MOVEMENTFLAG_PITCH_UP | MOVEMENTFLAG_PITCH_DOWN);
+
+	//! Cannot move forwards and backwards at the same time
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_FORWARD) && mi->HasMovementFlag(MOVEMENTFLAG_BACKWARD),
+		MOVEMENTFLAG_FORWARD | MOVEMENTFLAG_BACKWARD);
+
+	//! Cannot walk on water without SPELL_AURA_WATER_WALK
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_WATERWALKING) && !HasAuraType(SPELL_AURA_WATER_WALK),
+		MOVEMENTFLAG_WATERWALKING);
+
+	//! Cannot feather fall without SPELL_AURA_FEATHER_FALL
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_FALLING_SLOW) && !HasAuraType(SPELL_AURA_FEATHER_FALL),
+		MOVEMENTFLAG_FALLING_SLOW);
+
+	/*! Cannot fly if no fly auras present. Exception is being a GM.
+	Note that we check for account level instead of Player::IsGameMaster() because in some
+	situations it may be feasable to use .gm fly on as a GM without having .gm on,
+	e.g. aerial combat.
+	*/
+
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_FLYING | MOVEMENTFLAG_CAN_FLY) && ToPlayer()->GetSession()->GetSecurity() == SEC_PLAYER &&
+		!ToPlayer()->m_mover->HasAuraType(SPELL_AURA_FLY) &&
+		!ToPlayer()->m_mover->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED),
+		MOVEMENTFLAG_FLYING | MOVEMENTFLAG_CAN_FLY);
+
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY | MOVEMENTFLAG_CAN_FLY) && mi->HasMovementFlag(MOVEMENTFLAG_FALLING),
+		MOVEMENTFLAG_FALLING);
+
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_FALLING) && (!hasFallData || !hasFallDirection), MOVEMENTFLAG_FALLING);
+
+	REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_SPLINE_ELEVATION) &&
+		(!hasSplineElevation || G3D::fuzzyEq(mi->splineElevation, 0.0f)), MOVEMENTFLAG_SPLINE_ELEVATION);
+
+	// Client first checks if spline elevation != 0, then verifies flag presence
+	if (hasSplineElevation)
+		mi->AddMovementFlag(MOVEMENTFLAG_SPLINE_ELEVATION);
+
+#undef REMOVE_VIOLATING_FLAGS
+}
+
+void Player::SendPetTameResult(PetTameResult result)
+{
+    WorldPacket data(SMSG_PET_TAME_FAILURE, 4);
+    data << uint32(result); // The result
+    GetSession()->SendPacket(&data);
+}
+
+PetData* Player::GetPetDatabySlot(uint8 slot)
+{
+    for (Stable::iterator itr = m_Stables.begin(); itr != m_Stables.end(); ++itr)
+        if (itr->second->slot == slot)
+            return itr->second;
+
+
+    return NULL;
+}
+
+PetData* Player::GetPetDatabySpell(uint32 spell)
+{
+    for (Stable::iterator itr = m_Stables.begin(); itr != m_Stables.end(); ++itr)
+        if (itr->second->summon_spell_id == spell)
+            return itr->second;
+
+    return NULL;
+}
+
+PetData* Player::GetPetDatabyGuid(uint32 guid)
+{
+    for (Stable::iterator itr = m_Stables.begin(); itr != m_Stables.end(); ++itr)
+        if (itr->second->id == guid)
+            return itr->second;
+
+    return NULL;
+}
+
+PetData* Player::GetPetDatabyEntry(uint32 entry)
+{
+    for (Stable::iterator itr = m_Stables.begin(); itr != m_Stables.end(); ++itr)
+        if (itr->second->entry == entry)
+            return itr->second;
+
+    return NULL;
+}
+
+void Player::_SavePets(SQLTransaction& trans)
+{
+    PreparedStatement* stmt = NULL;
+    uint32 lowGuid = GetGUIDLow();
+
+    time_t curTime = time(NULL);
+
+    Pet* t_pet = GetPet();
+    if(t_pet)
+        t_pet->SavePet(PET_SLOT_ACTUAL_PET_SLOT);
+
+    for (Stable::const_iterator itr = m_Stables.begin(); itr != m_Stables.end();)
+    {
+        PetData* data = itr->second;
+        uint32 petguid = data->id;
+
+        if (data->_state == DATA_REMOVED)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_ID);
+            stmt->setUInt32(0, petguid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_DECLINEDNAME);
+            stmt->setUInt32(0, petguid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_AURAS);
+            stmt->setUInt32(0, petguid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_SPELLS);
+            stmt->setUInt32(0, petguid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_SPELL_COOLDOWNS);
+            stmt->setUInt32(0, petguid);
+            trans->Append(stmt);
+
+            m_Stables.erase(itr++);
+
+            continue;
+        }
+        else if (data->_state != DATA_UNCHANGED)
+        {
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_AURAS);
+            stmt->setUInt32(0, petguid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_ID);
+            stmt->setUInt32(0, petguid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_SPELL_COOLDOWNS);
+            stmt->setUInt32(0, petguid);
+            trans->Append(stmt);
+
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PET_SPELLS);
+            stmt->setUInt32(0, petguid);
+            trans->Append(stmt);
+
+            //SaveCooldowns
+
+            for (PetSpellCooldown::iterator itr_m = data->m_spellscooldown.begin(), next = data->m_spellscooldown.begin(); itr_m != data->m_spellscooldown.end(); itr_m = next)
+            {
+                ++next;
+                PetSpellCooldownData& m_spellcooldown = itr_m->second;
+
+                if (m_spellcooldown.time  <= curTime)
+                    data->m_spellscooldown.erase(itr_m);
+                else
+                {
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PET_SPELL_COOLDOWN);
+                    stmt->setUInt32(0, petguid);
+                    stmt->setUInt32(1, itr_m->first);
+                    stmt->setUInt32(2, uint32(m_spellcooldown.time));
+                    trans->Append(stmt);
+                }
+
+            }
+            //SaveSpells
+            for (std::list<PetSpellData>::iterator itr_m = data->m_learnSpells.begin(), next = data->m_learnSpells.begin(); itr_m != data->m_learnSpells.end(); itr_m = next)
+            {
+                ++next;
+                PetSpellData& m_spell = (*itr_m);
+                if (m_spell.type == PETSPELL_FAMILY)
+                    continue;
+
+                PreparedStatement* stmt;
+
+                switch (m_spell._state)
+                {
+                    case DATA_REMOVED:
+                        data->m_learnSpells.erase(itr_m);
+                        continue;
+                    default:
+                        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PET_SPELL);
+                        stmt->setUInt32(0, petguid);
+                        stmt->setUInt32(1, m_spell.Id);
+                        stmt->setUInt8(2, m_spell.active);
+                        trans->Append(stmt);
+                }
+                m_spell._state = DATA_UNCHANGED;
+            }
+            //SaveAuras
+            for (PetAuraMap::iterator itr_m = data->m_auras.begin(); itr_m != data->m_auras.end(); ++itr_m)
+            {
+                PetAuraData& t_aura = *itr_m;
+
+                switch (t_aura._state)
+                {
+                    case DATA_REMOVED:
+                        data->m_auras.erase(itr_m);
+                        continue;
+                    default:
+                        uint8 index = 0;
+                        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PET_AURA);
+                        stmt->setUInt32(index++, petguid);
+                        stmt->setUInt64(index++, t_aura.caster_guid);
+                        stmt->setUInt32(index++, t_aura.spellid);
+                        stmt->setUInt8(index++, t_aura.effmask);
+                        stmt->setUInt8(index++, t_aura.recalculatemask);
+                        stmt->setUInt8(index++, t_aura.stackcount);
+                        stmt->setInt32(index++, t_aura.damage[0]);
+                        stmt->setInt32(index++, t_aura.damage[1]);
+                        stmt->setInt32(index++, t_aura.damage[2]);
+                        stmt->setInt32(index++, t_aura.baseDamage[0]);
+                        stmt->setInt32(index++, t_aura.baseDamage[1]);
+                        stmt->setInt32(index++, t_aura.baseDamage[2]);
+                        stmt->setInt32(index++, t_aura.maxduration);
+                        stmt->setInt32(index++, t_aura.remaintime);
+                        stmt->setUInt8(index++, t_aura.remaincharges);
+                        trans->Append(stmt);
+                }
+            }
+            uint8 index = 0;
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PET_BASE);
+            stmt->setUInt32(index++, petguid);
+            stmt->setUInt32(index++, data->entry);
+            stmt->setUInt32(index++, GetGUIDLow());
+            stmt->setUInt32(index++, data->modelid);
+            stmt->setUInt32(index++, data->summon_spell_id);
+            stmt->setUInt32(index++, uint32(data->pet_type));
+            stmt->setUInt16(index++, data->level);
+            stmt->setUInt32(index++, data->exp);
+            stmt->setUInt32(index++, uint32(data->reactstate));
+            stmt->setString(index++, data->name.c_str());
+            stmt->setUInt8(index++, uint32(data->renamed));
+            stmt->setUInt32(index++, uint32(data->slot));
+            stmt->setUInt32(index++, data->curhealth);
+            stmt->setUInt32(index++, data->curmana);
+            stmt->setUInt32(index++, time(NULL));
+            stmt->setString(index++, data->abdata.c_str());
+            trans->Append(stmt);
+
+            data->_state = DATA_UNCHANGED;
+            ++itr;
+        }
+        else
+            ++itr;
+    }
+}
+
+void Player::SendOnCancelExpectedVehicleRideAura()
+{
+    WorldPacket data(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);
+    GetSession()->SendPacket(&data);
+}
diff --git a/src/server/game/Handlers/BattleGroundHandler.cpp b/src/server/game/Handlers/BattleGroundHandler.cpp
index be18466..97ae3c1 100644
--- a/src/server/game/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Handlers/BattleGroundHandler.cpp
@@ -34,6 +34,7 @@
 #include "Opcodes.h"
 #include "DisableMgr.h"
 #include "Group.h"
+#include "../../scripts/Custom/npc_arena1v1.h"
 
 void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket& recvData)
 {
@@ -522,6 +523,10 @@ void WorldSession::HandleBattleFieldPortOpcode(WorldPacket &recvData)
         if (!_player->IsInvitedForBattlegroundQueueType(bgQueueTypeId))
             return;                                 // cheating?
 
+        // 1v1 Arena. Player can't join arena when forbidden talents are used.
+        if(bgQueueTypeId == BATTLEGROUND_QUEUE_5v5 && Arena1v1CheckTalents(_player) == false)
+            return;
+
         if (!_player->InBattleground())
             _player->SetBattlegroundEntryPoint();
 
diff --git a/src/server/game/Handlers/BattleGroundHandler.cpp.orig b/src/server/game/Handlers/BattleGroundHandler.cpp.orig
new file mode 100644
index 0000000..be18466
--- /dev/null
+++ b/src/server/game/Handlers/BattleGroundHandler.cpp.orig
@@ -0,0 +1,911 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Common.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "ArenaTeamMgr.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+
+#include "ArenaTeam.h"
+#include "BattlegroundMgr.h"
+#include "Battleground.h"
+#include "Chat.h"
+#include "Language.h"
+#include "Log.h"
+#include "Player.h"
+#include "Object.h"
+#include "Opcodes.h"
+#include "DisableMgr.h"
+#include "Group.h"
+
+void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket& recvData)
+{
+    uint64 guid;
+    recvData >> guid;
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_BATTLEMASTER_HELLO Message from (GUID: %u TypeId:%u)", GUID_LOPART(guid), GuidHigh2TypeId(GUID_HIPART(guid)));
+
+    Creature* unit = GetPlayer()->GetMap()->GetCreature(guid);
+    if (!unit)
+        return;
+
+    if (!unit->IsBattleMaster())                             // it's not battlemaster
+        return;
+
+    // Stop the npc if moving
+    unit->StopMoving();
+
+    BattlegroundTypeId bgTypeId = sBattlegroundMgr->GetBattleMasterBG(unit->GetEntry());
+
+    if (!_player->GetBGAccessByLevel(bgTypeId))
+    {
+                                                            // temp, must be gossip message...
+        SendNotification(LANG_YOUR_BG_LEVEL_REQ_ERROR);
+        return;
+    }
+
+    SendBattleGroundList(guid, bgTypeId);
+}
+
+void WorldSession::SendBattleGroundList(uint64 guid, BattlegroundTypeId bgTypeId)
+{
+    WorldPacket data;
+    sBattlegroundMgr->BuildBattlegroundListPacket(&data, guid, _player, bgTypeId);
+    SendPacket(&data);
+}
+
+void WorldSession::HandleBattlemasterJoinOpcode(WorldPacket& recvData)
+{
+    uint32 bgTypeId_;
+    uint32 instanceId;
+    uint8 asGroup;
+    bool isPremade = false;
+    Group* grp = NULL;
+    ObjectGuid guid;
+
+    recvData >> instanceId;                 // Instance Id
+    guid[2] = recvData.ReadBit();
+    guid[0] = recvData.ReadBit();
+    guid[3] = recvData.ReadBit();
+    guid[1] = recvData.ReadBit();
+    guid[5] = recvData.ReadBit();
+    asGroup = recvData.ReadBit();           // As Group
+    guid[4] = recvData.ReadBit();
+    guid[6] = recvData.ReadBit();
+    guid[7] = recvData.ReadBit();
+
+    recvData.ReadByteSeq(guid[2]);
+    recvData.ReadByteSeq(guid[6]);
+    recvData.ReadByteSeq(guid[4]);
+    recvData.ReadByteSeq(guid[3]);
+    recvData.ReadByteSeq(guid[7]);
+    recvData.ReadByteSeq(guid[0]);
+    recvData.ReadByteSeq(guid[5]);
+    recvData.ReadByteSeq(guid[1]);
+
+    //extract from guid
+    bgTypeId_ = GUID_LOPART(guid);
+
+    if (!sBattlemasterListStore.LookupEntry(bgTypeId_))
+    {
+        sLog->outError(LOG_FILTER_NETWORKIO, "Battleground: invalid bgtype (%u) received. possible cheater? player guid %u", bgTypeId_, _player->GetGUIDLow());
+        return;
+    }
+
+    if (DisableMgr::IsDisabledFor(DISABLE_TYPE_BATTLEGROUND, bgTypeId_, NULL))
+    {
+        ChatHandler(this).PSendSysMessage(LANG_BG_DISABLED);
+        return;
+    }
+    BattlegroundTypeId bgTypeId = BattlegroundTypeId(bgTypeId_);
+
+    //sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_BATTLEMASTER_JOIN Message from (GUID:"UI64FMTD" TypeId:%u)", guid, bgTypeId_);
+
+    // can do this, since it's battleground, not arena
+    BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(bgTypeId, 0);
+    BattlegroundQueueTypeId bgQueueTypeIdRandom = BattlegroundMgr::BGQueueTypeId(BATTLEGROUND_RB, 0);
+
+    // ignore if player is already in BG
+    if (_player->InBattleground())
+        return;
+
+    // get bg instance or bg template if instance not found
+    Battleground* bg = NULL;
+    if (instanceId)
+        bg = sBattlegroundMgr->GetBattlegroundThroughClientInstance(instanceId, bgTypeId);
+
+    if (!bg)
+        bg = sBattlegroundMgr->GetBattlegroundTemplate(bgTypeId);
+    if (!bg)
+        return;
+
+    // expected bracket entry
+    PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bg->GetMapId(), _player->getLevel());
+    if (!bracketEntry)
+        return;
+
+    GroupJoinBattlegroundResult err = ERR_BATTLEGROUND_NONE;
+
+    // check queue conditions
+    if (!asGroup)
+    {
+        if (GetPlayer()->isUsingLfg())
+        {
+            WorldPacket data;
+            sBattlegroundMgr->BuildStatusFailedPacket(&data, bg, _player, 0, ERR_LFG_CANT_USE_BATTLEGROUND);
+            GetPlayer()->GetSession()->SendPacket(&data);
+            return;
+        }
+
+        // check Deserter debuff
+        if (!_player->CanJoinToBattleground(bg))
+        {
+            WorldPacket data;
+            sBattlegroundMgr->BuildStatusFailedPacket(&data, bg, _player, 0, ERR_GROUP_JOIN_BATTLEGROUND_DESERTERS);
+            _player->GetSession()->SendPacket(&data);
+            return;
+        }
+
+        if (_player->GetBattlegroundQueueIndex(bgQueueTypeIdRandom) < PLAYER_MAX_BATTLEGROUND_QUEUES)
+        {
+            // player is already in random queue
+            WorldPacket data;
+            sBattlegroundMgr->BuildStatusFailedPacket(&data, bg, _player, 0, ERR_IN_RANDOM_BG);
+            _player->GetSession()->SendPacket(&data);
+            return;
+        }
+
+        if (_player->InBattlegroundQueue() && bgTypeId == BATTLEGROUND_RB)
+        {
+            // player is already in queue, can't start random queue
+            WorldPacket data;
+            sBattlegroundMgr->BuildStatusFailedPacket(&data, bg, _player, 0, ERR_IN_NON_RANDOM_BG);
+            _player->GetSession()->SendPacket(&data);
+            return;
+        }
+
+        // check if already in queue
+        if (_player->GetBattlegroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES)
+            // player is already in this queue
+            return;
+
+        // check if has free queue slots
+        if (!_player->HasFreeBattlegroundQueueId())
+        {
+            WorldPacket data;
+            sBattlegroundMgr->BuildStatusFailedPacket(&data, bg, _player, 0, ERR_BATTLEGROUND_TOO_MANY_QUEUES);
+            _player->GetSession()->SendPacket(&data);
+            return;
+        }
+
+        BattlegroundQueue& bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+        GroupQueueInfo* ginfo = bgQueue.AddGroup(_player, NULL, bgTypeId, bracketEntry, 0, false, isPremade, 0, 0);
+
+        uint32 avgTime = bgQueue.GetAverageQueueWaitTime(ginfo, bracketEntry->GetBracketId());
+        uint32 queueSlot = _player->AddBattlegroundQueueId(bgQueueTypeId);
+
+        // add joined time data
+        _player->AddBattlegroundQueueJoinTime(bgTypeId, ginfo->JoinTime);
+
+        WorldPacket data; // send status packet (in queue)
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, _player, queueSlot, STATUS_WAIT_QUEUE, avgTime, ginfo->JoinTime, ginfo->ArenaType);
+        SendPacket(&data);
+
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Battleground: player joined queue for bg queue type %u bg type %u: GUID %u, NAME %s",
+                       bgQueueTypeId, bgTypeId, _player->GetGUIDLow(), _player->GetName().c_str());
+    }
+    else
+    {
+        grp = _player->GetGroup();
+
+        if (!grp)
+            return;
+
+        if (grp->GetLeaderGUID() != _player->GetGUID())
+            return;
+
+        err = grp->CanJoinBattlegroundQueue(bg, bgQueueTypeId, 0, bg->GetMaxPlayersPerTeam(), false, 0);
+        isPremade = (grp->GetMembersCount() >= bg->GetMinPlayersPerTeam());
+
+        BattlegroundQueue& bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+        GroupQueueInfo* ginfo = NULL;
+        uint32 avgTime = 0;
+
+        if (!err)
+        {
+            sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Battleground: the following players are joining as group:");
+            ginfo = bgQueue.AddGroup(_player, grp, bgTypeId, bracketEntry, 0, false, isPremade, 0, 0);
+            avgTime = bgQueue.GetAverageQueueWaitTime(ginfo, bracketEntry->GetBracketId());
+        }
+
+        for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* member = itr->getSource();
+            if (!member)
+                continue;   // this should never happen
+
+            if (err)
+            {
+                WorldPacket data;
+                sBattlegroundMgr->BuildStatusFailedPacket(&data, bg, _player, 0, err);
+                member->GetSession()->SendPacket(&data);
+                continue;
+            }
+
+            // add to queue
+            uint32 queueSlot = member->AddBattlegroundQueueId(bgQueueTypeId);
+
+            // add joined time data
+            member->AddBattlegroundQueueJoinTime(bgTypeId, ginfo->JoinTime);
+
+            WorldPacket data; // send status packet (in queue)
+            sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, member, queueSlot, STATUS_WAIT_QUEUE, avgTime, ginfo->JoinTime, ginfo->ArenaType);
+            member->GetSession()->SendPacket(&data);
+            sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Battleground: player joined queue for bg queue type %u bg type %u: GUID %u, NAME %s",
+                bgQueueTypeId, bgTypeId, member->GetGUIDLow(), member->GetName().c_str());
+        }
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Battleground: group end");
+    }
+
+    sBattlegroundMgr->ScheduleQueueUpdate(0, 0, bgQueueTypeId, bgTypeId, bracketEntry->GetBracketId());
+}
+
+void WorldSession::HandleBattlegroundPlayerPositionsOpcode(WorldPacket& /*recvData*/)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_BATTLEGROUND_PLAYER_POSITIONS Message");
+
+    Battleground* bg = _player->GetBattleground();
+    if (!bg)                                                 // can't be received if player not in battleground
+        return;
+
+    uint32 acount = 0;
+    uint32 hcount = 0;
+    Player* aplr = NULL;
+    Player* hplr = NULL;
+
+    if (uint64 guid = bg->GetFlagPickerGUID(TEAM_ALLIANCE))
+    {
+        aplr = ObjectAccessor::FindPlayer(guid);
+        if (aplr)
+            ++acount;
+    }
+
+    if (uint64 guid = bg->GetFlagPickerGUID(TEAM_HORDE))
+    {
+        hplr = ObjectAccessor::FindPlayer(guid);
+        if (hplr)
+            ++hcount;
+    }
+
+    ObjectGuid aguid = aplr ? aplr->GetGUID() : 0;
+    ObjectGuid hguid = hplr ? hplr->GetGUID() : 0;
+
+    WorldPacket data(SMSG_BATTLEFIELD_PLAYER_POSITIONS);
+
+    data.WriteBits(acount, 22);
+    for (uint8 i = 0; i < acount; i++)
+    {
+        data.WriteBit(aguid[3]);
+        data.WriteBit(aguid[5]);
+        data.WriteBit(aguid[1]);
+        data.WriteBit(aguid[6]);
+        data.WriteBit(aguid[7]);
+        data.WriteBit(aguid[0]);
+        data.WriteBit(aguid[2]);
+        data.WriteBit(aguid[4]);
+    }
+
+    data.WriteBits(hcount, 22);
+    for (uint8 i = 0; i < hcount; i++)
+    {
+        data.WriteBit(hguid[6]);
+        data.WriteBit(hguid[5]);
+        data.WriteBit(hguid[4]);
+        data.WriteBit(hguid[7]);
+        data.WriteBit(hguid[2]);
+        data.WriteBit(hguid[1]);
+        data.WriteBit(hguid[0]);
+        data.WriteBit(hguid[3]);
+    }
+
+    data.FlushBits();
+
+    for (uint8 i = 0; i < hcount; i++)
+    {
+        data.WriteByteSeq(hguid[2]);
+        data.WriteByteSeq(hguid[1]);
+        data << float(hplr->GetPositionY());
+        data.WriteByteSeq(hguid[5]);
+        data.WriteByteSeq(hguid[4]);
+        data.WriteByteSeq(hguid[7]);
+        data.WriteByteSeq(hguid[0]);
+        data.WriteByteSeq(hguid[6]);
+        data.WriteByteSeq(hguid[3]);
+        data << float(hplr->GetPositionX());
+    }
+
+    for (uint8 i = 0; i < acount; i++)
+    {
+        data.WriteByteSeq(aguid[6]);
+        data << float(aplr->GetPositionX());
+        data.WriteByteSeq(aguid[5]);
+        data.WriteByteSeq(aguid[3]);
+        data << float(aplr->GetPositionY());
+        data.WriteByteSeq(aguid[1]);
+        data.WriteByteSeq(aguid[7]);
+        data.WriteByteSeq(aguid[0]);
+        data.WriteByteSeq(aguid[2]);
+        data.WriteByteSeq(aguid[4]);
+    }
+
+    SendPacket(&data);
+}
+
+void WorldSession::HandlePVPLogDataOpcode(WorldPacket & /*recvData*/)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_PVP_LOG_DATA Message");
+
+    Battleground* bg = _player->GetBattleground();
+    if (!bg)
+        return;
+
+    // Prevent players from sending BuildPvpLogDataPacket in an arena except for when sent in BattleGround::EndBattleGround.
+    if (bg->isArena())
+        return;
+
+    WorldPacket data;
+    sBattlegroundMgr->BuildPvpLogDataPacket(&data, bg);
+    SendPacket(&data);
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Sent SMSG_PVP_LOG_DATA Message");
+}
+
+void WorldSession::HandleBattlefieldListOpcode(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_BATTLEFIELD_LIST Message");
+
+    uint32 bgTypeId;
+    recvData >> bgTypeId;                                  // id from DBC
+
+    BattlemasterListEntry const* bl = sBattlemasterListStore.LookupEntry(bgTypeId);
+    if (!bl)
+    {
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "BattlegroundHandler: invalid bgtype (%u) with player (Name: %s, GUID: %u) received.", bgTypeId, _player->GetName().c_str(), _player->GetGUIDLow());
+        return;
+    }
+
+    /*WorldPacket data; //This is completely bugged, for example. The client sends CMSG_BATTLEFIELD_LIST when logging in and leveling up for some reason, I don't understand why. 
+    sBattlegroundMgr->BuildBattlegroundListPacket(&data, 0, _player, BattlegroundTypeId(bgTypeId));
+    SendPacket(&data);*/
+}
+
+void WorldSession::HandleBattleFieldPortOpcode(WorldPacket &recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_BATTLEFIELD_PORT Message");
+
+    uint32 time;
+    uint32 queueSlot;
+    uint32 bgtype;
+    uint8 action;                       // enter battle 0x1, leave queue 0x0
+    ObjectGuid guid;
+
+    recvData >> time;
+    recvData >> queueSlot;
+    recvData >> bgtype;
+
+    guid[0] = recvData.ReadBit();
+    guid[1] = recvData.ReadBit();
+    guid[5] = recvData.ReadBit();
+    guid[6] = recvData.ReadBit();
+    guid[7] = recvData.ReadBit();
+    guid[4] = recvData.ReadBit();
+    guid[3] = recvData.ReadBit();
+    guid[2] = recvData.ReadBit();
+
+    action = recvData.ReadBit();
+
+    recvData.ReadByteSeq(guid[1]);
+    recvData.ReadByteSeq(guid[3]);
+    recvData.ReadByteSeq(guid[5]);
+    recvData.ReadByteSeq(guid[7]);
+    recvData.ReadByteSeq(guid[0]);
+    recvData.ReadByteSeq(guid[2]);
+    recvData.ReadByteSeq(guid[6]);
+    recvData.ReadByteSeq(guid[4]);
+
+    if (!_player->InBattlegroundQueue())
+    {
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "CMSG_BATTLEFIELD_PORT %s Slot: %u, Unk: %u, Time: %u, Action: %u. Player not in queue!",
+            GetPlayerInfo().c_str(), queueSlot, bgtype, time, action);
+        return;
+    }
+
+    BattlegroundQueueTypeId bgQueueTypeId = _player->GetBattlegroundQueueTypeId(queueSlot);
+    if (bgQueueTypeId == BATTLEGROUND_QUEUE_NONE)
+    {
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "CMSG_BATTLEFIELD_PORT %s Slot: %u, Unk: %u, Time: %u, Action: %u. Invalid queueSlot!",
+            GetPlayerInfo().c_str(), queueSlot, bgtype, time, action);
+        return;
+    }
+
+    BattlegroundQueue& bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+
+    //we must use temporary variable, because GroupQueueInfo pointer can be deleted in BattlegroundQueue::RemovePlayer() function
+    GroupQueueInfo ginfo;
+    if (!bgQueue.GetPlayerGroupInfoData(_player->GetGUID(), &ginfo))
+    {
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "CMSG_BATTLEFIELD_PORT %s Slot: %u, Unk: %u, Time: %u, Action: %u. Player not in queue (No player Group Info)!",
+            GetPlayerInfo().c_str(), queueSlot, bgtype, time, action);
+        return;
+    }
+    // if action == 1, then instanceId is required
+    if (!ginfo.IsInvitedToBGInstanceGUID && action == 1)
+    {
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "CMSG_BATTLEFIELD_PORT %s Slot: %u, Unk: %u, Time: %u, Action: %u. Player is not invited to any bg!",
+            GetPlayerInfo().c_str(), queueSlot, bgtype, time, action);
+        return;
+    }
+
+    BattlegroundTypeId bgTypeId = BattlegroundMgr::BGTemplateId(bgQueueTypeId);
+    // BGTemplateId returns BATTLEGROUND_AA when it is arena queue.
+    // Do instance id search as there is no AA bg instances.
+    Battleground* bg = sBattlegroundMgr->GetBattleground(ginfo.IsInvitedToBGInstanceGUID, bgTypeId == BATTLEGROUND_AA ? BATTLEGROUND_TYPE_NONE : bgTypeId);
+    if (!bg)
+    {
+        if (action)
+        {
+            sLog->outDebug(LOG_FILTER_BATTLEGROUND, "CMSG_BATTLEFIELD_PORT %s Slot: %u, Unk: %u, Time: %u, Action: %u. Cant find BG with id %u!",
+                GetPlayerInfo().c_str(), queueSlot, bgtype, time, action, ginfo.IsInvitedToBGInstanceGUID);
+            return;
+        }
+
+        bg = sBattlegroundMgr->GetBattlegroundTemplate(bgTypeId);
+        if (!bg)
+        {
+            sLog->outError(LOG_FILTER_NETWORKIO, "BattlegroundHandler: bg_template not found for type id %u.", bgTypeId);
+            return;
+        }
+    }
+
+    sLog->outDebug(LOG_FILTER_BATTLEGROUND, "CMSG_BATTLEFIELD_PORT %s Slot: %u, Unk: %u, Time: %u, Action: %u.",
+        GetPlayerInfo().c_str(), queueSlot, bgtype, time, action);
+
+    // get real bg type
+    bgTypeId = bg->GetTypeID();
+
+    // expected bracket entry
+    PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bg->GetMapId(), _player->getLevel());
+    if (!bracketEntry)
+        return;
+
+    //some checks if player isn't cheating - it is not exactly cheating, but we cannot allow it
+    if (action == 1 && ginfo.ArenaType == 0)
+    {
+        //if player is trying to enter battleground (not arena!) and he has deserter debuff, we must just remove him from queue
+        if (!_player->CanJoinToBattleground(bg))
+        {
+            //send bg command result to show nice message
+            WorldPacket data2;
+            sBattlegroundMgr->BuildStatusFailedPacket(&data2, bg, _player, 0, ERR_GROUP_JOIN_BATTLEGROUND_DESERTERS);
+            _player->GetSession()->SendPacket(&data2);
+            action = 0;
+            sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Player %s (%u) has a deserter debuff, do not port him to battleground!", _player->GetName().c_str(), _player->GetGUIDLow());
+        }
+        //if player don't match battleground max level, then do not allow him to enter! (this might happen when player leveled up during his waiting in queue
+        if (_player->getLevel() > bg->GetMaxLevel())
+        {
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "Player %s (%u) has level (%u) higher than maxlevel (%u) of battleground (%u)! Do not port him to battleground!",
+                _player->GetName().c_str(), _player->GetGUIDLow(), _player->getLevel(), bg->GetMaxLevel(), bg->GetTypeID());
+            action = 0;
+        }
+    }
+
+    WorldPacket data;
+    if (action)
+    {
+        if (!_player->IsInvitedForBattlegroundQueueType(bgQueueTypeId))
+            return;                                 // cheating?
+
+        if (!_player->InBattleground())
+            _player->SetBattlegroundEntryPoint();
+
+        // resurrect the player
+        if (!_player->isAlive())
+        {
+            _player->ResurrectPlayer(1.0f);
+            _player->SpawnCorpseBones();
+        }
+        // stop taxi flight at port
+        if (_player->isInFlight())
+        {
+            _player->GetMotionMaster()->MovementExpired();
+            _player->CleanupAfterTaxiFlight();
+        }
+
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, _player, queueSlot, STATUS_IN_PROGRESS, _player->GetBattlegroundQueueJoinTime(bgTypeId), bg->GetElapsedTime(), bg->GetArenaType());
+        _player->GetSession()->SendPacket(&data);
+
+        // remove battleground queue status from BGmgr
+        bgQueue.RemovePlayer(_player->GetGUID(), false);
+        // this is still needed here if battleground "jumping" shouldn't add deserter debuff
+        // also this is required to prevent stuck at old battleground after SetBattlegroundId set to new
+        if (Battleground* currentBg = _player->GetBattleground())
+            currentBg->RemovePlayerAtLeave(_player->GetGUID(), false, true);
+
+        // set the destination instance id
+        _player->SetBattlegroundId(bg->GetInstanceID(), bgTypeId);
+        // set the destination team
+        _player->SetBGTeam(ginfo.Team);
+
+        // bg->HandleBeforeTeleportToBattleground(_player);
+        sBattlegroundMgr->SendToBattleground(_player, ginfo.IsInvitedToBGInstanceGUID, bgTypeId);
+        // add only in HandleMoveWorldPortAck()
+        // bg->AddPlayer(_player, team);
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Battleground: player %s (%u) joined battle for bg %u, bgtype %u, queue type %u.", _player->GetName().c_str(), _player->GetGUIDLow(), bg->GetInstanceID(), bg->GetTypeID(), bgQueueTypeId);
+    }
+    else // leave queue
+    {
+        // if player leaves rated arena match before match start, it is counted as he played but he lost
+        if (ginfo.IsRated && ginfo.IsInvitedToBGInstanceGUID)
+        {
+            ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(ginfo.Team);
+            if (at)
+            {
+                sLog->outDebug(LOG_FILTER_BATTLEGROUND, "UPDATING memberLost's personal arena rating for %u by opponents rating: %u, because he has left queue!", GUID_LOPART(_player->GetGUID()), ginfo.OpponentsTeamRating);
+                at->MemberLost(_player, ginfo.OpponentsMatchmakerRating);
+                at->SaveToDB();
+            }
+        }
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, _player, queueSlot, STATUS_NONE, _player->GetBattlegroundQueueJoinTime(bgTypeId), 0, ginfo.ArenaType);
+        SendPacket(&data);
+
+        _player->RemoveBattlegroundQueueId(bgQueueTypeId);  // must be called this way, because if you move this call to queue->removeplayer, it causes bugs
+        bgQueue.RemovePlayer(_player->GetGUID(), true);
+        // player left queue, we should update it - do not update Arena Queue
+        if (!ginfo.ArenaType)
+            sBattlegroundMgr->ScheduleQueueUpdate(ginfo.ArenaMatchmakerRating, ginfo.ArenaType, bgQueueTypeId, bgTypeId, bracketEntry->GetBracketId());
+
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Battleground: player %s (%u) left queue for bgtype %u, queue type %u.", _player->GetName().c_str(), _player->GetGUIDLow(), bg->GetTypeID(), bgQueueTypeId);
+    }
+}
+
+void WorldSession::HandleBattlefieldLeaveOpcode(WorldPacket& /*recvData*/)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_BATTLEFIELD_LEAVE Message");
+    _player->LeaveBattleground();
+}
+
+void WorldSession::HandleBattlefieldStatusOpcode(WorldPacket & /*recvData*/)
+{
+    // empty opcode
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_BATTLEFIELD_STATUS Message");
+
+    WorldPacket data;
+    // we must update all queues here
+    Battleground* bg = NULL;
+    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
+    {
+        BattlegroundQueueTypeId bgQueueTypeId = _player->GetBattlegroundQueueTypeId(i);
+        if (!bgQueueTypeId)
+            continue;
+        BattlegroundTypeId bgTypeId = BattlegroundMgr::BGTemplateId(bgQueueTypeId);
+        uint8 arenaType = BattlegroundMgr::BGArenaType(bgQueueTypeId);
+        if (bgTypeId == _player->GetBattlegroundTypeId())
+        {
+            bg = _player->GetBattleground();
+            //i cannot check any variable from player class because player class doesn't know if player is in 2v2 / 3v3 or 5v5 arena
+            //so i must use bg pointer to get that information
+            if (bg && bg->GetArenaType() == arenaType)
+            {
+                // this line is checked, i only don't know if GetElapsedTime() is changing itself after bg end!
+                // send status in Battleground
+                sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, GetPlayer(), i, STATUS_IN_PROGRESS, _player->GetBattlegroundQueueJoinTime(bgTypeId), bg->GetElapsedTime(), arenaType);
+                SendPacket(&data);
+                continue;
+            }
+        }
+
+        //we are sending update to player about queue - he can be invited there!
+        //get GroupQueueInfo for queue status
+        BattlegroundQueue& bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+        GroupQueueInfo ginfo;
+        if (!bgQueue.GetPlayerGroupInfoData(_player->GetGUID(), &ginfo))
+            continue;
+        if (ginfo.IsInvitedToBGInstanceGUID)
+        {
+            bg = sBattlegroundMgr->GetBattleground(ginfo.IsInvitedToBGInstanceGUID, bgTypeId);
+            if (!bg)
+                continue;
+
+            // send status invited to Battleground
+            sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, GetPlayer(), i, STATUS_WAIT_JOIN, getMSTimeDiff(getMSTime(), ginfo.RemoveInviteTime), _player->GetBattlegroundQueueJoinTime(bgTypeId), arenaType);
+            SendPacket(&data);
+        }
+        else
+        {
+            bg = sBattlegroundMgr->GetBattlegroundTemplate(bgTypeId);
+            if (!bg)
+                continue;
+
+            // expected bracket entry
+            PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bg->GetMapId(), _player->getLevel());
+            if (!bracketEntry)
+                continue;
+
+            uint32 avgTime = bgQueue.GetAverageQueueWaitTime(&ginfo, bracketEntry->GetBracketId());
+            // send status in Battleground Queue
+            sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, GetPlayer(), i, STATUS_WAIT_QUEUE, avgTime, _player->GetBattlegroundQueueJoinTime(bgTypeId), arenaType);
+            SendPacket(&data);
+        }
+    }
+}
+
+void WorldSession::HandleBattlemasterJoinArena(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_BATTLEMASTER_JOIN_ARENA");
+
+    uint8 arenaslot;                                        // 2v2, 3v3 or 5v5
+
+    recvData >> arenaslot;
+
+    // ignore if we already in BG or BG queue
+    if (_player->InBattleground())
+        return;
+
+    uint32 arenaRating = 0;
+    uint32 matchmakerRating = 0;
+
+    uint8 arenatype = ArenaTeam::GetTypeBySlot(arenaslot);
+
+    //check existance
+    Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(BATTLEGROUND_AA);
+    if (!bg)
+    {
+        sLog->outError(LOG_FILTER_NETWORKIO, "Battleground: template bg (all arenas) not found");
+        return;
+    }
+
+    if (DisableMgr::IsDisabledFor(DISABLE_TYPE_BATTLEGROUND, BATTLEGROUND_AA, NULL))
+    {
+        ChatHandler(this).PSendSysMessage(LANG_ARENA_DISABLED);
+        return;
+    }
+
+    BattlegroundTypeId bgTypeId = bg->GetTypeID();
+    BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(bgTypeId, arenatype);
+    PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bg->GetMapId(), _player->getLevel());
+    if (!bracketEntry)
+        return;
+
+    GroupJoinBattlegroundResult err = ERR_BATTLEGROUND_NONE;
+
+    Group* grp = _player->GetGroup();
+    // no group found, error
+    if (!grp)
+        return;
+    if (grp->GetLeaderGUID() != _player->GetGUID())
+        return;
+
+    uint32 ateamId = _player->GetArenaTeamId(arenaslot);
+    // check real arenateam existence only here (if it was moved to group->CanJoin .. () then we would ahve to get it twice)
+    ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(ateamId);
+    if (!at)
+    {
+        _player->GetSession()->SendNotInArenaTeamPacket(arenatype);
+        return;
+    }
+
+    // get the team rating for queueing
+    arenaRating = at->GetRating();
+    matchmakerRating = at->GetAverageMMR(grp);
+    // the arenateam id must match for everyone in the group
+
+    if (arenaRating <= 0)
+        arenaRating = 1;
+
+    BattlegroundQueue &bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+
+    uint32 avgTime = 0;
+    GroupQueueInfo* ginfo = NULL;
+
+    err = grp->CanJoinBattlegroundQueue(bg, bgQueueTypeId, arenatype, arenatype, true, arenaslot);
+    if (!err)
+    {
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Battleground: arena team id %u, leader %s queued with matchmaker rating %u for type %u", _player->GetArenaTeamId(arenaslot), _player->GetName().c_str(), matchmakerRating, arenatype);
+
+        ginfo = bgQueue.AddGroup(_player, grp, bgTypeId, bracketEntry, arenatype, true, false, arenaRating, matchmakerRating, ateamId);
+        avgTime = bgQueue.GetAverageQueueWaitTime(ginfo, bracketEntry->GetBracketId());
+    }
+
+    for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* member = itr->getSource();
+        if (!member)
+            continue;
+
+        if (err)
+        {
+            WorldPacket data;
+            sBattlegroundMgr->BuildStatusFailedPacket(&data, bg, _player, 0, err);
+            member->GetSession()->SendPacket(&data);
+            continue;
+        }
+
+        // add to queue
+        uint32 queueSlot = member->AddBattlegroundQueueId(bgQueueTypeId);
+
+        // add joined time data
+        member->AddBattlegroundQueueJoinTime(bgTypeId, ginfo->JoinTime);
+
+        WorldPacket data; // send status packet (in queue)
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, member, queueSlot, STATUS_WAIT_QUEUE, avgTime, ginfo->JoinTime, arenatype);
+        member->GetSession()->SendPacket(&data);
+
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "Battleground: player joined queue for arena as group bg queue type %u bg type %u: GUID %u, NAME %s", bgQueueTypeId, bgTypeId, member->GetGUIDLow(), member->GetName().c_str());
+    }
+
+    sBattlegroundMgr->ScheduleQueueUpdate(matchmakerRating, arenatype, bgQueueTypeId, bgTypeId, bracketEntry->GetBracketId());
+}
+
+void WorldSession::HandleReportPvPAFK(WorldPacket& recvData)
+{
+    uint64 playerGuid;
+    recvData >> playerGuid;
+    Player* reportedPlayer = ObjectAccessor::FindPlayer(playerGuid);
+
+    if (!reportedPlayer)
+    {
+        sLog->outDebug(LOG_FILTER_BATTLEGROUND, "WorldSession::HandleReportPvPAFK: player not found");
+        return;
+    }
+
+    sLog->outDebug(LOG_FILTER_BATTLEGROUND, "WorldSession::HandleReportPvPAFK: %s reported %s", _player->GetName().c_str(), reportedPlayer->GetName().c_str());
+
+    reportedPlayer->ReportedAfkBy(_player);
+}
+
+void WorldSession::HandleRequestRatedBgInfo(WorldPacket & recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_REQUEST_RATED_BG_INFO");
+
+    uint8 unk;
+    recvData >> unk; // BG type ?
+
+    sLog->outDebug(LOG_FILTER_BATTLEGROUND, "WorldSession::HandleRequestRatedBgInfo: unk = %u", unk);
+
+    /// @Todo: perfome research in this case
+    /// The unk fields are related to arenas
+    WorldPacket data(SMSG_RATED_BG_STATS, 72);
+    data << uint32(0);      // BgWeeklyWins20vs20
+    data << uint32(0);      // BgWeeklyPlayed20vs20
+    data << uint32(0);      // BgWeeklyPlayed15vs15
+    data << uint32(0);
+    data << uint32(0);      // BgWeeklyWins10vs10
+    data << uint32(0);
+    data << uint32(0);
+    data << uint32(0);
+    data << uint32(0);      // BgWeeklyWins15vs15
+    data << uint32(0);
+    data << uint32(0);
+    data << uint32(0);
+    data << uint32(0);
+    data << uint32(0);
+    data << uint32(0);
+    data << uint32(0);      // BgWeeklyPlayed10vs10
+    data << uint32(0);
+    data << uint32(0);
+
+    SendPacket(&data);
+}
+
+void WorldSession::HandleRequestPvpOptions(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_REQUEST_PVP_OPTIONS_ENABLED");
+
+    /// @Todo: perfome research in this case
+    WorldPacket data(SMSG_PVP_OPTIONS_ENABLED, 1);
+    data.WriteBit(1);
+    data.WriteBit(1);       // WargamesEnabled
+    data.WriteBit(1);
+    data.WriteBit(1);       // RatedBGsEnabled
+    data.WriteBit(1);       // RatedArenasEnabled
+
+    data.FlushBits();
+
+    SendPacket(&data);
+}
+
+void WorldSession::HandleRequestPvpReward(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_REQUEST_PVP_REWARDS");
+
+    _player->SendPvpRewards();
+}
+
+void WorldSession::HandleRequestRatedBgStats(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_REQUEST_RATED_BG_STATS");
+
+    /// There is 9 maps for RBG and 18 fiels so 2 fiels per map (1 for wins - 1 for played)
+    /// Or maybe it's anything else ? 
+
+    WorldPacket data(SMSG_BATTLEFIELD_RATED_INFO, 29);
+    data << uint32(400);  // Reward
+    data << uint8(3);   // BG type (10vs10 - 15vs15) ?
+    data << uint32(0);  // unk
+    data << uint32(0);  // unk
+	data << _player->GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_RBG, true);
+    data << uint32(0);  // unk
+    data << uint32(0);  // unk
+    data << _player->GetCurrency(CURRENCY_TYPE_CONQUEST_POINTS, true);
+
+    SendPacket(&data);
+}
+
+void WorldSession::HandleRequestInspectRatedBgStats(WorldPacket& recvData)
+{
+    ObjectGuid guid;
+    guid[1] = recvData.ReadBit();
+    guid[4] = recvData.ReadBit();
+    guid[6] = recvData.ReadBit();
+    guid[5] = recvData.ReadBit();
+    guid[0] = recvData.ReadBit();
+    guid[2] = recvData.ReadBit();
+    guid[7] = recvData.ReadBit();
+    guid[3] = recvData.ReadBit();
+
+    recvData.ReadByteSeq(guid[4]);
+    recvData.ReadByteSeq(guid[7]);
+    recvData.ReadByteSeq(guid[2]);
+    recvData.ReadByteSeq(guid[5]);
+    recvData.ReadByteSeq(guid[6]);
+    recvData.ReadByteSeq(guid[3]);
+    recvData.ReadByteSeq(guid[0]);
+    recvData.ReadByteSeq(guid[1]);
+    Player* player = ObjectAccessor::FindPlayer(guid);
+
+    if (!player)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "CMSG_REQUEST_INSPECT_RATED_BG_STATS: No player found from GUID: " UI64FMTD, (uint64)guid);
+        return;
+    }
+
+    ObjectGuid playerGuid = player->GetGUID();
+    WorldPacket data(SMSG_INSPECT_RATED_BG_STATS, 8+4+4+4);
+    data.WriteBit(playerGuid[6]);
+    data.WriteBit(playerGuid[4]);
+    data.WriteBit(playerGuid[5]);
+    data.WriteBit(playerGuid[1]);
+    data.WriteBit(playerGuid[2]);
+    data.WriteBit(playerGuid[7]);
+    data.WriteBit(playerGuid[0]);
+    data.WriteBit(playerGuid[3]);
+    data.WriteByteSeq(playerGuid[4]);
+    data << uint32(0); // Rating
+    data.WriteByteSeq(playerGuid[1]);
+    data.WriteByteSeq(playerGuid[7]);
+    data.WriteByteSeq(playerGuid[3]);
+    data.WriteByteSeq(playerGuid[6]);
+    data << uint32(0); // Won
+    data << uint32(0); // Played
+    data.WriteByteSeq(playerGuid[2]);
+    data.WriteByteSeq(playerGuid[5]);
+    data.WriteByteSeq(playerGuid[0]);
+    SendPacket(&data);
+}
diff --git a/src/server/game/Handlers/PetitionsHandler.cpp b/src/server/game/Handlers/PetitionsHandler.cpp
index 78b80c9..30a6c2e 100644
--- a/src/server/game/Handlers/PetitionsHandler.cpp
+++ b/src/server/game/Handlers/PetitionsHandler.cpp
@@ -949,7 +949,7 @@ void WorldSession::SendPetitionShowList(uint64 guid)
     }
     else
     {
-        data << uint8(3);                                   // count
+        data << uint8(2);                                   // count
         // 2v2
         data << uint32(1);                                  // index
         data << uint32(ARENA_TEAM_CHARTER_2v2);             // charter entry
@@ -965,12 +965,14 @@ void WorldSession::SendPetitionShowList(uint64 guid)
         data << uint32(3);                                  // unknown
         data << uint32(3);                                  // required signs?
         // 5v5
+        /* Disable purchase 5v5 petition - edit to 1v1 doesn't work (client prevent it)
         data << uint32(3);                                  // index
         data << uint32(ARENA_TEAM_CHARTER_5v5);             // charter entry
         data << uint32(CHARTER_DISPLAY_ID);                 // charter display id
         data << uint32(ARENA_TEAM_CHARTER_5v5_COST);        // charter cost
         data << uint32(5);                                  // unknown
         data << uint32(5);                                  // required signs?
+        */
     }
 
     SendPacket(&data);
diff --git a/src/server/game/Handlers/PetitionsHandler.cpp.orig b/src/server/game/Handlers/PetitionsHandler.cpp.orig
new file mode 100644
index 0000000..78b80c9
--- /dev/null
+++ b/src/server/game/Handlers/PetitionsHandler.cpp.orig
@@ -0,0 +1,978 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Common.h"
+#include "Language.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "ArenaTeamMgr.h"
+#include "GuildMgr.h"
+#include "Log.h"
+#include "Opcodes.h"
+#include "Guild.h"
+#include "ArenaTeam.h"
+#include "GossipDef.h"
+#include "SocialMgr.h"
+
+#define CHARTER_DISPLAY_ID 16161
+
+// Charters ID in item_template
+enum CharterItemIDs
+{
+    GUILD_CHARTER                                 = 5863,
+    ARENA_TEAM_CHARTER_2v2                        = 23560,
+    ARENA_TEAM_CHARTER_3v3                        = 23561,
+    ARENA_TEAM_CHARTER_5v5                        = 23562
+};
+
+enum CharterCosts
+{
+    GUILD_CHARTER_COST                            = 1000,
+    ARENA_TEAM_CHARTER_2v2_COST                   = 800000,
+    ARENA_TEAM_CHARTER_3v3_COST                   = 1200000,
+    ARENA_TEAM_CHARTER_5v5_COST                   = 2000000
+};
+
+void WorldSession::HandlePetitionBuyOpcode(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Received opcode CMSG_PETITION_BUY");
+
+    uint64 guidNPC;
+    uint32 clientIndex;                                     // 1 for guild and arenaslot+1 for arenas in client
+    std::string name;
+
+    recvData >> guidNPC;                                   // NPC GUID
+    recvData.read_skip<uint32>();                          // 0
+    recvData.read_skip<uint64>();                          // 0
+    recvData >> name;                                      // name
+    recvData.read_skip<std::string>();                     // some string
+    recvData.read_skip<uint32>();                          // 0
+    recvData.read_skip<uint32>();                          // 0
+    recvData.read_skip<uint32>();                          // 0
+    recvData.read_skip<uint32>();                          // 0
+    recvData.read_skip<uint32>();                          // 0
+    recvData.read_skip<uint32>();                          // 0
+    recvData.read_skip<uint32>();                          // 0
+    recvData.read_skip<uint16>();                          // 0
+    recvData.read_skip<uint32>();                          // 0
+    recvData.read_skip<uint32>();                          // 0
+    recvData.read_skip<uint32>();                          // 0
+
+    for (int i = 0; i < 10; ++i)
+        recvData.read_skip<std::string>();
+
+    recvData >> clientIndex;                               // index
+    recvData.read_skip<uint32>();                          // 0
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Petitioner with GUID %u tried sell petition: name %s", GUID_LOPART(guidNPC), name.c_str());
+
+    // prevent cheating
+    Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(guidNPC, UNIT_NPC_FLAG_PETITIONER);
+    if (!creature)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandlePetitionBuyOpcode - Unit (GUID: %u) not found or you can't interact with him.", GUID_LOPART(guidNPC));
+        return;
+    }
+
+    // remove fake death
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
+        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
+
+    uint32 charterid = 0;
+    uint32 cost = 0;
+    uint32 type = 0;
+    if (creature->IsTabardDesigner())
+    {
+        // if tabard designer, then trying to buy a guild charter.
+        // do not let if already in guild.
+        if (_player->GetGuildId())
+            return;
+
+        charterid = GUILD_CHARTER;
+        cost = GUILD_CHARTER_COST;
+        type = GUILD_CHARTER_TYPE;
+    }
+    else
+    {
+        // TODO: find correct opcode
+        if (_player->getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        {
+            SendNotification(LANG_ARENA_ONE_TOOLOW, sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
+            return;
+        }
+
+        switch (clientIndex)                                 // arenaSlot+1 as received from client (1 from 3 case)
+        {
+            case 1:
+                charterid = ARENA_TEAM_CHARTER_2v2;
+                cost = ARENA_TEAM_CHARTER_2v2_COST;
+                type = ARENA_TEAM_CHARTER_2v2_TYPE;
+                break;
+            case 2:
+                charterid = ARENA_TEAM_CHARTER_3v3;
+                cost = ARENA_TEAM_CHARTER_3v3_COST;
+                type = ARENA_TEAM_CHARTER_3v3_TYPE;
+                break;
+            case 3:
+                charterid = ARENA_TEAM_CHARTER_5v5;
+                cost = ARENA_TEAM_CHARTER_5v5_COST;
+                type = ARENA_TEAM_CHARTER_5v5_TYPE;
+                break;
+            default:
+                sLog->outDebug(LOG_FILTER_NETWORKIO, "unknown selection at buy arena petition: %u", clientIndex);
+                return;
+        }
+
+        if (_player->GetArenaTeamId(clientIndex - 1))        // arenaSlot+1 as received from client
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, name, "", ERR_ALREADY_IN_ARENA_TEAM);
+            return;
+        }
+    }
+
+    if (type == GUILD_CHARTER_TYPE)
+    {
+        if (sGuildMgr->GetGuildByName(name))
+        {
+            Guild::SendCommandResult(this, GUILD_COMMAND_CREATE, ERR_GUILD_NAME_EXISTS_S, name);
+            return;
+        }
+
+        if (sObjectMgr->IsReservedName(name) || !ObjectMgr::IsValidCharterName(name))
+        {
+            Guild::SendCommandResult(this, GUILD_COMMAND_CREATE, ERR_GUILD_NAME_INVALID, name);
+            return;
+        }
+    }
+    else
+    {
+        if (sArenaTeamMgr->GetArenaTeamByName(name))
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, name, "", ERR_ARENA_TEAM_NAME_EXISTS_S);
+            return;
+        }
+        if (sObjectMgr->IsReservedName(name) || !ObjectMgr::IsValidCharterName(name))
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, name, "", ERR_ARENA_TEAM_NAME_INVALID);
+            return;
+        }
+    }
+
+    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(charterid);
+    if (!pProto)
+    {
+        _player->SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, charterid, 0);
+        return;
+    }
+
+    if (!_player->HasEnoughMoney(uint64(cost)))
+    {                                                       //player hasn't got enough money
+        _player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, charterid, 0);
+        return;
+    }
+
+    ItemPosCountVec dest;
+    InventoryResult msg = _player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, charterid, pProto->BuyCount);
+    if (msg != EQUIP_ERR_OK)
+    {
+        _player->SendEquipError(msg, NULL, NULL, charterid);
+        return;
+    }
+
+    _player->ModifyMoney(-(int32)cost);
+    Item* charter = _player->StoreNewItem(dest, charterid, true);
+    if (!charter)
+        return;
+
+    charter->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1, charter->GetGUIDLow());
+    // ITEM_FIELD_ENCHANTMENT_1_1 is guild/arenateam id
+    // ITEM_FIELD_ENCHANTMENT_1_1+1 is current signatures count (showed on item)
+    charter->SetState(ITEM_CHANGED, _player);
+    _player->SendNewItem(charter, 1, true, false);
+
+    // a petition is invalid, if both the owner and the type matches
+    // we checked above, if this player is in an arenateam, so this must be
+    // datacorruption
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_BY_OWNER);
+    stmt->setUInt32(0, _player->GetGUIDLow());
+    stmt->setUInt8(1, type);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    std::ostringstream ssInvalidPetitionGUIDs;
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            ssInvalidPetitionGUIDs << '\'' << fields[0].GetUInt32() << "', ";
+        } while (result->NextRow());
+    }
+
+    // delete petitions with the same guid as this one
+    ssInvalidPetitionGUIDs << '\'' << charter->GetGUIDLow() << '\'';
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Invalid petition GUIDs: %s", ssInvalidPetitionGUIDs.str().c_str());
+    CharacterDatabase.EscapeString(name);
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    trans->PAppend("DELETE FROM petition WHERE petitionguid IN (%s)",  ssInvalidPetitionGUIDs.str().c_str());
+    trans->PAppend("DELETE FROM petition_sign WHERE petitionguid IN (%s)", ssInvalidPetitionGUIDs.str().c_str());
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PETITION);
+    stmt->setUInt32(0, _player->GetGUIDLow());
+    stmt->setUInt32(1, charter->GetGUIDLow());
+    stmt->setString(2, name);
+    stmt->setUInt8(3, uint8(type));
+    trans->Append(stmt);
+
+    CharacterDatabase.CommitTransaction(trans);
+}
+
+void WorldSession::HandlePetitionShowSignOpcode(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Received opcode CMSG_PETITION_SHOW_SIGNATURES");
+
+    uint8 signs = 0;
+    uint64 petitionguid;
+    recvData >> petitionguid;                              // petition guid
+
+    // solve (possible) some strange compile problems with explicit use GUID_LOPART(petitionguid) at some GCC versions (wrong code optimization in compiler?)
+    uint32 petitionGuidLow = GUID_LOPART(petitionguid);
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_TYPE);
+
+    stmt->setUInt32(0, petitionGuidLow);
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (!result)
+    {
+        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Petition %u is not found for player %u %s", GUID_LOPART(petitionguid), GetPlayer()->GetGUIDLow(), GetPlayer()->GetName().c_str());
+        return;
+    }
+    Field* fields = result->Fetch();
+    uint32 type = fields[0].GetUInt8();
+
+    // if guild petition and has guild => error, return;
+    if (type == GUILD_CHARTER_TYPE && _player->GetGuildId())
+        return;
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIGNATURE);
+
+    stmt->setUInt32(0, petitionGuidLow);
+
+    result = CharacterDatabase.Query(stmt);
+
+    // result == NULL also correct in case no sign yet
+    if (result)
+        signs = uint8(result->GetRowCount());
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "CMSG_PETITION_SHOW_SIGNATURES petition entry: '%u'", petitionGuidLow);
+
+    WorldPacket data(SMSG_PETITION_SHOW_SIGNATURES, (8+8+4+1+signs*12));
+    data << uint64(petitionguid);                           // petition guid
+    data << uint64(_player->GetGUID());                     // owner guid
+    data << uint32(petitionGuidLow);                        // guild guid
+    data << uint8(signs);                                   // sign's count
+
+    for (uint8 i = 1; i <= signs; ++i)
+    {
+        Field* fields2 = result->Fetch();
+        uint32 lowGuid = fields2[0].GetUInt32();
+
+        data << uint64(MAKE_NEW_GUID(lowGuid, 0, HIGHGUID_PLAYER)); // Player GUID
+        data << uint32(0);                                  // there 0 ...
+
+        result->NextRow();
+    }
+    SendPacket(&data);
+}
+
+void WorldSession::HandlePetitionQueryOpcode(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Received opcode CMSG_PETITION_QUERY");   // ok
+
+    uint32 guildguid;
+    uint64 petitionguid;
+    recvData >> guildguid;                                 // in Trinity always same as GUID_LOPART(petitionguid)
+    recvData >> petitionguid;                              // petition guid
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "CMSG_PETITION_QUERY Petition GUID %u Guild GUID %u", GUID_LOPART(petitionguid), guildguid);
+
+    SendPetitionQueryOpcode(petitionguid);
+}
+
+void WorldSession::SendPetitionQueryOpcode(uint64 petitionguid)
+{
+    uint64 ownerguid = 0;
+    uint32 type;
+    std::string name = "NO_NAME_FOR_GUID";
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionguid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        ownerguid = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+        name      = fields[1].GetString();
+        type      = fields[2].GetUInt8();
+    }
+    else
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "CMSG_PETITION_QUERY failed for petition (GUID: %u)", GUID_LOPART(petitionguid));
+        return;
+    }
+
+    WorldPacket data(SMSG_PETITION_QUERY_RESPONSE, (4+8+name.size()+1+1+4*12+2+10));
+    data << uint32(GUID_LOPART(petitionguid));              // guild/team guid (in Trinity always same as GUID_LOPART(petition guid)
+    data << uint64(ownerguid);                              // charter owner guid
+    data << name;                                           // name (guild/arena team)
+    data << uint8(0);                                       // some string
+    if (type == GUILD_CHARTER_TYPE)
+    {
+        uint32 needed = sWorld->getIntConfig(CONFIG_MIN_PETITION_SIGNS);
+        data << uint32(needed);
+        data << uint32(needed);
+        data << uint32(0);                                  // bypass client - side limitation, a different value is needed here for each petition
+    }
+    else
+    {
+        data << uint32(type-1);
+        data << uint32(type-1);
+        data << uint32(type);                               // bypass client - side limitation, a different value is needed here for each petition
+    }
+    data << uint32(0);                                      // 5
+    data << uint32(0);                                      // 6
+    data << uint32(0);                                      // 7
+    data << uint32(0);                                      // 8
+    data << uint16(0);                                      // 9 2 bytes field
+    data << uint32(0);                                      // 10
+    data << uint32(0);                                      // 11
+    data << uint32(0);                                      // 13 count of next strings?
+
+    for (int i = 0; i < 10; ++i)
+        data << uint8(0);                                   // some string
+
+    data << uint32(0);                                      // 14
+
+    data << uint32(type != GUILD_CHARTER_TYPE);             // 15 0 - guild, 1 - arena team
+
+    SendPacket(&data);
+}
+
+void WorldSession::HandlePetitionRenameOpcode(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Received opcode MSG_PETITION_RENAME");
+
+    uint64 petitionGuid;
+    uint32 type;
+    std::string newName;
+
+    recvData >> petitionGuid;                              // guid
+    recvData >> newName;                                   // new name
+
+    Item* item = _player->GetItemByGuid(petitionGuid);
+    if (!item)
+        return;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_TYPE);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionGuid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        type = fields[0].GetUInt8();
+    }
+    else
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "CMSG_PETITION_QUERY failed for petition (GUID: %u)", GUID_LOPART(petitionGuid));
+        return;
+    }
+
+    if (type == GUILD_CHARTER_TYPE)
+    {
+        if (sGuildMgr->GetGuildByName(newName))
+        {
+            Guild::SendCommandResult(this, GUILD_COMMAND_CREATE, ERR_GUILD_NAME_EXISTS_S, newName);
+            return;
+        }
+        if (sObjectMgr->IsReservedName(newName) || !ObjectMgr::IsValidCharterName(newName))
+        {
+            Guild::SendCommandResult(this, GUILD_COMMAND_CREATE, ERR_GUILD_NAME_INVALID, newName);
+            return;
+        }
+    }
+    else
+    {
+        if (sArenaTeamMgr->GetArenaTeamByName(newName))
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, newName, "", ERR_ARENA_TEAM_NAME_EXISTS_S);
+            return;
+        }
+        if (sObjectMgr->IsReservedName(newName) || !ObjectMgr::IsValidCharterName(newName))
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, newName, "", ERR_ARENA_TEAM_NAME_INVALID);
+            return;
+        }
+    }
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PETITION_NAME);
+
+    stmt->setString(0, newName);
+    stmt->setUInt32(1, GUID_LOPART(petitionGuid));
+
+    CharacterDatabase.Execute(stmt);
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Petition (GUID: %u) renamed to '%s'", GUID_LOPART(petitionGuid), newName.c_str());
+    WorldPacket data(MSG_PETITION_RENAME, (8+newName.size()+1));
+    data << uint64(petitionGuid);
+    data << newName;
+    SendPacket(&data);
+}
+
+void WorldSession::HandlePetitionSignOpcode(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Received opcode CMSG_PETITION_SIGN");    // ok
+
+    Field* fields;
+    uint64 petitionGuid;
+    uint8 unk;
+    recvData >> petitionGuid;                              // petition guid
+    recvData >> unk;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIGNATURES);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionGuid));
+    stmt->setUInt32(1, GUID_LOPART(petitionGuid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (!result)
+    {
+        sLog->outError(LOG_FILTER_NETWORKIO, "Petition %u is not found for player %u %s", GUID_LOPART(petitionGuid), GetPlayer()->GetGUIDLow(), GetPlayer()->GetName().c_str());
+        return;
+    }
+
+    fields = result->Fetch();
+    uint64 ownerGuid = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+    uint64 signs = fields[1].GetUInt64();
+    uint8 type = fields[2].GetUInt8();
+
+    uint32 playerGuid = _player->GetGUIDLow();
+    if (GUID_LOPART(ownerGuid) == playerGuid)
+        return;
+
+    // not let enemies sign guild charter
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD) && GetPlayer()->GetTeam() != sObjectMgr->GetPlayerTeamByGUID(ownerGuid))
+    {
+        if (type != GUILD_CHARTER_TYPE)
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", "", ERR_ARENA_TEAM_NOT_ALLIED);
+        else
+            Guild::SendCommandResult(this, GUILD_COMMAND_CREATE, ERR_GUILD_NOT_ALLIED);
+        return;
+    }
+
+    if (type != GUILD_CHARTER_TYPE)
+    {
+        if (_player->getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, "", _player->GetName().c_str(), ERR_ARENA_TEAM_TARGET_TOO_LOW_S);
+            return;
+        }
+
+        uint8 slot = ArenaTeam::GetSlotByType(type);
+        if (slot >= MAX_ARENA_SLOT)
+            return;
+
+        if (_player->GetArenaTeamId(slot))
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", _player->GetName().c_str(), ERR_ALREADY_IN_ARENA_TEAM_S);
+            return;
+        }
+
+        if (_player->GetArenaTeamIdInvited())
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", _player->GetName().c_str(), ERR_ALREADY_INVITED_TO_ARENA_TEAM_S);
+            return;
+        }
+    }
+    else
+    {
+        if (_player->GetGuildId())
+        {
+            Guild::SendCommandResult(this, GUILD_COMMAND_INVITE, ERR_ALREADY_IN_GUILD_S, _player->GetName());
+            return;
+        }
+        if (_player->GetGuildIdInvited())
+        {
+            Guild::SendCommandResult(this, GUILD_COMMAND_INVITE, ERR_ALREADY_INVITED_TO_GUILD_S, _player->GetName());
+            return;
+        }
+    }
+
+    if (++signs > type)                                        // client signs maximum
+        return;
+
+    // Client doesn't allow to sign petition two times by one character, but not check sign by another character from same account
+    // not allow sign another player from already sign player account
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_ACCOUNT);
+
+    stmt->setUInt32(0, GetAccountId());
+    stmt->setUInt32(1, GUID_LOPART(petitionGuid));
+
+    result = CharacterDatabase.Query(stmt);
+
+    if (result)
+    {
+        WorldPacket data(SMSG_PETITION_SIGN_RESULTS, (8+8+4));
+        data << uint64(petitionGuid);
+        data << uint64(_player->GetGUID());
+        data << uint32(PETITION_SIGN_ALREADY_SIGNED);
+
+        // close at signer side
+        SendPacket(&data);
+        return;
+    }
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PETITION_SIGNATURE);
+
+    stmt->setUInt32(0, GUID_LOPART(ownerGuid));
+    stmt->setUInt32(1, GUID_LOPART(petitionGuid));
+    stmt->setUInt32(2, playerGuid);
+    stmt->setUInt32(3, GetAccountId());
+
+    CharacterDatabase.Execute(stmt);
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "PETITION SIGN: GUID %u by player: %s (GUID: %u Account: %u)", GUID_LOPART(petitionGuid), _player->GetName().c_str(), playerGuid, GetAccountId());
+
+    WorldPacket data(SMSG_PETITION_SIGN_RESULTS, (8+8+4));
+    data << uint64(petitionGuid);
+    data << uint64(_player->GetGUID());
+    data << uint32(PETITION_SIGN_OK);
+
+    // close at signer side
+    SendPacket(&data);
+
+    // update signs count on charter, required testing...
+    //Item* item = _player->GetItemByGuid(petitionguid));
+    //if (item)
+    //    item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1+1, signs);
+
+    // update for owner if online
+    if (Player* owner = ObjectAccessor::FindPlayer(ownerGuid))
+        owner->GetSession()->SendPacket(&data);
+}
+
+void WorldSession::HandlePetitionDeclineOpcode(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Received opcode MSG_PETITION_DECLINE");  // ok
+
+    uint64 petitionguid;
+    uint64 ownerguid;
+    recvData >> petitionguid;                              // petition guid
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Petition %u declined by %u", GUID_LOPART(petitionguid), _player->GetGUIDLow());
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_OWNER_BY_GUID);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionguid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (!result)
+        return;
+
+    Field* fields = result->Fetch();
+    ownerguid = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+
+    Player* owner = ObjectAccessor::FindPlayer(ownerguid);
+    if (owner)                                               // petition owner online
+    {
+        WorldPacket data(MSG_PETITION_DECLINE, 8);
+        data << uint64(_player->GetGUID());
+        owner->GetSession()->SendPacket(&data);
+    }
+}
+
+void WorldSession::HandleOfferPetitionOpcode(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Received opcode CMSG_OFFER_PETITION");   // ok
+
+    uint8 signs = 0;
+    uint64 petitionguid, plguid;
+    uint32 type, junk;
+    Player* player;
+    recvData >> junk;                                      // this is not petition type!
+    recvData >> petitionguid;                              // petition guid
+    recvData >> plguid;                                    // player guid
+
+    player = ObjectAccessor::FindPlayer(plguid);
+    if (!player)
+        return;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_TYPE);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionguid));
+
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (!result)
+        return;
+
+    Field* fields = result->Fetch();
+    type = fields[0].GetUInt8();
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "OFFER PETITION: type %u, GUID1 %u, to player id: %u", type, GUID_LOPART(petitionguid), GUID_LOPART(plguid));
+
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD) && GetPlayer()->GetTeam() != player->GetTeam())
+    {
+        if (type != GUILD_CHARTER_TYPE)
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", "", ERR_ARENA_TEAM_NOT_ALLIED);
+        else
+            Guild::SendCommandResult(this, GUILD_COMMAND_CREATE, ERR_GUILD_NOT_ALLIED);
+        return;
+    }
+
+    if (type != GUILD_CHARTER_TYPE)
+    {
+        if (player->getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        {
+            // player is too low level to join an arena team
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, player->GetName().c_str(), "", ERR_ARENA_TEAM_TARGET_TOO_LOW_S);
+            return;
+        }
+
+        uint8 slot = ArenaTeam::GetSlotByType(type);
+        if (slot >= MAX_ARENA_SLOT)
+            return;
+
+        if (player->GetArenaTeamId(slot))
+        {
+            // player is already in an arena team
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, player->GetName().c_str(), "", ERR_ALREADY_IN_ARENA_TEAM_S);
+            return;
+        }
+
+        if (player->GetArenaTeamIdInvited())
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", _player->GetName().c_str(), ERR_ALREADY_INVITED_TO_ARENA_TEAM_S);
+            return;
+        }
+    }
+    else
+    {
+        if (player->GetGuildId())
+        {
+            Guild::SendCommandResult(this, GUILD_COMMAND_INVITE, ERR_ALREADY_IN_GUILD_S, _player->GetName());
+            return;
+        }
+
+        if (player->GetGuildIdInvited())
+        {
+            Guild::SendCommandResult(this, GUILD_COMMAND_INVITE, ERR_ALREADY_INVITED_TO_GUILD_S, _player->GetName());
+            return;
+        }
+    }
+
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIGNATURE);
+
+    stmt->setUInt32(0, GUID_LOPART(petitionguid));
+
+    result = CharacterDatabase.Query(stmt);
+
+    // result == NULL also correct charter without signs
+    if (result)
+        signs = uint8(result->GetRowCount());
+
+    WorldPacket data(SMSG_PETITION_SHOW_SIGNATURES, (8+8+4+signs+signs*12));
+    data << uint64(petitionguid);                           // petition guid
+    data << uint64(_player->GetGUID());                     // owner guid
+    data << uint32(GUID_LOPART(petitionguid));              // guild guid
+    data << uint8(signs);                                   // sign's count
+
+    for (uint8 i = 1; i <= signs; ++i)
+    {
+        Field* fields2 = result->Fetch();
+        data << uint64(MAKE_NEW_GUID(fields2[0].GetUInt32(), 0, HIGHGUID_PLAYER)); // Player GUID
+        data << uint32(0);                                  // there 0 ...
+
+        result->NextRow();
+    }
+
+    player->GetSession()->SendPacket(&data);
+}
+
+void WorldSession::HandleTurnInPetitionOpcode(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Received opcode CMSG_TURN_IN_PETITION");
+
+    // Get petition guid from packet
+    WorldPacket data;
+    uint64 petitionGuid;
+
+    recvData >> petitionGuid;
+
+    // Check if player really has the required petition charter
+    Item* item = _player->GetItemByGuid(petitionGuid);
+    if (!item)
+        return;
+
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Petition %u turned in by %u", GUID_LOPART(petitionGuid), _player->GetGUIDLow());
+
+    // Get petition data from db
+    uint32 ownerguidlo;
+    uint32 type;
+    std::string name;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION);
+    stmt->setUInt32(0, GUID_LOPART(petitionGuid));
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        ownerguidlo = fields[0].GetUInt32();
+        name = fields[1].GetString();
+        type = fields[2].GetUInt8();
+    }
+    else
+    {
+        sLog->outError(LOG_FILTER_NETWORKIO, "Player %s (guid: %u) tried to turn in petition (guid: %u) that is not present in the database", _player->GetName().c_str(), _player->GetGUIDLow(), GUID_LOPART(petitionGuid));
+        return;
+    }
+
+    // Only the petition owner can turn in the petition
+    if (_player->GetGUIDLow() != ownerguidlo)
+        return;
+
+    // Petition type (guild/arena) specific checks
+    if (type == GUILD_CHARTER_TYPE)
+    {
+        // Check if player is already in a guild
+        if (_player->GetGuildId())
+        {
+            data.Initialize(SMSG_TURN_IN_PETITION_RESULTS, 4);
+            data << uint32(PETITION_TURN_ALREADY_IN_GUILD);
+            _player->GetSession()->SendPacket(&data);
+            return;
+        }
+
+        // Check if guild name is already taken
+        if (sGuildMgr->GetGuildByName(name))
+        {
+            Guild::SendCommandResult(this, GUILD_COMMAND_CREATE, ERR_GUILD_NAME_EXISTS_S, name);
+            return;
+        }
+    }
+    else
+    {
+        // Check for valid arena bracket (2v2, 3v3, 5v5)
+        uint8 slot = ArenaTeam::GetSlotByType(type);
+        if (slot >= MAX_ARENA_SLOT)
+            return;
+
+        // Check if player is already in an arena team
+        if (_player->GetArenaTeamId(slot))
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, name, "", ERR_ALREADY_IN_ARENA_TEAM);
+            return;
+        }
+
+        // Check if arena team name is already taken
+        if (sArenaTeamMgr->GetArenaTeamByName(name))
+        {
+            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, name, "", ERR_ARENA_TEAM_NAME_EXISTS_S);
+            return;
+        }
+    }
+
+    // Get petition signatures from db
+    uint8 signatures;
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIGNATURE);
+    stmt->setUInt32(0, GUID_LOPART(petitionGuid));
+    result = CharacterDatabase.Query(stmt);
+
+    if (result)
+        signatures = uint8(result->GetRowCount());
+    else
+        signatures = 0;
+
+    uint32 requiredSignatures;
+    if (type == GUILD_CHARTER_TYPE)
+        requiredSignatures = sWorld->getIntConfig(CONFIG_MIN_PETITION_SIGNS);
+    else
+        requiredSignatures = type-1;
+
+    // Notify player if signatures are missing
+    if (signatures < requiredSignatures)
+    {
+        data.Initialize(SMSG_TURN_IN_PETITION_RESULTS, 4);
+        data << (uint32)PETITION_TURN_NEED_MORE_SIGNATURES;
+        SendPacket(&data);
+        return;
+    }
+
+    // Proceed with guild/arena team creation
+
+    // Delete charter item
+    _player->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+
+    if (type == GUILD_CHARTER_TYPE)
+    {
+        // Create guild
+        Guild* guild = new Guild;
+
+        if (!guild->Create(_player, name))
+        {
+            delete guild;
+            return;
+        }
+
+        // Register guild and add guild master
+        sGuildMgr->AddGuild(guild);
+
+        Guild::SendCommandResult(this, GUILD_COMMAND_CREATE, ERR_GUILD_COMMAND_SUCCESS, name);
+
+        // Add members from signatures
+        for (uint8 i = 0; i < signatures; ++i)
+        {
+            Field* fields = result->Fetch();
+            guild->AddMember(MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER));
+            result->NextRow();
+        }
+    }
+    else
+    {
+        // Receive the rest of the packet in arena team creation case
+        uint32 background, icon, iconcolor, border, bordercolor;
+        recvData >> background >> icon >> iconcolor >> border >> bordercolor;
+
+        // Create arena team
+        ArenaTeam* arenaTeam = new ArenaTeam();
+
+        if (!arenaTeam->Create(_player->GetGUID(), type, name, background, icon, iconcolor, border, bordercolor))
+        {
+            delete arenaTeam;
+            return;
+        }
+
+        // Register arena team
+        sArenaTeamMgr->AddArenaTeam(arenaTeam);
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "PetitonsHandler: Arena team (guid: %u) added to ObjectMgr", arenaTeam->GetId());
+
+        // Add members
+        for (uint8 i = 0; i < signatures; ++i)
+        {
+            Field* fields = result->Fetch();
+            uint32 memberGUID = fields[0].GetUInt32();
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "PetitionsHandler: Adding arena team (guid: %u) member %u", arenaTeam->GetId(), memberGUID);
+            arenaTeam->AddMember(MAKE_NEW_GUID(memberGUID, 0, HIGHGUID_PLAYER));
+            result->NextRow();
+        }
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_GUID);
+    stmt->setUInt32(0, GUID_LOPART(petitionGuid));
+    trans->Append(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_GUID);
+    stmt->setUInt32(0, GUID_LOPART(petitionGuid));
+    trans->Append(stmt);
+
+    CharacterDatabase.CommitTransaction(trans);
+
+    // created
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "TURN IN PETITION GUID %u", GUID_LOPART(petitionGuid));
+
+    data.Initialize(SMSG_TURN_IN_PETITION_RESULTS, 4);
+    data << (uint32)PETITION_TURN_OK;
+    SendPacket(&data);
+}
+
+void WorldSession::HandlePetitionShowListOpcode(WorldPacket& recvData)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Received CMSG_PETITION_SHOWLIST");
+
+    uint64 guid;
+    recvData >> guid;
+
+    SendPetitionShowList(guid);
+}
+
+void WorldSession::SendPetitionShowList(uint64 guid)
+{
+    Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_PETITIONER);
+    if (!creature)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandlePetitionShowListOpcode - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(guid)));
+        return;
+    }
+
+    WorldPacket data(SMSG_PETITION_SHOWLIST, 8+1+4*6);
+    data << guid;                                           // npc guid
+
+    if (creature->IsTabardDesigner())
+    {
+        data << uint8(1);                                   // count
+        data << uint32(1);                                  // index
+        data << uint32(GUILD_CHARTER);                      // charter entry
+        data << uint32(CHARTER_DISPLAY_ID);                 // charter display id
+        data << uint32(GUILD_CHARTER_COST);                 // charter cost
+        data << uint32(0);                                  // unknown
+        data << uint32(sWorld->getIntConfig(CONFIG_MIN_PETITION_SIGNS)); // required signs
+    }
+    else
+    {
+        data << uint8(3);                                   // count
+        // 2v2
+        data << uint32(1);                                  // index
+        data << uint32(ARENA_TEAM_CHARTER_2v2);             // charter entry
+        data << uint32(CHARTER_DISPLAY_ID);                 // charter display id
+        data << uint32(ARENA_TEAM_CHARTER_2v2_COST);        // charter cost
+        data << uint32(2);                                  // unknown
+        data << uint32(2);                                  // required signs?
+        // 3v3
+        data << uint32(2);                                  // index
+        data << uint32(ARENA_TEAM_CHARTER_3v3);             // charter entry
+        data << uint32(CHARTER_DISPLAY_ID);                 // charter display id
+        data << uint32(ARENA_TEAM_CHARTER_3v3_COST);        // charter cost
+        data << uint32(3);                                  // unknown
+        data << uint32(3);                                  // required signs?
+        // 5v5
+        data << uint32(3);                                  // index
+        data << uint32(ARENA_TEAM_CHARTER_5v5);             // charter entry
+        data << uint32(CHARTER_DISPLAY_ID);                 // charter display id
+        data << uint32(ARENA_TEAM_CHARTER_5v5_COST);        // charter cost
+        data << uint32(5);                                  // unknown
+        data << uint32(5);                                  // required signs?
+    }
+
+    SendPacket(&data);
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "Sent SMSG_PETITION_SHOWLIST");
+}
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index ed4e18d..d293958 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1596,11 +1596,15 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
+// 1v1 Arena
+void AddSC_npc_1v1arena();
 #endif
 
 void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
+// 1v1 Arena
+    AddSC_npc_1v1arena();
 #endif
 }
diff --git a/src/server/game/Scripting/ScriptLoader.cpp.orig b/src/server/game/Scripting/ScriptLoader.cpp.orig
new file mode 100644
index 0000000..ed4e18d
--- /dev/null
+++ b/src/server/game/Scripting/ScriptLoader.cpp.orig
@@ -0,0 +1,1606 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ScriptLoader.h"
+#include "AnticheatMgr.h"
+
+//examples
+void AddSC_example_creature();
+void AddSC_example_escort();
+void AddSC_example_gossip_codebox();
+void AddSC_example_misc();
+void AddSC_example_commandscript();
+
+// spells
+void AddSC_deathknight_spell_scripts();
+void AddSC_druid_spell_scripts();
+void AddSC_generic_spell_scripts();
+void AddSC_hunter_spell_scripts();
+void AddSC_mage_spell_scripts();
+void AddSC_paladin_spell_scripts();
+void AddSC_priest_spell_scripts();
+void AddSC_rogue_spell_scripts();
+void AddSC_shaman_spell_scripts();
+void AddSC_warlock_spell_scripts();
+void AddSC_warrior_spell_scripts();
+void AddSC_quest_spell_scripts();
+void AddSC_item_spell_scripts();
+void AddSC_example_spell_scripts();
+void AddSC_holiday_spell_scripts();
+void AddSC_guild_spell_scripts();
+
+void AddSC_SmartSCripts();
+
+//Commands
+void AddSC_anticheat_commandscript();
+void AddSC_account_commandscript();
+void AddSC_achievement_commandscript();
+void AddSC_ban_commandscript();
+void AddSC_bf_commandscript();
+void AddSC_cast_commandscript();
+void AddSC_character_commandscript();
+void AddSC_cheat_commandscript();
+void AddSC_debug_commandscript();
+void AddSC_disable_commandscript();
+void AddSC_event_commandscript();
+void AddSC_gm_commandscript();
+void AddSC_go_commandscript();
+void AddSC_gobject_commandscript();
+void AddSC_guild_commandscript();
+void AddSC_honor_commandscript();
+void AddSC_instance_commandscript();
+void AddSC_learn_commandscript();
+void AddSC_lfg_commandscript();
+void AddSC_list_commandscript();
+void AddSC_lookup_commandscript();
+void AddSC_message_commandscript();
+void AddSC_misc_commandscript();
+void AddSC_mmaps_commandscript();
+void AddSC_modify_commandscript();
+void AddSC_npc_commandscript();
+void AddSC_quest_commandscript();
+void AddSC_reload_commandscript();
+void AddSC_reset_commandscript();
+void AddSC_server_commandscript();
+void AddSC_tele_commandscript();
+void AddSC_ticket_commandscript();
+void AddSC_titles_commandscript();
+void AddSC_wp_commandscript();
+void AddSC_commandscript();
+void AddSC_cms_commandscript();
+
+#ifdef SCRIPTS
+//world
+void AddSC_areatrigger_scripts();
+void AddSC_emerald_dragons();
+void AddSC_generic_creature();
+void AddSC_go_scripts();
+void AddSC_guards();
+void AddSC_item_scripts();
+void AddSC_npc_professions();
+void AddSC_npc_innkeeper();
+void AddSC_npcs_special();
+void AddSC_npc_taxi();
+void AddSC_achievement_scripts();
+void AddSC_boss_garr_hyjal();
+void AddSC_boss_city_kings();
+void AddSC_boss_akmahat();
+void AddSC_boss_mobus();
+void AddSC_boss_julak_doom();
+
+//eastern kingdoms
+void AddSC_alterac_valley();                 //Alterac Valley
+void AddSC_boss_balinda();
+void AddSC_boss_drekthar();
+void AddSC_boss_galvangar();
+void AddSC_boss_vanndar();
+void AddSC_boss_alizabal();                  //Baradin Hold
+void AddSC_boss_argaloth();
+void AddSC_boss_occuthar();
+void AddSC_instance_baradin_hold();
+void AddSC_blackwing_descent();
+void AddSC_instance_blackwing_descent();
+void AddSC_boss_magmaw();
+void AddSC_boss_omnotron_defense_system();
+void AddSC_boss_atramedes();
+void AddSC_boss_chimaeron();
+void AddSC_boss_maloriak();
+void AddSC_boss_bd_nefarian();
+void AddSC_boss_romogg_bonecrusher();        //Blackrock caverns
+void AddSC_boss_corla_herald_of_twilight();
+void AddSC_boss_karsh_steelbender();
+void AddSC_boss_beauty();
+void AddSC_boss_ascendant_lord_obsidius();
+void AddSC_instance_blackrock_caverns();
+void AddSC_blackrock_depths();               //Blackrock Depths
+void AddSC_boss_ambassador_flamelash();
+void AddSC_boss_anubshiah();
+void AddSC_boss_draganthaurissan();
+void AddSC_boss_general_angerforge();
+void AddSC_boss_gorosh_the_dervish();
+void AddSC_boss_grizzle();
+void AddSC_boss_high_interrogator_gerstahn();
+void AddSC_boss_magmus();
+void AddSC_boss_moira_bronzebeard();
+void AddSC_boss_tomb_of_seven();
+void AddSC_instance_blackrock_depths();
+void AddSC_boss_drakkisath();                //Blackrock Spire
+void AddSC_boss_halycon();
+void AddSC_boss_highlordomokk();
+void AddSC_boss_mothersmolderweb();
+void AddSC_boss_overlordwyrmthalak();
+void AddSC_boss_shadowvosh();
+void AddSC_boss_thebeast();
+void AddSC_boss_warmastervoone();
+void AddSC_boss_quatermasterzigris();
+void AddSC_boss_pyroguard_emberseer();
+void AddSC_boss_gyth();
+void AddSC_boss_rend_blackhand();
+void AddSC_boss_gizrul_the_slavener();
+void AddSC_boss_urok_doomhowl();
+void AddSC_boss_lord_valthalak();
+void AddSC_instance_blackrock_spire();
+void AddSC_boss_razorgore();                 //Blackwing lair
+void AddSC_boss_vael();
+void AddSC_boss_broodlord();
+void AddSC_boss_firemaw();
+void AddSC_boss_ebonroc();
+void AddSC_boss_flamegor();
+void AddSC_boss_chromaggus();
+void AddSC_boss_nefarian();
+void AddSC_boss_victor_nefarius();
+void AddSC_boss_mr_smite();
+void AddSC_instance_deadmines(); //Deadmine
+void AddSC_boss_glubtok();
+void AddSC_boss_foe_reaper_5000();
+void AddSC_boss_captain_cookie();
+void AddSC_boss_admiral_ripsnarl();
+void AddSC_deadmines();
+void AddSC_boss_vanessa_vancleef();
+void AddSC_boss_mr_smite();
+void AddSC_boss_helix_gearbreaker();
+void AddSC_gnomeregan();                     //Gnomeregan
+void AddSC_instance_gnomeregan();
+void AddSC_boss_attumen();                   //Karazhan
+void AddSC_boss_curator();
+void AddSC_boss_maiden_of_virtue();
+void AddSC_boss_shade_of_aran();
+void AddSC_boss_malchezaar();
+void AddSC_boss_terestian_illhoof();
+void AddSC_boss_moroes();
+void AddSC_bosses_opera();
+void AddSC_boss_netherspite();
+void AddSC_instance_karazhan();
+void AddSC_karazhan();
+void AddSC_boss_nightbane();
+void AddSC_boss_felblood_kaelthas();         // Magister's Terrace
+void AddSC_boss_selin_fireheart();
+void AddSC_boss_vexallus();
+void AddSC_boss_priestess_delrissa();
+void AddSC_instance_magisters_terrace();
+void AddSC_magisters_terrace();
+void AddSC_boss_lucifron();                  //Molten core
+void AddSC_boss_magmadar();
+void AddSC_boss_gehennas();
+void AddSC_boss_garr();
+void AddSC_boss_baron_geddon();
+void AddSC_boss_shazzrah();
+void AddSC_boss_golemagg();
+void AddSC_boss_sulfuron();
+void AddSC_boss_majordomo();
+void AddSC_boss_ragnaros();
+void AddSC_instance_molten_core();
+void AddSC_the_scarlet_enclave();            //Scarlet Enclave
+void AddSC_the_scarlet_enclave_c1();
+void AddSC_the_scarlet_enclave_c2();
+void AddSC_the_scarlet_enclave_c5();
+void AddSC_boss_arcanist_doan();             //Scarlet Monastery
+void AddSC_boss_azshir_the_sleepless();
+void AddSC_boss_bloodmage_thalnos();
+void AddSC_boss_headless_horseman();
+void AddSC_boss_herod();
+void AddSC_boss_jinara();
+void AddSC_boss_high_inquisitor_fairbanks();
+void AddSC_boss_houndmaster_loksey();
+void AddSC_boss_interrogator_vishas();
+void AddSC_boss_scorn();
+void AddSC_instance_scarlet_monastery();
+void AddSC_boss_mograine_and_whitemane();
+void AddSC_boss_darkmaster_gandling();       //Scholomance
+void AddSC_boss_death_knight_darkreaver();
+void AddSC_boss_theolenkrastinov();
+void AddSC_boss_illuciabarov();
+void AddSC_boss_instructormalicia();
+void AddSC_boss_jandicebarov();
+void AddSC_boss_kormok();
+void AddSC_boss_lordalexeibarov();
+void AddSC_boss_lorekeeperpolkelt();
+void AddSC_boss_rasfrost();
+void AddSC_boss_theravenian();
+void AddSC_boss_vectus();
+void AddSC_boss_kirtonos_the_herald();
+void AddSC_instance_scholomance();
+void AddSC_shadowfang_keep();                //Shadowfang keep
+void AddSC_instance_shadowfang_keep();
+void AddSC_boss_lord_walden();
+void AddSC_boss_lord_godfrey();
+void AddSC_boss_baron_silverlaine();
+void AddSC_boss_commander_springvale();
+void AddSC_boss_baron_ashbury();
+void AddSC_boss_magistrate_barthilas();      //Stratholme
+void AddSC_boss_maleki_the_pallid();
+void AddSC_boss_nerubenkan();
+void AddSC_boss_cannon_master_willey();
+void AddSC_boss_baroness_anastari();
+void AddSC_boss_ramstein_the_gorger();
+void AddSC_boss_timmy_the_cruel();
+void AddSC_boss_postmaster_malown();
+void AddSC_boss_baron_rivendare();
+void AddSC_boss_dathrohan_balnazzar();
+void AddSC_boss_order_of_silver_hand();
+void AddSC_instance_stratholme();
+void AddSC_stratholme();
+void AddSC_sunken_temple();                  // Sunken Temple
+void AddSC_instance_sunken_temple();
+void AddSC_instance_sunwell_plateau();       //Sunwell Plateau
+void AddSC_boss_kalecgos();
+void AddSC_boss_brutallus();
+void AddSC_boss_felmyst();
+void AddSC_boss_eredar_twins();
+void AddSC_boss_muru();
+void AddSC_boss_kiljaeden();
+void AddSC_sunwell_plateau();
+void AddSC_boss_archaedas();                 //Uldaman
+void AddSC_boss_ironaya();
+void AddSC_uldaman();
+void AddSC_instance_uldaman();
+void AddSC_boss_daakara();
+void AddSC_boss_akilzon();                   //Zul'Aman
+void AddSC_boss_halazzi();
+void AddSC_boss_hex_lord_malacrass();
+void AddSC_boss_janalai();
+void AddSC_boss_nalorakk();
+void AddSC_instance_zulaman();
+void AddSC_zulaman();
+void AddSC_boss_grilek();                   // Zul'Gurub
+void AddSC_boss_hazzarah();
+void AddSC_boss_jindo_the_godbreaker();
+void AddSC_boss_kilnara();
+void AddSC_boss_mandokir();
+void AddSC_boss_renataki();
+void AddSC_boss_venoxis();
+void AddSC_boss_wushoolay();
+void AddSC_boss_zanzil();
+void AddSC_instance_zulgurub();
+void AddSC_zulgurub();
+//void AddSC_alterac_mountains();
+void AddSC_elwynn_forest();
+void AddSC_arathi_highlands();
+void AddSC_blasted_lands();
+void AddSC_burning_steppes();
+void AddSC_duskwood();
+void AddSC_dun_morogh();
+void AddSC_eastern_plaguelands();
+void AddSC_eversong_woods();
+void AddSC_ghostlands();
+void AddSC_hinterlands();
+void AddSC_ironforge();
+void AddSC_isle_of_queldanas();
+void AddSC_loch_modan();
+void AddSC_redridge_mountains();
+void AddSC_silvermoon_city();
+void AddSC_silverpine_forest();
+void AddSC_stormwind_city();
+void AddSC_stranglethorn_vale();
+void AddSC_swamp_of_sorrows();
+void AddSC_tirisfal_glades();
+void AddSC_twilight_highlands();
+void AddSC_undercity();
+void AddSC_western_plaguelands();
+void AddSC_westfall();
+void AddSC_wetlands();
+void AddSC_gilneas();
+
+//kalimdor
+void AddSC_blackfathom_deeps();              //Blackfathom Depths
+void AddSC_boss_gelihast();
+void AddSC_boss_kelris();
+void AddSC_boss_aku_mai();
+void AddSC_instance_blackfathom_deeps();
+void AddSC_hyjal();                          //CoT Battle for Mt. Hyjal
+void AddSC_boss_archimonde();
+void AddSC_instance_mount_hyjal();
+void AddSC_hyjal_trash();
+void AddSC_boss_rage_winterchill();
+void AddSC_boss_anetheron();
+void AddSC_boss_kazrogal();
+void AddSC_boss_azgalor();
+void AddSC_boss_captain_skarloc();           //CoT Old Hillsbrad
+void AddSC_boss_epoch_hunter();
+void AddSC_boss_lieutenant_drake();
+void AddSC_instance_old_hillsbrad();
+void AddSC_old_hillsbrad();
+void AddSC_boss_aeonus();                    //CoT The Dark Portal
+void AddSC_boss_chrono_lord_deja();
+void AddSC_boss_temporus();
+void AddSC_dark_portal();
+void AddSC_instance_dark_portal();
+void AddSC_boss_epoch();                     //CoT Culling Of Stratholme
+void AddSC_boss_infinite_corruptor();
+void AddSC_boss_salramm();
+void AddSC_boss_mal_ganis();
+void AddSC_boss_meathook();
+void AddSC_culling_of_stratholme();
+void AddSC_instance_culling_of_stratholme();
+void AddSC_instance_halls_of_origination(); //Halls of Origination
+void AddSC_boss_temple_guardian_anhuur();
+void AddSC_boss_earthrager_ptah();
+void AddSC_boss_anraphet();
+void AddSC_boss_setesh();
+void AddSC_boss_ammunae();
+void AddSC_boss_rajh();
+void AddSC_boss_isiset();
+void AddSC_boss_general_husam();             //Lost city Tol'vir
+void AddSC_boss_siamat();
+void AddSC_boss_high_prophet_barim();
+void AddSC_boss_lockmaw();
+void AddSC_instance_lost_city_of_the_tolvir();
+void AddSC_lost_city_of_the_tolvir();
+void AddSC_trash_lost_city_of_tolvir();
+void AddSC_boss_celebras_the_cursed();       //Maraudon
+void AddSC_boss_landslide();
+void AddSC_boss_noxxion();
+void AddSC_boss_ptheradras();
+void AddSC_boss_onyxia();                    //Onyxia's Lair
+void AddSC_instance_onyxias_lair();
+void AddSC_boss_amnennar_the_coldbringer();  //Razorfen Downs
+void AddSC_razorfen_downs();
+void AddSC_instance_razorfen_downs();
+void AddSC_razorfen_kraul();                 //Razorfen Kraul
+void AddSC_instance_razorfen_kraul();
+void AddSC_boss_kurinnaxx();                 //Ruins of ahn'qiraj
+void AddSC_boss_rajaxx();
+void AddSC_boss_moam();
+void AddSC_boss_buru();
+void AddSC_boss_ayamiss();
+void AddSC_boss_ossirian();
+void AddSC_instance_ruins_of_ahnqiraj();
+void AddSC_boss_cthun();                     //Temple of ahn'qiraj
+void AddSC_boss_viscidus();
+void AddSC_boss_fankriss();
+void AddSC_boss_huhuran();
+void AddSC_bug_trio();
+void AddSC_boss_sartura();
+void AddSC_boss_skeram();
+void AddSC_boss_twinemperors();
+void AddSC_boss_ouro();
+void AddSC_mob_anubisath_sentinel();
+void AddSC_instance_temple_of_ahnqiraj();
+void AddSC_wailing_caverns();                //Wailing caverns
+void AddSC_instance_wailing_caverns();
+void AddSC_boss_zum_rah();
+void AddSC_zulfarrak();                     //Zul'Farrak generic
+void AddSC_instance_zulfarrak();            //Zul'Farrak instance script
+void AddSC_instance_firelands();            //Firelands instance script
+void AddSC_boss_shannox();
+void AddSC_boss_bethtilac();
+void AddSC_boss_alysrazor();
+void AddSC_boss_lord_rhyolith();
+void AddSC_boss_ragnaros_firelands();
+void AddSC_boss_baloroc();
+void AddSC_boss_majordomus();
+
+void AddSC_firelands();
+void AddSC_boss_grand_vizier_ertan();      //Vortex Pinnacle
+void AddSC_boss_asaad();
+void AddSC_instance_the_vortex_pinnacle();
+void AddSC_boss_altairus();
+void AddSC_vortex_pinnacle();
+void AddSC_boss_alakir();                        // Throne of the four Winds
+void AddSC_boss_conclave_of_wind();
+void AddSC_instance_throne_of_the_four_winds();
+void AddSC_throne_of_the_four_winds();
+void AddSC_boss_echo_of_baine();             // End Time
+void AddSC_boss_echo_of_jaina();
+void AddSC_boss_echo_of_sylvanas();
+void AddSC_boss_echo_of_tyrande();
+void AddSC_boss_murozond();
+void AddSC_instance_end_time();
+void AddSC_end_time_teleport();
+
+void AddSC_instance_hour_of_twilight();            // HoT
+void AddSC_boss_arcurion();
+void AddSC_boss_asira_dawnslayer();
+void AddSC_boss_archbishop_benedictus();
+void AddSC_trash_mobs_hot();
+
+        
+void AddSC_instance_well_of_eternity();         //Well Of Eternity
+void AddSC_well_of_eternity();	
+void AddSC_boss_queen_azshara();
+void AddSC_boss_mannoroth();
+void AddSC_boss_perotharn();
+void AddSC_well_of_eternity_teleport();	
+
+void AddSC_instance_dragon_soul();   // Dragon Soul
+void AddSC_dragon_soul_teleport_and_transport();
+void AddSC_boss_unsleeping();
+void AddSC_boss_warmaster_blackhorn();
+void AddSC_boss_warlord();
+void AddSC_boss_ultraxion();
+void AddSC_boss_morchok();
+void AddSC_boss_hagara();
+void AddSC_boss_deathwing();
+void AddSC_ashenvale();
+void AddSC_azshara();
+void AddSC_azuremyst_isle();
+void AddSC_bloodmyst_isle();
+void AddSC_darkshore();
+void AddSC_desolace();
+void AddSC_durotar();
+void AddSC_dustwallow_marsh();
+void AddSC_felwood();
+void AddSC_feralas();
+void AddSC_moonglade();
+void AddSC_molten_front();
+void AddSC_mulgore();
+void AddSC_orgrimmar();
+void AddSC_silithus();
+void AddSC_stonetalon_mountains();
+void AddSC_tanaris();
+void AddSC_teldrassil();
+void AddSC_the_barrens();
+void AddSC_thousand_needles();
+void AddSC_thunder_bluff();
+void AddSC_ungoro_crater();
+void AddSC_winterspring();
+
+//maelstrom
+void AddSC_kezan();
+void AddSC_deepholm();
+void AddSC_lost_isle();
+void AddSC_boss_corborus(); //the stonecore
+void AddSC_boss_azil();
+void AddSC_boss_ozruk();
+void AddSC_boss_slabhide();
+void AddSC_instance_the_stonecore();
+void AddSC_the_stonecore();
+
+//northrend
+void AddSC_boss_slad_ran();
+void AddSC_boss_moorabi();
+void AddSC_boss_drakkari_colossus();
+void AddSC_boss_gal_darah();
+void AddSC_boss_eck();
+void AddSC_instance_gundrak();
+void AddSC_boss_krik_thir();             //Azjol-Nerub
+void AddSC_boss_hadronox();
+void AddSC_boss_anub_arak();
+void AddSC_instance_azjol_nerub();
+void AddSC_instance_ahnkahet();          //Azjol-Nerub Ahn'kahet
+void AddSC_boss_amanitar();
+void AddSC_boss_taldaram();
+void AddSC_boss_jedoga_shadowseeker();
+void AddSC_boss_elder_nadox();
+void AddSC_boss_volazj();
+void AddSC_boss_argent_challenge();      //Trial of the Champion
+void AddSC_boss_black_knight();
+void AddSC_boss_grand_champions();
+void AddSC_instance_trial_of_the_champion();
+void AddSC_trial_of_the_champion();
+void AddSC_boss_anubarak_trial();        //Trial of the Crusader
+void AddSC_boss_faction_champions();
+void AddSC_boss_jaraxxus();
+void AddSC_boss_northrend_beasts();
+void AddSC_boss_twin_valkyr();
+void AddSC_trial_of_the_crusader();
+void AddSC_instance_trial_of_the_crusader();
+void AddSC_boss_anubrekhan();            //Naxxramas
+void AddSC_boss_maexxna();
+void AddSC_boss_patchwerk();
+void AddSC_boss_grobbulus();
+void AddSC_boss_razuvious();
+void AddSC_boss_kelthuzad();
+void AddSC_boss_loatheb();
+void AddSC_boss_noth();
+void AddSC_boss_gluth();
+void AddSC_boss_sapphiron();
+void AddSC_boss_four_horsemen();
+void AddSC_boss_faerlina();
+void AddSC_boss_heigan();
+void AddSC_boss_gothik();
+void AddSC_boss_thaddius();
+void AddSC_instance_naxxramas();
+void AddSC_boss_magus_telestra();        //The Nexus Nexus
+void AddSC_boss_anomalus();
+void AddSC_boss_ormorok();
+void AddSC_boss_keristrasza();
+void AddSC_instance_nexus();
+void AddSC_nexus();
+void AddSC_boss_drakos();                //The Nexus The Oculus
+void AddSC_boss_urom();
+void AddSC_boss_varos();
+void AddSC_boss_eregos();
+void AddSC_instance_oculus();
+void AddSC_oculus();
+void AddSC_boss_malygos();              // The Nexus: Eye of Eternity
+void AddSC_instance_eye_of_eternity();
+void AddSC_boss_sartharion();            //Obsidian Sanctum
+void AddSC_instance_obsidian_sanctum();
+void AddSC_boss_bjarngrim();             //Ulduar Halls of Lightning
+void AddSC_boss_loken();
+void AddSC_boss_ionar();
+void AddSC_boss_volkhan();
+void AddSC_instance_halls_of_lightning();
+void AddSC_boss_maiden_of_grief();       //Ulduar Halls of Stone
+void AddSC_boss_krystallus();
+void AddSC_boss_sjonnir();
+void AddSC_instance_halls_of_stone();
+void AddSC_halls_of_stone();
+void AddSC_boss_auriaya();               //Ulduar Ulduar
+void AddSC_boss_flame_leviathan();
+void AddSC_boss_ignis();
+void AddSC_boss_razorscale();
+void AddSC_boss_xt002();
+void AddSC_boss_kologarn();
+void AddSC_boss_assembly_of_iron();
+void AddSC_boss_general_vezax();
+void AddSC_ulduar_teleporter();
+void AddSC_boss_mimiron();
+void AddSC_boss_hodir();
+void AddSC_boss_freya();
+void AddSC_boss_algalon_the_observer();
+void AddSC_instance_ulduar();
+void AddSC_boss_keleseth();              //Utgarde Keep
+void AddSC_boss_skarvald_dalronn();
+void AddSC_boss_ingvar_the_plunderer();
+void AddSC_instance_utgarde_keep();
+void AddSC_boss_svala();                 //Utgarde pinnacle
+void AddSC_boss_palehoof();
+void AddSC_boss_skadi();
+void AddSC_boss_ymiron();
+void AddSC_instance_utgarde_pinnacle();
+void AddSC_utgarde_keep();
+void AddSC_boss_archavon();              //Vault of Archavon
+void AddSC_boss_emalon();
+void AddSC_boss_koralon();
+void AddSC_boss_toravon();
+void AddSC_instance_archavon();
+void AddSC_boss_trollgore();             //Drak'Tharon Keep
+void AddSC_boss_novos();
+void AddSC_boss_dred();
+void AddSC_boss_tharon_ja();
+void AddSC_instance_drak_tharon();
+void AddSC_boss_cyanigosa();             //Violet Hold
+void AddSC_boss_erekem();
+void AddSC_boss_ichoron();
+void AddSC_boss_lavanthor();
+void AddSC_boss_moragg();
+void AddSC_boss_xevozz();
+void AddSC_boss_zuramat();
+void AddSC_instance_violet_hold();
+void AddSC_violet_hold();
+void AddSC_instance_forge_of_souls();   //Forge of Souls
+void AddSC_forge_of_souls();
+void AddSC_boss_bronjahm();
+void AddSC_boss_devourer_of_souls();
+void AddSC_instance_pit_of_saron();     //Pit of Saron
+void AddSC_pit_of_saron();
+void AddSC_boss_garfrost();
+void AddSC_boss_ick();
+void AddSC_boss_tyrannus();
+void AddSC_instance_halls_of_reflection();   // Halls of Reflection
+void AddSC_halls_of_reflection();
+void AddSC_boss_falric();
+void AddSC_boss_marwyn();
+void AddSC_boss_lord_marrowgar();       // Icecrown Citadel
+void AddSC_boss_lady_deathwhisper();
+void AddSC_boss_deathbringer_saurfang();
+void AddSC_boss_festergut();
+void AddSC_boss_rotface();
+void AddSC_boss_professor_putricide();
+void AddSC_boss_blood_prince_council();
+void AddSC_boss_blood_queen_lana_thel();
+void AddSC_boss_valithria_dreamwalker();
+void AddSC_boss_sindragosa();
+void AddSC_boss_the_lich_king();
+void AddSC_icecrown_citadel_teleport();
+void AddSC_instance_icecrown_citadel();
+void AddSC_icecrown_citadel();
+void AddSC_instance_ruby_sanctum();      // Ruby Sanctum
+void AddSC_ruby_sanctum();
+void AddSC_boss_baltharus_the_warborn();
+void AddSC_boss_saviana_ragefire();
+void AddSC_boss_general_zarithrian();
+void AddSC_boss_halion();
+
+void AddSC_dalaran();
+void AddSC_borean_tundra();
+void AddSC_dragonblight();
+void AddSC_grizzly_hills();
+void AddSC_howling_fjord();
+void AddSC_icecrown();
+void AddSC_sholazar_basin();
+void AddSC_storm_peaks();
+void AddSC_wintergrasp();
+void AddSC_zuldrak();
+void AddSC_crystalsong_forest();
+void AddSC_isle_of_conquest();
+
+//outland
+void AddSC_boss_exarch_maladaar();           //Auchindoun Auchenai Crypts
+void AddSC_boss_shirrak_the_dead_watcher();
+void AddSC_instance_auchenai_crypts();
+void AddSC_boss_nexusprince_shaffar();       //Auchindoun Mana Tombs
+void AddSC_boss_pandemonius();
+void AddSC_instance_mana_tombs();
+void AddSC_boss_darkweaver_syth();           //Auchindoun Sekketh Halls
+void AddSC_boss_talon_king_ikiss();
+void AddSC_instance_sethekk_halls();
+void AddSC_boss_anzu();
+void AddSC_instance_shadow_labyrinth();      //Auchindoun Shadow Labyrinth
+void AddSC_boss_ambassador_hellmaw();
+void AddSC_boss_blackheart_the_inciter();
+void AddSC_boss_grandmaster_vorpil();
+void AddSC_boss_murmur();
+void AddSC_black_temple();                   //Black Temple
+void AddSC_boss_illidan();
+void AddSC_boss_shade_of_akama();
+void AddSC_boss_supremus();
+void AddSC_boss_gurtogg_bloodboil();
+void AddSC_boss_mother_shahraz();
+void AddSC_boss_reliquary_of_souls();
+void AddSC_boss_teron_gorefiend();
+void AddSC_boss_najentus();
+void AddSC_boss_illidari_council();
+void AddSC_instance_black_temple();
+void AddSC_boss_fathomlord_karathress();     //CR Serpent Shrine Cavern
+void AddSC_boss_hydross_the_unstable();
+void AddSC_boss_lady_vashj();
+void AddSC_boss_leotheras_the_blind();
+void AddSC_boss_morogrim_tidewalker();
+void AddSC_instance_serpentshrine_cavern();
+void AddSC_boss_the_lurker_below();
+void AddSC_boss_hydromancer_thespia();       //CR Steam Vault
+void AddSC_boss_mekgineer_steamrigger();
+void AddSC_boss_warlord_kalithresh();
+void AddSC_instance_steam_vault();
+void AddSC_boss_hungarfen();                 //CR Underbog
+void AddSC_boss_the_black_stalker();
+
+void AddSC_instance_the_slave_pens();        // Salve Pens
+void AddSC_boss_quagmirran();
+void AddSC_boss_rokmar_the_crackler();
+void AddSC_boss_ahune();
+void AddSC_boss_mennu_the_betrayer();
+
+void AddSC_boss_gruul();                     //Gruul's Lair
+void AddSC_boss_high_king_maulgar();
+void AddSC_instance_gruuls_lair();
+void AddSC_boss_broggok();                   //HC Blood Furnace
+void AddSC_boss_kelidan_the_breaker();
+void AddSC_boss_the_maker();
+void AddSC_instance_blood_furnace();
+void AddSC_boss_magtheridon();               //HC Magtheridon's Lair
+void AddSC_instance_magtheridons_lair();
+void AddSC_boss_grand_warlock_nethekurse();  //HC Shattered Halls
+void AddSC_boss_warbringer_omrogg();
+void AddSC_boss_warchief_kargath_bladefist();
+void AddSC_instance_shattered_halls();
+void AddSC_boss_watchkeeper_gargolmar();     //HC Ramparts
+void AddSC_boss_omor_the_unscarred();
+void AddSC_boss_vazruden_the_herald();
+void AddSC_instance_ramparts();
+void AddSC_arcatraz();                       //TK Arcatraz
+void AddSC_boss_harbinger_skyriss();
+void AddSC_instance_arcatraz();
+void AddSC_boss_high_botanist_freywinn();    //TK Botanica
+void AddSC_boss_laj();
+void AddSC_boss_warp_splinter();
+void AddSC_boss_thorngrin_the_tender();
+void AddSC_boss_commander_sarannis();
+void AddSC_instance_the_botanica();
+void AddSC_boss_alar();                      //TK The Eye
+void AddSC_boss_kaelthas();
+void AddSC_boss_void_reaver();
+void AddSC_boss_high_astromancer_solarian();
+void AddSC_instance_the_eye();
+void AddSC_the_eye();
+void AddSC_boss_gatewatcher_iron_hand();     //TK The Mechanar
+void AddSC_boss_gatewatcher_gyrokill();
+void AddSC_boss_nethermancer_sepethrea();
+void AddSC_boss_pathaleon_the_calculator();
+void AddSC_boss_mechano_lord_capacitus();
+void AddSC_instance_mechanar();
+
+void AddSC_blades_edge_mountains();
+void AddSC_boss_doomlordkazzak();
+void AddSC_boss_doomwalker();
+void AddSC_hellfire_peninsula();
+void AddSC_nagrand();
+void AddSC_netherstorm();
+void AddSC_shadowmoon_valley();
+void AddSC_shattrath_city();
+void AddSC_terokkar_forest();
+void AddSC_zangarmarsh();
+
+void AddSC_instance_throne_of_the_tides();      //Throne of the Tides
+void AddSC_boss_nazjar();
+void AddSC_boss_ulthok();
+void AddSC_boss_erunak_stonespeaker();
+void AddSC_boss_ozumat();
+
+void AddSC_bastion_of_twilight();
+void AddSC_instance_bastion_of_twilight();
+void AddSC_boss_halfus();
+void AddSC_boss_valiona_theralion();
+void AddSC_boss_ascendant_council();
+void AddSC_boss_chogall();
+void AddSC_boss_sinestra();
+
+
+void AddSC_instance_grim_batol();// Dungeon Grim Batol
+void AddSC_boss_drahga_shadowburner();
+void AddSC_boss_erudax();
+void AddSC_boss_forgemaster_throngus();
+void AddSC_boss_general_umbriss();
+void AddSC_mob_trash_grim_batol();
+void AddSC_grimbatol();
+
+// Events
+void AddSC_event_childrens_week();
+
+// battlegrounds
+
+// outdoor pvp
+void AddSC_outdoorpvp_hp();
+void AddSC_outdoorpvp_na();
+void AddSC_outdoorpvp_si();
+void AddSC_outdoorpvp_tf();
+void AddSC_outdoorpvp_zm();
+void AddSC_outdoorpvp_gh();
+
+// player
+void AddSC_chat_log();
+
+#endif
+
+void AddScripts()
+{
+    AddExampleScripts();
+    AddSpellScripts();
+    AddSC_SmartSCripts();
+    AddCommandScripts();
+    sAnticheatMgr->StartScripts();
+#ifdef SCRIPTS
+    AddWorldScripts();
+    AddEasternKingdomsScripts();
+    AddKalimdorScripts();
+    AddOutlandScripts();
+    AddMaelstromScripts();
+    AddNorthrendScripts();
+    AddBattlegroundScripts();
+    AddOutdoorPvPScripts();
+    AddCustomScripts();
+#endif
+}
+
+void AddExampleScripts()
+{
+    AddSC_example_creature();
+    AddSC_example_escort();
+    AddSC_example_gossip_codebox();
+    AddSC_example_misc();
+    AddSC_example_commandscript();
+}
+
+void AddSpellScripts()
+{
+    AddSC_deathknight_spell_scripts();
+    AddSC_druid_spell_scripts();
+    AddSC_generic_spell_scripts();
+    AddSC_hunter_spell_scripts();
+    AddSC_mage_spell_scripts();
+    AddSC_paladin_spell_scripts();
+    AddSC_priest_spell_scripts();
+    AddSC_rogue_spell_scripts();
+    AddSC_shaman_spell_scripts();
+    AddSC_warlock_spell_scripts();
+    AddSC_warrior_spell_scripts();
+    AddSC_quest_spell_scripts();
+    AddSC_item_spell_scripts();
+    AddSC_example_spell_scripts();
+    AddSC_holiday_spell_scripts();
+    AddSC_guild_spell_scripts();
+}
+
+void AddCommandScripts()
+{
+    AddSC_anticheat_commandscript();
+    AddSC_account_commandscript();
+    AddSC_achievement_commandscript();
+    AddSC_ban_commandscript();
+    AddSC_bf_commandscript();
+    AddSC_cast_commandscript();
+    AddSC_character_commandscript();
+    AddSC_cheat_commandscript();
+    AddSC_debug_commandscript();
+    AddSC_disable_commandscript();
+    AddSC_event_commandscript();
+    AddSC_gm_commandscript();
+    AddSC_go_commandscript();
+    AddSC_gobject_commandscript();
+    AddSC_guild_commandscript();
+    AddSC_honor_commandscript();
+    AddSC_instance_commandscript();
+    AddSC_learn_commandscript();
+    AddSC_lfg_commandscript();
+    AddSC_list_commandscript();
+	AddSC_lookup_commandscript();
+    AddSC_message_commandscript();
+    AddSC_misc_commandscript();
+    AddSC_mmaps_commandscript();
+    AddSC_modify_commandscript();
+    AddSC_npc_commandscript();
+    AddSC_quest_commandscript();
+    AddSC_reload_commandscript();
+    AddSC_reset_commandscript();
+    AddSC_server_commandscript();
+    AddSC_tele_commandscript();
+    AddSC_ticket_commandscript();
+    AddSC_titles_commandscript();
+	AddSC_wp_commandscript();
+    AddSC_commandscript();
+    AddSC_cms_commandscript();
+}
+
+void AddWorldScripts()
+{
+#ifdef SCRIPTS
+    AddSC_areatrigger_scripts();
+    AddSC_emerald_dragons();
+    AddSC_generic_creature();
+    AddSC_go_scripts();
+    AddSC_guards();
+    AddSC_item_scripts();
+    AddSC_npc_professions();
+    AddSC_npc_innkeeper();
+    AddSC_npcs_special();
+    AddSC_npc_taxi();
+    AddSC_achievement_scripts();
+    AddSC_boss_garr_hyjal();
+    AddSC_boss_city_kings();
+    AddSC_boss_akmahat();
+    AddSC_boss_mobus();
+    AddSC_boss_julak_doom();
+    AddSC_chat_log();
+#endif
+}
+
+void AddEasternKingdomsScripts()
+{
+#ifdef SCRIPTS
+    AddSC_alterac_valley();                 //Alterac Valley
+    AddSC_boss_balinda();
+    AddSC_boss_drekthar();
+    AddSC_boss_galvangar();
+    AddSC_boss_vanndar();
+    AddSC_boss_alizabal();                  //Baradin Hold
+    AddSC_boss_argaloth();
+    AddSC_boss_occuthar();
+    AddSC_instance_baradin_hold();
+      // BWD
+    AddSC_blackwing_descent();
+    AddSC_instance_blackwing_descent();
+    AddSC_boss_magmaw();
+    AddSC_boss_omnotron_defense_system();
+    AddSC_boss_atramedes();
+    AddSC_boss_chimaeron();
+    AddSC_boss_maloriak();
+    AddSC_boss_bd_nefarian();
+    AddSC_boss_romogg_bonecrusher();        //Blackrock caverns
+    AddSC_boss_corla_herald_of_twilight();
+    AddSC_boss_karsh_steelbender();
+    AddSC_boss_beauty();
+    AddSC_boss_ascendant_lord_obsidius();
+    AddSC_instance_blackrock_caverns();
+    AddSC_blackrock_depths();               //Blackrock Depths
+    AddSC_boss_ambassador_flamelash();
+    AddSC_boss_anubshiah();
+    AddSC_boss_draganthaurissan();
+    AddSC_boss_general_angerforge();
+    AddSC_boss_gorosh_the_dervish();
+    AddSC_boss_grizzle();
+    AddSC_boss_high_interrogator_gerstahn();
+    AddSC_boss_magmus();
+    AddSC_boss_moira_bronzebeard();
+    AddSC_boss_tomb_of_seven();
+    AddSC_instance_blackrock_depths();
+    AddSC_boss_drakkisath();                //Blackrock Spire
+    AddSC_boss_halycon();
+    AddSC_boss_highlordomokk();
+    AddSC_boss_mothersmolderweb();
+    AddSC_boss_overlordwyrmthalak();
+    AddSC_boss_shadowvosh();
+    AddSC_boss_thebeast();
+    AddSC_boss_warmastervoone();
+    AddSC_boss_quatermasterzigris();
+    AddSC_boss_pyroguard_emberseer();
+    AddSC_boss_gyth();
+    AddSC_boss_rend_blackhand();
+    AddSC_boss_gizrul_the_slavener();
+    AddSC_boss_urok_doomhowl();
+    AddSC_boss_lord_valthalak();	
+    AddSC_instance_blackrock_spire();
+    AddSC_boss_razorgore();                 //Blackwing lair
+    AddSC_boss_vael();
+    AddSC_boss_broodlord();
+    AddSC_boss_firemaw();
+    AddSC_boss_ebonroc();
+    AddSC_boss_flamegor();
+    AddSC_boss_chromaggus();
+    AddSC_boss_nefarian();
+    AddSC_boss_victor_nefarius();
+    AddSC_instance_deadmines(); //Deadmine
+    AddSC_boss_glubtok();
+    AddSC_boss_foe_reaper_5000();
+    AddSC_boss_captain_cookie();
+    AddSC_boss_admiral_ripsnarl();
+    AddSC_deadmines();
+    AddSC_boss_vanessa_vancleef();
+    AddSC_boss_mr_smite();
+    AddSC_boss_helix_gearbreaker();
+    AddSC_gnomeregan();                     //Gnomeregan
+    AddSC_instance_gnomeregan();
+    AddSC_boss_attumen();                   //Karazhan
+    AddSC_boss_curator();
+    AddSC_boss_maiden_of_virtue();
+    AddSC_boss_shade_of_aran();
+    AddSC_boss_malchezaar();
+    AddSC_boss_terestian_illhoof();
+    AddSC_boss_moroes();
+    AddSC_bosses_opera();
+    AddSC_boss_netherspite();
+    AddSC_instance_karazhan();
+    AddSC_karazhan();
+    AddSC_boss_nightbane();
+    AddSC_boss_felblood_kaelthas();         // Magister's Terrace
+    AddSC_boss_selin_fireheart();
+    AddSC_boss_vexallus();
+    AddSC_boss_priestess_delrissa();
+    AddSC_instance_magisters_terrace();
+    AddSC_magisters_terrace();
+    AddSC_boss_lucifron();                  //Molten core
+    AddSC_boss_magmadar();
+    AddSC_boss_gehennas();
+    AddSC_boss_garr();
+    AddSC_boss_baron_geddon();
+    AddSC_boss_shazzrah();
+    AddSC_boss_golemagg();
+    AddSC_boss_sulfuron();
+    AddSC_boss_majordomo();
+    AddSC_boss_ragnaros();
+    AddSC_instance_molten_core();
+    AddSC_the_scarlet_enclave();            //Scarlet Enclave
+    AddSC_the_scarlet_enclave_c1();
+    AddSC_the_scarlet_enclave_c2();
+    AddSC_the_scarlet_enclave_c5();
+    AddSC_boss_arcanist_doan();             //Scarlet Monastery
+    AddSC_boss_azshir_the_sleepless();
+    AddSC_boss_bloodmage_thalnos();
+    AddSC_boss_headless_horseman();
+    AddSC_boss_herod();
+    AddSC_boss_jinara();
+    AddSC_boss_high_inquisitor_fairbanks();
+    AddSC_boss_houndmaster_loksey();
+    AddSC_boss_interrogator_vishas();
+    AddSC_boss_scorn();
+    AddSC_instance_scarlet_monastery();
+    AddSC_boss_mograine_and_whitemane();
+    AddSC_boss_darkmaster_gandling();       //Scholomance
+    AddSC_boss_death_knight_darkreaver();
+    AddSC_boss_theolenkrastinov();
+    AddSC_boss_illuciabarov();
+    AddSC_boss_instructormalicia();
+    AddSC_boss_jandicebarov();
+    AddSC_boss_kormok();
+    AddSC_boss_lordalexeibarov();
+    AddSC_boss_lorekeeperpolkelt();
+    AddSC_boss_rasfrost();
+    AddSC_boss_theravenian();
+    AddSC_boss_vectus();
+    AddSC_boss_kirtonos_the_herald();
+    AddSC_instance_scholomance();
+    AddSC_shadowfang_keep();                //Shadowfang keep
+    AddSC_instance_shadowfang_keep();
+    AddSC_boss_lord_walden();
+    AddSC_boss_lord_godfrey();
+    AddSC_boss_baron_silverlaine();
+    AddSC_boss_commander_springvale();
+    AddSC_boss_baron_ashbury();
+    AddSC_boss_magistrate_barthilas();      //Stratholme
+    AddSC_boss_maleki_the_pallid();
+    AddSC_boss_nerubenkan();
+    AddSC_boss_cannon_master_willey();
+    AddSC_boss_baroness_anastari();
+    AddSC_boss_ramstein_the_gorger();
+    AddSC_boss_timmy_the_cruel();
+    AddSC_boss_postmaster_malown();
+    AddSC_boss_baron_rivendare();
+    AddSC_boss_dathrohan_balnazzar();
+    AddSC_boss_order_of_silver_hand();
+    AddSC_instance_stratholme();
+    AddSC_stratholme();
+    AddSC_sunken_temple();                  // Sunken Temple
+    AddSC_instance_sunken_temple();
+    AddSC_instance_sunwell_plateau();       //Sunwell Plateau
+    AddSC_boss_kalecgos();
+    AddSC_boss_brutallus();
+    AddSC_boss_felmyst();
+    AddSC_boss_eredar_twins();
+    AddSC_boss_muru();
+    AddSC_boss_kiljaeden();
+    AddSC_sunwell_plateau();
+    AddSC_boss_archaedas();                 //Uldaman
+    AddSC_boss_ironaya();
+    AddSC_uldaman();
+    AddSC_instance_uldaman();
+    AddSC_boss_akilzon();     
+	AddSC_boss_daakara(); //Zul'Aman
+    AddSC_boss_halazzi();
+    AddSC_boss_hex_lord_malacrass();
+    AddSC_boss_janalai();
+    AddSC_boss_nalorakk();
+    AddSC_instance_zulaman();
+    AddSC_zulaman();
+    AddSC_boss_grilek();                    // Zul'Gurub
+    AddSC_boss_hazzarah();
+    AddSC_boss_jindo_the_godbreaker();
+    AddSC_boss_kilnara();
+    AddSC_boss_mandokir();
+    AddSC_boss_renataki();
+    AddSC_boss_venoxis();
+    AddSC_boss_wushoolay();
+    AddSC_boss_zanzil();
+    AddSC_instance_zulgurub();
+    AddSC_zulgurub();
+    AddSC_instance_grim_batol();// Dungeon Grim Batol
+    AddSC_boss_drahga_shadowburner();
+    AddSC_boss_erudax();
+    AddSC_boss_forgemaster_throngus();
+    AddSC_boss_general_umbriss();
+    AddSC_mob_trash_grim_batol();
+	AddSC_grimbatol();
+
+    //AddSC_alterac_mountains();
+    AddSC_elwynn_forest();
+    AddSC_arathi_highlands();
+    AddSC_blasted_lands();
+    AddSC_burning_steppes();
+    AddSC_dun_morogh();
+    AddSC_duskwood();
+    AddSC_eastern_plaguelands();
+    AddSC_eversong_woods();
+    AddSC_ghostlands();
+    AddSC_hinterlands();
+    AddSC_ironforge();
+    AddSC_isle_of_queldanas();
+    AddSC_loch_modan();
+    AddSC_redridge_mountains();
+    AddSC_silvermoon_city();
+    AddSC_silverpine_forest();
+    AddSC_stormwind_city();
+    AddSC_stranglethorn_vale();
+    AddSC_swamp_of_sorrows();
+    AddSC_tirisfal_glades();
+    AddSC_twilight_highlands();
+    AddSC_undercity();
+    AddSC_western_plaguelands();
+    AddSC_westfall();
+    AddSC_wetlands();
+    AddSC_gilneas();
+#endif
+}
+
+void AddKalimdorScripts()
+{
+#ifdef SCRIPTS
+    AddSC_blackfathom_deeps();              //Blackfathom Depths
+    AddSC_boss_gelihast();
+    AddSC_boss_kelris();
+    AddSC_boss_aku_mai();
+    AddSC_instance_blackfathom_deeps();
+    AddSC_hyjal();                          //CoT Battle for Mt. Hyjal
+    AddSC_boss_archimonde();
+    AddSC_instance_mount_hyjal();
+    AddSC_hyjal_trash();
+    AddSC_boss_rage_winterchill();
+    AddSC_boss_anetheron();
+    AddSC_boss_kazrogal();
+    AddSC_boss_azgalor();
+    AddSC_boss_captain_skarloc();           //CoT Old Hillsbrad
+    AddSC_boss_epoch_hunter();
+    AddSC_boss_lieutenant_drake();
+    AddSC_instance_old_hillsbrad();
+    AddSC_old_hillsbrad();
+    AddSC_boss_aeonus();                    //CoT The Dark Portal
+    AddSC_boss_chrono_lord_deja();
+    AddSC_boss_temporus();
+    AddSC_dark_portal();
+    AddSC_instance_dark_portal();
+    AddSC_boss_epoch();                     //CoT Culling Of Stratholme
+    AddSC_boss_infinite_corruptor();
+    AddSC_boss_salramm();
+    AddSC_boss_mal_ganis();
+    AddSC_boss_meathook();
+    AddSC_culling_of_stratholme();
+    AddSC_instance_culling_of_stratholme();
+    AddSC_boss_temple_guardian_anhuur();  //Halls of Origination
+    AddSC_boss_earthrager_ptah();
+    AddSC_boss_anraphet();
+    AddSC_boss_setesh();
+    AddSC_boss_ammunae();
+    AddSC_boss_rajh();
+    AddSC_boss_isiset();
+    AddSC_instance_halls_of_origination();
+    AddSC_boss_general_husam();             //Lost city Tol'vir
+    AddSC_boss_siamat();
+    AddSC_boss_high_prophet_barim();
+    AddSC_boss_lockmaw();
+    AddSC_instance_lost_city_of_the_tolvir();
+	AddSC_lost_city_of_the_tolvir();
+	AddSC_trash_lost_city_of_tolvir();
+    AddSC_boss_celebras_the_cursed();       //Maraudon
+    AddSC_boss_landslide();
+    AddSC_boss_noxxion();
+    AddSC_boss_ptheradras();
+    AddSC_boss_onyxia();                    //Onyxia's Lair
+    AddSC_instance_onyxias_lair();
+    AddSC_boss_amnennar_the_coldbringer();  //Razorfen Downs
+    AddSC_razorfen_downs();
+    AddSC_instance_razorfen_downs();
+    AddSC_razorfen_kraul();                 //Razorfen Kraul
+    AddSC_instance_razorfen_kraul();
+    AddSC_boss_kurinnaxx();                 //Ruins of ahn'qiraj
+    AddSC_boss_rajaxx();
+    AddSC_boss_moam();
+    AddSC_boss_buru();
+    AddSC_boss_ayamiss();
+    AddSC_boss_ossirian();
+    AddSC_instance_ruins_of_ahnqiraj();
+    AddSC_boss_cthun();                     //Temple of ahn'qiraj
+    AddSC_boss_viscidus();
+    AddSC_boss_fankriss();
+    AddSC_boss_huhuran();
+    AddSC_bug_trio();
+    AddSC_boss_sartura();
+    AddSC_boss_skeram();
+    AddSC_boss_twinemperors();
+    AddSC_boss_ouro();
+    AddSC_mob_anubisath_sentinel();
+    AddSC_instance_temple_of_ahnqiraj();
+    AddSC_wailing_caverns();                //Wailing caverns
+    AddSC_instance_wailing_caverns();
+	AddSC_boss_zum_rah();
+    AddSC_zulfarrak();                      //Zul'Farrak generic
+    AddSC_instance_zulfarrak();             //Zul'Farrak instance script
+    AddSC_boss_grand_vizier_ertan();      //Vortex Pinnacle
+    AddSC_boss_asaad();
+    AddSC_instance_the_vortex_pinnacle();
+    AddSC_boss_altairus();
+    AddSC_vortex_pinnacle();
+    AddSC_boss_alakir();                        // Throne of the four Winds
+    AddSC_boss_conclave_of_wind();
+    AddSC_instance_throne_of_the_four_winds();
+    AddSC_throne_of_the_four_winds();
+    AddSC_boss_echo_of_baine();             // End Time
+    AddSC_boss_echo_of_jaina();
+    AddSC_boss_echo_of_sylvanas();
+    AddSC_boss_echo_of_tyrande();
+    AddSC_boss_murozond();
+    AddSC_instance_end_time();
+    AddSC_end_time_teleport();
+	
+    AddSC_instance_hour_of_twilight();            // HoT
+    AddSC_boss_arcurion();
+    AddSC_boss_asira_dawnslayer();
+    AddSC_boss_archbishop_benedictus();
+    AddSC_trash_mobs_hot();
+    
+    AddSC_instance_well_of_eternity();         //Well Of Eternity
+    AddSC_well_of_eternity();	
+    AddSC_boss_queen_azshara();
+    AddSC_boss_mannoroth();
+    AddSC_boss_perotharn();
+    AddSC_well_of_eternity_teleport();	
+	
+    AddSC_instance_dragon_soul();   // Dragon Soul
+    AddSC_dragon_soul_teleport_and_transport();
+    AddSC_boss_unsleeping();
+    AddSC_boss_warmaster_blackhorn();
+    AddSC_boss_warlord();
+    AddSC_boss_ultraxion();
+    AddSC_boss_morchok();
+    AddSC_boss_hagara();
+    AddSC_boss_deathwing();
+
+    AddSC_ashenvale();
+    AddSC_azshara();
+    AddSC_azuremyst_isle();
+    AddSC_bloodmyst_isle();
+    AddSC_darkshore();
+    AddSC_desolace();
+    AddSC_durotar();
+    AddSC_dustwallow_marsh();
+    AddSC_felwood();
+    AddSC_feralas();
+    AddSC_moonglade();
+	AddSC_molten_front();
+    AddSC_mulgore();
+    AddSC_orgrimmar();
+    AddSC_silithus();
+    AddSC_stonetalon_mountains();
+    AddSC_tanaris();
+    AddSC_teldrassil();
+    AddSC_the_barrens();
+    AddSC_thousand_needles();
+    AddSC_thunder_bluff();
+    AddSC_ungoro_crater();
+    AddSC_winterspring();
+    AddSC_instance_firelands();  //Firelands instance script
+    AddSC_boss_shannox();
+    AddSC_boss_bethtilac();
+    AddSC_boss_alysrazor();
+    AddSC_boss_lord_rhyolith();
+    AddSC_boss_ragnaros_firelands();
+    AddSC_boss_baloroc();
+    AddSC_boss_majordomus();
+    AddSC_firelands();
+  
+#endif
+}
+
+void AddOutlandScripts()
+{
+#ifdef SCRIPTS
+    AddSC_boss_exarch_maladaar();           //Auchindoun Auchenai Crypts
+    AddSC_boss_shirrak_the_dead_watcher();
+	AddSC_instance_auchenai_crypts();
+    AddSC_boss_nexusprince_shaffar();       //Auchindoun Mana Tombs
+    AddSC_boss_pandemonius();
+	AddSC_instance_mana_tombs();
+    AddSC_boss_darkweaver_syth();           //Auchindoun Sekketh Halls
+    AddSC_boss_talon_king_ikiss();
+    AddSC_instance_sethekk_halls();
+	AddSC_boss_anzu();
+    AddSC_instance_shadow_labyrinth();      //Auchindoun Shadow Labyrinth
+    AddSC_boss_ambassador_hellmaw();
+    AddSC_boss_blackheart_the_inciter();
+    AddSC_boss_grandmaster_vorpil();
+    AddSC_boss_murmur();
+    AddSC_black_temple();                   //Black Temple
+    AddSC_boss_illidan();
+    AddSC_boss_shade_of_akama();
+    AddSC_boss_supremus();
+    AddSC_boss_gurtogg_bloodboil();
+    AddSC_boss_mother_shahraz();
+    AddSC_boss_reliquary_of_souls();
+    AddSC_boss_teron_gorefiend();
+    AddSC_boss_najentus();
+    AddSC_boss_illidari_council();
+    AddSC_instance_black_temple();
+    AddSC_boss_fathomlord_karathress();     //CR Serpent Shrine Cavern
+    AddSC_boss_hydross_the_unstable();
+    AddSC_boss_lady_vashj();
+    AddSC_boss_leotheras_the_blind();
+    AddSC_boss_morogrim_tidewalker();
+    AddSC_instance_serpentshrine_cavern();
+    AddSC_boss_the_lurker_below();
+    AddSC_boss_hydromancer_thespia();       //CR Steam Vault
+    AddSC_boss_mekgineer_steamrigger();
+    AddSC_boss_warlord_kalithresh();
+    AddSC_instance_steam_vault();
+    AddSC_boss_hungarfen();                 //CR Underbog
+    AddSC_boss_the_black_stalker();
+    AddSC_boss_gruul();                     //Gruul's Lair
+	
+    AddSC_instance_the_slave_pens();        // Salve Pens
+    AddSC_boss_quagmirran();
+    AddSC_boss_rokmar_the_crackler();
+    AddSC_boss_ahune();
+    AddSC_boss_mennu_the_betrayer();	
+	
+    AddSC_boss_high_king_maulgar();
+    AddSC_instance_gruuls_lair();
+    AddSC_boss_broggok();                   //HC Blood Furnace
+    AddSC_boss_kelidan_the_breaker();
+    AddSC_boss_the_maker();
+    AddSC_instance_blood_furnace();
+    AddSC_boss_magtheridon();               //HC Magtheridon's Lair
+    AddSC_instance_magtheridons_lair();
+    AddSC_boss_grand_warlock_nethekurse();  //HC Shattered Halls
+    AddSC_boss_warbringer_omrogg();
+    AddSC_boss_warchief_kargath_bladefist();
+    AddSC_instance_shattered_halls();
+    AddSC_boss_watchkeeper_gargolmar();     //HC Ramparts
+    AddSC_boss_omor_the_unscarred();
+    AddSC_boss_vazruden_the_herald();
+    AddSC_instance_ramparts();
+    AddSC_arcatraz();                       //TK Arcatraz
+    AddSC_boss_harbinger_skyriss();
+    AddSC_instance_arcatraz();
+    AddSC_boss_high_botanist_freywinn();    //TK Botanica
+    AddSC_boss_laj();
+    AddSC_boss_warp_splinter();
+    AddSC_boss_thorngrin_the_tender();
+    AddSC_boss_commander_sarannis();
+    AddSC_instance_the_botanica();
+    AddSC_boss_alar();                      //TK The Eye
+    AddSC_boss_kaelthas();
+    AddSC_boss_void_reaver();
+    AddSC_boss_high_astromancer_solarian();
+    AddSC_instance_the_eye();
+    AddSC_the_eye();
+    AddSC_boss_gatewatcher_iron_hand();     //TK The Mechanar
+    AddSC_boss_gatewatcher_gyrokill();
+    AddSC_boss_nethermancer_sepethrea();
+    AddSC_boss_pathaleon_the_calculator();
+    AddSC_boss_mechano_lord_capacitus();
+    AddSC_instance_mechanar();
+
+    AddSC_blades_edge_mountains();
+    AddSC_boss_doomlordkazzak();
+    AddSC_boss_doomwalker();
+    AddSC_hellfire_peninsula();
+    AddSC_nagrand();
+    AddSC_netherstorm();
+    AddSC_shadowmoon_valley();
+    AddSC_shattrath_city();
+    AddSC_terokkar_forest();
+    AddSC_zangarmarsh();
+
+    AddSC_instance_throne_of_the_tides();      //Throne of the Tides
+    AddSC_boss_nazjar();
+    AddSC_boss_ulthok();
+    AddSC_boss_erunak_stonespeaker();
+    AddSC_boss_ozumat();
+
+    AddSC_bastion_of_twilight();
+    AddSC_instance_bastion_of_twilight();
+    AddSC_boss_halfus();
+    AddSC_boss_valiona_theralion();
+    AddSC_boss_ascendant_council();
+    AddSC_boss_chogall();
+    AddSC_boss_sinestra();
+#endif
+}
+
+void AddMaelstromScripts()
+{
+#ifdef SCRIPTS
+  AddSC_kezan();
+  AddSC_deepholm();
+  AddSC_lost_isle();
+  AddSC_boss_corborus(); //the stonecore
+  AddSC_boss_azil();
+  AddSC_boss_ozruk();
+  AddSC_boss_slabhide();
+  AddSC_instance_the_stonecore();
+  AddSC_the_stonecore();
+#endif
+}
+
+void AddNorthrendScripts()
+{
+#ifdef SCRIPTS
+    AddSC_boss_slad_ran();               //Gundrak
+    AddSC_boss_moorabi();
+    AddSC_boss_drakkari_colossus();
+    AddSC_boss_gal_darah();
+    AddSC_boss_eck();
+    AddSC_instance_gundrak();
+    AddSC_boss_amanitar();
+    AddSC_boss_taldaram();              //Azjol-Nerub Ahn'kahet
+    AddSC_boss_elder_nadox();
+    AddSC_boss_jedoga_shadowseeker();
+    AddSC_boss_volazj();
+    AddSC_instance_ahnkahet();
+    AddSC_boss_argent_challenge();      //Trial of the Champion
+    AddSC_boss_black_knight();
+    AddSC_boss_grand_champions();
+    AddSC_instance_trial_of_the_champion();
+    AddSC_trial_of_the_champion();
+    AddSC_boss_anubarak_trial();        //Trial of the Crusader
+    AddSC_boss_faction_champions();
+    AddSC_boss_jaraxxus();
+    AddSC_trial_of_the_crusader();
+    AddSC_boss_twin_valkyr();
+    AddSC_boss_northrend_beasts();
+    AddSC_instance_trial_of_the_crusader();
+    AddSC_boss_krik_thir();             //Azjol-Nerub Azjol-Nerub
+    AddSC_boss_hadronox();
+    AddSC_boss_anub_arak();
+    AddSC_instance_azjol_nerub();
+    AddSC_boss_anubrekhan();            //Naxxramas
+    AddSC_boss_maexxna();
+    AddSC_boss_patchwerk();
+    AddSC_boss_grobbulus();
+    AddSC_boss_razuvious();
+    AddSC_boss_kelthuzad();
+    AddSC_boss_loatheb();
+    AddSC_boss_noth();
+    AddSC_boss_gluth();
+    AddSC_boss_sapphiron();
+    AddSC_boss_four_horsemen();
+    AddSC_boss_faerlina();
+    AddSC_boss_heigan();
+    AddSC_boss_gothik();
+    AddSC_boss_thaddius();
+    AddSC_instance_naxxramas();
+    AddSC_boss_magus_telestra();        //The Nexus Nexus
+    AddSC_boss_anomalus();
+    AddSC_boss_ormorok();
+    AddSC_boss_keristrasza();
+    AddSC_instance_nexus();
+    AddSC_nexus();
+    AddSC_boss_drakos();                //The Nexus The Oculus
+    AddSC_boss_urom();
+    AddSC_boss_varos();
+    AddSC_boss_eregos();
+    AddSC_instance_oculus();
+    AddSC_oculus();
+    AddSC_boss_malygos();              // The Nexus: Eye of Eternity
+    AddSC_instance_eye_of_eternity();
+    AddSC_boss_sartharion();            //Obsidian Sanctum
+    AddSC_instance_obsidian_sanctum();
+    AddSC_boss_bjarngrim();             //Ulduar Halls of Lightning
+    AddSC_boss_loken();
+    AddSC_boss_ionar();
+    AddSC_boss_volkhan();
+    AddSC_instance_halls_of_lightning();
+    AddSC_boss_maiden_of_grief();       //Ulduar Halls of Stone
+    AddSC_boss_krystallus();
+    AddSC_boss_sjonnir();
+    AddSC_instance_halls_of_stone();
+    AddSC_halls_of_stone();
+    AddSC_boss_auriaya();               //Ulduar Ulduar
+    AddSC_boss_flame_leviathan();
+    AddSC_boss_ignis();
+    AddSC_boss_razorscale();
+    AddSC_boss_xt002();
+    AddSC_boss_general_vezax();
+    AddSC_boss_assembly_of_iron();
+    AddSC_boss_kologarn();
+    AddSC_ulduar_teleporter();
+    AddSC_boss_mimiron();
+    AddSC_boss_hodir();
+    AddSC_boss_freya();
+    AddSC_boss_algalon_the_observer();
+    AddSC_instance_ulduar();
+    AddSC_boss_keleseth();              //Utgarde Keep
+    AddSC_boss_skarvald_dalronn();
+    AddSC_boss_ingvar_the_plunderer();
+    AddSC_instance_utgarde_keep();
+    AddSC_boss_svala();                 //Utgarde pinnacle
+    AddSC_boss_palehoof();
+    AddSC_boss_skadi();
+    AddSC_boss_ymiron();
+    AddSC_instance_utgarde_pinnacle();
+    AddSC_utgarde_keep();
+    AddSC_boss_archavon();              //Vault of Archavon
+    AddSC_boss_emalon();
+    AddSC_boss_koralon();
+    AddSC_boss_toravon();
+    AddSC_instance_archavon();
+    AddSC_boss_trollgore();             //Drak'Tharon Keep
+    AddSC_boss_novos();
+    AddSC_boss_dred();
+    AddSC_boss_tharon_ja();
+    AddSC_instance_drak_tharon();
+    AddSC_boss_cyanigosa();             //Violet Hold
+    AddSC_boss_erekem();
+    AddSC_boss_ichoron();
+    AddSC_boss_lavanthor();
+    AddSC_boss_moragg();
+    AddSC_boss_xevozz();
+    AddSC_boss_zuramat();
+    AddSC_instance_violet_hold();
+    AddSC_violet_hold();
+    AddSC_instance_forge_of_souls();   //Forge of Souls
+    AddSC_forge_of_souls();
+    AddSC_boss_bronjahm();
+    AddSC_boss_devourer_of_souls();
+    AddSC_instance_pit_of_saron();      //Pit of Saron
+    AddSC_pit_of_saron();
+    AddSC_boss_garfrost();
+    AddSC_boss_ick();
+    AddSC_boss_tyrannus();
+    AddSC_instance_halls_of_reflection();   // Halls of Reflection
+    AddSC_halls_of_reflection();
+    AddSC_boss_falric();
+    AddSC_boss_marwyn();
+    AddSC_boss_lord_marrowgar();        // Icecrown Citadel
+    AddSC_boss_lady_deathwhisper();
+    AddSC_boss_deathbringer_saurfang();
+    AddSC_boss_festergut();
+    AddSC_boss_rotface();
+    AddSC_boss_professor_putricide();
+    AddSC_boss_blood_prince_council();
+    AddSC_boss_blood_queen_lana_thel();
+    AddSC_boss_valithria_dreamwalker();
+    AddSC_boss_sindragosa();
+    AddSC_boss_the_lich_king();
+    AddSC_icecrown_citadel_teleport();
+    AddSC_instance_icecrown_citadel();
+    AddSC_icecrown_citadel();
+    AddSC_instance_ruby_sanctum();      // Ruby Sanctum
+    AddSC_ruby_sanctum();
+    AddSC_boss_baltharus_the_warborn();
+    AddSC_boss_saviana_ragefire();
+    AddSC_boss_general_zarithrian();
+    AddSC_boss_halion();
+
+    AddSC_dalaran();
+    AddSC_borean_tundra();
+    AddSC_dragonblight();
+    AddSC_grizzly_hills();
+    AddSC_howling_fjord();
+    AddSC_icecrown();
+    AddSC_sholazar_basin();
+    AddSC_storm_peaks();
+    AddSC_wintergrasp();
+    AddSC_zuldrak();
+    AddSC_crystalsong_forest();
+    AddSC_isle_of_conquest();
+#endif
+}
+
+void AddEventScripts()
+{
+#ifdef SCRIPTS
+    AddSC_event_childrens_week();
+#endif
+}
+
+void AddOutdoorPvPScripts()
+{
+#ifdef SCRIPTS
+    AddSC_outdoorpvp_hp();
+    AddSC_outdoorpvp_na();
+    AddSC_outdoorpvp_si();
+    AddSC_outdoorpvp_tf();
+    AddSC_outdoorpvp_zm();
+    AddSC_outdoorpvp_gh();
+#endif
+}
+
+void AddBattlegroundScripts()
+{
+#ifdef SCRIPTS
+#endif
+}
+
+#ifdef SCRIPTS
+/* This is where custom scripts' loading functions should be declared. */
+#endif
+
+void AddCustomScripts()
+{
+#ifdef SCRIPTS
+    /* This is where custom scripts should be added. */
+#endif
+}
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 331fc3f..2653010 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1084,6 +1084,13 @@ void World::LoadConfigSettings(bool reload)
     m_int_configs[CONFIG_ARENA_START_MATCHMAKER_RATING]              = ConfigMgr::GetIntDefault ("Arena.ArenaStartMatchmakerRating", 1500);
     m_bool_configs[CONFIG_ARENA_SEASON_IN_PROGRESS]                  = ConfigMgr::GetBoolDefault("Arena.ArenaSeason.InProgress", true);
     m_bool_configs[CONFIG_ARENA_LOG_EXTENDED_INFO]                   = ConfigMgr::GetBoolDefault("ArenaLog.ExtendedInfo", false);
+    m_bool_configs[CONFIG_ARENA_1V1_ENABLE]                             = ConfigMgr::GetBoolDefault("Arena.1v1.Enable", true);
+    m_bool_configs[CONFIG_ARENA_1V1_ANNOUNCER]                         = ConfigMgr::GetBoolDefault("Arena.1v1.Announcer", false);
+    m_int_configs[CONFIG_ARENA_1V1_MIN_LEVEL]                         = ConfigMgr::GetIntDefault("Arena.1v1.MinLevel", 80);
+    m_int_configs[CONFIG_ARENA_1V1_COSTS]                             = ConfigMgr::GetIntDefault("Arena.1v1.Costs", 400000);
+    m_bool_configs[CONFIG_ARENA_1V1_VENDOR_RATING]                     = ConfigMgr::GetBoolDefault("Arena.1v1.VendorRating", false);
+    m_float_configs[CONFIG_ARENA_1V1_ARENAPOINTS_MULTI]                 = ConfigMgr::GetFloatDefault("Arena.1v1.ArenaPointsMulti", 0.64f);
+    m_bool_configs[CONFIG_ARENA_1V1_BLOCK_FORBIDDEN_TALENTS]         = ConfigMgr::GetBoolDefault("Arena.1v1.BlockForbiddenTalents", true);
 
     m_bool_configs[CONFIG_RATED_BATTLEGROUND_ENABLED]                = ConfigMgr::GetBoolDefault("Rated.BG.Enable", true);
 
diff --git a/src/server/game/World/World.cpp.orig b/src/server/game/World/World.cpp.orig
new file mode 100644
index 0000000..331fc3f
--- /dev/null
+++ b/src/server/game/World/World.cpp.orig
@@ -0,0 +1,3697 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** \file
+    \ingroup world
+*/
+
+#include "AnticheatMgr.h"
+#include "Common.h"
+#include "Memory.h"
+#include "DatabaseEnv.h"
+#include "Config.h"
+#include "SystemConfig.h"
+#include "Log.h"
+#include "Opcodes.h"
+#include "WorldSession.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "Vehicle.h"
+#include "SkillExtraItems.h"
+#include "SkillDiscovery.h"
+#include "World.h"
+#include "AccountMgr.h"
+#include "AchievementMgr.h"
+#include "AuctionHouseMgr.h"
+#include "ObjectMgr.h"
+#include "ArenaTeamMgr.h"
+#include "GuildMgr.h"
+#include "GuildFinderMgr.h"
+#include "TicketMgr.h"
+#include "SpellMgr.h"
+#include "GroupMgr.h"
+#include "Chat.h"
+#include "DBCStores.h"
+#include "DB2Stores.h"
+#include "LootMgr.h"
+#include "ItemEnchantmentMgr.h"
+#include "MapManager.h"
+#include "CreatureAIRegistry.h"
+#include "BattlegroundMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "TemporarySummon.h"
+#include "WaypointMovementGenerator.h"
+#include "VMapFactory.h"
+#include "MMapFactory.h"
+#include "GameEventMgr.h"
+#include "PoolMgr.h"
+#include "GridNotifiersImpl.h"
+#include "CellImpl.h"
+#include "InstanceSaveMgr.h"
+#include "Util.h"
+#include "Language.h"
+#include "CreatureGroups.h"
+#include "Transport.h"
+#include "ScriptMgr.h"
+#include "AddonMgr.h"
+#include "LFGMgr.h"
+#include "ConditionMgr.h"
+#include "DisableMgr.h"
+#include "CharacterDatabaseCleaner.h"
+#include "ScriptMgr.h"
+#include "WeatherMgr.h"
+#include "CreatureTextMgr.h"
+#include "SmartAI.h"
+#include "Channel.h"
+#include "WardenCheckMgr.h"
+#include "Warden.h"
+#include "CalendarMgr.h"
+#include "BattlefieldMgr.h"
+#include "InfoMgr.h"
+#include "PerformanceLog.h"
+
+ACE_Atomic_Op<ACE_Thread_Mutex, bool> World::m_stopEvent = false;
+uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
+volatile uint32 World::m_worldLoopCounter = 0;
+
+float World::m_MaxVisibleDistanceOnContinents = DEFAULT_VISIBILITY_DISTANCE;
+float World::m_MaxVisibleDistanceInInstances  = DEFAULT_VISIBILITY_INSTANCE;
+float World::m_MaxVisibleDistanceInBGArenas   = DEFAULT_VISIBILITY_BGARENAS;
+
+int32 World::m_visibility_notify_periodOnContinents = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
+int32 World::m_visibility_notify_periodInInstances  = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
+int32 World::m_visibility_notify_periodInBGArenas   = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
+
+/// World constructor
+World::World()
+{
+    m_playerLimit = 0;
+    m_allowedSecurityLevel = SEC_PLAYER;
+    m_allowMovement = true;
+    m_ShutdownMask = 0;
+    m_ShutdownTimer = 0;
+    m_gameTime = time(NULL);
+    m_startTime = m_gameTime;
+    m_maxActiveSessionCount = 0;
+    m_maxQueuedSessionCount = 0;
+    m_PlayerCount = 0;
+    m_MaxPlayerCount = 0;
+    m_NextDailyQuestReset = 0;
+    m_NextWeeklyQuestReset = 0;
+    m_NextCurrencyReset = 0;
+
+    m_defaultDbcLocale = LOCALE_enUS;
+    m_availableDbcLocaleMask = 0;
+
+    m_updateTimeSum = 0;
+    m_updateTimeCount = 0;
+
+    m_isClosed = false;
+
+    m_CleaningFlags = 0;
+}
+
+/// World destructor
+World::~World()
+{
+    ///- Empty the kicked session set
+    while (!m_sessions.empty())
+    {
+        // not remove from queue, prevent loading new sessions
+        delete m_sessions.begin()->second;
+        m_sessions.erase(m_sessions.begin());
+    }
+
+    CliCommandHolder* command = NULL;
+    while (cliCmdQueue.next(command))
+        delete command;
+
+    VMAP::VMapFactory::clear();
+    MMAP::MMapFactory::clear();
+
+    //TODO free addSessQueue
+}
+
+/// Find a player in a specified zone
+Player* World::FindPlayerInZone(uint32 zone)
+{
+    ///- circle through active sessions and return the first player found in the zone
+    SessionMap::const_iterator itr;
+    for (itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (!itr->second)
+            continue;
+
+        Player* player = itr->second->GetPlayer();
+        if (!player)
+            continue;
+
+        if (player->IsInWorld() && player->GetZoneId() == zone)
+        {
+            // Used by the weather system. We return the player to broadcast the change weather message to him and all players in the zone.
+            return player;
+        }
+    }
+    return NULL;
+}
+
+bool World::IsClosed() const
+{
+    return m_isClosed;
+}
+
+void World::SetClosed(bool val)
+{
+    m_isClosed = val;
+
+    // Invert the value, for simplicity for scripters.
+    sScriptMgr->OnOpenStateChange(!val);
+}
+
+void World::SetMotd(const std::string& motd)
+{
+    m_motd = motd;
+
+    sScriptMgr->OnMotdChange(m_motd);
+}
+
+const char* World::GetMotd() const
+{
+    return m_motd.c_str();
+}
+
+/// Find a session by its id
+WorldSession* World::FindSession(uint32 id) const
+{
+    SessionMap::const_iterator itr = m_sessions.find(id);
+
+    if (itr != m_sessions.end())
+        return itr->second;                                 // also can return NULL for kicked session
+    else
+        return NULL;
+}
+
+/// Remove a given session
+bool World::RemoveSession(uint32 id)
+{
+    ///- Find the session, kick the user, but we can't delete session at this moment to prevent iterator invalidation
+    SessionMap::const_iterator itr = m_sessions.find(id);
+
+    if (itr != m_sessions.end() && itr->second)
+    {
+        if (itr->second->PlayerLoading())
+            return false;
+
+        itr->second->KickPlayer("World::RemoveSession");
+    }
+
+    return true;
+}
+
+void World::AddSession(WorldSession* s)
+{
+    addSessQueue.add(s);
+}
+
+void World::AddSession_(WorldSession* s)
+{
+    ASSERT(s);
+
+    //NOTE - Still there is race condition in WorldSession* being used in the Sockets
+
+    ///- kick already loaded player with same account (if any) and remove session
+    ///- if player is in loading and want to load again, return
+    if (!RemoveSession (s->GetAccountId()))
+    {
+        s->KickPlayer("World::AddSession_");
+        delete s;                                           // session not added yet in session list, so not listed in queue
+        return;
+    }
+
+    // decrease session counts only at not reconnection case
+    bool decrease_session = true;
+
+    // if session already exist, prepare to it deleting at next world update
+    // NOTE - KickPlayer() should be called on "old" in RemoveSession()
+    {
+        SessionMap::const_iterator old = m_sessions.find(s->GetAccountId());
+
+        if (old != m_sessions.end())
+        {
+            // prevent decrease sessions count if session queued
+            if (RemoveQueuedPlayer(old->second))
+                decrease_session = false;
+            // not remove replaced session form queue if listed
+            delete old->second;
+        }
+    }
+
+    m_sessions[s->GetAccountId()] = s;
+
+    uint32 Sessions = GetActiveAndQueuedSessionCount();
+    uint32 pLimit = GetPlayerAmountLimit();
+    uint32 QueueSize = GetQueuedSessionCount(); //number of players in the queue
+
+    //so we don't count the user trying to
+    //login as a session and queue the socket that we are using
+    if (decrease_session)
+        --Sessions;
+
+    if (pLimit > 0 && Sessions >= pLimit && AccountMgr::IsPlayerAccount(s->GetSecurity()) && !HasRecentlyDisconnected(s))
+    {
+        AddQueuedPlayer(s);
+        UpdateMaxSessionCounters();
+        sLog->outInfo(LOG_FILTER_GENERAL, "PlayerQueue: Account id %u is in Queue Position (%u).", s->GetAccountId(), ++QueueSize);
+        return;
+    }
+
+    s->SendAuthResponse(AUTH_OK, false);
+    s->SendAddonsInfo();
+    s->SendClientCacheVersion(sWorld->getIntConfig(CONFIG_CLIENTCACHE_VERSION));
+    s->SendTutorialsData();
+
+    UpdateMaxSessionCounters();
+
+    // Updates the population
+    if (pLimit > 0)
+    {
+        float popu = (float)GetActiveSessionCount();              // updated number of users on the server
+        popu /= pLimit;
+        popu *= 2;
+        sLog->outInfo(LOG_FILTER_GENERAL, "Server Population (%f).", popu);
+    }
+}
+
+bool World::HasRecentlyDisconnected(WorldSession* session)
+{
+    if (!session)
+        return false;
+
+    if (uint32 tolerance = getIntConfig(CONFIG_INTERVAL_DISCONNECT_TOLERANCE))
+    {
+        for (DisconnectMap::iterator i = m_disconnects.begin(); i != m_disconnects.end();)
+        {
+            if (difftime(i->second, time(NULL)) < tolerance)
+            {
+                if (i->first == session->GetAccountId())
+                    return true;
+                ++i;
+            }
+            else
+                m_disconnects.erase(i++);
+        }
+    }
+    return false;
+ }
+
+int32 World::GetQueuePos(WorldSession* sess)
+{
+    uint32 position = 1;
+
+    for (Queue::const_iterator iter = m_QueuedPlayer.begin(); iter != m_QueuedPlayer.end(); ++iter, ++position)
+        if ((*iter) == sess)
+            return position;
+
+    return 0;
+}
+
+void World::AddQueuedPlayer(WorldSession* sess)
+{
+    sess->SetInQueue(true);
+    m_QueuedPlayer.push_back(sess);
+
+    // The 1st SMSG_AUTH_RESPONSE needs to contain other info too.
+    sess->SendAuthResponse(AUTH_OK, true, GetQueuePos(sess));
+}
+
+bool World::RemoveQueuedPlayer(WorldSession* sess)
+{
+    // sessions count including queued to remove (if removed_session set)
+    uint32 sessions = GetActiveSessionCount();
+
+    uint32 position = 1;
+    Queue::iterator iter = m_QueuedPlayer.begin();
+
+    // search to remove and count skipped positions
+    bool found = false;
+
+    for (; iter != m_QueuedPlayer.end(); ++iter, ++position)
+    {
+        if (*iter == sess)
+        {
+            sess->SetInQueue(false);
+            sess->ResetTimeOutTime();
+            iter = m_QueuedPlayer.erase(iter);
+            found = true;                                   // removing queued session
+            break;
+        }
+    }
+
+    // iter point to next socked after removed or end()
+    // position store position of removed socket and then new position next socket after removed
+
+    // if session not queued then we need decrease sessions count
+    if (!found && sessions)
+        --sessions;
+
+    // accept first in queue
+    if ((!m_playerLimit || sessions < m_playerLimit) && !m_QueuedPlayer.empty())
+    {
+        WorldSession* pop_sess = m_QueuedPlayer.front();
+        pop_sess->SetInQueue(false);
+        pop_sess->ResetTimeOutTime();
+        pop_sess->SendAuthWaitQue(0);
+        pop_sess->SendAddonsInfo();
+
+        pop_sess->SendClientCacheVersion(sWorld->getIntConfig(CONFIG_CLIENTCACHE_VERSION));
+        pop_sess->SendAccountDataTimes(GLOBAL_CACHE_MASK);
+        pop_sess->SendTutorialsData();
+
+        m_QueuedPlayer.pop_front();
+
+        // update iter to point first queued socket or end() if queue is empty now
+        iter = m_QueuedPlayer.begin();
+        position = 1;
+    }
+
+    // update position from iter to end()
+    // iter point to first not updated socket, position store new position
+    for (; iter != m_QueuedPlayer.end(); ++iter, ++position)
+        (*iter)->SendAuthWaitQue(position);
+
+    return found;
+}
+
+/// Initialize config values
+void World::LoadConfigSettings(bool reload)
+{
+    if (reload)
+    {
+        if (!ConfigMgr::Load())
+        {
+            sLog->outError(LOG_FILTER_GENERAL, "World settings reload fail: can't read settings from %s.", ConfigMgr::GetFilename().c_str());
+            return;
+        }
+        sLog->LoadFromConfig();
+    }
+
+    ///- Read the player limit and the Message of the day from the config file
+    SetPlayerAmountLimit(ConfigMgr::GetIntDefault("PlayerLimit", 1000));
+    SetMotd(ConfigMgr::GetStringDefault("Motd", "Welcome to WoWSource V9."));
+
+    ///- Read ticket system setting from the config file
+    m_bool_configs[CONFIG_ALLOW_TICKETS] = ConfigMgr::GetBoolDefault("AllowTickets", true);
+
+    ///- Get string for new logins (newly created characters)
+    SetNewCharString(ConfigMgr::GetStringDefault("PlayerStart.String", ""));
+
+    ///- Send server info on login?
+    m_int_configs[CONFIG_ENABLE_SINFO_LOGIN] = ConfigMgr::GetIntDefault("Server.LoginInfo", 0);
+
+    ///- Read all rates from the config file
+    rate_values[RATE_HEALTH]      = ConfigMgr::GetFloatDefault("Rate.Health", 1);
+    if (rate_values[RATE_HEALTH] < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Rate.Health (%f) must be > 0. Using 1 instead.", rate_values[RATE_HEALTH]);
+        rate_values[RATE_HEALTH] = 1;
+    }
+    rate_values[RATE_POWER_MANA]  = ConfigMgr::GetFloatDefault("Rate.Mana", 1);
+    if (rate_values[RATE_POWER_MANA] < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Rate.Mana (%f) must be > 0. Using 1 instead.", rate_values[RATE_POWER_MANA]);
+        rate_values[RATE_POWER_MANA] = 1;
+    }
+    rate_values[RATE_POWER_RAGE_INCOME] = ConfigMgr::GetFloatDefault("Rate.Rage.Income", 1);
+    rate_values[RATE_POWER_RAGE_LOSS]   = ConfigMgr::GetFloatDefault("Rate.Rage.Loss", 1);
+    if (rate_values[RATE_POWER_RAGE_LOSS] < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Rate.Rage.Loss (%f) must be > 0. Using 1 instead.", rate_values[RATE_POWER_RAGE_LOSS]);
+        rate_values[RATE_POWER_RAGE_LOSS] = 1;
+    }
+    rate_values[RATE_POWER_RUNICPOWER_INCOME] = ConfigMgr::GetFloatDefault("Rate.RunicPower.Income", 1);
+    rate_values[RATE_POWER_RUNICPOWER_LOSS]   = ConfigMgr::GetFloatDefault("Rate.RunicPower.Loss", 1);
+    if (rate_values[RATE_POWER_RUNICPOWER_LOSS] < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Rate.RunicPower.Loss (%f) must be > 0. Using 1 instead.", rate_values[RATE_POWER_RUNICPOWER_LOSS]);
+        rate_values[RATE_POWER_RUNICPOWER_LOSS] = 1;
+    }
+    rate_values[RATE_POWER_FOCUS]  = ConfigMgr::GetFloatDefault("Rate.Focus", 1.0f);
+    rate_values[RATE_POWER_ENERGY] = ConfigMgr::GetFloatDefault("Rate.Energy", 1.0f);
+
+    rate_values[RATE_SKILL_DISCOVERY]      = ConfigMgr::GetFloatDefault("Rate.Skill.Discovery", 1.0f);
+
+    rate_values[RATE_DROP_ITEM_POOR]       = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Poor", 1.0f);
+    rate_values[RATE_DROP_ITEM_NORMAL]     = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Normal", 1.0f);
+    rate_values[RATE_DROP_ITEM_UNCOMMON]   = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Uncommon", 1.0f);
+    rate_values[RATE_DROP_ITEM_RARE]       = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Rare", 1.0f);
+    rate_values[RATE_DROP_ITEM_EPIC]       = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Epic", 1.0f);
+    rate_values[RATE_DROP_ITEM_LEGENDARY]  = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Legendary", 1.0f);
+    rate_values[RATE_DROP_ITEM_ARTIFACT]   = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Artifact", 1.0f);
+    rate_values[RATE_DROP_ITEM_REFERENCED] = ConfigMgr::GetFloatDefault("Rate.Drop.Item.Referenced", 1.0f);
+    rate_values[RATE_DROP_ITEM_REFERENCED_AMOUNT] = ConfigMgr::GetFloatDefault("Rate.Drop.Item.ReferencedAmount", 1.0f);
+    rate_values[RATE_DROP_MONEY]  = ConfigMgr::GetFloatDefault("Rate.Drop.Money", 1.0f);
+    rate_values[RATE_XP_KILL]     = ConfigMgr::GetFloatDefault("Rate.XP.Kill", 1.0f);
+    rate_values[RATE_XP_QUEST]    = ConfigMgr::GetFloatDefault("Rate.XP.Quest", 1.0f);
+    rate_values[RATE_XP_EXPLORE]  = ConfigMgr::GetFloatDefault("Rate.XP.Explore", 1.0f);
+    rate_values[RATE_REPAIRCOST]  = ConfigMgr::GetFloatDefault("Rate.RepairCost", 1.0f);
+    if (rate_values[RATE_REPAIRCOST] < 0.0f)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Rate.RepairCost (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_REPAIRCOST]);
+        rate_values[RATE_REPAIRCOST] = 0.0f;
+    }
+    rate_values[RATE_REPUTATION_GAIN]  = ConfigMgr::GetFloatDefault("Rate.Reputation.Gain", 1.0f);
+    rate_values[RATE_REPUTATION_LOWLEVEL_KILL]  = ConfigMgr::GetFloatDefault("Rate.Reputation.LowLevel.Kill", 1.0f);
+    rate_values[RATE_REPUTATION_LOWLEVEL_QUEST]  = ConfigMgr::GetFloatDefault("Rate.Reputation.LowLevel.Quest", 1.0f);
+    rate_values[RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS] = ConfigMgr::GetFloatDefault("Rate.Reputation.RecruitAFriendBonus", 0.1f);
+    rate_values[RATE_CREATURE_NORMAL_DAMAGE]          = ConfigMgr::GetFloatDefault("Rate.Creature.Normal.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_ELITE_DAMAGE]     = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.Elite.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RAREELITE_DAMAGE] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RAREELITE.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_DAMAGE] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.Damage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RARE_DAMAGE]      = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RARE.Damage", 1.0f);
+    rate_values[RATE_CREATURE_NORMAL_HP]          = ConfigMgr::GetFloatDefault("Rate.Creature.Normal.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_ELITE_HP]     = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.Elite.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RAREELITE_HP] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RAREELITE.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_HP] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.HP", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RARE_HP]      = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RARE.HP", 1.0f);
+    rate_values[RATE_CREATURE_NORMAL_SPELLDAMAGE]          = ConfigMgr::GetFloatDefault("Rate.Creature.Normal.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_ELITE_SPELLDAMAGE]     = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.Elite.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RAREELITE_SPELLDAMAGE] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RAREELITE.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_WORLDBOSS_SPELLDAMAGE] = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.WORLDBOSS.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_ELITE_RARE_SPELLDAMAGE]      = ConfigMgr::GetFloatDefault("Rate.Creature.Elite.RARE.SpellDamage", 1.0f);
+    rate_values[RATE_CREATURE_AGGRO]  = ConfigMgr::GetFloatDefault("Rate.Creature.Aggro", 1.0f);
+    rate_values[RATE_REST_INGAME]                    = ConfigMgr::GetFloatDefault("Rate.Rest.InGame", 1.0f);
+    rate_values[RATE_REST_OFFLINE_IN_TAVERN_OR_CITY] = ConfigMgr::GetFloatDefault("Rate.Rest.Offline.InTavernOrCity", 1.0f);
+    rate_values[RATE_REST_OFFLINE_IN_WILDERNESS]     = ConfigMgr::GetFloatDefault("Rate.Rest.Offline.InWilderness", 1.0f);
+    rate_values[RATE_DAMAGE_FALL]  = ConfigMgr::GetFloatDefault("Rate.Damage.Fall", 1.0f);
+    rate_values[RATE_AUCTION_TIME]  = ConfigMgr::GetFloatDefault("Rate.Auction.Time", 1.0f);
+    rate_values[RATE_AUCTION_DEPOSIT] = ConfigMgr::GetFloatDefault("Rate.Auction.Deposit", 1.0f);
+    rate_values[RATE_AUCTION_CUT] = ConfigMgr::GetFloatDefault("Rate.Auction.Cut", 1.0f);
+    rate_values[RATE_HONOR] = ConfigMgr::GetFloatDefault("Rate.Honor", 1.0f);
+    rate_values[RATE_MINING_AMOUNT] = ConfigMgr::GetFloatDefault("Rate.Mining.Amount", 1.0f);
+    rate_values[RATE_MINING_NEXT]   = ConfigMgr::GetFloatDefault("Rate.Mining.Next", 1.0f);
+    rate_values[RATE_ARCHAEOLOGY_AMOUNT]   = ConfigMgr::GetFloatDefault("Rate.Archaeology.Amount", 1.0f);
+    rate_values[RATE_ARCHAEOLOGY_NEXT]   = ConfigMgr::GetFloatDefault("Rate.Archaeology.Next", 1.0f);
+    rate_values[RATE_INSTANCE_RESET_TIME] = ConfigMgr::GetFloatDefault("Rate.InstanceResetTime", 1.0f);
+    rate_values[RATE_TALENT] = ConfigMgr::GetFloatDefault("Rate.Talent", 1.0f);
+    if (rate_values[RATE_TALENT] < 0.0f)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Rate.Talent (%f) must be > 0. Using 1 instead.", rate_values[RATE_TALENT]);
+        rate_values[RATE_TALENT] = 1.0f;
+    }
+    rate_values[RATE_MOVESPEED] = ConfigMgr::GetFloatDefault("Rate.MoveSpeed", 1.0f);
+    if (rate_values[RATE_MOVESPEED] < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Rate.MoveSpeed (%f) must be > 0. Using 1 instead.", rate_values[RATE_MOVESPEED]);
+        rate_values[RATE_MOVESPEED] = 1.0f;
+    }
+    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i) playerBaseMoveSpeed[i] = baseMoveSpeed[i] * rate_values[RATE_MOVESPEED];
+    rate_values[RATE_CORPSE_DECAY_LOOTED] = ConfigMgr::GetFloatDefault("Rate.Corpse.Decay.Looted", 0.5f);
+
+    rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] = ConfigMgr::GetFloatDefault("TargetPosRecalculateRange", 1.5f);
+    if (rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] < CONTACT_DISTANCE)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "TargetPosRecalculateRange (%f) must be >= %f. Using %f instead.", rate_values[RATE_TARGET_POS_RECALCULATION_RANGE], CONTACT_DISTANCE, CONTACT_DISTANCE);
+        rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] = CONTACT_DISTANCE;
+    }
+    else if (rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] > NOMINAL_MELEE_RANGE)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "TargetPosRecalculateRange (%f) must be <= %f. Using %f instead.",
+            rate_values[RATE_TARGET_POS_RECALCULATION_RANGE], NOMINAL_MELEE_RANGE, NOMINAL_MELEE_RANGE);
+        rate_values[RATE_TARGET_POS_RECALCULATION_RANGE] = NOMINAL_MELEE_RANGE;
+    }
+
+    rate_values[RATE_DURABILITY_LOSS_ON_DEATH]  = ConfigMgr::GetFloatDefault("DurabilityLoss.OnDeath", 10.0f);
+    if (rate_values[RATE_DURABILITY_LOSS_ON_DEATH] < 0.0f)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "DurabilityLoss.OnDeath (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_ON_DEATH]);
+        rate_values[RATE_DURABILITY_LOSS_ON_DEATH] = 0.0f;
+    }
+    if (rate_values[RATE_DURABILITY_LOSS_ON_DEATH] > 100.0f)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "DurabilityLoss.OnDeath (%f) must be <= 100. Using 100.0 instead.", rate_values[RATE_DURABILITY_LOSS_ON_DEATH]);
+        rate_values[RATE_DURABILITY_LOSS_ON_DEATH] = 0.0f;
+    }
+    rate_values[RATE_DURABILITY_LOSS_ON_DEATH] = rate_values[RATE_DURABILITY_LOSS_ON_DEATH] / 100.0f;
+
+    rate_values[RATE_DURABILITY_LOSS_DAMAGE] = ConfigMgr::GetFloatDefault("DurabilityLossChance.Damage", 0.5f);
+    if (rate_values[RATE_DURABILITY_LOSS_DAMAGE] < 0.0f)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "DurabilityLossChance.Damage (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_DAMAGE]);
+        rate_values[RATE_DURABILITY_LOSS_DAMAGE] = 0.0f;
+    }
+    rate_values[RATE_DURABILITY_LOSS_ABSORB] = ConfigMgr::GetFloatDefault("DurabilityLossChance.Absorb", 0.5f);
+    if (rate_values[RATE_DURABILITY_LOSS_ABSORB] < 0.0f)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "DurabilityLossChance.Absorb (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_ABSORB]);
+        rate_values[RATE_DURABILITY_LOSS_ABSORB] = 0.0f;
+    }
+    rate_values[RATE_DURABILITY_LOSS_PARRY] = ConfigMgr::GetFloatDefault("DurabilityLossChance.Parry", 0.05f);
+    if (rate_values[RATE_DURABILITY_LOSS_PARRY] < 0.0f)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "DurabilityLossChance.Parry (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_PARRY]);
+        rate_values[RATE_DURABILITY_LOSS_PARRY] = 0.0f;
+    }
+    rate_values[RATE_DURABILITY_LOSS_BLOCK] = ConfigMgr::GetFloatDefault("DurabilityLossChance.Block", 0.05f);
+    if (rate_values[RATE_DURABILITY_LOSS_BLOCK] < 0.0f)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "DurabilityLossChance.Block (%f) must be >=0. Using 0.0 instead.", rate_values[RATE_DURABILITY_LOSS_BLOCK]);
+        rate_values[RATE_DURABILITY_LOSS_BLOCK] = 0.0f;
+    }
+    ///- Read other configuration items from the config file
+
+    m_bool_configs[CONFIG_DURABILITY_LOSS_IN_PVP] = ConfigMgr::GetBoolDefault("DurabilityLoss.InPvP", false);
+
+    m_int_configs[CONFIG_COMPRESSION] = ConfigMgr::GetIntDefault("Compression", 1);
+    if (m_int_configs[CONFIG_COMPRESSION] < 1 || m_int_configs[CONFIG_COMPRESSION] > 9)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Compression level (%i) must be in range 1..9. Using default compression level (1).", m_int_configs[CONFIG_COMPRESSION]);
+        m_int_configs[CONFIG_COMPRESSION] = 1;
+    }
+    m_bool_configs[CONFIG_ADDON_CHANNEL] = ConfigMgr::GetBoolDefault("AddonChannel", true);
+    m_bool_configs[CONFIG_CLEAN_CHARACTER_DB] = ConfigMgr::GetBoolDefault("CleanCharacterDB", false);
+    m_int_configs[CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS] = ConfigMgr::GetIntDefault("PersistentCharacterCleanFlags", 0);
+    m_int_configs[CONFIG_CHAT_CHANNEL_LEVEL_REQ] = ConfigMgr::GetIntDefault("ChatLevelReq.Channel", 1);
+    m_int_configs[CONFIG_CHAT_WHISPER_LEVEL_REQ] = ConfigMgr::GetIntDefault("ChatLevelReq.Whisper", 1);
+    m_int_configs[CONFIG_CHAT_SAY_LEVEL_REQ] = ConfigMgr::GetIntDefault("ChatLevelReq.Say", 1);
+    m_int_configs[CONFIG_TRADE_LEVEL_REQ] = ConfigMgr::GetIntDefault("LevelReq.Trade", 1);
+    m_int_configs[CONFIG_TICKET_LEVEL_REQ] = ConfigMgr::GetIntDefault("LevelReq.Ticket", 1);
+    m_int_configs[CONFIG_AUCTION_LEVEL_REQ] = ConfigMgr::GetIntDefault("LevelReq.Auction", 1);
+    m_int_configs[CONFIG_MAIL_LEVEL_REQ] = ConfigMgr::GetIntDefault("LevelReq.Mail", 1);
+    m_bool_configs[CONFIG_ALLOW_PLAYER_COMMANDS] = ConfigMgr::GetBoolDefault("AllowPlayerCommands", 1);
+    m_bool_configs[CONFIG_PRESERVE_CUSTOM_CHANNELS] = ConfigMgr::GetBoolDefault("PreserveCustomChannels", false);
+    m_int_configs[CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION] = ConfigMgr::GetIntDefault("PreserveCustomChannelDuration", 14);
+    m_bool_configs[CONFIG_GRID_UNLOAD] = ConfigMgr::GetBoolDefault("GridUnload", true);
+    m_int_configs[CONFIG_INTERVAL_SAVE] = ConfigMgr::GetIntDefault("PlayerSaveInterval", 15 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_INTERVAL_DISCONNECT_TOLERANCE] = ConfigMgr::GetIntDefault("DisconnectToleranceInterval", 0);
+    m_bool_configs[CONFIG_STATS_SAVE_ONLY_ON_LOGOUT] = ConfigMgr::GetBoolDefault("PlayerSave.Stats.SaveOnlyOnLogout", true);
+    m_int_configs[CONFIG_DOUBLE_MOVING] = ConfigMgr::GetIntDefault("DoubleMovementSpeed", 0);
+
+    m_bool_configs[CONFIG_ARENA_READYMARK_ENABLED] = ConfigMgr::GetBoolDefault("ReadymarkEnabled", false);
+
+    m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE] = ConfigMgr::GetIntDefault("PlayerSave.Stats.MinLevel", 0);
+    if (m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE] > MAX_LEVEL)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "PlayerSave.Stats.MinLevel (%i) must be in range 0..80. Using default, do not save character stats (0).", m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE]);
+        m_int_configs[CONFIG_MIN_LEVEL_STAT_SAVE] = 0;
+    }
+
+    m_int_configs[CONFIG_INTERVAL_GRIDCLEAN] = ConfigMgr::GetIntDefault("GridCleanUpDelay", 5 * MINUTE * IN_MILLISECONDS);
+    if (m_int_configs[CONFIG_INTERVAL_GRIDCLEAN] < MIN_GRID_DELAY)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "GridCleanUpDelay (%i) must be greater %u. Use this minimal value.", m_int_configs[CONFIG_INTERVAL_GRIDCLEAN], MIN_GRID_DELAY);
+        m_int_configs[CONFIG_INTERVAL_GRIDCLEAN] = MIN_GRID_DELAY;
+    }
+    if (reload)
+        sMapMgr->SetGridCleanUpDelay(m_int_configs[CONFIG_INTERVAL_GRIDCLEAN]);
+
+    m_int_configs[CONFIG_INTERVAL_MAPUPDATE] = ConfigMgr::GetIntDefault("MapUpdateInterval", 100);
+    if (m_int_configs[CONFIG_INTERVAL_MAPUPDATE] < MIN_MAP_UPDATE_DELAY)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "MapUpdateInterval (%i) must be greater %u. Use this minimal value.", m_int_configs[CONFIG_INTERVAL_MAPUPDATE], MIN_MAP_UPDATE_DELAY);
+        m_int_configs[CONFIG_INTERVAL_MAPUPDATE] = MIN_MAP_UPDATE_DELAY;
+    }
+    if (reload)
+        sMapMgr->SetMapUpdateInterval(m_int_configs[CONFIG_INTERVAL_MAPUPDATE]);
+
+    m_int_configs[CONFIG_INTERVAL_CHANGEWEATHER] = ConfigMgr::GetIntDefault("ChangeWeatherInterval", 10 * MINUTE * IN_MILLISECONDS);
+
+    if (reload)
+    {
+        uint32 val = ConfigMgr::GetIntDefault("WorldServerPort", 8085);
+        if (val != m_int_configs[CONFIG_PORT_WORLD])
+            sLog->outError(LOG_FILTER_SERVER_LOADING, "WorldServerPort option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_PORT_WORLD]);
+    }
+    else
+        m_int_configs[CONFIG_PORT_WORLD] = ConfigMgr::GetIntDefault("WorldServerPort", 8085);
+
+    m_int_configs[CONFIG_SOCKET_TIMEOUTTIME] = ConfigMgr::GetIntDefault("SocketTimeOutTime", 900000);
+    m_int_configs[CONFIG_SESSION_ADD_DELAY] = ConfigMgr::GetIntDefault("SessionAddDelay", 10000);
+
+    m_float_configs[CONFIG_GROUP_XP_DISTANCE] = ConfigMgr::GetFloatDefault("MaxGroupXPDistance", 74.0f);
+    m_float_configs[CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE] = ConfigMgr::GetFloatDefault("MaxRecruitAFriendBonusDistance", 100.0f);
+
+    /// \todo Add MonsterSight and GuarderSight (with meaning) in worldserver.conf or put them as define
+    m_float_configs[CONFIG_SIGHT_MONSTER] = ConfigMgr::GetFloatDefault("MonsterSight", 50);
+    m_float_configs[CONFIG_SIGHT_GUARDER] = ConfigMgr::GetFloatDefault("GuarderSight", 50);
+
+    if (reload)
+    {
+        uint32 val = ConfigMgr::GetIntDefault("GameType", 0);
+        if (val != m_int_configs[CONFIG_GAME_TYPE])
+            sLog->outError(LOG_FILTER_SERVER_LOADING, "GameType option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_GAME_TYPE]);
+    }
+    else
+        m_int_configs[CONFIG_GAME_TYPE] = ConfigMgr::GetIntDefault("GameType", 0);
+
+    if (reload)
+    {
+        uint32 val = ConfigMgr::GetIntDefault("RealmZone", REALM_ZONE_DEVELOPMENT);
+        if (val != m_int_configs[CONFIG_REALM_ZONE])
+            sLog->outError(LOG_FILTER_SERVER_LOADING, "RealmZone option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_REALM_ZONE]);
+    }
+    else
+        m_int_configs[CONFIG_REALM_ZONE] = ConfigMgr::GetIntDefault("RealmZone", REALM_ZONE_DEVELOPMENT);
+
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_ACCOUNTS]            = ConfigMgr::GetBoolDefault("AllowTwoSide.Accounts", true);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_CALENDAR]= ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Calendar", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHAT]    = ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Chat", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHANNEL] = ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Channel", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP]   = ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Group", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD]   = ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Guild", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION] = ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Auction", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_INTERACTION_MAIL]    = ConfigMgr::GetBoolDefault("AllowTwoSide.Interaction.Mail", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_WHO_LIST]            = ConfigMgr::GetBoolDefault("AllowTwoSide.WhoList", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_ADD_FRIEND]          = ConfigMgr::GetBoolDefault("AllowTwoSide.AddFriend", false);
+    m_bool_configs[CONFIG_ALLOW_TWO_SIDE_TRADE]               = ConfigMgr::GetBoolDefault("AllowTwoSide.trade", false);
+    m_int_configs[CONFIG_STRICT_PLAYER_NAMES]                 = ConfigMgr::GetIntDefault ("StrictPlayerNames",  0);
+    m_int_configs[CONFIG_STRICT_CHARTER_NAMES]                = ConfigMgr::GetIntDefault ("StrictCharterNames", 0);
+    m_int_configs[CONFIG_STRICT_PET_NAMES]                    = ConfigMgr::GetIntDefault ("StrictPetNames",     0);
+
+    m_int_configs[CONFIG_MIN_PLAYER_NAME]                     = ConfigMgr::GetIntDefault ("MinPlayerName",  2);
+    if (m_int_configs[CONFIG_MIN_PLAYER_NAME] < 1 || m_int_configs[CONFIG_MIN_PLAYER_NAME] > MAX_PLAYER_NAME)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "MinPlayerName (%i) must be in range 1..%u. Set to 2.", m_int_configs[CONFIG_MIN_PLAYER_NAME], MAX_PLAYER_NAME);
+        m_int_configs[CONFIG_MIN_PLAYER_NAME] = 2;
+    }
+
+    m_int_configs[CONFIG_MIN_CHARTER_NAME]                    = ConfigMgr::GetIntDefault ("MinCharterName", 2);
+    if (m_int_configs[CONFIG_MIN_CHARTER_NAME] < 1 || m_int_configs[CONFIG_MIN_CHARTER_NAME] > MAX_CHARTER_NAME)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "MinCharterName (%i) must be in range 1..%u. Set to 2.", m_int_configs[CONFIG_MIN_CHARTER_NAME], MAX_CHARTER_NAME);
+        m_int_configs[CONFIG_MIN_CHARTER_NAME] = 2;
+    }
+
+    m_int_configs[CONFIG_MIN_PET_NAME]                        = ConfigMgr::GetIntDefault ("MinPetName",     2);
+    if (m_int_configs[CONFIG_MIN_PET_NAME] < 1 || m_int_configs[CONFIG_MIN_PET_NAME] > MAX_PET_NAME)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "MinPetName (%i) must be in range 1..%u. Set to 2.", m_int_configs[CONFIG_MIN_PET_NAME], MAX_PET_NAME);
+        m_int_configs[CONFIG_MIN_PET_NAME] = 2;
+    }
+
+    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED] = ConfigMgr::GetIntDefault("CharacterCreating.Disabled", 0);
+    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED_RACEMASK] = ConfigMgr::GetIntDefault("CharacterCreating.Disabled.RaceMask", 0);
+    m_int_configs[CONFIG_CHARACTER_CREATING_DISABLED_CLASSMASK] = ConfigMgr::GetIntDefault("CharacterCreating.Disabled.ClassMask", 0);
+
+    m_int_configs[CONFIG_CHARACTERS_PER_REALM] = ConfigMgr::GetIntDefault("CharactersPerRealm", 10);
+    if (m_int_configs[CONFIG_CHARACTERS_PER_REALM] < 1 || m_int_configs[CONFIG_CHARACTERS_PER_REALM] > 10)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "CharactersPerRealm (%i) must be in range 1..10. Set to 10.", m_int_configs[CONFIG_CHARACTERS_PER_REALM]);
+        m_int_configs[CONFIG_CHARACTERS_PER_REALM] = 10;
+    }
+
+    // must be after CONFIG_CHARACTERS_PER_REALM
+    m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT] = ConfigMgr::GetIntDefault("CharactersPerAccount", 50);
+    if (m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT] < m_int_configs[CONFIG_CHARACTERS_PER_REALM])
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "CharactersPerAccount (%i) can't be less than CharactersPerRealm (%i).", m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT], m_int_configs[CONFIG_CHARACTERS_PER_REALM]);
+        m_int_configs[CONFIG_CHARACTERS_PER_ACCOUNT] = m_int_configs[CONFIG_CHARACTERS_PER_REALM];
+    }
+
+    m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM] = ConfigMgr::GetIntDefault("HeroicCharactersPerRealm", 1);
+    if (int32(m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM]) < 0 || m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM] > 10)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "HeroicCharactersPerRealm (%i) must be in range 0..10. Set to 1.", m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM]);
+        m_int_configs[CONFIG_HEROIC_CHARACTERS_PER_REALM] = 1;
+    }
+
+    m_int_configs[CONFIG_CHARACTER_CREATING_MIN_LEVEL_FOR_HEROIC_CHARACTER] = ConfigMgr::GetIntDefault("CharacterCreating.MinLevelForHeroicCharacter", 55);
+
+    m_int_configs[CONFIG_SKIP_CINEMATICS] = ConfigMgr::GetIntDefault("SkipCinematics", 0);
+    if (int32(m_int_configs[CONFIG_SKIP_CINEMATICS]) < 0 || m_int_configs[CONFIG_SKIP_CINEMATICS] > 2)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "SkipCinematics (%i) must be in range 0..2. Set to 0.", m_int_configs[CONFIG_SKIP_CINEMATICS]);
+        m_int_configs[CONFIG_SKIP_CINEMATICS] = 0;
+    }
+
+    if (reload)
+    {
+        uint32 val = ConfigMgr::GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
+        if (val != m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
+            sLog->outError(LOG_FILTER_SERVER_LOADING, "MaxPlayerLevel option can't be changed at config reload, using current value (%u).", m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+    }
+    else
+        m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = ConfigMgr::GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
+
+    if (m_int_configs[CONFIG_MAX_PLAYER_LEVEL] > MAX_LEVEL)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "MaxPlayerLevel (%i) must be in range 1..%u. Set to %u.", m_int_configs[CONFIG_MAX_PLAYER_LEVEL], MAX_LEVEL, MAX_LEVEL);
+        m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = MAX_LEVEL;
+    }
+
+    m_int_configs[CONFIG_MIN_DUALSPEC_LEVEL] = ConfigMgr::GetIntDefault("MinDualSpecLevel", 40);
+
+    m_int_configs[CONFIG_START_PLAYER_LEVEL] = ConfigMgr::GetIntDefault("StartPlayerLevel", 1);
+    if (m_int_configs[CONFIG_START_PLAYER_LEVEL] < 1)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "StartPlayerLevel (%i) must be in range 1..MaxPlayerLevel(%u). Set to 1.", m_int_configs[CONFIG_START_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+        m_int_configs[CONFIG_START_PLAYER_LEVEL] = 1;
+    }
+    else if (m_int_configs[CONFIG_START_PLAYER_LEVEL] > m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "StartPlayerLevel (%i) must be in range 1..MaxPlayerLevel(%u). Set to %u.", m_int_configs[CONFIG_START_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+        m_int_configs[CONFIG_START_PLAYER_LEVEL] = m_int_configs[CONFIG_MAX_PLAYER_LEVEL];
+    }
+
+    m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] = ConfigMgr::GetIntDefault("StartHeroicPlayerLevel", 55);
+    if (m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] < 1)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "StartHeroicPlayerLevel (%i) must be in range 1..MaxPlayerLevel(%u). Set to 55.",
+            m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+        m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] = 55;
+    }
+    else if (m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] > m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "StartHeroicPlayerLevel (%i) must be in range 1..MaxPlayerLevel(%u). Set to %u.",
+            m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL]);
+        m_int_configs[CONFIG_START_HEROIC_PLAYER_LEVEL] = m_int_configs[CONFIG_MAX_PLAYER_LEVEL];
+    }
+
+    m_int_configs[CONFIG_START_PLAYER_MONEY] = ConfigMgr::GetIntDefault("StartPlayerMoney", 0);
+    if (int32(m_int_configs[CONFIG_START_PLAYER_MONEY]) < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "StartPlayerMoney (%i) must be in range 0.." UI64FMTD ". Set to %u.", m_int_configs[CONFIG_START_PLAYER_MONEY], uint64(MAX_MONEY_AMOUNT), 0);
+        m_int_configs[CONFIG_START_PLAYER_MONEY] = 0;
+    }
+    else if (m_int_configs[CONFIG_START_PLAYER_MONEY] > 0x7FFFFFFF-1) // TODO: (See MAX_MONEY_AMOUNT)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "StartPlayerMoney (%i) must be in range 0..%u. Set to %u.",
+            m_int_configs[CONFIG_START_PLAYER_MONEY], 0x7FFFFFFF-1, 0x7FFFFFFF-1);
+        m_int_configs[CONFIG_START_PLAYER_MONEY] = 0x7FFFFFFF-1;
+    }
+
+    m_int_configs[CONFIG_CURRENCY_RESET_HOUR] = ConfigMgr::GetIntDefault("Currency.ResetHour", 3);
+    if (m_int_configs[CONFIG_CURRENCY_RESET_HOUR] > 23)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.ResetHour (%i) can't be load. Set to 6.", m_int_configs[CONFIG_CURRENCY_RESET_HOUR]);
+        m_int_configs[CONFIG_CURRENCY_RESET_HOUR] = 3;
+    }
+    m_int_configs[CONFIG_CURRENCY_RESET_DAY] = ConfigMgr::GetIntDefault("Currency.ResetDay", 3);
+    if (m_int_configs[CONFIG_CURRENCY_RESET_DAY] > 6)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.ResetDay (%i) can't be load. Set to 3.", m_int_configs[CONFIG_CURRENCY_RESET_DAY]);
+        m_int_configs[CONFIG_CURRENCY_RESET_DAY] = 3;
+    }
+    m_int_configs[CONFIG_CURRENCY_RESET_INTERVAL] = ConfigMgr::GetIntDefault("Currency.ResetInterval", 7);
+    if (int32(m_int_configs[CONFIG_CURRENCY_RESET_INTERVAL]) <= 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.ResetInterval (%i) must be > 0, set to default 7.", m_int_configs[CONFIG_CURRENCY_RESET_INTERVAL]);
+        m_int_configs[CONFIG_CURRENCY_RESET_INTERVAL] = 7;
+    }
+
+    m_int_configs[CONFIG_CURRENCY_START_HONOR_POINTS] = ConfigMgr::GetIntDefault("Currency.StartHonorPoints", 0);
+    if (int32(m_int_configs[CONFIG_CURRENCY_START_HONOR_POINTS]) < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.StartHonorPoints (%i) must be >= 0, set to default 0.", m_int_configs[CONFIG_CURRENCY_START_HONOR_POINTS]);
+        m_int_configs[CONFIG_CURRENCY_START_HONOR_POINTS] = 0;
+    }
+    m_int_configs[CONFIG_CURRENCY_MAX_HONOR_POINTS] = ConfigMgr::GetIntDefault("Currency.MaxHonorPoints", 4000);
+    if (int32(m_int_configs[CONFIG_CURRENCY_MAX_HONOR_POINTS]) < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.MaxHonorPoints (%i) can't be negative. Set to default 4000.", m_int_configs[CONFIG_CURRENCY_MAX_HONOR_POINTS]);
+        m_int_configs[CONFIG_CURRENCY_MAX_HONOR_POINTS] = 4000;
+    }
+    m_int_configs[CONFIG_CURRENCY_MAX_HONOR_POINTS] *= 100;     //precision mod
+
+    m_int_configs[CONFIG_CURRENCY_START_JUSTICE_POINTS] = ConfigMgr::GetIntDefault("Currency.StartJusticePoints", 0);
+    if (int32(m_int_configs[CONFIG_CURRENCY_START_JUSTICE_POINTS]) < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.StartJusticePoints (%i) must be >= 0, set to default 0.", m_int_configs[CONFIG_CURRENCY_START_JUSTICE_POINTS]);
+        m_int_configs[CONFIG_CURRENCY_START_JUSTICE_POINTS] = 0;
+    }
+    m_int_configs[CONFIG_CURRENCY_MAX_JUSTICE_POINTS] = ConfigMgr::GetIntDefault("Currency.MaxJusticePoints", 4000);
+    if (int32(m_int_configs[CONFIG_CURRENCY_MAX_JUSTICE_POINTS]) < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.MaxJusticePoints (%i) can't be negative. Set to default 4000.", m_int_configs[CONFIG_CURRENCY_MAX_JUSTICE_POINTS]);
+        m_int_configs[CONFIG_CURRENCY_MAX_JUSTICE_POINTS] = 4000;
+    }
+    m_int_configs[CONFIG_CURRENCY_MAX_JUSTICE_POINTS] *= 100;     //precision mod
+
+    m_int_configs[CONFIG_CURRENCY_START_VALOR_POINTS] = ConfigMgr::GetIntDefault("Currency.StartValorPoints", 0);
+    if (int32(m_int_configs[CONFIG_CURRENCY_START_VALOR_POINTS]) < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.StartValorPoints (%i) must be >= 0, set to default 0.", m_int_configs[CONFIG_CURRENCY_START_VALOR_POINTS]);
+        m_int_configs[CONFIG_CURRENCY_START_VALOR_POINTS] = 0;
+    }
+
+    m_int_configs[CONFIG_CURRENCY_START_CONQUEST_POINTS] = ConfigMgr::GetIntDefault("Currency.StartConquestPoints", 0);
+    if (int32(m_int_configs[CONFIG_CURRENCY_START_CONQUEST_POINTS]) < 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.StartConquestPoints (%i) must be >= 0, set to default 0.", m_int_configs[CONFIG_CURRENCY_START_CONQUEST_POINTS]);
+        m_int_configs[CONFIG_CURRENCY_START_CONQUEST_POINTS] = 0;
+    }
+    m_int_configs[CONFIG_CURRENCY_CONQUEST_POINTS_WEEK_CAP] = ConfigMgr::GetIntDefault("Currency.ConquestPointsWeekCap", 1350);
+    if (int32(m_int_configs[CONFIG_CURRENCY_CONQUEST_POINTS_WEEK_CAP]) <= 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.ConquestPointsWeekCap (%i) must be > 0, set to default 1650.", m_int_configs[CONFIG_CURRENCY_CONQUEST_POINTS_WEEK_CAP]);
+        m_int_configs[CONFIG_CURRENCY_CONQUEST_POINTS_WEEK_CAP] = 1350;
+    }
+    m_int_configs[CONFIG_CURRENCY_CONQUEST_POINTS_WEEK_CAP] *= 100;     //precision mod
+
+    m_int_configs[CONFIG_CURRENCY_CONQUEST_POINTS_ARENA_REWARD] = ConfigMgr::GetIntDefault("Currency.ConquestPointsArenaReward", 180);
+    if (int32(m_int_configs[CONFIG_CURRENCY_CONQUEST_POINTS_ARENA_REWARD]) <= 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Currency.ConquestPointsArenaReward (%i) must be > 0, set to default 180.", m_int_configs[CONFIG_CURRENCY_CONQUEST_POINTS_ARENA_REWARD]);
+        m_int_configs[CONFIG_CURRENCY_CONQUEST_POINTS_ARENA_REWARD] = 180;
+    }
+    m_int_configs[CONFIG_CURRENCY_CONQUEST_POINTS_ARENA_REWARD] *= 100;     //precision mod
+
+    m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL] = ConfigMgr::GetIntDefault("RecruitAFriend.MaxLevel", 60);
+    if (m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL] > m_int_configs[CONFIG_MAX_PLAYER_LEVEL])
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "RecruitAFriend.MaxLevel (%i) must be in the range 0..MaxLevel(%u). Set to %u.",
+            m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL], m_int_configs[CONFIG_MAX_PLAYER_LEVEL], 60);
+        m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL] = 60;
+    }
+
+    m_int_configs[CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL_DIFFERENCE] = ConfigMgr::GetIntDefault("RecruitAFriend.MaxDifference", 4);
+    m_bool_configs[CONFIG_ALL_TAXI_PATHS] = ConfigMgr::GetBoolDefault("AllFlightPaths", false);
+    m_bool_configs[CONFIG_INSTANT_TAXI] = ConfigMgr::GetBoolDefault("InstantFlightPaths", false);
+
+    m_bool_configs[CONFIG_INSTANCE_IGNORE_LEVEL] = ConfigMgr::GetBoolDefault("Instance.IgnoreLevel", false);
+    m_bool_configs[CONFIG_INSTANCE_IGNORE_RAID]  = ConfigMgr::GetBoolDefault("Instance.IgnoreRaid", false);
+
+    m_bool_configs[CONFIG_CAST_UNSTUCK] = ConfigMgr::GetBoolDefault("CastUnstuck", true);
+    m_int_configs[CONFIG_INSTANCE_RESET_TIME_HOUR]  = ConfigMgr::GetIntDefault("Instance.ResetTimeHour", 4);
+    m_int_configs[CONFIG_INSTANCE_UNLOAD_DELAY] = ConfigMgr::GetIntDefault("Instance.UnloadDelay", 30 * MINUTE * IN_MILLISECONDS);
+
+    m_int_configs[CONFIG_MAX_PRIMARY_TRADE_SKILL] = ConfigMgr::GetIntDefault("MaxPrimaryTradeSkill", 2);
+    m_int_configs[CONFIG_MIN_PETITION_SIGNS] = ConfigMgr::GetIntDefault("MinPetitionSigns", 9);
+    if (m_int_configs[CONFIG_MIN_PETITION_SIGNS] > 9)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "MinPetitionSigns (%i) must be in range 0..9. Set to 9.", m_int_configs[CONFIG_MIN_PETITION_SIGNS]);
+        m_int_configs[CONFIG_MIN_PETITION_SIGNS] = 9;
+    }
+
+    m_int_configs[CONFIG_GM_LOGIN_STATE]        = ConfigMgr::GetIntDefault("GM.LoginState", 2);
+    m_int_configs[CONFIG_GM_VISIBLE_STATE]      = ConfigMgr::GetIntDefault("GM.Visible", 2);
+    m_int_configs[CONFIG_GM_CHAT]               = ConfigMgr::GetIntDefault("GM.Chat", 2);
+    m_int_configs[CONFIG_GM_WHISPERING_TO]      = ConfigMgr::GetIntDefault("GM.WhisperingTo", 2);
+
+    m_int_configs[CONFIG_GM_LEVEL_IN_GM_LIST]   = ConfigMgr::GetIntDefault("GM.InGMList.Level", SEC_ADMINISTRATOR);
+    m_int_configs[CONFIG_GM_LEVEL_IN_WHO_LIST]  = ConfigMgr::GetIntDefault("GM.InWhoList.Level", SEC_ADMINISTRATOR);
+    m_bool_configs[CONFIG_GM_LOG_TRADE]         = ConfigMgr::GetBoolDefault("GM.LogTrade", false);
+    m_int_configs[CONFIG_START_GM_LEVEL]        = ConfigMgr::GetIntDefault("GM.StartLevel", 1);
+    if (m_int_configs[CONFIG_START_GM_LEVEL] < m_int_configs[CONFIG_START_PLAYER_LEVEL])
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "GM.StartLevel (%i) must be in range StartPlayerLevel(%u)..%u. Set to %u.",
+            m_int_configs[CONFIG_START_GM_LEVEL], m_int_configs[CONFIG_START_PLAYER_LEVEL], MAX_LEVEL, m_int_configs[CONFIG_START_PLAYER_LEVEL]);
+        m_int_configs[CONFIG_START_GM_LEVEL] = m_int_configs[CONFIG_START_PLAYER_LEVEL];
+    }
+    else if (m_int_configs[CONFIG_START_GM_LEVEL] > MAX_LEVEL)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "GM.StartLevel (%i) must be in range 1..%u. Set to %u.", m_int_configs[CONFIG_START_GM_LEVEL], MAX_LEVEL, MAX_LEVEL);
+        m_int_configs[CONFIG_START_GM_LEVEL] = MAX_LEVEL;
+    }
+    m_bool_configs[CONFIG_ALLOW_GM_GROUP]       = ConfigMgr::GetBoolDefault("GM.AllowInvite", false);
+    m_bool_configs[CONFIG_ALLOW_GM_FRIEND]      = ConfigMgr::GetBoolDefault("GM.AllowFriend", false);
+    m_bool_configs[CONFIG_GM_LOWER_SECURITY] = ConfigMgr::GetBoolDefault("GM.LowerSecurity", false);
+    m_float_configs[CONFIG_CHANCE_OF_GM_SURVEY] = ConfigMgr::GetFloatDefault("GM.TicketSystem.ChanceOfGMSurvey", 50.0f);
+
+    m_int_configs[CONFIG_GROUP_VISIBILITY] = ConfigMgr::GetIntDefault("Visibility.GroupMode", 1);
+
+    m_int_configs[CONFIG_MAIL_DELIVERY_DELAY] = ConfigMgr::GetIntDefault("MailDeliveryDelay", HOUR);
+
+    m_int_configs[CONFIG_UPTIME_UPDATE] = ConfigMgr::GetIntDefault("UpdateUptimeInterval", 10);
+    if (int32(m_int_configs[CONFIG_UPTIME_UPDATE]) <= 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "UpdateUptimeInterval (%i) must be > 0, set to default 10.", m_int_configs[CONFIG_UPTIME_UPDATE]);
+        m_int_configs[CONFIG_UPTIME_UPDATE] = 10;
+    }
+    if (reload)
+    {
+        m_timers[WUPDATE_UPTIME].SetInterval(m_int_configs[CONFIG_UPTIME_UPDATE]*MINUTE*IN_MILLISECONDS);
+        m_timers[WUPDATE_UPTIME].Reset();
+    }
+
+    // log db cleanup interval
+    m_int_configs[CONFIG_LOGDB_CLEARINTERVAL] = ConfigMgr::GetIntDefault("LogDB.Opt.ClearInterval", 10);
+    if (int32(m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]) <= 0)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "LogDB.Opt.ClearInterval (%i) must be > 0, set to default 10.", m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]);
+        m_int_configs[CONFIG_LOGDB_CLEARINTERVAL] = 10;
+    }
+    if (reload)
+    {
+        m_timers[WUPDATE_CLEANDB].SetInterval(m_int_configs[CONFIG_LOGDB_CLEARINTERVAL] * MINUTE * IN_MILLISECONDS);
+        m_timers[WUPDATE_CLEANDB].Reset();
+    }
+    m_int_configs[CONFIG_LOGDB_CLEARTIME] = ConfigMgr::GetIntDefault("LogDB.Opt.ClearTime", 1209600); // 14 days default
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Will clear `logs` table of entries older than %i seconds every %u minutes.",
+        m_int_configs[CONFIG_LOGDB_CLEARTIME], m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]);
+
+    m_int_configs[CONFIG_SKILL_CHANCE_ORANGE] = ConfigMgr::GetIntDefault("SkillChance.Orange", 100);
+    m_int_configs[CONFIG_SKILL_CHANCE_YELLOW] = ConfigMgr::GetIntDefault("SkillChance.Yellow", 75);
+    m_int_configs[CONFIG_SKILL_CHANCE_GREEN]  = ConfigMgr::GetIntDefault("SkillChance.Green", 25);
+    m_int_configs[CONFIG_SKILL_CHANCE_GREY]   = ConfigMgr::GetIntDefault("SkillChance.Grey", 0);
+
+    m_int_configs[CONFIG_SKILL_CHANCE_MINING_STEPS]  = ConfigMgr::GetIntDefault("SkillChance.MiningSteps", 75);
+    m_int_configs[CONFIG_SKILL_CHANCE_ARCHAEOLOGY_STEPS]  = ConfigMgr::GetIntDefault("SkillChance.ArchaeologySteps", 75);
+    m_int_configs[CONFIG_SKILL_CHANCE_SKINNING_STEPS]   = ConfigMgr::GetIntDefault("SkillChance.SkinningSteps", 75);
+
+    m_bool_configs[CONFIG_SKILL_PROSPECTING] = ConfigMgr::GetBoolDefault("SkillChance.Prospecting", false);
+    m_bool_configs[CONFIG_SKILL_MILLING] = ConfigMgr::GetBoolDefault("SkillChance.Milling", false);
+
+    m_int_configs[CONFIG_SKILL_GAIN_CRAFTING]  = ConfigMgr::GetIntDefault("SkillGain.Crafting", 1);
+
+    m_int_configs[CONFIG_SKILL_GAIN_GATHERING]  = ConfigMgr::GetIntDefault("SkillGain.Gathering", 1);
+
+    m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] = ConfigMgr::GetIntDefault("MaxOverspeedPings", 2);
+    if (m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] != 0 && m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] < 2)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "MaxOverspeedPings (%i) must be in range 2..infinity (or 0 to disable check). Set to 2.", m_int_configs[CONFIG_MAX_OVERSPEED_PINGS]);
+        m_int_configs[CONFIG_MAX_OVERSPEED_PINGS] = 2;
+    }
+
+    m_bool_configs[CONFIG_SAVE_RESPAWN_TIME_IMMEDIATELY] = ConfigMgr::GetBoolDefault("SaveRespawnTimeImmediately", true);
+    m_bool_configs[CONFIG_WEATHER] = ConfigMgr::GetBoolDefault("ActivateWeather", true);
+
+    m_int_configs[CONFIG_DISABLE_BREATHING] = ConfigMgr::GetIntDefault("DisableWaterBreath", SEC_CONSOLE);
+
+
+    if (reload)
+    {
+        uint32 val = ConfigMgr::GetIntDefault("Expansion", 1);
+        if (val != m_int_configs[CONFIG_EXPANSION])
+            sLog->outError(LOG_FILTER_SERVER_LOADING, "Expansion option can't be changed at worldserver.conf reload, using current value (%u).", m_int_configs[CONFIG_EXPANSION]);
+    }
+    else
+        m_int_configs[CONFIG_EXPANSION] = ConfigMgr::GetIntDefault("Expansion", 1);
+
+    m_int_configs[CONFIG_CHATFLOOD_MESSAGE_COUNT] = ConfigMgr::GetIntDefault("ChatFlood.MessageCount", 10);
+    m_int_configs[CONFIG_CHATFLOOD_MESSAGE_DELAY] = ConfigMgr::GetIntDefault("ChatFlood.MessageDelay", 1);
+    m_int_configs[CONFIG_CHATFLOOD_MUTE_TIME]     = ConfigMgr::GetIntDefault("ChatFlood.MuteTime", 10);
+
+    m_int_configs[CONFIG_EVENT_ANNOUNCE] = ConfigMgr::GetIntDefault("Event.Announce", 0);
+
+    m_float_configs[CONFIG_CREATURE_FAMILY_FLEE_ASSISTANCE_RADIUS] = ConfigMgr::GetFloatDefault("CreatureFamilyFleeAssistanceRadius", 30.0f);
+    m_float_configs[CONFIG_CREATURE_FAMILY_ASSISTANCE_RADIUS] = ConfigMgr::GetFloatDefault("CreatureFamilyAssistanceRadius", 10.0f);
+    m_int_configs[CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY]  = ConfigMgr::GetIntDefault("CreatureFamilyAssistanceDelay", 1500);
+    m_int_configs[CONFIG_CREATURE_FAMILY_FLEE_DELAY]        = ConfigMgr::GetIntDefault("CreatureFamilyFleeDelay", 7000);
+
+    m_int_configs[CONFIG_WORLD_BOSS_LEVEL_DIFF] = ConfigMgr::GetIntDefault("WorldBossLevelDiff", 3);
+
+	m_bool_configs[CONFIG_QUEST_ENABLE_QUEST_TRACKER] = ConfigMgr::GetBoolDefault("Quests.EnableQuestTracker", false);
+
+    // note: disable value (-1) will assigned as 0xFFFFFFF, to prevent overflow at calculations limit it to max possible player level MAX_LEVEL(100)
+    m_int_configs[CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF] = ConfigMgr::GetIntDefault("Quests.LowLevelHideDiff", 4);
+    if (m_int_configs[CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF] > MAX_LEVEL)
+        m_int_configs[CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF] = MAX_LEVEL;
+    m_int_configs[CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF] = ConfigMgr::GetIntDefault("Quests.HighLevelHideDiff", 7);
+    if (m_int_configs[CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF] > MAX_LEVEL)
+        m_int_configs[CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF] = MAX_LEVEL;
+    m_bool_configs[CONFIG_QUEST_IGNORE_RAID] = ConfigMgr::GetBoolDefault("Quests.IgnoreRaid", false);
+    m_bool_configs[CONFIG_QUEST_IGNORE_AUTO_ACCEPT] = ConfigMgr::GetBoolDefault("Quests.IgnoreAutoAccept", false);
+    m_bool_configs[CONFIG_QUEST_IGNORE_AUTO_COMPLETE] = ConfigMgr::GetBoolDefault("Quests.IgnoreAutoComplete", false);
+
+    m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR] = ConfigMgr::GetIntDefault("Battleground.Random.ResetHour", 6);
+    if (m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR] > 23)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Battleground.Random.ResetHour (%i) can't be load. Set to 6.", m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR]);
+        m_int_configs[CONFIG_RANDOM_BG_RESET_HOUR] = 6;
+    }
+
+    m_int_configs[CONFIG_GUILD_RESET_HOUR] = ConfigMgr::GetIntDefault("Guild.ResetHour", 6);
+    if (m_int_configs[CONFIG_GUILD_RESET_HOUR] > 23)
+    {
+        sLog->outError(LOG_FILTER_GENERAL, "Guild.ResetHour (%i) can't be load. Set to 6.", m_int_configs[CONFIG_GUILD_RESET_HOUR]);
+        m_int_configs[CONFIG_GUILD_RESET_HOUR] = 6;
+    }
+
+    m_bool_configs[CONFIG_DETECT_POS_COLLISION] = ConfigMgr::GetBoolDefault("DetectPosCollision", true);
+
+    m_bool_configs[CONFIG_RESTRICTED_LFG_CHANNEL]      = ConfigMgr::GetBoolDefault("Channel.RestrictedLfg", true);
+    m_bool_configs[CONFIG_SILENTLY_GM_JOIN_TO_CHANNEL] = ConfigMgr::GetBoolDefault("Channel.SilentlyGMJoin", false);
+
+    m_bool_configs[CONFIG_TALENTS_INSPECTING]           = ConfigMgr::GetBoolDefault("TalentsInspecting", true);
+    m_bool_configs[CONFIG_CHAT_FAKE_MESSAGE_PREVENTING] = ConfigMgr::GetBoolDefault("ChatFakeMessagePreventing", false);
+    m_int_configs[CONFIG_CHAT_STRICT_LINK_CHECKING_SEVERITY] = ConfigMgr::GetIntDefault("ChatStrictLinkChecking.Severity", 0);
+    m_int_configs[CONFIG_CHAT_STRICT_LINK_CHECKING_KICK] = ConfigMgr::GetIntDefault("ChatStrictLinkChecking.Kick", 0);
+
+    m_int_configs[CONFIG_CORPSE_DECAY_NORMAL]    = ConfigMgr::GetIntDefault("Corpse.Decay.NORMAL", 60);
+    m_int_configs[CONFIG_CORPSE_DECAY_RARE]      = ConfigMgr::GetIntDefault("Corpse.Decay.RARE", 300);
+    m_int_configs[CONFIG_CORPSE_DECAY_ELITE]     = ConfigMgr::GetIntDefault("Corpse.Decay.ELITE", 300);
+    m_int_configs[CONFIG_CORPSE_DECAY_RAREELITE] = ConfigMgr::GetIntDefault("Corpse.Decay.RAREELITE", 300);
+    m_int_configs[CONFIG_CORPSE_DECAY_WORLDBOSS] = ConfigMgr::GetIntDefault("Corpse.Decay.WORLDBOSS", 3600);
+
+    m_int_configs[CONFIG_DEATH_SICKNESS_LEVEL]           = ConfigMgr::GetIntDefault ("Death.SicknessLevel", 11);
+    m_bool_configs[CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP] = ConfigMgr::GetBoolDefault("Death.CorpseReclaimDelay.PvP", true);
+    m_bool_configs[CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE] = ConfigMgr::GetBoolDefault("Death.CorpseReclaimDelay.PvE", true);
+    m_bool_configs[CONFIG_DEATH_BONES_WORLD]              = ConfigMgr::GetBoolDefault("Death.Bones.World", true);
+    m_bool_configs[CONFIG_DEATH_BONES_BG_OR_ARENA]        = ConfigMgr::GetBoolDefault("Death.Bones.BattlegroundOrArena", true);
+
+    m_bool_configs[CONFIG_DIE_COMMAND_MODE] = ConfigMgr::GetBoolDefault("Die.Command.Mode", true);
+
+    m_float_configs[CONFIG_THREAT_RADIUS] = ConfigMgr::GetFloatDefault("ThreatRadius", 60.0f);
+
+    // always use declined names in the russian client
+    m_bool_configs[CONFIG_DECLINED_NAMES_USED] =
+        (m_int_configs[CONFIG_REALM_ZONE] == REALM_ZONE_RUSSIAN) ? true : ConfigMgr::GetBoolDefault("DeclinedNames", false);
+
+    m_float_configs[CONFIG_LISTEN_RANGE_SAY]       = ConfigMgr::GetFloatDefault("ListenRange.Say", 25.0f);
+    m_float_configs[CONFIG_LISTEN_RANGE_TEXTEMOTE] = ConfigMgr::GetFloatDefault("ListenRange.TextEmote", 25.0f);
+    m_float_configs[CONFIG_LISTEN_RANGE_YELL]      = ConfigMgr::GetFloatDefault("ListenRange.Yell", 300.0f);
+
+    m_bool_configs[CONFIG_BATTLEGROUND_CAST_DESERTER]                = ConfigMgr::GetBoolDefault("Battleground.CastDeserter", true);
+    m_bool_configs[CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_ENABLE]       = ConfigMgr::GetBoolDefault("Battleground.QueueAnnouncer.Enable", false);
+    m_bool_configs[CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY]   = ConfigMgr::GetBoolDefault("Battleground.QueueAnnouncer.PlayerOnly", false);
+    m_int_configs[CONFIG_BATTLEGROUND_INVITATION_TYPE]               = ConfigMgr::GetIntDefault ("Battleground.InvitationType", 0);
+    m_int_configs[CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER]        = ConfigMgr::GetIntDefault ("Battleground.PrematureFinishTimer", 5 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_BATTLEGROUND_PREMADE_GROUP_WAIT_FOR_MATCH]  = ConfigMgr::GetIntDefault ("Battleground.PremadeGroupWaitForMatch", 30 * MINUTE * IN_MILLISECONDS);
+    m_bool_configs[CONFIG_BG_XP_FOR_KILL]                            = ConfigMgr::GetBoolDefault("Battleground.GiveXPForKills", false);
+    m_int_configs[CONFIG_ARENA_MAX_RATING_DIFFERENCE]                = ConfigMgr::GetIntDefault ("Arena.MaxRatingDifference", 150);
+    m_int_configs[CONFIG_ARENA_RATING_DISCARD_TIMER]                 = ConfigMgr::GetIntDefault ("Arena.RatingDiscardTimer", 10 * MINUTE * IN_MILLISECONDS);
+    m_int_configs[CONFIG_ARENA_RATED_UPDATE_TIMER]                   = ConfigMgr::GetIntDefault ("Arena.RatedUpdateTimer", 5 * IN_MILLISECONDS);
+    m_bool_configs[CONFIG_ARENA_QUEUE_ANNOUNCER_ENABLE]              = ConfigMgr::GetBoolDefault("Arena.QueueAnnouncer.Enable", false);
+    m_bool_configs[CONFIG_ARENA_QUEUE_ANNOUNCER_PLAYERONLY]          = ConfigMgr::GetBoolDefault("Arena.QueueAnnouncer.PlayerOnly", false);
+    m_int_configs[CONFIG_ARENA_SEASON_ID]                            = ConfigMgr::GetIntDefault ("Arena.ArenaSeason.ID", 1);
+    m_int_configs[CONFIG_ARENA_START_RATING]                         = ConfigMgr::GetIntDefault ("Arena.ArenaStartRating", 0);
+    m_int_configs[CONFIG_ARENA_START_PERSONAL_RATING]                = ConfigMgr::GetIntDefault ("Arena.ArenaStartPersonalRating", 1000);
+    m_int_configs[CONFIG_ARENA_START_MATCHMAKER_RATING]              = ConfigMgr::GetIntDefault ("Arena.ArenaStartMatchmakerRating", 1500);
+    m_bool_configs[CONFIG_ARENA_SEASON_IN_PROGRESS]                  = ConfigMgr::GetBoolDefault("Arena.ArenaSeason.InProgress", true);
+    m_bool_configs[CONFIG_ARENA_LOG_EXTENDED_INFO]                   = ConfigMgr::GetBoolDefault("ArenaLog.ExtendedInfo", false);
+
+    m_bool_configs[CONFIG_RATED_BATTLEGROUND_ENABLED]                = ConfigMgr::GetBoolDefault("Rated.BG.Enable", true);
+
+    /// Now it seems to be that only Arena Season ID is send to client (0 if arena isn't in progress)
+    if (m_int_configs[CONFIG_ARENA_SEASON_ID] < 1)
+        m_int_configs[CONFIG_ARENA_SEASON_ID] = 1;
+
+    m_bool_configs[CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN]            = ConfigMgr::GetBoolDefault("OffhandCheckAtSpellUnlearn", true);
+
+    if (int32 clientCacheId = ConfigMgr::GetIntDefault("ClientCacheVersion", 0))
+    {
+        // overwrite DB/old value
+        if (clientCacheId > 0)
+        {
+            m_int_configs[CONFIG_CLIENTCACHE_VERSION] = clientCacheId;
+            sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Client cache version set to: %u", clientCacheId);
+        }
+        else
+            sLog->outError(LOG_FILTER_SERVER_LOADING, "ClientCacheVersion can't be negative %d, ignored.", clientCacheId);
+    }
+
+    m_int_configs[CONFIG_INSTANT_LOGOUT] = ConfigMgr::GetIntDefault("InstantLogout", SEC_MODERATOR);
+
+    m_int_configs[CONFIG_GUILD_NEWS_LOG_COUNT] = ConfigMgr::GetIntDefault("Guild.NewsLogRecordsCount", GUILD_NEWSLOG_MAX_RECORDS);
+    if (m_int_configs[CONFIG_GUILD_NEWS_LOG_COUNT] > GUILD_NEWSLOG_MAX_RECORDS)
+        m_int_configs[CONFIG_GUILD_NEWS_LOG_COUNT] = GUILD_NEWSLOG_MAX_RECORDS;
+    m_int_configs[CONFIG_GUILD_EVENT_LOG_COUNT] = ConfigMgr::GetIntDefault("Guild.EventLogRecordsCount", GUILD_EVENTLOG_MAX_RECORDS);
+    if (m_int_configs[CONFIG_GUILD_EVENT_LOG_COUNT] > GUILD_EVENTLOG_MAX_RECORDS)
+        m_int_configs[CONFIG_GUILD_EVENT_LOG_COUNT] = GUILD_EVENTLOG_MAX_RECORDS;
+    m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] = ConfigMgr::GetIntDefault("Guild.BankEventLogRecordsCount", GUILD_BANKLOG_MAX_RECORDS);
+    if (m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] > GUILD_BANKLOG_MAX_RECORDS)
+        m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] = GUILD_BANKLOG_MAX_RECORDS;
+
+    //visibility on continents
+    m_MaxVisibleDistanceOnContinents = ConfigMgr::GetFloatDefault("Visibility.Distance.Continents", DEFAULT_VISIBILITY_DISTANCE);
+    if (m_MaxVisibleDistanceOnContinents < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Visibility.Distance.Continents can't be less max aggro radius %f", 45*sWorld->getRate(RATE_CREATURE_AGGRO));
+        m_MaxVisibleDistanceOnContinents = 45*sWorld->getRate(RATE_CREATURE_AGGRO);
+    }
+    else if (m_MaxVisibleDistanceOnContinents > MAX_VISIBILITY_DISTANCE)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Visibility.Distance.Continents can't be greater %f", MAX_VISIBILITY_DISTANCE);
+        m_MaxVisibleDistanceOnContinents = MAX_VISIBILITY_DISTANCE;
+    }
+
+    //visibility in instances
+    m_MaxVisibleDistanceInInstances = ConfigMgr::GetFloatDefault("Visibility.Distance.Instances", DEFAULT_VISIBILITY_INSTANCE);
+    if (m_MaxVisibleDistanceInInstances < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Visibility.Distance.Instances can't be less max aggro radius %f", 45*sWorld->getRate(RATE_CREATURE_AGGRO));
+        m_MaxVisibleDistanceInInstances = 45*sWorld->getRate(RATE_CREATURE_AGGRO);
+    }
+    else if (m_MaxVisibleDistanceInInstances > MAX_VISIBILITY_DISTANCE)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Visibility.Distance.Instances can't be greater %f", MAX_VISIBILITY_DISTANCE);
+        m_MaxVisibleDistanceInInstances = MAX_VISIBILITY_DISTANCE;
+    }
+
+    //visibility in BG/Arenas
+    m_MaxVisibleDistanceInBGArenas = ConfigMgr::GetFloatDefault("Visibility.Distance.BGArenas", DEFAULT_VISIBILITY_BGARENAS);
+    if (m_MaxVisibleDistanceInBGArenas < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Visibility.Distance.BGArenas can't be less max aggro radius %f", 45*sWorld->getRate(RATE_CREATURE_AGGRO));
+        m_MaxVisibleDistanceInBGArenas = 45*sWorld->getRate(RATE_CREATURE_AGGRO);
+    }
+    else if (m_MaxVisibleDistanceInBGArenas > MAX_VISIBILITY_DISTANCE)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Visibility.Distance.BGArenas can't be greater %f", MAX_VISIBILITY_DISTANCE);
+        m_MaxVisibleDistanceInBGArenas = MAX_VISIBILITY_DISTANCE;
+    }
+
+    m_visibility_notify_periodOnContinents = ConfigMgr::GetIntDefault("Visibility.Notify.Period.OnContinents", DEFAULT_VISIBILITY_NOTIFY_PERIOD);
+    m_visibility_notify_periodInInstances = ConfigMgr::GetIntDefault("Visibility.Notify.Period.InInstances",   DEFAULT_VISIBILITY_NOTIFY_PERIOD);
+    m_visibility_notify_periodInBGArenas = ConfigMgr::GetIntDefault("Visibility.Notify.Period.InBGArenas",    DEFAULT_VISIBILITY_NOTIFY_PERIOD);
+
+    ///- Load the CharDelete related config options
+    m_int_configs[CONFIG_CHARDELETE_METHOD] = ConfigMgr::GetIntDefault("CharDelete.Method", 0);
+    m_int_configs[CONFIG_CHARDELETE_MIN_LEVEL] = ConfigMgr::GetIntDefault("CharDelete.MinLevel", 0);
+    m_int_configs[CONFIG_CHARDELETE_KEEP_DAYS] = ConfigMgr::GetIntDefault("CharDelete.KeepDays", 30);
+
+    //HP Gold Synch
+    m_bool_configs[CONFIG_HPGOLD_REFRESH_ENABLED] = ConfigMgr::GetBoolDefault("HPGold.Refresh.Enabled", true);
+    m_int_configs[CONFIG_HPGOLD_REFRESH_INTERVAL] = ConfigMgr::GetIntDefault("HPGold.Refresh.Interval", 10);
+    if (int32(m_int_configs[CONFIG_HPGOLD_REFRESH_INTERVAL]) < 10)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "HPGold.Refresh.Interval (%i) must be >= 10, set to default 10.", m_int_configs[CONFIG_HPGOLD_REFRESH_INTERVAL]);
+        m_int_configs[CONFIG_HPGOLD_REFRESH_INTERVAL] = 10;
+    }
+    if (reload)
+    {
+        m_timers[WUPDATE_HPGOLD].SetInterval(m_int_configs[CONFIG_HPGOLD_REFRESH_INTERVAL] * IN_MILLISECONDS);
+        m_timers[WUPDATE_HPGOLD].Reset();
+    }
+
+    //Cronjobs
+    m_bool_configs[CONFIG_CRONJOBS_ENABLED] = ConfigMgr::GetBoolDefault("Cronjobs.Enabled", true);
+    m_int_configs[CONFIG_CRONJOBS_INTERVAL] = ConfigMgr::GetIntDefault("Cronjobs.Execute.Interval", 5);
+    if (int32(m_int_configs[CONFIG_CRONJOBS_INTERVAL]) < 1)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Cronjobs.Execute.Interval (%i) must be >= 1, set to default 5.", m_int_configs[CONFIG_CRONJOBS_INTERVAL]);
+        m_int_configs[CONFIG_CRONJOBS_INTERVAL] = 5;
+    }
+    if (reload)
+    {
+        m_timers[WUPDATE_CRONJOBS].SetInterval(m_int_configs[CONFIG_CRONJOBS_INTERVAL] * IN_MILLISECONDS);
+        m_timers[WUPDATE_CRONJOBS].Reset();
+    }
+
+    ///- Read the "Data" directory from the config file
+    std::string dataPath = ConfigMgr::GetStringDefault("DataDir", "./");
+    if (dataPath.at(dataPath.length()-1) != '/' && dataPath.at(dataPath.length()-1) != '\\')
+        dataPath.push_back('/');
+
+#if PLATFORM == PLATFORM_UNIX || PLATFORM == PLATFORM_APPLE
+    if (dataPath[0] == '~')
+    {
+        const char* home = getenv("HOME");
+        if (home)
+            dataPath.replace(0, 1, home);
+    }
+#endif
+
+    if (reload)
+    {
+        if (dataPath != m_dataPath)
+            sLog->outError(LOG_FILTER_SERVER_LOADING, "DataDir option can't be changed at worldserver.conf reload, using current value (%s).", m_dataPath.c_str());
+    }
+    else
+    {
+        m_dataPath = dataPath;
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Using DataDir %s", m_dataPath.c_str());
+    }
+
+    m_bool_configs[CONFIG_ENABLE_MMAPS] = ConfigMgr::GetBoolDefault("mmap.enablePathFinding", false);
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "WORLD: MMap data directory is: %smmaps", m_dataPath.c_str());
+
+    m_bool_configs[CONFIG_VMAP_INDOOR_CHECK] = ConfigMgr::GetBoolDefault("vmap.enableIndoorCheck", 0);
+    bool enableIndoor = ConfigMgr::GetBoolDefault("vmap.enableIndoorCheck", true);
+    bool enableLOS = ConfigMgr::GetBoolDefault("vmap.enableLOS", true);
+    bool enableHeight = ConfigMgr::GetBoolDefault("vmap.enableHeight", true);
+
+    if (!enableHeight)
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "VMap height checking disabled! Creatures movements and other various things WILL be broken! Expect no support.");
+
+    VMAP::VMapFactory::createOrGetVMapManager()->setEnableLineOfSightCalc(enableLOS);
+    VMAP::VMapFactory::createOrGetVMapManager()->setEnableHeightCalc(enableHeight);
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "VMap support included. LineOfSight: %i, getHeight: %i, indoorCheck: %i", enableLOS, enableHeight, enableIndoor);
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "VMap data directory is: %svmaps", m_dataPath.c_str());
+
+    m_int_configs[CONFIG_MAX_WHO] = ConfigMgr::GetIntDefault("MaxWhoListReturns", 49);
+    m_bool_configs[CONFIG_START_ALL_SPELLS] = ConfigMgr::GetBoolDefault("PlayerStart.AllSpells", false);
+    if (m_bool_configs[CONFIG_START_ALL_SPELLS])
+        sLog->outWarn(LOG_FILTER_SERVER_LOADING, "PlayerStart.AllSpells enabled - may not function as intended!");
+    m_int_configs[CONFIG_HONOR_AFTER_DUEL] = ConfigMgr::GetIntDefault("HonorPointsAfterDuel", 0);
+    m_bool_configs[CONFIG_START_ALL_EXPLORED] = ConfigMgr::GetBoolDefault("PlayerStart.MapsExplored", false);
+    m_bool_configs[CONFIG_START_ALL_REP] = ConfigMgr::GetBoolDefault("PlayerStart.AllReputation", false);
+    m_bool_configs[CONFIG_ALWAYS_MAXSKILL] = ConfigMgr::GetBoolDefault("AlwaysMaxWeaponSkill", false);
+    m_bool_configs[CONFIG_PVP_TOKEN_ENABLE] = ConfigMgr::GetBoolDefault("PvPToken.Enable", false);
+    m_int_configs[CONFIG_PVP_TOKEN_MAP_TYPE] = ConfigMgr::GetIntDefault("PvPToken.MapAllowType", 4);
+    m_int_configs[CONFIG_PVP_TOKEN_ID] = ConfigMgr::GetIntDefault("PvPToken.ItemID", 29434);
+    m_int_configs[CONFIG_PVP_TOKEN_COUNT] = ConfigMgr::GetIntDefault("PvPToken.ItemCount", 1);
+    if (m_int_configs[CONFIG_PVP_TOKEN_COUNT] < 1)
+        m_int_configs[CONFIG_PVP_TOKEN_COUNT] = 1;
+
+    m_bool_configs[CONFIG_NO_RESET_TALENT_COST] = ConfigMgr::GetBoolDefault("NoResetTalentsCost", false);
+    m_bool_configs[CONFIG_SHOW_KICK_IN_WORLD] = ConfigMgr::GetBoolDefault("ShowKickInWorld", false);
+	m_bool_configs[CONFIG_SHOW_MUTE_IN_WORLD] = ConfigMgr::GetBoolDefault("ShowMuteInWorld", false);
+	m_bool_configs[CONFIG_SHOW_BAN_IN_WORLD] = ConfigMgr::GetBoolDefault("ShowBanInWorld", false);
+    m_int_configs[CONFIG_INTERVAL_LOG_UPDATE] = ConfigMgr::GetIntDefault("RecordUpdateTimeDiffInterval", 60000);
+    m_int_configs[CONFIG_MIN_LOG_UPDATE] = ConfigMgr::GetIntDefault("MinRecordUpdateTimeDiff", 100);
+    m_int_configs[CONFIG_NUMTHREADS] = ConfigMgr::GetIntDefault("MapUpdate.Threads", 1);
+    m_int_configs[CONFIG_MAX_RESULTS_LOOKUP_COMMANDS] = ConfigMgr::GetIntDefault("Command.LookupMaxResults", 0);
+
+    // chat logging
+    m_bool_configs[CONFIG_CHATLOG_CHANNEL] = ConfigMgr::GetBoolDefault("ChatLogs.Channel", false);
+    m_bool_configs[CONFIG_CHATLOG_WHISPER] = ConfigMgr::GetBoolDefault("ChatLogs.Whisper", false);
+    m_bool_configs[CONFIG_CHATLOG_SYSCHAN] = ConfigMgr::GetBoolDefault("ChatLogs.SysChan", false);
+    m_bool_configs[CONFIG_CHATLOG_PARTY] = ConfigMgr::GetBoolDefault("ChatLogs.Party", false);
+    m_bool_configs[CONFIG_CHATLOG_RAID] = ConfigMgr::GetBoolDefault("ChatLogs.Raid", false);
+    m_bool_configs[CONFIG_CHATLOG_GUILD] = ConfigMgr::GetBoolDefault("ChatLogs.Guild", false);
+    m_bool_configs[CONFIG_CHATLOG_PUBLIC] = ConfigMgr::GetBoolDefault("ChatLogs.Public", false);
+    m_bool_configs[CONFIG_CHATLOG_ADDON] = ConfigMgr::GetBoolDefault("ChatLogs.Addon", false);
+    m_bool_configs[CONFIG_CHATLOG_BGROUND] = ConfigMgr::GetBoolDefault("ChatLogs.Battleground", false);
+
+    // Warden
+    m_bool_configs[CONFIG_WARDEN_ENABLED]              = ConfigMgr::GetBoolDefault("Warden.Enabled", false);
+    m_int_configs[CONFIG_WARDEN_NUM_MEM_CHECKS]        = ConfigMgr::GetIntDefault("Warden.NumMemChecks", 3);
+    m_int_configs[CONFIG_WARDEN_NUM_OTHER_CHECKS]      = ConfigMgr::GetIntDefault("Warden.NumOtherChecks", 7);
+    m_int_configs[CONFIG_WARDEN_CLIENT_BAN_DURATION]   = ConfigMgr::GetIntDefault("Warden.BanDuration", 86400);
+    m_int_configs[CONFIG_WARDEN_CLIENT_CHECK_HOLDOFF]  = ConfigMgr::GetIntDefault("Warden.ClientCheckHoldOff", 30);
+    m_int_configs[CONFIG_WARDEN_CLIENT_FAIL_ACTION]    = ConfigMgr::GetIntDefault("Warden.ClientCheckFailAction", 0);
+    m_int_configs[CONFIG_WARDEN_CLIENT_RESPONSE_DELAY] = ConfigMgr::GetIntDefault("Warden.ClientResponseDelay", 600);
+
+    // Dungeon finder
+    m_int_configs[CONFIG_LFG_OPTIONSMASK] = ConfigMgr::GetIntDefault("DungeonFinder.OptionsMask", 1);
+
+    // DBC_ItemAttributes
+    m_bool_configs[CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES] = ConfigMgr::GetBoolDefault("DBC.EnforceItemAttributes", true);
+
+    // Max instances per hour
+    m_int_configs[CONFIG_MAX_INSTANCES_PER_HOUR] = ConfigMgr::GetIntDefault("AccountInstancesPerHour", 5);
+
+    // AutoBroadcast
+    m_bool_configs[CONFIG_AUTOBROADCAST] = ConfigMgr::GetBoolDefault("AutoBroadcast.On", false);
+    m_int_configs[CONFIG_AUTOBROADCAST_CENTER] = ConfigMgr::GetIntDefault("AutoBroadcast.Center", 0);
+    m_int_configs[CONFIG_AUTOBROADCAST_INTERVAL] = ConfigMgr::GetIntDefault("AutoBroadcast.Timer", 60000);
+    if (reload)
+    {
+        m_timers[WUPDATE_AUTOBROADCAST].SetInterval(m_int_configs[CONFIG_AUTOBROADCAST_INTERVAL]);
+        m_timers[WUPDATE_AUTOBROADCAST].Reset();
+    }
+
+    // MySQL ping time interval
+    m_int_configs[CONFIG_DB_PING_INTERVAL] = ConfigMgr::GetIntDefault("MaxPingTime", 30);
+
+    // Guild save interval
+    m_bool_configs[CONFIG_GUILD_LEVELING_ENABLED] = ConfigMgr::GetBoolDefault("Guild.LevelingEnabled", true);
+    m_int_configs[CONFIG_GUILD_SAVE_INTERVAL] = ConfigMgr::GetIntDefault("Guild.SaveInterval", 15);
+    m_int_configs[CONFIG_GUILD_MAX_LEVEL] = ConfigMgr::GetIntDefault("Guild.MaxLevel", 25);
+    m_int_configs[CONFIG_GUILD_UNDELETABLE_LEVEL] = ConfigMgr::GetIntDefault("Guild.UndeletableLevel", 4);
+    rate_values[RATE_XP_QUEST_GUILD_MODIFIER] = ConfigMgr::GetFloatDefault("Guild.XPQuestModifier", 0.25f);
+    rate_values[RATE_XP_BASEKILL_GUILD_MODIFIER] = ConfigMgr::GetFloatDefault("Guild.XPBaseKillModifier", 4.0f);
+    rate_values[RATE_XP_HEROIC_DUNGEON_GUILD_MODIFIER] = ConfigMgr::GetFloatDefault("Guild.XPHeroicDungeonModifier", 1.25f);
+    rate_values[RATE_XP_HEROIC_RAID_GUILD_MODIFIER] = ConfigMgr::GetFloatDefault("Guild.XPHeroicRaidModifier", 1.0f);
+    rate_values[RATE_XP_HONOR_EARNED_GUILD_MODIFIER] = ConfigMgr::GetFloatDefault("Guild.XPHonorEarnedModifier", 10.0f);
+    m_int_configs[CONFIG_GUILD_XP_REWARD_ARENA] = ConfigMgr::GetIntDefault("Guild.XPRewardInArena", 138800);
+    m_int_configs[CONFIG_GUILD_REPUTATION_QUEST_DIVIDER] = ConfigMgr::GetIntDefault("Guild.ReputationQuestDivider", 450);
+    m_int_configs[CONFIG_GUILD_DAILY_XP_CAP] = ConfigMgr::GetIntDefault("Guild.DailyXPCap", 7807500);
+    m_int_configs[CONFIG_GUILD_WEEKLY_REP_CAP] = ConfigMgr::GetIntDefault("Guild.WeeklyReputationCap", 4375);
+    m_int_configs[CONFIG_GUILD_CHALLENGE_DUNGEON_XP] = ConfigMgr::GetIntDefault("Guild.Challenge.DungeonXP", 300000);
+    m_int_configs[CONFIG_GUILD_CHALLENGE_DUNGEON_GOLD] = ConfigMgr::GetIntDefault("Guild.Challenge.DungeonGold", 125);
+    m_int_configs[CONFIG_GUILD_CHALLENGE_DUNGEON_NEEDED] = ConfigMgr::GetIntDefault("Guild.Challenge.DungeonNedeed", 7);
+    m_int_configs[CONFIG_GUILD_CHALLENGE_RAID_XP] = ConfigMgr::GetIntDefault("Guild.Challenge.RaidXP", 3000000);
+    m_int_configs[CONFIG_GUILD_CHALLENGE_RAID_GOLD] = ConfigMgr::GetIntDefault("Guild.Challenge.RaidGold", 500);
+    m_int_configs[CONFIG_GUILD_CHALLENGE_RAID_NEEDED] = ConfigMgr::GetIntDefault("Guild.Challenge.RaidNedeed", 1);
+    m_int_configs[CONFIG_GUILD_CHALLENGE_RATEDBG_XP] = ConfigMgr::GetIntDefault("Guild.Challenge.RaidXP", 1500000);
+    m_int_configs[CONFIG_GUILD_CHALLENGE_RATEDBG_GOLD] = ConfigMgr::GetIntDefault("Guild.Challenge.RaidGold", 250);
+    m_int_configs[CONFIG_GUILD_CHALLENGE_RATEDBG_NEEDED] = ConfigMgr::GetIntDefault("Guild.Challenge.RaidNedeed", 3);
+
+    // misc
+    m_bool_configs[CONFIG_PDUMP_NO_PATHS] = ConfigMgr::GetBoolDefault("PlayerDump.DisallowPaths", true);
+    m_bool_configs[CONFIG_PDUMP_NO_OVERWRITE] = ConfigMgr::GetBoolDefault("PlayerDump.DisallowOverwrite", true);
+    m_bool_configs[CONFIG_UI_QUESTLEVELS_IN_DIALOGS] = ConfigMgr::GetBoolDefault("UI.ShowQuestLevelsInDialogs", false);
+	
+	m_bool_configs[CONFIG_ANTICHEAT_ENABLE] = ConfigMgr::GetBoolDefault("Anticheat.Enable", true);
+    m_int_configs[CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION] = ConfigMgr::GetIntDefault("Anticheat.ReportsForIngameWarnings", 70);
+    m_int_configs[CONFIG_ANTICHEAT_DETECTIONS_ENABLED] = ConfigMgr::GetIntDefault("Anticheat.DetectionsEnabled",31);
+    m_int_configs[CONFIG_ANTICHEAT_MAX_REPORTS_FOR_DAILY_REPORT] = ConfigMgr::GetIntDefault("Anticheat.MaxReportsForDailyReport",70);
+
+    // call ScriptMgr if we're reloading the configuration
+    m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = ConfigMgr::GetBoolDefault("Wintergrasp.Enable", false);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = ConfigMgr::GetIntDefault("Wintergrasp.PlayerMax", 100);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN] = ConfigMgr::GetIntDefault("Wintergrasp.PlayerMin", 0);
+    m_int_configs[CONFIG_WINTERGRASP_PLR_MIN_LVL] = ConfigMgr::GetIntDefault("Wintergrasp.PlayerMinLvl", 77);
+    m_int_configs[CONFIG_WINTERGRASP_BATTLETIME] = ConfigMgr::GetIntDefault("Wintergrasp.BattleTimer", 30);
+    m_int_configs[CONFIG_WINTERGRASP_NOBATTLETIME] = ConfigMgr::GetIntDefault("Wintergrasp.NoBattleTimer", 150);
+    m_int_configs[CONFIG_WINTERGRASP_RESTART_AFTER_CRASH] = ConfigMgr::GetIntDefault("Wintergrasp.CrashRestartTimer", 10);
+
+    // TOL BARAD
+    m_bool_configs[CONFIG_TOL_BARAD_ENABLE] = ConfigMgr::GetBoolDefault("Tol.Barad.Enable", false);
+    m_int_configs[CONFIG_TOL_BARAD_PLR_MAX] = ConfigMgr::GetIntDefault("Tol.Barad.PlayerMax", 100);
+    m_int_configs[CONFIG_TOL_BARAD_PLR_MIN] = ConfigMgr::GetIntDefault("Tol.Barad.PlayerMin", 0);
+    m_int_configs[CONFIG_TOL_BARAD_PLR_MIN_LVL] = ConfigMgr::GetIntDefault("Tol.Barad.PlayerMinLvl", 80);
+    m_int_configs[CONFIG_TOL_BARAD_BATTLETIME] = ConfigMgr::GetIntDefault("Tol.Barad.BattleTimer", 15);
+    m_int_configs[CONFIG_TOL_BARAD_NOBATTLETIME] = ConfigMgr::GetIntDefault("Tol.Barad.NoBattleTimer", 150);
+
+    ///- ALLOW ZONE AND AREA VALUES CORRECTION AT STARTUP
+    m_bool_configs[CONFIG_ALLOW_ZONE_AND_AREA_VALUES_CORRECTION_AT_STARTUP] = ConfigMgr::GetBoolDefault("AllowZoneAndAreaCheckForCreatureAndGameobject", false);
+
+    // - item guid gestion
+    m_int_configs[CONFIG_DYN_ITEM_GUID_SIZE] = ConfigMgr::GetIntDefault("ItemLoading.stackSize", 0);
+    m_int_configs[CONFIG_DYN_ITEM_SQL_REQUEST_SIZE] = ConfigMgr::GetIntDefault("ItemLoading.requestSize", 2000);
+    if (reload)
+        sScriptMgr->OnConfigLoad(reload);
+}
+
+extern void LoadGameObjectModelList();
+
+/// Initialize the World
+void World::SetInitialWorldSettings()
+{
+    ///- Server startup begin
+    uint32 startupBegin = getMSTime();
+
+    ///- Initialize the random number generator
+    srand((unsigned int)time(NULL));
+
+    ///- Initialize detour memory management
+    dtAllocSetCustom(dtCustomAlloc, dtCustomFree);
+
+    ///- Initialize config settings
+    LoadConfigSettings();
+
+    ///- Initialize Allowed Security Level
+    LoadDBAllowedSecurityLevel();
+
+    ///- Init highest guids before any table loading to prevent using not initialized guids in some code.
+    sObjectMgr->SetHighestGuids();
+
+    ///- Check the existence of the map files for all races' startup areas.
+    if (!MapManager::ExistMapAndVMap(0, -6240.32f, 331.033f)
+        || !MapManager::ExistMapAndVMap(0, -8949.95f, -132.493f)
+        || !MapManager::ExistMapAndVMap(1, -618.518f, -4251.67f)
+        || !MapManager::ExistMapAndVMap(0, 1676.35f, 1677.45f)
+        || !MapManager::ExistMapAndVMap(1, 10311.3f, 832.463f)
+        || !MapManager::ExistMapAndVMap(1, -2917.58f, -257.98f)
+        || (m_int_configs[CONFIG_EXPANSION] && (
+            !MapManager::ExistMapAndVMap(530, 10349.6f, -6357.29f) ||
+            !MapManager::ExistMapAndVMap(530, -3961.64f, -13931.2f))))
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Correct *.map files not found in path '%smaps' or *.vmtree/*.vmtile files in '%svmaps'. Please place *.map/*.vmtree/*.vmtile files in appropriate directories or correct the DataDir value in the worldserver.conf file.", m_dataPath.c_str(), m_dataPath.c_str());
+        exit(1);
+    }
+
+    ///- Initialize pool manager
+    sPoolMgr->Initialize();
+
+    ///- Initialize game event manager
+    sGameEventMgr->Initialize();
+
+    ///- Loading strings. Getting no records means core load has to be canceled because no error message can be output.
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Trinity strings...");
+    if (!sObjectMgr->LoadTrinityStrings())
+        exit(1);                                            // Error message displayed in function already
+
+    ///- Update the realm entry in the database with the realm type from the config file
+    //No SQL injection as values are treated as integers
+
+    // not send custom type REALM_FFA_PVP to realm list
+    uint32 server_type = IsFFAPvPRealm() ? uint32(REALM_TYPE_PVP) : getIntConfig(CONFIG_GAME_TYPE);
+    uint32 realm_zone = getIntConfig(CONFIG_REALM_ZONE);
+
+    LoginDatabase.PExecute("UPDATE realmlist SET icon = %u, timezone = %u WHERE id = '%d'", server_type, realm_zone, realmID);      // One-time query
+
+    ///- Remove the bones (they should not exist in DB though) and old corpses after a restart
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_OLD_CORPSES);
+    stmt->setUInt32(0, 3 * DAY);
+    CharacterDatabase.Execute(stmt);
+
+    ///- Load the DBC files
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Initialize data stores...");
+    LoadDBCStores(m_dataPath);
+    LoadDB2Stores(m_dataPath);
+    DetectDBCLang();
+
+    InitPacketThrottling();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading SpellInfo store...");
+    sSpellMgr->LoadSpellInfoStore();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading SpellInfo corrections...");
+    sSpellMgr->LoadSpellInfoCorrections();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading SkillLineAbilityMultiMap Data...");
+    sSpellMgr->LoadSkillLineAbilityMap();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading spell custom attributes...");
+    sSpellMgr->LoadSpellCustomAttr();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading GameObject models...");
+    LoadGameObjectModelList();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Script Names...");
+    sObjectMgr->LoadScriptNames();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Instance Template...");
+    sObjectMgr->LoadInstanceTemplate();
+
+    // Must be called before `creature_respawn`/`gameobject_respawn` tables
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading instances...");
+    sInstanceSaveMgr->LoadInstances();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Localization strings...");
+    uint32 oldMSTime = getMSTime();
+    sObjectMgr->LoadCreatureLocales();
+    sObjectMgr->LoadGameObjectLocales();
+    sObjectMgr->LoadItemLocales();
+    sObjectMgr->LoadQuestLocales();
+    sObjectMgr->LoadNpcTextLocales();
+    sObjectMgr->LoadPageTextLocales();
+    sObjectMgr->LoadGossipMenuItemsLocales();
+    sObjectMgr->LoadPointOfInterestLocales();
+
+    sObjectMgr->SetDBCLocaleIndex(GetDefaultDbcLocale());        // Get once for all the locale index of DBC language (console/broadcasts)
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">> Localization strings loaded in %u ms", GetMSTimeDiffToNow(oldMSTime));
+
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Page Texts...");
+    sObjectMgr->LoadPageTexts();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Game Object Templates...");         // must be after LoadPageTexts
+    sObjectMgr->LoadGameObjectTemplate();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell Rank Data...");
+    sSpellMgr->LoadSpellRanks();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell Required Data...");
+    sSpellMgr->LoadSpellRequired();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell Group types...");
+    sSpellMgr->LoadSpellGroups();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell Learn Skills...");
+    sSpellMgr->LoadSpellLearnSkills();                           // must be after LoadSpellRanks
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell Learn Spells...");
+    sSpellMgr->LoadSpellLearnSpells();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell Proc Event conditions...");
+    sSpellMgr->LoadSpellProcEvents();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell Proc conditions and data...");
+    sSpellMgr->LoadSpellProcs();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell Bonus Data...");
+    sSpellMgr->LoadSpellBonusess();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Aggro Spells Definitions...");
+    sSpellMgr->LoadSpellThreats();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell Group Stack Rules...");
+    sSpellMgr->LoadSpellGroupStackRules();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell Phase Dbc Info...");
+    sObjectMgr->LoadSpellPhaseInfo();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading NPC Texts...");
+    sObjectMgr->LoadGossipText();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Enchant Spells Proc datas...");
+    sSpellMgr->LoadSpellEnchantProcData();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Item Random Enchantments Table...");
+    LoadRandomEnchantmentsTable();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Disables");                         // must be before loading quests and items
+    DisableMgr::LoadDisables();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Items...");                         // must be after LoadRandomEnchantmentsTable and LoadPageTexts
+    sObjectMgr->LoadItemTemplates();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Item set names...");                // must be after LoadItemPrototypes
+    sObjectMgr->LoadItemTemplateAddon();
+
+    sLog->outInfo(LOG_FILTER_GENERAL, "Loading Item Scripts...");                 // must be after LoadItemPrototypes
+    sObjectMgr->LoadItemScriptNames();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature Model Based Info Data...");
+    sObjectMgr->LoadCreatureModelInfo();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature templates...");
+    sObjectMgr->LoadCreatureTemplates();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Equipment templates...");           // must be after LoadCreatureTemplates
+    sObjectMgr->LoadEquipmentTemplates();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature template addons...");
+    sObjectMgr->LoadCreatureTemplateAddons();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Reputation Reward Rates...");
+    sObjectMgr->LoadReputationRewardRate();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature Reward OnKill Data...");
+    sObjectMgr->LoadRewardOnKill();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Reputation Spillover Data...");
+    sObjectMgr->LoadReputationSpilloverTemplate();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Points Of Interest Data...");
+    sObjectMgr->LoadPointsOfInterest();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature Base Stats...");
+    sObjectMgr->LoadCreatureClassLevelStats();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature Data...");
+    sObjectMgr->LoadCreatures();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading pet levelup spells...");
+    sSpellMgr->LoadPetLevelupSpellMap();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading pet default spells additional to levelup spells...");
+    sSpellMgr->LoadPetDefaultSpells();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature Addon Data...");
+    sObjectMgr->LoadCreatureAddons();                            // must be after LoadCreatureTemplates() and LoadCreatures()
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Gameobject Data...");
+    sObjectMgr->LoadGameobjects();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature Linked Respawn...");
+    sObjectMgr->LoadLinkedRespawn();                             // must be after LoadCreatures(), LoadGameObjects()
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Weather Data...");
+    WeatherMgr::LoadWeatherData();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Quests...");
+    sObjectMgr->LoadQuests();                                    // must be loaded after DBCs, creature_template, item_template, gameobject tables
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Checking Quest Disables");
+    DisableMgr::CheckQuestDisables();                           // must be after loading quests
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Quest POI");
+    sObjectMgr->LoadQuestPOI();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Quests Relations...");
+    sObjectMgr->LoadQuestRelations();                            // must be after quest load
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Objects Pooling Data...");
+    sPoolMgr->LoadFromDB();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Game Event Data...");               // must be after loading pools fully
+    sGameEventMgr->LoadFromDB();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading UNIT_NPC_FLAG_SPELLCLICK Data..."); // must be after LoadQuests
+    sObjectMgr->LoadNPCSpellClickSpells();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Vehicle Template Accessories...");
+    sObjectMgr->LoadVehicleTemplateAccessories();                // must be after LoadCreatureTemplates() and LoadNPCSpellClickSpells()
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Vehicle Accessories...");
+    sObjectMgr->LoadVehicleAccessories();                       // must be after LoadCreatureTemplates() and LoadNPCSpellClickSpells()
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading SpellArea Data...");                // must be after quest load
+    sSpellMgr->LoadSpellAreas();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading AreaTrigger definitions...");
+    sObjectMgr->LoadAreaTriggerTeleports();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Access Requirements...");
+    sObjectMgr->LoadAccessRequirements();                        // must be after item template load
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Quest Area Triggers...");
+    sObjectMgr->LoadQuestAreaTriggers();                         // must be after LoadQuests
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Tavern Area Triggers...");
+    sObjectMgr->LoadTavernAreaTriggers();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading AreaTrigger script names...");
+    sObjectMgr->LoadAreaTriggerScripts();
+
+	sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading LFG entrance positions...");
+    sLFGMgr->LoadLFGDungeons();
+	
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Dungeon boss data...");
+    sObjectMgr->LoadInstanceEncounters();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading LFG rewards...");
+    sLFGMgr->LoadRewards();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Graveyard-zone links...");
+    sObjectMgr->LoadGraveyardZones();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading spell pet auras...");
+    sSpellMgr->LoadSpellPetAuras();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Spell target coordinates...");
+    sSpellMgr->LoadSpellTargetPositions();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading enchant custom attributes...");
+    sSpellMgr->LoadEnchantCustomAttr();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading linked spells...");
+    sSpellMgr->LoadSpellLinked();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Player Create Data...");
+    sObjectMgr->LoadPlayerInfo();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Exploration BaseXP Data...");
+    sObjectMgr->LoadExplorationBaseXP();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Pet Name Parts...");
+    sObjectMgr->LoadPetNames();
+
+    CharacterDatabaseCleaner::CleanDatabase();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading the max pet number...");
+    sObjectMgr->LoadPetNumber();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading pet level stats...");
+    sObjectMgr->LoadPetLevelInfo();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Player Corpses...");
+    sObjectMgr->LoadCorpses();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Player level dependent mail rewards...");
+    sObjectMgr->LoadMailLevelRewards();
+
+    // Loot tables
+    LoadLootTables();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Skill Discovery Table...");
+    LoadSkillDiscoveryTable();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Skill Extra Item Table...");
+    LoadSkillExtraItemTable();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Skill Fishing base level requirements...");
+    sObjectMgr->LoadFishingBaseSkillLevel();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Research Dig Sites info...");
+    sObjectMgr->LoadResearchSitesInfo();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Achievements...");
+    sAchievementMgr->LoadAchievementReferenceList();
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Achievement Criteria Lists...");
+    sAchievementMgr->LoadAchievementCriteriaList();
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Achievement Criteria Data...");
+    sAchievementMgr->LoadAchievementCriteriaData();
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Achievement Rewards...");
+    sAchievementMgr->LoadRewards();
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Achievement Reward Locales...");
+    sAchievementMgr->LoadRewardLocales();
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Completed Achievements...");
+    sAchievementMgr->LoadCompletedAchievements();
+
+    // Delete expired auctions before loading
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Deleting expired auctions...");
+    sAuctionMgr->DeleteExpiredAuctionsAtStartup();
+
+    ///- Load dynamic data tables from the database
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Item Auctions...");
+    sAuctionMgr->LoadAuctionItems();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Auctions...");
+    sAuctionMgr->LoadAuctions();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Guild XP for level...");
+    sGuildMgr->LoadGuildXpForLevel();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Guild rewards...");
+    sGuildMgr->LoadGuildRewards();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Guilds...");
+    sGuildMgr->LoadGuilds();
+
+    sGuildFinderMgr->LoadFromDB();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading ArenaTeams...");
+    sArenaTeamMgr->LoadArenaTeams();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Groups...");
+    sGroupMgr->LoadGroups();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading ReservedNames...");
+    sObjectMgr->LoadReservedPlayersNames();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading GameObjects for quests...");
+    sObjectMgr->LoadGameObjectForQuests();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading BattleMasters...");
+    sBattlegroundMgr->LoadBattleMastersEntry();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading GameTeleports...");
+    sObjectMgr->LoadGameTele();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Gossip menu...");
+    sObjectMgr->LoadGossipMenu();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Gossip menu options...");
+    sObjectMgr->LoadGossipMenuItems();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Vendors...");
+    sObjectMgr->LoadVendors();                                   // must be after load CreatureTemplate and ItemTemplate
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Trainers...");
+    sObjectMgr->LoadTrainerSpell();                              // must be after load CreatureTemplate
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Waypoints...");
+    sWaypointMgr->Load();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading SmartAI Waypoints...");
+    sSmartWaypointMgr->LoadFromDB();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature Formations...");
+    sFormationMgr->LoadCreatureFormations();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading World States...");              // must be loaded before battleground, outdoor PvP and conditions
+    LoadWorldStates();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Phase definitions...");
+    sObjectMgr->LoadPhaseDefinitions();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Conditions...");
+    sConditionMgr->LoadConditions();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading faction change achievement pairs...");
+    sObjectMgr->LoadFactionChangeAchievements();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading faction change spell pairs...");
+    sObjectMgr->LoadFactionChangeSpells();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading faction change item pairs...");
+    sObjectMgr->LoadFactionChangeItems();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading faction change reputation pairs...");
+    sObjectMgr->LoadFactionChangeReputations();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading faction change title pairs...");
+    sObjectMgr->LoadFactionChangeTitles();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading GM tickets...");
+    sTicketMgr->LoadTickets();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading GM surveys...");
+    sTicketMgr->LoadSurveys();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading client addons...");
+    AddonMgr::LoadFromDB();
+
+    ///- Handle outdated emails (delete/return)
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Returning old mails...");
+    sObjectMgr->ReturnOrDeleteOldMails(false);
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Autobroadcasts...");
+    LoadAutobroadcasts();
+
+    ///- Load and initialize scripts
+    sObjectMgr->LoadSpellScripts();                              // must be after load Creature/Gameobject(Template/Data)
+    sObjectMgr->LoadEventScripts();                              // must be after load Creature/Gameobject(Template/Data)
+    sObjectMgr->LoadWaypointScripts();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Scripts text locales...");      // must be after Load*Scripts calls
+    sObjectMgr->LoadDbScriptStrings();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading spell script names...");
+    sObjectMgr->LoadSpellScriptNames();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature Texts...");
+    sCreatureTextMgr->LoadCreatureTexts();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Creature Text Locales...");
+    sCreatureTextMgr->LoadCreatureTextLocales();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Initializing Scripts...");
+    sScriptMgr->Initialize();
+    sScriptMgr->OnConfigLoad(false);                                // must be done after the ScriptMgr has been properly initialized
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Validating spell scripts...");
+    sObjectMgr->ValidateSpellScripts();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading SmartAI scripts...");
+    sSmartScriptMgr->LoadSmartAIFromDB();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Calendar data...");
+    sCalendarMgr->LoadFromDB();
+
+    ///- Initialize game time and timers
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Initialize game time and timers");
+    m_gameTime = time(NULL);
+    m_startTime = m_gameTime;
+
+    LoginDatabase.PExecute("INSERT INTO uptime (realmid, starttime, uptime, revision) VALUES(%u, %u, 0, '%s')",
+                            realmID, uint32(m_startTime), _FULLVERSION);       // One-time query
+
+    m_timers[WUPDATE_WEATHERS].SetInterval(1*IN_MILLISECONDS);
+    m_timers[WUPDATE_AUCTIONS].SetInterval(MINUTE*IN_MILLISECONDS);
+    m_timers[WUPDATE_UPTIME].SetInterval(m_int_configs[CONFIG_UPTIME_UPDATE]*MINUTE*IN_MILLISECONDS);
+                                                            //Update "uptime" table based on configuration entry in minutes.
+    m_timers[WUPDATE_CORPSES].SetInterval(20 * MINUTE * IN_MILLISECONDS);
+                                                            //erase corpses every 20 minutes
+    m_timers[WUPDATE_CLEANDB].SetInterval(m_int_configs[CONFIG_LOGDB_CLEARINTERVAL]*MINUTE*IN_MILLISECONDS);
+                                                            // clean logs table every 14 days by default
+    m_timers[WUPDATE_AUTOBROADCAST].SetInterval(getIntConfig(CONFIG_AUTOBROADCAST_INTERVAL));
+    m_timers[WUPDATE_DELETECHARS].SetInterval(DAY*IN_MILLISECONDS); // check for chars to delete every day
+
+    m_timers[WUPDATE_PINGDB].SetInterval(getIntConfig(CONFIG_DB_PING_INTERVAL)*MINUTE*IN_MILLISECONDS);    // Mysql ping time in minutes
+
+    m_timers[WUPDATE_GUILDSAVE].SetInterval(getIntConfig(CONFIG_GUILD_SAVE_INTERVAL) * MINUTE * IN_MILLISECONDS);
+
+    //HP Gold Refresh
+    m_timers[WUPDATE_HPGOLD].SetInterval(getIntConfig(CONFIG_HPGOLD_REFRESH_INTERVAL) * IN_MILLISECONDS);
+
+    //Cronjobs
+    m_timers[WUPDATE_CRONJOBS].SetInterval(getIntConfig(CONFIG_CRONJOBS_INTERVAL) * IN_MILLISECONDS);
+
+    //to set mailtimer to return mails every day between 4 and 5 am
+    //mailtimer is increased when updating auctions
+    //one second is 1000 -(tested on win system)
+    //TODO: Get rid of magic numbers
+    mail_timer = ((((localtime(&m_gameTime)->tm_hour + 20) % 24)* HOUR * IN_MILLISECONDS) / m_timers[WUPDATE_AUCTIONS].GetInterval());
+                                                            //1440
+    mail_timer_expires = ((DAY * IN_MILLISECONDS) / (m_timers[WUPDATE_AUCTIONS].GetInterval()));
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Mail timer set to: " UI64FMTD ", mail return is called every " UI64FMTD " minutes", uint64(mail_timer), uint64(mail_timer_expires));
+
+    ///- Initilize static helper structures
+    AIRegistry::Initialize();
+
+    ///- Initialize MapManager
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Starting Map System");
+    sMapMgr->Initialize();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Starting Game Event system...");
+    uint32 nextGameEvent = sGameEventMgr->StartSystem();
+    m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);    //depend on next event
+
+    // Delete all characters which have been deleted X days before
+    Player::DeleteOldCharacters();
+
+    // Delete all custom channels which haven't been used for PreserveCustomChannelDuration days.
+    Channel::CleanOldChannelsInDB();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Starting Arena Season...");
+    sGameEventMgr->StartArenaSeason();
+
+    sTicketMgr->Initialize();
+
+    ///- Initialize Battlegrounds
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Starting Battleground System");
+    sBattlegroundMgr->CreateInitialBattlegrounds();
+
+    ///- Initialize outdoor pvp
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Starting Outdoor PvP System");
+    sOutdoorPvPMgr->InitOutdoorPvP();
+
+    ///- Initialize Battlefield
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Starting Battlefield System");
+    sBattlefieldMgr->InitBattlefield();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Transports...");
+    sMapMgr->LoadTransports();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Transport NPCs...");
+    sMapMgr->LoadTransportNPCs();
+
+    ///- Initialize Warden
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Warden Checks...");
+    sWardenCheckMgr->LoadWardenChecks();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading Warden Action Overrides...");
+    sWardenCheckMgr->LoadWardenOverrides();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Deleting expired bans...");
+    LoginDatabase.Execute("DELETE FROM ip_banned WHERE unbandate <= UNIX_TIMESTAMP() AND unbandate<>bandate");      // One-time query
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Calculate next daily quest reset time...");
+    InitDailyQuestResetTime();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Calculate next weekly quest reset time...");
+    InitWeeklyQuestResetTime();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Calculate next monthly quest reset time...");
+    InitMonthlyQuestResetTime();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Calculate random battleground reset time...");
+    InitRandomBGResetTime();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Calculate Guild cap reset time...");
+    InitGuildResetTime();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Calculate next currency reset time...");
+    InitCurrencyResetTime();
+
+    sLog->outInfo(LOG_FILTER_GENERAL, "Initializing Opcodes...");
+    opcodeTable.Initialize();
+
+    sLog->outInfo(LOG_FILTER_GENERAL, "Initializing Performance logger...");
+    sPerfLog->Initialize();
+
+    sLog->outInfo(LOG_FILTER_GENERAL, "Loading hotfix info...");
+    sObjectMgr->LoadHotfixData();
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading missing KeyChains...");
+    sObjectMgr->LoadMissingKeyChains();
+
+    sInfoMgr->Initialize();
+
+    uint32 startupDuration = GetMSTimeDiffToNow(startupBegin);
+
+    sLog->outInfo(LOG_FILTER_WORLDSERVER, "World initialized in %u minutes %u seconds", (startupDuration / 60000), ((startupDuration % 60000) / 1000));
+
+    if (uint32 realmId = ConfigMgr::GetIntDefault("RealmID", 0)) // 0 reserved for auth
+        sLog->SetRealmId(realmId);
+}
+
+void World::DetectDBCLang()
+{
+    uint8 m_lang_confid = ConfigMgr::GetIntDefault("DBC.Locale", 0);
+
+    if (m_lang_confid >= TOTAL_LOCALES)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Incorrect DBC.Locale! Must be >= 0 and < %d (set to 0)", TOTAL_LOCALES);
+        m_lang_confid = LOCALE_enUS;
+    }
+
+    /*ChrRacesEntry const* race = sChrRacesStore.LookupEntry(1);
+
+    std::string availableLocalsStr;
+
+    uint8 default_locale = TOTAL_LOCALES;
+    for (uint8 i = default_locale-1; i < TOTAL_LOCALES; --i)  // -1 will be 255 due to uint8
+    {
+        if (race->name[i][0] != '\0')                     // check by race names
+        {
+            default_locale = i;
+            m_availableDbcLocaleMask |= (1 << i);
+            availableLocalsStr += localeNames[i];
+            availableLocalsStr += " ";
+        }
+    }
+
+    if (default_locale != m_lang_confid && m_lang_confid < TOTAL_LOCALES &&
+        (m_availableDbcLocaleMask & (1 << m_lang_confid)))
+    {
+        default_locale = m_lang_confid;
+    }
+
+    if (default_locale >= TOTAL_LOCALES)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Unable to determine your DBC Locale! (corrupt DBC?)");
+        exit(1);
+    }*/
+
+    m_defaultDbcLocale = LocaleConstant(m_lang_confid);
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Using %s DBC Locale", localeNames[m_defaultDbcLocale]);
+}
+
+void World::RecordTimeDiff(const char *text, ...)
+{
+    if (m_updateTimeCount != 1)
+        return;
+    if (!text)
+    {
+        m_currentTime = getMSTime();
+        return;
+    }
+
+    uint32 thisTime = getMSTime();
+    uint32 diff = getMSTimeDiff(m_currentTime, thisTime);
+
+    if (diff > m_int_configs[CONFIG_MIN_LOG_UPDATE])
+    {
+        va_list ap;
+        char str[256];
+        va_start(ap, text);
+        vsnprintf(str, 256, text, ap);
+        va_end(ap);
+        sLog->outInfo(LOG_FILTER_GENERAL, "Difftime %s: %u.", str, diff);
+    }
+
+    m_currentTime = thisTime;
+}
+
+void World::LoadAutobroadcasts()
+{
+    uint32 oldMSTime = getMSTime();
+
+    m_Autobroadcasts.clear();
+
+    QueryResult result = WorldDatabase.Query("SELECT text FROM autobroadcast");
+
+    if (!result)
+    {
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">> Loaded 0 autobroadcasts definitions. DB table `autobroadcast` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+        std::string message = fields[0].GetString();
+
+        m_Autobroadcasts.push_back(message);
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">> Loaded %u autobroadcast definitions in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
+/// Update the World !
+void World::Update(uint32 diff)
+{
+    m_updateTime = diff;
+
+    if (m_int_configs[CONFIG_INTERVAL_LOG_UPDATE] && diff > m_int_configs[CONFIG_MIN_LOG_UPDATE])
+    {
+        if (m_updateTimeSum > m_int_configs[CONFIG_INTERVAL_LOG_UPDATE])
+        {
+            sLog->outDebug(LOG_FILTER_GENERAL, "Update time diff: %u. Players online: %u.", m_updateTimeSum / m_updateTimeCount, GetActiveSessionCount());
+            m_updateTimeSum = m_updateTime;
+            m_updateTimeCount = 1;
+        }
+        else
+        {
+            m_updateTimeSum += m_updateTime;
+            ++m_updateTimeCount;
+        }
+    }
+
+    ///- Update the different timers
+    for (int i = 0; i < WUPDATE_COUNT; ++i)
+    {
+        if (m_timers[i].GetCurrent() >= 0)
+            m_timers[i].Update(diff);
+        else
+            m_timers[i].SetCurrent(0);
+    }
+
+    ///- Update the game time and check for shutdown time
+    _UpdateGameTime();
+
+    /// Handle daily quests reset time
+    if (m_gameTime > m_NextDailyQuestReset)
+    {
+        ResetDailyQuests();
+        m_NextDailyQuestReset += DAY;
+    }
+
+    /// Handle weekly quests reset time
+    if (m_gameTime > m_NextWeeklyQuestReset)
+        ResetWeeklyQuests();
+
+    /// Handle monthly quests reset time
+    if (m_gameTime > m_NextMonthlyQuestReset)
+        ResetMonthlyQuests();
+
+    if (m_gameTime > m_NextRandomBGReset)
+        ResetRandomBG();
+
+    if (m_gameTime > m_NextGuildReset)
+        ResetGuildCap();
+
+	if (m_gameTime > m_NextCurrencyReset)
+	ResetCurrencyWeekCap();
+
+    /// <ul><li> Handle auctions when the timer has passed
+    if (m_timers[WUPDATE_AUCTIONS].Passed())
+    {
+        m_timers[WUPDATE_AUCTIONS].Reset();
+
+        ///- Update mails (return old mails with item, or delete them)
+        //(tested... works on win)
+        if (++mail_timer > mail_timer_expires)
+        {
+            mail_timer = 0;
+            sObjectMgr->ReturnOrDeleteOldMails(true);
+        }
+
+        ///- Handle expired auctions
+        sAuctionMgr->Update();
+    }
+
+    /// <li> Handle session updates when the timer has passed
+    RecordTimeDiff(NULL);
+    UpdateSessions(diff);
+    RecordTimeDiff("UpdateSessions");
+
+    /// <li> Handle weather updates when the timer has passed
+    if (m_timers[WUPDATE_WEATHERS].Passed())
+    {
+        m_timers[WUPDATE_WEATHERS].Reset();
+        WeatherMgr::Update(uint32(m_timers[WUPDATE_WEATHERS].GetInterval()));
+    }
+
+    if (sWorld->getBoolConfig(CONFIG_CRONJOBS_ENABLED))
+    {
+        if (m_timers[WUPDATE_CRONJOBS].Passed())
+        {
+            m_timers[WUPDATE_CRONJOBS].Reset();
+            ExecuteCronjobs();
+        }
+    }
+
+    /// <li> Update uptime table
+    if (m_timers[WUPDATE_UPTIME].Passed())
+    {
+        uint32 tmpDiff = uint32(m_gameTime - m_startTime);
+        uint32 maxOnlinePlayers = GetMaxPlayerCount();
+
+        m_timers[WUPDATE_UPTIME].Reset();
+
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_UPTIME_PLAYERS);
+
+        stmt->setUInt32(0, tmpDiff);
+        stmt->setUInt16(1, uint16(maxOnlinePlayers));
+        stmt->setUInt32(2, realmID);
+        stmt->setUInt32(3, uint32(m_startTime));
+
+        LoginDatabase.Execute(stmt);
+    }
+
+    /// <li> Clean logs table
+    if (sWorld->getIntConfig(CONFIG_LOGDB_CLEARTIME) > 0) // if not enabled, ignore the timer
+    {
+        if (m_timers[WUPDATE_CLEANDB].Passed())
+        {
+            m_timers[WUPDATE_CLEANDB].Reset();
+
+            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_OLD_LOGS);
+
+            stmt->setUInt32(0, sWorld->getIntConfig(CONFIG_LOGDB_CLEARTIME));
+            stmt->setUInt32(1, uint32(time(0)));
+
+            LoginDatabase.Execute(stmt);
+        }
+    }
+
+    /// <li> Handle all other objects
+    ///- Update objects when the timer has passed (maps, transport, creatures, ...)
+    RecordTimeDiff(NULL);
+    sMapMgr->Update(diff);
+    RecordTimeDiff("UpdateMapMgr");
+
+    if (sWorld->getBoolConfig(CONFIG_AUTOBROADCAST))
+    {
+        if (m_timers[WUPDATE_AUTOBROADCAST].Passed())
+        {
+            m_timers[WUPDATE_AUTOBROADCAST].Reset();
+            SendAutoBroadcast();
+        }
+    }
+
+    sBattlegroundMgr->Update(diff);
+    RecordTimeDiff("UpdateBattlegroundMgr");
+
+    sOutdoorPvPMgr->Update(diff);
+    RecordTimeDiff("UpdateOutdoorPvPMgr");
+
+    sBattlefieldMgr->Update(diff);
+    RecordTimeDiff("BattlefieldMgr");
+
+    ///- Delete all characters which have been deleted X days before
+    if (m_timers[WUPDATE_DELETECHARS].Passed())
+    {
+        m_timers[WUPDATE_DELETECHARS].Reset();
+        Player::DeleteOldCharacters();
+    }
+
+    sLFGMgr->Update(diff);
+    RecordTimeDiff("UpdateLFGMgr");
+
+    // execute callbacks from sql queries that were queued recently
+    ProcessQueryCallbacks();
+    RecordTimeDiff("ProcessQueryCallbacks");
+
+    ///- Erase corpses once every 20 minutes
+    if (m_timers[WUPDATE_CORPSES].Passed())
+    {
+        m_timers[WUPDATE_CORPSES].Reset();
+        sObjectAccessor->RemoveOldCorpses();
+    }
+
+    ///- Process Game events when necessary
+    if (m_timers[WUPDATE_EVENTS].Passed())
+    {
+        m_timers[WUPDATE_EVENTS].Reset();                   // to give time for Update() to be processed
+        uint32 nextGameEvent = sGameEventMgr->Update();
+        m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);
+        m_timers[WUPDATE_EVENTS].Reset();
+    }
+
+    ///- Ping to keep MySQL connections alive
+    if (m_timers[WUPDATE_PINGDB].Passed())
+    {
+        m_timers[WUPDATE_PINGDB].Reset();
+        sLog->outDebug(LOG_FILTER_GENERAL, "Ping MySQL to keep connection alive");
+        CharacterDatabase.KeepAlive();
+        LoginDatabase.KeepAlive();
+        WorldDatabase.KeepAlive();
+    }
+
+    if (m_timers[WUPDATE_GUILDSAVE].Passed())
+    {
+        m_timers[WUPDATE_GUILDSAVE].Reset();
+        sGuildMgr->SaveGuilds();
+    }
+
+    // update the instance reset times
+    sInstanceSaveMgr->Update();
+
+    // And last, but not least handle the issued cli commands
+    ProcessCliCommands();
+
+    sScriptMgr->OnWorldUpdate(diff);
+
+    sPerfLog->Update(diff);
+}
+
+void World::ForceGameEventUpdate()
+{
+    m_timers[WUPDATE_EVENTS].Reset();                   // to give time for Update() to be processed
+    uint32 nextGameEvent = sGameEventMgr->Update();
+    m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);
+    m_timers[WUPDATE_EVENTS].Reset();
+}
+
+/// Send a packet to all players (except self if mentioned)
+void World::SendGlobalMessage(WorldPacket* packet, WorldSession* self, uint32 team)
+{
+    SessionMap::const_iterator itr;
+    for (itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (itr->second &&
+            itr->second->GetPlayer() &&
+            itr->second->GetPlayer()->IsInWorld() &&
+            itr->second != self &&
+            (team == 0 || itr->second->GetPlayer()->GetTeam() == team))
+        {
+            itr->second->SendPacket(packet);
+        }
+    }
+}
+
+/// Send a packet to all GMs (except self if mentioned)
+void World::SendGlobalGMMessage(WorldPacket* packet, WorldSession* self, uint32 team)
+{
+    SessionMap::iterator itr;
+    for (itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (itr->second &&
+            itr->second->GetPlayer() &&
+            itr->second->GetPlayer()->IsInWorld() &&
+            itr->second != self &&
+            !AccountMgr::IsPlayerAccount(itr->second->GetSecurity()) &&
+            (team == 0 || itr->second->GetPlayer()->GetTeam() == team))
+        {
+            itr->second->SendPacket(packet);
+        }
+    }
+}
+
+namespace Trinity
+{
+    class WorldWorldTextBuilder
+    {
+        public:
+            typedef std::vector<WorldPacket*> WorldPacketList;
+            explicit WorldWorldTextBuilder(int32 textId, va_list* args = NULL) : i_textId(textId), i_args(args) {}
+            void operator()(WorldPacketList& data_list, LocaleConstant loc_idx)
+            {
+                char const* text = sObjectMgr->GetTrinityString(i_textId, loc_idx);
+
+                if (i_args)
+                {
+                    // we need copy va_list before use or original va_list will corrupted
+                    va_list ap;
+                    va_copy(ap, *i_args);
+
+                    char str[2048];
+                    vsnprintf(str, 2048, text, ap);
+                    va_end(ap);
+
+                    do_helper(data_list, &str[0]);
+                }
+                else
+                    do_helper(data_list, (char*)text);
+            }
+        private:
+            char* lineFromMessage(char*& pos) { char* start = strtok(pos, "\n"); pos = NULL; return start; }
+            void do_helper(WorldPacketList& data_list, char* text)
+            {
+                char* pos = text;
+
+                while (char* line = lineFromMessage(pos))
+                {
+                    WorldPacket* data = new WorldPacket();
+
+                    uint32 lineLength = (line ? strlen(line) : 0) + 1;
+
+                    data->Initialize(SMSG_MESSAGECHAT, 100);                // guess size
+                    *data << uint8(CHAT_MSG_SYSTEM);
+                    *data << uint32(LANG_UNIVERSAL);
+                    *data << uint64(0);
+                    *data << uint32(0);                                     // can be chat msg group or something
+                    *data << uint64(0);
+                    *data << uint32(lineLength);
+                    *data << line;
+                    *data << uint8(0);
+
+                    data_list.push_back(data);
+                }
+            }
+
+            int32 i_textId;
+            va_list* i_args;
+    };
+}                                                           // namespace Trinity
+
+/// Send a System Message to all players (except self if mentioned)
+void World::SendWorldText(int32 string_id, ...)
+{
+    va_list ap;
+    va_start(ap, string_id);
+
+    Trinity::WorldWorldTextBuilder wt_builder(string_id, &ap);
+    Trinity::LocalizedPacketListDo<Trinity::WorldWorldTextBuilder> wt_do(wt_builder);
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld())
+            continue;
+
+        wt_do(itr->second->GetPlayer());
+    }
+
+    va_end(ap);
+}
+
+/// Send a System Message to all GMs (except self if mentioned)
+void World::SendGMText(int32 string_id, ...)
+{
+    va_list ap;
+    va_start(ap, string_id);
+
+    Trinity::WorldWorldTextBuilder wt_builder(string_id, &ap);
+    Trinity::LocalizedPacketListDo<Trinity::WorldWorldTextBuilder> wt_do(wt_builder);
+    for (SessionMap::iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld())
+            continue;
+
+        if (AccountMgr::IsPlayerAccount(itr->second->GetSecurity()))
+            continue;
+
+        wt_do(itr->second->GetPlayer());
+    }
+
+    va_end(ap);
+}
+
+/// DEPRECATED, only for debug purpose. Send a System Message to all players (except self if mentioned)
+void World::SendGlobalText(const char* text, WorldSession* self)
+{
+    WorldPacket data;
+
+    // need copy to prevent corruption by strtok call in LineFromMessage original string
+    char* buf = strdup(text);
+    char* pos = buf;
+
+    while (char* line = ChatHandler::LineFromMessage(pos))
+    {
+        ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, 0, line, NULL);
+        SendGlobalMessage(&data, self);
+    }
+
+    free(buf);
+}
+
+/// Send a packet to all players (or players selected team) in the zone (except self if mentioned)
+void World::SendZoneMessage(uint32 zone, WorldPacket* packet, WorldSession* self, uint32 team)
+{
+    SessionMap::const_iterator itr;
+    for (itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (itr->second &&
+            itr->second->GetPlayer() &&
+            itr->second->GetPlayer()->IsInWorld() &&
+            itr->second->GetPlayer()->GetZoneId() == zone &&
+            itr->second != self &&
+            (team == 0 || itr->second->GetPlayer()->GetTeam() == team))
+        {
+            itr->second->SendPacket(packet);
+        }
+    }
+}
+
+/// Send a System Message to all players in the zone (except self if mentioned)
+void World::SendZoneText(uint32 zone, const char* text, WorldSession* self, uint32 team)
+{
+    WorldPacket data;
+    ChatHandler::FillMessageData(&data, NULL, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, 0, text, NULL);
+    SendZoneMessage(zone, &data, self, team);
+}
+
+/// Kick (and save) all players
+void World::KickAll()
+{
+    m_QueuedPlayer.clear();                                 // prevent send queue update packet and login queued sessions
+
+    // session not removed at kick and will removed in next update tick
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        itr->second->KickPlayer("World::KickAll");
+}
+
+/// Kick (and save) all players with security level less `sec`
+void World::KickAllLess(AccountTypes sec)
+{
+    // session not removed at kick and will removed in next update tick
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetSecurity() < sec)
+            itr->second->KickPlayer("World::KickAllLess");
+}
+
+/// Ban an account or ban an IP address, duration will be parsed using TimeStringToSecs if it is positive, otherwise permban
+BanReturn World::BanAccount(BanMode mode, std::string const& nameOrIP, std::string const& duration, std::string const& reason, std::string const& author)
+{
+    uint32 duration_secs = TimeStringToSecs(duration);
+    PreparedQueryResult resultAccounts = PreparedQueryResult(NULL); //used for kicking
+    PreparedStatement* stmt = NULL;
+
+    ///- Update the database with ban information
+    switch (mode)
+    {
+        case BAN_IP:
+            // No SQL injection with prepared statements
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_BY_IP);
+            stmt->setString(0, nameOrIP);
+            resultAccounts = LoginDatabase.Query(stmt);
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_IP_BANNED);
+            stmt->setString(0, nameOrIP);
+            stmt->setUInt32(1, duration_secs);
+            stmt->setString(2, author);
+            stmt->setString(3, reason);
+            LoginDatabase.Execute(stmt);
+            break;
+        case BAN_ACCOUNT:
+            // No SQL injection with prepared statements
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_ID_BY_NAME);
+            stmt->setString(0, nameOrIP);
+            resultAccounts = LoginDatabase.Query(stmt);
+            break;
+        case BAN_CHARACTER:
+            // No SQL injection with prepared statements
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ACCOUNT_BY_NAME);
+            stmt->setString(0, nameOrIP);
+            resultAccounts = CharacterDatabase.Query(stmt);
+            break;
+        default:
+            return BAN_SYNTAX_ERROR;
+    }
+
+    if (!resultAccounts)
+    {
+        if (mode == BAN_IP)
+            return BAN_SUCCESS;                             // ip correctly banned but nobody affected (yet)
+        else
+            return BAN_NOTFOUND;                            // Nobody to ban
+    }
+
+    ///- Disconnect all affected players (for IP it can be several)
+    SQLTransaction trans = LoginDatabase.BeginTransaction();
+    do
+    {
+        Field* fieldsAccount = resultAccounts->Fetch();
+        uint32 account = fieldsAccount[0].GetUInt32();
+
+        if (mode != BAN_IP)
+        {
+            // make sure there is only one active ban
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_ACCOUNT_NOT_BANNED);
+            stmt->setUInt32(0, account);
+            trans->Append(stmt);
+            // No SQL injection with prepared statements
+            stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_ACCOUNT_BANNED);
+            stmt->setUInt32(0, account);
+            stmt->setUInt32(1, duration_secs);
+            stmt->setString(2, author);
+            stmt->setString(3, reason);
+            trans->Append(stmt);
+        }
+
+        if (WorldSession* sess = FindSession(account))
+            if (std::string(sess->GetPlayerName()) != author)
+                sess->KickPlayer("World::BanAccount");
+    } while (resultAccounts->NextRow());
+
+    LoginDatabase.CommitTransaction(trans);
+
+    return BAN_SUCCESS;
+}
+
+/// Remove a ban from an account or IP address
+bool World::RemoveBanAccount(BanMode mode, std::string const& nameOrIP)
+{
+    PreparedStatement* stmt = NULL;
+    if (mode == BAN_IP)
+    {
+        stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_IP_NOT_BANNED);
+        stmt->setString(0, nameOrIP);
+        LoginDatabase.Execute(stmt);
+    }
+    else
+    {
+        uint32 account = 0;
+        if (mode == BAN_ACCOUNT)
+            account = AccountMgr::GetId(nameOrIP);
+        else if (mode == BAN_CHARACTER)
+            account = sObjectMgr->GetPlayerAccountIdByPlayerName(nameOrIP);
+
+        if (!account)
+            return false;
+
+        //NO SQL injection as account is uint32
+        stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_ACCOUNT_NOT_BANNED);
+        stmt->setUInt32(0, account);
+        LoginDatabase.Execute(stmt);
+    }
+    return true;
+}
+
+/// Ban an account or ban an IP address, duration will be parsed using TimeStringToSecs if it is positive, otherwise permban
+BanReturn World::BanCharacter(std::string const& name, std::string const& duration, std::string const& reason, std::string const& author)
+{
+    Player* pBanned = sObjectAccessor->FindPlayerByName(name);
+    uint32 guid = 0;
+
+    uint32 duration_secs = TimeStringToSecs(duration);
+
+    /// Pick a player to ban if not online
+    if (!pBanned)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUID_BY_NAME);
+        stmt->setString(0, name);
+        PreparedQueryResult resultCharacter = CharacterDatabase.Query(stmt);
+
+        if (!resultCharacter)
+            return BAN_NOTFOUND;                                    // Nobody to ban
+
+        guid = (*resultCharacter)[0].GetUInt32();
+    }
+    else
+        guid = pBanned->GetGUIDLow();
+
+    // make sure there is only one active ban
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER_BAN);
+    stmt->setUInt32(0, guid);
+    CharacterDatabase.Execute(stmt);
+
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_BAN);
+    stmt->setUInt32(0, guid);
+    stmt->setUInt32(1, duration_secs);
+    stmt->setString(2, author);
+    stmt->setString(3, reason);
+    CharacterDatabase.Execute(stmt);
+
+    if (pBanned)
+        pBanned->GetSession()->KickPlayer("World::BanCharacter");
+
+    return BAN_SUCCESS;
+}
+
+/// Remove a ban from a character
+bool World::RemoveBanCharacter(std::string const& name)
+{
+    Player* pBanned = sObjectAccessor->FindPlayerByName(name);
+    uint32 guid = 0;
+
+    /// Pick a player to ban if not online
+    if (!pBanned)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUID_BY_NAME);
+        stmt->setString(0, name);
+        PreparedQueryResult resultCharacter = CharacterDatabase.Query(stmt);
+
+        if (!resultCharacter)
+            return false;
+
+        guid = (*resultCharacter)[0].GetUInt32();
+    }
+    else
+        guid = pBanned->GetGUIDLow();
+
+    if (!guid)
+        return false;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER_BAN);
+    stmt->setUInt32(0, guid);
+    CharacterDatabase.Execute(stmt);
+    return true;
+}
+
+/// Update the game time
+void World::_UpdateGameTime()
+{
+    ///- update the time
+    time_t thisTime = time(NULL);
+    uint32 elapsed = uint32(thisTime - m_gameTime);
+    m_gameTime = thisTime;
+
+    ///- if there is a shutdown timer
+    if (!IsStopped() && m_ShutdownTimer > 0 && elapsed > 0)
+    {
+        ///- ... and it is overdue, stop the world (set m_stopEvent)
+        if (m_ShutdownTimer <= elapsed)
+        {
+            if (!(m_ShutdownMask & SHUTDOWN_MASK_IDLE) || GetActiveAndQueuedSessionCount() == 0)
+                m_stopEvent = true;                         // exist code already set
+            else
+                m_ShutdownTimer = 1;                        // minimum timer value to wait idle state
+        }
+        ///- ... else decrease it and if necessary display a shutdown countdown to the users
+        else
+        {
+            m_ShutdownTimer -= elapsed;
+
+            ShutdownMsg();
+        }
+    }
+}
+
+/// Shutdown the server
+void World::ShutdownServ(uint32 time, uint32 options, uint8 exitcode)
+{
+    // ignore if server shutdown at next tick
+    if (IsStopped())
+        return;
+
+    m_ShutdownMask = options;
+    m_ExitCode = exitcode;
+
+    ///- If the shutdown time is 0, set m_stopEvent (except if shutdown is 'idle' with remaining sessions)
+    if (time == 0)
+    {
+        if (!(options & SHUTDOWN_MASK_IDLE) || GetActiveAndQueuedSessionCount() == 0)
+            m_stopEvent = true;                             // exist code already set
+        else
+            m_ShutdownTimer = 1;                            //So that the session count is re-evaluated at next world tick
+    }
+    ///- Else set the shutdown timer and warn users
+    else
+    {
+        m_ShutdownTimer = time;
+        ShutdownMsg(true);
+    }
+
+    sScriptMgr->OnShutdownInitiate(ShutdownExitCode(exitcode), ShutdownMask(options));
+}
+
+/// Display a shutdown message to the user(s)
+void World::ShutdownMsg(bool show, Player* player)
+{
+    // not show messages for idle shutdown mode
+    if (m_ShutdownMask & SHUTDOWN_MASK_IDLE)
+        return;
+
+    ///- Display a message every 12 hours, hours, 5 minutes, minute, 5 seconds and finally seconds
+    if (show ||
+        (m_ShutdownTimer < 5* MINUTE && (m_ShutdownTimer % 15) == 0) || // < 5 min; every 15 sec
+        (m_ShutdownTimer < 15 * MINUTE && (m_ShutdownTimer % MINUTE) == 0) || // < 15 min ; every 1 min
+        (m_ShutdownTimer < 30 * MINUTE && (m_ShutdownTimer % (5 * MINUTE)) == 0) || // < 30 min ; every 5 min
+        (m_ShutdownTimer < 12 * HOUR && (m_ShutdownTimer % HOUR) == 0) || // < 12 h ; every 1 h
+        (m_ShutdownTimer > 12 * HOUR && (m_ShutdownTimer % (12 * HOUR)) == 0)) // > 12 h ; every 12 h
+    {
+        std::string str = secsToTimeString(m_ShutdownTimer);
+        str = str + ShutdownReason;
+
+        ServerMessageType msgid = (m_ShutdownMask & SHUTDOWN_MASK_RESTART) ? SERVER_MSG_RESTART_TIME : SERVER_MSG_SHUTDOWN_TIME;
+
+        SendServerMessage(msgid, str.c_str(), player);
+        sLog->outDebug(LOG_FILTER_GENERAL, "Server is %s in %s", (m_ShutdownMask & SHUTDOWN_MASK_RESTART ? "restart" : "shuttingdown"), str.c_str());
+    }
+}
+
+/// Cancel a planned server shutdown
+void World::ShutdownCancel()
+{
+    // nothing cancel or too later
+    if (!m_ShutdownTimer || m_stopEvent.value())
+        return;
+
+    ServerMessageType msgid = (m_ShutdownMask & SHUTDOWN_MASK_RESTART) ? SERVER_MSG_RESTART_CANCELLED : SERVER_MSG_SHUTDOWN_CANCELLED;
+
+    m_ShutdownMask = 0;
+    m_ShutdownTimer = 0;
+    m_ExitCode = SHUTDOWN_EXIT_CODE;                       // to default value
+    SendServerMessage(msgid);
+
+    sLog->outDebug(LOG_FILTER_GENERAL, "Server %s cancelled.", (m_ShutdownMask & SHUTDOWN_MASK_RESTART ? "restart" : "shuttingdown"));
+
+    sScriptMgr->OnShutdownCancel();
+}
+
+/// Send a server message to the user(s)
+void World::SendServerMessage(ServerMessageType type, const char *text, Player* player)
+{
+    WorldPacket data(SMSG_SERVER_MESSAGE, 50);              // guess size
+    data << uint32(type);
+    if (type <= SERVER_MSG_STRING)
+        data << text;
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        SendGlobalMessage(&data);
+}
+
+void World::UpdateSessions(uint32 diff)
+{
+    ///- Add new sessions
+    WorldSession* sess = NULL;
+    while (addSessQueue.next(sess))
+        AddSession_ (sess);
+
+    ///- Then send an update signal to remaining ones
+    for (SessionMap::iterator itr = m_sessions.begin(), next; itr != m_sessions.end(); itr = next)
+    {
+        next = itr;
+        ++next;
+
+        ///- and remove not active sessions from the list
+        WorldSession* pSession = itr->second;
+        WorldSessionFilter updater(pSession);
+
+        if (!pSession->Update(diff, updater))    // As interval = 0
+        {
+            if (!RemoveQueuedPlayer(itr->second) && itr->second && getIntConfig(CONFIG_INTERVAL_DISCONNECT_TOLERANCE))
+                m_disconnects[itr->second->GetAccountId()] = time(NULL);
+            RemoveQueuedPlayer(pSession);
+            m_sessions.erase(itr);
+            delete pSession;
+
+        }
+    }
+}
+
+// This handles the issued and queued CLI commands
+void World::ProcessCliCommands()
+{
+    CliCommandHolder::Print* zprint = NULL;
+    void* callbackArg = NULL;
+    CliCommandHolder* command = NULL;
+    while (cliCmdQueue.next(command))
+    {
+        sLog->outInfo(LOG_FILTER_GENERAL, "CLI command under processing...");
+        zprint = command->m_print;
+        callbackArg = command->m_callbackArg;
+        CliHandler handler(callbackArg, zprint);
+        handler.ParseCommands(command->m_command);
+        if (command->m_commandFinished)
+            command->m_commandFinished(callbackArg, !handler.HasSentErrorMessage());
+        delete command;
+    }
+}
+
+void World::SendAutoBroadcast()
+{
+    if (m_Autobroadcasts.empty())
+        return;
+
+    std::string msg;
+
+    msg = Trinity::Containers::SelectRandomContainerElement(m_Autobroadcasts);
+
+    uint32 abcenter = sWorld->getIntConfig(CONFIG_AUTOBROADCAST_CENTER);
+
+    if (abcenter == 0)
+        sWorld->SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+    else if (abcenter == 1)
+    {
+        WorldPacket data(SMSG_NOTIFICATION, 2 + msg.length());
+        data.WriteBits(msg.length(), 13);
+        data.FlushBits();
+        data.WriteString(msg);
+        sWorld->SendGlobalMessage(&data);
+    }
+
+    else if (abcenter == 2)
+    {
+        sWorld->SendWorldText(LANG_AUTO_BROADCAST, msg.c_str());
+
+        WorldPacket data(SMSG_NOTIFICATION, 2 + msg.length());
+        data.WriteBits(msg.length(), 13);
+        data.FlushBits();
+        data.WriteString(msg);
+        sWorld->SendGlobalMessage(&data);
+    }
+
+    sLog->outDebug(LOG_FILTER_GENERAL, "AutoBroadcast: '%s'", msg.c_str());
+}
+
+void World::UpdateRealmCharCount(uint32 accountId)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_COUNT);
+    stmt->setUInt32(0, accountId);
+    PreparedQueryResultFuture result = CharacterDatabase.AsyncQuery(stmt);
+    m_realmCharCallbacks.insert(result);
+}
+
+void World::_UpdateRealmCharCount(PreparedQueryResult resultCharCount)
+{
+    if (resultCharCount)
+    {
+        Field* fields = resultCharCount->Fetch();
+        uint32 accountId = fields[0].GetUInt32();
+        uint8 charCount = uint8(fields[1].GetUInt64());
+
+        PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_REALM_CHARACTERS_BY_REALM);
+        stmt->setUInt32(0, accountId);
+        stmt->setUInt32(1, realmID);
+        LoginDatabase.Execute(stmt);
+
+        stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_REALM_CHARACTERS);
+        stmt->setUInt8(0, charCount);
+        stmt->setUInt32(1, accountId);
+        stmt->setUInt32(2, realmID);
+        LoginDatabase.Execute(stmt);
+    }
+}
+
+void World::InitWeeklyQuestResetTime()
+{
+    time_t wstime = uint64(sWorld->getWorldState(WS_WEEKLY_QUEST_RESET_TIME));
+    time_t curtime = time(NULL);
+    m_NextWeeklyQuestReset = wstime < curtime ? curtime : time_t(wstime);
+}
+
+void World::InitDailyQuestResetTime()
+{
+    time_t mostRecentQuestTime;
+
+    QueryResult result = CharacterDatabase.Query("SELECT MAX(time) FROM character_queststatus_daily");
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        mostRecentQuestTime = time_t(fields[0].GetUInt32());
+    }
+    else
+        mostRecentQuestTime = 0;
+
+    // client built-in time for reset is 6:00 AM
+    // FIX ME: client not show day start time
+    time_t curTime = time(NULL);
+    tm localTm = *localtime(&curTime);
+    localTm.tm_hour = 6;
+    localTm.tm_min  = 0;
+    localTm.tm_sec  = 0;
+
+    // current day reset time
+    time_t curDayResetTime = mktime(&localTm);
+
+    // last reset time before current moment
+    time_t resetTime = (curTime < curDayResetTime) ? curDayResetTime - DAY : curDayResetTime;
+
+    // need reset (if we have quest time before last reset time (not processed by some reason)
+    if (mostRecentQuestTime && mostRecentQuestTime <= resetTime)
+        m_NextDailyQuestReset = mostRecentQuestTime;
+    else // plan next reset time
+        m_NextDailyQuestReset = (curTime >= curDayResetTime) ? curDayResetTime + DAY : curDayResetTime;
+}
+
+void World::InitMonthlyQuestResetTime()
+{
+    time_t wstime = uint64(sWorld->getWorldState(WS_MONTHLY_QUEST_RESET_TIME));
+    time_t curtime = time(NULL);
+    m_NextMonthlyQuestReset = wstime < curtime ? curtime : time_t(wstime);
+}
+
+void World::InitRandomBGResetTime()
+{
+	time_t bgtime = uint64(sWorld->getWorldState(WS_BG_DAILY_RESET_TIME));
+	if (!bgtime)
+		m_NextRandomBGReset = time_t(time(NULL));         // game time not yet init
+
+	// generate time by config
+	time_t curTime = time(NULL);
+	tm localTm = *localtime(&curTime);
+	localTm.tm_hour = getIntConfig(CONFIG_RANDOM_BG_RESET_HOUR);
+	localTm.tm_min = 0;
+	localTm.tm_sec = 0;
+
+	// current day reset time
+	time_t nextDayResetTime = mktime(&localTm);
+
+	// next reset time before current moment
+	if (curTime >= nextDayResetTime)
+		nextDayResetTime += DAY;
+
+	// normalize reset time
+	m_NextRandomBGReset = bgtime < curTime ? nextDayResetTime - DAY : nextDayResetTime;
+
+	if (!bgtime)
+		sWorld->setWorldState(WS_BG_DAILY_RESET_TIME, uint64(m_NextRandomBGReset));
+}
+
+void World::InitGuildResetTime()
+{
+    time_t gtime = uint64(getWorldState(WS_GUILD_DAILY_RESET_TIME));
+    if (!gtime)
+        m_NextGuildReset = time_t(time(NULL));         // game time not yet init
+
+    // generate time by config
+    time_t curTime = time(NULL);
+    tm localTm = *localtime(&curTime);
+    localTm.tm_hour = getIntConfig(CONFIG_GUILD_RESET_HOUR);
+    localTm.tm_min = 0;
+    localTm.tm_sec = 0;
+
+    // current day reset time
+    time_t nextDayResetTime = mktime(&localTm);
+
+    // next reset time before current moment
+    if (curTime >= nextDayResetTime)
+        nextDayResetTime += DAY;
+
+    // normalize reset time
+    m_NextGuildReset = gtime < curTime ? nextDayResetTime - DAY : nextDayResetTime;
+
+    if (!gtime)
+        sWorld->setWorldState(WS_GUILD_DAILY_RESET_TIME, uint64(m_NextGuildReset));
+}
+
+void World::InitCurrencyResetTime()
+{
+	time_t currencytime = uint64(sWorld->getWorldState(WS_CURRENCY_RESET_TIME));
+	if (!currencytime)
+		m_NextCurrencyReset = time_t(time(NULL));         // game time not yet init
+
+	// generate time by config
+	time_t curTime = time(NULL);
+	tm localTm = *localtime(&curTime);
+
+	localTm.tm_wday = getIntConfig(CONFIG_CURRENCY_RESET_DAY);
+	localTm.tm_hour = getIntConfig(CONFIG_CURRENCY_RESET_HOUR);
+	localTm.tm_min = 0;
+	localTm.tm_sec = 0;
+
+	// current week reset time
+	time_t nextWeekResetTime = mktime(&localTm);
+
+	// next reset time before current moment
+	if (curTime >= nextWeekResetTime)
+		nextWeekResetTime += getIntConfig(CONFIG_CURRENCY_RESET_INTERVAL) * DAY;
+
+	// normalize reset time
+	m_NextCurrencyReset = currencytime < curTime ? nextWeekResetTime - getIntConfig(CONFIG_CURRENCY_RESET_INTERVAL) * DAY : nextWeekResetTime;
+
+	if (!currencytime)
+		sWorld->setWorldState(WS_CURRENCY_RESET_TIME, uint64(m_NextCurrencyReset));
+}
+
+void World::ResetDailyQuests()
+{
+    sLog->outInfo(LOG_FILTER_GENERAL, "Daily quests reset for all characters.");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_DAILY);
+    CharacterDatabase.Execute(stmt);
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->ResetDailyQuestStatus();
+
+    // change available dailies
+    sPoolMgr->ChangeDailyQuests();
+	
+	sAnticheatMgr->ResetDailyReportStates();
+
+    sAnticheatMgr->ResetDailyReportStates();
+}
+
+void World::ResetCurrencyWeekCap()
+{
+	CharacterDatabase.Execute("UPDATE `character_currency` SET `week_count` = 0");
+
+	// Calculating week cap for conquest points
+	CharacterDatabase.Execute("UPDATE character_currency_weekcap SET week_cap = ROUND(1.4326 * (1511.26 / (1 + 1639.28 / exp(0.00412 * `max_week_rating`))) + 857.15) WHERE `source`=0 AND `max_week_rating` BETWEEN 1500 AND 3000");
+	CharacterDatabase.PExecute("UPDATE character_currency_weekcap SET week_cap = '%u' WHERE `source`=0 AND `max_week_rating` < 1500", 1350);
+	CharacterDatabase.Execute("UPDATE character_currency_weekcap SET week_cap =3000 WHERE `source`=0 AND `max_week_rating` > 3000");
+	CharacterDatabase.Execute("UPDATE character_currency_weekcap SET max_week_rating=0");
+
+	for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+	if (itr->second->GetPlayer())
+		itr->second->GetPlayer()->ResetCurrencyWeekCap();
+
+	m_NextCurrencyReset = time_t(m_NextCurrencyReset + DAY * getIntConfig(CONFIG_CURRENCY_RESET_INTERVAL));
+	sWorld->setWorldState(WS_CURRENCY_RESET_TIME, uint64(m_NextCurrencyReset));
+}
+
+void World::LoadDBAllowedSecurityLevel()
+{
+    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_REALMLIST_SECURITY_LEVEL);
+    stmt->setInt32(0, int32(realmID));
+    PreparedQueryResult result = LoginDatabase.Query(stmt);
+
+    if (result)
+        SetPlayerSecurityLimit(AccountTypes(result->Fetch()->GetUInt8()));
+}
+
+void World::SetPlayerSecurityLimit(AccountTypes _sec)
+{
+    AccountTypes sec = _sec < SEC_CONSOLE ? _sec : SEC_PLAYER;
+    bool update = sec > m_allowedSecurityLevel;
+    m_allowedSecurityLevel = sec;
+    if (update)
+        KickAllLess(m_allowedSecurityLevel);
+}
+
+void World::ResetWeeklyQuests()
+{
+    sLog->outInfo(LOG_FILTER_GENERAL, "Weekly quests reset for all characters.");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_WEEKLY);
+    CharacterDatabase.Execute(stmt);
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->ResetWeeklyQuestStatus();
+
+    m_NextWeeklyQuestReset = time_t(m_NextWeeklyQuestReset + WEEK);
+    sWorld->setWorldState(WS_WEEKLY_QUEST_RESET_TIME, uint64(m_NextWeeklyQuestReset));
+
+    // change available weeklies
+    sPoolMgr->ChangeWeeklyQuests();
+}
+
+void World::ResetMonthlyQuests()
+{
+    sLog->outInfo(LOG_FILTER_GENERAL, "Monthly quests reset for all characters.");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_MONTHLY);
+    CharacterDatabase.Execute(stmt);
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->ResetMonthlyQuestStatus();
+
+    time_t mostRecentQuestTime = 0;
+
+    // generate time
+    time_t curTime = time(NULL);
+    tm localTm = *localtime(&curTime);
+
+    int month   = localTm.tm_mon;
+    int year    = localTm.tm_year;
+
+    ++month;
+
+    // month 11 is december, next is january (0)
+    if (month > 11)
+    {
+        month = 0;
+        year += 1;
+    }
+
+    // reset time for next month
+    localTm.tm_year     = year;
+    localTm.tm_mon      = month;
+    localTm.tm_mday     = 1;        // don't know if we really need config option for day / hour
+    localTm.tm_hour     = 0;
+    localTm.tm_min      = 0;
+    localTm.tm_sec      = 0;
+
+    time_t nextMonthResetTime = mktime(&localTm);
+
+    // last reset time before current moment
+    time_t resetTime = (curTime < nextMonthResetTime) ? nextMonthResetTime - MONTH : nextMonthResetTime;
+
+    // need reset (if we have quest time before last reset time (not processed by some reason)
+    if (mostRecentQuestTime && mostRecentQuestTime <= resetTime)
+        m_NextMonthlyQuestReset = mostRecentQuestTime;
+    else // plan next reset time
+        m_NextMonthlyQuestReset = (curTime >= nextMonthResetTime) ? nextMonthResetTime + MONTH : nextMonthResetTime;
+
+    sWorld->setWorldState(WS_MONTHLY_QUEST_RESET_TIME, uint64(m_NextMonthlyQuestReset));
+}
+
+void World::ResetEventSeasonalQuests(uint16 event_id)
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_SEASONAL);
+    stmt->setUInt16(0, event_id);
+    CharacterDatabase.Execute(stmt);
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->ResetSeasonalQuestStatus(event_id);
+}
+
+void World::ResetRandomBG()
+{
+    sLog->outInfo(LOG_FILTER_GENERAL, "Random BG status reset for all characters.");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_BATTLEGROUND_RANDOM);
+    CharacterDatabase.Execute(stmt);
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second->GetPlayer())
+            itr->second->GetPlayer()->SetRandomWinner(false);
+
+    m_NextRandomBGReset = time_t(m_NextRandomBGReset + DAY);
+    sWorld->setWorldState(WS_BG_DAILY_RESET_TIME, uint64(m_NextRandomBGReset));
+}
+
+void World::ResetGuildCap()
+{
+    m_NextGuildReset = time_t(m_NextGuildReset + DAY);
+    sWorld->setWorldState(WS_GUILD_DAILY_RESET_TIME, uint64(m_NextGuildReset));
+
+    bool weekReset = false;
+    time_t week = uint64(getWorldState(WS_GUILD_WEEKLY_RESET_TIME));
+    if (!week)
+    {
+        weekReset = true;
+        sWorld->setWorldState(WS_GUILD_WEEKLY_RESET_TIME, uint64(m_NextGuildReset+WEEK-1));
+    }
+    else
+    {
+        if (week < m_NextGuildReset)
+        {
+            weekReset = true;
+            sWorld->setWorldState(WS_GUILD_WEEKLY_RESET_TIME, uint64(m_NextGuildReset+WEEK-1));
+        }
+    }
+
+    sLog->outInfo(LOG_FILTER_GENERAL, "Guild Daily Cap reset. Week: %u", weekReset);
+    sGuildMgr->ResetTimes(weekReset);
+}
+
+void World::UpdateMaxSessionCounters()
+{
+    m_maxActiveSessionCount = std::max(m_maxActiveSessionCount, uint32(m_sessions.size()-m_QueuedPlayer.size()));
+    m_maxQueuedSessionCount = std::max(m_maxQueuedSessionCount, uint32(m_QueuedPlayer.size()));
+}
+
+void World::LoadDBVersion()
+{
+    QueryResult result = WorldDatabase.Query("SELECT db_version, cache_id FROM version LIMIT 1");
+    if (result)
+    {
+        Field* fields = result->Fetch();
+
+        m_DBVersion = fields[0].GetString();
+        // will be overwrite by config values if different and non-0
+        m_int_configs[CONFIG_CLIENTCACHE_VERSION] = fields[1].GetUInt32();
+    }
+
+    if (m_DBVersion.empty())
+        m_DBVersion = "Unknown world database.";
+}
+
+void World::ProcessStartEvent()
+{
+    isEventKillStart = true;
+}
+
+void World::ProcessStopEvent()
+{
+    isEventKillStart = false;
+}
+
+void World::UpdateAreaDependentAuras()
+{
+    SessionMap::const_iterator itr;
+    for (itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second && itr->second->GetPlayer() && itr->second->GetPlayer()->IsInWorld())
+        {
+            itr->second->GetPlayer()->UpdateAreaDependentAuras(itr->second->GetPlayer()->GetAreaId());
+            itr->second->GetPlayer()->UpdateZoneDependentAuras(itr->second->GetPlayer()->GetZoneId());
+        }
+}
+
+void World::LoadWorldStates()
+{
+    uint32 oldMSTime = getMSTime();
+
+    QueryResult result = CharacterDatabase.Query("SELECT entry, value FROM worldstates");
+
+    if (!result)
+    {
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">> Loaded 0 world states. DB table `worldstates` is empty!");
+
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+        m_worldstates[fields[0].GetUInt32()] = fields[1].GetUInt32();
+        ++count;
+    }
+    while (result->NextRow());
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">> Loaded %u world states in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+
+}
+
+// Setting a worldstate will save it to DB
+void World::setWorldState(uint32 index, uint64 value)
+{
+    WorldStatesMap::const_iterator it = m_worldstates.find(index);
+    if (it != m_worldstates.end())
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_WORLDSTATE);
+
+        stmt->setUInt32(0, uint32(value));
+        stmt->setUInt32(1, index);
+
+        CharacterDatabase.Execute(stmt);
+    }
+    else
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_WORLDSTATE);
+
+        stmt->setUInt32(0, index);
+        stmt->setUInt32(1, uint32(value));
+
+        CharacterDatabase.Execute(stmt);
+    }
+    m_worldstates[index] = value;
+}
+
+uint64 World::getWorldState(uint32 index) const
+{
+    WorldStatesMap::const_iterator it = m_worldstates.find(index);
+    return it != m_worldstates.end() ? it->second : 0;
+}
+
+void World::ProcessQueryCallbacks()
+{
+    PreparedQueryResult result;
+
+    while (!m_realmCharCallbacks.is_empty())
+    {
+        ACE_Future<PreparedQueryResult> lResult;
+        ACE_Time_Value timeout = ACE_Time_Value::zero;
+        if (m_realmCharCallbacks.next_readable(lResult, &timeout) != 1)
+            break;
+
+        if (lResult.ready())
+        {
+            lResult.get(result);
+            _UpdateRealmCharCount(result);
+            lResult.cancel();
+        }
+    }
+}
+
+void World::LoadCharacterNameData()
+{
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">>Loading character name data");
+
+    QueryResult result = CharacterDatabase.Query("SELECT guid, name, race, gender, class, level FROM characters WHERE deleteDate IS NULL");
+    if (!result)
+    {
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">>No character name data loaded, empty query");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+        AddCharacterNameData(fields[0].GetUInt32(), fields[1].GetString(),
+            fields[3].GetUInt8() /*gender*/, fields[2].GetUInt8() /*race*/, fields[4].GetUInt8() /*class*/, fields[5].GetUInt8() /*level*/);
+        ++count;
+    } while (result->NextRow());
+
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, ">>Loaded name data for %u characters", count);
+}
+
+void World::AddCharacterNameData(uint32 guid, std::string const& name, uint8 gender, uint8 race, uint8 playerClass, uint8 level)
+{
+    CharacterNameData& data = _characterNameDataMap[guid];
+    data.m_name = name;
+    data.m_race = race;
+    data.m_gender = gender;
+    data.m_class = playerClass;
+    data.m_level = level;
+}
+
+void World::UpdateCharacterNameData(uint32 guid, std::string const& name, uint8 gender /*= GENDER_NONE*/, uint8 race /*= RACE_NONE*/)
+{
+    std::map<uint32, CharacterNameData>::iterator itr = _characterNameDataMap.find(guid);
+    if (itr == _characterNameDataMap.end())
+        return;
+
+    itr->second.m_name = name;
+
+    if (gender != GENDER_NONE)
+        itr->second.m_gender = gender;
+
+    if (race != RACE_NONE)
+        itr->second.m_race = race;
+
+    WorldPacket data(SMSG_INVALIDATE_PLAYER, 8);
+    data << MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER);
+    SendGlobalMessage(&data);
+}
+
+void World::UpdateCharacterNameDataLevel(uint32 guid, uint8 level)
+{
+    std::map<uint32, CharacterNameData>::iterator itr = _characterNameDataMap.find(guid);
+    if (itr == _characterNameDataMap.end())
+        return;
+
+    itr->second.m_level = level;
+}
+
+CharacterNameData const* World::GetCharacterNameData(uint32 guid) const
+{
+    std::map<uint32, CharacterNameData>::const_iterator itr = _characterNameDataMap.find(guid);
+    if (itr != _characterNameDataMap.end())
+        return &itr->second;
+    else
+        return NULL;
+}
+
+void World::UpdatePhaseDefinitions()
+{
+    SessionMap::const_iterator itr;
+    for (itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+        if (itr->second && itr->second->GetPlayer() && itr->second->GetPlayer()->IsInWorld())
+            itr->second->GetPlayer()->GetPhaseMgr().NotifyStoresReloaded();
+}
+
+void World::InitPacketThrottling()
+{
+    memset(opcodePerSecond, 1000, sizeof(uint32) * NUM_OPCODE_HANDLERS);
+
+    opcodePerSecond[CMSG_WHO] = 1;
+    opcodePerSecond[CMSG_INSPECT] = 1;
+    opcodePerSecond[CMSG_CHAR_ENUM] = 1;
+    opcodePerSecond[CMSG_GAMEOBJ_USE] = 1;
+    opcodePerSecond[CMSG_GAMEOBJ_REPORT_USE] = 1;
+    opcodePerSecond[CMSG_SPELLCLICK] = 1;
+    opcodePerSecond[CMSG_PLAYER_LOGOUT] = 1;
+    opcodePerSecond[CMSG_LOGOUT_REQUEST] = 1;
+    opcodePerSecond[CMSG_LOGOUT_CANCEL] = 1;
+    opcodePerSecond[CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE] = 1;
+    opcodePerSecond[CMSG_REQUEST_VEHICLE_PREV_SEAT] = 1;
+    opcodePerSecond[CMSG_REQUEST_VEHICLE_NEXT_SEAT] = 1;
+    opcodePerSecond[CMSG_REQUEST_VEHICLE_SWITCH_SEAT] = 1;
+    opcodePerSecond[CMSG_TOGGLE_PVP] = 1;
+    opcodePerSecond[CMSG_CONTACT_LIST] = 1;
+    opcodePerSecond[CMSG_ADD_FRIEND] = 1;
+    opcodePerSecond[CMSG_DEL_FRIEND] = 1;
+    opcodePerSecond[CMSG_SET_CONTACT_NOTES] = 1;
+    opcodePerSecond[CMSG_RESET_INSTANCES] = 1;
+    opcodePerSecond[CMSG_HEARTH_AND_RESURRECT] = 1;
+    opcodePerSecond[CMSG_CHAR_CREATE] = 1;
+    opcodePerSecond[CMSG_READY_FOR_ACCOUNT_DATA_TIMES] = 1;
+    opcodePerSecond[CMSG_CHAR_ENUM] = 1;
+    opcodePerSecond[CMSG_REALM_SPLIT] = 1;
+    opcodePerSecond[CMSG_CHAR_DELETE] = 1;
+    opcodePerSecond[CMSG_PLAYER_LOGIN] = 1;
+    opcodePerSecond[CMSG_PET_ABANDON] = 1;
+    opcodePerSecond[CMSG_PET_RENAME] = 1;
+    opcodePerSecond[CMSG_CHAR_RENAME] = 1;
+    opcodePerSecond[CMSG_CHAR_CUSTOMIZE] = 1;
+    opcodePerSecond[CMSG_CHAR_RACE_CHANGE] = 1;
+    opcodePerSecond[CMSG_CHAR_FACTION_CHANGE] = 1;
+    opcodePerSecond[CMSG_GMTICKET_CREATE] = 1;
+    opcodePerSecond[CMSG_GMTICKET_UPDATETEXT] = 1;
+    opcodePerSecond[CMSG_GMTICKET_DELETETICKET] = 1;
+    opcodePerSecond[CMSG_GMSURVEY_SUBMIT] = 1;
+    opcodePerSecond[CMSG_GM_REPORT_LAG] = 1;
+    opcodePerSecond[CMSG_BUG] = 1;
+    opcodePerSecond[CMSG_GMRESPONSE_RESOLVE] = 1;
+    opcodePerSecond[CMSG_ACTIVATETAXIEXPRESS] = 1;
+    opcodePerSecond[CMSG_ACTIVATETAXI] = 1;
+    opcodePerSecond[CMSG_SELF_RES] = 1;
+    opcodePerSecond[CMSG_INITIATE_TRADE] = 1;
+    opcodePerSecond[CMSG_BEGIN_TRADE] = 1;
+    opcodePerSecond[CMSG_UNLEARN_SKILL] = 1;
+    opcodePerSecond[CMSG_DISMISS_CONTROLLED_VEHICLE] = 1;
+    opcodePerSecond[CMSG_REQUEST_VEHICLE_EXIT] = 1;
+    opcodePerSecond[CMSG_LEARN_PREVIEW_TALENTS] = 1;
+    opcodePerSecond[CMSG_LEARN_PREVIEW_TALENTS_PET] = 1;
+    opcodePerSecond[CMSG_PLAYER_VEHICLE_ENTER] = 1;
+    opcodePerSecond[CMSG_EQUIPMENT_SET_SAVE] = 1;
+    opcodePerSecond[CMSG_DELETEEQUIPMENT_SET] = 1;
+    opcodePerSecond[CMSG_ALTER_APPEARANCE] = 1;
+    opcodePerSecond[CMSG_QUESTGIVER_ACCEPT_QUEST] = 1;
+    opcodePerSecond[CMSG_QUESTGIVER_CHOOSE_REWARD] = 1;
+    opcodePerSecond[CMSG_QUESTGIVER_REQUEST_REWARD] = 1;
+    opcodePerSecond[CMSG_QUESTGIVER_CANCEL] = 1;
+    opcodePerSecond[CMSG_QUESTLOG_REMOVE_QUEST] = 1;
+    opcodePerSecond[CMSG_QUEST_CONFIRM_ACCEPT] = 1;
+    opcodePerSecond[CMSG_QUESTGIVER_COMPLETE_QUEST] = 1;
+    opcodePerSecond[CMSG_DISMISS_CRITTER] = 1;
+    opcodePerSecond[CMSG_REPOP_REQUEST] = 1;
+    opcodePerSecond[CMSG_PETITION_BUY] = 1;
+    opcodePerSecond[CMSG_PETITION_SIGN] = 1;
+    opcodePerSecond[CMSG_TURN_IN_PETITION] = 1;
+    opcodePerSecond[CMSG_COMPLETE_CINEMATIC] = 1;
+    opcodePerSecond[CMSG_ITEM_REFUND] = 1;
+    opcodePerSecond[CMSG_SOCKET_GEMS] = 1;
+    opcodePerSecond[CMSG_WRAP_ITEM] = 1;
+    opcodePerSecond[CMSG_BUY_BANK_SLOT] = 1;
+    opcodePerSecond[CMSG_GROUP_UNINVITE_GUID] = 1;
+    opcodePerSecond[CMSG_GROUP_UNINVITE] = 1;
+    opcodePerSecond[CMSG_GROUP_SET_LEADER] = 1;
+    opcodePerSecond[CMSG_GROUP_DISBAND] = 1;
+    opcodePerSecond[CMSG_GROUP_RAID_CONVERT] = 1;
+    opcodePerSecond[CMSG_GROUP_CHANGE_SUB_GROUP] = 1;
+    opcodePerSecond[CMSG_GROUP_ASSISTANT_LEADER] = 1;
+    opcodePerSecond[CMSG_REQUEST_PARTY_MEMBER_STATS] = 1;
+    opcodePerSecond[CMSG_OPT_OUT_OF_LOOT] = 1;
+    opcodePerSecond[CMSG_BATTLEMASTER_JOIN_ARENA] = 1;
+    opcodePerSecond[CMSG_REPORT_PVP_AFK] = 1;
+    opcodePerSecond[CMSG_DUEL_ACCEPTED] = 1;
+    opcodePerSecond[CMSG_DUEL_CANCELLED] = 1;
+    opcodePerSecond[CMSG_SETSHEATHED] = 1;
+    opcodePerSecond[CMSG_CALENDAR_GET_CALENDAR] = 1;
+    opcodePerSecond[CMSG_CALENDAR_ADD_EVENT] = 1;
+    opcodePerSecond[CMSG_CALENDAR_UPDATE_EVENT] = 1;
+    opcodePerSecond[CMSG_CALENDAR_REMOVE_EVENT] = 1;
+    opcodePerSecond[CMSG_CALENDAR_COPY_EVENT] = 1;
+    opcodePerSecond[CMSG_CALENDAR_EVENT_INVITE] = 1;
+    opcodePerSecond[CMSG_CALENDAR_EVENT_SIGNUP] = 1;
+    opcodePerSecond[CMSG_CALENDAR_EVENT_RSVP] = 1;
+    opcodePerSecond[CMSG_CALENDAR_EVENT_REMOVE_INVITE] = 1;
+    opcodePerSecond[CMSG_CALENDAR_EVENT_MODERATOR_STATUS] = 1;
+    opcodePerSecond[CMSG_CALENDAR_COMPLAIN] = 1;
+    opcodePerSecond[CMSG_ARENA_TEAM_INVITE] = 1;
+    opcodePerSecond[CMSG_ARENA_TEAM_ACCEPT] = 1;
+    opcodePerSecond[CMSG_ARENA_TEAM_DECLINE] = 1;
+    opcodePerSecond[CMSG_ARENA_TEAM_LEAVE] = 1;
+    opcodePerSecond[CMSG_ARENA_TEAM_DISBAND] = 1;
+    opcodePerSecond[CMSG_ARENA_TEAM_REMOVE] = 1;
+    opcodePerSecond[CMSG_ARENA_TEAM_LEADER] = 1;
+    opcodePerSecond[CMSG_LOOT_METHOD] = 1;
+    opcodePerSecond[CMSG_GUILD_INVITE] = 1;
+    opcodePerSecond[CMSG_GUILD_ACCEPT] = 1;
+    opcodePerSecond[CMSG_GUILD_DECLINE] = 1;
+    opcodePerSecond[CMSG_GUILD_LEAVE] = 1;
+    opcodePerSecond[CMSG_GUILD_DISBAND] = 1;
+    opcodePerSecond[CMSG_GUILD_MOTD] = 1;
+    opcodePerSecond[CMSG_GUILD_ADD_RANK] = 1;
+    opcodePerSecond[CMSG_GUILD_DEL_RANK] = 1;
+    opcodePerSecond[CMSG_GUILD_INFO_TEXT] = 1;
+    opcodePerSecond[CMSG_GUILD_BANK_DEPOSIT_MONEY] = 1;
+    opcodePerSecond[CMSG_GUILD_BANK_WITHDRAW_MONEY] = 1;
+    opcodePerSecond[CMSG_GUILD_BANK_BUY_TAB] = 1;
+    opcodePerSecond[CMSG_GUILD_BANK_UPDATE_TAB] = 1;
+    opcodePerSecond[CMSG_SET_GUILD_BANK_TEXT] = 1;
+    opcodePerSecond[MSG_SAVE_GUILD_EMBLEM] = 1;
+    opcodePerSecond[MSG_PETITION_RENAME] = 1;
+    opcodePerSecond[MSG_PETITION_DECLINE] = 1;
+    opcodePerSecond[MSG_TALENT_WIPE_CONFIRM] = 1;
+    opcodePerSecond[MSG_SET_DUNGEON_DIFFICULTY] = 1;
+    opcodePerSecond[MSG_SET_RAID_DIFFICULTY] = 1;
+    opcodePerSecond[MSG_RANDOM_ROLL] = 1;
+    opcodePerSecond[MSG_RAID_TARGET_UPDATE] = 1;
+    opcodePerSecond[MSG_PARTY_ASSIGNMENT] = 1;
+    opcodePerSecond[MSG_RAID_READY_CHECK] = 1;
+    opcodePerSecond[CMSG_SET_TAXI_BENCHMARK_MODE] = 1;
+
+    opcodePerSecond[CMSG_EJECT_PASSENGER] = 25;
+    opcodePerSecond[CMSG_GUILD_SWITCH_RANK] = 25;
+    opcodePerSecond[CMSG_GUILD_SET_NOTE] = 25;
+    opcodePerSecond[CMSG_QUEST_QUERY] = 25;
+
+    opcodePerSecond[CMSG_BATTLEFIELD_JOIN] = 50;
+    opcodePerSecond[CMSG_BATTLEFIELD_LEAVE] = 50;
+    opcodePerSecond[CMSG_BATTLEFIELD_LIST] = 50;
+
+    opcodePerSecond[CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE] = 50;
+    opcodePerSecond[CMSG_BATTLEFIELD_MGR_EXIT_REQUEST] = 50;
+    opcodePerSecond[CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE] = 50;
+    opcodePerSecond[CMSG_BATTLEFIELD_MGR_QUEUE_REQUEST] = 50;
+    opcodePerSecond[CMSG_BATTLEFIELD_PORT] = 50;
+    opcodePerSecond[CMSG_BATTLEFIELD_REQUEST_SCORE_DATA] = 50;
+    opcodePerSecond[CMSG_BATTLEFIELD_STATUS] = 50;
+    opcodePerSecond[CMSG_QUERY_BATTLEFIELD_STATE] = 50;
+
+    opcodePerSecond[CMSG_GROUP_CANCEL] = 50;
+
+    opcodePerSecond[CMSG_ITEM_REFUND_INFO] = 200;
+    opcodePerSecond[CMSG_ITEM_TEXT_QUERY] = 200;
+    opcodePerSecond[CMSG_GUILD_QUERY] = 200;
+    opcodePerSecond[CMSG_NAME_QUERY] = 200;
+    opcodePerSecond[CMSG_PET_NAME_QUERY] = 200;
+    opcodePerSecond[CMSG_GAMEOBJECT_QUERY] = 200;
+    opcodePerSecond[CMSG_CREATURE_QUERY] = 200;
+    opcodePerSecond[CMSG_NPC_TEXT_QUERY] = 200;
+    opcodePerSecond[CMSG_ARENA_TEAM_QUERY] = 200;
+    opcodePerSecond[CMSG_TAXINODE_STATUS_QUERY] = 200;
+    opcodePerSecond[CMSG_TAXIQUERYAVAILABLENODES] = 200;
+    opcodePerSecond[CMSG_QUESTGIVER_QUERY_QUEST] = 200;
+    opcodePerSecond[CMSG_QUEST_QUERY] = 200;
+    opcodePerSecond[CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY] = 200;
+    opcodePerSecond[CMSG_QUERY_QUESTS_COMPLETED] = 200;
+    opcodePerSecond[CMSG_QUEST_POI_QUERY] = 200;
+    opcodePerSecond[CMSG_QUERY_TIME] = 200;
+    opcodePerSecond[CMSG_PAGE_TEXT_QUERY] = 200;
+    opcodePerSecond[CMSG_PETITION_QUERY] = 200;
+    opcodePerSecond[CMSG_QUERY_INSPECT_ACHIEVEMENTS] = 200;
+    opcodePerSecond[CMSG_AREA_SPIRIT_HEALER_QUERY] = 200;
+    opcodePerSecond[CMSG_CORPSE_MAP_POSITION_QUERY] = 200;
+    opcodePerSecond[CMSG_MOVE_TIME_SKIPPED] = 200;
+    opcodePerSecond[CMSG_GUILD_BANK_QUERY_TAB] = 200;
+    opcodePerSecond[MSG_CORPSE_QUERY] = 200;
+    opcodePerSecond[MSG_QUERY_NEXT_MAIL_TIME] = 200;
+    opcodePerSecond[MSG_MOVE_SET_FACING] = 200;
+    opcodePerSecond[CMSG_CANCEL_CAST] = 200;
+    opcodePerSecond[CMSG_GUILD_BANK_LOG_QUERY] = 200;
+    opcodePerSecond[CMSG_GUILD_EVENT_LOG_QUERY] = 200;
+}
+
+void World::ExecuteCronjobs()
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT id, guid, type, param1, param2, x, y, z FROM cronjobs");
+
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 id = fields[0].GetUInt32();
+            uint64 guid = fields[1].GetUInt64();
+            uint8 type = fields[2].GetUInt8();
+            bool executed = false;
+
+            switch (type)
+            {
+                case CRONJOB_TELEPORT:
+                {
+                    Player* player = sObjectAccessor->FindPlayer(guid);
+                    if (player)
+                    {
+                        uint32 mapId = atoi(fields[3].GetCString());
+                        float x = fields[5].GetFloat();
+                        float y = fields[6].GetFloat();
+                        float z = fields[7].GetFloat();
+
+                        player->TeleportTo(mapId, x, y, z, 0.0f, 0);
+                        executed = true;
+                    }
+                    break;
+                }
+
+                case CRONJOB_REVIVE:
+                {
+                    Player* player = sObjectAccessor->FindPlayer(guid);
+                    if (player)
+                    {
+                        player->ResurrectPlayer(100.0f, false);
+                        executed = true;
+                    }
+
+                    break;
+                }
+
+                case CRONJOB_LEVEL:
+                {
+                    Player* player = sObjectAccessor->FindPlayer(guid);
+                    if (player)
+                    {
+                        uint8 level = atoi(fields[3].GetCString());
+                        if (level)
+                        {
+                            player->SetLevel(level);
+                            executed = true;
+                        }
+                    }
+
+                    break;
+                }
+
+                case CRONJOB_FACTIONCHANGE:
+                {
+                    Player* player = sObjectAccessor->FindPlayer(guid);
+                    if (player)
+                    {
+                        player->SetAtLoginFlag(AT_LOGIN_CHANGE_FACTION);
+                        executed = true;
+                    }
+                    else
+                    {
+                        CharacterDatabase.PExecute("UPDATE characters SET at_login = at_login | %u WHERE guid = %u", 0x40, guid);
+                        executed = true;
+                    }
+
+                    break;
+                }
+
+                case CRONJOB_RACECHANGE:
+                {
+                    Player* player = sObjectAccessor->FindPlayer(guid);
+                    if (player)
+                    {
+                        player->SetAtLoginFlag(AT_LOGIN_CHANGE_RACE);
+                        executed = true;
+                    }
+                    else
+                    {
+                        CharacterDatabase.PExecute("UPDATE characters SET at_login = at_login | %u WHERE guid = %u", 0x80, guid);
+                        executed = true;
+                    }
+
+                    break;
+                }
+
+                case CRONJOB_CUSTOMIZE:
+                {
+                    Player* player = sObjectAccessor->FindPlayer(guid);
+                    if (player)
+                    {
+                        player->SetAtLoginFlag(AT_LOGIN_CUSTOMIZE);
+                        executed = true;
+                    }
+                    else
+                    {
+                        CharacterDatabase.PExecute("UPDATE characters SET at_login = at_login | %u WHERE guid = %u", 0x08, guid);
+                        executed = true;
+                    }
+
+                    break;
+                }
+
+                default:
+                {
+                    sLog->outError(LOG_FILTER_GENERAL, "[CRONJOB] There is a cronjob with unknown type %u and primary key %u. Skipping", type, id);
+                    break;
+                }
+            }
+
+            if (executed)
+                CharacterDatabase.PExecute("DELETE FROM cronjobs WHERE id = %u", id);
+        }
+        while (result->NextRow());
+    }
+}
+
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 840e6cd..7eb1e0d 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -155,6 +155,10 @@ enum WorldBoolConfigs
     CONFIG_ARENA_QUEUE_ANNOUNCER_PLAYERONLY,
     CONFIG_ARENA_SEASON_IN_PROGRESS,
     CONFIG_ARENA_LOG_EXTENDED_INFO,
+    CONFIG_ARENA_1V1_ENABLE,
+    CONFIG_ARENA_1V1_ANNOUNCER,
+    CONFIG_ARENA_1V1_VENDOR_RATING,
+    CONFIG_ARENA_1V1_BLOCK_FORBIDDEN_TALENTS,
     CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN,
     CONFIG_VMAP_INDOOR_CHECK,
     CONFIG_START_ALL_SPELLS,
@@ -212,6 +216,7 @@ enum WorldFloatConfigs
     CONFIG_CREATURE_FAMILY_ASSISTANCE_RADIUS,
     CONFIG_THREAT_RADIUS,
     CONFIG_CHANCE_OF_GM_SURVEY,
+    CONFIG_ARENA_1V1_ARENAPOINTS_MULTI,
     FLOAT_CONFIG_VALUE_COUNT
 };
 
@@ -322,6 +327,8 @@ enum WorldIntConfigs
     CONFIG_ARENA_START_RATING,
     CONFIG_ARENA_START_PERSONAL_RATING,
     CONFIG_ARENA_START_MATCHMAKER_RATING,
+    CONFIG_ARENA_1V1_MIN_LEVEL,
+    CONFIG_ARENA_1V1_COSTS,
     CONFIG_MAX_WHO,
     CONFIG_HONOR_AFTER_DUEL,
     CONFIG_PVP_TOKEN_MAP_TYPE,
diff --git a/src/server/game/World/World.h.orig b/src/server/game/World/World.h.orig
new file mode 100644
index 0000000..840e6cd
--- /dev/null
+++ b/src/server/game/World/World.h.orig
@@ -0,0 +1,926 @@
+/*
+ * Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/// \addtogroup world The World
+/// @{
+/// \file
+
+#ifndef __WORLD_H
+#define __WORLD_H
+
+#include "Common.h"
+#include "Timer.h"
+#include <ace/Singleton.h>
+#include <ace/Atomic_Op.h>
+#include "SharedDefines.h"
+#include "QueryResult.h"
+#include "Callback.h"
+
+#include <map>
+#include <set>
+#include <list>
+
+class Object;
+class WorldPacket;
+class WorldSession;
+class Player;
+class WorldSocket;
+class SystemMgr;
+
+// ServerMessages.dbc
+enum ServerMessageType
+{
+    SERVER_MSG_SHUTDOWN_TIME          = 1,
+    SERVER_MSG_RESTART_TIME           = 2,
+    SERVER_MSG_STRING                 = 3,
+    SERVER_MSG_SHUTDOWN_CANCELLED     = 4,
+    SERVER_MSG_RESTART_CANCELLED      = 5,
+    SERVER_MSG_BG_SHUTDOWN_TIME       = 6,
+    SERVER_MSG_BG_RESTART_TIME        = 7,
+    SERVER_MSG_INSTANCE_SHUTDOWN_TIME = 8,
+    SERVER_MSG_INSTANCE_RESTART_TIME  = 9,
+    SERVER_MSG_CONTENT_READY          = 10,
+    SERVER_MSG_TICKET_SERVICED_SOON   = 11,
+    SERVER_MSG_WAIT_TIME_UNAVAILABLE  = 12,
+    SERVER_MSG_TICKET_WAIT_TIME       = 13,
+};
+
+enum ShutdownMask
+{
+    SHUTDOWN_MASK_RESTART = 1,
+    SHUTDOWN_MASK_IDLE    = 2
+};
+
+enum ShutdownExitCode
+{
+    SHUTDOWN_EXIT_CODE = 0,
+    ERROR_EXIT_CODE    = 1,
+    RESTART_EXIT_CODE  = 2
+};
+
+/// Timers for different object refresh rates
+enum WorldTimers
+{
+    WUPDATE_AUCTIONS,
+    WUPDATE_WEATHERS,
+    WUPDATE_UPTIME,
+    WUPDATE_CORPSES,
+    WUPDATE_EVENTS,
+    WUPDATE_CLEANDB,
+    WUPDATE_AUTOBROADCAST,
+    WUPDATE_MAILBOXQUEUE,
+    WUPDATE_DELETECHARS,
+    WUPDATE_PINGDB,
+    WUPDATE_GUILDSAVE,
+    WUPDATE_HPGOLD,
+    WUPDATE_CRONJOBS,
+    WUPDATE_COUNT
+};
+
+enum CronjobType
+{
+    CRONJOB_TELEPORT      = 1,
+    CRONJOB_REVIVE        = 2,
+    CRONJOB_LEVEL         = 3,
+    CRONJOB_FACTIONCHANGE = 4,
+    CRONJOB_RACECHANGE    = 5,
+    CRONJOB_CUSTOMIZE     = 6
+};
+
+/// Configuration elements
+enum WorldBoolConfigs
+{
+    CONFIG_DURABILITY_LOSS_IN_PVP = 0,
+    CONFIG_ADDON_CHANNEL,
+    CONFIG_ALLOW_PLAYER_COMMANDS,
+    CONFIG_CLEAN_CHARACTER_DB,
+    CONFIG_GRID_UNLOAD,
+    CONFIG_STATS_SAVE_ONLY_ON_LOGOUT,
+    CONFIG_ALLOW_TWO_SIDE_ACCOUNTS,
+    CONFIG_ALLOW_TWO_SIDE_INTERACTION_CALENDAR,
+    CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHAT,
+    CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHANNEL,
+    CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP,
+    CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD,
+    CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION,
+    CONFIG_ALLOW_TWO_SIDE_INTERACTION_MAIL,
+    CONFIG_ALLOW_TWO_SIDE_WHO_LIST,
+    CONFIG_ALLOW_TWO_SIDE_ADD_FRIEND,
+    CONFIG_ALLOW_TWO_SIDE_TRADE,
+    CONFIG_ALL_TAXI_PATHS,
+    CONFIG_INSTANT_TAXI,
+    CONFIG_INSTANCE_IGNORE_LEVEL,
+    CONFIG_INSTANCE_IGNORE_RAID,
+    CONFIG_CAST_UNSTUCK,
+    CONFIG_GM_LOG_TRADE,
+    CONFIG_ALLOW_GM_GROUP,
+    CONFIG_ALLOW_GM_FRIEND,
+    CONFIG_GM_LOWER_SECURITY,
+    CONFIG_SKILL_PROSPECTING,
+    CONFIG_SKILL_MILLING,
+    CONFIG_SAVE_RESPAWN_TIME_IMMEDIATELY,
+    CONFIG_WEATHER,
+    CONFIG_QUEST_IGNORE_RAID,
+    CONFIG_DETECT_POS_COLLISION,
+    CONFIG_RESTRICTED_LFG_CHANNEL,
+    CONFIG_SILENTLY_GM_JOIN_TO_CHANNEL,
+    CONFIG_TALENTS_INSPECTING,
+    CONFIG_CHAT_FAKE_MESSAGE_PREVENTING,
+    CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP,
+    CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE,
+    CONFIG_DEATH_BONES_WORLD,
+    CONFIG_DEATH_BONES_BG_OR_ARENA,
+    CONFIG_DIE_COMMAND_MODE,
+    CONFIG_DECLINED_NAMES_USED,
+    CONFIG_BATTLEGROUND_CAST_DESERTER,
+    CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_ENABLE,
+    CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY,
+    CONFIG_BG_XP_FOR_KILL,
+    CONFIG_ARENA_QUEUE_ANNOUNCER_ENABLE,
+    CONFIG_ARENA_QUEUE_ANNOUNCER_PLAYERONLY,
+    CONFIG_ARENA_SEASON_IN_PROGRESS,
+    CONFIG_ARENA_LOG_EXTENDED_INFO,
+    CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN,
+    CONFIG_VMAP_INDOOR_CHECK,
+    CONFIG_START_ALL_SPELLS,
+    CONFIG_START_ALL_EXPLORED,
+    CONFIG_START_ALL_REP,
+    CONFIG_ALWAYS_MAXSKILL,
+    CONFIG_PVP_TOKEN_ENABLE,
+    CONFIG_NO_RESET_TALENT_COST,
+    CONFIG_SHOW_KICK_IN_WORLD,
+	CONFIG_SHOW_MUTE_IN_WORLD,
+	CONFIG_SHOW_BAN_IN_WORLD,
+    CONFIG_CHATLOG_CHANNEL,
+    CONFIG_CHATLOG_WHISPER,
+    CONFIG_CHATLOG_SYSCHAN,
+    CONFIG_CHATLOG_PARTY,
+    CONFIG_CHATLOG_RAID,
+    CONFIG_CHATLOG_GUILD,
+    CONFIG_CHATLOG_PUBLIC,
+    CONFIG_CHATLOG_ADDON,
+    CONFIG_CHATLOG_BGROUND,
+    CONFIG_AUTOBROADCAST,
+    CONFIG_ALLOW_TICKETS,
+    CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
+    CONFIG_PRESERVE_CUSTOM_CHANNELS,
+    CONFIG_ANTICHEAT_ENABLE,
+    CONFIG_PDUMP_NO_PATHS,
+    CONFIG_PDUMP_NO_OVERWRITE,
+    CONFIG_QUEST_IGNORE_AUTO_ACCEPT,
+    CONFIG_QUEST_IGNORE_AUTO_COMPLETE,
+	CONFIG_QUEST_ENABLE_QUEST_TRACKER,
+    CONFIG_WARDEN_ENABLED,
+    CONFIG_ENABLE_MMAPS,
+    CONFIG_WINTERGRASP_ENABLE,
+    CONFIG_TOL_BARAD_ENABLE,
+    CONFIG_GUILD_LEVELING_ENABLED,
+    CONFIG_UI_QUESTLEVELS_IN_DIALOGS,     // Should we add quest levels to the title in the NPC dialogs?
+    CONFIG_RATED_BATTLEGROUND_ENABLED,
+    CONFIG_ALLOW_ZONE_AND_AREA_VALUES_CORRECTION_AT_STARTUP,
+    CONFIG_ARENA_READYMARK_ENABLED,
+    CONFIG_HPGOLD_REFRESH_ENABLED,
+    CONFIG_CRONJOBS_ENABLED,
+    BOOL_CONFIG_VALUE_COUNT
+};
+
+enum WorldFloatConfigs
+{
+    CONFIG_GROUP_XP_DISTANCE = 0,
+    CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE,
+    CONFIG_SIGHT_MONSTER,
+    CONFIG_SIGHT_GUARDER,
+    CONFIG_LISTEN_RANGE_SAY,
+    CONFIG_LISTEN_RANGE_TEXTEMOTE,
+    CONFIG_LISTEN_RANGE_YELL,
+    CONFIG_CREATURE_FAMILY_FLEE_ASSISTANCE_RADIUS,
+    CONFIG_CREATURE_FAMILY_ASSISTANCE_RADIUS,
+    CONFIG_THREAT_RADIUS,
+    CONFIG_CHANCE_OF_GM_SURVEY,
+    FLOAT_CONFIG_VALUE_COUNT
+};
+
+enum WorldIntConfigs
+{
+    CONFIG_COMPRESSION = 0,
+    CONFIG_INTERVAL_SAVE,
+    CONFIG_INTERVAL_GRIDCLEAN,
+    CONFIG_INTERVAL_MAPUPDATE,
+    CONFIG_INTERVAL_CHANGEWEATHER,
+    CONFIG_INTERVAL_DISCONNECT_TOLERANCE,
+    CONFIG_PORT_WORLD,
+    CONFIG_SOCKET_TIMEOUTTIME,
+    CONFIG_SESSION_ADD_DELAY,
+    CONFIG_GAME_TYPE,
+    CONFIG_REALM_ZONE,
+    CONFIG_STRICT_PLAYER_NAMES,
+    CONFIG_STRICT_CHARTER_NAMES,
+    CONFIG_STRICT_PET_NAMES,
+    CONFIG_MIN_PLAYER_NAME,
+    CONFIG_MIN_CHARTER_NAME,
+    CONFIG_MIN_PET_NAME,
+    CONFIG_CHARACTER_CREATING_DISABLED,
+    CONFIG_CHARACTER_CREATING_DISABLED_RACEMASK,
+    CONFIG_CHARACTER_CREATING_DISABLED_CLASSMASK,
+    CONFIG_CHARACTERS_PER_ACCOUNT,
+    CONFIG_CHARACTERS_PER_REALM,
+    CONFIG_HEROIC_CHARACTERS_PER_REALM,
+    CONFIG_CHARACTER_CREATING_MIN_LEVEL_FOR_HEROIC_CHARACTER,
+    CONFIG_SKIP_CINEMATICS,
+    CONFIG_MAX_PLAYER_LEVEL,
+    CONFIG_MIN_DUALSPEC_LEVEL,
+    CONFIG_START_PLAYER_LEVEL,
+    CONFIG_START_HEROIC_PLAYER_LEVEL,
+    CONFIG_START_PLAYER_MONEY,
+    CONFIG_CURRENCY_START_JUSTICE_POINTS,
+    CONFIG_CURRENCY_MAX_JUSTICE_POINTS,
+    CONFIG_CURRENCY_START_VALOR_POINTS,
+    CONFIG_CURRENCY_START_HONOR_POINTS,
+    CONFIG_CURRENCY_MAX_HONOR_POINTS,
+    CONFIG_CURRENCY_START_CONQUEST_POINTS,
+    CONFIG_CURRENCY_CONQUEST_POINTS_WEEK_CAP,
+    CONFIG_CURRENCY_CONQUEST_POINTS_ARENA_REWARD,
+    CONFIG_CURRENCY_RESET_HOUR,
+    CONFIG_CURRENCY_RESET_DAY,
+    CONFIG_CURRENCY_RESET_INTERVAL,
+    CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL,
+    CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL_DIFFERENCE,
+    CONFIG_INSTANCE_RESET_TIME_HOUR,
+    CONFIG_INSTANCE_UNLOAD_DELAY,
+    CONFIG_MAX_PRIMARY_TRADE_SKILL,
+    CONFIG_MIN_PETITION_SIGNS,
+    CONFIG_GM_LOGIN_STATE,
+    CONFIG_GM_VISIBLE_STATE,
+    CONFIG_GM_ACCEPT_TICKETS,
+    CONFIG_GM_CHAT,
+    CONFIG_GM_WHISPERING_TO,
+    CONFIG_GM_LEVEL_IN_GM_LIST,
+    CONFIG_GM_LEVEL_IN_WHO_LIST,
+    CONFIG_START_GM_LEVEL,
+    CONFIG_GROUP_VISIBILITY,
+    CONFIG_MAIL_DELIVERY_DELAY,
+    CONFIG_UPTIME_UPDATE,
+    CONFIG_SKILL_CHANCE_ORANGE,
+    CONFIG_SKILL_CHANCE_YELLOW,
+    CONFIG_SKILL_CHANCE_GREEN,
+    CONFIG_SKILL_CHANCE_GREY,
+    CONFIG_SKILL_CHANCE_MINING_STEPS,
+    CONFIG_SKILL_CHANCE_ARCHAEOLOGY_STEPS,
+    CONFIG_SKILL_CHANCE_SKINNING_STEPS,
+    CONFIG_SKILL_GAIN_CRAFTING,
+    CONFIG_SKILL_GAIN_GATHERING,
+    CONFIG_MAX_OVERSPEED_PINGS,
+    CONFIG_EXPANSION,
+    CONFIG_CHATFLOOD_MESSAGE_COUNT,
+    CONFIG_CHATFLOOD_MESSAGE_DELAY,
+    CONFIG_CHATFLOOD_MUTE_TIME,
+    CONFIG_EVENT_ANNOUNCE,
+    CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY,
+    CONFIG_CREATURE_FAMILY_FLEE_DELAY,
+    CONFIG_WORLD_BOSS_LEVEL_DIFF,
+    CONFIG_QUEST_LOW_LEVEL_HIDE_DIFF,
+    CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF,
+    CONFIG_CHAT_STRICT_LINK_CHECKING_SEVERITY,
+    CONFIG_CHAT_STRICT_LINK_CHECKING_KICK,
+    CONFIG_CHAT_CHANNEL_LEVEL_REQ,
+    CONFIG_CHAT_WHISPER_LEVEL_REQ,
+    CONFIG_CHAT_SAY_LEVEL_REQ,
+    CONFIG_TRADE_LEVEL_REQ,
+    CONFIG_TICKET_LEVEL_REQ,
+    CONFIG_AUCTION_LEVEL_REQ,
+    CONFIG_MAIL_LEVEL_REQ,
+    CONFIG_CORPSE_DECAY_NORMAL,
+    CONFIG_CORPSE_DECAY_RARE,
+    CONFIG_CORPSE_DECAY_ELITE,
+    CONFIG_CORPSE_DECAY_RAREELITE,
+    CONFIG_CORPSE_DECAY_WORLDBOSS,
+    CONFIG_DEATH_SICKNESS_LEVEL,
+    CONFIG_INSTANT_LOGOUT,
+    CONFIG_DISABLE_BREATHING,
+    CONFIG_BATTLEGROUND_INVITATION_TYPE,
+    CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER,
+    CONFIG_BATTLEGROUND_PREMADE_GROUP_WAIT_FOR_MATCH,
+    CONFIG_ARENA_MAX_RATING_DIFFERENCE,
+    CONFIG_ARENA_RATING_DISCARD_TIMER,
+    CONFIG_ARENA_RATED_UPDATE_TIMER,
+    CONFIG_ARENA_SEASON_ID,
+    CONFIG_ARENA_START_RATING,
+    CONFIG_ARENA_START_PERSONAL_RATING,
+    CONFIG_ARENA_START_MATCHMAKER_RATING,
+    CONFIG_MAX_WHO,
+    CONFIG_HONOR_AFTER_DUEL,
+    CONFIG_PVP_TOKEN_MAP_TYPE,
+    CONFIG_PVP_TOKEN_ID,
+    CONFIG_PVP_TOKEN_COUNT,
+    CONFIG_INTERVAL_LOG_UPDATE,
+    CONFIG_MIN_LOG_UPDATE,
+    CONFIG_ENABLE_SINFO_LOGIN,
+    CONFIG_PLAYER_ALLOW_COMMANDS,
+    CONFIG_NUMTHREADS,
+    CONFIG_LOGDB_CLEARINTERVAL,
+    CONFIG_LOGDB_CLEARTIME,
+    CONFIG_CLIENTCACHE_VERSION,
+    CONFIG_GUILD_NEWS_LOG_COUNT,
+    CONFIG_GUILD_EVENT_LOG_COUNT,
+    CONFIG_GUILD_BANK_EVENT_LOG_COUNT,
+    CONFIG_MIN_LEVEL_STAT_SAVE,
+    CONFIG_RANDOM_BG_RESET_HOUR,
+    CONFIG_GUILD_RESET_HOUR,
+    CONFIG_CHARDELETE_KEEP_DAYS,
+    CONFIG_CHARDELETE_METHOD,
+    CONFIG_CHARDELETE_MIN_LEVEL,
+    CONFIG_AUTOBROADCAST_CENTER,
+    CONFIG_AUTOBROADCAST_INTERVAL,
+    CONFIG_MAX_RESULTS_LOOKUP_COMMANDS,
+    CONFIG_DB_PING_INTERVAL,
+    CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
+    CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
+    CONFIG_LFG_OPTIONSMASK,
+	CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION,
+    CONFIG_ANTICHEAT_MAX_REPORTS_FOR_DAILY_REPORT,
+    CONFIG_MAX_INSTANCES_PER_HOUR,
+	CONFIG_ANTICHEAT_DETECTIONS_ENABLED,
+    CONFIG_DOUBLE_MOVING,
+    CONFIG_WARDEN_CLIENT_RESPONSE_DELAY,
+    CONFIG_WARDEN_CLIENT_CHECK_HOLDOFF,
+    CONFIG_WARDEN_CLIENT_FAIL_ACTION,
+    CONFIG_WARDEN_CLIENT_BAN_DURATION,
+    CONFIG_WARDEN_NUM_MEM_CHECKS,
+    CONFIG_WARDEN_NUM_OTHER_CHECKS,
+    CONFIG_WINTERGRASP_PLR_MAX,
+    CONFIG_WINTERGRASP_PLR_MIN,
+    CONFIG_WINTERGRASP_PLR_MIN_LVL,
+    CONFIG_WINTERGRASP_BATTLETIME,
+    CONFIG_WINTERGRASP_NOBATTLETIME,
+    CONFIG_WINTERGRASP_RESTART_AFTER_CRASH,
+    CONFIG_TOL_BARAD_PLR_MAX,
+    CONFIG_TOL_BARAD_PLR_MIN,
+    CONFIG_TOL_BARAD_PLR_MIN_LVL,
+    CONFIG_TOL_BARAD_BATTLETIME,
+    CONFIG_TOL_BARAD_NOBATTLETIME,
+    CONFIG_GUILD_SAVE_INTERVAL,
+    CONFIG_GUILD_MAX_LEVEL,
+    CONFIG_GUILD_UNDELETABLE_LEVEL,
+    CONFIG_GUILD_DAILY_XP_CAP,
+    CONFIG_GUILD_WEEKLY_REP_CAP,
+    CONFIG_GUILD_XP_REWARD_ARENA,
+    CONFIG_GUILD_REPUTATION_QUEST_DIVIDER,
+    CONFIG_GUILD_CHALLENGE_DUNGEON_XP,
+    CONFIG_GUILD_CHALLENGE_DUNGEON_GOLD,
+    CONFIG_GUILD_CHALLENGE_DUNGEON_NEEDED,
+    CONFIG_GUILD_CHALLENGE_RAID_XP,
+    CONFIG_GUILD_CHALLENGE_RAID_GOLD,
+    CONFIG_GUILD_CHALLENGE_RAID_NEEDED,
+    CONFIG_GUILD_CHALLENGE_RATEDBG_XP,
+    CONFIG_GUILD_CHALLENGE_RATEDBG_GOLD,
+    CONFIG_GUILD_CHALLENGE_RATEDBG_NEEDED,
+    CONFIG_DYN_ITEM_GUID_SIZE,
+    CONFIG_DYN_ITEM_SQL_REQUEST_SIZE,
+    CONFIG_HPGOLD_REFRESH_INTERVAL,
+    CONFIG_CRONJOBS_INTERVAL,
+    INT_CONFIG_VALUE_COUNT
+};
+
+/// Server rates
+enum Rates
+{
+    RATE_HEALTH = 0,
+    RATE_POWER_MANA,
+    RATE_POWER_RAGE_INCOME,
+    RATE_POWER_RAGE_LOSS,
+    RATE_POWER_RUNICPOWER_INCOME,
+    RATE_POWER_RUNICPOWER_LOSS,
+    RATE_POWER_FOCUS,
+    RATE_POWER_ENERGY,
+    RATE_SKILL_DISCOVERY,
+    RATE_DROP_ITEM_POOR,
+    RATE_DROP_ITEM_NORMAL,
+    RATE_DROP_ITEM_UNCOMMON,
+    RATE_DROP_ITEM_RARE,
+    RATE_DROP_ITEM_EPIC,
+    RATE_DROP_ITEM_LEGENDARY,
+    RATE_DROP_ITEM_ARTIFACT,
+    RATE_DROP_ITEM_REFERENCED,
+    RATE_DROP_ITEM_REFERENCED_AMOUNT,
+    RATE_DROP_MONEY,
+    RATE_XP_KILL,
+    RATE_XP_QUEST,
+    RATE_XP_QUEST_GUILD_MODIFIER,
+    RATE_XP_BASEKILL_GUILD_MODIFIER,
+    RATE_XP_HEROIC_DUNGEON_GUILD_MODIFIER,
+    RATE_XP_HEROIC_RAID_GUILD_MODIFIER,
+    RATE_XP_HONOR_EARNED_GUILD_MODIFIER,
+    RATE_XP_EXPLORE,
+    RATE_REPAIRCOST,
+    RATE_REPUTATION_GAIN,
+    RATE_REPUTATION_LOWLEVEL_KILL,
+    RATE_REPUTATION_LOWLEVEL_QUEST,
+    RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS,
+    RATE_CREATURE_NORMAL_HP,
+    RATE_CREATURE_ELITE_ELITE_HP,
+    RATE_CREATURE_ELITE_RAREELITE_HP,
+    RATE_CREATURE_ELITE_WORLDBOSS_HP,
+    RATE_CREATURE_ELITE_RARE_HP,
+    RATE_CREATURE_NORMAL_DAMAGE,
+    RATE_CREATURE_ELITE_ELITE_DAMAGE,
+    RATE_CREATURE_ELITE_RAREELITE_DAMAGE,
+    RATE_CREATURE_ELITE_WORLDBOSS_DAMAGE,
+    RATE_CREATURE_ELITE_RARE_DAMAGE,
+    RATE_CREATURE_NORMAL_SPELLDAMAGE,
+    RATE_CREATURE_ELITE_ELITE_SPELLDAMAGE,
+    RATE_CREATURE_ELITE_RAREELITE_SPELLDAMAGE,
+    RATE_CREATURE_ELITE_WORLDBOSS_SPELLDAMAGE,
+    RATE_CREATURE_ELITE_RARE_SPELLDAMAGE,
+    RATE_CREATURE_AGGRO,
+    RATE_REST_INGAME,
+    RATE_REST_OFFLINE_IN_TAVERN_OR_CITY,
+    RATE_REST_OFFLINE_IN_WILDERNESS,
+    RATE_DAMAGE_FALL,
+    RATE_AUCTION_TIME,
+    RATE_AUCTION_DEPOSIT,
+    RATE_AUCTION_CUT,
+    RATE_HONOR,
+    RATE_MINING_AMOUNT,
+    RATE_MINING_NEXT,
+    RATE_ARCHAEOLOGY_AMOUNT,
+    RATE_ARCHAEOLOGY_NEXT,
+    RATE_TALENT,
+    RATE_CORPSE_DECAY_LOOTED,
+    RATE_INSTANCE_RESET_TIME,
+    RATE_TARGET_POS_RECALCULATION_RANGE,
+    RATE_DURABILITY_LOSS_ON_DEATH,
+    RATE_DURABILITY_LOSS_DAMAGE,
+    RATE_DURABILITY_LOSS_PARRY,
+    RATE_DURABILITY_LOSS_ABSORB,
+    RATE_DURABILITY_LOSS_BLOCK,
+    RATE_MOVESPEED,
+    MAX_RATES
+};
+
+/// Can be used in SMSG_AUTH_RESPONSE packet
+enum BillingPlanFlags
+{
+    SESSION_NONE            = 0x00,
+    SESSION_UNUSED          = 0x01,
+    SESSION_RECURRING_BILL  = 0x02,
+    SESSION_FREE_TRIAL      = 0x04,
+    SESSION_IGR             = 0x08,
+    SESSION_USAGE           = 0x10,
+    SESSION_TIME_MIXTURE    = 0x20,
+    SESSION_RESTRICTED      = 0x40,
+    SESSION_ENABLE_CAIS     = 0x80
+};
+
+/// Type of server, this is values from second column of Cfg_Configs.dbc
+enum RealmType
+{
+    REALM_TYPE_NORMAL       = 0,
+    REALM_TYPE_PVP          = 1,
+    REALM_TYPE_NORMAL2      = 4,
+    REALM_TYPE_RP           = 6,
+    REALM_TYPE_RPPVP        = 8,
+    REALM_TYPE_FFA_PVP      = 16                            // custom, free for all pvp mode like arena PvP in all zones except rest activated places and sanctuaries
+                                                            // replaced by REALM_PVP in realm list
+};
+
+enum RealmZone
+{
+    REALM_ZONE_UNKNOWN       = 0,                           // any language
+    REALM_ZONE_DEVELOPMENT   = 1,                           // any language
+    REALM_ZONE_UNITED_STATES = 2,                           // extended-Latin
+    REALM_ZONE_OCEANIC       = 3,                           // extended-Latin
+    REALM_ZONE_LATIN_AMERICA = 4,                           // extended-Latin
+    REALM_ZONE_TOURNAMENT_5  = 5,                           // basic-Latin at create, any at login
+    REALM_ZONE_KOREA         = 6,                           // East-Asian
+    REALM_ZONE_TOURNAMENT_7  = 7,                           // basic-Latin at create, any at login
+    REALM_ZONE_ENGLISH       = 8,                           // extended-Latin
+    REALM_ZONE_GERMAN        = 9,                           // extended-Latin
+    REALM_ZONE_FRENCH        = 10,                          // extended-Latin
+    REALM_ZONE_SPANISH       = 11,                          // extended-Latin
+    REALM_ZONE_RUSSIAN       = 12,                          // Cyrillic
+    REALM_ZONE_TOURNAMENT_13 = 13,                          // basic-Latin at create, any at login
+    REALM_ZONE_TAIWAN        = 14,                          // East-Asian
+    REALM_ZONE_TOURNAMENT_15 = 15,                          // basic-Latin at create, any at login
+    REALM_ZONE_CHINA         = 16,                          // East-Asian
+    REALM_ZONE_CN1           = 17,                          // basic-Latin at create, any at login
+    REALM_ZONE_CN2           = 18,                          // basic-Latin at create, any at login
+    REALM_ZONE_CN3           = 19,                          // basic-Latin at create, any at login
+    REALM_ZONE_CN4           = 20,                          // basic-Latin at create, any at login
+    REALM_ZONE_CN5           = 21,                          // basic-Latin at create, any at login
+    REALM_ZONE_CN6           = 22,                          // basic-Latin at create, any at login
+    REALM_ZONE_CN7           = 23,                          // basic-Latin at create, any at login
+    REALM_ZONE_CN8           = 24,                          // basic-Latin at create, any at login
+    REALM_ZONE_TOURNAMENT_25 = 25,                          // basic-Latin at create, any at login
+    REALM_ZONE_TEST_SERVER   = 26,                          // any language
+    REALM_ZONE_TOURNAMENT_27 = 27,                          // basic-Latin at create, any at login
+    REALM_ZONE_QA_SERVER     = 28,                          // any language
+    REALM_ZONE_CN9           = 29,                          // basic-Latin at create, any at login
+    REALM_ZONE_TEST_SERVER_2 = 30,                          // any language
+    REALM_ZONE_CN10          = 31,                          // basic-Latin at create, any at login
+    REALM_ZONE_CTC           = 32,
+    REALM_ZONE_CNC           = 33,
+    REALM_ZONE_CN1_4         = 34,                          // basic-Latin at create, any at login
+    REALM_ZONE_CN2_6_9       = 35,                          // basic-Latin at create, any at login
+    REALM_ZONE_CN3_7         = 36,                          // basic-Latin at create, any at login
+    REALM_ZONE_CN5_8         = 37                           // basic-Latin at create, any at login
+};
+
+enum WorldStates
+{
+    WS_WEEKLY_QUEST_RESET_TIME  = 20002,                     // Next weekly reset time
+    WS_BG_DAILY_RESET_TIME      = 20003,                     // Next daily BG reset time
+    WS_CLEANING_FLAGS           = 20004,                     // Cleaning Flags
+    WS_GUILD_DAILY_RESET_TIME   = 20006,                     // Next guild cap reset time
+    WS_MONTHLY_QUEST_RESET_TIME = 20007,                     // Next monthly reset time
+    // Cata specific custom worldstates
+    WS_GUILD_WEEKLY_RESET_TIME  = 20050,                     // Next guild week reset time
+};
+
+/// Storage class for commands issued for delayed execution
+struct CliCommandHolder
+{
+    typedef void Print(void*, const char*);
+    typedef void CommandFinished(void*, bool success);
+
+    void* m_callbackArg;
+    char *m_command;
+    Print* m_print;
+
+    CommandFinished* m_commandFinished;
+
+    CliCommandHolder(void* callbackArg, const char *command, Print* zprint, CommandFinished* commandFinished)
+        : m_callbackArg(callbackArg), m_print(zprint), m_commandFinished(commandFinished)
+    {
+        size_t len = strlen(command)+1;
+        m_command = new char[len];
+        memcpy(m_command, command, len);
+    }
+
+    ~CliCommandHolder() { delete[] m_command; }
+};
+
+typedef UNORDERED_MAP<uint32, WorldSession*> SessionMap;
+
+struct CharacterNameData
+{
+    std::string m_name;
+    uint8 m_class;
+    uint8 m_race;
+    uint8 m_gender;
+    uint8 m_level;
+};
+
+/// The World
+class World
+{
+    public:
+        static volatile uint32 m_worldLoopCounter;
+
+        World();
+        ~World();
+
+        WorldSession* FindSession(uint32 id) const;
+        void AddSession(WorldSession* s);
+        void SendAutoBroadcast();
+        bool RemoveSession(uint32 id);
+        /// Get the number of current active sessions
+        void UpdateMaxSessionCounters();
+        const SessionMap& GetAllSessions() const { return m_sessions; }
+        uint32 GetActiveAndQueuedSessionCount() const { return m_sessions.size(); }
+        uint32 GetActiveSessionCount() const { return m_sessions.size() - m_QueuedPlayer.size(); }
+        uint32 GetQueuedSessionCount() const { return m_QueuedPlayer.size(); }
+        /// Get the maximum number of parallel sessions on the server since last reboot
+        uint32 GetMaxQueuedSessionCount() const { return m_maxQueuedSessionCount; }
+        uint32 GetMaxActiveSessionCount() const { return m_maxActiveSessionCount; }
+        /// Get number of players
+        inline uint32 GetPlayerCount() const { return m_PlayerCount; }
+        inline uint32 GetMaxPlayerCount() const { return m_MaxPlayerCount; }
+        /// Increase/Decrease number of players
+        inline void IncreasePlayerCount()
+        {
+            m_PlayerCount++;
+            m_MaxPlayerCount = std::max(m_MaxPlayerCount, m_PlayerCount);
+        }
+        inline void DecreasePlayerCount() { m_PlayerCount--; }
+
+        Player* FindPlayerInZone(uint32 zone);
+
+        /// Deny clients?
+        bool IsClosed() const;
+
+        /// Close world
+        void SetClosed(bool val);
+
+        /// Security level limitations
+        AccountTypes GetPlayerSecurityLimit() const { return m_allowedSecurityLevel; }
+        void SetPlayerSecurityLimit(AccountTypes sec);
+        void LoadDBAllowedSecurityLevel();
+
+        /// Active session server limit
+        void SetPlayerAmountLimit(uint32 limit) { m_playerLimit = limit; }
+        uint32 GetPlayerAmountLimit() const { return m_playerLimit; }
+
+        //player Queue
+        typedef std::list<WorldSession*> Queue;
+        void AddQueuedPlayer(WorldSession*);
+        bool RemoveQueuedPlayer(WorldSession* session);
+        int32 GetQueuePos(WorldSession*);
+        bool HasRecentlyDisconnected(WorldSession*);
+
+        /// \todo Actions on m_allowMovement still to be implemented
+        /// Is movement allowed?
+        bool getAllowMovement() const { return m_allowMovement; }
+        /// Allow/Disallow object movements
+        void SetAllowMovement(bool allow) { m_allowMovement = allow; }
+
+        /// Set a new Message of the Day
+        void SetMotd(std::string const& motd);
+        /// Get the current Message of the Day
+        const char* GetMotd() const;
+
+        /// Set the string for new characters (first login)
+        void SetNewCharString(std::string const& str) { m_newCharString = str; }
+        /// Get the string for new characters (first login)
+        std::string const& GetNewCharString() const { return m_newCharString; }
+
+        LocaleConstant GetDefaultDbcLocale() const { return m_defaultDbcLocale; }
+
+        /// Get the path where data (dbc, maps) are stored on disk
+        std::string const& GetDataPath() const { return m_dataPath; }
+
+        /// When server started?
+        time_t const& GetStartTime() const { return m_startTime; }
+        /// What time is it?
+        time_t const& GetGameTime() const { return m_gameTime; }
+        /// Uptime (in secs)
+        uint32 GetUptime() const { return uint32(m_gameTime - m_startTime); }
+        /// Update time
+        uint32 GetUpdateTime() const { return m_updateTime; }
+        void SetRecordDiffInterval(int32 t) { if (t >= 0) m_int_configs[CONFIG_INTERVAL_LOG_UPDATE] = (uint32)t; }
+
+        /// Next daily quests and random bg reset time
+        time_t GetNextDailyQuestsResetTime() const { return m_NextDailyQuestReset; }
+        time_t GetNextWeeklyQuestsResetTime() const { return m_NextWeeklyQuestReset; }
+        time_t GetNextRandomBGResetTime() const { return m_NextRandomBGReset; }
+
+        /// Get the maximum skill level a player can reach
+        uint16 GetConfigMaxSkillValue() const
+        {
+            uint8 lvl = uint8(getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
+            return lvl > 60 ? 300 + ((lvl - 60) * 75) / 10 : lvl * 5;
+        }
+
+        void SetInitialWorldSettings();
+        void LoadConfigSettings(bool reload = false);
+
+        void SendWorldText(int32 string_id, ...);
+        void SendGlobalText(const char* text, WorldSession* self);
+        void SendGMText(int32 string_id, ...);
+        void SendGlobalMessage(WorldPacket* packet, WorldSession* self = 0, uint32 team = 0);
+        void SendGlobalGMMessage(WorldPacket* packet, WorldSession* self = 0, uint32 team = 0);
+        void SendZoneMessage(uint32 zone, WorldPacket* packet, WorldSession* self = 0, uint32 team = 0);
+        void SendZoneText(uint32 zone, const char *text, WorldSession* self = 0, uint32 team = 0);
+        void SendServerMessage(ServerMessageType type, const char *text = "", Player* player = NULL);
+
+        /// Are we in the middle of a shutdown?
+        bool IsShuttingDown() const { return m_ShutdownTimer > 0; }
+        uint32 GetShutDownTimeLeft() const { return m_ShutdownTimer; }
+        void ShutdownServ(uint32 time, uint32 options, uint8 exitcode);
+        void ShutdownCancel();
+        void ShutdownMsg(bool show = false, Player* player = NULL);
+        static uint8 GetExitCode() { return m_ExitCode; }
+        static void StopNow(uint8 exitcode) { m_stopEvent = true; m_ExitCode = exitcode; }
+        static bool IsStopped() { return m_stopEvent.value(); }
+
+        std::string ShutdownReason; 
+        void SetShutdownMessage(std::string reason) { ShutdownReason = reason; }
+
+        void Update(uint32 diff);
+
+        void UpdateSessions(uint32 diff);
+        /// Set a server rate (see #Rates)
+        void setRate(Rates rate, float value) { rate_values[rate]=value; }
+        /// Get a server rate (see #Rates)
+        float getRate(Rates rate) const { return rate_values[rate]; }
+
+        /// Set a server configuration element (see #WorldConfigs)
+        void setBoolConfig(WorldBoolConfigs index, bool value)
+        {
+            if (index < BOOL_CONFIG_VALUE_COUNT)
+                m_bool_configs[index] = value;
+        }
+
+        /// Get a server configuration element (see #WorldConfigs)
+        bool getBoolConfig(WorldBoolConfigs index) const
+        {
+            return index < BOOL_CONFIG_VALUE_COUNT ? m_bool_configs[index] : 0;
+        }
+
+        /// Set a server configuration element (see #WorldConfigs)
+        void setFloatConfig(WorldFloatConfigs index, float value)
+        {
+            if (index < FLOAT_CONFIG_VALUE_COUNT)
+                m_float_configs[index] = value;
+        }
+
+        /// Get a server configuration element (see #WorldConfigs)
+        float getFloatConfig(WorldFloatConfigs index) const
+        {
+            return index < FLOAT_CONFIG_VALUE_COUNT ? m_float_configs[index] : 0;
+        }
+
+        /// Set a server configuration element (see #WorldConfigs)
+        void setIntConfig(WorldIntConfigs index, uint32 value)
+        {
+            if (index < INT_CONFIG_VALUE_COUNT)
+                m_int_configs[index] = value;
+        }
+
+        /// Get a server configuration element (see #WorldConfigs)
+        uint32 getIntConfig(WorldIntConfigs index) const
+        {
+            return index < INT_CONFIG_VALUE_COUNT ? m_int_configs[index] : 0;
+        }
+
+        void setWorldState(uint32 index, uint64 value);
+        uint64 getWorldState(uint32 index) const;
+        void LoadWorldStates();
+
+        /// Are we on a "Player versus Player" server?
+        bool IsPvPRealm() const { return (getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_PVP || getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_RPPVP || getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_FFA_PVP); }
+        bool IsFFAPvPRealm() const { return getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_FFA_PVP; }
+
+        void KickAll();
+        void KickAllLess(AccountTypes sec);
+        BanReturn BanAccount(BanMode mode, std::string const& nameOrIP, std::string const& duration, std::string const& reason, std::string const& author);
+        bool RemoveBanAccount(BanMode mode, std::string const& nameOrIP);
+        BanReturn BanCharacter(std::string const& name, std::string const& duration, std::string const& reason, std::string const& author);
+        bool RemoveBanCharacter(std::string const& name);
+
+        // for max speed access
+        static float GetMaxVisibleDistanceOnContinents()    { return m_MaxVisibleDistanceOnContinents; }
+        static float GetMaxVisibleDistanceInInstances()     { return m_MaxVisibleDistanceInInstances;  }
+        static float GetMaxVisibleDistanceInBGArenas()      { return m_MaxVisibleDistanceInBGArenas;   }
+
+        static int32 GetVisibilityNotifyPeriodOnContinents(){ return m_visibility_notify_periodOnContinents; }
+        static int32 GetVisibilityNotifyPeriodInInstances() { return m_visibility_notify_periodInInstances;  }
+        static int32 GetVisibilityNotifyPeriodInBGArenas()  { return m_visibility_notify_periodInBGArenas;   }
+
+        void ProcessCliCommands();
+        void QueueCliCommand(CliCommandHolder* commandHolder) { cliCmdQueue.add(commandHolder); }
+
+        void ForceGameEventUpdate();
+
+        void UpdateRealmCharCount(uint32 accid);
+
+        LocaleConstant GetAvailableDbcLocale(LocaleConstant locale) const { if (m_availableDbcLocaleMask & (1 << locale)) return locale; else return m_defaultDbcLocale; }
+
+        // used World DB version
+        void LoadDBVersion();
+        char const* GetDBVersion() const { return m_DBVersion.c_str(); }
+
+        void RecordTimeDiff(const char * text, ...);
+
+        void LoadAutobroadcasts();
+
+        void UpdateAreaDependentAuras();
+
+        CharacterNameData const* GetCharacterNameData(uint32 guid) const;
+        void AddCharacterNameData(uint32 guid, std::string const& name, uint8 gender, uint8 race, uint8 playerClass, uint8 level);
+        void UpdateCharacterNameData(uint32 guid, std::string const& name, uint8 gender = GENDER_NONE, uint8 race = RACE_NONE);
+        void UpdateCharacterNameDataLevel(uint32 guid, uint8 level);
+
+        void ProcessStartEvent();
+        void ProcessStopEvent();
+        bool GetEventKill() const { return isEventKillStart; }
+
+        bool isEventKillStart;
+
+        uint32 GetCleaningFlags() const { return m_CleaningFlags; }
+        void   SetCleaningFlags(uint32 flags) { m_CleaningFlags = flags; }
+        void   ResetEventSeasonalQuests(uint16 event_id);
+
+        void UpdatePhaseDefinitions();
+        void ExecuteCronjobs();
+
+    protected:
+        void _UpdateGameTime();
+        // callback for UpdateRealmCharacters
+        void _UpdateRealmCharCount(PreparedQueryResult resultCharCount);
+
+        void InitPacketThrottling();
+        void InitDailyQuestResetTime();
+        void InitWeeklyQuestResetTime();
+        void InitMonthlyQuestResetTime();
+        void InitRandomBGResetTime();
+        void InitGuildResetTime();
+        void InitCurrencyResetTime();
+        void ResetDailyQuests();
+        void ResetWeeklyQuests();
+        void ResetMonthlyQuests();
+        void ResetRandomBG();
+        void ResetGuildCap();
+        void ResetCurrencyWeekCap();
+    private:
+        static ACE_Atomic_Op<ACE_Thread_Mutex, bool> m_stopEvent;
+        static uint8 m_ExitCode;
+        uint32 m_ShutdownTimer;
+        uint32 m_ShutdownMask;
+
+        uint32 m_CleaningFlags;
+
+        bool m_isClosed;
+
+        time_t m_startTime;
+        time_t m_gameTime;
+        IntervalTimer m_timers[WUPDATE_COUNT];
+        time_t mail_timer;
+        time_t mail_timer_expires;
+        uint32 m_updateTime, m_updateTimeSum;
+        uint32 m_updateTimeCount;
+        uint32 m_currentTime;
+
+        SessionMap m_sessions;
+        typedef UNORDERED_MAP<uint32, time_t> DisconnectMap;
+        DisconnectMap m_disconnects;
+        uint32 m_maxActiveSessionCount;
+        uint32 m_maxQueuedSessionCount;
+        uint32 m_PlayerCount;
+        uint32 m_MaxPlayerCount;
+
+        std::string m_newCharString;
+
+        float rate_values[MAX_RATES];
+        uint32 m_int_configs[INT_CONFIG_VALUE_COUNT];
+        bool m_bool_configs[BOOL_CONFIG_VALUE_COUNT];
+        float m_float_configs[FLOAT_CONFIG_VALUE_COUNT];
+        typedef std::map<uint32, uint64> WorldStatesMap;
+        WorldStatesMap m_worldstates;
+        uint32 m_playerLimit;
+        AccountTypes m_allowedSecurityLevel;
+        LocaleConstant m_defaultDbcLocale;                     // from config for one from loaded DBC locales
+        uint32 m_availableDbcLocaleMask;                       // by loaded DBC
+        void DetectDBCLang();
+        bool m_allowMovement;
+        std::string m_motd;
+        std::string m_dataPath;
+
+        // for max speed access
+        static float m_MaxVisibleDistanceOnContinents;
+        static float m_MaxVisibleDistanceInInstances;
+        static float m_MaxVisibleDistanceInBGArenas;
+
+        static int32 m_visibility_notify_periodOnContinents;
+        static int32 m_visibility_notify_periodInInstances;
+        static int32 m_visibility_notify_periodInBGArenas;
+
+        // CLI command holder to be thread safe
+        ACE_Based::LockedQueue<CliCommandHolder*, ACE_Thread_Mutex> cliCmdQueue;
+
+        // scheduled reset times
+        time_t m_NextDailyQuestReset;
+        time_t m_NextWeeklyQuestReset;
+        time_t m_NextMonthlyQuestReset;
+        time_t m_NextRandomBGReset;
+        time_t m_NextGuildReset;
+        time_t m_NextCurrencyReset;
+
+        //Player Queue
+        Queue m_QueuedPlayer;
+
+        // sessions that are added async
+        void AddSession_(WorldSession* s);
+        ACE_Based::LockedQueue<WorldSession*, ACE_Thread_Mutex> addSessQueue;
+
+        // used versions
+        std::string m_DBVersion;
+
+        std::list<std::string> m_Autobroadcasts;
+		
+        std::map<uint32, CharacterNameData> _characterNameDataMap;
+        void LoadCharacterNameData();
+
+        void ProcessQueryCallbacks();
+        ACE_Future_Set<PreparedQueryResult> m_realmCharCallbacks;
+};
+
+extern uint32 realmID;
+
+#define sWorld ACE_Singleton<World, ACE_Null_Mutex>::instance()
+#endif
+/// @}
diff --git a/src/server/scripts/Custom/npc_arena1v1.cpp b/src/server/scripts/Custom/npc_arena1v1.cpp
new file mode 100644
index 0000000..b90cc56
--- /dev/null
+++ b/src/server/scripts/Custom/npc_arena1v1.cpp
@@ -0,0 +1,309 @@
+/*
+ *
+ * Copyright (C) 2013 Emu-Devstore <http://emu-devstore.com/>
+ * Written by Teiby <http://www.teiby.de/>
+ *
+ */
+
+#include "ScriptMgr.h"
+#include "ArenaTeamMgr.h"
+#include "Common.h"
+#include "DisableMgr.h"
+#include "BattlegroundMgr.h"
+#include "Battleground.h"
+#include "ArenaTeam.h"
+#include "Language.h"
+#include "npc_arena1v1.h"
+
+
+class npc_1v1arena : public CreatureScript
+{
+public:
+    npc_1v1arena() : CreatureScript("npc_1v1arena")
+    {
+    }
+
+
+    bool JoinQueueArena(Player* player, Creature* me, bool isRated)
+    {
+        if(!player || !me)
+            return false;
+
+        if(sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL) > player->getLevel())
+            return false;
+
+        ObjectGuid guid = player->GetGUID();
+        uint8 arenaslot = ArenaTeam::GetSlotByType(ARENA_TEAM_5v5);
+        uint8 arenatype = ARENA_TYPE_5v5;
+        uint32 arenaRating = 0;
+        uint32 matchmakerRating = 0;
+
+        // ignore if we already in BG or BG queue
+        if (player->InBattleground())
+            return false;
+
+        //check existance
+        Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(BATTLEGROUND_AA);
+        if (!bg)
+        {
+            sLog->outError(LOG_FILTER_SQL, "Battleground: template bg (all arenas) not found");
+            return false;
+        }
+
+        if (DisableMgr::IsDisabledFor(DISABLE_TYPE_BATTLEGROUND, BATTLEGROUND_AA, NULL))
+        {
+            ChatHandler(player->GetSession()).PSendSysMessage(LANG_ARENA_DISABLED);
+            return false;
+        }
+
+        BattlegroundTypeId bgTypeId = bg->GetTypeID();
+        BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(bgTypeId, arenatype);
+        PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bg->GetMapId(), player->getLevel());
+        if (!bracketEntry)
+            return false;
+
+        GroupJoinBattlegroundResult err = ERR_BATTLEGROUND_JOIN_FAILED;
+
+        // check if already in queue
+        if (player->GetBattlegroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES)
+            //player is already in this queue
+            return false;
+        // check if has free queue slots
+        if (!player->HasFreeBattlegroundQueueId())
+            return false;
+
+        uint32 ateamId = 0;
+
+        if(isRated)
+        {
+            ateamId = player->GetArenaTeamId(arenaslot);
+            ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(ateamId);
+            if (!at)
+            {
+                player->GetSession()->SendNotInArenaTeamPacket(arenatype);
+                return false;
+            }
+
+            // get the team rating for queueing
+            arenaRating = at->GetRating();
+            matchmakerRating = arenaRating;
+            // the arenateam id must match for everyone in the group
+
+            if (arenaRating <= 0)
+                arenaRating = 1;
+        }
+
+        BattlegroundQueue &bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+        bg->SetRated(isRated);
+
+        GroupQueueInfo* ginfo = bgQueue.AddGroup(player, NULL, bgTypeId, bracketEntry, arenatype, isRated, false, arenaRating, matchmakerRating, ateamId);
+        uint32 avgTime = bgQueue.GetAverageQueueWaitTime(ginfo, bracketEntry->GetBracketId());
+        uint32 queueSlot = player->AddBattlegroundQueueId(bgQueueTypeId);
+
+        WorldPacket data;
+        // send status packet (in queue)
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, player, queueSlot, STATUS_WAIT_QUEUE, avgTime, 0, arenatype);
+        player->GetSession()->SendPacket(&data);
+
+        sBattlegroundMgr->ScheduleQueueUpdate(matchmakerRating, arenatype, bgQueueTypeId, bgTypeId, bracketEntry->GetBracketId());
+
+        return true;
+    }
+
+
+    bool CreateArenateam(Player* player, Creature* me)
+    {
+        if(!player || !me)
+            return false;
+
+        uint8 slot = ArenaTeam::GetSlotByType(ARENA_TEAM_5v5);
+        if (slot >= MAX_ARENA_SLOT)
+            return false;
+
+        // Check if player is already in an arena team
+        if (player->GetArenaTeamId(slot))
+        {
+            player->GetSession()->SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, player->GetName(), "", ERR_ALREADY_IN_ARENA_TEAM);
+            return false;
+        }
+
+
+        // Teamname = playername
+        // if teamname exist, we have to choose another name (playername + number)
+        int i = 1;
+        std::stringstream teamName;
+        teamName << player->GetName();
+        do
+        {
+            if(sArenaTeamMgr->GetArenaTeamByName(teamName.str()) != NULL) // teamname exist, so choose another name
+            {
+                teamName.str(std::string());
+                teamName << player->GetName() << (i++);
+            }
+            else
+                break;
+        } while (i < 100); // should never happen
+
+        // Create arena team
+        ArenaTeam* arenaTeam = new ArenaTeam();
+
+        if (!arenaTeam->Create(player->GetGUID(), ARENA_TEAM_5v5, teamName.str(), 4283124816, 45, 4294242303, 5, 4294705149))
+        {
+            delete arenaTeam;
+            return false;
+        }
+
+        // Register arena team
+        sArenaTeamMgr->AddArenaTeam(arenaTeam);
+        arenaTeam->AddMember(player->GetGUID());
+
+        ChatHandler(player->GetSession()).SendSysMessage("1v1 Arenateam successful created!");
+
+        return true;
+    }
+
+
+    bool OnGossipHello(Player* player, Creature* me)
+    {
+        if(!player || !me)
+            return true;
+
+        if(sWorld->getBoolConfig(CONFIG_ARENA_1V1_ENABLE) == false)
+        {
+            ChatHandler(player->GetSession()).SendSysMessage("1v1 disabled!");
+            return true;
+        }
+
+        if(player->InBattlegroundQueueForBattlegroundQueueType(BATTLEGROUND_QUEUE_5v5))
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "Leave queue 1v1 Arena", GOSSIP_SENDER_MAIN, 3, "Are you sure?", 0, false);
+        else
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Sign up 1v1 Arena (unrated)", GOSSIP_SENDER_MAIN, 20);
+
+        if(player->GetArenaTeamId(ArenaTeam::GetSlotByType(ARENA_TEAM_5v5)) == 0)
+            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "Create new 1v1 Arenateam", GOSSIP_SENDER_MAIN, 1, "Create 1v1 arenateam?", sWorld->getIntConfig(CONFIG_ARENA_1V1_COSTS), false);
+        else
+        {
+            if(player->InBattlegroundQueueForBattlegroundQueueType(BATTLEGROUND_QUEUE_5v5) == false)
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Sign up 1v1 Arena (rated)", GOSSIP_SENDER_MAIN, 2);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "Disband arenateam", GOSSIP_SENDER_MAIN, 5, "Are you sure?", 0, false);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Show statistics", GOSSIP_SENDER_MAIN, 4);
+        }
+
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Script Info", GOSSIP_SENDER_MAIN, 8);
+        player->SEND_GOSSIP_MENU(68, me->GetGUID());
+        return true;
+    }
+
+
+
+    bool OnGossipSelect(Player* player, Creature* me, uint32 /*uiSender*/, uint32 uiAction)
+    {
+        if(!player || !me)
+            return true;
+
+        player->PlayerTalkClass->ClearMenus();
+
+        switch (uiAction)
+        {
+        case 1: // Create new Arenateam
+            {
+                if(sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL) <= player->getLevel())
+                {
+                    if(player->GetMoney() >= sWorld->getIntConfig(CONFIG_ARENA_1V1_COSTS) && CreateArenateam(player, me))
+                        player->ModifyMoney(sWorld->getIntConfig(CONFIG_ARENA_1V1_COSTS) * -1);
+                }
+                else
+                {
+                    ChatHandler(player->GetSession()).PSendSysMessage("You need level %u+ to create an 1v1 arenateam.", sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL));
+                    player->CLOSE_GOSSIP_MENU();
+                    return true;
+                }
+            }
+            break;
+
+        case 2: // Join Queue Arena (rated)
+            {
+                if(Arena1v1CheckTalents(player) && JoinQueueArena(player, me, true) == false)
+                    ChatHandler(player->GetSession()).SendSysMessage("Something went wrong while join queue.");
+
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 20: // Join Queue Arena (unrated)
+            {
+                if(Arena1v1CheckTalents(player) && JoinQueueArena(player, me, false) == false)
+                    ChatHandler(player->GetSession()).SendSysMessage("Something went wrong while join queue.");
+
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 3: // Leave Queue
+            {
+                WorldPacket Data;
+                Data << (uint8)0x1 << (uint8)0x0 << (uint32)BATTLEGROUND_AA << (uint16)0x0 << (uint8)0x0;
+                player->GetSession()->HandleBattleFieldPortOpcode(Data);
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 4: // get statistics
+            {
+                ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(player->GetArenaTeamId(ArenaTeam::GetSlotByType(ARENA_TEAM_5v5)));
+                if(at)
+                {
+                    std::stringstream s;
+                    s << "Rating: " << at->GetStats().Rating;
+                    s << "\nRank: " << at->GetStats().Rank;
+                    s << "\nSeason Games: " << at->GetStats().SeasonGames;
+                    s << "\nSeason Wins: " << at->GetStats().SeasonWins;
+                    s << "\nWeek Games: " << at->GetStats().WeekGames;
+                    s << "\nWeek Wins: " << at->GetStats().WeekWins;
+
+                    ChatHandler(player->GetSession()).PSendSysMessage(s.str().c_str());
+                }
+            }
+            break;
+
+
+        case 5: // Disband arenateam
+            {
+                WorldPacket Data;
+                Data << (uint32)player->GetArenaTeamId(ArenaTeam::GetSlotByType(ARENA_TEAM_5v5));
+                player->GetSession()->HandleArenaTeamLeaveOpcode(Data);
+                ChatHandler(player->GetSession()).SendSysMessage("Arenateam deleted!");
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 8: // Script Info
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Developer: Teiby", GOSSIP_SENDER_MAIN, uiAction);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Website: www.teiby.de", GOSSIP_SENDER_MAIN, uiAction);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Version: 2.1", GOSSIP_SENDER_MAIN, uiAction);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<-- Back", GOSSIP_SENDER_MAIN, 7);
+                player->SEND_GOSSIP_MENU(68, me->GetGUID());
+                return true;
+            }
+            break;
+
+        }
+
+        OnGossipHello(player, me);
+        return true;
+    }
+};
+
+
+void AddSC_npc_1v1arena()
+{
+    new npc_1v1arena();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/npc_arena1v1.h b/src/server/scripts/Custom/npc_arena1v1.h
new file mode 100644
index 0000000..caa75a2
--- /dev/null
+++ b/src/server/scripts/Custom/npc_arena1v1.h
@@ -0,0 +1,69 @@
+/*
+ *
+ * Copyright (C) 2013 Emu-Devstore <http://emu-devstore.com/>
+ * Written by Teiby <http://www.teiby.de/>
+ *
+ */
+
+#ifndef ARENA_1V1_H
+#define ARENA_1V1_H
+
+// TalentTab.dbc -> TalentTabID
+const uint32 FORBIDDEN_TALENTS_IN_1V1_ARENA[] =
+{
+    // Healer
+    201, // PriestDiscipline
+    202, // PriestHoly
+    382, // PaladinHoly
+    262, // ShamanRestoration
+    282, // DruidRestoration
+
+    // Tanks
+    //383, // PaladinProtection
+    //163, // WarriorProtection
+
+    0 // End
+};
+
+
+// Return false, if player have invested more than 35 talentpoints in a forbidden talenttree.
+static bool Arena1v1CheckTalents(Player* player)
+{
+    if(!player)
+        return false;
+
+    if(sWorld->getBoolConfig(CONFIG_ARENA_1V1_BLOCK_FORBIDDEN_TALENTS) == false)
+        return true;
+
+    uint32 count = 0;
+    for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
+    {
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+
+        if (!talentInfo)
+            continue;
+
+        for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+        {
+            if (talentInfo->RankID[rank] == 0)
+                continue;
+
+            if (player->HasTalent(talentInfo->RankID[rank], player->GetActiveSpec()))
+            {
+                for(int8 i = 0; FORBIDDEN_TALENTS_IN_1V1_ARENA[i] != 0; i++)
+                    if(FORBIDDEN_TALENTS_IN_1V1_ARENA[i] == talentInfo->TalentTab)
+                        count += rank + 1;
+            }
+        }
+    }
+
+    if(count >= 36)
+    {
+        ChatHandler(player->GetSession()).SendSysMessage("You can't join, because you have invested too many points in a forbidden talent. Please edit your talents.");
+        return false;
+    }
+    else
+        return true;
+}
+
+#endif
\ No newline at end of file
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 7fce026..c7ff5e2 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2380,6 +2380,71 @@ ArenaLog.ExtendedInfo = 0
 
 #
 ###################################################################################################
+# 1V1 ARENA CONFIG
+#
+#     Arena.1v1.Enable
+#         Description: Enable the 1v1 arena.
+#         Default:     0 - (Disabled)
+#                      1 - (Enabled)
+
+Arena.1v1.Enable = 1
+
+#
+#    Arena.1v1.Announcer
+#        Description: Announce 1v1 arena queue status to chat.
+#                      Arena.QueueAnnouncer.Enable must be enabled.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Arena.1v1.Announcer = 0
+
+#
+#    Arena.1v1.MinLevel
+#        Description: Min level to create an arena team
+#        Default:     80
+
+Arena.1v1.MinLevel = 80
+
+#
+#    Arena.1v1.Costs
+#        Description: Costs for create an arena team
+#        Default:     400000 - (40 gold)
+
+Arena.1v1.Costs = 400000
+
+#
+#    Arena.1v1.VendorRating
+#        Description: If true, 1v1 rating will use to calculate highest personal-rating (extended costs).
+#                      Note: The vendor-item will show as not buyable (red), but players can buy it, if enabled and rating is high enough.
+#        Default:     0 - (false)
+#                      1 - (true)
+
+Arena.1v1.VendorRating = 0
+
+#
+#    Arena.1v1.ArenaPointsMulti
+#        Description: An 5v5 arena team with 1500 rating will gain 344 points per week (blizzlike).
+#                      3v3 with same rating will gain 302 points (5v5points * 0.88)
+#                      2v2 will gain 261 points (5v5points * 0.76)
+#                      and 1v1 will gain 167 points (5v5points * 0.64)
+#                      With this multiplier you can modify the arenapoints for 1v1.
+#        Default:     0.64
+
+Arena.1v1.ArenaPointsMulti = 0.64
+
+#
+#    Arena.1v1.BlockForbiddenTalents
+#        Description: If true, healers can't join 1v1 arena, if they invested more than 35 talentpoints in a healing-talenttree.
+#                      You can also block tanks and other talents, if you modify FORBIDDEN_TALENTS_IN_1V1_ARENA in the npc_arena1v1.h file (hardcoding). See TalentTab.dbc for available talents (you will need an DBC-Editor).
+#        Default:     1 - (true)
+#                      0 - (false)
+
+Arena.1v1.BlockForbiddenTalents = 1
+
+#
+###################################################################################################
+
+###################################################################################################
 
 ###################################################################################################
 # NETWORK CONFIG
diff --git a/src/server/worldserver/worldserver.conf.dist.orig b/src/server/worldserver/worldserver.conf.dist.orig
new file mode 100644
index 0000000..7fce026
--- /dev/null
+++ b/src/server/worldserver/worldserver.conf.dist.orig
@@ -0,0 +1,3195 @@
+################################################
+# Trinity Core World Server configuration file #
+################################################
+[worldserver]
+
+###################################################################################################
+# SECTION INDEX
+#
+#    EXAMPLE CONFIG
+#    CONNECTIONS AND DIRECTORIES
+#    PERFORMANCE SETTINGS
+#    SERVER LOGGING
+#    SERVER SETTINGS
+#    WARDEN SETTINGS
+#    PLAYER INTERACTION
+#    CREATURE SETTINGS
+#    CHAT SETTINGS
+#    GAME MASTER SETTINGS
+#    VISIBILITY AND DISTANCES
+#    SERVER RATES
+#    AUTO BROADCAST
+#    BATTLEGROUND CONFIG
+#    BATTLEFIELD CONFIG
+#    ARENA CONFIG
+#    NETWORK CONFIG
+#    CONSOLE AND REMOTE ACCESS
+#    CHARACTER DELETE OPTIONS
+#    CUSTOM SERVER OPTIONS
+#    LOGGING SYSTEM SETTINGS
+#    CURRENCIES SETTINGS
+#    CUSTOM CONTENT WOW-SOURCES SETTINGS
+#
+###################################################################################################
+
+###################################################################################################
+# EXAMPLE CONFIG
+#
+#    Variable
+#        Description: Brief description what the variable is doing.
+#        Important:   Annotation for important things about this variable.
+#        Example:     "Example, i.e. if the value is a string"
+#        Default:     10 - (Enabled|Comment|Variable name in case of grouped config options)
+#                     0  - (Disabled|Comment|Variable name in case of grouped config options)
+#
+# Note to developers:
+# - Copy this example to keep the formatting.
+# - Line breaks should be at column 100.
+###################################################################################################
+
+###################################################################################################
+# CONNECTIONS AND DIRECTORIES
+#
+#    RealmID
+#        Description: ID of the Realm using this config.
+#        Important:   RealmID must match the realmlist inside the auth database.
+#        Default:     1
+
+RealmID = 1
+
+#
+#    DataDir
+#        Description: Data directory setting.
+#        Important:   DataDir needs to be quoted, as the string might contain space characters.
+#        Example:     "@prefix@/share/trinitycore"
+#        Default:     "."
+
+DataDir = "."
+
+#
+#    LogsDir
+#        Description: Logs directory setting.
+#        Important:   LogsDir needs to be quoted, as the string might contain space characters.
+#                     Logs directory must exists, or log file creation will be disabled.
+#        Default:     "" - (Log files will be stored in the current path)
+
+LogsDir = "logs"
+
+#
+#    LoginDatabaseInfo
+#    WorldDatabaseInfo
+#    CharacterDatabaseInfo
+#        Description: Database connection settings for the world server.
+#        Example:     "hostname;port;username;ascent;database"
+#                     ".;somenumber;username;ascent;database" - (Use named pipes on Windows
+#                                                                 "enable-named-pipe" to [mysqld]
+#                                                                 section my.ini)
+#                     ".;/path/to/unix_socket;username;ascent;database" - (use Unix sockets on
+#                                                                           Unix/Linux)
+#        Default:     "127.0.0.1;3306;root;ascent;auth"       - (LoginDatabaseInfo)
+#                     "127.0.0.1;3306;root;ascent;world"      - (WorldDatabaseInfo)
+#                     "127.0.0.1;3306;root;ascent;characters" - (CharacterDatabaseInfo)
+
+LoginDatabaseInfo     = "127.0.0.1;3306;root;ascent;auth"
+WorldDatabaseInfo     = "127.0.0.1;3306;root;ascent;world"
+CharacterDatabaseInfo = "127.0.0.1;3306;root;ascent;characters"
+
+#
+#    LoginDatabase.WorkerThreads
+#    WorldDatabase.WorkerThreads
+#    CharacterDatabase.WorkerThreads
+#        Description: The amount of worker threads spawned to handle asynchronous (delayed) MySQL
+#                     statements. Each worker thread is mirrored with its own connection to the
+#                     MySQL server and their own thread on the MySQL server.
+#        Default:     1 - (LoginDatabase.WorkerThreads)
+#                     1 - (WorldDatabase.WorkerThreads)
+#                     1 - (CharacterDatabase.WorkerThreads)
+
+LoginDatabase.WorkerThreads     = 1
+WorldDatabase.WorkerThreads     = 1
+CharacterDatabase.WorkerThreads = 1
+HomepageDatabase.WorkerThreads  = 2
+
+#
+#    LoginDatabase.SynchThreads
+#    WorldDatabase.SynchThreads
+#    CharacterDatabase.SynchThreads
+#        Description: The amount of MySQL connections spawned to handle.
+#        Default:     1 - (LoginDatabase.WorkerThreads)
+#                     1 - (WorldDatabase.WorkerThreads)
+#                     2 - (CharacterDatabase.WorkerThreads)
+
+LoginDatabase.SynchThreads     = 1
+WorldDatabase.SynchThreads     = 1
+CharacterDatabase.SynchThreads = 2
+HomepageDatabase.SynchThreads  = 2
+
+#
+#    MaxPingTime
+#        Description: Time (in minutes) between database pings.
+#        Default:     30
+
+MaxPingTime = 30
+
+#
+#    WorldServerPort
+#        Description: TCP port to reach the world server.
+#        Default:     8085
+
+WorldServerPort = 8085
+
+#
+#    BindIP
+#        Description: Bind world server to IP/hostname
+#        Default:     "0.0.0.0" - (Bind to all IPs on the system)
+
+BindIP = "0.0.0.0"
+
+#
+###################################################################################################
+
+###################################################################################################
+# PERFORMANCE SETTINGS
+#
+#    UseProcessors
+#        Description: Processors mask for Windows based multi-processor systems.
+#        Default:     0  - (Selected by OS)
+#                     1+ - (Bit mask value of selected processors)
+
+UseProcessors = 0
+
+#
+#    ProcessPriority
+#        Description: Process priority setting for Windows based systems.
+#        Default:     1 - (High)
+#                     0 - (Normal)
+
+ProcessPriority = 1
+
+#
+#    Compression
+#        Description: Compression level for client update packages
+#        Range:       1-9
+#        Default:     1   - (Speed)
+#                     9   - (Best compression)
+
+Compression = 1
+
+#
+#    PlayerLimit
+#        Description: Maximum number of players in the world. Excluding Mods, GMs and Admins.
+#          Important: If you want to block players and only allow Mods, GMs or Admins to join the
+#                     server, use the DB field "auth.realmlist.allowedSecurityLevel".
+#            Default: 100 - (Enabled)
+#                     1+  - (Enabled)
+#                     0   - (Disabled, No limit)
+
+PlayerLimit = 1000
+
+
+#
+#    SaveRespawnTimeImmediately
+#        Description: Save respawn time for creatures at death and gameobjects at use/open.
+#        Default:     1 - (Enabled, Save respawn time immediately)
+#                     0 - (Disabled, Save respawn time at grid unloading)
+
+SaveRespawnTimeImmediately = 1
+
+#
+#    MaxOverspeedPings
+#        Description: Maximum overspeed ping count before character is disconnected.
+#        Default:     2  - (Enabled, Minimum value)
+#                     3+ - (Enabled, More checks before kick)
+#                     0  - (Disabled)
+
+MaxOverspeedPings = 2
+
+#
+#    GridUnload
+#        Description: Unload grids to save memory. Can be disabled if enough memory is available
+#                     to speed up moving players to new grids.
+#        Default:     1 - (enable, Unload grids)
+#                     0 - (disable, Do not unload grids)
+
+GridUnload = 1
+
+#
+#    SocketTimeOutTime
+#        Description: Time (in milliseconds) after which a connection being idle on the character
+#                     selection screen is disconnected.
+#        Default:     900000 - (15 minutes)
+
+SocketTimeOutTime = 900000
+
+#
+#    SessionAddDelay
+#        Description: Time (in microseconds) that a network thread will sleep after authentication
+#                     protocol handling before adding a connection to the world session map.
+#        Default:     10000 - (10 milliseconds, 0.01 second)
+
+SessionAddDelay = 10000
+
+#
+#    GridCleanUpDelay
+#        Description: Time (in milliseconds) grid clean up delay.
+#        Default:     300000 - (5 minutes)
+
+GridCleanUpDelay = 300000
+
+#
+#    MapUpdateInterval
+#        Description: Time (milliseconds) for map update interval.
+#        Default:     100 - (0.1 second)
+
+MapUpdateInterval = 100
+
+#
+#    ChangeWeatherInterval
+#        Description: Time (in milliseconds) for weather update interval.
+#        Default:     600000 - (10 min)
+
+ChangeWeatherInterval = 600000
+
+#
+#    PlayerSaveInterval
+#        Description: Time (in milliseconds) for player save interval.
+#        Default:     900000 - (15 min)
+
+PlayerSaveInterval = 900000
+
+#
+#    PlayerSave.Stats.MinLevel
+#        Description: Minimum level for saving character stats in the database for external usage.
+#        Default:     0  - (Disabled, Do not save character stats)
+#                     1+ - (Enabled, Level beyond which character stats are saved)
+
+PlayerSave.Stats.MinLevel = 0
+
+#
+#    PlayerSave.Stats.SaveOnlyOnLogout
+#        Description: Save player stats only on logout.
+#        Default:     1 - (Enabled, Only save on logout)
+#                     0 - (Disabled, Save on every player save)
+
+PlayerSave.Stats.SaveOnlyOnLogout = 1
+
+#
+#    mmap.enablePathFinding
+#        Description: Enable/Disable pathfinding using mmaps - experimental
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+mmap.enablePathFinding = 1
+
+#
+#    vmap.enableLOS
+#    vmap.enableHeight
+#        Description: VMmap support for line of sight and height calculation.
+#        Default:     1 - (Enabled, vmap.enableLOS)
+#                     1 - (Enabled, vmap.enableHeight)
+#                     0 - (Disabled)
+
+vmap.enableLOS    = 1
+vmap.enableHeight = 1
+
+#
+#    vmap.enableIndoorCheck
+#        Description: VMap based indoor check to remove outdoor-only auras (mounts etc.).
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled, somewhat less CPU usage)
+
+vmap.enableIndoorCheck = 1
+
+#
+#    DetectPosCollision
+#        Description: Check final move position, summon position, etc for visible collision with
+#                     other objects or walls (walls only if vmaps are enabled).
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled, Less position precision but less CPU usage)
+
+DetectPosCollision = 1
+
+#
+#    TargetPosRecalculateRange
+#        Description: Max distance from movement target point (+moving unit size) and targeted
+#                     object (+size) after that new target movement point calculated.
+#        Range:       0.5-5.0
+#        Default:     1.5
+#                     0.5 - (Minimum, Contact Range, More sensitive reaction to target movement)
+#                     5.0 - (Maximum, Melee attack range, Less CPU usage)
+
+TargetPosRecalculateRange = 1.5
+
+#
+#    UpdateUptimeInterval
+#        Description: Update realm uptime period (in minutes).
+#        Default:     10 - (10 minutes)
+#                     1+
+
+UpdateUptimeInterval = 10
+
+#
+#    LogDB.Opt.ClearInterval
+#        Description: Time (in minutes) for the WUPDATE_CLEANDB timer that clears the `logs` table
+#                     of old entries.
+#        Default:     10 - (10 minutes)
+#                     1+
+
+LogDB.Opt.ClearInterval = 10
+
+#
+#    LogDB.Opt.ClearTime
+#        Description: Time (in seconds) for keeping old `logs` table entries.
+#        Default:     1209600 - (Enabled, 14 days)
+#                     0       - (Disabled, Do not clear entries)
+
+LogDB.Opt.ClearTime = 1209600
+
+#
+#    MaxCoreStuckTime
+#        Description: Time (in seconds) before the server is forced to crash if it is frozen.
+#        Default:     0   - (Disabled)
+#                     10+ - (Enabled, Recommended 10+)
+
+MaxCoreStuckTime = 0
+
+#
+#    AddonChannel
+#        Description: Configure the use of the addon channel through the server (some client side
+#                     addons will not work correctly with disabled addon channel)
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+AddonChannel = 1
+
+#
+#    MapUpdate.Threads
+#        Description: Number of threads to update maps.
+#        Default:     1
+
+MapUpdate.Threads = 1
+
+#
+#    CleanCharacterDB
+#        Description: Clean out deprecated achievements, skills, spells and talents from the db.
+#        Default:     0 - (Disabled)
+#                     1 - (Enable)
+
+CleanCharacterDB = 0
+
+#
+#    PersistentCharacterCleanFlags
+#        Description: Determines the character clean flags that remain set after cleanups.
+#                     This is a bitmask value, check /doc/CharacterDBCleanup.txt for more
+#                     information.
+#        Example:     14 - (Cleaning up skills, talents and spells will remain enabled after the
+#                           next cleanup)
+#        Default:     0  - (All cleanup methods will be disabled after the next cleanup)
+
+PersistentCharacterCleanFlags = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+# SERVER LOGGING
+#
+#    PidFile
+#        Description: World daemon PID file
+#        Example:     "./world.pid" - (Enabled)
+#        Default:     ""            - (Disabled)
+
+PidFile = ""
+
+#
+#    PacketLogFile
+#        Description: Binary packet logging file for the world server.
+#                     Filename extension must be .bin to be parsable with WowPacketParser.
+#        Example:     "World.bin" - (Enabled)
+#        Default:     ""          - (Disabled)
+
+PacketLogFile = ""
+
+#
+#    ChatLogs.Channel
+#        Description: Log custom channel chat.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ChatLogs.Channel = 0
+
+#
+#    ChatLogs.Whisper
+#        Description: Log whispers between players.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ChatLogs.Whisper = 0
+
+#
+#    ChatLogs.SysChan
+#        Description: Log system channel messages.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ChatLogs.SysChan = 0
+
+#
+#    ChatLogs.Party
+#        Description: Log party chat.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+
+ChatLogs.Party = 0
+
+#
+#    ChatLogs.Raid
+#        Description: Log raid chat.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+
+ChatLogs.Raid = 0
+
+#
+#    ChatLogs.Guild
+#        Description: Log guild chat.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ChatLogs.Guild = 0
+
+#
+#    ChatLogs.Public
+#        Description: Log public chat (say/yell/emote).
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ChatLogs.Public = 0
+
+#
+#    ChatLogs.Addon
+#        Description: Log addon messages.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ChatLogs.Addon = 0
+
+#
+#    ChatLogs.BattleGround
+#        Description: Log battleground chat.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ChatLogs.BattleGround = 0
+
+# Extended Logging system configuration moved to end of file (on purpose)
+#
+###################################################################################################
+
+###################################################################################################
+# SERVER SETTINGS
+#
+#    GameType
+#        Description: Server realm type.
+#        Default:     0  - (NORMAL)
+#                     1  - (PVP)
+#                     4  - (NORMAL)
+#                     6  - (RP)
+#                     8  - (RPPVP)
+#                     16 - (FFA_PVP, Free for all pvp mode like arena PvP in all zones except rest
+#                          activated places and sanctuaries)
+
+GameType = 0
+
+#
+#    RealmZone
+#        Description: Server realm zone. Set allowed alphabet in character, etc. names.
+#        Default      1  - (Development   - any language)
+#                     2  - (United States - extended-Latin)
+#                     3  - (Oceanic       - extended-Latin)
+#                     4  - (Latin America - extended-Latin)
+#                     5  - (Tournament    - basic-Latin at create, any at login)
+#                     6  - (Korea         - East-Asian)
+#                     7  - (Tournament    - basic-Latin at create, any at login)
+#                     8  - (English       - extended-Latin)
+#                     9  - (German        - extended-Latin)
+#                     10 - (French        - extended-Latin)
+#                     11 - (Spanish       - extended-Latin)
+#                     12 - (Russian       - Cyrillic)
+#                     13 - (Tournament    - basic-Latin at create, any at login)
+#                     14 - (Taiwan        - East-Asian)
+#                     15 - (Tournament    - basic-Latin at create, any at login)
+#                     16 - (China         - East-Asian)
+#                     17 - (CN1           - basic-Latin at create, any at login)
+#                     18 - (CN2           - basic-Latin at create, any at login)
+#                     19 - (CN3           - basic-Latin at create, any at login)
+#                     20 - (CN4           - basic-Latin at create, any at login)
+#                     21 - (CN5           - basic-Latin at create, any at login)
+#                     22 - (CN6           - basic-Latin at create, any at login)
+#                     23 - (CN7           - basic-Latin at create, any at login)
+#                     24 - (CN8           - basic-Latin at create, any at login)
+#                     25 - (Tournament    - basic-Latin at create, any at login)
+#                     26 - (Test Server   - any language)
+#                     27 - (Tournament    - basic-Latin at create, any at login)
+#                     28 - (QA Server     - any language)
+#                     29 - (CN9           - basic-Latin at create, any at login)
+
+RealmZone = 1
+
+#
+#    StrictPlayerNames
+#        Description: Limit player name to language specific symbol set. Prevents character
+#                     creation and forces rename request if not allowed symbols are used
+#        Default:     0 - (Disable, Limited server timezone dependent client check)
+#                     1 - (Enabled, Strictly basic Latin characters)
+#                     2 - (Enabled, Strictly realm zone specific, See RealmZone setting,
+#                         Note: Client needs to have the appropriate fonts installed which support
+#                         the charset. For non-official localization, custom fonts need to be
+#                         placed in clientdir/Fonts.
+#                     3 - (Enabled, Basic Latin characters + server timezone specific)
+
+StrictPlayerNames = 0
+
+#
+#    StrictCharterNames
+#        Description: Limit guild/arena team charter names to language specific symbol set.
+#                     Prevents charter creation if not allowed symbols are used.
+#        Default:     0 - (Disable, Limited server timezone dependent client check)
+#                     1 - (Enabled, Strictly basic Latin characters)
+#                     2 - (Enabled, Strictly realm zone specific, See RealmZone setting,
+#                         Note: Client needs to have the appropriate fonts installed which support
+#                         the charset. For non-official localization, custom fonts need to be
+#                         placed in clientdir/Fonts.
+#                     3 - (Enabled, Basic Latin characters + server timezone specific)
+
+StrictCharterNames = 0
+
+#
+#    StrictPetNames
+#        Description: Limit pet names to language specific symbol set.
+#                     Prevents pet naming if not allowed symbols are used.
+#        Default:     0 - (Disable, Limited server timezone dependent client check)
+#                     1 - (Enabled, Strictly basic Latin characters)
+#                     2 - (Enabled, Strictly realm zone specific, See RealmZone setting,
+#                         Note: Client needs to have the appropriate fonts installed which support
+#                         the charset. For non-official localization, custom fonts need to be
+#                         placed in clientdir/Fonts.
+#                     3 - (Enabled, Basic Latin characters + server timezone specific)
+
+StrictPetNames = 0
+
+#
+#    DBC.Locale
+#        Description: DBC language settings.
+#        Default:     0   - (English)
+#                     1   - (Korean)
+#                     2   - (French)
+#                     3   - (German)
+#                     4   - (Chinese)
+#                     5   - (Taiwanese)
+#                     6   - (Spanish)
+#                     7   - (Spanish Mexico)
+#                     8   - (Russian)
+
+DBC.Locale = 0
+
+#
+#    DeclinedNames
+#        Description: Allow Russian clients to set and use declined names.
+#        Default:     0 - (Disabled, Except when the Russian RealmZone is set)
+#                     1 - (Enabled)
+
+DeclinedNames = 0
+
+#
+#    Expansion
+#        Description: Allow server to use content from expansions. Checks for expansion-related
+#                     map files, client compatibility and class/race character creation.
+#        Default:     3 - (Expansion 3)
+#                     2 - (Expansion 2)
+#                     1 - (Expansion 1)
+#                     0 - (Disabled, Ignore and disable expansion content (maps, races, classes)
+
+Expansion = 3
+
+#
+#    MinPlayerName
+#        Description: Minimal player name length.
+#        Range:       1-12
+#        Default:     2
+
+MinPlayerName = 2
+
+#
+#    MinCharterName
+#        Description: Minimal charter name length.
+#        Range:       1-24
+#        Default:     2
+
+MinCharterName = 2
+
+#
+#    MinPetName
+#        Description: Minimal pet name length.
+#        Range:       1-12
+#        Default:     2
+
+MinPetName = 2
+
+#
+#    MaxWhoListReturns
+#        Description: Set the max number of players returned in the /who list and interface.
+#        Default:     49 - (stable)
+
+MaxWhoListReturns = 49
+
+#
+#    CharacterCreating.Disabled
+#        Description: Disable character creation for players based on faction.
+#        Default:     0 - (Enabled, All factions are allowed)
+#                     1 - (Disabled, Alliance)
+#                     2 - (Disabled, Horde)
+#                     3 - (Disabled, Both factions)
+
+CharacterCreating.Disabled = 0
+
+#
+#    CharacterCreating.Disabled.RaceMask
+#        Description: Mask of races which cannot be created by players.
+#        Example:     1536 - (1024 + 512, Blood Elf and Draenei races are disabled)
+#        Default:     0    - (Enabled, All races are allowed)
+#                     1    - (Disabled, Human)
+#                     2    - (Disabled, Orc)
+#                     4    - (Disabled, Dwarf)
+#                     8    - (Disabled, Night Elf)
+#                     16   - (Disabled, Undead)
+#                     32   - (Disabled, Tauren)
+#                     64   - (Disabled, Gnome)
+#                     128  - (Disabled, Troll)
+#                     512  - (Disabled, Blood Elf)
+#                     1024 - (Disabled, Draenei)
+
+CharacterCreating.Disabled.RaceMask = 0
+
+#
+#    CharacterCreating.Disabled.ClassMask
+#        Description: Mask of classes which cannot be created by players.
+#        Example:     288 - (32 + 256, Death Knight and Warlock classes are disabled)
+#        Default:     0    - (Enabled, All classes are allowed)
+#                     1    - (Disabled, Warrior)
+#                     2    - (Disabled, Paladin)
+#                     4    - (Disabled, Hunter)
+#                     8    - (Disabled, Rogue)
+#                     16   - (Disabled, Undead)
+#                     32   - (Disabled, Death Knight)
+#                     64   - (Disabled, Shaman)
+#                     128  - (Disabled, Mage)
+#                     256  - (Disabled, Warlock)
+#                     1024 - (Disabled, Druid)
+
+CharacterCreating.Disabled.ClassMask = 0
+
+#
+#    CharactersPerAccount
+#        Description: Limit number of characters per account on all realms on this realmlist.
+#        Important:   Number must be >= CharactersPerRealm
+#        Default:     50
+
+CharactersPerAccount = 50
+#
+#    CharactersPerRealm
+#        Description: Limit number of characters per account on this realm.
+#        Range:       1-10
+#        Default:     10 - (Client limitation)
+
+CharactersPerRealm = 10
+
+#
+#    HeroicCharactersPerRealm
+#        Description: Limit number of heroic class characters per account on this realm.
+#        Range:       1-10
+#        Default:     1
+
+HeroicCharactersPerRealm = 1
+
+#
+#    CharacterCreating.MinLevelForHeroicCharacter
+#        Description: Limit creating heroic characters only for account with another
+#                     character of specific level (ignored for GM accounts)
+#        Default:     55 - (Enabled, Requires at least another level 55 character)
+#                     0  - (Disabled)
+#                     1  - (Enabled, Requires at least another level 1 character)
+
+CharacterCreating.MinLevelForHeroicCharacter = 55
+
+#
+#    SkipCinematics
+#        Description: Disable cinematic intro at first login after character creation.
+#                     Prevents buggy intros in case of custom start location coordinates.
+#        Default:     0 - (Show intro for each new character)
+#                     1 - (Show intro only for first character of selected race)
+#                     2 - (Disable intro for all classes)
+
+SkipCinematics = 0
+
+#
+#    MaxPlayerLevel
+#        Description: Maximum level that can be reached by players.
+#        Important:   Levels beyond 100 are not recommended at all.
+#        Range:       1-255
+#        Default:     85
+
+MaxPlayerLevel = 85
+
+#
+#    MinDualSpecLevel
+#        Description: Level requirement for Dual Talent Specialization
+#        Default:     30
+
+MinDualSpecLevel = 30
+
+#
+#    StartPlayerLevel
+#        Description: Starting level for characters after creation.
+#        Range:       1-MaxPlayerLevel
+#        Default:     1
+
+StartPlayerLevel = 1
+
+#
+#    StartHeroicPlayerLevel
+#        Description: Staring level for heroic class characters after creation.
+#        Range:       1-MaxPlayerLevel
+#        Default:     55
+
+StartHeroicPlayerLevel = 55
+
+#
+#    StartPlayerMoney
+#        Description: Amount of money (in Copper) that a character has after creation.
+#        Default:     0
+#                     100 - (1 Silver)
+
+StartPlayerMoney = 0
+
+#
+#    RecruitAFriend.MaxLevel
+#        Description: Highest level up to which a character can benefit from the Recruit-A-Friend
+#                     experience multiplier.
+#        Default:     80
+
+RecruitAFriend.MaxLevel = 80
+
+#
+#    RecruitAFriend.MaxDifference
+#        Description: Highest level difference between linked Recruiter and Friend benefit from
+#                     the Recruit-A-Friend experience multiplier.
+#        Default:     4
+
+RecruitAFriend.MaxDifference = 4
+
+#
+#    InstantLogout
+#        Description: Required security level for instantly logging out everywhere.
+#                     Does not work while in combat, dueling or falling.
+#        Default:     1  - (Enabled, Mods/GMs/Admins)
+#                     0  - (Enabled, Everyone)
+#                     2  - (Enabled, GMs/Admins)
+#                     3  - (Enabled, Admins)
+#                     4  - (Disabled)
+
+InstantLogout = 1
+
+#
+#    DisableWaterBreath
+#        Description: Required security level for water breathing.
+#        Default:     4  - (Disabled)
+#                     0  - (Enabled, Everyone)
+#                     1  - (Enabled, Mods/GMs/Admins)
+#                     2  - (Enabled, GMs/Admins)
+#                     3  - (Enabled, Admins)
+
+DisableWaterBreath = 4
+
+#
+#    AllFlightPaths
+#        Description: Character knows all flight paths (of both factions) after creation.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllFlightPaths = 0
+
+#
+#    InstantFlightPaths
+#        Description: Flight paths will take players to their destination instantly instead
+#                     of making them wait while flying.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+InstantFlightPaths = 0
+
+#
+#    ActivateWeather
+#        Description: Activate the weather system.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+ActivateWeather = 1
+
+#
+#    CastUnstuck
+#        Description: Allow casting the Unstuck spell using .start or unstuck button in client
+#                     help options.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+CastUnstuck = 1
+
+#
+#    Instance.IgnoreLevel
+#        Description: Ignore level requirement when entering instances.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Instance.IgnoreLevel = 0
+
+#
+#    Instance.IgnoreRaid
+#        Description: Ignore raid group requirement when entering instances.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Instance.IgnoreRaid = 0
+
+#
+#    Instance.ResetTimeHour
+#        Description: Hour of the day when the global instance reset occurs.
+#        Range:       0-23
+#        Default:     4 - (04:00 AM)
+
+Instance.ResetTimeHour = 4
+
+#
+#    Instance.UnloadDelay
+#        Description: Time (in milliseconds) before instance maps are unloaded from memory if no
+#                     characters are inside.
+#        Default:     1800000 - (Enabled, 30 minutes)
+#                     0       - (Disabled, Instance maps are kept in memory until the instance
+#                               resets)
+
+Instance.UnloadDelay = 1800000
+
+#    Quests.EnableQuestTracker
+#        Description: Store datas in the database about quest completion and abandonment to help finding out bugged quests.
+#        Default:     0  - (Disabled)
+#                     1  - (Enabled)
+
+Quests.EnableQuestTracker = 0
+
+#
+
+#
+#    Quests.LowLevelHideDiff
+#        Description: Level difference between player and quest level at which quests are
+#                     considered low-level and are not shown via exclamation mark (!) at quest
+#                     givers.
+#        Default:     4  - (Enabled, Hide quests that have 4 levels less than the character)
+#                     -1 - (Disabled, Show all available quest marks)
+
+Quests.LowLevelHideDiff = 4
+
+#
+#    Quests.HighLevelHideDiff
+#        Description: Level difference between player and quest level at which quests are
+#                     considered high-level and are not shown via exclamation mark (!) at quest
+#                     givers.
+#        Default:     7  - (Enabled, Hide quests that have 7 levels more than the character)
+#                     -1 - (Disabled, Show all available quest marks)
+
+Quests.HighLevelHideDiff = 7
+
+#
+#    Quests.IgnoreRaid
+#        Description: Allow non-raid quests to be completed while in a raid group.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Quests.IgnoreRaid = 0
+
+#
+#    Quests.IgnoreAutoAccept
+#        Description: Ignore auto accept flag. Clients will have to manually accept all quests.
+#        Default:     0 - (Disabled, DB values determine if quest is marked auto accept or not.)
+#                     1 - (Enabled, clients will not be told to automatically accept any quest.)
+
+Quests.IgnoreAutoAccept = 0
+
+#
+#    Quests.IgnoreAutoComplete
+#        Description: Ignore auto complete flag. Clients will have to manually complete all quests.
+#        Default:     0 - (Disabled, DB values determine if quest is marked auto complete or not.)
+#                     1 - (Enabled, clients will not be told to automatically complete any quest.)
+
+Quests.IgnoreAutoComplete = 0
+
+#
+#    Guild.EventLogRecordsCount
+#        Description: Number of log entries for guild events that are stored per guild. Old entries
+#                     will be overwritten if the number of log entries exceed the configured value.
+#                     High numbers prevent this behavior but may have performance impacts.
+#        Default:     100
+
+Guild.EventLogRecordsCount = 100
+
+#
+#    Guild.ResetHour
+#        Description: Hour of the day when the daily cap resets occur.
+#        Range:       0-23
+#        Default:     6 - (06:00 AM)
+
+Guild.ResetHour = 6
+
+#
+#    Guild.BankEventLogRecordsCount
+#        Description: Number of log entries for guild bank events that are stored per guild. Old
+#                     entries will be overwritten if the number of log entries exceed the
+#                     configured value. High numbers prevent this behavior but may have performance
+#                     impacts.
+#        Default:     25 - (Minimum)
+
+Guild.BankEventLogRecordsCount = 25
+
+#
+#    Guild.NewsLogRecordsCount
+#        Description: Number of log entries for guild news that are stored per guild. Old
+#                     entries will be overwritten if the number of log entries exceed the
+#                     configured value. High numbers prevent this behavior but may have performance
+#                     impacts.
+#        Default:     250
+
+Guild.NewsLogRecordsCount = 250
+
+#
+#    MaxPrimaryTradeSkill
+#        Description: Maximum number of primary professions a character can learn.
+#        Range:       0-10
+#        Default:     2
+
+MaxPrimaryTradeSkill = 2
+
+#
+#    MinPetitionSigns
+#        Description: Number of required signatures on charters to create a guild.
+#        Range:       0-4
+#        Default:     4
+
+MinPetitionSigns = 4
+
+#
+#    MaxGroupXPDistance
+#        Description: Max distance to creature for group member to get experience at creature
+#                     death.
+#        Default:     74
+
+MaxGroupXPDistance = 74
+
+#
+#    MaxRecruitAFriendBonusDistance
+#        Description: Max distance between character and and group to gain the Recruit-A-Friend
+#                     XP multiplier.
+#        Default:     100
+
+MaxRecruitAFriendBonusDistance = 100
+
+#
+#    MailDeliveryDelay
+#        Description: Time (in seconds) mail delivery is delayed when sending items.
+#        Default:     3600 - (1 hour)
+
+MailDeliveryDelay = 3600
+
+#
+#    SkillChance.Prospecting
+#        Description: Allow skill increase from prospecting.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+SkillChance.Prospecting = 0
+
+#
+#    SkillChance.Milling
+#        Description: Allow skill increase from milling.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+SkillChance.Milling = 0
+
+#
+#    OffhandCheckAtSpellUnlearn
+#        Description: Unlearning certain spells can change offhand weapon restrictions
+#                     for equip slots.
+#        Default:     1 - (Recheck offhand slot weapon at unlearning a spell)
+#                     0 - (Recheck offhand slot weapon only at zone update)
+
+OffhandCheckAtSpellUnlearn = 1
+
+#
+#    ClientCacheVersion
+#        Description: Client cache version for client cache data reset. Use any value different
+#                     from DB and not recently been used to trigger client side cache reset.
+#        Default:     0 - (Use DB value from world DB db_version.cache_id field)
+
+ClientCacheVersion = 0
+
+#
+#    Event.Announce
+#        Description: Announce events.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Event.Announce = 0
+
+#
+#    BeepAtStart
+#        Description: Beep when the world server finished starting (Unix/Linux systems).
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+BeepAtStart = 1
+
+#
+#    Motd
+#        Description: Message of the Day, displayed at login.
+#                     Use '@' for a newline and be sure to escape special characters.
+#        Example:     "Welcome to John\'s Server@This server runs on Trinity Core."
+#        Default:     "Welcome to a Trinity Core server."
+
+Motd = "This Is WoWSource V9"
+
+#
+#    Server.LoginInfo
+#        Description: Display core version (.server info) on login.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Server.LoginInfo = 0
+
+#
+#    Command.LookupMaxResults
+#        Description: Number of results being displayed using a .lookup command.
+#        Default:     0 - (Unlimited)
+
+Command.LookupMaxResults = 0
+
+#
+#    AllowTickets
+#        Description: Allow/disallow sending new tickets.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+AllowTickets = 1
+
+#
+#     DungeonFinder.OptionsMask
+#        Description: Dungeon and raid finder system.
+#        Value is a bitmask consisting of:
+#           LFG_OPTION_ENABLE_DUNGEON_FINDER = 1,     Enable the dungeon finder browser
+#           LFG_OPTION_ENABLE_RAID_BROWSER   = 2,     Enable the raid browser
+#        Default:     1
+
+DungeonFinder.OptionsMask = 1
+
+
+#
+#   DBC.EnforceItemAttributes
+#        Description: Disallow overriding item attributes stored in DBC files with values from the
+#                     database.
+#        Default:     1 - (Enabled, Enforce DBC values)
+#                     0 - (Disabled, Use database values)
+
+DBC.EnforceItemAttributes = 1
+
+#
+#   AccountInstancesPerHour
+#        Description: Controls the max amount of different instances player can enter within hour
+#        Default:     5
+
+AccountInstancesPerHour = 5
+
+#
+###################################################################################################
+
+###################################################################################################
+# WARDEN SETTINGS
+#
+#    Warden.Enabled
+#        Description: Enable Warden anticheat system.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Warden.Enabled = 0
+
+#
+#    Warden.NumMemChecks
+#        Description: Number of Warden memory checks that are sent to the client each cycle.
+#        Default:     3 - (Enabled)
+#                     0 - (Disabled)
+
+Warden.NumMemChecks = 3
+
+#
+#    Warden.NumOtherChecks
+#        Description: Number of Warden checks other than memory checks that are added to request
+#                     each checking cycle.
+#        Default:     7 - (Enabled)
+#                     0 - (Disabled)
+
+Warden.NumOtherChecks = 7
+
+#
+#    Warden.ClientResponseDelay
+#        Description: Time (in seconds) before client is getting disconnecting for not responding.
+#        Default:     600 - (10 Minutes)
+#                     0 - (Disabled, client won't be kicked)
+
+Warden.ClientResponseDelay = 600
+
+#
+#    Warden.ClientCheckHoldOff
+#        Description: Time (in seconds) to wait before sending the next check request to the client.
+#                     A low number increases traffic and load on client and server side.
+#        Default:     30 - (30 Seconds)
+#                     0  - (Send check as soon as possible)
+
+Warden.ClientCheckHoldOff = 30
+
+#
+#    Warden.ClientCheckFailAction
+#        Description: Default action being taken if a client check failed. Actions can be
+#                     overwritten for each single check via warden_action table in characters
+#                     database.
+#        Default:     0 - (Disabled, Logging only)
+#                     1 - (Kick)
+#                     2 - (Ban)
+
+Warden.ClientCheckFailAction = 0
+
+#
+#    Warden.BanDuration
+#        Description: Time (in seconds) an account will be banned if ClientCheckFailAction is set
+#                     to ban.
+#        Default:     86400 - (24 hours)
+#                     0     - (Permanent ban)
+
+Warden.BanDuration = 86400
+
+#
+###################################################################################################
+
+###################################################################################################
+# PLAYER INTERACTION
+#
+#    AllowTwoSide.Accounts
+#        Description: Allow creating characters of both factions on the same account.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+AllowTwoSide.Accounts = 1
+
+#
+#    AllowTwoSide.Interaction.Calendar
+#        Description: Allow calendar invites between factions.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllowTwoSide.Interaction.Calendar = 0
+
+#
+#    AllowTwoSide.Interaction.Chat
+#        Description: Allow say chat between factions.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllowTwoSide.Interaction.Chat = 0
+
+#
+#    AllowTwoSide.Interaction.Channel
+#        Description: Allow channel chat between factions.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllowTwoSide.Interaction.Channel = 0
+
+#
+#    AllowTwoSide.Interaction.Group
+#        Description: Allow group joining between factions.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllowTwoSide.Interaction.Group = 0
+
+#
+#    AllowTwoSide.Interaction.Guild
+#        Description: Allow guild joining between factions.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllowTwoSide.Interaction.Guild = 0
+
+#
+#    AllowTwoSide.Interaction.Auction
+#        Description: Allow auctions between factions.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllowTwoSide.Interaction.Auction = 0
+
+#
+#    AllowTwoSide.Interaction.Mail
+#        Description: Allow sending mails between factions.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllowTwoSide.Interaction.Mail = 0
+
+#
+#    AllowTwoSide.WhoList
+#        Description: Show characters from both factions in the /who list.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllowTwoSide.WhoList = 0
+
+#
+#    AllowTwoSide.AddFriend
+#        Description: Allow adding friends from other faction the friends list.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllowTwoSide.AddFriend = 0
+
+#
+#    AllowTwoSide.Trade
+#        Description: Allow trading between factions.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AllowTwoSide.Trade = 0
+
+#
+#    TalentsInspecting
+#        Description: Allow inspecting characters from the opposing faction.
+#                     Doesn't affect characters in gamemaster mode.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+TalentsInspecting = 1
+
+#
+###################################################################################################
+
+###################################################################################################
+# CREATURE SETTINGS
+#
+#    ThreatRadius
+#        Description: Distance for creatures to evade after being pulled away from the combat
+#                     starting point. If ThreatRadius is less than creature aggro radius then aggro
+#                     radius will be used.
+#        Default:     60
+
+ThreatRadius = 60
+
+#
+#    Rate.Creature.Aggro
+#        Description: Aggro radius percentage.
+#        Default:     1   - (Enabled, 100%)
+#                     1.5 - (Enabled, 150%)
+#                     0   - (Disabled, 0%)
+
+Rate.Creature.Aggro = 1
+
+#
+#    CreatureFamilyFleeAssistanceRadius
+#        Description: Distance for fleeing creatures seeking assistance from other creatures.
+#        Default:     30 - (Enabled)
+#                     0  - (Disabled)
+
+CreatureFamilyFleeAssistanceRadius = 30
+
+#
+#    CreatureFamilyAssistanceRadius
+#        Description: Distance for creatures calling for assistance from other creatures without
+#                     moving.
+#        Default:     10 - (Enabled)
+#                     0  - (Disabled)
+
+CreatureFamilyAssistanceRadius = 10
+
+#
+#    CreatureFamilyAssistanceDelay
+#        Description: Time (in milliseconds) before creature assistance call.
+#        Default:     1500 - (1.5 Seconds)
+
+CreatureFamilyAssistanceDelay = 1500
+
+#
+#    CreatureFamilyFleeDelay
+#        Description: Time (in milliseconds) during which creature can flee if no assistance was
+#                     found.
+#        Default:     7000 (7 Seconds)
+
+CreatureFamilyFleeDelay = 7000
+
+#
+#    WorldBossLevelDiff
+#        Description: World boss level difference.
+#        Default:     3
+
+WorldBossLevelDiff = 3
+
+#
+#    Corpse.Decay.NORMAL
+#    Corpse.Decay.RARE
+#    Corpse.Decay.ELITE
+#    Corpse.Decay.RAREELITE
+#    Corpse.Decay.WORLDBOSS
+#        Description: Time (in seconds) until creature corpse will decay if not looted or skinned.
+#        Default:     60   - (1 Minute, Corpse.Decay.NORMAL)
+#                     300  - (5 Minutes, Corpse.Decay.RARE)
+#                     300  - (5 Minutes, Corpse.Decay.ELITE)
+#                     300  - (5 Minutes, Corpse.Decay.RAREELITE)
+#                     3600 - (1 Hour, Corpse.Decay.WORLDBOSS)
+
+Corpse.Decay.NORMAL    = 60
+Corpse.Decay.RARE      = 300
+Corpse.Decay.ELITE     = 300
+Corpse.Decay.RAREELITE = 300
+Corpse.Decay.WORLDBOSS = 3600
+
+#
+#    Rate.Corpse.Decay.Looted
+#        Description: Multiplier for Corpse.Decay.* to configure how long creature corpses stay
+#                     after they have been looted.
+#         Default:    0.5
+
+Rate.Corpse.Decay.Looted = 0.5
+
+#
+#    Rate.Creature.Normal.Damage
+#    Rate.Creature.Elite.Elite.Damage
+#    Rate.Creature.Elite.RARE.Damage
+#    Rate.Creature.Elite.RAREELITE.Damage
+#    Rate.Creature.Elite.WORLDBOSS.Damage
+#        Description: Mulitplier for creature melee damage.
+#        Default:     1 - (Rate.Creature.Normal.Damage)
+#                     1 - (Rate.Creature.Elite.Elite.Damage)
+#                     1 - (Rate.Creature.Elite.RARE.Damage)
+#                     1 - (Rate.Creature.Elite.RAREELITE.Damage)
+#                     1 - (Rate.Creature.Elite.WORLDBOSS.Damage)
+#
+
+Rate.Creature.Normal.Damage          = 1
+Rate.Creature.Elite.Elite.Damage     = 1
+Rate.Creature.Elite.RARE.Damage      = 1
+Rate.Creature.Elite.RAREELITE.Damage = 1
+Rate.Creature.Elite.WORLDBOSS.Damage = 1
+
+#
+#    Rate.Creature.Normal.SpellDamage
+#    Rate.Creature.Elite.Elite.SpellDamage
+#    Rate.Creature.Elite.RARE.SpellDamage
+#    Rate.Creature.Elite.RAREELITE.SpellDamage
+#    Rate.Creature.Elite.WORLDBOSS.SpellDamage
+#        Description: Mulitplier for creature spell damage.
+#        Default:     1 - (Rate.Creature.Normal.SpellDamage)
+#                     1 - (Rate.Creature.Elite.Elite.SpellDamage)
+#                     1 - (Rate.Creature.Elite.RARE.SpellDamage)
+#                     1 - (Rate.Creature.Elite.RAREELITE.SpellDamage)
+#                     1 - (Rate.Creature.Elite.WORLDBOSS.SpellDamage)
+
+Rate.Creature.Normal.SpellDamage          = 1
+Rate.Creature.Elite.Elite.SpellDamage     = 1
+Rate.Creature.Elite.RARE.SpellDamage      = 1
+Rate.Creature.Elite.RAREELITE.SpellDamage = 1
+Rate.Creature.Elite.WORLDBOSS.SpellDamage = 1
+
+#
+#    Rate.Creature.Normal.HP
+#    Rate.Creature.Elite.Elite.HP
+#    Rate.Creature.Elite.RARE.HP
+#    Rate.Creature.Elite.RAREELITE.HP
+#    Rate.Creature.Elite.WORLDBOSS.HP
+#        Description: Mulitplier for creature health.
+#        Default:     1 - (Rate.Creature.Normal.HP)
+#                     1 - (Rate.Creature.Elite.Elite.HP)
+#                     1 - (Rate.Creature.Elite.RARE.HP)
+#                     1 - (Rate.Creature.Elite.RAREELITE.HP)
+#                     1 - (Rate.Creature.Elite.WORLDBOSS.HP)
+
+Rate.Creature.Normal.HP          = 1
+Rate.Creature.Elite.Elite.HP     = 1
+Rate.Creature.Elite.RARE.HP      = 1
+Rate.Creature.Elite.RAREELITE.HP = 1
+Rate.Creature.Elite.WORLDBOSS.HP = 1
+
+#
+#    ListenRange.Say
+#        Description: Distance in which players can read say messages from creatures or
+#                     gameobjects.
+#        Default:     40
+
+ListenRange.Say = 40
+
+#
+#    ListenRange.TextEmote
+#        Description: Distance in which players can read emotes from creatures or gameobjects.
+#        Default:     40
+
+ListenRange.TextEmote = 40
+
+#
+#    ListenRange.Yell
+#        Description: Distance in which players can read yell messages from creatures or
+#                     gameobjects.
+#        Default:     300
+
+ListenRange.Yell = 300
+
+#
+###################################################################################################
+
+###################################################################################################
+# CHAT SETTINGS
+#
+#    ChatFakeMessagePreventing
+#        Description: Chat protection from creating fake messages using a lot spaces or other
+#                     invisible symbols. Not applied to the addon language, but may break old
+#                     addons that use normal languages for sending data to other clients.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ChatFakeMessagePreventing = 0
+
+#
+#    ChatStrictLinkChecking.Severity
+#        Description: Check chat messages for ingame links to spells, items, quests, etc.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled, Check if only valid pipe commands are used, Prevents posting
+#                         pictures.)
+#                     2 - (Enabled, Verify that pipe commands are used in a correct order)
+#                     3 - (Check if color, entry and name don't contradict each other. For this to
+#                         work correctly, please assure that you have extracted locale DBCs of
+#                         every language specific client playing on this server)
+
+ChatStrictLinkChecking.Severity = 0
+
+#
+#    ChatStrictLinkChecking.Kick
+#        Description: Defines what should be done if a message is considered to contain invalid
+#                     pipe commands.
+#        Default:     0 - (Silently ignore message)
+#                     1 - (Disconnect players who sent malformed messages)
+
+ChatStrictLinkChecking.Kick = 0
+
+#
+#    ChatFlood.MessageCount
+#        Description: Chat flood protection, number of messages before player gets muted.
+#        Default:     10 - (Enabled)
+#                     0  - (Disabled)
+
+ChatFlood.MessageCount = 10
+
+#
+#    ChatFlood.MessageDelay
+#        Description: Time (in seconds) between messages to be counted into ChatFlood.MessageCount.
+#        Default:     1
+
+ChatFlood.MessageDelay = 1
+
+#
+#    ChatFlood.MuteTime
+#        Description: Time (in seconds) characters get muted for violating ChatFlood.MessageCount.
+#        Default:     10
+
+ChatFlood.MuteTime = 10
+
+#
+#    Channel.RestrictedLfg
+#        Description: Restrict LookupForGroup channel to characters registered in the LFG tool.
+#        Default:     1 - (Enabled, Allow join to channel only if registered in LFG)
+#                     0 - (Disabled, Allow join to channel in any time)
+
+Channel.RestrictedLfg = 1
+
+#
+#    Channel.SilentlyGMJoin
+#        Description: Silently join GM characters to channels. If set to 1, channel kick and ban
+#                     commands issued by a GM will not be broadcasted.
+#        Default:     0 - (Disabled, Join with announcement)
+#                     1 - (Enabled, Join without announcement)
+
+Channel.SilentlyGMJoin = 0
+
+#
+#    ChatLevelReq.Channel
+#        Description: Level requirement for characters to be able to write in chat channels.
+#        Default:     1
+
+ChatLevelReq.Channel = 1
+
+#
+#    ChatLevelReq.Whisper
+#        Description: Level requirement for characters to be able to whisper other characters.
+#        Default:     1
+
+ChatLevelReq.Whisper = 1
+
+#
+#    ChatLevelReq.Say
+#        Description: Level requirement for characters to be able to use say/yell/emote.
+#        Default:     1
+
+ChatLevelReq.Say = 1
+
+#
+#    AllowPlayerCommands
+#        Description: Allow players to use commands.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+AllowPlayerCommands = 1
+
+#
+#    PreserveCustomChannels
+#        Description: Store custom chat channel settings like password, automatic ownership handout
+#                     or ban list in the database. Needs to be enabled to save custom
+#                     world/trade/etc. channels that have automatic ownership handout disabled.
+#                     (.channel set ownership $channel off)
+#        Default:     0 - (Disabled, Blizzlike, Channel settings are lost if last person left)
+#                     1 - (Enabled)
+
+PreserveCustomChannels = 1
+
+#
+#    PreserveCustomChannelDuration
+#        Description: Time (in days) that needs to pass before the customs chat channels get
+#                     cleaned up from the database. Only channels with ownership handout enabled
+#                     (default behavior) will be cleaned.
+#        Default:     14 - (Enabled, Clean channels that haven't been used for 14 days)
+#                     0  - (Disabled, Infinite channel storage)
+
+PreserveCustomChannelDuration = 14
+
+#
+###################################################################################################
+
+###################################################################################################
+# GAME MASTER SETTINGS
+#
+#    GM.LoginState
+#        Description: GM mode at login.
+#        Default:     2 - (Last save state)
+#                     0 - (Disable)
+#                     1 - (Enable)
+
+GM.LoginState = 2
+
+#
+#    GM.Visible
+#        Description: GM visibility at login.
+#        Default:     2 - (Last save state)
+#                     0 - (Invisible)
+#                     1 - (Visible)
+
+GM.Visible = 2
+
+#
+#    GM.Chat
+#        Description: GM chat mode at login.
+#        Default:     2 - (Last save state)
+#                     0 - (Disable)
+#                     1 - (Enable)
+
+GM.Chat = 2
+
+#
+#    GM.WhisperingTo
+#        Description: Is GM accepting whispers from player by default or not.
+#        Default:     2 - (Last save state)
+#                     0 - (Disable)
+#                     1 - (Enable)
+
+GM.WhisperingTo = 2
+
+#
+#    GM.InGMList.Level
+#        Description: Maximum GM level shown in GM list (if enabled) in non-GM state (.gm off).
+#        Default:     3 - (Anyone)
+#                     0 - (Only players)
+#                     1 - (Only moderators)
+#                     2 - (Only gamemasters)
+
+GM.InGMList.Level = 3
+
+#
+#    GM.InWhoList.Level
+#        Description: Max GM level showed in who list (if visible).
+#        Default:     3 - (Anyone)
+#                     0 - (Only players)
+#                     1 - (Only moderators)
+#                     2 - (Only gamemasters)
+
+GM.InWhoList.Level = 3
+
+#
+#    GM.LogTrade
+#        Description: Include GM trade and trade slot enchanting operations in GM log.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+GM.LogTrade = 1
+
+#
+#    GM.StartLevel
+#        Description: GM character starting level.
+#        Default:     1
+
+GM.StartLevel = 1
+
+#
+#    GM.AllowInvite
+#        Description: Allow players to invite GM characters.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+GM.AllowInvite = 0
+
+#
+#    GM.AllowFriend
+#        Description: Allow players to add GM characters to their friends list.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+GM.AllowFriend = 0
+
+#
+#    GM.LowerSecurity
+#        Description: Allow lower security levels to use commands on higher security level
+#                     characters.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+GM.LowerSecurity = 0
+
+#
+#    GM.TicketSystem.ChanceOfGMSurvey
+#        Description: Chance of sending a GM survey after ticket completion.
+#        Default:     50 - (Enabled)
+#                     0  - (Disabled)
+
+GM.TicketSystem.ChanceOfGMSurvey = 50
+
+#
+###################################################################################################
+
+###################################################################################################
+# VISIBILITY AND DISTANCES
+#
+#    Visibility.GroupMode
+#        Description: Group visibility modes. Defines which groups can aways detect invisible
+#                     characters of the same raid, group or faction.
+#        Default:     1 - (Raid)
+#                     0 - (Party)
+#                     2 - (Faction)
+
+Visibility.GroupMode = 1
+
+#
+#    Visibility.Distance.Continents
+#    Visibility.Distance.Instances
+#    Visibility.Distance.BGArenas
+#        Description: Visibility distance to see other players or gameobjects.
+#                     Visibility on continents on retail ~90 yards. In BG/Arenas ~533.
+#                     For instances default ~170.
+#                     Max limited by grid size: 533.33333
+#                     Min limit is max aggro radius (45) * Rate.Creature.Aggro
+#        Default:     90  - (Visibility.Distance.Continents)
+#                     170 - (Visibility.Distance.Instances)
+#                     533 - (Visibility.Distance.BGArenas)
+
+Visibility.Distance.Continents = 90
+Visibility.Distance.Instances = 170
+Visibility.Distance.BGArenas = 533
+
+#
+#    Visibility.Notify.Period.OnContinents
+#    Visibility.Notify.Period.InInstances
+#    Visibility.Notify.Period.InBGArenas
+#        Description: Time (in milliseconds) for visibility update period. Lower values may have
+#                     performance impact.
+#        Default:     1000 - (Visibility.Notify.Period.OnContinents)
+#                     1000 - (Visibility.Notify.Period.InInstances)
+#                     1000 - (Visibility.Notify.Period.InBGArenas)
+
+Visibility.Notify.Period.OnContinents = 1000
+Visibility.Notify.Period.InInstances  = 1000
+Visibility.Notify.Period.InBGArenas   = 1000
+
+#
+###################################################################################################
+
+###################################################################################################
+# SERVER RATES
+#
+#    Rate.Health
+#    Rate.Mana
+#    Rate.Rage.Income
+#    Rate.Rage.Loss
+#    Rate.RunicPower.Income
+#    Rate.RunicPower.Loss
+#    Rate.Focus
+#    Rate.Energy
+#    Rate.Loyalty
+#        Description: Multiplier to configure health, mana, incoming rage, loss of rage, focus
+#                     energy and loyalty increase or decrease.
+#        Default:     1 - (Rate.Health)
+#                     1 - (Rate.Mana)
+#                     1 - (Rate.Rage.Income)
+#                     1 - (Rate.Rage.Loss)
+#                     1 - (Rate.RunicPower.Income)
+#                     1 - (Rate.RunicPower.Loss)
+#                     1 - (Rate.Focus)
+#                     1 - (Rate.Energy)
+#                     1 - (Rate.Loyalty)
+
+Rate.Health            = 1
+Rate.Mana              = 1
+Rate.Rage.Income       = 1
+Rate.Rage.Loss         = 1
+Rate.RunicPower.Income = 1
+Rate.RunicPower.Loss   = 1
+Rate.Focus             = 1
+Rate.Energy            = 1
+Rate.Loyalty           = 1
+
+#
+#    Rate.Skill.Discovery
+#        Description: Multiplier for skill discovery.
+#        Default:     1
+
+Rate.Skill.Discovery = 1
+
+#
+#    Rate.Drop.Item.Poor
+#    Rate.Drop.Item.Normal
+#    Rate.Drop.Item.Uncommon
+#    Rate.Drop.Item.Rare
+#    Rate.Drop.Item.Epic
+#    Rate.Drop.Item.Legendary
+#    Rate.Drop.Item.Artifact
+#    Rate.Drop.Item.Referenced
+#    Rate.Drop.Money
+#        Description: Drop rates for money and items based on quality.
+#        Default:     1 - (Rate.Drop.Item.Poor)
+#                     1 - (Rate.Drop.Item.Normal)
+#                     1 - (Rate.Drop.Item.Uncommon)
+#                     1 - (Rate.Drop.Item.Rare)
+#                     1 - (Rate.Drop.Item.Epic)
+#                     1 - (Rate.Drop.Item.Legendary)
+#                     1 - (Rate.Drop.Item.Artifact)
+#                     1 - (Rate.Drop.Item.Referenced)
+#                     1 - (Rate.Drop.Money)
+
+Rate.Drop.Item.Poor             = 1
+Rate.Drop.Item.Normal           = 1
+Rate.Drop.Item.Uncommon         = 1
+Rate.Drop.Item.Rare             = 1
+Rate.Drop.Item.Epic             = 1
+Rate.Drop.Item.Legendary        = 1
+Rate.Drop.Item.Artifact         = 1
+Rate.Drop.Item.Referenced       = 1
+Rate.Drop.Money                 = 1
+
+#
+#    Rate.Drop.Item.ReferencedAmount
+#        Description: Multiplier for referenced loot amount.
+#        Default:     1
+
+Rate.Drop.Item.ReferencedAmount = 1
+
+#
+#    Rate.XP.Kill
+#    Rate.XP.Quest
+#    Rate.XP.Explore
+#        Description: Experience rates.
+#        Default:     1 - (Rate.XP.Kill)
+#                     1 - (Rate.XP.Quest)
+#                     1 - (Rate.XP.Explore)
+
+Rate.XP.Kill    = 2
+Rate.XP.Quest   = 3
+Rate.XP.Explore = 1
+
+#
+#    Rate.RepairCost
+#        Description: Repair cost rate.
+#        Default:     1
+
+Rate.RepairCost = 1
+
+#
+#    Rate.Rest.InGame
+#    Rate.Rest.Offline.InTavernOrCity
+#    Rate.Rest.Offline.InWilderness
+#        Description: Resting points grow rates.
+#        Default:     1 - (Rate.Rest.InGame)
+#                     1 - (Rate.Rest.Offline.InTavernOrCity)
+#                     1 - (Rate.Rest.Offline.InWilderness)
+
+Rate.Rest.InGame                 = 1
+Rate.Rest.Offline.InTavernOrCity = 1
+Rate.Rest.Offline.InWilderness   = 1
+
+#
+#    Rate.Damage.Fall
+#        Description: Damage after fall rate.
+#        Default:     1
+
+Rate.Damage.Fall = 1
+
+#
+#    Rate.Auction.Time
+#    Rate.Auction.Deposit
+#    Rate.Auction.Cut
+#        Description: Auction rates (auction time, deposit get at auction start,
+#                     auction cut from price at auction end)
+#        Default:     1 - (Rate.Auction.Time)
+#                     1 - (Rate.Auction.Deposit)
+#                     1 - (Rate.Auction.Cut)
+
+Rate.Auction.Time    = 1
+Rate.Auction.Deposit = 1
+Rate.Auction.Cut     = 1
+
+#
+#    Rate.Honor
+#        Description: Honor gain rate.
+#        Default:     1
+
+Rate.Honor = 1
+
+#
+#    Rate.Mining.Amount
+#        Description: Rate for minimum/maximum times a deposit can be used.
+#        Default:     1
+
+Rate.Mining.Amount = 1
+
+#
+#    Rate.Mining.Next
+#        Description: Mining rates.
+#        Default:     Chance to to mine a deposit again.
+
+Rate.Mining.Next = 1
+
+#
+#    Rate.Talent
+#        Description: Talent point rate.
+#        Default:     1
+
+Rate.Talent = 1
+
+#
+#    Rate.Reputation.Gain
+#        Description: Reputation gain rate.
+#        Default:     1
+
+Rate.Reputation.Gain = 1
+
+#
+#    Rate.Reputation.LowLevel.Kill
+#        Description: Reputation gain from killing low level (grey) creatures.
+#        Default:     1
+
+Rate.Reputation.LowLevel.Kill = 1
+
+#
+#    Rate.Reputation.LowLevel.Quest
+#        Description: Reputation gain rate.
+#        Default:     1
+
+Rate.Reputation.LowLevel.Quest = 1
+
+#
+#    Rate.Reputation.RecruitAFriendBonus
+#        Description: Reputation bonus rate for recruit-a-friend.
+#        Default:     0.1
+
+Rate.Reputation.RecruitAFriendBonus = 0.1
+
+#
+#    Rate.MoveSpeed
+#        Description: Movement speed rate.
+#        Default:     1
+
+Rate.MoveSpeed = 1
+
+#
+#    Rate.InstanceResetTime
+#        Description: Multiplier for the rate between global raid/heroic instance resets
+#                     (dbc value). Higher value increases the time between resets,
+#                     lower value lowers the time, you need clean instance_reset in
+#                     characters db in order to let new values work.
+#        Default:     1
+
+Rate.InstanceResetTime = 1
+
+#
+#    SkillGain.Crafting
+#    SkillGain.Gathering
+#        Description: Crafting/defense/gathering/weapon skills gain rate.
+#        Default:     1 - (SkillGain.Crafting)
+#                     1 - (SkillGain.Gathering)
+
+SkillGain.Crafting  = 1
+SkillGain.Gathering = 1
+
+#
+#    SkillChance.Orange
+#    SkillChance.Yellow
+#    SkillChance.Green
+#    SkillChance.Grey
+#        Description: Chance to increase skill based on recipe color.
+#        Default:     100 - (SkillChance.Orange)
+#                     75  - (SkillChance.Yellow)
+#                     25  - (SkillChance.Green)
+#                     0   - (SkillChance.Grey)
+
+SkillChance.Orange = 100
+SkillChance.Yellow = 75
+SkillChance.Green  = 25
+SkillChance.Grey   = 0
+
+#
+#    SkillChance.MiningSteps
+#    SkillChance.SkinningSteps
+#        Description: Skinning and Mining chance decreases with skill level.
+#        Default:     0  - (Disabled)
+#                     75 - (In 2 times each 75 skill points)
+
+SkillChance.MiningSteps   = 0
+SkillChance.SkinningSteps = 0
+
+#
+#    DurabilityLoss.InPvP
+#        Description: Durability loss on death during PvP.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+DurabilityLoss.InPvP = 0
+
+#
+#    DurabilityLoss.OnDeath
+#        Description: Durability loss percentage on death.
+#        Default:     10
+
+DurabilityLoss.OnDeath = 10
+
+#
+#    DurabilityLossChance.Damage
+#        Description: Chance to lose durability on one equipped item from damage.
+#        Default:     0.5 - (100/0.5 = 200, Each 200 damage one equipped item will use durability)
+
+DurabilityLossChance.Damage = 0.5
+
+#
+#    DurabilityLossChance.Absorb
+#        Description: Chance to lose durability on one equipped armor item when absorbing damage.
+#        Default:     0.5 - (100/0.5 = 200, Each 200 absorbed damage one equipped item will lose
+#                           durability)
+
+DurabilityLossChance.Absorb = 0.5
+
+#
+#    DurabilityLossChance.Parry
+#        Description: Chance to lose durability on main weapon when parrying attacks.
+#        Default:     0.05 - (100/0.05 = 2000, Each 2000 parried damage the main weapon will lose
+#                            durability)
+
+DurabilityLossChance.Parry = 0.05
+
+#
+#    DurabilityLossChance.Block
+#        Description: Chance to lose durability on shield when blocking attacks.
+#        Default:     0.05 - (100/0.05 = 2000, Each 2000 blocked damage the shield will lose
+#                            durability)
+
+DurabilityLossChance.Block = 0.05
+
+#
+#    Death.SicknessLevel
+#        Description: Starting level for resurrection sickness.
+#        Example:     11 - (Level 1-10 characters will not be affected,
+#                           Level 11-19 characters will be affected for 1 minute,
+#                           Level 20-MaxPlayerLevel characters will be affected for 10 minutes)
+#         Default:    11               - (Enabled, See Example)
+#                     MaxPlayerLevel+1 - (Disabled)
+#                     -10              - (Enabled, Level 1+ characters have 10 minute duration)
+
+Death.SicknessLevel = 11
+
+#
+#    Death.CorpseReclaimDelay.PvP
+#    Death.CorpseReclaimDelay.PvE
+#        Description: Increase corpse reclaim delay at PvP/PvE deaths.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+Death.CorpseReclaimDelay.PvP = 1
+Death.CorpseReclaimDelay.PvE = 0
+
+#
+#    Death.Bones.World
+#    Death.Bones.BattlegroundOrArena
+#        Description: Create bones instead of corpses at resurrection in normal zones, instances,
+#                     battleground or arenas.
+#        Default:     1 - (Enabled, Death.Bones.World)
+#                     1 - (Enabled, Death.Bones.BattlegroundOrArena)
+#                     0 - (Disabled)
+
+Death.Bones.World               = 1
+Death.Bones.BattlegroundOrArena = 1
+
+#
+#    Die.Command.Mode
+#        Description: Do not trigger things like loot from .die command.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+Die.Command.Mode = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+# AUTO BROADCAST
+#
+#    AutoBroadcast.On
+#        Description: Enable auto broadcast.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AutoBroadcast.On = 1
+
+#
+#    AutoBroadcast.Center
+#        Description: Auto broadcasting display method.
+#        Default:     0 - (Announce)
+#                     1 - (Notify)
+#                     2 - (Both)
+
+AutoBroadcast.Center = 0
+
+#
+#    AutoBroadcast.Timer
+#        Description: Timer (in milliseconds) for auto broadcasts.
+#        Default:     60000 - (60 seconds)
+
+AutoBroadcast.Timer = 999999
+
+#
+###################################################################################################
+
+###################################################################################################
+# BATTLEGROUND CONFIG
+#
+#    Battleground.CastDeserter
+#        Description: Cast Deserter spell at players who leave battlegrounds in progress.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+Battleground.CastDeserter = 1
+
+#
+#    Battleground.QueueAnnouncer.Enable
+#        Description: Announce battleground queue status to chat.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Battleground.QueueAnnouncer.Enable = 0
+
+#
+#    Battleground.QueueAnnouncer.PlayerOnly
+#        Description: Battleground queue announcement type.
+#        Default:     0 - (System message, Anyone can see it)
+#                     1 - (Private, Only queued players can see it)
+
+Battleground.QueueAnnouncer.PlayerOnly = 0
+
+#
+#    Battleground.InvitationType
+#        Description: Set Battleground invitation type.
+#        Default:     0 - (Normal, Invite as much players to battlegrounds as queued,
+#                          Don't bother with balance)
+#                     1 - (Experimental, Don't allow to invite much more players
+#                          of one faction)
+
+Battleground.InvitationType = 0
+
+#
+#    Battleground.PrematureFinishTimer
+#        Description: Time (in milliseconds) before battleground will end prematurely if there are
+#                     not enough players on one team. (Values defined in battleground template)
+#        Default:     300000 - (Enabled, 5 minutes)
+#                     0      - (Disabled, Not recommended)
+
+BattleGround.PrematureFinishTimer = 300000
+
+#
+#    BattleGround.PremadeGroupWaitForMatch
+#        Description: Time (in milliseconds) a pre-made group has to wait for matching group of the
+#                     other faction.
+#        Default:     1800000 - (Enabled, 30 minutes)
+#                     0       - (Disabled, Not recommended)
+
+BattleGround.PremadeGroupWaitForMatch = 1800000
+
+#
+#    Battleground.GiveXPForKills
+#        Description: Give experience for honorable kills in battlegrounds.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Battleground.GiveXPForKills = 0
+
+#
+#    Battleground.Random.ResetHour
+#        Description: Hour of the day when the global instance resets occur.
+#        Range:       0-23
+#        Default:     6 - (06:00 AM)
+
+Battleground.Random.ResetHour = 6
+
+#
+###################################################################################################
+
+###################################################################################################
+# BATTLEFIELD CONFIG
+#
+#     Wintergrasp.Enable
+#         Description: Enable the Wintergrasp battlefield.
+#         Default:     0 - (Disabled)
+#                      1 - (Enabled, Experimental as of still being in development)
+
+######################
+# WINTERGRASP CONFIG #
+######################
+
+Wintergrasp.Enable = 0
+
+#
+#     Wintergrasp.PlayerMax
+#         Description: Maximum number of players allowed in Wintergrasp.
+#         Default:     100
+
+Wintergrasp.PlayerMax = 100
+
+#
+#     Wintergrasp.PlayerMin
+#         Description: Minimum number of players required for Wintergrasp.
+#         Default:     0
+
+Wintergrasp.PlayerMin = 0
+
+#
+#     Wintergrasp.PlayerMinLvl
+#         Description: Required character level for the Wintergrasp battle.
+#         Default:     77
+
+Wintergrasp.PlayerMinLvl = 77
+
+#
+#     Wintergrasp.BattleTimer
+#         Description: Time (in minutes) for the Wintergrasp battle to last.
+#         Default:     30
+
+Wintergrasp.BattleTimer = 30
+
+#
+#     Wintergrasp.NoBattleTimer
+#         Description: Time (in minutes) between Wintergrasp battles.
+#         Default:     150
+
+Wintergrasp.NoBattleTimer = 150
+
+#
+#     Wintergrasp.CrashRestartTimer
+#         Description: Time (in minutes) to delay the restart of Wintergrasp if the world server
+#                      crashed during a running battle.
+#         Default:     10
+
+Wintergrasp.CrashRestartTimer = 10
+
+###################
+# TOLBARAD CONFIG #
+###################
+
+#
+#   Tol Barad.Enable
+#         Enable Tol Barad
+#         Default: 0 - off
+#                  1 - on
+
+Tol.Barad.Enable = 0
+
+#
+#    Tol Barad.PlayerMax
+#         Max players allowed in Tol Barad
+#         Default: 100 (players)
+
+Tol.Barad.PlayerMax = 100
+
+#
+#    Tol Barad.PlayerMin
+#         Min players allowed in Tol Barad
+#         Default: 0 (players)
+
+Tol.Barad.PlayerMin = 0
+
+#
+#    Tol Barad.PlayerMinLvl
+#         Min player level allowed in Tol Barad
+#         Default: 80
+
+Tol.Barad.PlayerMinLvl = 80
+
+#
+#    Tol Barad.BattleTimer
+#         Wartime timer
+#         Default: 30 (in min)
+
+Tol.Barad.BattleTimer = 30
+
+#
+#    Tol Barad.NoBattleTimer
+#         Out of wartime timer
+#         Default: 150 (in min)
+
+Tol.Barad.NoBattleTimer = 150
+
+#
+###################################################################################################
+
+###################################################################################################
+# ARENA CONFIG
+#
+#    Arena.MaxRatingDifference
+#        Description: Maximum rating difference between two teams in rated matches.
+#        Default:     150 - (Enabled)
+#                     0   - (Disabled)
+
+Arena.MaxRatingDifference = 150
+
+#
+#    Arena.RatingDiscardTimer
+#        Description: Time (in milliseconds) after which rating differences are ignored when
+#                     setting up matches.
+#        Default:     600000 - (Enabled, 10 minutes)
+#                     0      - (Disabled)
+
+Arena.RatingDiscardTimer = 600000
+
+#
+#    Arena.RatedUpdateTimer
+#        Description: Time (in milliseconds) between checks for matchups in rated arena
+#        Default:     5000 - (5 seconds)
+
+Arena.RatedUpdateTimer = 5000
+
+#
+#    Arena.AutoDistributePoints
+#        Description: Automatically distribute arena points.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Arena.AutoDistributePoints = 0
+
+#
+#    Arena.AutoDistributeInterval
+#        Description: Time (in days) how often arena points should be distributed if automatic
+#                     distribution is enabled.
+#        Default:     7 - (Weekly)
+
+Arena.AutoDistributeInterval = 7
+
+#
+#    Arena.QueueAnnouncer.Enable
+#        Description: Announce arena queue status to chat.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Arena.QueueAnnouncer.Enable = 1
+
+#
+#    Arena.ArenaSeason.ID
+#        Description: Current arena season id shown in clients.
+#        Default:     8
+
+Arena.ArenaSeason.ID = 8
+
+#
+#    Arena.ArenaSeason.InProgress
+#        Description: State of current arena season.
+#        Default:     1 - (Active)
+#                     0 - (Finished)
+
+Arena.ArenaSeason.InProgress = 1
+
+#
+#    Arena.ArenaStartRating
+#        Description: Start rating for new arena teams.
+#        Default:     0
+
+Arena.ArenaStartRating = 0
+
+#
+#    Arena.ArenaStartPersonalRating
+#        Description: Start personal rating when joining a team.
+#        Default:     0
+
+Arena.ArenaStartPersonalRating = 0
+
+#
+#    Arena.ArenaStartMatchmakerRating
+#        Description: Start matchmaker rating for players.
+#        Default:     1500
+
+Arena.ArenaStartMatchmakerRating = 1500
+
+#
+#    ArenaLog.ExtendedInfo
+#        Description: Include extended info to ArenaLogFile for each player after rated arena
+#                     matches (guid, name, team, IP, healing/damage done, killing blows).
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ArenaLog.ExtendedInfo = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+# NETWORK CONFIG
+#
+#    Network.Threads
+#        Description: Number of threads for network.
+#         Default:    1 - (Recommended 1 thread per 1000 connections)
+
+Network.Threads = 1
+
+#
+#    Network.OutKBuff
+#        Description: Amount of memory (in bytes) used for the output kernel buffer (see SO_SNDBUF
+#                     socket option, TCP manual).
+#        Default:     -1 - (Use system default setting)
+
+Network.OutKBuff = -1
+
+#
+#    Network.OutUBuff
+#        Description: Amount of memory (in bytes) reserved in the user space per connection for
+#                     output buffering.
+#         Default:    65536
+
+Network.OutUBuff = 65536
+
+#
+#    Network.TcpNoDelay:
+#        Description: TCP Nagle algorithm setting.
+#         Default:    0 - (Enabled, Less traffic, More latency)
+#                     1 - (Disabled, More traffic, Less latency, TCP_NO_DELAY)
+
+Network.TcpNodelay = 1
+
+#
+###################################################################################################
+
+###################################################################################################
+# CONSOLE AND REMOTE ACCESS
+#
+#    Console.Enable
+#        Description: Enable console.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+Console.Enable = 1
+
+#
+#    Ra.Enable
+#        Description: Enable remote console (telnet).
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Ra.Enable = 0
+
+#
+#    Ra.IP
+#        Description: Bind remote access to IP/hostname.
+#        Default:     "0.0.0.0" - (Bind to all IPs on the system)
+
+Ra.IP = "0.0.0.0"
+
+#
+#    Ra.Port
+#        Description: TCP port to reach the remote console.
+#        Default:     3443
+
+Ra.Port = 3443
+
+#
+#    Ra.MinLevel
+#        Description: Required security level to use the remote console.
+#        Default:     3
+
+Ra.MinLevel = 3
+
+#
+#    SOAP.Enable
+#        Description: Enable soap service
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+SOAP.Enabled = 0
+
+#
+#    SOAP.IP
+#        Description: Bind SOAP service to IP/hostname
+#        Default:     "127.0.0.1" - (Bind to localhost)
+
+SOAP.IP = "127.0.0.1"
+
+#
+#    SOAP.Port
+#        Description: TCP port to reach the SOAP service.
+#        Default:     7878
+
+SOAP.Port = 7878
+
+#
+###################################################################################################
+
+###################################################################################################
+# CHARACTER DELETE OPTIONS
+#
+#    CharDelete.Method
+#        Description: Character deletion behavior.
+#        Default:     0 - (Completely remove character from the database)
+#                     1 - (Unlink the character from account and free up the name, Appears as
+#                         deleted ingame)
+
+CharDelete.Method = 0
+
+#
+#    CharDelete.MinLevel
+#        Description: Required level to use the unlinking method if enabled.
+#        Default:     0  - (Same method for every level)
+#                     1+ - (Only characters with the specified level will use the unlinking method)
+
+CharDelete.MinLevel = 0
+
+#
+#    CharDelete.KeepDays
+#        Description: Time (in days) before unlinked characters will be removed from the database.
+#        Default:     30 - (Enabled)
+#                     0  - (Disabled, Don't delete any characters)
+
+CharDelete.KeepDays = 30
+
+#
+###################################################################################################
+
+###################################################################################################
+# CUSTOM SERVER OPTIONS
+#
+#    PlayerStart.AllReputation
+#        Description: Players will start with most of the high level reputations that are needed
+#                     for items, mounts etc.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+PlayerStart.AllReputation = 0
+
+#
+#    PlayerStart.AllSpells
+#        Description: If enabled, players will start with all their class spells (not talents).
+#                     You must populate playercreateinfo_spell_custom table with the spells you
+#                     want, or this will not work! The table has data for all classes / races up
+#                     to TBC expansion.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+PlayerStart.AllSpells = 0
+
+#
+#    PlayerStart.MapsExplored
+#        Description: Characters start with all maps explored.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+PlayerStart.MapsExplored = 0
+
+#
+#    HonorPointsAfterDuel
+#        Description: Amount of honor points the duel winner will get after a duel.
+#        Default:     0  - (Disabled)
+#                     1+ - (Enabled)
+
+HonorPointsAfterDuel = 0
+
+#
+#    AlwaysMaxWeaponSkill
+#        Description: Players will automatically gain max weapon/defense skill when logging in,
+#                     or leveling.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+AlwaysMaxWeaponSkill = 0
+
+#
+#    PvPToken.Enable
+#        Description: Character will receive a token after defeating another character that yields
+#                     honor.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+PvPToken.Enable = 0
+
+#
+#    PvPToken.MapAllowType
+#        Description: Define where characters can receive tokens.
+#        Default:     4 - (All maps)
+#                     3 - (Battlegrounds)
+#                     2 - (FFA areas only like Gurubashi arena)
+#                     1 - (Battlegrounds and FFA areas)
+
+PvPToken.MapAllowType = 4
+
+#
+#    PvPToken.ItemID
+#        Description: Item characters will receive after defeating another character if PvP Token
+#                     system is enabled.
+#        Default:     29434 - (Badge of justice)
+
+PvPToken.ItemID = 29434
+
+#
+#    PvPToken.ItemCount
+#        Description: Number of tokens a character will receive.
+#        Default:     1
+
+PvPToken.ItemCount = 1
+
+#
+#    NoResetTalentsCost
+#        Description: Resetting talents doesn't cost anything.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+NoResetTalentsCost = 0
+
+#
+#     Guild.AllowMultipleGuildMaster
+#        Description: Allow more than one guild master. Additional Guild Masters must be set using
+#                     the ".guild rank" command.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Guild.AllowMultipleGuildMaster = 0
+
+#
+#     ShowKickInWorld
+#        Description: Determines whether a message is broadcasted to the entire server when a
+#                     player gets kicked
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ShowKickInWorld = 1
+
+#     ShowMuteInWorld
+#        Description: Determines whether a message is broadcasted to the entire server when a
+#                     player gets muted.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ShowMuteInWorld = 1
+
+#
+#     ShowBanInWorld
+#        Description: Determines whether a message is broadcasted to the entire server when a
+#                     player gets banned.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+ShowBanInWorld = 1
+
+#
+#     RecordUpdateTimeDiffInterval
+#        Description: Time (in milliseconds) update time diff is written to the log file.
+#                     Update diff can be used as a performance indicator. Diff < 300: good
+#                     performance. Diff > 600 bad performance, may be caused by high CPU usage.
+#        Default:     60000 - (Enabled, 1 minute)
+#                     0     - (Disabled)
+
+RecordUpdateTimeDiffInterval = 60000
+#
+#     MinRecordUpdateTimeDiff
+#        Description: Only record update time diff which is greater than this value.
+#        Default:     100
+
+MinRecordUpdateTimeDiff = 100
+
+#
+#     PlayerStart.String
+#        Description: String to be displayed at first login of newly created characters.
+#         Default:    "" - (Disabled)
+
+PlayerStart.String = ""
+
+#
+#     LevelReq.Trade
+#        Description: Level requirement for characters to be able to trade.
+#        Default:     1
+
+LevelReq.Trade = 1
+
+#
+#     LevelReq.Ticket
+#        Description: Level requirement for characters to be able to write tickets.
+#        Default:     1
+
+LevelReq.Ticket = 1
+
+#
+#     LevelReq.Auction
+#        Description: Level requirement for characters to be able to use the auction house.
+#        Default:     1
+
+LevelReq.Auction = 1
+
+#
+#     LevelReq.Mail
+#        Description: Level requirement for characters to be able to send and receive mails.
+#        Default:     1
+
+LevelReq.Mail = 1
+
+#
+#     Anticheat.Enable
+#        Description: Enables or disables the Anticheat System functionality
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+Anticheat.Enable = 1
+
+#     Anticheat.ReportsForIngameWarnings
+#        Description: How many reports the player must have to notify to GameMasters ingame when he generates a new report.
+#        Default:     70
+
+Anticheat.ReportsForIngameWarnings = 70
+
+#     Anticheat.DetectionsEnabled
+#        Description: It represents which detections are enabled.
+#
+#        SPEED_HACK_DETECTION            = 1
+#        FLY_HACK_DETECTION              = 2
+#        WALK_WATER_HACK_DETECTION       = 4
+#        JUMP_HACK_DETECTION             = 8
+#        TELEPORT_PLANE_HACK_DETECTION   = 16
+#        CLIMB_HACK_DETECTION            = 32
+#
+#        Default:     31
+
+Anticheat.DetectionsEnabled = 63
+
+#     Anticheat.MaxReportsForDailyReport
+#        Description: How many reports must the player have to make a report that it is in DB for a day (not only during the player's session).
+#        Default:     70
+
+Anticheat.MaxReportsForDailyReport = 70
+
+#
+#     PlayerDump.DisallowPaths
+#        Description: Disallow using paths in PlayerDump output files
+#        Default:     1
+
+PlayerDump.DisallowPaths = 1
+
+#
+#     PlayerDump.DisallowOverwrite
+#        Description: Disallow overwriting existing files with PlayerDump
+#        Default:     1
+
+PlayerDump.DisallowOverwrite = 1
+
+#
+#     UI.ShowQuestLevelsInDialogs
+#        Description: Show quest levels next to quest titles in UI dialogs
+#        Example: [13] Westfall Stew
+#        Default: 0 (do not show)
+
+UI.ShowQuestLevelsInDialogs = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+#  LOGGING SYSTEM SETTINGS
+#
+#  Appender config values: Given a appender "name"
+#    Appender.name
+#        Description: Defines 'where to log'
+#        Format:      Type,LogLevel,Flags,optional1,optional2,optional3
+#
+#                     Type
+#                         0 - (None)
+#                         1 - (Console)
+#                         2 - (File)
+#                         3 - (DB)
+#
+#                     LogLevel
+#                         0 - (Disabled)
+#                         1 - (Trace)
+#                         2 - (Debug)
+#                         3 - (Info)
+#                         4 - (Warn)
+#                         5 - (Error)
+#                         6 - (Fatal)
+#
+#                     Flags:
+#                         0 - None
+#                         1 - Prefix Timestamp to the text
+#                         2 - Prefix Log Level to the text
+#                         4 - Prefix Log Filter type to the text
+#                         8 - Append timestamp to the log file name. Format: YYYY-MM-DD_HH-MM-SS (Only used with Type = 2)
+#                        16 - Make a backup of existing file before overwrite (Only used with Mode = w)
+#
+#                     Colors (read as optional1 if Type = Console)
+#                         Format: "fatal error warn info debug trace"
+#                         0 - BLACK
+#                         1 - RED
+#                         2 - GREEN
+#                         3 - BROWN
+#                         4 - BLUE
+#                         5 - MAGENTA
+#                         6 - CYAN
+#                         7 - GREY
+#                         8 - YELLOW
+#                         9 - LRED
+#                        10 - LGREEN
+#                        11 - LBLUE
+#                        12 - LMAGENTA
+#                        13 - LCYAN
+#                        14 - WHITE
+#                         Example: "13 11 9 5 3 1"
+#
+#                     File: Name of the file (read as optional1 if Type = File)
+#                         Allows to use one "%s" to create dynamic files
+#
+#                     Mode: Mode to open the file (read as optional2 if Type = File)
+#                          a - (Append)
+#                          w - (Overwrite)
+#
+#                     MaxFileSize: Maximum file size of the log file before creating a new log file
+#                     (read as optional3 if Type = File)
+#                         Size is measured in bytes expressed in a 64-bit unsigned integer.
+#                         Maximum value is 4294967295 (4 gb). Leave blank for no limit.
+#                         NOTE: Does not work with dynamic filenames.
+#                         Example:  536870912 (512 mb)
+#
+
+Appender.Console=1,3,0,13 11 9 5 3 1
+Appender.Server=2,2,3,Server.log,w
+Appender.GM=2,2,3,GM.log
+Appender.DBErrors=2,2,3,DBErrors.log
+Appender.Char=2,2,3,Char.log,w
+Appender.RA=2,2,3,RA.log
+Appender.Warden=2,4,3,Warden.log
+Appender.Chat=2,2,3,Chat.log
+Appender.CharDump=2,2,3,%s.log
+Appender.Arenas=2,2,3,Arena.log
+Appender.SQLDev=2,2,3,SQLDev.log
+Appender.SQLDriver=2,2,3,SQLDriver.log
+
+#    Appenders
+#        Description: List of Appenders to read from config
+#                     (Using spaces as separator).
+#        Default:     "Console Server GM DBErrors Char RA Warden Chat"
+
+Appenders=Console Server GM DBErrors Char RA Warden Chat
+
+#  Logger config values: Given a logger "name"
+#    Logger.name
+#        Description: Defines 'What to log'
+#        Format:      Type,LogLevel,AppenderList
+#                     Type
+#                         0 - Default. Each type that has no config will
+#                             rely on this one. Core will create this logger
+#                             (disabled) if it's not configured
+#                         1 - Units that doesn't fit in other categories
+#                         2 - Pets
+#                         3 - Vehicles
+#                         4 - C++ AI, instance scripts, etc.
+#                         5 - DB AI, such as SAI, EAI, CreatureAI
+#                         6 - DB map scripts
+#                         7 - Network input/output,
+#                             such as packet handlers and netcode logs
+#                         8 - Spellsystem and aurasystem
+#                         9 - Achievement system
+#                        10 - Condition system
+#                        11 - Pool system
+#                        12 - Auction house
+#                        13 - Arena's and battlegrounds
+#                        14 - Outdoor PVP
+#                        15 - Chat system
+#                        16 - LFG system
+#                        17 - Maps, instances (not scripts),
+#                             grids, cells, visibility, etc.
+#                        18 - Player that doesn't fit in other categories.
+#                        19 - Player loading from DB
+#                             (Player::_LoadXXX functions)
+#                        20 - Items
+#                        21 - Player skills (do not confuse with spells)
+#                        22 - Player chat logs
+#                        23 - loot
+#                        24 - guilds
+#                        25 - transports
+#                        26 - SQL. DB errors
+#                        27 - GM Commands
+#                        28 - Remote Access Commands
+#                        29 - Warden
+#                        30 - Authserver
+#                        31 - Worldserver
+#                        32 - Game Events
+#                        33 - Calendar
+#                        34 - Character (Exclusive to log login, logout, create, rename)
+#                        35 - Arenas
+#                        36 - SQL Driver
+#                        37 - SQL Dev
+#                        38 - Player Dump
+#                        39 - Battlefield
+#                        40 - Server Loading
+#                        41 - Opcodes (just id and name sent / received)
+#                        42 - SOAP
+#
+#                     LogLevel
+#                         0 - (Disabled)
+#                         1 - (Trace)
+#                         2 - (Debug)
+#                         3 - (Info)
+#                         4 - (Warn)
+#                         5 - (Error)
+#                         6 - (Fatal)
+#
+#                     AppenderList: List of appenders linked to logger
+#                     (Using spaces as separator).
+#
+
+Logger.Root=0,5,Console Server
+Logger.Chat=22,2,Chat
+Logger.DBErrors=26,5,Console Server DBErrors
+Logger.GM=27,3,Console Server GM
+Logger.RA=28,3,RA
+Logger.Warden=29,4,Warden
+Logger.WorldServer=31,3,Console Server
+Logger.Character=34,3,Char
+Logger.Arenas=35,3,Arenas
+Logger.SQLDriver=36,5,SQLDriver
+Logger.SQLDev=37,3,SQLDev
+Logger.CharDump=38,3,CharDump
+Logger.Load=40,3,Console Server
+Logger.Opcodes=41,6,Console Server
+
+#
+#    Loggers
+#        Description: List of Loggers to read from config
+#                     (Using spaces as separator).
+#        Default:     "Root Chat DBErrors GM RA Warden Character Load"
+
+Loggers=Root Chat DBErrors GM RA Warden Character Load WorldServer Opcodes
+
+#
+#    Log.Async.Enable
+#        Description: Enables asyncronous message logging.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+Log.Async.Enable = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+#  GUILD LEVELING SETTINGS
+#
+#    Guild.LevelingEnabled
+#        Description: Controls whether guild can gain levels
+#        Default:     1
+#
+
+Guild.LevelingEnabled = 1
+
+#
+#    Guild.SaveInterval
+#        Description: Time (in minutes) between guild experience saves
+#        Default:     15
+#
+
+Guild.SaveInterval = 15
+
+#
+#    Guild.MaxLevel
+#        Description: Defines max level a guild can reach
+#        Default:     25
+#
+
+Guild.MaxLevel = 25
+
+#
+#    Guild.UndeletableLevel
+#        Description: Guild reaching this level (and higher) cannot be disbanded anymore
+#        Default:     4
+#
+
+Guild.UndeletableLevel = 4
+
+#
+#    Guild.XPModifier
+#        Description: Multiplier for guild experience gained from quests
+#        Default:     0.25
+#
+
+Guild.XPModifier = 0.25
+
+#
+#    Guild.DailyXPCap
+#        Description: Maximum experience points a guild can earn each day
+#        Default:     7807500
+#
+
+Guild.DailyXPCap = 7807500
+
+#
+#    Guild.WeeklyReputationCap
+#        Description: Maximum guild reputation a player can earn every week
+#        Default:     4375
+#
+
+Guild.WeeklyReputationCap = 4375
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# CURRENCIES SETTINGS
+#
+#    Currency.ResetInterval
+#        How often should currency week count reset (days)
+#        Default: 7 (weekly)
+#
+
+Currency.ResetInterval = 7
+
+#
+#    Currency.ResetWeekDay
+#        Week day when currency week count is reset (0..6) 0 == Sunday
+#        Default: 3 (Wednesday)
+#
+
+Currency.ResetWeekDay = 3
+
+#
+#    Currency.ResetHour
+#        Hour of a day when currency week count is reset (0..23)
+#        Default: 6
+#
+
+Currency.ResetHour = 6
+
+#
+#    Currency.StartHonorPoints
+#        Amount of honor points that new players will start with
+#        Default: 0 (with precision)
+#
+
+Currency.StartHonorPoints = 0
+
+#
+#    Currency.MaxHonorPoints
+#        Amount honor points a player can have
+#        Default: 4000
+#
+
+Currency.MaxHonorPoints = 4000
+
+#
+#    Currency.StartJusticePoints
+#        Amount of justice points that new players will start with
+#        Default: 0 (with precision)
+#
+
+Currency.StartJusticePoints = 0
+
+#
+#    Currency.MaxJusticePoints
+#        Amount justice points a player can have
+#        Default: 4000
+#
+
+Currency.MaxJusticePoints = 4000
+
+#
+#    Currency.StartConquestPoints
+#        Amount of conquest points that new players will start with
+#        Default: 0 (with precision)
+#
+
+Currency.StartConquestPoints = 0
+
+#
+#    Currency.ConquestPointsWeekCap
+#        Amount of conquest points that player can earn per week
+#        Default: 1350
+#
+
+Currency.ConquestPointsWeekCap = 1350
+
+#
+#    Currency.ConquestPointsArenaReward
+#        Amount of conquest points rewarded by winning arenas
+#        Default: 180
+#
+
+Currency.ConquestPointsArenaReward = 180
+
+#
+###################################################################################################
+#                           CUSTOM CONTENT WOW-SOURCES SETTINGS                                   #
+#                                                                                                 #
+###################################################################################################
+# ALLOW ZONE AND AREA VALUES CORRECTION AT STARTUP FOR GAMEOBJECT AND CREATURE TABLES
+#
+# Enable : 1
+# Default : 0
+#
+
+AllowZoneAndAreaCheckForCreatureAndGameobject = 0
+
+#
+###################################################################################################
+
+###########################################################
+#
+#          Double Movement speed
+#        The movement speed is x2 outdoor, inside of Instances/BG/Raids it is 1
+#          (Default: 0) to active set = 1
+#
+DoubleMovementSpeed = 0
+##########################################################
+
+###################################################################################################
+#
+#    Currency.StartJusticePoints
+#        Amount of valor points that new players will start with
+#        Default: 0 (with precision)
+#
+
+Currency.StartValorPoints = 0
+
+#
+#    Currency.StartConquestPoints
+#        Amount of conquest points that new players will start with
+#        Default: 0 (with precision)
+#
+###################################################################################################
+
+###################################################################################################
+#
+# a stack will be generating at core loading with free item guid that were < of max free guid.
+# resolved loss in item guid gestion in the database.
+# default : 0 (disable)
+# tested with 500000 and 1k5 players online (no loss)
+
+ItemLoading.stackSize = 0
+
+#
+# improved core startup speed, request all item guid for 2000 range (select guid > x  and guid < x + 2000
+# with an old databse with more than 16000000 of items, with 2000 range and 500000 stacksize guid loading take aroune 5 seconds.
+#
+
+ItemLoading.requestSize = 2000
+
+#
+####################################################################################################
+
+###########################################################
+#   Homepage Settings
+#
+#    HPGold.Refresh.Enabled
+#        Description: activates homepage gold sync with session
+#        Default:     0 - (Disable)
+#                     1 - (Enable)
+
+HPGold.Refresh.Enabled = 1
+
+#
+#   HPGold.Refresh.Interval
+#       Description: interval for sync with hp gold
+#       Default: 10 (seconds)
+
+HPGold.Refresh.Interval = 10
+
+###########################################################
+
+###########################################################
+#   Cronjob Settings
+#
+#    Cronjobs.Enabled
+#        Description: activates cronjobs
+#        Default:     1 - (Enable)
+#                     0 - (Disable)
+#                     
+
+Cronjobs.Enabled = 1
+
+#
+#   Cronjobs.Execute.Interval
+#       Description: interval to execute cronjobs
+#       Default: 5 (seconds)
+
+Cronjobs.Execute.Interval = 5
+
+###########################################################
+
+###########################################################
+#   Duel Reset Settings
+#
+#    DuelResetCooldown.Enabled
+#        Description: activates cooldown reset for duels.
+#        Default:     0 - (Disable)
+#                     1 - (Enable)
+
+DuelResetCooldown.Enable = 1
+
+#   Duel Area allowed
+#        Description: Set the id of the area.
+#        Deafult:     NULL - (Disabled)
+#                     AREAID - (Enabled) (Exemple 5) use .gps ingame to know area.
+                      
+DuelReset.Area.One = NULL                        
+DuelReset.Area.Two = NULL                
-- 
1.7.10.4

