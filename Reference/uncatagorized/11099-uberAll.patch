From 51927cdae471e49b13e72f0794df40033bfe3beb Mon Sep 17 00:00:00 2001
From: root <root@deb.privatedns.com>
Date: Tue, 1 Feb 2011 02:27:38 -0500
Subject: [PATCH] 11099-uberAll

---
 README.NPCTELEPORT                                 |   14 +
 doc/AuctionHouseBot.txt                            |  236 ++
 sql/All/character_VIPAccount.sql                   |    8 +
 sql/All/characters_anticheat.sql                   |   14 +
 sql/All/characters_bots.sql                        |    8 +
 sql/All/characters_jail.sql                        |   66 +
 sql/All/world_DalaranSewers.sql                    |    4 +
 sql/All/world_ahbot.sql                            |   72 +
 sql/All/world_argenttournament.sql                 |  425 ++
 sql/All/world_bots.sql                             |  246 ++
 sql/All/world_bots_update.sql                      |   13 +
 sql/All/world_command_Deutsch.sql                  |    7 +
 sql/All/world_command_English.sql                  |    7 +
 sql/All/world_command_Francais.sql                 |    7 +
 sql/All/world_icc.sql                              |  510 +++
 sql/All/world_icc_loot.sql                         | 1703 ++++++++
 sql/All/world_npc_teleport.sql                     |  119 +
 sql/All/world_ruby_sanctum.sql                     |   82 +
 sql/All/world_trinity_string.sql                   |   41 +
 sql/All/world_wintergrasp.sql                      |  132 +
 sql/CMakeLists.txt                                 |    1 +
 sql/Wintergrasp_world.sql                          |  132 +
 src/server/authserver/Server/AuthSocket.cpp        |    3 +
 src/server/game/AI/Bots/PlayerbotAI.cpp            | 4387 ++++++++++++++++++++
 src/server/game/AI/Bots/PlayerbotAI.h              |  284 ++
 src/server/game/AI/Bots/PlayerbotClassAI.cpp       |  594 +++
 src/server/game/AI/Bots/PlayerbotClassAI.h         |  162 +
 src/server/game/AI/Bots/PlayerbotDeathKnightAI.cpp |  325 ++
 src/server/game/AI/Bots/PlayerbotDeathKnightAI.h   |   61 +
 src/server/game/AI/Bots/PlayerbotDruidAI.cpp       |  676 +++
 src/server/game/AI/Bots/PlayerbotDruidAI.h         |   70 +
 src/server/game/AI/Bots/PlayerbotHunterAI.cpp      |  561 +++
 src/server/game/AI/Bots/PlayerbotHunterAI.h        |   70 +
 src/server/game/AI/Bots/PlayerbotMageAI.cpp        |  384 ++
 src/server/game/AI/Bots/PlayerbotMageAI.h          |   69 +
 src/server/game/AI/Bots/PlayerbotPaladinAI.cpp     |  536 +++
 src/server/game/AI/Bots/PlayerbotPaladinAI.h       |   70 +
 src/server/game/AI/Bots/PlayerbotPriestAI.cpp      |  400 ++
 src/server/game/AI/Bots/PlayerbotPriestAI.h        |   59 +
 src/server/game/AI/Bots/PlayerbotRogueAI.cpp       |  266 ++
 src/server/game/AI/Bots/PlayerbotRogueAI.h         |   41 +
 src/server/game/AI/Bots/PlayerbotShamanAI.cpp      |  555 +++
 src/server/game/AI/Bots/PlayerbotShamanAI.h        |   75 +
 src/server/game/AI/Bots/PlayerbotWarlockAI.cpp     |  410 ++
 src/server/game/AI/Bots/PlayerbotWarlockAI.h       |   57 +
 src/server/game/AI/Bots/PlayerbotWarriorAI.cpp     |  400 ++
 src/server/game/AI/Bots/PlayerbotWarriorAI.h       |   57 +
 src/server/game/AI/CoreAI/PetAI.cpp                |    9 +
 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp  |  373 ++
 src/server/game/AI/ScriptedAI/sc_npc_teleport.h    |  151 +
 src/server/game/Anticheat/AnticheatMgr.cpp         |  206 +
 src/server/game/Anticheat/AnticheatMgr.h           |   52 +
 .../AuctionHouseBot/AuctionHouseBot.cpp            | 1884 +++++++++
 .../AuctionHouse/AuctionHouseBot/AuctionHouseBot.h | 1247 ++++++
 src/server/game/AuctionHouse/AuctionHouseMgr.cpp   |   13 +-
 src/server/game/AuctionHouse/AuctionHouseMgr.h     |    2 +
 .../game/Battlegrounds/Zones/BattlegroundDS.cpp    |   42 +
 .../game/Battlegrounds/Zones/BattlegroundDS.h      |    9 +-
 src/server/game/CMakeLists.txt                     |    9 +
 src/server/game/Chat/Chat.cpp                      |   31 +-
 src/server/game/Chat/Chat.h                        |   21 +
 src/server/game/Chat/Commands/Level0.cpp           |  234 ++-
 src/server/game/Chat/Commands/Level1.cpp           |  292 ++-
 src/server/game/Chat/Commands/Level2.cpp           |  243 ++-
 src/server/game/Chat/Commands/Level3.cpp           |  703 ++++
 src/server/game/Entities/Creature/Creature.cpp     |    3 +
 src/server/game/Entities/Creature/Creature.h       |   15 +
 src/server/game/Entities/Creature/GossipDef.h      |    1 +
 .../game/Entities/Creature/TemporarySummon.cpp     |    8 +
 src/server/game/Entities/GameObject/GameObject.cpp |    4 +-
 src/server/game/Entities/Object/Object.cpp         |   27 +-
 src/server/game/Entities/Player/Player.cpp         | 1752 +++++++-
 src/server/game/Entities/Player/Player.h           |  148 +-
 src/server/game/Entities/Unit/Unit.cpp             |   18 +
 src/server/game/Globals/ObjectMgr.cpp              |  115 +
 src/server/game/Globals/ObjectMgr.h                |   27 +
 src/server/game/Groups/Group.cpp                   |  140 +-
 src/server/game/Groups/Group.h                     |   19 +-
 src/server/game/Mails/Mail.cpp                     |    8 +
 src/server/game/Maps/Map.cpp                       |   24 +-
 src/server/game/Miscellaneous/Formulas.h           |    4 +-
 src/server/game/Miscellaneous/Language.h           |   59 +
 src/server/game/OutdoorPvP/OutdoorPvP.h            |    3 +-
 src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp       |    1 +
 src/server/game/Quests/QuestDef.h                  |    4 +-
 src/server/game/Scripting/ScriptLoader.cpp         |   87 +-
 src/server/game/Scripting/ScriptMgr.cpp            |   23 +-
 src/server/game/Scripting/ScriptMgr.h              |    3 +
 .../Protocol/Handlers/AuctionHouseHandler.cpp      |    1 +
 .../Protocol/Handlers/BattleGroundHandler.cpp      |   14 +
 .../Server/Protocol/Handlers/CharacterHandler.cpp  |  175 +
 .../game/Server/Protocol/Handlers/ChatHandler.cpp  |   34 +-
 .../game/Server/Protocol/Handlers/GroupHandler.cpp |   35 +-
 .../Server/Protocol/Handlers/MovementHandler.cpp   |    4 +
 .../game/Server/Protocol/Handlers/NPCHandler.cpp   |    6 +-
 .../game/Server/Protocol/Handlers/PetHandler.cpp   |    9 +
 .../game/Server/Protocol/Handlers/QuestHandler.cpp |    1 +
 src/server/game/Server/WorldSession.cpp            |  120 +-
 src/server/game/Server/WorldSession.h              |   17 +-
 src/server/game/Server/WorldSocket.cpp             |   13 +-
 src/server/game/Spells/Auras/SpellAuraEffects.cpp  |    7 +
 src/server/game/Spells/Spell.cpp                   |   12 +
 src/server/game/Spells/SpellEffects.cpp            |   82 +-
 src/server/game/Spells/SpellMgr.cpp                |   17 +
 src/server/game/Weather/Weather.cpp                |    2 +-
 src/server/game/World/World.cpp                    |   76 +-
 src/server/game/World/World.h                      |   33 +
 src/server/scripts/Bots/CMakeLists.txt             |   26 +
 src/server/scripts/Bots/bot_ai.cpp                 |  565 +++
 src/server/scripts/Bots/bot_ai.h                   |   89 +
 src/server/scripts/Bots/bot_druid_ai.cpp           |  563 +++
 src/server/scripts/Bots/bot_druid_ai.h             |   63 +
 src/server/scripts/Bots/bot_hunter_ai.cpp          |  304 ++
 src/server/scripts/Bots/bot_hunter_ai.h            |   27 +
 src/server/scripts/Bots/bot_mage_ai.cpp            |  523 +++
 src/server/scripts/Bots/bot_mage_ai.h              |  127 +
 src/server/scripts/Bots/bot_paladin_ai.cpp         |  276 ++
 src/server/scripts/Bots/bot_paladin_ai.h           |   62 +
 src/server/scripts/Bots/bot_priest_ai.cpp          |  276 ++
 src/server/scripts/Bots/bot_priest_ai.h            |   33 +
 src/server/scripts/Bots/bot_rogue_ai.cpp           |  314 ++
 src/server/scripts/Bots/bot_rogue_ai.h             |   31 +
 src/server/scripts/Bots/bot_shaman_ai.cpp          |  386 ++
 src/server/scripts/Bots/bot_shaman_ai.h            |   48 +
 src/server/scripts/Bots/bot_warlock_ai.cpp         |  292 ++
 src/server/scripts/Bots/bot_warlock_ai.h           |   42 +
 src/server/scripts/Bots/bot_warrior_ai.cpp         |  502 +++
 src/server/scripts/Bots/bot_warrior_ai.h           |   87 +
 src/server/scripts/Bots/script_bot_giver.cpp       |  233 ++
 src/server/scripts/CMakeLists.txt                  |    5 +
 src/server/scripts/Commands/CMakeLists.txt         |    1 +
 src/server/scripts/Commands/cs_anticheat.cpp       |  307 ++
 src/server/scripts/Commands/cs_gm.cpp              |    4 +-
 src/server/scripts/Custom/CMakeLists.txt           |    1 +
 src/server/scripts/Custom/npc_teleport.cpp         |  222 +
 src/server/scripts/Custom/resetduel.cpp            |   26 +
 .../scripts/EasternKingdoms/silvermoon_city.cpp    |    4 +-
 src/server/scripts/Northrend/CMakeLists.txt        |   26 +-
 .../IcecrownCitadel/boss_gunship_battle.cpp        |  164 +
 .../Northrend/IcecrownCitadel/boss_sindragosa.cpp  |  724 ++++
 .../IcecrownCitadel/boss_the_lich_king.cpp         | 1369 ++++++
 .../IcecrownCitadel/boss_valithria_dreamwalker.cpp | 1424 +++++++
 .../Northrend/IcecrownCitadel/icecrown_citadel.h   |  144 +-
 .../IcecrownCitadel/icecrown_citadel_teleport.cpp  |    6 +-
 .../IcecrownCitadel/instance_icecrown_citadel.cpp  |  248 +-
 .../Northrend/RubySanctum/boss_baltharus.cpp       |  365 ++
 .../scripts/Northrend/RubySanctum/boss_halion.cpp  |  807 ++++
 .../Northrend/RubySanctum/boss_ragefire.cpp        |  191 +
 .../Northrend/RubySanctum/boss_zarithrian.cpp      |  230 +
 .../RubySanctum/instance_ruby_sanctum.cpp          |  269 ++
 .../scripts/Northrend/RubySanctum/ruby_sanctum.h   |   74 +
 .../VaultOfArchavon/instance_vault_of_archavon.cpp |   17 +
 src/server/scripts/Northrend/grizzly_hills.cpp     |  215 +
 src/server/scripts/Northrend/icecrown.cpp          | 1051 +++++-
 src/server/scripts/Northrend/wintergrasp.cpp       |   90 +
 src/server/scripts/OutdoorPvP/CMakeLists.txt       |    2 +
 src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp     | 2306 ++++++++++
 src/server/scripts/OutdoorPvP/OutdoorPvPWG.h       |  341 ++
 src/server/shared/Common.h                         |    4 +
 .../Database/Implementation/LoginDatabase.cpp      |    1 +
 .../shared/Database/Implementation/LoginDatabase.h |    1 +
 src/server/worldserver/worldserver.conf.dist       |  418 ++
 162 files changed, 38697 insertions(+), 320 deletions(-)
 create mode 100644 README.NPCTELEPORT
 create mode 100644 doc/AuctionHouseBot.txt
 create mode 100644 sql/All/character_VIPAccount.sql
 create mode 100644 sql/All/characters_anticheat.sql
 create mode 100644 sql/All/characters_bots.sql
 create mode 100644 sql/All/characters_jail.sql
 create mode 100644 sql/All/world_DalaranSewers.sql
 create mode 100644 sql/All/world_ahbot.sql
 create mode 100644 sql/All/world_argenttournament.sql
 create mode 100644 sql/All/world_bots.sql
 create mode 100644 sql/All/world_bots_update.sql
 create mode 100644 sql/All/world_command_Deutsch.sql
 create mode 100644 sql/All/world_command_English.sql
 create mode 100644 sql/All/world_command_Francais.sql
 create mode 100644 sql/All/world_icc.sql
 create mode 100644 sql/All/world_icc_loot.sql
 create mode 100644 sql/All/world_npc_teleport.sql
 create mode 100644 sql/All/world_ruby_sanctum.sql
 create mode 100644 sql/All/world_trinity_string.sql
 create mode 100644 sql/All/world_wintergrasp.sql
 create mode 100644 sql/Wintergrasp_world.sql
 create mode 100644 src/server/game/AI/Bots/PlayerbotAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotClassAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotClassAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotDeathKnightAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotDeathKnightAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotDruidAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotDruidAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotHunterAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotHunterAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotMageAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotMageAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotPaladinAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotPaladinAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotPriestAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotPriestAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotRogueAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotRogueAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotShamanAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotShamanAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotWarlockAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotWarlockAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotWarriorAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotWarriorAI.h
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.h
 create mode 100644 src/server/game/Anticheat/AnticheatMgr.cpp
 create mode 100644 src/server/game/Anticheat/AnticheatMgr.h
 create mode 100644 src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
 create mode 100644 src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
 create mode 100644 src/server/scripts/Bots/CMakeLists.txt
 create mode 100644 src/server/scripts/Bots/bot_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_ai.h
 create mode 100644 src/server/scripts/Bots/bot_druid_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_druid_ai.h
 create mode 100644 src/server/scripts/Bots/bot_hunter_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_hunter_ai.h
 create mode 100644 src/server/scripts/Bots/bot_mage_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_mage_ai.h
 create mode 100644 src/server/scripts/Bots/bot_paladin_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_paladin_ai.h
 create mode 100644 src/server/scripts/Bots/bot_priest_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_priest_ai.h
 create mode 100644 src/server/scripts/Bots/bot_rogue_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_rogue_ai.h
 create mode 100644 src/server/scripts/Bots/bot_shaman_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_shaman_ai.h
 create mode 100644 src/server/scripts/Bots/bot_warlock_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_warlock_ai.h
 create mode 100644 src/server/scripts/Bots/bot_warrior_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_warrior_ai.h
 create mode 100644 src/server/scripts/Bots/script_bot_giver.cpp
 create mode 100644 src/server/scripts/Commands/cs_anticheat.cpp
 create mode 100644 src/server/scripts/Custom/npc_teleport.cpp
 create mode 100644 src/server/scripts/Custom/resetduel.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
 create mode 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
 create mode 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
 create mode 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
 create mode 100644 src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel_teleport.cpp
 mode change 100755 => 100644 src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h
 create mode 100644 src/server/scripts/Northrend/wintergrasp.cpp
 create mode 100644 src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
 create mode 100644 src/server/scripts/OutdoorPvP/OutdoorPvPWG.h

diff --git a/README.NPCTELEPORT b/README.NPCTELEPORT
new file mode 100644
index 0000000..015c9c2
--- /dev/null
+++ b/README.NPCTELEPORT
@@ -0,0 +1,14 @@
+NPC Teleport for Trinity
+
+Original author : Wilibald09
+
+Allows you to add a custom NPC for teleporting, using .npc add 100000.
+The default NPC is entry 100000.
+
+All settings are located in the DB, so you can customize and add destinations,
+set level restrictions and also charge the player for teleporting.
+
+Installation:
+
+Run the query setup_npc_teleport.sql located in the trinity sql directory on
+your world DB. This will setup the DB and you can customize from there.
diff --git a/doc/AuctionHouseBot.txt b/doc/AuctionHouseBot.txt
new file mode 100644
index 0000000..cc15a08
--- /dev/null
+++ b/doc/AuctionHouseBot.txt
@@ -0,0 +1,236 @@
+Populates the auction houses with items. It can make the game feel a bit more
+like official on small servers. Items and prices are chosen randomly based on
+the parameters you define. If an auction expires, auctions are deleted quietly.
+AHBot will not buy it's own items, and will not receive mail from the AH
+or get returned mail.
+
+===============================================================================
+~~HOW TO CONFIGURE~~
+===============================================================================
+Step 1.) Create a character that you are going to use as the auction house bot
+         character. This character will be the auction's owner for all the
+         items created by the bot.
+Step 2.) Go into the realm database and note the account number for the
+         character.
+Step 3.) Go into the characters database and note the character's GUID.
+Step 4.) Log in at least once with this character.
+         (Do not change the configuration before this)
+Step 5.) Tune the configuration options in the configuration file and the
+         Database.
+
+#These are the settings in the configuration file:
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+AuctionHouseBot.DEBUG enables (1) or disables (0) Debug output
+AuctionHouseBot.EnableSeller enables (1) or disables (0) the Seller
+AuctionHouseBot.EnableBuyer enables (1) or disables (0) the Buyer
+AuctionHouseBot.UseBuyPriceForSeller Use SellPrice (0) or BuyPrice (1) for determining prices
+AuctionHouseBot.UseBuyPriceForBuyer Use SellPrice (0) or BuyPrice (1) for determining prices
+AuctionHouseBot.Account is the account number (in realmd->account table) of the player you want to run as the auction bot. Note: a value of 0 will disable the bot.
+AuctionHouseBot.GUID is the GUID (in characters->characters table) of the player you want to run as the auction bot. Note: a value of 0 will disable the bot.
+AuctionHouseBot.ItemsPerCycle determines how many items are added each time AHBot is run (once per minute, by default)
+
+#These are the Filters For filtering certain items/trade goods from the AH
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisableBeta_PTR_Unused = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+
+AuctionHouseBot.VendorItems is a boolean value (0 or 1) that indicates whether to include Vendor only items
+AuctionHouseBot.VendorTradeGoods is a boolean value (0 or 1) that indicates whether to include Vendor only Trade Goods
+AuctionHouseBot.LootItems  is a boolean value (0 or 1) that indicates whether to include Loot/Fish/Skin/etc. only items
+AuctionHouseBot.LootTradeGoods  is a boolean value (0 or 1) that indicates whether to include Loot/Fish/Skin/etc. only Trade Goods
+AuctionHouseBot.OtherItems  is a boolean value (0 or 1) that indicates whether to include Other items not covered by the first 2
+AuctionHouseBot.OtherTradeGoods  is a boolean value (0 or 1) that indicates whether to include Other Trade Goods not covered by the first 2
+AuctionHouseBot.No_Bind is a boolean value (0 or 1) that indicates whether to include items with a bonding of 0
+AuctionHouseBot.Bind_When_Picked_Up = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 1
+AuctionHouseBot.Bind_When_Equipped = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 2
+AuctionHouseBot.Bind_When_Use = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 3
+AuctionHouseBot.Bind_Quest_Item = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 4
+AuctionHouseBot.DisableBeta_PTR_Unused is a boolean value (0 or 1) that will Disable certain items that are usually unavailable to Players
+AuctionHouseBot.DisablePermEnchant is a boolean value (0 or 1) that will Disable Items with a Permanent Enchantment
+AuctionHouseBot.DisableConjured is a boolean value (0 or 1) that will Disable Conjured Items
+AuctionHouseBot.DisableGems is a boolean value (0 or 1) that will Disable Gems
+AuctionHouseBot.DisableMoney is a boolean value (0 or 1) that will Disable Items that are used as money
+AuctionHouseBot.DisableMoneyLoot is a boolean value (0 or 1) that will Disable Items that have Money as a loot
+AuctionHouseBot.DisableLootable is a boolean value (0 or 1) that will Disable Items that have other items as loot
+AuctionHouseBot.DisableKeys is a boolean value (0 or 1) that will Disable Items that are keys
+AuctionHouseBot.DisableDuration is a boolean value (0 or 1) that will Disable Items with a duration
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel is a boolean value (0 or 1) that will Disable items that are BOP or Quest Item with a Required level that is less than the Item Level
+
+#These Filters are boolean (0 or 1) and will disable items that are
+#specifically meant for the Class named.
+#(UnusedClass is Class 10, which was skipped for some reason)
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+#These are the Filters For filtering certain items/trade goods from the AH
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
+#These are the settings in the Database:
+#Each Auctionhouse has it's own set of these
+
+MinItems = 0
+#The Minimum number of items you want to keep in the auction houses.
+#(default 0 - minimum will be the same as maximum).
+#If it is higher than the value of the corresponding maxItems setting,
+#it will be set down to match the maxItems setting.
+
+MaxItems = 0
+#The Maximum number of items you want to keep in the auction houses.
+
+#These must add up to 100 each one is the percentage
+#of the auction items that should be trade goods of
+#that quality. A value of 0 will disable.
+
+PercentGreyTradeGoods = 0
+PercentWhiteTradeGoods = 27
+PercentGreenTradeGoods = 12
+PercentBlueTradeGoods = 10
+PercentPurpleTradeGoods = 1
+PercentOrangeTradeGoods = 0
+PercentYellowTradeGoods = 0
+
+PercentGreyItems = 0
+PercentWhiteItems = 10
+PercentGreenItems = 30
+PercentBlueItems = 8
+PercentPurpleItems = 2
+PercentOrangeItems = 0
+PercentYellowItems = 0
+
+#MinPrice(Color)    is the minimum price adjustment for items. For example the default is 150, which means 150%. So if an item vendors for 1g it would go to auction for a minimum of 1.5g.
+#MaxPrice(Color)    is the maximum price adjustment for items.
+#MinBidPrice(Color) these two control the starting bid as a percent of the buyout price. For example, if MinBidPrice is 30 and MaxBidPrice is 80 the starting bid for the auction will randomly be between 30-80% of the randomly chosen buyout price.
+#MaxBidPrice(Color) these two control the starting bid as a percent of the buyout price. For example, if MinBidPrice is 30 and MaxBidPrice is 80 the starting bid for the auction will randomly be between 30-80% of the randomly chosen buyout price.
+#MaxStack(Color)    is maximum stack size to create for this quality type. A value of zero will disable the maximum stack size for this quality allowing the bot to create stacks (of random size) of items as big as the item type allows.
+
+MinPriceGrey = 100
+MaxPriceGrey = 150
+MinBidPriceGrey = 70
+MaxBidPriceGrey = 100
+MaxStackGrey = 0
+MinPriceWhite = 150
+MaxPriceWhite = 250
+MinBidPriceWhite = 70
+MaxBidPriceWhite = 100
+MaxStackWhite = 0
+MinPriceGreen = 800
+MaxPriceGreen = 1400
+MinBidPriceGreen = 80
+MaxBidPriceGreen = 100
+MaxStackGreen = 0
+MinPriceBlue = 1250
+MaxPriceBlue = 1750
+MinBidPriceBlue = 75
+MaxBidPriceBlue = 100
+MaxStackBlue = 0
+MinPricePurple = 2250
+MaxPricePurple = 4550
+MinBidPricePurple = 80
+MaxBidPricePurple = 100
+MaxStackPurple = 0
+MinPriceOrange = 4250
+MaxPriceOrange = 5550
+MinBidPriceOrange = 80
+MaxBidPriceOrange = 100
+MaxStackOrange = 0
+MinPriceYellow = 5250
+MaxPriceYellow = 6550
+MinBidPriceYellow = 80
+MaxBidPriceYellow = 100
+MaxStackYellow = 0
+
+#These are the multipliers that are applied to the vendor price for an item, that determines if AHBot will buy it or not.
+#1 means AHBot will pay the same as (or less than) a vendor would pay, 2 means up to twice as much, etc.
+
+BuyerPriceGrey = 1
+BuyerPriceWhite = 3
+BuyerPriceGreen = 5
+BuyerPriceBlue = 12
+BuyerPricePurple = 15
+BuyerPriceOrange = 20
+BuyerPriceYellow = 22
+
+#BuyerBiddingInterval is the time (in minutes) between bids.
+#BuyerBidsPerInterval is the number of bids the buyer will make in a cycle
+
+BuyerBiddingInterval = 1
+BuyerBidsPerInterval = 1
+
+
+
+How to use ahcommands from the console (CLI) or in game with GM level 3 players:
+ahbotoptions - will display usage instructions
+ahbotoptions help - will display the list of commands
+
+ahexpire - will expire all the auctions in the requested auction house that were created by AHBot.
+minitems - will set the minimum number of items in the AH before it starts being filled again.
+maxitems - will set the maximum number of items in the AH.
+percentages - will set the percentage of each quality in the AH
+minprice - will set the minimum price multiplier for auctions.
+maxprice - will set the maximum price multiplier for auctions.
+minbidprice - will set the minimum starting bid as a percent of the buyout price for auctions.
+maxbidprice - will set the maximum starting bid as a percent of the buyout price for auctions.
+maxstack - will set the maximum number of items in stacks for auctions. 0 will set the maximum to the maximum for that item type.
+buyerprice - will set the bid price multiplier for auctions.
+biddinginterval - will set the number of minutes between bids on auctions.
+bidsperinterval - will set the number of bids to enter per cycle.
+
+The auction house IDs are:
+2 - Alliance
+6 - Horde
+7 - Neutral
+
+
+AHBot Originally made by Chris K. Currently maintained by Paradox
+Much thanks to Chris K, grether and Dolomit6!
+AHBot Now includes AHBuyer created by Kerbe as a derivative of AHBot, and later modified by Paradox
diff --git a/sql/All/character_VIPAccount.sql b/sql/All/character_VIPAccount.sql
new file mode 100644
index 0000000..df317ed
--- /dev/null
+++ b/sql/All/character_VIPAccount.sql
@@ -0,0 +1,8 @@
+CREATE TABLE IF NOT EXISTS `account_premium` (
+  `id` int(11) NOT NULL default '0' COMMENT 'Account id',
+  `setdate` bigint(40) NOT NULL default '0',
+  `unsetdate` bigint(40) NOT NULL default '0',
+  `premium_type` tinyint(4) unsigned NOT NULL default '1',
+  `active` tinyint(4) NOT NULL default '1',
+  PRIMARY KEY  (`id`,`setdate`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Premium Accounts';
\ No newline at end of file
diff --git a/sql/All/characters_anticheat.sql b/sql/All/characters_anticheat.sql
new file mode 100644
index 0000000..5ee8494
--- /dev/null
+++ b/sql/All/characters_anticheat.sql
@@ -0,0 +1,14 @@
+DROP TABLE IF EXISTS `players_reports_status`;
+
+CREATE TABLE `players_reports_status` (
+  `guid` int(10) unsigned NOT NULL DEFAULT '0',
+  `creation_time` int(10) unsigned NOT NULL DEFAULT '0',
+  `average` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `total_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `speed_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `fly_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `jump_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `waterwalk_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `teleportplane_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`guid`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='';
\ No newline at end of file
diff --git a/sql/All/characters_bots.sql b/sql/All/characters_bots.sql
new file mode 100644
index 0000000..eb2362f
--- /dev/null
+++ b/sql/All/characters_bots.sql
@@ -0,0 +1,8 @@
+CREATE TABLE IF NOT EXISTS `character_npcbot` (
+  `owner` int(11) default NULL,
+  `entry` int(11) default NULL,
+  `race` tinyint(4) default NULL,
+  `class` tinyint(4) default NULL
+)  ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+
diff --git a/sql/All/characters_jail.sql b/sql/All/characters_jail.sql
new file mode 100644
index 0000000..1c33c58
--- /dev/null
+++ b/sql/All/characters_jail.sql
@@ -0,0 +1,66 @@
+/*
+MySQL Data Transfer
+Source Host: localhost
+Source Database: characters
+Target Host: localhost
+Target Database: characters
+Date: 25.04.2010 00:00:00
+*/
+DROP TABLE IF EXISTS `jail`;
+SET FOREIGN_KEY_CHECKS=0;
+-- ----------------------------
+-- Table structure for jail
+-- ----------------------------
+CREATE TABLE `jail` (
+  `guid` int(11) unsigned NOT NULL COMMENT 'GUID of the jail brother',
+  `char` varchar(13) NOT NULL COMMENT 'Jailed charname',
+  `release` int(11) unsigned NOT NULL COMMENT 'Release time for the char',
+  `amnestietime` int(11) NOT NULL,
+  `reason` varchar(255) NOT NULL COMMENT 'Reason for the jail',
+  `times` int(11) unsigned NOT NULL COMMENT 'How many times this char already was jailed',
+  `gmacc` int(11) unsigned NOT NULL COMMENT 'Used GM acc to jail this char',
+  `gmchar` varchar(13) NOT NULL COMMENT 'Used GM char to jail this char',
+  `lasttime` timestamp NOT NULL default '0000-00-00 00:00:00' on update CURRENT_TIMESTAMP COMMENT 'Last time jailed',
+  `duration` int(11) unsigned NOT NULL default '0' COMMENT 'Duration of the jail',
+  PRIMARY KEY  (`guid`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Jail table for Trinitycore by WarHead Edited by SPGM';
+
+-- ----------------------------
+-- Records 
+-- ----------------------------
+DROP TABLE IF EXISTS `jail_conf`;
+SET FOREIGN_KEY_CHECKS=0;
+-- ----------------------------
+-- Table structure for jail_conf
+-- ----------------------------
+
+CREATE TABLE `jail_conf` (
+  `id` int(11) NOT NULL auto_increment,
+  `obt` varchar(50) default NULL,
+  `jail_conf` int(11) default NULL,
+  `jail_tele` float default NULL,
+  `help_ger` varchar(255) character set latin1 default '',
+  `help_enq` varchar(255) default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;
+
+-- ----------------------------
+-- Records 
+-- ----------------------------
+INSERT INTO `jail_conf` VALUES ('1', 'm_jailconf_max_jails', '3', null, 'Hier legst ihre fest nach wie fielen Jails der Char gelöscht werden \r\nStandart = 3\r\n ', 'How many time the characters can be Jailed before being deleted\r\nDefault = 3');
+INSERT INTO `jail_conf` VALUES ('2', 'm_jailconf_max_duration', '672', null, 'Hier legst ihre fest wie hoch der maximale Jail Time in Stunden \r\nStandart = 672\r\n', 'Here put how high the maximum Jail Time in hours\r\nDefault = 672');
+INSERT INTO `jail_conf` VALUES ('3', 'm_jailconf_min_reason', '25', null, 'Hier legst ihre die minimalen Zeichen fest die als Grund angeben müsst  \r\nStandart = 25\r\n\r\n', 'Here list how many characters are needed as the minimum reason\r\nDefault = 25');
+INSERT INTO `jail_conf` VALUES ('4', 'm_jailconf_warn_player', '1', null, 'Hier legst ihre fest wann der Char gewarnt wirt  bevor er gelöscht wird \r\nStandart = 1\r\n', 'How many time to warn the player before jailing them\r\nDefault = 1');
+INSERT INTO `jail_conf` VALUES ('5', 'm_jailconf_amnestie', '180', null, 'Hier legst ihre in Tagen fest wann der Jail Status  auf 0 zurückgesetzt wird   \r\nStandart = 180 Tage (das entspricht ca. ½ Jahr)  \r\n                     0  Tage (Aus)\r\n', 'This is how many in days when the Jail is status is set to 0\r\nStandard = 180 days (approximately ½ year)\r\n                     0 days (off)');
+INSERT INTO `jail_conf` VALUES ('6', 'm_jailconf_ally_x', null, '31.7282', 'Teleport Alliance  X Achse \r\nStandart = 31,7282\r\n', 'Teleport Alliance  X Axis \r\nStandart = 31,7282\r\n');
+INSERT INTO `jail_conf` VALUES ('7', 'm_jailconf_ally_y', null, '135.794', 'Teleport Alliance  Y Achse \r\nStandart = 135,794\r\n', 'Teleport Alliance  Y Axis \r\nStandart = 135,794\r\n');
+INSERT INTO `jail_conf` VALUES ('8', 'm_jailconf_ally_z', null, '-40.0508', 'Teleport Alliance  Z Achse \r\nStandart = -40,0508', 'Teleport Alliance  Z Axis \r\nStandart = -40,0508');
+INSERT INTO `jail_conf` VALUES ('9', 'm_jailconf_ally_o', null, '4.73516', 'Teleport Alliance  blickrichtung\r\nStandart = 4,73516', 'Teleport Alliance  Orientation\r\nStandart = 4,73516');
+INSERT INTO `jail_conf` VALUES ('10', 'm_jailconf_ally_m', '35', null, 'Teleport Alliance  Mape\r\nStandart = 35', 'Teleport Alliance  Map\r\nStandart = 35');
+INSERT INTO `jail_conf` VALUES ('11', 'm_jailconf_horde_x', null, '2179.85', 'Teleport Horde  X Achse \r\nStandart = \r\n', 'Teleport Horde  X Axis \r\nStandart = \r\n');
+INSERT INTO `jail_conf` VALUES ('12', 'm_jailconf_horde_y', null, '-4763.96', 'Teleport Horde  Y Achse \r\nStandart = -4763,96', 'Teleport Horde  Y Axis \r\nStandart = -4763,96');
+INSERT INTO `jail_conf` VALUES ('13', 'm_jailconf_horde_z', null, '54.911', 'Teleport Horde  Z Achse \r\nStandart = 54,911', 'Teleport Horde  Z Axis \r\nStandart = 54,911');
+INSERT INTO `jail_conf` VALUES ('14', 'm_jailconf_horde_o', null, '4.44216', 'Teleport  Horde  blickrichtung\r\nStandart = 4,44216', 'Teleport  Horde  Orientation\r\nStandart = 4,44216');
+INSERT INTO `jail_conf` VALUES ('15', 'm_jailconf_horde_m', '1', null, 'Teleport Horde  Mape\r\nStandart = 1', 'eleport Horde  Map\r\nStandart = 1');
+INSERT INTO `jail_conf` VALUES ('16', 'm_jailconf_ban', '0', null, 'Nach wie vielen Jail soll der  Account Gebant werden\r\nStandart = 0  (aus)\r\n', 'After how many jails the account will be Banned\r\nDefault = 0 (off)');
+INSERT INTO `jail_conf` VALUES ('17', 'm_jailconf_radius', '10', null, 'Legt den Bewegung Radius in Metern waren des Jails fest\r\nStandart = 10\r\n', 'Sets the range of motion in meters of the jail\r\nDefault = 10'');
diff --git a/sql/All/world_DalaranSewers.sql b/sql/All/world_DalaranSewers.sql
new file mode 100644
index 0000000..5d2676e
--- /dev/null
+++ b/sql/All/world_DalaranSewers.sql
@@ -0,0 +1,4 @@
+UPDATE `world`.`gameobject_template` SET `flags` = '36' WHERE `gameobject_template`.`entry` =192642 LIMIT 1 ;
+UPDATE `world`.`gameobject_template` SET `flags` = '36' WHERE `gameobject_template`.`entry` =192643 LIMIT 1 ;
+UPDATE `world`.`battleground_template` SET `MinPlayersPerTeam` = '0', `MaxPlayersPerTeam` = '2' WHERE `battleground_template`.`id` =10 LIMIT 1 ;
+DELETE FROM `disables` WHERE `entry` = 10 ;
diff --git a/sql/All/world_ahbot.sql b/sql/All/world_ahbot.sql
new file mode 100644
index 0000000..9a5a4f7
--- /dev/null
+++ b/sql/All/world_ahbot.sql
@@ -0,0 +1,72 @@
+CREATE TABLE `auctionhousebot` (
+    `auctionhouse` INT(11) NOT NULL DEFAULT '0' COMMENT 'mapID of the auctionhouse.',
+    `name` CHAR(25) NULL DEFAULT NULL COMMENT 'Text name of the auctionhouse.',
+    `minitems` INT(11) NULL DEFAULT '0' COMMENT 'This is the minimum number of items you want to keep in the auction house. a 0 here will make it the same as the maximum.',
+    `maxitems` INT(11) NULL DEFAULT '0' COMMENT 'This is the number of items you want to keep in the auction house.',
+    `percentgreytradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Grey Trade Goods auction items',
+    `percentwhitetradegoods` INT(11) NULL DEFAULT '27' COMMENT 'Sets the percentage of the White Trade Goods auction items',
+    `percentgreentradegoods` INT(11) NULL DEFAULT '12' COMMENT 'Sets the percentage of the Green Trade Goods auction items',
+    `percentbluetradegoods` INT(11) NULL DEFAULT '10' COMMENT 'Sets the percentage of the Blue Trade Goods auction items',
+    `percentpurpletradegoods` INT(11) NULL DEFAULT '1' COMMENT 'Sets the percentage of the Purple Trade Goods auction items',
+    `percentorangetradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Orange Trade Goods auction items',
+    `percentyellowtradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Yellow Trade Goods auction items',
+    `percentgreyitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Grey auction items',
+    `percentwhiteitems` INT(11) NULL DEFAULT '10' COMMENT 'Sets the percentage of the non trade White auction items',
+    `percentgreenitems` INT(11) NULL DEFAULT '30' COMMENT 'Sets the percentage of the non trade Green auction items',
+    `percentblueitems` INT(11) NULL DEFAULT '8' COMMENT 'Sets the percentage of the non trade Blue auction items',
+    `percentpurpleitems` INT(11) NULL DEFAULT '2' COMMENT 'Sets the percentage of the non trade Purple auction items',
+    `percentorangeitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Orange auction items',
+    `percentyellowitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Yellow auction items',
+    `minpricegrey` INT(11) NULL DEFAULT '100' COMMENT 'Minimum price of Grey items (percentage).',
+    `maxpricegrey` INT(11) NULL DEFAULT '150' COMMENT 'Maximum price of Grey items (percentage).',
+    `minpricewhite` INT(11) NULL DEFAULT '150' COMMENT 'Minimum price of White items (percentage).',
+    `maxpricewhite` INT(11) NULL DEFAULT '250' COMMENT 'Maximum price of White items (percentage).',
+    `minpricegreen` INT(11) NULL DEFAULT '800' COMMENT 'Minimum price of Green items (percentage).',
+    `maxpricegreen` INT(11) NULL DEFAULT '1400' COMMENT 'Maximum price of Green items (percentage).',
+    `minpriceblue` INT(11) NULL DEFAULT '1250' COMMENT 'Minimum price of Blue items (percentage).',
+    `maxpriceblue` INT(11) NULL DEFAULT '1750' COMMENT 'Maximum price of Blue items (percentage).',
+    `minpricepurple` INT(11) NULL DEFAULT '2250' COMMENT 'Minimum price of Purple items (percentage).',
+    `maxpricepurple` INT(11) NULL DEFAULT '4550' COMMENT 'Maximum price of Purple items (percentage).',
+    `minpriceorange` INT(11) NULL DEFAULT '3250' COMMENT 'Minimum price of Orange items (percentage).',
+    `maxpriceorange` INT(11) NULL DEFAULT '5550' COMMENT 'Maximum price of Orange items (percentage).',
+    `minpriceyellow` INT(11) NULL DEFAULT '5250' COMMENT 'Minimum price of Yellow items (percentage).',
+    `maxpriceyellow` INT(11) NULL DEFAULT '6550' COMMENT 'Maximum price of Yellow items (percentage).',
+    `minbidpricegrey` INT(11) NULL DEFAULT '70' COMMENT 'Starting bid price of Grey items as a percentage of the randomly chosen buyout price. Default: 70',
+    `maxbidpricegrey` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Grey items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricewhite` INT(11) NULL DEFAULT '70' COMMENT 'Starting bid price of White items as a percentage of the randomly chosen buyout price. Default: 70',
+    `maxbidpricewhite` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of White items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricegreen` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Green items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpricegreen` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Green items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceblue` INT(11) NULL DEFAULT '75' COMMENT 'Starting bid price of Blue items as a percentage of the randomly chosen buyout price. Default: 75',
+    `maxbidpriceblue` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Blue items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricepurple` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Purple items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpricepurple` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Purple items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceorange` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Orange items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpriceorange` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Orange items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceyellow` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Yellow items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpriceyellow` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Yellow items as a percentage of the randomly chosen buyout price. Default: 100',
+    `maxstackgrey` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackwhite` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackgreen` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackblue` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackpurple` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackorange` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackyellow` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `buyerpricegrey` INT(11) NULL DEFAULT '1' COMMENT 'Multiplier to vendorprice when buying grey items from auctionhouse',
+    `buyerpricewhite` INT(11) NULL DEFAULT '3' COMMENT 'Multiplier to vendorprice when buying white items from auctionhouse',
+    `buyerpricegreen` INT(11) NULL DEFAULT '5' COMMENT 'Multiplier to vendorprice when buying green items from auctionhouse',
+    `buyerpriceblue` INT(11) NULL DEFAULT '12' COMMENT 'Multiplier to vendorprice when buying blue items from auctionhouse',
+    `buyerpricepurple` INT(11) NULL DEFAULT '15' COMMENT 'Multiplier to vendorprice when buying purple items from auctionhouse',
+    `buyerpriceorange` INT(11) NULL DEFAULT '20' COMMENT 'Multiplier to vendorprice when buying orange items from auctionhouse',
+    `buyerpriceyellow` INT(11) NULL DEFAULT '22' COMMENT 'Multiplier to vendorprice when buying yellow items from auctionhouse',
+    `buyerbiddinginterval` INT(11) NULL DEFAULT '1' COMMENT 'Interval how frequently AHB bids on each AH. Time in minutes',
+    `buyerbidsperinterval` INT(11) NULL DEFAULT '1' COMMENT 'number of bids to put in per bidding interval',
+    PRIMARY KEY (`auctionhouse`)
+)
+ENGINE=InnoDB
+ROW_FORMAT=DEFAULT
+
+insert  into `auctionhousebot`(`auctionhouse`,`name`,`minitems`,`maxitems`,`percentgreytradegoods`,`percentwhitetradegoods`,`percentgreentradegoods`,`percentbluetradegoods`,`percentpurpletradegoods`,`percentorangetradegoods`,`percentyellowtradegoods`,`percentgreyitems`,`percentwhiteitems`,`percentgreenitems`,`percentblueitems`,`percentpurpleitems`,`percentorangeitems`,`percentyellowitems`,`minpricegrey`,`maxpricegrey`,`minpricewhite`,`maxpricewhite`,`minpricegreen`,`maxpricegreen`,`minpriceblue`,`maxpriceblue`,`minpricepurple`,`maxpricepurple`,`minpriceorange`,`maxpriceorange`,`minpriceyellow`,`maxpriceyellow`,`minbidpricegrey`,`maxbidpricegrey`,`minbidpricewhite`,`maxbidpricewhite`,`minbidpricegreen`,`maxbidpricegreen`,`minbidpriceblue`,`maxbidpriceblue`,`minbidpricepurple`,`maxbidpricepurple`,`minbidpriceorange`,`maxbidpriceorange`,`minbidpriceyellow`,`maxbidpriceyellow`,`maxstackgrey`,`maxstackwhite`,`maxstackgreen`,`maxstackblue`,`maxstackpurple`,`maxstackorange`,`maxstackyellow`,`buyerpricegrey`,`buyerpricewhite`,`buyerpricegreen`,`buyerpriceblue`,`buyerpricepurple`,`buyerpriceorange`,`buyerpriceyellow`,`buyerbiddinginterval`,`buyerbidsperinterval`) values
+(2,'Alliance',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1),
+(6,'Horde',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1),
+(7,'Neutral',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1);
\ No newline at end of file
diff --git a/sql/All/world_argenttournament.sql b/sql/All/world_argenttournament.sql
new file mode 100644
index 0000000..4379f9d
--- /dev/null
+++ b/sql/All/world_argenttournament.sql
@@ -0,0 +1,425 @@
+-- Horde
+-- Premiere quete : Le tournoi d'argent
+DELETE FROM `creature_questrelation` WHERE `quest`=13668;
+INSERT INTO `creature_questrelation` (`id`, `quest`) VALUES (33817, 13668);
+-- Icone monture de la horde
+UPDATE `creature_template` SET IconName='vehichleCursor' WHERE entry IN (33842,33796,33798,33791,33792,33799);
+-- Vehicule id des monture
+UPDATE `creature_template` SET `VehicleId`=349 WHERE entry IN (33320,33321,33322,33323,33324);
+-- Vitesse des montures
+UPDATE creature_template SET speed_run = 1.571429 WHERE entry IN (33844, 33320, 33321, 33322, 33323, 33324);
+-- Spells des montures
+UPDATE `creature_template` SET `spell1`=62544, `spell2`=62575, `spell3`=62960, `spell4`=62552, `spell5`=64077 WHERE `entry` IN (33844, 33320, 33321, 33322, 33323, 33324);
+-- Immune to Confuse
+UPDATE `creature_template` SET `mechanic_immune_mask` = `mechanic_immune_mask` | 2 WHERE `entry` IN (33844, 33320, 33321, 33322, 33323, 33324);
+
+-- Ajouts des spellclick_spells pour les montures Ã  l'Ã©curie
+DELETE FROM `npc_spellclick_spells` WHERE npc_entry IN (33842,33796,33798,33791,33792,33799);
+INSERT INTO `npc_spellclick_spells` (`npc_entry`, `spell_id`, `quest_start`, `quest_start_active`, `quest_end`, `cast_flags`, `aura_required`, `aura_forbidden`, `user_type`) VALUES
+(33842, 63791, 13668, 1, 13680, 1, 0, 0, 0), -- Aspirant
+-- Orgrimmar
+(33799, 62783, 13726, 0, 0, 1, 0, 0, 0), -- Champion Of Orgrimmar
+(33799, 62783, 13691, 0, 0, 1, 0, 0, 0), -- A Valiant Of Orgrimmar
+(33799, 62783, 13707, 0, 0, 1, 0, 0, 0), -- Valiant Of Orgrimmar
+-- Sen'jin
+(33796, 62784, 13727, 0, 0, 1, 0, 0, 0), -- Champion Of Sen'jin
+(33796, 62784, 13693, 0, 0, 1, 0, 0, 0), -- A Valiant Of Sen'jin
+(33796, 62784, 13708, 0, 0, 1, 0, 0, 0), -- Valiant Of Sen'jin
+-- Thunder Bluff
+(33792, 62785, 13728, 0, 0, 1, 0, 0, 0), -- Champion Of Thunder Bluff
+(33792, 62785, 13694, 0, 0, 1, 0, 0, 0), -- A Valiant Of Thunder Bluff
+(33792, 62785, 13709, 0, 0, 1, 0, 0, 0), -- Valiant Of Thunder Bluff
+-- Undercity
+(33798, 62787, 13729, 0, 0, 1, 0, 0, 0), -- Champion Of Undercity
+(33798, 62787, 13695, 0, 0, 1, 0, 0, 0), -- A Valiant Of Undercity
+(33798, 62787, 13710, 0, 0, 1, 0, 0, 0), -- Valiant Of Undercity
+-- Silvermoon
+(33791, 62786, 13731, 0, 0, 1, 0, 0, 0), -- Champion Of Silvermoon
+(33791, 62786, 13696, 0, 0, 1, 0, 0, 0), -- A Valiant Of Silvermoon
+(33791, 62786, 13711, 0, 0, 1, 0, 0, 0); -- Valiant Of Silvermoon
+
+-- Horde ArgentTournament
+	-- Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13668;
+UPDATE `quest_template` SET `PrevQuestId`=13668, `NextQuestId`=13678, `ExclusiveGroup`=-13829, `NextQuestInChain`=0 WHERE `entry` IN (13829, 13839, 13838);
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13680 WHERE `entry`=13678;
+	-- Daily Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=-13678, `NextQuestId`=0, `ExclusiveGroup`=13673, `NextQuestInChain`=0 WHERE `entry`=13673;
+UPDATE `quest_template` SET `PrevQuestId`=-13678, `NextQuestId`=0, `ExclusiveGroup`=13673, `NextQuestInChain`=0 WHERE `entry`=13675;
+UPDATE `quest_template` SET `PrevQuestId`=-13678, `NextQuestId`=0, `ExclusiveGroup`=13673, `NextQuestInChain`=0 WHERE `entry`=13674;
+UPDATE `quest_template` SET `PrevQuestId`=-13678, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13676;
+UPDATE `quest_template` SET `PrevQuestId`=-13678, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13677;
+	-- End Of Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13678, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13680;
+	-- Valiant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13680 WHERE `entry` IN (13691, 13693, 13694, 13695, 13696);
+
+UPDATE `quest_template` SET `RequiredRaces`=2, `NextQuestId`=13697, `NextQuestInChain`=13697, `ExclusiveGroup`=13691 WHERE `entry`=13691;
+UPDATE `quest_template` SET `RequiredRaces`=128, `NextQuestId`=13719, `NextQuestInChain`=13719, `ExclusiveGroup`=13693 WHERE `entry`=13693;
+UPDATE `quest_template` SET `RequiredRaces`=32, `NextQuestId`=13720, `NextQuestInChain`=13720, `ExclusiveGroup`=13694 WHERE `entry`=13694;
+UPDATE `quest_template` SET `RequiredRaces`=16, `NextQuestId`=13721, `NextQuestInChain`=13721, `ExclusiveGroup`=13695 WHERE `entry`=13695;
+UPDATE `quest_template` SET `RequiredRaces`=512, `NextQuestId`=13722, `NextQuestInChain`=13722, `ExclusiveGroup`=13696 WHERE `entry`=13696;
+
+-- INFOS DEV -- Premiere Quete (AdmissibilitÃ©) : 13687 -- Deuxieme Quete (Champion) : 13701
+UPDATE `quest_template` SET `PrevQuestId`=13701 WHERE `entry` IN (13707, 13708, 13709, 13710, 13711); -- TOScript into the core (check of 13687)
+
+UPDATE `quest_template` SET `NextQuestId`=13697, `NextQuestInChain`=13697, `ExclusiveGroup`=13691 WHERE `entry`=13707;
+UPDATE `quest_template` SET `NextQuestId`=13719, `NextQuestInChain`=13719, `ExclusiveGroup`=13693 WHERE `entry`=13708;
+UPDATE `quest_template` SET `NextQuestId`=13720, `NextQuestInChain`=13720, `ExclusiveGroup`=13694 WHERE `entry`=13709;
+UPDATE `quest_template` SET `NextQuestId`=13721, `NextQuestInChain`=13721, `ExclusiveGroup`=13695 WHERE `entry`=13710;
+UPDATE `quest_template` SET `NextQuestId`=13722, `NextQuestInChain`=13722, `ExclusiveGroup`=13696 WHERE `entry`=13711;
+
+UPDATE `quest_template` SET `PrevQuestId`=0, `ExclusiveGroup`=0 WHERE `entry` IN (13697, 13719, 13720, 13721, 13722);
+
+UPDATE `quest_template` SET `NextQuestId`=13726, `NextQuestInChain`=13726 WHERE `entry`=13697;
+UPDATE `quest_template` SET `NextQuestId`=13727, `NextQuestInChain`=13727  WHERE `entry`=13719;
+UPDATE `quest_template` SET `NextQuestId`=13728, `NextQuestInChain`=13728  WHERE `entry`=13720;
+UPDATE `quest_template` SET `NextQuestId`=13729, `NextQuestInChain`=13729  WHERE `entry`=13721;
+UPDATE `quest_template` SET `NextQuestId`=13731, `NextQuestInChain`=13731  WHERE `entry`=13722;
+	-- Valiant Daily Quests
+		-- A Blade Fit For A Champion
+		-- The Edge Of Winter
+		-- A Worthy Weapon
+UPDATE `quest_template` SET `PrevQuestId`=-13697, `NextQuestId`=0, `ExclusiveGroup`=13762, `NextQuestInChain`=0 WHERE `entry` IN (13762, 13763, 13764);
+UPDATE `quest_template` SET `PrevQuestId`=-13719, `NextQuestId`=0, `ExclusiveGroup`=13768, `NextQuestInChain`=0 WHERE `entry` IN (13768, 13769, 13770);
+UPDATE `quest_template` SET `PrevQuestId`=-13720, `NextQuestId`=0, `ExclusiveGroup`=13773, `NextQuestInChain`=0 WHERE `entry` IN (13773, 13774, 13775);
+UPDATE `quest_template` SET `PrevQuestId`=-13721, `NextQuestId`=0, `ExclusiveGroup`=13778, `NextQuestInChain`=0 WHERE `entry` IN (13778, 13779, 13780);
+UPDATE `quest_template` SET `PrevQuestId`=-13722, `NextQuestId`=0, `ExclusiveGroup`=13783, `NextQuestInChain`=0 WHERE `entry` IN (13783, 13784, 13785);
+		-- A Valiant's Field Training
+		-- The Grand Melee
+		-- At The Enemy's Gates
+UPDATE `quest_template` SET `PrevQuestId`=-13697, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13765, 13767, 13856);
+UPDATE `quest_template` SET `PrevQuestId`=-13719, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13771, 13772, 13857);
+UPDATE `quest_template` SET `PrevQuestId`=-13720, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13776, 13777, 13858);
+UPDATE `quest_template` SET `PrevQuestId`=-13721, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13781, 13782, 13860);
+UPDATE `quest_template` SET `PrevQuestId`=-13722, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13786, 13787, 13859);
+	-- End Of Valiant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13697, `NextQuestId`=13736, `ExclusiveGroup`=0, `NextQuestInChain`=13736 WHERE `entry`=13726;
+UPDATE `quest_template` SET `PrevQuestId`=13719, `NextQuestId`=13737, `ExclusiveGroup`=0, `NextQuestInChain`=13737 WHERE `entry`=13727;
+UPDATE `quest_template` SET `PrevQuestId`=13720, `NextQuestId`=13738, `ExclusiveGroup`=0, `NextQuestInChain`=13738 WHERE `entry`=13728;
+UPDATE `quest_template` SET `PrevQuestId`=13721, `NextQuestId`=13739, `ExclusiveGroup`=0, `NextQuestInChain`=13739 WHERE `entry`=13729;
+UPDATE `quest_template` SET `PrevQuestId`=13722, `NextQuestId`=13740, `ExclusiveGroup`=0, `NextQuestInChain`=13740 WHERE `entry`=13731;
+	-- A Champion Rises (Final Quest of a Branch)
+UPDATE `quest_template` SET `PrevQuestId`=13726, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13736;
+UPDATE `quest_template` SET `PrevQuestId`=13727, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13737;
+UPDATE `quest_template` SET `PrevQuestId`=13728, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13738;
+UPDATE `quest_template` SET `PrevQuestId`=13729, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13739;
+UPDATE `quest_template` SET `PrevQuestId`=13740, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13740;
+
+-- Debug Quest Requirements
+UPDATE `quest_template` SET `RequiredRaces`=690 WHERE `entry` IN (13697, 13719, 13720, 13721, 13722);
+UPDATE `quest_template` SET `RequiredRaces`=690 WHERE `entry` IN (13726, 13727, 13728, 13729, 13731);
+UPDATE `quest_template` SET `RequiredRaces`=690 WHERE `entry` IN (13736, 13737, 13738, 13739, 13740);
+
+-- Alliance
+-- Premiere quete : Le tournoi d'argent
+DELETE FROM `creature_questrelation` WHERE `quest`=13667;
+INSERT INTO `creature_questrelation` (`id`, `quest`) VALUES (33817, 13667);
+-- Icone monture de la horde
+UPDATE `creature_template` SET IconName='vehichleCursor' WHERE `entry` IN (33843,33794,33800,33793,33795,33790);
+-- Vehicule id des montures
+UPDATE `creature_template` SET `VehicleId`=349 WHERE `entry` IN (33319,33317,33318,33217,33316);
+-- Vitesse des montures
+UPDATE `creature_template` SET `speed_run`= 1.571429 WHERE `entry` IN (33845, 33319, 33317, 33318, 33217, 33316);
+-- Spells des montures
+UPDATE `creature_template` SET `spell1`=62544, `spell2`=62575, `spell3`=62960, `spell4`=62552, `spell5`=64077 WHERE `entry` IN (33845, 33319, 33317, 33318, 33217, 33316);
+-- Immune to Confuse
+UPDATE `creature_template` SET `mechanic_immune_mask` = `mechanic_immune_mask` | 2 WHERE `entry` IN (33845, 33319, 33317, 33318, 33217, 33316);
+
+-- Ajouts des spellclick_spells pour les montures Ã  l'Ã©curie
+DELETE FROM `npc_spellclick_spells` WHERE npc_entry IN (33843,33800,33795,33790,33793,33794);
+
+INSERT INTO `npc_spellclick_spells` (`npc_entry`, `spell_id`, `quest_start`, `quest_start_active`, `quest_end`, `cast_flags`, `aura_required`, `aura_forbidden`, `user_type`) VALUES
+(33843, 63792, 13667, 1, 13679, 1, 0, 0, 0), -- Aspirant
+-- Darnassus
+(33794, 62782, 13725, 0, 0, 1, 0, 0, 0), -- Champion Of Darnassus
+(33794, 62782, 13689, 0, 0, 1, 0, 0, 0), -- A Valiant Of Darnassus
+(33794, 62782, 13706, 0, 0, 1, 0, 0, 0), -- Valiant Of Darnassus
+-- Hurlevent
+(33800, 62774, 13699, 0, 0, 1, 0, 0, 0), -- Champion Of Sen'jin
+(33800, 62774, 13593, 0, 0, 1, 0, 0, 0), -- A Valiant Of Sen'jin
+(33800, 62774, 13684, 0, 0, 1, 0, 0, 0), -- Valiant Of Sen'jin
+-- Gnomregan
+(33793, 62780, 13723, 0, 0, 1, 0, 0, 0), -- Champion Of Thunder Bluff
+(33793, 62780, 13688, 0, 0, 1, 0, 0, 0), -- A Valiant Of Thunder Bluff
+(33793, 62780, 13704, 0, 0, 1, 0, 0, 0), -- Valiant Of Thunder Bluff
+-- Forgefer
+(33795, 62779, 13713, 0, 0, 1, 0, 0, 0), -- Champion Of Forgefer
+(33795, 62779, 13685, 0, 0, 1, 0, 0, 0), -- A Valiant Of Undercity
+(33795, 62779, 13703, 0, 0, 1, 0, 0, 0), -- Valiant Of Forgefer
+-- Exodar
+(33790, 62781, 13724, 0, 0, 1, 0, 0, 0), -- Champion Of Exodar
+(33790, 62781, 13690, 0, 0, 1, 0, 0, 0), -- A Valiant Of Exodar
+(33790, 62781, 13705, 0, 0, 1, 0, 0, 0); -- Valiant Of Exodar
+
+
+-- Alliance ArgentTournament
+	-- Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13667;
+UPDATE `quest_template` SET `PrevQuestId`=13667, `NextQuestId`=13672, `ExclusiveGroup`=-13828, `NextQuestInChain`=0 WHERE `entry` IN (13828, 13837, 13835);
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13679 WHERE `entry`=13672;
+	-- Daily Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=-13672, `NextQuestId`=0, `ExclusiveGroup`=13666, `NextQuestInChain`=0 WHERE `entry`=13666;
+UPDATE `quest_template` SET `PrevQuestId`=-13672, `NextQuestId`=0, `ExclusiveGroup`=13666, `NextQuestInChain`=0 WHERE `entry`=13670;
+UPDATE `quest_template` SET `PrevQuestId`=-13672, `NextQuestId`=0, `ExclusiveGroup`=13666, `NextQuestInChain`=0 WHERE `entry`=13669;
+UPDATE `quest_template` SET `PrevQuestId`=-13672, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13671;
+UPDATE `quest_template` SET `PrevQuestId`=-13672, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13625;
+	-- End Of Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13672, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13679;
+	-- Valiant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13679 WHERE `entry` IN (13684, 13685, 13689, 13688, 13690);
+
+UPDATE `quest_template` SET `RequiredRaces`=1, `NextQuestId`=13718, `NextQuestInChain`=13718, `ExclusiveGroup`=13684 WHERE `entry`=13684;
+UPDATE `quest_template` SET `RequiredRaces`=4, `NextQuestId`=13714, `NextQuestInChain`=13714, `ExclusiveGroup`=13685 WHERE `entry`=13685;
+UPDATE `quest_template` SET `RequiredRaces`=8, `NextQuestId`=13717, `NextQuestInChain`=13717, `ExclusiveGroup`=13689 WHERE `entry`=13689;
+UPDATE `quest_template` SET `RequiredRaces`=64, `NextQuestId`=13715, `NextQuestInChain`=13715, `ExclusiveGroup`=13688 WHERE `entry`=13688;
+UPDATE `quest_template` SET `RequiredRaces`=1024, `NextQuestId`=13716, `NextQuestInChain`=13716, `ExclusiveGroup`=13690 WHERE `entry`=13690;
+
+-- INFOS DEV -- Premiere Quete (AdmissibilitÃ©) : 13686 -- Deuxieme Quete (Champion) : 13700
+UPDATE `quest_template` SET `PrevQuestId`=13700 WHERE `entry` IN (13593, 13703, 13706, 13704, 13705); -- TOScript into the core (check of 13686)
+
+UPDATE `quest_template` SET `NextQuestId`=13718, `NextQuestInChain`=13718, `ExclusiveGroup`=13718 WHERE `entry`=13593;
+UPDATE `quest_template` SET `NextQuestId`=13714, `NextQuestInChain`=13714, `ExclusiveGroup`=13714 WHERE `entry`=13703;
+UPDATE `quest_template` SET `NextQuestId`=13717, `NextQuestInChain`=13717, `ExclusiveGroup`=13717 WHERE `entry`=13706;
+UPDATE `quest_template` SET `NextQuestId`=13715, `NextQuestInChain`=13715, `ExclusiveGroup`=13715 WHERE `entry`=13704;
+UPDATE `quest_template` SET `NextQuestId`=13716, `NextQuestInChain`=13716, `ExclusiveGroup`=13716 WHERE `entry`=13705;
+
+UPDATE `quest_template` SET `PrevQuestId`=0, `ExclusiveGroup`=0 WHERE `entry` IN (13718, 13714, 13717, 13715, 13716);
+
+UPDATE `quest_template` SET `NextQuestId`=13699, `NextQuestInChain`=13699 WHERE `entry`=13718;
+UPDATE `quest_template` SET `NextQuestId`=13713, `NextQuestInChain`=13713  WHERE `entry`=13714;
+UPDATE `quest_template` SET `NextQuestId`=13725, `NextQuestInChain`=13725  WHERE `entry`=13717;
+UPDATE `quest_template` SET `NextQuestId`=13723, `NextQuestInChain`=13723  WHERE `entry`=13715;
+UPDATE `quest_template` SET `NextQuestId`=13724, `NextQuestInChain`=13724  WHERE `entry`=13716;
+	-- Valiant Daily Quests
+		-- A Blade Fit For A Champion
+		-- The Edge Of Winter
+		-- A Worthy Weapon
+UPDATE `quest_template` SET `PrevQuestId`=-13718, `NextQuestId`=0, `ExclusiveGroup`=13603, `NextQuestInChain`=0 WHERE `entry` IN (13603, 13600, 13616);
+UPDATE `quest_template` SET `PrevQuestId`=-13714, `NextQuestId`=0, `ExclusiveGroup`=13741, `NextQuestInChain`=0 WHERE `entry` IN (13741, 13742, 13743);
+UPDATE `quest_template` SET `PrevQuestId`=-13717, `NextQuestId`=0, `ExclusiveGroup`=13757, `NextQuestInChain`=0 WHERE `entry` IN (13757, 13758, 13759);
+UPDATE `quest_template` SET `PrevQuestId`=-13715, `NextQuestId`=0, `ExclusiveGroup`=13746, `NextQuestInChain`=0 WHERE `entry` IN (13746, 13747, 13748);
+UPDATE `quest_template` SET `PrevQuestId`=-13716, `NextQuestId`=0, `ExclusiveGroup`=13752, `NextQuestInChain`=0 WHERE `entry` IN (13752, 13753, 13754);
+		-- A Valiant's Field Training
+		-- The Grand Melee
+		-- At The Enemy's Gates
+UPDATE `quest_template` SET `PrevQuestId`=-13718, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13592, 13665, 13847);
+UPDATE `quest_template` SET `PrevQuestId`=-13714, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13744, 13745, 13851);
+UPDATE `quest_template` SET `PrevQuestId`=-13717, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13760, 13761, 13855);
+UPDATE `quest_template` SET `PrevQuestId`=-13715, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13749, 13750, 13852);
+UPDATE `quest_template` SET `PrevQuestId`=-13716, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13755, 13756, 13854);
+	-- End Of Valiant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13718, `NextQuestId`=13702, `ExclusiveGroup`=0, `NextQuestInChain`=13702 WHERE `entry`=13699;
+UPDATE `quest_template` SET `PrevQuestId`=13714, `NextQuestId`=13732, `ExclusiveGroup`=0, `NextQuestInChain`=13732 WHERE `entry`=13713;
+UPDATE `quest_template` SET `PrevQuestId`=13717, `NextQuestId`=13735, `ExclusiveGroup`=0, `NextQuestInChain`=13735 WHERE `entry`=13725;
+UPDATE `quest_template` SET `PrevQuestId`=13715, `NextQuestId`=13733, `ExclusiveGroup`=0, `NextQuestInChain`=13733 WHERE `entry`=13723;
+UPDATE `quest_template` SET `PrevQuestId`=13716, `NextQuestId`=13734, `ExclusiveGroup`=0, `NextQuestInChain`=13734 WHERE `entry`=13724;
+	-- A Champion Rises (Final Quest of a Branch)
+UPDATE `quest_template` SET `PrevQuestId`=13699, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13702;
+UPDATE `quest_template` SET `PrevQuestId`=13713, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13732;
+UPDATE `quest_template` SET `PrevQuestId`=13725, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13735;
+UPDATE `quest_template` SET `PrevQuestId`=13723, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13733;
+UPDATE `quest_template` SET `PrevQuestId`=13734, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13734;
+
+-- Debug Quest Requirements
+UPDATE `quest_template` SET `RequiredRaces`=1101 WHERE `entry` IN (13718, 13714, 13717, 13715, 13716);
+UPDATE `quest_template` SET `RequiredRaces`=1101 WHERE `entry` IN (13699, 13713, 13725, 13723, 13724);
+UPDATE `quest_template` SET `RequiredRaces`=1101 WHERE `entry` IN (13702, 13732, 13735, 13733, 13734);
+
+
+-- Black Night chain
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=13641, `ExclusiveGroup`=13633, `NextQuestInChain`=13641 WHERE `entry` IN (13633, 13634);
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13643 WHERE `entry`=13641;
+UPDATE `quest_template` SET `PrevQuestId`=13641, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13654 WHERE `entry`=13643;
+UPDATE `quest_template` SET `PrevQuestId`=13643, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13663 WHERE `entry`=13654;
+UPDATE `quest_template` SET `PrevQuestId`=13654, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13664 WHERE `entry`=13663;
+UPDATE `quest_template` SET `PrevQuestId`=13663, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=14016 WHERE `entry`=13664;
+UPDATE `quest_template` SET `PrevQuestId`=13664, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=14017 WHERE `entry`=14016;
+UPDATE `quest_template` SET `PrevQuestId`=14016, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=14017;
+
+-- Champion Dailies
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13794; -- Eadric the Pure -- Works yet, but might bug with The Scourgebane
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13795; -- The Scourgebane
+	-- Among The Champions
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13790; -- Alliance Among The Champions
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13793; -- Alliance DK Among The Champions
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13811; -- Horde Among The Champions
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13814; -- Horde DK Among The Champions
+	-- Battle Before The Citadel
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13861; -- Alliance Battle Before The Citadel
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13864; -- Alliance DK Battle Before The Citadel
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13862; -- Horde Battle Before The Citadel
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13863; -- Horde DK Battle Before The Citadel
+	-- Taking Battle To The Enemy
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13789; -- Alliance Taking Battle To The Enemy
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13791; -- Alliance DK Taking Battle To The Enemy
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13810; -- Horde Taking Battle To The Enemy
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13813; -- Horde DK Taking Battle To The Enemy
+	-- Threat From Above
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13682; -- Alliance Threat From Above
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13788; -- Alliance DK Threat From Above
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13809; -- Horde Threat From Above
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13812; -- Horde DK Threat From Above
+
+-- Crusader dailies
+	-- Mistcaller Yngvar
+	-- Drottinn Hrothgar
+	-- Ornolf The Scarred
+	-- Deathspeaker Kharos
+UPDATE `quest_template` SET `ExclusiveGroup`=14102, `NextQuestId`=0, `NextQuestInChain`=0 WHERE `entry` IN (14102, 14101, 14104, 14105);
+	-- The Fate Of The Fallen
+	-- Get Kraken!
+	-- Identifying the Remains
+UPDATE `quest_template` SET `ExclusiveGroup`=14107, `NextQuestId`=0, `NextQuestInChain`=0 WHERE `entry` IN (14107, 14108, 14095);
+
+-- Covenant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13700, `RequiredMinRepFaction`=1094, `RequiredMinRepValue`=42000, `NextQuestId`=0, `NextQuestInChain`=0 WHERE `entry` IN (14112, 14076, 14090, 14096, 14152, 14080, 14077, 14074); -- Alliance
+UPDATE `quest_template` SET `PrevQuestId`=13701, `RequiredMinRepFaction`=1124, `RequiredMinRepValue`=42000, `NextQuestId`=0, `NextQuestInChain`=0 WHERE `entry` IN (14145, 14092, 14141, 14142, 14136, 14140, 14144, 14143); -- Horde
+	-- What Do You Feed A Yeti, Anyway?
+	-- Breakfast Of Champions
+	-- Gormok Wants His Snobolds
+UPDATE `quest_template` SET `ExclusiveGroup`=14112 WHERE `entry` IN (14112, 14145, 14076, 14092, 14090, 14141); -- A1, H1, A2, H2, A3, H3
+	-- You've Really Done It This Time, Kul
+	--
+	-- Rescue At Sea
+	-- Stop The Agressors
+	-- The Light's Mercy
+	-- A Leg Up
+UPDATE `quest_template` SET `ExclusiveGroup`=14152 WHERE `entry` IN (14152, 14136, 14080, 14140, 14077, 14144, 14074, 14143); -- A1, H1, A2, H2, A3, H3, A4, H4
+
+-- Champion Marker
+UPDATE `quest_template` SET `NextQuestId`=13846, `ExclusiveGroup`=13700 WHERE `entry` IN (13700, 13701); -- Alliance, Horde
+
+-- Contributin' To The Cause
+UPDATE `quest_template` SET `RequiredMaxRepFaction`=1106, `RequiredMaxRepValue`=42000 WHERE `entry`=13846;
+
+-- Goblin Dailies Removing
+	-- The Blastbolt Brothers
+	-- A Chip Off the Ulduar Block
+	-- Jack Me Some Lumber
+DELETE FROM `creature_questrelation` WHERE `quest` IN (13820, 13681, 13627);
+
+-- DK Quests Restrictions
+	-- The Scourgebane
+	-- Taking Battle To The Enemy (A, H)
+	-- Threat From Above (A, H)
+	-- Among the Champions (A, H)
+	-- Battle Before The Citadel (A, H)
+UPDATE `quest_template` SET `SkillOrClassMask`=-32 WHERE `entry` IN (13795, 13791, 13813, 13788, 13812, 13793, 13814, 13864, 13863);
+-- Non DK Quests Restrictions
+	-- Eadric The Pure
+	-- Taking Battle To The Enemy (A, H)
+	-- Threat From Above (A, H)
+	-- Among the Champions (A, H)
+	-- Battle Before The Citadel (A, H)
+UPDATE `quest_template` SET `SkillOrClassMask`=-1503 WHERE `entry` IN (13794, 13788, 13789, 13810, 13682, 13809, 13790, 13811, 13861, 13862);
+
+-- Teleports Locations
+DELETE FROM `spell_target_position` WHERE `id` IN (63986,63987);
+INSERT INTO `spell_target_position` (`id`,`target_map`,`target_position_x`,`target_position_y`,`target_position_z`,`target_orientation`) VALUES
+(63986,571,8574.87,700.595,547.29,5.48),
+(63987,571,8460,700,547.4,3.839);
+
+-- Armor Modificator set to null for Targets
+UPDATE `creature_template` SET `Armor_mod`=0 WHERE `entry` IN (33243, 33272, 33229);
+
+-- Add Scripts to NPCs
+UPDATE `creature_template` SET `ScriptName`='npc_quest_givers_argent_tournament' WHERE `entry` IN (33593, 33592, 33225, 33312, 33335, 33379, 33373, 33361, 33403, 33372);
+UPDATE `creature_template` SET `ScriptName`='npc_quest_givers_for_crusaders' WHERE `entry` IN (34882, 35094);
+UPDATE `creature_template` SET `ScriptName`='npc_crusader_rhydalla' WHERE `entry`=33417;
+UPDATE `creature_template` SET `ScriptName`='npc_eadric_the_pure' WHERE `entry`=33759;
+UPDATE `creature_template` SET `ScriptName`='npc_crok_scourgebane' WHERE `entry`=33762;
+UPDATE `creature_template` SET `ScriptName`='npc_valis_windchaser' WHERE `entry`=33974;
+UPDATE `creature_template` SET `ScriptName`='npc_rugan_steelbelly' WHERE `entry`=33972;
+UPDATE `creature_template` SET `ScriptName`='npc_jeran_lockwood' WHERE `entry`=33973;
+UPDATE `creature_template` SET `ScriptName`='npc_training_dummy_argent' WHERE `entry`=33229;
+UPDATE `creature_template` SET `ScriptName`='npc_training_dummy_argent' WHERE `entry`=33272;
+UPDATE `creature_template` SET `ScriptName`='npc_training_dummy_argent' WHERE `entry`=33243;
+
+-- Debug QuestRelation A2
+DELETE FROM `creature_questrelation` WHERE `quest` IN (13828, 13672, 13679, 13684, 13685, 13689, 13688, 13690);
+INSERT `creature_questrelation` (`id`, `quest`) VALUES (33625, 13828), (33625, 13672), (33625, 13679), (33625, 13684), (33625, 13685), (33625,13689), (33625, 13688), (33625, 13690);
+
+-- Debug QuestRelation H2
+DELETE FROM `creature_questrelation` WHERE `quest` IN (13691, 13693, 13694, 13695, 13696, 13829, 13680, 13678);
+INSERT `creature_questrelation` (`id`, `quest`) VALUES (33542, 13691), (33542, 13693), (33542, 13694), (33542, 13695), (33542, 13696), (33542,13829), (33542, 13680), (33542, 13678);
+
+-- Quest 13666 & 13673:  Une lame digne d'un champion!
+-- Lake Frog
+-- Maiden Of Ahswood Lake
+UPDATE `creature_template` SET `ScriptName` = 'npc_lake_frog' WHERE `creature_template`.`entry` =33211 LIMIT 1 ;
+UPDATE `creature_template` SET `npcflag` = `npcflag` | 1, `ScriptName` = 'npc_maiden_of_ashwood_lake' WHERE `creature_template`.`entry` =33220;
+-- frog speed from sniff
+UPDATE creature_template SET speed_run = 1 WHERE entry = 33211;
+UPDATE creature_template SET speed_walk = 1.6 WHERE entry = 33211;
+
+-- Quest : Le fil de l'hiver
+DELETE FROM creature WHERE guid = '336364';
+INSERT INTO creature VALUES  (336364,33289,571,1,1,0,0,5136.74,-83.3769,347.326,1.44434,300,0,0,12600,3994,0,0,0,0,0);
+DELETE FROM `creature_loot_template` WHERE `entry`=33289 AND `item`=45005;
+INSERT INTO `creature_loot_template` (`entry`, `item`, `ChanceOrQuestChance`) VALUES (33289, 45005, -100);
+
+-- Quete : Une arme remarquable
+DELETE FROM `script_texts` WHERE `entry` IN (-1850000,-1850001,-1850002,-1850003);
+INSERT INTO `script_texts` (`npc_entry`, `entry`, `content_default`, `content_loc2`,`comment`) VALUES
+(0, -1850000, 'Oh, it\'s winter hyacinths? For me?','Oh, it\'s winter hyacinths? For me?',''),
+(0, -1850001, 'I had not brought flowers here for so long.','I had not brought flowers here for so long.',''),
+(0, -1850002, 'The lake is a very lonely place for some years. Travelers no longer come, and evil has invaded the waters.','The lake is a very lonely place for some years. Travelers no longer come, and evil has invaded the waters.',''),
+(0, -1850003, 'Your gift reveals a rare kindness, traveler. I beg you, take this blade as a token of my gratitude. Long ago, another passenger who had left here, but I do not need.','Your gift reveals a rare kindness, traveler. I beg you, take this blade as a token of my gratitude. Long ago, another passenger who had left here, but I do not need.','');
+DELETE FROM `event_scripts` WHERE `id`=20990;
+INSERT INTO `event_scripts` (`id`, `delay`, `command`, `datalong`, `datalong2`, `x`, `y`, `z`, `o`) VALUES (20990, 0, 10, 33273, 42000, 4602.977, -1600.141, 156.7834, 0.7504916);
+UPDATE `creature_template` SET `InhabitType`=5, `ScriptName`='npc_maiden_of_drak_mar' WHERE `entry`=33273;
+DELETE FROM `creature_template_addon` WHERE `entry`=33273;
+INSERT INTO `creature_template_addon` (`entry`, `emote`) VALUES (33273, 13); -- 13 = EMOTE_STATE_SIT
+
+-- Quete Entrainement sur le terrain:
+UPDATE `creature_template` SET `faction_A`=16,`faction_H`=16 WHERE entry IN (29720,29719,29722);
+INSERT INTO `creature` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`,`npcflag`,`unit_flags`, `dynamicflags`) VALUES
+(NULL, 29720, 571, 1, 1, 0, 0, 8562.48, 2771.93, 759.958, 6.10672, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8584.64, 2760.8, 759.958, 2.59599, 300, 15, 0, 12600, 0, 0, 1,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8617.49, 2735.11, 759.958, 2.32895, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8420.8, 2688.71, 759.957, 1.33806, 300, 15, 0, 12600, 0, 0, 1,0,0,0),
+(NULL, 29719, 571, 1, 1, 0, 0, 8417.11, 2641.07, 759.957, 1.57604, 300, 15, 0, 12600, 0, 0, 1,0,0,0),
+(NULL, 29719, 571, 1, 1, 0, 0, 8435.89, 2596.91, 759.957, 2.30577, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8477.25, 2565.16, 759.957, 2.51783, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29719, 571, 1, 1, 0, 0, 8522.14, 2556.99, 759.957, 3.11709, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8571.58, 2559.95, 759.957, 4.05564, 300, 0, 0, 12600, 0, 0, 0,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8609.24, 2589.19, 759.958, 0.155352, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29719, 571, 1, 1, 0, 0, 8637.35, 2651.77, 759.958, 4.15303, 300, 15, 0, 12600, 0, 0, 1,0,0,0),
+(NULL, 29719, 571, 1, 1, 0, 0, 8636.85, 2679.47, 759.958, 4.93842, 300, 15, 0, 12175, 0, 0, 1,0,0,0);
+
+-- Texte des vailliants
+-- Quete : Une arme remarquable
+DELETE FROM `script_texts` WHERE `entry` IN (-1850004,-1850005,-1850006,-1850007,-1850008,-1850009,-1850010,-1850011,-1850012);
+INSERT INTO `script_texts` (`npc_entry`, `entry`, `content_default`, `content_loc2`,`comment`) VALUES
+(0, -1850004, 'Get ready!','Get ready!',''),
+(0, -1850005, 'Let the battle begin!','Let the battle begin!',''),
+(0, -1850006, 'Get Set!','Get ready!',''),
+(0, -1850007, 'You think you have the courage in you? We\'ll see.','You think you have the courage in you? We\'ll see.',''),
+(0, -1850008, 'An impressive demonstration. I think you\'re quite able to join the ranks of the brave.','Impressive demonstration. I think you\'re quite able to join the ranks of the valiant.',''),
+(0, -1850009, 'I won. You\'ll probably have more luck next time.','I won. You\'ll probably have more luck next time.',''),
+(0, -1850010, 'I am defeated. Nice fight!','I am defeated. Nice fight!',''),
+(0, -1850011, 'Looks like I underestimated your skills. Well done.','Looks like I underestimated your skills. Well done.',''),
+(0, -1850012, 'I won. You\'ll probably have more luck next time.','I won. You\'ll probably have more luck next time.','');
+
+-- Announcer for start event
+DELETE FROM `creature_template` WHERE `entry` in (35591,35592);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(35591, 0, 0, 0, 0, 0, 29894, 0, 0, 0, 'Jaeren Sunsworn', '', '', 0, 75, 75, 2, 14, 14, 0, 1, 1, 0, 0, 0, 0, 0, 1, 2000, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_anstart'),
+(35592, 0, 0, 0, 0, 0, 29893, 0, 0, 0, 'Arelas Brightstar', '', '', 0, 75, 75, 2, 14, 14, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 512, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_anstart');
+UPDATE `creature_template` SET `ScriptName` = 'npc_gr' WHERE `entry` = '35492';
+UPDATE `creature_template` SET `ScriptName` = 'npc_anstart' WHERE `entry` IN ('35591', '35592');
+
+UPDATE `creature_template` SET `ScriptName`='npc_vendor_argent_tournament' WHERE `entry` IN (33553, 33554, 33556, 33555, 33557, 33307, 33310, 33653, 33650, 33657);
+UPDATE `creature_template` SET `ScriptName`='quest_givers_argent_tournament' WHERE `entry` IN (33593, 33592, 33225, 33312, 33335, 33379, 33373, 33361, 33403, 33372);
+UPDATE `creature_template` SET `ScriptName`='npc_argent_champion' WHERE `entry`=33707;
+UPDATE `creature_template` SET `ScriptName`='npc_squire_danny' WHERE `entry`=33518;
+UPDATE `creature_template` SET `ScriptName`='npc_justicar_mariel_trueheart' WHERE `entry`=33817;
+
+UPDATE `creature_template` SET `ScriptName` = 'boss_twilight_halion' WHERE `entry` = '40142';
+UPDATE `creature_template` SET `ScriptName` = 'npc_meteor_strike', `flags_extra` = 128 WHERE `entry` = '40041';
+UPDATE `creature_template` SET `ScriptName` = 'npc_spell_meteor_strike', `flags_extra` = 128 WHERE `entry` = '40029';
+UPDATE `creature_template` SET `ScriptName` = 'npc_meteor_flame', `flags_extra` = 128 WHERE `entry` = '40042';
+
+UPDATE `creature_template` SET `name` = 'summon halion', `ScriptName` = 'npc_summon_halion', `flags_extra` = 128 WHERE `entry` = '40044';
+UPDATE `creature_template` SET `ScriptName` = 'npc_onyx_flamecaller' WHERE `entry` = '39814'
\ No newline at end of file
diff --git a/sql/All/world_bots.sql b/sql/All/world_bots.sql
new file mode 100644
index 0000000..4e2e285
--- /dev/null
+++ b/sql/All/world_bots.sql
@@ -0,0 +1,246 @@
+
+-- Add command as level 0
+DELETE FROM command where name='bot';
+INSERT INTO command (name, security, help) VALUES ('bot',0,'Syntax: .bot $subcommand $Name');
+
+delete from `creature_template` where entry >= 60000 && entry < 60239;
+
+insert  into `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction_A`,`faction_H`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`mindmg`,`maxdmg`,`dmgschool`,`attackpower`,`dmg_multiplier`,`baseattacktime`,`rangeattacktime`,`unit_class`,`unit_flags`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`minrangedmg`,`maxrangedmg`,`rangedattackpower`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`Health_mod`,`Mana_mod`,`Armor_mod`,`RacialLeader`,`questItem1`,`questItem2`,`questItem3`,`questItem4`,`questItem5`,`questItem6`,`movementId`,`RegenHealth`,`equipment_id`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`WDBVerified`) values
+(60000,0,0,0,0,0,169,0,169,0,'Recruitment Officer','','',0,80,80,0,35,35,1,1.4,1.14286,1,0,228,298,0,1837,1,2000,0,1,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,300,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,'script_bot_giver',0),
+(60001,0,0,0,0,0,5001,0,5001,0,'Khelden','Mage Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,8,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60002,0,0,0,0,0,1294,0,1294,0,'Zaldimar','Mage Bot','',0,80,80,2,12,12,1,0.98,1.14286,1,0,5,10,0,54,1,1500,0,8,4608,0,0,0,0,8,1,21.5072,29.5724,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,85,0,'mage_bot',0),
+(60003,0,0,0,0,0,1484,0,1484,0,'Maginor','Mage Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,8,4608,0,0,0,0,8,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60004,0,0,0,0,0,3344,0,3344,0,'Anetta','Priest Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,5,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60005,0,0,0,0,0,1495,0,1495,0,'Laurena','Priest Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,8,4608,0,0,0,0,5,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60006,0,0,0,0,0,1295,0,1295,0,'Josetta','Priest Bot','',0,80,80,2,12,12,1,0.98,1.14286,1,0,5,10,0,54,1,1500,0,8,4608,0,0,0,0,5,1,21.5072,29.5724,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,85,0,'priest_bot',0),
+(60007,0,0,0,0,0,3345,0,3345,0,'Drusilla','Warlock Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,9,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60008,0,0,0,0,0,1930,0,1930,0,'Alamar','Warlock Bot','',0,80,80,2,875,875,1,1.07,1.14286,1,0,2,5,0,23,1,1960,2156,8,4608,0,0,0,0,9,7,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60009,0,0,0,0,0,1469,0,1469,0,'Demisette','Warlock Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,8,4608,0,0,0,0,9,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60010,0,0,0,0,0,12749,0,12749,0,'Nalesette','Hunter Bot','',0,80,80,2,80,80,1,1.1,1.14286,1,0,23,48,0,247,1,1500,1500,2,4608,0,0,3,0,3,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,319,0,'hunter_bot',0),
+(60011,0,0,0,0,0,3401,0,3401,0,'Branstock','Priest Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,5,0,23,1,1960,2156,8,4608,0,0,0,0,5,3,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60012,0,0,0,0,0,3395,0,3395,0,'Thorgas','Hunter Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,5,0,23,1,1960,2156,2,4608,0,0,0,0,3,3,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60013,0,0,0,0,0,3343,0,3343,0,'Llane','Warrior Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,65,0,364,1,1500,0,1,4608,0,0,0,0,1,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,702,0,'warrior_bot',0),
+(60014,0,0,0,0,0,3399,0,3399,0,'Thran','Warrior Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,55,0,267,1,1960,2156,1,4608,0,0,0,0,1,3,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,702,0,'warrior_bot',0),
+(60015,0,0,0,0,0,1300,0,1300,0,'Lyria','Warrior Bot','',0,80,80,2,12,12,1,0.97,1.14286,1,0,5,90,0,543,1,1500,0,1,4608,0,0,0,0,1,1,19.9584,27.4428,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,647,0,'warrior_bot',0),
+(60016,0,0,0,0,0,3351,0,3351,0,'Jorik','Rogue Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,75,0,1489,1,1500,0,4,4608,0,0,0,0,4,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,397,0,'rogue_bot',0),
+(60017,0,0,0,0,0,3407,0,3407,0,'Solm','Rogue Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,74,0,1489,1,1960,2156,4,4608,0,0,0,0,4,3,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,397,0,'rogue_bot',0),
+(60018,0,0,0,0,0,1297,0,1297,0,'Keryn','Rogue Bot','',0,80,80,2,12,12,1,0.97,1.14286,1,0,5,53,0,1489,1,2000,0,4,4608,0,0,0,0,4,1,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,730,0,'rogue_bot',0),
+(60019,0,0,0,0,0,1507,0,1507,0,'Osborne','Rogue Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,1489,1,1500,0,4,4608,0,0,0,0,4,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,392,0,'rogue_bot',0),
+(60020,0,0,0,0,0,3346,0,3346,0,'Sammuel','Paladin Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,2,4608,0,0,0,0,2,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,429,0,'paladin_bot',0),
+(60021,0,0,0,0,0,3393,0,3393,0,'Bob','Paladin Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,5,0,23,1,1960,2156,2,4608,0,0,0,0,2,3,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,429,0,'paladin_bot',0),
+(60022,0,0,0,0,0,1299,0,1299,0,'Wilhelm','Paladin Bot','',0,80,80,2,12,12,1,0.97,1.14286,1,0,5,9,0,45,1,1500,0,2,4608,0,0,0,0,2,1,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,426,0,'paladin_bot',0),
+(60023,0,0,0,0,0,1499,0,1499,0,'Brisombre','Paladin Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,2,4608,0,0,0,0,2,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,105,0,'paladin_bot',0),
+(60024,0,0,0,0,0,10216,0,10216,0,'Marry','Mage Bot','',0,80,80,2,875,875,1,1.07,1.14286,1,0,2,5,0,23,1,1960,2156,8,4608,0,0,0,0,8,7,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,3,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60025,0,0,0,0,0,4552,0,4552,0,'Haromm','Shaman Bot','',0,80,80,2,29,29,1,1.05,1.14286,1,0,32,200,0,345,1,2000,0,2,4608,0,0,0,0,7,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1691,0,'shaman_bot',0),
+(60026,0,0,0,0,0,4567,0,4567,0,'Kartosh','Warlock Bot','',0,80,80,2,29,29,1,1.05,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60027,0,0,0,0,0,3429,0,3429,0,'MaxanAnvol','Priest Bot','',0,80,80,2,55,55,1,0.96,1.14286,1,0,3,9,0,42,1,1500,0,8,4608,0,0,0,0,5,3,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1315,0,'priest_bot',0),
+(60028,0,0,0,0,0,10215,0,10215,0,'Magis','Mage Bot','',0,80,80,2,875,875,1,1.1,1.14286,1,0,3,9,0,42,1,1500,0,8,4608,0,0,0,0,8,7,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60029,0,0,0,0,0,3431,0,3431,0,'GranVivehache','Warrior Bot','',0,80,80,2,55,55,1,0.96,1.14286,1,0,3,75,0,422,1,1500,0,1,4608,0,0,0,0,1,3,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,1309,0,'warrior_bot',0),
+(60030,0,0,0,0,0,1622,0,1622,0,'Azar','Paladin Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,2,4608,0,0,0,0,2,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,105,0,'paladin_bot',0),
+(60031,0,0,0,0,0,3436,0,3436,0,'Hogral','Rogue Bot','',0,80,80,2,55,55,1,0.97,1.14286,1,0,5,56,0,1489,1,2000,0,4,4608,0,0,0,0,4,3,19.9584,27.4428,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,397,0,'rogue_bot',0),
+(60032,0,0,0,0,0,3053,0,3053,0,'Kelstrum','Warrior Bot','',0,80,80,2,55,55,1,1.17,1.14286,1,0,27,57,0,294,1,1500,0,1,4608,0,0,0,0,1,3,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,1853,0,'warrior_bot',0),
+(60033,0,0,0,0,0,1578,0,1578,0,'Dannal','Warrior Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,67,0,364,1,2000,0,1,4608,0,0,0,0,1,5,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,639,0,'warrior_bot',0),
+(60034,0,0,0,0,0,1579,0,1579,0,'SombreDuesten','Priest Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,5,0,23,1,2000,0,8,4608,0,0,0,0,5,5,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,604,0,'priest_bot',0),
+(60035,0,0,0,0,0,1592,0,1592,0,'Isabella','Mage Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,5,0,23,1,2000,0,8,4608,0,0,0,0,8,5,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1022,0,'mage_bot',0),
+(60036,0,0,0,0,0,1581,0,1581,0,'Maximillion','Warlock Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,5,0,23,1,2000,0,8,4608,0,0,0,0,9,5,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,143,0,'warlock_bot',0),
+(60037,0,0,0,0,0,1604,0,1604,0,'Rupert','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,6,13,0,65,1,2000,0,8,4608,0,0,0,0,9,5,24.552,33.759,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1022,0,'warlock_bot',0),
+(60038,0,0,0,0,0,1600,0,1600,0,'Cain','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,6,12,0,59,1,2000,0,8,4608,0,0,0,0,8,5,23.0384,31.6778,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60039,0,0,0,0,0,1602,0,1602,0,'SombreBeryl','Priest Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,7,14,0,75,1,2000,0,8,4608,0,0,0,0,5,5,27.5264,37.8488,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,604,0,'priest_bot',0),
+(60041,0,0,0,0,0,10548,0,10548,0,'Milituus','Mage Bot','',0,80,80,2,55,55,1,1.35,1.14286,1,0,27,57,0,294,1,2000,0,8,4608,0,0,0,0,8,3,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60042,0,0,0,0,0,2810,0,2810,0,'Lexington','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,19,40,0,205,1,2000,0,8,4608,0,0,0,0,8,5,51.128,70.301,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60043,0,0,0,0,0,2123,0,2123,0,'Siln','Shaman Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,200,0,345,1,2000,0,2,4608,0,0,0,0,7,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,586,0,'shaman_bot',0),
+(60044,0,0,0,0,0,19598,0,19598,0,'Umbrua','Shaman Bot','',0,80,80,2,1640,1640,1,1.125,1.14286,1,0,176,200,0,1235,1,2000,0,2,4608,0,0,0,0,7,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1627,0,'shaman_bot',0),
+(60045,0,0,0,0,0,2102,0,2102,0,'Tigor','Shaman Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,200,0,247,1,2000,0,2,4608,0,0,0,0,7,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,145,0,'shaman_bot',0),
+(60046,0,0,0,0,0,2082,0,2082,0,'Beram','Shaman Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,200,0,451,1,2000,0,2,4608,0,0,0,0,7,6,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,157,0,'shaman_bot',0),
+(60047,0,0,0,0,0,2106,0,2106,0,'Turak','Druid Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,200,0,345,1,2000,0,2,4608,0,0,0,0,11,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1069,0,'druid_bot',0),
+(60048,0,0,0,0,0,2121,0,2121,0,'Sheal','Druid Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,200,0,1034,1,2000,0,2,4608,0,0,0,0,11,6,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1252,0,'druid_bot',0),
+(60049,0,0,0,0,0,2115,0,2115,0,'Kym','Druid Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,123,248,0,1034,1,2000,0,2,4608,0,0,0,0,11,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1034,0,'druid_bot',0),
+(60050,0,0,0,0,0,2112,0,2112,0,'Kary','Hunter Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,67,0,345,1,2000,1200,2,4608,0,0,0,0,3,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,920,0,'hunter_bot',0),
+(60051,0,0,0,0,0,2087,0,2087,0,'Holt','Hunter Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,88,0,451,1,2000,1000,2,4608,0,0,0,0,3,6,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60052,0,0,0,0,0,2105,0,2105,0,'Urek','Hunter Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,1300,2,4608,0,0,0,0,3,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,6,0,'hunter_bot',0),
+(60053,0,0,0,0,0,2103,0,2103,0,'Torm','Warrior Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,1,4608,0,0,0,0,1,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,916,0,'warrior_bot',0),
+(60054,0,0,0,0,0,2096,0,2096,0,'Sark','Warrior Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,1,4608,0,0,0,0,1,6,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,133,0,'warrior_bot',0),
+(60055,0,0,0,0,0,17211,0,17211,0,'Kerra','Warrior Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,0,1,4608,0,0,0,0,1,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,491,18,0,'warrior_bot',0),
+(60056,0,0,0,0,0,2139,0,2139,0,'Miles Welsh','Priest Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,5,5,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,40,0,'priest_bot',0),
+(60057,0,0,0,0,0,2138,0,2138,0,'Malakai','Priest Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,5,5,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,65,0,'priest_bot',0),
+(60058,0,0,0,0,0,2137,0,2137,0,'Cobb','Priest Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,5,5,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1096,0,'priest_bot',0),
+(60059,0,0,0,0,0,2134,0,2134,0,'Shymm','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,8,5,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,143,145,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,108,0,'mage_bot',0),
+(60060,0,0,0,0,0,6058,0,6058,0,'Ursyn','Mage Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,8,5,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60061,0,0,0,0,0,2135,0,2135,0,'Thurston','Mage Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,8,5,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,129,0,'mage_bot',0),
+(60062,0,0,0,0,0,3793,0,3793,0,'Harutt','Warrior Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,40,99,0,637,1,2000,0,1,4608,0,0,0,0,1,6,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,1977,0,'warrior_bot',0),
+(60063,0,0,0,0,0,3819,0,3819,0,'Gart','Druid Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,3,200,0,1034,1,2000,0,2,4608,0,0,0,0,11,6,15.2064,20.9088,100,7,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1073,0,'druid_bot',0),
+(60064,0,0,0,0,0,3810,0,3810,0,'Lanka','Hunter Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,5,9,0,45,1,2000,1460,2,4608,0,0,0,0,3,6,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,138,0,'hunter_bot',0),
+(60065,0,0,0,0,0,10180,0,10180,0,'Meela','Shaman Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,3,200,0,42,1,2000,0,2,4608,0,0,0,0,7,6,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,157,0,'shaman_bot',0),
+(60066,0,0,0,0,0,3794,0,3794,0,'Krang','Warrior Bot','',0,80,80,2,104,104,1,0.98,1.14286,1,0,40,68,0,575,1,2000,0,1,4608,0,0,0,0,1,6,23.0384,31.6778,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,1977,0,'warrior_bot',0),
+(60067,0,0,0,0,0,10734,0,10734,0,'Gennia','Druid Bot','',0,80,80,2,104,104,1,0.98,1.14286,1,0,5,200,0,1034,1,2000,0,2,4608,0,0,0,0,11,6,19.9584,27.4428,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1069,0,'druid_bot',0),
+(60068,0,0,0,0,0,3811,0,3811,0,'Yaw','Hunter Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,5,9,0,45,1,2000,1200,2,4608,0,0,0,0,3,6,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,127,0,'hunter_bot',0),
+(60069,0,0,0,0,0,3816,0,3816,0,'Narm','Shaman Bot','',0,80,80,2,104,104,1,0.98,1.14286,1,0,5,200,0,54,1,2000,0,2,4608,0,0,0,0,7,6,21.5072,29.5724,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,446,0,'shaman_bot',0),
+(60070,0,0,0,0,0,1880,0,1880,0,'Frang','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,30,99,0,670,1,2000,2090,1,4608,0,0,0,0,1,2,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,1977,0,'warrior_bot',0),
+(60071,0,0,0,0,0,1882,0,1882,0,'Jenshan','Hunter Bot','',0,80,80,2,126,126,1,0.95,1.14286,1,0,2,7,0,33,1,2000,2123,2,4608,0,0,0,0,3,8,13.5872,18.6824,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,193,0,'hunter_bot',0),
+(60072,0,0,0,0,0,1884,0,1884,0,'Nartok','Warlock Bot','',0,80,80,2,29,29,1,0.96,1.14286,1,0,3,9,0,38,1,2000,2112,8,4608,0,0,0,0,9,2,15.2064,20.9088,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1022,0,'warlock_bot',0),
+(60073,0,0,0,0,0,1878,0,1878,0,'Shikrik','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,3,200,0,42,1,2000,2101,2,4608,0,0,0,0,7,2,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,604,0,'shaman_bot',0),
+(60074,0,0,0,0,0,3743,0,3743,0,'Tarshaw','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,25,53,0,273,1,2000,1738,1,4608,0,0,0,0,1,2,59.7872,82.2074,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,642,0,'warrior_bot',0),
+(60075,0,0,0,0,0,3744,0,3744,0,'Thotar','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,6,15,0,72,1,2000,2035,2,4608,0,0,0,0,3,2,26.048,35.816,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,920,0,'hunter_bot',0),
+(60076,0,0,0,0,0,3745,0,3745,0,'Dhugru','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,21,43,0,220,1,2000,1804,8,4608,0,0,0,0,9,2,53.3984,73.4228,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60077,0,0,0,0,0,3746,0,3746,0,'Swart','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,6,200,0,65,1,2000,2046,2,4608,0,0,0,0,7,2,24.552,33.759,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,861,0,'shaman_bot',0),
+(60078,0,0,0,0,0,1324,0,1324,0,'Groldar','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60079,0,0,0,0,0,1325,0,1325,0,'Mirket','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60080,0,0,0,0,0,1326,0,1326,0,'Zevrost','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60081,0,0,0,0,0,1360,0,1360,0,'Kardris','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,200,0,451,1,2000,0,2,4608,0,0,0,0,7,2,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,586,0,'shaman_bot',0),
+(60082,0,0,0,0,0,1373,0,1373,0,'Ormak','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,88,0,451,1,2000,1551,2,4608,0,0,0,0,3,2,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,8,0,'hunter_bot',0),
+(60083,0,0,0,0,0,1374,0,1374,0,'Grezz','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,1,4608,0,0,0,0,1,2,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,1865,0,'warrior_bot',0),
+(60084,0,0,0,0,0,1375,0,1375,0,'Sorek','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,1,4608,0,0,0,0,1,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,725,0,'warrior_bot',0),
+(60085,0,0,0,0,0,4231,0,4231,0,'Siantsu','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,200,0,247,1,2000,0,2,4608,0,0,0,0,7,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,170,0,'shaman_bot',0),
+(60086,0,0,0,0,0,4239,0,4239,0,'Xorjuul','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,1661,2,4608,0,0,0,0,3,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60087,0,0,0,0,0,4241,0,4241,0,'Siandur','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,2,4608,0,0,0,0,3,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60088,0,0,0,0,0,4242,0,4242,0,'Zelmak','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,1,4608,0,0,0,0,1,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,1867,0,'warrior_bot',0),
+(60089,0,0,0,0,0,7915,0,7915,0,'ClaudeErksine','Hunter Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,1610,1771,2,4608,0,0,3,0,3,3,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60090,0,0,0,0,0,1721,0,1721,0,'Alyissia','Warrior Bot','',0,80,80,2,80,80,1,0.97,1.14286,1,0,50,87,0,322,1,2000,0,1,4608,0,0,0,0,1,4,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,639,0,'warrior_bot',0),
+(60091,0,0,0,0,0,1725,0,1725,0,'FrahunMurmombre','Rogue Bot','',0,80,80,2,80,80,1,0.97,1.14286,1,0,5,43,0,1489,1,2000,0,4,4608,0,0,0,0,4,4,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,220,0,'rogue_bot',0),
+(60092,0,0,0,0,0,1733,0,1733,0,'Shanda','Priest Bot','',0,80,80,2,80,80,1,0.96,1.14286,1,0,3,9,0,42,1,2000,0,8,4608,0,0,0,0,5,4,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,604,0,'priest_bot',0),
+(60093,0,0,0,0,0,1732,0,1732,0,'Mardant','Druid Bot','',0,80,80,2,80,80,1,0.97,1.14286,1,0,5,367,0,45,1,2000,0,2,4608,0,0,0,0,11,4,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,114,0,'druid_bot',0),
+(60094,0,0,0,0,0,1707,0,1707,0,'Kyra','Warrior Bot','',0,80,80,2,80,80,1,1.01,1.14286,1,0,25,87,0,422,1,2000,0,1,4608,0,0,0,0,1,4,30.4304,41.8418,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,1913,0,'warrior_bot',0),
+(60095,0,0,0,0,0,1704,0,1704,0,'Jannok','Rogue Bot','',0,80,80,2,80,80,1,1.02,1.14286,1,0,9,73,0,1489,1,2000,0,4,4608,0,0,0,0,4,4,31.856,43.802,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,628,0,'rogue_bot',0),
+(60096,0,0,0,0,0,1708,0,1708,0,'Laurna','Priest Bot','',0,80,80,2,80,80,1,1.03,1.14286,1,0,9,20,0,100,1,2000,0,8,4608,0,0,0,0,5,4,33.264,45.738,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60097,0,0,0,0,0,1706,0,1706,0,'Kal','Druid Bot','',0,80,80,2,80,80,1,1.03,1.14286,1,0,10,214,0,107,1,2000,0,2,4608,0,0,0,0,11,4,34.6544,47.6498,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'druid_bot',0),
+(60098,0,0,0,0,0,4296,0,4296,0,'Harruk','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,2,4608,0,0,3,0,3,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,344,0,'hunter_bot',0),
+(60099,0,0,0,0,0,4299,0,4299,0,'Reban','Hunter bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,1100,2,4608,0,0,3,0,3,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,865,0,'hunter_bot',0),
+(60100,0,0,0,0,0,4304,0,4304,0,'Bolyun','Hunter Bot','',0,80,80,2,80,80,1,1.05,1.14286,1,0,23,48,0,247,1,2000,1235,2,4608,0,0,3,0,3,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60101,0,0,0,0,0,1897,0,1897,0,'Taijin','Priest Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,8,16,0,84,1,2000,2013,8,4608,0,0,0,0,5,8,28.9872,39.8574,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60102,0,0,0,0,0,4068,0,4068,0,'Kenjai','Priest Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,3,9,0,42,1,2000,2101,8,4608,0,0,0,0,5,8,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,458,0,'priest_bot',0),
+(60103,0,0,0,0,0,2066,0,2066,0,'Danlaar','Hunter Bot','',0,80,80,2,80,80,1,1.05,1.14286,1,0,19,40,0,205,1,2000,1382,2,4608,0,0,0,0,3,4,51.128,70.301,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,1,0,'hunter_bot',0),
+(60104,0,0,0,0,0,2196,0,2196,0,'Ariasta','Warrior Bot','',0,80,80,2,80,80,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,1,4608,0,0,0,0,1,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,822,0,'warrior_bot',0),
+(60105,0,0,0,0,0,2198,0,2198,0,'Sildanair','Warrior Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,1,4608,0,0,0,0,1,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,281,0,'warrior_bot',0),
+(60106,0,0,0,0,0,2200,0,2200,0,'Astarii','Priest Bot','',0,80,80,2,80,80,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,5,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60107,0,0,0,0,0,2201,0,2201,0,'Jandria','Priest Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,5,4,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'priest_bot',0),
+(60108,0,0,0,0,0,2202,0,2202,0,'Lariia','Priest Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,5,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60109,0,0,0,0,0,2231,0,2231,0,'Syurna','Rogue Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,48,0,1489,1,2000,0,4,4608,0,0,0,0,4,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,220,0,'rogue_bot',0),
+(60110,0,0,0,0,0,7669,0,7669,0,'Elissa','Mage Bot','',0,80,80,2,80,80,1,1.11,1.14286,1,0,19,40,0,205,1,2000,0,8,4608,0,0,0,0,8,4,51.128,70.301,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60111,0,0,0,0,0,2252,0,2252,0,'Erion','Rogue Bot','',0,80,80,2,80,80,1,1.26,1.14286,1,0,42,88,0,1489,1,2000,0,4,4608,0,0,0,0,4,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,277,0,'rogue_bot',0),
+(60112,0,0,0,0,0,2243,0,2243,0,'Anishar','Rogue Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,67,0,1489,1,2000,0,4,4608,0,0,0,0,4,4,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,1913,0,'rogue_bot',0),
+(60113,0,0,0,0,0,2250,0,2250,0,'Denatharion','Druid Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,267,0,345,1,2000,0,2,4608,0,0,0,0,11,4,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,258,0,'druid_bot',0),
+(60114,0,0,0,0,0,2255,0,2255,0,'Fylerian','Druid Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,348,0,247,1,2000,0,2,4608,0,0,0,0,11,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,358,0,'druid_bot',0),
+(60115,0,0,0,0,0,2416,0,2416,0,'Caelyb','Hunter Bot','',0,80,80,2,80,80,1,1.05,1.14286,1,0,23,48,0,247,1,2000,1186,2,4608,0,0,3,0,3,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,1073,0,'hunter_bot',0),
+(60116,0,0,0,0,0,2675,0,2675,0,'Kaal','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,9,5,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60117,0,0,0,0,0,16800,0,16800,0,'Lana','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,5,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1784,0,'warlock_bot',0),
+(60118,0,0,0,0,0,2646,0,2646,0,'Richard','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,9,5,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1217,0,'warlock_bot',0),
+(60119,0,0,0,0,0,10214,0,10214,0,'Kaelystia','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,8,5,74.448,102.366,100,6,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,8388624,'mage_bot',0),
+(60120,0,0,0,0,0,2644,0,2644,0,'Pierce','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,8,5,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60121,0,0,0,0,0,2657,0,2657,0,'Anastasia','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,8,5,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60122,0,0,0,0,0,2620,0,2620,0,'Chris','Warrior Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,1,4608,0,0,0,0,1,5,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,801,0,'warrior_bot',0),
+(60123,0,0,0,0,0,2658,0,2658,0,'Angela','Warrior Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,1,4608,0,0,0,0,1,5,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,1881,0,'warrior_bot',0),
+(60124,0,0,0,0,0,2614,0,2614,0,'Baltus','Warrior Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,1,4608,0,0,0,0,1,5,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,1882,0,'warrior_bot',0),
+(60125,0,0,0,0,0,3054,0,3054,0,'Kelv','Warrior Bot','',0,80,80,2,55,55,1,1.17,1.14286,1,0,27,57,0,294,1,1560,1716,1,4608,0,0,0,0,1,3,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,136,0,'warrior_bot',0),
+(60126,0,0,0,0,0,3055,0,3055,0,'Bilban','Warrior Bot','',0,80,80,2,875,875,1,1.35,1.14286,1,0,27,57,0,294,1,1500,0,1,4608,0,0,0,0,1,7,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,675,0,'warrior_bot',0),
+(60127,0,0,0,0,0,3056,0,3056,0,'Daera','Hunter Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,1410,1551,2,4608,0,0,0,0,3,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60128,0,0,0,0,0,3072,0,3072,0,'Olmin','Hunter Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,1033,2,4608,0,0,0,0,3,3,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60129,0,0,0,0,0,3073,0,3073,0,'Regnus','Hunter Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,2000,1012,2,4608,0,0,0,0,3,3,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60130,0,0,0,0,0,3086,0,3086,0,'Theodrus','Priest Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,5,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60131,0,0,0,0,0,3066,0,3066,0,'Braenna','Priest Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,5,3,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'priest_bot',0),
+(60132,0,0,0,0,0,3085,0,3085,0,'Toldren','Priest Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,5,3,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60134,0,0,0,0,0,3108,0,3108,0,'Bink','Mage Bot','',0,80,80,2,875,875,1,1.31,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,8,7,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60135,0,0,0,0,0,10214,0,10214,0,'Juli','Mage Bot','',0,80,80,2,875,875,1,1.38,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,8,7,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60136,0,0,0,0,0,3109,0,3109,0,'Nittegousse','Mage Bot','',0,80,80,2,55,55,1,1.45,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,8,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60137,0,0,0,0,0,3089,0,3089,0,'Valgar','Paladin Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,2,4608,0,0,0,0,2,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,105,0,'paladin_bot',0),
+(60138,0,0,0,0,0,3088,0,3088,0,'Beldruk','Paladin Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,2,4608,0,0,0,0,2,3,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,799,0,'paladin_bot',0),
+(60139,0,0,0,0,0,3087,0,3087,0,'Brandur','Paladin Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,2,4608,0,0,0,0,2,3,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,799,0,'paladin_bot',0),
+(60140,0,0,0,0,0,3101,0,3101,0,'Hulfdan','Rogue Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,1489,1,2000,0,4,4608,0,0,0,0,4,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,1886,0,'rogue_bot',0),
+(60141,0,0,0,0,0,3100,0,3100,0,'Ormyr','Rogue Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,1489,1,2000,0,4,4608,0,0,0,0,4,3,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,220,0,'rogue_bot',0),
+(60142,0,0,0,0,0,3113,0,3113,0,'Phenwick','Rogue Bot','',0,80,80,2,875,875,1,1.31,1.14286,1,0,23,48,0,1489,1,2000,0,4,4608,0,0,0,0,4,7,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,220,0,'rogue_bot',0),
+(60143,0,0,0,0,0,3115,0,3115,0,'Coeurdechardon','Warlock Bot','',0,80,80,2,55,55,1,1.31,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,9,3,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60144,0,0,0,0,0,3116,0,3116,0,'Eglantin','Warlock Bot','',0,80,80,2,875,875,1,1.38,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,7,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60145,0,0,0,0,0,3122,0,3122,0,'Alexander','Warlock Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,9,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60146,0,0,0,0,0,3280,0,3280,0,'Wu','Warrior Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,1500,0,1,4608,0,0,0,0,1,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,727,0,'warrior_bot',0),
+(60147,0,0,0,0,0,3287,0,3287,0,'Ilsa','Warrior Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,1500,0,1,4608,0,0,0,0,1,1,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,613,0,'warrior_bot',0),
+(60148,0,0,0,0,0,3283,0,3283,0,'Joshua','Priest Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,5,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'priest_bot',0),
+(60149,0,0,0,0,0,3284,0,3284,0,'Arthur','Paladin Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,2,4608,0,0,0,0,2,1,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,799,0,'paladin_bot',0),
+(60150,0,0,0,0,0,3289,0,3289,0,'Katherine','Paladin Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,2,4608,0,0,0,0,2,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,799,0,'paladin_bot',0),
+(60151,0,0,0,0,0,3291,0,3291,0,'Deline','Warlock Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,9,1,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60152,0,0,0,0,0,3286,0,3286,0,'Sandahl','Warlock Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60153,0,0,0,0,0,3292,0,3292,0,'Jennea','Mage Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,8,1,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60154,0,0,0,0,0,19803,0,19803,0,'Elsharin','Mage Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,8,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60155,0,0,0,0,0,3299,0,3299,0,'Kaerbrus','Hunter Bot','',0,80,80,2,80,80,1,1.1,1.14286,1,0,39,80,0,418,1,2000,1263,2,4608,0,0,0,0,3,4,72.2304,99.3168,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60156,0,0,0,0,0,3300,0,3300,0,'Sheldras','Druid Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,288,0,451,1,2000,0,2,4608,0,0,0,0,11,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1071,0,'druid_bot',0),
+(60157,0,0,0,0,0,3301,0,3301,0,'Theridran','Druid Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,467,0,345,1,2000,0,2,4608,0,0,0,0,11,4,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,258,0,'druid_bot',0),
+(60158,0,0,0,0,0,3312,0,3312,0,'Einris','Hunter Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,2000,1157,2,4608,0,0,0,0,3,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60159,0,0,0,0,0,3309,0,3309,0,'Ulfir','Hunter Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,1379,2,4608,0,0,0,0,3,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60160,0,0,0,0,0,3310,0,3310,0,'Thorfin','Hunter Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,1175,2,4608,0,0,0,0,3,1,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,298,0,'hunter_bot',0),
+(60161,0,0,0,0,0,10171,0,10171,0,'UnThuwa','Mage Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,6,12,0,59,1,2000,2057,8,4608,0,0,0,0,8,8,23.0384,31.6778,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,143,0,'mage_bot',0),
+(60162,0,0,0,0,0,4524,0,4524,0,'Pephredo','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,88,0,451,1,2000,1551,8,4608,0,0,0,0,8,2,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,559,0,'mage_bot',0),
+(60163,0,0,0,0,0,4522,0,4522,0,'Enyo','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,1661,8,4608,0,0,0,0,8,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,99,0,'mage_bot',0),
+(60164,0,0,0,0,0,4526,0,4526,0,'Mai','Mage Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,3,4,0,26,1,2000,2101,8,4608,0,0,0,0,8,8,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,143,0,'mage_bot',0),
+(60165,0,0,0,0,0,4523,0,4523,0,'Deino','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,8,4608,0,0,0,0,8,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,21,0,'mage_bot',0),
+(60166,0,0,0,0,0,4665,0,4665,0,'Birgitte','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,27,57,0,294,1,1000,0,8,4608,0,0,0,0,8,5,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60167,0,0,0,0,0,12849,0,12849,0,'Thuul','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,27,57,0,294,1,1000,1716,8,4608,0,0,0,0,8,2,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60168,0,0,0,0,0,4690,0,4690,0,'Zayus','Priest Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,62,131,0,677,1,2000,1551,8,4608,0,0,0,0,5,2,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,143,0,'priest_bot',0),
+(60169,0,0,0,0,0,10473,0,10473,0,'Xyera','Priest Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,1661,8,4608,0,0,0,0,5,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,228,0,'priest_bot',0),
+(60170,0,0,0,0,0,4711,0,4711,0,'Urkyo','Priest Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,8,4608,0,0,0,0,5,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,85,0,'priest_bot',0),
+(60171,0,0,0,0,0,6060,0,6060,0,'Uthelnay','Mage Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,8,4608,0,0,0,0,8,8,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1071,0,'mage_bot',0),
+(60172,0,0,0,0,0,6072,0,6072,0,'Dink','Mage Bot','',0,80,80,2,875,875,1,1.31,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,8,7,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60173,0,0,0,0,0,6071,0,6071,0,'Darnath','Warrior Bot','',0,80,80,2,80,80,1,1.23,1.14286,1,0,36,77,0,394,1,2000,0,1,4608,0,0,0,0,1,4,70.664,97.163,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,277,0,'warrior_bot',0),
+(60174,0,0,0,0,0,7356,0,7356,0,'Karman','Paladin Bot','',0,80,80,2,894,894,1,1.25,1.14286,1,0,27,57,0,294,1,2000,0,2,4608,0,0,0,0,2,1,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,117,0,'paladin_bot',0),
+(60175,0,0,0,0,0,11037,0,11037,0,'Evencane','Warrior Bot','',0,80,80,2,894,894,1,1.25,1.14286,1,0,27,57,0,294,1,2000,0,1,4608,0,0,0,0,1,1,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,639,0,'warrior_bot',0),
+(60176,0,0,0,0,0,7357,0,7357,0,'Jannos','Druid Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,32,200,0,1034,1,2000,0,2,4608,0,0,0,0,11,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,119,0,'druid_bot',0),
+(60177,0,0,0,0,0,7538,0,7538,0,'Alenndaar','Hunter Bot','',0,80,80,2,1076,1076,1,1.05,1.14286,1,0,14,28,0,143,1,2000,1012,2,4608,0,0,0,0,3,4,41.3424,56.8458,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,886,0,'hunter_bot',0),
+(60178,0,0,0,0,0,10738,0,10738,0,'Golhine','Druid Bot','',0,80,80,2,80,80,1,1.1,1.14286,1,0,42,288,0,451,1,2000,0,2,4608,0,0,0,0,11,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1252,0,'druid_bot',0),
+(60179,0,0,0,0,0,9337,0,9337,0,'Hesuwa','Hunter Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,1178,2,4608,0,0,3,0,3,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,6,0,'hunter_bot',0),
+(60180,0,0,0,0,0,9336,0,9336,0,'Xao\'tsu','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,2,4608,0,0,3,0,3,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,886,0,'hunter_bot',0),
+(60181,0,0,0,0,0,9338,0,9338,0,'Belia','Hunter Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,2000,1426,2,4608,0,0,3,0,3,3,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,1081,0,'hunter_bot',0),
+(60182,0,0,0,0,0,10245,0,10245,0,'Dargh','Hunter Bot','',0,80,80,2,55,55,1,1.05,1.14286,1,0,12,25,0,128,1,1760,1936,2,4608,0,0,0,0,3,3,38.72,53.24,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,19,0,'hunter_bot',0),
+(60183,0,0,0,0,0,11044,0,11044,0,'Meideros','Priest Bot','',0,80,80,2,80,80,1,1.08,1.14286,1,0,16,32,0,164,1,2000,0,8,4608,0,0,0,0,5,4,45.144,62.073,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60184,0,0,0,0,0,11048,0,11048,0,'Presse','Priest Bot','',0,80,80,2,1076,1076,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,5,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60185,0,0,0,0,0,11053,0,11053,0,'Rohan','Priest Bot','',0,80,80,2,122,122,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,5,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60186,0,0,0,0,0,12053,0,12053,0,'Loganaar','Druid Bot','',0,80,80,2,994,994,1,1.1,1.14286,1,0,33,269,0,353,1,2000,0,2,4608,0,0,0,0,11,4,67.32,92.565,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1252,0,'druid_bot',0),
+(60187,0,0,0,0,0,13171,0,13171,0,'Romano','Rogue Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,1489,1,2000,0,4,4608,0,0,0,0,4,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,734,0,'rogue_bot',0),
+(60188,0,0,0,0,0,13341,0,13341,0,'Sagorne','Shaman Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,32,200,0,345,1,2000,0,2,4608,0,0,0,0,7,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,458,0,'shaman_bot',0),
+(60189,0,0,0,0,0,15522,0,15522,0,'Julia','Mage Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,8,10,23.4783,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1022,0,'mage_bot',0),
+(60190,0,0,0,0,0,15511,0,15511,0,'Jesthenis','Paladin Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,2,4608,0,0,0,0,2,10,23.4783,32.7308,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1229,0,'paladin_bot',0),
+(60191,0,0,0,0,0,15524,0,15524,0,'Invocateur','Warlock Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,9,10,23.4783,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1491,1455,0,'warlock_bot',0),
+(60192,0,0,0,0,0,15518,0,15518,0,'Matrone','Priest Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,5,10,23.4783,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1306,0,'priest_bot',0),
+(60193,0,0,0,0,0,2659,0,2659,0,'Eclaireur','Rogue Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,62,99,0,1489,1,2000,0,4,4608,0,0,0,0,4,5,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1204,0,0,'rogue_bot',0),
+(60194,0,0,0,0,0,15520,0,15520,0,'Sallina','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,1543,2,4608,0,0,0,0,3,10,23.4783,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,27,0,'hunter_bot',0),
+(60195,0,0,0,0,0,16685,0,16685,0,'Noellene','Paladin Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,7,0,33,1,1500,0,2,4608,0,0,0,0,2,10,56.3478,78.5538,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,204,725,0,'paladin_bot',0),
+(60196,0,0,0,0,0,16707,0,16707,0,'Ponaris','Priest Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,7,0,33,1,1500,0,8,4608,0,0,0,0,5,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1096,0,'priest_bot',0),
+(60197,0,0,0,0,0,16222,0,16222,0,'Keilnei','Hunter Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,18,0,79,1,2000,1180,2,4608,0,0,0,0,3,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,1619,0,'hunter_bot',0),
+(60198,0,0,0,0,0,16223,0,16223,0,'Valaatu','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,18,0,79,1,2000,0,8,4608,0,0,0,0,8,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1624,0,'mage_bot',0),
+(60199,0,0,0,0,0,16224,0,16224,0,'Aurelon','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,18,0,79,1,2000,0,2,4608,0,0,0,0,2,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,205,1610,0,'paladin_bot',0),
+(60200,0,0,0,0,0,16225,0,16225,0,'Zalduun','Priest Bot','',0,80,80,2,1638,1638,1,1.25,1.14286,1,0,5,18,0,79,1,2000,0,8,4608,0,0,0,0,5,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1626,0,'priest_bot',0),
+(60201,0,0,0,0,0,16226,0,16226,0,'Kore','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,54,0,322,1,2000,0,1,4608,0,0,0,0,1,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1022,1618,0,'warrior_bot',0),
+(60202,0,0,0,0,0,16787,0,16787,0,'Alamma','Warlock Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,4608,0,0,0,0,9,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1491,0,0,'warlock_bot',0),
+(60203,0,0,0,0,0,16800,0,16800,0,'Talionia','Warlock Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,8,4608,0,0,0,0,9,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1491,0,0,'warlock_bot',0),
+(60204,0,0,0,0,0,16831,0,16831,0,'Zanien','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,18,66,0,290,1,2000,1180,2,4608,0,0,0,0,9,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60205,0,0,0,0,0,16781,0,16781,0,'Zaedana','Mage Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,8,4608,0,0,0,0,8,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60206,0,0,0,0,0,16824,0,16824,0,'Quithas','Mage Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,4608,0,0,0,0,8,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60207,0,0,0,0,0,16739,0,16739,0,'Harene','Druid Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,18,366,0,290,1,2000,0,2,4608,0,0,0,0,11,6,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,0,0,'druid_bot',0),
+(60208,0,0,0,0,0,16778,0,16778,0,'Tana','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,12,42,0,185,1,2000,1168,2,4608,0,0,0,0,3,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60209,0,0,0,0,0,16816,0,16816,0,'Oninath','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,14,53,0,236,1,1000,1084,2,4608,0,0,0,0,3,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60210,0,0,0,0,0,16829,0,16829,0,'Bachi','Paladin Bot','',0,80,80,2,1604,1604,1,0.93,1.14286,1,0,38,68,0,367,1,2000,0,2,4608,0,0,0,0,2,10,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,0,0,'paladin_bot',0),
+(60211,0,0,0,0,0,16767,0,16767,0,'Zelanis','Rogue Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,62,80,0,1489,1,2000,0,4,4608,0,0,0,0,4,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1206,0,0,'rogue_bot',0),
+(60212,0,0,0,0,0,16798,0,16798,0,'Elara','Rogue Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,52,77,0,1489,1,2000,0,4,4608,0,0,0,0,4,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1204,0,0,'rogue_bot',0),
+(60213,0,0,0,0,0,16858,0,16858,0,'Shalannius','Druid Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,100,300,0,290,1,2000,0,2,4608,0,0,0,0,11,6,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,0,0,'druid_bot',0),
+(60214,0,0,0,0,0,17434,0,17434,0,'Deremiis','Hunter Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,1076,2,4608,0,0,0,0,3,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60215,0,0,0,0,0,17247,0,17247,0,'Caedmos','Priest Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,18,66,0,290,1,2000,0,8,4608,0,0,0,0,5,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60216,0,0,0,0,0,17225,0,17225,0,'Baatun','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,18,66,0,290,1,2000,0,2,4608,0,0,0,0,2,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,205,0,0,'paladin_bot',0),
+(60217,0,0,0,0,0,17212,0,17212,0,'Ahonan','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,12,42,0,453,1,2000,0,1,4608,0,0,0,0,1,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,394,0,0,'warrior_bot',0),
+(60218,0,0,0,0,0,17598,0,17598,0,'Firmanvaar','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,200,0,79,1,2000,0,2,4608,0,0,0,0,7,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,1622,0,'shaman_bot',0),
+(60219,0,0,0,0,0,16860,0,16860,0,'Actron','Hunter Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,23,1,2000,1125,2,4608,0,0,0,0,3,11,46.9565,65.4615,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60220,0,0,0,0,0,17213,0,17213,0,'Behomat','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,18,66,0,290,1,2000,0,1,4608,0,0,0,0,1,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1362,0,0,'warrior_bot',0),
+(60221,0,0,0,0,0,17600,0,17600,0,'Nobundo','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,21,200,0,345,1,2000,0,2,4608,0,0,0,0,7,11,346.02,481.06,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60222,0,0,0,0,0,17599,0,17599,0,'Tuluun','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,41,200,0,393,1,2000,0,2,4608,0,0,0,0,7,11,70.4348,98.1923,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,1086,0,'shaman_bot',0),
+(60223,0,0,0,0,0,16914,0,16914,0,'Sulaa','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,200,0,236,1,2000,0,2,4608,0,0,0,0,7,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60224,0,0,0,0,0,17215,0,17215,0,'Ruada','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,76,0,643,1,2000,0,1,4608,0,0,0,0,1,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1022,797,0,'warrior_bot',0),
+(60225,0,0,0,0,0,17233,0,17233,0,'Semid','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,23,1,2000,0,8,4608,0,0,0,0,8,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1304,0,'mage_bot',0),
+(60226,0,0,0,0,0,17232,0,17232,0,'Guvan','Priest Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,26,1,2000,0,8,4608,0,0,0,0,5,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60227,0,0,0,0,0,17234,0,17234,0,'Tullas','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,23,1,2000,0,2,4608,0,0,0,0,2,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,204,422,0,'paladin_bot',0),
+(60228,0,0,0,0,0,17488,0,17488,0,'Killac','Hunter bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,2,4608,0,0,0,0,3,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,'hunter_bot',0),
+(60229,0,0,0,0,0,17226,0,17226,0,'Jol','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,2,4608,0,0,0,0,2,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,205,0,0,'paladin_bot',0),
+(60230,0,0,0,0,0,17248,0,17248,0,'Fallat','Priest Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,4608,0,0,0,0,5,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60231,0,0,0,0,0,17243,0,17243,0,'Harnan','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,4608,0,0,0,0,8,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60232,0,0,0,0,0,17241,0,17241,0,'Bati','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,8,4608,0,0,0,0,8,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60233,0,0,0,0,0,17792,0,17792,0,'Hobahken','Shaman Bot','',0,80,80,2,1638,1638,1,1.08,1.14286,1,0,18,200,0,290,1,2000,0,2,4608,0,0,0,0,7,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60234,0,0,0,0,0,6820,0,6820,0,'Gurrag','Shaman Bot','',0,80,80,2,1638,1638,1,1.08,1.14286,1,0,12,200,0,185,1,2000,0,2,4608,0,0,0,0,7,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60235,0,0,0,0,0,19596,0,19596,0,'Auberose','Paladin Bot','',0,80,80,2,1602,1602,1,1.1,1.14286,1,0,176,176,0,367,1,2000,0,2,4608,0,0,0,0,2,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,897,1552,0,'paladin_bot',0),
+(60236,0,0,0,0,0,10335,10335,10335,10335,'Afina','Priest Bot','',0,80,80,2,35,35,1,0.95,1.14286,1,0,12,25,0,128,1,10000,0,8,4608,0,0,0,0,5,2,40,53,100,7,1,0,0,0,100,100,100,100,100,100,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,0,0,0,0,0,0,0,0,1,1370,0,0,'priest_bot',0),
+(60237,0,0,0,0,0,1132,0,1132,0,'Voidwalker',NULL,NULL,0,80,80,2,14,14,0,1.1,1.14286,1,0,50,50,0,100,1,2000,0,1,0,0,16,0,0,1,0,23.0384,31.6778,100,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'PetAI',0,1,1.1,0.77,1,0,0,0,0,0,0,0,0,1,0,0,0,'',0),
+(60238,0,0,0,0,0,1105,0,0,0,'Hunter\'s Pet',NULL,NULL,0,80,80,0,14,14,1,1.1,1.14286,1,0,87,117,0,214,1,2000,0,1,0,0,7,0,0,1,0,61,90,21,1,1,0,0,0,0,0,0,0,0,0,5708,0,0,0,0,0,0,0,0,0,0,0,'PetAI',0,3,1,1,1,0,0,0,0,0,0,0,149,1,0,0,0,'',0);
+
diff --git a/sql/All/world_bots_update.sql b/sql/All/world_bots_update.sql
new file mode 100644
index 0000000..e312de0
--- /dev/null
+++ b/sql/All/world_bots_update.sql
@@ -0,0 +1,13 @@
+-- OPTIONAL UPDATE
+-- Updated values I thought should be closer to the bots values at least for my server.
+-- You can create your own values to be in line with your own server if these are not acceptable.
+
+UPDATE `creature_template` SET mindmg:=150, maxdmg:=350, attackpower:=300, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, speed_walk:=1.5, speed_run:=1.5, resistance1:=100, resistance2:=100, resistance3:=100, resistance4:=100, resistance5:=100, resistance6:=100, InhabitType:=3, health_mod:=2, mana_mod:=2.7, armor_mod:=2, mechanic_immune_mask:=0, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Druid Bot';
+UPDATE `creature_template` SET mindmg:=700, maxdmg:=900, attackpower:=2700, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=950, maxrangedmg:=1050, rangedattackpower:=3000, speed_walk:=1.5, speed_run:=1.5, resistance1:=100, resistance2:=100, resistance3:=100, resistance4:=100, resistance5:=100, resistance6:=100, InhabitType:=3, health_mod:=2, mana_mod:=2.7, armor_mod:=2, mechanic_immune_mask:=0, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Hunter Bot';
+UPDATE `creature_template` SET mindmg:=125, maxdmg:=350, attackpower:=70, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=500, maxrangedmg:=900, rangedattackpower:=50, resistance1:=100, speed_walk:=1.5, speed_run:=1.5, resistance2:=100, resistance3:=100, resistance4:=100, resistance5:=100, resistance6:=100, InhabitType:=3, health_mod:=2, mana_mod:=2.7, armor_mod:=2, mechanic_immune_mask:=0, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Mage Bot';
+UPDATE `creature_template` SET mindmg:=200, maxdmg:=400, attackpower:=550, baseattacktime:=20000, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=80, resistance1:=100, speed_walk:=1.5, speed_run:=1.5, resistance2:=100, resistance3:=100, resistance4:=100, resistance5:=100, resistance6:=100, InhabitType:=3, health_mod:=2, mana_mod:=2.7, armor_mod:=2, mechanic_immune_mask:=0, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Paladin Bot';
+UPDATE `creature_template` SET mindmg:=100, maxdmg:=300, attackpower:=60, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=300, maxrangedmg:=600, rangedattackpower:=50, resistance1:=100, speed_walk:=1.5, speed_run:=1.5, resistance2:=100, resistance3:=100, resistance4:=100, resistance5:=100, resistance6:=100, InhabitType:=3, health_mod:=2, mana_mod:=2.7, armor_mod:=2, mechanic_immune_mask:=0, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Priest Bot';
+UPDATE `creature_template` SET mindmg:=1200, maxdmg:=1500, attackpower:=4500, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=900, maxrangedmg:=1100, rangedattackpower:=4100, speed_walk:=1.5, speed_run:=1.5, resistance1:=100, resistance2:=100, resistance3:=100, resistance4:=100, resistance5:=100, resistance6:=100, InhabitType:=3, health_mod:=2, mana_mod:=2.7, armor_mod:=2, mechanic_immune_mask:=0, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Rogue Bot';
+UPDATE `creature_template` SET mindmg:=150, maxdmg:=350, attackpower:=350, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=70, speed_walk:=1.5, speed_run:=1.5, resistance1:=100, resistance2:=100, resistance3:=100, resistance4:=100, resistance5:=100, resistance6:=100, InhabitType:=3, health_mod:=2, mana_mod:=2.7, armor_mod:=2, mechanic_immune_mask:=0, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Shaman Bot';
+UPDATE `creature_template` SET mindmg:=225, maxdmg:=375, attackpower:=90, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=500, maxrangedmg:=900, rangedattackpower:=60, speed_walk:=1.5, speed_run:=1.5, resistance1:=100, resistance2:=100, resistance3:=100, resistance4:=100, resistance5:=100, resistance6:=100, InhabitType:=3, health_mod:=2, mana_mod:=2.7, armor_mod:=2, mechanic_immune_mask:=0, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Warlock Bot';
+UPDATE `creature_template` SET mindmg:=800, maxdmg:=1000, attackpower:=4000, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=425, maxrangedmg:=625, rangedattackpower:=250, speed_walk:=1.5, speed_run:=1.5, resistance1:=100, resistance2:=100, resistance3:=100, resistance4:=100, resistance5:=100, resistance6:=100, InhabitType:=3, health_mod:=2, mana_mod:=2.7, armor_mod:=2, mechanic_immune_mask:=0, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Warrior Bot';
diff --git a/sql/All/world_command_Deutsch.sql b/sql/All/world_command_Deutsch.sql
new file mode 100644
index 0000000..1a2db0b
--- /dev/null
+++ b/sql/All/world_command_Deutsch.sql
@@ -0,0 +1,7 @@
+/* World Command Deutsch */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, security, help) VALUES
+('jail', 1, 'Syntax: .jail Charakter Stunden Grund\nBuchtet den \'Charakter\' für \'Stunden\' aus dem \'Grund\' ein.'),
+('jailinfo', 0, 'Syntax: .jailinfo\nZeigt dir deinen Knast-Status an.'),
+('unjail', 1, 'Syntax: .unjail Charakter\nEntläßt den \'Charakter\' aus dem Knast.'),
+('jailreload', 3, 'Syntax: .jailreload\nLädt die Jail-Konfiguration neu.');
diff --git a/sql/All/world_command_English.sql b/sql/All/world_command_English.sql
new file mode 100644
index 0000000..0176922
--- /dev/null
+++ b/sql/All/world_command_English.sql
@@ -0,0 +1,7 @@
+/* World Command English */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, security, help) VALUES
+('jail', 1, 'Syntax: .jail character hours reason\nJailed the \'character\' for \'hours\' with the \'reason\'.'),
+('jailinfo', 0, 'Syntax: .jailinfo\nShows your jail status.'),
+('unjail', 1, 'Syntax: .unjail character\nRealeases the \'character\' out of the jail.'),
+('jailreload', 3, 'Syntax: .jailreload\nLoads the jail config new.');
diff --git a/sql/All/world_command_Francais.sql b/sql/All/world_command_Francais.sql
new file mode 100644
index 0000000..237f30d
--- /dev/null
+++ b/sql/All/world_command_Francais.sql
@@ -0,0 +1,7 @@
+/* World Command Francais */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, security, help) VALUES
+('jail', 1, 'Syntaxe: .jail #personage #heures #raison\nEmprisonner un \'personnage\' pendant \'heures\' pour la \'raison\'.'),
+('jailinfo', 0, 'Syntaxe: .jailinfo\nVoir le statut de vos emprisonnements.'),
+('unjail', 1, 'Syntaxe: .unjail #personnages\nLibérer le \'personnage\' de la prison.'),
+('jailreload', 3, 'Syntaxe: .jailreload\nRecharger la configuration du Jail.');
diff --git a/sql/All/world_icc.sql b/sql/All/world_icc.sql
new file mode 100644
index 0000000..e36f794
--- /dev/null
+++ b/sql/All/world_icc.sql
@@ -0,0 +1,510 @@
+-- IceCrown Citadel SQL by LordPsyan
+
+-- ICC Teleports
+DELETE FROM `areatrigger_teleport` WHERE `id` IN (5698,5700,5718);
+INSERT INTO `areatrigger_teleport` (`id`, `name`, `target_map`, `target_position_x`, `target_position_y`, `target_position_z`, `target_orientation`) VALUES
+('5698','IceCrown Citadel Spire (Entrance)','631','4138.76','2769.25','351','0'),
+('5700','IceCrown Citadel Spire (Exit)','631','-482.01','2211.44','541.2','3.14'),
+('5718','IceCrown Citadel The Frozen Throne (Entrance)','631','529.3','-2124.7','1050','3.14159');
+
+-- Spell Stuffs and Conditions
+REPLACE INTO `conditions` (`SourceTypeOrReferenceId`,`SourceGroup`,`SourceEntry`,`ElseGroup`,`ConditionTypeOrReference`,`ConditionValue1`,`ConditionValue2`,`ConditionValue3`,`ErrorTextId`,`ScriptName`,`Comment`) VALUES
+(13,0,71614,0,18,1,38995,0,0, '', 'LichKing - Ice Lock'),
+(13,0,70588,0,18,1,36789,0,0, '', 'Valithria - Suppression'),
+(13,0,70588,0,18,1,38174,0,0, '', 'Valithria - Suppression'),
+(13,0,74074,0,18,1,36597,0,0, '', 'The Lich King - Plague Siphon');
+
+DELETE FROM `npc_spellclick_spells` WHERE npc_entry IN (37945,38430);
+INSERT INTO `npc_spellclick_spells` (`npc_entry`, `spell_id`, `quest_start`, `quest_start_active`, `quest_end`, `cast_flags`, `aura_required`, `aura_forbidden`, `user_type`) VALUES
+(37945,70766,0,0,0,3,0,0,0),
+(38430,70766,0,0,0,3,0,0,0);
+
+REPLACE INTO `spell_linked_spell` (`spell_trigger`,`spell_effect`,`type`,`comment`) VALUES
+(-70337,70338,0, 'The Lich King: Necrotic plague initial cast'),
+(-70337,72846,0, 'The Lich King: Necrotic plague immun'),
+(-70338,70338,0, 'The Lich King: Necrotic jump'),
+(-69200,69201,0, 'The Lich King: Raging Spirit'),
+(-70338,74074,0, 'The Licg King: Plague Siphon');
+
+-- coldflame spell in hallway - upper spire
+DELETE FROM `creature` WHERE `guid` IN (293962, 293961, 293960, 293959, 293958, 293957, 293956, 293955, 293954, 293953, 293952, 293951);
+insert into `creature` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`, `npcflag`, `unit_flags`, `dynamicflags`) values
+('293962','38879','631','15','1','0','0','4202.15','2750.44','352.048','0.0533629','7200','0','0','1','0','0','2','0','0','0'),
+('293961','38879','631','15','1','0','0','4223.07','2735.04','355','3.24601','7200','0','0','1','0','0','2','0','0','0'),
+('293960','38879','631','15','1','0','0','4192.36','2731.76','354.767','4.72648','7200','0','0','1','0','0','2','0','0','0'),
+('293959','38879','631','15','1','0','0','4163.35','2734.41','354.66','0.00622606','7200','0','0','1','0','0','2','0','0','0'),
+('293958','38879','631','15','1','0','0','4183.17','2751.48','352.19','3.06929','7200','0','0','1','0','0','2','0','0','0'),
+('293957','38879','631','15','1','0','0','4156.21','2779.04','352.203','4.85609','7200','0','0','1','0','0','2','0','0','0'),
+('293956','38879','631','15','1','0','0','4161.48','2788.18','352.818','6.21089','7200','0','0','1','0','0','2','0','0','0'),
+('293955','38879','631','15','1','0','0','4161.86','2803.8','354.641','0.0015316','7200','0','0','1','0','0','2','0','0','0'),
+('293954','38879','631','15','1','0','0','4192.56','2826.93','354.893','4.65503','7200','0','0','1','0','0','2','0','0','0'),
+('293953','38879','631','15','1','0','0','4223.45','2804.13','355.145','3.14707','7200','0','0','1','0','0','2','0','0','0'),
+('293952','38879','631','15','1','0','0','4223.81','2788.38','352.017','3.21851','7200','0','0','1','0','0','2','0','0','0');
+
+DELETE FROM `waypoint_scripts` WHERE `id` IN (716,717,718,719,720,721,722,747,748,749,750);
+INSERT INTO `waypoint_scripts` (`id`, `delay`, `command`, `datalong`, `datalong2`, `dataint`, `x`, `y`, `z`, `o`, `guid`) VALUES
+('716','3','15','70460','4','38879','1','0','0','0','974'),
+('717','3','15','70460','4','38879','1','0','0','0','975'),
+('718','3','15','70460','4','38879','1','0','0','0','976'),
+('719','3','15','70460','4','38879','1','0','0','0','977'),
+('720','3','15','70460','4','38879','1','0','0','0','978'),
+('721','3','15','70460','4','38879','1','0','0','0','979'),
+('722','3','15','70460','4','38879','1','0','0','0','980'),
+('747','3','15','70460','4','38879','1','0','0','0','997'),
+('748','3','15','70460','4','38879','1','0','0','0','998'),
+('749','3','15','70460','4','38879','1','0','0','0','999'),
+('750','3','15','70460','4','38879','1','0','0','0','1000');
+
+DELETE FROM `waypoint_data` WHERE `id` IN (2939620, 2939610, 2939600, 2939590, 2939580, 2939570, 2939560, 2939550, 2939540, 2939530, 2939520, 2939510);
+INSERT INTO `waypoint_data` (`id`, `point`, `position_x`, `position_y`, `position_z`, `delay`, `move_flag`, `action`, `action_chance`, `wpguid`) VALUES
+('2939520','1','4223.81','2788.38','352.017','7000','0','716','100','0'),
+('2939530','1','4223.45','2804.13','355.145','5000','0','717','100','0'),
+('2939540','1','4192.56','2826.93','354.893','7000','0','718','100','0'),
+('2939550','1','4161.86','2803.8','354.641','5000','0','719','100','0'),
+('2939560','1','4161.48','2788.18','352.818','7000','0','720','100','0'),
+('2939570','1','4156.21','2779.04','352.203','5000','0','721','100','0'),
+('2939580','1','4183.17','2751.48','352.19','7000','0','722','100','0'),
+('2939590','1','4163.35','2734.41','354.66','5000','0','747','100','0'),
+('2939600','1','4192.36','2731.76','354.767','7000','0','748','100','0'),
+('2939610','1','4223.07','2735.04','355','5000','0','749','100','0'),
+('2939620','1','4202.15','2750.44','352.048','7000','0','750','100','0');
+
+DELETE FROM `creature_addon` WHERE `guid` IN (293962, 293961, 293960, 293959, 293958, 293957, 293956, 293955, 293954, 293953, 293952, 293951);
+INSERT INTO `creature_addon` (`guid`, `path_id`, `mount`, `bytes1`, `bytes2`, `emote`, `auras`) VALUES
+('293962','2939620','0','0','0','0',NULL),
+('293961','2939610','0','0','0','0',NULL),
+('293960','2939600','0','0','0','0',NULL),
+('293959','2939590','0','0','0','0',NULL),
+('293958','2939580','0','0','0','0',NULL),
+('293957','2939570','0','0','0','0',NULL),
+('293956','2939560','0','0','0','0',NULL),
+('293955','2939550','0','0','0','0',NULL),
+('293954','2939540','0','0','0','0',NULL),
+('293953','2939530','0','0','0','0',NULL),
+('293952','2939520','0','0','0','0',NULL);
+
+-- trash mobs scripts.
+DELETE FROM `creature_ai_scripts` WHERE `creature_id` IN (37868,36791,37863,37886,37934,38068,37698,36701);
+UPDATE `creature_template` SET `AIName`= 'EventAI' WHERE `entry` IN (37868,36791,37863,37886,37934,38068,37698,36701);
+INSERT INTO `creature_ai_scripts` VALUES
+('85021059','37868','0','0','100','7','15000','15000','27000','27000','11','71179','4','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Mana Void'),
+('85021060','37868','0','0','100','25','15000','15000','27000','27000','11','71741','4','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Mana Void'),
+('85021061','37868','0','0','100','3','10000','10000','18000','22000','11','70759','0','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Frostbolt Volley'),
+('85021062','37868','0','0','100','9','10000','10000','18000','22000','11','71889','0','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Frostbolt Volley'),
+('85021063','37868','0','0','100','5','10000','10000','18000','22000','11','72015','0','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Frostbolt Volley'),
+('85021064','37868','0','0','100','17','10000','10000','18000','22000','11','72016','0','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Frostbolt Volley'),
+('85021065','37868','0','0','100','31','18000','18000','28000','28000','11','70602','4','0','0','0','0','0','0','0','0','0','Risen Archmage - Cast Corruption'),
+('85021066','38068','0','0','100','30','30000','30000','0','0','37','0','0','1','0','0','0','0','0','0','0','0', 'Mana Void - Self Destruct'),
+('80021007','36791','0','0','100','7','8000','8000','22000','25000','11','69325','0','1','0','0','0','0','0','0','0','0','Blazing Skeleton - Casts Lay Waste'),
+('80021008','36791','0','0','100','25','8000','8000','22000','25000','11','71730','0','1','0','0','0','0','0','0','0','0','Blazing Skeleton - Casts Lay Waste'),
+('80021009','36791','0','0','100','6','0','0','0','0','21','0','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Stop Movement on Aggro'),
+('80021010','36791','4','0','100','6','0','0','0','0','11','70754','1','0','22','6','0','0','0','0','0','0','Blazing Skeleton - Cast Fireball and Set Phase 1 on Aggro'),
+('80021011','36791','3','0','100','6','15','0','0','0','21','1','0','0','22','5','0','0','0','0','0','0','Blazing Skeleton - Start Movement and Set Phase 2 when Mana is at 15%'),
+('80021012','36791','0','6','100','7','0','0','1500','3000','11','70754','1','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Cast Fireball above 15% Mana (Phase 1)'),
+('80021013','36791','3','5','100','6','100','28','0','0','21','0','0','0','22','6','0','0','0','0','0','0','Blazing Skeleton - Set Ranged Movement and Set Phase 1 when Mana is above 28% (Phase 2)'),
+('80021014','36791','9','0','100','7','30','50','0','0','22','1','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Start Movement Beyond 30 Yards'),
+('80021015','36791','7','0','100','6','0','0','0','0','22','0','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - On Evade set Phase to 0'),
+('80021016','36791','0','0','100','24','0','0','0','0','21','0','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Stop Movement on Aggro'),
+('80021017','36791','4','0','100','24','0','0','0','0','11','71748','1','0','22','6','0','0','0','0','0','0','Blazing Skeleton - Cast Fireball and Set Phase 1 on Aggro'),
+('80021018','36791','3','0','100','24','15','0','0','0','21','1','0','0','22','5','0','0','0','0','0','0','Blazing Skeleton - Start Movement and Set Phase 2 when Mana is at 15%'),
+('80021019','36791','0','6','100','25','0','0','1500','3000','11','71748','1','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Cast Fireball above 15% Mana (Phase 1)'),
+('80021020','36791','3','5','100','24','100','28','0','0','21','0','0','0','22','6','0','0','0','0','0','0','Blazing Skeleton - Set Ranged Movement and Set Phase 1 when Mana is above 28% (Phase 2)'),
+('80021021','36791','9','0','100','25','30','50','0','0','22','1','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - Start Movement Beyond 30 Yards'),
+('80021022','36791','7','0','100','24','0','0','0','0','22','0','0','0','0','0','0','0','0','0','0','0','Blazing Skeleton - On Evade set Phase to 0'),
+('86021086','37863','4','0','100','30','0','0','0','0','11','70588','1','0','0','0','0','0','0','0','0','0','Suppresser - Cast Suppression'),
+('82021033','37886','0','0','100','7','10000','11000','22000','28000','11','70633','4','0','0','0','0','0','0','0','0','0','Gluttonous Abomination - Casts Gut Spray'),
+('82021034','37886','0','0','100','25','10000','11000','22000','28000','11','71283','4','0','0','0','0','0','0','0','0','0','Gluttonous Abomination - Casts Gut Spray'),
+('82021035','37886','6','0','100','30','0','0','0','0','11','70675','0','2','0','0','0','0','0','0','0','0', 'Gluttonous Abomination - Casts on death Summon Rot Worm'),
+('80021026','37934','2','0','100','7','10','0','12300','14900','11','70744','0','0','0','0','0','0','0','0','0','0','Blistering Zombie - Casts Acid Burst at 10% HP'),
+('80021027','37934','2','0','100','25','10','0','12300','14900','11','71733','0','0','0','0','0','0','0','0','0','0','Blistering Zombie - Casts Acid Burst at 10% HP'),
+('85021075','37698','2','0','100','6','25','0','0','0','11','72143','0','0','1','-106','0','0','0','0','0','0','Shambling Horror - Casts Enrage at 25% HP'),
+('85021076','37698','2','0','100','24','25','0','0','0','11','72146','0','0','1','-106','0','0','0','0','0','0','Shambling Horror - Casts Enrage at 25% HP'),
+('85021077','37698','0','0','100','7','7000','9000','15000','17000','11','72149','0','0','0','0','0','0','0','0','0','0','Shambling Horror - Casts Shockwave'),
+('85021078','37698','0','0','100','25','7000','9000','15000','17000','11','73794','0','0','0','0','0','0','0','0','0','0','Shambling Horror - Casts Shockwave'),
+('85021054','36701','0','0','100','7','10000','10000','25000','35000','11','69242','0','0','0','0','0','0','0','0','0','0','Raging Spirit - Cast Soul Shriek'),
+('85021055','36701','0','0','100','25','10000','10000','25000','35000','11','73800','0','0','0','0','0','0','0','0','0','0','Raging Spirit - Cast Soul Shriek');
+
+
+
+-- Creature Script Names
+UPDATE `creature_template` SET `ScriptName` = "npc_coldflame" WHERE `entry` = 36672;
+UPDATE `creature_template` SET `ScriptName` = "npc_cult_fanatic" WHERE `entry` IN (37890,38009,38135);
+UPDATE `creature_template` SET `ScriptName` = "npc_cult_adherent" WHERE `entry` IN(37949,38010,38136);
+UPDATE `creature_template` SET `ScriptName` = "npc_vengeful_shade" WHERE `entry` = 38222;
+UPDATE `creature_template` SET `ScriptName` = "npc_little_ooze" WHERE `entry` = 36897;
+UPDATE `creature_template` SET `ScriptName` = "npc_big_ooze" WHERE `entry` = 36899;
+UPDATE `creature_template` SET `ScriptName` = "npc_icc_puddle_stalker" WHERE `entry` = 37824;
+UPDATE `creature_template` SET `ScriptName` = "npc_ooze_explode_stalker" WHERE `entry` = 38107;
+UPDATE `creature_template` SET `ScriptName` = "npc_gas_cloud_icc" WHERE `entry` = 37562;
+UPDATE `creature_template` SET `ScriptName` = "npc_bomb_icc" WHERE `entry` = 38159;
+UPDATE `creature_template` SET `ScriptName` = "boss_prince_valanar_icc" WHERE `entry` = 37970;
+UPDATE `creature_template` SET `ScriptName` = "boss_prince_keleseth_icc" WHERE `entry` = 37972;
+UPDATE `creature_template` SET `ScriptName` = "boss_prince_taldaram_icc" WHERE `entry` = 37973;
+UPDATE `creature_template` SET `ScriptName` = "npc_spinestalker" WHERE `entry` = 37534;
+UPDATE `creature_template` SET `ScriptName` = "boss_valithria" WHERE `entry` = 36789;
+UPDATE `creature_template` SET `ScriptName` = "npc_rimefang" WHERE `entry` = 37533;
+UPDATE `creature_template` SET `ScriptName` = "npc_dreamportal_icc" WHERE `entry` = 37945;
+UPDATE `creature_template` SET `ScriptName` = "npc_dreamportal_icc" WHERE `entry` = 38186;
+UPDATE `creature_template` SET `ScriptName` = "npc_icc_combat_stalker" WHERE `entry` = 38752;
+UPDATE `creature_template` SET `ScriptName` = "boss_the_lich_king" WHERE `entry` = 36597;
+UPDATE `creature_template` SET `ScriptName` = "boss_sindragosa" WHERE `entry` = 36853;
+UPDATE `creature_template` SET `ScriptName` = "npc_valithria_alternative" WHERE `entry` = 37950;
+UPDATE `creature_template` SET `ScriptName` = "npc_dreamcloud_icc" WHERE `entry` = 37985;
+UPDATE `creature_template` SET `ScriptName` = "npc_ice_tomb" WHERE `entry` = 36980;
+UPDATE `creature_template` SET `ScriptName` = "npc_tirion_icc" WHERE `entry` = 38995;
+UPDATE `creature_template` SET `ScriptName` = "npc_valkyr_icc" WHERE `entry` = 36609;
+UPDATE `creature_template` SET `ScriptName` = "npc_vile_spirit_icc" WHERE `entry` = 37799;
+UPDATE `creature_template` SET `ScriptName` = "npc_dreamportal_icc" WHERE `entry` = 38429;
+UPDATE `creature_template` SET `ScriptName` = "npc_dreamportal_icc" WHERE `entry` = 38430;
+UPDATE `creature_template` SET `ScriptName` = "boss_valithria" WHERE `entry` = 36789;
+UPDATE `creature_template` SET `ScriptName` = "boss_the_lich_king" WHERE `entry` = 36597;
+UPDATE `creature_template` SET `ScriptName` = "npc_tirion_icc" WHERE `entry` = 38995;
+
+UPDATE `creature_template` SET `ScriptName` = "npc_muradin_bronzebeard_icc" WHERE `entry` = 37200;
+UPDATE `creature_template` SET `ScriptName` = "npc_muradin_bronzebeard_gunship" WHERE `entry` = 37540;
+UPDATE `creature_template` SET `ScriptName` = "boss_blood_queen_lana_thel" WHERE `entry`=37955;
+UPDATE `creature_template` SET `ScriptName` = "boss_valithria" WHERE `entry` = 36789;
+UPDATE `creature_template` SET `ScriptName` = "boss_sindragosa" WHERE `entry` = 36853;
+UPDATE `creature_template` SET `ScriptName` = "boss_the_lich_king" WHERE `entry` = 36597;
+UPDATE `creature_template` SET `ScriptName` = "boss_deathbringer_saurfang" WHERE `entry`=37813;
+UPDATE `creature_template` SET `ScriptName` = "npc_high_overlord_saurfang_icc" WHERE `entry`=37187;
+UPDATE `creature_template` SET `ScriptName` = "npc_valithria_alternative" WHERE `entry` = 37950;
+UPDATE `creature_template` SET `ScriptName` = "npc_column_of_frost_icc" WHERE `entry` = 37918;
+
+-- Missing creatures
+DELETE FROM `creature_template` WHERE `entry` IN (38157,38078,38094,38151,38486,38717,38552,38590,15214, 22515, 26043, 30298, 32601, 32780, 36171, 36597, 36659, 36724, 36789, 36839, 36848, 36934, 36948, 36970, 36998, 37004, 37012, 37013, 37016, 37017, 37023, 37027, 37028, 37029, 37030, 37031, 37032, 37033, 37034, 37035, 37122, 37123, 37124, 37125, 37126, 37127, 37129, 37132, 37133, 37134, 37144, 37146, 37148, 37149, 37181, 37182, 37183, 37184, 37215, 37230, 37231, 37503, 37519, 37528, 37531, 37532, 37533, 37534, 37544, 37545, 37546, 37663, 37696, 37702, 37824, 37868, 37882, 37903, 37904, 37928, 37935, 37936, 37947, 37948, 37950, 37996, 38008, 38125, 38153, 38154, 38228, 38229, 38231, 38232, 38248, 38317, 38463, 38471, 38490, 38494, 38501, 38551, 38557, 38589, 38752, 38879, 38995, 39010);
+UPDATE `creature_template` SET `npcflag` = 1 WHERE `entry` IN (38639,38640);
+insert into `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) values
+('38078','0','0','0','37017','0','30473','30465','0','0','Skybreaker Assassin (1)','','','0','82','82','2','1802','1802','0','0.5','0.571429','1','1','375','563','0','141','35.9','2000','2000','4','32832','8','0','0','0','0','0','300','450','113','7','72','38078','0','0','0','0','0','0','0','0','69921','71128','69920','71145','0','0','0','0','0','0','8523','8523','','0','3','80','10','1','0','0','0','0','0','0','0','0','1','2031','0','0','','12340'),
+('38094','0','0','0','0','0','30485','30486','0','0','Kor\'kron Stalker (1)','','','0','82','82','2','1801','1801','0','1','1.14286','1','1','375','563','0','141','2.4','2000','2000','4','32832','8','0','0','0','0','0','300','450','113','7','72','0','0','0','0','0','0','0','0','0','69921','71128','69920','71145','0','0','0','0','0','0','8631','8631','','0','3','80','10','1','0','0','0','0','0','0','0','0','1','2034','0','0','','12340'),
+('38151','0','0','0','37532','0','30640','0','0','0','Frostwing Whelp (1)','','','0','80','80','2','2212','2212','0','1','1','1','1','391','585','0','146','16.1','2000','2000','2','0','8','0','0','0','0','0','313','468','117','6','0','38151','0','0','0','0','0','0','0','0','71350','71361','0','0','0','0','0','0','0','0','0','0','','0','3','20','1','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('38157','0','0','0','36948','0','30508','0','0','0','Muradin Bronzebeard (1)','','','0','83','83','2','1802','1802','1','1','1.14286','1','1','468','702','0','176','47.2','2000','2000','1','32768','8','0','0','0','0','0','374','562','141','7','76','0','0','0','0','0','0','0','0','0','15284','70309','0','0','0','0','0','0','0','0','0','0','','0','3','350','1','1','0','0','0','0','0','0','0','164','1','2022','0','0','','12340'),
+('38486','0','0','0','0','0','31127','0','0','0','Infiltrator Minchar (1)','','','0','80','80','2','35','35','2','1','1.14286','1','1','349','523','0','131','12.1','2000','2000','4','0','8','0','0','0','0','0','279','418','105','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','75','1','1','0','0','0','0','0','0','0','0','1','2283','0','0','','12340'),
+('38552','0','0','0','0','0','31097','0','0','0','Alrin the Agile (1)','','','0','80','80','2','35','35','3','1','1.14286','1','1','349','523','0','131','12.1','2000','2000','4','32768','8','0','0','0','0','0','279','418','105','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','75','1','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('38590','0','0','0','0','0','31125','0','0','0','Valithria Dreamwalker (1)','','','0','83','83','2','35','35','2','1.8','1.14286','1','3','468','702','0','176','47.2','2000','2000','1','0','8','0','0','0','0','0','374','562','141','2','4172','0','0','0','0','0','0','0','0','0','70904','0','0','0','0','0','0','0','0','0','0','0','','0','3','717.103','1','1','0','0','0','0','0','0','0','0','0','0','801849343','1','','12340'),
+('38717','0','0','0','0','0','29760','0','0','0','Alchemist Adrianna (1)','','','11032','80','80','2','2070','2070','3','1','1.14286','1','0','307','459','0','115','1.4','2000','2000','8','0','8','0','0','0','0','0','246','367','92','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','5','5','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('15214','0','0','0','0','0','1126','11686','0','0','Invisible Stalker','','','0','1','1','0','35','35','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','33554432','8','0','0','0','0','0','1','2','0','10','1024','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','7','1','1','1','0','0','0','0','0','0','0','0','1','0','0','128','','12340'),
+('22515','0','0','0','0','0','169','16925','0','0','World Trigger','','','0','60','60','0','114','114','0','1','1.14286','1','0','128','192','0','48','1','2000','2000','1','33555200','8','0','0','0','0','0','102','154','38','10','16778240','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1.35','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340'),
+('26043','0','0','0','0','0','1126','23501','0','0','Steam Burst','','','0','1','1','0','35','35','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','33555200','8','0','0','0','0','0','1','2','0','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','1','1','1','0','0','0','0','0','0','0','0','1','0','0','128','','12340'),
+('30298','0','0','0','0','0','1126','11686','0','0','Invisible Stalker (Float, Uninteractible, LargeAOI)','','','0','1','1','2','35','35','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','33554432','8','0','0','0','0','0','1','2','0','10','1048576','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','EventAI','0','5','1','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340'),
+('32601','0','0','0','0','0','26847','22152','23167','17476','Dalaran Visitor','','','0','79','80','2','2007','2007','0','1','1.14286','1','0','307','459','0','115','1','2000','2000','8','32768','8','0','0','0','0','0','246','367','92','7','4096','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('32780','0','0','0','0','0','1126','11686','0','0','Invisible Stalker (All Phases)','','','0','1','1','2','35','35','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','33554432','8','0','0','0','0','0','1','2','0','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','1','128','','12340'),
+('36171','0','0','0','0','0','169','16925','0','0','World Trigger (Infinite AOI)','','','0','60','60','1','114','114','0','1','1.14286','1','0','128','192','0','48','1','2000','2000','1','33555200','8','0','0','0','0','0','102','154','38','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1.35','1','1','0','0','0','0','0','0','0','0','1','0','0','128','','12340'),
+('36597','39166','39167','39168','0','0','30721','0','0','0','The Lich King','','','0','83','83','2','974','974','0','2','1.14286','1','3','351','527','0','132','133.2','1500','1500','1','768','8','0','0','0','0','0','281','422','106','6','268435564','36597','0','0','0','0','0','0','0','0','68980','70541','72133','68981','0','0','0','0','0','0','1542857','1542857','','0','3','1250','500','1','0','0','0','0','0','0','0','169','1','0','667631615','1','generic_creature','12340'),
+('36659','0','0','0','0','0','1126','11686','0','0','Abomination Wing Orange Gas Stalker','','','0','80','80','2','14','14','0','1','1.14286','1','0','420','630','0','158','1','2000','2000','1','33554688','8','0','0','0','0','0','336','504','126','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','2','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340'),
+('36724','38057','0','0','0','38121','26919','0','0','0','Servant of the Throne','','','0','80','80','2','21','21','0','1.5','1.14286','1','1','391','585','0','146','10.8','2000','2000','2','32832','8','0','0','0','0','0','313','468','117','6','0','36724','0','0','0','0','0','0','0','0','71029','0','0','0','0','0','0','0','0','0','7604','7604','','0','3','30','25','1','0','0','0','0','0','0','0','0','1','0','0','0','generic_creature','12340'),
+('36789','38174','0','0','0','0','30318','0','0','0','Valithria Dreamwalker','','','0','83','83','2','1802','1801','0','1.8','1.14286','1','3','468','702','0','176','47.2','2000','2000','1','536870912','8','0','0','0','0','0','374','562','141','2','67113036','0','0','0','0','0','0','0','0','0','70904','71196','71189','0','0','0','0','0','0','0','0','0','','0','3','860.524','1','1','0','0','0','0','0','0','0','0','0','0','801849343','1','generic_creature','12340'),
+('36839','0','0','0','0','0','29489','0','0','0','Horde Gunship Cannon','','vehichleCursor','0','80','80','2','1665','1665','0','0','0','1','0','349','523','0','131','1.4','2000','2000','4','16384','8','0','0','0','0','0','279','418','105','9','8','0','0','0','0','0','0','0','0','0','69399','70175','0','0','0','0','0','0','0','555','0','0','','0','3','65.5185','1','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('36848','0','0','0','0','0','1126','17612','0','0','Invisible Stalker','','','0','1','1','2','35','35','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','33554688','8','0','0','0','0','0','1','2','0','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340'),
+('36934','0','0','0','0','0','1126','11686','0','0','Empowering Orb Controller Stalker','','','0','1','1','2','35','35','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','33554688','8','0','0','0','0','0','1','2','0','10','1048576','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','0','128','','12340'),
+('36948','38157','38639','38640','0','0','30508','0','0','0','Muradin Bronzebeard','','','10875','83','83','2','1802','1802','1','1','1.14286','1','1','468','702','0','176','47.2','2000','2000','1','32768','8','0','0','0','0','0','374','562','141','7','76','0','0','0','0','0','0','0','0','0','15284','70309','0','0','0','0','0','0','0','0','0','0','','0','3','175','1','1','0','0','0','0','0','0','0','164','1','2022','0','0','generic_creature','12340'),
+('36970','0','0','0','0','0','26989','26990','26991','26992','Skybreaker Deckhand','','','0','80','80','2','1802','1802','0','1','1.14286','1','0','420','630','0','158','1.4','2000','2000','1','832','8','0','0','0','0','0','336','504','126','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','914','0','0','','12340'),
+('36998','38082','0','0','0','0','30452','30450','0','0','Skybreaker Protector','','','0','82','82','2','1802','1802','0','1.5','1.14286','1','1','452','678','0','170','22.3','2000','2000','1','32832','8','0','0','0','0','0','362','542','136','7','72','36998','0','0','0','0','0','0','0','0','69902','69903','72645','69901','0','0','0','0','0','0','9315','9315','','0','3','35','10','1','0','0','0','0','0','0','0','0','1','2025','0','0','generic_creature','12340'),
+('37004','38079','0','0','0','0','30455','30457','0','0','Skybreaker Dreadblade','','','0','82','82','2','1802','1802','0','1.5','1.14286','1','1','452','678','0','170','22.9','2000','2000','1','32832','8','0','0','0','0','0','362','542','136','7','72','37004','0','0','0','0','0','0','0','0','69916','69912','0','0','0','0','0','0','0','0','7610','7610','','0','3','30','10','1','0','0','0','0','0','0','0','0','1','2027','0','0','generic_creature','12340'),
+('37012','38059','0','0','0','38121','30616','30617','0','0','Ancient Skeletal Soldier','','','0','80','80','2','21','21','0','1.5','1.14286','1','1','420','630','0','158','15','2000','2000','1','32832','8','0','0','0','0','0','336','504','126','6','0','37012','0','0','0','0','0','0','0','0','70964','0','0','0','0','0','0','0','0','0','0','0','','0','3','25','1','1','0','0','0','0','0','0','0','0','1','2029','0','0','generic_creature','12340'),
+('37013','0','0','0','0','0','1126','11686','0','0','Puddle Stalker','','','0','80','80','2','14','14','0','1','1.14286','1','0','420','630','0','158','1','2000','2000','1','33554432','8','0','0','0','0','0','336','504','126','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','2','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340'),
+('37016','38081','0','0','0','0','30463','0','0','0','Skybreaker Luminary','','','0','82','82','2','1802','1802','0','0.6','0.685714','1','1','420','631','0','158','6.9','2000','2000','2','32832','8','0','0','0','0','0','336','505','126','7','72','37016','0','0','0','0','0','0','0','0','69923','71120','69926','69958','0','0','0','0','0','0','8586','8586','','0','3','25','10','1','0','0','0','0','0','0','0','0','1','2030','0','0','generic_creature','12340'),
+('37017','38078','0','0','0','0','30473','30465','0','0','Skybreaker Assassin','','','0','82','82','2','1802','1802','0','0.5','0.571429','1','1','375','563','0','141','29.8','2000','2000','4','32832','8','0','0','0','0','0','300','450','113','7','72','37017','0','0','0','0','0','0','0','0','69921','71128','69920','71145','0','0','0','0','0','0','8523','8523','','0','3','30','10','1','0','0','0','0','0','0','0','0','1','2031','0','0','generic_creature','12340'),
+('37023','38062','0','0','0','38121','31020','31022','0','0','Plague Scientist','','','0','80','80','2','21','21','0','1.5','1.14286','1','1','391','585','0','146','16.7','2000','2000','2','64','8','0','0','0','0','0','313','468','117','6','72','37023','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','7687','7687','','0','3','35','2','1','0','0','0','0','0','0','0','144','1','0','0','0','','12340'),
+('37027','38080','0','0','0','0','30471','30472','0','0','Skybreaker Hierophant','','','0','82','82','2','1802','1802','0','1','1.14286','1','1','330','495','0','124','15.5','2000','2000','8','32832','8','0','0','0','0','0','264','396','99','7','72','37027','0','0','0','0','0','0','0','0','69899','71121','69882','71141','0','0','0','0','0','0','8875','8875','','0','3','25','10','1','0','0','0','0','0','0','0','0','1','2033','0','0','generic_creature','12340'),
+('37028','38094','0','0','0','0','30485','30486','0','0','Kor\'kron Stalker','','','0','82','82','2','1801','1801','0','1','1.14286','1','1','375','563','0','141','2.4','2000','2000','4','32832','8','0','0','0','0','0','300','450','113','7','72','0','0','0','0','0','0','0','0','0','69921','71128','69920','71145','0','0','0','0','0','0','8631','8631','','0','3','30','10','1','0','0','0','0','0','0','0','0','1','2034','0','0','generic_creature','12340'),
+('37029','38092','0','0','0','0','30482','30484','0','0','Kor\'kron Reaver','','','0','82','82','2','1801','1801','0','1','1.14286','1','1','452','678','0','170','17.9','2000','2000','1','32832','8','0','0','0','0','0','362','542','136','7','72','37029','0','0','0','0','0','0','0','0','69916','69912','0','0','0','0','0','0','0','0','8676','8676','','0','3','30','10','1','0','0','0','0','0','0','0','0','1','2035','0','0','generic_creature','12340'),
+('37030','38091','0','0','0','0','30480','30481','0','0','Kor\'kron Primalist','','','0','82','82','2','1801','1801','0','1.5','1.14286','1','1','330','495','0','124','9.5','2000','2000','8','32832','8','0','0','0','0','0','264','396','99','7','72','37030','0','0','0','0','0','0','0','0','69899','71121','69882','71141','0','0','0','0','0','0','8668','8668','','0','3','25','10','1','0','0','0','0','0','0','0','0','1','2033','0','0','generic_creature','12340'),
+('37031','38090','0','0','0','0','30478','30479','0','0','Kor\'kron Oracle','','','0','82','82','2','1801','1801','0','1.5','1.14286','1','1','420','631','0','158','19.2','2000','2000','2','32832','8','0','0','0','0','0','336','505','126','7','72','37031','0','0','0','0','0','0','0','0','69923','71120','69926','69958','0','0','0','0','0','0','8929','8929','','0','3','25','10','1','0','0','0','0','0','0','0','0','1','2036','0','0','generic_creature','12340'),
+('37032','38087','0','0','0','0','30474','30475','0','0','Kor\'kron Defender','','','0','82','82','2','1801','1801','0','1.5','1.14286','1','1','452','678','0','170','22.3','2000','2000','1','32832','8','0','0','0','0','0','362','542','136','7','72','37032','0','0','0','0','0','0','0','0','69902','69903','72645','69901','0','0','0','0','0','0','8505','8505','','0','3','35','10','1','0','0','0','0','0','0','0','0','1','2037','0','0','generic_creature','12340'),
+('37033','38088','0','0','0','0','30476','30477','0','0','Kor\'kron Invoker','','','0','82','82','2','1801','1801','0','1.5','1.14286','1','1','330','495','0','124','29.7','2000','2000','8','32832','8','0','0','0','0','0','264','396','99','7','72','37033','0','0','0','0','0','0','0','0','69904','69869','71130','69811','0','0','0','0','0','0','9723','9723','','0','3','25','10','1','0','0','0','0','0','0','0','0','1','2038','0','0','generic_creature','12340'),
+('37034','38095','0','0','0','0','30487','30488','0','0','Kor\'kron Templar','','','0','82','82','2','1801','1801','0','1.5','1.14286','1','1','330','495','0','124','24.1','2000','2000','8','32832','8','0','0','0','0','0','264','396','99','7','72','37034','0','0','0','0','0','0','0','0','69963','71131','69910','69967','0','0','0','0','0','0','9225','9225','','0','3','25','10','1','0','0','0','0','0','0','0','0','1','2039','0','0','generic_creature','12340'),
+('37035','38096','0','0','0','0','30489','30490','0','0','Kor\'kron Vanquisher','','','0','82','82','2','1801','1801','0','1.5','1.14286','1','1','420','631','0','158','19.2','2000','2000','2','32832','8','0','0','0','0','0','336','505','126','7','72','37035','0','0','0','0','0','0','0','0','69927','71117','69930','71122','0','0','0','0','0','0','9559','9559','','0','3','35','10','1','0','0','0','0','0','0','0','0','1','2040','0','0','generic_creature','12340'),
+('37122','38298','0','0','0','0','30907','0','0','0','Captain Arnath','','','0','81','81','2','2131','2131','0','1.6','1.14286','1','1','304','456','0','114','26.7','1500','1500','2','0','8','0','0','0','0','0','243','365','91','7','4096','0','0','0','0','0','0','0','0','0','14515','71595','71781','71546','0','0','0','0','0','0','0','0','','0','3','10','1','1','0','0','0','0','0','0','0','0','1','2043','0','0','generic_creature','12340'),
+('37123','38299','0','0','0','0','30908','0','0','0','Captain Brandon','','','0','81','81','2','2131','2131','0','1.8','1.14286','1','1','304','456','0','114','20.1','1500','1500','2','0','8','0','0','0','0','0','243','365','91','7','4096','0','0','0','0','0','0','0','0','0','71549','71550','71784','71551','0','0','0','0','0','0','0','0','','0','3','10','1','1','0','0','0','0','0','0','0','0','1','2044','0','0','generic_creature','12340'),
+('37124','38303','0','0','0','0','30909','0','0','0','Captain Grondel','','','0','81','81','2','2131','2131','0','1.7','1.14286','1','1','327','491','0','123','24.8','1500','1500','1','0','8','0','0','0','0','0','262','393','98','7','4096','0','0','0','0','0','0','0','0','0','71553','71785','71552','71554','0','0','0','0','0','0','0','0','','0','3','10','1','1','0','0','0','0','0','0','0','0','1','2045','0','0','generic_creature','12340'),
+('37125','38304','0','0','0','38121','30910','0','0','0','Captain Rupert','','','0','81','81','2','2131','2131','0','1.6','1.14286','1','1','327','491','0','123','18.7','1500','1500','1','0','8','0','0','0','0','0','262','393','98','7','4096','0','0','0','0','0','0','0','0','0','71592','71789','71590','70089','0','0','0','0','0','0','0','0','','0','3','10','1','1','0','0','0','0','0','0','0','0','1','2046','0','0','generic_creature','12340'),
+('37126','38258','0','0','0','38121','30521','0','0','0','Sister Svalna','','','0','82','82','2','2209','2209','0','2','1.14286','1','1','420','631','0','158','34.4','2000','2000','2','320','8','0','0','0','0','0','336','505','126','6','96','37126','0','0','0','0','0','0','0','0','71468','71463','71465','0','0','0','0','0','0','0','0','0','','0','4','200','20','1','0','0','0','0','0','0','0','200','1','2041','0','0','generic_creature','12340'),
+('37127','38126','0','0','0','38121','27548','0','0','0','Ymirjar Frostbinder','','','0','80','80','2','2212','2212','0','1.6','1.14286','1','1','307','459','0','115','13.7','2000','2000','8','0','8','0','0','0','0','0','246','367','92','7','8','0','0','0','0','0','0','0','0','0','71270','71274','69929','71306','0','0','0','0','0','0','0','0','','0','3','45','1','1','0','0','0','0','0','0','0','0','1','93','0','0','generic_creature','12340'),
+('37129','38000','0','0','0','0','30911','0','0','0','Crok Scourgebane','Grand Champion of the Ebon Blade','','0','83','83','2','2214','2214','0','1','1.14286','1','1','468','702','0','176','2','2000','2000','1','512','8','0','0','0','0','0','374','562','141','7','4104','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','20','1','1','0','0','0','0','0','0','0','0','1','5252','0','0','','12340'),
+('37132','38132','0','0','0','38121','27549','0','0','0','Ymirjar Battle-Maiden','','','0','80','80','2','2209','2209','0','1.7','1.14286','1','1','420','630','0','158','10','2000','2000','1','32832','8','0','0','0','0','0','336','504','126','7','8','0','0','0','0','0','0','0','0','0','71258','71257','0','0','0','0','0','0','0','0','0','0','','0','3','45','1','1','0','0','0','0','0','0','0','0','1','1945','0','0','generic_creature','12340'),
+('37133','38133','0','0','0','38121','26623','0','0','0','Ymirjar Warlord','','','0','80','80','2','2209','2209','0','1.7','1.14286','1','1','420','630','0','158','10','2000','2000','1','32832','8','0','0','0','0','0','336','504','126','7','8','0','0','0','0','0','0','0','0','0','41057','0','0','0','0','0','0','0','0','0','0','0','','0','3','50','1','1','0','0','0','0','0','0','0','0','1','358','803160063','0','generic_creature','12340'),
+('37134','38131','0','0','0','38121','25771','0','0','0','Ymirjar Huntress','','','0','80','80','2','2209','2209','0','1.7','1.14286','1','1','391','585','0','146','10','2000','2000','2','32832','8','0','0','0','0','0','313','468','117','7','8','0','0','0','0','0','0','0','0','0','71249','71251','71253','71252','0','0','0','0','0','0','0','0','','0','3','35','1','1','0','0','0','0','0','0','0','0','1','2047','0','0','generic_creature','12340'),
+('37144','38097','0','0','0','0','30529','30528','0','0','Skybreaker Marksman','','','0','82','82','2','1802','1802','0','1.5','1.14286','1','1','420','631','0','158','19.2','2000','2000','2','32832','8','0','0','0','0','0','336','505','126','7','72','37144','0','0','0','0','0','0','0','0','69989','71116','69975','71126','0','0','0','0','0','0','7973','7973','','0','3','30','10','1','0','0','0','0','0','0','0','0','1','2048','0','0','generic_creature','12340'),
+('37146','38093','0','0','0','0','30530','30531','0','0','Kor\'kron Sniper','','','0','82','82','2','1801','1801','0','1.5','1.14286','1','1','420','631','0','158','19.2','2000','2000','2','32832','8','0','0','0','0','0','336','505','126','7','72','37146','0','0','0','0','0','0','0','0','69989','71116','69975','71126','0','0','0','0','0','0','9749','9749','','0','3','30','10','1','0','0','0','0','0','0','0','0','1','2049','0','0','generic_creature','12340'),
+('37148','38084','0','0','0','0','30535','30536','0','0','Skybreaker Summoner','','','0','82','82','2','1802','1802','0','1.5','1.14286','1','1','330','495','0','124','11.6','2000','2000','8','32832','8','0','0','0','0','0','264','396','99','7','72','37148','0','0','0','0','0','0','0','0','69969','71124','69973','71135','0','0','0','0','0','0','8617','8617','','0','3','25','10','1','0','0','0','0','0','0','0','0','1','2050','0','0','generic_creature','12340'),
+('37149','38089','0','0','0','0','30532','30534','0','0','Kor\'kron Necrolyte','','','0','82','82','2','1801','1801','0','1','1.14286','1','1','330','495','0','124','11.6','2000','2000','8','32832','8','0','0','0','0','0','264','396','99','7','72','37149','0','0','0','0','0','0','0','0','69969','71124','69973','71135','0','0','0','0','0','0','10133','10133','','0','3','25','10','1','0','0','0','0','0','0','0','0','1','2051','0','0','generic_creature','12340'),
+('37181','0','0','0','0','0','19725','25455','0','0','The Lich King','','','0','83','83','2','35','35','0','1','1.14286','1','0','435','653','0','163','1.1','2000','2000','2','33555200','8','0','0','0','0','0','348','522','130','10','8','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','2000','2000','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('37182','0','0','0','0','0','26982','0','0','0','High Captain Justin Bartlett','','','0','80','80','2','1802','1802','0','1','1.14286','1','1','420','630','0','158','10','2000','2000','1','768','8','0','0','0','0','0','336','504','126','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','4','1','1','0','0','0','0','0','0','0','0','1','2052','0','0','','12340'),
+('37183','0','0','0','0','0','19725','25455','0','0','Highlord Bolvar Fordragon','','','0','80','80','2','35','35','0','1','1.14286','1','3','391','585','0','146','35.8','2000','2000','2','33587968','8','0','0','0','0','0','313','468','117','10','1052676','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','50','20','1','0','0','0','0','0','0','0','0','1','0','12584976','0','','12340'),
+('37184','0','0','0','0','0','19000','0','0','0','Zafod Boombox','','','10885','83','83','2','35','35','1','1','1.14286','1','1','468','702','0','176','47.2','2000','2000','1','32768','8','0','0','0','0','0','374','562','141','7','8','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','4','1','1','0','0','0','0','0','0','0','164','1','88','0','0','','12340'),
+('37215','38129','38701','38702','0','0','31044','1126','0','0','Orgrim\'s Hammer','','','0','83','83','2','35','35','0','1','1.14286','1','3','468','702','0','176','2','2000','2000','1','0','8','0','0','0','0','0','374','562','141','10','76','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','49.4801','1','1','0','0','0','0','0','0','0','150','1','0','12584976','0','','12340'),
+('37230','38444','0','0','0','38121','30902','0','0','0','Spire Frostwyrm','','','0','82','82','2','2209','2209','0','2','1.5873','1','1','420','631','0','158','52.2','2000','2000','2','32832','8','0','0','0','0','0','336','505','126','6','72','37230','0','0','0','0','0','0','0','0','70362','71118','70361','70116','0','0','0','0','0','0','0','0','','0','4','80','10','1','0','0','0','0','0','0','0','0','1','0','2145337343','0','generic_creature','12340'),
+('37231','0','0','0','0','0','1126','24719','0','0','Rope Beam Stalker','','','0','1','1','2','1375','1375','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','33554688','8','0','0','0','0','0','1','2','0','10','1048576','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340'),
+('37503','0','0','0','0','0','19725','25455','0','0','Sindragosa\'s Ward','','','0','83','83','2','35','35','0','1','1.14286','1','0','435','653','0','163','1','2000','2000','2','33555200','8','0','0','0','0','0','348','522','130','10','2050','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','2000','2000','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('37519','0','0','0','0','0','18783','15435','0','0','Safe Area (IGB)','','','0','83','83','2','35','35','0','1','1.14286','1','0','468','702','0','176','1','2000','2000','1','33554432','8','0','0','0','0','0','374','562','141','10','1024','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','1','1','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('37528','0','0','0','0','0','27982','0','0','0','Spire Frostwyrm (Ambient)','','','0','82','82','2','2190','2190','0','2','1.14286','1','1','420','631','0','158','7.9','2000','2000','2','33588032','8','0','0','0','0','0','336','505','126','10','72','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','50','10','1','0','0','0','0','0','0','0','0','1','0','0','2','','12340'),
+('37531','38139','0','0','0','38121','26623','0','0','0','Frostwarden Handler','','','0','80','80','2','2212','2212','0','1.5','1.42857','1','1','420','630','0','158','10','2000','2000','1','0','8','0','0','0','0','0','336','504','126','7','64','37531','0','0','0','0','0','0','0','0','71337','0','0','0','0','0','0','0','0','0','7423','7423','','0','3','90','1','1','0','0','0','0','0','0','0','0','1','523','0','0','generic_creature','12340'),
+('37532','38151','0','0','0','38121','30640','0','0','0','Frostwing Whelp','','','0','80','80','2','2212','2212','0','1','1','1','1','391','585','0','146','10.8','2000','2000','2','0','8','0','0','0','0','0','313','468','117','6','0','37532','0','0','0','0','0','0','0','0','71350','71361','0','0','0','0','0','0','0','0','0','0','','0','3','10','1','1','0','0','0','0','0','0','0','0','1','0','0','0','generic_creature','12340'),
+('37533','38220','0','0','0','0','27982','0','0','0','Rimefang','','','0','82','82','2','21','21','0','1','1.14286','1','1','420','631','0','158','32.6','2000','2000','2','64','8','0','0','0','0','0','336','505','126','6','72','0','0','0','0','0','0','0','0','0','71387','71386','71376','0','0','0','0','0','0','0','0','0','','0','4','240','10','1','0','0','0','0','0','0','0','0','1','0','0','0','generic_creature','12340'),
+('37534','38219','0','0','0','38121','27982','0','0','0','Spinestalker','','','0','82','82','2','21','21','0','1','1.14286','1','1','420','631','0','158','18.9','2000','2000','2','64','8','0','0','0','0','0','336','505','126','6','72','0','0','0','0','0','0','0','0','0','36922','40505','71369','0','0','0','0','0','0','0','0','0','','0','4','240','10','1','0','0','0','0','0','0','0','0','1','0','0','0','generic_creature','12340'),
+('37544','38481','0','0','0','38121','14696','0','0','0','Spire Gargoyle','','','0','82','82','2','2209','2209','0','1.5','1.14286','1','1','479','719','0','180','16.6','2280','2280','2','32832','8','0','0','0','0','0','383','575','144','6','72','37544','0','0','0','0','0','0','0','0','70189','0','0','0','0','0','0','0','0','0','8736','8736','','0','3','25','10','1','0','0','0','0','0','0','0','0','1','0','0','0','generic_creature','12340'),
+('37545','38445','0','0','0','38121','30656','0','0','0','Spire Minion','','','0','82','82','2','2209','2209','0','1.5','1.14286','1','1','420','631','0','158','18.7','2000','2000','2','32832','8','0','0','0','0','0','336','505','126','6','72','37545','0','0','0','0','0','0','0','0','70363','70396','0','0','0','0','0','0','0','0','8209','8209','','0','3','25','10','1','0','0','0','0','0','0','0','0','1','0','0','0','generic_creature','12340'),
+('37546','38446','0','0','0','38121','16206','0','0','0','Frenzied Abomination','','','0','82','82','2','2209','2209','0','1.5','1.14286','1','1','226','339','0','85','111.4','1000','1000','1','32832','8','0','0','0','0','0','181','271','68','6','72','37546','0','0','0','0','0','0','0','0','70191','70371','0','0','0','0','0','0','0','0','8516','8516','','0','3','50','10','1','0','0','0','0','0','0','0','0','1','0','0','0','generic_creature','12340'),
+('37663','38480','0','0','0','38121','31033','31034','31035','31036','Darkfallen Noble','The San\'layn','','0','82','82','2','16','16','0','1.5','1.14286','1','1','330','495','0','124','24.1','2000','2000','8','32832','8','0','0','0','0','0','264','396','99','6','72','37663','0','0','0','0','0','0','0','0','70645','72960','0','0','0','0','0','0','0','0','7340','7340','','0','3','40','10','1','0','0','0','0','0','0','0','0','1','0','0','0','generic_creature','12340'),
+('37696','0','0','0','0','0','30716','0','0','0','Crusader Halford','Paladin Armor','','11101','80','80','2','2070','2070','4481','1','1.14286','1','0','315','473','0','118','1.3','1500','1500','1','512','8','0','0','0','0','0','252','378','94','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','157','0','2','','12340'),
+('37702','0','0','0','0','0','16480','26241','0','0','Runeforge Bunny','','','0','60','60','1','35','35','0','1','1.14286','1','0','128','192','0','48','1','2000','2000','1','33816832','8','0','0','0','0','0','102','154','38','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','1','1','1','0','0','0','0','0','0','0','0','1','0','0','128','','12340'),
+('37824','0','0','0','0','0','1126','11686','0','0','Abomination Wing Mad Scientist Stalker','','','0','80','80','2','14','14','0','1','1.14286','1','0','420','630','0','158','1','2000','2000','1','33554688','8','0','0','0','0','0','336','504','126','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','7','2','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340'),
+('37868','38167','38725','38735','0','38121','7919','0','0','0','Risen Archmage','','','0','81','81','2','16','16','0','1','1.14286','1','1','405','609','0','152','21.5','2000','2000','2','0','8','0','0','0','0','0','324','487','122','6','8','0','0','0','0','0','0','0','0','0','70602','70759','0','0','0','0','0','0','0','0','0','0','','0','3','8','20','1','0','0','0','0','0','0','0','0','1','0','0','0','generic_creature','12340'),
+('37882','0','0','0','0','0','1126','11686','0','0','The Frozen Throne','','','0','1','1','2','35','35','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','0','0','0','0','0','0','0','1','2','0','10','1048576','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','0','128','','12340'),
+('37903','0','0','0','0','0','3613','0','0','0','Shely Steelbowels','Blacksmith','','0','60','65','1','35','35','4224','1','1.42857','1','1','188','282','0','70','2','2000','2000','1','0','8','0','0','0','0','0','150','226','56','7','72','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','20','1','1','0','0','0','0','0','0','0','144','1','1835','0','0','','12340'),
+('37904','0','0','0','0','0','23061','0','0','0','Brazie Getz','General Goods','','0','69','69','2','35','35','128','1','1.42857','1','1','244','366','0','92','2','2000','2000','1','0','8','0','0','0','0','0','195','293','74','7','72','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','20','1','1','0','0','0','0','0','0','0','144','1','318','0','0','','12340'),
+('37928','0','0','0','0','0','26838','26839','26840','26841','Argent Champion','','','0','80','80','2','2131','2131','0','1','1.14286','1','1','420','630','0','158','10','2000','2000','1','33280','8','0','0','0','0','0','336','504','126','7','2048','0','0','0','0','0','0','0','0','0','53625','0','0','0','0','0','0','0','0','0','0','0','','0','3','75','1','1','0','0','0','0','0','0','0','0','1','2066','0','2','generic_creature','12340'),
+('37935','0','0','0','0','0','24242','0','0','0','Apothecary Candith Tomas','General Goods','','0','80','80','2','35','35','128','1','1.14286','1','1','420','630','0','158','2','2000','2000','1','0','8','0','0','0','0','0','336','504','126','7','72','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','20','1','1','0','0','0','0','0','0','0','144','1','0','0','0','','12340'),
+('37936','0','0','0','0','0','30838','0','0','0','Morgan Dayblaze','Blacksmith','','0','80','80','2','35','35','4224','1','1.14286','1','1','420','630','0','158','2','2000','2000','1','0','8','0','0','0','0','0','336','504','126','7','72','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','20','1','1','0','0','0','0','0','0','0','144','1','0','0','0','','12340'),
+('37947','0','0','0','0','0','169','16925','0','0','Deathwhisper Spawn Stalker','','','0','80','80','2','14','14','0','1','1.14286','1','0','420','630','0','158','1','2000','2000','1','33554432','8','0','0','0','0','0','336','504','126','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340'),
+('37948','0','0','0','0','0','169','16925','0','0','Deathwhisper Controller','','','0','80','80','2','14','14','0','1','1.14286','1','1','420','630','0','158','2','2000','2000','1','33554432','8','0','0','0','0','0','336','504','126','10','1048576','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340'),
+('37950','0','0','0','0','0','30318','0','0','0','Valithria Dreamwalker','','','0','1','1','2','35','35','0','1','1.14286','1','3','1','1','0','1','2','2000','2000','1','0','8','0','0','0','0','0','1','1','1','2','4108','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','10000','1','1','0','0','0','0','0','0','0','0','1','0','12584976','0','','12340'),
+('37996','0','0','0','0','0','30859','30860','30861','30862','Ebon Champion','','','0','80','80','2','2144','2144','0','1','1.14286','1','1','420','630','0','158','10','2000','2000','1','32768','8','0','0','0','0','0','336','504','126','7','2048','0','0','0','0','0','0','0','0','0','66019','67929','66047','67935','0','0','0','0','0','0','0','0','','0','3','75','1','1','0','0','0','0','0','0','0','0','1','2071','0','2','generic_creature','12340'),
+('38008','38641','38773','38774','0','0','16925','1126','0','0','Blood Orb Controller','','','0','80','80','2','16','16','0','1','0.992063','1','3','420','630','0','158','2','2000','2000','1','33554432','8','0','0','0','0','0','336','504','126','10','76','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','405','1','1','0','0','0','0','0','0','0','0','1','0','12584976','0','boss_blood_council_controller','12340'),
+('38125','38130','0','0','0','38121','27548','0','0','0','Ymirjar Deathbringer','','','0','80','80','2','2212','2212','0','1.6','1.14286','1','1','391','585','0','146','10.8','2000','2000','2','0','8','0','0','0','0','0','313','468','117','7','8','0','0','0','0','0','0','0','0','0','71298','71299','71296','69929','0','0','0','0','0','0','0','0','','0','3','45','30','1','0','0','0','0','0','0','0','0','1','93','0','0','generic_creature','12340'),
+('38153','0','0','0','0','0','16480','21342','0','0','The Lich King','','','0','60','60','1','35','35','0','1','1.14286','1','0','128','192','0','48','1','2000','2000','1','33554688','8','0','0','0','0','0','102','154','38','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','1','1','1','0','0','0','0','0','0','0','0','1','0','0','128','','12340'),
+('38154','0','0','0','0','0','22633','0','0','0','Warhawk','','','0','80','80','2','2212','2212','0','1','1.14286','1','0','420','630','0','158','1.4','2000','2000','1','0','8','26','0','0','0','0','336','504','126','1','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','25','1','1','0','0','0','0','0','0','0','210','1','0','0','0','','12340'),
+('38228','0','0','0','0','0','7511','2177','9829','0','Plagued Insect','','','0','1','1','2','188','188','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','0','8','0','0','0','0','0','1','2','0','8','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','0.3','1','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('38229','0','0','0','0','0','7511','2177','9829','0','Frozen Insect','','','0','1','1','2','188','188','0','0.4','0.714286','1','0','1','2','0','0','1','2000','2000','1','0','8','0','0','0','0','0','1','2','0','8','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','0.3','1','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('38231','0','0','0','0','0','30995','0','0','0','Blood Parasite','','','0','1','1','2','188','188','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','0','8','0','0','0','0','0','1','2','0','8','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','0.3','1','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('38232','0','0','0','0','0','30996','0','0','0','Blood Spider','','','0','1','1','2','190','190','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','32768','8','0','0','0','0','0','1','2','0','8','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','0.2','1','1','0','0','0','0','0','0','0','100','1','0','0','0','','12340'),
+('38248','0','0','0','0','38121','31004','0','0','0','Impaling Spear','','Interact','0','80','80','2','14','14','0','1','1.14286','1','1','420','630','0','158','10','2000','2000','1','64','8','0','0','0','0','0','336','504','126','6','72','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','14','1','1','0','0','0','0','0','0','0','164','1','2072','0','0','','12340'),
+('38317','0','0','0','0','0','1126','27823','0','0','Tear Gas Target Stalker','','','0','80','80','2','14','14','0','1','1.14286','1','0','420','630','0','158','1','2000','2000','1','33554432','8','0','0','0','0','0','336','504','126','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','2','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340'),
+('38463','0','0','0','0','0','1126','11686','0','0','Empowering Orb Visual Stalker','','','0','1','1','2','35','35','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','33554688','8','0','0','0','0','0','1','2','0','10','1048576','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','0','128','','12340'),
+('38471','38486','0','0','0','0','31127','0','0','0','Infiltrator Minchar','','','0','80','80','2','35','35','2','1','1.14286','1','1','349','523','0','131','12.1','2000','2000','4','0','8','0','0','0','0','0','279','418','105','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','75','1','1','0','0','0','0','0','0','0','0','1','2283','0','0','','12340'),
+('38490','0','0','0','0','38121','30843','0','0','0','Rotting Frost Giant','','','0','82','82','2','16','16','0','2','1.14286','1','1','452','678','0','170','69.9','2000','2000','1','33280','8','0','0','0','0','0','362','542','136','6','72','38490','0','0','0','0','0','0','0','0','72865','64652','0','0','0','0','0','0','0','0','0','0','','0','3','450','1','1','0','0','0','0','0','0','0','0','1','0','2145337343','0','generic_creature','12340'),
+('38494','0','0','0','0','38121','30843','0','0','0','Rotting Frost Giant','','','0','82','82','2','14','14','0','2','1.14286','1','1','452','678','0','170','81.7','2000','2000','1','0','8','0','0','0','0','0','362','542','136','6','72','38494','0','0','0','0','0','0','0','0','72865','64652','0','0','0','0','0','0','0','0','0','0','','0','3','1650','1','1','0','0','0','0','0','0','0','0','1','0','2145337343','0','generic_creature','12340'),
+('38501','38717','0','0','0','0','29760','0','0','0','Alchemist Adrianna','','','11032','80','80','2','2070','2070','3','1','1.14286','1','0','307','459','0','115','1.4','2000','2000','8','0','8','0','0','0','0','0','246','367','92','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','5','5','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('38551','38552','0','0','0','0','31097','0','0','0','Alrin the Agile','','','0','80','80','2','35','35','3','1','1.14286','1','1','349','523','0','131','12.1','2000','2000','4','32768','8','0','0','0','0','0','279','418','105','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','75','1','1','0','0','0','0','0','0','0','0','1','0','0','0','','12340'),
+('38557','0','0','0','0','0','169','16925','0','0','Minchar Beam Stalker','','','0','1','1','2','14','14','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','33554432','8','0','0','0','0','0','1','2','0','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','0','0','0','0','0','0','0','0','1','0','0','128','','12340'),
+('38589','38590','0','0','0','0','31125','0','0','0','Valithria Dreamwalker','','','0','83','83','2','35','35','2','1.8','1.14286','1','3','468','702','0','176','47.2','2000','2000','1','0','8','0','0','0','0','0','374','562','141','2','4172','0','0','0','0','0','0','0','0','0','70904','0','0','0','0','0','0','0','0','0','0','0','','0','3','717.103','1','1','0','0','0','0','0','0','0','0','0','0','801849343','1','generic_creature','12340'),
+('38752','0','0','0','0','0','15294','0','0','0','Green Dragon Combat Trigger','','','0','1','1','2','14','14','0','1','1.14286','1','0','1','2','0','0','1','2000','2000','1','33554432','8','0','0','0','0','0','1','2','0','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1.35','1','1','0','0','0','0','0','0','0','0','1','0','0','2','','12340'),
+('38995','0','0','0','0','0','31286','0','0','0','Highlord Tirion Fordring','','','10993','83','83','2','2073','2073','1','1','1.14286','1','3','468','702','0','176','47.2','2000','2000','1','32832','8','0','0','0','0','0','374','562','141','7','2084','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1000','1000','1','0','0','0','0','0','0','0','0','1','547','12584976','2','','12340'),
+('39010','39011','39012','39013','0','0','169','11686','0','0','Martyr Stalker (Reputation)','','','0','83','83','2','16','16','0','1','1.14286','1','3','468','702','0','176','2','2000','2000','1','33554432','8','0','0','0','0','0','374','562','141','10','1088','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','0.0001','1','1','0','0','0','0','0','0','0','0','1','0','12584976','130','','12340');
+
+-- Weapons
+--Saurfang axe
+DELETE FROM `creature_equip_template` WHERE `entry` = 37813;
+INSERT INTO `creature_equip_template` (`entry`,`equipentry1`,`equipentry2`,`equipentry3`) VALUES
+(37813,51905,0,0);
+UPDATE `creature_template` SET `equipment_id` = 37813 WHERE `entry` = 37813;
+
+-- Blood Queen Lana'thel staff
+DELETE FROM `creature_equip_template` WHERE `entry` = 37955;
+INSERT INTO `creature_equip_template` (`entry`,`equipentry1`,`equipentry2`,`equipentry3`) VALUES
+(37955,50725,0,0);
+UPDATE `creature_template` SET `equipment_id` = 37955 WHERE `entry` = 37955;
+
+
+-- Trigger NPC fixes
+
+replace into `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) values
+('38879','0','0','0','0','0','1126','11686','0','0','Putricide\'s Trap','','','0','80','80','2','2102','2102','0','1','1.14286','1','0','420','630','0','158','1','2000','2000','1','33554432','8','0','0','0','0','0','336','504','126','10','1048576','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','4','1','1','1','0','0','0','0','0','0','0','0','1','0','0','130','','12340');
+
+
+-- Spell Script Names
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_winter" WHERE `spell_id` = 68981;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lord_marrowgar_bone_storm" WHERE `spell_id` = 69075;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_ice_burst_distance_check" WHERE `spell_id` = 69110;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_rotface_unstable_explosion" WHERE `spell_id` = 69558;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_sindragosa_unchained_magic" WHERE `spell_id` = 69766;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_sindragosa_mystic_buffet" WHERE `spell_id` = 70127;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_sindragosa_ice_tomb" WHERE `spell_id` = 70157;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_necrotic_plague" WHERE `spell_id` = 70338;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_vile_spirit_distance_check" WHERE `spell_id` = 70534;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_infection" WHERE `spell_id` = 70541;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_marrowgar_bone_storm" WHERE `spell_id` IN (70834,70835,70836);
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_quake" WHERE `spell_id` = 72262;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_sindragosa_mystic_buffet" WHERE `spell_id` = 72528;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_sindragosa_mystic_buffet" WHERE `spell_id` = 72529;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_sindragosa_mystic_buffet" WHERE `spell_id` = 72530;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_play_movie" WHERE `spell_id` = 73159;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_infection" WHERE `spell_id` = 73779;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_infection" WHERE `spell_id` = 73780;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_infection" WHERE `spell_id` = 73781;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_necrotic_plague" WHERE `spell_id` = 73785;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_necrotic_plague" WHERE `spell_id` = 73786;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_necrotic_plague" WHERE `spell_id` = 73787;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_winter" WHERE `spell_id` = 74270;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_winter" WHERE `spell_id` = 74271;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_winter" WHERE `spell_id` = 74272;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_lich_king_valkyr_summon" WHERE `spell_id` = 74361;
+UPDATE `spell_script_names` SET `ScriptName` = "spell_valkyr_carry_can_cast" WHERE `spell_id` = 74506;
+
+ 
+DELETE FROM `spell_script_names` WHERE `ScriptName` = "spell_valithria_adds_summon";
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (71301,71977,70873,71941,70912,70913,70914,70915,70916,71721,69057,70826,72088,72089,69140,72705,69146,70823,70824,70825,69075,70834,70835,70836,72378,73058,72255,72444,72445,72446,70402,72511,72512,72513);
+INSERT INTO `spell_script_names` (`spell_id`, `ScriptName`) VALUES
+(70912,'spell_valithria_adds_summon'),
+(70913,'spell_valithria_adds_summon'),
+(70914,'spell_valithria_adds_summon'),
+(70915,'spell_valithria_adds_summon'),
+(70916,'spell_valithria_adds_summon'),
+(71721,'spell_cancel_all_aura'),
+(71301, 'spell_valithria_summon_portal'),
+(71977, 'spell_valithria_summon_portal'),
+(70873, 'spell_valithria_vigor'),
+(71941, 'spell_valithria_vigor'),
+( 69057, 'spell_marrowgar_bone_spike_graveyard'),
+( 70826, 'spell_marrowgar_bone_spike_graveyard'),
+( 72088, 'spell_marrowgar_bone_spike_graveyard'),
+( 72089, 'spell_marrowgar_bone_spike_graveyard'),
+( 69140, 'spell_marrowgar_coldflame'),
+( 72705, 'spell_marrowgar_coldflame'),
+( 69146, 'spell_marrowgar_coldflame_damage'),
+( 70823, 'spell_marrowgar_coldflame_damage'),
+( 70824, 'spell_marrowgar_coldflame_damage'),
+( 70825, 'spell_marrowgar_coldflame_damage'),
+( 69075, 'spell_marrowgar_bone_storm'),
+( 70834, 'spell_marrowgar_bone_storm'),
+( 70835, 'spell_marrowgar_bone_storm'),
+( 70836, 'spell_marrowgar_bone_storm'),
+( 72378, 'spell_deathbringer_blood_nova_targeting'),
+( 73058, 'spell_deathbringer_blood_nova_targeting'),
+( 72255, 'spell_deathbringer_mark_of_the_fallen_champion'),
+( 72444, 'spell_deathbringer_mark_of_the_fallen_champion'),
+( 72445, 'spell_deathbringer_mark_of_the_fallen_champion'),
+( 72446, 'spell_deathbringer_mark_of_the_fallen_champion'),
+( 70402, 'spell_putricide_mutated_transformation_dmg'),
+( 72511, 'spell_putricide_mutated_transformation_dmg'),
+( 72512, 'spell_putricide_mutated_transformation_dmg'),
+( 72513, 'spell_putricide_mutated_transformation_dmg');
+
+-- Gameobject Script Names
+UPDATE `gameobject_template`SET `ScriptName` = "icecrown_citadel_teleport" WHERE `entry` = 202242;
+UPDATE `gameobject_template`SET `ScriptName` = "icecrown_citadel_teleport" WHERE `entry` = 202243;
+UPDATE `gameobject_template`SET `ScriptName` = "icecrown_citadel_teleport" WHERE `entry` = 202244;
+UPDATE `gameobject_template`SET `ScriptName` = "icecrown_citadel_teleport" WHERE `entry` = 202245;
+UPDATE `gameobject_template`SET `ScriptName` = "icecrown_citadel_teleport" WHERE `entry` = 202223;
+UPDATE `gameobject_template`SET `ScriptName` = "icecrown_citadel_teleport" WHERE `entry` = 202235;
+UPDATE `gameobject_template`SET `ScriptName` = "icecrown_citadel_teleport" WHERE `entry` = 202246;
+
+-- Missing spell script names in tdb
+DELETE FROM `spell_script_names` WHERE `spell_id` IN (68981,69110,69558,69766,70127,70157,70338,70534,70541,72262,72528,72529,72530,73159,73779,73780,73781,73785,73786,73787,74270,74271,74272,74361,74506,71049,69712);
+insert into `spell_script_names` (`spell_id`, `ScriptName`) values
+('68981','spell_lich_king_winter'),
+('69110','spell_ice_burst_distance_check'),
+('69558','spell_rotface_unstable_explosion'),
+('69766','spell_sindragosa_unchained_magic'),
+('70127','spell_sindragosa_mystic_buffet'),
+('70157','spell_sindragosa_ice_tomb'),
+('70338','spell_lich_king_necrotic_plague'),
+('70534','spell_vile_spirit_distance_check'),
+('70541','spell_lich_king_infection'),
+('72262','spell_lich_king_quake'),
+('72528','spell_sindragosa_mystic_buffet'),
+('72529','spell_sindragosa_mystic_buffet'),
+('72530','spell_sindragosa_mystic_buffet'),
+('73159','spell_lich_king_play_movie'),
+('73779','spell_lich_king_infection'),
+('73780','spell_lich_king_infection'),
+('73781','spell_lich_king_infection'),
+('73785','spell_lich_king_necrotic_plague'),
+('73786','spell_lich_king_necrotic_plague'),
+('73787','spell_lich_king_necrotic_plague'),
+('74270','spell_lich_king_winter'),
+('74271','spell_lich_king_winter'),
+('74272','spell_lich_king_winter'),
+('74361','spell_lich_king_valkyr_summon'),
+('74506','spell_valkyr_carry_can_cast'),
+('71049','spell_sindragosa_blistering_cold'),
+('69712','spell_sindragosa_ice_tomb_effect');
+
+-- Alliance/Horde Gunships creatures
+DELETE FROM `creature_template` WHERE `entry` IN (30342,37215,38129,38701,38702,30343,37540,38700,38699,38128);
+
+insert into `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) values
+(30342, 0, 0, 0, 0, 0, 22712, 17200, 0, 0, 'Orgrim''s Hammer', '', '', 0, 80, 80, 2, 35, 35, 0, 1, 1.14286, 1, 1, 349, 523, 0, 131, 2.7, 2000, 2000, 4, 33555200, 8, 0, 0, 0, 0, 0, 279, 418, 105, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 245, 0, 0, '', 0, 3, 10, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, '', 12340),
+(30343, 0, 0, 0, 0, 0, 22712, 17200, 0, 0, 'The Skybreaker', '', '', 0, 80, 80, 2, 35, 35, 0, 1, 1.14286, 1, 1, 349, 523, 0, 131, 2.7, 2000, 2000, 4, 33587712, 8, 0, 0, 0, 0, 0, 279, 418, 105, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 0, 0, '', 0, 7, 10, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, '', 12340),
+(37215, 38129, 38701, 38702, 0, 0, 31044, 1126, 0, 0, 'Orgrim''s Hammer', '', '', 0, 83, 83, 2, 35, 35, 0, 1, 1.14286, 1, 3, 468, 702, 0, 176, 2, 2000, 2000, 1, 0, 8, 0, 0, 0, 0, 0, 374, 562, 141, 10, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 4, 49.4801, 1, 1, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 12584976, 0, '', 12340),
+(37540, 38128, 38699, 38700, 0, 0, 31043, 169, 0, 0, 'The Skybreaker', '', '', 0, 83, 83, 2, 35, 35, 0, 1, 1.14286, 1, 3, 468, 702, 0, 176, 47.2, 2000, 2000, 1, 0, 8, 0, 0, 0, 0, 0, 374, 562, 141, 10, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 49.4801, 1, 1, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 12584976, 0, '', 12340),
+(38128, 0, 0, 0, 0, 0, 31043, 169, 0, 0, 'The Skybreaker (1)', '', '', 0, 83, 83, 2, 35, 35, 0, 1, 1.14286, 1, 3, 468, 702, 0, 176, 47.2, 2000, 2000, 1, 0, 8, 0, 0, 0, 0, 0, 374, 562, 141, 10, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 98.9602, 1, 1, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 12584976, 0, '', 12340),
+(38129, 0, 0, 0, 0, 0, 31044, 1126, 0, 0, 'Orgrim''s Hammer (1)', '', '', 0, 83, 83, 2, 35, 35, 0, 1, 1.14286, 1, 3, 468, 702, 0, 176, 2, 2000, 2000, 1, 0, 8, 0, 0, 0, 0, 0, 374, 562, 141, 10, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 98.9602, 1, 1, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 12584976, 0, '', 12340),
+(38699, 0, 0, 0, 0, 0, 31043, 169, 0, 0, 'The Skybreaker (2)', '', '', 0, 83, 83, 2, 35, 35, 0, 1, 1.14286, 1, 3, 468, 702, 0, 176, 47.2, 2000, 2000, 1, 0, 8, 0, 0, 0, 0, 0, 374, 562, 141, 10, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 56.9021, 1, 1, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 12584976, 0, '', 12340),
+(38700, 0, 0, 0, 0, 0, 31043, 169, 0, 0, 'The Skybreaker (3)', '', '', 0, 83, 83, 2, 35, 35, 0, 1, 1.14286, 1, 3, 468, 702, 0, 176, 47.2, 2000, 2000, 1, 0, 8, 0, 0, 0, 0, 0, 374, 562, 141, 10, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 113.804, 1, 1, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 12584976, 0, '', 12340),
+(38701, 0, 0, 0, 0, 0, 31044, 1126, 0, 0, 'Orgrim''s Hammer (2)', '', '', 0, 83, 83, 2, 35, 35, 0, 1, 1.14286, 1, 3, 468, 702, 0, 176, 2, 2000, 2000, 1, 0, 8, 0, 0, 0, 0, 0, 374, 562, 141, 10, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 56.9021, 1, 1, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 12584976, 0, '', 12340),
+(38702, 0, 0, 0, 0, 0, 31044, 1126, 0, 0, 'Orgrim''s Hammer (3)', '', '', 0, 83, 83, 2, 35, 35, 0, 1, 1.14286, 1, 3, 468, 702, 0, 176, 2, 2000, 2000, 1, 0, 8, 0, 0, 0, 0, 0, 374, 562, 141, 10, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 113.804, 1, 1, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 12584976, 0, '', 12340);
+
+-- Alliance/Horde Gunships gameobjects
+DELETE FROM `gameobject_template` WHERE `entry` IN (201812,201599,201581,201598,201580,201811,195276,195121,201834);
+
+insert into `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `WDBVerified`) values
+('195121','15','9002','Alliance Gunship','','','','0','40','1','0','0','0','0','0','0','1248','20','10','0','0','0','641','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','','12340'),
+('195276','15','9001','Horde Gunship','','','','0','40','1','0','0','0','0','0','0','1252','20','10','0','0','0','642','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','','12340'),
+('201580','15','9150','The Skybreaker','','','','0','40','1','0','0','0','0','0','0','1814','20','10','0','0','61','672','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','','12340'),
+('201581','15','9151','Orgrim\'s Hammer','','','','0','40','1','0','0','0','0','0','0','1816','20','10','0','0','61','673','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','','12340'),
+('201598','15','9002','The Skybreaker','','','','0','40','1','0','0','0','0','0','0','1815','20','10','0','0','0','712','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','','12340'),
+('201599','15','8253','Orgrim\'s Hammer','','','','0','40','1','0','0','0','0','0','0','1817','20','10','0','0','0','713','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','','12340'),
+('201811','15','9150','The Skybreaker','','','','0','40','1','0','0','0','0','0','0','1819','20','10','0','0','61','672','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','','12340'),
+('201812','15','9151','Orgrim\'s Hammer','','','','0','40','1','0','0','0','0','0','0','1818','20','10','0','0','61','673','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','','12340'),
+('201834','15','7546','Zeppelin, Horde (The Mighty Wind) (Icecrown Raid)','','','','0','40','1','0','0','0','0','0','0','1834','40','5','0','0','61','718','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','','12340');
+
+-- remove spawned gunships. Causes conflicts with "transports"
+DELETE FROM `gameobject` WHERE `guid` IN (150163,150171);
+
+-- transports
+DELETE FROM `transports` WHERE `guid` BETWEEN 21 AND 29;
+insert into `transports` (`guid`, `entry`, `name`, `period`, `ScriptName`) values
+('21','201812','Icecrown_Citadel_Horde_10','74000',''),
+('22','201599','Orgrim\'s Hammer','15000',''),
+('23','201581','ICC Raid, Orgrim\'s Hammer','51584',''),
+('24','201598','The Skybreaker','23970',''),
+('25','201580','ICC Raid, The Skybreaker','77527',''),
+('26','201811','Icecrown_Citadel_Alliance_10','74000',''),
+('27','195276','IOC - Horde Gunship','115661',''),
+('28','195121','IOC - Alliance Gunship','118797',''),
+('29','201834','Zeppelin, Horde (The Mighty Wind) (Icecrown Raid)','154573','');
+
+-- Equip_template data
+replace into `creature_equip_template` (`entry`, `equipentry1`, `equipentry2`, `equipentry3`) values('1945','34816','34816','0');
+replace into `creature_equip_template` (`entry`, `equipentry1`, `equipentry2`, `equipentry3`) values('5252','45528','0','0');
+replace into `creature_equip_template` (`entry`, `equipentry1`, `equipentry2`, `equipentry3`) values('37813','51905','0','0');
+
+-- Script Texts
+
+DELETE FROM script_texts WHERE entry<=-1665919 AND entry>=-1665959;
+
+-- Script text
+INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+(0,-1665919,'Thank the spirits for you, brothers and sisters. The Skybreaker has already left. Quickly now, to Orgrim\'s Hammer! If you leave soon, you may be able to catch them.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,0,0,0,''),
+(0,-1665920,'This should be helpin\'ya!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,0,0,0,''),
+(0,-1665921,'Aka\'Magosh, brave warriors. The alliance is in great number here.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665922,'Captain Saurfang will be pleased to see you aboard Orgrim\'s Hammer. Make haste, we will secure the area until you are ready for take-off.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665923,'A screeching cry pierces the air above!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665924,'A Spire Frostwyrm lands just before Orgrim\'s Hammer.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665925,'Rise up, sons and daughters of the Horde! Today we battle a hated enemy of the Horde! LOK\'TAR OGAR! Kor\'kron, take us out!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665926,'What is that?! Something approaching in the distance!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665927,'ALLIANCE GUNSHIP! ALL HANDS ON DECK!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665928,'Move yer jalopy or we\'ll blow it out of the sky, orc! The Horde\'s got no business here!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665929,'You will know our business soon! KOR\'KRON, ANNIHILATE THEM!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665930,'Marines, Sergeants, attack!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665931,'You DARE board my ship? Your death will come swiftly.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665932,'Riflemen, shoot faster!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665933,'Mortar team, reload!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665934,'We\'re taking hull damage, get a sorcerer out here to shut down those cannons!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665935,'The Alliance falter. Onward to the Lich King!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665936,'Damage control! Put those fires out! You haven\'t seen the last of the Horde!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665937,'Thank goodness you arrived when you did, heroes. Orgrim\'s Hammer has already left. Quickly now, to The Skybreaker! If you leave soon, you may be able to catch them.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665938,'This ought to help!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665939,'Skybreaker Sorcerer summons a Skybreaker Battle Standard.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665940,'You have my thanks. We were outnumbered until you arrived.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665941,'Captain Muradin is waiting aboard The Skybreaker. We\'ll secure the area until you are ready for take off.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665942,'Skybreaker infantry, hold position!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665943,'A screeching cry pierces the air above!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665944,'A Spire Frostwyrm lands just before The Skybreaker. ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665945,'Fire up the engines! We got a meetin with destiny, lads!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665946,'Hold on to yer hats!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665947,'What in the world is that? Grab me spyglass, crewman!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665948,'By me own beard! HORDE SAILIN IN FAST N HOT!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665949,'EVASIVE ACTION! MAN THE GUNS!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665950,'Cowardly dogs! Ye blindsighted us!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665951,'This is not your battle, dwarf. Back down or we will be forced to destroy your ship.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665952,'Not me battle? I dunnae who ye? think ye are, mister, but I got a score to settle with Arthas and yer not gettin in me way! FIRE ALL GUNS! FIRE! FIRE!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665953,'Reavers, Sergeants, attack!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665954,'What\'s this then?! Ye won\'t be takin this son o Ironforge\'s vessel without a fight!.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665955,'Axethrowers, hurl faster!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665956,'Rocketeers, reload!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665957,'We\'re taking hull damage, get a battle-mage out here to shut down those cannons!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665958,'Don\'t say I didn\'t warn ya, scoundrels! Onward, brothers and sisters!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,''),
+(0,-1665959,'Captain Bartlett, get us out of here! We\'re taken too much damage to stay afloat!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,1,0,0,'');
diff --git a/sql/All/world_icc_loot.sql b/sql/All/world_icc_loot.sql
new file mode 100644
index 0000000..adeffaa
--- /dev/null
+++ b/sql/All/world_icc_loot.sql
@@ -0,0 +1,1703 @@
+-- creature_template lootid for ICC
+UPDATE `creature_template` SET `lootid` = 36597 WHERE `entry` = 36597;
+UPDATE `creature_template` SET `lootid` = 36612 WHERE `entry` = 36612;
+UPDATE `creature_template` SET `lootid` = 36626 WHERE `entry` = 36626;
+UPDATE `creature_template` SET `lootid` = 36627 WHERE `entry` = 36627;
+UPDATE `creature_template` SET `lootid` = 36678 WHERE `entry` = 36678;
+UPDATE `creature_template` SET `lootid` = 36724 WHERE `entry` = 36724;
+UPDATE `creature_template` SET `lootid` = 36725 WHERE `entry` = 36725;
+UPDATE `creature_template` SET `lootid` = 36805 WHERE `entry` = 36805;
+UPDATE `creature_template` SET `lootid` = 36807 WHERE `entry` = 36807;
+UPDATE `creature_template` SET `lootid` = 36808 WHERE `entry` = 36808;
+UPDATE `creature_template` SET `lootid` = 36811 WHERE `entry` = 36811;
+UPDATE `creature_template` SET `lootid` = 36829 WHERE `entry` = 36829;
+UPDATE `creature_template` SET `lootid` = 36855 WHERE `entry` = 36855;
+UPDATE `creature_template` SET `lootid` = 36880 WHERE `entry` = 36880;
+UPDATE `creature_template` SET `lootid` = 36998 WHERE `entry` = 36998;
+UPDATE `creature_template` SET `lootid` = 37003 WHERE `entry` = 37003;
+UPDATE `creature_template` SET `lootid` = 37004 WHERE `entry` = 37004;
+UPDATE `creature_template` SET `lootid` = 37007 WHERE `entry` = 37007;
+UPDATE `creature_template` SET `lootid` = 37011 WHERE `entry` = 37011;
+UPDATE `creature_template` SET `lootid` = 37012 WHERE `entry` = 37012;
+UPDATE `creature_template` SET `lootid` = 37016 WHERE `entry` = 37016;
+UPDATE `creature_template` SET `lootid` = 37017 WHERE `entry` = 37017;
+UPDATE `creature_template` SET `lootid` = 37021 WHERE `entry` = 37021;
+UPDATE `creature_template` SET `lootid` = 37022 WHERE `entry` = 37022;
+UPDATE `creature_template` SET `lootid` = 37023 WHERE `entry` = 37023;
+UPDATE `creature_template` SET `lootid` = 37025 WHERE `entry` = 37025;
+UPDATE `creature_template` SET `lootid` = 37026 WHERE `entry` = 37026;
+UPDATE `creature_template` SET `lootid` = 37027 WHERE `entry` = 37027;
+UPDATE `creature_template` SET `lootid` = 37029 WHERE `entry` = 37029;
+UPDATE `creature_template` SET `lootid` = 37030 WHERE `entry` = 37030;
+UPDATE `creature_template` SET `lootid` = 37031 WHERE `entry` = 37031;
+UPDATE `creature_template` SET `lootid` = 37032 WHERE `entry` = 37032;
+UPDATE `creature_template` SET `lootid` = 37033 WHERE `entry` = 37033;
+UPDATE `creature_template` SET `lootid` = 37034 WHERE `entry` = 37034;
+UPDATE `creature_template` SET `lootid` = 37035 WHERE `entry` = 37035;
+UPDATE `creature_template` SET `lootid` = 37038 WHERE `entry` = 37038;
+UPDATE `creature_template` SET `lootid` = 37098 WHERE `entry` = 37098;
+UPDATE `creature_template` SET `lootid` = 37126 WHERE `entry` = 37126;
+UPDATE `creature_template` SET `lootid` = 37144 WHERE `entry` = 37144;
+UPDATE `creature_template` SET `lootid` = 37146 WHERE `entry` = 37146;
+UPDATE `creature_template` SET `lootid` = 37148 WHERE `entry` = 37148;
+UPDATE `creature_template` SET `lootid` = 37149 WHERE `entry` = 37149;
+UPDATE `creature_template` SET `lootid` = 37217 WHERE `entry` = 37217;
+UPDATE `creature_template` SET `lootid` = 37230 WHERE `entry` = 37230;
+UPDATE `creature_template` SET `lootid` = 37531 WHERE `entry` = 37531;
+UPDATE `creature_template` SET `lootid` = 37532 WHERE `entry` = 37532;
+UPDATE `creature_template` SET `lootid` = 37544 WHERE `entry` = 37544;
+UPDATE `creature_template` SET `lootid` = 37545 WHERE `entry` = 37545;
+UPDATE `creature_template` SET `lootid` = 37546 WHERE `entry` = 37546;
+UPDATE `creature_template` SET `lootid` = 37571 WHERE `entry` = 37571;
+UPDATE `creature_template` SET `lootid` = 37595 WHERE `entry` = 37595;
+UPDATE `creature_template` SET `lootid` = 37662 WHERE `entry` = 37662;
+UPDATE `creature_template` SET `lootid` = 37663 WHERE `entry` = 37663;
+UPDATE `creature_template` SET `lootid` = 37664 WHERE `entry` = 37664;
+UPDATE `creature_template` SET `lootid` = 37665 WHERE `entry` = 37665;
+UPDATE `creature_template` SET `lootid` = 37666 WHERE `entry` = 37666;
+UPDATE `creature_template` SET `lootid` = 37955 WHERE `entry` = 37955;
+UPDATE `creature_template` SET `lootid` = 37970 WHERE `entry` = 37970;
+UPDATE `creature_template` SET `lootid` = 38490 WHERE `entry` = 38490;
+UPDATE `creature_template` SET `lootid` = 38494 WHERE `entry` = 38494;
+
+-- Reference Loot
+DELETE FROM `reference_loot_template` WHERE `entry` = 50452;
+
+insert into `reference_loot_template` (`entry`, `item`, `ChanceOrQuestChance`, `lootmode`, `groupid`, `mincountOrRef`, `maxcount`) values
+('50452','50444','0','1','1','1','1'),
+('50452','50447','0','1','1','1','1'),
+('50452','50449','0','1','1','1','1'),
+('50452','50450','0','1','1','1','1'),
+('50452','50451','0','1','1','1','1'),
+('50452','50452','0','1','1','1','1'),
+('50452','50453','0','1','1','1','1');
+
+
+-- Creature Loot
+insert ignore into `creature_loot_template` (`entry`, `item`, `ChanceOrQuestChance`, `lootmode`, `groupid`, `mincountOrRef`, `maxcount`) values
+(38151,33631,62.579,1,0,1,3),
+(38151,33632,15.6764,1,0,1,3),
+(38151,50452,5,1,0,-50452,1),
+(36597,49426,100,1,0,2,2),
+(36597,51795,0,1,2,1,1),
+(36597,51796,0,1,1,1,1),
+(36597,51797,0,1,1,1,1),
+(36597,51798,0,1,1,1,1),
+(36597,51799,0,1,2,1,1),
+(36597,51800,0,1,2,1,1),
+(36597,51801,0,1,1,1,1),
+(36597,51802,0,1,1,1,1),
+(36597,51803,0,1,2,1,1),
+(36612,49426,100,1,0,2,2),
+(36612,50339,0,1,1,1,1),
+(36612,50759,0,1,1,1,1),
+(36612,50760,0,1,2,1,1),
+(36612,50761,0,1,1,1,1),
+(36612,50762,0,1,2,1,1),
+(36612,50763,0,1,2,1,1),
+(36612,50764,0,1,1,1,1),
+(36612,50771,0,1,1,1,1),
+(36612,50772,0,1,1,1,1),
+(36612,50773,0,1,2,1,1),
+(36612,50774,0,1,2,1,1),
+(36612,50775,0,1,2,1,1),
+(36626,49426,100,1,0,2,2),
+(36626,50810,0,1,1,1,1),
+(36626,50811,0,1,1,1,1),
+(36626,50812,0,1,2,1,1),
+(36626,50852,0,1,1,1,1),
+(36626,50858,0,1,1,1,1),
+(36626,50859,0,1,2,1,1),
+(36626,50966,0,1,1,1,1),
+(36626,50967,0,1,2,1,1),
+(36626,50985,0,1,2,1,1),
+(36626,50986,0,1,2,1,1),
+(36626,50988,0,1,2,1,1),
+(36626,50990,0,1,1,1,1),
+(36627,49426,100,1,0,2,2),
+(36627,50998,0,1,1,1,1),
+(36627,50999,0,1,1,1,1),
+(36627,51000,0,1,2,1,1),
+(36627,51001,0,1,1,1,1),
+(36627,51002,0,1,2,1,1),
+(36627,51003,0,1,1,1,1),
+(36627,51004,0,1,1,1,1),
+(36627,51005,0,1,2,1,1),
+(36627,51006,0,1,2,1,1),
+(36627,51007,0,1,1,1,1),
+(36627,51008,0,1,2,1,1),
+(36627,51009,0,1,2,1,1),
+(36678,49426,100,1,0,2,2),
+(36678,50341,0,1,2,1,1),
+(36678,51010,0,1,2,1,1),
+(36678,51011,0,1,1,1,1),
+(36678,51012,0,1,1,1,1),
+(36678,51013,0,1,2,1,1),
+(36678,51014,0,1,2,1,1),
+(36678,51015,0,1,1,1,1),
+(36678,51016,0,1,1,1,1),
+(36678,51017,0,1,1,1,1),
+(36678,51018,0,1,2,1,1),
+(36678,51019,0,1,2,1,1),
+(36678,51020,0,1,1,1,1),
+(36724,33365,0.2203,1,0,1,1),
+(36724,33366,0.3304,1,0,1,1),
+(36724,33367,0.5507,1,0,1,1),
+(36724,33368,0.2203,1,0,1,1),
+(36724,33369,0.2203,1,0,1,1),
+(36724,33370,0.4405,1,0,1,1),
+(36724,33371,0.2203,1,0,1,1),
+(36724,33379,0.4405,1,0,1,1),
+(36724,33380,0.2203,1,0,1,1),
+(36724,33381,0.8811,1,0,1,1),
+(36724,33382,0.5507,1,0,1,1),
+(36724,33383,0.1101,1,0,1,1),
+(36724,33384,0.3304,1,0,1,1),
+(36724,33385,0.3304,1,0,1,1),
+(36724,33397,0.2203,1,0,1,1),
+(36724,33398,0.3304,1,0,1,1),
+(36724,33399,0.4405,1,0,1,1),
+(36724,33400,0.1101,1,0,1,1),
+(36724,33401,0.3304,1,0,1,1),
+(36724,33402,0.1101,1,0,1,1),
+(36724,33403,0.2203,1,0,1,1),
+(36724,33412,0.2203,1,0,1,1),
+(36724,33413,0.1101,1,0,1,1),
+(36724,33414,0.2203,1,0,1,1),
+(36724,33415,0.5507,1,0,1,1),
+(36724,33416,0.4405,1,0,1,1),
+(36724,33419,0.2203,1,0,1,1),
+(36724,33422,0.6608,1,0,1,1),
+(36724,33423,0.4405,1,0,1,1),
+(36724,33424,0.4405,1,0,1,1),
+(36724,33425,0.3304,1,0,1,1),
+(36724,33426,0.5507,1,0,1,1),
+(36724,33427,0.5507,1,0,1,1),
+(36724,33428,0.6608,1,0,1,1),
+(36724,33429,0.6608,1,0,1,1),
+(36724,33430,0.4405,1,0,1,1),
+(36724,33431,0.3304,1,0,1,1),
+(36724,33433,0.1101,1,0,1,1),
+(36724,33434,0.5507,1,0,1,1),
+(36724,33435,0.2203,1,0,1,1),
+(36724,33436,0.2203,1,0,1,1),
+(36724,33445,3.8022,1,0,1,1),
+(36724,33447,2.3973,1,0,1,1),
+(36724,33448,0.9912,1,0,1,1),
+(36724,33470,36.1264,1,0,1,7),
+(36724,35947,7.833,1,0,1,1),
+(36724,36035,0.1101,1,0,1,1),
+(36724,36036,0.2203,1,0,1,1),
+(36724,36037,0.3304,1,0,1,1),
+(36724,36038,0.2203,1,0,1,1),
+(36724,36039,0.3304,1,0,1,1),
+(36724,36040,0.2203,1,0,1,1),
+(36724,36041,0.1101,1,0,1,1),
+(36724,36042,0.3304,1,0,1,1),
+(36724,36043,0.2203,1,0,1,1),
+(36724,36044,0.3304,1,0,1,1),
+(36724,36045,0.1101,1,0,1,1),
+(36724,36046,0.2203,1,0,1,1),
+(36724,36047,0.2203,1,0,1,1),
+(36724,36048,0.2203,1,0,1,1),
+(36724,36049,0.5507,1,0,1,1),
+(36724,36050,0.1101,1,0,1,1),
+(36724,36051,0.2203,1,0,1,1),
+(36724,36052,0.4405,1,0,1,1),
+(36724,36053,0.3304,1,0,1,1),
+(36724,36054,0.4405,1,0,1,1),
+(36724,36055,0.1101,1,0,1,1),
+(36724,36056,0.2203,1,0,1,1),
+(36724,36057,0.2203,1,0,1,1),
+(36724,36058,0.4405,1,0,1,1),
+(36724,36147,0.4405,1,0,1,1),
+(36724,36148,0.1101,1,0,1,1),
+(36724,36149,0.1101,1,0,1,1),
+(36724,36150,0.2203,1,0,1,1),
+(36724,36151,0.1101,1,0,1,1),
+(36724,36152,0.2203,1,0,1,1),
+(36724,36153,0.1101,1,0,1,1),
+(36724,36154,0.3304,1,0,1,1),
+(36724,36155,0.1101,1,0,1,1),
+(36724,36156,0.1101,1,0,1,1),
+(36724,36158,0.4405,1,0,1,1),
+(36724,36159,0.1101,1,0,1,1),
+(36724,36160,0.1101,1,0,1,1),
+(36724,36161,0.1101,1,0,1,1),
+(36724,36162,0.2203,1,0,1,1),
+(36724,36165,0.1101,1,0,1,1),
+(36724,36166,0.1101,1,0,1,1),
+(36724,36170,0.1101,1,0,1,1),
+(36724,36259,0.1101,1,0,1,1),
+(36724,36260,0.5507,1,0,1,1),
+(36724,36261,0.1101,1,0,1,1),
+(36724,36262,0.3304,1,0,1,1),
+(36724,36263,0.1101,1,0,1,1),
+(36724,36264,0.1101,1,0,1,1),
+(36724,36265,0.1101,1,0,1,1),
+(36724,36268,0.1101,1,0,1,1),
+(36724,36270,0.5507,1,0,1,1),
+(36724,36271,0.1101,1,0,1,1),
+(36724,36272,0.3304,1,0,1,1),
+(36724,36273,0.1101,1,0,1,1),
+(36724,36275,0.2203,1,0,1,1),
+(36724,36276,0.1101,1,0,1,1),
+(36724,36277,0.2203,1,0,1,1),
+(36724,36280,0.1101,1,0,1,1),
+(36724,36281,0.2203,1,0,1,1),
+(36724,36282,0.4405,1,0,1,1),
+(36724,36371,0.2203,1,0,1,1),
+(36724,36372,0.4405,1,0,1,1),
+(36724,36373,0.2203,1,0,1,1),
+(36724,36374,0.1101,1,0,1,1),
+(36724,36375,0.2203,1,0,1,1),
+(36724,36378,0.1101,1,0,1,1),
+(36724,36379,0.1101,1,0,1,1),
+(36724,36380,0.2203,1,0,1,1),
+(36724,36382,0.1101,1,0,1,1),
+(36724,36383,0.1101,1,0,1,1),
+(36724,36384,0.1101,1,0,1,1),
+(36724,36385,0.2203,1,0,1,1),
+(36724,36387,0.1101,1,0,1,1),
+(36724,36388,0.3304,1,0,1,1),
+(36724,36391,0.2203,1,0,1,1),
+(36724,36392,0.5507,1,0,1,1),
+(36724,36393,0.2203,1,0,1,1),
+(36724,36394,0.1101,1,0,1,1),
+(36724,36427,0.5507,1,0,1,1),
+(36724,36428,0.8811,1,0,1,1),
+(36724,36429,0.6608,1,0,1,1),
+(36724,36441,0.4405,1,0,1,1),
+(36724,36442,0.4405,1,0,1,1),
+(36724,36443,0.3304,1,0,1,1),
+(36724,36456,0.2203,1,0,1,1),
+(36724,36457,0.4405,1,0,1,1),
+(36724,36470,0.1101,1,0,1,1),
+(36724,36471,0.1101,1,0,1,1),
+(36724,36484,0.1101,1,0,1,1),
+(36724,36498,0.2203,1,0,1,1),
+(36724,36499,0.1101,1,0,1,1),
+(36724,36512,0.1101,1,0,1,1),
+(36724,36526,0.1101,1,0,1,1),
+(36724,36555,0.1101,1,0,1,1),
+(36724,36567,0.1101,1,0,1,1),
+(36724,36568,0.1101,1,0,1,1),
+(36724,36569,0.1101,1,0,1,1),
+(36724,36581,0.1101,1,0,1,1),
+(36724,36583,0.1101,1,0,1,1),
+(36724,36595,0.1101,1,0,1,1),
+(36724,36596,0.1101,1,0,1,1),
+(36724,36624,0.1101,1,0,1,1),
+(36724,36652,0.2203,1,0,1,1),
+(36724,36665,0.1101,1,0,1,1),
+(36724,36666,0.3304,1,0,1,1),
+(36724,36667,0.2203,1,0,1,1),
+(36724,36679,0.1101,1,0,1,1),
+(36724,36680,0.1101,1,0,1,1),
+(36724,36681,0.3304,1,0,1,1),
+(36724,36693,0.2203,1,0,1,1),
+(36724,36695,0.4405,1,0,1,1),
+(36724,36708,0.1101,1,0,1,1),
+(36724,37091,0.4405,1,0,1,1),
+(36724,37097,0.2203,1,0,1,1),
+(36724,37770,0.1101,1,0,1,1),
+(36724,37780,0.1101,1,0,1,1),
+(36724,37793,0.1101,1,0,1,1),
+(36724,37822,0.2203,1,0,1,1),
+(36724,41781,0.1101,1,0,1,1),
+(36724,41787,0.1101,1,0,1,1),
+(36724,41788,0.1101,1,0,1,1),
+(36724,42175,0.1101,1,0,1,1),
+(36724,42177,0.1101,1,0,1,1),
+(36724,43465,0.1101,1,0,1,1),
+(36724,43507,0.4405,1,0,1,1),
+(36724,43508,0.5507,1,0,1,1),
+(36724,43509,0.2203,1,0,1,1),
+(36724,43510,0.2203,1,0,1,1),
+(36724,43624,0.1101,1,0,1,1),
+(36724,43852,18.9162,1,0,1,1),
+(36724,45912,0.6608,1,0,1,1),
+(36724,50452,1,1,0,-50452,1),
+(36725,33445,3.3933,1,0,1,1),
+(36725,33447,2.8087,1,0,1,1),
+(36725,33470,33.5779,1,0,1,7),
+(36725,35947,7.1994,1,0,1,1),
+(36725,43852,19.2824,1,0,1,1),
+(36725,50452,2,1,0,-50452,1),
+(36805,33368,0.7874,1,0,1,1),
+(36805,33369,1.5748,1,0,1,1),
+(36805,33370,0.7874,1,0,1,1),
+(36805,33371,0.7874,1,0,1,1),
+(36805,33380,0.7874,1,0,1,1),
+(36805,33381,0.7874,1,0,1,1),
+(36805,33384,0.7874,1,0,1,1),
+(36805,33400,0.7874,1,0,1,1),
+(36805,33402,0.7874,1,0,1,1),
+(36805,33415,0.7874,1,0,1,1),
+(36805,33422,0.7874,1,0,1,1),
+(36805,33425,0.7874,1,0,1,1),
+(36805,33426,0.7874,1,0,1,1),
+(36805,33428,0.7874,1,0,1,1),
+(36805,33431,1.5748,1,0,1,1),
+(36805,33433,0.7874,1,0,1,1),
+(36805,33434,1.5748,1,0,1,1),
+(36805,33435,0.7874,1,0,1,1),
+(36805,33436,0.7874,1,0,1,1),
+(36805,33445,3.5951,1,0,1,1),
+(36805,33447,2.24,1,0,1,1),
+(36805,33454,7.7434,1,0,1,1),
+(36805,33470,34.8451,1,0,1,7),
+(36805,36053,0.7874,1,0,1,1),
+(36805,36060,0.7874,1,0,1,1),
+(36805,36064,0.7874,1,0,1,1),
+(36805,36163,0.7874,1,0,1,1),
+(36805,36165,0.7874,1,0,1,1),
+(36805,36172,0.7874,1,0,1,1),
+(36805,36177,0.7874,1,0,1,1),
+(36805,36275,0.7874,1,0,1,1),
+(36805,36277,0.7874,1,0,1,1),
+(36805,36286,0.7874,1,0,1,1),
+(36805,36287,2.3622,1,0,1,1),
+(36805,36289,0.7874,1,0,1,1),
+(36805,36393,1.5748,1,0,1,1),
+(36805,36400,0.7874,1,0,1,1),
+(36805,36401,0.7874,1,0,1,1),
+(36805,36415,0.7874,1,0,1,1),
+(36805,36429,0.7874,1,0,1,1),
+(36805,36430,0.7874,1,0,1,1),
+(36805,36444,0.7874,1,0,1,1),
+(36805,36528,0.7874,1,0,1,1),
+(36805,36611,0.7874,1,0,1,1),
+(36805,36639,0.7874,1,0,1,1),
+(36805,36667,0.7874,1,0,1,1),
+(36805,36668,0.7874,1,0,1,1),
+(36805,36682,1.5748,1,0,1,1),
+(36805,36696,0.7874,1,0,1,1),
+(36805,37097,1.5748,1,0,1,1),
+(36805,43465,0.7874,1,0,1,1),
+(36805,43467,0.7874,1,0,1,1),
+(36805,43507,0.7874,1,0,1,1),
+(36805,43852,20.0221,1,0,1,1),
+(36805,50452,1,1,0,-50452,1),
+(36807,33368,0.6897,1,0,1,1),
+(36807,33380,0.6897,1,0,1,1),
+(36807,33397,0.6897,1,0,1,1),
+(36807,33422,0.6897,1,0,1,1),
+(36807,33423,0.6897,1,0,1,1),
+(36807,33424,0.6897,1,0,1,1),
+(36807,33427,0.6897,1,0,1,1),
+(36807,33429,0.6897,1,0,1,1),
+(36807,33430,0.6897,1,0,1,1),
+(36807,33431,0.6897,1,0,1,1),
+(36807,33435,0.6897,1,0,1,1),
+(36807,33445,3.2207,1,0,1,1),
+(36807,33447,1.9115,1,0,1,1),
+(36807,33448,0.6897,1,0,1,1),
+(36807,33470,35.978,1,0,1,7),
+(36807,35947,8.4053,1,0,1,1),
+(36807,36053,0.6897,1,0,1,1),
+(36807,36055,1.3793,1,0,1,1),
+(36807,36058,0.6897,1,0,1,1),
+(36807,36060,0.6897,1,0,1,1),
+(36807,36062,0.6897,1,0,1,1),
+(36807,36063,0.6897,1,0,1,1),
+(36807,36065,0.6897,1,0,1,1),
+(36807,36165,0.6897,1,0,1,1),
+(36807,36166,1.3793,1,0,1,1),
+(36807,36167,0.6897,1,0,1,1),
+(36807,36168,0.6897,1,0,1,1),
+(36807,36169,0.6897,1,0,1,1),
+(36807,36173,0.6897,1,0,1,1),
+(36807,36278,0.6897,1,0,1,1),
+(36807,36279,0.6897,1,0,1,1),
+(36807,36283,0.6897,1,0,1,1),
+(36807,36387,0.6897,1,0,1,1),
+(36807,36391,0.6897,1,0,1,1),
+(36807,36395,1.3793,1,0,1,1),
+(36807,36397,0.6897,1,0,1,1),
+(36807,36398,0.6897,1,0,1,1),
+(36807,36429,1.3793,1,0,1,1),
+(36807,36430,2.069,1,0,1,1),
+(36807,36444,0.6897,1,0,1,1),
+(36807,36457,0.6897,1,0,1,1),
+(36807,36458,0.6897,1,0,1,1),
+(36807,36514,0.6897,1,0,1,1),
+(36807,36528,0.6897,1,0,1,1),
+(36807,36584,0.6897,1,0,1,1),
+(36807,36597,0.6897,1,0,1,1),
+(36807,36667,0.6897,1,0,1,1),
+(36807,36668,1.3793,1,0,1,1),
+(36807,36681,0.6897,1,0,1,1),
+(36807,37093,0.6897,1,0,1,1),
+(36807,43465,0.6897,1,0,1,1),
+(36807,43507,0.6897,1,0,1,1),
+(36807,43509,1.3793,1,0,1,1),
+(36807,43510,0.6897,1,0,1,1),
+(36807,43852,20.686,1,0,1,1),
+(36807,44309,0.6897,1,0,1,1),
+(36807,44310,0.6897,1,0,1,1),
+(36807,50452,1,1,0,-50452,1),
+(36808,33366,0.3861,1,0,1,1),
+(36808,33367,0.3861,1,0,1,1),
+(36808,33368,1.1583,1,0,1,1),
+(36808,33369,0.7722,1,0,1,1),
+(36808,33371,0.3861,1,0,1,1),
+(36808,33379,1.1583,1,0,1,1),
+(36808,33380,0.3861,1,0,1,1),
+(36808,33397,0.3861,1,0,1,1),
+(36808,33399,0.7722,1,0,1,1),
+(36808,33400,0.3861,1,0,1,1),
+(36808,33414,0.3861,1,0,1,1),
+(36808,33416,0.3861,1,0,1,1),
+(36808,33424,0.3861,1,0,1,1),
+(36808,33428,0.7722,1,0,1,1),
+(36808,33429,0.3861,1,0,1,1),
+(36808,33431,1.1583,1,0,1,1),
+(36808,33435,0.3861,1,0,1,1),
+(36808,33436,0.3861,1,0,1,1),
+(36808,33445,3.2587,1,0,1,1),
+(36808,33447,0.7722,1,0,1,1),
+(36808,33448,1.5444,1,0,1,1),
+(36808,33454,8.0321,1,0,1,1),
+(36808,33470,36.9526,1,0,1,7),
+(36808,36053,0.3861,1,0,1,1),
+(36808,36055,0.3861,1,0,1,1),
+(36808,36056,0.3861,1,0,1,1),
+(36808,36057,0.7722,1,0,1,1),
+(36808,36059,1.1583,1,0,1,1),
+(36808,36060,0.7722,1,0,1,1),
+(36808,36062,0.7722,1,0,1,1),
+(36808,36063,0.7722,1,0,1,1),
+(36808,36064,0.3861,1,0,1,1),
+(36808,36164,0.7722,1,0,1,1),
+(36808,36165,1.1583,1,0,1,1),
+(36808,36167,0.3861,1,0,1,1),
+(36808,36168,0.7722,1,0,1,1),
+(36808,36169,0.3861,1,0,1,1),
+(36808,36174,1.1583,1,0,1,1),
+(36808,36276,0.3861,1,0,1,1),
+(36808,36277,0.3861,1,0,1,1),
+(36808,36281,0.3861,1,0,1,1),
+(36808,36284,0.7722,1,0,1,1),
+(36808,36286,0.7722,1,0,1,1),
+(36808,36287,1.1583,1,0,1,1),
+(36808,36289,0.3861,1,0,1,1),
+(36808,36290,1.1583,1,0,1,1),
+(36808,36391,0.7722,1,0,1,1),
+(36808,36396,0.3861,1,0,1,1),
+(36808,36397,1.5444,1,0,1,1),
+(36808,36398,0.3861,1,0,1,1),
+(36808,36400,0.3861,1,0,1,1),
+(36808,36401,0.7722,1,0,1,1),
+(36808,36402,0.3861,1,0,1,1),
+(36808,36429,0.7722,1,0,1,1),
+(36808,36430,1.5444,1,0,1,1),
+(36808,36443,0.3861,1,0,1,1),
+(36808,36458,0.3861,1,0,1,1),
+(36808,36471,1.1583,1,0,1,1),
+(36808,36472,0.3861,1,0,1,1),
+(36808,36500,0.3861,1,0,1,1),
+(36808,36514,0.3861,1,0,1,1),
+(36808,36611,0.7722,1,0,1,1),
+(36808,36640,0.3861,1,0,1,1),
+(36808,36667,0.7722,1,0,1,1),
+(36808,36668,0.3861,1,0,1,1),
+(36808,36681,0.7722,1,0,1,1),
+(36808,36682,0.7722,1,0,1,1),
+(36808,36695,0.3861,1,0,1,1),
+(36808,37091,0.3861,1,0,1,1),
+(36808,37093,0.3861,1,0,1,1),
+(36808,37097,0.7722,1,0,1,1),
+(36808,37254,0.3861,1,0,1,1),
+(36808,37824,0.3861,1,0,1,1),
+(36808,41786,0.3861,1,0,1,1),
+(36808,42172,0.3861,1,0,1,1),
+(36808,43507,0.3861,1,0,1,1),
+(36808,43508,0.3861,1,0,1,1),
+(36808,43510,0.7722,1,0,1,1),
+(36808,43852,19.1446,1,0,1,1),
+(36808,50452,1,1,0,-50452,1),
+(36811,33365,0.4651,1,0,1,1),
+(36811,33366,0.4651,1,0,1,1),
+(36811,33367,0.9302,1,0,1,1),
+(36811,33368,0.4651,1,0,1,1),
+(36811,33369,0.4651,1,0,1,1),
+(36811,33379,0.4651,1,0,1,1),
+(36811,33385,0.4651,1,0,1,1),
+(36811,33400,0.4651,1,0,1,1),
+(36811,33401,0.9302,1,0,1,1),
+(36811,33403,0.4651,1,0,1,1),
+(36811,33412,0.4651,1,0,1,1),
+(36811,33419,0.9302,1,0,1,1),
+(36811,33425,1.3953,1,0,1,1),
+(36811,33426,0.4651,1,0,1,1),
+(36811,33428,0.4651,1,0,1,1),
+(36811,33430,0.9302,1,0,1,1),
+(36811,33431,0.4651,1,0,1,1),
+(36811,33433,0.4651,1,0,1,1),
+(36811,33434,1.3953,1,0,1,1),
+(36811,33445,3.7105,1,0,1,1),
+(36811,33447,2.2105,1,0,1,1),
+(36811,33448,0.4651,1,0,1,1),
+(36811,33454,8.3421,1,0,1,1),
+(36811,33470,35.4737,1,0,1,7),
+(36811,36052,0.4651,1,0,1,1),
+(36811,36053,0.4651,1,0,1,1),
+(36811,36057,0.9302,1,0,1,1),
+(36811,36058,0.9302,1,0,1,1),
+(36811,36060,0.4651,1,0,1,1),
+(36811,36061,0.4651,1,0,1,1),
+(36811,36063,0.9302,1,0,1,1),
+(36811,36064,1.3953,1,0,1,1),
+(36811,36163,0.4651,1,0,1,1),
+(36811,36165,0.9302,1,0,1,1),
+(36811,36167,0.4651,1,0,1,1),
+(36811,36171,0.4651,1,0,1,1),
+(36811,36173,0.4651,1,0,1,1),
+(36811,36175,0.4651,1,0,1,1),
+(36811,36176,1.3953,1,0,1,1),
+(36811,36278,0.4651,1,0,1,1),
+(36811,36279,0.4651,1,0,1,1),
+(36811,36284,0.4651,1,0,1,1),
+(36811,36288,0.4651,1,0,1,1),
+(36811,36290,1.3953,1,0,1,1),
+(36811,36387,0.9302,1,0,1,1),
+(36811,36388,0.4651,1,0,1,1),
+(36811,36389,0.4651,1,0,1,1),
+(36811,36390,0.4651,1,0,1,1),
+(36811,36391,0.9302,1,0,1,1),
+(36811,36396,0.4651,1,0,1,1),
+(36811,36399,0.9302,1,0,1,1),
+(36811,36402,0.4651,1,0,1,1),
+(36811,36429,0.9302,1,0,1,1),
+(36811,36430,0.9302,1,0,1,1),
+(36811,36443,0.4651,1,0,1,1),
+(36811,36444,0.4651,1,0,1,1),
+(36811,36457,0.9302,1,0,1,1),
+(36811,36458,0.4651,1,0,1,1),
+(36811,36471,0.4651,1,0,1,1),
+(36811,36486,0.9302,1,0,1,1),
+(36811,36528,0.4651,1,0,1,1),
+(36811,36597,0.4651,1,0,1,1),
+(36811,36598,0.9302,1,0,1,1),
+(36811,36640,0.4651,1,0,1,1),
+(36811,36668,0.4651,1,0,1,1),
+(36811,36681,0.4651,1,0,1,1),
+(36811,36682,0.4651,1,0,1,1),
+(36811,37761,0.4651,1,0,1,1),
+(36811,37794,0.4651,1,0,1,1),
+(36811,37824,0.4651,1,0,1,1),
+(36811,43465,0.4651,1,0,1,1),
+(36811,43507,1.3953,1,0,1,1),
+(36811,43508,0.9302,1,0,1,1),
+(36811,43509,0.4651,1,0,1,1),
+(36811,43510,0.9302,1,0,1,1),
+(36811,43852,18.6316,1,0,1,1),
+(36811,44308,0.4651,1,0,1,1),
+(36811,44311,0.4651,1,0,1,1),
+(36811,45912,0.4651,1,0,1,1),
+(36811,50452,1,1,0,-50452,1),
+(36829,33370,0.8,1,0,1,1),
+(36829,33371,0.8,1,0,1,1),
+(36829,33382,0.8,1,0,1,1),
+(36829,33383,0.8,1,0,1,1),
+(36829,33397,0.8,1,0,1,1),
+(36829,33400,0.8,1,0,1,1),
+(36829,33403,0.8,1,0,1,1),
+(36829,33419,0.8,1,0,1,1),
+(36829,33422,3.2,1,0,1,1),
+(36829,33426,0.8,1,0,1,1),
+(36829,33427,0.8,1,0,1,1),
+(36829,33429,0.8,1,0,1,1),
+(36829,33430,0.8,1,0,1,1),
+(36829,33434,0.8,1,0,1,1),
+(36829,33436,0.8,1,0,1,1),
+(36829,33445,4.3534,1,0,1,1),
+(36829,33447,1.5971,1,0,1,1),
+(36829,33448,2.4,1,0,1,1),
+(36829,33470,34.4925,1,0,1,7),
+(36829,35947,7.2128,1,0,1,1),
+(36829,36052,0.8,1,0,1,1),
+(36829,36054,1.6,1,0,1,1),
+(36829,36055,2.4,1,0,1,1),
+(36829,36056,0.8,1,0,1,1),
+(36829,36059,0.8,1,0,1,1),
+(36829,36065,0.8,1,0,1,1),
+(36829,36165,1.6,1,0,1,1),
+(36829,36167,0.8,1,0,1,1),
+(36829,36171,0.8,1,0,1,1),
+(36829,36284,0.8,1,0,1,1),
+(36829,36290,0.8,1,0,1,1),
+(36829,36394,0.8,1,0,1,1),
+(36829,36395,0.8,1,0,1,1),
+(36829,36401,1.6,1,0,1,1),
+(36829,36443,0.8,1,0,1,1),
+(36829,36457,0.8,1,0,1,1),
+(36829,36471,0.8,1,0,1,1),
+(36829,36570,0.8,1,0,1,1),
+(36829,36583,1.6,1,0,1,1),
+(36829,36584,0.8,1,0,1,1),
+(36829,36667,0.8,1,0,1,1),
+(36829,36682,1.6,1,0,1,1),
+(36829,36696,0.8,1,0,1,1),
+(36829,37093,0.8,1,0,1,1),
+(36829,43297,0.8,1,0,1,1),
+(36829,43507,0.8,1,0,1,1),
+(36829,43508,1.6,1,0,1,1),
+(36829,43509,0.8,1,0,1,1),
+(36829,43510,0.8,1,0,1,1),
+(36829,43852,17.9804,1,0,1,1),
+(36829,50452,5,1,0,-50452,1),
+(36855,49426,100,1,0,2,2),
+(36855,50342,0,1,1,1,1),
+(36855,50776,0,1,1,1,1),
+(36855,50777,0,1,1,1,1),
+(36855,50778,0,1,2,1,1),
+(36855,50779,0,1,2,1,1),
+(36855,50780,0,1,1,1,1),
+(36855,50781,0,1,1,1,1),
+(36855,50782,0,1,1,1,1),
+(36855,50783,0,1,2,1,1),
+(36855,50784,0,1,2,1,1),
+(36855,50785,0,1,2,1,1),
+(36855,50786,0,1,2,1,1),
+(36880,33445,3.3284,1,0,1,1),
+(36880,33447,2.4474,1,0,1,1),
+(36880,33470,33.4802,1,0,1,7),
+(36880,35947,6.8527,1,0,1,1),
+(36880,36456,1.5873,1,0,1,1),
+(36880,43852,19.2364,1,0,1,1),
+(36880,50452,5,1,0,-50452,1),
+(36998,33417,1.061,1,0,1,1),
+(36998,33424,5.8824,1,0,1,1),
+(36998,33431,1.0914,1,0,1,1),
+(36998,33443,10.6412,1,0,1,1),
+(36998,33445,3.8199,1,0,1,1),
+(36998,33447,1.0914,1,0,1,1),
+(36998,33448,1.3263,1,0,1,1),
+(36998,33470,31.105,1,0,1,7),
+(36998,36056,1.2278,1,0,1,1),
+(36998,36059,1.061,1,0,1,1),
+(36998,36061,5.8824,1,0,1,1),
+(36998,36065,5.8824,1,0,1,1),
+(36998,36166,5.8824,1,0,1,1),
+(36998,36168,1.0914,1,0,1,1),
+(36998,36171,5.8824,1,0,1,1),
+(36998,36178,1.061,1,0,1,1),
+(36998,36287,1.061,1,0,1,1),
+(36998,36400,5.8824,1,0,1,1),
+(36998,36430,1.0914,1,0,1,1),
+(36998,36444,1.0914,1,0,1,1),
+(36998,36513,5.8824,1,0,1,1),
+(36998,43852,20.3274,1,0,1,1),
+(36998,50452,1,1,0,-50452,1),
+(37003,33382,3.5714,1,0,1,1),
+(37003,33401,3.5714,1,0,1,1),
+(37003,33429,3.5714,1,0,1,1),
+(37003,33430,1.8978,1,0,1,1),
+(37003,33433,3.5714,1,0,1,1),
+(37003,33435,3.5714,1,0,1,1),
+(37003,33443,8.1752,1,0,1,1),
+(37003,33445,3.5036,1,0,1,1),
+(37003,33447,2.7737,1,0,1,1),
+(37003,33448,1.8978,1,0,1,1),
+(37003,33470,35.6204,1,0,1,7),
+(37003,36051,3.5714,1,0,1,1),
+(37003,36059,3.5714,1,0,1,1),
+(37003,36060,3.5714,1,0,1,1),
+(37003,36167,1.2539,1,0,1,1),
+(37003,36276,7.1429,1,0,1,1),
+(37003,36278,3.5714,1,0,1,1),
+(37003,36284,3.5714,1,0,1,1),
+(37003,36391,3.5714,1,0,1,1),
+(37003,36399,1.0219,1,0,1,1),
+(37003,36429,1.0219,1,0,1,1),
+(37003,36430,1.2539,1,0,1,1),
+(37003,36528,3.5714,1,0,1,1),
+(37003,36681,3.5714,1,0,1,1),
+(37003,37097,3.5714,1,0,1,1),
+(37003,43467,1.0219,1,0,1,1),
+(37003,43852,14.7445,1,0,1,1),
+(37003,50452,1,1,0,-50452,1),
+(37004,33380,3.125,1,0,1,1),
+(37004,33399,3.125,1,0,1,1),
+(37004,33402,3.125,1,0,1,1),
+(37004,33422,3.125,1,0,1,1),
+(37004,33425,3.125,1,0,1,1),
+(37004,33430,3.125,1,0,1,1),
+(37004,33443,8.5393,1,0,1,1),
+(37004,33445,2.9963,1,0,1,1),
+(37004,33447,1.8727,1,0,1,1),
+(37004,33470,31.6854,1,0,1,7),
+(37004,36053,3.125,1,0,1,1),
+(37004,36056,3.125,1,0,1,1),
+(37004,36170,1.1236,1,0,1,1),
+(37004,36429,3.125,1,0,1,1),
+(37004,36458,3.125,1,0,1,1),
+(37004,36542,3.125,1,0,1,1),
+(37004,36668,3.125,1,0,1,1),
+(37004,42176,3.125,1,0,1,1),
+(37004,43467,3.125,1,0,1,1),
+(37004,43852,17.1536,1,0,1,1),
+(37004,50452,1,1,0,-50452,1),
+(37007,33365,0.1912,1,0,1,1),
+(37007,33367,0.1912,1,0,1,1),
+(37007,33369,0.3824,1,0,1,1),
+(37007,33371,0.1912,1,0,1,1),
+(37007,33379,0.5736,1,0,1,1),
+(37007,33381,0.1912,1,0,1,1),
+(37007,33383,0.1912,1,0,1,1),
+(37007,33397,0.3824,1,0,1,1),
+(37007,33398,0.1912,1,0,1,1),
+(37007,33399,0.3824,1,0,1,1),
+(37007,33401,0.3824,1,0,1,1),
+(37007,33402,0.5736,1,0,1,1),
+(37007,33403,0.1912,1,0,1,1),
+(37007,33412,0.3824,1,0,1,1),
+(37007,33413,0.1912,1,0,1,1),
+(37007,33414,0.1912,1,0,1,1),
+(37007,33415,0.3824,1,0,1,1),
+(37007,33419,0.1912,1,0,1,1),
+(37007,33422,0.1912,1,0,1,1),
+(37007,33423,0.3824,1,0,1,1),
+(37007,33424,0.3824,1,0,1,1),
+(37007,33425,0.5736,1,0,1,1),
+(37007,33426,0.3824,1,0,1,1),
+(37007,33427,0.7648,1,0,1,1),
+(37007,33428,0.7648,1,0,1,1),
+(37007,33429,0.5736,1,0,1,1),
+(37007,33430,0.7648,1,0,1,1),
+(37007,33431,0.1912,1,0,1,1),
+(37007,33433,0.1912,1,0,1,1),
+(37007,33434,0.3824,1,0,1,1),
+(37007,33435,0.3824,1,0,1,1),
+(37007,33436,0.3824,1,0,1,1),
+(37007,33445,3.6671,1,0,1,1),
+(37007,33447,1.9884,1,0,1,1),
+(37007,33448,1.1472,1,0,1,1),
+(37007,33470,32.9536,1,0,1,7),
+(37007,35947,7.4141,1,0,1,1),
+(37007,36052,0.7648,1,0,1,1),
+(37007,36056,0.3824,1,0,1,1),
+(37007,36057,0.1912,1,0,1,1),
+(37007,36058,0.1912,1,0,1,1),
+(37007,36059,0.1912,1,0,1,1),
+(37007,36060,0.3824,1,0,1,1),
+(37007,36061,0.3824,1,0,1,1),
+(37007,36062,0.5736,1,0,1,1),
+(37007,36064,0.5736,1,0,1,1),
+(37007,36065,0.3824,1,0,1,1),
+(37007,36066,0.1912,1,0,1,1),
+(37007,36163,0.3824,1,0,1,1),
+(37007,36164,0.7648,1,0,1,1),
+(37007,36165,0.5736,1,0,1,1),
+(37007,36166,0.3824,1,0,1,1),
+(37007,36167,0.5736,1,0,1,1),
+(37007,36168,0.5736,1,0,1,1),
+(37007,36170,0.3824,1,0,1,1),
+(37007,36171,0.3824,1,0,1,1),
+(37007,36173,0.1912,1,0,1,1),
+(37007,36174,0.1912,1,0,1,1),
+(37007,36175,0.1912,1,0,1,1),
+(37007,36178,0.5736,1,0,1,1),
+(37007,36276,0.1912,1,0,1,1),
+(37007,36277,0.1912,1,0,1,1),
+(37007,36279,0.3824,1,0,1,1),
+(37007,36280,0.7648,1,0,1,1),
+(37007,36281,0.3824,1,0,1,1),
+(37007,36283,0.7648,1,0,1,1),
+(37007,36284,0.1912,1,0,1,1),
+(37007,36285,0.3824,1,0,1,1),
+(37007,36286,0.1912,1,0,1,1),
+(37007,36288,0.1912,1,0,1,1),
+(37007,36389,0.1912,1,0,1,1),
+(37007,36390,0.1912,1,0,1,1),
+(37007,36391,0.3824,1,0,1,1),
+(37007,36392,0.3824,1,0,1,1),
+(37007,36394,0.3824,1,0,1,1),
+(37007,36395,0.1912,1,0,1,1),
+(37007,36396,0.5736,1,0,1,1),
+(37007,36397,0.1912,1,0,1,1),
+(37007,36398,0.3824,1,0,1,1),
+(37007,36399,0.3824,1,0,1,1),
+(37007,36400,0.5736,1,0,1,1),
+(37007,36401,0.1912,1,0,1,1),
+(37007,36402,0.5736,1,0,1,1),
+(37007,36429,0.7648,1,0,1,1),
+(37007,36430,1.3384,1,0,1,1),
+(37007,36443,0.3824,1,0,1,1),
+(37007,36444,0.956,1,0,1,1),
+(37007,36457,0.1912,1,0,1,1),
+(37007,36458,0.1912,1,0,1,1),
+(37007,36471,0.5736,1,0,1,1),
+(37007,36472,0.3824,1,0,1,1),
+(37007,36499,0.1912,1,0,1,1),
+(37007,36555,0.3824,1,0,1,1),
+(37007,36569,0.1912,1,0,1,1),
+(37007,36570,0.1912,1,0,1,1),
+(37007,36583,0.1912,1,0,1,1),
+(37007,36584,0.1912,1,0,1,1),
+(37007,36597,0.1912,1,0,1,1),
+(37007,36668,0.5736,1,0,1,1),
+(37007,36681,0.7648,1,0,1,1),
+(37007,36682,0.1912,1,0,1,1),
+(37007,36695,0.956,1,0,1,1),
+(37007,36696,0.3824,1,0,1,1),
+(37007,37093,0.5736,1,0,1,1),
+(37007,37254,0.1912,1,0,1,1),
+(37007,37761,0.1912,1,0,1,1),
+(37007,37794,0.1912,1,0,1,1),
+(37007,37824,0.1912,1,0,1,1),
+(37007,42173,0.1912,1,0,1,1),
+(37007,43507,0.7648,1,0,1,1),
+(37007,43509,0.1912,1,0,1,1),
+(37007,43852,18.2254,1,0,1,1),
+(37007,45912,0.3824,1,0,1,1),
+(37007,50452,5,1,0,-50452,1),
+(37011,33365,0.3069,1,0,1,1),
+(37011,33366,0.537,1,0,1,1),
+(37011,33367,0.1918,1,0,1,1),
+(37011,33368,0.4219,1,0,1,1),
+(37011,33369,0.2685,1,0,1,1),
+(37011,33370,0.1918,1,0,1,1),
+(37011,33371,0.2685,1,0,1,1),
+(37011,33379,0.3452,1,0,1,1),
+(37011,33380,0.3069,1,0,1,1),
+(37011,33381,0.3836,1,0,1,1),
+(37011,33384,0.1534,1,0,1,1),
+(37011,33385,0.1534,1,0,1,1),
+(37011,33397,0.3069,1,0,1,1),
+(37011,33398,0.1918,1,0,1,1),
+(37011,33399,0.1918,1,0,1,1),
+(37011,33400,0.2685,1,0,1,1),
+(37011,33401,0.2685,1,0,1,1),
+(37011,33402,0.1918,1,0,1,1),
+(37011,33403,0.2301,1,0,1,1),
+(37011,33412,0.3452,1,0,1,1),
+(37011,33413,0.1918,1,0,1,1),
+(37011,33415,0.1151,1,0,1,1),
+(37011,33416,0.2685,1,0,1,1),
+(37011,33419,0.2301,1,0,1,1),
+(37011,33422,0.8055,1,0,1,1),
+(37011,33423,0.6137,1,0,1,1),
+(37011,33424,0.4987,1,0,1,1),
+(37011,33425,0.5754,1,0,1,1),
+(37011,33426,0.5754,1,0,1,1),
+(37011,33427,0.6904,1,0,1,1),
+(37011,33428,0.4603,1,0,1,1),
+(37011,33429,0.4987,1,0,1,1),
+(37011,33430,0.4987,1,0,1,1),
+(37011,33431,0.6137,1,0,1,1),
+(37011,33433,0.3836,1,0,1,1),
+(37011,33434,0.1534,1,0,1,1),
+(37011,33435,0.3836,1,0,1,1),
+(37011,33436,0.1918,1,0,1,1),
+(37011,33445,3.7826,1,0,1,1),
+(37011,33447,2.1066,1,0,1,1),
+(37011,33448,1.1891,1,0,1,1),
+(37011,33470,34.8447,1,0,1,7),
+(37011,35947,7.4382,1,0,1,1),
+(37011,36035,0.1534,1,0,1,1),
+(37011,36036,0.2301,1,0,1,1),
+(37011,36037,0.3836,1,0,1,1),
+(37011,36038,0.3069,1,0,1,1),
+(37011,36039,0.2301,1,0,1,1),
+(37011,36040,0.2685,1,0,1,1),
+(37011,36041,0.3836,1,0,1,1),
+(37011,36042,0.1534,1,0,1,1),
+(37011,36043,0.4603,1,0,1,1),
+(37011,36044,0.1534,1,0,1,1),
+(37011,36045,0.3069,1,0,1,1),
+(37011,36046,0.3069,1,0,1,1),
+(37011,36047,0.1918,1,0,1,1),
+(37011,36048,0.2685,1,0,1,1),
+(37011,36049,0.2301,1,0,1,1),
+(37011,36050,0.3069,1,0,1,1),
+(37011,36051,0.1151,1,0,1,1),
+(37011,36052,0.4219,1,0,1,1),
+(37011,36053,0.3452,1,0,1,1),
+(37011,36054,0.3452,1,0,1,1),
+(37011,36055,0.1151,1,0,1,1),
+(37011,36056,0.1918,1,0,1,1),
+(37011,36057,0.1534,1,0,1,1),
+(37011,36058,0.3452,1,0,1,1),
+(37011,36147,0.1918,1,0,1,1),
+(37011,36148,0.2301,1,0,1,1),
+(37011,36149,0.2685,1,0,1,1),
+(37011,36150,0.1918,1,0,1,1),
+(37011,36152,0.1534,1,0,1,1),
+(37011,36153,0.1151,1,0,1,1),
+(37011,36154,0.1534,1,0,1,1),
+(37011,36155,0.1918,1,0,1,1),
+(37011,36156,0.1534,1,0,1,1),
+(37011,36157,0.1151,1,0,1,1),
+(37011,36158,0.1534,1,0,1,1),
+(37011,36159,0.1534,1,0,1,1),
+(37011,36160,0.1534,1,0,1,1),
+(37011,36161,0.2685,1,0,1,1),
+(37011,36162,0.1151,1,0,1,1),
+(37011,36163,0.1918,1,0,1,1),
+(37011,36164,0.1534,1,0,1,1),
+(37011,36166,0.1534,1,0,1,1),
+(37011,36167,0.3069,1,0,1,1),
+(37011,36168,0.1918,1,0,1,1),
+(37011,36169,0.1918,1,0,1,1),
+(37011,36170,0.1534,1,0,1,1),
+(37011,36259,0.1151,1,0,1,1),
+(37011,36260,0.1918,1,0,1,1),
+(37011,36261,0.0767,1,0,1,1),
+(37011,36262,0.1534,1,0,1,1),
+(37011,36263,0.1534,1,0,1,1),
+(37011,36264,0.0767,1,0,1,1),
+(37011,36265,0.1534,1,0,1,1),
+(37011,36266,0.3452,1,0,1,1),
+(37011,36267,0.1534,1,0,1,1),
+(37011,36268,0.1918,1,0,1,1),
+(37011,36269,0.1151,1,0,1,1),
+(37011,36270,0.3836,1,0,1,1),
+(37011,36271,0.1534,1,0,1,1),
+(37011,36272,0.1534,1,0,1,1),
+(37011,36273,0.1534,1,0,1,1),
+(37011,36274,0.1918,1,0,1,1),
+(37011,36275,0.1918,1,0,1,1),
+(37011,36277,0.1918,1,0,1,1),
+(37011,36278,0.2301,1,0,1,1),
+(37011,36279,0.1534,1,0,1,1),
+(37011,36280,0.1151,1,0,1,1),
+(37011,36281,0.1534,1,0,1,1),
+(37011,36282,0.2301,1,0,1,1),
+(37011,36371,0.2301,1,0,1,1),
+(37011,36372,0.1151,1,0,1,1),
+(37011,36373,0.1918,1,0,1,1),
+(37011,36374,0.2301,1,0,1,1),
+(37011,36375,0.2685,1,0,1,1),
+(37011,36376,0.2301,1,0,1,1),
+(37011,36377,0.1534,1,0,1,1),
+(37011,36378,0.1534,1,0,1,1),
+(37011,36379,0.1534,1,0,1,1),
+(37011,36380,0.0767,1,0,1,1),
+(37011,36381,0.2301,1,0,1,1),
+(37011,36382,0.2685,1,0,1,1),
+(37011,36383,0.2301,1,0,1,1),
+(37011,36384,0.1534,1,0,1,1),
+(37011,36385,0.0767,1,0,1,1),
+(37011,36386,0.1534,1,0,1,1),
+(37011,36388,0.2301,1,0,1,1),
+(37011,36389,0.3069,1,0,1,1),
+(37011,36390,0.1151,1,0,1,1),
+(37011,36391,0.1151,1,0,1,1),
+(37011,36392,0.2301,1,0,1,1),
+(37011,36393,0.3069,1,0,1,1),
+(37011,36394,0.1918,1,0,1,1),
+(37011,36413,0.0767,1,0,1,1),
+(37011,36414,0.2685,1,0,1,1),
+(37011,36415,0.1918,1,0,1,1),
+(37011,36427,0.4987,1,0,1,1),
+(37011,36428,0.5754,1,0,1,1),
+(37011,36429,0.6521,1,0,1,1),
+(37011,36441,0.3452,1,0,1,1),
+(37011,36442,0.1918,1,0,1,1),
+(37011,36443,0.2685,1,0,1,1),
+(37011,36456,0.1534,1,0,1,1),
+(37011,36457,0.0767,1,0,1,1),
+(37011,36470,0.0767,1,0,1,1),
+(37011,36471,0.1534,1,0,1,1),
+(37011,36484,0.1918,1,0,1,1),
+(37011,36499,0.1151,1,0,1,1),
+(37011,36511,0.1534,1,0,1,1),
+(37011,36513,0.0767,1,0,1,1),
+(37011,36525,0.1151,1,0,1,1),
+(37011,36526,0.1534,1,0,1,1),
+(37011,36527,0.1534,1,0,1,1),
+(37011,36539,0.1151,1,0,1,1),
+(37011,36540,0.1151,1,0,1,1),
+(37011,36553,0.1151,1,0,1,1),
+(37011,36554,0.1151,1,0,1,1),
+(37011,36567,0.1151,1,0,1,1),
+(37011,36568,0.1151,1,0,1,1),
+(37011,36581,0.1151,1,0,1,1),
+(37011,36582,0.1151,1,0,1,1),
+(37011,36583,0.1151,1,0,1,1),
+(37011,36597,0.0767,1,0,1,1),
+(37011,36609,0.0767,1,0,1,1),
+(37011,36610,0.1151,1,0,1,1),
+(37011,36611,0.1151,1,0,1,1),
+(37011,36665,0.2685,1,0,1,1),
+(37011,36666,0.2301,1,0,1,1),
+(37011,36667,0.2685,1,0,1,1),
+(37011,36679,0.3452,1,0,1,1),
+(37011,36680,0.3452,1,0,1,1),
+(37011,36681,0.3452,1,0,1,1),
+(37011,36693,0.1918,1,0,1,1),
+(37011,36694,0.1534,1,0,1,1),
+(37011,36695,0.1534,1,0,1,1),
+(37011,37091,0.2301,1,0,1,1),
+(37011,37097,0.1534,1,0,1,1),
+(37011,37254,0.0767,1,0,1,1),
+(37011,37760,0.1151,1,0,1,1),
+(37011,37781,0.1151,1,0,1,1),
+(37011,37794,0.0767,1,0,1,1),
+(37011,37822,0.1151,1,0,1,1),
+(37011,43465,0.1534,1,0,1,1),
+(37011,43467,0.1534,1,0,1,1),
+(37011,43507,0.3836,1,0,1,1),
+(37011,43508,0.4987,1,0,1,1),
+(37011,43509,0.3836,1,0,1,1),
+(37011,43510,0.4987,1,0,1,1),
+(37011,43624,0.1534,1,0,1,1),
+(37011,43852,18.9185,1,0,1,1),
+(37011,45912,0.6521,1,0,1,1),
+(37011,50452,1,1,0,-50452,1),
+(37012,33445,3.5179,1,0,1,1),
+(37012,33447,2.5696,1,0,1,1),
+(37012,33470,34.8119,1,0,1,7),
+(37012,35947,7.4946,1,0,1,1),
+(37012,43852,19.5779,1,0,1,1),
+(37012,50452,1,1,0,-50452,1),
+(37016,33383,3.8462,1,0,1,1),
+(37016,33401,1.3889,1,0,1,1),
+(37016,33425,1.0526,1,0,1,1),
+(37016,33431,1.0526,1,0,1,1),
+(37016,33433,1.1111,1,0,1,1),
+(37016,33443,7.8195,1,0,1,1),
+(37016,33445,3.4586,1,0,1,1),
+(37016,33447,1.5038,1,0,1,1),
+(37016,33448,7.6923,1,0,1,1),
+(37016,33470,33.0827,1,0,1,7),
+(37016,36055,3.8462,1,0,1,1),
+(37016,36059,3.8462,1,0,1,1),
+(37016,36062,3.8462,1,0,1,1),
+(37016,36064,3.8462,1,0,1,1),
+(37016,36175,3.8462,1,0,1,1),
+(37016,36289,3.8462,1,0,1,1),
+(37016,36400,3.8462,1,0,1,1),
+(37016,36583,1.9549,1,0,1,1),
+(37016,36682,1.203,1,0,1,1),
+(37016,36696,3.8462,1,0,1,1),
+(37016,37093,1.1111,1,0,1,1),
+(37016,43852,22.406,1,0,1,1),
+(37016,44312,3.8462,1,0,1,1),
+(37016,45912,1.203,1,0,1,1),
+(37016,50452,1,1,0,-50452,1),
+(37017,33371,4.1667,1,0,1,1),
+(37017,33380,4.1667,1,0,1,1),
+(37017,33382,1.059,1,0,1,1),
+(37017,33397,1.4368,1,0,1,1),
+(37017,33417,1.059,1,0,1,1),
+(37017,33424,8.3333,1,0,1,1),
+(37017,33443,8.1694,1,0,1,1),
+(37017,33445,2.8744,1,0,1,1),
+(37017,33447,1.6641,1,0,1,1),
+(37017,33448,1.4368,1,0,1,1),
+(37017,33470,29.1982,1,0,1,7),
+(37017,36054,4.1667,1,0,1,1),
+(37017,36055,4.1667,1,0,1,1),
+(37017,36058,1.4368,1,0,1,1),
+(37017,36173,4.1667,1,0,1,1),
+(37017,36429,8.3333,1,0,1,1),
+(37017,36444,3.3283,1,0,1,1),
+(37017,36583,4.1667,1,0,1,1),
+(37017,43463,4.1667,1,0,1,1),
+(37017,43507,4.1667,1,0,1,1),
+(37017,43852,18.6082,1,0,1,1),
+(37017,45912,1.1494,1,0,1,1),
+(37017,50452,1,1,0,-50452,1),
+(37021,33417,2.5,1,0,1,1),
+(37021,33428,2.1308,1,0,1,1),
+(37021,33430,2.5,1,0,1,1),
+(37021,33431,1.1283,1,0,1,1),
+(37021,33435,2.5,1,0,1,1),
+(37021,33443,7.4945,1,0,1,1),
+(37021,33445,4.6289,1,0,1,1),
+(37021,33447,1.6165,1,0,1,1),
+(37021,33470,34.0191,1,0,1,7),
+(37021,36051,2.5,1,0,1,1),
+(37021,36053,2.5,1,0,1,1),
+(37021,36058,5,1,0,1,1),
+(37021,36169,2.5,1,0,1,1),
+(37021,36275,2.5,1,0,1,1),
+(37021,36278,2.5,1,0,1,1),
+(37021,36283,2.5,1,0,1,1),
+(37021,36429,1.1756,1,0,1,1),
+(37021,36443,2.5,1,0,1,1),
+(37021,36597,2.5,1,0,1,1),
+(37021,36667,2.5,1,0,1,1),
+(37021,36682,2.5,1,0,1,1),
+(37021,43852,18.8097,1,0,1,1),
+(37021,50452,1,1,0,-50452,1),
+(37022,33445,3.9507,1,0,1,1),
+(37022,33447,1.9053,1,0,1,1),
+(37022,33470,33.9591,1,0,1,7),
+(37022,35947,7.7333,1,0,1,1),
+(37022,43852,20.0616,1,0,1,1),
+(37022,50452,1,1,0,-50452,1),
+(37023,33445,3.7409,1,0,1,1),
+(37023,33447,1.9787,1,0,1,1),
+(37023,33448,1.5922,1,0,1,1),
+(37023,33470,32.3079,1,0,1,7),
+(37023,35947,7.7292,1,0,1,1),
+(37023,43852,19.1374,1,0,1,1),
+(37023,50452,2,1,0,-50452,1),
+(37025,33365,1.548,1,0,1,1),
+(37025,33417,1.257,1,0,1,1),
+(37025,33423,1.2384,1,0,1,1),
+(37025,33425,2.1672,1,0,1,1),
+(37025,33426,2.095,1,0,1,1),
+(37025,33428,1.676,1,0,1,1),
+(37025,33435,1.8576,1,0,1,1),
+(37025,33436,1.548,1,0,1,1),
+(37025,33568,13.9665,1,0,1,16),
+(37025,44128,4.3296,1,0,1,1),
+(37025,50452,1,1,0,-50452,1),
+(37026,33381,1.1364,1,0,1,1),
+(37026,33398,6.25,1,0,1,1),
+(37026,33402,1.1364,1,0,1,1),
+(37026,33414,1.1364,1,0,1,1),
+(37026,33422,1.0204,1,0,1,1),
+(37026,33423,6.25,1,0,1,1),
+(37026,33424,1.2245,1,0,1,1),
+(37026,33425,1.0204,1,0,1,1),
+(37026,33426,1.2245,1,0,1,1),
+(37026,33428,2.0408,1,0,1,1),
+(37026,33431,6.25,1,0,1,1),
+(37026,33443,6.9388,1,0,1,1),
+(37026,33445,3.4694,1,0,1,1),
+(37026,33447,1.2245,1,0,1,1),
+(37026,33470,31.6327,1,0,1,7),
+(37026,36052,6.25,1,0,1,1),
+(37026,36066,1.2245,1,0,1,1),
+(37026,36166,6.25,1,0,1,1),
+(37026,36396,1.8367,1,0,1,1),
+(37026,36399,6.25,1,0,1,1),
+(37026,36429,1.0204,1,0,1,1),
+(37026,36430,1.0204,1,0,1,1),
+(37026,36444,1.0204,1,0,1,1),
+(37026,36695,6.25,1,0,1,1),
+(37026,37093,6.25,1,0,1,1),
+(37026,43852,19.5918,1,0,1,1),
+(37026,45912,6.25,1,0,1,1),
+(37026,50452,1,1,0,-50452,1),
+(37027,33397,1.1628,1,0,1,1),
+(37027,33428,1.0264,1,0,1,1),
+(37027,33431,4.1667,1,0,1,1),
+(37027,33443,7.0381,1,0,1,1),
+(37027,33445,4.5455,1,0,1,1),
+(37027,33447,2.9326,1,0,1,1),
+(37027,33448,4.1667,1,0,1,1),
+(37027,33470,31.085,1,0,1,7),
+(37027,36055,1.0264,1,0,1,1),
+(37027,36058,1.1628,1,0,1,1),
+(37027,36063,4.1667,1,0,1,1),
+(37027,36167,1.1628,1,0,1,1),
+(37027,36168,1.9062,1,0,1,1),
+(37027,36170,1.1628,1,0,1,1),
+(37027,36387,4.1667,1,0,1,1),
+(37027,36399,4.1667,1,0,1,1),
+(37027,36400,4.1667,1,0,1,1),
+(37027,36416,4.1667,1,0,1,1),
+(37027,36429,1.0264,1,0,1,1),
+(37027,36471,4.1667,1,0,1,1),
+(37027,43852,19.2082,1,0,1,1),
+(37027,50452,1,1,0,-50452,1),
+(37029,33367,2.439,1,0,1,1),
+(37029,33385,2.439,1,0,1,1),
+(37029,33422,1.1041,1,0,1,1),
+(37029,33424,2.439,1,0,1,1),
+(37029,33426,2.439,1,0,1,1),
+(37029,33427,1.0265,1,0,1,1),
+(37029,33445,4.0205,1,0,1,1),
+(37029,33447,2.2241,1,0,1,1),
+(37029,33448,1.1041,1,0,1,1),
+(37029,33454,8.2121,1,0,1,1),
+(37029,33470,31.3944,1,0,1,7),
+(37029,36056,2.439,1,0,1,1),
+(37029,36062,2.439,1,0,1,1),
+(37029,36065,2.439,1,0,1,1),
+(37029,36066,2.439,1,0,1,1),
+(37029,36163,2.439,1,0,1,1),
+(37029,36165,2.439,1,0,1,1),
+(37029,36168,2.439,1,0,1,1),
+(37029,36174,2.439,1,0,1,1),
+(37029,36280,1.6253,1,0,1,1),
+(37029,36288,2.439,1,0,1,1),
+(37029,36389,2.439,1,0,1,1),
+(37029,36430,2.439,1,0,1,1),
+(37029,36569,2.439,1,0,1,1),
+(37029,36681,1.0265,1,0,1,1),
+(37029,36682,2.439,1,0,1,1),
+(37029,36695,2.439,1,0,1,1),
+(37029,37794,2.439,1,0,1,1),
+(37029,43852,19.846,1,0,1,1),
+(37029,50452,1,1,0,-50452,1),
+(37030,33368,5.2632,1,0,1,1),
+(37030,33369,5.2632,1,0,1,1),
+(37030,33384,5.2632,1,0,1,1),
+(37030,33397,1.199,1,0,1,1),
+(37030,33416,5.2632,1,0,1,1),
+(37030,33445,4.9007,1,0,1,1),
+(37030,33447,2.3841,1,0,1,1),
+(37030,33448,1.0596,1,0,1,1),
+(37030,33454,7.4172,1,0,1,1),
+(37030,33470,36.0265,1,0,1,7),
+(37030,36163,5.2632,1,0,1,1),
+(37030,36174,5.2632,1,0,1,1),
+(37030,36277,5.2632,1,0,1,1),
+(37030,36398,5.2632,1,0,1,1),
+(37030,36429,1.3245,1,0,1,1),
+(37030,36430,1.199,1,0,1,1),
+(37030,36681,1.457,1,0,1,1),
+(37030,37091,5.2632,1,0,1,1),
+(37030,37794,5.2632,1,0,1,1),
+(37030,43510,5.2632,1,0,1,1),
+(37030,43852,19.6026,1,0,1,1),
+(37030,50452,1,1,0,-50452,1),
+(37031,33379,1.0067,1,0,1,1),
+(37031,33400,5.2632,1,0,1,1),
+(37031,33401,1.087,1,0,1,1),
+(37031,33415,10.5263,1,0,1,1),
+(37031,33422,1.0067,1,0,1,1),
+(37031,33423,5.2632,1,0,1,1),
+(37031,33424,1.087,1,0,1,1),
+(37031,33425,5.2632,1,0,1,1),
+(37031,33428,1.8116,1,0,1,1),
+(37031,33429,1.0067,1,0,1,1),
+(37031,33445,3.2609,1,0,1,1),
+(37031,33447,1.6304,1,0,1,1),
+(37031,33448,1.4493,1,0,1,1),
+(37031,33454,7.4275,1,0,1,1),
+(37031,33470,35.1449,1,0,1,7),
+(37031,36057,5.2632,1,0,1,1),
+(37031,36170,5.2632,1,0,1,1),
+(37031,36283,5.2632,1,0,1,1),
+(37031,36289,1.3423,1,0,1,1),
+(37031,36415,1.0067,1,0,1,1),
+(37031,36444,1.3423,1,0,1,1),
+(37031,36514,5.2632,1,0,1,1),
+(37031,36667,5.2632,1,0,1,1),
+(37031,36668,5.2632,1,0,1,1),
+(37031,41783,5.2632,1,0,1,1),
+(37031,43852,17.5725,1,0,1,1),
+(37031,50452,1,1,0,-50452,1),
+(37032,33400,4.7619,1,0,1,1),
+(37032,33401,1.0638,1,0,1,1),
+(37032,33425,1.2262,1,0,1,1),
+(37032,33428,9.5238,1,0,1,1),
+(37032,33435,1.0638,1,0,1,1),
+(37032,33445,4.3597,1,0,1,1),
+(37032,33447,2.5886,1,0,1,1),
+(37032,33454,5.8583,1,0,1,1),
+(37032,33470,35.0136,1,0,1,7),
+(37032,36051,4.7619,1,0,1,1),
+(37032,36062,4.7619,1,0,1,1),
+(37032,36165,4.7619,1,0,1,1),
+(37032,36177,4.7619,1,0,1,1),
+(37032,36569,4.7619,1,0,1,1),
+(37032,36681,4.7619,1,0,1,1),
+(37032,43508,4.7619,1,0,1,1),
+(37032,43852,19.7548,1,0,1,1),
+(37032,50452,1,1,0,-50452,1),
+(37033,33367,8.3333,1,0,1,1),
+(37033,33401,1.1719,1,0,1,1),
+(37033,33419,1.1719,1,0,1,1),
+(37033,33422,8.3333,1,0,1,1),
+(37033,33425,1.1719,1,0,1,1),
+(37033,33445,3.6609,1,0,1,1),
+(37033,33447,2.3121,1,0,1,1),
+(37033,33448,1.3487,1,0,1,1),
+(37033,33454,8.6705,1,0,1,1),
+(37033,33470,31.0212,1,0,1,7),
+(37033,36051,1.1719,1,0,1,1),
+(37033,36054,1.5625,1,0,1,1),
+(37033,36066,8.3333,1,0,1,1),
+(37033,36170,1.5414,1,0,1,1),
+(37033,36283,1.1719,1,0,1,1),
+(37033,36396,8.3333,1,0,1,1),
+(37033,36429,8.3333,1,0,1,1),
+(37033,36570,8.3333,1,0,1,1),
+(37033,36682,1.1561,1,0,1,1),
+(37033,37771,8.3333,1,0,1,1),
+(37033,43852,19.8459,1,0,1,1),
+(37033,50452,1,1,0,-50452,1),
+(37034,33369,3.7037,1,0,1,1),
+(37034,33371,3.7037,1,0,1,1),
+(37034,33381,2.4339,1,0,1,1),
+(37034,33384,3.7037,1,0,1,1),
+(37034,33398,3.7037,1,0,1,1),
+(37034,33417,3.7037,1,0,1,1),
+(37034,33422,3.7037,1,0,1,1),
+(37034,33425,1.1696,1,0,1,1),
+(37034,33427,1.1696,1,0,1,1),
+(37034,33429,1.1696,1,0,1,1),
+(37034,33445,2.7513,1,0,1,1),
+(37034,33447,2.6455,1,0,1,1),
+(37034,33454,8.9947,1,0,1,1),
+(37034,33470,30.4762,1,0,1,7),
+(37034,36057,3.7037,1,0,1,1),
+(37034,36163,3.7037,1,0,1,1),
+(37034,36178,3.7037,1,0,1,1),
+(37034,36278,3.7037,1,0,1,1),
+(37034,36287,3.7037,1,0,1,1),
+(37034,36393,3.7037,1,0,1,1),
+(37034,36394,3.7037,1,0,1,1),
+(37034,36429,1.0582,1,0,1,1),
+(37034,36499,3.7037,1,0,1,1),
+(37034,36583,3.7037,1,0,1,1),
+(37034,36681,3.7037,1,0,1,1),
+(37034,36695,3.7037,1,0,1,1),
+(37034,43852,20.4233,1,0,1,1),
+(37034,50452,1,1,0,-50452,1),
+(37035,33365,5.5556,1,0,1,1),
+(37035,33366,5.5556,1,0,1,1),
+(37035,33371,5.5556,1,0,1,1),
+(37035,33380,5.5556,1,0,1,1),
+(37035,33424,1.25,1,0,1,1),
+(37035,33445,4.2188,1,0,1,1),
+(37035,33447,2.6563,1,0,1,1),
+(37035,33448,1.0938,1,0,1,1),
+(37035,33454,7.1875,1,0,1,1),
+(37035,33470,33.4375,1,0,1,7),
+(37035,36175,5.5556,1,0,1,1),
+(37035,36430,1.0938,1,0,1,1),
+(37035,36668,5.5556,1,0,1,1),
+(37035,43852,18.2813,1,0,1,1),
+(37035,50452,1,1,0,-50452,1),
+(37038,33445,3.6501,1,0,1,1),
+(37038,33447,2.2007,1,0,1,1),
+(37038,33470,35.2135,1,0,1,7),
+(37038,35947,7.6631,1,0,1,1),
+(37038,43852,19.6144,1,0,1,1),
+(37038,50452,1,1,0,-50452,1),
+(37098,33422,2.2453,1,0,1,1),
+(37098,33424,1.5544,1,0,1,1),
+(37098,33429,1.8998,1,0,1,1),
+(37098,33430,1.723,1,0,1,1),
+(37098,36443,1.0363,1,0,1,1),
+(37098,45912,1.8998,1,0,1,1),
+(37098,50452,1,1,0,-50452,1),
+(37126,33369,2.1739,1,0,1,1),
+(37126,33371,2.8986,1,0,1,1),
+(37126,33383,1.4493,1,0,1,1),
+(37126,33400,2.1739,1,0,1,1),
+(37126,33401,2.1739,1,0,1,1),
+(37126,33423,2.1739,1,0,1,1),
+(37126,33427,2.1739,1,0,1,1),
+(37126,33428,3.6232,1,0,1,1),
+(37126,33430,2.1739,1,0,1,1),
+(37126,33431,8.3333,1,0,1,1),
+(37126,33433,8.3333,1,0,1,1),
+(37126,36052,1.4493,1,0,1,1),
+(37126,36061,8.3333,1,0,1,1),
+(37126,36063,8.3333,1,0,1,1),
+(37126,36169,2.8986,1,0,1,1),
+(37126,36170,2.1739,1,0,1,1),
+(37126,36175,8.3333,1,0,1,1),
+(37126,36276,1.4493,1,0,1,1),
+(37126,36285,2.1739,1,0,1,1),
+(37126,36388,2.8986,1,0,1,1),
+(37126,36400,1.4493,1,0,1,1),
+(37126,36429,8.3333,1,0,1,1),
+(37126,36430,2.8986,1,0,1,1),
+(37126,36443,8.3333,1,0,1,1),
+(37126,37794,1.4493,1,0,1,1),
+(37144,33383,1.2195,1,0,1,1),
+(37144,33385,4.3478,1,0,1,1),
+(37144,33424,1.2195,1,0,1,1),
+(37144,33431,1.0796,1,0,1,1),
+(37144,33433,4.3478,1,0,1,1),
+(37144,33443,7.6923,1,0,1,1),
+(37144,33445,3.6437,1,0,1,1),
+(37144,33447,2.1592,1,0,1,1),
+(37144,33448,1.2195,1,0,1,1),
+(37144,33470,32.9285,1,0,1,7),
+(37144,36064,4.3478,1,0,1,1),
+(37144,36169,4.3478,1,0,1,1),
+(37144,36176,1.2195,1,0,1,1),
+(37144,36275,4.3478,1,0,1,1),
+(37144,36284,4.3478,1,0,1,1),
+(37144,36429,4.3478,1,0,1,1),
+(37144,36430,1.4634,1,0,1,1),
+(37144,36668,4.3478,1,0,1,1),
+(37144,37761,4.3478,1,0,1,1),
+(37144,43508,4.3478,1,0,1,1),
+(37144,43852,18.0837,1,0,1,1),
+(37144,50452,1,1,0,-50452,1),
+(37146,33412,1.0724,1,0,1,1),
+(37146,33417,1.3405,1,0,1,1),
+(37146,33422,1.0116,1,0,1,1),
+(37146,33424,1.0116,1,0,1,1),
+(37146,33426,1.3006,1,0,1,1),
+(37146,33445,3.9017,1,0,1,1),
+(37146,33447,1.3006,1,0,1,1),
+(37146,33448,1.0116,1,0,1,1),
+(37146,33454,7.2254,1,0,1,1),
+(37146,33470,30.3468,1,0,1,7),
+(37146,36054,1.0724,1,0,1,1),
+(37146,36056,1.0724,1,0,1,1),
+(37146,36058,6.25,1,0,1,1),
+(37146,36061,1.0724,1,0,1,1),
+(37146,36065,1.0724,1,0,1,1),
+(37146,36168,1.0724,1,0,1,1),
+(37146,36277,6.25,1,0,1,1),
+(37146,36281,6.25,1,0,1,1),
+(37146,36286,1.0724,1,0,1,1),
+(37146,36429,1.0724,1,0,1,1),
+(37146,36682,1.0724,1,0,1,1),
+(37146,37093,6.25,1,0,1,1),
+(37146,37097,6.25,1,0,1,1),
+(37146,37824,6.25,1,0,1,1),
+(37146,43467,6.25,1,0,1,1),
+(37146,43852,19.6532,1,0,1,1),
+(37146,50452,1,1,0,-50452,1),
+(37148,33366,4.3478,1,0,1,1),
+(37148,33384,4.3478,1,0,1,1),
+(37148,33427,4.3478,1,0,1,1),
+(37148,33431,1.0221,1,0,1,1),
+(37148,33443,6.644,1,0,1,1),
+(37148,33445,3.7479,1,0,1,1),
+(37148,33447,2.0443,1,0,1,1),
+(37148,33470,30.8348,1,0,1,7),
+(37148,36060,4.3478,1,0,1,1),
+(37148,36066,4.3478,1,0,1,1),
+(37148,36165,4.3478,1,0,1,1),
+(37148,36177,1.0601,1,0,1,1),
+(37148,36275,1.0601,1,0,1,1),
+(37148,36280,1.0601,1,0,1,1),
+(37148,36387,1.0601,1,0,1,1),
+(37148,36390,4.3478,1,0,1,1),
+(37148,36393,1.0601,1,0,1,1),
+(37148,36398,4.3478,1,0,1,1),
+(37148,36443,8.6957,1,0,1,1),
+(37148,36444,1.0601,1,0,1,1),
+(37148,36499,4.3478,1,0,1,1),
+(37148,36681,4.3478,1,0,1,1),
+(37148,36682,8.6957,1,0,1,1),
+(37148,37097,1.0601,1,0,1,1),
+(37148,42173,4.3478,1,0,1,1),
+(37148,43510,4.3478,1,0,1,1),
+(37148,43852,18.3986,1,0,1,1),
+(37148,50452,1,1,0,-50452,1),
+(37149,33403,1.2085,1,0,1,1),
+(37149,33423,1.1382,1,0,1,1),
+(37149,33445,4.7154,1,0,1,1),
+(37149,33447,2.439,1,0,1,1),
+(37149,33454,5.8537,1,0,1,1),
+(37149,33470,33.6585,1,0,1,7),
+(37149,36055,1.2085,1,0,1,1),
+(37149,36170,1.5106,1,0,1,1),
+(37149,36279,10,1,0,1,1),
+(37149,36429,1.1382,1,0,1,1),
+(37149,36681,1.2085,1,0,1,1),
+(37149,43852,18.0488,1,0,1,1),
+(37149,45912,10,1,0,1,1),
+(37149,50452,1,1,0,-50452,1),
+(37217,33426,1.4925,1,0,1,1),
+(37217,33430,1.2793,1,0,1,1),
+(37217,33568,8.8785,1,0,1,16),
+(37217,44128,1.7058,1,0,1,1),
+(37217,50452,5,1,0,-50452,1),
+(37217,52019,32.9907,1,0,1,1),
+(37230,33366,1.4286,1,0,1,1),
+(37230,33380,1.4286,1,0,1,1),
+(37230,33433,1.4286,1,0,1,1),
+(37230,33631,68.1923,1,0,1,3),
+(37230,33632,17.5385,1,0,1,3),
+(37230,36052,1.4286,1,0,1,1),
+(37230,36056,1.4286,1,0,1,1),
+(37230,36061,2.8571,1,0,1,1),
+(37230,36178,1.4286,1,0,1,1),
+(37230,36276,1.4286,1,0,1,1),
+(37230,36281,1.4286,1,0,1,1),
+(37230,36290,1.4286,1,0,1,1),
+(37230,36397,1.4286,1,0,1,1),
+(37230,36402,1.4286,1,0,1,1),
+(37230,36416,1.4286,1,0,1,1),
+(37230,36429,2.8571,1,0,1,1),
+(37230,36457,2.8571,1,0,1,1),
+(37230,36500,1.4286,1,0,1,1),
+(37230,37761,1.4286,1,0,1,1),
+(37230,50452,5,1,0,-50452,1),
+(37531,33427,1.1719,1,0,1,1),
+(37531,33429,1.5625,1,0,1,1),
+(37531,33445,3.5156,1,0,1,1),
+(37531,33447,2.3438,1,0,1,1),
+(37531,33454,5.8594,1,0,1,1),
+(37531,33470,35.3516,1,0,1,7),
+(37531,43852,22.2656,1,0,1,1),
+(37531,50452,1,1,0,-50452,1),
+(37532,33631,74.4811,1,0,1,3),
+(37532,33632,16.9581,1,0,1,3),
+(37532,50452,1,1,0,-50452,1),
+(37544,33381,3.2258,1,0,1,1),
+(37544,33397,1.6393,1,0,1,1),
+(37544,33422,3.2258,1,0,1,1),
+(37544,33427,3.2258,1,0,1,1),
+(37544,33445,4.0573,1,0,1,1),
+(37544,33447,1.9093,1,0,1,1),
+(37544,33448,3.2258,1,0,1,1),
+(37544,33470,38.6635,1,0,1,7),
+(37544,35947,7.1599,1,0,1,1),
+(37544,36054,2.459,1,0,1,1),
+(37544,36061,3.2258,1,0,1,1),
+(37544,36171,3.2258,1,0,1,1),
+(37544,36178,3.2258,1,0,1,1),
+(37544,36279,3.2258,1,0,1,1),
+(37544,36281,3.2258,1,0,1,1),
+(37544,36388,3.2258,1,0,1,1),
+(37544,36390,3.2258,1,0,1,1),
+(37544,36399,3.2258,1,0,1,1),
+(37544,36416,3.2258,1,0,1,1),
+(37544,36429,3.2258,1,0,1,1),
+(37544,36443,3.2258,1,0,1,1),
+(37544,36458,1.6393,1,0,1,1),
+(37544,36485,3.2258,1,0,1,1),
+(37544,36667,3.2258,1,0,1,1),
+(37544,37781,3.2258,1,0,1,1),
+(37544,43510,3.2258,1,0,1,1),
+(37544,43852,21.2411,1,0,1,1),
+(37544,50452,1,1,0,-50452,1),
+(37545,33423,7.1429,1,0,1,1),
+(37545,33425,1.7544,1,0,1,1),
+(37545,33445,3.7681,1,0,1,1),
+(37545,33447,2.029,1,0,1,1),
+(37545,33470,34.2029,1,0,1,7),
+(37545,35947,8.4058,1,0,1,1),
+(37545,36058,7.1429,1,0,1,1),
+(37545,36166,7.1429,1,0,1,1),
+(37545,36168,1.4493,1,0,1,1),
+(37545,36281,7.1429,1,0,1,1),
+(37545,36398,7.1429,1,0,1,1),
+(37545,36472,1.7544,1,0,1,1),
+(37545,36513,7.1429,1,0,1,1),
+(37545,36667,1.7544,1,0,1,1),
+(37545,36681,7.1429,1,0,1,1),
+(37545,43852,19.1304,1,0,1,1),
+(37545,44313,7.1429,1,0,1,1),
+(37545,45912,7.1429,1,0,1,1),
+(37545,50452,2,1,0,-50452,1),
+(37546,33366,1.9417,1,0,1,1),
+(37546,33400,6.6667,1,0,1,1),
+(37546,33413,1.9417,1,0,1,1),
+(37546,33428,6.6667,1,0,1,1),
+(37546,33445,3.7464,1,0,1,1),
+(37546,33447,2.9126,1,0,1,1),
+(37546,33470,40.0576,1,0,1,7),
+(37546,35947,9.5101,1,0,1,1),
+(37546,36055,1.9417,1,0,1,1),
+(37546,36059,1.9417,1,0,1,1),
+(37546,36173,6.6667,1,0,1,1),
+(37546,36279,6.6667,1,0,1,1),
+(37546,36286,6.6667,1,0,1,1),
+(37546,36389,1.9417,1,0,1,1),
+(37546,36430,1.1527,1,0,1,1),
+(37546,36472,6.6667,1,0,1,1),
+(37546,43852,19.8847,1,0,1,1),
+(37571,33445,4.1237,1,0,1,1),
+(37571,33447,2.6044,1,0,1,1),
+(37571,33448,1.5193,1,0,1,1),
+(37571,33470,34.943,1,0,1,7),
+(37571,35947,8.0304,1,0,1,1),
+(37571,43852,21.6495,1,0,1,1),
+(37571,50452,1,1,0,-50452,1),
+(37595,33414,1.5464,1,0,1,1),
+(37595,33426,1.2887,1,0,1,1),
+(37595,33445,4.1741,1,0,1,1),
+(37595,33447,1.2887,1,0,1,1),
+(37595,33470,34.9023,1,0,1,7),
+(37595,35947,9.4139,1,0,1,1),
+(37595,43852,19.0053,1,0,1,1),
+(37595,50452,1,1,0,-50452,1),
+(37662,33445,3.4808,1,0,1,1),
+(37662,33447,1.8879,1,0,1,1),
+(37662,33454,8.7316,1,0,1,1),
+(37662,33470,35.5752,1,0,1,7),
+(37662,43852,18.9971,1,0,1,1),
+(37662,50452,1,1,0,-50452,1),
+(37663,33413,1.6949,1,0,1,1),
+(37663,33445,3.4422,1,0,1,1),
+(37663,33447,1.9417,1,0,1,1),
+(37663,33454,8.3848,1,0,1,1),
+(37663,33470,36.8049,1,0,1,7),
+(37663,36289,1.1299,1,0,1,1),
+(37663,36393,1.6949,1,0,1,1),
+(37663,36681,1.1299,1,0,1,1),
+(37663,37091,1.9417,1,0,1,1),
+(37663,43852,17.917,1,0,1,1),
+(37663,50452,1,1,0,-50452,1),
+(37664,33445,3.8317,1,0,1,1),
+(37664,33448,2.2883,1,0,1,1),
+(37664,33470,35.6875,1,0,1,7),
+(37664,35947,7.2878,1,0,1,1),
+(37664,43852,19.6093,1,0,1,1),
+(37664,50452,1,1,0,-50452,1),
+(37665,33445,3.7631,1,0,1,1),
+(37665,33447,2.269,1,0,1,1),
+(37665,33454,7.803,1,0,1,1),
+(37665,33470,35.0304,1,0,1,7),
+(37665,43852,19.3691,1,0,1,1),
+(37665,50452,1,1,0,-50452,1),
+(37666,33445,3.5755,1,0,1,1),
+(37666,33447,2.0761,1,0,1,1),
+(37666,33448,1.4682,1,0,1,1),
+(37666,33454,8.1892,1,0,1,1),
+(37666,33470,35.3518,1,0,1,7),
+(37666,36430,2.1338,1,0,1,1),
+(37666,43852,17.2434,1,0,1,1),
+(37666,50452,1,1,0,-50452,1),
+(37955,49426,100,1,0,2,2),
+(37955,51384,0,1,1,1,1),
+(37955,51385,0,1,1,1,1),
+(37955,51386,0,1,2,1,1),
+(37955,51387,0,1,1,1,1),
+(37955,51548,0,1,2,1,1),
+(37955,51550,0,1,2,1,1),
+(37955,51551,0,1,1,1,1),
+(37955,51552,0,1,2,1,1),
+(37955,51553,0,1,1,1,1),
+(37955,51554,0,1,1,1,1),
+(37955,51555,0,1,2,1,1),
+(37955,51556,0,1,2,1,1),
+(37970,49426,100,1,0,2,2),
+(37970,51021,0,1,1,1,1),
+(37970,51022,0,1,1,1,1),
+(37970,51023,0,1,1,1,1),
+(37970,51024,0,1,2,1,1),
+(37970,51025,0,1,2,1,1),
+(37970,51325,0,1,1,1,1),
+(37970,51326,0,1,1,1,1),
+(37970,51379,0,1,2,1,1),
+(37970,51380,0,1,2,1,1),
+(37970,51381,0,1,1,1,1),
+(37970,51382,0,1,2,1,1),
+(37970,51383,0,1,2,1,1),
+(38490,33400,1.3889,1,0,1,1),
+(38490,33412,1.3889,1,0,1,1),
+(38490,33414,2.0833,1,0,1,1),
+(38490,33422,1.3889,1,0,1,1),
+(38490,33423,2.7778,1,0,1,1),
+(38490,33424,2.7778,1,0,1,1),
+(38490,33445,3.4722,1,0,1,1),
+(38490,33470,26.3889,1,0,1,7),
+(38490,35947,9.0278,1,0,1,1),
+(38490,36166,2.0833,1,0,1,1),
+(38490,36429,1.3889,1,0,1,1),
+(38490,43852,24.3056,1,0,1,1),
+(38494,33369,1.1628,1,0,1,1),
+(38494,33424,1.1628,1,0,1,1),
+(38494,33431,1.1628,1,0,1,1),
+(38494,33470,20.9302,1,0,1,7),
+(38494,36053,1.1628,1,0,1,1),
+(38494,36056,1.1628,1,0,1,1),
+(38494,36057,1.1628,1,0,1,1),
+(38494,36059,1.1628,1,0,1,1),
+(38494,36063,3.4884,1,0,1,1),
+(38494,36164,1.1628,1,0,1,1),
+(38494,36166,1.1628,1,0,1,1),
+(38494,36388,1.1628,1,0,1,1),
+(38494,36396,1.1628,1,0,1,1),
+(38494,36471,1.1628,1,0,1,1),
+(38494,36696,1.1628,1,0,1,1),
+(38494,37771,1.1628,1,0,1,1),
+(38494,43463,1.1628,1,0,1,1),
+(38494,43508,1.1628,1,0,1,1),
+(38494,43852,25.5814,1,0,1,1),
+(38494,44309,1.1628,1,0,1,1);
diff --git a/sql/All/world_npc_teleport.sql b/sql/All/world_npc_teleport.sql
new file mode 100644
index 0000000..03b9e93
--- /dev/null
+++ b/sql/All/world_npc_teleport.sql
@@ -0,0 +1,119 @@
+DROP TABLE IF EXISTS `custom_npc_tele_category`;
+CREATE TABLE `custom_npc_tele_category` (
+  `id` int(6) unsigned NOT NULL default '0',
+  `name` varchar(255) NOT NULL default '',
+  `flag` tinyint(3) unsigned NOT NULL default '0',
+  `data0` bigint(20) unsigned NOT NULL default '0',
+  `data1` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_destination`;
+CREATE TABLE `custom_npc_tele_destination` (
+  `id` int(6) unsigned NOT NULL auto_increment,
+  `name` char(100) NOT NULL default '',
+  `pos_X` float NOT NULL default '0',
+  `pos_Y` float NOT NULL default '0',
+  `pos_Z` float NOT NULL default '0',
+  `map` smallint(5) unsigned NOT NULL default '0',
+  `orientation` float NOT NULL default '0',
+  `level` tinyint(3) unsigned NOT NULL default '0',
+  `cost` int(10) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_association`;
+CREATE TABLE `custom_npc_tele_association` (
+  `cat_id` int(6) unsigned NOT NULL default '0',
+  `dest_id` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`cat_id`, `dest_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+TRUNCATE `custom_npc_tele_category`;
+INSERT INTO `custom_npc_tele_category`
+   (`id`, `name`, `flag`, `data0`, `data1`)
+VALUES
+   (1, 'Cities', 0, 1, 0),
+   (2, 'Cities', 0, 2, 0),
+   (3, 'Battlegrounds', 0, 1, 0),
+   (4, 'Battlegrounds', 0, 2, 0),
+   (5, 'Arenas', 0, 0, 0),
+   (6, '[Instances Lvl 1-60]', 0, 0, 0),
+   (7, '[Instances Lvl 60+]', 5, 60, 0),
+   (8, '[Instances Lvl 70+]', 5, 70, 0),
+   (9, 'Destinations MJ', 3, 0, 0);
+
+TRUNCATE `custom_npc_tele_destination`;
+INSERT INTO `custom_npc_tele_destination`
+   (`id`, `name`, `pos_X`, `pos_Y`, `pos_Z`, `map`, `orientation`, `level`, `cost`)
+VALUES
+   (1, 'Alterac Valley', 883.187, -489.375, 96.7618, 30, 3.06932, 0, 0),
+   (2, 'Alterac Valley', -818.155, -623.043, 54.0884, 30, 2.1, 0, 0),
+   (3, 'Arathi Basin', 686.053, 683.165, -12.9149, 529, 0.18, 0, 0),
+   (4, 'Arathi Basin', 1308.68, 1306.03, -9.0107, 529, 3.91285, 0, 0),
+   (5, 'Black Temple', -3610.72, 324.988, 37.4, 530, 3.28298, 0, 0),
+   (6, 'Blackfathom Deeps', 4254.58, 664.74, -29.04, 1, 1.97, 0, 0),
+   (7, 'Blackrock Depths', -7301.03, -913.19, 165.37, 0, 0.08, 0, 0),
+   (8, 'Blackrock Spire', -7535.43, -1212.04, 285.45, 0, 5.29, 0, 0),
+   (9, 'Blackwing Lair', -7665.55, -1102.49, 400.679, 469, 0, 0, 0),
+   (10, 'Caverns of Time', -8173.66, -4746.36, 33.8423, 1, 4.93989, 0, 0),
+   (11, 'Circle of Blood', 2839.44, 5930.17, 11.1002, 530, 3.16284, 0, 0),
+   (12, 'Coilfang Reservoir', 517.288, 6976.28, 32.0072, 530, 0, 0, 0),
+   (13, 'Darnassus', 9947.52, 2482.73, 1316.21, 1, 0, 0, 0),
+   (14, 'Dire Maul', -3982.47, 1127.79, 161.02, 1, 0.05, 0, 0),
+   (15, 'Exodar', -4073.03, -12020.4, -1.47, 530, 0, 0, 0),
+   (16, 'Eye of the Storm', 2487.72, 1609.12, 1224.64, 566, 3.35671, 0, 0),
+   (17, 'Eye of the Storm', 1843.73, 1529.77, 1224.43, 566, 0.297579, 0, 0),
+   (18, 'Goldshire', -9464, 62, 56, 0, 0, 0, 0),
+   (19, 'Gruul\'s Lair', 3539.01, 5082.36, 1.69107, 530, 0, 0, 0),
+   (20, 'Gurubashi', -13261.3, 168.294, 35.0792, 0, 1.00688, 0, 0),
+   (21, 'Hellfire Citadel', -305.816, 3056.4, -2.47318, 530, 2.01, 0, 0),
+   (22, 'Ironforge', -4924.07, -951.95, 501.55, 0, 5.4, 0, 0),
+   (23, 'Isle Of Quel\'Danas', 12947.4, -6893.31, 5.68398, 530, 3.09154, 0, 0),
+   (24, 'Karazhan', -11118.8, -2010.84, 47.0807, 0, 0, 0, 0),
+   (25, 'Maraudon', -1433.33, 2955.34, 96.21, 1, 4.82, 0, 0),
+   (26, 'Molten Core', 1121.45, -454.317, -101.33, 230, 3.5, 0, 0),
+   (27, 'Naxxramas', 3125.18, -3748.02, 136.049, 0, 0, 0, 0),
+   (28, 'Onyxia\'s Lair', -4707.44, -3726.82, 54.6723, 1, 3.8, 0, 0),
+   (29, 'Orgrimmar', 1552.5, -4420.66, 8.94802, 1, 0, 0, 0),
+   (30, 'Razor Hill', 315.721, -4743.4, 10.4867, 1, 0, 0, 0),
+   (31, 'Razorfen Downs', -4645.08, -2470.85, 85.53, 1, 4.39, 0, 0),
+   (32, 'Razorfen Kraul', -4484.04, -1739.4, 86.47, 1, 1.23, 0, 0),
+   (33, 'Ring of Trials', -1999.94, 6581.71, 11.32, 530, 2.3, 0, 0),
+   (34, 'Ruins of Ahn\'Qiraj', -8409.03, 1498.83, 27.3615, 1, 2.49757, 0, 0),
+   (35, 'Scholomance', 1219.01, -2604.66, 85.61, 0, 0.5, 0, 0),
+   (36, 'Shadowfang Keep', -254.47, 1524.68, 76.89, 0, 1.56, 0, 0),
+   (37, 'Shattrath City', -1850.21, 5435.82, -10.9614, 530, 3.40391, 0, 0),
+   (38, 'Silvermoon', 9338.74, -7277.27, 13.7895, 530, 0, 0, 0),
+   (39, 'Stormwind', -8960.14, 516.266, 96.3568, 0, 0, 0, 0),
+   (40, 'Stratholme', 3263.54, -3379.46, 143.59, 0, 0, 0, 0),
+   (41, 'Tempest Keep', 3089.58, 1399.05, 187.653, 530, 4.79407, 0, 0),
+   (42, 'Temple of Ahn\'Qiraj', -8245.84, 1983.74, 129.072, 1, 0.936195, 0, 0),
+   (43, 'The Deadmines', -11212, 1658.58, 25.67, 0, 1.45, 0, 0),
+   (44, 'The Maul', -3761.49, 1133.43, 132.083, 1, 4.57259, 0, 0),
+   (45, 'The Scarlet Monastery', 2843.89, -693.74, 139.32, 0, 5.11, 0, 0),
+   (46, 'The Sunken Temple', -10346.9, -3851.9, -43.41, 0, 6.09, 0, 0),
+   (47, 'The Wailing Caverns', -722.53, -2226.3, 16.94, 1, 2.71, 0, 0),
+   (48, 'Thunder Bluff', -1290, 147.034, 129.682, 1, 4.919, 0, 0),
+   (49, 'Uldaman', -6119.7, -2957.3, 204.11, 0, 0.03, 0, 0),
+   (50, 'Undercity', 1819.71, 238.79, 60.5321, 0, 0, 0, 0),
+   (51, 'Warsong Gulch', 930.851, 1431.57, 345.537, 489, 0.015704, 0, 0),
+   (52, 'Warsong Gulch', 1525.95, 1481.66, 352.001, 489, 3.20756, 0, 0),
+   (53, 'Zul\'Aman', 6846.95, -7954.5, 170.028, 530, 4.61501, 0, 0),
+   (54, 'Zul\'Farrak', -6839.39, -2911.03, 8.87, 1, 0.41, 0, 0),
+   (55, 'Zul\'Gurub', -11916.7, -1212.82, 92.2868, 0, 4.6095, 0, 0),
+   (56, 'Ile des MJ', 16254, 16276.9, 14.5082, 1, 1.70269, 0, 0);
+
+TRUNCATE `custom_npc_tele_association`;
+INSERT INTO `custom_npc_tele_association`
+  (`cat_id`, `dest_id`)
+VALUES
+  (1, 13), (1, 15), (1, 18), (1, 22), (1, 23), (1, 37), (1, 39), (2, 23), (2, 29), (2, 30), (2, 37), (2, 38), (2, 48), (2, 50), (3, 1), (3, 4), (3, 16), (3, 52), (4, 2), (4, 3), (4, 17), (4, 51), (5, 11), (5, 20), (5, 33), (5, 44), (6, 6), (6, 7), (6, 8), (6, 14), (6, 25), (6, 31), (6, 32), (6, 35), (6, 36), (6, 40), (6, 43), (6, 45), (6, 46), (6, 47), (6, 49), (6, 54), (7, 9), (7, 26), (7, 27), (7, 28), (7, 34), (7, 42), (7, 55), (8, 5), (8, 10), (8, 12), (8, 19), (8, 21), (8, 24), (8, 41), (8, 53), (9, 56);
+
+-- `npc_text`
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100000, 'Choose your Category.'),
+   (100001, 'Choose your Destination.');
+
+-- `creature_template`
+INSERT INTO `creature_template` VALUES (100000, 0, 0, 0, 0, 0, 26502, 0, 0, 0, 'Abisal Vortex', '', '', 0, 83, 83, 0, 35, 35, 1, 1, 1.14286, 2, 1, 509, 683, 0, 805, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 371, 535, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 'npc_teleport', 1);
diff --git a/sql/All/world_ruby_sanctum.sql b/sql/All/world_ruby_sanctum.sql
new file mode 100644
index 0000000..5be6b0a
--- /dev/null
+++ b/sql/All/world_ruby_sanctum.sql
@@ -0,0 +1,82 @@
+-- -----------------------------------------------------------------------------------------------
+-- ----------------------------------- Dragon Temple Sanctum -------------------------------------
+-- -----------------------------------------------------------------------------------------------
+-- THIS SQL CONTAIN ALL DRAGON TEMPLE SANCTUM SQL NEEDED DATA FOR MYTH CORE.
+-- -------------------------------------------------------------------------
+-- -------------------------- Obsidian Sanctum -----------------------------
+-- -------------------------------------------------------------------------
+
+-- -------------------------------------------------------------------------
+-- ----------------------------- Ruby Sanctum ------------------------------
+-- -------------------------------------------------------------------------
+DELETE FROM `script_texts` WHERE `entry` <= -1752008 AND `entry` >= -1752016;
+DELETE FROM `script_texts` WHERE `entry` <= -1752001 AND `entry` >= -1752006;
+DELETE FROM `script_texts` WHERE `entry` <= -1752017 AND `entry` >= -1752036;
+
+INSERT INTO `script_texts` (`entry`, `content_default`, `npc_entry`, `content_loc3`, `sound`, `type`, `language`) VALUES
+('-1752008', 'Help! I am trapped within this tree! I require aid!', '0', '', '17490', '1', '0'),         
+('-1752009', 'Thank you! I could not have held out for much longer.... A terrible thing has happened here.', '0', '', '17491', '1', '0'),         
+('-1752010', 'We believed the Sanctum was well-fortified, but we were not prepared for the nature of this assault.', '0', '', '17492', '0', '0'),         
+('-1752011', 'The Black dragonkin materialized from thin air, and set upon us before we could react.', '0', '', '17493', '0', '0'),     
+('-1752012', 'We did not stand a chance. As my brethren perished around me, I managed to retreat here and bar the entrance.', '0', '', '17494', '0', '0'),     
+('-1752013', 'They slaughtered us with cold efficiency, but the true focus of their interest seemed to be the eggs kept here in the Sanctum.', '0', '', '17495', '0', '0'),    
+('-1752014', 'The commander of the forces on the ground here is a cruel brute named Zarithrian, but I fear there are greater powers at work.', '0', '', '17496', '0', '0'),    
+('-1752015', 'In their initial assault, I caught a glimpse of their true leader, a fearsome full-grown twilight dragon.', '0', '', '17497', '0', '0'),    
+('-1752016', 'I know not the extent of their plans, heroes, but I know this: They cannot be allowed to succeed!', '0', '', '17498', '0', '0'),
+
+( -1752001, "Ah, the entertainment has arrived.", 0, "", 17520, 1, 0),
+( -1752002, "Baltharus leaves no survivors!", 0, "", 17521, 1, 0),
+( -1752003, "This world has enough heroes.", 0, "", 17522, 1, 0),
+( -1752004, "I..Didn''t saw...that coming...", 0, "", 17523, 1, 0),
+( -1752005, "Twice the pain and half the fun.", 0, "", 17524, 1, 0),
+( -1752006, "Your power wanes, ancient one.... Soon you will join your friends.", 0, "", 17525, 1, 0),
+( -1752017, "Alexstrasza has chosen capable allies... A pity that I must END YOU!", 0, "", 17512, 1, 0),
+( -1752018, "You thought you stood a chance?", 0, "", 17513, 1, 0),
+( -1752019, "It''s for the best.", 0, "", 17514, 1, 0),
+( -1752020, "HALION! I...", 0, "", 17515, 1, 0),
+( -1752021, "Turn them to ashes, minions!", 0, "", 17516, 1, 0),
+( -1752022, "You will sssuffer for this intrusion!", 0, "", 17528, 1, 0),
+( -1752023, "As it should be...", 0, "", 17529, 1, 0),
+( -1752024, "Halion will be pleased", 0, "", 17530, 1, 0),
+( -1752025, "Hhrr...Grr..", 0, "", 17531, 1, 0),
+( -1752026, "Burn in the master's flame!", 0, "", 17532, 1, 0),
+( -1752027, 'Insects! You''re too late. The Ruby Sanctum is lost.',NULL,NULL,17499,0,0),
+( -1752028, 'Your world teeters on the brink of annihilation. You will ALL bear witness to the coming of a new age of DESTRUCTION!',NULL,NULL,17500,0,0),
+( -1752029, 'Another hero falls.',NULL,NULL,17501,0,0),
+( -1752030, 'Hahahahaha.',NULL,NULL,17502,0,0),
+( -1752031, 'Relish this victory, mortals, for it will be your last! This world will burn with the master''s return!',NULL,NULL,17503,0,0),
+( -1752032, 'Not good enough.',NULL,NULL,17504,0,0),
+( -1752033, 'The heavens burn!',NULL,NULL,17505,0,0),
+( -1752034, 'Beware the shadow!',NULL,NULL,17506,0,0),
+( -1752035, 'You will find only suffering within the realm of twilight! Enter if you dare!',NULL,NULL,17507,0,0),
+( -1752036, 'I am the light and the darkness! Cower, mortals, before the herald of Deathwing!',NULL,NULL,17508,0,0);
+
+UPDATE `instance_template` SET `script` = 'instance_ruby_sanctum' WHERE `map` = '724';
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus' WHERE `entry` = '39751';
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus_summon' WHERE `entry` = '39899';
+UPDATE `creature_template` SET `ScriptName` = 'npc_xerestrasza' WHERE `entry` = '40429';
+UPDATE `creature_template` SET `ScriptName` = 'boss_zarithrian' WHERE `entry` = '39746';
+UPDATE `creature_template` SET `ScriptName` = 'boss_ragefire' WHERE `entry` = '39747';
+UPDATE `creature_template` SET `ScriptName` = 'boss_halion' WHERE `entry` =  '39863';
+UPDATE `creature_template` SET `ScriptName` = 'boss_twilight_halion' WHERE `entry` = '40142';
+UPDATE `creature_template` SET `ScriptName` = 'npc_onyx_flamecaller' WHERE `entry` = '39814';
+UPDATE `creature_template` SET `ScriptName` = 'npc_meteor_strike', `flags_extra` = 128 WHERE `entry` = '40041';
+UPDATE `creature_template` SET `ScriptName` = 'npc_meteor_flame', `flags_extra` = 128 WHERE `entry` = '40042';
+UPDATE `creature_template` SET `ScriptName` = 'npc_spell_meteor_strike', `flags_extra` = 128 WHERE `entry` = '40029';
+UPDATE `creature_template` SET `name` = 'summon halion', `ScriptName` = 'npc_summon_halion', `flags_extra` = 128 WHERE `entry` = '40044';
+
+UPDATE `gameobject_template` SET `data10` = 74807 WHERE `entry` = 202794;
+UPDATE `gameobject_template` SET `data10` = 74812 WHERE `entry` = 202796;
+
+DELETE FROM `spell_script_names` WHERE `spell_id` = 74812;
+INSERT INTO `spell_script_names` (`spell_id`, `ScriptName`) VALUES
+('74812','spell_halion_portal');
+
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger` = '-74562') AND (`spell_effect` = '74610');
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger` = '-74792') AND (`spell_effect` = '74800');
+INSERT INTO `spell_linked_spell` VALUES (-74562, 74610, 0, 'Fiery Combustion removed -> Combustion');
+INSERT INTO `spell_linked_spell` VALUES (-74792, 74800, 0, 'Soul Consumption removed -> Consumption');
+
+DELETE FROM `creature` WHERE `id` = 39863 AND `map` = 724;
+INSERT INTO `creature` (`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`DeathState`,`MovementType`)
+VALUES (39863,724,15,1,0,0,3144.93,527.233,72.8887,0.110395,300,0,0,11156000,0,0,0);
\ No newline at end of file
diff --git a/sql/All/world_trinity_string.sql b/sql/All/world_trinity_string.sql
new file mode 100644
index 0000000..d5cc99c
--- /dev/null
+++ b/sql/All/world_trinity_string.sql
@@ -0,0 +1,41 @@
+/* World trinity_string */
+SET NAMES 'utf8';
+DELETE FROM trinity_string WHERE `entry` IN (950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983);
+
+INSERT INTO `trinity_string` VALUES 
+('950', 'You are jailed by \'%s\' for %u hour(s)!', null, 'Vous tes emprisonn par \'%s\' pour %u heures!', 'Du wurdest von \'%s\' für %u Stunde(n) eingebuchtet!', null, null, null, null, null),
+('951', '\'%s\' wrote this as reason: \'%s\'', null, '%s a crit ceci comme tant la raison de votre emprisonnement: %s.', '\'%s\' gab dies als Grund an: \'%s\'', null, null, null, null, null),
+('952', '\'%s\' was jailed by you for %u hour(s).', null, 'Vous avez emprisonn %s pour %u heures!', '\'%s\' wurde von dir für %u Stunde(n) eingebuchtet.', null, null, null, null, null),
+('953', 'You was released out of the jail by %s.', null, 'Vous avez t liber de la prison par %s.', '\'%s\' hat dich aus dem Knast entlassen.', null, null, null, null, null),
+('954', 'You have released %s out of the jail.', null, 'Vous avez liber \'%s\' de la prison.', 'Du hast \'%s\' aus dem Knast geholt.', null, null, null, null, null),
+('955', 'No reason given or reason is < %u chars!', null, 'Aucune raison d\\\'emprisonnement donne ou la raison est < %u personnages.', 'Du hast keinen Grund angegeben, oder der Grund ist < %u Zeichen!', null, null, null, null, null),
+('956', 'No name given!', null, 'Aucun nom donn!', 'Du hast keinen Namen angegeben!', null, null, null, null, null),
+('957', 'No time given!', null, 'Aucun temps donn!', 'Du hast keine Zeit angegeben!', null, null, null, null, null),
+('958', 'The jailtime must be between 1 and %u hours!', null, 'Le temps d\\\'emprisonnement est situ entre 1 et %u heures!', 'Die Jail-Zeit muss zwischen 1 und %u Std. liegen!', null, null, null, null, null),
+('959', 'The character \'%s\' is not jailed!', null, '\'%s\' n\\\'est pas emprisonn!', 'Der Charakter \'%s\' ist Überhaupt nicht im Knast!', null, null, null, null, null),
+('960', 'Command forbidden for jailed characters!', null, 'Commandes interdites pour les personnages emprisons!', 'Sorry, aber das d?rfen Gefangene nicht!', null, null, null, null, null),
+('961', 'You have %u hour(s) left in the jail.', null, 'Vous avez %u heures  attendre avant de quitter la prison.', 'Du musst noch %u Stunde(n) absitzen.', null, null, null, null, null),
+('962', 'You have %u minute(s) left in the jail.', null, 'Vous avez %u minutes attendre avant de quitter la prison.', 'Du musst noch %u Minute(n) absitzen.', null, null, null, null, null),
+('963', 'You\'re a free like a bird! ;-)', null, 'Vous tes libre.', 'Du bist frei wie ein Vogel! ;-)', null, null, null, null, null),
+('964', '%s was %u times jailed and has %u minute(s) left. Last time jailed by %s. Last reason was: \'%s\'', null, '%s a t librde prison, il avait t emprisonn pour %u et a t libr au aprs %u minutes. Il avait t emprisonn par %s, pour la raison suivante: %s', '\'%s\' war bis jetzt %u mal im Knast, und hat noch %u Minute(n) abzusitzen.\n Zuletzt eingebuchtet von: \'%s\'\nLetzter Grund: %s', null, null, null, null, null),
+('965', '\'%s\' was never jailed.', null, '\'%s\' n\\\'a jamais t emprisonn.', '\'%s\' hat eine weiße Weste.', null, null, null, null, null),
+('966', 'You can\'t jail yourself!', null, 'Vous ne pouvez pas vous emprisonner vous-m me!', 'Du kannst dich nicht selber einbuchten!', null, null, null, null, null),
+('967', 'You can\'t unjail yourself!', null, 'Vous ne pouvez pas vous librer vous m me!', 'So weit kommt es noch, daß Knastbruder sich selber befreien! :-(', null, null, null, null, null),
+('968', '|cffff0000[!!! ATTENTION - IMPORTANT - WARNING !!!\r\n You were already %u times in prison. If you are in Jail for a total of  %u times, your character will be deleted\r\n|cffff0000!!! ATTENTION - IMPORTANT - WARNING !!!]', null, '|cffff0000[!!!ATTENTION - ATTENTION - ATTENTION!!!\r\n Vous étiez déjà %u fois en prison en %u fois, votre personnage supprimé\r\n|cffff0000!!! ATTENTION - ATTENTION - ATTENTION !!!]', '|cffff0000[!!! ACHTUNG - WICHTIG - WARNUNG !!!\r\n Du warst schon %u mal in Knast beim %u mal wird dein Charakter gelöscht\r\n|cffff0000!!! ACHTUNG - WICHTIG - WARNUNG !!!]', null, null, null, null, null),
+('969', 'The character \'', null, 'Le personnage ', 'Der Charakter \'', null, null, null, null, null),
+('970', '\' was jailed for ', null, ' a t emprisonn pour ', '\' wurde für ', null, null, null, null, null),
+('971', ' hour(s) by the GM character \'', null, ' heure(s) par le MJ ', ' Stunde(n) von dem GM-Charakter \'', null, null, null, null, null),
+('972', '\'. The reason is: ', null, '. La raison est: ', '\' eingebuchtet. Der Grund ist: ', null, null, null, null, null),
+('973', 'The jail configuration was reloaded.', null, 'La configuration de jail a t recharge.', 'Die Gefängnis-Konfiguration wurde neu geladen.', null, null, null, null, null),
+('974', '>> Trinity Jail config loaded.', null, '>> Configuration du jail charge.', '>> Gefängnis-Konfiguration geladen.', null, null, null, null, null),
+('975', 'Can\'t load jail config! Table empty or missed! Use characters_jail.sql!', null, 'Impossible de charger la configuration du jail! Table vide ou innexistante! Appliquez characters_jail.sql!', 'Fehler beim laden der Gef?ngnis-Konfiguration! Der Table \'jail_conf\' ist leer oder nicht vorhanden! Nutze die \'characters_jail.sql\'!', null, null, null, null, null),
+('976', 'Set all jail config settings to default...', null, 'Placez tous les param tres de configuration de prison par d faut.', 'Setze die Konfiguration des Gef?ngnisses auf Standardwerte...', null, null, null, null, null),
+('977', 'The Character \'%s\'  is jailed and teleportet into the jail.', null, 'Le personnage \'%s\'  est emprisonn et t leport dans la prison.', 'Der Charakter \'%s\'  ist ein Knastbruder und wird in den Knast teleportiert.', null, null, null, null, null),
+('978', 'The Character \'%s\'  was released out of the jail.', null, 'Le personnage %s  est liber  de prison.', 'Der Charakter \'%s\'  wurde aus dem Knast entlassen.', null, null, null, null, null),
+('979', 'A character with this name doesn\'t exists!', null, 'Il n\'y a aucun personnage portant ce nom.', 'Ein Charakter mit diesem Namen gibt es nicht!', null, null, null, null, null),
+('980', '|cffff0000[!!! ATTENTION - IMPORTANT - WARNING !!!\r\n You were already %u times in prison. If you are in Jail for a total of  %u times, your account  will be banned!\r\n|cffff0000!!! ATTENTION - IMPORTANT - WARNING !!!]', null, '|cffff0000[!!!ATTENTION - ATTENTION - ATTENTION!!!\r\n Vous avez %u fois en prison en %u fois votre compte sera banni\r\n|cffff0000!!! ATTENTION - ATTENTION - ATTENTION !!!]', '|cffff0000[!!! ACHTUNG - WICHTIG - WARNUNG !!!\r\n Du hast %u mal in Knast beim %u mal wird dein Account gebannt\r\n|cffff0000!!! ACHTUNG - WICHTIG - WARNUNG !!!]', null, null, null, null, null),
+('981', 'Max. jailtimes reached!', null, 'Nombre maximum d\'Jails atteint!', 'Maximale Anzahl an Jails erreicht!', null, null, null, null, null),
+('982', 'Robotron', null, 'Robotron', 'Robotron', null, null, null, null, null),
+('983', 'Your Jail status was reset to 0 ', null, 'Votre statut a été Jail à 0 ', 'Dein Jail status wurde auf 0 zurück gesatzt', null, null, null, null, null);
+
+
diff --git a/sql/All/world_wintergrasp.sql b/sql/All/world_wintergrasp.sql
new file mode 100644
index 0000000..81b818e
--- /dev/null
+++ b/sql/All/world_wintergrasp.sql
@@ -0,0 +1,132 @@
+/*NOTE! Included Cyrillic Fonts - open it in UTF8 coding*/
+
+SET NAMES 'utf8';
+
+DELETE FROM `trinity_string` WHERE entry IN (756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,780,781,782,783);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES
+('756', 'Battle begins!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¸ÑÐ²Ð° Ð½Ð°ÑÐ°Ð»Ð°ÑÑ'),
+('757', '%s has successfully defended the fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s ÑÑÐ¿ÐµÑÐ½Ð¾ Ð·Ð°ÑÐ¸ÑÐ¸Ð»(Ð°) ÐºÑÐµÐ¿Ð¾ÑÑÑ!'),
+('758', '%s has taken over the fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s Ð·Ð°ÑÐ²Ð°ÑÐ¸Ð»(Ð°) ÐºÑÐµÐ¿Ð¾ÑÑÑ'),
+('759', 'The %s siege workshop has been damaged by the %s!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('760', 'The %s siege workshop has been destroyed by the %s!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('761', 'The %s tower has been damaged!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s Ð±Ð°ÑÐ½Ñ Ð¿Ð¾Ð²ÑÐµÐ¶Ð´ÐµÐ½Ð°'),
+('762', 'The %s tower has been destroyed!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s Ð±Ð°ÑÐ½Ñ ÑÐ½Ð¸ÑÑÐ¾Ð¶ÐµÐ½Ð°!'),
+('763', 'Wintergrasp fortress is under attack!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('764', 'Wintergrasp is now under the control of the %s.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('765', 'Wintergrasp timer set to %s.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('766', 'Wintergrasp battle started.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('767', 'Wintergrasp battle finished.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('768', 'Wintergrasp info: %s controlled. Timer: %s. Wartime: %s. Number of Players: (Horde: %u, Alliance: %u)', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('769', 'Wintergrasp outdoorPvP is disabled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('770', 'Wintergrasp outdoorPvP is enabled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('771', 'You have reached Rank 1: Corporal', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÑ Ð´Ð¾ÑÑÐ¸Ð³Ð»Ð¸ Ð Ð°Ð½Ð³Ð° 1: ÐÐ°Ð¿ÑÐ°Ð»'),
+('772', 'You have reached Rank 2: First Lieutenant', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÑ Ð´Ð¾ÑÑÐ¸Ð³Ð»Ð¸ Ð Ð°Ð½Ð³Ð° 2: ÐÐµÐ¹ÑÐµÐ½Ð°Ð½Ñ'),
+('780', 'Before the Battle of  Wintergrasp left 30 minutes!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¾ Ð±Ð¸ÑÐ²Ñ Ð½Ð°  ÐÐ·ÐµÑÐµ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² Ð¾ÑÑÐ°Ð»Ð¾ÑÑ 30 Ð¼Ð¸Ð½ÑÑ!'),
+('781', 'Before the Battle of  Wintergrasp left 10 minutes! Portal from Dalaran will work in 5 minutes.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¾ Ð±Ð¸ÑÐ²Ñ Ð½Ð°  ÐÐ·ÐµÑÐµ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² Ð¾ÑÑÐ°Ð»Ð¾ÑÑ 10 Ð¼Ð¸Ð½ÑÑ! ÐÐ¾ÑÑÐ°Ð» Ñ ÐÐ°Ð»Ð°ÑÐ°Ð½Ð° Ð½Ð°ÑÐ½ÐµÑ ÑÐ¾Ð±Ð¾ÑÑ ÑÐµÑÐµÐ· 5 Ð¼Ð¸Ð½ÑÑ.'),
+('782', 'The battle for Wintergrasp  has stopped! Not enough defenders. Wintergrasp Fortress remains  Attackers.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¸ÑÐ²Ð° Ð·Ð° ÐÐ·ÐµÑÐ¾ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² ÐÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð°. ÐÐµ ÑÐ²Ð°ÑÐ°ÐµÑ Ð·Ð°ÑÐ¸ÑÐ½Ð¸ÐºÐ¾Ð². ÐÑÐµÐ¿Ð¾ÑÑÑ Ð¿ÐµÑÐµÑÐ¾Ð´Ð¸Ñ Ð°ÑÐ°ÐºÑÑÑÐµÐ¹  ÑÑÐ¾ÑÐ¾Ð½Ðµ.'),
+('783', 'The battle for Wintergrasp  has stopped! Not enough attackers. Wintergrasp Fortress remains  Defenders.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¸ÑÐ²Ð° Ð·Ð° ÐÐ·ÐµÑÐ¾ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² ÐÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð°. ÐÐµ ÑÐ²Ð°ÑÐ°ÐµÑ Ð½Ð°Ð¿Ð°Ð´Ð°ÑÑÐ¸Ñ. ÐÑÐµÐ¿Ð¾ÑÑÑ Ð¾ÑÑÐ°ÐµÑÑÑ Ð·Ð°ÑÐ¸ÑÐ½Ð¸ÐºÐ°Ð¼.');
+
+DELETE FROM `command` WHERE name IN ('wg','wg enable','wg start','wg status','wg stop','wg switch','wg timer');
+INSERT INTO `command` (`name`, `security`, `help`) VALUES
+('wg', '3', 'Syntax: .wg $subcommand.'),
+('wg enable', '3', 'Syntax: .wg enable [on/off] Enable/Disable Wintergrasp outdoorPvP.'),
+('wg start', '3', 'Syntax: .wg start\r\nForce Wintergrasp battle start.'),
+('wg status', '3', 'Syntax: .wg status\r\nWintergrasp info, defender, timer, wartime.'),
+('wg stop', '3', 'Syntax: .wg stop\r\nForce Wintergrasp battle stop (No rewards).'),
+('wg switch', '3', 'Syntax: .wg switch\r\nSwitchs Wintergrasp defender team.'),
+('wg timer', '3', 'Syntax: .wg timer $minutes\r\nChange the current timer. Min value = 1, Max value 60 (Wartime), 1440 (Not Wartime)');
+
+/* WG scriptname */
+DELETE FROM `outdoorpvp_template` WHERE TypeId=7;
+INSERT INTO `outdoorpvp_template` (`TypeId`, `ScriptName`, `comment`) VALUES 
+('7', 'outdoorpvp_wg', 'Wintergrasp');
+
+UPDATE `creature_template` SET `ScriptName` = 'npc_demolisher_engineerer' WHERE `entry` IN (30400,30499);
+
+/* Teleport WG SPELLs*/
+DELETE FROM `spell_target_position` WHERE id IN ('59096', '58632', '58633');
+INSERT INTO `spell_target_position` (`id`, `target_map`, `target_position_x`, `target_position_y`, `target_position_z`, `target_orientation`) VALUES
+('59096', '571', '5325.06', '2843.36', '409.285', '3.20278'),
+('58632', '571', '5097.79', '2180.29', '365.61', '2.41'),
+('58633', '571', '5026.80', '3676.69', '362.58', '3.94');
+
+/* Defender's Portal Activate Proper Spell */
+DELETE FROM `spell_linked_spell` WHERE spell_trigger=54640;
+INSERT INTO `spell_linked_spell` (`spell_trigger`, `spell_effect`, `type`, `comment`) VALUES 
+('54640','54643','0','Defender\'s Portal Activate Proper Spell');
+
+/* Temp removed gameobject stopping you getting to the relic
+* 194323 - [Wintergrasp Keep Collision Wall X:5396.209961 Y:2840.010010 Z:432.268005 MapId:571
+* 194162 - [Doodad_WG_Keep_Door01_collision01 X:5397.109863 Y:2841.540039 Z:425.901001 MapId:571]*/
+DELETE FROM gameobject WHERE id IN ('194323', '194162');
+
+/* Titan Relic remove */
+DELETE FROM `gameobject` WHERE `id`=192829;
+
+/* Towers */
+UPDATE `gameobject_template` SET `faction` = 0, `flags` = 6553632 WHERE `entry` IN (190356,190357,190358);
+
+/*Spirit healer FIX */
+UPDATE creature_template SET npcflag=npcflag|32768 WHERE entry IN (31841,31842);
+
+/* Creature template */
+UPDATE creature_template SET faction_A = '1802', faction_H = '1802' WHERE entry IN (30499,28312,28319);
+UPDATE creature_template SET faction_A = '1801', faction_H = '1801' WHERE entry IN (30400,32629,32627);
+UPDATE creature_template SET npcflag=npcflag|32768 WHERE entry   IN (31841,31842);
+
+/* spell target for build vehicles */
+DELETE FROM `conditions` WHERE ConditionValue2=27852;
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`, `SourceGroup`, `SourceEntry`, `ElseGroup`, `ConditionTypeOrReference`, `ConditionValue1`, `ConditionValue2`, `ConditionValue3`, `ErrorTextId`, `ScriptName`, `Comment`) VALUES
+(13, 0, 49899, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56575, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56661, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56663, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56665, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56667, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56669, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 61408, 0, 18, 1, 27852, 0, 0, '', NULL);
+
+/* Workshop */
+UPDATE `gameobject_template` SET `faction` = 35 WHERE `entry` IN (192028,192029,192030,192031,192032,192033);
+
+/*WG Spell area Data */
+/*For wg antifly */
+DELETE FROM `spell_area` WHERE spell IN (58730, 57940, 58045);
+INSERT INTO `spell_area` (`spell`, `area`, `quest_start`, `quest_start_active`, `quest_end`, `aura_spell`, `racemask`, `gender`, `autocast`) VALUES
+(58730, 4197, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4584, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4581, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4585, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4612, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4582, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4611, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4578, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4576, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4538, 0, 0, 0, 0, 0, 2, 1),
+(57940, 65, 0, 0, 0, 0, 0, 2, 1),
+(57940, 66, 0, 0, 0, 0, 0, 2, 1),
+(57940, 67, 0, 0, 0, 0, 0, 2, 1),
+(57940, 206, 0, 0, 0, 0, 0, 2, 1),
+(57940, 210, 0, 0, 0, 0, 0, 2, 1),
+(57940, 394, 0, 0, 0, 0, 0, 2, 1),
+(57940, 395, 0, 0, 0, 0, 0, 2, 1),
+(57940, 1196, 0, 0, 0, 0, 0, 2, 1),
+(57940, 2817, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3456, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3477, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3537, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3711, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4100, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4196, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4228, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4264, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4265, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4272, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4273, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4395, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4415, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4416, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4493, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4494, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4603, 0, 0, 0, 0, 0, 2, 1),
+(58045, 4197, 0, 0, 0, 0, 0, 2, 1);
\ No newline at end of file
diff --git a/sql/CMakeLists.txt b/sql/CMakeLists.txt
index e1b0921..4562748 100644
--- a/sql/CMakeLists.txt
+++ b/sql/CMakeLists.txt
@@ -15,6 +15,7 @@ if( WITH_SQL )
       scripts
       base
       create
+	  All
     DESTINATION
       shared/trinity/sql
   )
diff --git a/sql/Wintergrasp_world.sql b/sql/Wintergrasp_world.sql
new file mode 100644
index 0000000..81b818e
--- /dev/null
+++ b/sql/Wintergrasp_world.sql
@@ -0,0 +1,132 @@
+/*NOTE! Included Cyrillic Fonts - open it in UTF8 coding*/
+
+SET NAMES 'utf8';
+
+DELETE FROM `trinity_string` WHERE entry IN (756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,780,781,782,783);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES
+('756', 'Battle begins!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¸ÑÐ²Ð° Ð½Ð°ÑÐ°Ð»Ð°ÑÑ'),
+('757', '%s has successfully defended the fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s ÑÑÐ¿ÐµÑÐ½Ð¾ Ð·Ð°ÑÐ¸ÑÐ¸Ð»(Ð°) ÐºÑÐµÐ¿Ð¾ÑÑÑ!'),
+('758', '%s has taken over the fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s Ð·Ð°ÑÐ²Ð°ÑÐ¸Ð»(Ð°) ÐºÑÐµÐ¿Ð¾ÑÑÑ'),
+('759', 'The %s siege workshop has been damaged by the %s!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('760', 'The %s siege workshop has been destroyed by the %s!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('761', 'The %s tower has been damaged!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s Ð±Ð°ÑÐ½Ñ Ð¿Ð¾Ð²ÑÐµÐ¶Ð´ÐµÐ½Ð°'),
+('762', 'The %s tower has been destroyed!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s Ð±Ð°ÑÐ½Ñ ÑÐ½Ð¸ÑÑÐ¾Ð¶ÐµÐ½Ð°!'),
+('763', 'Wintergrasp fortress is under attack!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('764', 'Wintergrasp is now under the control of the %s.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('765', 'Wintergrasp timer set to %s.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('766', 'Wintergrasp battle started.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('767', 'Wintergrasp battle finished.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('768', 'Wintergrasp info: %s controlled. Timer: %s. Wartime: %s. Number of Players: (Horde: %u, Alliance: %u)', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('769', 'Wintergrasp outdoorPvP is disabled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('770', 'Wintergrasp outdoorPvP is enabled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('771', 'You have reached Rank 1: Corporal', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÑ Ð´Ð¾ÑÑÐ¸Ð³Ð»Ð¸ Ð Ð°Ð½Ð³Ð° 1: ÐÐ°Ð¿ÑÐ°Ð»'),
+('772', 'You have reached Rank 2: First Lieutenant', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÑ Ð´Ð¾ÑÑÐ¸Ð³Ð»Ð¸ Ð Ð°Ð½Ð³Ð° 2: ÐÐµÐ¹ÑÐµÐ½Ð°Ð½Ñ'),
+('780', 'Before the Battle of  Wintergrasp left 30 minutes!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¾ Ð±Ð¸ÑÐ²Ñ Ð½Ð°  ÐÐ·ÐµÑÐµ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² Ð¾ÑÑÐ°Ð»Ð¾ÑÑ 30 Ð¼Ð¸Ð½ÑÑ!'),
+('781', 'Before the Battle of  Wintergrasp left 10 minutes! Portal from Dalaran will work in 5 minutes.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¾ Ð±Ð¸ÑÐ²Ñ Ð½Ð°  ÐÐ·ÐµÑÐµ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² Ð¾ÑÑÐ°Ð»Ð¾ÑÑ 10 Ð¼Ð¸Ð½ÑÑ! ÐÐ¾ÑÑÐ°Ð» Ñ ÐÐ°Ð»Ð°ÑÐ°Ð½Ð° Ð½Ð°ÑÐ½ÐµÑ ÑÐ¾Ð±Ð¾ÑÑ ÑÐµÑÐµÐ· 5 Ð¼Ð¸Ð½ÑÑ.'),
+('782', 'The battle for Wintergrasp  has stopped! Not enough defenders. Wintergrasp Fortress remains  Attackers.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¸ÑÐ²Ð° Ð·Ð° ÐÐ·ÐµÑÐ¾ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² ÐÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð°. ÐÐµ ÑÐ²Ð°ÑÐ°ÐµÑ Ð·Ð°ÑÐ¸ÑÐ½Ð¸ÐºÐ¾Ð². ÐÑÐµÐ¿Ð¾ÑÑÑ Ð¿ÐµÑÐµÑÐ¾Ð´Ð¸Ñ Ð°ÑÐ°ÐºÑÑÑÐµÐ¹  ÑÑÐ¾ÑÐ¾Ð½Ðµ.'),
+('783', 'The battle for Wintergrasp  has stopped! Not enough attackers. Wintergrasp Fortress remains  Defenders.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'ÐÐ¸ÑÐ²Ð° Ð·Ð° ÐÐ·ÐµÑÐ¾ ÐÐµÐ´ÑÐ½ÑÑ ÐÐºÐ¾Ð² ÐÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð°. ÐÐµ ÑÐ²Ð°ÑÐ°ÐµÑ Ð½Ð°Ð¿Ð°Ð´Ð°ÑÑÐ¸Ñ. ÐÑÐµÐ¿Ð¾ÑÑÑ Ð¾ÑÑÐ°ÐµÑÑÑ Ð·Ð°ÑÐ¸ÑÐ½Ð¸ÐºÐ°Ð¼.');
+
+DELETE FROM `command` WHERE name IN ('wg','wg enable','wg start','wg status','wg stop','wg switch','wg timer');
+INSERT INTO `command` (`name`, `security`, `help`) VALUES
+('wg', '3', 'Syntax: .wg $subcommand.'),
+('wg enable', '3', 'Syntax: .wg enable [on/off] Enable/Disable Wintergrasp outdoorPvP.'),
+('wg start', '3', 'Syntax: .wg start\r\nForce Wintergrasp battle start.'),
+('wg status', '3', 'Syntax: .wg status\r\nWintergrasp info, defender, timer, wartime.'),
+('wg stop', '3', 'Syntax: .wg stop\r\nForce Wintergrasp battle stop (No rewards).'),
+('wg switch', '3', 'Syntax: .wg switch\r\nSwitchs Wintergrasp defender team.'),
+('wg timer', '3', 'Syntax: .wg timer $minutes\r\nChange the current timer. Min value = 1, Max value 60 (Wartime), 1440 (Not Wartime)');
+
+/* WG scriptname */
+DELETE FROM `outdoorpvp_template` WHERE TypeId=7;
+INSERT INTO `outdoorpvp_template` (`TypeId`, `ScriptName`, `comment`) VALUES 
+('7', 'outdoorpvp_wg', 'Wintergrasp');
+
+UPDATE `creature_template` SET `ScriptName` = 'npc_demolisher_engineerer' WHERE `entry` IN (30400,30499);
+
+/* Teleport WG SPELLs*/
+DELETE FROM `spell_target_position` WHERE id IN ('59096', '58632', '58633');
+INSERT INTO `spell_target_position` (`id`, `target_map`, `target_position_x`, `target_position_y`, `target_position_z`, `target_orientation`) VALUES
+('59096', '571', '5325.06', '2843.36', '409.285', '3.20278'),
+('58632', '571', '5097.79', '2180.29', '365.61', '2.41'),
+('58633', '571', '5026.80', '3676.69', '362.58', '3.94');
+
+/* Defender's Portal Activate Proper Spell */
+DELETE FROM `spell_linked_spell` WHERE spell_trigger=54640;
+INSERT INTO `spell_linked_spell` (`spell_trigger`, `spell_effect`, `type`, `comment`) VALUES 
+('54640','54643','0','Defender\'s Portal Activate Proper Spell');
+
+/* Temp removed gameobject stopping you getting to the relic
+* 194323 - [Wintergrasp Keep Collision Wall X:5396.209961 Y:2840.010010 Z:432.268005 MapId:571
+* 194162 - [Doodad_WG_Keep_Door01_collision01 X:5397.109863 Y:2841.540039 Z:425.901001 MapId:571]*/
+DELETE FROM gameobject WHERE id IN ('194323', '194162');
+
+/* Titan Relic remove */
+DELETE FROM `gameobject` WHERE `id`=192829;
+
+/* Towers */
+UPDATE `gameobject_template` SET `faction` = 0, `flags` = 6553632 WHERE `entry` IN (190356,190357,190358);
+
+/*Spirit healer FIX */
+UPDATE creature_template SET npcflag=npcflag|32768 WHERE entry IN (31841,31842);
+
+/* Creature template */
+UPDATE creature_template SET faction_A = '1802', faction_H = '1802' WHERE entry IN (30499,28312,28319);
+UPDATE creature_template SET faction_A = '1801', faction_H = '1801' WHERE entry IN (30400,32629,32627);
+UPDATE creature_template SET npcflag=npcflag|32768 WHERE entry   IN (31841,31842);
+
+/* spell target for build vehicles */
+DELETE FROM `conditions` WHERE ConditionValue2=27852;
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`, `SourceGroup`, `SourceEntry`, `ElseGroup`, `ConditionTypeOrReference`, `ConditionValue1`, `ConditionValue2`, `ConditionValue3`, `ErrorTextId`, `ScriptName`, `Comment`) VALUES
+(13, 0, 49899, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56575, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56661, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56663, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56665, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56667, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56669, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 61408, 0, 18, 1, 27852, 0, 0, '', NULL);
+
+/* Workshop */
+UPDATE `gameobject_template` SET `faction` = 35 WHERE `entry` IN (192028,192029,192030,192031,192032,192033);
+
+/*WG Spell area Data */
+/*For wg antifly */
+DELETE FROM `spell_area` WHERE spell IN (58730, 57940, 58045);
+INSERT INTO `spell_area` (`spell`, `area`, `quest_start`, `quest_start_active`, `quest_end`, `aura_spell`, `racemask`, `gender`, `autocast`) VALUES
+(58730, 4197, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4584, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4581, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4585, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4612, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4582, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4611, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4578, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4576, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4538, 0, 0, 0, 0, 0, 2, 1),
+(57940, 65, 0, 0, 0, 0, 0, 2, 1),
+(57940, 66, 0, 0, 0, 0, 0, 2, 1),
+(57940, 67, 0, 0, 0, 0, 0, 2, 1),
+(57940, 206, 0, 0, 0, 0, 0, 2, 1),
+(57940, 210, 0, 0, 0, 0, 0, 2, 1),
+(57940, 394, 0, 0, 0, 0, 0, 2, 1),
+(57940, 395, 0, 0, 0, 0, 0, 2, 1),
+(57940, 1196, 0, 0, 0, 0, 0, 2, 1),
+(57940, 2817, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3456, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3477, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3537, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3711, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4100, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4196, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4228, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4264, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4265, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4272, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4273, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4395, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4415, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4416, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4493, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4494, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4603, 0, 0, 0, 0, 0, 2, 1),
+(58045, 4197, 0, 0, 0, 0, 0, 2, 1);
\ No newline at end of file
diff --git a/src/server/authserver/Server/AuthSocket.cpp b/src/server/authserver/Server/AuthSocket.cpp
index 0b7a49f..21a4fe5 100755
--- a/src/server/authserver/Server/AuthSocket.cpp
+++ b/src/server/authserver/Server/AuthSocket.cpp
@@ -349,6 +349,9 @@ bool AuthSocket::_HandleLogonChallenge()
     // Verify that this IP is not in the ip_banned table
     LoginDatabase.Execute(LoginDatabase.GetPreparedStatement(LOGIN_SET_EXPIREDIPBANS));
 
+    LoginDatabase.Execute(
+        LoginDatabase.GetPreparedStatement(LOGIN_SET_ACCOUNT_PREMIUM)
+            );
     const std::string& ip_address = socket().get_remote_address();
     PreparedStatement *stmt = LoginDatabase.GetPreparedStatement(LOGIN_GET_IPBANNED);
     stmt->setString(0, ip_address);
diff --git a/src/server/game/AI/Bots/PlayerbotAI.cpp b/src/server/game/AI/Bots/PlayerbotAI.cpp
new file mode 100644
index 0000000..f171b21
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotAI.cpp
@@ -0,0 +1,4387 @@
+#include "Common.h"
+#include "Database/DatabaseEnv.h"
+#include "DBCStores.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotPriestAI.h"
+#include "PlayerbotWarriorAI.h"
+#include "PlayerbotShamanAI.h"
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotMageAI.h"
+#include "PlayerbotDruidAI.h"
+#include "PlayerbotWarlockAI.h"
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotDeathKnightAI.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Chat.h"
+#include "WorldPacket.h"
+#include "Spell.h"
+#include "Unit.h"
+#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+#include "SharedDefines.h"
+#include "GossipDef.h"
+#include "Config.h"
+#include "Group.h"
+#include <ctime>
+
+
+
+/*
+* Packets often compress the GUID (global unique identifier)
+* This function extracts the guid from the packet and decompresses it.
+* The first word (8 bits) in the packet represents how many words in the following packet(s) are part of
+* the guid and what weight they hold. I call it the mask. For example) if mask is 01001001,
+* there will be only 3 words. The first word is shifted to the left 0 times,
+* the second is shifted 3 times, and the third is shifted 6.
+*/
+uint64 extractGuid(WorldPacket &packet)
+{
+    uint8 mask; packet >> mask;
+    uint64 guid = 0;
+    uint8 bit = 0;
+    uint8 testMask = 1;
+    while(true)
+    {
+        if(mask & testMask)
+        {
+            uint8 word; packet >> word;
+            guid += (word << bit);
+        }
+        if(bit == 7) break;
+        ++bit;
+        testMask <<= 1;
+    }
+    return guid;
+}
+
+//ChatHandler already implements some useful commands the master can call on bots
+//These commands are protected inside the ChatHandler class so this class provides access to the commands
+//we'd like to call on our bots
+class PlayerbotChatHandler : protected ChatHandler
+{
+    public:
+        explicit PlayerbotChatHandler(Player *pMasterPlayer) : ChatHandler(pMasterPlayer){}
+
+        bool revive(const Player &botPlayer){ return HandleReviveCommand(botPlayer.GetName()); }
+        bool teleport(const Player &botPlayer){ return HandleSummonCommand(botPlayer.GetName()); }
+        bool teleport(Player &botPlayer, const WorldLocation &loc){ return botPlayer.TeleportTo(loc,TELE_TO_GM_MODE); }
+        bool uninvite(const char *str){ return HandlePlayerbotCommand(str); }
+        void sysmessage(const char *str){ SendSysMessage(str); }
+        bool acceptQuest(const char *str){ return HandleQuestAdd(str); }
+        bool abandonQuest(const char *str) { return HandleQuestRemove(str); }
+};
+
+PlayerbotAI::PlayerbotAI(Player *const master, Player *const bot): m_master(master), m_bot(bot),
+m_ignoreAIUpdatesUntilTime(0), m_combatOrder(ORDERS_NONE), m_ScenarioType(SCENARIO_PVEEASY),
+m_TimeDoneEating(0), m_TimeDoneDrinking(0), m_CurrentlyCastingSpellId(0), m_IsFollowingMaster(true),
+m_spellIdCommand(0), m_targetGuidCommand(0), m_classAI(0), isLooting(false), m_TimeRessurect(0),
+m_FeastSpamTimer(0)
+{
+
+    //If the player have a group, it's possible to add the bot.
+    if(master->GetGroup())
+    {
+        Group *m_group = master->GetGroup();
+        bool inGroup = false;
+        Group::MemberSlotList members = m_group->GetMemberSlots();
+
+        if(!m_group->IsFull() ||
+            m_group->IsMember(bot->GetGUID()) )
+        {
+            //check that bot is not already in the group, ie from a server crash
+            Group::MemberSlotList const &groupSlot = master->GetGroup()->GetMemberSlots();
+            for(Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+            {
+                Player *tPlayer = master->GetObjPlayer(itr->guid);
+                if(itr->guid == bot->GetGUID()) inGroup = true;
+            }
+            if(!inGroup) m_group->AddMember(bot->GetGUID(), bot->GetName());
+        } else {
+            //group is full so can't add bot
+            bot->Say("Group is full!", LANG_UNIVERSAL);
+        }
+    } else {
+        Group *m_group = new Group;
+        if(!m_group->Create(master->GetGUID(), master->GetName()))
+        {
+            delete m_group;
+            return;
+        }
+        sObjectMgr->AddGroup(m_group);
+        if(!m_group->IsFull()) m_group->AddMember(bot->GetGUID(), bot->GetName());
+    }
+
+    //get class specific AI
+    switch(m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotPriestAI(master, m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotWarriorAI(master, m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotShamanAI(master, m_bot, this);
+            break;
+        case CLASS_ROGUE:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotRogueAI(master, m_bot, this);
+            break;
+        case CLASS_PALADIN:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotPaladinAI(master, m_bot, this);
+            break;
+        case CLASS_MAGE:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotMageAI(master, m_bot, this);
+            break;
+        case CLASS_DRUID:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotDruidAI(master, m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotWarlockAI(master, m_bot, this);
+            break;
+        case CLASS_HUNTER:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotHunterAI(master, m_bot, this);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotDeathKnightAI(master, m_bot, this);
+            break;
+    }
+
+    //load config variables
+    m_followDistanceMin = sConfig->GetFloatDefault("Bot.FollowDistanceMin", 0.5f);
+    m_followDistanceMax = sConfig->GetFloatDefault("Bot.FollowDistanceMax", 3.0f);
+    m_playerBotsFly = sConfig->GetIntDefault("Bot.PlayerBotsFly", 0);
+
+    SetQuestNeedItems();
+    m_needEmblemList.clear();
+    m_needEmblemList[29434] = 200; // Badge of Justice
+    m_needEmblemList[40752] = 200; // Emblem of Heroism
+    m_needEmblemList[40753] = 200; // Emblem of Valor
+    m_needEmblemList[45624] = 200; // Emblem of Conquest
+    m_needEmblemList[47241] = 200; // Emblem of Triumph
+    m_needEmblemList[49426] = 200; // Emblem of Frost
+    m_needEmblemList[44990] = 200; // Champion's Seal
+    HandleCommand("help", *m_master);
+}
+PlayerbotAI::~PlayerbotAI(){}
+
+//finds spell ID for matching substring args
+//in priority of full text match, spells not taking reagents, and highest rank
+uint32 PlayerbotAI::getSpellId(const char *args, bool master) const
+{
+    if(!*args) return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if(!Utf8toWStr(namepart, wnamepart)) return 0;
+
+    //converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = 0;
+    if(master) loc = m_master->GetSession()->GetSessionDbcLocale();
+    else loc = m_bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || IsPassiveSpell(spellId)) continue;
+
+        const SpellEntry *pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if(!pSpellInfo) continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if(name.empty() || !Utf8FitTo(name, wnamepart)) continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <=  0) ? true : false;
+
+        //if we already found a spell
+        bool useThisSpell = true;
+        if(foundSpellId > 0)
+        {
+            if(isExactMatch && !foundExactMatch){}
+            else if(usesNoReagents && !foundMatchUsesNoReagents){}
+            else if(spellId > foundSpellId){}
+            else useThisSpell = false;
+        }
+        if(useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+    return foundSpellId;
+}
+
+uint32 PlayerbotAI::getSpellIdExact(const char *args, bool includePassive, bool master)
+{
+    if(!*args) return 0;
+    std::string namepart = args;
+    int loc = 0;
+    if(master) loc = m_master->GetSession()->GetSessionDbcLocale();
+    else loc = m_bot->GetSession()->GetSessionDbcLocale();
+    uint32 foundSpellId = (uint32) 0;
+    bool foundMatchUsesNoReagents = false;
+
+    for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || ( !includePassive && IsPassiveSpell(spellId))) continue;
+        const SpellEntry *pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if(!pSpellInfo) continue;
+        if(pSpellInfo->Effect[0] == SPELL_EFFECT_LEARN_SPELL) continue; //This is a learn spell
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if(name.empty()) continue;
+        if(strcmp(name.c_str(),namepart.c_str())) continue;
+        if(pSpellInfo->Reagent[0] <=  0 && !foundMatchUsesNoReagents){ foundSpellId = spellId; foundMatchUsesNoReagents = true; }
+        else if(spellId > foundSpellId) { foundSpellId = spellId; }
+    }
+    //sLog->outDebug("PBot Class %u - Found in Search - [%u/%s]", m_bot->getClass(), foundSpellId, namepart.c_str());
+    if (foundSpellId > 70000) { sLog->outDebug("CRITICAL: PBot Class %u - Weird Spell in Search - [%u/%s]", m_bot->getClass(), foundSpellId, namepart.c_str()); }
+    return foundSpellId;
+}
+
+// finds quest ID for matching substring args
+uint32 PlayerbotAI::getQuestId(const char* args, bool remove) const
+{
+    if (!*args)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart,wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+    uint32 questId = 0;
+    uint32 foundQuestId = 0;
+    bool foundExactMatch = false;
+    if (!m_questsSeen.empty() && !remove)
+    {
+        for (BotQuestsSeen::const_iterator iter = m_questsSeen.begin(); iter != m_questsSeen.end(); ++iter)
+        {
+            uint32 questId = iter->first;
+            const std::string name = iter->second;
+            if (name.empty() || !Utf8FitTo(name, wnamepart))
+                continue;
+            bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+            // if we already found a quest
+            bool useThisQuest = true;
+            if (foundQuestId > 0)
+            {
+                if (isExactMatch && ! foundExactMatch)
+                {
+                }
+                else if (questId > foundQuestId)
+                {
+                }
+                else
+                    useThisQuest = false;
+            }
+            if (useThisQuest)
+            {
+                foundQuestId = questId;
+                foundExactMatch = isExactMatch;
+            }
+        }
+    }
+    else if (remove)
+    {
+        for (QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+        {
+            const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+            if (!qInfo) continue;
+
+            uint32 questId = qInfo->GetQuestId();
+            const std::string name = qInfo->GetTitle();
+            if (name.empty() || !Utf8FitTo(name, wnamepart))
+                continue;
+
+            bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+            // if we already found a quest
+            bool useThisQuest = true;
+            if (foundQuestId > 0)
+            {
+                if (isExactMatch && ! foundExactMatch)
+                {
+                }
+                else if (questId > foundQuestId)
+                {
+                }
+                else
+                    useThisQuest = false;
+            }
+            if (useThisQuest)
+            {
+                foundQuestId = questId;
+                foundExactMatch = isExactMatch;
+            }
+        }
+    }
+    return foundQuestId;
+}
+
+
+/*
+* Send a list of equipment that is in bot's inventor that is currently unequipped.
+* This is called when the master is inspecting the bot.
+*/
+void PlayerbotAI::SendNotEquipList(Player &player)
+{
+    //find all unequipped items and put them in
+    //a vector of dynamically created lists where the vector index is from 0-18
+    //and the list contains Item *that can be equipped to that slot
+    //Note: each dynamically created list in the vector must be deleted at end
+    //so NO EARLY RETURNS!
+    //see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
+    //is assigned to. (The first is EQUIPMENT_SLOT_HEAD = 0, and last is EQUIPMENT_SLOT_TABARD = 18)
+
+    std::list<Item *> *equip[19];
+    for(uint8 i = 0; i < 19; ++i) equip[i] = NULL;
+
+    //list out items in main backpack
+    for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem)
+            continue;
+
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+        if(msg != EQUIP_ERR_OK) continue;
+
+        //the dest looks like it includes the old loc in the 8 higher bits
+        //so casting it to a uint8 strips them
+        uint8 equipSlot = uint8(dest);
+        if(!(equipSlot >= 0 && equipSlot < 19)) continue;
+
+        //create a list if one doesn't already exist
+        if(equip[equipSlot] == NULL)
+            equip[equipSlot] = new std::list<Item *>;
+
+        std::list<Item *> *itemListForEqSlot = equip[equipSlot];
+
+        itemListForEqSlot->push_back(pItem);
+    }
+
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag)
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(!pItem)
+                    continue;
+
+                uint16 equipSlot;
+                uint8 msg = m_bot->CanEquipItem(NULL_SLOT, equipSlot, pItem, !pItem->IsBag());
+                if(msg != EQUIP_ERR_OK)
+                    continue;
+                if(!(equipSlot >= 0 && equipSlot < 19))
+                    continue;
+
+                //create a list if one doesn't already exist
+                if(equip[equipSlot] == NULL)
+                    equip[equipSlot] = new std::list<Item *>;
+
+                std::list<Item *> *itemListForEqSlot = equip[equipSlot];
+                itemListForEqSlot->push_back(pItem);
+            }
+        }
+    }
+
+    TellMaster("Here's all the items in my inventory that I can equip:");
+    ChatHandler ch(m_master);
+
+    const std::string descr[] = { "head", "neck", "shoulders", "body", "chest",
+    "waist", "legs", "feet", "wrists", "hands", "finger1", "finger2",
+    "trinket1", "trinket2", "back", "mainhand", "offhand", "ranged", "tabard" };
+
+    //now send client all items that can be equipped by slot
+    for(uint8 equipSlot = 0; equipSlot < 19; ++equipSlot)
+    {
+        if(equip[equipSlot] == NULL) continue;
+        std::list<Item *> *itemListForEqSlot = equip[equipSlot];
+        std::ostringstream out;
+        out << descr[equipSlot] << ": ";
+        for(std::list<Item *>::iterator it = itemListForEqSlot->begin(); it != itemListForEqSlot->end(); ++it)
+        {
+            const ItemPrototype *const pItemProto = (*it)->GetProto();
+            out << " |cffffffff|Hitem:" << pItemProto->ItemId
+            << ":0:0:0:0:0:0:0" << "|h[" << pItemProto->Name1
+            << "]|h|r";
+        }
+        ch.SendSysMessage(out.str().c_str());
+        delete itemListForEqSlot; //delete list of Item *
+    }
+}
+
+void PlayerbotAI::HandleMasterOutgoingPacket(const WorldPacket &packet, WorldSession &masterSession)
+{
+    // Testing
+    const char *oc = LookupOpcodeName(packet.GetOpcode());
+
+    std::ostringstream out;
+    out << "HandleMasterOutgoingPacket: " << oc;
+    sLog->outError(out.str().c_str());
+    // Testing
+}
+
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket &packet, WorldSession &masterSession)
+{
+    switch(packet.GetOpcode())
+    {
+		case CMSG_SET_SELECTION:
+		{
+			//sLog->outError("cmsg_set_selection");
+			return;
+		}
+
+        //If master inspects one of his bots, give the master useful info in chat window
+        //such as inventory that can be equipped
+        case CMSG_INSPECT:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint64 guid; p >> guid;
+            Player *const bot = masterSession.GetPlayerBot(guid);
+            if(!bot) return;
+            bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+        }
+
+        case CMSG_PUSHQUESTTOPARTY:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint32 quest; p >> quest;
+            Player *pPlayer = masterSession.GetPlayer();
+            Quest const *pQuest = sObjectMgr->GetQuestTemplate(quest);
+
+            if(pQuest)
+                for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player *const bot = it->second;
+                    uint64 guid = it->first;
+                    uint32 unk1 = 0;
+
+                    WorldPacket data(MSG_QUEST_PUSH_RESULT, (8+4+4));
+                    //data << guid;
+                    data << pPlayer->GetGUID();
+                    data << quest;
+                    data << unk1;
+
+                    bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(data);
+                    bot->GetPlayerbotAI()->SetQuestNeedItems();
+                }
+            return;
+        }
+
+        //handle emotes from the master
+        //case CMSG_EMOTE:
+        case CMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint32 emoteNum;
+//            uint64 guid;
+            p >> emoteNum;
+
+            switch(emoteNum)
+            {
+                case TEXTEMOTE_BONK:
+                {
+                    Player *const pPlayer = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(!pPlayer || !pPlayer->GetPlayerbotAI()) return;
+                    PlayerbotAI *const pBot = pPlayer->GetPlayerbotAI();
+
+                    ChatHandler ch(masterSession.GetPlayer());
+
+                    {
+                    std::ostringstream out;
+                    out << "clock(): " << (getMSTime())
+                    << " m_ignoreAIUpdatesUntilTime: " << (pBot->m_ignoreAIUpdatesUntilTime);
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
+                    << " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "m_IsFollowingMaster: " << pBot->m_IsFollowingMaster;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "IsBeingTeleported(): " << pBot->m_bot->IsBeingTeleported();
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    bool tradeActive = (pBot->m_bot->GetTrader()) ? true : false;
+                    out << "tradeActive: " << tradeActive;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "IsCharmed(): " << pBot->m_bot->isCharmed();
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "IsInCombat(): " << pBot->m_bot->isInCombat();
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "isLooting: " << pBot->isLooting;
+                    ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                    std::ostringstream out;
+                    out << "isPulling: " << pBot->GetClassAI()->isPulling();
+                    ch.SendSysMessage(out.str().c_str());
+                    }
+                    return;
+                }
+
+                case TEXTEMOTE_EAT:
+                case TEXTEMOTE_DRINK:
+                {
+                    Player *const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(bot) bot->GetPlayerbotAI()->Stay();
+                    else {
+                        for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player *const bot = it->second;
+                            bot->GetPlayerbotAI()->Feast();
+                        }
+                    }
+                    return;
+                }
+
+                //emote to stay
+                case TEXTEMOTE_STAND:
+                {
+                    Player *const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(bot) bot->GetPlayerbotAI()->Stay();
+                    else {
+                        for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player *const bot = it->second;
+                            bot->GetPlayerbotAI()->Stay();
+                        }
+                    }
+                    return;
+                }
+
+                //324 is the followme emote (not defined in enum)
+                //if master has bot selected then only bot follows, else all bots follow
+                case 324:
+                case TEXTEMOTE_WAVE:
+                {
+                    Player *const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(bot)
+                    {
+                        bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                        bot->GetPlayerbotAI()->SetLooting(false);
+                    } else {
+                        for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player *const bot = it->second;
+                            bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                            bot->GetPlayerbotAI()->SetLooting(false);
+                        }
+                    }
+                    return;
+                }
+
+                default: return;
+            }
+        } //end CMSG_TEXT_EMOTE
+
+        case CMSG_GROUP_UNINVITE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            std::string member; p >> member;
+            p.clear();
+
+            WorldPacket data(CMSG_GROUP_UNINVITE, 1);
+            PlayerbotChatHandler ch(masterSession.GetPlayer());
+            std::ostringstream out;
+            out << "remove " << member;
+            ch.uninvite(out.str().c_str());
+            return;
+        }
+
+        case CMSG_REPAIR_ITEM:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint64 npcGUID;
+            p >> npcGUID;
+
+            Object *const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT);
+            if(!pNpc)
+                return;
+
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+                if(!bot->IsInMap((WorldObject*) pNpc))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to repair items!");
+                    continue;
+                } else {
+                    bot->GetPlayerbotAI()->TellMaster("Repairing my items.");
+                    bot->DurabilityRepairAll(false, 0.0, false);
+                }
+
+            }
+            return;
+        }
+
+        case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            WorldPacket incP(packet);
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+
+                Player *const bot = it->second;
+                if (!bot->GetPlayerbotAI()->CanBotsFly()) return;
+
+                if(!bot->IsInMap((WorldObject*) masterSession.GetPlayer()))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to fly!");
+                    continue;
+                } else {
+                    WorldPacket p;
+                   // p << guid << _totalcost << node_count;
+                    bot->GetPlayerbotAI()->Stay();  // clear any movement
+                    incP.rpos(0);
+                    bot->GetSession()->HandleActivateTaxiExpressOpcode(incP);
+                }
+
+            }
+            return;
+        }
+
+        case CMSG_ACTIVATETAXI:
+        {
+            WorldPacket incP(packet);
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+                if (!bot->GetPlayerbotAI()->CanBotsFly()) return;
+
+                if(!bot->IsInMap((WorldObject*) masterSession.GetPlayer()))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to fly!");
+                    continue;
+                } else {
+                    WorldPacket p;
+                   // p << guid << nodes[0] << nodes[1];
+                    bot->GetPlayerbotAI()->Stay();  // clear any movement
+                    incP.rpos(0);
+                    bot->GetSession()->HandleActivateTaxiOpcode(incP);
+                }
+
+            }
+            return;
+        }
+
+        // when landing from a flight path
+        case CMSG_MOVE_SPLINE_DONE:
+        {
+            WorldPacket p(packet);
+            //p.rpos(0);  // reset reader
+
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+
+                if(!bot->IsInMap((WorldObject*) masterSession.GetPlayer()))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to land!");
+                    continue;
+                } else {
+                    p.rpos(0);  // reset reader
+                    p.appendPackGUID(bot->GetGUID());
+                    bot->GetSession()->HandleMoveSplineDoneOpcode(p);
+                    uint32 sourcenode = bot->m_taxi.GetTaxiSource();
+                    uint32 mountDisplayId = sObjectMgr->GetTaxiMountDisplayId(sourcenode, bot->GetTeam());
+
+                    if (mountDisplayId==0) {
+                        bot->CleanupAfterTaxiFlight();
+                        bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                    }
+                }
+
+            }
+            return;
+        }
+        case CMSG_LOOT:
+            {
+                WorldPacket p(packet);
+                p.rpos(0); // reset reader
+                uint64 cGUID;
+                p >> cGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                Creature *cToLoot = m_master->GetMap()->GetCreature(cGUID);
+                if (!cToLoot)
+                    return;
+                /* for all master's bots */
+                for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                    it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+                    if (!bot->IsInMap((WorldObject*) cToLoot))
+                    {
+                        bot->GetPlayerbotAI()->TellMaster("I'm too far away to check for needed Quest Items!");
+                        continue;
+                    }
+                    else
+                    {
+                        //bot->GetPlayerbotAI()->TellMaster("Checking for needed Quest Items.");
+                        bot->GetPlayerbotAI()->AddLootGUID(cGUID);
+                        bot->GetPlayerbotAI()->DoLoot();
+                    }
+                }
+                return;
+
+            }
+            break;
+
+        case CMSG_GAMEOBJ_USE:
+            {
+                WorldPacket p(packet);
+                p.rpos(0); // reset reader
+                uint64 objGUID;
+                p >> objGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                GameObject *obj = m_master->GetMap()->GetGameObject( objGUID );
+                if( !obj )
+                    return;
+
+               for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+//sLog->outError ("gameobject type = %u", obj->GetGoType());
+                    if( obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER )
+                    {
+                        bot->GetPlayerbotAI()->TurnInQuests( obj );
+                    }
+                    // add other go types here, i.e.:
+                    // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                }
+            }
+            break;
+
+        case CMSG_GAMEOBJ_REPORT_USE:
+            {
+                WorldPacket p(packet);
+                p.rpos(0); // reset reader
+                uint64 objGUID;
+                p >> objGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                GameObject *obj = m_master->GetMap()->GetGameObject( objGUID );
+                if( !obj )
+                    return;
+
+                //Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+                //if (!pNpc) return;
+            /* For all master's bots */
+            for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                if (!bot->IsInMap((WorldObject*) obj))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to check for needed Quest Items!");
+                    continue;
+                }
+                else
+                {
+                    //bot->GetPlayerbotAI()->TellMaster("Checking for needed Quest Items.");
+                    bot->GetPlayerbotAI()->AddLootGUID(objGUID);
+                    bot->GetPlayerbotAI()->DoLoot();
+                }
+            }
+            return;
+        }
+
+        //if master talks to an NPC
+        case CMSG_GOSSIP_HELLO:
+        case CMSG_QUESTGIVER_HELLO:
+            {
+                WorldPacket p(packet);
+                p.rpos(0); //reset reader
+                uint64 npcGUID;
+                p >> npcGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                //Object *const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT);
+                WorldObject* pNpc = ObjectAccessor::GetWorldObject( *m_master, npcGUID );
+                if(!pNpc)
+                    return;
+
+                // if its a flight master
+                if(pNpc->HasFlag( UNIT_NPC_FLAGS, UNIT_NPC_FLAG_FLIGHTMASTER ))
+                {
+                    for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                    {
+                        Player *const bot = it->second;
+                        if (bot->GetSession()->SendLearnNewTaxiNode((Creature*)pNpc))
+                            bot->GetPlayerbotAI()->TellMaster("Learned a new path.");
+                    }
+                    return;
+                }
+
+                // for all master's bots
+                for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+                    bot->GetPlayerbotAI()->TurnInQuests( pNpc );
+                    bot->GetPlayerbotAI()->SetQuestNeedItems();
+
+                    bot->TalkedToCreature(pNpc->GetEntry(), pNpc->GetGUID());
+                }
+
+                return;
+        }
+
+        case CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+           if (!masterSession.GetPlayer()->GetSelection()) return;
+
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                p.rpos(0); // reset reader
+                bot->GetSession()->HandleQuestgiverStatusMultipleQuery(p);
+            }
+
+
+        return;
+        }
+
+        // if master accepts a quest, bots should also try to accept quest
+        case CMSG_QUESTGIVER_ACCEPT_QUEST:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            uint64 guid;
+            uint32 quest;
+            p >> guid >> quest;
+            Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+            if (qInfo)
+            {
+                //for all master's bots
+                for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+
+                    if (bot->GetQuestStatus(quest) == QUEST_STATUS_COMPLETE)
+                        bot->GetPlayerbotAI()->TellMaster("I already completed that quest.");
+                    else if (! bot->CanTakeQuest(qInfo, false))
+                    {
+                        if (! bot->SatisfyQuestStatus(qInfo, false))
+                            bot->GetPlayerbotAI()->TellMaster("I already have that quest.");
+                        else
+                            bot->GetPlayerbotAI()->TellMaster("I can't take that quest.");
+                    }
+                    else if (! bot->SatisfyQuestLog(false))
+                        bot->GetPlayerbotAI()->TellMaster("My quest log is full.");
+                    else if (! bot->CanAddQuest(qInfo, false))
+                        bot->GetPlayerbotAI()->TellMaster("I can't take that quest because it requires that I take items, but my bags are full!");
+
+                    else
+                    {
+                        p.rpos(0); // reset reader
+                        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+                        bot->GetPlayerbotAI()->TellMaster("Got the quest.");
+                        bot->GetPlayerbotAI()->SetQuestNeedItems();
+                    }
+                }
+            }
+
+            return;
+        }
+
+        case CMSG_LIST_INVENTORY:
+            {
+                uint64 npcGUID;
+                WorldPacket p1(packet);
+                p1.rpos(0); /* reset reader */
+                p1 >> npcGUID;
+
+                Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+                if (!pNpc) return;
+
+                /* for all master's bots */
+                for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                    it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+                    if (!bot->IsInMap((WorldObject*) pNpc))
+                    {
+                        bot->GetPlayerbotAI()->TellMaster("I'm too far away to sell items!");
+                        continue;
+                    }
+                    else
+                    {
+                        uint32 TotalCost = 0;
+                        uint32 TotalSold = 0;
+                        std::ostringstream report;
+                        std::ostringstream canSell;
+                        canSell << "Items that are not trash and can be sold: ";
+                        // list out items in main backpack
+                        for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                        {
+                            Item* const item = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                            if (!item)
+                                continue;
+
+                            if (item->CanBeTraded() && item->GetProto()->Quality == ITEM_QUALITY_POOR)
+                            {
+                                int32 cost = item->GetCount() * item->GetProto()->SellPrice;
+                                bot->ModifyMoney(cost);
+                                bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+                                bot->AddItemToBuyBackSlot(item);
+
+                                TotalSold = TotalSold + 1;
+                                TotalCost = TotalCost + cost;
+
+                                report << "Sold " << item->GetCount() << "x";
+                                report << " |cffffffff|Hitem:" << item->GetProto()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetProto()->Name1 << "]|h|r";
+                                report << " for ";
+
+                                uint32 gold = uint32(cost / 10000);
+                                cost -= (gold * 10000);
+                                uint32 silver = uint32(cost / 100);
+                                cost -= (silver * 100);
+
+                                if (gold > 0)
+                                {
+                                    report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                                }
+                                if (silver > 0)
+                                {
+                                    report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                                }
+                                report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+                            }
+                            else if (item->GetProto()->SellPrice > 0)
+                            {
+                                canSell << "|cffffffff|Hitem:" << item->GetProto()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetProto()->Name1 << "]|h|r ";
+                            }
+                        }
+
+                        for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END;++bag)
+                        {
+                            const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                            if (pBag)
+                            {
+                                for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                                {
+                                    Item* const item = bot->GetItemByPos(bag, slot);
+                                    if (!item)
+                                        continue;
+
+                                    if (item->CanBeTraded() && item->GetProto()->Quality == ITEM_QUALITY_POOR)
+                                    {
+                                        int32 cost = item->GetCount() * item->GetProto()->SellPrice;
+                                        bot->ModifyMoney(cost);
+                                        bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+                                        bot->AddItemToBuyBackSlot(item);
+
+                                        TotalSold = TotalSold + 1;
+                                        TotalCost = TotalCost + cost;
+
+                                        report << "Sold " << item->GetCount() << "x";
+                                        report << " |cffffffff|Hitem:" << item->GetProto()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetProto()->Name1 << "]|h|r";
+                                        report << " for ";
+
+                                        uint32 gold = uint32(cost / 10000);
+                                        cost -= (gold * 10000);
+                                        uint32 silver = uint32(cost / 100);
+                                        cost -= (silver * 100);
+                                        if (gold > 0)
+                                        {
+                                            report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                                        }
+                                        if (silver > 0)
+                                        {
+                                            report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                                        }
+                                        report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+                                    }
+                                    else if (item->GetProto()->SellPrice > 0)
+                                    {
+                                        canSell << "|cffffffff|Hitem:" << item->GetProto()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetProto()->Name1 << "]|h|r ";
+                                    }
+                                }
+                            }
+                        }
+                        if (TotalSold > 0) {
+                            report << "Sold total " << TotalSold << " item(s) for ";
+                            uint32 gold = uint32(TotalCost / 10000);
+                            TotalCost -= (gold * 10000);
+                            uint32 silver = uint32(TotalCost / 100);
+                            TotalCost -= (silver * 100);
+                            if (gold > 0)
+                            {
+                                report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                            }
+                            if (silver > 0)
+                            {
+                                report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                            }
+                            report << TotalCost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t";
+                            bot->GetPlayerbotAI()->TellMaster(report.str());
+                        }
+                        bot->GetPlayerbotAI()->TellMaster(canSell.str());
+                    }
+                }
+                return;
+
+            }
+
+        case CMSG_AREATRIGGER:
+        {
+            uint32 Trigger_ID;
+            WorldPacket p1(packet);
+            p1.rpos(0); /* reset reader */
+            p1 >> Trigger_ID;
+
+            /* for all master's bots */
+            for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+
+                uint32 quest_id = sObjectMgr->GetQuestForAreaTrigger( Trigger_ID );
+                // The conditions that intentionally left unchecked are:
+                // Bot is alive or not
+                // Bot is in the trigger area or not
+                if( quest_id && bot->IsActiveQuest(quest_id) )
+                {
+                    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+                    if( pQuest )
+                    {
+                        if(bot->GetQuestStatus(quest_id) == QUEST_STATUS_INCOMPLETE)
+                        {
+                            bot->AreaExploredOrEventHappens( quest_id );
+                            bot->GetPlayerbotAI()->TellMaster("Quest area explored");
+                        }
+                    }
+                }
+
+                if(sObjectMgr->IsTavernAreaTrigger(Trigger_ID))
+                {
+                    // set resting flag we are in the inn
+                    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
+                    bot->InnEnter(time(NULL), bot->GetMapId() , bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ());
+                    bot->SetRestType(REST_TYPE_IN_TAVERN);
+
+                    if(sWorld->IsFFAPvPRealm())
+                        bot->RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+                }
+            }
+            return;
+        }
+
+
+        default:
+        {
+			const char *oc = LookupOpcodeName(packet.GetOpcode());
+            ChatHandler ch(masterSession.GetPlayer());
+            ch.SendSysMessage(oc);
+
+            std::ostringstream out;
+            out << "HandleMasterIncomingPacket: " << oc;
+            sLog->outError(out.str().c_str());
+
+            return;
+        }
+
+    }
+}
+
+//handle outgoing packets the server would send to the client
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket &packet)
+{
+    switch(packet.GetOpcode())
+    {
+         case SMSG_TRADE_STATUS_EXTENDED:
+         {
+             //m_bot->GetSession()->SendTradeStatus(TRADE_STATUS_TRADE_ACCEPT);
+             return;
+         }
+
+
+        case SMSG_DUEL_WINNER:
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
+            return;
+
+        case SMSG_DUEL_COMPLETE:
+            SetIgnoreUpdateTime(4);
+            m_combatOrder = ORDERS_NONE;
+            m_ScenarioType = SCENARIO_PVEEASY;
+            m_bot->GetMotionMaster()->Clear(true);
+            return;
+
+        case SMSG_DUEL_OUTOFBOUNDS:
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
+            return;
+
+        case SMSG_DUEL_REQUESTED:
+        {
+            SetIgnoreUpdateTime(0);
+            WorldPacket p(packet);
+            uint64 flagGuid; p >> flagGuid;
+            uint64 playerGuid; p >> playerGuid;
+            Player *const pPlayer = ObjectAccessor::FindPlayer(playerGuid);
+            if(canObeyCommandFrom(*pPlayer))
+            {
+                m_bot->GetMotionMaster()->Clear(true);
+                WorldPacket *const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+                *packet << flagGuid;
+                m_bot->GetSession()->QueuePacket(packet); //queue the packet to get around race condition
+
+                //follow target in casting range
+                float angle = rand_norm()*M_PI; //Generates random float between 0 and 3.14
+                float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10); //Using urand to get a random float is stupid. It takes uint32, not float.
+                m_bot->GetMotionMaster()->Clear(true);
+                m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
+
+                m_bot->SetSelection(playerGuid);
+                SetIgnoreUpdateTime(4);
+                m_combatOrder = ORDERS_KILL;
+                m_ScenarioType = SCENARIO_DUEL;
+            }
+            return;
+        }
+
+        case SMSG_INVENTORY_CHANGE_FAILURE:
+            TellMaster("I can't use that.");
+            return;
+
+        case SMSG_SPELL_DELAYED:
+        {
+            //sLog->outDebug("Bot [%u] SMSG_SPELL_DELAYED",m_bot->GetGUIDLow());
+            WorldPacket p(packet);
+            //uint64 casterGuid = extractGuid(p); //somehow the caster guid is corrupt
+            //if(casterGuid != m_bot->GetGUID()) return;
+            //uint32 delayTime; p >> delayTime;
+            //sLog->outDebug("Bot [%u] caster [%u] Spell Delayed [%u]",m_bot->GetGUIDLow(), casterGuid, delayTime);
+            //m_ignoreAIUpdatesUntilTime +=  ((((float)delayTime) / 1000.0f ) + 0.1f) * CLOCKS_PER_SEC;
+            if(m_CurrentlyCastingSpellId > 0)
+            {
+                m_ignoreAIUpdatesUntilTime += 0.5f * 1000; //Until this is handled correctly, assume, delay is the default 0.5 secs
+            }
+            return;
+        }
+
+        case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint64 casterGuid = extractGuid(p);
+            if(casterGuid != m_bot->GetGUID()) return;
+            uint32 spellId; p >> spellId;
+            if(m_CurrentlyCastingSpellId == spellId)
+            {
+                SetIgnoreUpdateTime(1);
+                m_CurrentlyCastingSpellId = 0;
+            }
+            return;
+        }
+
+        //if a change in speed was detected for the master
+        //make sure we have the same mount status
+        case SMSG_FORCE_RUN_SPEED_CHANGE:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            //uint64 guid; p >> guid;
+            Player *tPlayer = sObjectMgr->GetPlayer(guid);
+            if(!tPlayer) return;
+            if (!m_master || !m_bot) return;
+            if(guid == m_bot->GetGUID()) return;
+            if(guid == m_master->GetGUID()) {
+                m_bot->GetPlayerbotAI()->UseMount();
+                SetIgnoreUpdateTime(2);
+            }
+            return;
+        }
+
+        //handle flying acknowledgement
+        case SMSG_MOVE_SET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            if(guid != m_bot->GetGUID()) return;
+            m_bot->AddUnitMovementFlag(MOVEMENTFLAG_FLYING);
+            //SetSpeed(MOVE_RUN, m_master->GetSpeed(MOVE_FLIGHT) + 0.1f, true);
+            return;
+        }
+
+        //handle dismount flying acknowledgement
+        case SMSG_MOVE_UNSET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            if(guid != m_bot->GetGUID()) return;
+            m_bot->RemoveUnitMovementFlag(MOVEMENTFLAG_FLYING);
+            //SetSpeed(MOVE_RUN, m_master->GetSpeedRate(MOVE_RUN), true);
+            return;
+        }
+
+        //If the leader role was given to the bot automatically give it to the master
+        //if the master is in the group, otherwise leave group
+        case SMSG_GROUP_SET_LEADER:
+        {
+            WorldPacket p(packet);
+            std::string name; p >> name;
+            if(m_bot->GetGroup() && name == m_bot->GetName())
+            {
+                if(m_bot->GetGroup()->IsMember(m_master->GetGUID()))
+                {
+                    p.resize(8);
+                    p << m_master->GetGUID();
+                    m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                } else {
+                    p.clear(); //not really needed
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p); //packet not used
+                }
+            }
+            return;
+        }
+
+        //If the master leaves the group, then the bot leaves too
+        case SMSG_PARTY_COMMAND_RESULT:
+        {
+            WorldPacket p(packet);
+            uint32 operation; p >> operation;
+            std::string member; p >> member;
+            uint32 result; p >> result;
+            p.clear();
+            if(operation == PARTY_OP_LEAVE && member == m_master->GetName()) m_bot->GetSession()->HandleGroupDisbandOpcode(p); //packet not used
+            return;
+        }
+
+        //Automatically accept rez. Useful when bot dies, and a druid does a battle rez.
+        case SMSG_RESURRECT_REQUEST:
+        {
+            WorldPacket p, incP(packet);
+            uint8 status = 1;
+            uint64 rezzer; incP >> rezzer;
+            p << rezzer;
+            p << status;
+            m_bot->GetPlayerbotAI()->SetLooting(false);
+            m_bot->GetSession()->HandleResurrectResponseOpcode(p);
+            m_IsFollowingMaster = true;
+            m_TimeRessurect = 0;
+            return;
+        }
+
+        //Handle Group invites (auto accept if master is in group, otherwise decline & send message)
+        case SMSG_GROUP_INVITE:
+        {
+            if(m_bot->GetGroupInvite())
+            {
+                const Group *const grp = m_bot->GetGroupInvite();
+                if(!grp) return;
+                Player *const inviter = sObjectMgr->GetPlayer(grp->GetLeaderGUID());
+                if(!inviter) return;
+                WorldPacket p;
+                if(!canObeyCommandFrom(*inviter))
+                {
+                    std::string buf = "I can't accept your invite unless you first invite my master ";
+                    buf += m_master->GetName();
+                    buf += ".";
+                    SendWhisper(buf, *inviter);
+                    m_bot->GetSession()->HandleGroupDeclineOpcode(p); //packet not used
+                } else
+                    m_bot->GetSession()->HandleGroupAcceptOpcode(p); //packet not used
+            }
+            return;
+        }
+
+        //Handle when another player opens the trade window with the bot
+        //also sends list of tradable items bot can trade if bot is allowed to obey commands from
+        case SMSG_TRADE_STATUS:
+        {
+            if(m_bot->GetTrader() == NULL) break;
+            WorldPacket p(packet);
+            uint32 status; p >> status;
+            p.clear();
+
+            if(status == 4) { // TRADE_STATUS_TRADE_ACCEPT
+				if (!m_bot->GetTradeData()->IsAccepted() || !m_bot->GetTrader()->GetTradeData()->IsAccepted()) {
+                    m_bot->GetSession()->HandleAcceptTradeOpcode(p); //packet not used
+                }
+
+            } else if(status == 1) // TRADE_STATUS_BEGIN_TRADE
+            {
+                m_bot->GetSession()->HandleBeginTradeOpcode(p); //packet not used
+
+                //if(!canObeyCommandFrom(*(m_bot->GetTrader())))
+                //{
+                    //SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
+                    //return;
+                //}
+
+                //list out items available for trade
+                std::ostringstream out;
+
+                //list out items in main backpack
+                for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                {
+                    const Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    if(pItem && pItem->CanBeTraded())
+                    {
+                        const ItemPrototype *const pItemProto = pItem->GetProto();
+                        std::string name = pItemProto->Name1;
+
+                        out << " |cffffffff|Hitem:" << pItemProto->ItemId << ":0:0:0:0:0:0:0" << "|h[" << name << "]|h|r";
+                        if(pItem->GetCount() > 1)
+                            out << "x" << pItem->GetCount() << ' ';
+                    }
+                }
+                //list out items in other removable backpacks
+                for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+                {
+                    const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                    if(pBag)
+                    {
+                        for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                        {
+                            const Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                            if(pItem && pItem->CanBeTraded())
+                            {
+                                const ItemPrototype *const pItemProto = pItem->GetProto();
+                                const std::string name = pItemProto->Name1;
+
+                                //item link format: http://www.wowwiki.com/ItemString
+                                //itemId, enchantId, jewelId1, jewelId2, jewelId3, jewelId4, suffixId, uniqueId
+                                out << " |cffffffff|Hitem:" << pItemProto->ItemId << ":0:0:0:0:0:0:0" << "|h[" << name << "]|h|r";
+                                if(pItem->GetCount() > 1)
+                                    out << "x" << pItem->GetCount() << ' ';
+                            }
+                        }
+                    }
+                }
+
+                //calculate how much money bot has
+                uint32 copper = m_bot->GetMoney();
+                uint32 gold = uint32(copper / 10000);
+                copper -= (gold * 10000);
+                uint32 silver = uint32(copper / 100);
+                copper -= (silver * 100);
+
+                //send bot the message
+                std::ostringstream whisper;
+                whisper << "I have |cff00ff00" << gold
+                << "|r|cfffffc00g|r|cff00ff00" << silver
+                << "|r|cffcdcdcds|r|cff00ff00" << copper
+                << "|r|cffffd333c|r" << " and the following items:";
+                m_bot->GetPlayerbotAI()->SendWhisper(whisper.str(), *(m_bot->GetTrader()));
+                ChatHandler ch(m_bot->GetTrader());
+                ch.SendSysMessage(out.str().c_str());
+            }
+            return;
+        }
+
+        case SMSG_SPELL_GO:
+        {
+            WorldPacket p(packet);
+            uint64 castItemGuid = extractGuid(p);
+            uint64 casterGuid = extractGuid(p);
+            if(casterGuid != m_bot->GetGUID()) return;
+
+            uint32 spellId; p >> spellId;
+            uint16 castFlags; p >> castFlags;
+            uint32 msTime; p >> msTime;
+            uint8 numHit; p >> numHit;
+            if(m_CurrentlyCastingSpellId == spellId)
+            {
+                Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+                if(!pSpell) return;
+                if(pSpell->IsChannelActive() || pSpell->IsAutoRepeat())
+                    SetIgnoreUpdateTime( (((float)GetSpellDuration(pSpell->m_spellInfo) / 1000.0f) + 1.0f) );
+                else if(pSpell->IsAutoRepeat())
+                    SetIgnoreUpdateTime(6);
+                else {
+                    SetIgnoreUpdateTime(0.5f);
+                    m_CurrentlyCastingSpellId = 0;
+                }
+            }
+            return;
+        }
+
+        case SMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint32 text_emote;
+            uint64 guid;
+            p >> guid;
+            p >> text_emote;
+
+            switch(text_emote)
+            {
+                case TEXTEMOTE_BOW:
+                {
+                    //Buff anyone who bows before me. Useful for players not in bot's group
+                    Player *pPlayer = sObjectMgr->GetPlayer(guid);
+
+                    Player *const bot =sObjectMgr->GetPlayer(pPlayer->GetSelection());
+
+                    if(bot && bot->GetGUID()==m_bot->GetGUID() &&
+                       bot->GetPlayerbotAI()->GetClassAI())
+                    {
+                        bot->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
+                    }
+                    return;
+                }
+
+                default:
+                    m_bot->HandleEmoteCommand(text_emote);
+                    return;
+            }
+            return;
+        }
+
+        case MSG_MOVE_TELEPORT_ACK:
+            HandleTeleportAck();
+            return;
+
+        case SMSG_QUESTGIVER_STATUS_MULTIPLE:
+        {
+            return;
+        }
+
+        // used to communicate between bots
+        case SMSG_MESSAGECHAT:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint8 msgtype;
+            uint32 language;
+            uint64 guid;
+            uint32 language2;
+            uint64 guid2;
+            uint32 textlen;
+            std::string msg;
+
+            p>>msgtype; p>>language; p>>guid; p>>language2; p>>guid2; p>>textlen;
+            p>>msg;
+
+            Player * fromPlayer = sObjectMgr->GetPlayer(guid);
+            if (fromPlayer == NULL) break;
+            const std::string text = msg;
+            HandleCommand(text, *fromPlayer);
+        }
+
+        case SMSG_MONSTER_MOVE:
+        case SMSG_UPDATE_WORLD_STATE:
+        case SMSG_COMPRESSED_UPDATE_OBJECT:
+        case MSG_MOVE_SET_FACING:
+        case MSG_MOVE_STOP:
+        case MSG_MOVE_HEARTBEAT:
+        case MSG_MOVE_STOP_STRAFE:
+        case MSG_MOVE_START_STRAFE_LEFT:
+        case SMSG_UPDATE_OBJECT:
+        case MSG_MOVE_START_FORWARD:
+        case SMSG_WEATHER:
+        case SMSG_POWER_UPDATE:
+        case SMSG_TIME_SYNC_REQ:
+        case SMSG_STANDSTATE_UPDATE:
+        case SMSG_PERIODICAURALOG:
+        case SMSG_AURA_UPDATE:
+        return;
+
+// TESTING
+        default:
+        const char *oc = LookupOpcodeName(packet.GetOpcode());
+        TellMaster(oc);
+        sLog->outError("SMSG opcode: %s", oc);
+  // TESTING
+    }
+}
+void PlayerbotAI::HandleTeleportAck()
+{
+    SetIgnoreUpdateTime(6);
+    m_bot->GetMotionMaster()->Clear(true);
+    if(m_bot->IsBeingTeleportedNear())
+    {
+        WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+        p.appendPackGUID(m_bot->GetGUID());
+        p << (uint32) 0; //supposed to be flags? not used currently
+        p << (uint32) time(0); //time - not currently used
+        m_bot->GetSession()->HandleMoveTeleportAck(p);
+    }
+    else if(m_bot->IsBeingTeleportedFar())
+        m_bot->GetSession()->HandleMoveWorldportAckOpcode();
+}
+
+uint8 PlayerbotAI::GetHealthPercent(const Unit &target) const
+{
+    return(static_cast<float>(target.GetHealth()) / target.GetMaxHealth()) * 100;
+}
+
+uint8 PlayerbotAI::GetHealthPercent() const
+{
+    return GetHealthPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetManaPercent(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+
+uint8 PlayerbotAI::GetManaPercent() const
+{
+    return GetManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent(const Unit &target) const
+{
+    if(target.GetPower(POWER_MANA) >= target.GetCreateMana())
+        return(100);
+    else
+        return(static_cast<float>(target.GetPower(POWER_MANA)) / target.GetCreateMana()) * 100;
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent() const
+{
+    return GetBaseManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRageAmount(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_RAGE)));
+}
+
+uint8 PlayerbotAI::GetRageAmount() const
+{
+    return GetRageAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetEnergyAmount(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_ENERGY)));
+}
+
+uint8 PlayerbotAI::GetEnergyAmount() const
+{
+    return GetEnergyAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRunicPower(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_RUNIC_POWER)));
+}
+
+uint8 PlayerbotAI::GetRunicPower() const
+{
+    return GetRunicPower(*m_bot);
+}
+
+
+typedef std::pair<uint32, uint8> spellEffectPair;
+typedef std::multimap< spellEffectPair, Aura*> AuraMap;
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit *player) const
+{
+    for(Unit::AuraMap::const_iterator iter = player->GetOwnedAuras().begin(); iter != player->GetOwnedAuras().end(); ++iter)
+    {
+        if(iter->second->GetId() == spellId) return true;
+    }
+    return false;
+}
+bool PlayerbotAI::HasAura(const char *spellName) const
+{
+    return HasAura(spellName, m_bot);
+}
+bool PlayerbotAI::HasAura(const char *spellName, const Unit *player) const
+{
+    uint32 spellId = getSpellId(spellName);
+    return(spellId) ? HasAura(spellId, player) : false;
+}
+
+void PlayerbotAI::UseMount() const
+{
+
+    if(m_master->IsMounted() && ! m_bot->IsMounted())
+    {
+// sLog->outError ("PlayerbotAI::UseMount: %s is mounted but %s is not", m_master->GetName(), m_bot->GetName());
+        //Player Part
+        int32 master_speed1 = 0;
+        int32 master_speed2 = 0;
+        if(!m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).empty())
+        {
+            master_speed1 = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).front()->GetSpellProto()->EffectBasePoints[1];
+            master_speed2 = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).front()->GetSpellProto()->EffectBasePoints[2];
+        }
+//sLog->outError ("master_speed1 = %d", master_speed1);
+//sLog->outError ("master_speed2 = %d", master_speed2);
+        //Bot Part
+        uint32 spellMount = 0;
+        for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        {
+            uint32 spellId = itr->first;
+            if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || IsPassiveSpell(spellId))
+                continue;
+            const SpellEntry *pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if(!pSpellInfo)
+                continue;
+            if(pSpellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOUNTED)
+            {
+                if((pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                    && (pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+                {
+                    if((pSpellInfo->EffectBasePoints[1] == master_speed1)
+                        && (pSpellInfo->EffectBasePoints[2] == master_speed2))
+                    {
+                        spellMount = spellId;
+                        break;
+                    }
+                }
+                else if((pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                    && (pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+                {
+                    if((pSpellInfo->EffectBasePoints[2] == master_speed2)
+                        && (pSpellInfo->EffectBasePoints[1] == master_speed1))
+                    {
+                        spellMount = spellId;
+                        break;
+                    }
+                }
+                else if(pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                {
+                    if(pSpellInfo->EffectBasePoints[1] == master_speed1 && master_speed2 <= 0) { spellMount = spellId; break; } //Has no secondary mount aura
+                    else if (spellMount == 0) { spellMount = spellId; } // default to first mount in case it doesnt have correct version
+                }
+            }
+        }
+//sLog->outError ("spellMount = %u", spellMount);
+        if(spellMount > 0) m_bot->GetPlayerbotAI()->CastSpell(spellMount, m_bot);
+
+    }
+    else if(!m_master->IsMounted() && m_bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+    }
+} //end UseMount
+
+Item *PlayerbotAI::FindFood() const
+{
+    // list out items in main backpack
+    for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (! pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+            if (pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+                (pItemProto->SubClass==ITEM_SUBCLASS_FOOD ||
+                pItemProto->SubClass==ITEM_SUBCLASS_POTION ||
+                pItemProto->SubClass==ITEM_SUBCLASS_ELIXIR))
+            {
+                // if is FOOD
+                if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (! pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+                    if (pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+                        (pItemProto->SubClass==ITEM_SUBCLASS_FOOD ||
+                        pItemProto->SubClass==ITEM_SUBCLASS_POTION ||
+                        pItemProto->SubClass==ITEM_SUBCLASS_ELIXIR))
+                    {
+                        // if is FOOD
+                        if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+Item *PlayerbotAI::FindDrink() const
+{
+    // list out items in main backpack
+    for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (! pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+            if (pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+                (pItemProto->SubClass==ITEM_SUBCLASS_FOOD ||
+                pItemProto->SubClass==ITEM_SUBCLASS_POTION ||
+                pItemProto->SubClass==ITEM_SUBCLASS_ELIXIR))
+            {
+                if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK ||
+                    pItemProto->Spells[0].SpellCategory == 4)
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (! pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+                    if (pItemProto->Class==ITEM_CLASS_CONSUMABLE &&
+                        (pItemProto->SubClass==ITEM_SUBCLASS_FOOD ||
+                        pItemProto->SubClass==ITEM_SUBCLASS_POTION ||
+                        pItemProto->SubClass==ITEM_SUBCLASS_ELIXIR))
+                    {
+                        // if is WATER
+                        if (pItemProto->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK ||
+                            pItemProto->Spells[0].SpellCategory == 4)
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+
+Item *PlayerbotAI::FindPotion() const
+{
+    // list out items in main backpack
+    for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (! pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+            if (pItemProto->IsPotion())
+            {
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (! pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+                    if (pItemProto->IsPotion())
+                    {
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+
+
+Item *PlayerbotAI::FindBandage() const
+{
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemPrototype *const pItemProto = pItem->GetProto();
+            if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+            if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag)
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemPrototype *const pItemProto = pItem->GetProto();
+                    if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+                    if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+// finds poison starting from the front
+Item *PlayerbotAI::FindPoisonForward() const
+{
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemPrototype *const pItemProto = pItem->GetProto();
+            if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+            if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag && pBag->IsBag())
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemPrototype *const pItemProto = pItem->GetProto();
+                    if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+                    if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+// finds poison starting from the back
+Item *PlayerbotAI::FindPoisonBackward() const
+{
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_END; slot > INVENTORY_SLOT_ITEM_START; slot--)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemPrototype *const pItemProto = pItem->GetProto();
+            if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+            if(pItemProto->Class == ITEM_CLASS_GLYPH) continue;
+            if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_END; bag > INVENTORY_SLOT_BAG_START; --bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag && pBag->IsBag())
+        {
+            for(uint8 slot = pBag->GetBagSize(); slot > 0  ; --slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemPrototype *const pItemProto = pItem->GetProto();
+                    if(!pItemProto || m_bot->CanUseItem(pItemProto)!=EQUIP_ERR_OK) continue;
+                    if(pItemProto->Class == ITEM_CLASS_GLYPH) continue;
+                    if(pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+void PlayerbotAI::InterruptCurrentCastingSpell()
+{
+    //TellMaster("I'm interrupting my current spell!");
+    WorldPacket *const packet = new WorldPacket(CMSG_CANCEL_CAST, 5);
+    uint8 counter = 1;
+    *packet << counter;
+    *packet << m_CurrentlyCastingSpellId;
+    m_CurrentlyCastingSpellId = 0;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+void PlayerbotAI::Feast()
+{
+    //stand up if we are done feasting
+    if(!(m_bot->GetHealth() < m_bot->GetMaxHealth() || (m_bot->getPowerType() == POWER_MANA && m_bot->GetPower(POWER_MANA) < m_bot->GetMaxPower(POWER_MANA))))
+    {
+        m_TimeDoneDrinking = time(0) - 1;
+        m_TimeDoneEating = time(0) - 1;
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        return;
+    }
+
+    //wait 3 seconds before checking if we need to drink more or eat more
+    time_t currentTime = time(0);
+    SetIgnoreUpdateTime(3);
+
+    //should we drink another
+    if(m_bot->getPowerType() == POWER_MANA && currentTime > m_TimeDoneDrinking && ((static_cast<float>(m_bot->GetPower(POWER_MANA)) / m_bot->GetMaxPower(POWER_MANA)) < 0.8))
+    {
+        Item *pItem = FindDrink();
+        if(pItem != NULL && !m_bot->HasSpellCooldown(pItem->GetSpell()))
+        {
+            UseItem(*pItem);
+            m_TimeDoneDrinking = currentTime + 30;
+            return;
+        } else {
+
+            // find a mage
+            if (m_FeastSpamTimer > 0) --m_FeastSpamTimer;
+            else {
+                Player *mage = GetClassAI()->FindMage(m_bot);
+                if (mage != NULL) {
+                    SendWhisper("I could use a drink.", *mage);
+                }
+                TellMaster("I need water.");
+                m_FeastSpamTimer=100;
+            }
+        }
+    }
+
+    //should we eat another
+    if(currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking  && ((static_cast<float>(m_bot->GetHealth()) / m_bot->GetMaxHealth()) < 0.8))
+    {
+        Item *pItem = FindFood();
+        if(pItem != NULL && !m_bot->HasSpellCooldown(pItem->GetSpell()))
+        {
+            UseItem(*pItem);
+            m_TimeDoneEating = currentTime + 30;
+            return;
+        }
+        //TellMaster("I need food."); //Disabled, tends to be horribly spammy.
+    }
+
+    //if we are no longer eating or drinking
+    //because we are out of items or we are above 80% in both stats
+    if(currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking)
+    {
+        //TellMaster("I'm ready, let's go.");
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+}
+
+Unit *PlayerbotAI::getNextTarget(Unit *victim)
+{
+    Unit *target = NULL;
+    AttackerSet m_attackers = victim->getAttackers();
+    if(!m_attackers.empty())
+    {
+        for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+        {
+            if(*iter && m_bot->GetDistance((*iter)) < 30)
+            {
+                target = *iter;
+                break;
+            } //end if
+        } //end for
+    }
+    return target;
+} //end getNextTarget
+
+//intelligently sets a reasonable combat order for this bot
+//based on its class / level / etc
+void PlayerbotAI::GetCombatOrders()
+{
+    if(m_bot->isDead() || isLooting) return;
+    Unit *thingToAttack=0;
+
+    // check raid targets icons
+   if (!thingToAttack)
+    {
+        Group *group = m_bot->GetGroup();
+        uint64 targetGUID = group->GetTargetWithIconByGroup (m_bot->GetGUID());
+        if (targetGUID>0)
+        {
+            thingToAttack = ObjectAccessor::GetUnit(*m_master, targetGUID);
+            if (!thingToAttack || thingToAttack->isDead() || !m_bot->IsHostileTo(thingToAttack)) thingToAttack=0;
+//else sLog->outError ("%s is attacking %s", m_bot->GetName(), thingToAttack->GetName());
+        }
+    }
+
+    //check if someone wants to attack master or me
+    if (!thingToAttack) thingToAttack = getNextTarget(m_master);
+
+    if(!thingToAttack)
+        thingToAttack = getNextTarget(m_bot);
+
+    //check master's target
+    if(!thingToAttack)
+    {
+        Unit *const pTarget = ObjectAccessor::GetUnit(*m_master, m_master->GetSelection());
+        if(pTarget && pTarget->isInCombat() && pTarget->IsHostileTo(m_master))
+            thingToAttack = pTarget;
+    }
+
+    //last try to find something to attack
+    if(!thingToAttack)
+    {
+        Unit *pUnit = NULL;
+        Trinity::NearestHostileUnitInAttackDistanceCheck u_check((Creature*)m_bot, 30.0);
+        Trinity::UnitLastSearcher<Trinity::NearestHostileUnitInAttackDistanceCheck> searcher(m_bot, pUnit, u_check);
+        m_bot->VisitNearbyObject(30, searcher);
+        if(pUnit != NULL && pUnit->isAlive() && pUnit->IsHostileToPlayers()) thingToAttack = pUnit;
+    }
+
+
+    //if the thing to attack is a world invisible trigger, ex Glyph in UBRS,
+    //default to master's current victim
+    if(!thingToAttack || thingToAttack->GetUInt32Value(UNIT_FIELD_DISPLAYID) == 11686) thingToAttack = m_master->getVictim();
+
+    //if the thing to attack is an invisible trigger ex vazruden in Hellfire Ramparts,
+    //default to master's current victim
+    if(!thingToAttack || !thingToAttack->IsVisible()) thingToAttack = m_master->getVictim();
+    // if the thing to attack is not attackable
+    if (!thingToAttack || thingToAttack->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE)) thingToAttack = NULL;
+
+    // override all others if ordered to pull
+    if (m_bot->GetPlayerbotAI()->GetClassAI()->isPulling()) {
+        thingToAttack = ObjectAccessor::GetUnit(*m_master,m_master->GetSelection());
+    }
+
+    if(!thingToAttack)
+    {
+        if(GetClassAI() && !m_bot->isInCombat()) (GetClassAI())->DoNonCombatActions();
+        return;
+    }
+
+    //wait till it gets closer
+    //if(m_bot->GetDistance(thingToAttack) > 30) return;
+
+    //if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
+    //this method never gets called when the bot is in a duel and this code
+    //prevents bot from helping
+    if(thingToAttack->GetTypeId() == TYPEID_PLAYER && ((Player*)(thingToAttack))->duel)
+    {
+       SetIgnoreUpdateTime(6);
+        return;
+    }
+
+    m_bot->SetSelection(thingToAttack->GetGUID());
+    SetIgnoreUpdateTime(1);
+    m_combatOrder = ORDERS_KILL;
+
+    if(m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    m_bot->Attack(thingToAttack, true);
+
+    if(thingToAttack->GetTypeId() != TYPEID_PLAYER)
+    {
+        //add thingToAttack to loot list
+        CreatureInfo const *cInfo = ((Creature *)thingToAttack)->GetCreatureInfo();
+        if(cInfo && cInfo->lootid) m_lootCreature.push_back(thingToAttack->GetGUID());
+    }
+
+    return;
+}
+
+
+void PlayerbotAI::DoNextCombatManeuver()
+{
+    if(isLooting) return;
+
+    Unit *const pTarget = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+
+    //if current order doesn't make sense anymore
+    //clear our orders so we can get orders in next update
+    if((!pTarget || pTarget->isDead() || !pTarget->IsInWorld() ||
+        !m_bot->IsHostileTo(pTarget) || pTarget->IsPolymorphed() || m_bot->isDead()
+        || ( !m_master->isInCombat() && !m_bot->isInCombat() && !pTarget->isInCombat()) // The mob probably is in evade mode, stop combat..
+        //|| pTarget->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE)
+        ) &&
+        !m_bot->GetPlayerbotAI()->GetClassAI()->isPulling() )
+    {
+        m_combatOrder = ORDERS_NONE;
+        m_bot->SetSelection(0);
+        m_bot->GetMotionMaster()->Clear(true);
+        m_bot->InterruptNonMeleeSpells(true);
+//sLog->outError ("current target doesn't make sense so following");
+        Follow(*m_master);
+        return;
+    }
+
+    if(GetClassAI())
+    {
+        if(m_bot->HasUnitState(UNIT_STAT_CASTING))
+        {
+            return;
+        }
+
+        GetClassAI()->DoNextCombatManeuver(pTarget);
+    }
+}
+
+//this is where the AI should go
+//GetRandomContactPoint
+//GetPower, GetMaxPower
+//HasSpellCooldown
+//IsAffectedBySpellmod
+//isMoving
+//HasUnitState(FLAG) FLAG like: UNIT_STAT_ROOT, UNIT_STAT_CONFUSED, UNIT_STAT_STUNNED
+//hasAuraType
+
+void PlayerbotAI::UpdateAI(const uint32 p_time)
+{
+    time_t currentTime = time(0);
+    uint32 currentClock = getMSTime();
+    m_bot->UpdateZone(m_bot->GetZoneId(), m_bot->GetAreaId());
+
+    if (m_playerBotsFly==0 && m_master->isInFlight())
+    {
+        if (m_IsFollowingMaster)
+        {
+            const WorldLocation fakeloc = WorldLocation(35, -0.873190f, 52.920242f, -27.550674f, 1.655620f);
+            PlayerbotChatHandler ch(m_master);
+            if (! ch.teleport(*m_bot, fakeloc))
+            {
+                ch.sysmessage(".. could not be teleported ..");
+                return;
+            }
+            m_bot->SendUpdateToPlayer(m_master);
+       }
+        Stay();
+        return;
+    }
+
+    if(m_TimeRessurect == 0 && m_bot->isDead())
+    {
+        m_IsFollowingMaster = false;
+        m_TimeRessurect = currentTime + 30;
+        return;
+    }
+    else if(m_TimeRessurect > currentTime && m_bot->isDead())
+    {
+        return;
+    }
+    else if((!m_TimeRessurect == 0) && m_TimeRessurect <= currentTime && m_bot->isDead())
+    {
+        m_IsFollowingMaster = true;
+        m_TimeRessurect = 0;
+    }
+    if(((int64)m_ignoreAIUpdatesUntilTime - (int64)currentClock) > (int64) 30000) { SetIgnoreUpdateTime(2); return; } // Fix Timer overflow and AI freeze (max limit 30 secs)
+    if(currentClock < m_ignoreAIUpdatesUntilTime || m_bot->IsBeingTeleported() || m_bot->GetTrader()) return;
+
+
+    //default updates occur every 1.5 seconds
+    SetIgnoreUpdateTime(1.5);
+
+    // prevent cheating
+    if (!m_bot->GetGroup())
+    {
+        m_master->GetSession()->LogoutPlayerBot(m_bot->GetGUID(), false);
+        return;
+    }
+
+    if(m_bot->isDead()) isLooting = false;
+
+    /*
+     * combat checks
+     */
+    if(m_master <= 0 || ((m_master->isInCombat() || m_bot->isInCombat()) && m_bot->isDead())) return; //You're DEAD, stop thinking.
+
+    //if we are casting a spell then interrupt it
+    //make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
+    Spell *const pSpell = GetCurrentSpell();
+    if(pSpell && !(pSpell->IsChannelActive() || pSpell->IsAutoRepeat())) InterruptCurrentCastingSpell();
+
+    //direct cast command from master
+    else if(m_spellIdCommand != 0)
+    {
+        Unit *pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+        if(pTarget != NULL) CastSpell(m_spellIdCommand, pTarget);
+        m_spellIdCommand = 0;
+        m_targetGuidCommand = 0;
+    }
+
+    else if(m_combatOrder != ORDERS_NONE) DoNextCombatManeuver(); //handle combat
+
+    else if (m_bot->GetPlayerbotAI()->GetClassAI()->isPulling())
+    {
+        GetCombatOrders();
+        return;
+    }
+
+    //if master is in combat and bot is not, automatically assist master
+    //NOTE: combat orders are also set via incoming packets to bot or outgoing packets from master
+    else if(m_master->isInCombat() && (!m_bot->isInCombat() || m_combatOrder == ORDERS_NONE) || m_master->isDead()) GetCombatOrders();
+
+    //if bot is in combat but master is not, attack
+    else if(m_bot->isInCombat()) GetCombatOrders();
+
+    // if bot is not in combat, but main tank is
+    else if (!m_bot->isInCombat()) {
+       Unit *tank=m_classAI->FindMainTankInRaid(m_bot);
+       if (tank!=NULL && tank->isInCombat()) GetCombatOrders();
+
+    }
+
+    /*
+     * Non combat checks
+     */
+
+    //are we sitting, if so feast if possible
+/* TESTING */    if(m_bot->getStandState() == UNIT_STAND_STATE_SIT) {
+/* TESTING */sLog->outError ("%s - sitting so feast", m_bot->GetName());
+//
+/* TESTING */    }
+
+    //if commanded to follow master and not already following master then follow master
+    if(!m_bot->isInCombat() && m_IsFollowingMaster && m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE)
+    {
+        Follow(*m_master);
+
+    //do class specific non combat actions
+	} else if(!m_bot->isInCombat() && GetClassAI()) {
+        (GetClassAI())->DoNonCombatActions();
+    } if(!m_master->isInCombat())
+        DoLoot();
+
+
+    if (m_master->getStandState() == UNIT_STAND_STATE_SIT)
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_SIT);
+        m_bot->SendUpdateToPlayer(m_master);
+        Feast();
+    }
+    else if (m_TimeDoneDrinking < time(0) && m_TimeDoneEating < time(0)) //Do no interrupt if bot is eating/drinking
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+
+
+    //try to catch if he is falling through the world.  This happens
+    //when zoning in/out of an instance
+    if(m_IsFollowingMaster && m_bot->GetMapId() != m_master->GetMapId() ||
+    //m_bot->GetZoneId() != m_master->GetZoneId() ||
+    (abs(abs(m_bot->GetPositionX()) - abs(m_master->GetPositionX())) > 90) ||
+    (abs(abs(m_bot->GetPositionY()) - abs(m_master->GetPositionY())) > 90) ||
+    (abs(abs(m_bot->GetPositionZ()) - abs(m_master->GetPositionZ())) > 50))
+    {
+//sLog->outError ("%s: %s is too far away so following", m_bot->GetName(), m_master->GetName());
+        Follow(*m_master);
+    }
+}
+
+
+void PlayerbotAI::KilledMonster(uint32 entry, uint64 guid)
+{
+   // isLooting = true;
+
+    if(m_master->isAlive() && m_IsFollowingMaster && !m_master->isInCombat())
+    {
+        if(!DoLoot())
+        {
+            float angle = rand_norm()*M_PI; //Generates random float between 0 and 3.14
+            float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10);
+
+            m_bot->GetMotionMaster()->Clear(true);
+            m_bot->GetMotionMaster()->MoveFollow(m_master, dist, angle);
+        }
+    }
+
+    // reset main tank every time we finish combat, just in case the
+    // original main tank died and got set to next tank.
+    //m_classAI->SetMainTank(NULL);
+}
+
+Spell *PlayerbotAI::GetCurrentSpell() const
+{
+    if(m_CurrentlyCastingSpellId == 0) return NULL;
+    Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
+    return pSpell;
+}
+
+void PlayerbotAI::TellMaster(const std::string &text)
+{
+    SendWhisper(text, *m_master);
+}
+
+bool PlayerbotAI::CanBotsFly()
+{
+    if (m_playerBotsFly==0) return false;
+    else return true;
+}
+
+void PlayerbotAI::SendWhisper(const std::string &text, Player &player)
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    m_bot->BuildPlayerChat(&data, CHAT_MSG_WHISPER_INFORM, text, LANG_UNIVERSAL);
+    player.GetSession()->SendPacket(&data);
+}
+
+bool PlayerbotAI::canObeyCommandFrom(const Player &player) const
+{
+    return player.GetSession()->GetAccountId() == m_master->GetSession()->GetAccountId();
+}
+
+void PlayerbotAI::SetInFront(const Unit *obj)
+{
+    if(!m_bot->HasInArc(M_PI, obj))
+    {
+        m_bot->SetInFront(obj);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+}
+
+bool PlayerbotAI::CastSpell(const char *args)
+{
+    uint32 spellId = getSpellId(args);
+    return(spellId) ? CastSpell(spellId) : false;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{
+    if (!spellId) return false;
+
+    if (!m_bot->HasSpell(spellId)) {
+        return false;
+    }
+
+    const SpellEntry * pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        sLog->outDebug("CRITICAL: PBot Class %u - Non-existing Spell in Cast - [%u]", m_bot->getClass(), spellId);
+        std::stringstream ss;
+        ss << "Missing spell entry in CastSpell - ";
+        ss << spellId;
+        TellMaster(ss.str());
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    return CastSpell(pSpellInfo, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered);
+}
+
+bool PlayerbotAI::CastSpell(const SpellEntry * pSpellInfo, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{
+    if(!m_bot->isAlive()) return false;
+    if(!pSpellInfo)
+    {
+        sLog->outError ("%s: Missing spell entry in CastSpell Direct", m_bot->GetName());
+        TellMaster("Missing spell entry in CastSpell");
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    uint32 spellId = pSpellInfo->Id;
+    uint64 oldSel = m_bot->GetSelection();
+
+    // Auto Targeting
+    if (!target)
+    {
+        //NEGATIVE SPELL
+        if (sSpellMgr->GetSpellCustomAttr(spellId) & SPELL_ATTR0_CU_NEGATIVE)
+        {
+            if (m_bot->GetSelection() <= 0) return false;
+            else
+            {
+                target = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+                if (!target) return false;
+            }
+        }
+        else { target = m_bot; }
+    }
+
+    //Make the Checks
+
+    if (!triggered && checkFirst && !CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck) ) { return false; }
+    if ( m_bot->GetSelection() != target->GetGUID() ) { m_bot->SetSelection(target->GetGUID()); } //if target is different than selection apply it
+
+    m_bot->CastSpell(target, pSpellInfo, triggered); //CAST THE SPELL
+    if ( m_bot->GetSelection() != oldSel ) { m_bot->SetSelection(oldSel); } // Restore if target changed to cast
+
+    // Check if the casting started..
+    Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+    if(!pSpell) return false;
+
+    // Trigger Pseudo Global Cooldown and consider casttime
+    float GCD = 1.5f;
+    if (m_bot->getPowerType() == POWER_ENERGY) GCD = 1;
+    float psCastTime = ((float)pSpell->GetCastTime()) / 1000.0f;
+    if (psCastTime - GCD > -0.3f) GCD = 0.3f; //Global cooldown won't be an issiue for casts (0.3 secs is for safe next cast)
+    else { GCD -= psCastTime; } //Remaining GCD after cast..
+    //float psRecoveryTime = GetSpellRecoveryTime(pSpellInfo) / 1000;
+    //sLog->outDebug("Bot [%u] Start Spell [%u] Cast Time [%f]", m_bot->GetGUIDLow(), pSpellInfo->Id, psCastTime);
+    m_CurrentlyCastingSpellId = spellId;
+    //SetIgnoreUpdateTime(psCastTime + GCD);
+    SetIgnoreUpdateTime(psCastTime > GCD ? psCastTime : GCD);
+    return true;
+}
+
+bool PlayerbotAI::CanCast(uint32 spellId, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+     //if spellId == 0, it means that the bot is not high enough level to
+    //have learned the spell
+    if (!spellId) return false;
+    const SpellEntry * pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        sLog->outDebug("CRITICAL: PBot Class %u - Non-existing Spell in Cast - [%u]", m_bot->getClass(), spellId);
+        std::stringstream ss;
+        ss << "Missing spell entry in CastSpell - ";
+        ss << spellId;
+        TellMaster(ss.str());
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    return CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);
+}
+
+bool PlayerbotAI::CanCast(const SpellEntry * pSpellInfo, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+    if (!pSpellInfo)
+    {
+        sLog->outDebug("CRITICAL: PBot Class %u - Non-existing Spell in CastCheck - Direct SpellEntry", m_bot->getClass());
+        TellMaster("Missing spell entry in CastSpell");
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    uint32 spellId = pSpellInfo->Id;
+
+    // Auto Targeting
+    if (!target)
+    {
+        //NEGATIVE SPELL
+        if (sSpellMgr->GetSpellCustomAttr(spellId) & SPELL_ATTR0_CU_NEGATIVE)
+        {
+            if (m_bot->GetSelection() <= 0) return false;
+            else
+            {
+                target = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+                if (!target) return false;
+            }
+        }
+        else { target = m_bot; }
+    }
+
+    if (!m_bot->isAlive()) return false;
+    if (m_bot->HasSpellCooldown(spellId)) return false;
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) return false;
+    if (m_bot->IsMounted()) return false;
+
+    //cast existing aura over again?
+    if (!castExistingAura && target->HasAura(spellId, m_bot->GetGUID())) return false;
+
+    //Stances-forms and equipment REQs
+    if (!skipEquipStanceCheck)
+    {
+        uint32 formMask = (GetForm() ? 1 << (GetPlayerBot()->GetShapeshiftForm() - 1) : 0);
+        //sLog->outDebug("DEBUG: Spell [%u] - Form [%X] - Need Form [%X] - Not Form [%X]", pSpellInfo->Id, formMask, pSpellInfo->Stances, pSpellInfo->StancesNot );
+        if (pSpellInfo->Stances & formMask) { return true; }
+        if (pSpellInfo->StancesNot && pSpellInfo->StancesNot & formMask) { return false; }
+        if (!m_bot->HasItemFitToSpellRequirements(pSpellInfo)) return false;
+    }
+
+    //Power Costs
+    const SpellSchoolMask pSpellSchool = GetSpellSchoolMask(pSpellInfo);
+    uint32 pPowerCost = CalculatePowerCost(pSpellInfo, m_bot, pSpellSchool);
+
+    if (skipEquipStanceCheck) { if (m_bot->GetPower((Powers)pSpellInfo->powerType) < pPowerCost) return false; } //Power check for Required PowerType (After changind stance, powertype may change, for druids)
+    else { if (m_bot->GetPower(m_bot->getPowerType()) < pPowerCost) return false; } //Power check for Current m_bot Power Type
+
+    //Distance / movement checks
+    const SpellRangeEntry * pSpellRange = sSpellRangeStore.LookupEntry(pSpellInfo->rangeIndex);
+    float curDistance = m_bot->GetDistance(target);
+    if (GetSpellCastTime(pSpellInfo) > 0 && m_bot->isMoving()) return false; //Cannot cast while moving
+
+    //The target is immune or not?
+    if (target->GetTypeId() != TYPEID_PLAYER) { if ( ((Creature*)target)->IsImmunedToSpell(pSpellInfo)) { return false; } }
+    else { if (target->IsImmunedToSpell(pSpellInfo)) { return false; } }
+
+    //target reaction checks (Has problems with dual effect spells like death coil/holy shock)
+    if (skipFriendlyCheck)
+    {
+        if (pSpellRange->maxRangeHostile != 0) { if ( pSpellRange->maxRangeHostile < curDistance || pSpellRange->minRangeHostile > curDistance ) { return false; } } //Assume hostile spell
+    }
+    else if (IsPositiveSpell(spellId))
+    {
+        if(! m_bot->IsFriendlyTo(target)) { return false; }
+        else if (pSpellRange->maxRangeFriend != 0) { if (pSpellRange->maxRangeFriend < curDistance || pSpellRange->minRangeFriend > curDistance) { return false; } }
+        else if (curDistance > MELEE_RANGE) return false;
+    }
+    else
+    {
+        if (m_bot->IsFriendlyTo(target))  return false;
+        if (!m_bot->HasInArc(M_PI,target)) return false; //target is not in front
+        if (pSpellRange->maxRangeHostile != 0) { if ( pSpellRange->maxRangeHostile < curDistance || pSpellRange->minRangeHostile > curDistance ) { return false; } }
+        else if (curDistance > MELEE_RANGE) return false; //Out of range - Melee Range
+    }
+
+    return true;
+}
+
+uint8 PlayerbotAI::GetForm(Unit *pPlayer)
+{
+    if (!pPlayer) pPlayer = m_bot;
+    return (pPlayer->GetUInt32Value(UNIT_FIELD_BYTES_2) & 0xFF000000) >> (4 * 6);
+}
+
+//extracts all item ids in format below
+//I decided to roll my own extractor rather then use the one in ChatHandler
+//because this one works on a const string, and it handles multiple links
+//|color|linkType:key:something1:...:somethingN|h[name]|h|r
+void PlayerbotAI::extractItemIds(const std::string &text, std::list<uint32> &itemIds) const
+{
+    uint8 pos = 0;
+    while(true)
+    {
+        int i = text.find("Hitem:", pos);
+        if(i == -1) break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if(endPos == -1) break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if(id) itemIds.push_back(id);
+    }
+}
+
+bool PlayerbotAI::extractGOinfo(const std::string& text, uint32 &guid, uint32 &entry, int &mapid, float &x, float &y, float &z) const
+{
+
+   //    Link format
+   //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':' << x << ':' << y << ':' << z  << ':' << mapid << ':' <<  "|h[" << gInfo->name << "]|h|r";
+
+     //    |cFFFFFF00|Hfound:5093:1731:-9295:-270:81.874:0:|h[Copper Vein]|h|r
+  uint8 pos = 0;
+      // extract GO guid
+       int i = text.find("Hfound:", pos); // base H = 11
+       if (i == -1) // break if error
+            return false;
+
+       pos = i + 7; //start of window in text 11 + 7 = 18
+      int endPos = text.find(':', pos); // end of window in text 22
+      if (endPos == -1) //break if error
+           return false;
+       std::string guidC = text.substr(pos, endPos - pos); // get string within window i.e guid 22 - 18 =  4
+       guid = atol(guidC.c_str()); // convert ascii to long int
+     // extract GO entry
+       pos = endPos + 1;
+      endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+      std::string entryC = text.substr(pos, endPos - pos); // get string within window i.e entry
+        entry = atol(entryC.c_str()); // convert ascii to float
+     // extract GO x
+       pos = endPos + 1;
+      endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+       std::string xC = text.substr(pos, endPos - pos); // get string within window i.e x
+
+        x = atof(xC.c_str()); // convert ascii to float
+      // extract GO y
+       pos = endPos + 1;
+      endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+      std::string yC = text.substr(pos, endPos - pos); // get string within window i.e y
+      y = atof(yC.c_str()); // convert ascii to float
+     // extract GO z
+
+        pos = endPos + 1;
+       endPos = text.find(':', pos); // end of window in text
+        if (endPos == -1) //break if error
+           return false;
+
+       std::string zC = text.substr(pos, endPos - pos); // get string within window i.e z
+
+        z = atof(zC.c_str()); // convert ascii to float
+
+      //extract GO mapid
+       pos = endPos + 1;
+       endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+      std::string mapidC = text.substr(pos, endPos - pos); // get string within window i.e mapid
+       mapid = atoi(mapidC.c_str()); // convert ascii to int
+        pos = endPos; // end
+      return true;
+}
+
+//extracts currency in #g#s#c format
+uint32 PlayerbotAI::extractMoney(const std::string &text) const
+{
+    //if user specified money in ##g##s##c format
+    std::string acum = "";
+    uint32 copper = 0;
+    for(uint8 i = 0; i < text.length(); i++)
+    {
+        if(text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if(text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if(text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if(text[i] == ' ')
+        {
+            break;
+        }
+        else if(text[i] >= 48 && text[i] <= 57)
+        {
+            acum += text[i];
+        } else {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+// finds items in equipment and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+    for( uint8 slot=EQUIPMENT_SLOT_START; itemIdSearchList.size()>0 && slot<EQUIPMENT_SLOT_END; slot++ ) {
+        Item* const pItem = m_bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+        if( !pItem )
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetProto()->ItemId != *it)
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+}
+
+
+//finds items in inventory and adds Item *to foundItemList
+//also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+
+    //look for items in main bag
+    for(uint8 slot = INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 && slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem) continue;
+        for(std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if(pItem->GetProto()->ItemId != *it) continue;
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+
+    //for all for items in other bags
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 && bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(!pBag) continue;
+        for(uint8 slot = 0; itemIdSearchList.size() > 0 && slot < pBag->GetBagSize(); ++slot)
+        {
+            Item *const pItem = m_bot->GetItemByPos(bag, slot);
+            if(!pItem) continue;
+            for(std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+            {
+                if(pItem->GetProto()->ItemId != *it) continue;
+                foundItemList.push_back(pItem);
+                itemIdSearchList.erase(it);
+                break;
+            }
+        }
+    }
+}
+
+bool PlayerbotAI::HasPick()
+{
+    QueryResult result;
+
+    // list out equiped items
+    for( uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+        if (pItem )
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                if (!pItemProto )
+                    continue;
+
+            result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemProto->ItemId);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 tc = fields[0].GetUInt32();
+                // sLog->outDebug("HasPick %u",tc);
+                if(tc ==  165 || tc == 167) // pick = 165, hammer = 162 or hammer pick = 167
+                    return true;
+            }
+        }
+    }
+
+    // list out items in backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug("[%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot); // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemPrototype* const pItemProto = pItem->GetProto();
+            if (!pItemProto )
+                continue;
+            result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemProto->ItemId);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 tc = fields[0].GetUInt32();
+                // sLog->outDebug("HasPick %u",tc);
+                if(tc ==  165 || tc == 167) // pick = 165, hammer = 162 or hammer pick = 167
+                    return true;
+            }
+        }
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag); // 255, 20 to 23
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog->outDebug("[%s's]bag[%u] slot = %u",m_bot->GetName(),bag,slot); // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+
+                    if (!pItemProto )
+                        continue;
+
+                    result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemProto->ItemId);
+                    if (result)
+                    {
+
+                        Field *fields = result->Fetch();
+                        uint32 tc = fields[0].GetUInt32();
+                        // sLog->outDebug("HasPick %u",tc);
+                        if(tc ==  165 || tc == 167)
+                            return true;
+                    }
+                }
+            }
+        }
+    }
+    std::ostringstream out;
+    out << "|cffffffffI do not have a pick!";
+    TellMaster( out.str().c_str() );
+    return false;
+}
+
+
+//submits packet to use an item
+void PlayerbotAI::PoisonWeapon(Item &item, uint32 _spellId, uint32 _target, EquipmentSlots weaponSlot)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 cast_count = 1;
+    uint32 spellid = _spellId;
+    uint64 item_guid = item.GetGUID();
+    uint32 glyphIndex = 0; //??
+    uint8 unk_flags = 0; //not 0x02
+
+    uint32 target = _target;
+    uint32 targetItemGUID = 0;
+    uint8 x = 0;
+    Item *weapon=NULL;
+    if (_spellId>0){
+
+        targetItemGUID = 16;
+        x = 135;
+        cast_count = 7;
+        weapon = GetPlayerBot()->GetItemByPos( INVENTORY_SLOT_BAG_0, weaponSlot );
+
+    }
+
+    WorldPacket *const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1 + 4);
+    *packet << bagIndex << slot << cast_count << spellid << item_guid << glyphIndex << unk_flags << target;
+    if (weapon) packet->appendPackGUID(weapon->GetGUID());
+
+    m_bot->GetSession()->QueuePacket(packet); //queue the packet to get around race condition
+
+} // end PoisonWeapon
+
+
+
+//submits packet to use an item
+void PlayerbotAI::UseItem(Item &item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 cast_count = 1;
+    uint32 spellid = 0; //only used in combat
+    uint64 item_guid = item.GetGUID();
+    uint32 glyphIndex = 0; //??
+    uint8 unk_flags = 0; //not 0x02
+
+    //create target data
+    //note other targets are possible but not supported at the moment
+    //see SpellCastTargets::read in Spell.cpp to see other options
+    //for setting target
+
+    uint32 target = TARGET_FLAG_SELF;
+
+    WorldPacket *const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1);
+    *packet << bagIndex << slot << cast_count << spellid << item_guid << glyphIndex << unk_flags << target;
+    m_bot->GetSession()->QueuePacket(packet); //queue the packet to get aroundrace condition
+
+} // end UseItem
+
+
+//submits packet to use an item
+void PlayerbotAI::EquipItem(Item &item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+
+    WorldPacket *const packet = new WorldPacket(CMSG_AUTOEQUIP_ITEM, 2);
+    *packet << bagIndex << slot;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+// submits packet to trade an item (trade window must already be open)
+// default slot is -1 which means trade slots 0 to 5. if slot is set
+// to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+// 'Will not be traded' slot.
+bool PlayerbotAI::TradeItem(const Item& item, int8 slot)
+{
+    sLog->outDebug( "[PlayerbotAI::TradeItem]: slot=%d, hasTrader=%d, itemInTrade=%d, itemTradeable=%d",
+        slot,
+        (m_bot->GetTrader()?1:0),
+        (item.IsInTrade()?1:0),
+        (item.CanBeTraded()?1:0)
+        );
+
+    if (!m_bot->GetTrader() || item.IsInTrade())
+        return false;
+
+    int8 tradeSlot = -1;
+
+    if( (slot>=0 && slot<TRADE_SLOT_COUNT) /* && m_bot->GetItem(trade slot)==NULL_SLOT */) {
+        tradeSlot = slot;
+    } else if (!item.CanBeTraded())
+    {
+        tradeSlot = (uint8) TRADE_SLOT_NONTRADED;
+    }
+    else
+    {
+        for( uint8 i=0; i<TRADE_SLOT_TRADED_COUNT; ++i )
+        {
+			if (m_bot->GetTradeData()->GetItem(TradeSlots(i)) == NULL){
+                tradeSlot = (uint8)i;
+                break;
+			}
+        }
+    }
+
+    if( tradeSlot == -1 ) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+            << (uint8) item.GetSlot();
+    m_bot->GetSession()->QueuePacket(packet);
+
+    return true;
+}
+
+
+//submits packet to trade copper (trade window must be open)
+bool PlayerbotAI::TradeCopper(uint32 copper)
+{
+    if(copper > 0)
+    {
+        WorldPacket *const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        m_bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+    return false;
+}
+
+void PlayerbotAI::Stay()
+{
+    if (!m_IsFollowingMaster)
+        return;
+
+    m_IsFollowingMaster = false;
+    m_bot->GetMotionMaster()->Clear(true);
+    m_bot->HandleEmoteCommand(EMOTE_ONESHOT_SALUTE);
+}
+
+
+bool PlayerbotAI::Follow(Player &player)
+{
+    if(m_master <= 0 || ((m_master->isInCombat() || m_bot->isInCombat()) && m_bot->isDead())) return false; //You're DEAD, stop thinking.
+    if(m_master->isDead()) return false;
+    if(m_master->IsBeingTeleported() || m_master->isInFlight()) return false;
+
+    if(m_bot->getStandState() == UNIT_STAND_STATE_SIT && (m_TimeDoneDrinking < time(0) && m_TimeDoneEating < time(0))) return false; //Do no interrupt if bot is eating/drinking
+
+    m_IsFollowingMaster = true;
+
+    if(!m_bot->IsStandState()) {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+
+    if(!m_bot->isInCombat())
+    {
+        //if bot is dead and master is alive, revive bot
+        if(m_master->isAlive() && !m_bot->isAlive())
+        {
+            SetIgnoreUpdateTime(6);
+            isLooting = false;
+            PlayerbotChatHandler ch(m_master);
+            if(!ch.revive(*m_bot))
+            {
+                ch.sysmessage(".. could not be revived ..");
+                return false;
+            }
+        }
+
+        if(!m_bot->isDead() && !m_bot->IsBeingTeleported() && !player.isDead() &&
+            (m_bot->GetMapId() != player.GetMapId()
+            || m_bot->GetZoneId() != player.GetZoneId()
+            || m_bot->GetAreaId() != player.GetAreaId()
+            || m_bot->GetPhaseMask() != player.GetPhaseMask())
+            || m_bot->GetDistance(player) > 255)
+            {
+                SetIgnoreUpdateTime(6);
+                isLooting = false;
+                PlayerbotChatHandler ch(m_master);
+                if(!ch.teleport(*m_bot))
+                {
+                    ch.sysmessage(".. could not be teleported ..");
+                    return false;
+                }
+        }
+    }
+
+    if(m_bot->isAlive() && !isLooting)
+    {
+        float angle = M_PI/2 + rand_norm()*M_PI ; //Generates random float between 90 and 270 degrees
+        float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10); // Using urand to get a random float is stupid.
+        m_bot->GetMotionMaster()->Clear(true);
+        m_bot->GetMotionMaster()->MoveFollow(&player, dist, angle);
+
+        return true;
+    }
+    return false;
+}
+
+//handle commands sent through chat channels
+void PlayerbotAI::HandleCommand(const std::string &text, Player &fromPlayer)
+{
+    //ignore any messages from Addons
+    if(text.empty() ||
+        text.find("X-Perl") != std::wstring::npos ||
+        text.find("HealBot") != std::wstring::npos ||
+        text.find("LOOT_OPENED") != std::wstring::npos ||
+        text.find("CTRA") != std::wstring::npos)
+        return;
+
+    //if message is not from a player in the masters account auto reply and ignore
+    if(!canObeyCommandFrom(fromPlayer))
+    {
+        std::string msg = "I can't talk to you. Please speak to my master ";
+        msg += m_master->GetName();
+        msg += ".";
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
+        SendWhisper(msg, fromPlayer);
+    }
+
+
+    else if (text == "I could use a drink." &&
+             m_bot->getClass() == CLASS_MAGE)
+    {
+            Item const*pItem = FindDrink();
+            if (pItem != NULL) {
+                WorldPacket *p = new WorldPacket(CMSG_INITIATE_TRADE, 8);
+                *p << fromPlayer.GetGUID();
+                m_bot->GetSession()-> HandleInitiateTradeOpcode(*p);
+                SendWhisper ("Here is a tasty treat for you", fromPlayer);
+
+            }
+    }
+    // accept food/drink from mage
+    else if (text == "Here is a tasty treat for you")
+    {
+        m_bot->Say ("Thank you for this treat", LANG_UNIVERSAL);
+        SendWhisper ("Thank you for this treat.", fromPlayer);
+    }
+    // trade opened so send items over
+    else if (text == "Thank you for this treat")
+    {
+        if (m_bot->getClass()!=CLASS_MAGE) return;
+
+        Item const*pItem = FindDrink();
+        if (pItem==NULL) return;
+
+        bool trade = TradeItem (*pItem,2);
+        if (trade) {
+            m_bot->Say("Enjoy the refreshing drink.", LANG_UNIVERSAL);
+
+			WorldPacket* const packet = new WorldPacket(CMSG_ACCEPT_TRADE, 3);
+			m_bot->GetSession()->QueuePacket(packet);  // packet is not used
+        } else {
+            m_bot->Say ("I cannot trade with you.", LANG_UNIVERSAL);
+        }
+    }
+
+    // if in the middle of a trade, and player asks for an item/money
+    else if (m_bot->GetTrader() && m_bot->GetTrader()->GetGUID() == fromPlayer.GetGUID() &&
+        fromPlayer.GetPlayerbotAI() == NULL)
+    {
+        uint32 copper = extractMoney(text);
+        if (copper > 0)
+            TradeCopper(copper);
+
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (itemIds.size() == 0)
+            SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
+        else
+        {
+            std::list<Item*> itemList;
+            findItemsInInv(itemIds, itemList);
+            findItemsInEquip(itemIds, itemList);
+            for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+                TradeItem(**it);
+        }
+    }
+
+
+
+    else if(text == "follow" || text == "come")
+        Follow(*m_master);
+
+    else if(text == "stay" || text == "stop")
+        Stay();
+
+    //handle cast command
+    else if(text.size() > 2 && text.substr(0, 2) == "c " ||
+        text.size() > 5 && text.substr(0, 5) == "cast ")
+        {
+            uint32 spellId = 0;
+            std::string spellStr = text.substr(text.find(" ") + 1);
+
+            if(spellStr.find("Hspell:"))
+            {
+                spellStr = spellStr.substr(spellStr.find("|h[") + 3);
+                spellStr = spellStr.substr(0, spellStr.find("]"));
+            } else
+                spellId = (uint32)atol(spellStr.c_str());
+
+            //try and get spell ID by name
+            if(spellId == 0) spellId = getSpellId(spellStr.c_str(), true);
+
+            uint64 castOnGuid = fromPlayer.GetSelection();
+            if(castOnGuid == 0) castOnGuid = m_bot->GetGUID();
+            if(spellId != 0)
+            {
+                m_spellIdCommand = spellId;
+                m_targetGuidCommand = castOnGuid;
+            }
+    }
+
+    //use items
+    else if(text.size() > 2 && text.substr(0, 2) == "u " ||
+    text.size() > 4 && text.substr(0, 4) == "use ")
+    {
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it) UseItem(**it);
+    }
+
+    // poison mainhand weapon
+    else if(text.size() > 2 && text.substr(0, 2) == "p " ||
+    text.size() >= 8 && text.substr(0, 8) == "poison m")
+    {
+
+        Item *poison = FindPoisonForward();
+        if(poison == NULL) {
+            std::string msg = "No poison found for mainhand.";
+            SendWhisper(msg, fromPlayer);
+            return;
+        }
+
+        PoisonWeapon(*poison, poison->GetProto()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_MAINHAND);
+    }
+
+    // poison offhand weapon
+    else if(text.size() >= 8 && text.substr(0, 8) == "poison o")
+    {
+
+        Item *poison = FindPoisonBackward();
+        if(poison == NULL) {
+            std::string msg = "No poison found for offhand.";
+            SendWhisper(msg, fromPlayer);
+            return;
+        }
+
+        PoisonWeapon(*poison, poison->GetProto()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_OFFHAND);
+    }
+
+    // npcbot commands
+    else if(text.size() >= 8 && text.substr(0, 8) == "npcbot a")
+    {
+        if(m_bot->HaveBot()) {
+            SendWhisper("I already have a bot.", fromPlayer);
+            return;
+        }
+
+        std::string text1 = text.substr(text.find(" ") + 1);
+        std::string botClass = text1.substr(text1.find(" ") + 1);
+
+
+        if (botClass == "priest") m_bot->CreateNPCBot(CLASS_PRIEST);
+        else if (botClass == "warrior") m_bot->CreateNPCBot(CLASS_WARRIOR);
+        else if (botClass == "druid") m_bot->CreateNPCBot(CLASS_DRUID);
+        else if (botClass == "paladin") m_bot->CreateNPCBot(CLASS_PALADIN);
+        else if (botClass == "hunter") m_bot->CreateNPCBot(CLASS_HUNTER);
+        else if (botClass == "mage") m_bot->CreateNPCBot(CLASS_MAGE);
+        else if (botClass == "warlock") m_bot->CreateNPCBot(CLASS_WARLOCK);
+        else if (botClass == "shaman") m_bot->CreateNPCBot(CLASS_SHAMAN);
+        else if (botClass == "rogue") m_bot->CreateNPCBot(CLASS_ROGUE);
+        else {
+             SendWhisper("Unknown class", fromPlayer);
+             return;
+        }
+
+       // m_master->CreateNPCBot(CLASS_PALADIN);
+    }
+    else if(text.size() >= 8 && text.substr(0, 8) == "npcbot d")
+    {
+        if(m_bot->HaveBot())
+            m_bot->SetBotMustDie();
+    }
+
+    //equip items
+    else if(text.size() > 2 && text.substr(0, 2) == "e " ||
+    text.size() > 6 && text.substr(0, 6) == "equip ")
+    {
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+         for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it) EquipItem(**it);
+    }
+
+    else if(text == "spells")
+    {
+        int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+        std::ostringstream posOut;
+        std::ostringstream negOut;
+
+        const std::string ignoreList = ",Opening,Closing,Stuck,Remove Insignia,Opening - No Text,Grovel,Duel,Honorless Target,";
+        std::string alreadySeenList = ",";
+
+        for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        {
+            const uint32 spellId = itr->first;
+
+            if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || IsPassiveSpell(spellId))
+                continue;
+
+            const SpellEntry *const pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if(!pSpellInfo)
+                continue;
+
+            //|| name.find("Teleport") != -1
+
+            std::string comp = ",";
+            comp.append(pSpellInfo->SpellName[loc]);
+            comp.append(",");
+
+            if(!(ignoreList.find(comp) == std::string::npos &&
+                alreadySeenList.find(comp) == std::string::npos))
+                continue;
+
+            alreadySeenList += pSpellInfo->SpellName[loc];
+            alreadySeenList += ",";
+
+            if(IsPositiveSpell(spellId))
+                posOut << " |cffffffff|Hspell:" << spellId << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+            else
+                negOut << " |cffffffff|Hspell:" << spellId << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+        }
+
+        ChatHandler ch(&fromPlayer);
+        SendWhisper("Here's my non-attack spells:", fromPlayer);
+        ch.SendSysMessage(posOut.str().c_str());
+        SendWhisper("Here's my attack spells:", fromPlayer);
+        ch.SendSysMessage(negOut.str().c_str());
+    }
+
+    else if (text.size() > 13 && text.substr(0,13) == "accept quest ")
+    {
+        uint32 questId = 0;
+        std::string questStr = text.substr(text.find(" ") + 1);
+        questStr = questStr.substr(questStr.find(" ") + 1);
+        std::string questStrLink = questStr;
+        if (questStr.find("Hquest:"))
+        {
+            questStr = questStr.substr(questStr.find("|h[") + 3);
+            questStr = questStr.substr(0, questStr.find("]"));
+        }
+        else
+            questId = (uint32)atol(questStr.c_str());
+
+        // try and get quest ID by name
+        if (questId == 0)
+            questId = getQuestId(questStr.c_str(), 0);
+        std::ostringstream out;
+        out << "Quest " << questId << " " << questStr.c_str();
+
+        PlayerbotChatHandler ch(m_master);
+        uint64 oldSel = 0;
+        if (m_master->GetSelection())
+            oldSel = m_master->GetSelection();
+        m_master->SetSelection(m_bot->GetGUID());
+        if (questId != 0 && ch.acceptQuest(questStrLink.c_str()))
+        {
+            out << " accepted.";
+            TellMaster(out.str());
+        }
+        else
+        {
+            out << " not accepted.";
+            TellMaster(out.str());
+        }
+        if (oldSel > 0)
+            m_master->SetSelection(oldSel);
+    }
+
+    else if (text.size() > 14 && text.substr(0,14) == "abandon quest ")
+    {
+        uint32 questId = 0;
+        std::string questStr = text.substr(text.find(" ") + 1);
+        questStr = questStr.substr(questStr.find(" ") + 1);
+        std::string questStrLink = questStr;
+        if (questStr.find("Hquest:"))
+        {
+            questStr = questStr.substr(questStr.find("|h[") + 3);
+            questStr = questStr.substr(0, questStr.find("]"));
+        }
+        else
+            questId = (uint32)atol(questStr.c_str());
+
+        // try and get quest ID by name
+        if (questId == 0)
+            questId = getQuestId(questStr.c_str(), 1);
+        std::ostringstream out;
+        out << "Quest " << questId << " " << questStr.c_str();
+
+        PlayerbotChatHandler ch(m_master);
+        uint64 oldSel = 0;
+        if (m_master->GetSelection())
+            oldSel = m_master->GetSelection();
+        m_master->SetSelection(m_bot->GetGUID());
+        if (questId != 0 && ch.abandonQuest(questStrLink.c_str()))
+        {
+            out << " abandoned.";
+            TellMaster(out.str());
+        }
+               else
+        {
+            out << " not abandoned.";
+            TellMaster(out.str());
+        }
+        if (oldSel > 0)
+            m_master->SetSelection(oldSel);
+    }
+
+    else if (text.size() == 1 && text.substr(0,1) == "q" ||
+        text == "quests")
+    {
+        std::ostringstream out;
+        for (QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+        {
+            const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+            if (!qInfo)
+                continue;
+            QuestStatusData *qData = &iter->second;
+
+            uint32 questId = qInfo->GetQuestId();
+            const std::string name = qInfo->GetTitle();
+            if (name.empty())
+                continue;
+            //out << qData->m_status << " ";
+            if (qData->m_status == QUEST_STATUS_NONE)
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " no status" << "\n";
+                continue;
+            }
+            else if (qData->m_status == QUEST_STATUS_COMPLETE)
+            {
+                out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                out << " complete" << "\n";
+            }
+            else if (qData->m_status == QUEST_STATUS_UNAVAILABLE)
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " unavailable" << "\n";
+                continue;
+            }
+            else if (qData->m_status == QUEST_STATUS_INCOMPLETE)
+            {
+                out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                out << " incomplete" << "\n";
+            }
+            else if (qData->m_status == QUEST_STATUS_AVAILABLE)
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " available" << "\n";
+                continue;
+            }
+            else if (qData->m_status == QUEST_STATUS_FAILED)
+            {
+                out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                out << " failed" << "\n";
+            }
+            else
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " unknown" << "\n";
+                continue;
+            }
+        }
+        if (!out.str().empty())
+            TellMaster(out.str());
+    }
+
+    else if (text == "train")
+    {
+         Unit *unit = m_master->GetSelectedUnit();
+
+         if (!unit)
+         {
+             TellMaster("Please select the trainer which I should learn  from!");
+             return;
+         }
+         if (!unit->isTrainer())
+         {
+             TellMaster("This is not a trainer!");
+             return;
+         }
+
+         Creature *creature =  m_bot->GetMap()->GetCreature(m_master->GetSelection());
+         if(!creature->isCanTrainingOf(m_bot, false))
+         {
+             TellMaster("This trainer can not train me anything at  all!");
+             return;
+         }
+
+         CreatureInfo const *ci = creature->GetCreatureInfo();
+
+         if (!ci)
+         {
+             TellMaster("This trainer can not train me anything at  all!");
+             return;
+         }
+
+         TrainerSpellData const* trainer_spells =  creature->GetTrainerSpells();
+         if(!trainer_spells)
+         {
+             TellMaster("No training spells can be found from this  trainer");
+             return;
+         }
+         // reputation discount
+         float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+         bool can_learn_primary_prof =  m_bot->GetFreePrimaryProfessionPoints() > 0;
+
+         std::ostringstream msg;
+         msg << "I had learnt the following spells:\n";
+         uint32 totalCost = 0;
+         uint32 totalSpellLearnt = 0;
+         int loc = m_master->GetSession()->GetSessionDbcLocale();
+         for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+         {
+             TrainerSpell const* tSpell = &itr->second;
+
+             bool valid = true;
+             bool primary_prof_first_rank = false;
+             for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+             {
+                 if (!tSpell->learnedSpell[i])
+                     continue;
+                  if(!m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[i]))
+                 {
+                     valid = false;
+                     break;
+                 }
+                 if  (sSpellMgr->IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell[i]))
+                     primary_prof_first_rank = true;
+             }
+             if (!valid)
+                 continue;
+
+             TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+             if (state != TRAINER_SPELL_GREEN)
+             {
+                 continue;
+             }
+             //data << uint32(primary_prof_first_rank &&  can_learn_primary_prof ? 1 : 0);
+             uint32 spellId = tSpell->spell;
+             const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+             if (!pSpellInfo)
+             {
+                 continue;
+             }
+             uint32 cost = (uint32) (floor(tSpell->spellCost *  fDiscountMod));
+
+             // check money requirement
+             if(m_bot->GetMoney() < cost )
+                 continue;
+
+             m_bot->ModifyMoney( -int32(cost) );
+
+             // learn explicitly or cast explicitly
+             if(tSpell->IsCastable())
+                 //FIXME: prof. spell entry in trainer list not marked  gray until list re-open.
+                 m_bot->CastSpell(m_bot,tSpell->spell,true);
+             else
+                 m_bot->learnSpell(spellId,false);
+             totalSpellLearnt++;
+             totalCost = totalCost + cost;
+
+             msg << " |cffffffff|Hspell:" << spellId <<  "|h[" << pSpellInfo->SpellName[loc] << "]|h|r" <<  ", ";
+             uint32 gold = uint32(cost / 10000);
+             cost -= (gold * 10000);
+             uint32 silver = uint32(cost / 100);
+             cost -= (silver * 100);
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << cost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+         }
+
+         uint32 gold = uint32(totalCost / 10000);
+         totalCost -= (gold * 10000);
+         uint32 silver = uint32(totalCost / 100);
+         totalCost -= (silver * 100);
+         msg << "Total of " << totalSpellLearnt << "  spell(s) learnt, ";
+         if (gold > 0)
+         {
+             msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+         }
+         if (silver > 0)
+         {
+             msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+         }
+         msg << totalCost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t spent.";
+
+         TellMaster(msg.str());
+
+         m_bot->GetPlayerbotAI()->GetClassAI()->LoadSpells();
+
+    }
+    else if (text == "train list")
+    {
+         Unit *unit = m_master->GetSelectedUnit();
+
+         if (!unit)
+         {
+             TellMaster("Please select the trainer which I should learn  from!");
+             return;
+         }
+         if (!unit->isTrainer())
+         {
+             TellMaster("This is not a trainer!");
+             return;
+         }
+
+         Creature *creature =  m_bot->GetMap()->GetCreature(m_master->GetSelection());
+         if(!creature->isCanTrainingOf(m_bot, false))
+         {
+             TellMaster("This trainer can not train me anything at  all!");
+             return;
+         }
+
+         CreatureInfo const *ci = creature->GetCreatureInfo();
+
+         if (!ci)
+         {
+             TellMaster("This trainer can not train me anything at  all!");
+             return;
+         }
+
+         TrainerSpellData const* trainer_spells =  creature->GetTrainerSpells();
+         if(!trainer_spells)
+         {
+             TellMaster("No training spells can be found from this  trainer");
+             return;
+         }
+         // reputation discount
+         float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+         bool can_learn_primary_prof =  m_bot->GetFreePrimaryProfessionPoints() > 0;
+
+         std::ostringstream msg;
+         msg << "The spells I can learn and their costs are:\n";
+         uint32 totalCost = 0;
+         int loc = m_master->GetSession()->GetSessionDbcLocale();
+         for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+         {
+             TrainerSpell const* tSpell = &itr->second;
+
+             bool valid = true;
+             bool primary_prof_first_rank = false;
+             for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+             {
+                 if (!tSpell->learnedSpell[i])
+                     continue;
+                  if(!m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[i]))
+                 {
+                     valid = false;
+                     break;
+                 }
+                 if  (sSpellMgr->IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell[i]))
+                     primary_prof_first_rank = true;
+             }
+             if (!valid)
+                 continue;
+
+             TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+             if (state != TRAINER_SPELL_GREEN)
+             {
+                 continue;
+             }
+             //data << uint32(primary_prof_first_rank &&  can_learn_primary_prof ? 1 : 0);
+             uint32 spellId = tSpell->spell;
+             const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+             if (!pSpellInfo)
+             {
+                 continue;
+             }
+             uint32 cost = (uint32) (floor(tSpell->spellCost *  fDiscountMod));
+             totalCost = totalCost + cost;
+
+             uint32 gold = uint32(cost / 10000);
+             cost -= (gold * 10000);
+             uint32 silver = uint32(cost / 100);
+             cost -= (silver * 100);
+             msg << " |cffffffff|Hspell:" << spellId <<  "|h[" << pSpellInfo->SpellName[loc] << "]|h|r" <<  ", ";
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << cost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+         }
+         uint32 moneyDiff = m_bot->GetMoney() - totalCost;
+         if (moneyDiff >= 0)
+         {
+             uint32 gold = uint32(moneyDiff / 10000);
+             moneyDiff -= (gold * 10000);
+             uint32 silver = uint32(moneyDiff / 100);
+             moneyDiff -= (silver * 100);
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << moneyDiff <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t left.";
+             }
+         else
+         {
+             moneyDiff = moneyDiff * (-1);
+             uint32 gold = uint32(moneyDiff / 10000);
+             moneyDiff -= (gold * 10000);
+             uint32 silver = uint32(moneyDiff / 100);
+             moneyDiff -= (silver * 100);
+             msg << "I need ";
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << moneyDiff <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t more to learn all the  spells!";
+         }
+         TellMaster(msg.str());
+
+    }
+ else if(text.size() >= 4 && text.substr(0, 4) == "sell")
+    {
+        Unit *unit = m_master->GetSelectedUnit();
+
+        if (!unit)
+        {
+            TellMaster("Please show me who I should trade with!");
+            return;
+        }
+        if (!unit->isVendor())
+        {
+            TellMaster("This person does not want to trade with me!");
+            return;
+        }
+        if (!m_bot->IsInMap((WorldObject*) unit))
+        {
+            TellMaster("I'm too far away to sell items!");
+            return;
+        }
+        uint32 TotalCost = 0;
+        uint32 TotalSold = 0;
+        std::ostringstream report;
+
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+        {
+            if ((**it).GetProto()->SellPrice > 0)
+            {
+                int32 cost = (**it).GetCount() * (**it).GetProto()->SellPrice;
+                m_bot->ModifyMoney(cost);
+                m_bot->MoveItemFromInventory((**it).GetBagSlot(), (**it).GetSlot(), true);
+
+                TotalSold = TotalSold + 1;
+                TotalCost = TotalCost + cost;
+
+                if ((**it).GetCount() > 0) {
+                    report << "Sold " << (**it).GetCount() << "x";
+                    report << " |cffffffff|Hitem:" << (**it).GetProto()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << (**it).GetProto()->Name1 << "]|h|r";
+                    report << " for ";
+
+                    uint32 gold = uint32(cost / 10000);
+                    cost -= (gold * 10000);
+                    uint32 silver = uint32(cost / 100);
+                    cost -= (silver * 100);
+
+                    if (gold > 0)
+                    {
+                        report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                    }
+                    if (silver > 0)
+                    {
+                        report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                    }
+                    report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+                }
+            }
+        }
+        if (TotalSold > 0) {
+            report << "Sold total " << TotalSold << " item(s) for ";
+
+            uint32 gold = uint32(TotalCost / 10000);
+            TotalCost -= (gold * 10000);
+            uint32 silver = uint32(TotalCost / 100);
+            TotalCost -= (silver * 100);
+
+            if (gold > 0)
+            {
+                report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+            }
+            if (silver > 0)
+            {
+                report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+            }
+            report << TotalCost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t.";
+            TellMaster(report.str());
+        }
+    }
+
+ else if (text.size() > 2 && text.substr(0, 2) == "g " || text.size() > 4 && text.substr(0, 4) == "get ")
+ {
+     uint32 guid;
+     float x,y,z;
+     uint32 entry;
+     int mapid;
+     if (extractGOinfo(text, guid, entry, mapid, x, y, z))
+     {
+         sLog->outDebug("find: guid : %u entry : %u x : (%f) y : (%f) z : (%f) mapid : %d",guid, entry, x, y, z, mapid);
+         m_lootCurrent = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+         GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+         if (!go)
+         {
+             m_bot->Say("I can't find it.", LANG_UNIVERSAL);
+             m_lootCurrent = 0;
+             return;
+         }
+
+         if ( !go->isSpawned() ) {
+             m_bot->Say("It is not there anymore.", LANG_UNIVERSAL);
+             return;
+         }
+
+         m_bot->UpdateGroundPositionZ(x,y,z);
+         m_bot->GetMotionMaster()->MovePoint( mapid, x, y, z );
+         m_bot->SetPosition(x, y, z, m_bot->GetOrientation());
+         m_bot->SendLoot( m_lootCurrent, LOOT_CORPSE );
+         Loot *loot = &go->loot;
+         uint32 lootNum = loot->GetMaxSlotInLootFor( m_bot );
+
+         sLog->outDebug( "[PlayerbotAI]: GetGOType %u - %s looting: '%s' got %d items", go->GetGoType(), m_bot->GetName(), go->GetGOInfo()->name, loot->GetMaxSlotInLootFor( m_bot ));
+         for ( uint32 l=0; l<lootNum; l++ )
+         {
+             QuestItem *qitem=0, *ffaitem=0, *conditem=0;
+             LootItem *item = loot->LootItemInSlot( l, m_bot, &qitem, &ffaitem, &conditem );
+             if ( !item )
+                 continue;
+
+             if ( !qitem && item->is_blocked )
+             {
+                 m_bot->SendLootRelease( m_lootCurrent );
+                 continue;
+             }
+
+             if ( m_needItemList[item->itemid]>0 )
+             {
+                 ItemPosCountVec dest;
+                 if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count ) == EQUIP_ERR_OK )
+                 {
+                     Item * newitem = m_bot->StoreNewItem( dest, item->itemid, true, item->randomPropertyId);
+                     if ( qitem )
+                     {
+                         qitem->is_looted = true;
+                         if ( item->freeforall || loot->GetPlayerQuestItems().size() == 1 )
+                             m_bot->SendNotifyLootItemRemoved( l );
+                         else
+                             loot->NotifyQuestItemRemoved( qitem->index );
+                     }
+                     else
+                     {
+                         if ( ffaitem )
+                         {
+                             ffaitem->is_looted=true;
+                             m_bot->SendNotifyLootItemRemoved( l );
+                         }
+                         else
+                         {
+                             if ( conditem )
+                                 conditem->is_looted=true;
+                             loot->NotifyItemRemoved( l );
+                         }
+                     }
+                     if (!item->freeforall)
+                         item->is_looted = true;
+                     --loot->unlootedCount;
+                     m_bot->SendNewItem( newitem, uint32(item->count), false, false, true );
+
+                     m_bot->GetAchievementMgr().UpdateAchievementCriteria( ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count );
+                 }
+             }
+             uint32 lockId = go->GetGOInfo()->GetLockId();
+             LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+             if(lockInfo)
+             {
+                 uint32 skillId = SkillByLockType(LockType(lockInfo->Index[0]));
+                 switch(skillId)
+                 {
+                 case SKILL_MINING:
+                     if (m_bot->HasSkill(SKILL_MINING) && HasPick()) // Has skill & suitable pick
+                     {
+                         ItemPosCountVec dest;
+                         if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK )
+                         {
+                             Item* pItem = m_bot->StoreNewItem (dest,item->itemid,true,item->randomPropertyId);
+                             uint32 reqSkillValue = lockInfo->Skill[0];
+                             uint32 SkillValue = m_bot->GetPureSkillValue(SKILL_MINING);
+                             if (SkillValue >= reqSkillValue)
+                             {
+                                 m_bot->SendNewItem(pItem, uint32(item->count), false, false, true);
+                                 m_bot->UpdateGatherSkill(SKILL_MINING, SkillValue, reqSkillValue);
+                                 --loot->unlootedCount;
+                             }
+                         }
+                     }
+                     break;
+                 case SKILL_HERBALISM:
+                     if (m_bot->HasSkill(SKILL_HERBALISM)) // Has skill
+                     {
+                         ItemPosCountVec dest;
+                         if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK )
+
+                         {
+                             Item* pItem = m_bot->StoreNewItem (dest,item->itemid,true,item->randomPropertyId);
+                             uint32 reqSkillValue = lockInfo->Skill[0];
+                             uint32 SkillValue = m_bot->GetPureSkillValue(SKILL_HERBALISM);
+                             if (SkillValue >= reqSkillValue)
+                             {
+                                 m_bot->SendNewItem(pItem, uint32(item->count), false, false, true);
+                                 m_bot->UpdateGatherSkill(SKILL_HERBALISM, SkillValue, reqSkillValue);
+                                 --loot->unlootedCount;
+                             }
+                         }
+                     }
+                     break;
+                 }
+             }
+         }
+         // release loot
+         m_bot->GetSession()->DoLootRelease( m_lootCurrent );
+
+         // clear movement target, take next target on next update
+         m_bot->GetMotionMaster()->Clear();
+         m_bot->GetMotionMaster()->MoveIdle();
+         sLog->outDebug( "[PlayerbotAI]: %s looted target 0x%08X", m_bot->GetName(), m_lootCurrent );
+         SetQuestNeedItems();
+     }
+     else
+         SendWhisper("I have no info on that object", fromPlayer);
+ }
+
+ else if (text == "survey")
+ {
+      float distance = 100.0f;
+      uint32 count = 0;
+      std::ostringstream detectout;
+
+      QueryResult result = WorldDatabase.PQuery("SELECT guid, id, position_x, position_y, position_z, map, "
+        "(POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) AS order_ "
+        "FROM gameobject WHERE map='%u' AND (POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) <= '%f' ORDER BY order_",
+         m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(),
+         m_bot->GetMapId(), m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), distance*distance);
+
+      if (result)
+      {
+         do
+         {
+             Field *fields = result->Fetch();
+             uint32 guid = fields[0].GetUInt32();
+             uint32 entry = fields[1].GetUInt32();
+             float x = fields[2].GetFloat();
+             float y = fields[3].GetFloat();
+             float z = fields[4].GetFloat();
+             int mapid = fields[5].GetUInt16();
+
+             GameObjectInfo const * gInfo = ObjectMgr::GetGameObjectInfo(entry);
+
+             if(!gInfo)
+                 continue;
+
+             uint64 objGuid = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+             GameObject *go = m_bot->GetMap()->GetGameObject(objGuid);
+             if ( !go || (go && !go->isSpawned()) ) continue;
+
+             if(count < 12) // count, limits number of links
+                  detectout << "|cFFFFFF00|Hfound:" << guid << ":" << entry << ":" << x << ":" << y << ":" << z  << ":" << mapid  << ":" <<  "|h[" << gInfo->name << "]|h|r";
+             ++count;
+         } while (result->NextRow());
+
+      }
+      SendWhisper(detectout.str().c_str(), fromPlayer);
+    }
+
+    else if (text == "pull")
+    {
+        m_bot->GetPlayerbotAI()->GetClassAI()->Pull();
+    }
+    else if(text == "help")
+    {
+        std::string msg;
+        if (m_bot->getClass() == CLASS_ROGUE)
+            msg = "The commands I respond to are \n follow, stay, (c)ast <spellname>, spells, (e)quip, (u)se, \nnpcbot (a)dd, npcbot (d)elete <class>,\n(q)uests, accept quest <hlink>, abandon quest <hlink>\npoison [main | off].\ntrain list";
+        else
+            msg = "The commands I respond to are \n follow, stay, (c)ast <spellname>, spells, (e)quip, (u)se, \nnpcbot (a)dd, npcbot (d)elete <class>,\n(q)uests, accept quest <hlink>, abandon quest <hlink>\ntrain list.";
+
+        SendWhisper(msg, fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+      else
+    {
+        // if this looks like an item link, reward item it completed quest and talking to NPC
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (!itemIds.empty()) {
+            uint32 itemId = itemIds.front();
+            bool wasRewarded = false;
+            uint64 questRewarderGUID = m_bot->GetSelection();
+            Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*m_bot, questRewarderGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+            for (uint32 iI = 0; !wasRewarded && iI < questMenu.MenuItemCount(); ++iI)
+            {
+                QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+                uint32 questID = qItem.m_qId;
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+                QuestStatus status = m_bot->GetQuestStatus(questID);
+
+                // if quest is complete, turn it in
+                if (status == QUEST_STATUS_COMPLETE &&
+                    ! m_bot->GetQuestRewardStatus(questID) &&
+                    pQuest->GetRewChoiceItemsCount() > 1 &&
+                    m_bot->CanRewardQuest(pQuest, false))
+                {
+                    for (uint8 rewardIdx=0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+                    {
+                        ItemPrototype const * const pRewardItem = sObjectMgr->GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
+                        if (itemId == pRewardItem->ItemId)
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
+
+                            std::string questTitle  = pQuest->GetTitle();
+                            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            std::ostringstream out;
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r rewarded";
+                            SendWhisper(out.str(), fromPlayer);
+                            wasRewarded = true;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+}
+
+void PlayerbotAI::SetLooting(bool looting)
+{
+    isLooting = looting;
+}
+
+void PlayerbotAI::AddLootGUID(uint64 guid) {
+    m_lootCreature.push_back(guid);
+}
+
+bool PlayerbotAI::DoLoot()
+{
+    if(!m_lootCurrent && m_lootCreature.empty())
+    {
+        sLog->outDebug("[PlayerbotAI]: %s reset loot list / go back to idle", m_bot->GetName());
+//        SetQuestNeedItems();
+        isLooting = false;
+        return false;
+    }
+
+    if(m_bot->isDead())
+    {
+        isLooting = false;
+        return false;
+    }
+
+    if(!m_lootCurrent)
+    {
+        m_lootCurrent = m_lootCreature.front();
+
+        if(!m_lootCurrent)
+        {
+            //sLog->outError("PlayerbotAI::DoLoot() error location #1, please report this error immediately!");
+            return false;
+        }
+
+        Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+        GameObject *o = m_bot->GetMap()->GetGameObject( m_lootCurrent );
+
+        if(!c && !o)
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false;
+        }
+        if(c && c->isAlive())
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false; //not dead yet
+        }
+
+        sLog->outDebug("[PlayerbotAI]: %s got loot target 0x%08X", m_bot->GetName(), m_lootCurrent);
+        Position pos;
+
+        WorldObject *object;
+        if (c) object = c;
+        else object = o;
+
+        if(m_bot->IsWithinDistInMap(object, INTERACTION_DISTANCE * 3)){ //Verify if the bot it close to a loot.
+
+            m_lootCreature.pop_front();
+            object->GetPosition(&pos);
+            m_bot->GetMotionMaster()->MovePoint(object->GetMapId(), (const Position &)(pos));
+
+        } else { //Rotate the loot to very if one is not near the bot.
+
+            m_lootobjtemp = m_lootCreature.front();
+            m_lootCreature.pop_front();
+            m_lootCreature.push_back(m_lootobjtemp);
+            m_lootCurrent = 0;
+        }
+        return true;
+
+    } else {
+
+        Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+        GameObject *o = m_bot->GetMap()->GetGameObject( m_lootCurrent );
+        if(!c && !o)
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false;
+        }
+        if(c && c->isAlive())
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false; //not dead yet
+        }
+
+        WorldObject *object;
+        if (c) object = c;
+        else object = o;
+
+        if(m_bot->IsWithinDistInMap(object, INTERACTION_DISTANCE))
+        {
+            //check for needed items
+            m_bot->SendLoot(m_lootCurrent, LOOT_CORPSE);
+
+            Loot *loot;
+            if (c)
+                loot = &c->loot;
+            else
+                loot = &o->loot;
+
+            assert(loot);
+
+            uint32 lootNum = loot->GetMaxSlotInLootFor(m_bot);
+//sLog->outError("[PlayerbotAI]: %s loot target 0x%08X got %d items", m_bot->GetName(), m_lootCurrent, loot->GetMaxSlotInLootFor(m_bot));
+
+            for(uint32 l = 0; l < lootNum; ++l)
+            {
+                QuestItem *qitem = 0, *ffaitem = 0, *conditem = 0;
+                LootItem *item = loot->LootItemInSlot(l, m_bot, &qitem, &ffaitem, &conditem);
+                if(!item) continue;
+                if(!qitem && item->is_blocked)
+                {
+                    m_bot->SendLootRelease(m_bot->GetLootGUID());
+                    continue;
+                }
+
+                if(m_needItemList[item->itemid] > 0)
+                {
+//sLog->outError("[PlayerbotAI]: %s LOOT needed item 0x%04X", m_bot->GetName(), item->itemid);
+                    ItemPosCountVec dest;
+                    if(m_bot->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK)
+                    {
+                        Item *newitem = m_bot->StoreNewItem(dest, item->itemid,true, item->randomPropertyId);
+                        if(qitem)
+                        {
+                            qitem->is_looted = true;
+                            if(item->freeforall ||loot->GetPlayerQuestItems().size() == 1)
+                                m_bot->SendNotifyLootItemRemoved(l);
+                            else
+                                loot->NotifyQuestItemRemoved(qitem->index);
+                        }
+                        else if(ffaitem)
+                        {
+                            ffaitem->is_looted = true;
+                            m_bot->SendNotifyLootItemRemoved(l);
+                        } else {
+                            if(conditem) conditem->is_looted = true;
+                            loot->NotifyItemRemoved(l);
+                        }
+                        if(!item->freeforall) item->is_looted = true;
+                        --(loot->unlootedCount);
+                        m_bot->SendNewItem(newitem, uint32(item->count), false,false, true);
+                        m_bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count);
+
+                        std::ostringstream out;
+                        PlayerbotChatHandler ch(m_master);
+                        out << m_bot->GetName() << " needs " << m_needItemList[item->itemid]-1 << " more.";
+                        ch.sysmessage(out.str().c_str());
+                        m_ignoreAIUpdatesUntilTime = time(0);
+                    }
+                }
+            }
+            //release loot
+            if(uint64 lguid = m_bot->GetLootGUID() && m_bot->GetSession())
+                m_bot->GetSession()->DoLootRelease(lguid);
+            else if(!m_bot->GetSession())
+                sLog->outDebug("[PlayerbotAI]: %s has no session. Cannot releaseloot!", m_bot->GetName());
+
+            //clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+            sLog->outDebug("[PlayerbotAI]: %s looted target 0x%08X", m_bot->GetName(), m_lootCurrent);
+            m_lootCurrent = 0;
+            m_ignoreAIUpdatesUntilTime = time(0);
+            isLooting = false;
+        } else { //keep moving till we get there
+            Position pos;
+
+            if (c) {
+                c->GetPosition(&pos);
+                m_bot->GetMotionMaster()->MovePoint(c->GetMapId(), (const Position &)(pos));
+            } else {
+                o->GetPosition(&pos);
+                m_bot->GetMotionMaster()->MovePoint(o->GetMapId(), (const Position &)(pos));
+            }
+
+        }
+    }
+    return false;
+} //end DoLoot
+
+void PlayerbotAI::SetQuestNeedItems()
+{
+    //reset values first
+    m_needItemList.clear();
+    m_lootCreature.clear();
+    m_lootCurrent = 0;
+
+    //run through accepted quests, get quest infoand data
+    for(QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+    {
+        const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+        if(!qInfo) continue;
+        QuestStatusData *qData = &iter->second;
+
+        //only check quest if it is incomplete
+        if(qData->m_status != QUEST_STATUS_INCOMPLETE) continue;
+
+        //check for items we not have enough of
+        for(uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+        {
+            if(!qInfo->ReqItemCount[i] || (qInfo->ReqItemCount[i]-qData->m_itemcount[i]) <= 0) continue;
+            m_needItemList[qInfo->ReqItemId[i]] = (qInfo->ReqItemCount[i]-qData->m_itemcount[i]);
+        }
+    }
+}//end SetQuestNeedItems
+
+//Localization support
+void PlayerbotAI::ItemLocalization(std::string &itemName, const uint32 itemID) const
+{
+    int loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+    ItemLocale const *pItemInfo = sObjectMgr->GetItemLocale(itemID);
+    if(pItemInfo)
+    {
+        if(pItemInfo->Name.size() > loc && !pItemInfo->Name[loc].empty())
+        {
+            const std::string name = pItemInfo->Name[loc];
+            if(Utf8FitTo(name, wnamepart))
+                itemName = name.c_str();
+        }
+    }
+}
+
+void PlayerbotAI::QuestLocalization(std::string &questTitle, const uint32 questID) const
+{
+    int loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+    QuestLocale const *pQuestInfo = sObjectMgr->GetQuestLocale(questID);
+    if(pQuestInfo)
+    {
+        if(pQuestInfo->Title.size() > loc && !pQuestInfo->Title[loc].empty())
+        {
+            const std::string title = pQuestInfo->Title[loc];
+            if(Utf8FitTo(title, wnamepart))
+                questTitle = title.c_str();
+        }
+    }
+}
+
+void PlayerbotAI::TurnInQuests( WorldObject *pNpc )
+{
+
+    uint64 npcGUID = pNpc->GetGUID();
+    if (!m_bot->IsInMap((WorldObject*) pNpc))
+        m_bot->GetPlayerbotAI()->TellMaster("hey you are turning in quests without me!");
+    else
+    {
+        m_bot->SetSelection(npcGUID);
+
+        // auto complete every completed quest this NPC has
+        m_bot->PrepareQuestMenu(npcGUID);
+        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+        for (uint32 iI = 0; iI < questMenu.MenuItemCount(); ++iI)
+        {
+            QuestMenuItem const& qItem = questMenu.GetItem(iI);
+            uint32 questID = qItem.m_qId;
+            Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+            std::ostringstream out;
+            std::string questTitle  = pQuest->GetTitle();
+            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+
+            QuestStatus status = m_bot->GetQuestStatus(questID);
+            // if quest is complete, turn it in
+            if (status == QUEST_STATUS_COMPLETE)
+            {
+                // if bot hasn't already turned quest in
+                if (! m_bot->GetQuestRewardStatus(questID))
+                {
+                    // auto reward quest if no choice in reward
+                    if (pQuest->GetRewChoiceItemsCount() == 0)
+                    {
+                        if (m_bot->CanRewardQuest(pQuest, false))
+                        {
+                            m_bot->RewardQuest(pQuest, 0, pNpc, false);
+                            out << "Quest complete: |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                        else
+                        {
+                            out << "|cffff0000Unable to turn quest in:|r |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                    }
+
+                    // auto reward quest if one item as reward
+                    else if (pQuest->GetRewChoiceItemsCount() == 1)
+                    {
+                        int rewardIdx = 0;
+                        ItemPrototype const *pRewardItem = sObjectMgr->GetItemPrototype(pQuest->RewChoiceItemId[rewardIdx]);
+                        std::string itemName = pRewardItem->Name1;
+                        m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+                        if (m_bot->CanRewardQuest(pQuest, rewardIdx, false))
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, true);
+
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            out << "Quest complete: "
+                                << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                                << "|h[" << questTitle << "]|h|r reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                        else
+                        {
+                            out << "|cffff0000Unable to turn quest in:|r "
+                                << "|cff808080|Hquest:" << questID << ':'
+                                << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r"
+                                << " reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+
+                    // else multiple rewards - let master pick
+                    else {
+                        out << "What reward should I take for |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                            << "|h[" << questTitle << "]|h|r? ";
+                        for (uint8 i=0; i < pQuest->GetRewChoiceItemsCount(); ++i)
+                        {
+                            ItemPrototype const * const pRewardItem = sObjectMgr->GetItemPrototype(pQuest->RewChoiceItemId[i]);
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+                }
+            }
+
+            else if (status == QUEST_STATUS_INCOMPLETE) {
+                out << "|cffff0000Quest incomplete:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+            }
+
+//            else if (status == QUEST_STATUS_AVAILABLE){
+  //              out << "|cff00ff00Quest available:|r "
+//                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+//            }
+
+            if (! out.str().empty())
+                m_bot->GetPlayerbotAI()->TellMaster(out.str());
+        }
+    }
+} // TurnInQuests
+
+
+ void PlayerbotAI::SetCombatOrder (CombatOrderType orders)
+ {
+    m_combatOrder = orders;
+ }
diff --git a/src/server/game/AI/Bots/PlayerbotAI.h b/src/server/game/AI/Bots/PlayerbotAI.h
new file mode 100644
index 0000000..e40d6ad
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotAI.h
@@ -0,0 +1,284 @@
+#ifndef _PLAYERBOTAI_H
+#define _PLAYERBOTAI_H
+
+#include "Common.h"
+
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+
+enum ScenarioType
+{
+    SCENARIO_PVEEASY,
+    SCENARIO_PVEHARD,
+    SCENARIO_DUEL,
+    SCENARIO_PVPEASY,
+    SCENARIO_PVPHARD
+};
+
+//masters orders that should be obeyed by the AI during the updteAI routine
+//the master will auto set the target of the bot
+enum CombatOrderType
+{
+    ORDERS_NONE,
+    ORDERS_KILL,
+    ORDERS_CC,
+    ORDERS_HEAL,
+    ORDERS_TANK,
+    ORDERS_PROTECT,
+    ORDERS_REGEN
+};
+
+typedef std::set<Unit *> AttackerInfoList;
+
+class PlayerbotAI
+{
+public:
+    //******* Stuff the outside world calls ****************************
+    PlayerbotAI(Player *const master, Player *const bot);
+    virtual ~PlayerbotAI();
+
+    //This is called from Unit.cpp and is called every second (I think)
+    void UpdateAI(const uint32 p_time);
+
+    //This is called from ChatHandler.cpp when there is an incoming message to the bot
+    //from a whisper or from the party channel
+    void HandleCommand(const std::string &text, Player &fromPlayer);
+
+    //This is called by WorldSession.pm
+    //It provides a view of packets normally sent to the client.
+    //Since there is no client at the other end, the packets are dropped of course.
+    //For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
+    void HandleBotOutgoingPacket(const WorldPacket &packet);
+
+    //This is called whenever the master sends a packet to the server.
+    //These packets can be viewed, but not edited.
+    //It allows bot creators to craft AI in response to a master's actions.
+    //For a list of opcodes that can be caught see Opcodes.cpp (CMSG_* opcodes only)
+    //Notice: that this is static which means it is called once for all bots of the master.
+    static void HandleMasterIncomingPacket(const WorldPacket &packet, WorldSession &masterSession);
+    static void HandleMasterOutgoingPacket(const WorldPacket &packet, WorldSession &masterSession);
+
+    //Returns what kind of situation we are in so the AI can react accordingly
+    ScenarioType GetScenarioType(){ return m_ScenarioType; }
+
+    PlayerbotClassAI *GetClassAI(){ return m_classAI; }
+
+    //protected:
+
+    //******* Utilities ***************************************************
+
+    //finds spell ID for matching substring args
+    //in priority of full text match, spells not taking reagents, and highest rank
+    uint32 getSpellId(const char *args, bool master=false) const;
+    //Main PlayerBot spell finding function Returns ONLY exact matches including Upper/Lower case differentiation.
+    uint32 getSpellIdExact(const char *args, bool includePassive=false, bool master=false);
+
+    // finds quest ID for matching substring args
+    uint32 getQuestId(const char* args, bool remove) const;
+
+    //extracts item ids from links
+    void extractItemIds(const std::string &text, std::list<uint32> &itemIds) const;
+
+    //extracts currency from a string as #g#s#c and returns the total in copper
+    uint32 extractMoney(const std::string &text) const;
+
+    // extracts gameobject info from link
+    bool extractGOinfo(const std::string& text, uint32 &guid,  uint32 &entry, int &mapid, float &x, float &y, float &z) const;
+
+    // finds items in equipment and adds Item* to foundItemList
+    // also removes found item IDs from itemIdSearchList when found
+    void findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+
+    //finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+
+    //currently bots only obey commands from the master
+    bool canObeyCommandFrom(const Player &player) const;
+
+    //get current casting spell (will return NULL if no spell!)
+    Spell *GetCurrentSpell() const;
+
+    bool HasAura(uint32 spellId, const Unit *player) const;
+    bool HasAura(const char *spellName, const Unit *player) const;
+    bool HasAura(const char *spellName) const;
+    void HandleTeleportAck();
+
+    bool HasPick();
+
+    uint8 GetHealthPercent(const Unit &target) const;
+    uint8 GetHealthPercent() const;
+    uint8 GetBaseManaPercent(const Unit &target) const;
+    uint8 GetBaseManaPercent() const;
+    uint8 GetManaPercent(const Unit &target) const;
+    uint8 GetManaPercent() const;
+    uint8 GetRageAmount(const Unit &target) const;
+    uint8 GetRageAmount() const;
+    uint8 GetEnergyAmount(const Unit &target) const;
+    uint8 GetEnergyAmount() const;
+    uint8 GetRunicPower(const Unit &target) const;
+    uint8 GetRunicPower() const;
+
+    Item *FindFood() const;
+    Item *FindDrink() const;
+    Item *FindPotion() const;
+    Item *FindBandage() const;
+    Item *FindPoisonForward() const;    // finds poison starting from the front
+    Item *FindPoisonBackward() const;   // finds poison starting from the back
+
+    void UseMount() const;
+
+    //******* Actions ****************************************
+    //Your handlers can call these actions to make the bot do things.
+    void TellMaster(const std::string &text);
+    void SendWhisper(const std::string &text, Player &player);
+    bool CastSpell(const char *args);
+    //Player bots main spell cast function, if checkFirst > performs canCast() first, if castExistingAura > performs the cast even if the aura exists on target,
+    //if skipFriendlyCheck > do not perform spell positive/negative and target friendly/hostile checks (Useful for dual purpose spells like holy shock)
+    virtual bool CastSpell(uint32 spellId, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+    virtual bool CastSpell(const SpellEntry * pSpellInfo, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+    //Simple Checks to determine if the bot can cast the spell or not...
+    //Mana/Stance/EquipmentRequirement/Distance/TargetInFront/OverwriteOrStackExistingAura/FriendlyFire checks
+    virtual bool CanCast(uint32 spellId, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+    virtual bool CanCast(const SpellEntry * pSpellInfo, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+    //Gets the current form/stance of player
+    uint8 GetForm(Unit *pPlayer=NULL);
+    void UseItem(Item &item);
+    void PoisonWeapon(Item &item, uint32 spellid=0, uint32 target=0, EquipmentSlots weapon=EQUIPMENT_SLOT_MAINHAND);
+    void EquipItem(Item &item);
+    void Stay();
+    bool Follow(Player &player);
+    void SendNotEquipList(Player &player);
+    void Feast();
+    void SetLooting(bool looting);
+    void InterruptCurrentCastingSpell();
+    void GetCombatOrders();
+    void DoNextCombatManeuver();
+    void KilledMonster(uint32 entry, uint64 guid);
+    void ItemLocalization(std::string &itemName, const uint32 itemID) const;
+    void QuestLocalization(std::string &questTitle, const uint32 questID) const;
+
+    uint32 GetAttackerCount(){ return m_attackerInfo.size(); }
+	void SetIgnoreUpdateTime(float t){m_ignoreAIUpdatesUntilTime=getMSTime() + (t * 1000); };
+
+    Player *GetPlayerBot(){ return m_bot; }
+    void SetInFront(const Unit *obj);
+
+    bool CanBotsFly();  // take the flight path?
+    uint32 GetStartMapID() { return m_startMapID; };
+    uint32 GetStartZoneID() { return m_startZoneID; };
+    uint32 GetStartAreaID() { return m_startAreaID; };
+    uint32 GetStartPhase() { return m_startPhase; };
+    uint32 GetStartDifficulty() { return m_startDifficulty; };
+    uint32 GetStartInstanceID() { return m_startInstanceID; };
+    float GetStartX() { return m_startX; };
+    float GetStartY() { return m_startY; };
+    float GetStartZ() { return m_startZ; };
+    float GetStartO() { return m_startO; };
+
+    void SetStartMapID(uint32 mapID) { m_startMapID = mapID; };
+    void SetStartZoneID(uint32 zoneID) { m_startZoneID = zoneID; };
+    void SetStartAreaID(uint32 areaID) { m_startAreaID = areaID; };
+    void SetStartPhase(uint32 phase) { m_startPhase = phase; };
+    void SetStartDifficulty(uint32 difficulty) { m_startDifficulty = difficulty; };
+    void SetStartInstanceID(uint32 instanceID) { m_startInstanceID = instanceID; };
+    void SetStartX(float x) { m_startX = x; };
+    void SetStartY(float y) { m_startY = y; };
+    void SetStartZ(float z) { m_startZ = z; };
+    void SetStartO(float o) { m_startO = o; };
+
+    void AddLootGUID(uint64 guid);
+    void SetCombatOrder (CombatOrderType orders);
+
+private:
+
+    //****** Closed Actions ********************************
+    //These actions may only be called at special times.
+    //Trade methods are only applicable when the trade window is open
+    //and are only called from within HandleCommand.
+    // submits packet to trade an item (trade window must already be open)
+
+    // default slot is -1 which means trade slots 0 to 5. if slot is set
+    // to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+    // 'Will not be traded' slot.
+    bool TradeItem(const Item& item, int8 slot=-1);
+
+    bool TradeCopper(uint32 copper);
+
+    //it is safe to keep these back reference pointers because m_bot
+    //owns the "this" object and m_master owns m_bot. The owner always cleans up.
+    Player *const m_master;
+    Player *const m_bot;
+    PlayerbotClassAI *m_classAI;
+
+    //ignores AI updates until time specified
+    //no need to waste CPU cycles during casting etc
+    uint32 m_ignoreAIUpdatesUntilTime;
+
+    CombatOrderType m_combatOrder;
+
+    ScenarioType m_ScenarioType;
+    typedef std::set<Unit *> AttackerSet;
+
+    time_t m_TimeDoneEating;
+    time_t m_TimeDoneDrinking;
+    time_t m_TimeRessurect;
+    uint32 m_CurrentlyCastingSpellId;
+    bool m_IsFollowingMaster;
+
+    //if master commands bot to do something, store here until updateAI
+    //can do it
+    uint32 m_spellIdCommand;
+    uint64 m_targetGuidCommand;
+
+    //finds who to attack next
+    Unit *getNextTarget(Unit *victim);
+
+    /* -- Loot routines by runsttren */
+    bool DoLoot();
+    void SetQuestNeedItems();
+
+    void TurnInQuests( WorldObject *questgiver );
+
+    typedef std::map<uint32, uint32> BotNeedItem;
+    typedef std::list<uint64> BotLootCreature;
+    typedef std::map<uint32, std::string> BotQuestsSeen;
+
+    //list of items needed to fullfill quests
+    BotNeedItem m_needItemList;
+
+    //list of items needed to fullfill quests
+    BotNeedItem m_needEmblemList;
+
+    //list of quests recently seen that we can accept
+    BotQuestsSeen m_questsSeen;
+
+    //list of creatures we recently attacked and want to loot
+    BotLootCreature m_lootCreature; //list of creatures
+    uint64 m_lootCurrent; //current remains of interest
+    uint64 m_lootobjtemp;
+    bool isLooting;
+    AttackerInfoList m_attackerInfo;
+
+    float m_followDistanceMin, m_followDistanceMax;
+    int m_playerBotsFly;
+
+    uint32 m_startMapID;
+    uint32 m_startZoneID;
+    uint32 m_startAreaID;
+    uint32 m_startPhase;
+    uint32 m_startDifficulty;
+    uint32 m_startInstanceID;
+    float m_startX;
+    float m_startY;
+    float m_startZ;
+    float m_startO;
+
+    uint32 m_FeastSpamTimer;
+};
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotClassAI.cpp b/src/server/game/AI/Bots/PlayerbotClassAI.cpp
new file mode 100644
index 0000000..1cd9143
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotClassAI.cpp
@@ -0,0 +1,594 @@
+/*
+Name :    PlayerbotClassAI.cpp
+Notes:    Does not really work with peldor's own classbot AIs
+        Contains many improvements and hacks to overcome some difficulites
+Known
+Problems:    - Contains hardcoded values,  for an example check group heal, individual heal decision
+            - ai->getSpellIdExact func, *although works more accurately* is probably slower and hackish
+            - FindMainTankRaid func, includes a db query making it a resource hog
+            - canCast func, does not check for every possible problem, can cause AI stuck.. Should be inside PlayerbotAI class
+            - castSpell func is redundant and should be placed in PlayerbotAI class, sets private variable m_ai->m_CurrentlyCastingSpellId which is made public as a hack..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotClassAI.h"
+#include "Common.h"
+#include "Spell.h"
+#include "Group.h"
+
+PlayerbotClassAI::PlayerbotClassAI(Player *const master, Player *const bot, PlayerbotAI *const ai): m_master(master), m_bot(bot), m_ai(ai), rezSpamTimer(0)
+{
+    threatThreshold = 75;            // Threat % threshold for dps to lower tps
+    offensiveSpellThreshold = 70;    // Mana % threshold for healers to use offensive spells
+
+    // first aid
+    RECENTLY_BANDAGED = 11196; // first aid check
+
+    // RACIALS
+    R_ARCANE_TORRENT = ai->getSpellIdExact("Arcane Torrent");
+    R_BERSERKING = ai->getSpellIdExact("Berserking");
+    R_BLOOD_FURY = ai->getSpellIdExact("Blood Fury");
+    R_CANNIBALIZE = ai->getSpellIdExact("Cannibalize");
+    R_ESCAPE_ARTIST = ai->getSpellIdExact("Escape Artist");
+    R_EVERY_MAN_FOR_HIMSELF = ai->getSpellIdExact("Every Man for Himself");
+    R_GIFT_OF_NAARU = ai->getSpellIdExact("Gift of the Naaru");
+    R_SHADOWMELD = ai->getSpellIdExact("Shadowmeld");
+    R_STONEFORM = ai->getSpellIdExact("Stoneform");
+    R_WAR_STOMP = ai->getSpellIdExact("War Stomp");
+    R_WILL_OF_FORSAKEN = ai->getSpellIdExact("Will of the Forsaken");
+
+    mainTank = NULL;
+    m_pulling = false;
+}
+PlayerbotClassAI::~PlayerbotClassAI(){}
+
+void PlayerbotClassAI::DoNextCombatManeuver(Unit *){}
+
+void PlayerbotClassAI::DoNonCombatActions(){}
+
+void PlayerbotClassAI::LoadSpells(){}
+
+void PlayerbotClassAI::Pull(){}
+
+bool PlayerbotClassAI::BuffPlayer(Unit *target){ return false; }
+
+bool PlayerbotClassAI::FindMount(){ return true; }
+
+bool PlayerbotClassAI::Unmount(){ return true; }
+
+bool PlayerbotClassAI::HealTarget (Unit *target, uint8 hp){ return false; }
+
+bool PlayerbotClassAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal){ return false; }
+
+bool PlayerbotClassAI::CureTarget (Unit *target){ return false; }
+
+bool PlayerbotClassAI::RezTarget (Unit *target){ return false; }
+
+bool PlayerbotClassAI::IsMounted(){ return m_bot->IsMounted(); }
+
+bool PlayerbotClassAI::CastSpell(uint32 spellId, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{return m_ai->CastSpell(spellId, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered); }
+bool PlayerbotClassAI::CastSpell(const SpellEntry * pSpellInfo, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{return m_ai->CastSpell(pSpellInfo, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered);}
+
+bool PlayerbotClassAI::CanCast(uint32 spellId, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{return m_ai->CanCast(spellId, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);}
+
+bool PlayerbotClassAI::CanCast(const SpellEntry * pSpellInfo, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{return m_ai->CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);}
+
+bool PlayerbotClassAI::listAuras(Unit *u)
+{
+    int loc = 0;
+    Unit *target = u;
+    typedef std::pair<uint32, uint8> spellEffectPair;
+    typedef std::multimap< spellEffectPair, Aura*> AuraMap;
+    Unit::AuraMap &vAuras = target->GetOwnedAuras();
+    for(Unit::AuraMap::const_iterator itr = vAuras.begin(); itr!=vAuras.end(); ++itr)
+    {
+        //SpellEntry const *spellInfo = (*itr).second->GetSpellProto();
+        const SpellEntry *spellInfo = itr->second->GetSpellProto();
+        const std::string name = spellInfo->SpellName[loc];
+        sLog->outDebug("aura = %u %s", spellInfo->Id, name.c_str());
+    }
+    return true;
+};//end listAuras
+
+bool PlayerbotClassAI::HasAuraName (Unit *unit, uint32 spellId, uint64 casterGuid)
+{
+    const SpellEntry *const pSpellInfo = GetSpellStore()->LookupEntry (spellId);
+    if(!pSpellInfo) return false;
+    int loc = m_bot->GetSession()->GetSessionDbcLocale();
+    const std::string  name = pSpellInfo->SpellName[loc];
+    if(name.length() == 0) return false;
+    return HasAuraName(unit, name, casterGuid);
+}
+
+bool PlayerbotClassAI::HasAuraName (Unit *target, std::string spell, uint64 casterGuid)
+{
+    int loc = m_bot->GetSession()->GetSessionDbcLocale();
+    typedef std::pair<uint32, uint8>spellEffectPair;
+    typedef std::multimap<spellEffectPair, Aura*>AuraMap;
+
+    Unit::AuraMap &vAuras = target->GetOwnedAuras();
+    for(Unit::AuraMap::const_iterator itr = vAuras.begin(); itr!=vAuras.end(); ++itr)
+    {
+        //SpellEntry const *spellInfo = (*itr).second->GetSpellProto();
+        const SpellEntry *spellInfo = itr->second->GetSpellProto();
+        const std::string name = spellInfo->SpellName[loc];
+        if(!spell.compare(name))
+        //if(!strcmp(name.c_str(),spell.c_str()))
+        {
+            if(casterGuid == 0) //don't care who casted it
+                return true;
+            else if(casterGuid == itr->second->GetCasterGUID()) //only if correct caster casted it
+                return true;
+        }
+    }
+    return false;
+};
+
+bool PlayerbotClassAI::castDispel (uint32 dispelSpell, Unit *dTarget, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+    if (dispelSpell == 0 || !dTarget ) return false;
+    //if (!canCast(dispelSpell, dTarget, true)) return false; //Needless cpu cycles wasted, usually a playerbot can cast a dispell
+    const SpellEntry *dSpell = GetSpellStore()->LookupEntry(dispelSpell);
+    if (!dSpell) return false;
+
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+    {
+        if (dSpell->Effect[i] != (uint32)SPELL_EFFECT_DISPEL) continue;
+        uint32 dispel_type = dSpell->EffectMiscValue[i];
+        uint32 dispelMask  = GetDispellMask(DispelType(dispel_type));
+        Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura * aura = itr->second;
+            AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+            if (!aurApp)
+                continue;
+
+            if ((1<<aura->GetSpellProto()->Dispel) & dispelMask)
+            {
+                if(aura->GetSpellProto()->Dispel == DISPEL_MAGIC)
+                {
+                    bool positive = aurApp->IsPositive() ? (!(aura->GetSpellProto()->AttributesEx & SPELL_ATTR0_UNK7)) : false;
+
+                    // do not remove positive auras if friendly target
+                    //               negative auras if non-friendly target
+                    if(positive == dTarget->IsFriendlyTo(GetPlayerBot()))
+                        continue;
+                }
+                // If there is a successfull match return, else continue searching.
+                if (CastSpell(dSpell, dTarget, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck)) { return true; }
+            }
+        }
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::castSelfCCBreakers (uint32 castList[])
+{
+    uint32 dispelSpell = 0;
+    Player *dTarget = GetPlayerBot();
+
+
+            /* dispelSpell = (uint32) R_ESCAPE_ARTIST; // this is script effect,
+            Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+            {
+                Aura * aura = itr->second;
+                AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+                if (!aurApp)
+                    continue;
+
+                if ( ( aura->GetSpellProto()->Mechanic == MECHANIC_SNARE ) || ( aura->GetSpellProto()->Mechanic == MECHANIC_ROOT ) )
+                {
+                    if(aura->GetSpellProto()->Dispel == DISPEL_MAGIC)
+                    {
+                        bool positive = aurApp->IsPositive() ? (!(aura->GetSpellProto()->AttributesEx & SPELL_ATTR0_UNK7)) : false;
+
+                        // do not remove positive auras if friendly target
+                        //               negative auras if non-friendly target
+                        if(positive == dTarget->IsFriendlyTo(caster))
+                            continue;
+                    }
+                    return castSpell(dispelSpell, dTarget);
+                }
+            }
+            return false;  */
+
+        // racial abilities
+    /*  if( GetPlayerBot()->getRace() == RACE_BLOODELF && !pTarget->HasAura( ARCANE_TORRENT,0 ) && castSpell( ARCANE_TORRENT,pTarget ) ) {
+         //GetPlayerBot()->Say("Arcane Torrent!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_HUMAN && (GetPlayerBot()->HasUnitState( UNIT_STAT_STUNNED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_FEAR ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_CHARM )) && castSpell( EVERY_MAN_FOR_HIMSELF, GetPlayerBot() ) ) {
+        //GetPlayerBot()->Say("EVERY MAN FOR HIMSELF!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_UNDEAD_PLAYER && (GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_FEAR ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_CHARM )) && castSpell( WILL_OF_THE_FORSAKEN, GetPlayerBot() ) ) {
+       // GetPlayerBot()->Say("WILL OF THE FORSAKEN!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_DWARF && GetPlayerBot()->HasAuraState( AURA_STATE_DEADLY_POISON ) && castSpell( STONEFORM, GetPlayerBot() ) ) {
+        //GetPlayerBot()->Say("STONEFORM!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_GNOME && (GetPlayerBot()->HasUnitState( UNIT_STAT_STUNNED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED )) && castSpell( ESCAPE_ARTIST, GetPlayerBot() ) ) {
+       // GetPlayerBot()->Say("ESCAPE ARTIST!", LANG_UNIVERSAL);
+    } */
+
+    for (uint8 j = 0; j <  sizeof (castList); j++)
+    {
+        dispelSpell = castList[j];
+        if (dispelSpell == 0 || !dTarget->HasSpell(dispelSpell) || !CanCast(dispelSpell, dTarget, true)) continue;
+        SpellEntry const *dSpell = GetSpellStore()->LookupEntry(dispelSpell);
+        if (!dSpell) continue;
+
+        for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+        {
+            if (dSpell->Effect[i] != (uint32)SPELL_EFFECT_DISPEL && dSpell->Effect[i] != (uint32)SPELL_EFFECT_APPLY_AURA) continue;
+            if (dSpell->Effect[i] == (uint32)SPELL_EFFECT_APPLY_AURA && (
+                (dSpell->EffectApplyAuraName[i] != (uint32) SPELL_AURA_MECHANIC_IMMUNITY) ||
+                (dSpell->EffectApplyAuraName[i] != (uint32) SPELL_AURA_DISPEL_IMMUNITY)
+                )) continue;
+
+            Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+            {
+                Aura * aura = itr->second;
+                AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+                if (!aurApp) continue;
+
+                if (aura->GetSpellProto() && (
+                    (dSpell->Effect[i] == (uint32)SPELL_EFFECT_DISPEL  && ((1<<aura->GetSpellProto()->Dispel) & GetDispellMask(DispelType(dSpell->EffectMiscValue[i]))) )
+                    || (dSpell->EffectApplyAuraName[i] == (uint32) SPELL_AURA_MECHANIC_IMMUNITY && ( GetAllSpellMechanicMask(aura->GetSpellProto()) & ( 1 << dSpell->EffectMiscValue[i]) ) )
+                    || (dSpell->EffectApplyAuraName[i] == (uint32) SPELL_AURA_DISPEL_IMMUNITY && ( (1<<aura->GetSpellProto()->Dispel) & GetDispellMask(DispelType(dSpell->EffectMiscValue[i])) ) )
+                    ) )
+                {
+                    if(aura->GetSpellProto()->Dispel == DISPEL_MAGIC)
+                    {
+                        bool positive = aurApp->IsPositive() ? (!(aura->GetSpellProto()->AttributesEx & SPELL_ATTR0_UNK7)) : false;
+                        if(positive)continue;
+                    }
+                    return CastSpell(dispelSpell, dTarget, false);
+                }
+            }
+        }
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::DoSupportRaid(Player *gPlayer, float radius, bool dResurrect, bool dGroupHeal, bool dHeal, bool dCure, bool dBuff)
+{
+    bool needHeal = false;
+    if (dGroupHeal || dHeal)
+    {
+        uint8 cntNeedHeal = 0;
+        uint8 raidHPPercent = GetHealthPercentRaid(gPlayer, cntNeedHeal);
+        if (dGroupHeal && raidHPPercent <=90 && cntNeedHeal > 1)
+        {
+            if (HealGroup(gPlayer, raidHPPercent, cntNeedHeal)) return true;
+        }
+        if (raidHPPercent < 60 ) needHeal = true;
+    }
+    //std::list<Unit*> unitList;
+    //gPlayer->GetRaidMember(unitList,30);
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return false;
+    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Unit* tPlayer = itr->getSource();
+        if(!tPlayer || gPlayer->IsHostileTo(tPlayer)) continue;
+        if(GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        if(!m_bot->IsWithinDistInMap(tPlayer, radius)) { continue; }
+        if(tPlayer->isDead()) // May be we can rez
+        {
+            if(!dResurrect) continue;
+            if(needHeal) continue; //First heal others needing heal
+            if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+            if(tPlayer->IsNonMeleeSpellCasted(true)) continue; //Already rez
+            if(RezTarget(tPlayer)) { return true; }
+            else continue;
+        }
+        if (dHeal)
+        {
+            uint8 tarHPPercent = tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth();
+            if (tarHPPercent < 100 && HealTarget(tPlayer, tarHPPercent)) return true;
+        }
+        if (needHeal && dHeal) continue; //First heal others needing heal
+        if (dCure && CureTarget(tPlayer)) return true;
+        if (dBuff && BuffPlayer(tPlayer)) return true;
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::TakePosition(Unit *followTarget, BotRole bRole, float bDist, float bMinDist, float bMaxDist, float bAngle, Unit *faceTarget)
+{
+    bool doFollow = true;
+    bool omitAngle = false;
+    bool angleIsAutoSet = false;
+    if (!bAngle) angleIsAutoSet = true;
+    if (bAngle < 0) bAngle += 2 * M_PI;
+    //if (bAngle > 2 * M_PI) bAngle -= 2 * M_PI; //Do not send values higher than 2 PI, lower than -2 PI
+    bool rval = false;
+    if (followTarget == NULL) { followTarget = GetMaster(); if (followTarget == NULL) { return false; } }
+    if (faceTarget == NULL) { faceTarget = followTarget; }
+    if (bRole == BOT_ROLE_NONE) { bRole = ( (m_role == BOT_ROLE_NONE) ? BOT_ROLE_DPS_MELEE : m_role);  }
+    //Default values
+    Unit *pVictim = followTarget->getVictim();
+    if (pVictim && pVictim->GetGUID() == m_bot->GetGUID()) //if target is attacking me
+    {
+        if (bRole == BOT_ROLE_TANK || bRole == BOT_ROLE_OFFTANK || bRole == BOT_ROLE_DPS_MELEE)
+        {
+            //Move to target
+            if (!bDist || bDist > 0.7f) bDist = 0.7f;
+            if (bMinDist < 0 || bMinDist > 1) bMinDist = 0;
+            if (bMaxDist <= 0 || bMaxDist > MELEE_RANGE) bMaxDist = MELEE_RANGE;
+            bAngle = 0;
+        }
+        else {doFollow = false;} //Do not move, creature will come
+    }
+    else
+    {
+        // calculating distance to follow
+        switch (bRole)
+        {
+            case BOT_ROLE_TANK:
+            case BOT_ROLE_OFFTANK:
+                if (!bDist) { bDist = 0.7f; bMinDist = 0; bMaxDist = MELEE_RANGE; bAngle = 0;}
+                break;
+            case BOT_ROLE_HEALER:
+            case BOT_ROLE_SUPPORT:
+                if (!bDist) { bDist = urand(12, 14); bMinDist = 10; bMaxDist = 18; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+            case BOT_ROLE_DPS_RANGED:
+                if (!bDist) { bDist = urand(18, 24); bMinDist = 10;  bMaxDist = 26; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+            default:
+                if (!bDist) { bDist = 0.7f; bMinDist = 0.1f; bMaxDist = MELEE_RANGE; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+        }
+    }
+    //Do not try to go behind if ranged and creature is not boss like
+    if (bDist > MELEE_RANGE && followTarget->GetTypeId() != TYPEID_PLAYER)
+    {
+        const CreatureInfo *cInfo = ((Creature*) followTarget)->GetCreatureInfo();
+        if (!cInfo || cInfo->rank != 3) { omitAngle = true; }
+    }
+
+    //Move
+    if (doFollow)
+    {
+        float curDist = m_bot->GetDistance(followTarget);
+        if (m_pulling ||
+            (!m_bot->isMoving() &&
+            ((curDist > bMaxDist || curDist < bMinDist)  //Outside range boundries
+            || (!omitAngle && ((!followTarget->HasInArc(M_PI,m_bot)) ^ (bAngle > 0.5f * M_PI && bAngle < 1.5f * M_PI)))) )//is at right position front/behind?
+            )
+        {
+            //m_bot->GetMotionMaster()->Clear();
+            //sLog->outError("Bot[%u] is moving, curDist[%f], bDist[%f], bminDist[%f], bMaxDist[%f], bAngle[%f], InFront[%u]", m_bot->GetGUIDLow(), curDist, bDist,bMinDist, bMaxDist, bAngle, followTarget->HasInArc(M_PI,m_bot));
+            if (angleIsAutoSet && omitAngle) { m_bot->GetMotionMaster()->MoveChase(followTarget, bDist); }
+            else { m_bot->GetMotionMaster()->MoveChase(followTarget, bDist, bAngle); }
+            rval |= true;
+        }
+    }
+    //Face your faceTarget
+    if (!m_bot->HasInArc(M_PI/16, faceTarget) && !m_bot->isMoving() ) { m_bot->SetFacingToObject(faceTarget); rval |= true; }
+    return rval;
+}
+
+uint8 PlayerbotClassAI::GetThreatPercent(Unit *pTarget, Unit *pFrom)
+{
+    uint8 tPercent = 0;
+    Unit *pVictim = pTarget->getVictim();
+    if (!pVictim) return 100; //Not Attacking anyone yet, somehow..
+    if (!pFrom) { pFrom = m_bot; }
+    if (pVictim->GetGUID() == pFrom->GetGUID()) return 100; //I'm already being attacked, too late for alert, kill it..
+    //if (m_tank->GetGUID() == m_bot->GetGUID()) {} //If I am not tank and there is a target
+
+    ThreatManager &pthreatManager = pTarget->getThreatManager();
+    float maxThreat = pthreatManager.getThreat(pTarget->getVictim()) ;
+    if (maxThreat <= 0) { return 100; } //0 threat
+    float curThreat = pthreatManager.getThreat(pFrom);
+    return (curThreat * 100 / maxThreat);
+}
+//Gets if the unit is under attack by # of attackers
+bool PlayerbotClassAI::isUnderAttack(Unit *pAttacked,const uint8 &minNumberOfAttackers)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) { return false; } }
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() >= minNumberOfAttackers) { return true; }
+    return false;
+}
+
+//Gets the first found attacker of Unit
+Unit *PlayerbotClassAI::GetAttackerOf(Unit *pAttacked)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) { return NULL; } }
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() <= 0) { return NULL; }
+    return (*fAttackerSet.begin());
+}
+//Gets the first found attacker of Unit if not nearestToAttacked > finds the one nearest to bot
+Unit *PlayerbotClassAI::GetNearestAttackerOf(Unit *pAttacked, bool nearestToAttacked)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) return NULL;}
+
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() <= 0) { return NULL; }
+
+    Unit *nearestTo = m_bot;
+    if (nearestToAttacked) { nearestTo = pAttacked; }
+
+    Unit *curAtt = NULL;
+    float minDist = 30;
+
+
+    for (Unit::AttackerSet::const_iterator itr = fAttackerSet.begin(); itr != fAttackerSet.end(); ++itr)
+    {
+        Unit *tAtt = (*itr);
+        if (!tAtt) break; // Something is wrong.. How can a non existing mob attack?
+        if (tAtt->isDead()) break;
+        if (m_bot->GetDistance(tAtt) >= minDist) continue; //Get the nearest one
+        curAtt = tAtt;
+        minDist = tAtt->GetDistance(nearestTo);
+    }
+    return curAtt;
+
+}
+
+uint8 PlayerbotClassAI::GetHealthPercentRaid(Player *gPlayer, uint8 &countNeedHealing)
+{
+    uint8 validMemberCount=0;
+    uint16 totalHPPercent=0;
+    std::list<Unit*> unitList;
+    gPlayer->GetRaidMember(unitList,30);
+    if(!unitList.empty()){
+      for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr) {
+        //Player *tPlayer = GetPlayerBot()->GetObjPlayer((*itr)->GetGUID());
+        Unit *tPlayer = sObjectMgr->GetPlayer((*itr)->GetGUID());
+        if(tPlayer == NULL) continue;
+        if(tPlayer->isDead()) continue;
+        if(GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        //if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if(GetPlayerBot()->GetDistance(tPlayer) > 30) continue;
+        uint8 fndHPPercent =  tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth();
+        totalHPPercent+=fndHPPercent;
+        validMemberCount++;
+        if (fndHPPercent < 100) countNeedHealing++;
+
+        //const std::string myname = GetPlayerBot()->GetName();
+        //const std::string hisname = tPlayer->GetName();
+        //sLog->outDebug("me = %s, checked= %s %u [%u / %u]", myname.c_str(), hisname.c_str(), fndHPPercent, tPlayer->GetHealth(), tPlayer->GetMaxHealth());
+
+      }
+    }
+    if (validMemberCount == 0) return 100;
+    return totalHPPercent / validMemberCount;
+}
+
+Unit *PlayerbotClassAI::DoSelectLowestHpFriendly(float range, uint32 MinHPDiff)
+{
+    Unit *pUnit = NULL;
+    Trinity::MostHPMissingInRange u_check(GetPlayerBot(), range, MinHPDiff);
+    Trinity::UnitLastSearcher<Trinity::MostHPMissingInRange> searcher(GetPlayerBot(), pUnit, u_check);
+
+    GetPlayerBot()->VisitNearbyObject(range, searcher);
+
+    return pUnit;
+}
+
+void PlayerbotClassAI::SetMainTank(Unit *tank)
+{
+    mainTank = tank;
+}
+
+// is Resource heavy, do not spam or use heavily in loop
+Unit *PlayerbotClassAI::FindMainTankInRaid(Player *gPlayer)
+{
+    // check if original main tank is still alive. No point regetting main
+    // tank b/c chances are slim that it will not get reset in the middle of a fight.
+    // But if main tank dies, try to find next best canidate
+    if (mainTank!=NULL && mainTank->isAlive()) {
+        return mainTank;
+    }
+
+    if (!gPlayer) return NULL;
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return NULL;
+    uint64 pLeaderGuid = pGroup->GetLeaderGUID();
+
+    Unit *pPlayer = NULL;
+
+    // Check if set in raid
+    if (pGroup->isRaidGroup())
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINTANK, pGroup->GetGUID());
+        if(result)
+        {
+            uint64 pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+            pPlayer = sObjectMgr->GetPlayer(pGuid);
+            if (pPlayer && pGroup->IsMember(pGuid) && pPlayer->isAlive()){
+                mainTank = pPlayer;
+                return pPlayer;
+            }
+        }
+    }
+
+
+    // if could not find tank try assuming
+    // Assume the one with highest health is the main tank
+    uint32 maxhpfound=0;
+    std::list<Unit*> unitList;
+    gPlayer->GetRaidMember(unitList,30);
+    if (!unitList.empty()){
+      for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr) {
+        //Player *tPlayer = GetPlayerBot()->GetObjPlayer((*itr)->GetGUID());
+        Unit *tPlayer = sObjectMgr->GetPlayer((*itr)->GetGUID());
+        if (tPlayer == NULL) continue;
+        if (tPlayer->isDead()) continue;
+        if (GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        //if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if (GetPlayerBot()->GetDistance(tPlayer) > 50) continue;
+        if (tPlayer->GetMaxHealth() > maxhpfound) { maxhpfound = tPlayer->GetMaxHealth(); pPlayer=tPlayer; }
+        // Also check pets
+        if ( (tPlayer->getClass() == (uint8) CLASS_HUNTER || tPlayer->getClass() == (uint8) CLASS_WARLOCK) && IS_PET_GUID(tPlayer->GetPetGUID()) )
+        {
+            Pet* tpet = ObjectAccessor::GetPet(*tPlayer, tPlayer->GetPetGUID());
+            if (!tpet || !tpet->IsInWorld() || !tpet->isDead()) continue;
+            if (tpet->GetArmor() > tPlayer->GetArmor()) //Probably a tanking capable pet..
+            {
+                if (tpet->GetMaxHealth() > maxhpfound) { maxhpfound = tpet->GetMaxHealth(); pPlayer=tpet; }
+                else if (tPlayer->GetGUID() == pPlayer->GetGUID()) {pPlayer = tpet;} //set pet as tank instead of owner
+            }
+        }
+      }
+    }
+
+    mainTank = pPlayer;
+    return pPlayer;
+}
+
+Unit *PlayerbotClassAI::FindMainAssistInRaid(Player *gPlayer)
+{
+    if (!gPlayer) return NULL;
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return NULL;
+    uint64 pLeaderGuid = pGroup->GetLeaderGUID();
+
+
+    Unit *pPlayer = NULL;
+
+    // Check if set in raid
+    if (pGroup->isRaidGroup())
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINASSIST, pGroup->GetGUID());
+          if(result)
+        {
+            uint64 pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+            pPlayer = sObjectMgr->GetPlayer(pGuid);
+            if (pPlayer && pGroup->IsMember(pGuid) && pPlayer->isAlive()){
+                return pPlayer;
+            }
+        }
+    }
+
+    // default to main tank
+    return FindMainTankInRaid(gPlayer);
+}
+
+Player * PlayerbotClassAI::FindMage(Player *gPlayer)
+{
+    Group::MemberSlotList const &groupSlot = gPlayer->GetGroup()->GetMemberSlots();
+    for(Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *tPlayer = sObjectMgr->GetPlayer(itr->guid);
+
+        if(tPlayer == NULL) continue;
+        if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if(GetPlayerBot()->GetAreaId() != gPlayer->GetAreaId()) continue;
+        if(GetPlayerBot()->GetDistance(tPlayer) > 30) continue;
+
+        if (tPlayer->getClass() == CLASS_MAGE) return tPlayer;
+    }
+    return NULL;
+}
+
+
diff --git a/src/server/game/AI/Bots/PlayerbotClassAI.h b/src/server/game/AI/Bots/PlayerbotClassAI.h
new file mode 100644
index 0000000..5537b1d
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotClassAI.h
@@ -0,0 +1,162 @@
+#ifndef _PLAYERBOTCLASSAI_H
+#define _PLAYERBOTCLASSAI_H
+
+#include "Common.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "Unit.h"
+#include "SharedDefines.h"
+#include "PlayerbotAI.h"
+#include "SpellAuras.h"
+#include "Cell.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+
+
+class Player;
+class PlayerbotAI;
+class Aura;
+
+        enum BotRole
+        {
+            BOT_ROLE_NONE,
+            BOT_ROLE_TANK,
+            BOT_ROLE_OFFTANK,
+            BOT_ROLE_DPS_RANGED,
+            BOT_ROLE_DPS_MELEE,
+            BOT_ROLE_SUPPORT,
+            BOT_ROLE_HEALER
+        };
+
+class PlayerbotClassAI
+{
+    public:
+        PlayerbotClassAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotClassAI();
+
+        //all combat actions go here
+        virtual void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        virtual void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        virtual bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        virtual bool HealTarget (Unit *target, uint8 hp);
+
+        //Heals the group based off its HP
+        virtual bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cure the target
+        virtual bool CureTarget (Unit *target);
+
+        //Resurrect the target (OBSOLETE - Check individual ClassAIs instead)
+        virtual bool RezTarget(Unit *target);
+
+        //find any specific mount spells, ie druids = cat, shaman = ghost wolf etc (OBSOLETE)
+        virtual bool FindMount();
+
+        virtual bool Unmount();
+
+        virtual bool IsMounted();
+
+        virtual void LoadSpells();
+
+        virtual void Pull();
+
+        //Utilities
+        Player *GetMaster (){ return m_master; }
+        Player *GetPlayerBot(){ return m_bot; }
+        PlayerbotAI *GetAI (){ return m_ai; }
+
+        bool isPulling() { return m_pulling; }
+        bool TakePosition(Unit *followTarget, BotRole bRole=BOT_ROLE_NONE, float bDist=0, float bMinDist=0, float bMaxDist=0, float bAngle=0, Unit *faceTarget=NULL);
+        //Gets the threat done by bot / threat max (percent) to the target.
+        uint8 GetThreatPercent(Unit *pTarget, Unit *pFrom = NULL);
+        //Gets if the unit is under attack by # of attackers
+        bool isUnderAttack(Unit *pAttacked=NULL,const uint8 &minNumberOfAttackers=1);
+        //Gets the first found attacker of Unit
+        Unit *GetAttackerOf(Unit *pAttacked=NULL);
+        //Gets the nearest attacker of Unit if not nearestToAttacked > finds the one nearest to bot
+        Unit *GetNearestAttackerOf(Unit *pAttacked=NULL, bool nearestToAttacked=false);
+        //Calculates Average Raid Health condition as Percentage, ref value is the Count of units need healing..
+        uint8 GetHealthPercentRaid(Player *gPlayer, uint8 &countNeedHealing);
+
+        // Called when the main tank is set from raid ui
+        void SetMainTank (Unit *tank);
+
+        //Finds the possible MainTank in Raid including Hunter/Warlock pets.. Makes the assumption based on - max maxHealth..
+        Unit *FindMainTankInRaid(Player *gPlayer);
+
+        //Finds the possible MainAssist in Raid.  Defaults to Main Tank if it cannot find one.
+        Unit *FindMainAssistInRaid(Player *gPlayer);
+
+        Player *FindMage(Player *gPlayer);
+        //Finds the lowest hp creature around that is friendly with the caster.
+        Unit *DoSelectLowestHpFriendly(float range, uint32 MinHPDiff);
+
+
+        protected:
+        bool CastSpell(uint32 spellId, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+        bool CastSpell(const SpellEntry * pSpellInfo, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+        bool CanCast(uint32 spellId, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+        bool CanCast(const SpellEntry * pSpellInfo, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+
+        //Debug method to list the auras currently active.
+        //Use to find what spells were casted
+        bool listAuras(Unit *unit);
+
+        //More generalized method than HasAura().  It looks for
+        //any rank of the spell and it doesn't care which
+        //spell effect you want.  If it has the spell aura than
+        //it returns true
+        bool HasAuraName(Unit *unit, std::string spell, uint64 casterGuid=0);
+        bool HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid=0);
+
+        //The following functions return true only a match is found and the bot successfully casted a spell to resolve the problem
+        //If the result is false, either a match is not found, or the ClassAI could not cast or refused to cast a spell for some reason..
+
+        //Combination of all Healer roles, scans the party and decides if group healing > individual healing > Rez > curing > buffing is needed
+        //and directs any matches found to individual ClassAIs
+        //Main Raid scan function for Healer/Support types..
+        bool DoSupportRaid(Player *gPlayer, float radius=30, bool dResurrect=true, bool dGroupHeal=true, bool dHeal=true, bool dCure=true, bool dBuff=true);
+        //Find matching debuffs on target to provided Spell, and call castSpell() with provided parameters
+        bool castDispel (uint32 dispelSpell, Unit *dTarget, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+        //Cast matching debuffs on self with probided SpellId list.. Mainly Used for Racial spells.. List is used to prevent extra loops for each spell..
+        bool castSelfCCBreakers (uint32 castList[]);
+
+
+
+        typedef std::set<Unit *> AttackerSet;
+
+        uint8 rezSpamTimer;
+        uint32 foodDrinkSpamTimer;
+        static const uint32 foodDrinkSpamCount = 100;
+
+        BotRole m_role;
+        bool m_pulling;
+        uint32 threatThreshold, offensiveSpellThreshold;
+
+        // RACIAL SPELLS
+        uint32 R_ARCANE_TORRENT, R_BERSERKING, R_BLOOD_FURY, R_CANNIBALIZE, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_GIFT_OF_NAARU, R_SHADOWMELD, R_STONEFORM, R_WAR_STOMP, R_WILL_OF_FORSAKEN;
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+        uint32 SHOOT;
+
+    private:
+        Player *m_master;
+        Player *m_bot;
+        PlayerbotAI *m_ai;
+        Unit *mainTank;
+
+
+
+};
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotDeathKnightAI.cpp b/src/server/game/AI/Bots/PlayerbotDeathKnightAI.cpp
new file mode 100644
index 0000000..b0c26d9
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotDeathKnightAI.cpp
@@ -0,0 +1,325 @@
+/*
+Name : PlayerbotDeathknightAI.cpp
+Complete: maybe around 65%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is Blood dps/offtank type
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Situations needing Death grip casting : limited / non-existant..
+
+Authors : SwaLLoweD, rrtn
+Version : 0.40
+*/
+
+#include "PlayerbotDeathKnightAI.h"
+
+class PlayerbotAI;
+PlayerbotDeathKnightAI::PlayerbotDeathKnightAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+
+PlayerbotDeathKnightAI::~PlayerbotDeathKnightAI() {}
+
+void PlayerbotDeathKnightAI::LoadSpells(){
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    // Unholy
+    PLAGUE_STRIKE = ai->getSpellIdExact("Plague Strike");
+    DEATH_STRIKE = ai->getSpellIdExact("Death Strike");
+    SCOURGE_STRIKE  = ai->getSpellIdExact("Scourge Strike");
+
+    // Frost
+    ICY_TOUCH = ai->getSpellIdExact("Icy Touch");
+    OBLITERATE = ai->getSpellIdExact("Obliterate");
+
+    // Blood
+    BLOOD_STRIKE = ai->getSpellIdExact("Blood Strike");
+    HEART_STRIKE  = ai->getSpellIdExact("Heart Strike");
+    RUNE_TAP = ai->getSpellIdExact("Rune Tap");
+    DARK_COMMAND = ai->getSpellIdExact("Dark Command");
+
+    // AOE
+    HOWLING_BLAST = ai->getSpellIdExact("Howling Blast");
+    BLOOD_BOIL = ai->getSpellIdExact("Blood Boil");
+    PESTILENCE = ai->getSpellIdExact("Pestilence");
+    CORPSE_EXPLOSION = ai->getSpellIdExact("Corpse Explosion");
+    DEATH_AND_DECAY = ai->getSpellIdExact("Death and Decay");
+
+    // Rune attacks
+    FROST_STRIKE = ai->getSpellIdExact("Frost Strike");
+    DEATH_COIL = ai->getSpellIdExact("Death Coil");
+    RUNE_STRIKE = ai->getSpellIdExact("Rune Strike");
+
+    // CC Interrupt
+    DEATH_GRIP = ai->getSpellIdExact("Death Grip");
+    CHAINS_OF_ICE = ai->getSpellIdExact("Chains of Ice");
+    MIND_FREEZE = ai->getSpellIdExact("Mind Freeze");
+    HUNGERING_COLD = ai->getSpellIdExact("Hungering Cold");
+    STRANGULATE = ai->getSpellIdExact("Strangulate");
+
+    // Debuffs
+    FROST_FEVER = 55095; //ai->getSpellIdExact("Frost Fever",true);
+    BLOOD_PLAGUE = 55078; //ai->getSpellIdExact("Blood Plague",true);
+    CRYPT_FEVER = ai->getSpellIdExact("Crypt Fever",true);
+    EBON_PLAGUE = ai->getSpellIdExact("Ebon Plague",true);
+    MARK_OF_BLOOD = ai->getSpellIdExact("Mark of Blood");
+
+    // Buffs
+    HORN_OF_WINTER = ai->getSpellIdExact("Horn of Winter");
+    BONE_SHIELD = ai->getSpellIdExact("Bone Shield");
+    VAMPIRIC_BLOOD = ai->getSpellIdExact("Vampiric Blood");
+    HYSTERIA = ai->getSpellIdExact("Hysteria");
+    UNBREAKABLE_ARMOR = ai->getSpellIdExact("Unbreakable Armor");
+    ANTI_MAGIC_SHELL = ai->getSpellIdExact("Anti Magic Shell");
+    ANTI_MAGIC_ZONE = ai->getSpellIdExact("Anti Magic Zone");
+    ICEBOUND_FORTITUDE = ai->getSpellIdExact("Icebound Fortitude");
+    EMPOWER_WEAPON = ai->getSpellIdExact("Empower Rune Weapon");
+    LICHBORNE = ai->getSpellIdExact("Lichborne");
+
+    // Summons
+    RAISE_DEAD = ai->getSpellIdExact("Raise Dead");
+    ARMY_OF_THE_DEAD = ai->getSpellIdExact("Army of the Dead");
+    SUMMON_GARGOYLE = ai->getSpellIdExact("Summon Gargoyle");
+    GHOUL_FRENZY = ai->getSpellIdExact("Ghoul Frenzy");
+    DEATH_PACT = ai->getSpellIdExact("Death Pact");
+    DANCING_WEAPON = ai->getSpellIdExact("Dancing Rune Weapon");
+
+    // Presences
+    BLOOD_PRESENCE = ai->getSpellIdExact("Blood Presence");
+    FROST_PRESENCE = ai->getSpellIdExact("Frost Presence");
+    UNHOLY_PRESENCE  = ai->getSpellIdExact("Unholy Presence");
+
+    // Talent
+    TALENT_BLOOD = HEART_STRIKE;
+    TALENT_FROST = FROST_STRIKE;
+    TALENT_UNHOLY = SCOURGE_STRIKE;
+
+    uint8 talentCounter = 0;
+    if (TALENT_BLOOD) talentCounter++;
+    if (TALENT_FROST) talentCounter++;
+    if (TALENT_UNHOLY) talentCounter++;
+    if (talentCounter > 1) { TALENT_BLOOD = 0; TALENT_FROST = 0; TALENT_UNHOLY = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+void PlayerbotDeathKnightAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    std::ostringstream out;
+
+
+    if (!m_pulling)
+    {
+        m_role = BOT_ROLE_DPS_MELEE;
+        #pragma region Choose Role/Presence
+
+        // Choose Presence
+        if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+        {
+            if (CastSpell(FROST_PRESENCE,m_bot)) { m_role = BOT_ROLE_TANK; return; }
+        }
+        else if (isUnderAttack()) // I am under attack
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2)  {} // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+            if (CastSpell(FROST_PRESENCE,m_bot)) { m_role = BOT_ROLE_OFFTANK; return; }
+        }
+        else if (TALENT_UNHOLY)
+        {
+            if (CastSpell(UNHOLY_PRESENCE,m_bot)) return;
+        }
+        else if (CastSpell(BLOOD_PRESENCE,m_bot)) return;
+        #pragma endregion
+    }
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[6] = { LICHBORNE, ICEBOUND_FORTITUDE, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    TakePosition(pTarget);
+
+
+   if (m_pulling) {
+        if (GetAI()->CastSpell(DEATH_GRIP,pTarget)) {
+            m_pulling = false;
+            GetAI()->SetCombatOrder(ORDERS_NONE);
+            GetAI()->Follow(*GetMaster());
+            GetAI()->SetIgnoreUpdateTime(2);
+
+            if (m_bot->GetPet()) pet->SetReactState (REACT_DEFENSIVE);
+         }
+          return;
+    }
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    #pragma region Buff Heal Interrupt
+    //Buff UP
+    if (CastSpell(HORN_OF_WINTER,m_bot)) { return; }
+    if (CastSpell(BONE_SHIELD,m_bot)) { return; }
+
+    //HEAL UP && PROTECT UP
+    if (ai->GetHealthPercent() < 80 && ai->GetHealthPercent() > 20 && CastSpell(VAMPIRIC_BLOOD,m_bot)) { }  //NO GCD
+    if (ai->GetHealthPercent() < 65 && CastSpell(RUNE_TAP,m_bot)) { } //NO GCD
+    if (CanCast(DEATH_STRIKE,pTarget,true) && ai->GetHealthPercent() < 90 &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) ||pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(DEATH_STRIKE,pTarget,false) ) {return;}
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (pet && ai->GetHealthPercent() < 50 && CastSpell(DEATH_PACT,m_bot)) { return; }
+    if (pet && ai->GetHealthPercent() < 60 && CastSpell(MARK_OF_BLOOD,pTarget)) { return; }
+    if (ai->GetHealthPercent() < 65 && CastSpell(ICEBOUND_FORTITUDE,m_bot)) { } //No GCD
+    if (ai->GetHealthPercent() < 65 && CastSpell(UNBREAKABLE_ARMOR,m_bot)) { return; }
+
+    //Break spells being cast
+    if (pTarget->IsNonMeleeSpellCasted(true))
+    {
+        if (CastSpell(MIND_FREEZE,pTarget)) {} // No GCD
+        if (CastSpell(STRANGULATE,pTarget)) { return; }
+        if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+        if (CastSpell(ANTI_MAGIC_ZONE,m_bot)) { return; }
+        if (CastSpell(ANTI_MAGIC_SHELL,m_bot)) {} //NO GCD
+    }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(DEATH_GRIP,pTarget)) return;
+        if (CastSpell(CHAINS_OF_ICE,pTarget)) return;
+    }
+    #pragma endregion
+
+    #pragma region Taunt / Threat
+    // if i am main tank, protect master by taunt
+    if(m_tank->GetGUID() == m_bot->GetGUID())
+    {
+        // Taunt if needed (Only for master)
+        Unit *curAtt = GetAttackerOf(GetMaster());
+        if (curAtt && CastSpell(DARK_COMMAND, curAtt))  { }     //No gcd
+        // My target is not attacking me, taunt..
+        if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(DARK_COMMAND, pTarget) )  { } // No gcd
+    }
+
+    // If not in Frost Presence slow down due to threat
+    if (pThreat > threatThreshold && !m_bot->HasAura(FROST_PRESENCE) && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else { return; } //DK has no threat reducing spells, just slow down
+    }
+    #pragma endregion
+
+    #pragma region Dps
+    //Dps up
+    if (CastSpell(EMPOWER_WEAPON,m_bot)) {} //NO GCD
+    if (ai->GetHealthPercent() > 90 && CastSpell(HYSTERIA,m_bot)) {} //NO GCD
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    // Use up excess Runic Power
+    if (ai->GetRunicPower() > 60 && CastSpell(FROST_STRIKE,pTarget)) { return; }
+    else if (ai->GetRunicPower() > 60 && CastSpell(DEATH_COIL,pTarget,true,true,true)) { return; }
+    if ((isUnderAttack() || ai->GetRunicPower() > 70) && CastSpell(RUNE_STRIKE,pTarget)) {} //Next attack spell
+
+    // Build Diseases
+    if (!pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) && CastSpell(ICY_TOUCH,pTarget)) { return; }
+    if (!pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) && CastSpell(PLAGUE_STRIKE,pTarget)) { return; }
+
+    // Use AOEs summons
+    if (isUnderAttack(m_tank,4) && CastSpell(DEATH_AND_DECAY,pTarget)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(HOWLING_BLAST,pTarget)) { return; }
+    if (CanCast(PESTILENCE,pTarget,true) && isUnderAttack(m_tank,4) &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) && pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(PESTILENCE,pTarget,false)) { return; }
+    if (CanCast(BLOOD_BOIL,pTarget,true) && isUnderAttack(m_tank,4) &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) || pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(BLOOD_BOIL,pTarget,false)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    if (isUnderAttack(m_tank,6) && CastSpell(ARMY_OF_THE_DEAD,m_bot)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(SUMMON_GARGOYLE,pTarget)) { return; } //This should be somewhat different
+
+    // Use standard damage spells
+    if (CastSpell(HEART_STRIKE,pTarget,true,true)) { return; }
+    if (CastSpell(BLOOD_STRIKE,pTarget)) { return; }
+    if (TALENT_FROST && CastSpell(OBLITERATE,pTarget)) { return; }
+    else if (TALENT_UNHOLY && CastSpell(SCOURGE_STRIKE,pTarget)) { return; }
+    else if (CastSpell(DEATH_STRIKE,pTarget)) { return; }
+    #pragma endregion
+
+} // end DoNextCombatManeuver
+
+void PlayerbotDeathKnightAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff UP
+    if (CastSpell(HORN_OF_WINTER,m_bot)) { return; }
+    if (CastSpell(BONE_SHIELD,m_bot)) { return; }
+
+    //mana/hp check
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(RUNE_TAP,m_bot)) { return; } //no gcd but lets give the others a time to heal
+    if (ai->GetHealthPercent() < 30) { ai->Feast(); }
+    //Item* fItem = ai->FindBandage();
+    /* if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }  */
+} // end DoNonCombatActions
+
+void PlayerbotDeathKnightAI::Pull()
+{
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        m_pulling = false;
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+
+    if (GetPlayerBot()->GetPet()) GetPlayerBot()->GetPet()->SetReactState (REACT_PASSIVE);
+}
diff --git a/src/server/game/AI/Bots/PlayerbotDeathKnightAI.h b/src/server/game/AI/Bots/PlayerbotDeathKnightAI.h
new file mode 100644
index 0000000..a337537
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotDeathKnightAI.h
@@ -0,0 +1,61 @@
+#ifndef _PLAYERDEATHKNIGHTAI_H
+#define _PLAYERDEATHKNIGHTAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotDeathKnightAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotDeathKnightAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotDeathKnightAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        void Pull();
+
+    private:
+        // Unholy
+        uint32 PLAGUE_STRIKE, DEATH_STRIKE, SCOURGE_STRIKE;
+
+        // Frost
+        uint32 ICY_TOUCH, OBLITERATE;
+
+        // Blood
+        uint32 BLOOD_STRIKE, HEART_STRIKE, RUNE_TAP, DARK_COMMAND;
+
+        // AOE
+        uint32 HOWLING_BLAST, BLOOD_BOIL, PESTILENCE, CORPSE_EXPLOSION, DEATH_AND_DECAY;
+
+        // Rune attacks
+        uint32 FROST_STRIKE, DEATH_COIL, RUNE_STRIKE;
+
+        // CC Interrupt
+        uint32 DEATH_GRIP, CHAINS_OF_ICE, MIND_FREEZE, HUNGERING_COLD, STRANGULATE;
+
+        // Debuffs
+        uint32 FROST_FEVER, BLOOD_PLAGUE, CRYPT_FEVER, EBON_PLAGUE, MARK_OF_BLOOD;
+
+        // Buffs
+        uint32 HORN_OF_WINTER, BONE_SHIELD, VAMPIRIC_BLOOD, HYSTERIA, UNBREAKABLE_ARMOR, ANTI_MAGIC_SHELL, ANTI_MAGIC_ZONE, ICEBOUND_FORTITUDE, EMPOWER_WEAPON, LICHBORNE;
+
+        // Summons
+        uint32 RAISE_DEAD, ARMY_OF_THE_DEAD, SUMMON_GARGOYLE, GHOUL_FRENZY, DEATH_PACT, DANCING_WEAPON;
+
+        // Presences
+        uint32 BLOOD_PRESENCE, FROST_PRESENCE, UNHOLY_PRESENCE;
+
+        // Talent
+        uint32 TALENT_BLOOD, TALENT_FROST, TALENT_UNHOLY;
+
+};
+
+#endif
+
diff --git a/src/server/game/AI/Bots/PlayerbotDruidAI.cpp b/src/server/game/AI/Bots/PlayerbotDruidAI.cpp
new file mode 100644
index 0000000..4afa17d
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotDruidAI.cpp
@@ -0,0 +1,676 @@
+/*
+Name : PlayerbotDruidAI.cpp
+Complete: maybe around 70%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is a combination of Feral/balance type..
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Tree of life form transition is late and may never occur, due to healing bots attacking priority at full mana.
+                - Boomkin's support roles are not fully covered.. For example -> off healing
+                - Situations needing Abolish Disease casting : limited / non-existant..
+
+Authors : SwaLLoweD, rrtn, Natsukawa
+Version : 0.40
+*/
+#include "PlayerbotDruidAI.h"
+
+class PlayerbotAI;
+
+PlayerbotDruidAI::PlayerbotDruidAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+
+PlayerbotDruidAI::~PlayerbotDruidAI(){}
+
+void PlayerbotDruidAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+#pragma region SpellId Fill
+    // Balance Spells
+    MOONFIRE = ai->getSpellIdExact("Moonfire"); //attacks
+    WRATH = ai->getSpellIdExact("Wrath");
+    STARFIRE = ai->getSpellIdExact("Starfire");
+    STARFALL = ai->getSpellIdExact("Starfall");
+    FORCE_OF_NATURE = ai->getSpellIdExact("Force of Nature");
+    TYPHOON = ai->getSpellIdExact("Typhoon");
+    HURRICANE = ai->getSpellIdExact("Hurricane");
+    INSECT_SWARM = ai->getSpellIdExact("Insect Swarm");
+
+    CYCLONE = ai->getSpellIdExact("Cyclone");
+    ROOTS = ai->getSpellIdExact("Entangling Roots");
+    NATURES_GRASP = ai->getSpellIdExact("Nature's Grasp");
+
+    HIBERNATE = ai->getSpellIdExact("Hibernate");
+    FAERIE_FIRE = ai->getSpellIdExact("Faerie Fire");
+
+
+    // Bear Form Spells
+    MAUL = ai->getSpellIdExact("Maul");
+    BASH = ai->getSpellIdExact("Bash");
+    LACERATE = ai->getSpellIdExact("Lacerate");
+    MANGLE_BEAR = ai->getSpellIdExact("Mangle (Bear)");
+    SWIPE_BEAR = ai->getSpellIdExact("Swipe (Bear)");
+
+    DEMORALIZING_ROAR = ai->getSpellIdExact("Demoralizing Roar");
+    GROWL = ai->getSpellIdExact("Growl");
+    CHALLENGING_ROAR = ai->getSpellIdExact("Challenging Roar");
+
+    ENRAGE = ai->getSpellIdExact("Enrage");
+    FERAL_CHARGE_BEAR = ai->getSpellIdExact("Feral Charge - Bear");
+    FRENZIED_REGENERATION = ai->getSpellIdExact("Frenzied Regeneration");
+
+
+    //Cat Attack type's
+    RAKE = ai->getSpellIdExact("Rake"); //40 energy
+    CLAW = ai->getSpellIdExact("Claw"); //45
+    MANGLE_CAT = ai->getSpellIdExact("Mangle (Cat)"); //45
+    SHRED = ai->getSpellIdExact("Shred");
+
+    RIP = ai->getSpellIdExact("Rip"); //30
+    FEROCIOUS_BITE = ai->getSpellIdExact("Ferocious Bite"); //35
+    SAVAGE_ROAR = ai->getSpellIdExact("Savage Roar");
+    MAIM = ai->getSpellIdExact("Maim"); //35
+
+    FERAL_CHARGE_CAT = ai->getSpellIdExact("Feral Charge - Cat");
+    COWER = ai->getSpellIdExact("Cower"); //20
+    TIGERS_FURY = ai->getSpellIdExact("Tiger's Fury");
+
+    // Feral General
+    BERSERK = ai->getSpellIdExact("Berserk");
+    FAERIE_FIRE_FERAL = ai->getSpellIdExact("Faerie Fire (Feral)"); //debuffs
+
+    //buffs
+    MARK_OF_THE_WILD = ai->getSpellIdExact("Mark of the Wild"); //buffs
+    GIFT_OF_THE_WILD = ai->getSpellIdExact("Gift of the Wild");
+    THORNS = ai->getSpellIdExact("Thorns");
+    SURVIVAL_INSTINCTS = ai->getSpellIdExact("Survival Instincts");
+
+    // Restoration Spells
+    LIFEBLOOM = ai->getSpellIdExact("Lifebloom");
+    REJUVENATION = ai->getSpellIdExact("Rejuvenation"); //heals
+    REGROWTH = ai->getSpellIdExact("Regrowth");
+    NOURISH = ai->getSpellIdExact("Nourish");
+    SWIFTMEND = ai->getSpellIdExact("Swiftmend");
+    HEALING_TOUCH = ai->getSpellIdExact("Healing Touch");
+    INNERVATE = ai->getSpellIdExact("Innervate");
+    WILD_GROWTH = ai->getSpellIdExact("Wild Growth");
+    TRANQUILITY = ai->getSpellIdExact("Tranquility");
+    NATURES_SWIFTNESS = ai->getSpellIdExact("Nature's Swiftness");
+
+    CURE_POISON = ai->getSpellIdExact("Abolish Poison");
+    if (!CURE_POISON) CURE_POISON = ai->getSpellIdExact("Cure Poison");
+
+    REBIRTH    = ai->getSpellIdExact("Rebirth");
+    REVIVE = ai->getSpellIdExact("Revive");
+
+    BARKSKIN = ai->getSpellIdExact("Barkskin");
+
+    //Druid Forms
+    BEAR_FORM = ai->getSpellIdExact("Dire Bear Form");
+    if (!BEAR_FORM) BEAR_FORM = ai->getSpellIdExact("Bear Form");
+    CAT_FORM = ai->getSpellIdExact("Cat Form");
+    MOONKIN_FORM = ai->getSpellIdExact("Moonkin Form");
+    TREE_OF_LIFE_FORM = ai->getSpellIdExact("Tree of Life"); //33891;//learning spell has higher id..
+    AQUATIC_FORM = ai->getSpellIdExact("Aquatic Form");
+    TRAVEL_FORM = ai->getSpellIdExact("Travel Form");
+    FLIGHT_FORM = ai->getSpellIdExact("Swift Flight Form");
+    if (!FLIGHT_FORM) FLIGHT_FORM = ai->getSpellIdExact("Flight Form");
+
+
+    TALENT_BALANCE    = MOONKIN_FORM;
+    TALENT_RESTO    = SWIFTMEND;
+    TALENT_FERAL    = MANGLE_CAT;
+
+    uint8 talentCounter = 0;
+    if (TALENT_BALANCE) talentCounter++;
+    if (TALENT_FERAL) talentCounter++;
+    if (TALENT_RESTO) talentCounter++;
+    if (talentCounter > 1) { TALENT_BALANCE = 0; TALENT_RESTO = 0; TALENT_FERAL = 0; } //Unreliable Talent detection.
+#pragma endregion
+}
+
+void PlayerbotDruidAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+
+    #pragma region Select behaviour
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        if (TALENT_FERAL && BEAR_FORM) { m_role = BOT_ROLE_TANK; } //Just Keep Tanking dont even change forms for healing
+        else
+        {
+            if (TALENT_BALANCE) {
+                if ((ai->GetHealthPercent() <= 40 || masterHP <30 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else if (ai->GetManaPercent() < 25 ) { m_role = BOT_ROLE_TANK; }
+                else { m_role = BOT_ROLE_DPS_RANGED; }
+            }
+            else //I am both healer and tank?? Hmm
+            {
+                if ((ai->GetHealthPercent() <= 70 || masterHP <70 ) && (ai->GetManaPercent() >= 50)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else if (ai->GetManaPercent() < 15 ) { m_role = BOT_ROLE_TANK; }
+                else { m_role = BOT_ROLE_DPS_RANGED; }
+            }
+        }
+    }
+    else if (isUnderAttack() && !( ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_TREE)  ) // if i am under attack
+    {
+        // Keep being in Cat Form if you can reduce threat
+        if (ai->GetForm() == FORM_CAT && CastSpell(COWER,pTarget)) {return; }
+        else if (TALENT_RESTO && ai->GetManaPercent() > 10 ) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_OFFTANK; }
+    }
+    else if (TALENT_FERAL && CAT_FORM) { // If has any feral forms at all
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 30 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+        else{ m_role = BOT_ROLE_DPS_MELEE; }
+    }
+    else if (TALENT_BALANCE) {
+        if ((ai->GetHealthPercent() <= 50 || masterHP <40 ) && (ai->GetManaPercent() >= 10)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+    else if (TALENT_RESTO)    { m_role = BOT_ROLE_SUPPORT; }
+    else
+    {
+        // Unknown build or low level : Do not change forms rapidly..
+        if ( (ai->GetManaPercent() < 30 && BEAR_FORM) || ( (ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR) && ai->GetManaPercent() < 70 )  ) m_role = BOT_ROLE_DPS_MELEE;
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+
+    if (!isUnderAttack() && m_tank->GetGUID() != m_bot->GetGUID())
+    {
+        // Select Attacking target
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {} //if my target is attacking me continue
+        else
+        {
+            Unit *curAtt = GetNearestAttackerOf(m_bot);
+            if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(curAtt->GetGUID());
+                //ai->AddLootGUID(curAtt->GetGUID());
+                DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                return;
+            }
+        }
+        //my target is attacking me
+    }
+    #pragma endregion
+
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+    // Return to normal form from non combat forms
+    if (ai->GetForm() == FORM_NONE || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_TREE || ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR )  { } //Those are valid incombat auras
+    else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { } //return to caster form
+
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            //ai->TellMaster("DruidCombat");
+
+            // Do caster form stuff
+            if (ai->GetForm() == FORM_NONE)
+            {
+                //We have little mana probably cant change form
+                if (ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot) ) { return; }
+                else if(m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) {  return;}
+                else if(DoSupportRaid(GetMaster(),false,false,false)) return;
+                else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+            }
+
+            if (CAT_FORM) { if (ChangeForm(CAT_FORM)) { return; } }
+            else if (BEAR_FORM) { if (ChangeForm(BEAR_FORM)) { return; } }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) {  } //Normal Form
+
+            TakePosition(pTarget);
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_OFFTANK:
+        case BOT_ROLE_TANK: // It is a tank druid or a defending druid
+
+            // Do what you must before getting attacked...
+            if (ai->GetForm() == FORM_NONE)
+            {
+                // Non tank stuff to avoid
+                if (m_tank->GetGUID() != m_bot->GetGUID())
+                {
+                    if (ROOTS && !pTarget->HasAura(CYCLONE) && !pTarget->HasAura(HIBERNATE) && CastSpell(ROOTS, pTarget)) { return; }
+                    if (CYCLONE && pDist > 5 && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(HIBERNATE) && CastSpell(CYCLONE, pTarget)) { return; }
+                    if (HIBERNATE && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(CYCLONE) && CastSpell(HIBERNATE, pTarget)) { return; }
+                    //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+                }
+                // Things to do wheter Tank or not
+                if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd
+                if (ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot) ) { return; } //We have little mana probably cant change form
+            }
+            TakePosition(pTarget);
+
+            if (ChangeForm(BEAR_FORM)) { return; }
+
+            // if i am main tank, protect master by taunt
+            if(m_tank->GetGUID() == m_bot->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt)
+                {
+                    if (isUnderAttack(GetMaster(),2) && CastSpell(CHALLENGING_ROAR, curAtt)) { return; }
+                    if (CastSpell(GROWL, curAtt))  { return; }
+                }
+                // My target is not attacking me, taunt..
+                if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(GROWL, pTarget) )  { return; }
+            }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            if ( ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot)) { return; }
+
+            // Do caster form stuff
+            if (ai->GetForm() == FORM_NONE)
+            {
+                if(DoSupportRaid(GetMaster())) return;
+                else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+            }
+
+            if (MOONKIN_FORM) { if (ChangeForm(MOONKIN_FORM)) { return; } }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { } //Normal Form
+
+            TakePosition(pTarget);
+
+            // BUFF UP
+            if(DoSupportRaid(GetMaster(),false,false,false)) return;
+            else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+            if ( ai->GetManaPercent() < 20 && CastSpell (INNERVATE,m_bot)) { return; }
+            //Get to tree form only if you will no longer cast attack spells
+            if( TREE_OF_LIFE_FORM && (ai->GetManaPercent() < offensiveSpellThreshold || isUnderAttack()) )
+            {
+                 if (ChangeForm(TREE_OF_LIFE_FORM)) { return; }
+            }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { }  //Normal Form no gcd
+
+            TakePosition(pTarget);
+
+            //RezGroup(REBIRTH, GetMaster());
+            if (DoSupportRaid(GetMaster())) { return; }
+            if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            Unit *target = DoSelectLowestHpFriendly(30, 1000);
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            break;
+        #pragma endregion
+    }
+
+    #pragma region DruidCommon
+    // Common Dps and protection routine
+    if (ai->GetHealthPercent() <= 70 && CastSpell(BARKSKIN,m_bot)) { return; }
+    if (isUnderAttack() && CastSpell(NATURES_GRASP,m_bot)) { return; }
+
+    if (ai->GetForm() == FORM_CAT)
+    {
+        // If at threat limit, use Cower to reduce threat
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+        {
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+            {
+                m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                return;
+            }
+            else
+            {
+                if (CastSpell(COWER,pTarget)) { return; } //Lets see if we can manage
+                else { return; } //use no spells and wait threat to be reduced
+            }
+        }
+        if (CastSpell(FERAL_CHARGE_CAT,pTarget)) { return; }
+        if (m_bot->GetComboPoints() >= 1 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(MAIM, pTarget)) { return; }
+
+        if (CastSpell(BERSERK, m_bot)) { return; }
+        if (ai->GetHealthPercent() <= 75 && CastSpell(SURVIVAL_INSTINCTS, m_bot)) { return; }
+        if (isUnderAttack() && CastSpell(NATURES_GRASP, m_bot)) { return; }
+        if (CastSpell(FAERIE_FIRE_FERAL, pTarget)) { return; }
+
+        if (m_bot->GetComboPoints() < 5)
+        {
+            if (CastSpell(RAKE, pTarget)) { return; }
+            if (CastSpell(MANGLE_CAT, pTarget)) { return; }
+            if (!pTarget->HasInArc(M_PI,m_bot) && CastSpell(SHRED, pTarget)) { return; }
+            if (ai->GetEnergyAmount() > 65 && CastSpell(MANGLE_CAT, pTarget)) { return; } //Spam mangle if cannot cast shred
+            if (ai->GetEnergyAmount() > 65 && CastSpell(CLAW, pTarget) ) { return; } //Spam Claw if there is no mangle
+            // if (CanCast(COWER, pTarget) && CastSpell(COWER, pTarget)) { return; } //if still nothing, use COWER to reduce threat
+        }
+        else
+        {
+            if (CastSpell(SAVAGE_ROAR)) { return; }
+            if (CastSpell(RIP, pTarget)) { return; }
+            if (ai->GetEnergyAmount() >= 65 && CastSpell(FEROCIOUS_BITE, pTarget)) { return; } //maxhit for feracious bite
+        }
+        if (CastSpell(TIGERS_FURY, m_bot)) { return; } //if nothing is ready yet, use tigers fury
+    }
+    else if (ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        // If at threat limit, stop
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+        {
+            //Change to tank's target
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) { m_bot->SetSelection(m_tank->getVictim()->GetGUID()); }
+            return; //use no spells and wait threat to be reduced
+        }
+        if (CastSpell(FERAL_CHARGE_BEAR,pTarget)) { return; }
+        if (CastSpell(BASH, pTarget,true,true)) { return; } //Need check for immunity
+        if (CastSpell(BERSERK, m_bot)) { return; }
+        if (CastSpell(DEMORALIZING_ROAR, pTarget)) { return; }
+        if (ai->GetHealthPercent() > 90 && ai->GetRageAmount() < 50 && CastSpell(ENRAGE, m_bot)) { return; }
+        if (ai->GetHealthPercent() <= 75 && CastSpell(SURVIVAL_INSTINCTS, m_bot)) { return; }
+        if ( ( ai->GetHealthPercent() <= 30 || (ai->GetHealthPercent() < 85 && m_tank->GetGUID() != m_bot->GetGUID())  )
+            && CastSpell(FRENZIED_REGENERATION)) { return; }
+        if (CastSpell(FAERIE_FIRE_FERAL, pTarget)) { return; }
+        if (CastSpell(MANGLE_BEAR, pTarget)) { return; }
+        if ((ai->GetRageAmount() > 70 || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(SWIPE_BEAR, pTarget)) { return; }
+        if (ai->GetRageAmount() > 50 && CastSpell(MAUL, pTarget)) {} // Low Priority, Next Attack effect
+        if (ai->GetRageAmount() > 60 && CastSpell(LACERATE, pTarget)) { return; } //Currently applies only 1
+    }
+    else
+    {
+        //Defensive stuff
+        if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+        {
+            if (ROOTS && !pTarget->HasAura(CYCLONE) && !pTarget->HasAura(HIBERNATE) && CastSpell(ROOTS, pTarget)) { return; }
+            if (CYCLONE && pDist > 5 && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(HIBERNATE) && CastSpell(CYCLONE, pTarget)) { return; }
+            if (HIBERNATE && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(CYCLONE) && CastSpell(HIBERNATE, pTarget)) { return; }
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+            if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; }
+        }
+
+        if (CastSpell(FAERIE_FIRE, pTarget)) { return; }
+
+        // If at threat limit, stop
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+        {
+            //Change to tank's target
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) { m_bot->SetSelection(m_tank->getVictim()->GetGUID()); }
+            return; //use no spells and wait threat to be reduced
+        }
+        // Continue attacking if theres excess mana (for healers)
+        if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+        if (m_role != BOT_ROLE_SUPPORT && CastSpell(NATURES_SWIFTNESS, m_bot)) { } //only balance no gcd
+
+        if (m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(STARFIRE, pTarget)) { return; }
+        if (CastSpell(INSECT_SWARM, pTarget)) { return; }
+        if (CastSpell(TYPHOON, pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(HURRICANE, pTarget)) { ai->SetIgnoreUpdateTime(8); return; }
+        if (isUnderAttack(m_tank,5) && CastSpell(FORCE_OF_NATURE, m_bot)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(STARFALL, pTarget)) { return; }
+        if (CastSpell(MOONFIRE, pTarget)) { return; }
+        if (CastSpell(WRATH, pTarget)) { return; }
+        if (CastSpell(STARFIRE, pTarget)) { return; }
+    }
+
+    // If there is nothing else to do buff UP
+    if (m_role == BOT_ROLE_DPS_MELEE) //Those already healed and buffed or should never buff in combat
+    {
+        if (DoSupportRaid(GetMaster(),false,false,false)) { return; }
+        if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+    }
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+    #pragma endregion
+} //end DoNextCombatManeuver
+
+void PlayerbotDruidAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(GetMaster())) { return; }
+    if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(30, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 10 && CastSpell (INNERVATE, m_bot)) { return; } //Need mana fast
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() &&
+        (ai->GetForm() != FORM_CAT && ai->GetForm() != FORM_MOONKIN && ai->GetForm() != FORM_DIREBEAR && ai->GetForm() != FORM_BEAR)
+        && CastSpell(REGROWTH,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+
+bool PlayerbotDruidAI::BuffPlayer(Unit *target)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+
+    if(!target || target->isDead()) { return false; }
+
+    if (CanCast(THORNS,target,0,0,1) && !HasAuraName(target, THORNS)) {
+        // Decide if it is worth to change form
+        if( /*m_bot->HasAura(MOONKIN_FORM) ||*/ m_bot->HasAura(CAT_FORM) || m_bot->HasAura(BEAR_FORM))
+        {
+            if(GetAI()->GetManaPercent() >= 80 ) { ChangeForm(1); }
+            else { return false; }
+        }
+        return CastSpell(THORNS, target, false);
+    }
+    if (CanCast(MARK_OF_THE_WILD,target,0,0,1) && !HasAuraName(target, GIFT_OF_THE_WILD) && !HasAuraName(target, MARK_OF_THE_WILD)) {
+        // Decide if it is worth to change form
+        if(/*m_bot->HasAura(MOONKIN_FORM) ||*/ m_bot->HasAura(CAT_FORM) || m_bot->HasAura(BEAR_FORM))
+        {
+            if(GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+            else return false;
+        }
+        return CastSpell(MARK_OF_THE_WILD, target, false);
+    }
+    return false;
+}
+
+bool PlayerbotDruidAI::HealTarget(Unit *target, uint8 hp)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+
+    // Decide if it is worth to change form
+    if (ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        if (hp < 75 && GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+        else if (hp < 40 && GetAI()->GetManaPercent() >= 50) { ChangeForm(1); }
+        else if (hp < 25 && GetAI()->GetManaPercent() >= 30) { ChangeForm(1); }
+        else return false;
+    }
+
+    // if(m_bot->HasAura(TRAVEL_FORM)) ChangeForm(1);
+
+    if(hp < 60 && m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(HEALING_TOUCH, target)) { return true; }
+    if(hp < 90 && CastSpell(LIFEBLOOM, target)) { return true; }
+    if(hp < 80 && CastSpell(REJUVENATION, target)) { return true; }
+    if(hp < 60 && CastSpell(REGROWTH, target)) { return true; }
+    if(hp < 70 && CanCast(NOURISH,target) &&
+        (HasAuraName(target,REJUVENATION,m_bot->GetGUID()) || HasAuraName(target,LIFEBLOOM,m_bot->GetGUID()) || HasAuraName(target,REGROWTH,m_bot->GetGUID()))
+        ) { return CastSpell(NOURISH, target, false); }
+    if(hp < 50 && CanCast(SWIFTMEND,target) &&
+        (HasAuraName(target,REJUVENATION,m_bot->GetGUID()) || HasAuraName(target,REGROWTH,m_bot->GetGUID()))
+        ) { return CastSpell(SWIFTMEND, target, false); }
+    if(hp < 40 && m_bot->isInCombat() && CastSpell(NATURES_SWIFTNESS, m_bot)) { } // NO gcd
+    if(hp < 40 && CastSpell(HEALING_TOUCH, target)) { return true; }
+    return false;
+} //end HealTarget
+
+bool PlayerbotDruidAI::HealGroup(Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+
+    if (countNeedHeal < 2) { return false; }
+
+    // Decide if it is worth to change form
+    if (ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        if (hp > 70) { return false; }
+        if (!CanCast(TRANQUILITY,target,0,0,1) && !WILD_GROWTH) { return false; }
+        if (!WILD_GROWTH && hp > 35) { return false; }
+        if (hp < 65 && GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+        else if (hp < 40 && GetAI()->GetManaPercent() >= 50) { ChangeForm(1); }
+        else if (hp < 25 && GetAI()->GetManaPercent() >= 30) { ChangeForm(1); }
+        else return false;
+    }
+
+    if (hp < 36 && m_bot->isInCombat() && CanCast(TRANQUILITY,target))
+    {
+            bool sc = CastSpell(TRANQUILITY, target, false);
+            if (sc) GetAI()->SetIgnoreUpdateTime(10);
+            return sc;
+    }
+    if (hp < 75 && CastSpell(WILD_GROWTH,target)) { return true; }
+    return false;
+}
+
+bool PlayerbotDruidAI::CureTarget(Unit *target)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+    // Decide if it is worth to change form (they cange forms even if theres nothing to cure..)
+    if (ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        //if(GetAI()->GetManaPercent() >= 80 ) { ChangeForm(1); }
+        //else { return false; }
+        return false;
+    }
+    if (castDispel(CURE_POISON, target)) { return true; }
+    // if(HasAuraName(target, "Venom Spit") || HasAuraName(target, "Poison")) return CastSpell(CURE_POISON, target);
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotDruidAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+
+    if (m_bot->isInCombat())
+    {
+        if (!CanCast(REBIRTH,target)) return false;
+        Unit *m_tank = FindMainTankInRaid(m_bot);
+        if (!m_tank) m_tank = m_bot;
+        if (target->GetGUID() != m_tank->GetGUID() &&
+            (target->getClass() != (uint8) CLASS_PRIEST || target->getClass() != (uint8) CLASS_DRUID || target->getClass() != (uint8) CLASS_PALADIN) ) return false;
+        std::string msg = "Rezzing ";
+        msg += target->GetName();
+       // msg += " with ";
+       // msg += *REZZSpell->SpellName;
+        GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+        return CastSpell(REBIRTH, target);
+    }
+    else
+    {
+        if (!CanCast(REVIVE,target)) return false;
+        std::string msg = "Rezzing ";
+        msg += target->GetName();
+       // msg += " with ";
+       // msg += *REZZSpell->SpellName;
+        GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+        return CastSpell(REVIVE, target);
+    }
+    return false;
+}
+
+/*bool PlayerbotDruidAI::FindMount() {
+    if (TRAVEL_FORM) {
+        if (GetPlayerBot())    CastSpell(TRAVEL_FORM, GetPlayerBot());
+        return true;
+    } else return false;
+}
+
+bool PlayerbotDruidAI::Unmount() {
+    GetPlayerBot()->RemoveAurasDueToSpell(TRAVEL_FORM);
+    return true;
+}
+
+bool PlayerbotDruidAI::IsMounted() {
+    return GetPlayerBot()->IsMounted() || HasAuraName(GetPlayerBot(), TRAVEL_FORM);
+} */
+
+bool PlayerbotDruidAI::ChangeForm(uint32 form)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!form) return false;
+
+    if (form == 1 && ai->GetForm() == FORM_NONE) return false;
+
+    if (form != 1)
+    {
+        if (!CanCast(form,m_bot,0,0,1)) return false;
+        if (m_bot->HasAura(form)) { return false; }
+    }
+
+    if (ai->GetForm() == FORM_TREE) m_bot->RemoveAurasDueToSpell(TREE_OF_LIFE_FORM);
+    else if (ai->GetForm() == FORM_CAT) m_bot->RemoveAurasDueToSpell(CAT_FORM);
+    else if (ai->GetForm() == FORM_MOONKIN) m_bot->RemoveAurasDueToSpell(MOONKIN_FORM);
+    else if (ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR) m_bot->RemoveAurasDueToSpell(BEAR_FORM);
+    else if (ai->GetForm() == FORM_TRAVEL) m_bot->RemoveAurasDueToSpell(TRAVEL_FORM);
+    else if (ai->GetForm() == FORM_FLIGHT || ai->GetForm() == FORM_FLIGHT_EPIC)    m_bot->RemoveAurasDueToSpell(FLIGHT_FORM);
+    else if (ai->GetForm() == FORM_AQUA) m_bot->RemoveAurasDueToSpell(AQUATIC_FORM);
+
+    if (form == 1) { return true; }
+
+    return CastSpell(form,m_bot,false);
+}
+
+
diff --git a/src/server/game/AI/Bots/PlayerbotDruidAI.h b/src/server/game/AI/Bots/PlayerbotDruidAI.h
new file mode 100644
index 0000000..35f4d54
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotDruidAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERBOTDRUIDAI_H
+#define _PLAYERBOTDRUIDAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotDruidAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotDruidAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotDruidAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        bool HealGroup(Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget(Unit *target);
+
+        // find any specific mount spells, ie druids=cat, shaman=ghost wolf etc
+        /* virtual bool FindMount();
+        virtual bool Unmount();
+        virtual bool IsMounted(); */
+
+        //Change Form
+        bool ChangeForm(uint32 form);
+
+    private:
+
+        // BALANCE Attacks
+        uint32 MOONFIRE, WRATH, STARFALL, STARFIRE, TYPHOON, HURRICANE, FORCE_OF_NATURE, INSECT_SWARM, CYCLONE, ROOTS, NATURES_GRASP, HIBERNATE, FAERIE_FIRE;
+
+        // RESTORATION Spells
+        uint32 LIFEBLOOM, REJUVENATION, REGROWTH, NOURISH, SWIFTMEND, HEALING_TOUCH, NATURES_SWIFTNESS, INNERVATE, WILD_GROWTH, TRANQUILITY, REBIRTH, REVIVE, CURE_POISON, BARKSKIN;
+
+        // BEAR SPELLS
+        uint32 MAUL, BASH, LACERATE, MANGLE_BEAR, SWIPE_BEAR, DEMORALIZING_ROAR, GROWL, CHALLENGING_ROAR , ENRAGE, FERAL_CHARGE_BEAR, FRENZIED_REGENERATION;
+
+        // CAT SPELLS
+        uint32 CLAW, RAKE, SHRED, MANGLE_CAT, RIP, FEROCIOUS_BITE, SAVAGE_ROAR, MAIM, FERAL_CHARGE_CAT, COWER, TIGERS_FURY;
+
+        // FERAL General
+        uint32 BERSERK, FAERIE_FIRE_FERAL;
+
+        // BUFFS
+        uint32 MARK_OF_THE_WILD, GIFT_OF_THE_WILD, THORNS, SURVIVAL_INSTINCTS;
+
+        // FORMS
+        uint32 CAT_FORM, BEAR_FORM, MOONKIN_FORM, TREE_OF_LIFE_FORM, TRAVEL_FORM, FLIGHT_FORM, AQUATIC_FORM;
+
+        // Key TALENT SPELLS
+        uint32 TALENT_BALANCE, TALENT_RESTO, TALENT_FERAL;
+
+};
+
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotHunterAI.cpp b/src/server/game/AI/Bots/PlayerbotHunterAI.cpp
new file mode 100644
index 0000000..c625f50
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotHunterAI.cpp
@@ -0,0 +1,561 @@
+/*
+Name : PlayerbotHunterAI.cpp
+Complete: maybe around 70%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - AI always assumes pet is the tank if there are no higher hp people in group than the hunter..
+                - Possible threat build / reduce race between pet and hunter if attacking to same target.. Needs checking
+                - Possible target changing loop between pet and hunter if attacking to same target and getting aggro repeatedly.. Needs checking
+                - Disarm and Nature resist aspect, Disengage, Scorpid sting are not used right now..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotHunterAI.h"
+
+
+class PlayerbotAI;
+
+PlayerbotHunterAI::PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    m_petSummonFailed = false;
+    LoadSpells();
+}
+
+PlayerbotHunterAI::~PlayerbotHunterAI() {}
+
+void PlayerbotHunterAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    // PET CONTROL
+    PET_SUMMON = ai->getSpellIdExact("Call Pet");
+    PET_DISMISS = ai->getSpellIdExact("Dismiss Pet");
+    PET_REVIVE = ai->getSpellIdExact("Revive Pet");
+    PET_MEND = ai->getSpellIdExact("Mend Pet");
+    PET_FEED = 1539; //ai->getSpellIdExact("Feed Pet");
+    KILL_COMMAND = ai->getSpellIdExact("Kill Command");
+    INTIMIDATION = ai->getSpellIdExact("Intimidation");
+    BESTIAL_WRATH = ai->getSpellIdExact("Bestial Wrath");
+
+    // PET SPELL (master does not have these spells anymore)
+    GROWL = ai->getSpellIdExact("Growl");
+    COWER = ai->getSpellIdExact("Cower");
+    BAD_ATTITUDE = ai->getSpellIdExact("Bad Attitude");
+    SONIC_BLAST = ai->getSpellIdExact("Sonic Blast");
+    NETHER_SHOCK = ai->getSpellIdExact("Nether Shock");
+    DEMORALIZING_SCREECH = ai->getSpellIdExact("Demoralizing Screech");
+
+    // RANGED ATTACK
+    AUTO_SHOT = ai->getSpellIdExact("Auto Shot");
+    ARCANE_SHOT = ai->getSpellIdExact("Arcane Shot");
+    EXPLOSIVE_SHOT = ai->getSpellIdExact("Explosive Shot");
+    STEADY_SHOT = ai->getSpellIdExact("Steady Shot");
+    AIMED_SHOT = ai->getSpellIdExact("Aimed Shot");
+    SCATTER_SHOT = ai->getSpellIdExact("Scatter Shot");
+    KILL_SHOT = ai->getSpellIdExact("Kill Shot");
+    CHIMERA_SHOT = ai->getSpellIdExact("Chimera Shot");
+    CONCUSSIVE_SHOT = ai->getSpellIdExact("Concussive Shot");
+    DISTRACTING_SHOT = ai->getSpellIdExact("Distracting Shot");
+    SILENCING_SHOT = ai->getSpellIdExact("Silencing Shot");
+
+    // STINGS
+    SERPENT_STING = ai->getSpellIdExact("Serpent Sting");
+    SCORPID_STING = ai->getSpellIdExact("Scorpid Sting");
+    WYVERN_STING = ai->getSpellIdExact("Wyvern Sting");
+    VIPER_STING = ai->getSpellIdExact("Viper Sting");
+
+    // DEBUFF
+    HUNTERS_MARK = ai->getSpellIdExact("Hunter's Mark");
+    SCARE_BEAST = ai->getSpellIdExact("Scare Beast");
+
+    //AOE
+    VOLLEY = ai->getSpellIdExact("Volley");
+    MULTI_SHOT = ai->getSpellIdExact("Multi Shot");
+
+    //MELEE
+    RAPTOR_STRIKE = ai->getSpellIdExact("Raptor Strike");
+    WING_CLIP = ai->getSpellIdExact("Wing Clip");
+    MONGOOSE_BITE = ai->getSpellIdExact("Mongoose Bite");
+    COUNTERATTACK = ai->getSpellIdExact("Counterattack");
+
+    //TRAP
+    FREEZING_TRAP = ai->getSpellIdExact("Freezing Trap");
+    IMMOLATION_TRAP = ai->getSpellIdExact("Immolation Trap");
+    FROST_TRAP = ai->getSpellIdExact("Frost Trap");
+    EXPLOSIVE_TRAP = ai->getSpellIdExact("Explosive Trap");
+    SNAKE_TRAP = ai->getSpellIdExact("Snake Trap");
+    ARCANE_TRAP = ai->getSpellIdExact("Arcane Trap");
+    FREEZING_ARROW = ai->getSpellIdExact("Freezing Arrow");
+    BLACK_ARROW = ai->getSpellIdExact("Black Arrow");
+
+    //BUFF
+    TRUESHOT_AURA = ai->getSpellIdExact("Trueshot Aura");
+    DETERRENCE = ai->getSpellIdExact("Deterrence");
+    FEIGN_DEATH = ai->getSpellIdExact("Feign Death");
+    DISENGAGE = ai->getSpellIdExact("Disengage");
+    RAPID_FIRE = ai->getSpellIdExact("Rapid Fire");
+    READINESS = ai->getSpellIdExact("Readiness");
+    MISDIRECTION = ai->getSpellIdExact("Misdirection");
+
+    //ASPECT
+    ASPECT_OF_THE_HAWK = ai->getSpellIdExact("Aspect of the Dragonhawk");
+    ASPECT_OF_THE_MONKEY = ASPECT_OF_THE_HAWK;
+    if (!ASPECT_OF_THE_HAWK) ASPECT_OF_THE_HAWK = ai->getSpellIdExact("Aspect of the Hawk");
+    if (!ASPECT_OF_THE_MONKEY) ASPECT_OF_THE_MONKEY = ai->getSpellIdExact("Aspect of the Monkey");
+    ASPECT_OF_THE_VIPER = ai->getSpellIdExact("Aspect of the Viper");
+
+    TALENT_MM = TRUESHOT_AURA;
+    TALENT_BM = BESTIAL_WRATH;
+    TALENT_SURVIVAL = WYVERN_STING;
+
+    uint8 talentCounter = 0;
+    if (TALENT_MM) talentCounter++;
+    if (TALENT_BM) talentCounter++;
+    if (TALENT_SURVIVAL) talentCounter++;
+    if (talentCounter > 1) { TALENT_MM = 0; TALENT_BM = 0; TALENT_SURVIVAL = 0; } //Unreliable Talent detection.
+
+    #pragma endregion
+}
+
+bool PlayerbotHunterAI::HasPet(Player* bot)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM character_pet WHERE owner = '%u' AND (slot = '%u' OR slot = '%u')",bot->GetGUIDLow(),PET_SAVE_AS_CURRENT,PET_SAVE_NOT_IN_SLOT);
+
+    if(result)
+        return true; //hunter has current pet
+    else
+        return false; //hunter either has no pet or stabled
+}// end HasPet
+
+void PlayerbotHunterAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    if (m_tank->GetGUID() == m_bot->GetGUID() && pet && pet->isAlive() && pet->isInCombat()) { m_tank = pet; }
+    uint8 petThreat = 0;
+    if (pet) { GetThreatPercent(pTarget,pet); }
+
+ //   switch (ai->GetScenarioType())
+//    {
+//        case PlayerbotAI::SCENARIO_DUEL:
+ //           ai->CastSpell(RAPTOR_STRIKE);
+ //           return;
+//    }
+
+    // ------- Non Duel combat ----------
+
+
+    #pragma region Choose Target
+    // Choose Target
+    if (isUnderAttack()) // I am under attack
+    {
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+        else //Have to select nearest target
+        {
+            Unit *curAtt = GetNearestAttackerOf(m_bot);
+            if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(curAtt->GetGUID());
+                //ai->AddLootGUID(curAtt->GetGUID());
+                DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                return;
+            }
+        }
+        //my target is attacking me
+    }
+
+    #pragma endregion
+
+    #pragma region Pet Actions
+    // Pet's own Actions
+    if( pet && pet->isAlive() )
+    {
+        // Setup pet
+        if (pet->GetCharmInfo()->IsAtStay()) {pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW); }
+
+        //Heal pet
+        if ( ( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        && ( PET_MEND>0 && !pet->getDeathState() != ALIVE && pVictim != m_bot
+        && CastSpell(PET_MEND,m_bot) )) { return; }
+
+        // Set pet to attack hunter's attacker > its own attackers > hunter's target
+        if (!pet->getVictim()) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(m_bot)) { pet->AI()->AttackStart(pTarget); }  //Always help hunter if she's under attack
+        else if (pet->getVictim()->GetGUID() != pTarget->GetGUID() && !isUnderAttack(pet)) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(pet)) // Pet is under attack and hunter has no attackers
+        {
+            if ( pet->getVictim()->getVictim() && pet->getVictim()->getVictim()->GetGUID() == pet->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(pet,true);
+                if (curAtt && (!pet->getVictim() || curAtt->GetGUID() != pet->getVictim()->GetGUID()))
+                {
+                    pet->AI()->AttackStart(curAtt); //Attack nearest attacker
+                }
+            }
+            //Actions to do under attack (Always tank it, and try to kill it, until someone (!= hunter) takes aggro back)
+            //Hunter should help her pet whether main tank or not, unless she's being attacked (BEWARE Targeting Loop possibility)
+            if (pet->getVictim() && !isUnderAttack(m_bot) && pet->getVictim()->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(pet->getVictim()->GetGUID());
+                DoNextCombatManeuver(pet->getVictim()); //Restart new update to get variables fixed..
+                return;
+            }
+
+        }
+        // Pet tanking behaviour
+        if (pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot) || isUnderAttack(pet))
+        {
+            if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,true); //Autocast growl
+            if (BAD_ATTITUDE) pet->GetCharmInfo()->SetSpellAutocast(BAD_ATTITUDE,true);
+            if (COWER) pet->GetCharmInfo()->SetSpellAutocast(COWER,false);
+            if (CastSpell(INTIMIDATION,m_bot)) { return; }
+        }
+        else
+        {
+            if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,false); //Do not try to get aggro
+            if (BAD_ATTITUDE) pet->GetCharmInfo()->SetSpellAutocast(BAD_ATTITUDE,false);
+            if (COWER) pet->GetCharmInfo()->SetSpellAutocast(COWER,true); //Autocast cower
+        }
+        // NORMAL PET dps attacks
+        if (petThreat < threatThreshold || pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot))
+        {
+            if (CastSpell(KILL_COMMAND,m_bot)) { }
+            else if (CastSpell(BESTIAL_WRATH,m_bot)) { }
+        }
+        // NETHERSHOCK DEMORALIZINGSCREECH
+    }
+    #pragma endregion
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[4] = { R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    #pragma region Evasive manuevers
+    // Do evasive manuevers if under attack
+    if (isUnderAttack())
+    {
+        if (m_tank->GetGUID() == m_bot->GetGUID()) { } // i am tank and my pet is probably dead, so i have to face the attackers
+        else if (CastSpell(FEIGN_DEATH,m_bot)) { return; } //avoid attack
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+        else if (CastSpell(CONCUSSIVE_SHOT,pTarget)) { return; }
+        else if (CastSpell(WYVERN_STING,pTarget)) { return; }
+        else if (CastSpell(SCATTER_SHOT,pTarget)) { return; }
+        else if (CastSpell(FREEZING_ARROW,pTarget)) { return; }
+        else if (CastSpell(MISDIRECTION,m_tank)) { return; }
+        else if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget) ) { return; } //no gcd but is cast
+        else if (pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && CastSpell(SCARE_BEAST,pTarget)) { return; }
+        else if (pDist <= 2 && CastSpell(FREEZING_TRAP,pTarget)) { return; }
+    }
+    #pragma endregion
+
+    //Select combat mode
+    m_role = BOT_ROLE_DPS_RANGED;
+    if ((isUnderAttack()  && pDist <= ATTACK_DISTANCE) || !m_bot->GetUInt32Value(PLAYER_AMMO_ID) ) { m_role = BOT_ROLE_DPS_MELEE; }
+
+    TakePosition(pTarget);
+
+    #pragma region Buff / Protect
+    //Buff UP
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot) ) {  } //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot) ) { } //no GCD
+    if (CastSpell(TRUESHOT_AURA, m_bot)) { return; }
+    if (CastSpell(RAPID_FIRE,m_bot)) { return; }
+    if (CastSpell(HUNTERS_MARK,pTarget)) { return; }
+    if ((ai->GetHealthPercent() < 80 || ai->GetManaPercent() < 60 ) && CastSpell(READINESS,m_bot)) { } //no gcd
+
+
+    //Protect yourself if needed
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot) ) { } //no gcd
+    if (ai->GetHealthPercent() < 20 && CastSpell(DETERRENCE,m_bot)) {} //No GCD
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return;  }
+
+    //Break Spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && ( pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 20 ) && CastSpell(R_ARCANE_TORRENT, pTarget) ) { } //no gcd
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SILENCING_SHOT, pTarget) ) { return; }
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SCATTER_SHOT, pTarget) ) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(WING_CLIP,pTarget)) return;
+        if (CastSpell(CONCUSSIVE_SHOT,pTarget)) return;
+        if (CastSpell(SCATTER_SHOT, pTarget) ) { return; }
+    }
+    #pragma endregion
+
+    //Do combat
+    switch (m_role)
+    {
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            if (AUTO_SHOT) { m_bot->InterruptNonMeleeSpells( true, AUTO_SHOT ); } //Stop autoshot
+            if (CastSpell(ASPECT_OF_THE_MONKEY,m_bot)) { return; } //Get Monkey aspect
+
+            if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+
+            // Threat control
+            if (pThreat < threatThreshold || m_tank->GetGUID() == m_bot->GetGUID() || m_bot->HasAura(MISDIRECTION) ) { } //Continue attack
+            else
+            {
+                if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+                {
+                    m_bot->SetSelection(pet->getVictim()->GetGUID());
+                    return;
+                }
+                else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+                {
+                    m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                    return;
+                }
+                else if (CastSpell(FEIGN_DEATH,m_bot)) { return; }
+                else { return; } // No more threat reducing spells, just slow down
+            }
+
+            if (CastSpell(RAPTOR_STRIKE,pTarget,true,true)) {} //No gcd
+            if (CastSpell(MONGOOSE_BITE,pTarget,true,true)) { return; } // Cannot be sure if casted or not
+            else if (CastSpell(COUNTERATTACK,pTarget,true,true)) { return; } // Cannot be sure if casted or not
+            if (CastSpell(WING_CLIP,pTarget)) { return; }
+            if (isUnderAttack(m_tank,6) && CastSpell(SNAKE_TRAP,m_bot)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(EXPLOSIVE_TRAP,m_bot)) { return; }
+            if (CastSpell(IMMOLATION_TRAP,m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            if (m_pulling) {
+                if (GetAI()->CastSpell(CONCUSSIVE_SHOT,pTarget) ||
+                    GetAI()->CastSpell(AUTO_SHOT,pTarget)) {
+                    m_pulling = false;
+                    GetAI()->SetCombatOrder(ORDERS_NONE);
+                    GetAI()->Follow(*GetMaster());
+                    GetAI()->SetIgnoreUpdateTime(2);
+
+                    if(HasPet(GetPlayerBot()))
+                        m_bot->GetPet()->SetReactState(REACT_DEFENSIVE);
+                }
+                return;
+            }
+            if (AUTO_SHOT && !m_bot->FindCurrentSpellBySpellId(AUTO_SHOT)) { ai->CastSpell(AUTO_SHOT,pTarget); } //Start autoshot
+            if (!(ai->GetManaPercent() < 85 && m_bot->HasAura(ASPECT_OF_THE_VIPER)) && CastSpell(ASPECT_OF_THE_HAWK,m_bot)) { return; } //Get Hawk aspect
+            if ((ai->GetManaPercent() < 25) && CastSpell(ASPECT_OF_THE_VIPER,m_bot,true,false,true)) { return; } //Build up mana
+
+            // if i am main tank, protect master by taunt
+            if(m_tank->GetGUID() == m_bot->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt && CastSpell(DISTRACTING_SHOT, curAtt))  { return; }
+                // My target is not attacking me, taunt..
+                if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(DISTRACTING_SHOT, pTarget) )  { return; }
+            }
+            // If i am not tank, transfer threat to tank or pet..
+            else
+            {
+                if (CastSpell(MISDIRECTION,m_tank)) { return; }
+                if (pet && pet->isAlive() && CastSpell(MISDIRECTION,pet)) { return; }
+
+                // Threat control
+                if (pThreat < threatThreshold || m_bot->HasAura(MISDIRECTION) ) { } //Continue attack
+                else
+                {
+                    if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+                    {
+                        m_bot->SetSelection(pet->getVictim()->GetGUID());
+                        return;
+                    }
+                    else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+                    {
+                        m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                        return;
+                    }
+                    else if (CastSpell(FEIGN_DEATH,m_bot)) { return; }
+                    else { return; } // No more threat reducing spells, just slow down
+                }
+            }
+
+            // DO dps
+            if (ai->GetHealthPercent(*pTarget) < 20 && CastSpell(KILL_SHOT,pTarget)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(MULTI_SHOT,pTarget)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(VOLLEY,pTarget)) { GetAI()->SetIgnoreUpdateTime(7); return; }
+            if (CanCast(CHIMERA_SHOT,pTarget) &&
+                (pTarget->HasAura(VIPER_STING,m_bot->GetGUID()) || pTarget->HasAura(SERPENT_STING,m_bot->GetGUID()) )
+                && CastSpell(CHIMERA_SHOT,pTarget,false) ) { return; }
+            if (ai->GetManaPercent() < 60 && ai->GetManaPercent(*pTarget) > 4 && CastSpell(VIPER_STING,pTarget)) { return; }
+            if (!pTarget->HasAura(VIPER_STING,m_bot->GetGUID()) && CastSpell(SERPENT_STING,pTarget)) { return; }
+            if (CastSpell(ARCANE_SHOT,pTarget)) { return; }
+            if (CastSpell(BLACK_ARROW,pTarget)) { return; }
+            if (CastSpell(EXPLOSIVE_SHOT,pTarget)) { return; }
+            if (CastSpell(STEADY_SHOT,pTarget)) { return; }
+            break;
+        #pragma endregion
+    }
+
+    /*// drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }*/
+} // end DoNextCombatManeuver
+
+void PlayerbotHunterAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    // buff group
+    if (CastSpell(TRUESHOT_AURA, m_bot)) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 20 || ai->GetHealthPercent() < 30) { ai->Feast(); }
+
+    #pragma region Check Pet
+    // check for pet
+    if( PET_SUMMON>0 && !m_petSummonFailed && HasPet(m_bot) )
+    {
+        // we can summon pet, and no critical summon errors before
+        Pet *pet = m_bot->GetPet();
+        if( !pet )
+        {
+            // summon pet
+            if( PET_SUMMON>0 && ai->CastSpell(PET_SUMMON,m_bot) )
+                ai->TellMaster( "summoning pet." );
+            else
+            {
+                m_petSummonFailed = true;
+                ai->TellMaster( "summon pet failed!" );
+            }
+        }
+        else if( pet->getDeathState() != ALIVE )
+        {
+            // revive pet
+            if( PET_REVIVE>0 && ai->GetManaPercent()>=80 && ai->CastSpell(PET_REVIVE,m_bot) )
+                ai->TellMaster( "reviving pet." );
+        }
+        else if( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        {
+            // heal pet when health lower 50%
+            if( PET_MEND>0 && !pet->getDeathState() != ALIVE && !pet->HasAura(PET_MEND,0) && ai->GetManaPercent()>=13 && ai->CastSpell(PET_MEND,m_bot) )
+                ai->TellMaster( "healing pet." );
+        }
+        else if(pet->GetHappinessState() != HAPPY) // if pet is hungry
+        {
+            Unit *caster = (Unit*)m_bot;
+            // list out items in main backpack
+            for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+            {
+                Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                if (pItem)
+                {
+                    const ItemPrototype* const pItemProto = pItem->GetProto();
+                    if (!pItemProto )
+                        continue;
+                    if(pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                    {
+                        //sLog.outDebug("Food for pet: %s",pItemProto->Name1);
+                        caster->CastSpell(caster,51284,true); // pet feed visual
+                        uint32 count = 1; // number of items used
+                        int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                        m_bot->DestroyItemCount(pItem,count,true); // remove item from inventory
+                        m_bot->CastCustomSpell(m_bot,PET_FEED,&benefit,NULL,NULL,true); // feed pet
+                        ai->TellMaster( "feeding pet." );
+                        ai->SetIgnoreUpdateTime(10);
+                        return;
+                    }
+                }
+            }
+            // list out items in other removable backpacks
+            for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+            {
+                const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                if (pBag)
+                {
+                    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                    {
+                        Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                        if (pItem)
+                        {
+                            const ItemPrototype* const pItemProto = pItem->GetProto();
+                            if (!pItemProto )
+                                continue;
+                            if(pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                            {
+                                //sLog.outDebug("Food for pet: %s",pItemProto->Name1);
+                                caster->CastSpell(caster,51284,true); // pet feed visual
+                                uint32 count = 1; // number of items used
+                                int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                                m_bot->DestroyItemCount(pItem,count,true); // remove item from inventory
+                                m_bot->CastCustomSpell(m_bot,PET_FEED,&benefit,NULL,NULL,true); // feed pet
+                                ai->TellMaster( "feeding pet." );
+                                ai->SetIgnoreUpdateTime(10);
+                                return;
+                            }
+                        }
+                    }
+                }
+            }
+            if( pet->HasAura(PET_MEND, 0) && !pet->HasAura(PET_FEED, 0))
+
+                ai->TellMaster( "..no pet food!" );
+                ai->SetIgnoreUpdateTime(7);
+        }
+    #pragma endregion
+    }
+} // end DoNonCombatActions
+
+void PlayerbotHunterAI::Pull()
+{
+    if (!AUTO_SHOT) return;
+
+    // check ammo
+    uint32 ammo_id = GetPlayerBot()->GetUInt32Value(PLAYER_AMMO_ID);
+    if (!ammo_id) {
+        GetPlayerBot()->Say("I'm out of ammo.", LANG_UNIVERSAL);
+        return;
+    }
+
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+
+    if(GetPlayerBot()->GetPet())
+        GetPlayerBot()->GetPet()->SetReactState(REACT_PASSIVE);
+}
diff --git a/src/server/game/AI/Bots/PlayerbotHunterAI.h b/src/server/game/AI/Bots/PlayerbotHunterAI.h
new file mode 100644
index 0000000..4892624
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotHunterAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERHUNTERAI_H
+#define _PLAYERHUNTERAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotHunterAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotHunterAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotHunterAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        bool HasPet(Player* bot);
+
+        virtual void Pull();
+
+        //buff a specific player, usually a real PC who is not in group
+        //void BuffPlayer(Player *target);
+
+    private:
+        //Hunter
+        bool m_petSummonFailed;
+        bool m_petFeedPetFailed;
+
+        // PET CONTROL
+        uint32 PET_SUMMON, PET_DISMISS, PET_REVIVE, PET_MEND, PET_FEED, KILL_COMMAND, INTIMIDATION, BESTIAL_WRATH;
+
+        // PET SPELL
+        uint32 GROWL, COWER, BAD_ATTITUDE, SONIC_BLAST, NETHER_SHOCK, DEMORALIZING_SCREECH;
+
+        // RANGED ATTACK
+        uint32 AUTO_SHOT, ARCANE_SHOT, EXPLOSIVE_SHOT, STEADY_SHOT, AIMED_SHOT, SCATTER_SHOT, KILL_SHOT, CHIMERA_SHOT, CONCUSSIVE_SHOT, DISTRACTING_SHOT, SILENCING_SHOT;
+
+        // STINGS
+        uint32 SERPENT_STING, SCORPID_STING, WYVERN_STING, VIPER_STING;
+
+        // DEBUFF
+        uint32 HUNTERS_MARK, SCARE_BEAST;
+
+        //AOE
+        uint32 VOLLEY, MULTI_SHOT;
+
+        //MELEE
+        uint32 RAPTOR_STRIKE, WING_CLIP, MONGOOSE_BITE, COUNTERATTACK;
+
+        //TRAP
+        uint32 FREEZING_TRAP, IMMOLATION_TRAP, FROST_TRAP, EXPLOSIVE_TRAP, SNAKE_TRAP, ARCANE_TRAP, FREEZING_ARROW, BLACK_ARROW;
+
+        //BUFF
+        uint32 TRUESHOT_AURA, DETERRENCE, FEIGN_DEATH, DISENGAGE, RAPID_FIRE, READINESS, MISDIRECTION;
+
+        //ASPECT
+        uint32 ASPECT_OF_THE_HAWK, ASPECT_OF_THE_MONKEY, ASPECT_OF_THE_VIPER;
+
+        uint32 TALENT_MM, TALENT_BM, TALENT_SURVIVAL;
+
+};
+
+#endif
+
+
diff --git a/src/server/game/AI/Bots/PlayerbotMageAI.cpp b/src/server/game/AI/Bots/PlayerbotMageAI.cpp
new file mode 100644
index 0000000..1e33e03
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotMageAI.cpp
@@ -0,0 +1,384 @@
+#include "PlayerbotMageAI.h"
+class PlayerbotAI;
+PlayerbotMageAI::PlayerbotMageAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai){\
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotMageAI::~PlayerbotMageAI(){}
+
+void PlayerbotMageAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //arcane
+    ARCANE_MISSILES = ai->getSpellIdExact("Arcane Missiles");
+    ARCANE_EXPLOSION = ai->getSpellIdExact("Arcane Explosion");
+    ARCANE_BLAST = ai->getSpellIdExact("Arcane Blast");
+    ARCANE_BARRAGE = ai->getSpellIdExact("Arcane Barrage");
+
+
+    //fire
+    FIREBALL = ai->getSpellIdExact("Fireball");
+    FROSTFIRE_BOLT = ai->getSpellIdExact("Frostfire Bolt");
+    FIRE_BLAST = ai->getSpellIdExact("Fire Blast");
+    FLAMESTRIKE = ai->getSpellIdExact("Flamestrike");
+    BLAST_WAVE = ai->getSpellIdExact("Blastwave");
+    SCORCH = ai->getSpellIdExact("Scorch");
+    PYROBLAST = ai->getSpellIdExact("Pyroblast");
+    LIVING_BOMB = ai->getSpellIdExact("Living Bomb");
+
+
+    //cold
+    FROSTBOLT = ai->getSpellIdExact("Frostbolt");
+    FROST_NOVA = ai->getSpellIdExact("Frost Nova");
+    ICE_LANCE = ai->getSpellIdExact("Ice Lance");
+    BLIZZARD = ai->getSpellIdExact("Blizzard");
+    CONE_OF_COLD = ai->getSpellIdExact("Cone of Cold");
+
+    WATER_ELEMENTAL = ai->getSpellIdExact("Summon Water Elemental");
+
+
+    // buffs
+    FROST_ARMOR = ai->getSpellIdExact("Ice Armor");
+    if (!FROST_ARMOR) FROST_ARMOR = ai->getSpellIdExact("Frost Armor");
+    MAGE_ARMOR = ai->getSpellIdExact("Mage Armor");
+    MOLTEN_ARMOR = ai->getSpellIdExact("Molten Armor");
+    FIRE_WARD = ai->getSpellIdExact("Fire Ward");
+    FROST_WARD = ai->getSpellIdExact("Frost Ward");
+    MANA_SHIELD = ai->getSpellIdExact("Mana Shield");
+    ICE_BARRIER = ai->getSpellIdExact("Ice Barrier");
+    POM = ai->getSpellIdExact("Presence of Mind");
+    FOCUS_MAGIC = ai->getSpellIdExact("Focus Magic");
+    ARCANE_POWER = ai->getSpellIdExact("Arance Power");
+    COMBUSTION = ai->getSpellIdExact("Combustion");
+    ICY_VEINS = ai->getSpellIdExact("Icy Veins");
+
+    ARCANE_INTELLECT = ai->getSpellIdExact("Arcane Intellect");
+    ARCANE_BRILLIANCE = ai->getSpellIdExact("Arcane Brilliance");
+    DALARAN_INTELLECT = ai->getSpellIdExact("Dalaran Intellect");
+    DALARAN_BRILLIANCE = ai->getSpellIdExact("Dalaran Brilliance");
+    DAMPEN_MAGIC = ai->getSpellIdExact("Dampen Magic");
+    AMPLIFY_MAGIC = ai->getSpellIdExact("Amplify Magic");
+
+
+    //CC
+    POLYMORPH = ai->getSpellIdExact("Polymorph");
+    DRAGONS_BREATH = ai->getSpellIdExact("Dragon's Breath");
+    DEEP_FREEZE = ai->getSpellIdExact("Deep Freeze");
+
+
+    //other
+    CONJURE_REFRESHMENT = ai->getSpellIdExact("Conjure Refreshment");
+    CONJURE_WATER = ai->getSpellIdExact("Conjure Water");
+    CONJURE_FOOD = ai->getSpellIdExact("Conjure Food");
+    CONJURE_MANA_GEM = ai->getSpellIdExact("Conjure Mana Gem");
+    MIRROR_IMAGE = ai->getSpellIdExact("Mirror Image");
+    BLINK = ai->getSpellIdExact("Blink");
+    ICE_BLOCK = ai->getSpellIdExact("Ice Block");
+    INVISIBILITY = ai->getSpellIdExact("Invisibility");
+    EVOCATION = ai->getSpellIdExact("Evocation");
+    REMOVE_CURSE = ai->getSpellIdExact("Remove Curse");
+    COUNTER_SPELL = ai->getSpellIdExact("Counterspell");
+    SLOW = ai->getSpellIdExact("Slow");
+
+    //Special
+    P_BRAIN_FREEZE = 57761; //Brain Freeze proc
+    P_FIRESTARTER = 54741; //Firestarter proc
+    P_HOT_STREAK = 48108; //Hot Sreak proc
+    P_ARCANE_BLAST = 36032; //Arcane blast proc
+	P_MISSILE_BARRAGE = 54490; //Missle Barrage proc
+	P_FINGERS_OF_FROST = 44545; //Fingers of Frost proc
+	IMP_SCORCH = 12873; //IMP SCORCH
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_ARCANE = ARCANE_BARRAGE;
+    TALENT_FIRE = COMBUSTION;
+    TALENT_FROST = ICE_BARRIER;
+
+    uint8 talentCounter = 0;
+    if (TALENT_ARCANE) talentCounter++;
+    if (TALENT_FIRE) talentCounter++;
+    if (TALENT_FROST) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ARCANE = 0; TALENT_FIRE = 0; TALENT_FROST = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotMageAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents (MAGE is always ranged dps)
+    m_role = BOT_ROLE_DPS_RANGED;
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (isUnderAttack())
+    {
+        // Keep hitting but reduce threat
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    if (DoSupportRaid(m_bot,30,0,0,0,1,1)) { return; }
+
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        //if (CastSpell(INVISIBILITY, m_bot)) { return; }
+        if (ai->GetHealthPercent(*pTarget) > 50 && CastSpell(POLYMORPH)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (isUnderAttack() && pDist > 5 && CastSpell(FROST_NOVA, pTarget)) { return; }
+    if (DEEP_FREEZE && pTarget->isFrozen() && CastSpell(DEEP_FREEZE,pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(DRAGONS_BREATH, pTarget)) { return; }
+    if ((isUnderAttack() || ai->GetHealthPercent() < 75 && !HasAuraName(m_bot, MANA_SHIELD))  && ai->GetManaPercent() > 40 && CastSpell(MANA_SHIELD,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    if ((ai->GetHealthPercent() < 65 || ai->GetManaPercent() < 5) && CastSpell(ICE_BLOCK,m_bot)) { return; }
+    if (isUnderAttack() && CastSpell(ICE_BARRIER, pTarget)) { return; }
+    if (ai->GetManaPercent() < 30 && CastSpell (EVOCATION, m_bot)) { return; }
+
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pThreat < threatThreshold && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(COUNTER_SPELL, pTarget)) { return; } //High threat
+	if (!m_bot->HasAura(MOLTEN_ARMOR) && CastSpell(MOLTEN_ARMOR,m_bot)) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) > 96) { return; } // dont dps too early
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(FROST_NOVA,pTarget)) return;
+        if (CastSpell(FROSTBOLT,pTarget)) return;
+    }
+
+    // If at threat limit, try to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(INVISIBILITY,m_bot)) { return; } //Lets see if we can manage
+            else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+
+    // buff up
+    if (CastSpell(ICY_VEINS,m_bot)) {} //nogcd
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+    if (CastSpell(POM,m_bot)) {} //nogcd
+
+	if (TALENT_ARCANE)
+	{
+		if (CastSpell(ARCANE_POWER,m_bot)) {} //nogcd
+		if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+		//AOE
+		if (isUnderAttack(m_tank,5))
+		{
+			if (CastSpell(BLIZZARD,pTarget)) { return; }
+		}
+		//DPS
+		if (ARCANE_BLAST)
+        {
+            Aura *abaura = m_bot->GetAura(P_ARCANE_BLAST);
+            if (abaura && abaura->GetStackAmount() >= 3)
+			{
+				if (m_bot->HasAura(P_MISSILE_BARRAGE) && CastSpell(ARCANE_MISSILES,pTarget)) { return; }
+				else if (CastSpell(ARCANE_BARRAGE,pTarget)) { return; }
+			}
+        }
+        if (CastSpell(ARCANE_BARRAGE,pTarget) ) { return; }
+
+	}
+	if (TALENT_FIRE)
+	{
+		if (CastSpell(COMBUSTION,m_bot)) { } //nogcd
+		if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+
+		//AOE
+		if (isUnderAttack(m_tank,5))
+		{
+			if (CastSpell(FLAMESTRIKE,pTarget)) { return; }
+			if (CastSpell(BLAST_WAVE,pTarget)) { return; }
+			if (CastSpell(LIVING_BOMB,pTarget)) { return; }
+			if (CastSpell(DRAGONS_BREATH,pTarget)) { return; }
+		}
+
+		//DPS
+		if (m_bot->HasAura(P_HOT_STREAK) && CastSpell(PYROBLAST,pTarget)) { return; }
+		if (!pTarget->HasAura(LIVING_BOMB,m_bot->GetGUID()) && CastSpell(LIVING_BOMB,pTarget)) { return; }
+		//if (!pTarget->HasAura(IMP_SCORCH) && CastSpell(SCORCH,pTarget)) { return; }
+		if (CastSpell(FIREBALL,pTarget)) { return; }
+	}
+	if (TALENT_FROST)
+	{
+		if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+        if (CastSpell(WATER_ELEMENTAL,m_bot)) { return; }
+
+        uint64 pet_guid = m_bot->GetPetGUID();
+        if (pet_guid>0){
+            Pet* pet = ObjectAccessor::GetPet(*m_bot, pet_guid);
+            Unit *unit = ObjectAccessor::GetUnit(*m_bot, pet_guid);
+            if (unit!=NULL){
+				if (!unit->isInCombat()) {
+                    m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, COMMAND_ATTACK, ACT_COMMAND, pTarget->GetGUID());
+				}
+            }
+        }
+
+        //if (CastSpell(33395, pTarget)) // pet freeze spell
+        //    sLog.outError ("successfully casted freeze");
+
+        //AOE
+        if (isUnderAttack(m_tank,5))
+        {
+            if (CastSpell(BLIZZARD,pTarget)) { return; }
+        }
+
+        //DPS
+        if (m_bot->HasAura(P_FINGERS_OF_FROST) && CastSpell(DEEP_FREEZE,pTarget)) { return; }
+        if (m_bot->HasAura(P_BRAIN_FREEZE) && CastSpell(FROSTFIRE_BOLT,pTarget)) { return; }
+        if (CastSpell(FROSTBOLT,pTarget,true,true)) { return; }
+
+    }
+
+    // Defaults especialy for lower levels
+    if (m_bot->HasAura(P_BRAIN_FREEZE) && CastSpell(FIREBALL,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(P_FIRESTARTER) && CastSpell(FLAMESTRIKE,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(P_HOT_STREAK) && CastSpell(PYROBLAST,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(POM) && (CastSpell(PYROBLAST,pTarget,1,1) || CastSpell(FIREBALL,pTarget,1,1) || CastSpell(FROSTBOLT,pTarget,1,1))) { return; }
+        if (pTarget->isFrozen() && CastSpell(ICE_LANCE,pTarget)) { return; }
+        if (m_bot->isMoving() && (CastSpell(FIRE_BLAST,pTarget,1,1) || CastSpell(ARCANE_BARRAGE,pTarget) || CastSpell(ICE_LANCE,pTarget))) { return; }
+        if (CastSpell(FIREBALL,pTarget)) { return; }
+        if (CastSpell(FROSTBOLT,pTarget)) { return; }
+        if (CastSpell(ARCANE_MISSILES,pTarget)) { return; }
+
+    // drink potion
+    if(ai->GetManaPercent() < 5 )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+    // if we get down here, it means we are out of mana, so use wand
+    CastSpell(SHOOT, pTarget);
+
+} //end DoNextCombatManeuver
+void PlayerbotMageAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    // make sure pet stays by your side
+    uint64 pet_guid = m_bot->GetPetGUID();
+    if (pet_guid>0){
+        Pet* pet = ObjectAccessor::GetPet(*m_bot, pet_guid);
+        Unit *unit = ObjectAccessor::GetUnit(*m_bot, pet_guid);
+        if (unit!=NULL){
+            m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, COMMAND_FOLLOW, ACT_COMMAND, 0);
+            m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, REACT_DEFENSIVE, ACT_REACTION, 0);
+        }
+    }
+
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot,30,0,0,0,1,1)) { return; }
+
+    //Own Buffs
+    if (MOLTEN_ARMOR) { if ( CastSpell(MOLTEN_ARMOR,m_bot)) { return; } }
+    else if (CastSpell(MAGE_ARMOR,m_bot)) { return; }
+    if (CastSpell(COMBUSTION,m_bot)) { } //nogcd
+    if (!HasAuraName(m_bot, MANA_SHIELD)) CastSpell (MANA_SHIELD);
+
+    //conjure food & water
+    Item *pItem = ai->FindDrink();
+	if(pItem == NULL && ai->GetManaPercent() >= 48)
+    {
+        if (CastSpell(CONJURE_REFRESHMENT, m_bot)) { return; }
+        if (CastSpell(CONJURE_WATER, m_bot)) { return; }
+        return;
+    }
+    pItem = ai->FindFood();
+    if(pItem == NULL && ai->GetManaPercent() >= 48)
+    {
+        if (CastSpell(CONJURE_REFRESHMENT, m_bot)) { return; }
+        if (CastSpell(CONJURE_FOOD, m_bot)) { return; }
+        return;
+    }
+    //Conjure mana gem??
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 && CastSpell (EVOCATION, m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 || ai->GetHealthPercent() < 50) { ai->Feast(); }
+} //end DoNonCombatActions
+
+
+bool PlayerbotMageAI::BuffPlayer(Unit *target)
+{
+    if (!target || target->isDead()) return false;
+
+    if (target->getClass() == CLASS_WARRIOR || target->getClass() == CLASS_DEATH_KNIGHT || target->getClass() == CLASS_ROGUE) return false;
+
+    if (!HasAuraName(target, ARCANE_INTELLECT) && !HasAuraName(target, ARCANE_BRILLIANCE) && !HasAuraName(target, DALARAN_INTELLECT) && !HasAuraName(target, DALARAN_BRILLIANCE))
+    {
+        if (CastSpell(ARCANE_BRILLIANCE, target)) return true;
+        else if (CastSpell (ARCANE_INTELLECT, target)) return true;
+    }
+    return false;
+}
+bool PlayerbotMageAI::CureTarget(Unit *target)
+{
+	//Cures the target
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(DISPEL_CURSE, target)) return true;
+    return false;
+}
diff --git a/src/server/game/AI/Bots/PlayerbotMageAI.h b/src/server/game/AI/Bots/PlayerbotMageAI.h
new file mode 100644
index 0000000..307e519
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotMageAI.h
@@ -0,0 +1,69 @@
+#ifndef _PLAYERBOTMAGEAI_H
+#define _PLAYERBOTMAGEAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_SCORCH,
+    SPELL_POM,
+    SPELL_ARCANE_POWER,
+    SPELL_FIREBALL,
+    SPELL_MISSILES,
+    SPELL_FROSTBOLT
+};
+
+//class Player;
+
+class PlayerbotMageAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotMageAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotMageAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        typedef std::set<Unit *> AttackerSet;
+    private:
+        //arcane
+        uint32 ARCANE_MISSILES, ARCANE_EXPLOSION, ARCANE_BLAST, ARCANE_BARRAGE;
+
+        //fire
+        uint32 FIREBALL, FROSTFIRE_BOLT, FIRE_BLAST, FLAMESTRIKE, BLAST_WAVE, SCORCH, PYROBLAST, LIVING_BOMB;
+
+        //cold
+        uint32 FROSTBOLT, FROST_NOVA, ICE_LANCE, BLIZZARD, CONE_OF_COLD, WATER_ELEMENTAL;
+
+        // buffs
+        uint32 FROST_ARMOR, ICE_ARMOR, MAGE_ARMOR, MOLTEN_ARMOR, FIRE_WARD, FROST_WARD, MANA_SHIELD, ICE_BARRIER, POM, FOCUS_MAGIC, ARCANE_POWER, COMBUSTION, ICY_VEINS,
+            ARCANE_INTELLECT, ARCANE_BRILLIANCE, DALARAN_INTELLECT, DALARAN_BRILLIANCE, DAMPEN_MAGIC, AMPLIFY_MAGIC;
+
+        //CC
+        uint32 POLYMORPH, DRAGONS_BREATH, DEEP_FREEZE;
+
+        //other
+        uint32 CONJURE_REFRESHMENT, CONJURE_WATER, CONJURE_FOOD, CONJURE_MANA_GEM, MIRROR_IMAGE, BLINK, ICE_BLOCK, INVISIBILITY, EVOCATION, REMOVE_CURSE, COUNTER_SPELL, SLOW, SHOOT;
+
+        //special
+        uint32 P_BRAIN_FREEZE, P_FIRESTARTER, P_HOT_STREAK, P_ARCANE_BLAST, P_MISSILE_BARRAGE, P_FINGERS_OF_FROST, IMP_SCORCH;
+
+
+        uint32 TALENT_ARCANE, TALENT_FIRE, TALENT_FROST;
+
+};
+
+
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotPaladinAI.cpp b/src/server/game/AI/Bots/PlayerbotPaladinAI.cpp
new file mode 100644
index 0000000..c20e832
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotPaladinAI.cpp
@@ -0,0 +1,536 @@
+#include "PlayerbotPaladinAI.h"
+
+class PlayerbotAI;
+PlayerbotPaladinAI::PlayerbotPaladinAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotPaladinAI::~PlayerbotPaladinAI(){}
+
+void PlayerbotPaladinAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //heals
+    FLASH_OF_LIGHT = ai->getSpellIdExact("Flash of Light");
+    HOLY_LIGHT = ai->getSpellIdExact("Holy Light");
+    HOLY_SHOCK = ai->getSpellIdExact("Holy Shock");
+    CLEANSE = ai->getSpellIdExact("Cleanse");
+    if (!CLEANSE) CLEANSE = ai->getSpellIdExact("Purify");
+    LOH = ai->getSpellIdExact("Lay on Hands");
+    SACRED_SHIELD = ai->getSpellIdExact("Sacred Shield");
+    BEACON_OF_LIGHT = ai->getSpellIdExact("Beacon of Light");
+    DIVINE_FAVOR = ai->getSpellIdExact("Divine Favor");
+    REDEMPTION = ai->getSpellIdExact("Redemption");
+
+    //Damages
+    JOL = ai->getSpellIdExact("Judgement of Light");
+    JOW = ai->getSpellIdExact("Judgement of Wisdom");
+	JOJ = ai->getSpellIdExact("Judgement of Justice");
+    HAMMER_OF_WRATH = ai->getSpellIdExact("Hammer of Wrath");
+    EXORCISM = ai->getSpellIdExact("Exorcism");
+    HOLY_WRATH = ai->getSpellIdExact("Holy Wrath");
+    CONSECRATION = ai->getSpellIdExact("Consecration");
+    AVENGERS_SHIELD = ai->getSpellIdExact("Avenger's Shield");
+    SHIELD_OF_RIGHTEOUSNESS = ai->getSpellIdExact("Shield of Righteousness");
+    HOTR = ai->getSpellIdExact("Hammer of the Righteous");
+    CRUSADER_STRIKE = ai->getSpellIdExact("Crusader Strike");
+    DIVINE_STORM = ai->getSpellIdExact("Divine Storm");
+
+    //CC
+    HAMMER_OF_JUSTICE = ai->getSpellIdExact("Hammer of Justice");
+    REPENTANCE = ai->getSpellIdExact("Repentance");
+
+    //Self buffs
+    SOL = ai->getSpellIdExact("Seal of Light");
+    SOW = ai->getSpellIdExact("Seal of Wisdom");
+    SOR = ai->getSpellIdExact("Seal of Righteousness");
+    SOC = ai->getSpellIdExact("Seal of Command");
+	SOV = ai->getSpellIdExact("Seal of Vengeance");
+	if (!SOV) SOV = ai->getSpellIdExact("Seal of Corruption");
+    DIVINE_PLEA = ai->getSpellIdExact("Divine Plea");
+    HOLY_SHIELD = ai->getSpellIdExact("Holy Shield");
+    RIGHTEOUS_FURY = ai->getSpellIdExact("Righteous Fury");
+    DIVINE_SHIELD = ai->getSpellIdExact("Divine Shield");
+    if (!DIVINE_SHIELD) DIVINE_SHIELD = ai->getSpellIdExact("Divine Protection");
+    AVENGING_WRATH = ai->getSpellIdExact("Avenging Wrath");
+
+    //AURAS
+    DEVOTION_AURA = ai->getSpellIdExact("Devotion Aura");
+    RETRIBUTION_AURA = ai->getSpellIdExact("Retribution Aura");
+    CONCENTRATION_AURA = ai->getSpellIdExact("Concentration Aura");
+    FIRE_AURA = ai->getSpellIdExact("Fire Resistance Aura");
+    FROST_AURA = ai->getSpellIdExact("Frost Resistance Aura");
+    SHADOW_AURA = ai->getSpellIdExact("Shadow Resistance Aura");
+    CRUSADER_AURA = ai->getSpellIdExact("Crusader Aura");
+
+    //Blessings
+    BOW = ai->getSpellIdExact("Blessing of Wisdom");
+    BOM = ai->getSpellIdExact("Blessing of Might");
+    BOS = ai->getSpellIdExact("Blessing of Sanctuary");
+    BOK = ai->getSpellIdExact("Blessing of Kings");
+    GBOW = ai->getSpellIdExact("Greater Blessing of Wisdom");
+    GBOM = ai->getSpellIdExact("Greater Blessing of Might");
+    GBOS = ai->getSpellIdExact("Greater Blessing of Sanctuary");
+    GBOK = ai->getSpellIdExact("Greater Blessing of Kings");
+
+    //Hands
+    HOF = ai->getSpellIdExact("Hand of Freedom");
+    HOR = ai->getSpellIdExact("Hand of Reckoning");
+    HOS = ai->getSpellIdExact("Hand of Salvation");
+    HOP = ai->getSpellIdExact("Hand of Protection");
+    DIVINE_SACRIFICE = ai->getSpellIdExact("Divine Sacrifice");
+
+    //Taunt
+    RIGHTEOUS_DEFENSE = ai->getSpellIdExact("Righteous Defense");
+
+    FORBEARANCE = 25771;
+	AOW = 53488;
+
+    TALENT_RETRI = CRUSADER_STRIKE;
+    TALENT_PROT = HOLY_SHIELD;
+    TALENT_HOLY = HOLY_SHOCK;
+
+    uint8 talentCounter = 0;
+    if (TALENT_RETRI) talentCounter++;
+    if (TALENT_PROT) talentCounter++;
+    if (TALENT_HOLY) talentCounter++;
+    //if (talentCounter > 1) { TALENT_RETRI = 0; TALENT_PROT = 0; TALENT_HOLY = 0; } //Unreliable Talent detection.
+
+    #pragma endregion
+}
+
+void PlayerbotPaladinAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+
+    // Fill mana if needed
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && ai->GetManaPercent() < 20 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (ai->GetManaPercent() < 30 && CastSpell (DIVINE_PLEA, m_bot)) { return; }
+
+    // If hp is too low divine shield
+    if (ai->GetHealthPercent() < 20 && (!m_bot->HasAura(DIVINE_SHIELD) || !m_bot->HasAura(HOP) || !m_bot->HasAura(SACRED_SHIELD)))
+    {
+        if (!m_bot->HasAura(FORBEARANCE))
+        {
+            if (CastSpell(DIVINE_SHIELD,m_bot)) { return; }
+            if (CastSpell(HOP,m_bot)) { return; }
+        }
+        else if (CastSpell(SACRED_SHIELD,m_bot)) { return; }
+    }
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && !TALENT_PROT && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(HOS,m_bot,true,true)) { }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        if (TALENT_PROT) { m_role=BOT_ROLE_TANK; } //Just Keep Tanking
+        else
+        {
+            if (TALENT_RETRI) {
+                if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else { m_role = BOT_ROLE_TANK; } //have no shield but can tank if you think so
+            }
+            else if (TALENT_HOLY) //I am both healer and tank?? Hmm
+            {
+                if ((ai->GetHealthPercent() <= 70 || masterHP <70 ) && (ai->GetManaPercent() >= 50))m_role = BOT_ROLE_SUPPORT;
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else m_role = BOT_ROLE_TANK;
+            }
+            else { m_role = BOT_ROLE_TANK; } //Unknown build or low level
+        }
+    }
+    else if (TALENT_RETRI) {
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) {m_role = BOT_ROLE_SUPPORT;}
+        else { m_role = BOT_ROLE_DPS_MELEE; }
+    }
+    else if (TALENT_PROT) {
+        if ((ai->GetHealthPercent() <= 30 || masterHP <40 ) && (ai->GetManaPercent() >= 20)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 40) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_OFFTANK; }
+    }
+    else if (TALENT_HOLY) { m_role = BOT_ROLE_SUPPORT; }
+    else { m_role = BOT_ROLE_DPS_MELEE; } //Unknown build or low level.. Mainly attack
+
+	//takepos
+    if (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) TakePosition(pTarget,BOT_ROLE_DPS_MELEE,0.5f);
+    else TakePosition(pTarget,m_role);
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+
+            ChangeAura(CONCENTRATION_AURA);
+            if (!TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID()) m_bot->RemoveAurasDueToSpell(RIGHTEOUS_FURY);
+            // Choose Seal
+            if (SOW && ai->GetManaPercent() <= 30) {    if (CastSpell(SOW,m_bot)) { return; } }
+            else if (m_bot->HasAura(SOW) && ai->GetManaPercent() < 85) { } // Paladin was striving for mana, keep until he got most of his mana back
+            else if(SOL && ai->GetHealthPercent() < 40) { if(CastSpell(SOL,m_bot)) { return; } }
+            else if(CastSpell(SOR, m_bot)) { return; }
+
+            if (!m_bot->HasAura(FORBEARANCE) && CastSpell(AVENGING_WRATH,m_bot)) { } // no gcd
+
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            if (ai->GetManaPercent() <= 80 && CastSpell(JOW,pTarget,true,true)) { return; }
+
+            // Use Spells only if mana is sufficient..
+            if(ai->GetManaPercent() < offensiveSpellThreshold ) return;
+
+        break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_TANK:
+        case BOT_ROLE_OFFTANK:
+
+            ChangeAura(DEVOTION_AURA);
+            if (CastSpell(RIGHTEOUS_FURY,m_bot)) { return; }
+            // Choose Seal
+            if (SOW && ai->GetManaPercent() <= 30) { if (CastSpell(SOW,m_bot)) { return; } }
+            else if (m_bot->HasAura(SOW) && ai->GetManaPercent() < 85) { } // Paladin was striving for mana, keep until he got most of his mana back
+            else if (SOL && ai->GetHealthPercent() < 40) { if (CastSpell(SOL,m_bot)) { return; } }
+            else if (CastSpell(SOR,m_bot)) { return; }
+
+            // We are tank/offtank threat is not an issiue;
+            // Use taunts only if helping target is not main tank..
+            // Taunt if needed (Only for master)
+            if(GetMaster()->GetGUID() != m_tank->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt)
+                {
+                    if (isUnderAttack(GetMaster(),2) && CastSpell(RIGHTEOUS_DEFENSE, GetMaster())) { return; }
+                    if (CastSpell(HOR, curAtt,true,true))  { } //No GCD
+                }
+            }
+            // My target is not attacking me, taunt..
+            if ( m_tank->GetGUID() == m_bot->GetGUID() && pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(HOR, pTarget,true,true) )  { } //NO GCD
+
+            // Tank specials
+            if (TALENT_PROT && ai->GetManaPercent() < 90 && CastSpell (DIVINE_PLEA, m_bot)) { return; } //Prot paladin always uses this..
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && CastSpell(HOLY_SHIELD,m_bot)) { return; }
+            if (CastSpell(AVENGERS_SHIELD,pTarget,true,true)) { return; }
+            if (CastSpell(HOTR,pTarget,true,true)) { return; }
+            if (CastSpell(HOLY_WRATH,pTarget,true,true)){ return; }
+            if (CastSpell(CONSECRATION,pTarget)) { return; }
+            if (m_bot->getRace() == (uint8) RACE_DWARF && CastSpell(R_STONEFORM,m_bot)) { return; }
+
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+
+        break;
+		#pragma endregion
+
+		#pragma region BOT_ROLE_DPS_MELEE
+		case BOT_ROLE_DPS_MELEE:
+
+			ChangeAura(RETRIBUTION_AURA);
+			if (!TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID()) m_bot->RemoveAurasDueToSpell(RIGHTEOUS_FURY);
+			if (CastSpell(SOV,m_bot)) { return; }
+
+			if (CastSpell (HAMMER_OF_JUSTICE, pTarget)) { return; }
+			if (!m_bot->HasAura(FORBEARANCE) && CastSpell(AVENGING_WRATH,m_bot)) {} //no gcd
+			if (CastSpell(JOW,pTarget)) { return; }
+			if (CastSpell(DIVINE_STORM, pTarget)) { return; }
+			if (CastSpell(CRUSADER_STRIKE, pTarget)) { return; }
+			if (GetAI()->GetHealthPercent(*pTarget)<20 && CastSpell(HAMMER_OF_WRATH, pTarget)) { return; }
+			if (CastSpell(CONSECRATION,pTarget)) { return; }
+			if (m_bot->HasAura(AOW) && CastSpell(EXORCISM,pTarget)) { return; }
+			if (CastSpell(HOLY_WRATH,pTarget)) { return; }
+
+		break;
+        #pragma endregion
+
+    }
+    #pragma region PaladinCommon
+    // Shared dps spells
+    if (pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_HUMANOID && pTarget->IsNonMeleeSpellCasted(true) && CastSpell (REPENTANCE, pTarget)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} // no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} // no GCD
+
+    // If at threat limit, stop
+    if(pThreat > threatThreshold && !TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(HOS,m_bot)) { return; } //Lets see if we can manage with HOS
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+    // Continue attacking if theres excess mana (for healers)
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+
+    if (GetAI()->GetHealthPercent(*pTarget)<20 && CastSpell(HAMMER_OF_WRATH, pTarget,true,true)) { return; } //no gcd but cast
+    if (CastSpell (HAMMER_OF_JUSTICE, pTarget)) { return; }
+    if (CanCast(JOW,pTarget,true) &&
+        ( ( ai->GetManaPercent() <= 70 && ai->GetHealthPercent() > 90)
+        || ( ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 75)
+        || ( ai->GetManaPercent() <= 20 && ai->GetHealthPercent() > 20) )
+        && CastSpell(JOW,pTarget,false)) { return; }
+    else if (CastSpell(JOL,pTarget),true,true) { return; }
+    if (CastSpell(SHIELD_OF_RIGHTEOUSNESS,pTarget,true,true)) { return; }
+    if (CastSpell (DIVINE_STORM, pTarget,true,true)) { return; }
+    if (CastSpell (CRUSADER_STRIKE, pTarget,true,true)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no GCD but cast
+    if (isUnderAttack(m_tank,4) && CastSpell(HOLY_WRATH,pTarget,true,true)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(CONSECRATION,pTarget)) { return; }
+    if (CastSpell(HOLY_SHOCK,pTarget,true,true)) { return; }
+    if (m_role != BOT_ROLE_SUPPORT && ai->GetManaPercent() > 60 && OwnPartyHP < 65 && DoSupportRaid(m_bot)) { return; } //if there is spare time and mana, do healz and other stuff..
+    else if (m_role != BOT_ROLE_SUPPORT && ai->GetManaPercent() > 30 && DoSupportRaid(m_bot,30,false,false,false,true,false)) { return; }
+    if (CastSpell(EXORCISM,pTarget,true,true)) { return; }
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+    #pragma endregion
+
+} //end DoNextCombatManeuver
+
+void PlayerbotPaladinAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(FLASH_OF_LIGHT,m_bot)) { return; }
+    if (ai->GetManaPercent() < 70) { ai->Feast(); }
+} //end DoNonCombatActions
+
+bool PlayerbotPaladinAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if(hp < 10 && m_bot->isInCombat() && CastSpell(LOH, target)) { return true; }
+    if(hp < 10 && m_bot->isInCombat() && CastSpell(SACRED_SHIELD,target)) { return true; }
+    if(hp < 15 && m_bot->isInCombat() && CastSpell(HOP,target)) { return true; }
+    if(hp < 20 && m_bot->isInCombat() && CastSpell(BEACON_OF_LIGHT,target)) { return true; }
+    if(hp < 30 && CastSpell(HOLY_SHOCK,target,true,true,true)) { return true; }
+    if(hp < 30 && m_bot->isInCombat() && CanCast(DIVINE_FAVOR,m_bot,true) && CanCast(HOLY_LIGHT,target,true) ) { CastSpell(DIVINE_FAVOR, m_bot,false); return CastSpell(HOLY_LIGHT,target,false); } //No gcd
+    if(hp < 30 && CastSpell(FLASH_OF_LIGHT,target,true,true)) { return true; }
+    if(hp < 40 && m_bot->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) { return true; } // no GCD but has cast
+    if(hp < 65 && CastSpell(HOLY_LIGHT,target,true,true)) { return true; }
+    if(hp < 85 && CastSpell(FLASH_OF_LIGHT,target,true,true)) { return true; }
+    if(hp < 95 && m_bot->isInCombat() && CastSpell(BEACON_OF_LIGHT,target)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotPaladinAI::CureTarget(Unit *target)
+{
+    if (!target || target->isDead()) { return false; }
+    if (castDispel(CLEANSE, target)) { return true; }
+    return false;
+
+} //end CureTarget
+
+bool PlayerbotPaladinAI::BuffPlayer(Unit *target)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    // Check if target already has a blessing by me..
+    if (HasAuraName(target,BOW,m_bot->GetGUID()) ||
+    HasAuraName(target,BOK,m_bot->GetGUID()) ||
+    HasAuraName(target,BOM,m_bot->GetGUID()) ||
+    HasAuraName(target,BOS,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOW,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOK,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOM,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOS,m_bot->GetGUID())
+    ) return false;
+
+#pragma region Choose Buff > Class
+    switch(target->getClass())
+    {
+        case CLASS_MAGE:
+        case CLASS_WARLOCK:
+            if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_PRIEST:
+            if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_HUNTER:
+            if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_ROGUE:
+            if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_WARRIOR:
+        case CLASS_DEATH_KNIGHT:
+            if (target->GetUnitDodgeChance() + target->GetUnitParryChance() > 40)
+            {
+                if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            }
+            else
+            {
+                if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            }
+            break;
+        case CLASS_DRUID:
+        case CLASS_SHAMAN:
+        case CLASS_PALADIN:
+            if (target->GetMaxPower(target->getPowerType()) > target->GetMaxHealth())
+            {
+                if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+                else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            }
+            else if (target->GetUnitDodgeChance() + target->GetUnitParryChance() > 40)
+            {
+                if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            }
+            else
+            {
+                if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            }
+            break;
+
+        default:
+                if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                break;
+    }
+#pragma endregion
+
+    return false;
+}
+
+bool PlayerbotPaladinAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(REDEMPTION,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(REDEMPTION, target, false);
+}
+
+bool PlayerbotPaladinAI::ChangeAura(uint32 aura)
+{
+    Player *m_bot = GetPlayerBot();
+    if(!aura) return false;
+
+    if(!CanCast(aura,m_bot)) return false;
+
+    if(m_bot->HasAura(aura))
+    {
+        if (aura == DEVOTION_AURA)
+        {
+            if (ChangeAura(FIRE_AURA)) return true;
+            if (ChangeAura(FROST_AURA)) return true;
+            if (ChangeAura(SHADOW_AURA)) return true;
+            return true;
+        }
+        else return ChangeAura(DEVOTION_AURA);
+    }
+    return CastSpell(aura,m_bot,false);
+}
+
diff --git a/src/server/game/AI/Bots/PlayerbotPaladinAI.h b/src/server/game/AI/Bots/PlayerbotPaladinAI.h
new file mode 100644
index 0000000..72c6beb
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotPaladinAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERBOTPALADINAI_H
+#define _PLAYERBOTPALADINAI_H
+
+#include "PlayerbotClassAI.h"
+#include "SharedDefines.h"
+
+class PlayerbotPaladinAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotPaladinAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotPaladinAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget (Unit *target);
+
+        bool ChangeAura(uint32 aura);
+
+    private:
+        //heals
+        uint32 FLASH_OF_LIGHT, HOLY_LIGHT, HOLY_SHOCK, REZZ, CLEANSE, LOH, SACRED_SHIELD, BEACON_OF_LIGHT, DIVINE_FAVOR, REDEMPTION;
+
+        //Damages
+        uint32 JOL, JOW, JOJ, HAMMER_OF_WRATH, EXORCISM, HOLY_WRATH, CONSECRATION, AVENGERS_SHIELD, SHIELD_OF_RIGHTEOUSNESS, HOTR, CRUSADER_STRIKE, DIVINE_STORM;
+
+        //CC
+        uint32 HAMMER_OF_JUSTICE, REPENTANCE;
+
+        //Self buffs
+        uint32 SOL, SOW, SOR, SOC, SOV, DIVINE_PLEA, HOLY_SHIELD, RIGHTEOUS_FURY, DIVINE_SHIELD, AVENGING_WRATH;
+
+        //AURAS
+        uint32 DEVOTION_AURA, RETRIBUTION_AURA, CONCENTRATION_AURA, FIRE_AURA, FROST_AURA, SHADOW_AURA, CRUSADER_AURA ;
+
+        //Blessings
+        uint32 BOW, BOM, BOS, BOK, GBOW, GBOM, GBOS, GBOK;
+
+        //Hands
+        uint32 HOF, HOR, HOS, HOP, DIVINE_SACRIFICE;
+
+        //Taunt
+        uint32 RIGHTEOUS_DEFENSE;
+
+        uint32 FORBEARANCE;
+
+        uint32 TALENT_HOLY, TALENT_PROT, TALENT_RETRI;
+
+		//procs
+		uint32 AOW;
+
+};
+
+
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotPriestAI.cpp b/src/server/game/AI/Bots/PlayerbotPriestAI.cpp
new file mode 100644
index 0000000..729316f
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotPriestAI.cpp
@@ -0,0 +1,400 @@
+/*
+Name : PlayerbotPriest.cpp
+Complete: maybe around 55%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - Holy And Disc builds do not cast any offensive spells requiring cast time..(To compensate for the fact that Healing decision is not that intelligent)
+                - Priest breaks her own CCs.. Need a check for bots to not attack CC ed mobs..
+                - Wand usage is not very smooth..
+
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+#include "PlayerbotPriestAI.h"
+
+class PlayerbotAI;
+PlayerbotPriestAI::PlayerbotPriestAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotPriestAI::~PlayerbotPriestAI(){}
+
+void PlayerbotPriestAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //heals
+    RENEW = ai->getSpellIdExact("Renew");
+    FLASH_HEAL = ai->getSpellIdExact("Flash Heal");
+    if (!FLASH_HEAL) FLASH_HEAL = ai->getSpellIdExact("Lesser Heal");
+    HEAL = ai->getSpellIdExact("Greater Heal");
+    if (!HEAL) HEAL = ai->getSpellIdExact("Heal");
+    if (!HEAL) HEAL = FLASH_HEAL;
+    BINDING_HEAL = ai->getSpellIdExact("Binding Heal");
+    PO_MENDING = ai->getSpellIdExact("Prayer of Mending");
+    DESPERATE_PRAYER = ai->getSpellIdExact("Desperate Prayer");
+    PO_HEALING = ai->getSpellIdExact("Prayer of Healing");
+    CIRCLE_OF_HEALING = ai->getSpellIdExact("Circle of Healing");
+    DIVINE_HYMN = ai->getSpellIdExact("Divine Hymn");
+    RESURRECTION = ai->getSpellIdExact("Resurrection");
+    HYMN_OF_HOPE = ai->getSpellIdExact("Hymn of Hope");
+    CURE_DISEASE = ai->getSpellIdExact("Abolish Disease");
+    if (!CURE_DISEASE) CURE_DISEASE = ai->getSpellIdExact("Abolish Disease");
+    DISPEL_MAGIC = ai->getSpellIdExact("Dispel Magic");
+    MASS_DISPEL = ai->getSpellIdExact("Mass Dispel");
+
+    //Holy Offensive
+    SMITE = ai->getSpellIdExact("Smite");
+    HOLY_FIRE = ai->getSpellIdExact("Holy Fire");
+    PENANCE = ai->getSpellIdExact("Penance");
+    HOLY_NOVA = ai->getSpellIdExact("Holy Nova");
+
+    //Shadow Offensive
+    MIND_BLAST = ai->getSpellIdExact("Mind Blast");
+    SW_PAIN = ai->getSpellIdExact("Shadow Word: Pain");
+    DEVOURING_PLAGUE = ai->getSpellIdExact("Devouring Plague");
+    MIND_FLAY = ai->getSpellIdExact("Mind Flay");
+    VAMPIRIC_EMBRACE = ai->getSpellIdExact("Vampiric Embrace");
+    VAMPIRIC_TOUCH = ai->getSpellIdExact("Vampiric Touch");
+    SW_DEATH = ai->getSpellIdExact("Shadow Word: Death");
+    MIND_SEAR = ai->getSpellIdExact("Mind Sear");
+    MANA_BURN = ai->getSpellIdExact("Mana Burn");
+    SHADOWFIEND = ai->getSpellIdExact("Shadowfiend");
+
+    //CC - Breaker
+    PSYCHIC_SCREAM = ai->getSpellIdExact("Psychic Scream");
+    PSYCHIC_HORROR = ai->getSpellIdExact("Psychic Horror");
+    MIND_SOOTHE = ai->getSpellIdExact("Mind Soothe");
+    SHACKLE_UNDEAD = ai->getSpellIdExact("Shackle Undead");
+    SILENCE = ai->getSpellIdExact("Silence");
+    MIND_CONTROL = ai->getSpellIdExact("Mind Control");
+
+    //buffs
+    PW_SHIELD = ai->getSpellIdExact("Power Word: Shield");
+    INNER_FIRE = ai->getSpellIdExact("Inner Fire");
+    GUARDIAN_SPIRIT = ai->getSpellIdExact("Guardian Spirit");
+    FADE = ai->getSpellIdExact("Fade");
+    INNER_FOCUS = ai->getSpellIdExact("Inner Focus");
+    POWER_INFUSION = ai->getSpellIdExact("Power Infusion");
+    PAIN_SUPPRESSION = ai->getSpellIdExact("Pain Suppression");
+    SHADOWFORM = ai->getSpellIdExact("Shadowform");
+    DISPERSION = ai->getSpellIdExact("Dispersion");
+    LIGHTWELL = ai->getSpellIdExact("Lightwell");
+
+    PW_FORTITUDE = ai->getSpellIdExact("Power Word: Fortitude");
+    DIVINE_SPIRIT = ai->getSpellIdExact("Divine Spirit");
+    SHADOW_PROTECTION = ai->getSpellIdExact("Shadow Protection");
+    PO_FORTITUDE = ai->getSpellIdExact("Prayer of Fortitude");
+    PO_SPIRIT = ai->getSpellIdExact("Prayer of Spirit");
+    PO_SHADOW_PROTECTION = ai->getSpellIdExact("Prayer of Shadow Protection");
+    FEAR_WARD = ai->getSpellIdExact("Fear Ward");
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_DISC = PAIN_SUPPRESSION;
+    TALENT_HOLY = CIRCLE_OF_HEALING;
+    TALENT_SHADOW = SHADOWFORM;
+
+    uint8 talentCounter = 0;
+    if (TALENT_DISC) talentCounter++;
+    if (TALENT_HOLY) talentCounter++;
+    if (TALENT_SHADOW) talentCounter++;
+    if (talentCounter > 1) { TALENT_DISC = 0; TALENT_HOLY = 0; TALENT_SHADOW = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotPriestAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+    /*
+    switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            (ai->HasAura(SCREAM, pTarget) && ai->GetHealthPercent() < 60 && CastSpell(HEAL)) ||
+            CastSpell(PAIN) ||
+            (ai->GetHealthPercent() < 80 && CastSpell(RENEW)) ||
+            (m_bot->GetDistance(pTarget) <= 5 && CastSpell(SCREAM)) ||
+            CastSpell(MIND_BLAST) ||
+            (ai->GetHealthPercent() < 20 && CastSpell(FLASH_HEAL)) ||
+            CastSpell(SMITE);
+            return;
+    }*/
+
+
+    //------- Non Duel combat ----------
+
+
+    // Cast CC breakers if any match found (include any dispels first)  does not work yet
+    //uint32 ccSpells[6] = { DISPEL_MAGIC, CURE_DISEASE, DISPERSION, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    //if (ai->GetManaPercent() < 35) { ccSpells[0] = 0; ccSpells[1] = 0; } //We dont have any mana to waste...
+    //if (castSelfCCBreakers(ccSpells)) {  } // Most of them don't trigger gcd
+
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        m_role = BOT_ROLE_DPS_RANGED;
+    }
+    else if (TALENT_SHADOW) {
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 30)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 40) {m_role = BOT_ROLE_SUPPORT;}
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+    else { m_role = BOT_ROLE_SUPPORT; } //Unknown build or low level.. Mainly attack
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(FADE,m_bot)) { return; }
+        else if (CastSpell(PAIN_SUPPRESSION,m_bot)) { return; }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+
+    if (m_role == BOT_ROLE_DPS_RANGED && CastSpell(SHADOWFORM,m_bot)) { return; }
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetForm() == FORM_SHADOW) { m_bot->RemoveAurasDueToSpell(SHADOWFORM); }
+
+    //Buff
+    if (CastSpell(INNER_FIRE,m_bot)) { } //nogcd
+    if (CastSpell(POWER_INFUSION,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+
+    if (ai->GetForm() != FORM_SHADOW)
+    {
+        if (PO_MENDING && ai->GetHealthPercent(*m_tank) < 90 && !HasAuraName(m_tank, "Prayer of Mending") && CastSpell(PO_MENDING,m_tank)) { return; } //MEND tank first
+        if (DoSupportRaid(m_bot)) { return; }
+        //heal pets and bots
+        Unit *target = DoSelectLowestHpFriendly(30, 1000);
+        if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+    }
+    if (ai->GetForm() == FORM_SPIRITOFREDEMPTION) { return; } //You're dead..
+
+
+    //PROTECT
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (PSYCHIC_HORROR && CastSpell(PSYCHIC_HORROR, pTarget)) { return; }
+        if (PSYCHIC_SCREAM && CastSpell(PSYCHIC_SCREAM, pTarget)) { return; }
+        if (SHACKLE_UNDEAD && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_UNDEAD && CastSpell(SHACKLE_UNDEAD, pTarget)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (ai->GetHealthPercent() < 20 && CastSpell(DESPERATE_PRAYER)) { return; }
+    if (ai->GetHealthPercent() < 30 && CastSpell(PW_SHIELD)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (ai->GetHealthPercent() < 60 && CastSpell(PAIN_SUPPRESSION,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 50 && ai->GetManaPercent() < 10 && CastSpell(DISPERSION,m_bot)) { return; }
+    if (ai->GetManaPercent() < 10 && CastSpell (HYMN_OF_HOPE, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+
+
+    //Break Spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SILENCE, pTarget)) { return; }
+
+
+    // If at threat limit, try to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(PAIN_SUPPRESSION,m_bot)) { return; } //Lets see if we can manage
+            else if (CastSpell(FADE,m_bot)) { return; }
+            else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+    //WAND
+    if (ai->GetManaPercent() < 5 ||
+        (m_role != BOT_ROLE_DPS_RANGED && SHOOT && !m_bot->FindCurrentSpellBySpellId(SHOOT) && ai->CastSpell(SHOOT,pTarget) )
+        ) { return; } //Start autoshot
+
+    // Continue spell attacking if theres excess mana (for healers)
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) > 95) { return; } // dont dps too early
+
+    if (CastSpell(VAMPIRIC_EMBRACE,pTarget)) { return; }
+    if (CastSpell(VAMPIRIC_TOUCH,pTarget)) { return; }
+    if (CastSpell(DEVOURING_PLAGUE,pTarget)) { return; }
+    if (CastSpell(SW_PAIN,pTarget)) { return; }
+
+    if (ai->GetForm() == FORM_SHADOW)
+    {
+        if (castDispel(DISPEL_MAGIC, pTarget)) { return; } //Dispel buffs if any
+        if (CastSpell(MIND_BLAST,pTarget)) { return; }
+        if (CastSpell(MIND_FLAY,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(MIND_SEAR,pTarget)) { return; }
+    }
+
+    if (ai->GetForm() == FORM_NONE && m_role == BOT_ROLE_DPS_RANGED)
+    {
+        if (CastSpell(PENANCE,pTarget)) { return; }
+        if (CastSpell(MIND_BLAST,pTarget)) { return; }
+        if (CastSpell(HOLY_FIRE,pTarget)) { return; }
+        if (CastSpell(SMITE,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(MIND_SEAR,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(HOLY_NOVA,pTarget)) { return; }
+    }
+
+     // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+} //end DoNextCombatManeuver
+
+void PlayerbotPriestAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Own Buffs
+    if (CastSpell(INNER_FIRE,m_bot)) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(30, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(FLASH_HEAL,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+
+
+bool PlayerbotPriestAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if (hp < 30 && m_bot->isInCombat() && CastSpell(GUARDIAN_SPIRIT,target)) { } //nogcd
+    if (hp < 30 && CastSpell(PENANCE,target,true,false,true)) { return true; } //Channeling Dual purpose
+    if (hp < 35 && m_bot->isInCombat() && CastSpell(PW_SHIELD,target)) { return true; } //Check weakened soul
+    if (hp < 80 && hp > 50 && GetAI()->GetHealthPercent() < 80 && CastSpell (BINDING_HEAL,target)) { return true; }
+    if (hp < 85 && CastSpell(RENEW,target)) { return true; }
+    if (hp < 40 && GetPlayerBot()->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) { return true; } // no GCD, but has cast
+    if (hp < 55 && hp > 35 && CastSpell(HEAL,target)) { return true; }
+    if (hp < 75 && CastSpell(FLASH_HEAL,target)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotPriestAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    Player *m_bot = GetPlayerBot();
+    if (countNeedHeal < 2) { return false; }
+    Unit *rTarget = DoSelectLowestHpFriendly(30,500);
+    if (!rTarget || rTarget->isDead() || rTarget->GetHealth() * 100 / rTarget->GetMaxHealth() > 80 ) { return false; }
+
+    // if (hp < 75 && CastSpell(PO_MENDING, rTarget)) { return true; } //save this for tank
+    if (hp < 35 && m_bot->isInCombat() && CastSpell(DIVINE_HYMN,rTarget)) { /*GetAI()->SetIgnoreUpdateTime(9);*/ return true; }
+    if (hp < 70 && CastSpell(CIRCLE_OF_HEALING,rTarget)) { return true; }
+    if (hp < 75 && hp > 30 && countNeedHeal > 4 && CastSpell(PO_HEALING)) { return true; }
+    if (hp < 65 && CastSpell(HOLY_NOVA,rTarget,true,false,true)) { return true; }
+
+    return false;
+}
+
+//Cures the target
+bool PlayerbotPriestAI::CureTarget(Unit *target)
+{
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(DISPEL_MAGIC, target,true,false,true)) return true;
+    if (castDispel(CURE_DISEASE, target)) return true;
+    // if(HasAuraName(target, "Venom Spit") || HasAuraName(target, "Poison")) return CastSpell(CURE_POISON, target);
+    return false;
+}
+
+bool PlayerbotPriestAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(RESURRECTION,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+   // msg += " with ";
+   // msg += *REZZSpell->SpellName;
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(RESURRECTION, target,false);
+}
+
+bool PlayerbotPriestAI::BuffPlayer(Unit *target)
+{
+    if(!target || target->isDead()) return false;
+
+    return (
+        (!HasAuraName(target, PW_FORTITUDE) && !HasAuraName(target, PO_FORTITUDE) && CastSpell (PW_FORTITUDE, target)) ||
+        (!HasAuraName(target, SHADOW_PROTECTION) && !HasAuraName(target, PO_SHADOW_PROTECTION) && CastSpell(SHADOW_PROTECTION, target)) ||
+        (!HasAuraName(target, DIVINE_SPIRIT) && !HasAuraName(target, PO_SPIRIT) && CastSpell (DIVINE_SPIRIT, target)) ||
+        (!HasAuraName(target, FEAR_WARD) && CastSpell (FEAR_WARD, target))
+         );
+}
diff --git a/src/server/game/AI/Bots/PlayerbotPriestAI.h b/src/server/game/AI/Bots/PlayerbotPriestAI.h
new file mode 100644
index 0000000..9670986
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotPriestAI.h
@@ -0,0 +1,59 @@
+#ifndef _PLAYERBOTPRIESTAI_H
+#define _PLAYERBOTPRIESTAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotPriestAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPriestAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+    virtual ~PlayerbotPriestAI();
+
+    virtual void LoadSpells();
+
+    //all combat actions go here
+    void DoNextCombatManeuver(Unit *);
+
+    //all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    //buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Unit *target);
+
+    //Heals the target based off its HP
+    bool HealTarget(Unit *target, uint8 hp);
+
+    bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+    //Cures the target
+    bool CureTarget(Unit *target);
+
+    bool RezTarget (Unit *target);
+
+private:
+    //heals
+    uint32 RENEW, FLASH_HEAL, HEAL, BINDING_HEAL, PO_MENDING, DESPERATE_PRAYER, PO_HEALING, CIRCLE_OF_HEALING, DIVINE_HYMN, RESURRECTION, HYMN_OF_HOPE, CURE_DISEASE, DISPEL_MAGIC, MASS_DISPEL;
+
+    //Holy Offensive
+    uint32 SMITE, HOLY_FIRE, PENANCE, HOLY_NOVA;
+
+    //Shadow Offensive
+    uint32 MIND_BLAST, SW_PAIN, DEVOURING_PLAGUE, MIND_FLAY, VAMPIRIC_EMBRACE, VAMPIRIC_TOUCH, SW_DEATH, MIND_SEAR, MANA_BURN, SHADOWFIEND;
+
+    //CC - Breaker
+    uint32 PSYCHIC_SCREAM, PSYCHIC_HORROR, MIND_SOOTHE, SHACKLE_UNDEAD, SILENCE, MIND_CONTROL;
+
+    //buffs
+    uint32 PW_SHIELD, INNER_FIRE, GUARDIAN_SPIRIT, FADE, INNER_FOCUS, POWER_INFUSION, PAIN_SUPPRESSION, SHADOWFORM, DISPERSION, LIGHTWELL,
+        PW_FORTITUDE, DIVINE_SPIRIT, SHADOW_PROTECTION, PO_FORTITUDE, PO_SPIRIT, PO_SHADOW_PROTECTION, FEAR_WARD;
+
+    uint32 SHOOT;
+
+    uint32 TALENT_DISC, TALENT_HOLY, TALENT_SHADOW;
+};
+
+
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotRogueAI.cpp b/src/server/game/AI/Bots/PlayerbotRogueAI.cpp
new file mode 100644
index 0000000..4dff2db
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotRogueAI.cpp
@@ -0,0 +1,266 @@
+#include "PlayerbotRogueAI.h"
+#include "Spell.h"
+class PlayerbotAI;
+PlayerbotRogueAI::PlayerbotRogueAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotRogueAI::~PlayerbotRogueAI(){}
+
+void PlayerbotRogueAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //Damage spells
+    BACKSTAB = ai->getSpellIdExact("Backstab");
+    SINISTER_STRIKE = ai->getSpellIdExact("Sinister Strike");
+    MUTILATE = ai->getSpellIdExact("Mutilate");
+    HEMORRHAGE = ai->getSpellIdExact("Hemorrhage");
+    GHOSTLY_STRIKE = ai->getSpellIdExact("Ghostly Strike");
+    RIPOSTE = ai->getSpellIdExact("Riposte");
+    SHIV = ai->getSpellIdExact("Shiv");
+    FAN_OF_KNIVES = ai->getSpellIdExact("Fan of Knives");
+
+    //Finishing Moves
+    EVISCERATE = ai->getSpellIdExact("Eviscerate");
+    RUPTURE = ai->getSpellIdExact("Rupture");
+    KIDNEY_SHOT = ai->getSpellIdExact("Kidney Shot");
+    ENVENOM = ai->getSpellIdExact("Envenom");
+    SLICE_AND_DICE = ai->getSpellIdExact("Slice and Dice");
+    EXPOSE_ARMOR = ai->getSpellIdExact("Expose Armor");
+    DEADLY_THROW = ai->getSpellIdExact("Deadly Throw");
+
+    //Buffs
+    STEALTH = ai->getSpellIdExact("Stealth");
+    VANISH = ai->getSpellIdExact("Vanish");
+    EVASION = ai->getSpellIdExact("Evasion");
+    CLOAK_OF_SHADOWS = ai->getSpellIdExact("Cloak of Shadows");
+    SPRINT = ai->getSpellIdExact("Sprint");
+    COLD_BLOOD = ai->getSpellIdExact("Cold Blood");
+    HUNGER_FOR_BLOOD = ai->getSpellIdExact("Hunger for Blood");
+    BLADE_FLURRY = ai->getSpellIdExact("Blade Flurry");
+    ADRENALINE_RUSH = ai->getSpellIdExact("Adrenaline Rush");
+    KILLING_SPREE = ai->getSpellIdExact("Killing Spree");
+    SHADOW_DANCE = ai->getSpellIdExact("Shadow Dance");
+
+    //Openers
+    CHEAP_SHOT = ai->getSpellIdExact("Cheap Shot");
+    GARROTE = ai->getSpellIdExact("Garrote");
+    AMBUSH = ai->getSpellIdExact("Ambush");
+
+    //Others
+    GOUGE = ai->getSpellIdExact("Gouge");
+    BLIND = ai->getSpellIdExact("Blind");
+    DISMANTLE = ai->getSpellIdExact("Dismantle");
+    SAP = ai->getSpellIdExact("Sap");
+    KICK = ai->getSpellIdExact("Kick");
+    PREPARATION = ai->getSpellIdExact("Preparation");
+    PREMEDITATION = ai->getSpellIdExact("Premeditation");
+    SHADOWSTEP = ai->getSpellIdExact("Shadowstep");
+    FEINT = ai->getSpellIdExact("Feint");
+    TRICKS_OF_THE_TRADE = ai->getSpellIdExact("Tricks of the Trade");
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+    THROW = ai->getSpellIdExact("Throw");
+
+    TALENT_ASSASSINATION = MUTILATE;
+    TALENT_COMBAT = ADRENALINE_RUSH;
+    TALENT_SUBTELTY = PREMEDITATION;
+
+    //uint8 talentCounter = 0;
+    //if (TALENT_ASSASSINATION) talentCounter++;
+    //if (TALENT_COMBAT) talentCounter++;
+    //if (TALENT_SUBTELTY) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ASSASSINATION = 0; TALENT_COMBAT = 0; TALENT_SUBTELTY = 0; } //Unreliable Talent detection.
+#pragma endregion
+}
+
+void PlayerbotRogueAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    #pragma region Choose Target
+    // Choose actions accoring to talents (ROGUE is always MELEE DPS)
+    m_role = BOT_ROLE_DPS_MELEE;
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+        else if (CastSpell(VANISH,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+    #pragma endregion
+
+    // wait until we actually reach our target b4 we actually do anything
+    if (m_bot->GetDistance(pTarget)>10.0 &&
+        !m_bot->HasAura(STEALTH) &&
+        !m_bot->isInCombat() && CastSpell(STEALTH))
+    { return; }
+
+    TakePosition(pTarget);
+
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    // wait until we actually reach our target b4 we actually do anything
+    /*if (GetPlayerBot()->GetDistance(pTarget)>10.0 &&
+        !HasAuraName(GetPlayerBot(),STEALTH) &&
+        !GetPlayerBot()->isInCombat() && CastSpell(STEALTH))
+    { return; }*/
+
+    //Buff
+    if (CastSpell(PREMEDITATION,m_bot)) { return; }
+    if (CastSpell(COLD_BLOOD,m_bot)) { } //no gcd
+
+    //PROTECT UP
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+        if (CastSpell(FEINT,m_bot)) { return; }
+        if (CastSpell(VANISH,m_bot)) { return; }
+    }
+    if (isUnderAttack() && pDist <= MELEE_RANGE && ai->GetHealthPercent() <= 85 && CastSpell(EVASION, m_bot)) { } //no GCD
+    if (ai->GetHealthPercent() <= 55 && CastSpell(CLOAK_OF_SHADOWS, m_bot)) { return; }
+    if (isUnderAttack() && ai->GetHealthPercent() <= 65 && CastSpell(GOUGE, m_bot)) { return; }
+    if (isUnderAttack() && ai->GetHealthPercent() <= 45 && CastSpell(BLIND, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(KICK, pTarget)) { return; }
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(GOUGE, pTarget)) { return; }
+    else if (pTarget->IsNonMeleeSpellCasted(true) && m_bot->GetComboPoints() >= 1 && CastSpell(KIDNEY_SHOT, pTarget)) { return; }
+
+    //Transfer threat
+    if (m_tank->GetGUID() != m_bot->GetGUID() && CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+	if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    // sometimes we lose attack
+    if (!m_bot->isInCombat()) {
+        m_bot->Attack(pTarget, true);
+    }
+
+	if(TALENT_ASSASSINATION)
+	{
+		if (!m_bot->HasAura(HUNGER_FOR_BLOOD) && CastSpell(HUNGER_FOR_BLOOD,m_bot)) { return; }
+		if (m_bot->GetComboPoints() < 5)
+		{
+		    if (CastSpell(MUTILATE, pTarget)) { return; }
+		}
+		else
+		{
+			if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+
+		}
+	}
+
+    if(TALENT_COMBAT)
+	{
+		if (CastSpell(BLADE_FLURRY,m_bot)) { return; }
+		if (ai->GetEnergyAmount() < 20 && CastSpell(ADRENALINE_RUSH,m_bot)) { return; }
+		if (!CastSpell(ADRENALINE_RUSH) && CastSpell(KILLING_SPREE,m_bot,1,0,1)) { return; }
+		if (m_bot->GetComboPoints() > 5)
+		{
+			if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+		}
+	}
+
+    if(TALENT_SUBTELTY)
+	{
+		if (CastSpell(PREMEDITATION,m_bot)) {}
+		if (CastSpell(SHADOW_DANCE,m_bot)) {}
+		if (!CastSpell(SHADOW_DANCE,m_bot) && CastSpell(PREPARATION,m_bot)) { return; }
+		if (m_bot->GetComboPoints() < 5)
+		{
+			if (m_bot->HasAura(SHADOW_DANCE) && !pTarget->HasInArc(M_PI,m_bot)) { if (CastSpell(AMBUSH, pTarget)) { return; } }
+            if (CastSpell(GHOSTLY_STRIKE, pTarget)) { return; }
+		}
+		else
+		{
+			if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+			if (!m_bot->HasAura(SLICE_AND_DICE) && CastSpell(SLICE_AND_DICE)) { return; }
+			if (CastSpell(SHADOWSTEP,pTarget)) { }
+		}
+	}
+
+    // defaults if not high enough do specialized attacks
+    if (m_bot->GetComboPoints() < 5) {
+        if (!pTarget->HasInArc(M_PI,m_bot)) { if (CastSpell(BACKSTAB, pTarget)) { return; } }
+        if (!MUTILATE &&CastSpell(SINISTER_STRIKE,pTarget)) { return; } // Dont cast if we have mutilate, save energy for it
+    } else {
+        if (!m_bot->HasAura(SLICE_AND_DICE) && CastSpell(SLICE_AND_DICE)) {  return; }
+		if (CastSpell(ENVENOM,pTarget)) { return; }
+        if (CastSpell(EVISCERATE,pTarget)) { return; }
+    }
+} //end DoNextCombatManeuver
+
+
+void PlayerbotRogueAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff Up
+    if (ChangeWeaponEnchants()) { return; }
+} //end DoNonCombatActions
+
+bool PlayerbotRogueAI::ChangeWeaponEnchants()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+
+    Item *weap;
+    Item *poison;
+
+    weap = m_bot->GetWeaponForAttack(BASE_ATTACK);
+    if (weap && !weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+    {
+        poison = GetAI()->FindPoisonForward();
+        if(poison == NULL) return false;
+        GetAI()->PoisonWeapon(*poison, poison->GetProto()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_MAINHAND);
+        return true;
+    }
+    weap = m_bot->GetWeaponForAttack(OFF_ATTACK);
+    if (weap && !weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+    {
+        poison = GetAI()->FindPoisonBackward();
+        if(poison == NULL) return false;
+        GetAI()->PoisonWeapon(*poison, poison->GetProto()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_OFFHAND);
+        return true;
+    }
+    return false;
+}
diff --git a/src/server/game/AI/Bots/PlayerbotRogueAI.h b/src/server/game/AI/Bots/PlayerbotRogueAI.h
new file mode 100644
index 0000000..9c400f1
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotRogueAI.h
@@ -0,0 +1,41 @@
+#ifndef _PLAYERBOTROGUEAI_H
+#define _PLAYERBOTROGUEAI_H
+
+#include "PlayerbotClassAI.h"
+#include "TargetedMovementGenerator.h"
+
+class PlayerbotRogueAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotRogueAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotRogueAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, REBIRTHes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool ChangeWeaponEnchants();
+
+    private:
+        //Damage spells
+        uint32 BACKSTAB, SINISTER_STRIKE, MUTILATE, HEMORRHAGE, GHOSTLY_STRIKE, RIPOSTE, SHIV, FAN_OF_KNIVES;
+        //Finishing Moves
+        uint32 EVISCERATE, RUPTURE, KIDNEY_SHOT, ENVENOM, SLICE_AND_DICE, EXPOSE_ARMOR, DEADLY_THROW;
+        //Buffs
+        uint32 STEALTH, VANISH, EVASION, CLOAK_OF_SHADOWS, SPRINT, COLD_BLOOD, HUNGER_FOR_BLOOD, BLADE_FLURRY, ADRENALINE_RUSH, KILLING_SPREE, SHADOW_DANCE;
+        //Openers
+        uint32 CHEAP_SHOT, GARROTE, AMBUSH;
+        //Others
+        uint32 GOUGE, BLIND, DISMANTLE, SAP, KICK, PREPARATION, PREMEDITATION, SHADOWSTEP, FEINT, TRICKS_OF_THE_TRADE;
+
+        uint32 TALENT_ASSASSINATION, TALENT_COMBAT, TALENT_SUBTELTY;
+
+        uint32 THROW;
+
+};
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotShamanAI.cpp b/src/server/game/AI/Bots/PlayerbotShamanAI.cpp
new file mode 100644
index 0000000..201776e
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotShamanAI.cpp
@@ -0,0 +1,555 @@
+#include "PlayerbotShamanAI.h"
+class PlayerbotAI;
+PlayerbotShamanAI::PlayerbotShamanAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotShamanAI::~PlayerbotShamanAI(){}
+
+void PlayerbotShamanAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //totems
+    HEALING_STREAM_TOTEM = ai->getSpellIdExact("Healing Stream Totem");
+    MANA_SPRING_TOTEM = ai->getSpellIdExact("Mana Spring Totem");
+    MANA_TIDE_TOTEM = ai->getSpellIdExact("Mana Tide Totem");
+    CLEANSING_TOTEM = ai->getSpellIdExact("Cleansing Totem");
+    FIRE_RESISTANCE_TOTEM = ai->getSpellIdExact("Fire Resistance Totem");
+
+    WINDFURY_TOTEM = ai->getSpellIdExact("Windfury Totem");
+    WRATH_OF_AIR_TOTEM = ai->getSpellIdExact("Wrath of Air Totem");
+    GROUNDING_TOTEM = ai->getSpellIdExact("Grounding Totem");
+    NATURE_RESISTANCE_TOTEM = ai->getSpellIdExact("Nature Resistance Totem");
+
+    STRENGTH_OF_EARTH_TOTEM = ai->getSpellIdExact("Strength of Earth Totem");
+    EARTHBIND_TOTEM = ai->getSpellIdExact("Earthbind Totem");
+    STONESKIN_TOTEM = ai->getSpellIdExact("Stoneskin Totem");
+    STONECLAW_TOTEM = ai->getSpellIdExact("Stoneclaw Totem");
+    TREMOR_TOTEM = ai->getSpellIdExact("Tremor Totem");
+    EARTH_ELEMENTAL_TOTEM = ai->getSpellIdExact("Earth Elemental Totem");
+
+    FLAMETONGUE_TOTEM = ai->getSpellIdExact("Flametongue Totem");
+    TOTEM_OF_WRATH = ai->getSpellIdExact("Totem of Wrath");
+    SEARING_TOTEM = ai->getSpellIdExact("Searing Totem");
+    MAGMA_TOTEM = ai->getSpellIdExact("Magma Totem");
+    FIRE_ELEMENTAL_TOTEM = ai->getSpellIdExact("Fire Elemental Totem");
+    FROST_RESISTANCE_TOTEM = ai->getSpellIdExact("Frost Resistance Totem");
+
+    TOTEMIC_RECALL = ai->getSpellIdExact("Totemic Recall");
+    CALL_OF_THE_ELEMENTS = ai->getSpellIdExact("Call of the Elements");
+    CALL_OF_THE_ANCESTORS = ai->getSpellIdExact("Call of the Ancestors");
+    CALL_OF_THE_SPIRITS = ai->getSpellIdExact("Call of the Spirits");
+
+    //restoration
+    HEAL = ai->getSpellIdExact("Healing Wave");
+    LESSER_HEAL = ai->getSpellIdExact("Lesser Healing Wave");
+    CHAIN_HEAL = ai->getSpellIdExact("Chain Heal");
+    RIPTIDE = ai->getSpellIdExact("Riptide");
+    ANCESTRAL_SPIRIT = ai->getSpellIdExact("Ancestral Spirit");
+    CLEANSE_SPIRIT = ai->getSpellIdExact("Cleanse Spirit");
+    if (CLEANSE_SPIRIT) CLEANSE_SPIRIT = ai->getSpellIdExact("Cure Toxins");
+
+    //offensive spells
+    LIGHTNING_BOLT = ai->getSpellIdExact("Lightning Bolt");
+    CHAIN_LIGHTNING = ai->getSpellIdExact("Chain Lightning");
+    FIRE_NOVA = ai->getSpellIdExact("Fire Nova");
+    THUNDERSTORM = ai->getSpellIdExact("Thunderstorm");
+    LAVA_BURST = ai->getSpellIdExact("Lava Burst");
+    EARTH_SHOCK = ai->getSpellIdExact("Earth Shock");
+    WIND_SHEAR = ai->getSpellIdExact("Wind Shear");
+    FLAME_SHOCK = ai->getSpellIdExact("Flame Shock");
+    FROST_SHOCK = ai->getSpellIdExact("Frost Shock");
+    PURGE = ai->getSpellIdExact("Purge");
+    HEX  = ai->getSpellIdExact("Hex");
+
+    //buffs
+    LIGHTNING_SHIELD = ai->getSpellIdExact("Lightning Shield");
+    WATER_SHIELD = ai->getSpellIdExact("Water Shield");
+    EARTH_SHIELD = ai->getSpellIdExact("Earth Shield");
+    HEROISM = ai->getSpellIdExact("Heroism");
+    if (HEROISM) HEROISM = ai->getSpellIdExact("Bloodlust");
+    ELEMENTAL_MASTERY = ai->getSpellIdExact("Elemental Mastery");
+    NATURES_SWIFTNESS = ai->getSpellIdExact("Nature's Swiftness");
+
+    WINDFURY_WEAPON = ai->getSpellIdExact("Windfury Weapon");
+    FLAMETONGUE_WEAPON = ai->getSpellIdExact("Flametongue Weapon");
+    FROSTBRAND_WEAPON = ai->getSpellIdExact("Frostbrand Weapon");
+    ROCKBITER_WEAPON = ai->getSpellIdExact("Rockbiter Weapon");
+    EARTHLIVING_WEAPON = ai->getSpellIdExact("Earthliving Weapon");
+
+    WATER_BREATHING = ai->getSpellIdExact("Water Breathing");
+    WATER_WALKING = ai->getSpellIdExact("Water Walking");
+
+    //melee
+    LAVA_LASH = ai->getSpellIdExact("Lava Lash");
+    STORMSTRIKE = ai->getSpellIdExact("Stormstrike");
+    SHAMANISTIC_RAGE = ai->getSpellIdExact("Shamanistic Rage");
+    FERAL_SPIRIT = ai->getSpellIdExact("Feral Spirit");
+
+    GHOST_WOLF = ai->getSpellIdExact("Ghost Wolf");
+
+    EXHAUSTION = 57723; // heroism debuff
+    SATED = 57724; // bloodlust debuff
+    //MAELSTROM_WEAPON = 0; // We want the triggered aura, not the talent spell
+    uint32 mwtrigger = ai->getSpellIdExact("Maelstrom Weapon",true);
+    if (mwtrigger)
+    {
+        SpellEntry const *mwtSpell = GetSpellStore()->LookupEntry(mwtrigger);
+        if (mwtSpell && mwtSpell->EffectTriggerSpell[0] > 0) MAELSTROM_WEAPON = mwtSpell->EffectTriggerSpell[0];
+    }
+
+    TALENT_ELEMENTAL = ELEMENTAL_MASTERY;
+    TALENT_ENHANCEMENT = STORMSTRIKE;
+    TALENT_RESTO = EARTH_SHIELD;
+
+    uint8 talentCounter = 0;
+    if (TALENT_ELEMENTAL) talentCounter++;
+    if (TALENT_ENHANCEMENT) talentCounter++;
+    if (TALENT_RESTO) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ELEMENTAL = 0; TALENT_ENHANCEMENT = 0; TALENT_RESTO = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+void PlayerbotShamanAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+    switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            ((ai->GetHealthPercent() < 80 && CastSpell(LESSER_HEAL)) ||
+            CastSpell(LIGHTNING_BOLT, pTarget));
+            return;
+    }
+
+    // Cast CC breakers if any match found (include any dispels first)  does not work yet
+    //uint32 ccSpells[4] = { R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    //if (ai->GetManaPercent() < 35) { ccSpells[0] = 0; ccSpells[1] = 0; } //We dont have any mana to waste...
+    //if (castSelfCCBreakers(ccSpells)) {  } // Most of them don't trigger gcd
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) { m_role=BOT_ROLE_TANK; } // Hey! I am Main Tank
+    else if (TALENT_ENHANCEMENT) { m_role = BOT_ROLE_DPS_MELEE; }
+    else if (TALENT_ELEMENTAL) { m_role = BOT_ROLE_DPS_RANGED; }
+    else if (TALENT_RESTO) { m_role = BOT_ROLE_SUPPORT; }
+    else { m_role = BOT_ROLE_DPS_MELEE; } //Unknown build or low level.. Mainly attack
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack()  )
+    {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+    }
+    #pragma endregion
+
+    // Choose Weapon Enchant
+    if (ChangeWeaponEnchants()) return;
+
+	if (TALENT_ELEMENTAL){ if (!m_bot->HasAura(WATER_SHIELD) && CastSpell(WATER_SHIELD,m_bot)) { return; }}
+	if (TALENT_ENHANCEMENT){ if (!m_bot->HasAura(LIGHTNING_SHIELD) && CastSpell(LIGHTNING_SHIELD,m_bot)) { return; }}
+	if (TALENT_RESTO){ if (!m_bot->HasAura(WATER_SHIELD) && CastSpell(WATER_SHIELD,m_bot)) { return; }}
+    // Choose shield
+	/*
+    if (EARTH_SHIELD && ai->GetHealthPercent() < 80 && isUnderAttack()) { if (CastSpell(EARTH_SHIELD,m_bot)) { return; } }
+    else if (WATER_SHIELD && ai->GetManaPercent() < 40) { if (CastSpell(WATER_SHIELD,m_bot)) { return; } }
+    else if (LIGHTNING_SHIELD &&
+        ( isUnderAttack() || m_tank->GetGUID() == m_bot->GetGUID() )  && !(m_bot->HasAura(WATER_SHIELD) && ai->GetManaPercent() < 80)
+        ) { if (CastSpell(LIGHTNING_SHIELD,m_bot)) { return; } }
+    else if (CastSpell(WATER_SHIELD,m_bot)) { return; }
+	*/
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_TANK:
+        case BOT_ROLE_OFFTANK:
+             if (!TALENT_ELEMENTAL && !TALENT_RESTO) { TakePosition(pTarget); }
+            else { TakePosition(pTarget,BOT_ROLE_DPS_RANGED); } // mob will come to you sooner or later no need to hurry
+
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 70 && DoSupportRaid(m_bot)) { return; }
+
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 40 && DoSupportRaid(m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 40 && DoSupportRaid(m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            Unit *target = DoSelectLowestHpFriendly(40, 1000);
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            break;
+        #pragma endregion
+    }
+    #pragma region ShamanCommon
+
+
+    //Defensive Stuff
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (pDist > 5 && CastSpell(FROST_SHOCK, pTarget)) { return; }
+        if ((pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST || pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_HUMANOID) && CastSpell(HEX, pTarget)) { return; } // no gcd
+        if (CastSpell(WIND_SHEAR, pTarget)) { } // no gcd
+    }
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(WIND_SHEAR, pTarget)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(FROST_SHOCK,pTarget)) return;
+    }
+
+
+    //Buff and restores
+    if ( ( (ai->GetHealthPercent() < 60 && isUnderAttack()) ||
+        (ai->GetManaPercent() < 30) ) && CastSpell(SHAMANISTIC_RAGE, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} // no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} // no GCD
+    if (!m_bot->HasAura(HEROISM) && !m_bot->HasAura(EXHAUSTION) && !m_bot->HasAura(SATED) && CastSpell(HEROISM,m_bot)) { return; }
+    if (m_role != BOT_ROLE_SUPPORT && CastSpell(NATURES_SWIFTNESS, m_bot)) { } //healers keep it for healing no gcd
+    else if (CastSpell(ELEMENTAL_MASTERY, m_bot)) { } //no gcd
+
+    // If at threat limit, use WIND_SHEAR to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(WIND_SHEAR,pTarget)) { return; } //Lets see if we can manage
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+
+	if (TALENT_ELEMENTAL)
+	{
+		if (CastSpell(ELEMENTAL_MASTERY, m_bot)) { } //no gcd
+		if (!pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) && CastSpell(FLAME_SHOCK,pTarget)) { return; }
+		if (CastSpell(LAVA_BURST,pTarget)) { return; }
+		if (CastSpell(CHAIN_LIGHTNING,pTarget)) { return; }
+		if (CastSpell(LIGHTNING_BOLT,pTarget)) { return; }
+	}
+
+    //dps
+    if (MAELSTROM_WEAPON)
+    {
+        Aura *maelaura = m_bot->GetAura(MAELSTROM_WEAPON);
+        if (maelaura && maelaura->GetStackAmount() == 5)
+        {
+            if ((isUnderAttack(m_tank,3) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(CHAIN_LIGHTNING,pTarget,true,true)) { return; }
+            if (CastSpell(LIGHTNING_BOLT,pTarget,true,true)) { return; }
+        }
+    }
+	if (CastSpell(FLAME_SHOCK,pTarget)) { return; }
+    if (CastSpell(STORMSTRIKE,pTarget,true,true)) { return; }
+
+    //if (!TALENT_ENHANCEMENT && CanCast(LAVA_BURST,pTarget,true) && pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) && CastSpell(LAVA_BURST,pTarget,false)) { return; }
+	if (CastSpell(FERAL_SPIRIT,m_bot)) { return; }
+    if (CanCast(EARTH_SHOCK,pTarget,true) && (pTarget->HasAura(STORMSTRIKE,m_bot->GetGUID()) || pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) ) && CastSpell(EARTH_SHOCK,pTarget)) { return; }
+    //if (CanCast(FLAME_SHOCK,pTarget) && CastSpell(FLAME_SHOCK,pTarget)) { return; }
+	if (CastSpell(LAVA_LASH,pTarget,true,true)) { return; }
+	if (CastSpell(FIRE_NOVA,pTarget)) { return; }
+    //if ((isUnderAttack(m_tank,4) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(FIRE_NOVA,pTarget)) { return; }
+    if (ai->GetManaPercent() > 60 && castDispel(PURGE,pTarget)) { return; } //PURGE but dont overpurge
+
+    #pragma endregion
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+
+} //end DoNextCombatManeuver
+
+void PlayerbotShamanAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //Buffs
+    if (ChangeWeaponEnchants()) { return; }
+    if (CastSpell(WATER_SHIELD,m_bot)) { return; }
+    if (CastSpell(EARTH_SHIELD,m_bot)) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(LESSER_HEAL,m_bot)) { return; }
+	if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+bool PlayerbotShamanAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if(hp < 30 && m_bot->isInCombat() && CastSpell(NATURES_SWIFTNESS, m_bot)) {} // NO gcd
+    if(hp < 60 && CanCast(HEAL,target,true) && m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(HEAL, target, false)) { return true; }
+    if(hp < 30 && CastSpell(LESSER_HEAL,target,true,true)) { return true; }
+    if(hp < 40 && m_bot->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) {} // no GCD
+    if(hp < 65 && CanCast(EARTH_SHIELD,target) && !m_bot->HasAura(EARTH_SHIELD,m_bot->GetGUID()) && CastSpell(EARTH_SHIELD,target,false)) { return true; }
+    if(hp < 65 && CastSpell(HEAL,target,true,true)) { return true; }
+    if(hp < 85 && CastSpell(LESSER_HEAL,target,true,true)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotShamanAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    Player *m_bot = GetPlayerBot();
+    if (countNeedHeal < 2) { return false; }
+    Unit *rTarget = DoSelectLowestHpFriendly(30,500);
+    if (!rTarget || rTarget->isDead() || rTarget->GetHealth() * 100 / rTarget->GetMaxHealth() > 80 ) { return false; }
+
+    if (hp < 65 && RIPTIDE && rTarget->HasAura(RIPTIDE,m_bot->GetGUID()) && CastSpell(CHAIN_HEAL, rTarget)) { return true; }
+    if (hp < 85 && CastSpell(RIPTIDE, rTarget)) { return true; }
+    if (hp < 75 && CastSpell(CHAIN_HEAL, rTarget,true,true)) { return true; }
+
+    return false;
+}
+
+bool PlayerbotShamanAI::CureTarget(Unit *target)
+//Cures the target
+{
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(CLEANSE_SPIRIT, target)) return true;
+
+    return false;
+}
+
+bool PlayerbotShamanAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(ANCESTRAL_SPIRIT,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(ANCESTRAL_SPIRIT, target,false);
+}
+
+bool PlayerbotShamanAI::BuffPlayer(Unit *target)
+{
+    //std::string msg = "Mana totem, coming right up.";
+    //GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    //if(!HasAuraName(GetPlayerBot(), "Mana Spring")) { CastSpell(MANA_SPRING_TOTEM, GetPlayerBot()); } return true;
+    return false;
+}
+#pragma region Change Totems
+bool PlayerbotShamanAI::ChangeTotems(uint32 mode)
+{
+    uint32 earth=0, fire=0, water=0, air=0;
+
+    PlayerbotAI *ai = GetAI();
+    if(!ai) return false;
+    Player *m_bot = GetPlayerBot();
+    if(!m_bot || m_bot->isDead()) return false;
+
+    Unit *pTarget = m_bot->GetSelectedUnit();
+    Unit *pVictim = NULL;
+    if (m_bot->GetSelectedUnit()->IsFriendlyTo(m_bot)) pTarget = NULL;
+    if (pTarget) pVictim = pTarget->getVictim();
+
+    //Defaults
+    if (!HasAuraName(m_bot,"Horn of Winter") )earth = STRENGTH_OF_EARTH_TOTEM;
+    if (!earth) earth = STONESKIN_TOTEM;
+    if (!earth) earth = EARTHBIND_TOTEM;
+    fire = TOTEM_OF_WRATH;
+    if (!fire) fire = FLAMETONGUE_TOTEM;
+    if (!fire) fire = SEARING_TOTEM;
+    water = MANA_SPRING_TOTEM;
+    if (!water) water = HEALING_STREAM_TOTEM;
+    if (TALENT_ELEMENTAL || TALENT_RESTO) air = WRATH_OF_AIR_TOTEM;
+    else air = WINDFURY_TOTEM;
+
+    //Target reactive stuff
+    if (pTarget)
+    {
+        if (GROUNDING_TOTEM && pTarget->IsNonMeleeSpellCasted(true)) air = GROUNDING_TOTEM;
+    }
+
+    if (STONESKIN_TOTEM && isUnderAttack()) earth = STONESKIN_TOTEM;
+
+    uint32 totz[4] = {earth, fire, water, air};
+
+    for (int i = 0; i < 4; i++)
+    {
+        if (!totz[i]) continue;
+        SpellEntry const *tSpell = GetSpellStore()->LookupEntry(totz[i]);
+        if (!tSpell) continue;
+        uint32 tEntry = (uint32) tSpell->EffectMiscValue[0];
+        if (!tEntry) continue;
+        CreatureInfo const *totemEntry = GetCreatureTemplateStore(tEntry);
+        if (!tEntry) continue;
+
+        if (CanCast(totz[i], m_bot) && !m_bot->FindNearestCreature(tEntry,30)) { return CastSpell(totz[i],m_bot,false); }
+    }
+    return false;
+}
+#pragma endregion
+#pragma region ChangeWeaponEnchants
+bool PlayerbotShamanAI::ChangeWeaponEnchants()
+{
+    uint32 mhEnch = 0, ohEnch = 0;
+
+    PlayerbotAI *ai = GetAI();
+    if(!ai) return false;
+    Player *m_bot = GetPlayerBot();
+    if(!m_bot || m_bot->isDead()) return false;
+
+
+    // Choose Weapon Enchant
+    if (TALENT_RESTO) { mhEnch = EARTHLIVING_WEAPON; }
+    else if (TALENT_ELEMENTAL){ mhEnch = FLAMETONGUE_WEAPON; }
+    else
+    {
+        if (WINDFURY_WEAPON)
+        {
+            mhEnch = WINDFURY_WEAPON;
+            if (m_bot->haveOffhandWeapon())
+            {
+                if (LAVA_LASH) ohEnch = FLAMETONGUE_WEAPON;
+                else ohEnch = WINDFURY_WEAPON;
+            }
+		}
+    else if (FLAMETONGUE_WEAPON)
+    {
+        mhEnch = FLAMETONGUE_WEAPON;
+        if (m_bot->haveOffhandWeapon()) ohEnch = FLAMETONGUE_WEAPON;
+    }
+
+    }
+
+    Item* weap;
+    uint32 enchant_id = 0;
+    SpellEntry const *tSpell;
+    bool castedsomething = false;
+
+    if (mhEnch)
+    {
+        weap = m_bot->GetWeaponForAttack(BASE_ATTACK);
+        if (weap)
+        {
+            tSpell = GetSpellStore()->LookupEntry(mhEnch);
+            if (tSpell && tSpell->EffectMiscValue[0] > 0)
+            {
+                enchant_id = (uint32) tSpell->EffectMiscValue[0];
+                if (enchant_id && weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) != enchant_id && sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+                {
+                    m_bot->ApplyEnchantment(weap,TEMP_ENCHANTMENT_SLOT, false); //Remove old enchantment effect
+                    weap->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, 1800 * 1000, 0); //Add for 30 mins
+                    m_bot->ApplyEnchantment(weap, TEMP_ENCHANTMENT_SLOT, true); //Add new effect
+                    castedsomething = true;
+                }
+            }
+        }
+    }
+
+    if (ohEnch)
+    {
+        weap = m_bot->GetWeaponForAttack(OFF_ATTACK);
+        if (weap)
+        {
+            tSpell = GetSpellStore()->LookupEntry(ohEnch);
+            if (tSpell && tSpell->EffectMiscValue[0] > 0)
+            {
+                enchant_id = (uint32) tSpell->EffectMiscValue[0];
+                if (enchant_id && weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) != enchant_id && sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+                {
+                    m_bot->ApplyEnchantment(weap,TEMP_ENCHANTMENT_SLOT, false); //Remove old enchantment effect
+                    weap->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, 1800 * 1000, 0); //Add for 30 mins
+                    m_bot->ApplyEnchantment(weap, TEMP_ENCHANTMENT_SLOT, true); //Add new effect
+                    castedsomething = true;
+                }
+            }
+        }
+    }
+    return castedsomething;
+
+}
+#pragma endregion
diff --git a/src/server/game/AI/Bots/PlayerbotShamanAI.h b/src/server/game/AI/Bots/PlayerbotShamanAI.h
new file mode 100644
index 0000000..e5fef23
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotShamanAI.h
@@ -0,0 +1,75 @@
+#ifndef _PLAYERBOTSHAMANAI_H
+#define _PLAYERBOTSHAMANAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotShamanAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotShamanAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotShamanAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, REBIRTHes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget (Unit *target);
+
+        bool ChangeTotems(uint32 mode);
+
+        bool ChangeWeaponEnchants();
+
+        /*//find any specific mount spells, ie druids=cat, shaman=ghost wolf etc
+        virtual bool FindMount();
+        virtual bool Unmount();
+        virtual bool IsMounted(); */
+
+    private:
+
+        //totems
+        uint32 HEALING_STREAM_TOTEM, MANA_SPRING_TOTEM, MANA_TIDE_TOTEM, CLEANSING_TOTEM, FIRE_RESISTANCE_TOTEM; //water
+        uint32 WINDFURY_TOTEM, WRATH_OF_AIR_TOTEM, GROUNDING_TOTEM, NATURE_RESISTANCE_TOTEM;  //air
+        uint32 STRENGTH_OF_EARTH_TOTEM, EARTHBIND_TOTEM, STONESKIN_TOTEM, STONECLAW_TOTEM, TREMOR_TOTEM, EARTH_ELEMENTAL_TOTEM ; //earth
+        uint32 FLAMETONGUE_TOTEM, TOTEM_OF_WRATH, SEARING_TOTEM, MAGMA_TOTEM, FIRE_ELEMENTAL_TOTEM, FROST_RESISTANCE_TOTEM; //fire
+        uint32 TOTEMIC_RECALL, CALL_OF_THE_ELEMENTS, CALL_OF_THE_ANCESTORS, CALL_OF_THE_SPIRITS;
+
+        //restoration
+        uint32 HEAL, LESSER_HEAL, CHAIN_HEAL, RIPTIDE, ANCESTRAL_SPIRIT, CLEANSE_SPIRIT;
+
+        //offensive spells
+        uint32 LIGHTNING_BOLT, CHAIN_LIGHTNING, FIRE_NOVA, THUNDERSTORM, LAVA_BURST, EARTH_SHOCK, WIND_SHEAR, FLAME_SHOCK, FROST_SHOCK, PURGE, HEX ;
+
+        //buffs
+        uint32 LIGHTNING_SHIELD, WATER_SHIELD, EARTH_SHIELD, HEROISM, ELEMENTAL_MASTERY, NATURES_SWIFTNESS,
+            WINDFURY_WEAPON, FLAMETONGUE_WEAPON, FROSTBRAND_WEAPON, ROCKBITER_WEAPON, EARTHLIVING_WEAPON,
+            WATER_BREATHING, WATER_WALKING ;
+
+        //mellee
+        uint32 LAVA_LASH, STORMSTRIKE, SHAMANISTIC_RAGE, FERAL_SPIRIT;
+
+        uint32 GHOST_WOLF;
+
+        //special
+        uint32 EXHAUSTION, SATED, MAELSTROM_WEAPON;
+
+        uint32 TALENT_ELEMENTAL, TALENT_ENHANCEMENT, TALENT_RESTO;
+
+};
+
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotWarlockAI.cpp b/src/server/game/AI/Bots/PlayerbotWarlockAI.cpp
new file mode 100644
index 0000000..96d3ad1
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotWarlockAI.cpp
@@ -0,0 +1,410 @@
+/*
+Name : PlayerbotWarlockAI.cpp
+Complete: maybe around 60%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - Curse checks are slow, later all curses should be looked up in one loop
+                - Need a function to lookup pet known spells for better pet handling
+                - Warlock do not summon other pets than Fel hunter/Imp
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+#include "PlayerbotWarlockAI.h"
+
+class PlayerbotAI;
+PlayerbotWarlockAI::PlayerbotWarlockAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotWarlockAI::~PlayerbotWarlockAI(){}
+
+void PlayerbotWarlockAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //CURSES
+    CURSE_OF_ELEMENTS = ai->getSpellIdExact("Curse of Elements");
+    CURSE_OF_WEAKNESS = ai->getSpellIdExact("Curse of Weakness");
+    CURSE_OF_AGONY = ai->getSpellIdExact("Curse of Agony");
+    CURSE_OF_RECKLESSNESS = ai->getSpellIdExact("Curse of Recklessness");
+    CURSE_OF_TONGUES = ai->getSpellIdExact("Curse of Tongues");
+    CURSE_OF_DOOM = ai->getSpellIdExact("Curse of Doom");
+    CURSE_OF_EXHAUSTION = ai->getSpellIdExact("Curse of Exhaustion");
+
+
+    //AFFLICTION
+    CORRUPTION = ai->getSpellIdExact("Corruption");
+    DRAIN_SOUL = ai->getSpellIdExact("Drain Soul");
+    DRAIN_LIFE = ai->getSpellIdExact("Drain Life");
+    DRAIN_MANA = ai->getSpellIdExact("Drain Mana");
+    SIPHON_LIFE = ai->getSpellIdExact("Siphon Life");
+    UNSTABLE_AFFLICTION = ai->getSpellIdExact("Unstable Affliction");
+    HAUNT = ai->getSpellIdExact("Haunt");
+    SEED_OF_CORRUPTION = ai->getSpellIdExact("Seed of Corruption");
+    DEATH_COIL = ai->getSpellIdExact("Death Coil");
+
+
+    //DESTRUCTION
+    SHADOW_BOLT = ai->getSpellIdExact("Shadow Bolt");
+    IMMOLATE = ai->getSpellIdExact("Immolate");
+    INCINERATE = ai->getSpellIdExact("Incinerate");
+    SEARING_PAIN = ai->getSpellIdExact("Searing Pain");
+    CONFLAGRATE = ai->getSpellIdExact("Conflagrate");
+    SOUL_FIRE = ai->getSpellIdExact("Soul Fire");
+    SHADOWBURN = ai->getSpellIdExact("Shadowburn");
+    SHADOWFURY = ai->getSpellIdExact("Shadowfury");
+    CHAOS_BOLT = ai->getSpellIdExact("Chaos Bolt");
+    SHADOWFLAME = ai->getSpellIdExact("Shadowflame");
+    RAIN_OF_FIRE = ai->getSpellIdExact("Rain of Fire");
+    HELLFIRE = ai->getSpellIdExact("Hellfire");
+
+
+    //DEMONOLOGY
+    DEMON_ARMOR = ai->getSpellIdExact("Demon Armor");
+    if (!DEMON_ARMOR) DEMON_ARMOR = ai->getSpellIdExact("Demon Skin");
+    FEL_ARMOR = ai->getSpellIdExact("Fel Armor");
+    SOULSHATTER = ai->getSpellIdExact("Soulshatter");
+    HEALTH_FUNNEL = ai->getSpellIdExact("Health Funnel");
+    DARK_PACT = ai->getSpellIdExact("Dark Pact");
+    SOUL_LINK = ai->getSpellIdExact("Soul Link");
+    DEMONIC_EMPOWERMENT = ai->getSpellIdExact("Demonic Empowerment");
+    METAMORPHOSIS = ai->getSpellIdExact("Metamorphosis"); //Original is learn spell
+    SUMMON_IMP = ai->getSpellIdExact("Summon Imp");
+    SUMMON_VOIDWALKER = ai->getSpellIdExact("Summon Voidwalker");
+    SUMMON_SUCCUBUS = ai->getSpellIdExact("Summon Succubus");
+    SUMMON_FELHUNTER = ai->getSpellIdExact("Summon Felhunter");
+    SUMMON_FELGUARD = ai->getSpellIdExact("Summon Felguard");
+
+
+    //CC
+    FEAR = ai->getSpellIdExact("Fear");
+    HOWL_OF_TERROR = ai->getSpellIdExact("Howl of Terror");
+    BANISH = ai->getSpellIdExact("Banish");
+    ENSLAVE_DEMON = ai->getSpellIdExact("Enslave Demon");
+
+
+    //Buff
+    UNENDING_BREATH = ai->getSpellIdExact("Unending Breath");
+    DETECT_INVISIBILITY = ai->getSpellIdExact("Detect Invisibility");
+    SHADOW_WARD = ai->getSpellIdExact("Shadow Ward");
+
+
+    //Other
+    LIFE_TAP = ai->getSpellIdExact("Life Tap");
+    CREATE_SOULSTONE = ai->getSpellIdExact("Create Soulstone");
+
+
+    SOUL_SHARD = 6265; //Soul Shard Item id
+    P_BACKLASH = 34936; //Backlash proc
+    P_NIGHTFALL= 17941; //Nightfall proc
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_DEMONOLOGY = SUMMON_FELGUARD;
+    TALENT_AFFLICTION = UNSTABLE_AFFLICTION;
+    TALENT_DESTRUCTION = CONFLAGRATE;
+
+    uint8 talentCounter = 0;
+    if (TALENT_DEMONOLOGY) talentCounter++;
+    if (TALENT_AFFLICTION) talentCounter++;
+    if (TALENT_DESTRUCTION) talentCounter++;
+    if (talentCounter > 1) { TALENT_DEMONOLOGY = 0; TALENT_AFFLICTION = 0; TALENT_DESTRUCTION = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotWarlockAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    if (m_tank->GetGUID() == m_bot->GetGUID() && pet && pet->isAlive() && pet->isInCombat()) { m_tank = pet; }
+    uint8 petThreat = 0;
+    if (pet) { GetThreatPercent(pTarget,pet); }
+
+    /*switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            if(SHADOW_BOLT > 0) CastSpell(SHADOW_BOLT);
+            return;
+    }*/
+
+    //------- Non Duel combat ----------
+
+    //ai->Follow(*GetMaster()); //don't want to melee mob
+
+    #pragma region Choose Target
+    // Choose actions accoring to talents (WARLOCK is always ranged dps)
+    m_role = BOT_ROLE_DPS_RANGED;
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(SOULSHATTER,m_bot)) { return; }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+
+    #pragma endregion
+
+    #pragma region Pet Actions
+    // Pet's own Actions
+    if( pet && pet->isAlive() )
+    {
+        // Setup pet
+        if (pet->GetCharmInfo()->IsAtStay()) {pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW); }
+        //if (pet->HasSpell(BLOOD_PACT) && ); //Cast Blood Pact
+
+        if ( ( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        && ( HEALTH_FUNNEL>0 && !pet->getDeathState() != ALIVE && pVictim != m_bot
+        && CastSpell(HEALTH_FUNNEL,m_bot) )) { return; } //Heal pet
+
+        // Set pet to attack warlock's attacker > its own attackers > warlock's target
+        if (!pet->getVictim()) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(m_bot)) { pet->AI()->AttackStart(pTarget); }  //Always help warlock if he's under attack
+        else if (pet->getVictim()->GetGUID() != pTarget->GetGUID() && !isUnderAttack(pet)) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(pet)) // Pet is under attack and warlock has no attackers
+        {
+            if ( pet->getVictim()->getVictim() && pet->getVictim()->getVictim()->GetGUID() == pet->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(pet,true);
+                if (curAtt && (!pet->getVictim() || curAtt->GetGUID() != pet->getVictim()->GetGUID()))
+                {
+                    pet->AI()->AttackStart(curAtt); //Attack nearest attacker
+                }
+            }
+            //Actions to do under attack (Always tank it, and try to kill it, until someone (!= warlock) takes aggro back)
+            //Warlock should help her pet whether main tank or not, unless he's being attacked (BEWARE Targeting Loop possibility)
+            if (pet->getVictim() && !isUnderAttack(m_bot) && pet->getVictim()->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(pet->getVictim()->GetGUID());
+                DoNextCombatManeuver(pet->getVictim()); //Restart new update to get variables fixed..
+                return;
+            }
+
+        }
+        // Pet tanking behaviour
+        if (pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot) || isUnderAttack(pet))
+        {
+            //need pet tanking spells
+            //if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,true); //Autocast growl
+        }
+        else
+        {
+            //if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,false); //Do not try to get aggro
+        }
+        // NORMAL PET dps attacks
+        if (petThreat < threatThreshold || pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot))
+        {
+            //if (CastSpell(KILL_COMMAND,m_bot)) { }
+        }
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    //Buff
+    if (isUnderAttack()) { if (CastSpell (DEMON_ARMOR, m_bot)) { return; } }
+    else if (FEL_ARMOR) { if (CastSpell(FEL_ARMOR,m_bot)) { return; } }
+    else if (CastSpell(DEMON_ARMOR, m_bot)) { return; }
+    if (CastSpell(METAMORPHOSIS,m_bot)) { return; }
+    if (CastSpell(DEMONIC_EMPOWERMENT,m_bot)) { return; }
+
+    //Protect
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (CastSpell(SOULSHATTER, m_bot)) { return; }
+        if (pTarget->GetCreatureType() == CREATURE_TYPE_DEMON && CastSpell(BANISH,pTarget)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (isUnderAttack() && CastSpell(FEAR, pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(HOWL_OF_TERROR, pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(SHADOWFURY, pTarget)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    //Void Walker shield?
+    if (ai->GetHealthPercent() < 70 && CastSpell(DEATH_COIL,pTarget)) { return; }
+    if (ai->GetHealthPercent() < 70 && CastSpell(DRAIN_LIFE,pTarget)) { return; }
+    if (ai->GetManaPercent() < 70 && ai->GetManaPercent(*pTarget) > 10 && CastSpell(DRAIN_MANA,pTarget)) { return; }
+    if (ai->GetManaPercent() < 50 && pet && ai->GetManaPercent(*pet) > 50 && CastSpell(DARK_PACT,pet,1,0,1)) { return; }
+    if (ai->GetManaPercent() < 30 && ai->GetHealthPercent() > 60 && CastSpell(LIFE_TAP,m_bot,1,0,1)) { return; }
+    //Use Health stone
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(CURSE_OF_TONGUES, pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(CURSE_OF_EXHAUSTION,pTarget)) return;
+    }
+
+    // Threat control
+    if (pThreat < threatThreshold || m_tank->GetGUID() == m_bot->GetGUID() ) { } //Continue attack
+    else
+    {
+        if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+        {
+            m_bot->SetSelection(pet->getVictim()->GetGUID());
+            return;
+        }
+        else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else if (CastSpell(SOULSHATTER,m_bot)) { return; }
+        else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+        else { return; } // No more threat reducing spells, just slow down
+    }
+
+
+
+    //Urgent DPS
+    if ((m_bot->HasAura(P_NIGHTFALL) || m_bot->HasAura(P_BACKLASH)) && CastSpell(SHADOW_BOLT,pTarget)) { return; }
+    if (INCINERATE && pTarget->HasAura(IMMOLATE,m_bot->GetGUID()) && CastSpell(INCINERATE,pTarget)) { return; }
+    if (CONFLAGRATE && (pTarget->HasAura(IMMOLATE,m_bot->GetGUID()) || pTarget->HasAura(SHADOWFLAME,m_bot->GetGUID())) && CastSpell(CONFLAGRATE,pTarget)) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) < 2 && CastSpell(SHADOWBURN,pTarget)) { return; }
+    if (ai->GetHealthPercent(*pTarget) < 5 && m_bot->GetItemCount(SOUL_SHARD) < 20 && CastSpell(DRAIN_SOUL,pTarget)) { return; }
+
+    //Dps up
+    if (ai->GetHealthPercent(*pTarget) > 95) { return; } // dont dps too early
+
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+    if (CastSpell(HAUNT,pTarget)) { return; }
+
+    //AOE
+    if (isUnderAttack(m_tank,4) && CastSpell(SHADOWFLAME,pTarget)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(RAIN_OF_FIRE,pTarget)) { return; }
+
+    //Dps Main
+    if(CURSE_OF_ELEMENTS) { if (!CheckCurse(pTarget) && CastSpell(CURSE_OF_ELEMENTS, pTarget)) { return; } } //curse of elements trumps any other curses
+    else if (CURSE_OF_AGONY) { if (!CheckCurse(pTarget) && CastSpell(CURSE_OF_AGONY, pTarget)) { return; } }
+
+    if (SEED_OF_CORRUPTION && isUnderAttack(m_tank,4)) { if (CastSpell(SEED_OF_CORRUPTION,pTarget)) { return;} }
+    else if (CastSpell(CORRUPTION,pTarget)) { return; }
+
+    if (CastSpell(CHAOS_BOLT,pTarget)) { return; }
+
+    if (UNSTABLE_AFFLICTION) { if (CastSpell(UNSTABLE_AFFLICTION,pTarget)) { return; } }
+    else if (CastSpell(IMMOLATE,pTarget)) { return; }
+
+    if (CastSpell(SHADOW_BOLT,pTarget)) { return; }
+
+
+
+
+    //Use healthstone??
+    // drink poition
+    if(ai->GetManaPercent() < 5 )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+} //end DoNextCombatManeuver
+
+void PlayerbotWarlockAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot,30,0,0,0,0,1)) { return; }
+
+    //Own Buffs
+    if (CastSpell (FEL_ARMOR, m_bot)) { return; }
+    if (!FEL_ARMOR && CastSpell(DEMON_ARMOR, m_bot)) { return; }
+    if (SOUL_LINK && m_bot->GetPet() && !m_bot->HasAuraType(SPELL_AURA_SPLIT_DAMAGE_PCT) && CastSpell(SOUL_LINK,m_bot)) { return; }
+
+    if(m_bot->GetPet() == NULL) {
+        if (SUMMON_FELGUARD)
+            CastSpell(SUMMON_FELGUARD, m_bot);
+        else
+            CastSpell(SUMMON_IMP, m_bot);
+    } else {
+    m_bot->GetPet()->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+    m_bot->GetPet()->GetCharmInfo()->SetIsCommandAttack(false);
+    }
+
+    //Create Healthstone?
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 && ai->GetHealthPercent() > 60 && CastSpell (LIFE_TAP, m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 || ai->GetHealthPercent() < 50) { ai->Feast(); }
+
+
+} //end DoNonCombatActions
+
+bool PlayerbotWarlockAI::BuffPlayer(Unit *target)
+{
+    if (!target || target->isDead()) return false;
+
+    if (!HasAuraName(target, DETECT_INVISIBILITY) && CastSpell(DETECT_INVISIBILITY, target)) { return true; }
+    if (!HasAuraName(target, UNENDING_BREATH) && CastSpell(UNENDING_BREATH, target)) { return true; }
+    return false;
+}
+
+uint32 PlayerbotWarlockAI::CheckCurse(Unit *target)
+{
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead() || !target || target->isDead() ) { return 0; }
+    uint64 mGuid = m_bot->GetGUID();
+
+    if (CURSE_OF_ELEMENTS && target->HasAura(CURSE_OF_ELEMENTS,mGuid)) { return CURSE_OF_ELEMENTS; }
+    if (CURSE_OF_AGONY && target->HasAura(CURSE_OF_AGONY,mGuid)) { return CURSE_OF_AGONY; }
+    if (CURSE_OF_TONGUES && target->HasAura(CURSE_OF_TONGUES,mGuid)) { return CURSE_OF_TONGUES; }
+    if (CURSE_OF_WEAKNESS && target->HasAura(CURSE_OF_WEAKNESS,mGuid)) { return CURSE_OF_WEAKNESS; }
+    if (CURSE_OF_DOOM && target->HasAura(CURSE_OF_DOOM,mGuid)) { return CURSE_OF_DOOM; }
+    if (CURSE_OF_RECKLESSNESS && target->HasAura(CURSE_OF_RECKLESSNESS,mGuid)) { return CURSE_OF_RECKLESSNESS; }
+    if (CURSE_OF_EXHAUSTION && target->HasAura(CURSE_OF_EXHAUSTION,mGuid)) { return CURSE_OF_EXHAUSTION; }
+    return 0;
+}
+
+//void PlayerbotWarlockAI::BuffPlayer(Player *target){}
+
diff --git a/src/server/game/AI/Bots/PlayerbotWarlockAI.h b/src/server/game/AI/Bots/PlayerbotWarlockAI.h
new file mode 100644
index 0000000..6904261
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotWarlockAI.h
@@ -0,0 +1,57 @@
+#ifndef _PlayerbotWarlockAI_H
+#define _PlayerbotWarlockAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotWarlockAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotWarlockAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotWarlockAI();
+
+        virtual void LoadSpells();
+
+    //all combat actions go here
+    void DoNextCombatManeuver(Unit *);
+
+    //all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    //buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Unit *target);
+
+    uint32 CheckCurse(Unit *target);
+
+  private:
+    //CURSES
+    uint32 CURSE_OF_ELEMENTS, CURSE_OF_WEAKNESS, CURSE_OF_AGONY, CURSE_OF_RECKLESSNESS, CURSE_OF_TONGUES, CURSE_OF_DOOM, CURSE_OF_EXHAUSTION;
+
+    //AFFLICTION
+    uint32 CORRUPTION, DRAIN_SOUL, DRAIN_LIFE, DRAIN_MANA, SIPHON_LIFE, UNSTABLE_AFFLICTION, HAUNT, SEED_OF_CORRUPTION, DEATH_COIL;
+
+    //DESTRUCTION
+    uint32 SHADOW_BOLT, IMMOLATE, INCINERATE, SEARING_PAIN, CONFLAGRATE, SOUL_FIRE, SHADOWBURN, SHADOWFURY, CHAOS_BOLT, SHADOWFLAME, RAIN_OF_FIRE, HELLFIRE;
+
+    //DEMONOLOGY
+    uint32 DEMON_ARMOR, FEL_ARMOR, SOULSHATTER, HEALTH_FUNNEL, DARK_PACT, SOUL_LINK, DEMONIC_EMPOWERMENT, METAMORPHOSIS, SUMMON_IMP, SUMMON_VOIDWALKER, SUMMON_SUCCUBUS, SUMMON_FELHUNTER, SUMMON_FELGUARD;
+
+    //CC
+    uint32 FEAR, HOWL_OF_TERROR, BANISH, ENSLAVE_DEMON;
+
+    //Buff
+    uint32 UNENDING_BREATH, DETECT_INVISIBILITY, SHADOW_WARD;
+
+    //Other
+    uint32 LIFE_TAP, CREATE_SOULSTONE;
+
+    //Special
+    uint32 SOUL_SHARD, P_BACKLASH, P_NIGHTFALL, SHOOT;
+
+    uint32 TALENT_DEMONOLOGY, TALENT_AFFLICTION, TALENT_DESTRUCTION;
+};
+
+#endif
+
+
diff --git a/src/server/game/AI/Bots/PlayerbotWarriorAI.cpp b/src/server/game/AI/Bots/PlayerbotWarriorAI.cpp
new file mode 100644
index 0000000..29ad3ad
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotWarriorAI.cpp
@@ -0,0 +1,400 @@
+/*
+Name : PlayerbotWarrior.cpp
+Complete: maybe around 75%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is Blood dps/offtank type
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Situations needing Intervene casting : limited / non-existant..
+                - Intervene / Piercing Howl / Hamstring are not used..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotWarriorAI.h"
+
+class PlayerbotAI;
+PlayerbotWarriorAI::PlayerbotWarriorAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotWarriorAI::~PlayerbotWarriorAI(){}
+
+void PlayerbotWarriorAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+   #pragma region SpellId Fill
+    //Defensive Stance
+    SHIELD_WALL = ai->getSpellIdExact("Shield Wall");
+    REVENGE = ai->getSpellIdExact("Revenge");
+    SHIELD_BLOCK = ai->getSpellIdExact("Shield Block");
+    DISARM = ai->getSpellIdExact("Disarm");
+    INTERVENE = ai->getSpellIdExact("Intervene");
+
+    //Berserker Stance
+    RECKLESSNESS = ai->getSpellIdExact("Recklessness");
+    WHIRLWIND = ai->getSpellIdExact("Whirlwind");
+    PUMMEL = ai->getSpellIdExact("Pummel");
+    INTERCEPT = ai->getSpellIdExact("Intercept");
+
+    //Battle Stance
+    RETALIATION = ai->getSpellIdExact("Retaliation");
+    CHARGE = ai->getSpellIdExact("Charge");
+    OVERPOWER = ai->getSpellIdExact("Overpower");
+    SHATTERING_THROW = ai->getSpellIdExact("Shattering Throw");
+
+    //Mixed Attacks
+    REND = ai->getSpellIdExact("Rend");                                // 1 2
+    THUNDER_CLAP = ai->getSpellIdExact("Thunder Clap");
+    SPELL_REFLECTION = ai->getSpellIdExact("Spell Reflection");
+    SHIELD_BASH = ai->getSpellIdExact("Shield Bash");
+    EXECUTE = ai->getSpellIdExact("Execute");                        // 1 3
+    HAMSTRING = ai->getSpellIdExact("Hamstring");
+    SWEEPING_STRIKES = ai->getSpellIdExact("Sweeping Strikes");
+    VICTORY_RUSH = ai->getSpellIdExact("Victory Rush");
+
+
+    //General attacks
+    HEROIC_STRIKE = ai->getSpellIdExact("Heroic Strike");
+    MORTAL_STRIKE = ai->getSpellIdExact("Mortal Strike");
+    BLOODTHIRST = ai->getSpellIdExact("Bloodthirst");
+    SHIELD_SLAM = ai->getSpellIdExact("Shield Slam");
+    SHOCKWAVE = ai->getSpellIdExact("Shockwave");
+    SLAM = ai->getSpellIdExact("Slam");
+    CLEAVE = ai->getSpellIdExact("Cleave");
+    BLADESTORM = ai->getSpellIdExact("Bladestorm");
+    HEROIC_THROW = ai->getSpellIdExact("Heroic Throw");
+    CONCUSSION_BLOW = ai->getSpellIdExact("Concussion Blow");
+    SUNDER_ARMOR = ai->getSpellIdExact("Sunder Armor");
+    DEMORALIZING_SHOUT = ai->getSpellIdExact("Demoralizing Shout");
+    INTIMIDATING_SHOUT = ai->getSpellIdExact("Intimidating Shout");
+    PIERCING_HOWL = ai->getSpellIdExact("Piercing Howl");
+    DEVASTATE = ai->getSpellIdExact("Devastate");
+
+
+    //buffs
+    COMMANDING_SHOUT = ai->getSpellIdExact("Commanding Shout");
+    BATTLE_SHOUT = ai->getSpellIdExact("Battle Shout");
+    VIGILANCE = ai->getSpellIdExact("Vigilance");
+    BERSERKER_RAGE = ai->getSpellIdExact("Berserker Rage");
+    ENRAGED_REGENERATION = ai->getSpellIdExact("Enraged Regeneration");
+    BLOODRAGE = ai->getSpellIdExact("Bloodrage");
+    LAST_STAND = ai->getSpellIdExact("Last Stand");
+    HEROIC_FURY = ai->getSpellIdExact("Heroic Fury");
+    DEATH_WISH = ai->getSpellIdExact("Death Wish");
+
+
+    //Stances
+    DEFENSIVE_STANCE = ai->getSpellIdExact("Defensive Stance");
+    BATTLE_STANCE = ai->getSpellIdExact("Battle Stance");
+    BERSERKER_STANCE = ai->getSpellIdExact("Berserker Stance");
+
+
+    //Taunts
+    TAUNT = ai->getSpellIdExact("Taunt");
+    CHALLENGING_SHOUT = ai->getSpellIdExact("Challenging Shout");
+    MOCKING_BLOW = ai->getSpellIdExact("Mocking Blow");
+
+    //Special
+    SLAMM = 46916; //Instant Slam (Blood Surge)
+
+    TALENT_ARMS = MORTAL_STRIKE;
+    TALENT_FURY = BLOODTHIRST;
+    TALENT_PROT = DEVASTATE;
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    uint8 talentCounter = 0;
+    if (TALENT_ARMS) talentCounter++;
+    if (TALENT_FURY) talentCounter++;
+    if (TALENT_PROT) talentCounter++;
+    if (talentCounter > 1) { TALENT_ARMS = 0; TALENT_FURY = 0; TALENT_PROT = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotWarriorAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    if (!m_pulling){
+        #pragma region Choose Role / Stance
+
+        m_role = BOT_ROLE_DPS_MELEE;
+
+        // Choose Stance
+        if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+        {
+            if (ChangeStance(DEFENSIVE_STANCE)) { m_role = BOT_ROLE_TANK; return; }  //m_bot->GetShield(true)
+        }
+        else if (isUnderAttack()) // I am under attack
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2)  {} // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CanCast(R_SHADOWMELD,m_bot) && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+            if (m_bot->GetShield(true)) { if (ChangeStance(DEFENSIVE_STANCE)) { m_role = BOT_ROLE_OFFTANK; return; } }
+            else if (ChangeStance(BATTLE_STANCE)) { return; }
+        }
+        else if (ai->GetHealthPercent() > 90)
+        {
+            if (ChangeStance(BERSERKER_STANCE)) { return; }
+        }
+        else if (ai->GetForm() != FORM_BERSERKERSTANCE || ai->GetHealthPercent() < 70 ) { if (ChangeStance(BATTLE_STANCE)) { return; } }
+        #pragma endregion
+    }
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[7] = { HEROIC_FURY, BERSERKER_RAGE, BLADESTORM, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    TakePosition(pTarget);
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    if (m_pulling) {
+        if (GetAI()->CastSpell(SHOOT,pTarget)) {
+            m_pulling = false;
+            GetAI()->SetCombatOrder(ORDERS_NONE);
+            GetAI()->Follow(*GetMaster());
+            GetAI()->SetIgnoreUpdateTime(2);
+         }
+          return;
+    }
+
+    #pragma region Buff Heal Interrupt
+    //Buff UP
+    if (!m_bot->HasAura(BATTLE_SHOUT) && CastSpell(BATTLE_SHOUT,m_bot)) { return; }
+    if (!m_bot->HasAura(BATTLE_SHOUT,m_bot->GetGUID()) && !m_bot->HasAura(COMMANDING_SHOUT) && CastSpell(COMMANDING_SHOUT,m_bot)) { return; }
+
+
+    //HEAL UP && PROTECT UP
+    if (ai->GetHealthPercent() <= 85 && CastSpell(SHIELD_BLOCK, m_bot)) { } //no GCD
+    if (ai->GetHealthPercent() <= 45 && CastSpell(SHIELD_WALL, m_bot)) { return; }
+    if (ai->GetHealthPercent() < 55 &&
+        (m_bot->HasAura(BERSERKER_RAGE) || m_bot->HasAura(BLOODRAGE) || m_bot->HasAura(DEATH_WISH)) //There are other spells that count as enrage
+        && CastSpell(ENRAGED_REGENERATION,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 25 && CastSpell(INTIMIDATING_SHOUT, m_bot)) { return; }
+    if (ai->GetHealthPercent() <= 75 && CastSpell(LAST_STAND, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+
+    //Break spells being cast
+    if (pTarget->IsNonMeleeSpellCasted(true))
+    {
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && CastSpell(SPELL_REFLECTION,pTarget)) { return; }
+        if (m_bot->HasAura(SPELL_REFLECTION))
+        {
+            if (CastSpell(SHIELD_BASH,pTarget)) {} // No GCD
+            else if (CastSpell(PUMMEL,pTarget)) { return; }
+            else if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+        }
+    }
+    #pragma endregion
+
+    #pragma region Taunt / Threat
+    // if i am main tank, protect master by taunt
+    if(m_tank->GetGUID() == m_bot->GetGUID())
+    {
+        // Taunt if needed (Only for master)
+        Unit *curAtt = GetAttackerOf(GetMaster());
+        if (curAtt)
+        {
+            if (isUnderAttack(GetMaster(),2) && CastSpell(CHALLENGING_SHOUT, curAtt)) { return; }
+            if (CastSpell(TAUNT, curAtt,true,true))  { return; }
+            if (CastSpell(VIGILANCE, GetMaster())) { return; }
+            if (CastSpell(TAUNT, curAtt))  { return; }
+            if (CastSpell(MOCKING_BLOW, curAtt)) { return; }
+        }
+        // My target is not attacking me, taunt..
+        if (pVictim && pVictim->GetGUID() != m_bot->GetGUID())
+        {
+            if (CastSpell(VIGILANCE, pVictim)) { return; }
+            if (CastSpell(TAUNT, pTarget))  { return; }
+            if (CastSpell(MOCKING_BLOW, pTarget)) { return; }
+        }
+    }
+
+    // If not in Defensive Stance slow down due to threat
+    if (pThreat > threatThreshold && ai->GetForm() != FORM_DEFENSIVESTANCE && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else { return; } //Warrior has no threat reducing spells, just slow down
+    }
+    #pragma endregion
+
+    #pragma region Dps
+
+    //Ranged Stuff (Openers)
+    if (CastSpell(CHARGE,pTarget)) { } //no GCD
+    else if (CastSpell(INTERCEPT,pTarget)) { } //no GCD
+    if (pDist > MELEE_RANGE && ai->GetForm() == FORM_DEFENSIVESTANCE && CastSpell(HEROIC_THROW,pTarget)) { return; } //High threat
+    if (pDist > MELEE_RANGE && CastSpell(SHATTERING_THROW,pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(HAMSTRING,pTarget)) return;
+        if (CastSpell(PIERCING_HOWL,pTarget)) return;
+    }
+
+
+    //Dps up
+    if (ai->GetHealthPercent() > 90 && ai->GetRageAmount() < 20 && CastSpell(BLOODRAGE,m_bot))  { return; }
+    if (isUnderAttack() && CastSpell(RETALIATION,m_bot)) { return; }
+    if (ai->GetHealthPercent() > 90 && CastSpell(DEATH_WISH,m_bot)) { return; }
+    if (ai->GetHealthPercent() > 80 && CastSpell(RECKLESSNESS,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    //Tank only stuff
+    if ((ai->GetForm() == FORM_DEFENSIVESTANCE || ai->GetRageAmount() > 85) && CastSpell(THUNDER_CLAP)) { return; } //High threat
+    if ((ai->GetForm() == FORM_DEFENSIVESTANCE || ai->GetRageAmount() > 75) && CastSpell(HEROIC_STRIKE)) {} //nogcd high threat
+
+    //Finishing Move / Timed moves
+    if (ai->GetHealthPercent(*pTarget) < 20 && CastSpell(EXECUTE,pTarget)) { return; }
+    if (CastSpell(VICTORY_RUSH,pTarget)) { return; }
+
+    //AOE
+    if (CastSpell(SHOCKWAVE,pTarget)) { return; }
+    if ((isUnderAttack(m_tank,3) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(CLEAVE,pTarget)) {} //no GCD
+    if (isUnderAttack(m_tank,3) && CastSpell(SWEEPING_STRIKES,m_bot)) {} //no GCD
+    if (isUnderAttack(m_tank,4) && CastSpell(BLADESTORM,m_bot)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(WHIRLWIND,pTarget)) { return; }
+
+    //Main dps
+    if (m_bot->HasAura(SLAMM) && CastSpell(SLAM,pTarget)) { return; }  //instant slam only
+    if (CastSpell(REVENGE,pTarget)) { return; } //Def stance only
+    if (CastSpell(OVERPOWER,pTarget)) { return; }
+    if (CastSpell(SHIELD_SLAM,pTarget)) { return; }
+    if (CastSpell(BLOODTHIRST,pTarget)) { return; }
+    if (CastSpell(MORTAL_STRIKE,pTarget)) { return; }
+
+
+    //Support/Debuff
+    if (CastSpell(DEMORALIZING_SHOUT,pTarget)) { return; }
+    if (DEVASTATE) { if (CastSpell(DEVASTATE,pTarget,1,1)) { return; } }  //High threat
+    else if (CastSpell(SUNDER_ARMOR)) { return; } //Only 1 - High threat
+    if (CastSpell(CONCUSSION_BLOW,pTarget)) { return; }
+    if (CastSpell(REND,pTarget)) { return; }
+    if (CastSpell(DISARM,pTarget)) { return; }
+    #pragma endregion
+
+} //end DoNextCombatManeuver
+
+void PlayerbotWarriorAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff Up
+    if (!m_bot->HasAura(BATTLE_SHOUT) && CastSpell(BATTLE_SHOUT,m_bot)) { return; }
+    if (!m_bot->HasAura(BATTLE_SHOUT,m_bot->GetGUID()) && !m_bot->HasAura(COMMANDING_SHOUT) && CastSpell(COMMANDING_SHOUT,m_bot)) { return; }
+
+    if (GetMaster()->isAlive() && CastSpell(VIGILANCE, GetMaster())) { return; }
+
+    //want to start off in battle stance so we can CHARGE
+    //if(ai->GetRageAmount() < 20 && ai->GetForm() != FORM_BATTLESTANCE && ChangeStance(BATTLE_STANCE)) { return; }
+
+    //mana/hp check
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 75) { ai->Feast(); }
+} //end DoNonCombatActions
+
+bool PlayerbotWarriorAI::ChangeStance(uint32 stance)
+{
+    if (stance == 0) return false;
+    if (CastSpell(stance, GetPlayerBot())) { return true; }
+    return false;
+}
+
+void PlayerbotWarriorAI::Pull()
+{
+    if (!SHOOT) return;
+
+    // check ammo
+    uint32 ammo_id = GetPlayerBot()->GetUInt32Value(PLAYER_AMMO_ID);
+    if (!ammo_id) {
+        GetPlayerBot()->Say("I'm out of ammo.", LANG_UNIVERSAL);
+        return;
+    }
+
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        m_pulling = false;
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+}
+
+/*
+void PlayerbotWarriorAI::BreakCC(const uint32 diff)
+{
+    if(pvpTrinket_cd < diff && GCD < diff)
+    {
+        if(m_creature->HasAuraType(SPELL_AURA_MOD_ROOT) ||
+        m_creature->HasAuraType(SPELL_AURA_MOD_CONFUSE) || //dragons breath/blind/poly
+        m_creature->HasAura(8983)                       || //Druid bash rank 3
+        m_creature->HasAura(27006)                      || //Druid pounce rank 4
+        m_creature->HasAura(33786)                      || //Druid cyclone
+        m_creature->HasAura(22570, 1)                   || //Druid maim
+        m_creature->HasAura(10308)                      || //Paladin hammer of justice rank 4
+        m_creature->HasAura(30414, 1)                   || //Warlock shadowfury rank 3
+        m_creature->HasAura(6215)                       || //Warlock fear rank 3 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(17928)                      || //Warlock howlofterror rank 3 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(10890)                      || //Priest psychic scream rank 4 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(14902)                      || //Rogue Cheap shot
+        m_creature->HasAura(8643)                       || //Rogue Kidney shot Rank 2
+        m_creature->HasAura(38764, 2)                   || //Rogue Gouge Rank 6 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(12809))                        //Warrior concussion blow
+        {
+            doCast(m_creature, PVPTRINKET); //I think it would be better to instead of applying individual spells that apply the
+            pvpTrinket_cd = PVPTRINKET_CD;  //effect SPELL_AURA_MOD_STUN, just add that type and start removing bad choices e.g. impact.
+        }
+
+        if(m_creature->HasAura(11297) && m_creature->GetDistance(m_creature->getVictim()) < 10)
+        {      //if warrior sapped and creature is less then 10 yards from war, cast pvp trinket and attempt to demo shout him out of stealth
+            doCast(m_creature, PVPTRINKET);
+            pvpTrinket_cd = PVPTRINKET_CD;
+            castDemoralizingShout = true;
+        }
+    }
+} //BreakCC
+*/
diff --git a/src/server/game/AI/Bots/PlayerbotWarriorAI.h b/src/server/game/AI/Bots/PlayerbotWarriorAI.h
new file mode 100644
index 0000000..87ab4a8
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotWarriorAI.h
@@ -0,0 +1,57 @@
+#ifndef _PLAYERBOTWARRIORAI_H
+#define _PLAYERBOTWARRIORAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotWarriorAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotWarriorAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotWarriorAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        virtual void Pull();
+
+    private:
+        //Defensive Stance
+        uint32 SHIELD_WALL, REVENGE, SHIELD_BLOCK, DISARM, INTERVENE;
+
+        //Berserker Stance
+        uint32 RECKLESSNESS, WHIRLWIND, PUMMEL, INTERCEPT;
+
+        //Battle Stance
+        uint32 RETALIATION, CHARGE, OVERPOWER, SHATTERING_THROW;
+
+        //Mixed Attacks                                              //1 3
+        uint32 REND, THUNDER_CLAP, SPELL_REFLECTION, SHIELD_BASH, EXECUTE, HAMSTRING, SWEEPING_STRIKES, VICTORY_RUSH;
+
+        //General attacks
+        uint32 HEROIC_STRIKE, MORTAL_STRIKE, BLOODTHIRST, SHIELD_SLAM, SHOCKWAVE, SLAM, CLEAVE, BLADESTORM, HEROIC_THROW, CONCUSSION_BLOW, SUNDER_ARMOR, DEMORALIZING_SHOUT, INTIMIDATING_SHOUT, PIERCING_HOWL, DEVASTATE;
+
+        //buffs
+        uint32 COMMANDING_SHOUT, BATTLE_SHOUT, VIGILANCE, BERSERKER_RAGE, ENRAGED_REGENERATION, BLOODRAGE, LAST_STAND, HEROIC_FURY, DEATH_WISH;
+
+        //Stances
+        uint32 DEFENSIVE_STANCE, BATTLE_STANCE, BERSERKER_STANCE;
+
+        //Taunts
+        uint32 TAUNT, CHALLENGING_SHOUT, MOCKING_BLOW;
+
+        //Special
+        uint32 SLAMM;
+
+        uint32 TALENT_ARMS, TALENT_FURY, TALENT_PROT;
+
+        bool ChangeStance(uint32 stance);
+
+
+};
+
+#endif
diff --git a/src/server/game/AI/CoreAI/PetAI.cpp b/src/server/game/AI/CoreAI/PetAI.cpp
index ac142db..81d9bfe 100755
--- a/src/server/game/AI/CoreAI/PetAI.cpp
+++ b/src/server/game/AI/CoreAI/PetAI.cpp
@@ -46,6 +46,7 @@ PetAI::PetAI(Creature *c) : CreatureAI(c), i_tracker(TIME_INTERVAL_LOOK)
 
 void PetAI::EnterEvadeMode()
 {
+    if(me->GetIAmABot() && me->GetBotAI()) me->GetBotAI()->EnterEvadeMode();
 }
 
 bool PetAI::_needToStop()
@@ -83,6 +84,12 @@ void PetAI::UpdateAI(const uint32 diff)
     if (!me->isAlive())
         return;
 
+    if(me->GetIAmABot())
+    {
+        //don't do anything if eating or drinking, otherwise call UpdateAI
+        if(!me->HasAura(10256) && !me->HasAura(1137) && me->GetBotAI()) me->GetBotAI()->UpdateAI(diff);
+    }
+
     Unit* owner = me->GetCharmerOrOwner();
 
     if (m_updateAlliesTimer <= diff)
@@ -295,6 +302,8 @@ void PetAI::KilledUnit(Unit *victim)
 
 void PetAI::AttackStart(Unit *target)
 {
+    if (me->GetCharmInfo() == NULL) return;
+
     // Overrides Unit::AttackStart to correctly evaluate Pet states
 
     // Check all pet states to decide if we can attack this target
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
new file mode 100644
index 0000000..68565db
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
@@ -0,0 +1,373 @@
+/**
+ *
+ * @File : sc_npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 28/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+
+#define TELE    nsNpcTel::CatDest
+#define PAGE    nsNpcTel::Page
+#define PAGEI   PAGE::Instance
+
+
+nsNpcTel::VCatDest nsNpcTel::TabCatDest;
+
+
+uint32 PAGE::operator [] (Player * const player) const
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i].GetPageId();
+    }
+    return 0;
+}
+
+PAGE::Instance & PAGE::operator () (Player * const player)
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i];
+    }
+    m_TabInstance.push_back(Instance(player));
+    return m_TabInstance.back();
+}
+
+PAGE::Instance & PAGEI::operator = (const uint32 &id)
+{
+    m_PageId = id;
+    return *this;
+}
+
+PAGE::Instance & PAGEI::operator ++ (void)
+{
+    ++m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator ++ (int32)
+{
+    Instance tmp (*this);
+    ++m_PageId;
+    return tmp;
+}
+
+PAGE::Instance & PAGEI::operator -- (void)
+{
+    --m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator -- (int32)
+{
+    Instance tmp (*this);
+    --m_PageId;
+    return tmp;
+}
+
+TELE::CatDest(const uint32 &id, const std::string &name,
+              const Flag &flag, const uint64 &data0, const uint32 &data1)
+    : m_id(id), m_name(name), m_flag(flag), m_data0(data0), m_data1(data1)
+{
+    m_TabDest.clear();
+}
+
+std::string TELE::GetName(const bool IsGM /* = false */) const
+{
+    if (!IsGM || m_flag != FLAG_TEAM)
+        return m_name;
+
+    switch (m_data0)
+    {
+      case TEAM_HORDE:      return std::string(m_name + " (H)");
+      case TEAM_ALLIANCE:   return std::string(m_name + " (A)");
+    }
+    return m_name;
+}
+
+bool TELE::IsAllowedToTeleport(Player * const player) const
+{
+    if (player->isGameMaster())
+    {
+        if (m_flag == FLAG_GMLEVEL)
+            return player->GetSession()->GetSecurity() >= m_data0;
+        return true;
+    }
+
+    switch (m_flag)
+    {
+      case FLAG_TEAM:
+        switch (m_data0)
+        {
+          case TEAM_HORDE:      return player->GetTeam() == HORDE;
+          case TEAM_ALLIANCE:   return player->GetTeam() == ALLIANCE;
+          case TEAM_ALL:        return true;
+        }
+
+      case FLAG_GUILD:
+        return player->GetGuildId() == m_data0;
+
+      case FLAG_GMLEVEL:
+        return player->GetSession()->GetSecurity() >= m_data0;
+
+      case FLAG_ISGM:
+        return player->isGameMaster();
+
+      case FLAG_ACCOUNT:
+        return player->GetSession()->GetAccountId() == m_data0;
+
+      case FLAG_LEVEL:
+        return player->getLevel() >= m_data0;
+
+      case FLAG_ITEM:
+        return player->HasItemCount(m_data0, m_data1, true);
+
+      case FLAG_QUEST:
+        if (m_data1 < MAX_QUEST_STATUS)
+            return player->GetQuestStatus(m_data0) == m_data1;
+        return player->GetQuestRewardStatus(m_data0);
+
+      case FLAG_GENDER:
+        return player->getGender() == m_data0;
+
+      case FLAG_RACE:
+        return player->getRace() == m_data0;
+
+      case FLAG_CLASS:
+        return player->getClass() == m_data0;
+
+      case FLAG_REPUTATION:
+        return player->GetReputationRank(m_data0) >= m_data1;
+
+      case FLAG_PLAYER:
+        return player->GetGUID() == m_data0;
+    }
+
+    sLog->outError("Invalid flag (category: %u). Important problem...", GetCatID());
+    return false;
+}
+
+uint32 TELE::CountOfCategoryAllowedBy(Player * const player)
+{
+    uint32 count (0);
+    for (VCatDest_t i(0); i < TabCatDest.size(); ++i)
+    {
+        if (TabCatDest[i].IsAllowedToTeleport(player))
+            ++count;
+    }
+    return count;
+}
+
+bool nsNpcTel::IsValidData(const uint32 &cat,   const Flag &flag,
+                           const uint64 &data0, const uint32 &data1)
+{
+    switch(flag)
+    {
+      case FLAG_TEAM:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0 < MAX_FLAG_TEAM)
+            return true;
+        sLog->outError("Invalid data0 (Team) (category: %u).", cat);
+        return false;
+
+      case FLAG_GUILD:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError("Invalid data0 (GuildID) (category: %u).", cat);
+        return false;
+
+      case FLAG_GMLEVEL:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        sLog->outError("Invalid data0 (GmLevel) (category: %u).", cat);
+        return false;
+
+      case FLAG_ISGM:
+        if (data0)
+            sLog->outError("Invalid data0 (category: %u).", cat);
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        return true;
+
+      case FLAG_ACCOUNT:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError("Invalid data0 (AccountID) (category: %u).", cat);
+        return false;
+
+      case FLAG_LEVEL:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        sLog->outError("Invalid data0 (Level) (category: %u).", cat);
+        return false;
+
+      case FLAG_ITEM:
+        if (!data0)
+        {
+            sLog->outError("Invalid data0 (ItemID) (category: %u).", cat);
+            return false;
+        }
+        if (data1)
+            return true;
+        sLog->outError("Invalid data1 (Item Count) (category: %u).", cat);
+        return false;
+
+      case FLAG_QUEST:
+        if (!data0)
+        {
+            sLog->outError("Invalid data0 (QuestID) (category: %u).", cat);
+            return false;
+        }
+        if (data1 < MAX_QUEST_STATUS + 1)
+            return true;
+        sLog->outError("Invalid data1 (Quest Status) (category: %u).", cat);
+        return false;
+
+      case FLAG_GENDER:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0 < GENDER_NONE)
+            return true;
+        sLog->outError("Invalid data0 (Gender) (category: %u).", cat);
+        return false;
+
+      case FLAG_RACE:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_RACES)
+            return true;
+        sLog->outError("Invalid data0 (Race) (category: %u).", cat);
+        return false;
+
+      case FLAG_CLASS:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_CLASSES)
+            return true;
+        sLog->outError("Invalid data0 (Class) (category: %u).", cat);
+        return false;
+
+      case FLAG_REPUTATION:
+        if (!data0)
+        {
+            sLog->outError("Invalid data0 (Faction/Reputation) (category: %u).", cat);
+            return false;
+        }
+        if (data1 <= REP_EXALTED)
+            return true;
+        sLog->outError("Invalid data1 (Faction/Reputation) (category: %u).", cat);
+        return false;
+
+      case FLAG_PLAYER:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError("Invalid data0 (PlayerGuid) (category: %u).", cat);
+        return false;
+    }
+
+    sLog->outError("Invalid flag (category: %u).", cat);
+    return false;
+}
+
+void LoadNpcTele(void)
+{
+    const char *Table[] =
+    {
+        "custom_npc_tele_category",
+        "custom_npc_tele_destination",
+        "custom_npc_tele_association",
+    };
+
+
+    QueryResult result = WorldDatabase.PQuery(
+        "SELECT `flag`, `data0`, `data1`, `cat_id`, C.`name` `namecat`, D.`name` `namedest`, "
+        //      0        1        2        3                  4                   5
+               "`pos_X`, `pos_Y`, `pos_Z`, `orientation`, `map`, `level`, `cost` "
+        //      6        7        8        9              10     11       12
+        "FROM `%s` C, `%s` D, `%s` A "
+        "WHERE C.`id` = `cat_id` AND D.`id` = `dest_id` "
+        "ORDER BY `namecat`, `cat_id`, `namedest`", Table[0], Table[1], Table[2]);
+
+    nsNpcTel::TabCatDest.clear();
+
+    if (result)
+    {
+	    sLog->outString( "TSCR: Loading %s, %s and %s...", Table[0], Table[1], Table[2]);
+
+        uint32 catid = 0;
+        uint32 nbDest = 0;
+        bool IsValidCat = true;
+        bool FirstTime = true;
+
+        do
+        {
+            Field *fields = result->Fetch();
+
+            if (!IsValidCat && catid == fields[3].GetUInt32() && !FirstTime)
+                continue;
+
+            IsValidCat = true;
+            FirstTime = false;
+
+            if (!nsNpcTel::IsValidData(fields[3].GetUInt32(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                       fields[1].GetUInt64(), fields[2].GetUInt32()))
+            {
+                IsValidCat = false;
+                catid = fields[3].GetUInt32();
+                continue;
+            }
+
+            if (catid != fields[3].GetUInt32())
+            {
+                catid = fields[3].GetUInt32();
+                nsNpcTel::CatDest categorie (catid, fields[4].GetString(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                             fields[1].GetUInt64(), fields[2].GetUInt32());
+                nsNpcTel::TabCatDest.push_back(categorie);
+            }
+
+            nsNpcTel::Dest item =
+            {
+                fields[5].GetString(),   // Name
+                fields[6].GetFloat(),       // X
+                fields[7].GetFloat(),       // Y
+                fields[8].GetFloat(),       // Z
+                fields[9].GetFloat(),       // Orientation
+                fields[10].GetUInt16(),     // Map
+                fields[11].GetUInt8(),      // Level
+                fields[12].GetUInt32(),     // Cost
+            };
+
+            nsNpcTel::TabCatDest.back().AddDest(item);
+            ++nbDest;
+        } while (result->NextRow());
+
+        sLog->outString("");
+        sLog->outString("TSCR: >> Loaded %u npc_teleport.", nbDest);
+    } else sLog->outString("TSCR: WARNING >> Loaded 0 npc_teleport.");
+}
+
+
+#undef TELE
+#undef PAGE
+#undef PAGEI
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.h b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
new file mode 100644
index 0000000..4830245
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
@@ -0,0 +1,151 @@
+/**
+ *
+ * @File : sc_npc_teleport.h
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#ifndef SC_NPC_TELEPORT_H
+#define SC_NPC_TELEPORT_H
+
+#include <vector>
+
+
+namespace nsNpcTel
+{
+    // Different types of permissions
+    enum Flag
+    {
+        FLAG_TEAM       = 0,
+        FLAG_GUILD      = 1,
+        FLAG_GMLEVEL    = 2,
+        FLAG_ISGM       = 3,
+        FLAG_ACCOUNT    = 4,
+        FLAG_LEVEL      = 5,
+        FLAG_ITEM       = 6,
+        FLAG_QUEST      = 7,
+        FLAG_GENDER     = 8,
+        FLAG_RACE       = 9,
+        FLAG_CLASS      = 10,
+        FLAG_REPUTATION = 11,
+        FLAG_PLAYER     = 12,
+        MAX_FLAG,
+    };
+
+    // Different parameters of FLAG_TEAM
+    enum
+    {
+        TEAM_ALL        = 0,
+        TEAM_ALLIANCE   = 1,
+        TEAM_HORDE      = 2,
+        MAX_FLAG_TEAM,
+    };
+
+    // Structure representing the destinations
+    struct Dest
+    {
+        std::string m_name;
+        float       m_X, m_Y, m_Z, m_orient;
+        uint16      m_map;
+        uint8       m_level;
+        uint32      m_cost;
+    };
+
+    // Class representing the categories of destinations
+    class CatDest
+    {
+      public:
+
+        typedef std::vector<Dest> VDest;
+        typedef VDest::size_type  VDest_t;
+
+        CatDest(const uint32 &id, const std::string &name,
+                const Flag &flag, const uint64 &data0, const uint32 &data1);
+
+        void   AddDest  (const Dest &item)       { m_TabDest.push_back(item); }
+        Dest   GetDest  (const uint32 &id) const { return m_TabDest[id]; }
+        uint32 GetCatID (void)             const { return m_id; }
+        uint32 size     (void)             const { return m_TabDest.size(); }
+
+        std::string GetName(const bool IsGM = false)    const;
+        bool IsAllowedToTeleport(Player * const player) const;
+
+        static uint32 CountOfCategoryAllowedBy(Player * const player);
+
+      private:
+
+        uint32      m_id;
+        std::string m_name;
+        Flag        m_flag;
+        uint64      m_data0;
+        uint32      m_data1;
+        VDest       m_TabDest;
+    };
+
+    // Class page for current player
+    class Page
+    {
+      protected:
+
+        // Class instance for current player
+        class Instance
+        {
+          public:
+
+            Instance(Player * const player, const uint32 &PageId = 0)
+                : m_player(player), m_PageId(PageId) {}
+
+            Instance & operator =  (const uint32 &id);
+            Instance & operator ++ (void);
+            Instance   operator ++ (int32);
+            Instance & operator -- (void);
+            Instance   operator -- (int32);
+
+            uint32   GetPageId(void) const { return m_PageId; }
+            Player * GetPlayer(void) const { return m_player; }
+
+          private:
+
+            Player *m_player;
+            uint32  m_PageId;
+        };
+
+
+      public:
+
+        typedef std::vector<Instance> VInst;
+        typedef VInst::size_type      VInst_t;
+
+        Page(void) { m_TabInstance.clear(); }
+
+        Instance &   operator () (Player * const player);
+        uint32 operator [] (Player * const player) const;
+
+
+      private:
+
+        VInst m_TabInstance;
+    };
+
+    typedef std::vector <CatDest> VCatDest;
+    typedef VCatDest::size_type   VCatDest_t;
+
+    // Verification of data integrity
+    bool IsValidData(const uint32 &cat,   const Flag &flag,
+                     const uint64 &data0, const uint32 &data1);
+
+    extern VCatDest TabCatDest;
+}
+
+// Loading contents of database
+void LoadNpcTele(void);
+
+extern WorldDatabaseWorkerPool WorldDatabase;
+
+#endif
diff --git a/src/server/game/Anticheat/AnticheatMgr.cpp b/src/server/game/Anticheat/AnticheatMgr.cpp
new file mode 100644
index 0000000..99e4ed2
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatMgr.cpp
@@ -0,0 +1,206 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "AnticheatMgr.h"
+
+AnticheatMgr::AnticheatMgr() 
+{
+}
+
+AnticheatMgr::~AnticheatMgr()
+{
+}
+
+void AnticheatMgr::DeletePlayerReport(Player* player)
+{
+    if (!player->GetSession())
+        return;
+
+    CharacterDatabase.PExecute("DELETE FROM players_reports_status WHERE guid IN (SELECT guid FROM characters WHERE account=%u)",player->GetSession()->GetAccountId());
+}
+
+void AnticheatMgr::BuildReport(Player* player,uint8 reportType)
+{
+    if (player->anticheatData.total_reports == 0)
+    {
+        player->anticheatData.creation_time = time(NULL);
+        CharacterDatabase.PExecute("INSERT IGNORE INTO players_reports_status (guid,creation_time) VALUES (%u,%u);",player->GetGUIDLow(),player->anticheatData.creation_time);
+    }
+
+    std::string report_type = report_types[reportType];
+
+    player->anticheatData.type_reports[reportType]++;
+
+    uint64 actual_time = time(NULL) - player->anticheatData.creation_time;
+
+    player->anticheatData.average = player->anticheatData.total_reports > 0 ? ((player->anticheatData.average * (player->anticheatData.total_reports)) + actual_time) / (player->anticheatData.total_reports + 1) : 0;
+    player->anticheatData.total_reports++;
+
+    CharacterDatabase.PExecute("UPDATE players_reports_status SET %s=%u, total_reports=%u, average=%u WHERE guid=%u",report_type.c_str(),player->anticheatData.type_reports[reportType],player->anticheatData.total_reports,player->anticheatData.average,player->GetGUIDLow());
+    
+    if (player->anticheatData.total_reports > sWorld->getIntConfig(CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION))
+    {
+        // display warning at the center of the screen, hacky way?
+        std::string str = "";
+        str = "|cFFFFFC00[AC]|cFF00FFFF[|cFF60FF00" + std::string(player->GetName()) + "|cFF00FFFF] Possible cheater!";
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalGMMessage(&data);
+    }
+}
+
+void AnticheatMgr::DisableAnticheatDetection(Player* player, bool teleport)
+{
+    player->anticheatData.disableACCheck = true;
+    player->anticheatData.disableACCheckTimer = (teleport ? 7000 : 5000);
+}
+
+void AnticheatMgr::HandleHackDetectionTimer(Player* player,uint32 diffTime)
+{
+    if (player->anticheatData.disableACCheck)
+    {
+        if (player->anticheatData.disableACCheckTimer <= diffTime)
+        {
+            player->anticheatData.disableACCheck = false;
+        } else player->anticheatData.disableACCheckTimer -= diffTime;
+    }
+}
+
+void AnticheatMgr::JumpHackDetection(Player* player, MovementInfo movementInfo,uint32 opcode)
+{
+    if (player->anticheatData.lastOpcode == MSG_MOVE_JUMP && opcode == MSG_MOVE_JUMP)
+    {
+        BuildReport(player,JUMP_HACK_REPORT);
+        sLog->outError("Jump Hack Detection Player LowGuid %u",player->GetGUIDLow());
+    }
+}
+
+void AnticheatMgr::WalkOnWaterHackDetection(Player* player, MovementInfo movementInfo)
+{
+    if (!player->anticheatData.lastMovementInfo.HasMovementFlag(MOVEMENTFLAG_WATERWALKING))
+        return;
+
+    // if we are a ghost we can walk on water
+    if (!player->isAlive())
+        return;
+
+    if (player->HasAuraType(SPELL_AURA_FEATHER_FALL) ||
+        player->HasAuraType(SPELL_AURA_SAFE_FALL) ||
+        player->HasAuraType(SPELL_AURA_WATER_WALK))
+        return;
+
+    sLog->outError("Walk on Water Player LowGuid %u",player->GetGUIDLow());
+    BuildReport(player,WALK_WATER_HACK_REPORT);
+
+}
+
+void AnticheatMgr::FlyHackDetection(Player* player, MovementInfo movementInfo)
+{
+    if (!player->anticheatData.lastMovementInfo.HasMovementFlag(MOVEMENTFLAG_FLYING))
+        return;
+    
+    if (player->HasAuraType(SPELL_AURA_FLY) ||
+        player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ||
+        player->HasAuraType(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED))
+        return;
+    
+    sLog->outError("FlyHack Player LowGuid %u",player->GetGUIDLow());
+    BuildReport(player,FLY_HACK_REPORT);
+}
+
+void AnticheatMgr::TeleportPlaneHackDetection(Player* player, MovementInfo movementInfo)
+{
+    if (player->anticheatData.lastMovementInfo.pos.GetPositionZ() != 0 ||
+        movementInfo.pos.GetPositionZ() != 0)
+        return;
+
+    if (movementInfo.HasMovementFlag(MOVEMENTFLAG_FALLING))
+        return;
+
+    if (player->getDeathState() == DEAD_FALLING)
+        return;
+    float x, y, z;
+    player->GetPosition(x, y, z);
+    float ground_Z = player->GetMap()->GetHeight(x, y, z);
+    float z_diff = fabs(ground_Z - z);   
+
+    // we are not really walking there
+    if (z_diff > 1.0f)
+        BuildReport(player,TELEPORT_PLANE_HACK_REPORT);
+}
+
+void AnticheatMgr::StartHackDetection(Player* player, MovementInfo movementInfo, uint32 opcode)
+{
+    if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+        return;
+
+    if (player->isGameMaster())
+        return;
+
+    if (player->anticheatData.disableACCheck || player->isInFlight() || player->GetTransport() || player->GetVehicle())
+    {
+        player->anticheatData.lastMovementInfo = movementInfo;
+        player->anticheatData.lastOpcode = opcode;
+        return;
+    }
+
+    SpeedHackDetection(player,movementInfo);
+    FlyHackDetection(player,movementInfo);
+    WalkOnWaterHackDetection(player,movementInfo);
+    JumpHackDetection(player,movementInfo,opcode);
+    TeleportPlaneHackDetection(player, movementInfo);
+
+    player->anticheatData.lastMovementInfo = movementInfo;
+    player->anticheatData.lastOpcode = opcode;
+}
+
+
+void AnticheatMgr::SpeedHackDetection(Player* player,MovementInfo movementInfo)
+{
+    uint32 distance2D = (uint32)movementInfo.pos.GetExactDist2d(&player->anticheatData.lastMovementInfo.pos);
+    uint8 moveType = 0;
+
+    // we need to know HOW is the player moving
+    // TO-DO: Should we check the incoming movement flags?
+    if (player->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+        moveType = MOVE_SWIM;
+    else if (player->IsFlying())
+        moveType = MOVE_FLIGHT;
+    else if (player->HasUnitMovementFlag(MOVEMENTFLAG_WALKING))
+        moveType = MOVE_WALK;
+    else
+        moveType = MOVE_RUN;
+
+    // how many yards the player can do in one sec.
+    uint32 speedRate = (uint32)(player->GetSpeed(UnitMoveType(moveType)) + movementInfo.j_xyspeed);
+    
+    // how long the player took to move to here.
+    uint32 timeDiff = getMSTimeDiff(player->anticheatData.lastMovementInfo.time,movementInfo.time);
+
+    if (timeDiff == 0)
+        timeDiff = 1;
+
+    // this is the distance doable by the player in 1 sec, using the time done to move to this point.
+    uint32 clientSpeedRate = distance2D * 1000 / timeDiff;
+
+    //sLog->outError("fallxy %f fallz %f Distance2D %u clientSpeedRate %u speedRate %u timeDiff %u ",movementInfo.j_xyspeed, movementInfo.j_zspeed,distance2D,clientSpeedRate,speedRate,timeDiff);
+    
+    // we did the (uint32) cast to accept a margin of tolerance
+    if (clientSpeedRate > speedRate)
+    {
+        BuildReport(player,SPEED_HACK_REPORT);
+        sLog->outError("Speed Hack Player LowGuid %u",player->GetGUIDLow());
+    }
+}
\ No newline at end of file
diff --git a/src/server/game/Anticheat/AnticheatMgr.h b/src/server/game/Anticheat/AnticheatMgr.h
new file mode 100644
index 0000000..4e7d617
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatMgr.h
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <ace/Singleton.h>
+
+enum ReportTypes
+{
+    SPEED_HACK_REPORT = 0,
+    FLY_HACK_REPORT,
+    WALK_WATER_HACK_REPORT,
+    JUMP_HACK_REPORT,
+    TELEPORT_PLANE_HACK_REPORT,
+    
+    MAX_REPORT_TYPES
+};
+
+const std::string report_types[MAX_REPORT_TYPES] = {"speed_reports", "fly_reports", "waterwalk_reports", "jump_reports", "teleportplane_reports" };
+
+class AnticheatMgr
+{
+    friend class ACE_Singleton<AnticheatMgr, ACE_Null_Mutex>;
+    AnticheatMgr();
+    ~AnticheatMgr();
+
+    public:
+        void StartHackDetection(Player* player, MovementInfo movementInfo, uint32 opcode);
+        void HandleHackDetectionTimer(Player* player, uint32 timeDiff);
+        void DisableAnticheatDetection(Player* player, bool teleport = false);
+        void DeletePlayerReport(Player* player);
+    private:
+        void SpeedHackDetection(Player* player, MovementInfo movementInfo);
+        void FlyHackDetection(Player* player, MovementInfo movementInfo);
+        void WalkOnWaterHackDetection(Player* player, MovementInfo movementInfo);
+        void JumpHackDetection(Player* player, MovementInfo movementInfo,uint32 opcode);
+        void TeleportPlaneHackDetection(Player* player, MovementInfo);
+
+        void BuildReport(Player* player,uint8 reportType);
+};
+
+#define sAnticheatMgr ACE_Singleton<AnticheatMgr, ACE_Null_Mutex>::instance()
\ No newline at end of file
diff --git a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
new file mode 100644
index 0000000..373aa60
--- /dev/null
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
@@ -0,0 +1,1884 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ObjectMgr.h"
+#include "AuctionHouseMgr.h"
+#include "AuctionHouseBot.h"
+#include <vector>
+
+using namespace std;
+vector<uint32> npcItems;
+vector<uint32> lootItems;
+vector<uint32> greyTradeGoodsBin;
+vector<uint32> whiteTradeGoodsBin;
+vector<uint32> greenTradeGoodsBin;
+vector<uint32> blueTradeGoodsBin;
+vector<uint32> purpleTradeGoodsBin;
+vector<uint32> orangeTradeGoodsBin;
+vector<uint32> yellowTradeGoodsBin;
+vector<uint32> greyItemsBin;
+vector<uint32> whiteItemsBin;
+vector<uint32> greenItemsBin;
+vector<uint32> blueItemsBin;
+vector<uint32> purpleItemsBin;
+vector<uint32> orangeItemsBin;
+vector<uint32> yellowItemsBin;
+
+AuctionHouseBot::AuctionHouseBot()
+{
+    debug_Out = false;
+    debug_Out_Filters = false;
+    AHBSeller = false;
+    AHBBuyer = false;
+
+    //Begin Filters
+
+    Vendor_Items = false;
+    Loot_Items = false;
+    Other_Items = false;
+    Vendor_TGs = false;
+    Loot_TGs = false;
+    Other_TGs = false;
+
+    No_Bind = false;
+    Bind_When_Picked_Up = false;
+    Bind_When_Equipped = false;
+    Bind_When_Use = false;
+    Bind_Quest_Item = false;
+
+    DisableBeta_PTR_Unused = false;
+    DisablePermEnchant = false;
+    DisableConjured = false;
+    DisableGems = false;
+    DisableMoney = false;
+    DisableMoneyLoot = false;
+    DisableLootable = false;
+    DisableKeys = false;
+    DisableDuration = false;
+    DisableBOP_Or_Quest_NoReqLevel = false;
+
+    DisableWarriorItems = false;
+    DisablePaladinItems = false;
+    DisableHunterItems = false;
+    DisableRogueItems = false;
+    DisablePriestItems = false;
+    DisableDKItems = false;
+    DisableShamanItems = false;
+    DisableMageItems = false;
+    DisableWarlockItems = false;
+    DisableUnusedClassItems = false;
+    DisableDruidItems = false;
+
+    DisableItemsBelowLevel = 0;
+    DisableItemsAboveLevel = 0;
+    DisableTGsBelowLevel = 0;
+    DisableTGsAboveLevel = 0;
+    DisableItemsBelowGUID = 0;
+    DisableItemsAboveGUID = 0;
+    DisableTGsBelowGUID = 0;
+    DisableTGsAboveGUID = 0;
+    DisableItemsBelowReqLevel = 0;
+    DisableItemsAboveReqLevel = 0;
+    DisableTGsBelowReqLevel = 0;
+    DisableTGsAboveReqLevel = 0;
+    DisableItemsBelowReqSkillRank = 0;
+    DisableItemsAboveReqSkillRank = 0;
+    DisableTGsBelowReqSkillRank = 0;
+    DisableTGsAboveReqSkillRank = 0;
+
+    //End Filters
+
+    _lastrun_a = time(NULL);
+    _lastrun_h = time(NULL);
+    _lastrun_n = time(NULL);
+
+    AllianceConfig = AHBConfig(2);
+    HordeConfig = AHBConfig(6);
+    NeutralConfig = AHBConfig(7);
+}
+
+AuctionHouseBot::~AuctionHouseBot()
+{
+}
+
+void AuctionHouseBot::addNewAuctions(Player *AHBplayer, AHBConfig *config)
+{
+    if (!AHBSeller)
+    {
+        if (debug_Out) sLog->outError("AHSeller: Disabled");
+        return;
+    }
+
+    uint32 minItems = config->GetMinItems();
+    uint32 maxItems = config->GetMaxItems();
+
+    if (maxItems == 0)
+    {
+        //if (debug_Out) sLog->outString("AHSeller: Auctions disabled");
+        return;
+    }
+
+    AuctionHouseEntry const* ahEntry =  sAuctionMgr->GetAuctionHouseEntry(config->GetAHFID());
+    if (!ahEntry)
+    {
+        return;
+    }
+    AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+    if (!auctionHouse)
+    {
+        return;
+    }
+
+    uint32 auctions = auctionHouse->Getcount();
+
+    if (auctions >= minItems)
+    {
+        //if (debug_Out) sLog->outString("AHSeller: Auctions above minimum");
+        return;
+    }
+
+    if (auctions >= maxItems)
+    {
+        //if (debug_Out) sLog->outString("AHSeller: Auctions at or above maximum");
+        return;
+    }
+
+    uint32 items = 0;
+    if ((maxItems - auctions) >= ItemsPerCycle)
+        items = ItemsPerCycle;
+    else
+        items = (maxItems - auctions);
+
+    if (debug_Out) sLog->outString("AHSeller: Adding %u Auctions", items);
+
+    uint32 AuctioneerGUID = 0;
+
+    switch (config->GetAHID())
+    {
+    case 2:
+        AuctioneerGUID = 79707; //Human in stormwind.
+        break;
+    case 6:
+        AuctioneerGUID = 4656; //orc in Orgrimmar
+        break;
+    case 7:
+        AuctioneerGUID = 23442; //goblin in GZ
+        break;
+    default:
+        if (debug_Out) sLog->outError("AHSeller: GetAHID() - Default switch reached");
+        AuctioneerGUID = 23442; //default to neutral 7
+        break;
+    }
+
+    if (debug_Out) sLog->outString("AHSeller: Current Auctineer GUID is %u", AuctioneerGUID);
+
+    uint32 greyTGcount = config->GetPercents(AHB_GREY_TG);
+    uint32 whiteTGcount = config->GetPercents(AHB_WHITE_TG);
+    uint32 greenTGcount = config->GetPercents(AHB_GREEN_TG);
+    uint32 blueTGcount = config->GetPercents(AHB_BLUE_TG);
+    uint32 purpleTGcount = config->GetPercents(AHB_PURPLE_TG);
+    uint32 orangeTGcount = config->GetPercents(AHB_ORANGE_TG);
+    uint32 yellowTGcount = config->GetPercents(AHB_YELLOW_TG);
+    uint32 greyIcount = config->GetPercents(AHB_GREY_I);
+    uint32 whiteIcount = config->GetPercents(AHB_WHITE_I);
+    uint32 greenIcount = config->GetPercents(AHB_GREEN_I);
+    uint32 blueIcount = config->GetPercents(AHB_BLUE_I);
+    uint32 purpleIcount = config->GetPercents(AHB_PURPLE_I);
+    uint32 orangeIcount = config->GetPercents(AHB_ORANGE_I);
+    uint32 yellowIcount = config->GetPercents(AHB_YELLOW_I);
+/*    uint32 total = greyTGcount + whiteTGcount + greenTGcount + blueTGcount
+        + purpleTGcount + orangeTGcount + yellowTGcount
+        + whiteIcount + greenIcount + blueIcount + purpleIcount
+        + orangeIcount + yellowIcount;
+*/
+    uint32 greyTGoods = config->GetItemCounts(AHB_GREY_TG);
+    uint32 whiteTGoods = config->GetItemCounts(AHB_WHITE_TG);
+    uint32 greenTGoods = config->GetItemCounts(AHB_GREEN_TG);
+    uint32 blueTGoods = config->GetItemCounts(AHB_BLUE_TG);
+    uint32 purpleTGoods = config->GetItemCounts(AHB_PURPLE_TG);
+    uint32 orangeTGoods = config->GetItemCounts(AHB_ORANGE_TG);
+    uint32 yellowTGoods = config->GetItemCounts(AHB_YELLOW_TG);
+
+    uint32 greyItems = config->GetItemCounts(AHB_GREY_I);
+    uint32 whiteItems = config->GetItemCounts(AHB_WHITE_I);
+    uint32 greenItems = config->GetItemCounts(AHB_GREEN_I);
+    uint32 blueItems = config->GetItemCounts(AHB_BLUE_I);
+    uint32 purpleItems = config->GetItemCounts(AHB_PURPLE_I);
+    uint32 orangeItems = config->GetItemCounts(AHB_ORANGE_I);
+    uint32 yellowItems = config->GetItemCounts(AHB_YELLOW_I);
+    if (debug_Out) sLog->outString("AHSeller: %u items", items);
+
+    // only insert a few at a time, so as not to peg the processor
+    for (uint32 cnt = 1; cnt <= items; cnt++)
+    {
+    if (debug_Out) sLog->outString("AHSeller: %u count", cnt);
+        uint32 itemID = 0;
+        uint32 itemColor = 99;
+        uint32 loopbreaker = 0;
+        while (itemID == 0 && loopbreaker <= 50)
+        {
+            ++loopbreaker;
+            uint32 choice = urand(0, 13);
+            itemColor = choice;
+            switch (choice)
+            {
+            case 0:
+                {
+                    if ((greyItemsBin.size() > 0) && (greyItems < greyIcount))
+                        itemID = greyItemsBin[urand(0, greyItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 1:
+                {
+                    if ((whiteItemsBin.size() > 0) && (whiteItems < whiteIcount))
+                        itemID = whiteItemsBin[urand(0, whiteItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 2:
+                {
+                    if ((greenItemsBin.size() > 0) && (greenItems < greenIcount))
+                        itemID = greenItemsBin[urand(0, greenItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 3:
+                {
+                    if ((blueItemsBin.size() > 0) && (blueItems < blueIcount))
+                        itemID = blueItemsBin[urand(0, blueItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 4:
+                {
+                    if ((purpleItemsBin.size() > 0) && (purpleItems < purpleIcount))
+                        itemID = purpleItemsBin[urand(0, purpleItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 5:
+                {
+                    if ((orangeItemsBin.size() > 0) && (orangeItems < orangeIcount))
+                        itemID = orangeItemsBin[urand(0, orangeItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 6:
+                {
+                    if ((yellowItemsBin.size() > 0) && (yellowItems < yellowIcount))
+                        itemID = yellowItemsBin[urand(0, yellowItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 7:
+                {
+                    if ((greyTradeGoodsBin.size() > 0) && (greyTGoods < greyTGcount))
+                        itemID = greyTradeGoodsBin[urand(0, greyTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 8:
+                {
+                    if ((whiteTradeGoodsBin.size() > 0) && (whiteTGoods < whiteTGcount))
+                        itemID = whiteTradeGoodsBin[urand(0, whiteTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 9:
+                {
+                    if ((greenTradeGoodsBin.size() > 0) && (greenTGoods < greenTGcount))
+                        itemID = greenTradeGoodsBin[urand(0, greenTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 10:
+                {
+                    if ((blueTradeGoodsBin.size() > 0) && (blueTGoods < blueTGcount))
+                        itemID = blueTradeGoodsBin[urand(0, blueTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 11:
+                {
+                    if ((purpleTradeGoodsBin.size() > 0) && (purpleTGoods < purpleTGcount))
+                        itemID = purpleTradeGoodsBin[urand(0, purpleTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 12:
+                {
+                    if ((orangeTradeGoodsBin.size() > 0) && (orangeTGoods < orangeTGcount))
+                        itemID = orangeTradeGoodsBin[urand(0, orangeTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 13:
+                {
+                    if ((yellowTradeGoodsBin.size() > 0) && (yellowTGoods < yellowTGcount))
+                        itemID = yellowTradeGoodsBin[urand(0, yellowTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            default:
+                {
+                    if (debug_Out) sLog->outError("AHSeller: itemID Switch - Default Reached");
+                    break;
+                }
+            }
+
+            if (itemID == 0)
+            {
+                if (debug_Out) sLog->outError("AHSeller: Item::CreateItem() - ItemID is 0");
+                continue;
+            }
+
+            ItemPrototype const* prototype = sObjectMgr->GetItemPrototype(itemID);
+            if (prototype == NULL)
+            {
+                if (debug_Out) sLog->outError("AHSeller: Huh?!?! prototype == NULL");
+                continue;
+            }
+
+            Item* item = Item::CreateItem(itemID, 1, AHBplayer);
+            if (item == NULL)
+            {
+                if (debug_Out) sLog->outError("AHSeller: Item::CreateItem() returned NULL");
+                break;
+            }
+            item->AddToUpdateQueueOf(AHBplayer);
+
+            uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(itemID);
+            if (randomPropertyId != 0)
+                item->SetItemRandomProperties(randomPropertyId);
+
+            uint64 buyoutPrice = 0;
+            uint64 bidPrice = 0;
+            uint32 stackCount = 1;
+
+            switch (SellMethod)
+            {
+            case 0:
+                buyoutPrice  = prototype->SellPrice;
+                break;
+            case 1:
+                buyoutPrice  = prototype->BuyPrice;
+                break;
+            }
+
+            if ((prototype->Quality >= 0) && (prototype->Quality <= AHB_MAX_QUALITY))
+            {
+                if (config->GetMaxStack(prototype->Quality) > 1 && item->GetMaxStackCount() > 1)
+                    stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(prototype->Quality)));
+                else if (config->GetMaxStack(prototype->Quality) == 0 && item->GetMaxStackCount() > 1)
+                    stackCount = urand(1, item->GetMaxStackCount());
+                else
+                    stackCount = 1;
+                buyoutPrice *= urand(config->GetMinPrice(prototype->Quality), config->GetMaxPrice(prototype->Quality));
+                buyoutPrice /= 100;
+                bidPrice = buyoutPrice * urand(config->GetMinBidPrice(prototype->Quality), config->GetMaxBidPrice(prototype->Quality));
+                bidPrice /= 100;
+            }
+            else
+            {
+                // quality is something it shouldn't be, let's get out of here
+                if (debug_Out) sLog->outError("AHBuyer: Quality %u not Supported", prototype->Quality);
+                item->RemoveFromUpdateQueueOf(AHBplayer);
+                continue;
+            }
+
+            uint32 etime = urand(1,3);
+            switch(etime)
+            {
+            case 1:
+                etime = 43200;
+                break;
+            case 2:
+                etime = 86400;
+                break;
+            case 3:
+                etime = 172800;
+                break;
+            default:
+                etime = 86400;
+                break;
+            }
+            item->SetCount(stackCount);
+
+            uint32 dep =  sAuctionMgr->GetAuctionDeposit(ahEntry, etime, item, stackCount);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            AuctionEntry* auctionEntry = new AuctionEntry;
+            auctionEntry->Id = sObjectMgr->GenerateAuctionID();
+            auctionEntry->auctioneer = AuctioneerGUID;
+            auctionEntry->item_guidlow = item->GetGUIDLow();
+            auctionEntry->item_template = item->GetEntry();
+            auctionEntry->owner = AHBplayer->GetGUIDLow();
+            auctionEntry->startbid = bidPrice * stackCount;
+            auctionEntry->buyout = buyoutPrice * stackCount;
+            auctionEntry->bidder = 0;
+            auctionEntry->bid = 0;
+            auctionEntry->deposit = dep;
+            auctionEntry->expire_time = (time_t) etime + time(NULL);
+            auctionEntry->auctionHouseEntry = ahEntry;
+            item->SaveToDB(trans);
+            item->RemoveFromUpdateQueueOf(AHBplayer);
+            sAuctionMgr->AddAItem(item);
+            auctionHouse->AddAuction(auctionEntry);
+            auctionEntry->SaveToDB(trans);
+            CharacterDatabase.CommitTransaction(trans);
+
+            switch(itemColor)
+            {
+            case 0:
+                ++greyItems;
+                break;
+            case 1:
+                ++whiteItems;
+                break;
+            case 2:
+                ++greenItems;
+                break;
+            case 3:
+                ++blueItems;
+                break;
+            case 4:
+                ++purpleItems;
+                break;
+            case 5:
+                ++orangeItems;
+                break;
+            case 6:
+                ++yellowItems;
+                break;
+            case 7:
+                ++greyTGoods;
+                break;
+            case 8:
+                ++whiteTGoods;
+                break;
+            case 9:
+                ++greenTGoods;
+                break;
+            case 10:
+                ++blueTGoods;
+                break;
+            case 11:
+                ++purpleTGoods;
+                break;
+            case 12:
+                ++orangeTGoods;
+                break;
+            case 13:
+                ++yellowTGoods;
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+void AuctionHouseBot::addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session)
+{
+    if (!AHBBuyer)
+    {
+        if (debug_Out) sLog->outError("AHBuyer: Disabled");
+        return;
+    }
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT id FROM auctionhouse WHERE itemowner<>%u AND buyguid<>%u", AHBplayerGUID, AHBplayerGUID);
+
+    if (!result)
+        return;
+
+    if (result->GetRowCount() == 0)
+        return;
+
+    // Fetches content of selected AH
+    AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+    vector<uint32> possibleBids;
+
+    do
+    {
+        uint32 tmpdata = result->Fetch()->GetUInt32();
+        possibleBids.push_back(tmpdata);
+    }while (result->NextRow());
+
+    for (uint32 count = 1; count <= config->GetBidsPerInterval(); ++count)
+    {
+        // Do we have anything to bid? If not, stop here.
+        if (possibleBids.empty())
+        {
+            //if (debug_Out) sLog->outString("AHBuyer: I have no items to bid on.");
+            count = config->GetBidsPerInterval();
+            continue;
+        }
+
+        // Choose random auction from possible auctions
+        uint32 vectorPos = urand(0, possibleBids.size() - 1);
+        vector<uint32>::iterator iter = possibleBids.begin();
+        advance(iter, vectorPos);
+
+        // from auctionhousehandler.cpp, creates auction pointer & player pointer
+        AuctionEntry* auction = auctionHouse->GetAuction(*iter);
+
+        // Erase the auction from the vector to prevent bidding on item in next iteration.
+        possibleBids.erase(iter);
+
+        if (!auction)
+            continue;
+
+        // get exact item information
+        Item *pItem =  sAuctionMgr->GetAItem(auction->item_guidlow);
+        if (!pItem)
+        {
+            if (debug_Out) sLog->outError("AHBuyer: Item %u doesn't exist, perhaps bought already?", auction->item_guidlow);
+            continue;
+        }
+
+        // get item prototype
+        ItemPrototype const* prototype = sObjectMgr->GetItemPrototype(auction->item_template);
+
+        // check which price we have to use, startbid or if it is bidded already
+        uint32 currentprice;
+        if (auction->bid)
+            currentprice = auction->bid;
+        else
+            currentprice = auction->startbid;
+
+        // Prepare portion from maximum bid
+        double bidrate = static_cast<double>(urand(1, 100)) / 100;
+        long double bidMax = 0;
+
+        // check that bid has acceptable value and take bid based on vendorprice, stacksize and quality
+        switch (BuyMethod)
+        {
+        case 0:
+            {
+                if ((prototype->Quality >= 0) && (prototype->Quality <= AHB_MAX_QUALITY))
+                {
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality))
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality);
+                }
+                else
+                {
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out) sLog->outError("AHBuyer: Quality %u not Supported", prototype->Quality);
+                    continue;
+                }
+                break;
+            }
+        case 1:
+            {
+                if ((prototype->Quality >= 0) && (prototype->Quality <= AHB_MAX_QUALITY))
+                {
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality))
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality);
+                }
+                else
+                {
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out) sLog->outError("AHBuyer: Quality %u not Supported", prototype->Quality);
+                    continue;
+                }
+                break;
+            }
+        }
+
+        // check some special items, and do recalculating to their prices
+        switch (prototype->Class)
+        {
+            // ammo
+        case 6:
+            bidMax = 0;
+            break;
+        default:
+            break;
+        }
+
+        if (bidMax == 0)
+        {
+            // quality check failed to get bidmax, let's get out of here
+            continue;
+        }
+
+        // Calculate our bid
+        long double bidvalue = currentprice + ((bidMax - currentprice) * bidrate);
+        // Convert to uint32
+        uint32 bidprice = static_cast<uint32>(bidvalue);
+
+        // Check our bid is high enough to be valid. If not, correct it to minimum.
+        if ((currentprice + auction->GetAuctionOutBid()) > bidprice)
+            bidprice = currentprice + auction->GetAuctionOutBid();
+
+        if (debug_Out)
+        {
+            sLog->outString("-------------------------------------------------");
+            sLog->outString("AHBuyer: Info for Auction #%u:", auction->Id);
+            sLog->outString("AHBuyer: AuctionHouse: %u", auction->GetHouseId());
+            sLog->outString("AHBuyer: Auctioneer: %u", auction->auctioneer);
+            sLog->outString("AHBuyer: Owner: %u", auction->owner);
+            sLog->outString("AHBuyer: Bidder: %u", auction->bidder);
+            sLog->outString("AHBuyer: Starting Bid: %u", auction->startbid);
+            sLog->outString("AHBuyer: Current Bid: %u", currentprice);
+            sLog->outString("AHBuyer: Buyout: %u", auction->buyout);
+            sLog->outString("AHBuyer: Deposit: %u", auction->deposit);
+            sLog->outString("AHBuyer: Expire Time: %u", auction->expire_time);
+            sLog->outString("AHBuyer: Bid Rate: %f", bidrate);
+            sLog->outString("AHBuyer: Bid Max: %f", bidMax);
+            sLog->outString("AHBuyer: Bid Value: %f", bidvalue);
+            sLog->outString("AHBuyer: Bid Price: %u", bidprice);
+            sLog->outString("AHBuyer: Item GUID: %u", auction->item_guidlow);
+            sLog->outString("AHBuyer: Item Template: %u", auction->item_template);
+            sLog->outString("AHBuyer: Item Info:");
+            sLog->outString("AHBuyer: Item ID: %u", prototype->ItemId);
+            sLog->outString("AHBuyer: Buy Price: %u", prototype->BuyPrice);
+            sLog->outString("AHBuyer: Sell Price: %u", prototype->SellPrice);
+            sLog->outString("AHBuyer: Bonding: %u", prototype->Bonding);
+            sLog->outString("AHBuyer: Quality: %u", prototype->Quality);
+            sLog->outString("AHBuyer: Item Level: %u", prototype->ItemLevel);
+            sLog->outString("AHBuyer: Ammo Type: %u", prototype->AmmoType);
+            sLog->outString("-------------------------------------------------");
+        }
+
+        // Check whether we do normal bid, or buyout
+        if ((bidprice < auction->buyout) || (auction->buyout == 0))
+        {
+
+            if (auction->bidder > 0)
+            {
+                if (auction->bidder == AHBplayer->GetGUIDLow())
+                {
+                    //pl->ModifyMoney(-int32(price - auction->bid));
+                }
+                else
+                {
+                    // mail to last bidder and return money
+                    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                    sAuctionMgr->SendAuctionOutbiddedMail(auction , bidprice, session->GetPlayer(), trans);
+                    CharacterDatabase.CommitTransaction(trans);
+                    //pl->ModifyMoney(-int32(price));
+                }
+           }
+
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = bidprice;
+
+            // Saving auction into database
+            CharacterDatabase.PExecute("UPDATE auctionhouse SET buyguid = '%u',lastbid = '%u' WHERE id = '%u'", auction->bidder, auction->bid, auction->Id);
+        }
+        else
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            //buyout
+            if ((auction->bidder) && (AHBplayer->GetGUIDLow() != auction->bidder))
+            {
+                sAuctionMgr->SendAuctionOutbiddedMail(auction, auction->buyout, session->GetPlayer(), trans);
+            }
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = auction->buyout;
+
+            // Send mails to buyer & seller
+            sAuctionMgr->SendAuctionSalePendingMail(auction, trans);
+            sAuctionMgr->SendAuctionSuccessfulMail(auction, trans);
+            sAuctionMgr->SendAuctionWonMail(auction, trans);
+            auction->DeleteFromDB( trans);
+            uint32 item_template = auction->item_template;
+            sAuctionMgr->RemoveAItem(auction->item_guidlow);
+            auctionHouse->RemoveAuction(auction, item_template);
+            CharacterDatabase.CommitTransaction(trans);
+        }
+    }
+}
+
+void AuctionHouseBot::Update()
+{
+    time_t _newrun = time(NULL);
+    if ((!AHBSeller) && (!AHBBuyer))
+        return;
+
+    WorldSession _session(AHBplayerAccount, NULL, SEC_PLAYER, false, true, 0, LOCALE_enUS, 0);
+    Player _AHBplayer(&_session);
+    _AHBplayer.Initialize(AHBplayerGUID);
+    sObjectAccessor->AddObject(&_AHBplayer);
+
+    // Add New Bids
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        addNewAuctions(&_AHBplayer, &AllianceConfig);
+        if (((_newrun - _lastrun_a) >= (AllianceConfig.GetBiddingInterval() * MINUTE)) && (AllianceConfig.GetBidsPerInterval() > 0))
+        {
+            //if (debug_Out) sLog->outString("AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_a));
+            //if (debug_Out) sLog->outString("AHBuyer: Bidding on Alliance Auctions");
+            addNewAuctionBuyerBotBid(&_AHBplayer, &AllianceConfig, &_session);
+            _lastrun_a = _newrun;
+        }
+
+        addNewAuctions(&_AHBplayer, &HordeConfig);
+        if (((_newrun - _lastrun_h) >= (HordeConfig.GetBiddingInterval() * MINUTE)) && (HordeConfig.GetBidsPerInterval() > 0))
+        {
+            //if (debug_Out) sLog->outString("AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_h));
+            //if (debug_Out) sLog->outString("AHBuyer: Bidding on Horde Auctions");
+            addNewAuctionBuyerBotBid(&_AHBplayer, &HordeConfig, &_session);
+            _lastrun_h = _newrun;
+        }
+    }
+
+    addNewAuctions(&_AHBplayer, &NeutralConfig);
+    if (((_newrun - _lastrun_n) >= (NeutralConfig.GetBiddingInterval() * MINUTE)) && (NeutralConfig.GetBidsPerInterval() > 0))
+    {
+        //if (debug_Out) sLog->outString("AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_n));
+        //if (debug_Out) sLog->outString("AHBuyer: Bidding on Neutral Auctions");
+        addNewAuctionBuyerBotBid(&_AHBplayer, &NeutralConfig, &_session);
+        _lastrun_n = _newrun;
+    }
+    sObjectAccessor->RemoveObject(&_AHBplayer);
+}
+
+void AuctionHouseBot::Initialize()
+{
+    debug_Out = sConfig->GetBoolDefault("AuctionHouseBot.DEBUG", false);
+    debug_Out_Filters = sConfig->GetBoolDefault("AuctionHouseBot.DEBUG_FILTERS", false);
+
+    AHBSeller = sConfig->GetBoolDefault("AuctionHouseBot.EnableSeller", false);
+    AHBBuyer = sConfig->GetBoolDefault("AuctionHouseBot.EnableBuyer", false);
+    SellMethod = sConfig->GetBoolDefault("AuctionHouseBot.UseBuyPriceForSeller", false);
+    BuyMethod = sConfig->GetBoolDefault("AuctionHouseBot.UseBuyPriceForBuyer", false);
+
+    AHBplayerAccount = sConfig->GetIntDefault("AuctionHouseBot.Account", 0);
+    AHBplayerGUID = sConfig->GetIntDefault("AuctionHouseBot.GUID", 0);
+    ItemsPerCycle = sConfig->GetIntDefault("AuctionHouseBot.ItemsPerCycle", 200);
+
+    //Begin Filters
+
+    Vendor_Items = sConfig->GetBoolDefault("AuctionHouseBot.VendorItems", false);
+    Loot_Items = sConfig->GetBoolDefault("AuctionHouseBot.LootItems", true);
+    Other_Items = sConfig->GetBoolDefault("AuctionHouseBot.OtherItems", false);
+    Vendor_TGs = sConfig->GetBoolDefault("AuctionHouseBot.VendorTradeGoods", false);
+    Loot_TGs = sConfig->GetBoolDefault("AuctionHouseBot.LootTradeGoods", true);
+    Other_TGs = sConfig->GetBoolDefault("AuctionHouseBot.OtherTradeGoods", false);
+
+    No_Bind = sConfig->GetBoolDefault("AuctionHouseBot.No_Bind", true);
+    Bind_When_Picked_Up = sConfig->GetBoolDefault("AuctionHouseBot.Bind_When_Picked_Up", false);
+    Bind_When_Equipped = sConfig->GetBoolDefault("AuctionHouseBot.Bind_When_Equipped", true);
+    Bind_When_Use = sConfig->GetBoolDefault("AuctionHouseBot.Bind_When_Use", true);
+    Bind_Quest_Item = sConfig->GetBoolDefault("AuctionHouseBot.Bind_Quest_Item", false);
+
+    DisableBeta_PTR_Unused = sConfig->GetBoolDefault("AuctionHouseBot.DisableBeta_PTR_Unused", false);
+    DisablePermEnchant = sConfig->GetBoolDefault("AuctionHouseBot.DisablePermEnchant", false);
+    DisableConjured = sConfig->GetBoolDefault("AuctionHouseBot.DisableConjured", false);
+    DisableGems = sConfig->GetBoolDefault("AuctionHouseBot.DisableGems", false);
+    DisableMoney = sConfig->GetBoolDefault("AuctionHouseBot.DisableMoney", false);
+    DisableMoneyLoot = sConfig->GetBoolDefault("AuctionHouseBot.DisableMoneyLoot", false);
+    DisableLootable = sConfig->GetBoolDefault("AuctionHouseBot.DisableLootable", false);
+    DisableKeys = sConfig->GetBoolDefault("AuctionHouseBot.DisableKeys", false);
+    DisableDuration = sConfig->GetBoolDefault("AuctionHouseBot.DisableDuration", false);
+    DisableBOP_Or_Quest_NoReqLevel = sConfig->GetBoolDefault("AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel", false);
+
+    DisableWarriorItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableWarriorItems", false);
+    DisablePaladinItems = sConfig->GetBoolDefault("AuctionHouseBot.DisablePaladinItems", false);
+    DisableHunterItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableHunterItems", false);
+    DisableRogueItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableRogueItems", false);
+    DisablePriestItems = sConfig->GetBoolDefault("AuctionHouseBot.DisablePriestItems", false);
+    DisableDKItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableDKItems", false);
+    DisableShamanItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableShamanItems", false);
+    DisableMageItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableMageItems", false);
+    DisableWarlockItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableWarlockItems", false);
+    DisableUnusedClassItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableUnusedClassItems", false);
+    DisableDruidItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableDruidItems", false);
+
+    DisableItemsBelowLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsBelowLevel", 0);
+    DisableItemsAboveLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsAboveLevel", 0);
+    DisableTGsBelowLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsBelowLevel", 0);
+    DisableTGsAboveLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsAboveLevel", 0);
+    DisableItemsBelowGUID = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsBelowGUID", 0);
+    DisableItemsAboveGUID = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsAboveGUID", 0);
+    DisableTGsBelowGUID = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsBelowGUID", 0);
+    DisableTGsAboveGUID = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsAboveGUID", 0);
+    DisableItemsBelowReqLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsBelowReqLevel", 0);
+    DisableItemsAboveReqLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsAboveReqLevel", 0);
+    DisableTGsBelowReqLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsBelowReqLevel", 0);
+    DisableTGsAboveReqLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsAboveReqLevel", 0);
+    DisableItemsBelowReqSkillRank = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsBelowReqSkillRank", 0);
+    DisableItemsAboveReqSkillRank = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsAboveReqSkillRank", 0);
+    DisableTGsBelowReqSkillRank = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsBelowReqSkillRank", 0);
+    DisableTGsAboveReqSkillRank = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsAboveReqSkillRank", 0);
+
+    //End Filters
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        LoadValues(&AllianceConfig);
+        LoadValues(&HordeConfig);
+    }
+    LoadValues(&NeutralConfig);
+
+    //
+    // check if the AHBot account/GUID in the config actually exists
+    //
+
+    if ((AHBplayerAccount != 0) || (AHBplayerGUID != 0))
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT 1 FROM characters WHERE account = %u AND guid = %u", AHBplayerAccount, AHBplayerGUID);
+        if (!result)
+       {
+           sLog->outError("AuctionHouseBot: The account/GUID-information set for your AHBot is incorrect (account: %u guid: %u)", AHBplayerAccount, AHBplayerGUID);
+           return;
+        }
+    }
+
+    if (AHBSeller)
+    {
+        QueryResult results = QueryResult(NULL);
+        char npcQuery[] = "SELECT distinct item FROM npc_vendor";
+        results = WorldDatabase.Query(npcQuery);
+        if (results != NULL)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                npcItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+        }
+        else
+        {
+            if (debug_Out) sLog->outString("AuctionHouseBot: \"%s\" failed", npcQuery);
+        }
+
+        char lootQuery[] = "SELECT item FROM creature_loot_template UNION "
+            "SELECT item FROM reference_loot_template UNION "
+            "SELECT item FROM disenchant_loot_template UNION "
+            "SELECT item FROM fishing_loot_template UNION "
+            "SELECT item FROM gameobject_loot_template UNION "
+            "SELECT item FROM item_loot_template UNION "
+            "SELECT item FROM milling_loot_template UNION "
+            "SELECT item FROM pickpocketing_loot_template UNION "
+            "SELECT item FROM prospecting_loot_template UNION "
+            "SELECT item FROM skinning_loot_template";
+
+        results = WorldDatabase.Query(lootQuery);
+        if (results != NULL)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                lootItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+        }
+        else
+        {
+            if (debug_Out) sLog->outString("AuctionHouseBot: \"%s\" failed", lootQuery);
+        }
+
+        for (uint32 itemID = 0; itemID < sItemStorage.MaxEntry; itemID++)
+        {
+            ItemPrototype const* prototype = sObjectMgr->GetItemPrototype(itemID);
+
+            if (prototype == NULL)
+                continue;
+
+            switch (prototype->Bonding)
+            {
+            case NO_BIND:
+                if (!No_Bind)
+                    continue;
+                break;
+            case BIND_WHEN_PICKED_UP:
+                if (!Bind_When_Picked_Up)
+                    continue;
+                break;
+            case BIND_WHEN_EQUIPED:
+                if (!Bind_When_Equipped)
+                    continue;
+                break;
+            case BIND_WHEN_USE:
+                if (!Bind_When_Use)
+                    continue;
+                break;
+            case BIND_QUEST_ITEM:
+                if (!Bind_Quest_Item)
+                    continue;
+                break;
+            default:
+                continue;
+                break;
+            }
+
+            switch (SellMethod)
+            {
+            case 0:
+                if (prototype->SellPrice == 0)
+                    continue;
+                break;
+            case 1:
+                if (prototype->BuyPrice == 0)
+                    continue;
+                break;
+            }
+
+            if ((prototype->Quality < 0) || (prototype->Quality > 6))
+                continue;
+
+            if ((Vendor_Items == 0) && !(prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itemID == npcItems[i])
+                        isVendorItem = true;
+                }
+
+                if (isVendorItem)
+                    continue;
+            }
+
+            if ((Vendor_TGs == 0) && (prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorTG = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorTG); i++)
+                {
+                    if (itemID == npcItems[i])
+                        isVendorTG = true;
+                }
+
+                if (isVendorTG)
+                    continue;
+            }
+
+            if ((Loot_Items == 0) && !(prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itemID == lootItems[i])
+                        isLootItem = true;
+                }
+
+                if (isLootItem)
+                    continue;
+            }
+
+            if ((Loot_TGs == 0) && (prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isLootTG = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootTG); i++)
+                {
+                    if (itemID == lootItems[i])
+                        isLootTG = true;
+                }
+
+                if (isLootTG)
+                    continue;
+            }
+
+            if ((Other_Items == 0) && !(prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorItem = false;
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itemID == npcItems[i])
+                        isVendorItem = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itemID == lootItems[i])
+                        isLootItem = true;
+                }
+                if ((!isLootItem) && (!isVendorItem))
+                    continue;
+            }
+
+            if ((Other_TGs == 0) && (prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorTG = false;
+                bool isLootTG = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorTG); i++)
+                {
+                    if (itemID == npcItems[i])
+                        isVendorTG = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootTG); i++)
+                {
+                    if (itemID == lootItems[i])
+                        isLootTG = true;
+                }
+                if ((!isLootTG) && (!isVendorTG))
+                    continue;
+            }
+
+             //TODO:Make list of items and create a vector
+            // Disable PTR/Beta/Unused items
+            if ((DisableBeta_PTR_Unused) && ((prototype->ItemId == 21878) || (prototype->ItemId == 27774) || (prototype->ItemId == 27811) || (prototype->ItemId == 28117) || (prototype->ItemId == 28112)))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (PTR/Beta/Unused Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable permanent enchants items
+            if ((DisablePermEnchant) && (prototype->Class == ITEM_CLASS_PERMANENT))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Permanent Enchant Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable conjured items
+            if ((DisableConjured) && (prototype->IsConjuredConsumable()))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Conjured Consumable)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable gems
+            if ((DisableGems) && (prototype->Class == ITEM_CLASS_GEM))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Gem)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable money
+            if ((DisableMoney) && (prototype->Class == ITEM_CLASS_MONEY))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Money)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable moneyloot
+            if ((DisableMoneyLoot) && (prototype->MinMoneyLoot > 0))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (MoneyLoot)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable lootable items
+            if ((DisableLootable) && (prototype->Flags & 4))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Lootable Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable Keys
+            if ((DisableKeys) && (prototype->Class == ITEM_CLASS_KEY))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Quest Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items with duration
+            if ((DisableDuration) && (prototype->Duration > 0))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Has a Duration)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items which are BOP or Quest Items and have a required level lower than the item level
+            if ((DisableBOP_Or_Quest_NoReqLevel) && ((prototype->Bonding == BIND_WHEN_PICKED_UP || prototype->Bonding == BIND_QUEST_ITEM) && (prototype->RequiredLevel < prototype->ItemLevel)))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (BOP or BQI and Required Level is less than Item Level)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Warrior
+            if ((DisableWarriorItems) && (prototype->AllowableClass == 1))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Warrior Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Paladin
+            if ((DisablePaladinItems) && (prototype->AllowableClass == 2))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Paladin Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Hunter
+            if ((DisableHunterItems) && (prototype->AllowableClass == 4))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Hunter Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Rogue
+            if ((DisableRogueItems) && (prototype->AllowableClass == 8))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Rogue Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Priest
+            if ((DisablePriestItems) && (prototype->AllowableClass == 16))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Priest Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for DK
+            if ((DisableDKItems) && (prototype->AllowableClass == 32))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (DK Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Shaman
+            if ((DisableShamanItems) && (prototype->AllowableClass == 64))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Shaman Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Mage
+            if ((DisableMageItems) && (prototype->AllowableClass == 128))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Mage Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Warlock
+            if ((DisableWarlockItems) && (prototype->AllowableClass == 256))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Warlock Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Unused Class
+            if ((DisableUnusedClassItems) && (prototype->AllowableClass == 512))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Unused Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Druid
+            if ((DisableDruidItems) && (prototype->AllowableClass == 1024))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Druid Item)", prototype->ItemId);
+                continue;
+            }
+
+             // Disable Items below level X
+            if ((DisableItemsBelowLevel) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel < DisableItemsBelowLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Items above level X
+            if ((DisableItemsAboveLevel) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel > DisableItemsAboveLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+           // Disable Trade Goods below level X
+            if ((DisableTGsBelowLevel) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel < DisableTGsBelowLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (Trade Good Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+           // Disable Trade Goods above level X
+            if ((DisableTGsAboveLevel) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel > DisableTGsAboveLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (Trade Good Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Items below GUID X
+            if ((DisableItemsBelowGUID) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->ItemId < DisableItemsBelowGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Items above GUID X
+            if ((DisableItemsAboveGUID) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->ItemId > DisableItemsAboveGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Trade Goods below GUID X
+            if ((DisableTGsBelowGUID) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->ItemId < DisableTGsBelowGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Trade Good Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Trade Goods above GUID X
+            if ((DisableTGsAboveGUID) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->ItemId > DisableTGsAboveGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Trade Good Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Items for level lower than X
+            if ((DisableItemsBelowReqLevel) && (prototype->RequiredLevel < DisableItemsBelowReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredLevel = %u)", prototype->ItemId, prototype->RequiredLevel);
+                continue;
+            }
+
+            // Disable Items for level higher than X
+            if ((DisableItemsAboveReqLevel) && (prototype->RequiredLevel > DisableItemsAboveReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredLevel = %u)", prototype->ItemId, prototype->RequiredLevel);
+                continue;
+            }
+
+            // Disable Trade Goods for level lower than X
+            if ((DisableTGsBelowReqLevel) && (prototype->RequiredLevel < DisableTGsBelowReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (RequiredLevel = %u)", prototype->ItemId, prototype->RequiredLevel);
+                continue;
+            }
+
+            // Disable Trade Goods for level higher than X
+            if ((DisableTGsAboveReqLevel) && (prototype->RequiredLevel > DisableTGsAboveReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (RequiredLevel = %u)", prototype->ItemId, prototype->RequiredLevel);
+                continue;
+            }
+
+            // Disable Items that require skill lower than X
+            if ((DisableItemsBelowReqSkillRank) && (prototype->RequiredSkillRank < DisableItemsBelowReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", prototype->ItemId, prototype->RequiredSkillRank);
+                continue;
+            }
+
+            // Disable Items that require skill higher than X
+            if ((DisableItemsAboveReqSkillRank) && (prototype->RequiredSkillRank > DisableItemsAboveReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", prototype->ItemId, prototype->RequiredSkillRank);
+                continue;
+            }
+
+            // Disable Trade Goods that require skill lower than X
+            if ((DisableTGsBelowReqSkillRank) && (prototype->RequiredSkillRank < DisableTGsBelowReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", prototype->ItemId, prototype->RequiredSkillRank);
+                continue;
+            }
+
+            // Disable Trade Goods that require skill higher than X
+            if ((DisableTGsAboveReqSkillRank) && (prototype->RequiredSkillRank > DisableTGsAboveReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", prototype->ItemId, prototype->RequiredSkillRank);
+                continue;
+            }
+
+            switch (prototype->Quality)
+            {
+            case AHB_GREY:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    greyTradeGoodsBin.push_back(itemID);
+                else
+                    greyItemsBin.push_back(itemID);
+                break;
+
+            case AHB_WHITE:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    whiteTradeGoodsBin.push_back(itemID);
+                else
+                    whiteItemsBin.push_back(itemID);
+                break;
+
+            case AHB_GREEN:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    greenTradeGoodsBin.push_back(itemID);
+                else
+                    greenItemsBin.push_back(itemID);
+                break;
+
+            case AHB_BLUE:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    blueTradeGoodsBin.push_back(itemID);
+                else
+                    blueItemsBin.push_back(itemID);
+                break;
+
+            case AHB_PURPLE:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    purpleTradeGoodsBin.push_back(itemID);
+                else
+                    purpleItemsBin.push_back(itemID);
+                break;
+
+            case AHB_ORANGE:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    orangeTradeGoodsBin.push_back(itemID);
+                else
+                    orangeItemsBin.push_back(itemID);
+                break;
+
+            case AHB_YELLOW:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    yellowTradeGoodsBin.push_back(itemID);
+                else
+                    yellowItemsBin.push_back(itemID);
+                break;
+            }
+        }
+
+        if ((greyTradeGoodsBin.size() == 0) &&
+            (whiteTradeGoodsBin.size() == 0) &&
+            (greenTradeGoodsBin.size() == 0) &&
+            (blueTradeGoodsBin.size() == 0) &&
+            (purpleTradeGoodsBin.size() == 0) &&
+            (orangeTradeGoodsBin.size() == 0) &&
+            (yellowTradeGoodsBin.size() == 0) &&
+            (greyItemsBin.size() == 0) &&
+            (whiteItemsBin.size() == 0) &&
+            (greenItemsBin.size() == 0) &&
+            (blueItemsBin.size() == 0) &&
+            (purpleItemsBin.size() == 0) &&
+            (orangeItemsBin.size() == 0) &&
+            (yellowItemsBin.size() == 0))
+        {
+            sLog->outError("AuctionHouseBot: No items");
+            AHBSeller = 0;
+        }
+
+        sLog->outString("AuctionHouseBot:");
+        sLog->outString("loaded %u grey trade goods", greyTradeGoodsBin.size());
+        sLog->outString("loaded %u white trade goods", whiteTradeGoodsBin.size());
+        sLog->outString("loaded %u green trade goods", greenTradeGoodsBin.size());
+        sLog->outString("loaded %u blue trade goods", blueTradeGoodsBin.size());
+        sLog->outString("loaded %u purple trade goods", purpleTradeGoodsBin.size());
+        sLog->outString("loaded %u orange trade goods", orangeTradeGoodsBin.size());
+        sLog->outString("loaded %u yellow trade goods", yellowTradeGoodsBin.size());
+        sLog->outString("loaded %u grey items", greyItemsBin.size());
+        sLog->outString("loaded %u white items", whiteItemsBin.size());
+        sLog->outString("loaded %u green items", greenItemsBin.size());
+        sLog->outString("loaded %u blue items", blueItemsBin.size());
+        sLog->outString("loaded %u purple items", purpleItemsBin.size());
+        sLog->outString("loaded %u orange items", orangeItemsBin.size());
+        sLog->outString("loaded %u yellow items", yellowItemsBin.size());
+    }
+    sLog->outString("AuctionHouseBot and AuctionHouseBuyer have been loaded.");
+}
+
+void AuctionHouseBot::IncrementItemCounts(AuctionEntry* ah)
+{
+    // from auctionhousehandler.cpp, creates auction pointer & player pointer
+
+    // get exact item information
+    Item *pItem =  sAuctionMgr->GetAItem(ah->item_guidlow);
+    if (!pItem)
+    {
+        if (debug_Out) sLog->outError("AHBot: Item %u doesn't exist, perhaps bought already?", ah->item_guidlow);
+        return;
+    }
+
+    // get item prototype
+    ItemPrototype const* prototype = sObjectMgr->GetItemPrototype(ah->item_template);
+
+    AHBConfig *config;
+
+    FactionTemplateEntry const* u_entry = sFactionTemplateStore.LookupEntry(ah->GetHouseFaction());
+    if (!u_entry)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_ALLIANCE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Alliance", ah->GetHouseFaction());
+        config = &AllianceConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_HORDE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Horde", ah->GetHouseFaction());
+        config = &HordeConfig;
+    }
+    else
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+
+    config->IncItemCounts(prototype->Class, prototype->Quality);
+}
+
+void AuctionHouseBot::DecrementItemCounts(AuctionEntry* ah, uint32 item_template)
+{
+    // get item prototype
+    ItemPrototype const* prototype = sObjectMgr->GetItemPrototype(item_template);
+
+    AHBConfig *config;
+
+    FactionTemplateEntry const* u_entry = sFactionTemplateStore.LookupEntry(ah->GetHouseFaction());
+    if (!u_entry)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_ALLIANCE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Alliance", ah->GetHouseFaction());
+        config = &AllianceConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_HORDE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Horde", ah->GetHouseFaction());
+        config = &HordeConfig;
+    }
+    else
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+
+    config->DecItemCounts(prototype->Class, prototype->Quality);
+}
+
+void AuctionHouseBot::Commands(uint32 command, uint32 ahMapID, uint32 col, char* args)
+{
+    AHBConfig *config = NULL;
+    switch (ahMapID)
+    {
+    case 2:
+        config = &AllianceConfig;
+        break;
+    case 6:
+        config = &HordeConfig;
+        break;
+    case 7:
+        config = &NeutralConfig;
+        break;
+    }
+    std::string color;
+    switch (col)
+    {
+    case AHB_GREY:
+        color = "grey";
+        break;
+    case AHB_WHITE:
+        color = "white";
+        break;
+    case AHB_GREEN:
+        color = "green";
+        break;
+    case AHB_BLUE:
+        color = "blue";
+        break;
+    case AHB_PURPLE:
+        color = "purple";
+        break;
+    case AHB_ORANGE:
+        color = "orange";
+        break;
+    case AHB_YELLOW:
+        color = "yellow";
+        break;
+    default:
+        break;
+    }
+    switch (command)
+    {
+    case 0:     //ahexpire
+        {
+            AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+
+            AuctionHouseObject::AuctionEntryMap::iterator itr;
+            itr = auctionHouse->GetAuctionsBegin();
+
+            while (itr != auctionHouse->GetAuctionsEnd())
+            {
+                if (itr->second->owner == AHBplayerGUID)
+                {
+                    itr->second->expire_time = sWorld->GetGameTime();
+                    uint32 id = itr->second->Id;
+                    uint32 expire_time = itr->second->expire_time;
+                    CharacterDatabase.PExecute("UPDATE auctionhouse SET time = '%u' WHERE id = '%u'", expire_time, id);
+                }
+                ++itr;
+            }
+        }
+        break;
+    case 1:     //min items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minitems = '%u' WHERE auctionhouse = '%u'", minItems, ahMapID);
+            config->SetMinItems(minItems);
+        }
+        break;
+    case 2:     //max items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxitems = '%u' WHERE auctionhouse = '%u'", maxItems, ahMapID);
+            config->SetMaxItems(maxItems);
+            config->CalculatePercents();
+        }
+        break;
+    case 3:     //min time Deprecated (Place holder for future commands)
+        break;
+    case 4:     //max time Deprecated (Place holder for future commands)
+        break;
+    case 5:     //percentages
+        {
+            char * param1 = strtok(args, " ");
+            char * param2 = strtok(NULL, " ");
+            char * param3 = strtok(NULL, " ");
+            char * param4 = strtok(NULL, " ");
+            char * param5 = strtok(NULL, " ");
+            char * param6 = strtok(NULL, " ");
+            char * param7 = strtok(NULL, " ");
+            char * param8 = strtok(NULL, " ");
+            char * param9 = strtok(NULL, " ");
+            char * param10 = strtok(NULL, " ");
+            char * param11 = strtok(NULL, " ");
+            char * param12 = strtok(NULL, " ");
+            char * param13 = strtok(NULL, " ");
+            char * param14 = strtok(NULL, " ");
+            uint32 greytg = (uint32) strtoul(param1, NULL, 0);
+            uint32 whitetg = (uint32) strtoul(param2, NULL, 0);
+            uint32 greentg = (uint32) strtoul(param3, NULL, 0);
+            uint32 bluetg = (uint32) strtoul(param4, NULL, 0);
+            uint32 purpletg = (uint32) strtoul(param5, NULL, 0);
+            uint32 orangetg = (uint32) strtoul(param6, NULL, 0);
+            uint32 yellowtg = (uint32) strtoul(param7, NULL, 0);
+            uint32 greyi = (uint32) strtoul(param8, NULL, 0);
+            uint32 whitei = (uint32) strtoul(param9, NULL, 0);
+            uint32 greeni = (uint32) strtoul(param10, NULL, 0);
+            uint32 bluei = (uint32) strtoul(param11, NULL, 0);
+            uint32 purplei = (uint32) strtoul(param12, NULL, 0);
+            uint32 orangei = (uint32) strtoul(param13, NULL, 0);
+            uint32 yellowi = (uint32) strtoul(param14, NULL, 0);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            trans->PAppend("UPDATE auctionhousebot SET percentgreytradegoods = '%u' WHERE auctionhouse = '%u'", greytg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentwhitetradegoods = '%u' WHERE auctionhouse = '%u'", whitetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreentradegoods = '%u' WHERE auctionhouse = '%u'", greentg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentbluetradegoods = '%u' WHERE auctionhouse = '%u'", bluetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentpurpletradegoods = '%u' WHERE auctionhouse = '%u'", purpletg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentorangetradegoods = '%u' WHERE auctionhouse = '%u'", orangetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentyellowtradegoods = '%u' WHERE auctionhouse = '%u'", yellowtg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreyitems = '%u' WHERE auctionhouse = '%u'", greyi, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentwhiteitems = '%u' WHERE auctionhouse = '%u'", whitei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreenitems = '%u' WHERE auctionhouse = '%u'", greeni, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentblueitems = '%u' WHERE auctionhouse = '%u'", bluei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentpurpleitems = '%u' WHERE auctionhouse = '%u'", purplei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentorangeitems = '%u' WHERE auctionhouse = '%u'", orangei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentyellowitems = '%u' WHERE auctionhouse = '%u'", yellowi, ahMapID);
+            CharacterDatabase.CommitTransaction( trans);
+            config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        }
+        break;
+    case 6:     //min prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minPrice, ahMapID);
+            config->SetMinPrice(col, minPrice);
+        }
+        break;
+    case 7:     //max prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxPrice, ahMapID);
+            config->SetMaxPrice(col, maxPrice);
+        }
+        break;
+    case 8:     //min bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minBidPrice, ahMapID);
+            config->SetMinBidPrice(col, minBidPrice);
+        }
+        break;
+    case 9:     //max bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxBidPrice, ahMapID);
+            config->SetMaxBidPrice(col, maxBidPrice);
+        }
+        break;
+    case 10:        //max stacks
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxStack = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxstack%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxStack, ahMapID);
+            config->SetMaxStack(col, maxStack);
+        }
+        break;
+    case 11:        //buyer bid prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 buyerPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), buyerPrice, ahMapID);
+            config->SetBuyerPrice(col, buyerPrice);
+        }
+        break;
+    case 12:        //buyer bidding interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbiddinginterval = '%u' WHERE auctionhouse = '%u'", bidInterval, ahMapID);
+            config->SetBiddingInterval(bidInterval);
+        }
+        break;
+    case 13:        //buyer bids per interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidsPerInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbidsperinterval = '%u' WHERE auctionhouse = '%u'", bidsPerInterval, ahMapID);
+            config->SetBidsPerInterval(bidsPerInterval);
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+void AuctionHouseBot::LoadValues(AHBConfig *config)
+{
+    if (debug_Out) sLog->outString(((std::string)("Start Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetString())).c_str());
+    if (AHBSeller)
+    {
+        //load min and max items
+        config->SetMinItems(CharacterDatabase.PQuery("SELECT minitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxItems(CharacterDatabase.PQuery("SELECT maxitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load percentages
+        uint32 greytg = CharacterDatabase.PQuery("SELECT percentgreytradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitetg = CharacterDatabase.PQuery("SELECT percentwhitetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greentg = CharacterDatabase.PQuery("SELECT percentgreentradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluetg = CharacterDatabase.PQuery("SELECT percentbluetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purpletg = CharacterDatabase.PQuery("SELECT percentpurpletradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangetg = CharacterDatabase.PQuery("SELECT percentorangetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowtg = CharacterDatabase.PQuery("SELECT percentyellowtradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greyi = CharacterDatabase.PQuery("SELECT percentgreyitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitei = CharacterDatabase.PQuery("SELECT percentwhiteitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greeni = CharacterDatabase.PQuery("SELECT percentgreenitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluei = CharacterDatabase.PQuery("SELECT percentblueitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purplei = CharacterDatabase.PQuery("SELECT percentpurpleitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangei = CharacterDatabase.PQuery("SELECT percentorangeitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowi = CharacterDatabase.PQuery("SELECT percentyellowitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        //load min and max prices
+        config->SetMinPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load min and max bid prices
+        config->SetMinBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load max stacks
+        config->SetMaxStack(AHB_GREY, CharacterDatabase.PQuery("SELECT maxstackgrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxstackwhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxstackgreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxstackblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxstackpurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxstackorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxstackyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog->outString("minItems                = %u", config->GetMinItems());
+            sLog->outString("maxItems                = %u", config->GetMaxItems());
+            sLog->outString("percentGreyTradeGoods   = %u", config->GetPercentages(AHB_GREY_TG));
+            sLog->outString("percentWhiteTradeGoods  = %u", config->GetPercentages(AHB_WHITE_TG));
+            sLog->outString("percentGreenTradeGoods  = %u", config->GetPercentages(AHB_GREEN_TG));
+            sLog->outString("percentBlueTradeGoods   = %u", config->GetPercentages(AHB_BLUE_TG));
+            sLog->outString("percentPurpleTradeGoods = %u", config->GetPercentages(AHB_PURPLE_TG));
+            sLog->outString("percentOrangeTradeGoods = %u", config->GetPercentages(AHB_ORANGE_TG));
+            sLog->outString("percentYellowTradeGoods = %u", config->GetPercentages(AHB_YELLOW_TG));
+            sLog->outString("percentGreyItems        = %u", config->GetPercentages(AHB_GREY_I));
+            sLog->outString("percentWhiteItems       = %u", config->GetPercentages(AHB_WHITE_I));
+            sLog->outString("percentGreenItems       = %u", config->GetPercentages(AHB_GREEN_I));
+            sLog->outString("percentBlueItems        = %u", config->GetPercentages(AHB_BLUE_I));
+            sLog->outString("percentPurpleItems      = %u", config->GetPercentages(AHB_PURPLE_I));
+            sLog->outString("percentOrangeItems      = %u", config->GetPercentages(AHB_ORANGE_I));
+            sLog->outString("percentYellowItems      = %u", config->GetPercentages(AHB_YELLOW_I));
+            sLog->outString("minPriceGrey            = %u", config->GetMinPrice(AHB_GREY));
+            sLog->outString("maxPriceGrey            = %u", config->GetMaxPrice(AHB_GREY));
+            sLog->outString("minPriceWhite           = %u", config->GetMinPrice(AHB_WHITE));
+            sLog->outString("maxPriceWhite           = %u", config->GetMaxPrice(AHB_WHITE));
+            sLog->outString("minPriceGreen           = %u", config->GetMinPrice(AHB_GREEN));
+            sLog->outString("maxPriceGreen           = %u", config->GetMaxPrice(AHB_GREEN));
+            sLog->outString("minPriceBlue            = %u", config->GetMinPrice(AHB_BLUE));
+            sLog->outString("maxPriceBlue            = %u", config->GetMaxPrice(AHB_BLUE));
+            sLog->outString("minPricePurple          = %u", config->GetMinPrice(AHB_PURPLE));
+            sLog->outString("maxPricePurple          = %u", config->GetMaxPrice(AHB_PURPLE));
+            sLog->outString("minPriceOrange          = %u", config->GetMinPrice(AHB_ORANGE));
+            sLog->outString("maxPriceOrange          = %u", config->GetMaxPrice(AHB_ORANGE));
+            sLog->outString("minPriceYellow          = %u", config->GetMinPrice(AHB_YELLOW));
+            sLog->outString("maxPriceYellow          = %u", config->GetMaxPrice(AHB_YELLOW));
+            sLog->outString("minBidPriceGrey         = %u", config->GetMinBidPrice(AHB_GREY));
+            sLog->outString("maxBidPriceGrey         = %u", config->GetMaxBidPrice(AHB_GREY));
+            sLog->outString("minBidPriceWhite        = %u", config->GetMinBidPrice(AHB_WHITE));
+            sLog->outString("maxBidPriceWhite        = %u", config->GetMaxBidPrice(AHB_WHITE));
+            sLog->outString("minBidPriceGreen        = %u", config->GetMinBidPrice(AHB_GREEN));
+            sLog->outString("maxBidPriceGreen        = %u", config->GetMaxBidPrice(AHB_GREEN));
+            sLog->outString("minBidPriceBlue         = %u", config->GetMinBidPrice(AHB_BLUE));
+            sLog->outString("maxBidPriceBlue         = %u", config->GetMinBidPrice(AHB_BLUE));
+            sLog->outString("minBidPricePurple       = %u", config->GetMinBidPrice(AHB_PURPLE));
+            sLog->outString("maxBidPricePurple       = %u", config->GetMaxBidPrice(AHB_PURPLE));
+            sLog->outString("minBidPriceOrange       = %u", config->GetMinBidPrice(AHB_ORANGE));
+            sLog->outString("maxBidPriceOrange       = %u", config->GetMaxBidPrice(AHB_ORANGE));
+            sLog->outString("minBidPriceYellow       = %u", config->GetMinBidPrice(AHB_YELLOW));
+            sLog->outString("maxBidPriceYellow       = %u", config->GetMaxBidPrice(AHB_YELLOW));
+            sLog->outString("maxStackGrey            = %u", config->GetMaxStack(AHB_GREY));
+            sLog->outString("maxStackWhite           = %u", config->GetMaxStack(AHB_WHITE));
+            sLog->outString("maxStackGreen           = %u", config->GetMaxStack(AHB_GREEN));
+            sLog->outString("maxStackBlue            = %u", config->GetMaxStack(AHB_BLUE));
+            sLog->outString("maxStackPurple          = %u", config->GetMaxStack(AHB_PURPLE));
+            sLog->outString("maxStackOrange          = %u", config->GetMaxStack(AHB_ORANGE));
+            sLog->outString("maxStackYellow          = %u", config->GetMaxStack(AHB_YELLOW));
+        }
+        //AuctionHouseEntry const* ahEntry =  sAuctionMgr->GetAuctionHouseEntry(config->GetAHFID());
+        AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+
+        config->ResetItemCounts();
+        uint32 auctions = auctionHouse->Getcount();
+
+        if (auctions)
+        {
+            for (AuctionHouseObject::AuctionEntryMap::const_iterator itr = auctionHouse->GetAuctionsBegin(); itr != auctionHouse->GetAuctionsEnd(); ++itr)
+            {
+                AuctionEntry *Aentry = itr->second;
+                Item *item =  sAuctionMgr->GetAItem(Aentry->item_guidlow);
+                if (item)
+                {
+                    ItemPrototype const *prototype = item->GetProto();
+                    if (prototype)
+                    {
+                        switch (prototype->Quality)
+                        {
+                        case 0:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_GREY_TG);
+                            else
+                                config->IncItemCounts(AHB_GREY_I);
+                            break;
+                        case 1:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_WHITE_TG);
+                            else
+                                config->IncItemCounts(AHB_WHITE_I);
+                            break;
+                        case 2:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_GREEN_TG);
+                            else
+                                config->IncItemCounts(AHB_GREEN_I);
+                            break;
+                        case 3:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_BLUE_TG);
+                            else
+                                config->IncItemCounts(AHB_BLUE_I);
+                            break;
+                        case 4:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_PURPLE_TG);
+                            else
+                                config->IncItemCounts(AHB_PURPLE_I);
+                            break;
+                        case 5:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_ORANGE_TG);
+                            else
+                                config->IncItemCounts(AHB_ORANGE_I);
+                            break;
+                        case 6:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_YELLOW_TG);
+                            else
+                                config->IncItemCounts(AHB_YELLOW_I);
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        if (debug_Out)
+        {
+            sLog->outString(((std::string)("Current Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetString())).c_str());
+            sLog->outString("Grey Trade Goods\t%u\tGrey Items\t%u", config->GetItemCounts(AHB_GREY_TG), config->GetItemCounts(AHB_GREY_I));
+            sLog->outString("White Trade Goods\t%u\tWhite Items\t%u", config->GetItemCounts(AHB_WHITE_TG), config->GetItemCounts(AHB_WHITE_I));
+            sLog->outString("Green Trade Goods\t%u\tGreen Items\t%u", config->GetItemCounts(AHB_GREEN_TG), config->GetItemCounts(AHB_GREEN_I));
+            sLog->outString("Blue Trade Goods\t%u\tBlue Items\t%u", config->GetItemCounts(AHB_BLUE_TG), config->GetItemCounts(AHB_BLUE_I));
+            sLog->outString("Purple Trade Goods\t%u\tPurple Items\t%u", config->GetItemCounts(AHB_PURPLE_TG), config->GetItemCounts(AHB_PURPLE_I));
+            sLog->outString("Orange Trade Goods\t%u\tOrange Items\t%u", config->GetItemCounts(AHB_ORANGE_TG), config->GetItemCounts(AHB_ORANGE_I));
+            sLog->outString("Yellow Trade Goods\t%u\tYellow Items\t%u", config->GetItemCounts(AHB_YELLOW_TG), config->GetItemCounts(AHB_YELLOW_I));
+        }
+    }
+    if (AHBBuyer)
+    {
+        //load buyer bid prices
+        config->SetBuyerPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT buyerpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT buyerpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT buyerpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT buyerpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT buyerpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT buyerpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT buyerpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load bidding interval
+        config->SetBiddingInterval(CharacterDatabase.PQuery("SELECT buyerbiddinginterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load bids per interval
+        config->SetBidsPerInterval(CharacterDatabase.PQuery("SELECT buyerbidsperinterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog->outString("buyerPriceGrey          = %u", config->GetBuyerPrice(AHB_GREY));
+            sLog->outString("buyerPriceWhite         = %u", config->GetBuyerPrice(AHB_WHITE));
+            sLog->outString("buyerPriceGreen         = %u", config->GetBuyerPrice(AHB_GREEN));
+            sLog->outString("buyerPriceBlue          = %u", config->GetBuyerPrice(AHB_BLUE));
+            sLog->outString("buyerPricePurple        = %u", config->GetBuyerPrice(AHB_PURPLE));
+            sLog->outString("buyerPriceOrange        = %u", config->GetBuyerPrice(AHB_ORANGE));
+            sLog->outString("buyerPriceYellow        = %u", config->GetBuyerPrice(AHB_YELLOW));
+            sLog->outString("buyerBiddingInterval    = %u", config->GetBiddingInterval());
+            sLog->outString("buyerBidsPerInterval    = %u", config->GetBidsPerInterval());
+        }
+    }
+    if (debug_Out) sLog->outString(((std::string)("End Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetString())).c_str());
+}
diff --git a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
new file mode 100644
index 0000000..6c3cf82
--- /dev/null
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
@@ -0,0 +1,1247 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef AUCTION_HOUSE_BOT_H
+#define AUCTION_HOUSE_BOT_H
+
+#include "World.h"
+#include "Config.h"
+#include "ItemPrototype.h"
+
+#define AHB_GREY        0
+#define AHB_WHITE       1
+#define AHB_GREEN       2
+#define AHB_BLUE        3
+#define AHB_PURPLE      4
+#define AHB_ORANGE      5
+#define AHB_YELLOW      6
+#define AHB_MAX_QUALITY 6
+#define AHB_GREY_TG     0
+#define AHB_WHITE_TG    1
+#define AHB_GREEN_TG    2
+#define AHB_BLUE_TG     3
+#define AHB_PURPLE_TG   4
+#define AHB_ORANGE_TG   5
+#define AHB_YELLOW_TG   6
+#define AHB_GREY_I      7
+#define AHB_WHITE_I     8
+#define AHB_GREEN_I     9
+#define AHB_BLUE_I      10
+#define AHB_PURPLE_I    11
+#define AHB_ORANGE_I    12
+#define AHB_YELLOW_I    13
+
+class AHBConfig
+{
+private:
+    uint32 AHID;
+    uint32 AHFID;
+    uint32 minItems;
+    uint32 maxItems;
+    uint32 percentGreyTradeGoods;
+    uint32 percentWhiteTradeGoods;
+    uint32 percentGreenTradeGoods;
+    uint32 percentBlueTradeGoods;
+    uint32 percentPurpleTradeGoods;
+    uint32 percentOrangeTradeGoods;
+    uint32 percentYellowTradeGoods;
+    uint32 percentGreyItems;
+    uint32 percentWhiteItems;
+    uint32 percentGreenItems;
+    uint32 percentBlueItems;
+    uint32 percentPurpleItems;
+    uint32 percentOrangeItems;
+    uint32 percentYellowItems;
+    uint32 minPriceGrey;
+    uint32 maxPriceGrey;
+    uint32 minBidPriceGrey;
+    uint32 maxBidPriceGrey;
+    uint32 maxStackGrey;
+    uint32 minPriceWhite;
+    uint32 maxPriceWhite;
+    uint32 minBidPriceWhite;
+    uint32 maxBidPriceWhite;
+    uint32 maxStackWhite;
+    uint32 minPriceGreen;
+    uint32 maxPriceGreen;
+    uint32 minBidPriceGreen;
+    uint32 maxBidPriceGreen;
+    uint32 maxStackGreen;
+    uint32 minPriceBlue;
+    uint32 maxPriceBlue;
+    uint32 minBidPriceBlue;
+    uint32 maxBidPriceBlue;
+    uint32 maxStackBlue;
+    uint32 minPricePurple;
+    uint32 maxPricePurple;
+    uint32 minBidPricePurple;
+    uint32 maxBidPricePurple;
+    uint32 maxStackPurple;
+    uint32 minPriceOrange;
+    uint32 maxPriceOrange;
+    uint32 minBidPriceOrange;
+    uint32 maxBidPriceOrange;
+    uint32 maxStackOrange;
+    uint32 minPriceYellow;
+    uint32 maxPriceYellow;
+    uint32 minBidPriceYellow;
+    uint32 maxBidPriceYellow;
+    uint32 maxStackYellow;
+
+    uint32 buyerPriceGrey;
+    uint32 buyerPriceWhite;
+    uint32 buyerPriceGreen;
+    uint32 buyerPriceBlue;
+    uint32 buyerPricePurple;
+    uint32 buyerPriceOrange;
+    uint32 buyerPriceYellow;
+    uint32 buyerBiddingInterval;
+    uint32 buyerBidsPerInterval;
+
+    uint32 greytgp;
+    uint32 whitetgp;
+    uint32 greentgp;
+    uint32 bluetgp;
+    uint32 purpletgp;
+    uint32 orangetgp;
+    uint32 yellowtgp;
+    uint32 greyip;
+    uint32 whiteip;
+    uint32 greenip;
+    uint32 blueip;
+    uint32 purpleip;
+    uint32 orangeip;
+    uint32 yellowip;
+
+    uint32 greyTGoods;
+    uint32 whiteTGoods;
+    uint32 greenTGoods;
+    uint32 blueTGoods;
+    uint32 purpleTGoods;
+    uint32 orangeTGoods;
+    uint32 yellowTGoods;
+
+    uint32 greyItems;
+    uint32 whiteItems;
+    uint32 greenItems;
+    uint32 blueItems;
+    uint32 purpleItems;
+    uint32 orangeItems;
+    uint32 yellowItems;
+
+public:
+    AHBConfig(uint32 ahid)
+    {
+        AHID = ahid;
+        switch(ahid)
+        {
+        case 2:
+            AHFID = 55;
+            break;
+        case 6:
+            AHFID = 29;
+            break;
+        case 7:
+            AHFID = 120;
+            break;
+        default:
+            AHFID = 120;
+            break;
+        }
+    }
+    AHBConfig()
+    {
+    }
+    uint32 GetAHID()
+    {
+        return AHID;
+    }
+    uint32 GetAHFID()
+    {
+        return AHFID;
+    }
+    void SetMinItems(uint32 value)
+    {
+        minItems = value;
+    }
+    uint32 GetMinItems()
+    {
+        if ((minItems == 0) && (maxItems))
+            return maxItems;
+        else if ((maxItems) && (minItems > maxItems))
+            return maxItems;
+        else
+            return minItems;
+    }
+    void SetMaxItems(uint32 value)
+    {
+        maxItems = value;
+    // CalculatePercents() needs to be called, but only if
+    // SetPercentages() has been called at least once already.
+    }
+    uint32 GetMaxItems()
+    {
+        return maxItems;
+    }
+    void SetPercentages(uint32 greytg, uint32 whitetg, uint32 greentg, uint32 bluetg, uint32 purpletg, uint32 orangetg, uint32 yellowtg, uint32 greyi, uint32 whitei, uint32 greeni, uint32 bluei, uint32 purplei, uint32 orangei, uint32 yellowi)
+    {
+        uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+
+        if (totalPercent == 0)
+        {
+            maxItems = 0;
+        }
+        else if (totalPercent != 100)
+        {
+            greytg = 0;
+            whitetg = 27;
+            greentg = 12;
+            bluetg = 10;
+            purpletg = 1;
+            orangetg = 0;
+            yellowtg = 0;
+            greyi = 0;
+            whitei = 10;
+            greeni = 30;
+            bluei = 8;
+            purplei = 2;
+            orangei = 0;
+            yellowi = 0;
+        }
+        percentGreyTradeGoods = greytg;
+        percentWhiteTradeGoods = whitetg;
+        percentGreenTradeGoods = greentg;
+        percentBlueTradeGoods = bluetg;
+        percentPurpleTradeGoods = purpletg;
+        percentOrangeTradeGoods = orangetg;
+        percentYellowTradeGoods = yellowtg;
+        percentGreyItems = greyi;
+        percentWhiteItems = whitei;
+        percentGreenItems = greeni;
+        percentBlueItems = bluei;
+        percentPurpleItems = purplei;
+        percentOrangeItems = orangei;
+        percentYellowItems = yellowi;
+        CalculatePercents();
+    }
+    uint32 GetPercentages(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return percentGreyTradeGoods;
+            break;
+        case AHB_WHITE_TG:
+            return percentWhiteTradeGoods;
+            break;
+        case AHB_GREEN_TG:
+            return percentGreenTradeGoods;
+            break;
+        case AHB_BLUE_TG:
+            return percentBlueTradeGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return percentPurpleTradeGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return percentOrangeTradeGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return percentYellowTradeGoods;
+            break;
+        case AHB_GREY_I:
+            return percentGreyItems;
+            break;
+        case AHB_WHITE_I:
+            return percentWhiteItems;
+            break;
+        case AHB_GREEN_I:
+            return percentGreenItems;
+            break;
+        case AHB_BLUE_I:
+            return percentBlueItems;
+            break;
+        case AHB_PURPLE_I:
+            return percentPurpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return percentOrangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return percentYellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetMinPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minPriceGrey == 0)
+                    return 100;
+                else if (minPriceGrey > maxPriceGrey)
+                    return maxPriceGrey;
+                else
+                    return minPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minPriceWhite == 0)
+                    return 150;
+                else if (minPriceWhite > maxPriceWhite)
+                    return maxPriceWhite;
+                else
+                    return minPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minPriceGreen == 0)
+                    return 200;
+                else if (minPriceGreen > maxPriceGreen)
+                    return maxPriceGreen;
+                else
+                    return minPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minPriceBlue == 0)
+                    return 250;
+                else if (minPriceBlue > maxPriceBlue)
+                    return maxPriceBlue;
+                else
+                    return minPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minPricePurple == 0)
+                    return 300;
+                else if (minPricePurple > maxPricePurple)
+                    return maxPricePurple;
+                else
+                    return minPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minPriceOrange == 0)
+                    return 400;
+                else if (minPriceOrange > maxPriceOrange)
+                    return maxPriceOrange;
+                else
+                    return minPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minPriceYellow == 0)
+                    return 500;
+                else if (minPriceYellow > maxPriceYellow)
+                    return maxPriceYellow;
+                else
+                    return minPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxPriceGrey == 0)
+                    return 150;
+                else
+                    return maxPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxPriceWhite == 0)
+                    return 250;
+                else
+                    return maxPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxPriceGreen == 0)
+                    return 300;
+                else
+                    return maxPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxPriceBlue == 0)
+                    return 350;
+                else
+                    return maxPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxPricePurple == 0)
+                    return 450;
+                else
+                    return maxPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxPriceOrange == 0)
+                    return 550;
+                else
+                    return maxPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxPriceYellow == 0)
+                    return 650;
+                else
+                    return maxPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMinBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minBidPriceGrey > 100)
+                    return 100;
+                else
+                    return minBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minBidPriceWhite > 100)
+                    return 100;
+                else
+                    return minBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minBidPriceGreen > 100)
+                    return 100;
+                else
+                    return minBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minBidPriceBlue > 100)
+                    return 100;
+                else
+                    return minBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minBidPricePurple > 100)
+                    return 100;
+                else
+                    return minBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minBidPriceOrange > 100)
+                    return 100;
+                else
+                    return minBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minBidPriceYellow > 100)
+                    return 100;
+                else
+                    return minBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxBidPriceGrey > 100)
+                    return 100;
+                else
+                    return maxBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxBidPriceWhite > 100)
+                    return 100;
+                else
+                    return maxBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxBidPriceGreen > 100)
+                    return 100;
+                else
+                    return maxBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxBidPriceBlue > 100)
+                    return 100;
+                else
+                    return maxBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxBidPricePurple > 100)
+                    return 100;
+                else
+                    return maxBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxBidPriceOrange > 100)
+                    return 100;
+                else
+                    return maxBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxBidPriceYellow > 100)
+                    return 100;
+                else
+                    return maxBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxStack(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxStackGrey = value;
+            break;
+        case AHB_WHITE:
+            maxStackWhite = value;
+            break;
+        case AHB_GREEN:
+            maxStackGreen = value;
+            break;
+        case AHB_BLUE:
+            maxStackBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxStackPurple = value;
+            break;
+        case AHB_ORANGE:
+            maxStackOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxStackYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxStack(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                return maxStackGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                return maxStackWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                return maxStackGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                return maxStackBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                return maxStackPurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                return maxStackOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                return maxStackYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetBuyerPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            buyerPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            buyerPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            buyerPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            buyerPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            buyerPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            buyerPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            buyerPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetBuyerPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            return buyerPriceGrey;
+            break;
+        case AHB_WHITE:
+            return buyerPriceWhite;
+            break;
+        case AHB_GREEN:
+            return buyerPriceGreen;
+            break;
+        case AHB_BLUE:
+            return buyerPriceBlue;
+            break;
+        case AHB_PURPLE:
+            return buyerPricePurple;
+            break;
+        case AHB_ORANGE:
+            return buyerPriceOrange;
+            break;
+        case AHB_YELLOW:
+            return buyerPriceYellow;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBiddingInterval(uint32 value)
+    {
+        buyerBiddingInterval = value;
+    }
+    uint32 GetBiddingInterval()
+    {
+        return buyerBiddingInterval;
+    }
+    void CalculatePercents()
+    {
+        greytgp = (uint32) (((double)percentGreyTradeGoods / 100.0) * maxItems);
+        whitetgp = (uint32) (((double)percentWhiteTradeGoods / 100.0) * maxItems);
+        greentgp = (uint32) (((double)percentGreenTradeGoods / 100.0) * maxItems);
+        bluetgp = (uint32) (((double)percentBlueTradeGoods / 100.0) * maxItems);
+        purpletgp = (uint32) (((double)percentPurpleTradeGoods / 100.0) * maxItems);
+        orangetgp = (uint32) (((double)percentOrangeTradeGoods / 100.0) * maxItems);
+        yellowtgp = (uint32) (((double)percentYellowTradeGoods / 100.0) * maxItems);
+        greyip = (uint32) (((double)percentGreyItems / 100.0) * maxItems);
+        whiteip = (uint32) (((double)percentWhiteItems / 100.0) * maxItems);
+        greenip = (uint32) (((double)percentGreenItems / 100.0) * maxItems);
+        blueip = (uint32) (((double)percentBlueItems / 100.0) * maxItems);
+        purpleip = (uint32) (((double)percentPurpleItems / 100.0) * maxItems);
+        orangeip = (uint32) (((double)percentOrangeItems / 100.0) * maxItems);
+        yellowip = (uint32) (((double)percentYellowItems / 100.0) * maxItems);
+        uint32 total = greytgp + whitetgp + greentgp + bluetgp + purpletgp + orangetgp + yellowtgp + greyip + whiteip + greenip + blueip + purpleip + orangeip + yellowip;
+        int32 diff = (maxItems - total);
+        if (diff < 0)
+        {
+            if ((whiteip - diff) > 0)
+                whiteip -= diff;
+            else if ((greenip - diff) > 0)
+                greenip -= diff;
+        }
+        else if (diff < 0)
+        {
+            whiteip += diff;
+        }
+    }
+    uint32 GetPercents(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greytgp;
+            break;
+        case AHB_WHITE_TG:
+            return whitetgp;
+            break;
+        case AHB_GREEN_TG:
+            return greentgp;
+            break;
+        case AHB_BLUE_TG:
+            return bluetgp;
+            break;
+        case AHB_PURPLE_TG:
+            return purpletgp;
+            break;
+        case AHB_ORANGE_TG:
+            return orangetgp;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowtgp;
+            break;
+        case AHB_GREY_I:
+            return greyip;
+            break;
+        case AHB_WHITE_I:
+            return whiteip;
+            break;
+        case AHB_GREEN_I:
+            return greenip;
+            break;
+        case AHB_BLUE_I:
+            return blueip;
+            break;
+        case AHB_PURPLE_I:
+            return purpleip;
+            break;
+        case AHB_ORANGE_I:
+            return orangeip;
+            break;
+        case AHB_YELLOW_I:
+            return yellowip;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+
+    void DecItemCounts(uint32 Class, uint32 Quality)
+    {
+        switch(Class)
+        {
+        case ITEM_CLASS_TRADE_GOODS:
+            DecItemCounts(Quality);
+            break;
+        default:
+            DecItemCounts(Quality + 7);
+            break;
+        }
+    }
+
+    void DecItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            --greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            --whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            --greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            --blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            --purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            --orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            --yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            --greyItems;
+            break;
+        case AHB_WHITE_I:
+            --whiteItems;
+            break;
+        case AHB_GREEN_I:
+            --greenItems;
+            break;
+        case AHB_BLUE_I:
+            --blueItems;
+            break;
+        case AHB_PURPLE_I:
+            --purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            --orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            --yellowItems;
+            break;
+        default:
+            break;
+        }
+    }
+
+    void IncItemCounts(uint32 Class, uint32 Quality)
+    {
+        switch(Class)
+        {
+        case ITEM_CLASS_TRADE_GOODS:
+            IncItemCounts(Quality);
+            break;
+        default:
+            IncItemCounts(Quality + 7);
+            break;
+        }
+    }
+
+    void IncItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            ++greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            ++whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            ++greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            ++blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            ++purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            ++orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            ++yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            ++greyItems;
+            break;
+        case AHB_WHITE_I:
+            ++whiteItems;
+            break;
+        case AHB_GREEN_I:
+            ++greenItems;
+            break;
+        case AHB_BLUE_I:
+            ++blueItems;
+            break;
+        case AHB_PURPLE_I:
+            ++purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            ++orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            ++yellowItems;
+            break;
+        default:
+            break;
+        }
+    }
+
+    void ResetItemCounts()
+    {
+        greyTGoods = 0;
+        whiteTGoods = 0;
+        greenTGoods = 0;
+        blueTGoods = 0;
+        purpleTGoods = 0;
+        orangeTGoods = 0;
+        yellowTGoods = 0;
+
+        greyItems = 0;
+        whiteItems = 0;
+        greenItems = 0;
+        blueItems = 0;
+        purpleItems = 0;
+        orangeItems = 0;
+        yellowItems = 0;
+    }
+
+    uint32 TotalItemCounts()
+    {
+        return(
+        greyTGoods +
+        whiteTGoods +
+        greenTGoods +
+        blueTGoods +
+        purpleTGoods +
+        orangeTGoods +
+        yellowTGoods +
+
+        greyItems +
+        whiteItems +
+        greenItems +
+        blueItems +
+        purpleItems +
+        orangeItems +
+        yellowItems);
+    }
+
+    uint32 GetItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            return whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            return greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            return blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            return greyItems;
+            break;
+        case AHB_WHITE_I:
+            return whiteItems;
+            break;
+        case AHB_GREEN_I:
+            return greenItems;
+            break;
+        case AHB_BLUE_I:
+            return blueItems;
+            break;
+        case AHB_PURPLE_I:
+            return purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return yellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBidsPerInterval(uint32 value)
+    {
+        buyerBidsPerInterval = value;
+    }
+    uint32 GetBidsPerInterval()
+    {
+        return buyerBidsPerInterval;
+    }
+    ~AHBConfig()
+    {
+    }
+};
+class AuctionHouseBot
+{
+private:
+
+    bool debug_Out;
+    bool debug_Out_Filters;
+
+    bool AHBSeller;
+    bool AHBBuyer;
+    bool BuyMethod;
+    bool SellMethod;
+
+    uint32 AHBplayerAccount;
+    uint32 AHBplayerGUID;
+    uint32 ItemsPerCycle;
+
+    //Begin Filters
+
+    bool Vendor_Items;
+    bool Loot_Items;
+    bool Other_Items;
+    bool Vendor_TGs;
+    bool Loot_TGs;
+    bool Other_TGs;
+
+    bool No_Bind;
+    bool Bind_When_Picked_Up;
+    bool Bind_When_Equipped;
+    bool Bind_When_Use;
+    bool Bind_Quest_Item;
+
+    bool DisableBeta_PTR_Unused;
+    bool DisablePermEnchant;
+    bool DisableConjured;
+    bool DisableGems;
+    bool DisableMoney;
+    bool DisableMoneyLoot;
+    bool DisableLootable;
+    bool DisableKeys;
+    bool DisableDuration;
+    bool DisableBOP_Or_Quest_NoReqLevel;
+
+    bool DisableWarriorItems;
+    bool DisablePaladinItems;
+    bool DisableHunterItems;
+    bool DisableRogueItems;
+    bool DisablePriestItems;
+    bool DisableDKItems;
+    bool DisableShamanItems;
+    bool DisableMageItems;
+    bool DisableWarlockItems;
+    bool DisableUnusedClassItems;
+    bool DisableDruidItems;
+
+    uint32 DisableItemsBelowLevel;
+    uint32 DisableItemsAboveLevel;
+    uint32 DisableTGsBelowLevel;
+    uint32 DisableTGsAboveLevel;
+    uint32 DisableItemsBelowGUID;
+    uint32 DisableItemsAboveGUID;
+    uint32 DisableTGsBelowGUID;
+    uint32 DisableTGsAboveGUID;
+    uint32 DisableItemsBelowReqLevel;
+    uint32 DisableItemsAboveReqLevel;
+    uint32 DisableTGsBelowReqLevel;
+    uint32 DisableTGsAboveReqLevel;
+    uint32 DisableItemsBelowReqSkillRank;
+    uint32 DisableItemsAboveReqSkillRank;
+    uint32 DisableTGsBelowReqSkillRank;
+    uint32 DisableTGsAboveReqSkillRank;
+
+    //End Filters
+
+    AHBConfig AllianceConfig;
+    AHBConfig HordeConfig;
+    AHBConfig NeutralConfig;
+
+    time_t _lastrun_a;
+    time_t _lastrun_h;
+    time_t _lastrun_n;
+
+    inline uint32 minValue(uint32 a, uint32 b) { return a <= b ? a : b; };
+    void addNewAuctions(Player *AHBplayer, AHBConfig *config);
+    void addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session);
+
+    friend class ACE_Singleton<AuctionHouseBot, ACE_Null_Mutex>;
+    AuctionHouseBot();
+
+public:
+    ~AuctionHouseBot();
+    void Update();
+    void Initialize();
+    void LoadValues(AHBConfig*);
+    void DecrementItemCounts(AuctionEntry* ah, uint32 item_template);
+    void IncrementItemCounts(AuctionEntry* ah);
+    void Commands(uint32, uint32, uint32, char*);
+    uint32 GetAHBplayerGUID() { return AHBplayerGUID; };
+};
+
+#define auctionbot (*ACE_Singleton<AuctionHouseBot, ACE_Null_Mutex>::instance())
+
+#endif
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index 8a04b75..728e018 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -218,7 +218,7 @@ void AuctionHouseMgr::SendAuctionSuccessfulMail(AuctionEntry * auction, SQLTrans
         uint32 profit = auction->bid + auction->deposit - auctionCut;
 
         //FIXME: what do if owner offline
-        if (owner)
+        if (owner && owner->GetGUIDLow() != auctionbot.GetAHBplayerGUID())
         {
             owner->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_EARNED_BY_AUCTIONS, profit);
             owner->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_AUCTION_SOLD, auction->bid);
@@ -248,7 +248,7 @@ void AuctionHouseMgr::SendAuctionExpiredMail(AuctionEntry * auction, SQLTransact
         std::ostringstream subject;
         subject << auction->item_template << ":0:" << AUCTION_EXPIRED << ":0:0";
 
-        if (owner)
+        if (owner && owner->GetGUIDLow() != auctionbot.GetAHBplayerGUID())
             owner->GetSession()->SendAuctionOwnerNotification(auction);
 
         MailDraft(subject.str(), "")                        // TODO: fix body
@@ -273,6 +273,9 @@ void AuctionHouseMgr::SendAuctionOutbiddedMail(AuctionEntry *auction, uint32 new
         std::ostringstream msgAuctionOutbiddedSubject;
         msgAuctionOutbiddedSubject << auction->item_template << ":0:" << AUCTION_OUTBIDDED << ":0:0";
 
+        if (oldBidder && !newBidder)
+            oldBidder->GetSession()->SendAuctionBidderNotification(auction->GetHouseId(), auction->Id, auctionbot.GetAHBplayerGUID(), newPrice, auction->GetAuctionOutBid(), auction->item_template);
+
         if (oldBidder && newBidder)
             oldBidder->GetSession()->SendAuctionBidderNotification(auction->GetHouseId(), auction->Id, newBidder->GetGUID(), newPrice, auction->GetAuctionOutBid(), auction->item_template);
 
@@ -463,11 +466,13 @@ void AuctionHouseObject::AddAuction(AuctionEntry *auction)
 
     AuctionsMap[auction->Id] = auction;
     sScriptMgr->OnAuctionAdd(this, auction);
+	auctionbot.IncrementItemCounts(auction);
 }
 
-bool AuctionHouseObject::RemoveAuction(AuctionEntry *auction, uint32 /*item_template*/)
+bool AuctionHouseObject::RemoveAuction(AuctionEntry *auction, uint32 item_template)
 {
-    bool wasInMap = AuctionsMap.erase(auction->Id) ? true : false;
+    auctionbot.DecrementItemCounts(auction, item_template);
+	bool wasInMap = AuctionsMap.erase(auction->Id) ? true : false;
 
     sScriptMgr->OnAuctionRemove(this, auction);
 
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.h b/src/server/game/AuctionHouse/AuctionHouseMgr.h
index bf9edbc..910eed4 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.h
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.h
@@ -25,6 +25,8 @@
 #include "DatabaseEnv.h"
 #include "DBCStructure.h"
 
+#include "AuctionHouseBot/AuctionHouseBot.h"
+
 class Item;
 class Player;
 class WorldPacket;
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
index 1658f76..ecb14b8 100755
--- a/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
@@ -37,6 +37,9 @@ BattlegroundDS::BattlegroundDS()
     m_StartMessageIds[BG_STARTING_EVENT_SECOND] = LANG_ARENA_THIRTY_SECONDS;
     m_StartMessageIds[BG_STARTING_EVENT_THIRD]  = LANG_ARENA_FIFTEEN_SECONDS;
     m_StartMessageIds[BG_STARTING_EVENT_FOURTH] = LANG_ARENA_HAS_BEGUN;
+
+    m_knockback = 5000;
+    m_knockbackCheck = true;
 }
 
 BattlegroundDS::~BattlegroundDS()
@@ -76,6 +79,23 @@ void BattlegroundDS::Update(uint32 diff)
     }
     else
         setWaterFallTimer(getWaterFallTimer() - diff);
+
+        if (GetStatus() == STATUS_IN_PROGRESS)
+        {
+                if(m_knockback < diff && m_knockbackCheck)
+                {
+                        for(BattlegroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end();itr++)
+                        {
+                                Player * plr = sObjectMgr->GetPlayer(itr->first);
+                                if (plr->GetTeam() == ALLIANCE && plr->GetDistance2d(1214, 765) <= 50 && plr->GetPositionZ() > 10)
+                                        KnockBackPlayer(plr, 6.15f, 50.00f, 7.00f);
+                                if (plr->GetTeam() == HORDE && plr->GetDistance2d(1369, 817) <= 50 && plr->GetPositionZ() > 10)
+                                        KnockBackPlayer(plr, 3.10f, 50.00f, 7.00f);
+                                plr->RemoveAurasDueToSpell(48018);
+                        }
+                        m_knockbackCheck = false;
+                 } else m_knockback -= diff;
+        }
 }
 
 void BattlegroundDS::StartingEventCloseDoors()
@@ -97,6 +117,9 @@ void BattlegroundDS::StartingEventOpenDoors()
 
     for (uint32 i = BG_DS_OBJECT_WATER_1; i <= BG_DS_OBJECT_WATER_2; ++i)
         SpawnBGObject(i, getWaterFallTimer());
+
+    m_knockback = 5000;
+    m_knockbackCheck = true;
 }
 
 void BattlegroundDS::AddPlayer(Player *plr)
@@ -169,6 +192,8 @@ void BattlegroundDS::Reset()
 {
     //call parent's class reset
     Battleground::Reset();
+    m_knockback = 5000;
+    m_knockbackCheck = true;
 }
 
 
@@ -190,3 +215,20 @@ bool BattlegroundDS::SetupBattleground()
 
     return true;
 }
+
+void BattlegroundDS::KnockBackPlayer(Unit *pPlayer, float angle, float horizontalSpeed, float verticalSpeed)
+{
+    if(pPlayer->GetTypeId() == TYPEID_PLAYER)
+    {
+        WorldPacket data(SMSG_MOVE_KNOCK_BACK, 8+4+4+4+4+2);
+        data.append(pPlayer->GetPackGUID());
+        data << uint32(0);
+        data << float(cos(angle));
+        data << float(sin(angle));
+        data << float(horizontalSpeed);
+        data << float(-verticalSpeed);
+        ((Player*)pPlayer)->GetSession()->SendPacket(&data);
+    }
+    else
+        sLog->outError("The target of KnockBackPlayer must be a player !");
+}
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundDS.h b/src/server/game/Battlegrounds/Zones/BattlegroundDS.h
index 0071a38..057dd35 100755
--- a/src/server/game/Battlegrounds/Zones/BattlegroundDS.h
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundDS.h
@@ -43,10 +43,10 @@ enum BattlegroundDSObjects
 };
 
 enum BattlegroundDSData
-{ // These values are NOT blizzlike... need the correct data!
-    BG_DS_WATERFALL_TIMER_MIN                    = 30000,
+{
+    BG_DS_WATERFALL_TIMER_MIN                    = 35000,
     BG_DS_WATERFALL_TIMER_MAX                    = 60000,
-    BG_DS_WATERFALL_DURATION                     = 10000,
+    BG_DS_WATERFALL_DURATION                     = 30000,
 };
 
 class BattlegroundDSScore : public BattlegroundScore
@@ -81,6 +81,9 @@ class BattlegroundDS : public Battleground
     private:
         uint32 m_waterTimer;
         bool m_waterfallActive;
+        bool m_knockbackCheck;
+        uint32 m_knockback;
+        void KnockBackPlayer(Unit *pPlayer, float angle, float horizontalSpeed, float verticalSpeed);
     protected:
         bool isWaterFallActive() { return m_waterfallActive; };
         void setWaterFallActive(bool active) { m_waterfallActive = active; };
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 323a3ac..5f27894 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -13,10 +13,12 @@ if( USE_COREPCH )
 endif()
 
 file(GLOB_RECURSE sources_Accounts Accounts/*.cpp Accounts/*.h)
+file(GLOB_RECURSE sources_Anticheat Anticheat/*.cpp Anticheat/*.h)
 file(GLOB_RECURSE sources_Achievements Achievements/*.cpp Achievements/*.h)
 file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
 file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
 file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
+file(GLOB_RECURSE sources_AuctionHouseBot AuctionHouse/AuctionHouseBot/*.cpp AuctionHouse/AuctionHouseBot/*.h)
 file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
 file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
 file(GLOB_RECURSE sources_Chat Chat/*.cpp Chat/*.h)
@@ -62,10 +64,12 @@ endif()
 set(game_STAT_SRCS
   ${game_STAT_SRCS}
   ${sources_Accounts}
+  ${sources_Anticheat}
   ${sources_Achievements}
   ${sources_Addons}
   ${sources_AI}
   ${sources_AuctionHouse}
+  ${sources_AuctionHouseBot}
   ${sources_Battlegrounds}
   ${sources_Calendar}
   ${sources_Chat}
@@ -107,6 +111,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/dep/zlib
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/Bots
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
   ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
@@ -124,14 +129,17 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/Accounts
+  ${CMAKE_CURRENT_SOURCE_DIR}/Anticheat
   ${CMAKE_CURRENT_SOURCE_DIR}/Achievements
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/Bots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/EventAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
+  ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse/AuctionHouseBot
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
   ${CMAKE_CURRENT_SOURCE_DIR}/Calendar
@@ -190,6 +198,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
   ${CMAKE_CURRENT_SOURCE_DIR}/World
   ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
   ${ACE_INCLUDE_DIR}
   ${MYSQL_INCLUDE_DIR}
   ${OPENSSL_INCLUDE_DIR}
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index fedf1c3..9f7a111 100755
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -240,6 +240,14 @@ ChatCommand * ChatHandler::getCommandTable()
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
+    static ChatCommand questCommandTable[] =
+    {
+        { "add",            SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleQuestAdd>,                   "", NULL },
+        { "complete",       SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleQuestComplete>,              "", NULL },
+        { "remove",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleQuestRemove>,                "", NULL },
+        { NULL,             0,                  false, NULL,                                           "", NULL }
+    };
+
     static ChatCommand resetCommandTable[] =
     {
         { "achievements",   SEC_ADMINISTRATOR,  true,  OldHandler<&ChatHandler::HandleResetAchievementsCommand>,   "", NULL },
@@ -351,6 +359,17 @@ ChatCommand * ChatHandler::getCommandTable()
         { NULL,             0,                  false, NULL,                                                "", NULL }
     };
 
+    static ChatCommand wintergraspCommandTable[] =
+    {
+        { "status",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspStatusCommand>,       "", NULL },
+        { "enable",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspEnableCommand>,       "", NULL },
+        { "start",          SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspStartCommand>,        "", NULL },
+        { "stop",           SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspStopCommand>,         "", NULL },
+        { "switch",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspSwitchTeamCommand>,   "", NULL },
+        { "timer",          SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspTimerCommand>,        "", NULL },
+        { NULL,             0,                  false, NULL,                                               "", NULL }
+    };
+
     static ChatCommand commandTable[] =
     {
         { "character",      SEC_GAMEMASTER,     true,  NULL,                                           "", characterCommandTable},
@@ -367,7 +386,13 @@ ChatCommand * ChatHandler::getCommandTable()
 
         { "pet",            SEC_GAMEMASTER,     false, NULL,                                           "", petCommandTable },
         { "ticket",         SEC_MODERATOR,      false,  NULL,                                          "", ticketCommandTable },
-
+        { "ahbotoptions",   SEC_GAMEMASTER,     true,  OldHandler<&ChatHandler::HandleAHBotOptionsCommand>,        "", NULL },
+	     // Jail by WarHead Edited by LordPsyan
+        { "jail",           SEC_MODERATOR,      false, OldHandler<&ChatHandler::HandleJailCommand>,                "", NULL },
+        { "jailinfo",       SEC_PLAYER,         false, OldHandler<&ChatHandler::HandleJailInfoCommand>,            "", NULL },
+        { "unjail",         SEC_MODERATOR,      false, OldHandler<&ChatHandler::HandleUnJailCommand>,              "", NULL },
+        { "jailreload",     SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleJailReloadCommand>,          "", NULL },
+       
         { "aura",           SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleAuraCommand>,                "", NULL },
         { "unaura",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnAuraCommand>,              "", NULL },
         { "nameannounce",   SEC_MODERATOR,      false, OldHandler<&ChatHandler::HandleNameAnnounceCommand>,        "", NULL },
@@ -437,6 +462,10 @@ ChatCommand * ChatHandler::getCommandTable()
         { "bindsight",      SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBindSightCommand>,           "", NULL },
         { "unbindsight",    SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnbindSightCommand>,         "", NULL },
         { "playall",        SEC_GAMEMASTER,  false, OldHandler<&ChatHandler::HandlePlayAllCommand>,             "", NULL },
+        { "wg",             SEC_ADMINISTRATOR,  false, NULL,                                 "", wintergraspCommandTable },
+        // Playerbot mod
+        { "bot",            SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandlePlayerbotCommand>,             "", NULL },
+        { "maintank",       SEC_PLAYER,  false, OldHandler<&ChatHandler::HandlePlayerbotMainTankCommand>,             "", NULL },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
diff --git a/src/server/game/Chat/Chat.h b/src/server/game/Chat/Chat.h
index 486987d..01bce5a 100755
--- a/src/server/game/Chat/Chat.h
+++ b/src/server/game/Chat/Chat.h
@@ -131,6 +131,7 @@ class ChatHandler
         bool ShowHelpForCommand(ChatCommand *table, const char* cmd);
         bool ShowHelpForSubCommands(ChatCommand *table, char const* cmd, char const* subcmd);
 
+        bool HandleAHBotOptionsCommand(const char * args);
         bool HandleNameAnnounceCommand(const char* args);
         bool HandleGMNameAnnounceCommand(const char* args);
         bool HandleGMAnnounceCommand(const char* args);
@@ -172,6 +173,8 @@ class ChatHandler
         bool HandleUnPossessCommand(const char* args);
         bool HandleBindSightCommand(const char* args);
         bool HandleUnbindSightCommand(const char* args);
+        bool HandlePlayerbotCommand(const char *args);
+        bool HandlePlayerbotMainTankCommand(const char *args);
 
         bool HandleGuildCreateCommand(const char* args);
         bool HandleGuildInviteCommand(const char* args);
@@ -210,6 +213,10 @@ class ChatHandler
         bool HandlePDumpLoadCommand(const char *args);
         bool HandlePDumpWriteCommand(const char *args);
 
+        bool HandleQuestAdd(const char * args);
+        bool HandleQuestRemove(const char * args);
+        bool HandleQuestComplete(const char * args);
+
         bool HandleResetAchievementsCommand(const char * args);
         bool HandleResetAllCommand(const char * args);
         bool HandleResetHonorCommand(const char * args);
@@ -335,6 +342,12 @@ class ChatHandler
         bool HandleSendMessageCommand(const char * args);*/
 
         bool HandleFlushArenaPointsCommand(const char *args);
+        // Jail by WarHead Edited by spgm
+        bool HandleJailCommand(const char* args);
+		bool HandleJailInfoCommand(const char* args);
+		bool HandleUnJailCommand(const char* args);
+		bool HandleJailReloadCommand(const char* args);
+		
         bool HandlePlayAllCommand(const char* args);
         bool HandleRepairitemsCommand(const char* args);
 
@@ -358,6 +371,14 @@ class ChatHandler
         void HandleCharacterLevel(Player* player, uint64 player_guid, uint32 oldlevel, uint32 newlevel);
         void HandleLearnSkillRecipesHelper(Player* player,uint32 skill_id);
 
+        //Wintergrasp
+        bool HandleWintergraspStatusCommand(const char *args);
+        bool HandleWintergraspStartCommand(const char *args);
+        bool HandleWintergraspStopCommand(const char *args);
+        bool HandleWintergraspEnableCommand(const char *args);
+        bool HandleWintergraspSwitchTeamCommand(const char *args);
+        bool HandleWintergraspTimerCommand(const char *args);
+
         // Stores informations about a deleted character
         struct DeletedInfo
         {
diff --git a/src/server/game/Chat/Commands/Level0.cpp b/src/server/game/Chat/Commands/Level0.cpp
index 5deed67..b1f12e3 100755
--- a/src/server/game/Chat/Commands/Level0.cpp
+++ b/src/server/game/Chat/Commands/Level0.cpp
@@ -23,11 +23,14 @@
 #include "Opcodes.h"
 #include "Chat.h"
 #include "ObjectAccessor.h"
+#include "ObjectMgr.h"
 #include "Language.h"
 #include "AccountMgr.h"
 #include "SystemConfig.h"
 #include "revision.h"
 #include "Util.h"
+#include "Group.h"
+#include "math.h"
 
 bool ChatHandler::HandleHelpCommand(const char* args)
 {
@@ -54,6 +57,13 @@ bool ChatHandler::HandleCommandsCommand(const char* /*args*/)
 
 bool ChatHandler::HandleStartCommand(const char* /*args*/)
 {
+		// Jail by WarHead edited by spgm
+    if (m_session->GetPlayer()->m_jail_isjailed)
+    {
+        SendSysMessage(LANG_JAIL_DENIED);
+        return true;
+    }
+    
     Player *chr = m_session->GetPlayer();
 
     if (chr->isInFlight())
@@ -78,7 +88,7 @@ bool ChatHandler::HandleStartCommand(const char* /*args*/)
     }
 
     // cast spell Stuck
-    chr->CastSpell(chr, 7355, false);
+    chr->CastSpell(chr, 8690, false);
     return true;
 }
 
@@ -127,7 +137,14 @@ bool ChatHandler::HandleDismountCommand(const char* /*args*/)
 bool ChatHandler::HandleSaveCommand(const char* /*args*/)
 {
     Player *player = m_session->GetPlayer();
-
+    
+		// Jail by WarHead edited by LordPsyan
+    if (player->m_jail_isjailed)
+    {
+        SendSysMessage(LANG_JAIL_DENIED);
+        return true;
+    }
+  
     // save GM account without delay and output message
     if (m_session->GetSecurity() > SEC_PLAYER)
     {
@@ -144,10 +161,223 @@ bool ChatHandler::HandleSaveCommand(const char* /*args*/)
     return true;
 }
 
+//Playerbot mod
+bool ChatHandler::HandlePlayerbotCommand(const char *args)
+{
+    if(!m_session)
+    {
+        PSendSysMessage("You may only add bots from an active session");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if(!*args)
+    {
+        PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    char *cmd = strtok ((char*)args, " ");
+    char *charname = strtok (NULL, " ");
+    if(!cmd || !charname)
+    {
+        PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+    uint64 guid;
+
+   if (charnameStr.compare("all") != 0)
+   {
+       if (!normalizePlayerName(charnameStr))
+           return false;
+
+       guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+       if (guid == 0 || (guid == m_session->GetPlayer()->GetGUID()))
+       {
+           SendSysMessage(LANG_PLAYER_NOT_FOUND);
+           SetSentErrorMessage(true);
+           return false;
+       }
+
+       uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+       if (accountId != m_session->GetAccountId())
+       {
+           PSendSysMessage("You may only add bots from the same account.");
+           SetSentErrorMessage(true);
+           return false;
+       }
+   }
+
+    if (cmdStr.compare("add") == 0 || cmdStr.compare("login") == 0)
+    {
+        if (charnameStr.compare("all") == 0)
+        {
+            std::list<std::string> *names;
+            names=m_session->GetPlayer()->GetCharacterList();
+            std::list<std::string>::iterator iter,next;
+            for (iter = names->begin(); iter != names->end(); iter++)
+            {
+                std::stringstream arg;
+                arg << "add " << (*iter).c_str();
+                HandlePlayerbotCommand(arg.str().c_str());
+            }
+            PSendSysMessage("Bots added successfully.");
+            return true;
+        }
+        else
+        {
+            if(m_session->GetPlayerBot(guid) != NULL)
+            {
+                PSendSysMessage("Bot already exists in world.");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            m_session->AddPlayerBot(guid);
+        }
+
+    }
+    else if (cmdStr.compare("remove") == 0 || cmdStr.compare("logout") == 0)
+    {
+        if (charnameStr.compare("all") == 0)
+        {
+            std::list<std::string> *names = new std::list<std::string>;
+            for (PlayerBotMap::const_iterator iter = m_session->GetPlayerBotsBegin(); iter != m_session->GetPlayerBotsEnd(); ++iter)
+            {
+                names->push_back(iter->second->GetName());
+            }
+            std::list<std::string>::iterator iter,next;
+            for (iter = names->begin(); iter != names->end(); iter++)
+            {
+                std::stringstream arg;
+                arg << "remove " << (*iter).c_str();
+                HandlePlayerbotCommand(arg.str().c_str());
+            }
+            return true;
+        }
+        else
+        {
+            if (m_session->GetPlayerBot(guid) == NULL)
+            {
+                PSendSysMessage("Bot can not be removed because bot does not exst in world.");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            m_session->LogoutPlayerBot(guid, true);
+            PSendSysMessage("Bot removed successfully.");
+            return true;
+        }
+    }
+    return true;
+}
+
+bool ChatHandler::HandlePlayerbotMainTankCommand(const char *args)
+{
+    uint64 guid = 0;
+    uint64 pGuid = 0;
+    char *charname ;
+    Group *group = m_session->GetPlayer()->GetGroup();
+
+    if (group == NULL) {
+        PSendSysMessage("Must be in a group to set a main tank.");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINTANK, group->GetGUID());
+    if(result)
+    {
+        pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+    }
+
+    // if no arguments are passed in, just say who the current main tank is
+    if(!*args) {
+
+        if (pGuid>0) {
+            Player *pPlayer = sObjectMgr->GetPlayer(pGuid);
+
+            if (pPlayer  && pPlayer->isAlive()){
+                PSendSysMessage("Main tank is %s.", pPlayer->GetName());
+                return true;
+            }
+        }
+
+        PSendSysMessage("Currently there is no main tank. ");
+        return true;
+    } else {
+        charname = strtok ((char*)args, " ");
+        std::string charnameStr = charname;
+        guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+
+        // clear if same player
+        if (pGuid==guid) {
+            group->SetMainTank(guid, false);
+            PSendSysMessage("Main tank has been cleared. ");
+            return true;
+        }
+
+        if (m_session->GetPlayer()->GetGroup()->IsMember(guid)) {
+            group->SetMainTank(pGuid,false); // clear old one
+            group->SetMainTank(guid, true);  // set new one
+            Player *pPlayer = sObjectMgr->GetPlayer(guid);
+            if (pPlayer->IsInWorld())
+                PSendSysMessage("Main tank is %s.", pPlayer->GetName());
+            else
+                PSendSysMessage("Player is not online.");
+
+        } else {
+            PSendSysMessage("Player is not in your group.");
+        }
+
+    }
+
+
+    return true;
+}
+
+
 /// Display the 'Message of the day' for the realm
 bool ChatHandler::HandleServerMotdCommand(const char* /*args*/)
 {
     PSendSysMessage(LANG_MOTD_CURRENT, sWorld->GetMotd());
     return true;
 }
+	//Trinity Jail Edited by spgm
+bool ChatHandler::HandleJailInfoCommand(const char* args)
+{
+    time_t localtime;
+    localtime = time(NULL);
+    Player *chr = m_session->GetPlayer();
+
+    if (chr->m_jail_release > 0)
+    {
+        uint32 min_left = (uint32)floor(float(chr->m_jail_release - localtime) / 60);
+
+        if (min_left <= 0)
+        {
+            chr->m_jail_release = 0;
+            chr->_SaveJail();
+            SendSysMessage(LANG_JAIL_NOTJAILED_INFO);
+            return true;
+        }
+        else
+        {
+            if (min_left >= 60) PSendSysMessage(LANG_JAIL_JAILED_H_INFO, (uint32)floor(float(chr->m_jail_release - localtime) / 60 / 60));
+            else PSendSysMessage(LANG_JAIL_JAILED_M_INFO, min_left);
+            PSendSysMessage(LANG_JAIL_REASON, chr->m_jail_gmchar.c_str(), chr->m_jail_reason.c_str());
+
+            return true;
+        }
+    }
+    else
+    {
+        SendSysMessage(LANG_JAIL_NOTJAILED_INFO);
+        return true;
+    }
+    return false;
+}
 
diff --git a/src/server/game/Chat/Commands/Level1.cpp b/src/server/game/Chat/Commands/Level1.cpp
index d5acf4b..f86f5b7 100755
--- a/src/server/game/Chat/Commands/Level1.cpp
+++ b/src/server/game/Chat/Commands/Level1.cpp
@@ -270,9 +270,10 @@ bool ChatHandler::HandleSummonCommand(const char* args)
                 target->UnbindInstance(pMap->GetInstanceId(), target->GetDungeonDifficulty(), true);
 
             // we are in instance, and can summon only player in our group with us as lead
-            if (!m_session->GetPlayer()->GetGroup() || !target->GetGroup() ||
+            if(!target->IsPlayerbot() &&
+                (!m_session->GetPlayer()->GetGroup() || !target->GetGroup() ||
                 (target->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID()) ||
-                (m_session->GetPlayer()->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID()))
+                (m_session->GetPlayer()->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID())))
                 // the last check is a bit excessive, but let it be, just in case
             {
                 PSendSysMessage(LANG_CANNOT_SUMMON_TO_INST,nameLink.c_str());
@@ -320,7 +321,6 @@ bool ChatHandler::HandleSummonCommand(const char* args)
             m_session->GetPlayer()->GetZoneId(),
             target_guid);
     }
-
     return true;
 }
 
@@ -715,6 +715,292 @@ bool ChatHandler::HandleSaveAllCommand(const char* /*args*/)
     return true;
 }
 
+// Jail by WarHead edited by spgm
+bool ChatHandler::HandleJailCommand(const char *args)
+{
+    std::string cname, announce, ban_reason, ban_by;
+    time_t localtime;
+    localtime = time(NULL);
+
+    char *charname = strtok((char*)args, " ");
+    if (charname == NULL)
+    {
+        SendSysMessage(LANG_JAIL_NONAME);
+        return true;
+    } else cname = charname;
+
+    char *timetojail = strtok(NULL, " ");
+    if (timetojail == NULL)
+    {
+        SendSysMessage(LANG_JAIL_NOTIME);
+        return true;
+    }
+
+    uint32 jailtime = (uint32) atoi((char*)timetojail);
+    if (jailtime < 1 || jailtime > sObjectMgr->m_jailconf_max_duration)
+    {
+        PSendSysMessage(LANG_JAIL_VALUE, sObjectMgr->m_jailconf_max_duration);
+        return true;
+    }
+
+    char *reason = strtok(NULL, "\0");
+    std::string jailreason;
+    if (reason == NULL || strlen((const char*)reason) < sObjectMgr->m_jailconf_min_reason)
+    {
+        PSendSysMessage(LANG_JAIL_NOREASON, sObjectMgr->m_jailconf_min_reason);
+        return true;
+    } else jailreason = reason;
+
+    uint64 GUID = sObjectMgr->GetPlayerGUIDByName(cname.c_str());
+    if (GUID == 0)
+    {
+        SendSysMessage(LANG_JAIL_WRONG_NAME);
+        return true;
+    }
+
+    Player *chr = sObjectMgr->GetPlayer(GUID);
+    if (!chr)
+    {
+		uint32 jail_guid = GUID_LOPART(GUID);
+		std::string jail_char = cname;
+		bool jail_isjailed = true;
+		uint32 jail_release = localtime + (jailtime * 60 * 60);
+		uint32 jail_amnestietime = localtime +(60* 60 * 24 * sObjectMgr->m_jailconf_amnestie);
+		std::string jail_reason = jailreason;
+		uint32 jail_times = 0;
+
+		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+		QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", jail_guid);
+		CharacterDatabase.CommitTransaction(trans);
+
+        if (!result)
+        {
+            jail_times = 1;
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            jail_times = fields[5].GetUInt32()+1;
+        }
+
+        uint32 jail_gmacc = m_session->GetAccountId();
+        std::string jail_gmchar = m_session->GetPlayerName();
+
+        SQLTransaction trans2 = CharacterDatabase.BeginTransaction();
+		if (!result) CharacterDatabase.PExecute("INSERT INTO `jail` VALUES ('%u','%s','%u','%u','%s','%u','%u','%s',CURRENT_TIMESTAMP,'%u')", jail_guid, jail_char.c_str(), jail_release, jail_amnestietime, jail_reason.c_str(), jail_times, jail_gmacc, jail_gmchar.c_str(), jailtime);
+        else CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u', `amnestietime`='%u',`reason`='%s',`times`='%u',`gmacc`='%u',`gmchar`='%s',`duration`='%u' WHERE `guid`='%u' LIMIT 1", jail_release, jail_amnestietime, jail_reason.c_str(), jail_times, jail_gmacc, jail_gmchar.c_str(), jailtime, jail_guid);
+        CharacterDatabase.CommitTransaction(trans2);
+
+        PSendSysMessage(LANG_JAIL_WAS_JAILED, cname.c_str(), jailtime);
+
+        announce = GetTrinityString(LANG_JAIL_ANNOUNCE1);
+        announce += cname;
+        announce += GetTrinityString(LANG_JAIL_ANNOUNCE2);
+        announce += timetojail;
+        announce += GetTrinityString(LANG_JAIL_ANNOUNCE3);
+        announce += m_session->GetPlayerName();
+        announce += GetTrinityString(LANG_JAIL_ANNOUNCE4);
+        announce += jail_reason;
+
+        HandleAnnounceCommand(announce.c_str());
+
+        if ((sObjectMgr->m_jailconf_max_jails == jail_times) && !sObjectMgr->m_jailconf_ban)
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+            CharacterDatabase.CommitTransaction(trans);
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+
+            Field *fields = result->Fetch();
+
+            Player::DeleteFromDB(GUID, fields[1].GetUInt32());
+        }
+        else if ((sObjectMgr->m_jailconf_max_jails == jail_times) && sObjectMgr->m_jailconf_ban)
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+            CharacterDatabase.CommitTransaction(trans);
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+            Field *fields = result->Fetch();
+            uint32 acc_id = fields[1].GetUInt32();
+
+            SQLTransaction trans2 = LoginDatabase.BeginTransaction();
+            result = LoginDatabase.PQuery("SELECT * FROM `account` WHERE `id`='%u' LIMIT 1", acc_id);
+            LoginDatabase.CommitTransaction(trans2);
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+            ban_reason = GetTrinityString(LANG_JAIL_BAN_REASON);
+            ban_by = GetTrinityString(LANG_JAIL_BAN_BY);
+
+            SQLTransaction trans3 = LoginDatabase.BeginTransaction();
+            LoginDatabase.PExecute("INSERT IGNORE INTO `account_banned` (`id`,`bandate`,`bannedby`,`banreason`) VALUES ('%u',UNIX_TIMESTAMP,'%s','%s')", acc_id, ban_by.c_str(), ban_reason.c_str());
+            LoginDatabase.CommitTransaction(trans3);
+
+        }
+        return true;
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", chr->GetGUIDLow());
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+        PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+        return true;
+    }
+
+    Field *fields = result->Fetch();
+
+    if (chr->GetName() == m_session->GetPlayerName())
+    {
+        SendSysMessage(LANG_JAIL_NO_JAIL);
+        return true;
+    }
+
+		chr->SaveToDB();
+
+		chr->m_jail_guid = fields[0].GetUInt32();
+		chr->m_jail_char = fields[3].GetString();
+		chr->m_jail_isjailed = true;
+		chr->m_jail_release = localtime + (jailtime * 60 * 60);
+		chr->m_jail_amnestietime = localtime +(60* 60 * 24 * sObjectMgr->m_jailconf_amnestie);
+		chr->m_jail_reason = jailreason;
+		chr->m_jail_times = chr->m_jail_times+1;
+		chr->m_jail_gmacc = m_session->GetAccountId();
+		chr->m_jail_gmchar = m_session->GetPlayerName();
+		chr->m_jail_duration = jailtime;
+
+		chr->_SaveJail();
+
+		PSendSysMessage(LANG_JAIL_WAS_JAILED, fields[3].GetString().c_str(), jailtime);
+		ChatHandler(chr).PSendSysMessage(LANG_JAIL_YOURE_JAILED, m_session->GetPlayerName(), jailtime);
+		ChatHandler(chr).PSendSysMessage(LANG_JAIL_REASON, m_session->GetPlayerName(), jailreason.c_str());
+
+		announce = GetTrinityString(LANG_JAIL_ANNOUNCE1);
+		announce += fields[3].GetString();
+		announce += GetTrinityString(LANG_JAIL_ANNOUNCE2);
+		announce += timetojail;
+		announce += GetTrinityString(LANG_JAIL_ANNOUNCE3);
+		announce += m_session->GetPlayerName();
+		announce += GetTrinityString(LANG_JAIL_ANNOUNCE4);
+		announce += chr->m_jail_reason;
+
+		HandleAnnounceCommand(announce.c_str());
+
+    if (sObjectMgr->m_jailconf_max_jails == chr->m_jail_times)
+    {
+        chr->GetSession()->KickPlayer();
+        chr->DeleteFromDB(fields[0].GetUInt64(), fields[1].GetUInt32());
+    }
+    else if ((sObjectMgr->m_jailconf_max_jails == chr->m_jail_times) && sObjectMgr->m_jailconf_ban)
+    {
+        uint32 acc_id = chr->GetSession()->GetAccountId();
+        ban_reason = GetTrinityString(LANG_JAIL_BAN_REASON);
+        ban_by = GetTrinityString(LANG_JAIL_BAN_BY);
+
+		SQLTransaction trans = LoginDatabase.BeginTransaction();
+        LoginDatabase.PExecute("INSERT IGNORE INTO `account_banned` (`id`,`bandate`,`bannedby`,`banreason`) VALUES ('%u',UNIX_TIMESTAMP,'%s','%s')", acc_id, ban_by.c_str(), ban_reason.c_str());
+        LoginDatabase.CommitTransaction(trans);
+
+        chr->GetSession()->LogoutPlayer(false);
+    }
+    else chr->GetSession()->LogoutPlayer(false);
+    return true;
+}
+
+bool ChatHandler::HandleUnJailCommand(const char *args)
+{
+    char *charname = strtok((char*)args, " ");
+    std::string cname;
+
+    if (charname == NULL) return false;
+    else cname = charname;
+
+    uint64 GUID = sObjectMgr->GetPlayerGUIDByName(cname.c_str());
+    Player *chr = sObjectMgr->GetPlayer(GUID);
+
+    if (chr)
+    {
+        if (chr->GetName() == m_session->GetPlayerName())
+        {
+            SendSysMessage(LANG_JAIL_NO_UNJAIL);
+            return true;
+        }
+
+        if (chr->m_jail_isjailed)
+        {
+            chr->m_jail_isjailed = false;
+            chr->m_jail_release = 0;
+            chr->m_jail_times = chr->m_jail_times-1;
+
+            chr->_SaveJail();
+
+            if (chr->m_jail_times == 0)
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("DELETE FROM `jail` WHERE `guid`='%u' LIMIT 1", chr->GetGUIDLow());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+
+            PSendSysMessage(LANG_JAIL_WAS_UNJAILED, cname.c_str());
+            ChatHandler(chr).PSendSysMessage(LANG_JAIL_YOURE_UNJAILED, m_session->GetPlayerName());    
+            chr->CastSpell(chr,8690,false);
+            //chr->GetSession()->LogoutPlayer(false);
+        } else PSendSysMessage(LANG_JAIL_CHAR_NOTJAILED, cname.c_str());
+        return true;
+    }
+    else
+    {
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        QueryResult jresult = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+        CharacterDatabase.CommitTransaction(trans);
+
+        if (!jresult)
+        {
+            PSendSysMessage(LANG_JAIL_CHAR_NOTJAILED, cname.c_str());
+            return true;
+        }
+        else
+        {
+            Field *fields = jresult->Fetch();
+            uint32 jail_times = fields[4].GetUInt32()-1;
+
+            if (jail_times == 0)
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("DELETE FROM `jail` WHERE `guid`='%u' LIMIT 1", fields[0].GetUInt32());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+            else
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("UPDATE `jail` SET `release`='0',`times`='%u' WHERE `guid`='%u' LIMIT 1", jail_times, fields[0].GetUInt32());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+
+            PSendSysMessage(LANG_JAIL_WAS_UNJAILED, cname.c_str());
+            return true;
+        }
+
+    }
+    return true;
+}
+
 //Send mail by command
 bool ChatHandler::HandleSendMailCommand(const char* args)
 {
diff --git a/src/server/game/Chat/Commands/Level2.cpp b/src/server/game/Chat/Commands/Level2.cpp
index 00962a9..3b60b49 100755
--- a/src/server/game/Chat/Commands/Level2.cpp
+++ b/src/server/game/Chat/Commands/Level2.cpp
@@ -33,6 +33,8 @@
 #include "PoolMgr.h"
 #include "AccountMgr.h"
 #include "WaypointManager.h"
+#include "WaypointMovementGenerator.h"
+#include "math.h"
 #include "Util.h"
 #include <cctype>
 #include <iostream>
@@ -42,10 +44,12 @@
 #include "Transport.h"
 #include "TargetedMovementGenerator.h"                      // for HandleNpcUnFollowCommand
 #include "CreatureGroups.h"
+#include "OutdoorPvPWG.h"
 
 //mute player for some times
 bool ChatHandler::HandleMuteCommand(const char* args)
 {
+
     char* nameStr;
     char* delayStr;
     extractOptFirstArg((char*)args,&nameStr,&delayStr);
@@ -55,7 +59,7 @@ bool ChatHandler::HandleMuteCommand(const char* args)
     char *mutereason = strtok(NULL, "\r");
     std::string mutereasonstr = "No reason";
     if (mutereason != NULL)
-         mutereasonstr = mutereason;
+        mutereasonstr = mutereason;
 
     Player* target;
     uint64 target_guid;
@@ -225,8 +229,8 @@ bool ChatHandler::HandleKickPlayerCommand(const char *args)
         sWorld->SendWorldText(LANG_COMMAND_KICKMESSAGE, playerName.c_str());
     else
         PSendSysMessage(LANG_COMMAND_KICKMESSAGE, playerName.c_str());
-
     target->GetSession()->KickPlayer();
+
     return true;
 }
 
@@ -246,7 +250,19 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
     uint32 latency = 0;
     uint8 race;
     uint8 Class;
-
+    bool p_jail_isjailed;
+    uint32 p_jail_guid;
+    std::string p_jail_char;
+    uint32 p_jail_release;
+    bool p_jail_amnestietime;
+    std::string p_jail_reason;
+    uint32 p_jail_times;
+    uint32 p_jail_gmacc;
+    std::string p_jail_gmchar;
+    std::string p_jail_lasttime;
+    uint32 p_jail_duration;
+    std::string gmname;
+    
     // get additional information from Player object
     if (target)
     {
@@ -261,6 +277,18 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         latency = target->GetSession()->GetLatency();
         race = target->getRace();
         Class = target->getClass();
+        p_jail_isjailed = target->m_jail_isjailed;
+		p_jail_guid = target->m_jail_guid;
+		p_jail_char = target->m_jail_char;
+		p_jail_release = target->m_jail_release;
+		p_jail_amnestietime = target->m_jail_amnestietime;
+		p_jail_reason = target->m_jail_reason;
+		p_jail_times =  target->m_jail_times;
+		p_jail_gmacc =  target->m_jail_gmacc;
+		p_jail_gmchar = target->m_jail_gmchar;
+		p_jail_lasttime = target->m_jail_lasttime;
+		p_jail_duration = target->m_jail_duration;
+		gmname = target->GetName();
     }
     // get additional information from DB
     else
@@ -272,8 +300,11 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         //                                                     0          1      2      3        4     5
         QueryResult result = CharacterDatabase.PQuery("SELECT totaltime, level, money, account, race, class FROM characters WHERE guid = '%u'", GUID_LOPART(target_guid));
         if (!result)
+        {
             return false;
-
+		}
+		else
+		{
         Field *fields = result->Fetch();
         total_player_time = fields[0].GetUInt32();
         level = fields[1].GetUInt32();
@@ -281,6 +312,31 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         accId = fields[3].GetUInt32();
         race = fields[4].GetUInt8();
         Class = fields[5].GetUInt8();
+        		}
+		
+		QueryResult row = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(target_guid));
+	    
+		if (!row)
+		{
+			 p_jail_isjailed = false;
+		}
+		else
+		{
+
+			Field *data = row->Fetch();
+			p_jail_isjailed = true;
+			p_jail_guid = data[0].GetUInt32();
+			p_jail_char = data[1].GetString();
+			p_jail_release = data[2].GetUInt32();
+			p_jail_amnestietime = data[3].GetUInt32();
+			p_jail_reason = data[4].GetString();
+			p_jail_times = data[5].GetUInt32();
+			p_jail_gmacc = data[6].GetUInt32();
+			p_jail_gmchar = data[7].GetString();
+			p_jail_lasttime = data[8].GetString();
+			p_jail_duration = data[9].GetUInt32();
+			gmname = "";
+		}
     }
 
     std::string username = GetTrinityString(LANG_ERROR);
@@ -354,6 +410,39 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
     uint32 copp = (money % GOLD) % SILVER;
     PSendSysMessage(LANG_PINFO_LEVEL, race_s.c_str(), Class_s.c_str(), timeStr.c_str(), level, gold, silv, copp);
 
+	if (p_jail_times > 0)
+        {
+            if (p_jail_release > 0)
+            {
+                time_t localtime;
+                localtime = time(NULL);
+                uint32 min_left = (uint32)floor(float(p_jail_release - localtime) / 60);
+
+                if (min_left <= 0)
+                {
+                    p_jail_release = 0;
+                    CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u' WHERE `guid`='%u' LIMIT 1", p_jail_release, p_jail_guid);
+                    PSendSysMessage(LANG_JAIL_GM_INFO, p_jail_char.c_str(), p_jail_times, 0, p_jail_gmchar.c_str(), p_jail_reason.c_str());
+                    return true;
+                }
+                else
+                {
+                    PSendSysMessage(LANG_JAIL_GM_INFO, p_jail_char.c_str(), p_jail_times, min_left, p_jail_gmchar.c_str(), p_jail_reason.c_str());
+                    return true;
+                }
+            }
+            else
+            {
+                PSendSysMessage(LANG_JAIL_GM_INFO, p_jail_char.c_str(), p_jail_times, 0, p_jail_gmchar.c_str(), p_jail_reason.c_str());
+                return true;
+            }
+        }
+        else
+        {
+            PSendSysMessage(LANG_JAIL_GM_NOINFO, gmname.c_str());
+            return true;
+        }
+        
     return true;
 }
 
@@ -917,6 +1006,151 @@ bool ChatHandler::HandlePetTpCommand(const char *args)
     return true;
 }
 
+bool ChatHandler::HandleWintergraspStatusCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+   if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    PSendSysMessage(LANG_BG_WG_STATUS, sObjectMgr->GetTrinityStringForDBCLocale(
+        pvpWG->getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE),
+        secsToTimeString(pvpWG->GetTimer(), true).c_str(),
+        pvpWG->isWarTime() ? "Yes" : "No",
+        pvpWG->GetNumPlayersH(),
+        pvpWG->GetNumPlayersA());
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspStartCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+    pvpWG->forceStartBattle();
+    PSendSysMessage(LANG_BG_WG_BATTLE_FORCE_START);
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspStopCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+    pvpWG->forceStopBattle();
+    PSendSysMessage(LANG_BG_WG_BATTLE_FORCE_STOP);
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspEnableCommand(const char* args)
+{
+    if(!*args)
+        return false;
+
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (!strncmp(args, "on", 3))
+    {
+        if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        {
+            pvpWG->forceStopBattle();
+            sWorld->setBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED, true);
+        }
+        PSendSysMessage(LANG_BG_WG_ENABLE);
+        return true;
+    }
+    else if (!strncmp(args, "off", 4))
+    {
+        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        {
+            pvpWG->forceStopBattle();
+            sWorld->setBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED, false);
+        }
+        PSendSysMessage(LANG_BG_WG_DISABLE);
+        return true;
+    }
+    else
+    {
+        SendSysMessage(LANG_USE_BOL);
+        SetSentErrorMessage(true);
+        return false;
+    }
+}
+
+bool ChatHandler::HandleWintergraspTimerCommand(const char* args)
+{
+    if(!*args)
+        return false;
+
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG)
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    int32 time = atoi (args);
+
+    // Min value 1 min
+    if (1 > time)
+        time = 1;
+    // Max value during wartime = 60. No wartime = 1440 (day)
+    if (pvpWG->isWarTime())
+    {
+        if (60 < time)
+            return false;
+    }
+    else
+        if (1440 < time)
+            return false;
+    time *= MINUTE * IN_MILLISECONDS;
+
+    pvpWG->setTimer((uint32)time);
+
+    PSendSysMessage(LANG_BG_WG_CHANGE_TIMER, secsToTimeString(pvpWG->GetTimer(), true).c_str());
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspSwitchTeamCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG)
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+    uint32 timer = pvpWG->GetTimer();
+    pvpWG->forceChangeTeam();
+    pvpWG->setTimer(timer);
+    PSendSysMessage(LANG_BG_WG_SWITCH_FACTION, GetTrinityString(pvpWG->getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+    return true;
+}
+
 bool ChatHandler::HandleLookupTitleCommand(const char* args)
 {
     if (!*args)
@@ -1006,6 +1240,7 @@ bool ChatHandler::HandleCharacterTitlesCommand(const char* args)
         return false;
 
     Player* target;
+
     if (!extractPlayerTarget((char*)args,&target))
         return false;
 
diff --git a/src/server/game/Chat/Commands/Level3.cpp b/src/server/game/Chat/Commands/Level3.cpp
index 649e1ce..24a1566 100755
--- a/src/server/game/Chat/Commands/Level3.cpp
+++ b/src/server/game/Chat/Commands/Level3.cpp
@@ -62,6 +62,505 @@
 #include "Group.h"
 #include "ChannelMgr.h"
 
+#include "AuctionHouseBot.h"
+
+bool ChatHandler::HandleAHBotOptionsCommand(const char *args)
+{
+    uint32 ahMapID = 0;
+    char * opt = strtok((char*)args, " ");
+    char * ahMapIdStr = strtok(NULL, " ");
+    if (ahMapIdStr)
+    {
+        ahMapID = (uint32) strtoul(ahMapIdStr, NULL, 0);
+        switch (ahMapID)
+        {
+        case 2:
+        case 6:
+        case 7:
+            break;
+        default:
+            opt = NULL;
+            break;
+        }
+    }
+    if (!opt)
+    {
+        PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+        PSendSysMessage("Try ahbotoptions help to see a list of options.");
+        return false;
+    }
+    int l = strlen(opt);
+
+    if (strncmp(opt,"help",l) == 0)
+    {
+        PSendSysMessage("AHBot commands:");
+        PSendSysMessage("ahexpire");
+        PSendSysMessage("minitems");
+        PSendSysMessage("maxitems");
+        //PSendSysMessage("");
+        //PSendSysMessage("");
+        PSendSysMessage("percentages");
+        PSendSysMessage("minprice");
+        PSendSysMessage("maxprice");
+        PSendSysMessage("minbidprice");
+        PSendSysMessage("maxbidprice");
+        PSendSysMessage("maxstack");
+        PSendSysMessage("buyerprice");
+        PSendSysMessage("bidinterval");
+        PSendSysMessage("bidsperinterval");
+        return true;
+    }
+    else if (strncmp(opt,"ahexpire",l) == 0)
+    {
+        if (!ahMapIdStr)
+        {
+            PSendSysMessage("Syntax is: ahbotoptions ahexpire $ahMapID (2, 6 or 7)");
+            return false;
+        }
+        auctionbot.Commands(0, ahMapID, NULL, NULL);
+    }
+    else if (strncmp(opt,"minitems",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minitems $ahMapID (2, 6 or 7) $minItems");
+            return false;
+        }
+        auctionbot.Commands(1, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"maxitems",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxitems $ahMapID (2, 6 or 7) $maxItems");
+            return false;
+        }
+        auctionbot.Commands(2, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"mintime",l) == 0)
+    {
+        PSendSysMessage("ahbotoptions mintime has been deprecated");
+        return false;
+        /*
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions mintime $ahMapID (2, 6 or 7) $mintime");
+            return false;
+        }
+        auctionbot.Commands(3, ahMapID, NULL, param1);
+        */
+    }
+    else if (strncmp(opt,"maxtime",l) == 0)
+    {
+        PSendSysMessage("ahbotoptions maxtime has been deprecated");
+        return false;
+        /*
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxtime $ahMapID (2, 6 or 7) $maxtime");
+            return false;
+        }
+        auctionbot.Commands(4, ahMapID, NULL, param1);
+        */
+    }
+    else if (strncmp(opt,"percentages",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        char * param3 = strtok(NULL, " ");
+        char * param4 = strtok(NULL, " ");
+        char * param5 = strtok(NULL, " ");
+        char * param6 = strtok(NULL, " ");
+        char * param7 = strtok(NULL, " ");
+        char * param8 = strtok(NULL, " ");
+        char * param9 = strtok(NULL, " ");
+        char * param10 = strtok(NULL, " ");
+        char * param11 = strtok(NULL, " ");
+        char * param12 = strtok(NULL, " ");
+        char * param13 = strtok(NULL, " ");
+        char * param14 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param14))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+            PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+            PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+            PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+            PSendSysMessage("The total must add up to 100%");
+            return false;
+        }
+        uint32 greytg = (uint32) strtoul(param1, NULL, 0);
+        uint32 whitetg = (uint32) strtoul(param2, NULL, 0);
+        uint32 greentg = (uint32) strtoul(param3, NULL, 0);
+        uint32 bluetg = (uint32) strtoul(param3, NULL, 0);
+        uint32 purpletg = (uint32) strtoul(param5, NULL, 0);
+        uint32 orangetg = (uint32) strtoul(param6, NULL, 0);
+        uint32 yellowtg = (uint32) strtoul(param7, NULL, 0);
+        uint32 greyi = (uint32) strtoul(param8, NULL, 0);
+        uint32 whitei = (uint32) strtoul(param9, NULL, 0);
+        uint32 greeni = (uint32) strtoul(param10, NULL, 0);
+        uint32 bluei = (uint32) strtoul(param11, NULL, 0);
+        uint32 purplei = (uint32) strtoul(param12, NULL, 0);
+        uint32 orangei = (uint32) strtoul(param13, NULL, 0);
+        uint32 yellowi = (uint32) strtoul(param14, NULL, 0);
+        uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+        if ((totalPercent == 0) || (totalPercent != 100))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+            PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+            PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+            PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+            PSendSysMessage("The total must add up to 100%");
+            return false;
+        }
+        char param[100];
+        param[0] = '\0';
+        strcat(param, param1);
+        strcat(param, " ");
+        strcat(param, param2);
+        strcat(param, " ");
+        strcat(param, param3);
+        strcat(param, " ");
+        strcat(param, param4);
+        strcat(param, " ");
+        strcat(param, param5);
+        strcat(param, " ");
+        strcat(param, param6);
+        strcat(param, " ");
+        strcat(param, param7);
+        strcat(param, " ");
+        strcat(param, param8);
+        strcat(param, " ");
+        strcat(param, param9);
+        strcat(param, " ");
+        strcat(param, param10);
+        strcat(param, " ");
+        strcat(param, param11);
+        strcat(param, " ");
+        strcat(param, param12);
+        strcat(param, " ");
+        strcat(param, param13);
+        strcat(param, " ");
+        strcat(param, param14);
+        auctionbot.Commands(5, ahMapID, NULL, param);
+    }
+    else if (strncmp(opt,"minprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"minbidprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        uint32 minBidPrice = (uint32) strtoul(param2, NULL, 0);
+        if ((minBidPrice < 1) || (minBidPrice > 100))
+        {
+            PSendSysMessage("The min bid price multiplier must be between 1 and 100");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxbidprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        uint32 maxBidPrice = (uint32) strtoul(param2, NULL, 0);
+        if ((maxBidPrice < 1) || (maxBidPrice > 100))
+        {
+            PSendSysMessage("The max bid price multiplier must be between 1 and 100");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions max bidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxstack",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+            return false;
+        }
+        uint32 maxStack = (uint32) strtoul(param2, NULL, 0);
+        if (maxStack < 0)
+        {
+            PSendSysMessage("maxstack can't be a negative number.");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"buyerprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"bidinterval",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions bidinterval $ahMapID (2, 6 or 7) $interval(in minutes)");
+            return false;
+        }
+        auctionbot.Commands(12, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"bidsperinterval",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions bidsperinterval $ahMapID (2, 6 or 7) $bids");
+            return false;
+        }
+        auctionbot.Commands(13, ahMapID, NULL, param1);
+    }
+    else
+    {
+        PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+        PSendSysMessage("Try ahbotoptions help to see a list of options.");
+        return false;
+    }
+    return true;
+}
+
+//TrinityJail reload commands Edited by LordPsyan
+	bool ChatHandler::HandleJailReloadCommand(const char* arg)
+{
+    sObjectMgr->LoadJailConf();
+    SendSysMessage(LANG_JAIL_RELOAD);
+    return true;
+}
+
+
 bool ChatHandler::HandleMaxSkillCommand(const char* /*args*/)
 {
     Player* SelectedPlayer = getSelectedPlayer();
@@ -2858,6 +3357,210 @@ bool ChatHandler::HandleServerIdleShutDownCommand(const char *args)
     return true;
 }
 
+bool ChatHandler::HandleQuestAdd(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .addquest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    if (!pQuest)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND,entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // check item starting quest (it can work incorrectly if added without item in inventory)
+    for (uint32 id = 0; id < sItemStorage.MaxEntry; id++)
+    {
+        ItemPrototype const *pProto = sItemStorage.LookupEntry<ItemPrototype>(id);
+        if (!pProto)
+            continue;
+
+        if (pProto->StartQuest == entry)
+        {
+            PSendSysMessage(LANG_COMMAND_QUEST_STARTFROMITEM, entry, pProto->ItemId);
+            SetSentErrorMessage(true);
+            return false;
+        }
+    }
+
+    // ok, normal (creature/GO starting) quest
+    if (player->CanAddQuest(pQuest, true))
+    {
+        player->AddQuest(pQuest, NULL);
+
+        if (player->CanCompleteQuest(entry))
+            player->CompleteQuest(entry);
+    }
+
+    return true;
+}
+
+bool ChatHandler::HandleQuestRemove(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .removequest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    if (!pQuest)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 quest = player->GetQuestSlotQuestId(slot);
+        if (quest == entry)
+        {
+            player->SetQuestSlot(slot,0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            player->TakeQuestSourceItem(quest, false);
+        }
+    }
+
+    // set quest status to not started (will updated in DB at next save)
+    player->SetQuestStatus(entry, QUEST_STATUS_NONE);
+
+    // reset rewarded for restart repeatable quest
+   // player->getQuestStatusMap()[entry].m_rewarded = false;
+
+    SendSysMessage(LANG_COMMAND_QUEST_REMOVED);
+    return true;
+}
+
+bool ChatHandler::HandleQuestComplete(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .quest complete #entry
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    // If player doesn't have the quest
+    if (!pQuest || player->GetQuestStatus(entry) == QUEST_STATUS_NONE)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // Add quest items for quests that require items
+    for (uint8 x = 0; x < QUEST_ITEM_OBJECTIVES_COUNT; ++x)
+    {
+        uint32 id = pQuest->ReqItemId[x];
+        uint32 count = pQuest->ReqItemCount[x];
+        if (!id || !count)
+            continue;
+
+        uint32 curItemCount = player->GetItemCount(id,true);
+
+        ItemPosCountVec dest;
+        uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, id, count-curItemCount);
+        if (msg == EQUIP_ERR_OK)
+        {
+            Item* item = player->StoreNewItem(dest, id, true);
+            player->SendNewItem(item,count-curItemCount,true,false);
+        }
+    }
+
+    // All creature/GO slain/casted (not required, but otherwise it will display "Creature slain 0/10")
+    for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
+    {
+        uint32 creature = pQuest->ReqCreatureOrGOId[i];
+        uint32 creaturecount = pQuest->ReqCreatureOrGOCount[i];
+
+        if (uint32 spell_id = pQuest->ReqSpell[i])
+        {
+            for (uint16 z = 0; z < creaturecount; ++z)
+                player->CastedCreatureOrGO(creature,0,spell_id);
+        }
+        else if (creature > 0)
+        {
+            if (CreatureInfo const* cInfo = sObjectMgr->GetCreatureTemplate(creature))
+                for (uint16 z = 0; z < creaturecount; ++z)
+                    player->KilledMonster(cInfo,0);
+        }
+        else if (creature < 0)
+        {
+            for (uint16 z = 0; z < creaturecount; ++z)
+                player->CastedCreatureOrGO(creature,0,0);
+        }
+    }
+
+    // If the quest requires reputation to complete
+    if (uint32 repFaction = pQuest->GetRepObjectiveFaction())
+    {
+        uint32 repValue = pQuest->GetRepObjectiveValue();
+        uint32 curRep = player->GetReputationMgr().GetReputation(repFaction);
+        if (curRep < repValue)
+            if (FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction))
+                player->GetReputationMgr().SetReputation(factionEntry,repValue);
+    }
+
+    // If the quest requires a SECOND reputation to complete
+    if (uint32 repFaction = pQuest->GetRepObjectiveFaction2())
+    {
+        uint32 repValue2 = pQuest->GetRepObjectiveValue2();
+        uint32 curRep = player->GetReputationMgr().GetReputation(repFaction);
+        if (curRep < repValue2)
+            if (FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction))
+                player->GetReputationMgr().SetReputation(factionEntry,repValue2);
+    }
+
+    // If the quest requires money
+    int32 ReqOrRewMoney = pQuest->GetRewOrReqMoney();
+    if (ReqOrRewMoney < 0)
+        player->ModifyMoney(-ReqOrRewMoney);
+
+    player->CompleteQuest(entry);
+    return true;
+}
+
 bool ChatHandler::HandleBanAccountCommand(const char *args)
 {
     return HandleBanHelper(BAN_ACCOUNT,args);
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 81fef99..4198419 100755
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -152,6 +152,9 @@ m_formation(NULL)
     for (uint8 i = 0; i < CREATURE_MAX_SPELLS; ++i)
         m_spells[i] = 0;
 
+    is_a_bot = false;
+    bot_AI = NULL;
+
     m_CreatureSpellCooldowns.clear();
     m_CreatureCategoryCooldowns.clear();
     m_GlobalCooldown = 0;
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index 360522c..ae7f65b 100755
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -482,6 +482,18 @@ class Creature : public Unit, public GridObject<Creature>
         void AI_SendMoveToPacket(float x, float y, float z, uint32 time, uint32 MovementFlags, uint8 type);
         CreatureAI * AI() const { return (CreatureAI*)i_AI; }
 
+        //
+        //Bot commands
+        //
+        void SetBotAI(CreatureAI *newAI)
+        {
+            bot_AI = newAI;
+        }
+        CreatureAI *GetBotAI(){ return bot_AI; }
+        void SetIAmABot(bool bot){ is_a_bot = bot; }
+        bool GetIAmABot(){ return is_a_bot; }
+
+
         uint32 GetShieldBlockValue() const                  //dunno mob block value
         {
             return (getLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
@@ -724,6 +736,9 @@ class Creature : public Unit, public GridObject<Creature>
 
         bool isVisibleForInState(WorldObject const* seer) const;
     private:
+        bool is_a_bot;
+        CreatureAI *bot_AI;
+
         //WaypointMovementGenerator vars
         uint32 m_waypointID;
         uint32 m_path_id;
diff --git a/src/server/game/Entities/Creature/GossipDef.h b/src/server/game/Entities/Creature/GossipDef.h
index 2b6fe7d..e2e8f71 100755
--- a/src/server/game/Entities/Creature/GossipDef.h
+++ b/src/server/game/Entities/Creature/GossipDef.h
@@ -50,6 +50,7 @@ enum Gossip_Option
     GOSSIP_OPTION_UNLEARNPETTALENTS = 17,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_LEARNDUALSPEC     = 18,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_OUTDOORPVP        = 19,                   //added by code (option for outdoor pvp creatures)
+    GOSSIP_OPTION_BOT               = 20,
     GOSSIP_OPTION_MAX
 };
 
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index 1204a10..dc4a7f1 100755
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -238,6 +238,14 @@ void TempSummon::UnSummon()
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+    if (owner &&
+        owner->GetTypeId() == TYPEID_PLAYER &&
+       ((Player*)owner)->HaveBot() &&
+       ((Player*)owner)->GetBot()->GetGUID()==this->GetGUID() &&
+       this->isDead()) {    // dont unsummon corpse if a bot
+        return;
+    }
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
index 667b240..4f37851 100755
--- a/src/server/game/Entities/GameObject/GameObject.cpp
+++ b/src/server/game/Entities/GameObject/GameObject.cpp
@@ -1692,7 +1692,7 @@ void GameObject::TakenDamage(uint32 damage, Unit *who)
             RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
 
             SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-            SetUInt32Value(GAMEOBJECT_DISPLAYID, m_goInfo->building.destroyedDisplayId);
+            //SetUInt32Value(GAMEOBJECT_DISPLAYID, m_goInfo->building.destroyedDisplayId);
             EventInform(m_goInfo->building.destroyedEvent);
             if (pwho)
                 if (Battleground* bg = pwho->GetBattleground())
@@ -1718,7 +1718,7 @@ void GameObject::TakenDamage(uint32 damage, Unit *who)
                 m_goValue->building.health = 1;
 
             SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-            SetUInt32Value(GAMEOBJECT_DISPLAYID, m_goInfo->building.damagedDisplayId);
+            //SetUInt32Value(GAMEOBJECT_DISPLAYID, m_goInfo->building.damagedDisplayId);
             EventInform(m_goInfo->building.damagedEvent);
             hitType = BG_OBJECT_DMG_HIT_TYPE_JUST_HIGH_DAMAGED;
         }
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index ff08de3..4031e42 100755
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -1568,9 +1568,16 @@ void WorldObject::GetRandomPoint(const Position &pos, float distance, float &ran
 
 void WorldObject::UpdateGroundPositionZ(float x, float y, float &z) const
 {
-    float new_z = GetBaseMap()->GetHeight(x,y,z,true);
-    if (new_z > INVALID_HEIGHT)
-        z = new_z+ 0.05f;                                   // just to be sure that we are not a few pixel under the surface
+    float map_z = GetBaseMap()->GetHeight(x,y,z,false);
+    float vmap_z = GetBaseMap()->GetHeight(x,y,z,true);
+
+    if(vmap_z > INVALID_HEIGHT)
+       z = vmap_z;    // add or subtract say 0.05f, to adjust bot hover height
+
+    if((map_z > vmap_z) && (map_z > z))
+       z = map_z;
+
+    Trinity::NormalizeMapCoord(z);
 }
 
 bool Position::IsPositionValid() const
@@ -2106,7 +2113,19 @@ TempSummon *Map::SummonCreature(uint32 entry, const Position &pos, SummonPropert
         case UNIT_MASK_SUMMON:    summon = new TempSummon (properties, summoner);  break;
         case UNIT_MASK_GUARDIAN:  summon = new Guardian   (properties, summoner);  break;
         case UNIT_MASK_PUPPET:    summon = new Puppet     (properties, summoner);  break;
-        case UNIT_MASK_TOTEM:     summon = new Totem      (properties, summoner);  break;
+        case UNIT_MASK_TOTEM:
+        {
+            if(summoner->isCharmed())
+            {
+                //If the caster is charmed, assume it is a Bot.  This might not always be
+                //the case, but oh well.  This will allow the affects of the totem
+                //(ex healing, stoneskin, etc, to affect the bot owner insteadof the
+                //bot. Thats ok, the bot is expendable  :-)
+                summon = new Totem      (properties, summoner->GetCharmer());  break;
+            } else {
+                summon = new Totem      (properties, summoner);  break;
+            }
+        }
         case UNIT_MASK_MINION:    summon = new Minion     (properties, summoner);  break;
         default:    return NULL;
     }
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index c95e363..4b03a8d 100755
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "AnticheatMgr.h"
 #include "Common.h"
 #include "Language.h"
 #include "DatabaseEnv.h"
@@ -69,6 +70,13 @@
 #include "LFGMgr.h"
 #include "CharacterDatabaseCleaner.h"
 #include <cmath>
+#include "OutdoorPvPWG.h"
+
+// Playerbot mod
+#include "CreatureAIFactory.h"
+#include "Config.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
@@ -389,12 +397,43 @@ UpdateMask Player::updateVisualBits;
 #ifdef _MSC_VER
 #pragma warning(disable:4355)
 #endif
-Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputationMgr(this)
+Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputationMgr(this), m_MaxPlayerbots(9), m_bot_died(false)
 {
+    // Playerbot mod
+    m_playerbotAI = NULL;
+
 #ifdef _MSC_VER
 #pragma warning(default:4355)
 #endif
 
+	m_jail_guid     = 0;
+    m_jail_char     = "";
+    m_jail_amnestie = false;
+    m_jail_warning  = false;
+    m_jail_isjailed = false;
+    m_jail_amnestietime =0;
+    m_jail_release  = 0;
+    m_jail_times    = 0;
+    m_jail_reason   = "";
+    m_jail_gmacc    = 0;
+    m_jail_gmchar   = "";
+    m_jail_lasttime = "";
+    m_jail_duration = 0;
+	// Jail end
+
+    anticheatData.disableACCheck = false;
+    anticheatData.disableACCheckTimer = 0;
+    GetPosition(&anticheatData.lastMovementInfo.pos);
+    anticheatData.lastOpcode = 0;
+
+    anticheatData.total_reports = 0;
+
+    for (uint8 i = 0; i < 5; i++)
+        anticheatData.type_reports[i] = 0;
+
+    anticheatData.average = 0;
+    anticheatData.creation_time = 0;
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -608,6 +647,22 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
 
     m_ChampioningFaction = 0;
 
+    ///////////////////// Bot System ////////////////////////
+    m_botTimer = 0;
+    m_bot = NULL;
+    m_bot_form = 0;
+    m_bot_race = 0;
+    m_bot_class = 0;
+    m_bot_must_wait_for_spell_1 = 0;
+    m_bot_must_wait_for_spell_2 = 0;
+    m_bot_must_wait_for_spell_3 = 0;
+    m_bot_must_be_created = false;
+    m_bot_must_die = false;
+    m_bot_entry_must_be_created = 0;
+    m_bot_class_must_be_created = 0;
+    m_bot_race_must_be_created = 0;
+    m_bot_entry = 0;
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -622,6 +677,8 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
 
 Player::~Player ()
 {
+    sAnticheatMgr->DeletePlayerReport(this);
+
     // it must be unloaded already in PlayerLogout and accessed only for loggined player
     //m_social = NULL;
 
@@ -653,6 +710,12 @@ Player::~Player ()
 
     delete m_declinedname;
     delete m_runes;
+    //Playerbot mod: remove AI if exists
+    if(m_playerbotAI != NULL)
+    {
+        delete m_playerbotAI;
+        m_playerbotAI = NULL;
+    }
 
     sWorld->DecreasePlayerCount();
 }
@@ -667,6 +730,27 @@ void Player::CleanupsBeforeDelete(bool finalCleanup)
     if (m_transport)
         m_transport->RemovePassenger(this);
 
+    if(GetGroup() && HaveBot())
+    {
+         Creature *m_bot = GetBot();
+         Group *m_group = GetGroup();
+
+         //removing bot from group
+         if(m_group->IsMember(m_bot->GetGUID()))
+         {
+             //deleting bot from group
+             if(m_group->RemoveMember(m_bot->GetGUID(), GROUP_REMOVEMETHOD_DEFAULT) < 1) // 99 means I'm a bot
+             {
+                 //no one left in group so deleting group
+                 delete m_group;
+                 sObjectMgr->RemoveGroup(m_group);
+             }
+         }
+         m_bot->SetCharmerGUID(0);
+         m_bot->RemoveFromWorld();
+         RemoveBot();
+    }
+
     // clean up player-instance binds, may unload some instance saves
     for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
         for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
@@ -1249,6 +1333,8 @@ void Player::Update(uint32 p_time)
     if (!IsInWorld())
         return;
 
+    sAnticheatMgr->HandleHackDetectionTimer(this, p_time);
+
     // undelivered mail
     if (m_nextMailDelivereTime && m_nextMailDelivereTime <= time(NULL))
     {
@@ -1286,6 +1372,79 @@ void Player::Update(uint32 p_time)
     Unit::Update(p_time);
     SetCanDelayTeleport(false);
 
+	if (m_jail_isjailed)
+    {
+        time_t localtime;
+        localtime = time(NULL);
+		
+        if (m_jail_release <= localtime)
+        {
+            m_jail_isjailed = false;
+            m_jail_release = 0;
+
+            _SaveJail();
+            
+            sWorld->SendWorldText(LANG_JAIL_CHAR_FREE, GetName());
+            
+			CastSpell(this,8690,false);
+
+            return;
+        }
+
+        if (m_team == ALLIANCE)
+        {
+            if (GetDistance(sObjectMgr->m_jailconf_ally_x, sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z) > sObjectMgr->m_jailconf_radius)
+            {
+                TeleportTo(sObjectMgr->m_jailconf_ally_m, sObjectMgr->m_jailconf_ally_x,
+                    sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z, sObjectMgr->m_jailconf_ally_o);
+                return;
+            }
+        }
+        else
+        {
+            if (GetDistance(sObjectMgr->m_jailconf_horde_x, sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z) > sObjectMgr->m_jailconf_radius)
+            {
+                TeleportTo(sObjectMgr->m_jailconf_horde_m, sObjectMgr->m_jailconf_horde_x,
+                    sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z, sObjectMgr->m_jailconf_horde_o);
+                return;
+            }
+			
+        }
+    }
+	
+	if (m_jail_warning == true)
+	{
+		m_jail_warning  = false;
+		
+		if (sObjectMgr->m_jailconf_warn_player == m_jail_times || sObjectMgr->m_jailconf_warn_player <= m_jail_times)
+		{
+			if ((sObjectMgr->m_jailconf_max_jails-1 == m_jail_times-1) && sObjectMgr->m_jailconf_ban-1)
+			{
+				ChatHandler(this).PSendSysMessage(LANG_JAIL_WARNING_BAN, m_jail_times , sObjectMgr->m_jailconf_max_jails-1);
+			}
+			else
+			{
+				ChatHandler(this).PSendSysMessage(LANG_JAIL_WARNING, m_jail_times , sObjectMgr->m_jailconf_max_jails);
+			}
+		        
+		}
+				return;
+	}
+if (m_jail_amnestie == true && sObjectMgr->m_jailconf_amnestie > 0)
+{
+	m_jail_amnestie =false;
+	time_t localtime;
+    localtime    = time(NULL);
+	
+	if (localtime >  m_jail_amnestietime)
+	{   
+		CharacterDatabase.PExecute("DELETE FROM `jail` WHERE `guid` = '%u'",GetGUIDLow());
+		ChatHandler(this).PSendSysMessage(LANG_JAIL_AMNESTII);
+	}
+    return;
+}
+
+
     time_t now = time(NULL);
 
     UpdatePvPFlag(now);
@@ -1465,10 +1624,32 @@ void Player::Update(uint32 p_time)
         RegenerateAll();
     }
 
+
+    //want to refresh bot even if we're dead so
+    //it can rez me
+    if(HaveBot() || GetBotMustBeCreated() || m_bot_died)
+        RefreshBot(p_time);
+
+
+    if(m_botTimer > 0)
+    {
+        if(p_time >= m_botTimer)
+            m_botTimer = 0;
+        else
+            m_botTimer -= p_time;
+    }
+
+
     if (m_deathState == JUST_DIED)
-        KillPlayer();
+        // Prevent death of jailed players
+        if (!m_jail_isjailed) KillPlayer();
+        else
+        {
+            m_deathState = ALIVE;
+            RegenerateAll();
+        }
 
-    if (m_nextSave > 0)
+    if (m_nextSave > 0 && !m_jail_isjailed)
     {
         if (p_time >= m_nextSave)
         {
@@ -1550,6 +1731,9 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && isAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    //Playerbot mod: this was added as part of the Playerbot mod,
+    if(m_playerbotAI != NULL) m_playerbotAI->UpdateAI(p_time);
 }
 
 void Player::setDeathState(DeathState s)
@@ -1806,7 +1990,8 @@ void Player::SendTeleportPacket(Position &oldPos)
     WorldPacket data2(MSG_MOVE_TELEPORT, 38);
     data2.append(GetPackGUID());
     BuildMovementPacket(&data2);
-    Relocate(&oldPos);
+    // Relocate(&oldPos);
+    if (!this->IsPlayerbot()) Relocate(&oldPos);
     SendMessageToSet(&data2, false);
 }
 
@@ -1843,6 +2028,8 @@ void Player::TeleportOutOfMap(Map *oldMap)
 
 bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientation, uint32 options)
 {
+    sAnticheatMgr->DisableAnticheatDetection(this,true);
+
     if (!MapManager::IsValidMapCoord(mapid, x, y, z, orientation))
     {
         sLog->outError("TeleportTo: invalid map %d or absent instance template.", mapid);
@@ -1856,6 +2043,16 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         return false;
     }
 
+    //Playerbot mod: if this user has bots, tell them to stop following master
+    //so they don't try to follow the master after the master teleports
+    for(PlayerBotMap::const_iterator itr = GetSession()->GetPlayerBotsBegin(); itr != GetSession()->GetPlayerBotsEnd(); ++itr)
+    {
+            Player *botPlayer = itr->second;
+            botPlayer->GetMotionMaster()->Clear();
+    }
+
+
+
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
@@ -1905,6 +2102,33 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         }
     }
 
+     //HACK ELSE CLIENT CRASH WHEN PLAYER IS TELEPORTED
+     if(GetGroup() && HaveBot())
+     {
+         //sLog->outError("Player::teleporting.. removing from group");
+
+         Group *m_group = GetGroup();
+         Creature *m_bot = GetBot();
+
+         //removing bot from group
+         if(m_group->IsMember(m_bot->GetGUID()))
+         {
+             //deleting bot from group
+             if(m_group->RemoveMember(m_bot->GetGUID(), GROUP_REMOVEMETHOD_DEFAULT) < 1) // 99 means I'm a bot
+             {
+                 //no one left in group so deleting group
+                 delete m_group;
+                 sObjectMgr->RemoveGroup(m_group);
+             }
+         }
+         m_bot->SetCharmerGUID(0);
+         //m_bot->RemoveFromWorld();
+         RemoveBot();
+         SetBotMustBeCreated(m_bot_entry, newbotrace, newbotclass);
+     }
+
+
+
     // The player was ported to another map and loses the duel immediately.
     // We have to perform this check before the teleport, otherwise the
     // ObjectAccessor won't find the flag.
@@ -2018,182 +2242,1284 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
             if (pet)
                 UnsummonPetTemporaryIfAny();
 
-            // remove all dyn objects
-            RemoveAllDynObjects();
+            // remove all dyn objects
+            RemoveAllDynObjects();
+
+            // stop spellcasting
+            // not attempt interrupt teleportation spell at caster teleport
+            if (!(options & TELE_TO_SPELL))
+                if (IsNonMeleeSpellCasted(true))
+                    InterruptNonMeleeSpells(true);
+
+            //remove auras before removing from map...
+            RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_CHANGE_MAP | AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING);
+
+            if (!GetSession()->PlayerLogout())
+            {
+                // send transfer packets
+                WorldPacket data(SMSG_TRANSFER_PENDING, (4+4+4));
+                data << uint32(mapid);
+                if (m_transport)
+                {
+                    data << m_transport->GetEntry() << GetMapId();
+                }
+                GetSession()->SendPacket(&data);
+
+                data.Initialize(SMSG_NEW_WORLD, (20));
+                if (m_transport)
+                    data << (uint32)mapid << m_movementInfo.t_pos.PositionXYZOStream();
+                else
+                    data << (uint32)mapid << (float)x << (float)y << (float)z << (float)orientation;
+
+                GetSession()->SendPacket(&data);
+                SendSavedInstances();
+            }
+
+            // remove from old map now
+            if (oldmap)
+                oldmap->Remove(this, false);
+
+            // new final coordinates
+            float final_x = x;
+            float final_y = y;
+            float final_z = z;
+            float final_o = orientation;
+
+            if (m_transport)
+            {
+                final_x += m_movementInfo.t_pos.GetPositionX();
+                final_y += m_movementInfo.t_pos.GetPositionY();
+                final_z += m_movementInfo.t_pos.GetPositionZ();
+                final_o += m_movementInfo.t_pos.GetOrientation();
+            }
+
+            m_teleport_dest = WorldLocation(mapid, final_x, final_y, final_z, final_o);
+            SetFallInformation(0, final_z);
+            // if the player is saved before worldportack (at logout for example)
+            // this will be used instead of the current location in SaveToDB
+
+            // move packet sent by client always after far teleport
+            // code for finish transfer to new map called in WorldSession::HandleMoveWorldportAckOpcode at client packet
+            SetSemaphoreTeleportFar(true);
+        }
+        else
+            return false;
+    }
+
+    //if I'm dead than need to remove bot manually
+    //This means I'm at the graveyard, but the bot or rest of the group
+    //finished off the mob
+    if(HaveBot() && m_bot->isAlive() && !isAlive())
+    {
+        m_bot->SetCharmerGUID(0);
+        m_bot->RemoveFromWorld();
+        RemoveBot();
+
+        //recreate it when you are alive again
+        SetBotMustBeCreated(m_bot_entry, newbotrace, newbotclass);
+    } //end if bot is alive and I'm not
+
+    return true;
+}
+
+bool Player::TeleportToBGEntryPoint()
+{
+    ScheduleDelayedOperation(DELAYED_BG_MOUNT_RESTORE);
+    ScheduleDelayedOperation(DELAYED_BG_TAXI_RESTORE);
+    return TeleportTo(m_bgData.joinPos);
+}
+
+void Player::ProcessDelayedOperations()
+{
+    if (m_DelayedOperations == 0)
+        return;
+
+    if (m_DelayedOperations & DELAYED_RESURRECT_PLAYER)
+    {
+        ResurrectPlayer(0.0f, false);
+
+        if (GetMaxHealth() > m_resurrectHealth)
+            SetHealth(m_resurrectHealth);
+        else
+            SetFullHealth();
+
+        if (GetMaxPower(POWER_MANA) > m_resurrectMana)
+            SetPower(POWER_MANA, m_resurrectMana);
+        else
+            SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+
+        SetPower(POWER_RAGE, 0);
+        SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
+
+        SpawnCorpseBones();
+    }
+
+    if (m_DelayedOperations & DELAYED_SAVE_PLAYER)
+        SaveToDB();
+
+    if (m_DelayedOperations & DELAYED_SPELL_CAST_DESERTER)
+        CastSpell(this, 26013, true);               // Deserter
+
+    if (m_DelayedOperations & DELAYED_BG_MOUNT_RESTORE)
+    {
+        if (m_bgData.mountSpell)
+        {
+            CastSpell(this, m_bgData.mountSpell, true);
+            m_bgData.mountSpell = 0;
+        }
+    }
+
+    if (m_DelayedOperations & DELAYED_BG_TAXI_RESTORE)
+    {
+        if (m_bgData.HasTaxiPath())
+        {
+            m_taxi.AddTaxiDestination(m_bgData.taxiPath[0]);
+            m_taxi.AddTaxiDestination(m_bgData.taxiPath[1]);
+            m_bgData.ClearTaxiPath();
+
+            ContinueTaxiFlight();
+        }
+    }
+
+    //we have executed ALL delayed ops, so clear the flag
+    m_DelayedOperations = 0;
+}
+
+void Player::AddToWorld()
+{
+    ///- Do not add/remove the player from the object storage
+    ///- It will crash when updating the ObjectAccessor
+    ///- The player should only be added when logging in
+    Unit::AddToWorld();
+
+    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
+        if (m_items[i])
+            m_items[i]->AddToWorld();
+}
+
+void Player::RemoveFromWorld()
+{
+    // cleanup
+    if (IsInWorld())
+    {
+        ///- Release charmed creatures, unsummon totems and remove pets/guardians
+        StopCastingCharm();
+        StopCastingBindSight();
+        UnsummonPetTemporaryIfAny();
+        sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
+    }
+
+    ///- Do not add/remove the player from the object storage
+    ///- It will crash when updating the ObjectAccessor
+    ///- The player should only be removed when logging out
+    Unit::RemoveFromWorld();
+
+    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
+    {
+        if (m_items[i])
+            m_items[i]->RemoveFromWorld();
+    }
+
+    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
+        iter->second->RemoveFromWorld();
+
+    if (m_uint32Values)
+    {
+        if (WorldObject *viewpoint = GetViewpoint())
+        {
+            sLog->outCrash("Player %s has viewpoint %u %u when removed from world", GetName(), viewpoint->GetEntry(), viewpoint->GetTypeId());
+            SetViewpoint(viewpoint, false);
+        }
+    }
+}
+
+Player *Player::GetObjPlayer(uint64 guid)
+{
+    return sObjectMgr->GetPlayer(guid);
+}
+
+void Player::GetBotLevelInfo(uint32 race, uint32 class_,uint32 level, PlayerLevelInfo* info) const {
+    sObjectMgr->GetPlayerLevelInfo (race, class_, level, info);
+}
+
+void Player::RefreshBot(uint32 diff)
+{
+    if(m_botTimer != 0)
+        return;
+    uint32 refreshDelay = 0;
+
+    if(m_bot_died == true && !this->isInCombat() && isAlive())
+    {
+        //recreate bot because it died
+        CreateBot(m_bot_entry, newbotrace, newbotclass);
+        m_bot = GetBot();
+        m_bot_died = false;
+    }
+
+    if (isInFlight())
+    {
+        if (HaveBot())
+        {
+            if (GetGroup())
+            {
+                Group* m_group = GetGroup();
+                Creature* m_bot = GetBot();
+
+                // removing bot from group
+                if (m_group->IsMember(m_bot->GetGUID()))
+                {
+                    if (m_group->RemoveMember(m_bot->GetGUID(), GROUP_REMOVEMETHOD_DEFAULT) <= 1)
+                    {
+                        // deleting group since no one is left
+                        delete m_group;
+                        sObjectMgr->RemoveGroup(m_group);
+                    }
+                }
+            }
+            m_bot->SetCharmerGUID(0);
+            m_bot->RemoveFromWorld();
+            RemoveBot();
+
+            SetBotMustBeCreated(m_bot_entry, newbotrace, newbotclass);
+        }
+        return;
+    }
+
+    if(HaveBot())
+    {
+        Creature *m_bot = GetBot();
+
+        //BOT IS DEAD SUPPORT
+        if(GetGroup() && !m_bot->isAlive())
+        {
+            Group *m_group = GetGroup();
+
+            //respawn if master is not in combat and is alive
+            if(!this->isInCombat() && isAlive())
+            {
+                CreateBot(m_bot_entry, newbotrace, newbotclass);
+                m_bot = GetBot();
+            } else {
+                m_bot_died = true;
+            }
+        }
+        //BOT MUST DIE SUPPORT
+        else if(GetBotMustDie())
+        {
+            if(m_bot->isAlive()) {  // dont want to delete from group if dead
+                if(GetGroup())
+                {
+                    Group *m_group = GetGroup();
+
+                    //removing bot from group
+                    if(m_group->IsMember(m_bot->GetGUID()) && m_group->GetMembersCount() >= 2)
+                    {
+                        //deleting bot from group
+                        if(m_group->RemoveMember(m_bot->GetGUID(), GROUP_REMOVEMETHOD_DEFAULT) < 1) // 99 means I'm a bot
+                        {
+                            //no one left in group so deleting group
+                            delete m_group;
+                            sObjectMgr->RemoveGroup(m_group);
+                        }
+                    }
+                }
+
+                m_bot->SetReactState(REACT_PASSIVE);
+                m_bot->CombatStop();
+
+                m_bot->DeleteThreatList();
+                m_bot->SetCharmerGUID(0);
+                m_bot->RemoveFromWorld();
+                RemoveBot();
+
+                CharacterDatabase.PExecute("DELETE FROM character_npcbot WHERE owner='%u'", this->GetGUIDLow());
+            }
+        }
+    }
+
+    if(HaveBot() && GetBot()->isAlive())
+    {
+
+/*------------------------------------------*/
+    Creature *m_bot = GetBot();
+/*------------------------------------------*/
+
+    if(isInCombat())
+    {
+        if(m_bot->getVictim() > 0)
+        {
+            if(m_bot->getVictim()->IsPolymorphed())
+            {
+                    //m_bot->Say("SHEEP!", LANG_UNIVERSAL, NULL);
+                    m_bot->SetReactState(REACT_PASSIVE); //Don't attack sheep
+                    m_bot->CombatStop();
+                    return; //for now return because can't do anything, need to continue timer though somehow
+            } //end if polymorpth
+        } //end if getVictim > 0
+        else if(getVictim() > 0 && !getVictim()->IsPolymorphed())
+        {
+            if(GetBotClass() == CLASS_PRIEST || GetBotClass() == CLASS_MAGE || GetBotClass() == CLASS_WARLOCK)
+                m_bot->SetReactState(REACT_PASSIVE); //casters shouldn't melee
+            else
+                m_bot->SetReactState(REACT_DEFENSIVE);
+        }
+
+        //if I'm in combat but the bot is not, put bot in combat
+        //this fixes the case where group member gets initial aggro
+        //otherwise the bot wont fight unless I get hit.
+        if(!m_bot->isInCombat() && m_bot->GetReactState() != REACT_PASSIVE)
+        {
+            if(getVictim() > 0 && m_bot->GetDistance(getVictim())<30) {
+                m_bot->AI()->AttackStart(getVictim());
+                SetBotCommandState(COMMAND_ATTACK);
+                //m_bot->AI()->BotAttackStart(getVictim());
+            }
+        } else {
+//sLog->outError ("putting priest to follow master");
+  //          m_bot->GetMotionMaster()->MoveFollow(this, urand(5, 10), PET_FOLLOW_ANGLE);
+        }
+    } //end if isInCombat
+
+
+    //TELEPORT AND CHANGE ZONE/AREA SUPPORT
+    if(!isInFlight())
+    {
+        bool tp = false;
+        if(GetMapId() != m_bot->GetMapId())
+            tp = true;
+        else if(GetZoneId() != m_bot->GetZoneId())
+            tp = true;
+        //If bot and player not in the same area but around 25
+        else if((GetAreaId() != m_bot->GetAreaId()) &&
+        ((abs(m_bot->GetPositionX() - GetPositionX()) > 25) ||
+        (abs(m_bot->GetPositionY() - GetPositionY()) > 25)) ||
+        (abs(m_bot->GetPositionZ() - GetPositionZ()) > 25))
+        {
+            tp = true;
+        }
+
+        //If player change of zone/area
+        if(tp)
+        {
+            //HACK ELSE BOT IS DUPLICATED AND CLIENT CRASH
+            if(GetGroup() && GetBot())
+            {
+                Group *m_group = GetGroup();
+                Creature *m_bot = GetBot();
+
+                //removing bot from group
+                if(m_group->IsMember(m_bot->GetGUID()))
+                {
+                    //deleting bot from group
+                    if(m_group->RemoveMember(m_bot->GetGUID(), GROUP_REMOVEMETHOD_DEFAULT) < 1) // 99 means I'm a bot
+                    {
+                        //no one left in group so deleting group
+                        delete m_group;
+                        sObjectMgr->RemoveGroup(m_group);
+                    }
+                }
+            }
+
+            //SAVE INFO
+            uint32 entry = m_bot->GetEntry();
+
+            //DESPAWN
+            m_bot->SetCharmerGUID(0);
+            m_bot->RemoveFromWorld();
+            RemoveBot();
+
+            //RESPAWN
+            CreateBot(entry, newbotrace, newbotclass);
+            m_bot = GetBot();
+            return;
+        }
+    }
+
+        //FLYING MOUNT SUPPORT
+        if((IsMounted() && HasAuraType(SPELL_AURA_FLY)) || canFly() || IsFlying() || isInFlight())
+        {
+            if(m_bot->GetMountID() != 17759
+            && m_bot->GetMountID() != 17703
+            && m_bot->GetMountID() != 17718
+            && m_bot->GetMountID() != 17720
+            && m_bot->GetMountID() != 17721
+            && m_bot->GetMountID() != 17719)
+            {
+                int m_mount = 0;
+                int m_rand = rand()%100;
+                if(m_rand < 33)      m_mount = 1;
+                else if(m_rand > 64) m_mount = 2;
+                else                 m_mount = 3;
+
+                if((GetBotClass() == CLASS_DRUID) && (m_bot->getLevel() >= 70)) m_mount = 0;
+                if((GetBotClass() == CLASS_DRUID) && (m_bot->getLevel() >= 70)) m_mount = 0;
+
+                if(GetBotRace() == RACE_HUMAN || GetBotRace() == RACE_DWARF || GetBotRace() == RACE_NIGHTELF || GetBotRace() == RACE_GNOME || GetBotRace() == RACE_DRAENEI)
+                {
+                    switch(m_mount)
+                    {
+                        case 1: m_bot->Mount(17759); break;
+                        case 2: m_bot->Mount(17703); break;
+                        case 3: m_bot->Mount(17718); break;
+                        default: break;
+                    }
+                }
+                else if(GetBotRace() == RACE_ORC || GetBotRace() == RACE_UNDEAD_PLAYER || GetBotRace() == RACE_TAUREN || GetBotRace() == RACE_TROLL || GetBotRace() == RACE_BLOODELF)
+                {
+                    switch(m_mount)
+                    {
+                        case 1: m_bot->Mount(17720); break;
+                        case 2: m_bot->Mount(17721); break;
+                        case 3: m_bot->Mount(17719); break;
+                        default: break;
+                    }
+                }
+                //m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_WALK) - 0.1f, true);
+            }
+            if(isInFlight())
+            {
+                m_bot->HasUnitMovementFlag(MOVEMENTFLAG_FLYING);
+                m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_FLIGHT) + 0.1f, true);
+            }
+            else
+            {
+                m_bot->HasUnitMovementFlag(MOVEMENTFLAG_NONE);
+                m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_RUN) + 0.1f, true);
+            }
+        }
+        //MOUNT SUPPORT
+        else if(IsMounted() && !m_bot->IsMounted())
+        {
+            int m_mount = 0;
+            int m_rand = rand()%100;
+            if(m_rand < 33)      m_mount = 1;
+            else if(m_rand > 64) m_mount = 2;
+            else                 m_mount = 3;
+
+            if((GetBotClass() == CLASS_DRUID) && (m_bot->getLevel() < 60)) m_mount = 0;
+            if((GetBotClass() == CLASS_DRUID) && (m_bot->getLevel() < 60)) m_mount = 0;
+
+            switch(GetBotRace())
+            {
+                case RACE_HUMAN:
+                {
+                    if(getLevel() < 60)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(2409); break;
+                            case 2: m_bot->Mount(2404); break;
+                            case 3: m_bot->Mount(2405); break;
+                            default: break;
+                        }
+                    }
+                    else
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(14338); break;
+                            case 2: m_bot->Mount(14583); break;
+                            case 3: m_bot->Mount(14582); break;
+                            default: break;
+                        }
+                    }
+                    break;
+                }
+                case RACE_ORC:
+                {
+                    if(getLevel() < 60)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(247); break;
+                            case 2: m_bot->Mount(2327); break;
+                            case 3: m_bot->Mount(2328); break;
+                            default: break;
+                        }
+                    }
+                    else
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(14575); break;
+                            case 2: m_bot->Mount(14574); break;
+                            case 3: m_bot->Mount(14573); break;
+                            default: break;
+                        }
+                    }
+                    break;
+                }
+                case RACE_DWARF:
+                {
+                    if(getLevel() < 60)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(2785); break;
+                            case 2: m_bot->Mount(2786); break;
+                            case 3: m_bot->Mount(2736); break;
+                            default: break;
+                        }
+                    }
+                    else
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(14347); break;
+                            case 2: m_bot->Mount(14576); break;
+                            case 3: m_bot->Mount(14346); break;
+                            default: break;
+                        }
+                    }
+                    break;
+                }
+                case RACE_NIGHTELF:
+                {
+                    if(getLevel() < 60)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(6080); break;
+                            case 2: m_bot->Mount(6448); break;
+                            case 3: m_bot->Mount(6444); break;
+                            default: break;
+                        }
+                    }
+                    else
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(14632); break;
+                            case 2: m_bot->Mount(14332); break;
+                            case 3: m_bot->Mount(14331); break;
+                            default: break;
+                        }
+                    }
+                    break;
+                }
+                case RACE_UNDEAD_PLAYER:
+                {
+                    if(getLevel() < 60)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(10670); break;
+                            case 2: m_bot->Mount(10671); break;
+                            case 3: m_bot->Mount(10672); break;
+                            default: break;
+                        }
+                    }
+                    else
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(10721); break;
+                            case 2: m_bot->Mount(10720); break;
+                            case 3: m_bot->Mount(10719); break;
+                            default: break;
+                        }
+                    }
+                    break;
+                }
+                case RACE_TAUREN:
+                {
+                    if(getLevel() < 60)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(12246); break;
+                            case 2: m_bot->Mount(11641); break;
+                            case 3: m_bot->Mount(12245); break;
+                            default: break;
+                        }
+                    }
+                    else
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(14579); break;
+                            case 2: m_bot->Mount(14349); break;
+                            case 3: m_bot->Mount(14578); break;
+                            default: break;
+                        }
+                    }
+                    break;
+                }
+                case RACE_GNOME:
+                {
+                    if(getLevel() < 60)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(9473); break;
+                            case 2: m_bot->Mount(10661); break;
+                            case 3: m_bot->Mount(6569); break;
+                            default: break;
+                        }
+                    }
+                    else
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(14376); break;
+                            case 2: m_bot->Mount(14374); break;
+                            case 3: m_bot->Mount(14377); break;
+                            default: break;
+                        }
+                    }
+                    break;
+                }
+                case RACE_TROLL:
+                {
+                    if(getLevel() < 60)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(6472); break;
+                            case 2: m_bot->Mount(4806); break;
+                            case 3: m_bot->Mount(6473); break;
+                            default: break;
+                        }
+                    }
+                    else
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(14344); break;
+                            case 2: m_bot->Mount(14339); break;
+                            case 3: m_bot->Mount(14342); break;
+                            default: break;
+                        }
+                    }
+                    break;
+                }
+                case RACE_BLOODELF:
+                {
+                    if(getLevel() < 60)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(18696); break;
+                            case 2: m_bot->Mount(19480); break;
+                            case 3: m_bot->Mount(19478); break;
+                            default: break;
+                        }
+                    }
+                    else
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(19484); break;
+                            case 2: m_bot->Mount(18697); break;
+                            case 3: m_bot->Mount(19482); break;
+                            default: break;
+                        }
+                    }
+                    break;
+                }
+                case RACE_DRAENEI:
+                {
+                    if(getLevel() < 60)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(17063); break;
+                            case 2: m_bot->Mount(19870); break;
+                            case 3: m_bot->Mount(19869); break;
+                            default: break;
+                        }
+                    }
+                    else
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(19871); break;
+                            case 2: m_bot->Mount(19872); break;
+                            case 3: m_bot->Mount(19873); break;
+                            default: break;
+                        }
+                    }
+                    break;
+                }
+            }
+            m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_WALK) - 0.1f, true);
+        }
+        else if(!IsMounted()
+            && m_bot->IsMounted())
+        {
+            m_bot->Unmount();
+            CreatureInfo const *cinfo = sObjectMgr->GetCreatureTemplate(m_bot->GetEntry());
+            m_bot->SetSpeed(MOVE_RUN, cinfo->speed_run, true);
+            m_bot->HasUnitMovementFlag(MOVEMENTFLAG_NONE);
+        }
+
+        //if low on mana, take a drink (only check for classes with custom AI)
+        //because they are the only ones currently using mana
+        if(GetBotClass() == CLASS_SHAMAN || GetBotClass() == CLASS_DRUID ||
+        GetBotClass() == CLASS_PRIEST || GetBotClass() == CLASS_MAGE || GetBotClass() == CLASS_HUNTER ||
+        GetBotClass() == CLASS_WARLOCK || GetBotClass() == CLASS_PALADIN)
+        {
+            if(m_bot->GetPower(POWER_MANA)*100/m_bot->GetMaxPower(POWER_MANA) < 80 &&
+              !m_bot->HasAura(1137) &&
+              GetBotMustWaitForSpell3() <= 0 &&
+              !m_bot->isInCombat())
+            {
+                m_bot->CastSpell(m_bot, 1137, true);
+                SetBotMustWaitForSpell3(1000);
+                m_bot->SetStandState(1);
+                m_botTimer = 5000; //set longer delay so it wont stand up right away
+                return;
+            }
+        }
+
+        //if drinking, have to fake mana regen because charmed NPCs
+        //do not regen mana
+        if(m_bot->HasAura(1137))
+        {
+            uint32 addvalue = 0;
+            uint32 maxValue = m_bot->GetMaxPower(POWER_MANA);
+            uint32 curValue = m_bot->GetPower(POWER_MANA);
+
+            if(curValue <= maxValue)
+            {
+                addvalue = maxValue/20;
+                m_bot->ModifyPower(POWER_MANA, addvalue);
+                //return;
+            }
+        }
+
+        if(m_bot->HasAura(1137) && m_bot->GetPower(POWER_MANA) >= m_bot->GetMaxPower(POWER_MANA))
+            m_bot->RemoveAurasDueToSpell(1137);
+
+        //eat
+        if(m_bot->GetHealth()*100 / m_bot->GetMaxHealth() < 80 &&
+           !m_bot->HasAura(10256) &&
+           GetBotMustWaitForSpell3() <= 0 &&
+           !m_bot->isInCombat())
+        {
+            SetBotMustWaitForSpell3(1000);
+            m_bot->CastSpell(m_bot, 10256, true);
+            m_bot->SetStandState(1);
+            m_botTimer = 5000; //set longer delay so it wont stand up right away
+            return;
+        }
+
+        //if eating, have to fake regen because charmed NPCs
+        //do not regen
+        if(m_bot->HasAura(10256))
+        {
+            uint32 addvalue = 0;
+            uint32 maxValue = m_bot->GetMaxHealth();
+            uint32 curValue = m_bot->GetHealth();
+
+            if(curValue <= maxValue)
+            {
+                addvalue = maxValue/20;
+                m_bot->SetHealth(curValue + addvalue);
+                //return;
+            }
+        }
+
+        if(m_bot->GetHealth() == m_bot->GetMaxHealth() && m_bot->HasAura(10256))
+            m_bot->RemoveAurasDueToSpell(10256);
+
+        //if bot stands up for some reason, ie goes into combat,
+        //remove the food and drink affect
+        if(m_bot->isInCombat() /*|| !m_bot->IsStopped()*/ || m_bot->IsStandState())
+        {
+            if(m_bot->HasAura(10256)) m_bot->RemoveAurasDueToSpell(10256);
+            if(m_bot->HasAura(1137)) m_bot->RemoveAurasDueToSpell(1137);
+        }
+
+        //if done drinking and eating, stand up
+        if(!isInCombat() && m_bot->IsSitState() && !m_bot->HasAura(1137) && !m_bot->HasAura(10256))
+            m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+        //SPELL AI CUSTOM SUPPORT
+        switch(GetBotClass())
+        {
+            case CLASS_DRUID: //DRUID FORM SUPPORT
+            {
+                if(!m_bot->isAlive()) break;
+
+                CreatureInfo const *cinfo = sObjectMgr->GetCreatureTemplate(m_bot->GetEntry());
+
+                uint32 m_old_bot_form = m_bot->GetDisplayId();
+                if((IsMounted() && HasAuraType(SPELL_AURA_FLY)) || canFly() || IsFlying() || isInFlight())
+                {
+                    //flight form
+                    if((((IsMounted()) && (m_bot->getLevel() >= 70)) || (GetShapeshiftForm() == FORM_FLIGHT) || (GetShapeshiftForm() == FORM_FLIGHT_EPIC)))
+                    {
+                        if((GetBotRace() == RACE_NIGHTELF) && (m_bot->GetDisplayId() != 21243))
+                            m_bot->SetDisplayId(21243);
+                        if((GetBotRace() == RACE_TAUREN) && (m_bot->GetDisplayId() != 21244))
+                            m_bot->SetDisplayId(21244);
+                        m_bot->Unmount();
+                        SetBotForm(m_bot->GetDisplayId());
+                        SetBotMustWaitForSpell1(3000);
+                    }
+                }
+                else if((GetBotMustWaitForSpell1() == 0) && (m_bot->IsInWater()) && (!isInFlight()))
+                {
+                    //Removed this because it turns into a seal in Booty Bay
+                    //seal form
+/*
+                    if((GetBotRace() == RACE_NIGHTELF) && (m_bot->GetDisplayId() != 2428))
+                        m_bot->SetDisplayId(2428);
+                    if((GetBotRace() == RACE_TAUREN) && (m_bot->GetDisplayId() != 2428))
+                        m_bot->SetDisplayId(2428);
+                    SetBotForm(m_bot->GetDisplayId());
+                    SetBotMustWaitForSpell1(3000);
+*/
+                }
+                else if((GetBotMustWaitForSpell1() == 0) && (m_bot->isInCombat()) && (!m_bot->isInFlight()))
+                {
+                    //combat form is now handled in AI
+                }
+                else if((GetBotMustWaitForSpell1() == 0) && (((IsMounted()) && (m_bot->getLevel() < 60)) || (GetShapeshiftForm() == FORM_TRAVEL)) && (!m_bot->isInFlight()))
+                {
+                    //travel form
+                    if((GetBotRace() == RACE_NIGHTELF) && (m_bot->GetDisplayId() != 632))
+                        m_bot->SetDisplayId(632);
+                    if((GetBotRace() == RACE_TAUREN) && (m_bot->GetDisplayId() != 632))
+                        m_bot->SetDisplayId(632);
+                    SetBotForm(m_bot->GetDisplayId());
+                    SetBotMustWaitForSpell1(3000);
+                }
+                else if((GetBotMustWaitForSpell1() == 0) && (GetShapeshiftForm() == FORM_CAT) && (!m_bot->isInFlight()))
+                {
+                    //cat form
+                    if((GetBotRace() == RACE_NIGHTELF) && (m_bot->GetDisplayId() != 892))
+                        m_bot->SetDisplayId(892);
+                    if((GetBotRace() == RACE_TAUREN) && (m_bot->GetDisplayId() != 8571))
+                        m_bot->SetDisplayId(8571);
+                    SetBotForm(m_bot->GetDisplayId());
+                    //SetBotMustWaitForSpell1(3000);
+                }
+                else if((GetBotMustWaitForSpell1() == 0) && (GetShapeshiftForm() == FORM_BEAR) && (!m_bot->isInFlight()))
+                {
+                    //bear form
+                    if((GetBotRace() == RACE_NIGHTELF) && (m_bot->GetDisplayId() != 2281)) m_bot->SetDisplayId(2281);
+                    if((GetBotRace() == RACE_TAUREN) && (m_bot->GetDisplayId() != 2289)) m_bot->SetDisplayId(2289);
+                    SetBotForm(m_bot->GetDisplayId());
+                    //SetBotMustWaitForSpell1(3000);
+                }
+
+                if(m_old_bot_form != GetBotForm())
+                {
+                    //change stats based on forms
+                    m_bot->SetSpeed(MOVE_SWIM, cinfo->speed_run, true); m_bot->SetSpeed(MOVE_RUN, cinfo->speed_run, true);
+                    if(GetBotForm() == 2428)
+                        m_bot->SetSpeed(MOVE_SWIM, cinfo->speed_run * 1.50f, true);
+                    else if(GetBotForm() == 632) //travel form
+                    {
+                        //m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_WALK) , true);
+                        m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_RUN) - 0.1f, true);
+                    }
+
+                }
+
+                //RESET FORMS
+                if((!m_bot->isInFlight()) && (!m_bot->IsInWater())  &&  (!m_bot->isInCombat())  && (!IsMounted()) && (GetShapeshiftForm() != FORM_TRAVEL) && (GetShapeshiftForm() != FORM_CAT))
+                {
+                    //don't reset if bear or cat because it costs too much mana
+                    if(m_bot->HasAura(9634) ||
+                        m_bot->HasAura(768) ||
+                        m_bot->HasAura(16591))
+                        return;
+
+                    if((GetBotRace() == 4) && (m_bot->GetDisplayId() != cinfo->Modelid1))
+                        m_bot->SetDisplayId(cinfo->Modelid1);
+                    if((GetBotRace() == 6) && (m_bot->GetDisplayId() != cinfo->Modelid3))
+                        m_bot->SetDisplayId(cinfo->Modelid3);
+                    m_bot->SetSpeed(MOVE_SWIM, cinfo->speed_run, true);
+                    m_bot->SetSpeed(MOVE_RUN, cinfo->speed_run, true);
+                    SetBotForm(m_bot->GetDisplayId());
+                }
+
+                //SPECIAL SPELL FOR DRUID
+                SetBotForm(m_bot->GetDisplayId());
+                break;
+            }
+
+        }//END SWITCH
+
+        if (!m_bot->isInCombat() &&
+            m_bot->GetCharmInfo()->GetCommandState() != COMMAND_STAY &&
+            GetDistance(m_bot) > 60 &&
+            !IsBeingTeleported())
+        {
+            m_bot->Relocate(this);
+            SetBotCommandState(COMMAND_FOLLOW);
+        }
+
+        if (getStandState() == UNIT_STAND_STATE_SIT)
+        {
+            m_bot->SetStandState(UNIT_STAND_STATE_SIT);
+        }
+        else
+        {
+            m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        }
+    }
+    else if(GetBotMustBeCreated() && isAlive())
+    {
+        CreateBot(m_bot_entry_must_be_created, m_bot_race_must_be_created, m_bot_class_must_be_created);
+    }
+
+    if(GetBotMustWaitForSpell1() > 0)
+        SetBotMustWaitForSpell1(GetBotMustWaitForSpell1() - refreshDelay > 0 ? refreshDelay : 10);
+
+    if(GetBotMustWaitForSpell2() > 0)
+        SetBotMustWaitForSpell2(GetBotMustWaitForSpell2() - refreshDelay > 0 ? refreshDelay : 10);
+
+    if(GetBotMustWaitForSpell3() > 0)
+        SetBotMustWaitForSpell3(GetBotMustWaitForSpell3() - refreshDelay > 0 ? refreshDelay : 10);
+
+    m_botTimer = refreshDelay;
+
+} //end Player::RefreshBot
+
+void Player::RemoveBot()
+{
+    if(m_botHasPet && m_botsPet != NULL)
+    {
+        m_botsPet->SetCharmerGUID(0);
+        m_botsPet->CombatStop();
+        m_botsPet->DeleteFromDB();
+        m_botsPet->CleanupsBeforeDelete();
+        m_botsPet->AddObjectToRemoveList();
+    }
+    m_botsPet = NULL;
+    m_botHasPet = false;
+
+    m_bot->CombatStop();
+    m_bot->DeleteFromDB();
+    m_bot->CleanupsBeforeDelete();
+    m_bot->SetIAmABot(false); //this HAS to come after CleanupsBeforeDelete
+    m_bot->AddObjectToRemoveList();
+
+    m_bot = NULL; m_bot_class = 0; m_bot_race = 0; m_bot_form = 0;
+    m_bot_must_wait_for_spell_1 = 0; m_bot_must_wait_for_spell_2 = 0;
+    m_bot_must_wait_for_spell_3 = 0; m_bot_must_be_created = false;
+
+    if(m_bot_ai)
+    {
+        //delete m_bot_ai;
+        m_bot_ai = NULL;
+    }
+    m_bot_must_die = false;
+
 
-            // stop spellcasting
-            // not attempt interrupt teleportation spell at caster teleport
-            if (!(options & TELE_TO_SPELL))
-                if (IsNonMeleeSpellCasted(true))
-                    InterruptNonMeleeSpells(true);
+} //end RemoveBot
 
-            //remove auras before removing from map...
-            RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_CHANGE_MAP | AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING);
 
-            if (!GetSession()->PlayerLogout())
-            {
-                // send transfer packets
-                WorldPacket data(SMSG_TRANSFER_PENDING, (4+4+4));
-                data << uint32(mapid);
-                if (m_transport)
-                {
-                    data << m_transport->GetEntry() << GetMapId();
-                }
-                GetSession()->SendPacket(&data);
+void Player::CreateBot(uint32 botentry, uint8 botrace, uint8 botclass)
+{
+    if(IsBeingTeleported()) return; //being teleported so don't create bot yet
 
-                data.Initialize(SMSG_NEW_WORLD, (20));
-                if (m_transport)
-                    data << (uint32)mapid << m_movementInfo.t_pos.PositionXYZOStream();
-                else
-                    data << (uint32)mapid << (float)x << (float)y << (float)z << (float)orientation;
+    if (this->isInCombat() || this->isDead()) return; // don't create while fighting or dead
 
-                GetSession()->SendPacket(&data);
-                SendSavedInstances();
-            }
+    if (m_bot != NULL) {
+        m_bot->SetHealth(m_bot->GetMaxHealth());
+        m_bot->setDeathState(ALIVE);
+        return;
+    }
 
-            // remove from old map now
-            if (oldmap)
-                oldmap->Remove(this, false);
+    Creature *newbot = SummonCreature(botentry, GetPositionX()-2, GetPositionY()-2, GetPositionZ(), GetOrientation(), TEMPSUMMON_MANUAL_DESPAWN, 0);
 
-            // new final coordinates
-            float final_x = x;
-            float final_y = y;
-            float final_z = z;
-            float final_o = orientation;
+    SetBot(newbot);
+    SetBotClass(botclass);
+    SetBotRace(botrace);
 
-            if (m_transport)
-            {
-                final_x += m_movementInfo.t_pos.GetPositionX();
-                final_y += m_movementInfo.t_pos.GetPositionY();
-                final_z += m_movementInfo.t_pos.GetPositionZ();
-                final_o += m_movementInfo.t_pos.GetOrientation();
-            }
+    newbot->SetIAmABot(true);
+    newbot->SetCharmerGUID(GetGUID());
+    newbot->CombatStop();
+    newbot->DeleteThreatList();
+    newbot->AIM_Initialize();
 
-            m_teleport_dest = WorldLocation(mapid, final_x, final_y, final_z, final_o);
-            SetFallInformation(0, final_z);
-            // if the player is saved before worldportack (at logout for example)
-            // this will be used instead of the current location in SaveToDB
+    CharmInfo *charmInfonewbot = newbot->InitCharmInfo();
+    newbot->setFaction(getFaction());
+    if(botclass == CLASS_PRIEST || botclass == CLASS_MAGE || botclass == CLASS_WARLOCK)
+        newbot->SetReactState(REACT_PASSIVE); //casters shouldn't melee
+    else
+        newbot->SetReactState(REACT_DEFENSIVE);
+    //charmInfonewbot->SetCommandState(COMMAND_FOLLOW);
+    SetBotCommandState(COMMAND_FOLLOW);;
 
-            // move packet sent by client always after far teleport
-            // code for finish transfer to new map called in WorldSession::HandleMoveWorldportAckOpcode at client packet
-            SetSemaphoreTeleportFar(true);
+    //sLog->outError("Player::CreateBot: %s", newbot->GetName());
+    //sLog->outError("\thp = %d", newbot->GetMaxHealth());
+    //sLog->outError("\tmana = %d", newbot->GetMaxPower(POWER_MANA));
+    //sLog->outError("\tlevel = %d", newbot->getLevel());
+    //sLog->outError("\tentry = %d", botentry);
+    //sLog->outError("\trace = %d", botrace);
+    //sLog->outError("\tclass = %d", botclass);
+
+    //If the player have a group, it's possible to add the bot.
+    if(GetGroup())
+    {
+        Group *m_group = GetGroup();
+        if(!m_group->IsFull()) m_group->AddMember(newbot->GetGUID(), newbot->GetName());
+        else {
+            //group is full so can't add bot
+            //(m_bot->AI())->MonsterSay("Group is full.", LANG_UNIVERSAL, NULL);
+            SetBotMustDie();
         }
-        else
-            return false;
     }
-    return true;
-}
+    else
+    {
+        Group *m_group = new Group;
+        if(!m_group->Create(GetGUID(), GetName()))
+        {
+            delete m_group;
+            return;
+        }
+        sObjectMgr->AddGroup(m_group);
 
-bool Player::TeleportToBGEntryPoint()
-{
-    ScheduleDelayedOperation(DELAYED_BG_MOUNT_RESTORE);
-    ScheduleDelayedOperation(DELAYED_BG_TAXI_RESTORE);
-    return TeleportTo(m_bgData.joinPos);
-}
+        if(!m_group->IsFull()) m_group->AddMember(newbot->GetGUID(), newbot->GetName());
+    }
+    m_bot_must_die = false;
 
-void Player::ProcessDelayedOperations()
-{
-    if (m_DelayedOperations == 0)
+    //if not in group, go away
+    Group::MemberSlotList const &a =GetGroup()->GetMemberSlots();
+    if(GetGroup() == NULL || a.empty())
+    {
+        //m_creature->MonsterSay("Not in group.", LANG_UNIVERSAL, NULL);
+        SetBotMustDie();
         return;
+    }
 
-    if (m_DelayedOperations & DELAYED_RESURRECT_PLAYER)
-    {
-        ResurrectPlayer(0.0f, false);
+    m_bot_entry = m_bot->GetEntry();
+    newbotclass = GetBotClass();
+    newbotrace = GetBotRace();
 
-        if (GetMaxHealth() > m_resurrectHealth)
-            SetHealth(m_resurrectHealth);
-        else
-            SetFullHealth();
+    //Set the race. This is so when the druid shapeshifts
+    //it wont get an error about not finding correct race
+    GetBot()->SetByteValue(UNIT_FIELD_BYTES_0, 0, newbotrace);
 
-        if (GetMaxPower(POWER_MANA) > m_resurrectMana)
-            SetPower(POWER_MANA, m_resurrectMana);
-        else
-            SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+    if(GetBotAI()) GetBotAI()->JustRespawned();
 
-        SetPower(POWER_RAGE, 0);
-        SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
+    SetBotMustWaitForSpell1(0);
+    SetBotMustWaitForSpell2(0);
+    SetBotMustWaitForSpell3(0); //eating and drinking
 
-        SpawnCorpseBones();
+   // m_bot->SelectLevel(sObjectMgr->GetCreatureTemplate(m_bot->GetEntry()));
+   // m_bot->SelectLevel(sObjectMgr->GetCreatureTemplate(m_bot->GetEntry()));
+    CreatureBaseStats const* stats = sObjectMgr->GetCreatureBaseStats(getLevel(), newbot->GetCreatureInfo()->unit_class);
+    newbot->SetArmor(stats->BaseArmor);
+    newbot->SetMaxHealth((getLevel() * newbot->GetMaxHealth()) / newbot->getLevel()); //set health based of level
+    newbot->SetMaxHealth(newbot->GetMaxHealth() - newbot->GetMaxHealth() * urand(1, 25) / 100); // insert some randomness
+    newbot->SetHealth(newbot->GetMaxHealth());
+
+    if(botclass != CLASS_WARRIOR && botclass != CLASS_ROGUE && botclass != CLASS_DEATH_KNIGHT)
+    {
+        newbot->SetPower(POWER_MANA, m_bot->GetMaxPower(POWER_MANA));
+        newbot->SetMaxPower(POWER_MANA, (getLevel() * m_bot->GetMaxPower(POWER_MANA)) / m_bot->getLevel()); //set mana based of level
+        newbot->SetMaxPower(POWER_MANA, m_bot->GetMaxPower(POWER_MANA) - newbot->GetMaxPower(POWER_MANA) * urand(1, 20) / 100); // insert some randomness
     }
 
-    if (m_DelayedOperations & DELAYED_SAVE_PLAYER)
-        SaveToDB();
+    //newbot->SetFaction(getFaction());
+    newbot->setFaction(getFaction());
 
-    if (m_DelayedOperations & DELAYED_SPELL_CAST_DESERTER)
-        CastSpell(this, 26013, true);               // Deserter
+    //remove any entries, just in case it didnt get cleaned up earlier
+	CharacterDatabase.PExecute("DELETE FROM character_npcbot WHERE owner = '%u'", this->GetGUIDLow());
 
-    if (m_DelayedOperations & DELAYED_BG_MOUNT_RESTORE)
+    //add the new bot
+    CharacterDatabase.PExecute("INSERT INTO character_npcbot (owner,entry,race,class) VALUES ('%u','%u','%u','%u')", this->GetGUIDLow(), botentry, botrace, botclass);
+
+    m_botsPet = NULL;
+    m_botHasPet = false;
+
+    newbot->SetLevel(getLevel());
+    newbot->AI()->Reset();
+
+    m_SaveOrgLocation = sConfig->GetIntDefault("Bot.SaveOrgLocation", 0);
+
+} //end Player::CreateBot
+
+Creature *Player::GetBotsPet(uint32 entry)
+{
+    Creature *pet = this->SummonCreature(entry, GetPositionX() + 10, GetPositionY() + 10, GetPositionZ(), 0, TEMPSUMMON_DEAD_DESPAWN, 0);
+
+    QueryResult result;
+
+    result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi FROM pet_levelstats WHERE creature_entry = 1860 AND level=%u", this->getLevel());
+
+    if(result)
     {
-        if (m_bgData.mountSpell)
-        {
-            CastSpell(this, m_bgData.mountSpell, true);
-            m_bgData.mountSpell = 0;
-        }
+        Field *fields = result->Fetch();
+        uint32 hp = fields[0].GetUInt32();
+        uint32 mana = fields[1].GetUInt32();
+        uint32 armor = fields[2].GetUInt32();
+        uint32 str = fields[3].GetUInt32();
+        uint32 agi = fields[4].GetUInt32();
+        //sLog->outError("hp = %u", hp);
+        //sLog->outError("mana = %u", mana);
+        //sLog->outError("str = %u", str);
+        //sLog->outError("agi = %u", agi);
+
+        pet->SetMaxHealth(hp);
+        pet->SetMaxPower(POWER_MANA, mana);
+        pet->SetArmor(armor);
+        pet->SetStat(STAT_STRENGTH, str);
+        pet->SetStat(STAT_AGILITY, agi);
+
+        //delete result;
     }
+    pet->SetLevel(getLevel());
 
-    if (m_DelayedOperations & DELAYED_BG_TAXI_RESTORE)
-    {
-        if (m_bgData.HasTaxiPath())
-        {
-            m_taxi.AddTaxiDestination(m_bgData.taxiPath[0]);
-            m_taxi.AddTaxiDestination(m_bgData.taxiPath[1]);
-            m_bgData.ClearTaxiPath();
+    m_botHasPet = true;
+    m_botsPet = pet;
 
-            ContinueTaxiFlight();
-        }
+    return pet;
+} //end GetBotsPet
+
+void Player::SetBotsPetDied()
+{
+    if(m_botHasPet && m_botsPet != NULL)
+    {
+        m_botsPet->SetCharmerGUID(0);
+        m_botsPet->CombatStop();
+        m_botsPet->DeleteFromDB();
+        m_botsPet->CleanupsBeforeDelete();
+        m_botsPet->AddObjectToRemoveList();
     }
 
-    //we have executed ALL delayed ops, so clear the flag
-    m_DelayedOperations = 0;
+    m_botsPet = NULL;
+    m_botHasPet = false;
 }
 
-void Player::AddToWorld()
+//
+//This is called from script_bot_giver.cpp
+//
+uint8 Player::GetMaxPlayerBot()
 {
-    ///- Do not add/remove the player from the object storage
-    ///- It will crash when updating the ObjectAccessor
-    ///- The player should only be added when logging in
-    Unit::AddToWorld();
+    //load config variables
+    if(m_MaxPlayerbots > 9) m_MaxPlayerbots = sConfig->GetIntDefault("Bot.MaxPlayerbots", 9);
+
+    return m_MaxPlayerbots;
 
-    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
-        if (m_items[i])
-            m_items[i]->AddToWorld();
 }
 
-void Player::RemoveFromWorld()
+//
+//This is called from script_bot_giver.cpp
+//
+void Player::CreatePlayerBot(std::string name)
 {
-    // cleanup
-    if (IsInWorld())
-    {
-        ///- Release charmed creatures, unsummon totems and remove pets/guardians
-        StopCastingCharm();
-        StopCastingBindSight();
-        UnsummonPetTemporaryIfAny();
-        sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
-    }
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(name.c_str());
+    if(m_session->GetPlayerBot(guid) != NULL) return;
+    m_session->AddPlayerBot(guid);
+}
 
-    ///- Do not add/remove the player from the object storage
-    ///- It will crash when updating the ObjectAccessor
-    ///- The player should only be removed when logging out
-    Unit::RemoveFromWorld();
+//
+//This is called from script_bot_giver.cpp
+//
+std::list<std::string> *Player::GetCharacterList()
+{
+    std::string plName;
+    QueryResult results;
 
-    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
+    results = CharacterDatabase.PQuery("SELECT name FROM characters WHERE account='%u' AND online=0", m_session->GetAccountId());
+
+    if(!results) return NULL;
+
+    plName = (*results)[0].GetString();
+
+    std::list<std::string> *names = new std::list<std::string>;
+    do {
+        Field *fields = results->Fetch();
+        plName = fields[0].GetString();
+        if(plName.compare(GetName()) == 0) continue;
+        names->insert(names->end(), fields[0].GetString());
+    } while(results->NextRow());
+    return names;
+} //end GetCharacterList
+
+//Playerbot mod:
+void Player::SetPlayerbotAI(PlayerbotAI *ai)
+{
+    if(ai == NULL)
     {
-        if (m_items[i])
-            m_items[i]->RemoveFromWorld();
+        sLog->outError("Tried to assign playerbot AI to NULL; this is not supported!");
+        return;
+    }
+    if(GetPlayerbotAI() != NULL)
+    {
+        sLog->outError("Tried to reassign playerbot AI; this is not yet supported!");
+        return;
+    }
+    //assigning bot AI to normal players is not currently supported
+    if(!IsPlayerbot())
+    {
+        sLog->outError("Tried to set playerbot AI for a player that was not a bot.");
+        return;
     }
+    m_playerbotAI = ai;
 
-    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
-        iter->second->RemoveFromWorld();
+    m_SaveOrgLocation = sConfig->GetIntDefault("Bot.SaveOrgLocation", 0);
+}
 
-    if (m_uint32Values)
+
+
+//This is called from script_bot_giver.cpp
+//
+void Player::CreateNPCBot(uint8 bot_class)
+{
+    uint32 entry = 0;
+    uint32 bot_race = 0;
+
+    if(!this->HaveBot())
     {
-        if (WorldObject *viewpoint = GetViewpoint())
+        QueryResult result;
+
+        if(this->GetTeam() == ALLIANCE)
         {
-            sLog->outCrash("Player %s has viewpoint %u %u when removed from world", GetName(), viewpoint->GetEntry(), viewpoint->GetTypeId());
-            SetViewpoint(viewpoint, false);
+            if(bot_class == CLASS_ROGUE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='rogue_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+            else if(bot_class == CLASS_PRIEST) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='priest_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+            else if(bot_class == CLASS_DRUID) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='druid_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+            else if(bot_class == CLASS_SHAMAN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='shaman_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+            else if(bot_class == CLASS_MAGE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='mage_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+            else if(bot_class == CLASS_WARLOCK) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warlock_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+            else if(bot_class == CLASS_WARRIOR) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warrior_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+            else if(bot_class == CLASS_PALADIN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='paladin_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+            else if(bot_class == CLASS_HUNTER) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='hunter_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+            else result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='script_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        }
+        else if(this->GetTeam() == HORDE)
+        {
+            if(bot_class == CLASS_ROGUE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='rogue_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+            else if(bot_class == CLASS_PRIEST) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='priest_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+            else if(bot_class == CLASS_SHAMAN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='shaman_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+            else if(bot_class == CLASS_MAGE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='mage_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+            else if(bot_class == CLASS_WARLOCK) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warlock_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+            else if(bot_class == CLASS_WARRIOR) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warrior_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+            else if(bot_class == CLASS_DRUID) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='druid_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+            else if(bot_class == CLASS_PALADIN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='paladin_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+            else if(bot_class == CLASS_HUNTER) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='hunter_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+            else result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='script_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        }
+
+        //randomly select one of NPCs
+        if(result)
+        {
+            uint64 m_rand = urand(1, result->GetRowCount());
+            uint64 tmp_rand = 0;
+            do
+            {
+                Field *fields = result->Fetch();
+                entry = fields[0].GetUInt32();
+                bot_race = fields[1].GetUInt32();
+                ++tmp_rand;
+                if(tmp_rand == m_rand)
+                    break;
+            } while(result->NextRow());
+           // delete result;
         }
     }
-}
+
+    this->SetBotMustBeCreated(entry, bot_race, bot_class);
+} //end CreateNPCBot
+
 
 void Player::RegenerateAll()
 {
@@ -2470,7 +3796,7 @@ Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
                     return NULL;
 
     // not too far
-    if (!unit->IsWithinDistInMap(this,INTERACTION_DISTANCE))
+    if (!unit->IsWithinDistInMap(this,INTERACTION_DISTANCE) && !IsPlayerbot())
         return NULL;
 
     return unit;
@@ -2658,6 +3984,31 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
+		Player *_player = sObjectMgr->GetPlayer(guid);
+
+        if(_player!=NULL) {
+            WorldSession *session= _player->GetSession();
+            // Playerbot mod: if you remove yourself from a group, log out all playerbots
+
+            //save the map of playerbots first because if the map gets altered when
+            //a playerbot logs out which will corrupt the for loop
+            PlayerBotMap m_playerBots;
+            for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+            {
+                Player *bot = itr->second;
+                (m_playerBots)[itr->first] = bot;
+            }
+            for(PlayerBotMap::const_iterator itr2 = m_playerBots.begin(); itr2 != m_playerBots.end(); ++itr2)
+           {
+                Player *botPlayer = itr2->second;
+                if (!botPlayer) continue;
+
+                session->LogoutPlayerBot(botPlayer->GetGUID(),true);
+            }
+
+			if (!sObjectMgr->GetPlayer(guid)->GetGroup() || group->GetMembersCount()==0) return;
+        }
+
         if (group->RemoveMember(guid, method, kicker, reason) <= 1)
         {
             // group->Disband(); already disbanded in RemoveMember
@@ -6607,7 +7958,8 @@ void Player::CheckAreaExploreAndOutdoor()
                 {
                     XP = uint32(sObjectMgr->GetBaseXP(p->area_level)*sWorld->getRate(RATE_XP_EXPLORE));
                 }
-
+                if(GetSession()->IsPremium())
+                XP *= sWorld->getRate(RATE_XP_EXPLORE_PREMIUM);
                 GiveXP(XP, NULL);
                 SendExplorationExperience(area,XP);
             }
@@ -6888,6 +8240,10 @@ bool Player::RewardHonor(Unit *uVictim, uint32 groupsize, int32 honor, bool pvpt
         {
             Player *pVictim = uVictim->ToPlayer();
 
+            if(pVictim->IsPlayerbot() && (!sWorld->getBoolConfig(CONFIG_HONOR_FROM_PLAYERBOTS) ||
+                pVictim->GetPlayerbotAI()->GetClassAI()->GetMaster() == this)) //Killing your own playerbots is not honorable!
+                return false;
+
             if (GetTeam() == pVictim->GetTeam() && !sWorld->IsFFAPvPRealm())
                 return false;
 
@@ -8821,6 +10177,13 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
                                                             // 8 Arena season id
     data << uint32(0xF3D) << uint32(sWorld->getIntConfig(CONFIG_ARENA_SEASON_ID));
 
+    // May be send timer to start Wintergrasp
+    if(sWorld->GetWintergrapsState()==4354)
+        data << uint32(0x1102) << sWorld->GetWintergrapsTimer();
+    else
+        data << uint32(0xEC5) << sWorld->GetWintergrapsTimer();
+    // ---
+
     if (mapid == 530)                                       // Outland
     {
         data << uint32(0x9bf) << uint32(0x0);               // 7
@@ -13302,7 +14665,6 @@ void Player::ApplyEnchantment(Item *item, EnchantmentSlot slot, bool apply, bool
             uint32 enchant_display_type = pEnchant->type[s];
             uint32 enchant_amount = pEnchant->amount[s];
             uint32 enchant_spell_id = pEnchant->spellid[s];
-
             switch(enchant_display_type)
             {
                 case ITEM_ENCHANTMENT_TYPE_NONE:
@@ -13926,7 +15288,6 @@ void Player::OnGossipSelect(WorldObject* pSource, uint32 gossipListId, uint32 me
             return;
         }
     }
-
     GossipMenuItemData pMenuData = gossipmenu.GetItemData(gossipListId);
 
     switch(gossipOptionId)
@@ -14675,6 +16036,9 @@ void Player::RewardQuest(Quest const *pQuest, uint32 reward, Object* questGiver,
     for (Unit::AuraEffectList::const_iterator i = ModXPPctAuras.begin(); i != ModXPPctAuras.end(); ++i)
         AddPctN(XP, (*i)->GetAmount());
 
+    if (GetSession()->IsPremium())
+        XP *= sWorld->getRate(RATE_XP_QUEST_PREMIUM);
+
     int32 moneyRew = 0;
     if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
         GiveXP(XP, NULL);
@@ -15557,6 +16921,9 @@ void Player::KilledMonsterCredit(uint32 entry, uint64 guid)
             }
         }
     }
+
+    //Playerbot mod
+    if(m_playerbotAI != NULL) m_playerbotAI->KilledMonster(entry, guid);
 }
 
 void Player::CastedCreatureOrGO(uint32 entry, uint64 guid, uint32 spell_id)
@@ -15682,6 +17049,7 @@ void Player::TalkedToCreature(uint32 entry, uint64 guid)
                             m_QuestStatusSave[questid] = true;
 
                             SendQuestUpdateAddCreatureOrGo(qInfo, guid, j, curTalkCount, addTalkCount);
+                            if (IsPlayerbot()) this->GetPlayerbotAI()->TellMaster("Talked to quest guy.");
                         }
                         if (CanCompleteQuest(questid))
                             CompleteQuest(questid);
@@ -16802,10 +18170,77 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
     m_achievementMgr.CheckAllAchievementCriteria();
 
     _LoadEquipmentSets(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS));
+	// Loads the jail datas and if jailed it corrects the position to the corresponding jail
+    _LoadJail();
 
     return true;
 }
 
+void Player::_LoadJail(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GetGUIDLow());
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+        m_jail_isjailed = false;
+        return;
+    }
+
+		Field *fields = result->Fetch();
+		m_jail_warning = true;
+		m_jail_isjailed = true;
+		m_jail_guid = fields[0].GetUInt32();
+		m_jail_char = fields[1].GetString();
+		m_jail_release = fields[2].GetUInt32();
+		m_jail_amnestietime = fields[3].GetUInt32();
+		m_jail_reason = fields[4].GetString();
+		m_jail_times = fields[5].GetUInt32();
+		m_jail_gmacc = fields[6].GetUInt32();
+		m_jail_gmchar = fields[7].GetString();
+		m_jail_lasttime = fields[8].GetString();
+		m_jail_duration = fields[9].GetUInt32();
+
+    if (m_jail_release == 0)
+    {
+        m_jail_isjailed = false;
+        return;
+    }
+
+    time_t localtime;
+    localtime = time(NULL);
+
+    if (m_jail_release <= localtime)
+    {
+        m_jail_isjailed = false;
+        m_jail_release = 0;
+
+        _SaveJail();
+
+        sWorld->SendWorldText(LANG_JAIL_CHAR_FREE, GetName());
+
+        CastSpell(this,8690,false);
+        return;
+    }
+
+    if (m_jail_isjailed)
+    {
+        if (m_team == ALLIANCE)
+        {
+            TeleportTo(sObjectMgr->m_jailconf_ally_m, sObjectMgr->m_jailconf_ally_x,
+                sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z, sObjectMgr->m_jailconf_ally_o);
+        }
+        else
+        {
+            TeleportTo(sObjectMgr->m_jailconf_horde_m, sObjectMgr->m_jailconf_horde_x,
+                sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z, sObjectMgr->m_jailconf_horde_o);
+        }
+         
+        sWorld->SendWorldText(LANG_JAIL_CHAR_TELE, GetName());
+    }
+}
+
 bool Player::isAllowedToLoot(const Creature* creature)
 {
     if (!creature->isDead() || !creature->IsDamageEnoughForLootingAndReward())
@@ -17982,11 +19417,23 @@ bool Player::_LoadHomeBind(PreparedQueryResult result)
 /***                   SAVE SYSTEM                     ***/
 /*********************************************************/
 
+// Saves the jail datas (added by WarHead) edited by LordPsyan.
+void Player::_SaveJail(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT `guid` FROM `jail` WHERE `guid`='%u' LIMIT 1", m_jail_guid);
+    if (!result) CharacterDatabase.PExecute("INSERT INTO `jail` VALUES ('%u','%s','%u', '%u','%s','%u','%u','%s',CURRENT_TIMESTAMP,'%u')", m_jail_guid, m_jail_char.c_str(), m_jail_release, m_jail_amnestietime, m_jail_reason.c_str(), m_jail_times, m_jail_gmacc, m_jail_gmchar.c_str(), m_jail_duration);
+    else CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u', `amnestietime`='%u',`reason`='%s',`times`='%u',`gmacc`='%u',`gmchar`='%s',`duration`='%u' WHERE `guid`='%u' LIMIT 1", m_jail_release, m_jail_amnestietime, m_jail_reason.c_str(), m_jail_times, m_jail_gmacc, m_jail_gmchar.c_str(), m_jail_duration, m_jail_guid);
+    CharacterDatabase.CommitTransaction(trans);
+}
+
 void Player::SaveToDB()
 {
+	// Jail: Prevent saving of jailed players
+    if (m_jail_isjailed) return;
+
     // delay auto save at any saves (manual, in code, or autosave)
     m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);
-
     //lets allow only players in world to be saved
     if (IsBeingTeleportedFar())
     {
@@ -18027,6 +19474,18 @@ void Player::SaveToDB()
 
     if (!IsBeingTeleported())
     {
+        if (IsPlayerbot() && m_SaveOrgLocation == 1)
+        {
+            ss << m_playerbotAI->GetStartMapID() << ", "
+            << (uint32)m_playerbotAI->GetStartInstanceID() << ", "
+            << (uint32)m_playerbotAI->GetStartDifficulty() << ", "
+            << finiteAlways(m_playerbotAI->GetStartX()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartY()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartZ()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartO()) << ", ";
+        }
+        else
+        {
         ss << GetMapId() << ", "
         << (uint32)GetInstanceId() << ", "
         << uint32(uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4) << ", "
@@ -18034,9 +19493,22 @@ void Player::SaveToDB()
         << finiteAlways(GetPositionY()) << ", "
         << finiteAlways(GetPositionZ()) << ", "
         << finiteAlways(GetOrientation()) << ", ";
+        }
     }
     else
     {
+        if (IsPlayerbot() && m_SaveOrgLocation == 1)
+        {
+            ss << m_playerbotAI->GetStartMapID() << ", "
+            << (uint32)m_playerbotAI->GetStartInstanceID() << ", "
+            << (uint32)m_playerbotAI->GetStartDifficulty() << ", "
+            << finiteAlways(m_playerbotAI->GetStartX()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartY()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartZ()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartO()) << ", ";
+        }
+        else
+        {
         ss << GetTeleportDest().GetMapId() << ", "
         << (uint32)0 << ", "
         << uint32(uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4) << ", "
@@ -18044,6 +19516,7 @@ void Player::SaveToDB()
         << finiteAlways(GetTeleportDest().GetPositionY()) << ", "
         << finiteAlways(GetTeleportDest().GetPositionZ()) << ", "
         << finiteAlways(GetTeleportDest().GetOrientation()) << ", ";
+        }
     }
 
     ss << m_taxi << ", ";                                   // string with TaxiMaskSize numbers
@@ -19036,7 +20509,7 @@ void Player::StopCastingCharm()
     }
 }
 
-inline void Player::BuildPlayerChat(WorldPacket *data, uint8 msgtype, const std::string& text, uint32 language) const
+void Player::BuildPlayerChat(WorldPacket *data, uint8 msgtype, const std::string& text, uint32 language) const
 {
     *data << uint8(msgtype);
     *data << uint32(language);
@@ -23116,6 +24589,7 @@ void Player::_LoadSkills(PreparedQueryResult result)
             {
                 sLog->outError("Character %u has skill %u with value 0. Will be deleted.", GetGUIDLow(), skill);
                 CharacterDatabase.PExecute("DELETE FROM character_skills WHERE guid = '%u' AND skill = '%u' ", GetGUIDLow(), skill);
+				CharacterDatabase.PExecute("DELETE FROM `jail` WHERE `guid` = '%u'",GetGUIDLow());
                 continue;
             }
 
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index a4f5b42..f115a87 100755
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -52,6 +52,9 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+//Playerbot mod
+class PlayerbotAI;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -948,7 +951,6 @@ class TradeData
 
         Player* GetTrader() const { return m_trader; }
         TradeData* GetTraderData() const;
-
         Item* GetItem(TradeSlots slot) const;
         bool HasItem(uint64 item_guid) const;
         void SetItem(TradeSlots slot, Item* item);
@@ -988,6 +990,18 @@ class TradeData
         uint64     m_items[TRADE_SLOT_COUNT];               // traded itmes from m_player side including non-traded slot
 };
 
+struct AnticheatData
+{
+    uint32 lastOpcode;
+    MovementInfo lastMovementInfo;
+    bool disableACCheck;
+    uint32 disableACCheckTimer;
+    uint32 total_reports;
+    uint32 type_reports[5];
+    uint32 average;
+    uint64 creation_time;
+};
+
 class Player : public Unit, public GridObject<Player>
 {
     friend class WorldSession;
@@ -997,6 +1011,8 @@ class Player : public Unit, public GridObject<Player>
         explicit Player (WorldSession *session);
         ~Player ();
 
+        AnticheatData anticheatData;
+
         void CleanupsBeforeDelete(bool finalCleanup = true);
 
         static UpdateMask updateVisualBits;
@@ -1464,6 +1480,14 @@ class Player : public Unit, public GridObject<Player>
         void RegenerateHealth();
         void setRegenTimerCount(uint32 time) {m_regenTimerCount = time;}
         void setWeaponChangeTimer(uint32 time) {m_weaponChangeTimer = time;}
+        void RefreshBot(uint32 p_time);
+        void CreateBot(uint32 botentry, uint8 botrace, uint8 botclass);
+        void CreateNPCBot(uint8 botclass);
+        void CreatePlayerBot(std::string name);
+        uint8 GetMaxPlayerBot();
+        //bool isTradeAccepted () {return getTradeData()->IsAccepted();}
+        void GetBotLevelInfo(uint32 race, uint32 class_,uint32 level, PlayerLevelInfo* info) const;
+        std::list<std::string> *GetCharacterList();
 
         uint32 GetMoney() const { return GetUInt32Value (PLAYER_FIELD_COINAGE); }
         void ModifyMoney(int32 d);
@@ -1914,6 +1938,71 @@ class Player : public Unit, public GridObject<Player>
         bool HasSkill(uint32 skill) const;
         void learnSkillRewardedSpells(uint32 id, uint32 value);
 
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        bool HaveBot(){ if(m_bot == NULL) return false; else return true; }
+        //CreatureInfo const *GetBotInfo();
+        Player *GetObjPlayer(uint64 guid);
+        Creature *GetBot(){ return m_bot; }
+        void SetBot(Creature *bot){ m_bot = bot; }
+        CommandStates GetBotCommandState() { return m_botCommandState; }
+        void SetBotCommandState(CommandStates st)
+        {
+            m_botCommandState = st;
+            switch(st)
+            {
+                case COMMAND_STAY:
+                    //m_bot->MonsterSay("Standing still.", LANG_UNIVERSAL, NULL);
+                    m_bot->StopMoving();
+                    m_bot->GetMotionMaster()->Clear();
+                    m_bot->GetMotionMaster()->MoveIdle();
+                    m_bot->GetCharmInfo()->SetCommandState (COMMAND_STAY);
+                    break;
+                case COMMAND_FOLLOW:
+                    //m_bot->MonsterSay("Following.", LANG_UNIVERSAL, NULL);
+                    m_bot->GetMotionMaster()->MoveFollow(this, PET_FOLLOW_DIST*urand(1, 2), PET_FOLLOW_ANGLE);
+                    m_bot->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+                    m_bot->RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
+                    break;
+            }
+
+        }
+        void SetBotReactState(ReactStates st){ m_bot->SetReactState(st); }
+        void RemoveBot();
+        void SetBotAI(CreatureAI *ai){ m_bot_ai = ai; }
+        Creature *GetBotsPet (uint32 entry);
+        void SetBotsPetDied();
+        bool m_botHasPet;
+        Creature *m_botsPet;
+        CreatureAI *GetBotAI(){ return m_bot_ai; }
+        //void SetAmIABot(){m_bot_am_i = true; }
+        //bool AmIABot(){ return (m_bot_ai != NULL); }
+        uint8 GetBotClass(){ return m_bot_class; }
+        uint8 GetBotRace(){ return m_bot_race; }
+        bool GetBotMustBeCreated(){ return m_bot_must_be_created; }
+        bool GetBotMustDie(){ return m_bot_must_die; }
+        uint32 GetBotForm(){ return m_bot_form; }
+
+        void SetBotClass(uint8 botclass){ m_bot_class = botclass; }
+        void SetBotRace(uint8 botrace){ m_bot_race = botrace; }
+        void SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class)
+        {
+            m_bot_must_be_created = true;
+            m_bot_entry_must_be_created = m_entry;
+            m_bot_class_must_be_created = m_class;
+            m_bot_race_must_be_created = m_race;
+            m_bot_ai = NULL;
+        }
+        void SetBotMustDie(){ m_bot_must_die = true; }
+        void SetBotForm(uint32 form){ m_bot_form = form; }
+        void SetBotMustWaitForSpell1(uint32 wait){ m_bot_must_wait_for_spell_1 = wait; }
+        uint32 GetBotMustWaitForSpell1(){ return m_bot_must_wait_for_spell_1; }
+        void SetBotMustWaitForSpell2(uint32 wait){ m_bot_must_wait_for_spell_2 = wait; }
+        uint32 GetBotMustWaitForSpell2(){ return m_bot_must_wait_for_spell_2; }
+        void SetBotMustWaitForSpell3(uint32 wait){ m_bot_must_wait_for_spell_3 = wait; }
+        uint32 GetBotMustWaitForSpell3(){ return m_bot_must_wait_for_spell_3; }
+
         WorldLocation& GetTeleportDest() { return m_teleport_dest; }
         bool IsBeingTeleported() const { return mSemaphoreTeleport_Near || mSemaphoreTeleport_Far; }
         bool IsBeingTeleportedNear() const { return mSemaphoreTeleport_Near; }
@@ -2181,6 +2270,26 @@ class Player : public Unit, public GridObject<Player>
 
         uint32 EnvironmentalDamage(EnviromentalDamage type, uint32 damage);
 
+	    // Jail by WarHead edited by spgm
+        // ---------------
+        // Char datas...
+		bool m_jail_warning;
+		bool m_jail_amnestie;
+		bool m_jail_isjailed;           // Is this player jailed?
+		std::string m_jail_char;        // Name of jailed char
+		uint32 m_jail_guid;             // guid of the jailed char
+		uint32 m_jail_release;          // When is the player a free man/woman?
+		std::string m_jail_reason;      // Why was the char jailed?
+		uint32 m_jail_times;			// How often was the player jailed?
+		uint32 m_jail_amnestietime;
+		uint32 m_jail_gmacc;            // Used GM acc
+		std::string m_jail_gmchar;      // Used GM char
+		std::string m_jail_lasttime;    // Last jail time
+		uint32 m_jail_duration;         // Duration of the jail
+		// Load / save functions...
+		void _LoadJail(void);           // Loads the jail datas
+		void _SaveJail(void);           // Saves the jail datas
+
         /*********************************************************/
         /***               FLOOD FILTER SYSTEM                 ***/
         /*********************************************************/
@@ -2392,6 +2501,11 @@ class Player : public Unit, public GridObject<Player>
         bool HasTitle(CharTitlesEntry const* title) { return HasTitle(title->bit_index); }
         void SetTitle(CharTitlesEntry const* title, bool lost = false);
 
+        //Playerbot mod:
+        void SetPlayerbotAI(PlayerbotAI *ai);
+        PlayerbotAI *GetPlayerbotAI(){ return m_playerbotAI; }
+        bool IsPlayerbot(){ return(GetSession()->GetRemoteAddress() == "bot"); }
+
         //bool isActiveObject() const { return true; }
         bool canSeeSpellClickOn(Creature const* creature) const;
 
@@ -2655,6 +2769,35 @@ class Player : public Unit, public GridObject<Player>
 
         bool isAlwaysDetectableFor(WorldObject const* seer) const;
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+
+        Creature *m_bot;
+        uint8 m_bot_class;
+        uint8 m_bot_race;
+        uint8 m_MaxPlayerbots;
+        uint8 m_SaveOrgLocation;
+        CommandStates m_botCommandState;
+
+        //bool m_bot_am_I; //am I a bot?
+        bool m_bot_must_be_created;
+        bool m_bot_must_die;
+        uint32 m_bot_entry_must_be_created;
+        uint8 m_bot_class_must_be_created;
+        uint8 m_bot_race_must_be_created;
+        CreatureAI *m_bot_ai;
+
+        uint32 m_bot_form; //Only for Druid
+        uint32 m_bot_must_wait_for_spell_1; //in ms
+        uint32 m_bot_must_wait_for_spell_2; //in ms
+        uint32 m_bot_must_wait_for_spell_3; //in ms
+        uint32 m_botTimer;
+        uint32 m_bot_entry;
+        uint8 newbotclass;
+        uint8 newbotrace;
+        bool m_bot_died;
+
         // internal common parts for CanStore/StoreItem functions
         uint8 _CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemPrototype const *pProto, uint32& count, bool swap, Item *pSrcItem) const;
         uint8 _CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemPrototype const *pProto, uint32& count, bool merge, bool non_specialized, Item *pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
@@ -2686,6 +2829,9 @@ class Player : public Unit, public GridObject<Player>
 
         void UpdateCharmedAI();
 
+        // Playerbot mod
+        PlayerbotAI *m_playerbotAI;
+
         uint32 m_lastFallTime;
         float  m_lastFallZ;
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index b1fab1b..ed0a075 100755
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "AnticheatMgr.h"
 #include "Common.h"
 #include "CreatureAIImpl.h"
 #include "Log.h"
@@ -12002,6 +12003,9 @@ void Unit::SetVisible(bool x)
 
 void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
 {
+    if (this->ToPlayer())
+        sAnticheatMgr->DisableAnticheatDetection(this->ToPlayer());
+
     int32 main_speed_mod  = 0;
     float stack_bonus     = 1.0f;
     float non_stack_bonus = 1.0f;
@@ -15558,6 +15562,17 @@ void Unit::RemoveCharmedBy(Unit *charmer)
             case CHARM_TYPE_CONVERT:
                 break;
         }
+
+    }
+
+    if(GetTypeId() == TYPEID_UNIT && charmer->GetTypeId() == TYPEID_PLAYER)
+    {
+        if(((Creature*)this)->GetIAmABot())
+        {
+            //don't want to remove the pet action bar if a bot because the player might
+            //actually have a pet ie, hunter or warlock
+            return;
+        }
     }
 
     //a guardian should always have charminfo
@@ -15988,6 +16003,9 @@ void Unit::UpdateObjectVisibility(bool forced)
 
 void Unit::KnockbackFrom(float x, float y, float speedXY, float speedZ)
 {
+    if (this->ToPlayer())
+        sAnticheatMgr->DisableAnticheatDetection(this->ToPlayer());
+
     Player *player = NULL;
     if (GetTypeId() == TYPEID_PLAYER)
         player = (Player*)this;
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 013c8af..ea6ba00 100755
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -7064,6 +7064,121 @@ uint32 ObjectMgr::GeneratePetNumber()
     return ++m_hiPetNumber;
 }
 
+// Loads the jail conf out of the database
+void ObjectMgr::LoadJailConf(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail_conf`");
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+		sLog->outError(GetTrinityStringForDBCLocale(LANG_JAIL_CONF_ERR1));
+		sLog->outError(GetTrinityStringForDBCLocale(LANG_JAIL_CONF_ERR2));
+
+		m_jailconf_max_jails    = 3;
+		m_jailconf_max_duration = 672;
+		m_jailconf_min_reason   = 25;
+		m_jailconf_warn_player  = 1;
+		m_jailconf_amnestie     = 180;
+
+		m_jailconf_ally_x       = -8673.43;
+		m_jailconf_ally_y       = 631.795;
+		m_jailconf_ally_z       = 96.9406;
+		m_jailconf_ally_o       = 2.1785;
+		m_jailconf_ally_m       = 0;
+
+		m_jailconf_horde_x      = 2179.85;
+		m_jailconf_horde_y      = -4763.96;
+		m_jailconf_horde_z      = 54.911;
+		m_jailconf_horde_o      = 4.44216;
+		m_jailconf_horde_m      = 1;
+
+		m_jailconf_ban          = 0;
+		m_jailconf_radius       = 10;
+
+        return;
+    }
+do
+{
+    Field *fields = result->Fetch();
+    m_jail_obt = fields[1].GetString();
+	if (m_jail_obt == "m_jailconf_max_jails")
+	{
+      m_jailconf_max_jails    = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_max_duration")
+	{
+	  m_jailconf_max_duration = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_min_reason")
+	{
+      m_jailconf_min_reason   = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_warn_player")
+	{
+      m_jailconf_warn_player  = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_amnestie")
+	{
+	  m_jailconf_amnestie     = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_ally_x")
+	{
+      m_jailconf_ally_x       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_y")
+	{
+      m_jailconf_ally_y       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_z")
+	{
+      m_jailconf_ally_z       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_o")
+	{
+      m_jailconf_ally_o       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_m")
+	{
+      m_jailconf_ally_m       = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_horde_x")
+	{
+      m_jailconf_horde_x      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_y")
+	{
+      m_jailconf_horde_y      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_z")
+	{
+      m_jailconf_horde_z      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_o")
+	{
+      m_jailconf_horde_o      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_m")
+	{
+      m_jailconf_horde_m      = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_ban")
+	{
+      m_jailconf_ban = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_radius")
+	{
+      m_jailconf_radius = fields[2].GetUInt32();
+	}
+}
+while (result->NextRow());
+
+    sLog->outString("");
+    sLog->outString(GetTrinityStringForDBCLocale(LANG_JAIL_CONF_LOADED));
+    sLog->outString("");
+}
+
 void ObjectMgr::LoadCorpses()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 4efbbc7..88d2dca 100755
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -835,6 +835,10 @@ class ObjectMgr
         {
             return &mCreatureQuestRelations;
         }
+        QuestRelations* GetCreatureQuestInvolvedRelation()
+        {
+            return &mCreatureQuestInvolvedRelations;
+        }
 
         QuestRelationBounds GetCreatureQuestRelationBounds(uint32 creature_entry)
         {
@@ -927,6 +931,29 @@ class ObjectMgr
         void LoadTrainerSpell();
         void AddSpellToTrainer(uint32 entry, uint32 spell, uint32 spellCost, uint32 reqSkill, uint32 reqSkillValue, uint32 reqLevel);
 
+		// Loads the jail conf out of the database
+		void LoadJailConf(void);
+
+		// Jail Config...
+		std::string m_jail_obt;
+		uint32 m_jailconf_max_jails;    // Jail times when the char will be deleted
+		uint32 m_jailconf_max_duration; // Max. jail duration in hours
+		uint32 m_jailconf_min_reason;   // Min. char length of the reason
+		uint32 m_jailconf_warn_player;  // Warn player every login if max_jails is nearly reached?
+		uint32 m_jailconf_amnestie;     // player amnestie
+		float m_jailconf_ally_x;        // Coords of the jail for the allies
+		float m_jailconf_ally_y;
+		float m_jailconf_ally_z;
+		float m_jailconf_ally_o;
+		uint32 m_jailconf_ally_m;
+		float m_jailconf_horde_x;       // Coords of the jail for the horde
+		float m_jailconf_horde_y;
+		float m_jailconf_horde_z;
+		float m_jailconf_horde_o;
+		uint32 m_jailconf_horde_m;
+		uint32 m_jailconf_ban;          // Ban acc if max. jailtimes is reached?
+		uint32 m_jailconf_radius;       // Radius in which a jailed char can walk
+
         std::string GeneratePetName(uint32 entry);
         uint32 GetBaseXP(uint8 level);
         uint32 GetXPForLevel(uint8 level);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index b798c4d..c25f11a 100755
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -33,6 +33,10 @@
 #include "MapInstanced.h"
 #include "Util.h"
 #include "LFGMgr.h"
+//Playerbot mod
+#include "Config.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
 
 Roll::Roll(uint64 _guid, LootItem const& li) : itemGUID(_guid), itemid(li.itemid),
 itemRandomPropId(li.randomPropertyId), itemRandomSuffix(li.randomSuffix), itemCount(li.count),
@@ -92,6 +96,7 @@ Group::~Group()
     delete[] m_subGroupsCounts;
 }
 
+
 bool Group::Create(const uint64 &guid, const char * name)
 {
     uint32 lowguid = sObjectMgr->GenerateLowGuid(HIGHGUID_GROUP);
@@ -104,7 +109,7 @@ bool Group::Create(const uint64 &guid, const char * name)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
-    m_lootMethod = GROUP_LOOT;
+    m_lootMethod = (LootMethod)sConfig->GetIntDefault("Bot.LootMethod", 2);
     m_lootThreshold = ITEM_QUALITY_UNCOMMON;
     m_looterGuid = guid;
 
@@ -364,6 +369,38 @@ bool Group::AddMember(const uint64 &guid, const char* name)
 uint32 Group::RemoveMember(const uint64 &guid, const RemoveMethod &method /* = GROUP_REMOVEMETHOD_DEFAULT */, uint64 kicker /* = 0 */, const char* reason /* = NULL */)
 {
     BroadcastGroupUpdate();
+    {
+        Player *player = sObjectMgr->GetPlayer(guid);
+
+        if(player)
+        {
+            //Log out any Playerbots by the player
+            WorldSession *session = player->GetSession();
+
+            //save the map of playerbots first because if the map gets altered when
+            //a playerbot logs out which will corrupt the for loop
+            PlayerBotMap m_playerBots;
+            for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+            {
+                Player *bot = itr->second;
+                (m_playerBots)[itr->first] = bot;
+            }
+
+            //now log out any playerbots it may have
+            for(PlayerBotMap::const_iterator itr2 = m_playerBots.begin(); itr2 != m_playerBots.end(); ++itr2)
+            {
+                Player *bot = itr2->second;
+                session->LogoutPlayerBot(bot->GetGUID(),true);
+            }
+        }
+
+        //if the player manually removes himself from group, remove npc bot
+        if(player && player->HaveBot())
+        {
+            _removeMember(player->GetBot()->GetGUID());
+            player->SetBotMustDie();
+        }
+    }
 
     sScriptMgr->OnGroupRemoveMember(this, guid, method, kicker, reason);
 
@@ -402,6 +439,9 @@ uint32 Group::RemoveMember(const uint64 &guid, const RemoveMethod &method /* = G
             }
 
             _homebindIfInstance(player);
+        } else if(!player && method == 99){ //not a valid player and method == 99 mean I'm a bot
+            _removeMember(guid);
+            SendUpdate();
         }
 
         if (leaderChanged)
@@ -411,7 +451,7 @@ uint32 Group::RemoveMember(const uint64 &guid, const RemoveMethod &method /* = G
             BroadcastPacket(&data, true);
         }
 
-        SendUpdate();
+        if (sObjectMgr->GetPlayer(guid)) SendUpdate();
         ResetMaxEnchantingLevel();
     }
     // if group before remove <= 2 disband it
@@ -423,6 +463,24 @@ uint32 Group::RemoveMember(const uint64 &guid, const RemoveMethod &method /* = G
 
 void Group::ChangeLeader(const uint64 &guid)
 {
+    Player *player = sObjectMgr->GetPlayer(guid);
+
+    //keep looping until we find a valid player and not a bot
+    if(!player)
+    {
+        //not a valid leader, trying to find a new leader
+        //search from start
+        for(member_citerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
+        {
+            if(sObjectMgr->GetPlayer(itr->guid))
+            {
+                _setLeader(itr->guid);
+                return;
+            }
+        }
+        return;
+    }
+
     member_citerator slot = _getMemberCSlot(guid);
 
     if (slot == m_memberSlots.end())
@@ -441,6 +499,7 @@ void Group::Disband(bool hideDestroy /* = false */)
     sScriptMgr->OnGroupDisband(this);
 
     Player *player;
+
     for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
     {
         player = sObjectMgr->GetPlayer(citr->guid);
@@ -1027,6 +1086,34 @@ void Group::CountTheRoll(Rolls::iterator rollI, uint32 NumberOfPlayers)
     delete roll;
 }
 
+//
+// Bot changes
+//
+uint64 Group::GetTargetWithIconByGroup(uint64 guid)
+{
+  //  if (icon >= TARGETICONCOUNT) return 0;
+
+    uint64 targetGUID = 0;
+
+    switch(GetMemberGroup(guid))
+    {
+    case 0: targetGUID = m_targetIcons[STAR]; break;
+    case 1: targetGUID = m_targetIcons[CIRCLE]; break;
+    case 2: targetGUID = m_targetIcons[DIAMOND]; break;
+    case 3: targetGUID = m_targetIcons[TRIANGLE]; break;
+    case 4: targetGUID = m_targetIcons[MOON]; break;
+    case 5: targetGUID = m_targetIcons[SQUARE]; break;
+    case 6: targetGUID = m_targetIcons[CROSS]; break;
+    default: break;
+    }
+
+    // if no target icon, default to star
+    if (targetGUID==0) m_targetIcons[STAR];
+
+   return targetGUID;
+} // end getTargetWithIcon
+
+
 void Group::SetTargetIcon(uint8 id, uint64 whoGuid, uint64 targetGuid)
 {
     if (id >= TARGETICONCOUNT)
@@ -1092,23 +1179,34 @@ void Group::SendTargetIconList(WorldSession *session)
 
 void Group::SendUpdate()
 {
+    member_citerator prevCitr, citr3;
+    bool foundBot = false;
     Player *player;
+	uint64 value = 0;
     for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
     {
         player = sObjectMgr->GetPlayer(citr->guid);
+
         if (!player || !player->GetSession() || player->GetGroup() != this)
             continue;
-
+        uint64& botGuid= *((uint64*)&value);
+        if(player->HaveBot())
+        {
+            if(Creature *ci = player->GetBot())
+            {
+                botGuid = (uint64&)ci->GetGUID();
+            }
+        }
         WorldPacket data(SMSG_GROUP_LIST, (1+1+1+1+1+4+8+4+4+(GetMembersCount()-1)*(13+8+1+1+1+1)+8+1+8+1+1+1+1));
         data << uint8(m_groupType);                         // group type (flags in 3.3)
         data << uint8(citr->group);
         data << uint8(citr->flags);
         data << uint8(citr->roles);
-        if (isLFGGroup())
+        /* TESTING */if (isLFGGroup())
         {
             data << uint8(sLFGMgr->GetState(m_guid) == LFG_STATE_FINISHED_DUNGEON ? 2 : 0); // FIXME - Dungeon save status? 2 = done
             data << uint32(sLFGMgr->GetDungeon(m_guid));
-        }
+        }/* TESTING */
 
         data << uint64(m_guid);
         data << uint32(m_counter++);                        // 3.3, value increases every time this packet gets sent
@@ -1123,12 +1221,20 @@ void Group::SendUpdate()
             uint8 onlineState = (member) ? MEMBER_STATUS_ONLINE : MEMBER_STATUS_OFFLINE;
             onlineState = onlineState | ((isBGGroup()) ? MEMBER_STATUS_PVP : 0);
 
-            data << citr2->name;
-            data << uint64(citr2->guid);                    // guid
+            /* TESTING */citr3 = citr2;
+            if (citr2->guid == botGuid)
+            {
+               value = 0;
+               botGuid=*((uint64*)&value); // reset
+            }
+            data << citr3->name;
+            data << uint64(citr3->guid);                    // guid
             data << uint8(onlineState);                     // online-state
             data << uint8(citr2->group);                    // groupid
             data << uint8(citr2->flags);                    // See enum GroupMemberFlags
             data << uint8(citr2->roles);                    // Lfg Roles
+
+            if(foundBot) foundBot = false;/* TESTING */
         }
 
         data << uint64(m_leaderGuid);                       // leader guid
@@ -1423,6 +1529,15 @@ bool Group::_setAssistantFlag(const uint64 &guid, const bool &apply)
     if (!isBGGroup())
         CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
 
+    Player *pPlayer = sObjectMgr->GetPlayer(guid);
+    if (pPlayer->GetPlayerbotAI()!=NULL) {
+        if (apply) {
+            pPlayer->HandleEmoteCommand(EMOTE_ONESHOT_ROAR);        // if pBot is maintank, acknowledge it
+        } else {
+            pPlayer->HandleEmoteCommand(EMOTE_ONESHOT_CRY);
+        }
+    }
+
     return true;
 }
 
@@ -1438,6 +1553,17 @@ bool Group::_setMainTank(const uint64 &guid, const bool &apply)
     if (!isBGGroup())
         CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
 
+    // tell all the bots who is the main tank now
+    if (apply)
+        for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->getSource();
+            PlayerbotAI *ai = tPlayer->GetPlayerbotAI();
+            ai->GetClassAI();
+            if (tPlayer->IsPlayerbot())
+                tPlayer->GetPlayerbotAI()->GetClassAI()->SetMainTank(sObjectMgr->GetPlayer(guid));
+        }
+
     return true;
 }
 
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index d7fb7c7..97a751a 100755
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -43,6 +43,20 @@ struct MapEntry;
 #define MAX_RAID_SUBGROUPS MAXRAIDSIZE/MAXGROUPSIZE
 #define TARGETICONCOUNT 8
 
+class PlayerbotAI;
+class PlayerbotClassAI;
+
+enum TARGETICON
+{
+    STAR            = 0,
+    CIRCLE          = 1,
+    DIAMOND         = 2,
+    TRIANGLE        = 3,
+    MOON            = 4,
+    SQUARE          = 5,
+    CROSS           = 6,
+    SKULL           = 7
+};
 enum RollVote
 {
     PASS              = 0,
@@ -239,8 +253,11 @@ class Group
         void SetMainTank(uint64 guid, const bool &apply);
         void SetMainAssistant(uint64 guid, const bool &apply);
         void SetTargetIcon(uint8 id, uint64 whoGuid, uint64 targetGuid);
+        // Bot change
+        uint64 GetTargetWithIconByGroup(uint64 guid);
+        void SetTargetIcon(uint8 id, uint64 guid);
 
-        Difficulty GetDifficulty(bool isRaid) const;
+	    Difficulty GetDifficulty(bool isRaid) const;
         Difficulty GetDungeonDifficulty() const;
         Difficulty GetRaidDifficulty() const;
         void SetDungeonDifficulty(Difficulty difficulty);
diff --git a/src/server/game/Mails/Mail.cpp b/src/server/game/Mails/Mail.cpp
index 0956fae..e94f9fa 100755
--- a/src/server/game/Mails/Mail.cpp
+++ b/src/server/game/Mails/Mail.cpp
@@ -26,6 +26,7 @@
 #include "BattlegroundMgr.h"
 #include "Item.h"
 #include "AuctionHouseMgr.h"
+#include "AuctionHouseBot.h"
 
 MailSender::MailSender(Object* sender, MailStationery stationery) : m_stationery(stationery)
 {
@@ -181,6 +182,13 @@ void MailDraft::SendMailTo(SQLTransaction& trans, MailReceiver const& receiver,
 
     uint32 mailId = sObjectMgr->GenerateMailID();
 
+    if (receiver.GetPlayerGUIDLow() == auctionbot.GetAHBplayerGUID())
+    {
+        if (sender.GetMailMessageType() == MAIL_AUCTION)        // auction mail with items
+            deleteIncludedItems(trans, true);
+        return;
+    }
+
     time_t deliver_time = time(NULL) + deliver_delay;
 
     //expire time if COD 3 days, if no COD 30 days, if auction sale pending 1 hour
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index c4187ff..75c1dee 100755
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -2208,12 +2208,14 @@ void InstanceMap::InitVisibilityDistance()
 */
 bool InstanceMap::CanEnter(Player *player)
 {
-    if (player->GetMapRef().getTarget() == this)
+    //playerbots calls this twice, first by TeleportTo and again by WorldSession
+    //Don't want to error since we know we are already here.
+   /* if(player->GetMapRef().getTarget() == this && !player->IsPlayerbot())
     {
         sLog->outError("InstanceMap::CanEnter - player %s(%u) already in map %d,%d,%d!", player->GetName(), player->GetGUIDLow(), GetId(), GetInstanceId(), GetSpawnMode());
         ASSERT(false);
         return false;
-    }
+    }*/
 
     // allow GM's to enter
     if (player->isGameMaster())
@@ -2312,15 +2314,21 @@ bool InstanceMap::Add(Player *player)
             {
                 if (group)
                 {
+					bool isBot = player->IsPlayerbot();
                     // solo saves should be reset when entering a group
                     InstanceGroupBind *groupBind = group->GetBoundInstance(this);
                     if (playerBind)
                     {
-                        sLog->outError("InstanceMap::Add: player %s(%d) is being put into instance %d,%d,%d,%d,%d,%d but he is in group %d and is bound to instance %d,%d,%d,%d,%d,%d!", player->GetName(), player->GetGUIDLow(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), mapSave->GetPlayerCount(), mapSave->GetGroupCount(), mapSave->CanReset(), GUID_LOPART(group->GetLeaderGUID()), playerBind->save->GetMapId(), playerBind->save->GetInstanceId(), playerBind->save->GetDifficulty(), playerBind->save->GetPlayerCount(), playerBind->save->GetGroupCount(), playerBind->save->CanReset());
-                        if (groupBind)
-                            sLog->outError("InstanceMap::Add: the group is bound to the instance %d,%d,%d,%d,%d,%d", groupBind->save->GetMapId(), groupBind->save->GetInstanceId(), groupBind->save->GetDifficulty(), groupBind->save->GetPlayerCount(), groupBind->save->GetGroupCount(), groupBind->save->CanReset());
-                        //ASSERT(false);
-                        return false;
+						if (isBot)
+						{
+							player->UnbindInstance(mapSave->GetMapId(),mapSave->GetDifficulty(),true);
+						}
+						else {
+							sLog->outError("InstanceMap::Add: player %s(%d) is being put into instance %d,%d,%d,%d,%d,%d but he is in group %d and is bound to instance %d,%d,%d,%d,%d,%d!", player->GetName(), player->GetGUIDLow(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), mapSave->GetPlayerCount(), mapSave->GetGroupCount(), mapSave->CanReset(), GUID_LOPART(group->GetLeaderGUID()), playerBind->save->GetMapId(), playerBind->save->GetInstanceId(), playerBind->save->GetDifficulty(), playerBind->save->GetPlayerCount(), playerBind->save->GetGroupCount(), playerBind->save->CanReset());
+							if (groupBind) sLog->outError("InstanceMap::Add: the group is bound to the instance %d,%d,%d,%d,%d,%d", groupBind->save->GetMapId(), groupBind->save->GetInstanceId(), groupBind->save->GetDifficulty(), groupBind->save->GetPlayerCount(), groupBind->save->GetGroupCount(), groupBind->save->CanReset());
+							//ASSERT(false);
+							return false;
+						}
                     }
                     // bind to the group or keep using the group save
                     if (!groupBind)
@@ -2330,7 +2338,7 @@ bool InstanceMap::Add(Player *player)
                         // cannot jump to a different instance without resetting it
                         if (groupBind->save != mapSave)
                         {
-                            sLog->outError("InstanceMap::Add: player %s(%d) is being put into instance %d,%d,%d but he is in group %d which is bound to instance %d,%d,%d!", player->GetName(), player->GetGUIDLow(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), GUID_LOPART(group->GetLeaderGUID()), groupBind->save->GetMapId(), groupBind->save->GetInstanceId(), groupBind->save->GetDifficulty());
+                            sLog->outError("InstanceMap::Add: player %s(%d) is being put in instance %d,%d,%d but he is in group %d which is bound to instance %d,%d,%d!", player->GetName(), player->GetGUIDLow(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), GUID_LOPART(group->GetLeaderGUID()), groupBind->save->GetMapId(), groupBind->save->GetInstanceId(), groupBind->save->GetDifficulty());
                             if (mapSave)
                                 sLog->outError("MapSave players: %d, group count: %d", mapSave->GetPlayerCount(), mapSave->GetGroupCount());
                             else
diff --git a/src/server/game/Miscellaneous/Formulas.h b/src/server/game/Miscellaneous/Formulas.h
index 0cd45b9..65b8600 100755
--- a/src/server/game/Miscellaneous/Formulas.h
+++ b/src/server/game/Miscellaneous/Formulas.h
@@ -178,7 +178,9 @@ namespace Trinity
                         gain *= 2;
                 }
 
-                gain = uint32(gain * sWorld->getRate(RATE_XP_KILL));
+	    float premium_rate = pl->GetSession()->IsPremium() ? sWorld->getRate(RATE_XP_KILL_PREMIUM) : 1.0f;
+
+            return uint32(gain*sWorld->getRate(RATE_XP_KILL)*premium_rate);
             }
 
             sScriptMgr->OnGainCalculation(gain, pl, u);
diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
index 24c4114..e08dc3c 100755
--- a/src/server/game/Miscellaneous/Language.h
+++ b/src/server/game/Miscellaneous/Language.h
@@ -21,6 +21,42 @@
 
 enum TrinityStrings
 {
+		// Added by WarHead for the Jail edited by spgm
+	LANG_JAIL_YOURE_JAILED              = 950,  // "You are jailed by %s for %u hour(s)!"
+	LANG_JAIL_REASON                    = 951,  // "%s wrote this as reason: %s"
+	LANG_JAIL_WAS_JAILED                = 952,  // "%s was jailed by you for %u hour(s)!"
+	LANG_JAIL_YOURE_UNJAILED            = 953,  // "You was released out of the jail by %s."
+	LANG_JAIL_WAS_UNJAILED              = 954,  // "You have released %s out of the jail."
+	LANG_JAIL_NOREASON                  = 955,  // "No reason given or reason is < %u chars!"
+	LANG_JAIL_NONAME                    = 956,  // "No name given!"
+	LANG_JAIL_NOTIME                    = 957,  // "No time given!"
+	LANG_JAIL_VALUE                     = 958,  // "The jailtime must be between 1 and %u hours!"
+	LANG_JAIL_CHAR_NOTJAILED            = 959,  // "The character (%s) is not jailed!"
+	LANG_JAIL_DENIED                    = 960,  // "Command forbidden for jailed characters!"
+	LANG_JAIL_JAILED_H_INFO             = 961,  // "You have %u hour(s) left in the jail."
+	LANG_JAIL_JAILED_M_INFO             = 962,  // "You have %u minute(s) left in the jail."
+	LANG_JAIL_NOTJAILED_INFO            = 963,  // "You're a free woman / man. ;-)"
+	LANG_JAIL_GM_INFO                   = 964,  // "%s was %u times jailed and has %u minute(s) left. Last time jailed by %s. Last reason was: '%s'"
+	LANG_JAIL_GM_NOINFO                 = 965,  // "%s was never jailed."
+	LANG_JAIL_NO_JAIL                   = 966,  // "You can't jail yourself!"
+	LANG_JAIL_NO_UNJAIL                 = 967,  // "You can't unjail yourself!"
+	LANG_JAIL_WARNING                   = 968,  // "Be carefull! Only one more jailtime and your current character will be deleted!"
+	LANG_JAIL_ANNOUNCE1                 = 969,  // "The character '"
+	LANG_JAIL_ANNOUNCE2                 = 970,  // "' was jailed for "
+	LANG_JAIL_ANNOUNCE3                 = 971,  // " hour(s) by the GM character '"
+	LANG_JAIL_ANNOUNCE4                 = 972,  // "'. The reason is: "
+	LANG_JAIL_RELOAD                    = 973,  // "The jail configuration was reloaded."
+	LANG_JAIL_CONF_LOADED               = 974,  // ">> Jail config loaded."
+	LANG_JAIL_CONF_ERR1                 = 975,  // "Can't load jail config! Table empty or missed! Use jail_conf.sql!"
+	LANG_JAIL_CONF_ERR2                 = 976,  // "Set all jail config settings to default..."
+	LANG_JAIL_CHAR_TELE                 = 977,  // "The Character '%s' (GUID %u) is jailed and teleportet into the jail."
+	LANG_JAIL_CHAR_FREE                 = 978,  // "The Character '%s' (GUID %u) was released out of the jail."
+	LANG_JAIL_WRONG_NAME                = 979,  // "A character with this name doesn't exists!"
+	LANG_JAIL_WARNING_BAN               = 980,  // "Be carefull! Only one more jailtime and your account will be banned!"
+	LANG_JAIL_BAN_REASON                = 981,  // "Max. jailtimes reached!"
+	LANG_JAIL_BAN_BY                    = 982,  // "Robotron"
+	LANG_JAIL_AMNESTII					= 983,  // "AMNESTII"
+
     // for chat commands
     LANG_SELECT_CHAR_OR_CREATURE        = 1,
     LANG_SELECT_CREATURE                = 2,
@@ -702,6 +738,29 @@ enum TrinityStrings
 //  LANG_BG_AB_START_TWO_MINUTES        = 754, - defined above
 //  LANG_BG_EY_START_TWO_MINUTES        = 755, - defined above
 
+    LANG_BG_WG_BATTLE_STARTS            = 756,
+    LANG_BG_WG_DEFENDED                 = 757,
+    LANG_BG_WG_CAPTURED                 = 758,
+    LANG_BG_WG_WORKSHOP_DAMAGED         = 759,
+    LANG_BG_WG_WORKSHOP_DESTROYED       = 760,
+    LANG_BG_WG_TOWER_DAMAGED            = 761,
+    LANG_BG_WG_TOWER_DESTROYED          = 762,
+    LANG_BG_WG_FORTRESS_UNDER_ATTACK    = 763,
+    LANG_BG_WG_SWITCH_FACTION           = 764,
+    LANG_BG_WG_CHANGE_TIMER             = 765,
+    LANG_BG_WG_BATTLE_FORCE_START       = 766,
+    LANG_BG_WG_BATTLE_FORCE_STOP        = 767,
+    LANG_BG_WG_STATUS                   = 768,
+    LANG_BG_WG_DISABLE                  = 769,
+    LANG_BG_WG_ENABLE                   = 770,
+    LANG_BG_WG_RANK1                    = 771,
+    LANG_BG_WG_RANK2                    = 772,
+
+    LANG_BG_WG_WORLD_ANNOUNCE_30        = 780,
+    LANG_BG_WG_WORLD_ANNOUNCE_10        = 781,
+    LANG_BG_WG_WORLD_NO_DEF             = 782,
+    LANG_BG_WG_WORLD_NO_ATK             = 783,
+
     // Room for BG/ARENA                = 773-784, 788-799 not used
     LANG_ARENA_TESTING                  = 785,
     LANG_AUTO_ANN                       = 786,
diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.h b/src/server/game/OutdoorPvP/OutdoorPvP.h
index 1da710a..96666d1 100755
--- a/src/server/game/OutdoorPvP/OutdoorPvP.h
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.h
@@ -32,9 +32,10 @@ enum OutdoorPvPTypes
     OUTDOOR_PVP_ZM = 4,
     OUTDOOR_PVP_SI = 5,
     OUTDOOR_PVP_EP = 6,
+    OUTDOOR_PVP_WG = 7,
 };
 
-#define MAX_OUTDOORPVP_TYPES 7
+#define MAX_OUTDOORPVP_TYPES 8
 
 const uint8 CapturePointArtKit[3] = {2, 1, 21};
 
diff --git a/src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp b/src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp
index 4ccc31a..f506ced 100755
--- a/src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp
+++ b/src/server/game/OutdoorPvP/OutdoorPvPMgr.cpp
@@ -20,6 +20,7 @@
 #include "Player.h"
 #include "DisableMgr.h"
 #include "ScriptMgr.h"
+#include "OutdoorPvPWG.h"
 
 OutdoorPvPMgr::OutdoorPvPMgr()
 {
diff --git a/src/server/game/Quests/QuestDef.h b/src/server/game/Quests/QuestDef.h
index 1ddc5af..b311816 100755
--- a/src/server/game/Quests/QuestDef.h
+++ b/src/server/game/Quests/QuestDef.h
@@ -96,9 +96,9 @@ enum QuestStatus
 {
     QUEST_STATUS_NONE           = 0,
     QUEST_STATUS_COMPLETE       = 1,
-    //QUEST_STATUS_UNAVAILABLE    = 2,
+    QUEST_STATUS_UNAVAILABLE    = 2,
     QUEST_STATUS_INCOMPLETE     = 3,
-    //QUEST_STATUS_AVAILABLE      = 4,
+    QUEST_STATUS_AVAILABLE      = 4,
     QUEST_STATUS_FAILED         = 5,
     QUEST_STATUS_REWARDED       = 6,        // Not used in DB
     MAX_QUEST_STATUS
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index adbfbe6..242a013 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -25,6 +25,9 @@ void AddSC_example_gossip_codebox();
 void AddSC_example_misc();
 void AddSC_example_commandscript();
 
+//TeleNPC2
+void AddSC_npc_teleport();
+
 // spells
 void AddSC_deathknight_spell_scripts();
 void AddSC_druid_spell_scripts();
@@ -44,6 +47,7 @@ void AddSC_example_spell_scripts();
 void AddSC_SmartSCripts();
 
 //Commands
+void AddSC_anticheat_commandscript();
 void AddSC_account_commandscript();
 void AddSC_achievement_commandscript();
 void AddSC_debug_commandscript();
@@ -61,6 +65,9 @@ void AddSC_tele_commandscript();
 void AddSC_titles_commandscript();
 void AddSC_wp_commandscript();
 
+//Custom
+void AddSC_Reset();
+
 #ifdef SCRIPTS
 //world
 void AddSC_areatrigger_scripts();
@@ -77,6 +84,18 @@ void AddSC_npcs_special();
 void AddSC_npc_taxi();
 void AddSC_achievement_scripts();
 
+//Bots
+void AddSC_druid_bot();
+void AddSC_priest_bot();
+void AddSC_shaman_bot();
+void AddSC_warrior_bot();
+void AddSC_rogue_bot();
+void AddSC_mage_bot();
+void AddSC_warlock_bot();
+void AddSC_paladin_bot();
+void AddSC_hunter_bot();
+void AddSC_script_bot_giver();
+
 //eastern kingdoms
 void AddSC_alterac_valley();                 //Alterac Valley
 void AddSC_boss_balinda();
@@ -465,16 +484,19 @@ void AddSC_instance_halls_of_reflection();   // Halls of Reflection
 void AddSC_halls_of_reflection();
 void AddSC_boss_falric();
 void AddSC_boss_marwyn();
-void AddSC_boss_lord_marrowgar();       // Icecrown Citadel
-void AddSC_boss_lady_deathwhisper();
-void AddSC_boss_deathbringer_saurfang();
-void AddSC_boss_festergut();
+void AddSC_instance_icecrown_citadel();    // Icecrown Citadel
+void AddSC_icecrown_citadel_teleport();
+void AddSC_boss_valithria();
+void AddSC_boss_lichking();
+void AddSC_boss_sindragosa();
 void AddSC_boss_rotface();
-void AddSC_boss_professor_putricide();
 void AddSC_boss_blood_prince_council();
+void AddSC_boss_professor_putricide();
+void AddSC_boss_lord_marrowgar();
+void AddSC_boss_lady_deathwhisper();
+void AddSC_boss_festergut();
+void AddSC_boss_deathbringer_saurfang();
 void AddSC_boss_blood_queen_lana_thel();
-void AddSC_icecrown_citadel_teleport();
-void AddSC_instance_icecrown_citadel();
 
 void AddSC_dalaran();
 void AddSC_borean_tundra();
@@ -488,6 +510,13 @@ void AddSC_zuldrak();
 void AddSC_crystalsong_forest();
 void AddSC_isle_of_conquest();
 
+void AddSC_boss_baltharus();	//RubySanctum
+void AddSC_boss_halion();
+void AddSC_boss_ragefire();
+void AddSC_boss_zarithrian();
+void AddSC_instance_ruby_sanctum();
+
+
 //outland
 void AddSC_boss_exarch_maladaar();           //Auchindoun Auchenai Crypts
 void AddSC_boss_shirrak_the_dead_watcher();
@@ -579,6 +608,8 @@ void AddSC_outdoorpvp_na();
 void AddSC_outdoorpvp_si();
 void AddSC_outdoorpvp_tf();
 void AddSC_outdoorpvp_zm();
+void AddSC_outdoorpvp_wg();
+void AddSC_wintergrasp();
 
 // player
 void AddSC_chat_log();
@@ -632,6 +663,7 @@ void AddSpellScripts()
 
 void AddCommandScripts()
 {
+    AddSC_anticheat_commandscript();
     AddSC_account_commandscript();
     AddSC_achievement_commandscript();
     AddSC_debug_commandscript();
@@ -666,6 +698,19 @@ void AddWorldScripts()
     AddSC_npcs_special();
     AddSC_npc_taxi();
     AddSC_achievement_scripts();
+
+    //Bots
+    AddSC_druid_bot();
+    AddSC_priest_bot();
+    AddSC_shaman_bot();
+    AddSC_warrior_bot();
+    AddSC_rogue_bot();
+    AddSC_mage_bot();
+    AddSC_warlock_bot();
+    AddSC_paladin_bot();
+    AddSC_hunter_bot();
+    AddSC_script_bot_giver();
+
     AddSC_chat_log();
 #endif
 }
@@ -1154,16 +1199,19 @@ void AddNorthrendScripts()
     AddSC_halls_of_reflection();
     AddSC_boss_falric();
     AddSC_boss_marwyn();
-    AddSC_boss_lord_marrowgar();        // Icecrown Citadel
-    AddSC_boss_lady_deathwhisper();
-    AddSC_boss_deathbringer_saurfang();
-    AddSC_boss_festergut();
+	AddSC_instance_icecrown_citadel();    // Icecrown Citadel
+    AddSC_icecrown_citadel_teleport();
+    AddSC_boss_valithria();
+    AddSC_boss_lichking();
+    AddSC_boss_sindragosa();
     AddSC_boss_rotface();
-    AddSC_boss_professor_putricide();
     AddSC_boss_blood_prince_council();
+    AddSC_boss_professor_putricide();
+    AddSC_boss_lord_marrowgar();
+    AddSC_boss_lady_deathwhisper();
+    AddSC_boss_festergut();
+    AddSC_boss_deathbringer_saurfang();
     AddSC_boss_blood_queen_lana_thel();
-    AddSC_icecrown_citadel_teleport();
-    AddSC_instance_icecrown_citadel();
 
     AddSC_dalaran();
     AddSC_borean_tundra();
@@ -1176,6 +1224,13 @@ void AddNorthrendScripts()
     AddSC_zuldrak();
     AddSC_crystalsong_forest();
     AddSC_isle_of_conquest();
+
+    AddSC_wintergrasp();
+    AddSC_boss_baltharus();	//RubySanctum
+    AddSC_boss_halion();
+    AddSC_boss_ragefire();
+    AddSC_boss_zarithrian();
+    AddSC_instance_ruby_sanctum();
 #endif
 }
 
@@ -1188,6 +1243,7 @@ void AddOutdoorPvPScripts()
     AddSC_outdoorpvp_si();
     AddSC_outdoorpvp_tf();
     AddSC_outdoorpvp_zm();
+    AddSC_outdoorpvp_wg();
 #endif
 }
 
@@ -1207,5 +1263,8 @@ void AddCustomScripts()
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
 
+    AddSC_Reset();
+    //TeleNPC2
+    AddSC_npc_teleport();
 #endif
 }
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index 8b97aa2..a6d898f 100755
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -25,6 +25,7 @@
 #include "ScriptLoader.h"
 #include "ScriptSystem.h"
 #include "Transport.h"
+#include "sc_npc_teleport.h"
 
 // Utility macros to refer to the script registry.
 #define SCR_REG_MAP(T) ScriptRegistry<T>::ScriptMap
@@ -180,6 +181,8 @@ void ScriptMgr::Initialize()
     uint32 oldMSTime = getMSTime();
 
     LoadDatabase();
+	// Load TeleNPC2 - maybe not the best place to load it ...
+	LoadNpcTele();
 
     sLog->outString("Loading C++ scripts");
 
@@ -667,13 +670,29 @@ bool ScriptMgr::OnGossipHello(Player* player, Creature* creature)
     return tmpscript->OnGossipHello(player, creature);
 }
 
+bool ScriptMgr::OnGossipHelloScriptId(Player * player, Creature* creature, uint32 scriptId)
+{
+	ASSERT(player);
+    ASSERT(creature);
+
+    GET_SCRIPT_RET(CreatureScript, scriptId, tmpscript, false);
+    return tmpscript->OnGossipHello(player, creature);
+}
+
 bool ScriptMgr::OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
 {
     ASSERT(player);
     ASSERT(creature);
 
-    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
-    return tmpscript->OnGossipSelect(player, creature, sender, action);
+	// Bots change
+	if (sender > 6000)
+	{
+        GET_SCRIPT_RET(CreatureScript, sObjectMgr->GetScriptId("script_bot_giver"), tmpscript, false);
+        return tmpscript->OnGossipSelect(player, creature, sender, action);
+	} else {
+        GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
+        return tmpscript->OnGossipSelect(player, creature, sender, action);
+	}
 }
 
 bool ScriptMgr::OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code)
diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
index 090da69..d07231a 100755
--- a/src/server/game/Scripting/ScriptMgr.h
+++ b/src/server/game/Scripting/ScriptMgr.h
@@ -407,6 +407,8 @@ class CreatureScript : public ScriptObject, public UpdatableScript<Creature>
         // Called when a player opens a gossip dialog with the creature.
         virtual bool OnGossipHello(Player* /*player*/, Creature* /*creature*/) { return false; }
 
+        virtual bool OnGossipHelloScriptId(Player* /*player*/, Creature* /*creature*/, uint32 ScriptId) { return false; }
+
         // Called when a player selects a gossip item in the creature's gossip menu.
         virtual bool OnGossipSelect(Player* /*player*/, Creature* /*creature*/, uint32 /*sender*/, uint32 /*action*/) { return false; }
 
@@ -840,6 +842,7 @@ class ScriptMgr
 
         bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Creature* target);
         bool OnGossipHello(Player* player, Creature* creature);
+        bool OnGossipHelloScriptId(Player* player, Creature* creature, uint32 ScriptId);
         bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
         bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code);
         bool OnQuestAccept(Player* player, Creature* creature, Quest const* quest);
diff --git a/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp b/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp
index 6288fb6..4fb9863 100755
--- a/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp
@@ -22,6 +22,7 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+#include "AuctionHouseBot.h"
 #include "AuctionHouseMgr.h"
 #include "Log.h"
 #include "Opcodes.h"
diff --git a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
index 0641007..872f316 100755
--- a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
@@ -35,6 +35,9 @@
 #include "DisableMgr.h"
 #include "Group.h"
 
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
+
 void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket & recv_data)
 {
     uint64 guid;
@@ -598,7 +601,18 @@ void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
         return;
 
     if (bg)
+    {
         sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
+    }
+	else
+    {  // Wintergrasp Hack till 3.2 and it's implemented as BG
+        if (GetPlayer()->GetZoneId() == 4197)
+        {
+            OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+            if (pvpWG && pvpWG->isWarTime())
+                pvpWG->SendAreaSpiritHealerQueryOpcode(_player, guid);
+        }
+    }
 }
 
 
diff --git a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
index ca7efa7..fd84df7 100755
--- a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
@@ -41,6 +41,10 @@
 #include "ScriptMgr.h"
 #include "Battleground.h"
 
+// Playerbot mod
+#include "Config.h"
+#include "PlayerbotAI.h"
+
 class LoginQueryHolder : public SQLQueryHolder
 {
     private:
@@ -197,6 +201,34 @@ bool LoginQueryHolder::Initialize()
     return res;
 }
 
+// don't call WorldSession directly
+// it may get deleted before the query callbacks get executed
+// instead pass an account id to this handler
+class CharacterHandler
+{
+
+    public:
+        void HandleCharEnumCallback(QueryResult result, uint32 account)
+        {
+            WorldSession * session = sWorld->FindSession(account);
+            if (!session)
+                return;
+            session->HandleCharEnum(result);
+        }
+        void HandlePlayerLoginCallback(QueryResult /*dummy*/, SQLQueryHolder * holder)
+        {
+            if (!holder) return;
+            WorldSession *session = sWorld->FindSession(((LoginQueryHolder*)holder)->GetAccountId());
+            if (!session)
+            {
+                delete holder;
+                return;
+            }
+            session->HandlePlayerLogin((LoginQueryHolder*)holder);
+        }
+
+} chrHandler;
+
 void WorldSession::HandleCharEnum(QueryResult result)
 {
     WorldPacket data(SMSG_CHAR_ENUM, 100);                  // we guess size
@@ -887,10 +919,119 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder * holder)
         pCurrChar->SetStandState(UNIT_STAND_STATE_STAND);
 
     m_playerLoading = false;
+    //Check if it has an NPCBot
+    QueryResult results;
+    results = CharacterDatabase.PQuery("SELECT entry,race,class FROM character_npcbot WHERE owner='%u'", pCurrChar->GetGUIDLow());
+    if(results)
+    {
+        Field *fields = results->Fetch();
+        uint32 m_bot_entry = fields[0].GetUInt32();
+        uint8 m_bot_race = fields[1].GetUInt8();
+        uint8 m_bot_class = fields[2].GetUInt8();
+        if(m_bot_entry && m_bot_race && m_bot_class) pCurrChar->SetBotMustBeCreated(m_bot_entry, m_bot_race, m_bot_class);
+        //delete results;
+    }
 
     sScriptMgr->OnPlayerLogin(pCurrChar);
     delete holder;
 }
+//Playerbot mod: is different from the normal
+//HandlePlayerLoginCallback in that it sets up the bot's
+//world session and also stores the pointer to the bot player
+//in the master's world session m_playerBots map
+void WorldSession::HandlePlayerBotLogin(SQLQueryHolder *holder)
+{
+    if(!holder) return;
+
+    LoginQueryHolder *lqh = (LoginQueryHolder *)holder;
+
+    if(!lqh || !lqh->GetAccountId()) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #1 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        return;
+    }
+
+    WorldSession *masterSession = sWorld->FindSession(lqh->GetAccountId());
+
+    if(!masterSession) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #2 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        return;
+    }
+
+    //This WorldSession is owned by the bot player object
+    //it will deleted in the Player class constructor for Playerbots
+    //only
+    WorldSession *botSession = new WorldSession(lqh->GetAccountId(), NULL, SEC_PLAYER, true, 0, 0, LOCALE_enUS,0);
+
+    if(!botSession) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #3 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        return;
+    }
+
+    botSession->m_Address = "bot";
+    botSession->m_expansion = 2;
+
+    uint64 guid = lqh->GetGuid();
+     if(!guid) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #4 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        return;
+    }
+
+    Group * group = masterSession->GetPlayer()->GetGroup() ;
+    if(group && group->IsFull() &&
+        !group->IsMember(guid) )
+    {
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        ChatHandler chH = ChatHandler( masterSession->GetPlayer());
+        chH.PSendSysMessage("Bot removed because group is full.");
+        return;
+    }
+
+    botSession->HandlePlayerLogin(lqh);
+    Player *botPlayer = botSession->GetPlayer();
+
+    if(!botPlayer) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #5 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        return;
+    }
+
+    //give the bot some AI, object is owned by the player class
+    PlayerbotAI *ai = new PlayerbotAI(masterSession->GetPlayer(), botPlayer);
+    botPlayer->SetPlayerbotAI(ai);
+
+    ai->SetStartDifficulty(botPlayer->GetDungeonDifficulty());
+    ai->SetStartInstanceID(botPlayer->GetInstanceId());
+    ai->SetStartMapID(botPlayer->GetMapId());
+    ai->SetStartZoneID(botPlayer->GetZoneId());
+    ai->SetStartAreaID(botPlayer->GetAreaId());
+    ai->SetStartO(botPlayer->GetOrientation());
+    ai->SetStartX(botPlayer->GetPositionX());
+    ai->SetStartY(botPlayer->GetPositionY());
+    ai->SetStartZ(botPlayer->GetPositionZ());
+
+    //tell the world session that they now manage this new bot
+    (masterSession->m_playerBots)[guid] = botPlayer;
+
+    //if bot is in a group and master is not in group then
+    //have bot leave their group
+    if(botPlayer->GetGroup() &&
+        (masterSession->GetPlayer()->GetGroup() == NULL ||
+        masterSession->GetPlayer()->GetGroup()->IsMember(guid) == false))
+        botPlayer->RemoveFromGroup();
+}
 
 void WorldSession::HandleSetFactionAtWar(WorldPacket & recv_data)
 {
@@ -1075,6 +1216,40 @@ void WorldSession::HandleChangePlayerNameOpcodeCallBack(QueryResult result, std:
     SendPacket(&data);
 }
 
+//Playerbot mod - add new player bot for this master. This definition must
+//appear in this file because it utilizes the CharacterHandler class
+//which isn't accessible outside this file
+void WorldSession::AddPlayerBot(uint64 playerGuid)
+{
+    //has bot already been added?
+    if(GetPlayerBot(playerGuid) != 0) return;
+
+    ChatHandler chH = ChatHandler(GetPlayer());
+
+    //check if max playerbots are exceeded
+   uint8 count = 0;
+    uint8 m_MaxPlayerbots = sConfig->GetFloatDefault("Bot.MaxPlayerbots", 9);
+    for(PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr) ++count;
+
+    if(count >= m_MaxPlayerbots)
+    {
+        chH.PSendSysMessage("You have reached the maximum number (%d) of Player Bots allowed.", m_MaxPlayerbots);
+        return;
+    }
+
+    LoginQueryHolder *holder = new LoginQueryHolder(GetAccountId(), playerGuid);
+
+    if(!holder->Initialize())
+    {
+        delete holder; //delete all unprocessed queries
+        return;
+    }
+    //CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerBotLoginCallback, holder);
+	m_charBotLoginCallback = CharacterDatabase.DelayQueryHolder(holder);
+
+    chH.PSendSysMessage("Bot added successfully.");
+}
+
 void WorldSession::HandleSetPlayerDeclinedNames(WorldPacket& recv_data)
 {
     uint64 guid;
diff --git a/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp b/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
index 9981dfe..6493577 100755
--- a/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
@@ -39,6 +39,12 @@
 #include "Util.h"
 #include "ScriptMgr.h"
 
+//Playerbot mod
+#include "PlayerbotAI.h"
+
+
+
+
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
     if (lang != LANG_ADDON)
@@ -283,14 +289,23 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
                     return;
                 }
             }
-
             if (GetPlayer()->HasAura(1852) && !player->isGameMaster())
             {
                 SendNotification(GetTrinityString(LANG_GM_SILENCE), GetPlayer()->GetName());
                 return;
             }
 
-            GetPlayer()->Whisper(msg, lang, player->GetGUID());
+            //Playerbot mod: handle whispered command to bot
+            if(player->GetPlayerbotAI())
+            {
+                player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else {
+            //end Playerbot mod
+                GetPlayer()->Whisper(msg, lang, player->GetGUID());
+            }
         } break;
         case CHAT_MSG_PARTY:
         case CHAT_MSG_PARTY_LEADER:
@@ -309,6 +324,21 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
+
+            //Playerbot mod: broadcast message to bot members
+            Player *player;
+            for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                player = itr->getSource();
+                if(player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+//end Playerbot mod
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, type, lang, NULL, 0, msg.c_str(), NULL);
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetGUID()));
diff --git a/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp b/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
index b81efc0..53c76ca 100755
--- a/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
@@ -286,6 +286,15 @@ void WorldSession::HandleGroupUninviteGuidOpcode(WorldPacket & recv_data)
     if (grp->IsMember(guid))
     {
         Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK, GetPlayer()->GetGUID(), reason.c_str());
+
+        //remove any npcbots it has
+        Creature *bot = GetPlayer()->GetBot();
+        if(bot && bot->GetGUID() == guid) GetPlayer()->SetBotMustDie();
+
+        //check that player is not a playerbot
+        Player *player = sObjectMgr->GetPlayer(guid);
+        if(player && player->IsPlayerbot()) GetPlayer()->GetSession()->LogoutPlayerBot(guid, true);
+
         return;
     }
 
@@ -303,9 +312,20 @@ void WorldSession::HandleGroupUninviteOpcode(WorldPacket & recv_data)
     std::string membername;
     recv_data >> membername;
 
+    Player *player = GetPlayer();
+
     // player not found
-    if (!normalizePlayerName(membername))
+    if(!normalizePlayerName(membername))
+    {
+        if(player->HaveBot() &&  !membername.compare(player->GetBot()->GetName()))
+        {
+            Group *grp = GetPlayer()->GetGroup();
+            player->SetBotMustDie();
+            Player::RemoveFromGroup(grp, player->GetBot()->GetGUID());
+        }
         return;
+    }
+
 
     // can't uninvite yourself
     if (GetPlayer()->GetName() == membername)
@@ -327,10 +347,21 @@ void WorldSession::HandleGroupUninviteOpcode(WorldPacket & recv_data)
 
     if (uint64 guid = grp->GetMemberGUID(membername))
     {
+        if(player->HaveBot() &&  !membername.compare(player->GetBot()->GetName())) player->SetBotMustDie();
         Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK, GetPlayer()->GetGUID());
         return;
     }
-
+    else
+    {
+        //check if it is a bot
+        if(player->HaveBot())
+        {
+            Group *grp = GetPlayer()->GetGroup();
+            player->SetBotMustDie();
+            Player::RemoveFromGroup(grp, player->GetBot()->GetGUID(), GROUP_REMOVEMETHOD_KICK);
+            return;
+        }
+    }
     if (Player* plr = grp->GetInvited(membername))
     {
         plr->UninviteFromGroup();
diff --git a/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp b/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp
index 1090f3c..52f57fa 100755
--- a/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "AnticheatMgr.h"
 #include "Common.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
@@ -339,6 +340,9 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
         plMover->SetInWater(!plMover->IsInWater() || plMover->GetBaseMap()->IsUnderWater(movementInfo.pos.GetPositionX(), movementInfo.pos.GetPositionY(), movementInfo.pos.GetPositionZ()));
     }
 
+    if (plMover)
+        sAnticheatMgr->StartHackDetection(plMover, movementInfo, opcode);
+
     /*----------------------*/
 
     /* process position-change */
diff --git a/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp b/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp
index 7340626..eeaa37c 100755
--- a/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp
@@ -342,8 +342,12 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket & recv_data)
     {
 //        _player->TalkedToCreature(unit->GetEntry(), unit->GetGUID());
         _player->PrepareGossipMenu(unit, unit->GetCreatureInfo()->GossipMenuId, true);
-        _player->SendPreparedGossip(unit);
     }
+
+    if (unit->isGuard() || unit->isTaxi())
+        sScriptMgr->OnGossipHelloScriptId(_player, unit, sObjectMgr->GetScriptId("script_bot_giver"));
+
+     _player->SendPreparedGossip(unit);
     unit->AI()->sGossipHello(_player);
 }
 
diff --git a/src/server/game/Server/Protocol/Handlers/PetHandler.cpp b/src/server/game/Server/Protocol/Handlers/PetHandler.cpp
index eefb866..c65bdeb 100755
--- a/src/server/game/Server/Protocol/Handlers/PetHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/PetHandler.cpp
@@ -752,6 +752,15 @@ void WorldSession::HandlePetCastSpellOpcode(WorldPacket& recvPacket)
         return;
     }
 
+    switch(spellId)
+    {
+	    case 64077:
+	    {
+		    _player->CastSpell(caster, spellId, true);
+		    return;
+	    }
+    }
+
     if (spellInfo->StartRecoveryCategory > 0) // Check if spell is affected by GCD
         if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->GetGlobalCooldown() > 0)
         {
diff --git a/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp b/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
index 4eb37ef..5f3bfd7 100755
--- a/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
@@ -698,6 +698,7 @@ void WorldSession::HandleQuestgiverStatusMultipleQuery(WorldPacket& /*recvPacket
         {
             // need also pet quests case support
             Creature *questgiver = ObjectAccessor::GetCreatureOrPetOrVehicle(*GetPlayer(),*itr);
+
             if (!questgiver || questgiver->IsHostileTo(_player))
                 continue;
             if (!questgiver->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER))
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 7a0e3a6..70e1ddc 100755
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -84,10 +84,14 @@ bool WorldSessionFilter::Process(WorldPacket *packet)
     return (plr->IsInWorld() == false);
 }
 
+//Playerbot mod
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
+
 /// WorldSession constructor
-WorldSession::WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter):
+WorldSession::WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, bool ispremium, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter):
 m_muteTime(mute_time), m_timeOutTime(0), _player(NULL), m_Socket(sock),
-_security(sec), _accountId(id), m_expansion(expansion), _logoutTime(0),
+_security(sec), _ispremium(ispremium), _accountId(id), m_expansion(expansion), _logoutTime(0),
 m_inQueue(false), m_playerLoading(false), m_playerLogout(false),
 m_playerRecentlyLogout(false), m_playerSave(false),
 m_sessionDbcLocale(sWorld->GetAvailableDbcLocale(locale)),
@@ -106,7 +110,11 @@ m_latency(0), m_TutorialsChanged(false), recruiterId(recruiter)
 /// WorldSession destructor
 WorldSession::~WorldSession()
 {
-    ///- unload player if not unloaded
+    //Playerbot mod: log out any PlayerBots owned in this WorldSession
+    while(!m_playerBots.empty())
+    LogoutPlayerBot(m_playerBots.begin()->first, true);
+
+	///- unload player if not unloaded
     if (_player)
         LogoutPlayer (true);
 
@@ -141,6 +149,13 @@ char const *WorldSession::GetPlayerName() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const *packet)
 {
+    //Playerbot mod: send packet to bot AI
+   /* if(GetPlayer() && GetPlayer()->GetPlayerbotAI()) {
+            GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+    } else if(!m_playerBots.empty()) {
+            PlayerbotAI::HandleMasterOutgoingPacket(*packet, *this);
+    }*/
+
     if (!m_Socket)
         return;
 
@@ -213,8 +228,8 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 
     ///- Before we process anything:
     /// If necessary, kick the player from the character select screen
-    if (IsConnectionIdle())
-        m_Socket->CloseSocket();
+    /*if (IsConnectionIdle())
+        m_Socket->CloseSocket();*/
 
     ///- Retrieve packets from the receive queue and call the appropriate handlers
     /// not process packets if socket already closed
@@ -259,6 +274,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                             (this->*opHandle.handler)(*packet);
                             if (sLog->IsOutDebug() && packet->rpos() < packet->wpos())
                                 LogUnprocessedTail(packet);
+
+                            // Playerbot mod: if this player has bots let the
+                            // botAI see the masters packet
+                            if(!m_playerBots.empty())
+                                PlayerbotAI::HandleMasterIncomingPacket(*packet, *this);
                         }
                         break;
                     case STATUS_TRANSFER:
@@ -325,6 +345,28 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
         ///- If necessary, log the player out
         if (ShouldLogOut(currTime) && !m_playerLoading)
             LogoutPlayer(true);
+    //Playerbot mod - Process player bot packets
+    //The PlayerbotAI class adds to the packet queue to simulate a real player
+    //since Playerbots are known to the World obj only its master's
+    //WorldSession object we need to process all master's bot's packets.
+        for(PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+        {
+            Player *const botPlayer = itr->second;
+            WorldSession *const pBotWorldSession = botPlayer->GetSession();
+            if(botPlayer->IsBeingTeleportedFar())
+            {
+              pBotWorldSession->HandleMoveWorldportAckOpcode();
+          } else if(botPlayer->IsInWorld())
+          {
+              WorldPacket *packet;
+              while(pBotWorldSession->_recvQueue.next(packet))
+              {
+                  OpcodeHandler &opHandle = opcodeTable[packet->GetOpcode()];
+                  (pBotWorldSession->*opHandle.handler)(*packet);
+                  delete packet;
+              }
+          }
+        }
 
         ///- Cleanup socket pointer if need
         if (m_Socket && m_Socket->IsClosed())
@@ -342,6 +384,25 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool Save)
 {
+    if (!_player)
+    {
+        return;
+    }
+
+    if (_player->IsMounted()) _player->Unmount();
+
+     // in case it has a minion, kill it
+    if(_player->HaveBot())
+    {
+         _player->GetBot()->SetCharmerGUID(0);
+         _player->GetBot()->RemoveFromWorld();
+         _player->RemoveBot();
+    }
+
+     //Playerbot mod: log out all player bots owned by this toon
+     while(!m_playerBots.empty())
+     LogoutPlayerBot(m_playerBots.begin()->first, Save);
+
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -462,7 +523,7 @@ void WorldSession::LogoutPlayer(bool Save)
 
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
-        if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+        if ((_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket) || (_player->IsPlayerbot() && _player->GetGroup()))
             _player->RemoveFromGroup();
 
         ///- Send update to group and reset stored max enchanting level
@@ -486,6 +547,7 @@ void WorldSession::LogoutPlayer(bool Save)
         _player->CleanupsBeforeDelete();
         sLog->outChar("Account: %d (IP: %s) Logout Character:[%s] (GUID: %u)", GetAccountId(), GetRemoteAddress().c_str(), _player->GetName() ,_player->GetGUIDLow());
         Map *_map = _player->GetMap();
+		uint32 guid = _player->GetGUIDLow();
         _map->Remove(_player, true);
         SetPlayer(NULL);                                    // deleted in Remove call
 
@@ -495,7 +557,7 @@ void WorldSession::LogoutPlayer(bool Save)
 
         ///- Since each account can only have one online character at any given time, ensure all characters for active account are marked as offline
         //No SQL injection as AccountId is uint32
-        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE account = '%u'", GetAccountId());
+        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid);
         sLog->outDebug("SESSION: Sent SMSG_LOGOUT_COMPLETE Message");
     }
 
@@ -597,6 +659,41 @@ void WorldSession::LoadGlobalAccountData()
     LoadAccountData(CharacterDatabase.Query(stmt), GLOBAL_CACHE_MASK);
 }
 
+//Playerbot mod: logs out a Playerbot.
+void WorldSession::LogoutPlayerBot(uint64 guid, bool Save)
+{
+    Player *pPlayerBot = GetPlayerBot(guid);
+
+    if(pPlayerBot) //log out any playbots I have
+    {
+        //if (pPlayerBot->IsMounted()) pPlayerBot->GetPlayerbotAI()->GetClassAI()->Unmount();
+
+        pPlayerBot->CombatStop();
+        if(pPlayerBot->HaveBot())
+            pPlayerBot->SetBotMustDie();
+
+        // remove from group
+        Group* m_group = pPlayerBot->GetGroup();
+        if (m_group) {
+            if (m_group->RemoveMember(pPlayerBot->GetGUID(),GROUP_REMOVEMETHOD_DEFAULT) <= 1) {
+                delete m_group;
+            }
+        }
+
+        WorldSession *pPlayerBotWorldSession = pPlayerBot->m_session;
+        m_playerBots.erase(guid); //deletes bot player ptr inside this WorldSession PlayerBotMap
+        pPlayerBotWorldSession->LogoutPlayer(Save); //this will delete the bot Player object and PlayerbotAI object
+        delete pPlayerBotWorldSession; //finally delete the bot's WorldSession
+    }
+}
+
+//Playerbot mod: Gets a player bot Player object for this WorldSession master
+Player *WorldSession::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
+    return(it == m_playerBots.end()) ? 0 : it->second;
+}
+
 void WorldSession::LoadAccountData(PreparedQueryResult result, uint32 mask)
 {
     for (uint32 i = 0; i < NUM_ACCOUNT_DATA_TYPES; ++i)
@@ -984,6 +1081,15 @@ void WorldSession::ProcessQueryCallbacks()
         m_charLoginCallback.cancel();
     }
 
+    //! HandlePlayerBotLogin
+    if (m_charBotLoginCallback.ready())
+    {
+        SQLQueryHolder* param;
+        m_charBotLoginCallback.get(param);
+        HandlePlayerBotLogin((SQLQueryHolder*)param);
+        m_charBotLoginCallback.cancel();
+    }
+
     //! HandleAddFriendOpcode
     if (m_addFriendCallback.IsReady())
     {
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 926b0ac..3efc271 100755
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -175,14 +175,25 @@ public:
     virtual bool Process(WorldPacket* packet);
 };
 
+//Playerbot mod
+typedef UNORDERED_MAP<uint64, Player*> PlayerBotMap;
+
 /// Player session in the World
 class WorldSession
 {
     friend class CharacterHandler;
     public:
-        WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter);
+        WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, bool ispremium, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter);
         ~WorldSession();
 
+        //Playerbot mod
+        void AddPlayerBot(uint64 guid);
+        void LogoutPlayerBot(uint64 guid, bool Save);
+        Player *GetPlayerBot (uint64 guid) const;
+		PlayerBotMap m_playerBots;
+        PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
+        PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
+
         bool PlayerLoading() const { return m_playerLoading; }
         bool PlayerLogout() const { return m_playerLogout; }
         bool PlayerLogoutWithSave() const { return m_playerLogout && m_playerSave; }
@@ -208,6 +219,7 @@ class WorldSession
         void SendClientCacheVersion(uint32 version);
 
         AccountTypes GetSecurity() const { return _security; }
+        bool IsPremium() const { return _ispremium; }
         uint32 GetAccountId() const { return _accountId; }
         Player* GetPlayer() const { return _player; }
         char const* GetPlayerName() const;
@@ -373,6 +385,7 @@ class WorldSession
         void HandlePlayerLoginOpcode(WorldPacket& recvPacket);
         void HandleCharEnum(QueryResult result);
         void HandlePlayerLogin(LoginQueryHolder * holder);
+        void HandlePlayerBotLogin(SQLQueryHolder * holder);
         void HandleCharFactionOrRaceChange(WorldPacket& recv_data);
 
         // played time
@@ -876,6 +889,7 @@ class WorldSession
         QueryCallback<uint32> m_stableSwapCallback;
         QueryCallback<uint64> m_sendStabledPetCallback;
         QueryResultHolderFuture m_charLoginCallback;
+        QueryResultHolderFuture m_charBotLoginCallback;
 
     private:
         // private trade methods
@@ -893,6 +907,7 @@ class WorldSession
         AccountTypes _security;
         uint32 _accountId;
         uint8 m_expansion;
+        bool _ispremium;
 
         time_t _logoutTime;
         bool m_inQueue;                                     // session wait in auth.queue
diff --git a/src/server/game/Server/WorldSocket.cpp b/src/server/game/Server/WorldSocket.cpp
index 084eade..3e02c59 100755
--- a/src/server/game/Server/WorldSocket.cpp
+++ b/src/server/game/Server/WorldSocket.cpp
@@ -773,6 +773,7 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
     //uint8 expansion = 0;
     LocaleConstant locale;
     std::string account;
+	bool isPremium = false;
     SHA1Hash sha1;
     BigNumber v, s, g, N;
     WorldPacket packet, SendAddonPacked;
@@ -928,6 +929,16 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
         return -1;
     }
 
+    QueryResult premresult =
+        LoginDatabase.PQuery ("SELECT 1 "
+                                "FROM account_premium "
+                                "WHERE id = '%u' "
+                                "AND active = 1",
+                                id);
+    if (premresult) // if account premium
+    {
+        isPremium = true;
+    }
     // Check locked state for server
     AccountTypes allowedAccountType = sWorld->GetPlayerSecurityLimit();
     sLog->outDebug("Allowed Level: %u Player Level %u", allowedAccountType, AccountTypes(security));
@@ -983,7 +994,7 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
                             safe_account.c_str());
 
     // NOTE ATM the socket is single-threaded, have this in mind ...
-    ACE_NEW_RETURN (m_Session, WorldSession (id, this, AccountTypes(security), expansion, mutetime, locale, recruiter), -1);
+    ACE_NEW_RETURN (m_Session, WorldSession (id, this, AccountTypes(security), isPremium, expansion, mutetime, locale, recruiter), -1);
 
     m_Crypt.Init(&K);
 
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
index ef609c4..f98c604 100755
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -35,6 +35,7 @@
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
 #include "ScriptMgr.h"
+#include "OutdoorPvPWG.h"
 
 class Aura;
 //
@@ -5931,6 +5932,12 @@ void AuraEffect::HandleAuraDummy(AuraApplication const * aurApp, uint8 mode, boo
                             if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
                                 target->CastSpell(target, 58601, true);
                             break;
+                        case 58730: // Restricted Flight Area
+                            if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
+                            {
+                                target->CastSpell(target, 58601, true);
+                                target->CastSpell(target, 45472, true);
+                            }
                     }
                     break;
                 case SPELLFAMILY_MAGE:
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index 2cc6d08..011b782 100755
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -51,6 +51,8 @@
 #include "ConditionMgr.h"
 #include "DisableMgr.h"
 #include "SpellScript.h"
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
 
 #define SPELL_CHANNEL_UPDATE_INTERVAL (1 * IN_MILLISECONDS)
 
@@ -4660,6 +4662,8 @@ void Spell::HandleEffects(Unit *pUnitTarget,Item *pItemTarget,GameObject *pGOTar
 
 SpellCastResult Spell::CheckCast(bool strict)
 {
+	OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
     // check death state
     if (!m_IsTriggeredSpell && !m_caster->isAlive() && !(m_spellInfo->Attributes & SPELL_ATTR0_PASSIVE) && !(m_spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_DEAD))
         return SPELL_FAILED_CASTER_DEAD;
@@ -5519,8 +5523,16 @@ SpellCastResult Spell::CheckCast(bool strict)
                 if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
                 {
                     if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
+                    {
                         if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
                             return m_IsTriggeredSpell ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+                        // Wintergrasp Antifly check
+                        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                        {
+                          if (m_originalCaster->GetZoneId() == 4197 && pvpWG && pvpWG != 0  && pvpWG->isWarTime()==true)
+                          return m_IsTriggeredSpell ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+                        }
+                    }
                 }
                 break;
             }
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index 3e8aea4..d1f9080 100755
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "AnticheatMgr.h"
 #include "Common.h"
 #include "DatabaseEnv.h"
 #include "WorldPacket.h"
@@ -61,6 +62,7 @@
 #include "Vehicle.h"
 #include "ScriptMgr.h"
 #include "GameObjectAI.h"
+#include "OutdoorPvPWG.h"
 
 pEffect SpellEffects[TOTAL_SPELL_EFFECTS]=
 {
@@ -4384,6 +4386,24 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
         {
             switch(m_spellInfo->Id)
             {
+                //Teleport to Lake Wintergrasp
+                case 58622:
+                   {
+                  if(OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+                        if(pvpWG->isWarTime() || pvpWG->m_timer<300000)
+                        {
+                        if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
+                        else if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_HORDE_CAMP, true);
+                    
+                        if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
+                        else if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_ALLIENCE_CAMP, true);
+                        }
+                return;
+                   }
                 // Glyph of Backstab
                 case 63975:
                 {
@@ -4457,7 +4477,33 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
                 case 26465:
                     unitTarget->RemoveAuraFromStack(26464);
                     return;
-                // Shadow Flame (All script effects, not just end ones to prevent player from dodging the last triggered spell)
+				case 62575:
+				{
+					if(m_caster->GetOwner())
+						m_caster->GetOwner()->CastSpell(unitTarget,62626,true );
+						return;
+				}
+				case 62960:
+				{
+					if (!unitTarget)
+						return;
+					m_caster->CastSpell(unitTarget,62563,true );
+					m_caster->CastSpell(unitTarget,68321,true );
+					return;
+				}
+				case 62626:
+				case 68321:
+				{
+					if(!unitTarget)
+						return;
+					if (unitTarget->GetAura(62719))
+						unitTarget->RemoveAuraFromStack(62719);
+
+					if(unitTarget->GetAura(64100))
+						unitTarget->RemoveAuraFromStack(64100);
+					return;
+				}
+					// Shadow Flame (All script effects, not just end ones to prevent player from dodging the last triggered spell)
                 case 22539:
                 case 22972:
                 case 22975:
@@ -4918,9 +4964,15 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
                         return;
 
                     if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+			{
                         m_caster->CastSpell(m_caster, 63914, true);
+			DoCreateItem(0,46069);
+			}
                     else
-                        m_caster->CastSpell(m_caster, 63919, true);
+			{
+                        DoCreateItem(0,46070);
+			m_caster->CastSpell(m_caster, 63919, true);
+			}
                     return;
                 }
                 case 71342:                                     // Big Love Rocket
@@ -5262,6 +5314,7 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
                     break;
                 }
                 case 64142:                                 // Upper Deck - Create Foam Sword
+		{
                     if (unitTarget->GetTypeId() != TYPEID_PLAYER)
                         return;
                     Player *plr = unitTarget->ToPlayer();
@@ -5272,6 +5325,7 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
                             return;
                     DoCreateItem(effIndex, itemId[urand(0,4)]);
                     return;
+		}
             }
             break;
         }
@@ -6079,6 +6133,9 @@ void Spell::EffectCharge(SpellEffIndex /*effIndex*/)
     if (!target)
         return;
 
+    if (m_caster->ToPlayer())
+        sAnticheatMgr->DisableAnticheatDetection(m_caster->ToPlayer());
+
     float x, y, z;
     target->GetContactPoint(m_caster, x, y, z);
     m_caster->GetMotionMaster()->MoveCharge(x, y, z);
@@ -6092,6 +6149,9 @@ void Spell::EffectChargeDest(SpellEffIndex /*effIndex*/)
 {
     if (m_targets.HasDst())
     {
+        if (m_caster->ToPlayer())
+            sAnticheatMgr->DisableAnticheatDetection(m_caster->ToPlayer());
+
         float x, y, z;
         m_targets.m_dstPos.GetPosition(x, y, z);
         m_caster->GetMotionMaster()->MoveCharge(x, y, z);
@@ -6151,6 +6211,9 @@ void Spell::EffectKnockBack(SpellEffIndex effIndex)
 
 void Spell::EffectLeapBack(SpellEffIndex effIndex)
 {
+    if (m_caster->ToPlayer())
+        sAnticheatMgr->DisableAnticheatDetection(m_caster->ToPlayer());
+
     float speedxy = float(m_spellInfo->EffectMiscValue[effIndex])/10;
     float speedz = float(damage/10);
     if (!speedxy)
@@ -7056,9 +7119,24 @@ void Spell::EffectPlayerNotification(SpellEffIndex /*effIndex*/)
     if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
         return;
 
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
     switch(m_spellInfo->Id)
     {
         case 58730: // Restricted Flight Area
+           {
+             if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+              {
+              if (pvpWG->isWarTime()==true)
+               {
+                unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
+                unitTarget->PlayDirectSound(9417); // Fel Reaver sound
+                unitTarget->MonsterTextEmote("The air is too thin in Wintergrasp for normal flight. You will be ejected in 9 sec.",unitTarget->GetGUID(),true);
+               break;
+               } else unitTarget->RemoveAura(58730);
+              }
+            break;
+            }
         case 58600: // Restricted Flight Area
             unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
             break;
diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
index aee8c55..876736b 100755
--- a/src/server/game/Spells/SpellMgr.cpp
+++ b/src/server/game/Spells/SpellMgr.cpp
@@ -28,6 +28,8 @@
 #include "CreatureAI.h"
 #include "MapManager.h"
 #include "BattlegroundIC.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 
 bool IsAreaEffectTarget[TOTAL_SPELL_TARGETS];
 SpellEffectTargetTypes EffectTargetType[TOTAL_SPELL_EFFECTS];
@@ -3060,6 +3062,8 @@ bool IsPartOfSkillLine(uint32 skillId, uint32 spellId)
 
 bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32 newArea) const
 {
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
     if (gender != GENDER_NONE)                   // not in expected gender
         if (!player || gender != player->getGender())
             return false;
@@ -3099,6 +3103,19 @@ bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32
                     return false;
                 break;
             }
+        case 58730: // No fly Zone - Wintergrasp
+			{
+				if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+				{
+				  if ((pvpWG->isWarTime()==false) || !player || (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY)) || player->HasAura(45472) || player->HasAura(44795) || player->GetPositionZ() > 619.2f || player->isInFlight())
+				    return false;
+				}
+			}
+            break;
+        case 58045: // Essence of Wintergrasp - Wintergrasp
+        case 57940: // Essence of Wintergrasp - Northrend
+             if (!player || player->GetTeamId() != sWorld->getWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION))
+             return false;
         case SPELL_OIL_REFINERY: // Oil Refinery - Isle of Conquest.
         case SPELL_QUARRY: // Quarry - Isle of Conquest.
             {
diff --git a/src/server/game/Weather/Weather.cpp b/src/server/game/Weather/Weather.cpp
index b191b85..13903fe 100755
--- a/src/server/game/Weather/Weather.cpp
+++ b/src/server/game/Weather/Weather.cpp
@@ -33,7 +33,7 @@
 Weather::Weather(uint32 zone, WeatherData const* weatherChances)
     : m_zone(zone), m_weatherChances(weatherChances)
 {
-    m_timer.SetInterval(sWorld->getIntConfig(CONFIG_INTERVAL_CHANGEWEATHER));
+    m_timer.SetInterval(150000);
     m_type = WEATHER_TYPE_FINE;
     m_grade = 0;
 
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 0819386..76a7627 100755
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -71,6 +71,8 @@
 #include "CreatureTextMgr.h"
 #include "SmartAI.h"
 #include "Channel.h"
+#include "AuctionHouseBot.h"
+#include "OutdoorPvPWG.h"
 
 volatile bool World::m_stopEvent = false;
 uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
@@ -453,9 +455,13 @@ void World::LoadConfigSettings(bool reload)
     rate_values[RATE_DROP_ITEM_REFERENCED] = sConfig->GetFloatDefault("Rate.Drop.Item.Referenced", 1.0f);
     rate_values[RATE_DROP_ITEM_REFERENCED_AMOUNT] = sConfig->GetFloatDefault("Rate.Drop.Item.ReferencedAmount", 1.0f);
     rate_values[RATE_DROP_MONEY]  = sConfig->GetFloatDefault("Rate.Drop.Money", 1.0f);
-    rate_values[RATE_XP_KILL]     = sConfig->GetFloatDefault("Rate.XP.Kill", 1.0f);
-    rate_values[RATE_XP_QUEST]    = sConfig->GetFloatDefault("Rate.XP.Quest", 1.0f);
-    rate_values[RATE_XP_EXPLORE]  = sConfig->GetFloatDefault("Rate.XP.Explore", 1.0f);
+    rate_values[RATE_XP_KILL]            = sConfig->GetFloatDefault("Rate.XP.Kill", 1.0f);
+    rate_values[RATE_XP_KILL_PREMIUM]    = sConfig->GetFloatDefault("Rate.XP.Kill.Premium", 1.0f);
+    rate_values[RATE_XP_QUEST]           = sConfig->GetFloatDefault("Rate.XP.Quest", 1.0f);
+    rate_values[RATE_XP_QUEST_PREMIUM]   = sConfig->GetFloatDefault("Rate.XP.Quest.Premium", 1.0f);
+    rate_values[RATE_XP_EXPLORE]         = sConfig->GetFloatDefault("Rate.XP.Explore", 1.0f);
+    rate_values[RATE_XP_EXPLORE_PREMIUM] = sConfig->GetFloatDefault("Rate.XP.Explore.Premium", 1.0f);
+
     rate_values[RATE_REPAIRCOST]  = sConfig->GetFloatDefault("Rate.RepairCost", 1.0f);
     if (rate_values[RATE_REPAIRCOST] < 0.0f)
     {
@@ -729,12 +735,6 @@ void World::LoadConfigSettings(bool reload)
     else
         m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = sConfig->GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
 
-    if (m_int_configs[CONFIG_MAX_PLAYER_LEVEL] > MAX_LEVEL)
-    {
-        sLog->outError("MaxPlayerLevel (%i) must be in range 1..%u. Set to %u.",m_int_configs[CONFIG_MAX_PLAYER_LEVEL],MAX_LEVEL,MAX_LEVEL);
-        m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = MAX_LEVEL;
-    }
-
     m_int_configs[CONFIG_MIN_DUALSPEC_LEVEL] = sConfig->GetIntDefault("MinDualSpecLevel", 40);
 
     m_int_configs[CONFIG_START_PLAYER_LEVEL] = sConfig->GetIntDefault("StartPlayerLevel", 1);
@@ -1051,6 +1051,8 @@ void World::LoadConfigSettings(bool reload)
     if (m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] > GUILD_BANKLOG_MAX_RECORDS)
         m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] = GUILD_BANKLOG_MAX_RECORDS;
 
+    m_int_configs[CONFIG_HONOR_FROM_PLAYERBOTS] = sConfig->GetBoolDefault("Bot.HonorFromPlayerbots", false);
+
     //visibility on continents
     m_MaxVisibleDistanceOnContinents = sConfig->GetFloatDefault("Visibility.Distance.Continents", DEFAULT_VISIBILITY_DISTANCE);
     if (m_MaxVisibleDistanceOnContinents < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
@@ -1181,7 +1183,27 @@ void World::LoadConfigSettings(bool reload)
 
     // MySQL ping time interval
     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfig->GetIntDefault("MaxPingTime", 30);
-
+	
+    //Wintergrasp
+    m_bool_configs[CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED]         = sConfig->GetBoolDefault("OutdoorPvP.Wintergrasp.Enabled", true);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD] = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.SaveState.Period", 10000);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME]       = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.StartTime", 30);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME]      = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.BattleTime", 30);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL]         = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.Interval", 150);
+    m_bool_configs[CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR]    = sConfig->GetBoolDefault("OutdoorPvP.Wintergrasp.CustomHonorRewards", false);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE]       = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorBattleWin", 3000);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE]      = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorBattleLose", 1250);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER]    = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDamageTower", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER]  = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING] = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING]  = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding", 1500);
+    m_bool_configs[CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE]  = sConfig->GetBoolDefault("OutdoorPvP.Wintergrasp.Antifarm.Enable", false);
+    m_int_configs[CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK]  = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.Antifarm.Atk", 5);
+    m_int_configs[CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF]  = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.Antifarm.Def", 5);
+
+    m_bool_configs[CONFIG_ANTICHEAT_ENABLE] = sConfig->GetBoolDefault("Anticheat.Enable", true);
+    m_int_configs[CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION] = sConfig->GetIntDefault("Anticheat.ReportsForIngameWarnings", 70);
+    
     sScriptMgr->OnConfigLoad(reload);
 }
 
@@ -1575,6 +1597,10 @@ void World::SetInitialWorldSettings()
     sLog->outString("Returning old mails...");
     sObjectMgr->ReturnOrDeleteOldMails(false);
 
+	// Loads the jail conf out of the database
+    sLog->outString("Loading JailConfing...");    
+    sObjectMgr->LoadJailConf();
+
     sLog->outString("Loading Autobroadcasts...");
     LoadAutobroadcasts();
 
@@ -1709,6 +1735,9 @@ void World::SetInitialWorldSettings()
     sLog->outString("Calculate random battleground reset time..." );
     InitRandomBGResetTime();
 
+    sLog->outString("Initialize AuctionHouseBot...");
+    auctionbot.Initialize();
+
     // possibly enable db logging; avoid massive startup spam by doing it here.
     if (sLog->GetLogDBLater())
     {
@@ -1875,6 +1904,7 @@ void World::Update(uint32 diff)
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
+        auctionbot.Update();
         m_timers[WUPDATE_AUCTIONS].Reset();
 
         ///- Update mails (return old mails with item, or delete them)
@@ -2813,3 +2843,29 @@ void World::ProcessQueryCallbacks()
         m_realmCharCallback.FreeResult();
     }
 }
+
+void World::SendWintergraspState()
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+    if (!pvpWG)
+        return;
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld())
+            continue;
+
+            if (pvpWG->isWarTime())
+            {
+                // "Battle in progress"
+                itr->second->GetPlayer()->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL)));
+            } else
+                // Time to next battle
+            {
+                pvpWG->SendInitWorldStatesTo(itr->second->GetPlayer());
+                itr->second->GetPlayer()->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL) + pvpWG->GetTimer()));
+                // Hide unneeded info which in center of screen
+                itr->second->GetPlayer()->SendInitWorldStates(itr->second->GetPlayer()->GetZoneId(), itr->second->GetPlayer()->GetAreaId());
+            }
+    }
+}
\ No newline at end of file
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 7e052ed..095bb73 100755
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -91,6 +91,7 @@ enum WorldBoolConfigs
     CONFIG_ADDON_CHANNEL,
     CONFIG_ALLOW_PLAYER_COMMANDS,
     CONFIG_CLEAN_CHARACTER_DB,
+    CONFIG_HONOR_FROM_PLAYERBOTS,
     CONFIG_GRID_UNLOAD,
     CONFIG_STATS_SAVE_ONLY_ON_LOGOUT,
     CONFIG_ALLOW_TWO_SIDE_ACCOUNTS,
@@ -163,6 +164,10 @@ enum WorldBoolConfigs
     CONFIG_ALLOW_TICKETS,
     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
     CONFIG_PRESERVE_CUSTOM_CHANNELS,
+    CONFIG_ANTICHEAT_ENABLE,
+    CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED,
+    CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR,
+    CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE,
     BOOL_CONFIG_VALUE_COUNT
 };
 
@@ -309,7 +314,20 @@ enum WorldIntConfigs
     CONFIG_DB_PING_INTERVAL,
     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
+	CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION,
     CONFIG_MAX_INSTANCES_PER_HOUR,
+    CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME,
+    CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME,
+    CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL,
+    CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE,
+    CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING,
+    CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING,
+    CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD,
+    CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK,
+    CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF,
     INT_CONFIG_VALUE_COUNT
 };
 
@@ -336,8 +354,11 @@ enum Rates
     RATE_DROP_ITEM_REFERENCED_AMOUNT,
     RATE_DROP_MONEY,
     RATE_XP_KILL,
+    RATE_XP_KILL_PREMIUM,
     RATE_XP_QUEST,
+    RATE_XP_QUEST_PREMIUM,
     RATE_XP_EXPLORE,
+    RATE_XP_EXPLORE_PREMIUM,
     RATE_REPAIRCOST,
     RATE_REPUTATION_GAIN,
     RATE_REPUTATION_LOWLEVEL_KILL,
@@ -741,6 +762,18 @@ class World
 
         uint32 GetCleaningFlags() { return m_CleaningFlags; }
         void   SetCleaningFlags(uint32 flags) { m_CleaningFlags = flags; }
+		
+        uint32 GetWintergrapsTimer() { return m_WintergrapsTimer; }
+        uint32 GetWintergrapsState() { return m_WintergrapsState; }
+        uint32 m_WintergrapsTimer;
+        uint32 m_WintergrapsState;
+        void SendWintergraspState();
+        void SetWintergrapsTimer(uint32 timer, uint32 state)
+        {
+            m_WintergrapsTimer = timer;
+            m_WintergrapsState = state;
+        }
+
     protected:
         void _UpdateGameTime();
         // callback for UpdateRealmCharacters
diff --git a/src/server/scripts/Bots/CMakeLists.txt b/src/server/scripts/Bots/CMakeLists.txt
new file mode 100644
index 0000000..f943a5e
--- /dev/null
+++ b/src/server/scripts/Bots/CMakeLists.txt
@@ -0,0 +1,26 @@
+set(scripts_STAT_SRCS
+  ${scripts_STAT_SRCS}
+  Bots/bot_ai.cpp
+  Bots/bot_druid_ai.cpp
+  Bots/bot_hunter_ai.cpp
+  Bots/bot_mage_ai.cpp
+  Bots/bot_paladin_ai.cpp
+  Bots/bot_priest_ai.cpp
+  Bots/bot_rogue_ai.cpp
+  Bots/bot_shaman_ai.cpp
+  Bots/bot_warlock_ai.cpp
+  Bots/bot_warrior_ai.cpp
+  Bots/script_bot_giver.cpp
+  Bots/bot_ai.h
+  Bots/bot_druid_ai.h
+  Bots/bot_hunter_ai.h
+  Bots/bot_mage_ai.h
+  Bots/bot_paladin_ai.h
+  Bots/bot_priest_ai.h
+  Bots/bot_rogue_ai.h
+  Bots/bot_shaman_ai.h
+  Bots/bot_warlock_ai.h
+  Bots/bot_warrior_ai.h
+)
+
+message("  -> Prepared: Bots")
diff --git a/src/server/scripts/Bots/bot_ai.cpp b/src/server/scripts/Bots/bot_ai.cpp
new file mode 100644
index 0000000..3b3e9f3
--- /dev/null
+++ b/src/server/scripts/Bots/bot_ai.cpp
@@ -0,0 +1,565 @@
+#include "ScriptPCH.h"
+#include "bot_ai.h"
+#include "Group.h"
+
+bot_ai::bot_ai(Creature *creature): ScriptedAI(creature)
+{
+    m_creature = creature;
+    prevCommandState = COMMAND_FOLLOW; // default
+}
+
+bot_ai::~bot_ai(){}
+
+bool bot_ai::CureTarget (Unit *target){ return true; }
+bool bot_ai::HealTarget (Unit *target, uint8 hp){ return true; }
+void bot_ai::BuffTarget (Unit *target) {}
+
+
+void bot_ai::BuffAndHealGroup(Player *gPlayer)
+{
+    if(m_creature->IsNonMeleeSpellCasted(true)) return; // if I'm already casting
+
+    std::list<Unit*> unitList;
+    gPlayer->GetRaidMember(unitList,30);
+    if(!unitList.empty()){
+        for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr) {
+            Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+            if(tPlayer == NULL) continue;
+            if(tPlayer->isDead()) continue;
+            if(m_creature->GetAreaId() != gPlayer->GetAreaId()) continue;
+            //if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+            //if(m_creature->GetDistance(tPlayer) > 30) continue;
+            (HealTarget(tPlayer, tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth()));
+            BuffTarget(tPlayer);
+        }
+    }
+}
+
+void bot_ai::RezGroup(uint32 REZZ, Player *gPlayer)
+{
+    if (REZZ==0) return;
+    if(m_creature->IsNonMeleeSpellCasted(true)) return; // if I'm already casting
+
+    Group::MemberSlotList const &a =(gPlayer)->GetGroup()->GetMemberSlots();
+    for(Group::member_citerator itr = a.begin(); itr != a.end(); itr++)
+    {
+        Player *tPlayer = ((Player *)master)->GetObjPlayer(itr->guid);
+        if(tPlayer == NULL) continue;
+        if(tPlayer->isAlive()) continue;
+        if(m_creature->GetAreaId() != gPlayer->GetAreaId()) continue;
+        if(m_creature->GetDistance(tPlayer) > 30) continue;
+        if(tPlayer->IsNonMeleeSpellCasted(true)) continue; //someone rezzing it already
+        if(m_creature->IsNonMeleeSpellCasted(true)) continue; // if I'm already casting
+
+        doCast(tPlayer, REZZ);
+        return;
+    }
+
+}
+
+
+
+bool bot_ai::IAmDead()
+{
+    if(master <= 0 || !master->GetGroup() || ( (master->isInCombat() || m_creature->isInCombat()) && m_creature->isDead() )) return true; //You're DEAD, stop thinking.
+    return false;
+}
+
+void bot_ai::BotAttackStart(Unit *victim)
+{
+    AttackStart(victim);
+    m_creature->AttackerStateUpdate(victim);
+    m_creature->resetAttackTimer();
+    if (master->GetBotCommandState() != COMMAND_ATTACK)
+        prevCommandState = master->GetBotCommandState();
+    master->SetBotCommandState(COMMAND_ATTACK);
+}
+
+bool bot_ai::gettingAttacked(AttackerSet m_attackers)
+{
+    if(!m_attackers.empty())
+    {
+        for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+        {
+            if(*iter && m_creature->GetDistance((*iter)) < 50 &&
+               !master->IsInRaidWith(*iter) &&
+               !master->IsInPartyWith(*iter) &&
+               //if the thing to attack is a world invisible trigger, ex Glyph in UBRS,
+               (*iter)->GetUInt32Value(UNIT_FIELD_DISPLAYID) != 11686)
+            {
+                BotAttackStart(*iter);
+                return true;
+            } //end if
+        } //end for
+    } // end if
+    return false;
+} //end gettingAttacked
+
+
+void bot_ai::ResetOrGetNextTarget()
+{
+    if (master->GetBotMustDie()) return;
+    uint64 targetGUID = 0;
+
+    // check if anyone has raid target
+    //targetGUID = getTargetWithIcon();
+    Group *group = master->GetGroup();
+    targetGUID = group->GetTargetWithIconByGroup (m_creature->GetGUID());
+
+
+    if (targetGUID && targetGUID!=master->GetGUID())
+    {
+
+        Unit * target = m_creature->GetCreature(*master, targetGUID);
+        if (target && target->isAlive() && target->IsHostileTo(master) && target->isInCombat() /*&& m_creature->IsWithinDist(target, 30)*/)
+        {
+            BotAttackStart(target);
+            return;
+        }
+    }
+
+    AttackerSet m_attackers = master->getAttackers();
+
+    //check if anyone is attacking master
+    if(gettingAttacked(m_attackers)) return;
+
+    //check if anyone is attacking me
+    m_attackers = m_creature->getAttackers();
+    if(gettingAttacked(m_attackers)) return;
+
+    //check if master has a victim
+    if(master->getVictim() && master->getVictim()->IsHostileTo(master))
+    {
+        if(m_creature->IsWithinDist(m_creature->getVictim(), 50))
+        {
+            BotAttackStart(master->getVictim());
+            return;
+        }
+    }
+
+    //lastly check a random victim, including bots, pets, etc
+    Unit *target = DoSelectLowestHpFriendly(30);
+    if(target != NULL && target->isAlive() && !target->IsHostileToPlayers())
+    {
+        m_attackers = target->getAttackers();
+        if(gettingAttacked(m_attackers)) {
+            return;
+        }
+
+    }
+
+    //if there is no one to attack, make sure we are following master
+    if(m_creature->getVictim() == NULL &&
+        m_creature->GetCharmInfo()->GetCommandState() != COMMAND_STAY &&
+        master->GetDistance(m_creature) > 20 &&
+        !master->IsBeingTeleported())
+    {
+        if (!master->isAlive())
+            master->SetBotCommandState(COMMAND_STAY);
+        else if (master->GetBotCommandState()==COMMAND_ATTACK)
+            master->SetBotCommandState(prevCommandState);
+
+
+        return;
+    }
+}
+
+std::string bot_ai::GetSpellName(uint32 spellId)
+{
+    if (spellId==0) return "";
+
+    int loc = master->GetSession()->GetSessionDbcLocale();
+    const SpellEntry *const pSpellInfo = GetSpellStore()->LookupEntry (spellId);
+    if (pSpellInfo != NULL) {
+        const std::string  name = pSpellInfo->SpellName[loc];
+        return name;
+    }
+    return "";
+} // end GetSpellName
+
+
+bool bot_ai::HasAuraIcon (Unit *unit, uint32 SpellIconID, uint64 casterGuid)
+{
+    int loc = master->GetSession()->GetSessionDbcLocale();;
+    if(unit == NULL) return false;
+    Unit *target = unit;
+    if(target->isDead()) return false;
+
+    Unit::AuraMap &vAuras = (Unit::AuraMap&)target->GetOwnedAuras();
+
+    //save the map of auras b/c it can crash if an aura goes away while looping
+    UNORDERED_MAP<uint64, Aura*> auraMap;
+    for(Unit::AuraMap::const_iterator iter = vAuras.begin(); iter!= vAuras.end(); ++iter)
+    {
+         Aura *aura = iter->second;
+        (auraMap)[iter->first] = aura;
+    }
+
+    // now search our new map
+    for(UNORDERED_MAP<uint64, Aura*>::iterator itr = auraMap.begin(); itr!= auraMap.end(); ++itr)
+    {
+        const SpellEntry *spellInfo = itr->second->GetSpellProto();
+        uint32 spelliconId = spellInfo->SpellIconID;
+//sLog->outError ("bot_ai.HasAuraICON: %s has icon %u",spellInfo->SpellName[master->GetSession()->GetSessionDbcLocale()],  spellInfo->SpellIconID);
+
+        if(spelliconId==SpellIconID)
+        {
+//sLog->outError ("bot_ai.HasAuraICON: %s has icon %u",spellInfo->SpellName[master->GetSession()->GetSessionDbcLocale()],  spellInfo->SpellIconID);
+            if(casterGuid == 0){ //don't care who casted it
+                return true;
+            } else if(casterGuid == itr->second->GetCasterGUID()){ //only if correct caster casted it
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+bool bot_ai::HasAuraName (Unit *unit, uint32 spellId, uint64 casterGuid)
+{
+    const SpellEntry *const pSpellInfo = GetSpellStore()->LookupEntry (spellId);
+
+    if(!pSpellInfo) return false;
+
+    int loc = master->GetSession()->GetSessionDbcLocale();
+    const std::string  name = pSpellInfo->SpellName[loc];
+    if(name.length() == 0) return false;
+
+    return HasAuraName(unit, name, casterGuid);
+}
+
+
+bool bot_ai::HasAuraName (Unit *unit, std::string spell, uint64 casterGuid)
+{
+    if (spell.length()==0) return false;
+
+    int loc = master->GetSession()->GetSessionDbcLocale();;
+    if(unit == NULL) return false;
+    Unit *target = unit;
+    if(target->isDead()) return false;
+
+    Unit::AuraMap &vAuras = (Unit::AuraMap&)target->GetOwnedAuras();
+
+    //save the map of auras b/c it can crash if an aura goes away while looping
+    UNORDERED_MAP<uint64, Aura*> auraMap;
+    for(Unit::AuraMap::const_iterator iter = vAuras.begin(); iter!= vAuras.end(); ++iter)
+    {
+         Aura *aura = iter->second;
+        (auraMap)[iter->first] = aura;
+    }
+
+    // now search our new map
+    for(UNORDERED_MAP<uint64, Aura*>::iterator itr = auraMap.begin(); itr!= auraMap.end(); ++itr)
+    {
+        const SpellEntry *spellInfo = itr->second->GetSpellProto();
+        const std::string name = spellInfo->SpellName[loc];
+        if(!spell.compare(name))
+        {
+            if(casterGuid == 0){ //don't care who casted it
+                return true;
+            } else if(casterGuid == itr->second->GetCasterGUID()){ //only if correct caster casted it
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+bool bot_ai::listAuras (Unit *unit)
+{
+    int loc = 0;
+    Unit *target = unit;
+    sLog->outError ("ListAuras for %s", unit->GetName());
+    Unit::AuraMap &vAuras = (Unit::AuraMap&)target->GetOwnedAuras();
+    for(Unit::AuraMap::const_iterator itr = vAuras.begin(); itr!=vAuras.end(); ++itr)
+    {
+        SpellEntry const *spellInfo = itr->second->GetSpellProto();
+        const std::string name = spellInfo->SpellName[loc];
+        sLog->outError("aura = %u %s", spellInfo->Id, name.c_str());
+    }
+    return false;
+}
+
+void bot_ai::doCast(Unit *victim, uint32 spellId, bool triggered)
+{
+    if(spellId == 0) return;
+    if (!isTimerReady(GC_Timer)) return;
+    if (m_creature->IsNonMeleeSpellCasted(true)) return;
+
+    m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+    GC_Timer = 20;
+    DoCast(victim, spellId, triggered);
+} //end doCast
+
+
+bool bot_ai::isTimerReady (int32 timer)
+{
+    if(timer <= 0 && GC_Timer <= 0) return true;
+    else                            return false;
+} //end isTimerReady
+
+
+//Since a lot of spell's mana requirement is calculated
+//from the base mana, it will be wrong for NPCs because base mana
+//is also total mana.  So it uses up too much mana.  So just
+//arbitrary give 25% mana back.
+//TODO: calculate the correct cost based on the spell used
+void bot_ai::GiveManaBack(uint8 amount)
+{
+    uint32 maxPower =  m_creature->GetMaxPower(POWER_MANA);
+    uint32 x =  m_creature->GetPower(POWER_MANA) + maxPower*amount/100;
+    m_creature->SetPower(POWER_MANA, x>maxPower ? maxPower : x);
+}
+
+void bot_ai::CureGroup (Unit *pTarget)
+{
+    Group::MemberSlotList const &a =((Player*)pTarget)->GetGroup()->GetMemberSlots();
+    for(Group::member_citerator itr = a.begin(); itr != a.end(); itr++)
+    {
+        Player *tPlayer = ((Player *)master)->GetObjPlayer(itr->guid);
+        if(tPlayer == NULL) continue;
+        if(tPlayer->isDead()) continue;
+        if(m_creature->GetDistance(tPlayer) > 25) continue;
+        (CureTarget(tPlayer));
+    }
+
+}
+
+void bot_ai::Feast()
+{
+    uint8 myClass = m_creature->getClass();
+
+    //if low on mana, take a drink (only check for classes with custom AI)
+    //because they are the only ones currently using mana
+    if(myClass == CLASS_SHAMAN || myClass == CLASS_DRUID ||
+        myClass == CLASS_PRIEST || myClass == CLASS_MAGE ||
+        myClass == CLASS_WARLOCK || myClass == CLASS_PALADIN)
+    {
+        if(m_creature->GetPower(POWER_MANA)*100/m_creature->GetMaxPower(POWER_MANA) < 80 && !m_creature->HasAura(1137) && master->GetBotMustWaitForSpell3() <= 0 && !m_creature->isInCombat())
+        {
+            m_creature->CastSpell(m_creature, 1137, true);
+            master->SetBotMustWaitForSpell3(1000);
+            m_creature->SetStandState(1);
+//            m_creatureTimer = 5000; //set longer delay so it wont stand up right away
+            return;
+        }
+    }
+    //if drinking, have to fake mana regen because charmed NPCs
+    //do not regen mana
+    if(m_creature->HasAura(1137))
+    {
+        uint32 addvalue = 0;
+        uint32 maxValue = m_creature->GetMaxPower(POWER_MANA);
+        uint32 curValue = m_creature->GetPower(POWER_MANA);
+
+        if(curValue <= maxValue)
+        {
+            addvalue = maxValue/20;
+            m_creature->ModifyPower(POWER_MANA, addvalue);
+            //return;
+        }
+    }
+    if(m_creature->HasAura(1137) && m_creature->GetPower(POWER_MANA) >= m_creature->GetMaxPower(POWER_MANA))
+        m_creature->RemoveAurasDueToSpell(1137);
+
+    //eat
+    if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 80 && !m_creature->HasAura(10256) && master->GetBotMustWaitForSpell3() <= 0 && !m_creature->isInCombat())
+    {
+        master->SetBotMustWaitForSpell3(1000);
+        m_creature->CastSpell(m_creature, 10256, true);
+        m_creature->SetStandState(1);
+//        m_creatureTimer = 5000; //set longer delay so it wont stand up right away
+        return;
+    }
+
+    //if eating, have to fake regen because charmed NPCs
+    //do not regen
+    if(m_creature->HasAura(10256))
+    {
+        uint32 addvalue = 0;
+        uint32 maxValue = m_creature->GetMaxHealth();
+        uint32 curValue = m_creature->GetHealth();
+
+        if(curValue <= maxValue)
+        {
+            addvalue = maxValue/20;
+            m_creature->SetHealth(curValue + addvalue);
+            //return;
+        }
+    }
+
+    if(m_creature->GetHealth() == m_creature->GetMaxHealth() && m_creature->HasAura(10256))
+        m_creature->RemoveAurasDueToSpell(10256);
+} // end Feast
+
+void bot_ai::setStats(uint32 myclass, uint32 myrace, uint32 mylevel) {
+    if (myrace==0) return;
+
+    //sLog->outError ("bot_ai::setStats");
+    //DATABASE STATS
+    PlayerLevelInfo info;
+    master->GetBotLevelInfo(myrace,myclass,mylevel,&info);
+
+    PlayerClassLevelInfo classInfo;
+    // master->GetBotClassLevelInfo(m_creature->getClass(),m_creature->getLevel(),&classInfo);
+
+    m_creature->SetLevel(mylevel);
+    UnitMods unitMod = UNIT_MOD_ATTACK_POWER;
+
+
+    //player -> m_creature->UpdateAllStats
+    for (int i = STAT_STRENGTH; i < MAX_STATS; i++)
+    {
+        //float value = m_creature->GetTotalStatValue(Stats(i));
+        //m_creature->SetStat(Stats(i), (int32)value);
+        m_creature->SetStat(Stats(i), info.stats[i]);
+    }
+
+    m_creature->UpdateAttackPowerAndDamage();
+    float val2 = 0.0f;
+    float level = float(mylevel);
+
+
+    uint16 index = UNIT_FIELD_ATTACK_POWER;
+    uint16 index_mod = UNIT_FIELD_ATTACK_POWER_MODS;
+    uint16 index_mult = UNIT_FIELD_ATTACK_POWER_MULTIPLIER;
+
+    float mLevelMult = 0.0;
+    if (level>=40) mLevelMult = 1.5;
+    if (level>=50) mLevelMult = 2.0;
+    if (level>=60) mLevelMult = 3.0;
+    if (level>=70) mLevelMult = 4.0;
+    if (level>=80) mLevelMult = 5.0;
+
+    switch(myclass)
+    {
+    case CLASS_WARRIOR:       val2 = level * mLevelMult*4.0f + m_creature->GetStat(STAT_STRENGTH)*2.0f                   ; break;
+    case CLASS_DEATH_KNIGHT:  val2 = level * mLevelMult*4.0f + m_creature->GetStat(STAT_STRENGTH)*2.0f                   ; break;
+    case CLASS_PALADIN:       val2 = level * mLevelMult*3.0f + m_creature->GetStat(STAT_STRENGTH)*2.0f                    - 20.0f; break;
+    case CLASS_ROGUE:         val2 = level * mLevelMult*6.0f + m_creature->GetStat(STAT_STRENGTH) + m_creature->GetStat(STAT_AGILITY); break;
+    case CLASS_HUNTER:        val2 = level * mLevelMult*2.0f + m_creature->GetStat(STAT_STRENGTH) + m_creature->GetStat(STAT_AGILITY) - 20.0f; break;
+    case CLASS_SHAMAN:        val2 = level * mLevelMult*2.0f + m_creature->GetStat(STAT_STRENGTH)*2.0f                    - 20.0f; break;
+    case CLASS_DRUID:         val2 = m_creature->GetStat(STAT_STRENGTH)*2.0f - 20.0f; break;
+    case CLASS_MAGE:          val2 =              m_creature->GetStat(STAT_STRENGTH)  - 10.0f; break;
+    case CLASS_PRIEST:        val2 =              m_creature->GetStat(STAT_STRENGTH)  - 10.0f; break;
+    case CLASS_WARLOCK:       val2 =              m_creature->GetStat(STAT_STRENGTH)  - 10.0f; break;
+    }
+
+//sLog->outError ("val2 = %f", val2);
+//sLog->outError ("str = %f", m_creature->GetStat(STAT_STRENGTH));
+    //CreatureInfo const *cinfo = sObjectMgr.GetCreatureTemplate(m_creature->GetEntry());
+    //m_creature->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, cinfo->maxdmg/mylevel);
+
+    //Custom weapon system
+    val2 = abs(val2 + (val2 * (level/80)));
+   // sLog->outError ("custom val2 = %f", val2);
+    m_creature->SetModifierValue(unitMod, BASE_VALUE, val2);
+    float base_attPower  = m_creature->GetModifierValue(unitMod, BASE_VALUE) * m_creature->GetModifierValue(unitMod, BASE_PCT) * mLevelMult;
+
+    float attPowerMod = m_creature->GetModifierValue(unitMod, TOTAL_VALUE);
+
+    float attPowerMultiplier = m_creature->GetModifierValue(unitMod, TOTAL_PCT) - 1.0f;
+    attPowerMod = attPowerMod ?  attPowerMod : 1;
+    attPowerMultiplier = attPowerMultiplier ?  attPowerMultiplier : 0.1f;
+
+    m_creature->SetUInt32Value(UNIT_FIELD_ATTACK_POWER, (uint32)base_attPower);           //UNIT_FIELD_(RANGED)_ATTACK_POWER field
+    m_creature->SetUInt32Value(UNIT_FIELD_ATTACK_POWER_MODS, (uint32)attPowerMod);         //UNIT_FIELD_(RANGED)_ATTACK_POWER_MODS field
+    m_creature->SetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER, attPowerMultiplier);          //UNIT_FIELD_(RANGED)_ATTACK_POWER_MULTIPLIER field
+
+    m_creature->UpdateDamagePhysical(BASE_ATTACK);
+
+    //sLog->outError ("udpating BASE ATTACK");
+    //sLog->outError ("mLevelMult = %f", mLevelMult);
+    //sLog->outError ("bot_ai - base_attPower = %f", base_attPower);
+    //sLog->outError ("actpower multiplier = %f", attPowerMultiplier);
+    //sLog->outError ("actpower val2 = %f", val2);
+    //sLog->outError ("\tmin damage = %f", uint32(val2 * attPowerMultiplier)+level);
+    //sLog->outError ("\tmax damange = %f",uint32(val2 * attPowerMultiplier)*2+level);
+    //sLog->outError ("\tmax damange 2 = %f",uint32(val2 * attPowerMultiplier)*mLevelMult);
+    m_creature->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, uint32(val2 * attPowerMultiplier)+level);
+    m_creature->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, uint32(val2 * attPowerMultiplier)*2+level);
+
+    m_creature->UpdateDamagePhysical(BASE_ATTACK);
+    m_creature->SetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE,uint32(val2 * attPowerMultiplier)+level);
+    m_creature->SetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE,uint32(val2 * attPowerMultiplier)*2+level);
+//sLog->outError ("\t%s - min damage after setting it = %f", m_creature->GetName(), m_creature->GetFloatValue(UNIT_FIELD_MINDAMAGE));
+//sLog->outError ("\t%s - MINDAMAGE after setting it = %f", m_creature->GetName(), m_creature->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE));
+
+
+    m_creature->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, uint32(val2 * attPowerMultiplier));
+    //player -> m_creature->UpdateAttackPowerAndDamage(true); // ---> STUPID CREATURE CAN NOT BE RANGED
+
+
+    float value = 0.0f;
+    unitMod = UNIT_MOD_ARMOR;
+
+    value  = m_creature->GetModifierValue(unitMod, BASE_VALUE);         // base armor (from items)
+    value *= m_creature->GetModifierValue(unitMod, BASE_PCT);           // armor percent from items
+    value += m_creature->GetStat(STAT_AGILITY) * 2.0f;                  // armor bonus from stats
+    value += m_creature->GetModifierValue(unitMod, TOTAL_VALUE);
+
+    value *= m_creature->GetModifierValue(unitMod, TOTAL_PCT);
+    m_creature->UpdateAttackPowerAndDamage();
+
+    //Custom armor system
+    value = value + (value * (level/100));
+
+   // m_creature->SetArmor(int32(value));
+    m_creature->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    //m_creature->UpdateArmor();
+
+}
+
+void bot_ai::ReceiveEmote(Player *player, uint32 emote)
+{
+    if (emote == TEXTEMOTE_DANCE)
+        DoSay("I love to dance!",LANG_UNIVERSAL,m_creature->GetGUID(), player);
+
+    // debug to see what auras are on bot
+    if (emote == TEXTEMOTE_BONK)
+        listAuras(m_creature);
+
+    // debug to see what auras are on me
+    if (emote == TEXTEMOTE_SALUTE)
+        listAuras(player);
+
+    if (emote == TEXTEMOTE_STAND)
+    {
+        if (m_creature->GetCharmerGUID() != player->GetGUID())
+        {
+            m_creature->HandleEmoteCommand(TEXTEMOTE_RUDE);
+            return;
+        }
+        player->SetBotCommandState (COMMAND_STAY);
+        DoSay("Standing Still.",LANG_UNIVERSAL,m_creature->GetGUID(), player);
+    }
+
+    if (emote == TEXTEMOTE_WAVE)
+    {
+        if (m_creature->GetCharmerGUID() != player->GetGUID())
+        {
+            m_creature->HandleEmoteCommand(TEXTEMOTE_RUDE);
+            return;
+        }
+        player->SetBotCommandState (COMMAND_FOLLOW);
+        DoSay("Following!",LANG_UNIVERSAL,m_creature->GetGUID(), player);
+    }
+
+    // buff the requester
+    if (emote == TEXTEMOTE_BOW)
+    {
+        ReceiveBowEmote(player);
+    }
+
+} // end ReceiveEmote
+
+void bot_ai::ReceiveBowEmote(Player *player)
+{
+       // DoSay("I have no buffs for you!",LANG_UNIVERSAL,m_creature->GetGUID(), player);
+}
+
+void bot_ai::DoSay(const std::string& text, const uint32 language,uint64 receiver,Player *player)
+{
+
+}
diff --git a/src/server/scripts/Bots/bot_ai.h b/src/server/scripts/Bots/bot_ai.h
new file mode 100644
index 0000000..fa78d6e
--- /dev/null
+++ b/src/server/scripts/Bots/bot_ai.h
@@ -0,0 +1,89 @@
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#define SPELL_LEVEL ((int)m_creature->getLevel()/10)
+
+#define BANDAGE 27031
+#define MANAPOTION 28499
+#define REJUVEPOTION 28517
+#define HEALINGPOTION 28495
+#define POTIONCD 60000
+#define FIRSTAID 60000
+#define DRINK 1137
+
+#define master ((Player*)m_creature->GetCharmer())
+
+typedef std::set<Unit *> AttackerSet;
+
+class bot_ai : public ScriptedAI
+{
+    public:
+        bot_ai(Creature *c);
+
+        virtual ~bot_ai();
+
+        //Cure the target
+        virtual bool CureTarget (Unit *target);
+
+        //Heal the target
+        virtual bool HealTarget (Unit *target, uint8 hp);
+
+        // Buff target
+        virtual void BuffTarget(Unit *target);
+
+        virtual void ReceiveBowEmote(Player *player);
+
+
+        // Cycles through the group to heal/buff/rezz
+        void BuffAndHealGroup(Player *gPlayer);
+        void RezGroup(uint32 REZZ, Player *gPlayer);
+
+        //Debug method to list the auras currently active.
+        //Use to find what spells were casted
+        bool listAuras(Unit *unit);
+
+        //More generalized method than HasAura().  It looks for
+        //any rank of the spell and it doesn't care which
+        //spell effect you want.  If it has the spell aura than
+        //it returns true
+        bool HasAuraName(Unit *unit, std::string spell, uint64 casterGuid=0);
+        bool HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid=0);
+        bool HasAuraIcon (Unit *unit, uint32 SpellIconID, uint64 casterGuid=0);
+
+        std::string GetSpellName(uint32 spell_id);
+
+        void doCast(Unit *victim, uint32 spellId, bool triggered = false);
+        bool isTimerReady(int32 timer);
+
+        void ResetOrGetNextTarget();
+
+        void ReceiveEmote(Player *player, uint32 emote);
+
+        void DoSay(const std::string& text, const uint32 language,uint64 receiver,Player *player);
+
+        bool IAmDead();
+
+        void GiveManaBack(uint8 amount=25);
+
+        void CureGroup(Unit *pTarget);
+
+        void Feast();
+
+        void BotAttackStart(Unit *victim);
+
+        Creature *m_creature;
+
+        int32 GC_Timer; //global cooldown
+        uint32 FirstAid_cd;
+        uint32 Potion_cd;
+
+    private:
+        bool gettingAttacked(AttackerSet m_attackers);
+
+        CommandStates prevCommandState;
+
+    protected:
+        void setStats(uint32 myclass, uint32 myrace, uint32 mylevel);
+};
+#endif
+
diff --git a/src/server/scripts/Bots/bot_druid_ai.cpp b/src/server/scripts/Bots/bot_druid_ai.cpp
new file mode 100644
index 0000000..0f65931
--- /dev/null
+++ b/src/server/scripts/Bots/bot_druid_ai.cpp
@@ -0,0 +1,563 @@
+#include "ScriptPCH.h"
+#include "bot_druid_ai.h"
+#include "Group.h"
+
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new bot_druid_ai(pCreature);
+    }
+
+	struct bot_druid_ai : public bot_ai
+	{
+		bot_druid_ai(Creature *c) : bot_ai(c)
+		{
+			Reset();
+		}
+
+		int32 GC_Timer; //global cooldown
+		int32 Heal_Timer;
+		int32 Regrowth_Timer;
+		int32 Self_Regrowth_Timer;
+		int32 Self_Rejuvenation_Timer;
+		int32 Self_Heal_Timer;
+		int32 Rejuvenation_Timer;
+		int32 Others_Heal_Timer;
+		int32 Oom_timer;
+		int32 Fade_Timer;
+		int32 Potion_Timer;
+		int32 Warstomp_Timer;
+		int32 Rez_Timer;
+
+		int32 Noggenfogger_Timer;
+
+		//Bear Timers
+		int32 Demoralizing_Roar_Timer;
+		int32 Swipe_Timer;
+
+		//Cat Timers
+		int32 Claw_Timer;
+		int32 Rake_Timer;
+		int32 Shred_Timer;
+		int32 Rip_Timer;
+		int32 Mangle_Cat_Timer;
+
+		//Balance Timers
+		int32 Moonfire_Timer;
+		int32 Starfire_Timer;
+		int32 Wrath_Timer;
+		int32 Fairie_Fire_Timer;
+
+		Unit *mobsTarget;
+		Unit *opponent;
+
+		void Reset()
+		{
+			GC_Timer = 0;
+			Potion_Timer = 0;
+			Heal_Timer = 0;
+			Regrowth_Timer = 0;
+			Self_Regrowth_Timer = 0;
+			Self_Rejuvenation_Timer = 0;
+			Self_Heal_Timer = 0;
+			Rejuvenation_Timer = 0;
+			Rez_Timer = 0;
+
+			Others_Heal_Timer = 0;
+			Oom_timer = 0;
+
+			Warstomp_Timer = 0;
+			Demoralizing_Roar_Timer = 10;
+			Swipe_Timer = 20;
+			Noggenfogger_Timer = 0;
+
+			Claw_Timer = 0;
+			Rake_Timer = 0;
+			Shred_Timer = 0;
+			Rip_Timer = 0;
+			Mangle_Cat_Timer = 0;
+
+			Moonfire_Timer = 30;
+			Starfire_Timer = 90;
+			Wrath_Timer = 150;
+			Fairie_Fire_Timer = 10;
+
+			opponent = NULL;
+
+			if (master) {
+				setStats(CLASS_DRUID, m_creature->getRace(), master->getLevel());
+		   }
+		}
+
+		void Aggro(Unit *who){}
+
+		void EnterEvadeMode(){}
+
+		void KilledUnit(Unit *){ master->SetBotCommandState(COMMAND_FOLLOW); }
+
+		//try to do a warstomp every time I get out of animal form
+		void warstomp(const uint32 diff)
+		{
+			if(master->GetBotRace() != RACE_TAUREN) return;
+
+			if(Warstomp_Timer <= 0)
+			{
+				if(opponent != NULL)
+				{
+					Warstomp_Timer = 1200; //2 minutes
+					doCast(opponent, SPELL_WARSTOMP, true);
+				}
+			}
+			else if(Warstomp_Timer >= 0)
+				--Warstomp_Timer;
+		} //end warstomp
+
+		void removeFeralForm(Player *m=0)
+		{
+			if(!m) m=master; //if m is set than use it, else use master
+
+			if(m_creature->HasAura(SPELL_BEAR_FORM, 0))
+			{
+				m_creature->RemoveAurasDueToSpell(SPELL_BEAR_FORM);
+				m_creature->RemoveAurasDueToSpell(SPELL_BEAR_FORM_MOD);
+				m->SetBotMustWaitForSpell1(3000);
+			}
+
+			if(m_creature->HasAura(SPELL_CAT_FORM, 0))
+			{
+				m_creature->RemoveAurasDueToSpell(SPELL_CAT_FORM);
+				m_creature->RemoveAurasDueToSpell(SPELL_CAT_FORM_MOD);
+				m->SetBotMustWaitForSpell1(3000);
+			}
+
+			m_creature->setPowerType(POWER_MANA);
+
+		} //end removeFeralForm
+
+		bool isTimerReady(int32 timer)
+		{
+			if(timer <= 0 && GC_Timer <= 0) return true;
+			else                            return false;
+		}
+
+		void decrementTimers()
+		{
+			if(GC_Timer >= 0)                --GC_Timer;
+			if(Demoralizing_Roar_Timer >= 0) --Demoralizing_Roar_Timer;
+			if(Swipe_Timer >= 0)             --Swipe_Timer;
+			if(Claw_Timer >= 0)              --Claw_Timer;
+			if(Rake_Timer >= 0)              --Rake_Timer;
+			if(Shred_Timer >= 0)             --Shred_Timer;
+			if(Rip_Timer >= 0)               --Rip_Timer;
+			if(Mangle_Cat_Timer >= 0)        --Mangle_Cat_Timer;
+			if(Moonfire_Timer >= 0)          --Moonfire_Timer;
+			if(Starfire_Timer >= 0)          --Starfire_Timer;
+			if(Wrath_Timer >= 0)             --Wrath_Timer;
+			if(Rip_Timer >= 0)               --Fairie_Fire_Timer;
+			if(Potion_Timer >= 0)            --Potion_Timer;
+			if(Rejuvenation_Timer >= 0)      --Rejuvenation_Timer;
+			if(Regrowth_Timer >= 0)          --Regrowth_Timer;
+			if(Heal_Timer > 0)               --Heal_Timer;
+			if(Self_Regrowth_Timer >= 0)     --Self_Regrowth_Timer;
+			if(Self_Rejuvenation_Timer >= 0) --Self_Rejuvenation_Timer;
+			if(Self_Heal_Timer >= 0)         --Self_Heal_Timer;
+			if(Others_Heal_Timer >= 0)       --Others_Heal_Timer;
+			if(Rez_Timer >= 0)               --Rez_Timer;
+			if(Noggenfogger_Timer >= 0)      --Noggenfogger_Timer;
+
+		}
+
+		void doCast(Unit *victim, uint32 spellId, bool triggered = false)
+		{
+			if(spellId == 0) return;
+
+			GC_Timer = 20;
+			m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+			DoCast(victim, spellId, triggered);
+		} //end doCast
+
+		void doBearActions(const uint32 diff)
+		{
+			m_creature->setPowerType(POWER_RAGE);
+
+			if(isTimerReady(Demoralizing_Roar_Timer) && opponent != NULL)
+			{
+				Demoralizing_Roar_Timer = 150;
+				doCast(opponent, SPELL_DEMORALIZING_ROAR, true);
+			}
+
+			if(isTimerReady(Swipe_Timer) && opponent != NULL)
+			{
+				Swipe_Timer = 50;
+				doCast(opponent, SPELL_SWIPE, true);
+			}
+		}//end doBearActions
+
+
+
+		void doCatActions(/*Player *master, Creature *m_creature,*/ const uint32 diff)
+		{
+
+			m_creature->SetPower(POWER_ENERGY, 100);
+
+			if(isTimerReady(Claw_Timer) && opponent != NULL)
+			{
+				Claw_Timer = 70;
+				doCast(opponent, SPELL_CLAW, true);
+			}
+
+			if(isTimerReady(Mangle_Cat_Timer) && opponent != NULL)
+			{
+				Mangle_Cat_Timer = 70;
+				doCast(opponent, SPELL_MANGLE_CAT, true);
+			}
+
+			if(isTimerReady(Rake_Timer) && opponent != NULL)
+			{
+				Rake_Timer = 100;
+				doCast(opponent, SPELL_RAKE, true);
+			}
+
+			if(isTimerReady(Shred_Timer) && opponent != NULL)
+			{
+				Shred_Timer = 120;
+				doCast(opponent, SPELL_SHRED, true);
+			}
+
+			if(isTimerReady(Rip_Timer) && opponent != NULL)
+			{
+				Rip_Timer = 150;
+				doCast(opponent, SPELL_RIP, true);
+			}
+		} //end doCatActions
+
+
+		void doBalanceActions(const uint32 diff)
+		{
+			removeFeralForm();
+			m_creature->setPowerType (POWER_MANA);
+
+			if(isTimerReady(Moonfire_Timer) && opponent != NULL)
+			{
+				Moonfire_Timer = 150;
+				doCast(opponent, SPELL_MOONFIRE, true);
+			}
+
+			if(isTimerReady(Starfire_Timer) && opponent != NULL)
+			{
+				Starfire_Timer = 200;
+				doCast(opponent, SPELL_STARFIRE, true);
+			}
+
+			if(isTimerReady(Wrath_Timer) && opponent != NULL)
+			{
+				Wrath_Timer = 180;
+				doCast(opponent, SPELL_WRATH, true);
+			}
+
+			if(isTimerReady(Fairie_Fire_Timer) && opponent != NULL)
+			{
+				Fairie_Fire_Timer = 200;
+				doCast(opponent, SPELL_FAIRIE_FIRE, true);
+			}
+		} //end doBalanceActions
+
+
+		bool CureTarget(Unit *target)
+		{
+			if (HasAuraIcon(target, 68 /*"Venom Spit"*/)
+				//|| HasAuraName(target, "Venom Spit")
+				//|| HasAuraName(target, "Poison"))
+				&& !HasAuraName(target, SPELL_CURE_POISON))
+			{
+				removeFeralForm();
+				doCast(target, SPELL_CURE_POISON);
+			}
+			return true;
+		}
+
+		void UpdateAI(const uint32 diff)
+		{
+			decrementTimers();
+
+			if(IAmDead()) return;
+
+			if(m_creature->HasUnitState(UNIT_STAT_CASTING))
+				return;
+
+			//self buff
+			if(!m_creature->isInCombat())
+			{
+				if(!m_creature->HasAura(SPELL_THORNS))
+				{
+					removeFeralForm();
+					doCast(m_creature, SPELL_THORNS, true);
+				}
+			}
+
+			if(m_creature->GetPower(POWER_MANA) < 400 && isTimerReady(Potion_Timer))
+			{
+				 doCast(m_creature, REJUVEPOTION, true);
+				 //m_creature->MonsterSay("MANA POTION", LANG_UNIVERSAL, NULL);
+				 Potion_Timer = 150;
+				 Oom_timer = 0;
+			}
+			if(m_creature->GetPower(POWER_MANA)/m_creature->GetMaxPower(POWER_MANA) < 10)
+			{
+				if(Oom_timer == 0)
+				{
+					//m_creature->MonsterSay("OOM", LANG_UNIVERSAL, NULL);
+					Oom_timer = 1;
+				}
+			}
+
+			//Heal master
+			if((master->GetHealth()*100 / master->GetMaxHealth() < 90) && isTimerReady(Rejuvenation_Timer) && master->isAlive())
+			{
+				removeFeralForm();
+				warstomp(diff);
+				doCast(master, SPELL_REJUVENATION, true);
+				Rejuvenation_Timer = 300;
+				Heal_Timer = Heal_Timer + 30; //wait 3 seconds before casting a real heal
+				Regrowth_Timer = Regrowth_Timer + 20; //wait 2 seconds before casting a regrowth
+				//if(master->isInCombat() && master->getVictim() == NULL) return;
+				return;
+			}
+
+			if((master->GetHealth()*100 / master->GetMaxHealth() < 90) && isTimerReady(Regrowth_Timer) && master->isAlive())
+			{
+				removeFeralForm();
+				warstomp(diff);
+				doCast(master, SPELL_REGROWTH, true);
+				Regrowth_Timer = 200;
+				Heal_Timer = Heal_Timer + 20; //wait 2 seconds before casting a real heal
+				//if(master->isInCombat() && master->getVictim() == NULL) return;
+				return;
+			}
+
+			if((master->GetHealth()*100 / master->GetMaxHealth() < 75) && isTimerReady(Heal_Timer) && master->isAlive()
+			/* && CanCast(master, GetSpellStore()->LookupEntry(SPELL_HEALING_TOUCH))*/)
+			{
+				removeFeralForm();
+				warstomp(diff);
+				doCast(master, SPELL_HEALING_TOUCH, false);
+				Heal_Timer = 100;
+				return;
+			}
+
+			//
+			//Heal myself
+			//
+			if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 80 && !m_creature->HasAura(SPELL_REGROWTH, 1) && isTimerReady(Self_Regrowth_Timer))
+			{
+				removeFeralForm();
+				warstomp(diff);
+				doCast(m_creature, SPELL_REGROWTH, false);
+
+				Self_Regrowth_Timer = 120;
+				return;
+			}
+			if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 80 && !m_creature->HasAura(SPELL_REJUVENATION, 0) && isTimerReady(Self_Rejuvenation_Timer)
+			/* && CanCast(m_creature, GetSpellStore()->LookupEntry(SPELL_REGROWTH))*/)
+			{
+				removeFeralForm();
+				warstomp(diff);
+				doCast(m_creature, SPELL_REJUVENATION, false);
+
+				Self_Rejuvenation_Timer = 120;
+				return;
+			}
+			if((m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 75) && isTimerReady(Self_Heal_Timer)
+			/* && CanCast(master, GetSpellStore()->LookupEntry(SPELL_HEALING_TOUCH))*/)
+			{
+				removeFeralForm();
+				warstomp(diff);
+
+				doCast(m_creature, SPELL_HEALING_TOUCH, false);
+				Self_Heal_Timer = 100;
+				return;
+			}
+
+
+			//
+			//Heal others
+			//
+			//check group members, this doesn't check bots/pets.  They will be done later.  Preference
+			//goes to real players first.
+			//
+			Group::MemberSlotList const &a =((Player*)master)->GetGroup()->GetMemberSlots();
+			for(Group::member_citerator itr = a.begin(); itr != a.end(); itr++)
+			{
+				Player *tPlayer = ((Player *)master)->GetObjPlayer(itr->guid);
+				if(tPlayer == NULL) continue;
+
+				//healing others
+				if(tPlayer->isAlive() && isTimerReady(Others_Heal_Timer) && tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
+				{
+					//sLog->outError("Druid_Bot: healing someoneelse: %s it has %d HP", tPlayer->GetName(), tPlayer->GetHealth());
+					doCast(tPlayer, SPELL_HEALING_TOUCH, false);
+					Others_Heal_Timer = 250;
+				}
+
+				//rezzes
+				if(tPlayer->isDead() && m_creature->getLevel() >= 20 &&
+				//CanCast(tPlayer, GetSpellStore()->LookupEntry(SPELL_REBIRTH)) &&
+				m_creature->GetDistance(tPlayer) < 40 && (isTimerReady(Rez_Timer)))
+				{
+					char *str = (char *)malloc(32);
+					sprintf(str, "Rezzing %s", tPlayer->GetName());
+					m_creature->MonsterSay(str, LANG_UNIVERSAL, NULL);
+					free(str);
+					doCast(tPlayer, SPELL_REBIRTH, false);
+					Rez_Timer = 1600;
+				}
+
+				//buff group
+				if(tPlayer->isAlive())
+				{
+					if(!HasAuraName(tPlayer, GetSpellName(SPELL_MARK_OF_THE_WILD)) && !HasAuraName(tPlayer, "Gift of the Wild") && isTimerReady(GC_Timer))
+					{
+						removeFeralForm();
+						doCast(tPlayer, SPELL_MARK_OF_THE_WILD);
+					}
+
+					if(!HasAuraName(tPlayer, SPELL_THORNS) && isTimerReady(GC_Timer))
+					{
+						removeFeralForm();
+						doCast(tPlayer, SPELL_THORNS);
+					}
+				}
+			}
+
+			if(isTimerReady(Noggenfogger_Timer))
+			{
+				uint64 m_rand = urand(1, 2);
+				switch(m_rand)
+				{
+					case 1:
+						doCast(m_creature, SPELL_NOGGENFOGGER_SKELETON, true);
+						break;
+					case 2:
+						// Don't change forms b/c it crashes in GetModelForForm().  It checks
+						// PLAYER_BYTES and since its an npc it does not have this value.
+						//doCast(m_creature, SPELL_NOGGENFOGGER_SMALL, true);
+						break;
+				}
+				Noggenfogger_Timer = 6000; //10 minutes
+			}
+
+			//The rest is combat stuff, so if not in combat just return
+			opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+			if(!opponent && !m_creature->getVictim())
+			{
+				CureGroup(master);
+				ResetOrGetNextTarget();
+				return;
+			}
+
+			//default value
+			float val2 = m_creature->GetStat(STAT_STRENGTH)*2.0f;
+
+			//only go Feral if we are "small" from the noggenfogger spell
+			if(m_creature->HasAura(SPELL_NOGGENFOGGER_SMALL))
+			{
+				//if the target is attacking us, we want to go bear
+				if(opponent && opponent->getVictim() &&
+				opponent->getVictim()->GetGUID() == m_creature->GetGUID())
+				{
+					//if we don't have bear yet
+					if(!m_creature->HasAura(SPELL_BEAR_FORM))
+					{
+						m_creature->RemoveAurasDueToSpell(SPELL_CAT_FORM); //remove cat
+						m_creature->RemoveAurasDueToSpell(SPELL_CAT_FORM_MOD);
+						doCast(m_creature, SPELL_BEAR_FORM, true);
+						doCast(m_creature, SPELL_BEAR_FORM_MOD, true);
+						master->SetBotMustWaitForSpell1(3000);
+						m_creature->setPowerType(POWER_RAGE);
+						m_creature->SetMaxPower(POWER_RAGE, 1000);
+						m_creature->SetPower(POWER_RAGE, 1000);
+						val2 = m_creature->getLevel()*3.0f + m_creature->GetStat(STAT_STRENGTH)*2.0f;
+
+						//update attack power based on form
+						val2 = val2 + (val2 * (m_creature->getLevel()/50));
+						m_creature->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, val2);
+						m_creature->UpdateDamagePhysical(BASE_ATTACK);
+					}
+					doBearActions(diff);
+				} else {
+					//if we don't have cat yet
+					if(!m_creature->HasAura(SPELL_CAT_FORM))
+					{
+						m_creature->RemoveAurasDueToSpell(SPELL_BEAR_FORM); //remove bear
+						m_creature->RemoveAurasDueToSpell(SPELL_BEAR_FORM_MOD);
+						doCast(m_creature, SPELL_CAT_FORM, true);
+						doCast(m_creature, SPELL_CAT_FORM_MOD, true);
+						master->SetBotMustWaitForSpell1(3000);
+						m_creature->setPowerType(POWER_ENERGY);
+						m_creature->SetMaxPower(POWER_ENERGY, 1000);
+						m_creature->SetPower(POWER_ENERGY, 1000);
+						m_creature->SetSpeed(MOVE_RUN, m_creature->GetSpeed(MOVE_RUN) - 0.1f, true);
+						val2 = m_creature->getLevel()*5.0f + m_creature->GetStat(STAT_STRENGTH)*2.0f + m_creature->GetStat(STAT_AGILITY) - 20.0f;
+
+						//update attack power based on form
+						val2 = val2 + (val2 * (m_creature->getLevel()/50));
+						m_creature->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, val2);
+						m_creature->UpdateDamagePhysical(BASE_ATTACK);
+					}
+					doCatActions(diff);
+				}
+			//else go Balance if we are a skeleton from noggenfogger
+			} else {
+				val2 = m_creature->GetStat(STAT_STRENGTH)*2.0f;
+				val2 = val2 + (val2 * (m_creature->getLevel()/50));
+				m_creature->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, val2);
+				m_creature->UpdateDamagePhysical(BASE_ATTACK);
+				doBalanceActions(diff);
+			}
+
+
+
+			//now try to heal bots and pets.  DoSelectLowestHpFriendly will get
+			//everyone in group including bots and pets.  Unfortunately it can
+			//not be triggered for % of lost HP, so we just set it to -1000.
+			//This means low level players wont be healed because they wont have
+			//enough HP.
+			Unit *target = DoSelectLowestHpFriendly(40, 1000);
+			if(target && isTimerReady(Others_Heal_Timer))
+			{
+				doCast(target, SPELL_HEALING_TOUCH, false);
+				Others_Heal_Timer = 50;
+			} else {
+				target = DoSelectLowestHpFriendly(40, 500);  //now try someone with less HP lost
+				if(target && isTimerReady(Others_Heal_Timer))
+				{
+					if(!target->HasAura(SPELL_REGROWTH, 1))
+					{
+						doCast(target, SPELL_REGROWTH, false);
+						Others_Heal_Timer = 100;
+					}
+				}
+			}
+
+			ScriptedAI::UpdateAI(diff);
+		}
+		void ReceiveBowEmote(Player *player)
+		{
+			((bot_druid_ai*)m_creature->AI())->removeFeralForm((Player*) m_creature->GetCharmer());
+			((bot_druid_ai*)m_creature->AI())->doCast(player, SPELL_THORNS, true );
+			((bot_druid_ai*)m_creature->AI())->doCast(player, SPELL_MARK_OF_THE_WILD, false );
+		}
+
+	}; //end druid_bot
+
+};
+
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/scripts/Bots/bot_druid_ai.h b/src/server/scripts/Bots/bot_druid_ai.h
new file mode 100644
index 0000000..d63ea7b
--- /dev/null
+++ b/src/server/scripts/Bots/bot_druid_ai.h
@@ -0,0 +1,63 @@
+
+#include "bot_ai.h"
+
+
+#define SPELL_MARK_OF_THE_WILD      SPELL_MARK_OF_THE_WILD_A[SPELL_LEVEL]
+#define SPELL_THORNS                SPELL_THORNS_A[SPELL_LEVEL]
+#define SPELL_HEALING_TOUCH         SPELL_HEALING_TOUCH_A[SPELL_LEVEL]
+#define SPELL_REGROWTH              SPELL_REGROWTH_A[SPELL_LEVEL]
+#define SPELL_REJUVENATION          SPELL_REJUVENATION_A[SPELL_LEVEL]
+#define SPELL_REBIRTH               SPELL_REBIRTH_A[SPELL_LEVEL]
+#define SPELL_CURE_POISON           SPELL_CURE_POISON_A[SPELL_LEVEL]
+
+
+//0#define SPELL_RESURRECTION       10881    //rank 4
+#define SPELL_WARSTOMP              20549    //racial ability
+
+//FERAL SPELLS
+#define SPELL_CAT_FORM              768
+#define SPELL_CAT_FORM_MOD          3025
+#define SPELL_BEAR_FORM             9634
+#define SPELL_BEAR_FORM_MOD         1178
+
+#define SPELL_DEMORALIZING_ROAR     SPELL_DEMORALIZING_ROAR_A[SPELL_LEVEL]
+#define SPELL_SWIPE                 SPELL_SWIPE_A[SPELL_LEVEL]
+
+#define SPELL_CLAW                  SPELL_CLAW_A[SPELL_LEVEL]
+#define SPELL_RAKE                  SPELL_RAKE_A[SPELL_LEVEL]
+#define SPELL_SHRED                 SPELL_SHRED_A[SPELL_LEVEL]
+#define SPELL_RIP                   SPELL_RIP_A[SPELL_LEVEL]
+#define SPELL_MANGLE_CAT            SPELL_MANGLE_CAT_A[SPELL_LEVEL]
+
+//BALANCE SPELLS
+#define SPELL_MOONFIRE              SPELL_MOONFIRE_A[SPELL_LEVEL]
+#define SPELL_STARFIRE              SPELL_STARFIRE_A[SPELL_LEVEL]
+#define SPELL_WRATH                 SPELL_WRATH_A[SPELL_LEVEL]
+#define SPELL_FAIRIE_FIRE           SPELL_FAIRIE_FIRE_A[SPELL_LEVEL]
+
+#define SPELL_NOGGENFOGGER_SMALL    16595
+#define SPELL_NOGGENFOGGER_SKELETON 16591
+
+
+uint32 SPELL_MARK_OF_THE_WILD_A[] = { 1126, 5232, 6756, 5234, 8907, 21849, 21850, 26991, 48470 };
+uint32 SPELL_THORNS_A[] = { 467, 782, 1075, 8914, 9756, 9910, 26992, 26992, 53307, 53307 };
+uint32 SPELL_HEALING_TOUCH_A[] = { 5185, 5187, 5189, 6778, 9758, 9889, 26978, 26979, 26979 };
+uint32 SPELL_REGROWTH_A[] = { 0, 8936, 8939, 8941, 9750, 9857, 9858, 26980, 96980, 48442, 48442 };
+uint32 SPELL_REJUVENATION_A[] = { 774, 1058, 2090, 2091, 3627, 9840, 26981, 26982, 48440, 48440 };
+uint32 SPELL_REBIRTH_A[] = { 0, 0, 2006, 2010, 10880, 10881, 20770, 25435, 25435 };
+uint32 SPELL_CURE_POISON_A[] = { 0, 8946, 8946, 14253, 14253, 14253, 14253, 14253, 14253 };
+
+
+uint32 SPELL_DEMORALIZING_ROAR_A[] = { 0, 99, 1735, 9490, 9747, 9898, 26998, 26998, 48559, 48560, 48560 };
+uint32 SPELL_SWIPE_A[] = { 0, 779, 780, 769, 9754, 9908, 26997, 26997, 26997 };
+
+uint32 SPELL_CLAW_A[] = { 0, 0, 1082, 3029, 5201, 9849, 9850, 27000, 48569, 48569 };
+uint32 SPELL_RAKE_A[] = { 0, 0, 1822, 1823, 1824, 9904, 27003, 27003, 48574, 48574 };
+uint32 SPELL_SHRED_A[] = { 0, 0, 5221, 6800, 8992, 9829, 9830, 27001, 27002, 27002 };
+uint32 SPELL_RIP_A[] = { 0, 0, 1079, 9492, 9493, 9752, 9894, 9896, 27008, 27008 };
+uint32 SPELL_MANGLE_CAT_A[] = { 0, 0, 0, 0, 0, 33982, 33983, 48565, 48566, 48566 };
+
+uint32 SPELL_MOONFIRE_A[] = { 8921, 8924, 8925, 8928, 8929, 9834, 26987, 26988, 26988 };
+uint32 SPELL_STARFIRE_A[] = { 0, 0, 2912, 8950, 8951, 9875, 25298, 26986, 26986 };
+uint32 SPELL_WRATH_A[] = { 5176, 5178, 5179, 5180, 8905, 9912, 26984, 26985, 48461, 48461 };
+uint32 SPELL_FAIRIE_FIRE_A[] = { 0, 16857, 16857, 17390, 17391, 17392, 27011, 27011, 48475, 48475 };
diff --git a/src/server/scripts/Bots/bot_hunter_ai.cpp b/src/server/scripts/Bots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..4782966
--- /dev/null
+++ b/src/server/scripts/Bots/bot_hunter_ai.cpp
@@ -0,0 +1,304 @@
+#include "ScriptPCH.h"
+#include "bot_hunter_ai.h"
+#include "Group.h"
+
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new hunter_botAI(pCreature);
+    }
+
+	struct hunter_botAI : public bot_ai
+	{
+		hunter_botAI(Creature *c) :bot_ai(c)
+		{
+			Reset();
+			pet = NULL;
+		}
+
+		bool oom_spam;
+
+		Unit *opponent;
+		Creature *pet;
+
+		int32 ArcaneShot_cd;
+		int32 ChimeraShot_Timer;
+		int32 SilencingShot_Timer;
+		int32 AimedShot_Timer;
+
+		void Reset()
+		{
+			oom_spam = false;
+
+			opponent = NULL;
+
+			GC_Timer = 0;
+			ArcaneShot_cd = 0;
+			ChimeraShot_Timer = 0;
+			SilencingShot_Timer = 0;
+			AimedShot_Timer = 0;
+
+			if (master) {
+				setStats(CLASS_HUNTER, m_creature->getRace(), master->getLevel());
+		   }
+		}
+
+	   void CreatePet()
+		{
+			pet = master->GetBotsPet(60238);
+
+			if(pet == NULL)
+				return;
+
+			pet->UpdateCharmAI();
+			pet->setFaction(m_creature->getFaction());
+			pet->SetReactState(REACT_DEFENSIVE);
+			pet->GetMotionMaster()->MoveFollow(m_creature, PET_FOLLOW_DIST*urand(1, 2),PET_FOLLOW_ANGLE);
+			CharmInfo *charmInfonewbot = pet->InitCharmInfo();
+			pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+			pet->UpdateStats(STAT_STRENGTH);
+			pet->UpdateStats(STAT_AGILITY);
+			pet->SetLevel(master->getLevel());
+
+			float val2 = master->getLevel()*4.0f + pet->GetStat(STAT_STRENGTH)*2.0f;
+
+			val2=100.0;
+			uint32 attPowerMultiplier=1;
+			pet->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, uint32(val2));
+			pet->UpdateAttackPowerAndDamage();
+			pet->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, uint32(val2 * attPowerMultiplier));
+			pet->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, uint32(val2 * attPowerMultiplier)*2+master->getLevel());
+			pet->UpdateDamagePhysical(BASE_ATTACK);
+
+		}
+
+		void UpdateAI(const uint32 diff)
+		{
+
+			ReduceCD(diff);
+
+			if(IAmDead()) return;
+
+			if(!m_creature->isInCombat())
+			{
+				DoNonCombatActions();
+			}
+
+			if(pet && pet != NULL && pet->isDead())
+			{
+				master->SetBotsPetDied();
+				pet = NULL;
+			}
+
+			//if we think we have a pet, but master doesn't, it means we teleported
+			if(pet && master->m_botHasPet == false)
+			{
+				master->SetBotsPetDied();
+				pet = NULL;
+			}
+
+			DoNormalAttack(diff);
+			ScriptedAI::UpdateAI(diff);
+
+			//if low on health, drink a potion
+			if(m_creature->GetHealth() < m_creature->GetMaxHealth()*0.6 && isTimerReady(Potion_cd))
+			{
+				doCast(m_creature, HEALINGPOTION);
+				Potion_cd = 1500;
+			}
+
+			//if low on mana, drink a potion
+			 if(m_creature->GetPower(POWER_MANA) < m_creature->GetMaxPower(POWER_MANA)*0.2)
+			{
+				if(isTimerReady(Potion_cd))
+				{
+					doCast(m_creature, MANAPOTION);
+					//MonsterSay("MANA POTION", LANG_UNIVERSAL, NULL);
+					Potion_cd = 1500;
+				}
+			 }
+
+			opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+			if(!opponent && !m_creature->getVictim())
+			{
+				ResetOrGetNextTarget();
+
+				//to reduce the number of crashes, remove pet whenever we are not in combat
+				if(pet != NULL && pet->isAlive())
+				{
+					master->SetBotsPetDied();
+					pet = NULL;
+				}
+				return;
+			}
+
+
+			if(pet == NULL)
+				CreatePet();
+
+			if (pet && pet->isAlive() &&
+				!pet->isInCombat() &&
+				m_creature->getVictim()) {
+				pet->Attack (m_creature->getVictim(), true);
+				pet->GetMotionMaster()->MoveChase(m_creature->getVictim(), 1, 0);
+
+			}
+		}
+
+		void Aggro(Unit *who){}
+
+		void JustDied(Unit *Killer)
+		{
+			master->SetBotCommandState(COMMAND_FOLLOW);
+		}
+
+		void KilledUnit(Unit *)
+		{
+			((Player*)master)->SetBotCommandState(COMMAND_FOLLOW);
+		}
+
+
+		void AttackStart(Unit *u)
+		{
+			Aggro(u);
+			ScriptedAI::AttackStartCaster(u, 33);
+			m_creature->AddThreat(u, 0.001f);
+			u->AddThreat(m_creature, 0.001f);
+		}
+
+		void DoNormalAttack(const uint32 diff)
+		{
+			AttackerSet m_attackers = master->getAttackers();
+			if(opponent == NULL) return;
+			if(opponent->isDead()) return;
+
+
+			// try to get rid of enrage
+			if (TRANQ_SHOT && HasAuraName(opponent, "Enrage")) {
+				m_creature->InterruptNonMeleeSpells(true, AUTO_SHOT);
+			   // m_creature->MonsterSay("Tranquility shot!", LANG_UNIVERSAL, NULL);
+				doCast(opponent, TRANQ_SHOT);
+				GiveManaBack();
+			  //  doCast(opponent, AUTO_SHOT);
+			  //  return;
+			}
+
+			// silence it
+			if(SILENCING_SHOT && opponent->IsNonMeleeSpellCasted(true) && isTimerReady(SilencingShot_Timer))
+			{
+				doCast(opponent, SILENCING_SHOT);
+				SilencingShot_Timer = 200;
+				GiveManaBack();
+			  //  doCast(opponent, AUTO_SHOT);
+			  //  return;
+			}
+
+			// mark it
+			if (!HasAuraName(opponent, "Hunter's Mark")) {
+				doCast(opponent, HUNTERS_MARK);
+				GiveManaBack();
+			  //  doCast(opponent, AUTO_SHOT);
+			  //  return;
+			}
+
+			// sting it
+			if (SCORPID_STING && !opponent->HasAura(SCORPID_STING, m_creature->GetGUID())) {
+				m_creature->InterruptNonMeleeSpells(true, AUTO_SHOT);
+				doCast(opponent, SCORPID_STING);
+			   // m_creature->MonsterSay("Scorpid Sting!", LANG_UNIVERSAL, NULL);
+				GiveManaBack();
+			   // doCast(opponent, AUTO_SHOT);
+			   // return;
+			}
+
+			 if (CHIMERA_SHOT && isTimerReady(ChimeraShot_Timer)) {
+				m_creature->InterruptNonMeleeSpells(true, AUTO_SHOT);
+				doCast(opponent, CHIMERA_SHOT);
+				ChimeraShot_Timer = 100;
+			   // m_creature->MonsterSay("Chimera Sting!", LANG_UNIVERSAL, NULL);
+				GiveManaBack();
+			  //  doCast(opponent, AUTO_SHOT);
+			  //  return;
+			}
+
+			if(ARCANE_SHOT && isTimerReady(ArcaneShot_cd))
+			{
+				m_creature->InterruptNonMeleeSpells( true, AUTO_SHOT );
+				doCast(opponent, ARCANE_SHOT);
+			   // m_creature->MonsterSay("Arcane shot!", LANG_UNIVERSAL, NULL);
+				ArcaneShot_cd = 60;
+				GiveManaBack();
+			  //  doCast(opponent, AUTO_SHOT);
+			  //  return;
+			}
+
+			if(AIMED_SHOT && isTimerReady(AimedShot_Timer))
+			{
+				m_creature->InterruptNonMeleeSpells( true, AUTO_SHOT );
+				doCast(opponent, AIMED_SHOT);
+			   // m_creature->MonsterSay("Arcane shot!", LANG_UNIVERSAL, NULL);
+				AimedShot_Timer = 100;
+				GiveManaBack();
+			  //  doCast(opponent, AUTO_SHOT);
+			  //  return;
+			}
+
+
+			doCast(opponent, AUTO_SHOT);
+
+		}
+
+		void DoNonCombatActions()
+		{
+			if (ASPECT_OF_THE_WILD && !HasAuraName(m_creature, "Aspect of the Wild")) {
+				doCast(master, ASPECT_OF_THE_WILD);
+			}
+		}
+
+		void ReduceCD(const uint32 diff)
+		{
+			if(GC_Timer > 0)        --GC_Timer;
+			if(ArcaneShot_cd > 0)       --ArcaneShot_cd;
+			if(ChimeraShot_Timer > 0)       --ChimeraShot_Timer;
+			if(SilencingShot_Timer > 0)     --SilencingShot_Timer;
+			if(AimedShot_Timer > 0)         --AimedShot_Timer;
+		}
+
+		void ReceiveEmote(Player *player, uint32 emote)
+		{
+			//debug to see what auras are on bot
+			if(emote == TEXTEMOTE_BONK) ((hunter_botAI*)m_creature->AI())->listAuras(m_creature);
+
+			//debug to see what auras are on me
+			if(emote == TEXTEMOTE_SALUTE) ((hunter_botAI*)m_creature->AI())->listAuras(player);
+
+
+			if(emote == TEXTEMOTE_STAND)
+			{
+				if(m_creature->GetCharmerGUID() != player->GetGUID())
+				{
+					m_creature->HandleEmoteCommand(TEXTEMOTE_RUDE);
+					return;
+				}
+
+				player->SetBotCommandState (COMMAND_STAY);
+			}
+			if(emote == TEXTEMOTE_WAVE)
+			{
+				player->SetBotCommandState (COMMAND_FOLLOW);
+			}
+
+
+		}
+
+	};
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/scripts/Bots/bot_hunter_ai.h b/src/server/scripts/Bots/bot_hunter_ai.h
new file mode 100644
index 0000000..b4a7ce1
--- /dev/null
+++ b/src/server/scripts/Bots/bot_hunter_ai.h
@@ -0,0 +1,27 @@
+
+
+#include "bot_ai.h"
+
+
+#define AUTO_SHOT           75
+#define TRANQ_SHOT           TRANQ_SHOT_A[SPELL_LEVEL]
+#define SCORPID_STING        SCORPID_STING_A[SPELL_LEVEL]
+#define HUNTERS_MARK         HUNTERS_MARK_A[SPELL_LEVEL]
+
+#define ARCANE_SHOT          ARCANE_SHOT_A[SPELL_LEVEL]
+#define CHIMERA_SHOT         CHIMERA_SHOT_A[SPELL_LEVEL]
+#define AIMED_SHOT           AIMED_SHOT_A[SPELL_LEVEL]
+#define SILENCING_SHOT       SILENCING_SHOT_A[SPELL_LEVEL]
+#define ASPECT_OF_THE_WILD   ASPECT_OF_THE_WILD_A[SPELL_LEVEL]
+
+uint32 TRANQ_SHOT_A[] = { 0, 0, 19801, 19801, 19801, 19801, 19801, 19801, 19801, 19801 };
+uint32 HUNTERS_MARK_A[] = { 14325, 14325, 14325, 14325, 14325, 14325, 14325, 14325, 14325, 14325 };
+uint32 SCORPID_STING_A[] = { 0, 0, 0, 0, 0, 0, 3043, 3043, 3043, 3043 };
+
+uint32 ARCANE_SHOT_A[] = { 3044, 14281, 14282, 14284, 14285, 14286, 27019, 49044, 49045, 49045 };
+uint32 CHIMERA_SHOT_A[] = { 0, 0, 0, 0, 0, 0, 53209, 53209, 53209, 53209 };
+uint32 AIMED_SHOT_A[] = { 0, 0, 19434, 20900, 20902, 20903, 20904, 49049, 49050, 49050 };
+uint32 SILENCING_SHOT_A[] = { 0, 0, 0, 34490, 34490, 34490, 34490, 34490, 34490, 34490 };
+
+uint32 ASPECT_OF_THE_WILD_A[] = {0, 0, 0, 0, 20043, 20190, 27045, 49071, 49071 };
+
diff --git a/src/server/scripts/Bots/bot_mage_ai.cpp b/src/server/scripts/Bots/bot_mage_ai.cpp
new file mode 100644
index 0000000..34a248b
--- /dev/null
+++ b/src/server/scripts/Bots/bot_mage_ai.cpp
@@ -0,0 +1,523 @@
+    /* ScriptData
+    SDName: pvp_mage
+    SD%Complete: 0
+    SDComment: Original PVP mage by Brats reworked by Azrael with the help of Machiavelli
+    SDCategory: Custom
+    EndScriptData */
+#include "ScriptPCH.h"
+#include "bot_mage_ai.h"
+#include "Group.h"
+
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new mage_botAI(pCreature);
+    }
+
+	struct mage_botAI : public bot_ai
+	{
+		mage_botAI(Creature *c) :bot_ai(c)
+		{
+			//master = NULL;
+			Reset();
+		}
+
+		bool oom_spam;
+
+		uint8 state;
+		uint8 next_state;
+		uint32 next_state_timer;
+		Unit *opponent;
+
+		void Reset()
+		{
+			Blizzard_cd = 0;
+			FireBlast_cd = 0;
+			BlastWave_cd = 0;
+			CounterSpell_cd = 0;
+			FrostNova_cd = 0;
+			PoM_cd = 0;
+			Ward_cd = 0;
+			DragonBreath_cd = 0;
+			Blink_cd = 0;
+			Potion_cd = 0;
+			Combustion_cd = 0;
+			Evocation_cd = 0;
+			FirstAid_cd = 0;
+			GC_Timer = 0;
+			CastedArcaneIntellect = false;
+			CastedDampenMagic = false;
+			CastedArmor1 = false;
+			blink_timer = 10;
+			blink = false;
+			//wait = false;
+			oom_spam = false;
+
+			state = 1;
+			next_state = 0;
+			next_state_timer = 0;
+
+			opponent = NULL;
+
+			if (master) {
+				setStats(CLASS_DRUID, m_creature->getRace(), master->getLevel());
+		   }
+		}
+
+		void UpdateAI(const uint32 diff)
+		{
+			if(IAmDead()) return;
+
+			ReduceCD(diff);
+
+			if(!m_creature->isInCombat())
+			{
+				//buff master because master might be in different group
+				if(!HasAuraName(master, GetSpellName(ARCANEINTELLECT)) &&
+					master->isAlive() &&
+					isTimerReady(GC_Timer))
+						doCast(master, ARCANEINTELLECT, true);
+
+				//buff myself
+				if(!m_creature->HasAura(ARCANEINTELLECT) && isTimerReady(GC_Timer))
+					doCast(m_creature, ARCANEINTELLECT, true);
+
+				//check group members
+				Group::MemberSlotList const &a = ((Player*)master)->GetGroup()->GetMemberSlots();
+				for(Group::member_citerator itr = a.begin(); itr != a.end(); itr++)
+				{
+					Player *tPlayer = ((Player *)master)->GetObjPlayer(itr->guid);
+					if(tPlayer == NULL) continue;
+
+					//buff group
+					if(tPlayer->isAlive() &&
+						!m_creature->isInCombat() &&
+						isTimerReady(GC_Timer) &&
+						!HasAuraName(tPlayer, ARCANEINTELLECT))
+							doCast(tPlayer, ARCANEINTELLECT, true);
+				}
+
+				//no other buffs till full mana
+				if(m_creature->GetPower(POWER_MANA) == m_creature->GetMaxPower(POWER_MANA))
+				{
+					//sLog->outError("mana is %u, total mana is %u", m_creature->GetPower(POWER_MANA), m_creature->GetMaxPower(POWER_MANA));
+					//if(!HasAuraName(m_creature, "Mana Shield"))
+						//doCast(m_creature, MANASHIELD);
+
+					if(!HasAuraName(m_creature, DAMPENMAGIC) && isTimerReady(GC_Timer))
+					{
+						 doCast(m_creature, DAMPENMAGIC, true);
+						 GiveManaBack();
+						 CastedDampenMagic = true;
+						 //MonsterSay("DAMPEN MAGIC", LANG_UNIVERSAL, NULL);
+					}
+
+					if(!HasAuraName(m_creature, ICEARMOR) && isTimerReady(GC_Timer))
+					{
+						doCast(m_creature, ICEARMOR, true);
+						GiveManaBack();
+						//MonsterSay("ice armor", LANG_UNIVERSAL, NULL);
+						CastedArmor1 = true;
+					}
+				}
+			} //end if !isInCombat
+
+			m_creature->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+			m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+			if(m_creature->GetHealth() < m_creature->GetMaxHealth()*0.5 && isTimerReady(Potion_cd))
+			{
+				doCast(m_creature, HEALINGPOTION);
+				Potion_cd = 1500;
+			}
+			if(m_creature->GetPower(POWER_MANA) < m_creature->GetMaxPower(POWER_MANA)*0.3 && isTimerReady(Evocation_cd))
+			{
+				doCast(m_creature, EVOCATION);
+				Evocation_cd = EVOCATION_CD;
+			}
+			if(m_creature->GetPower(POWER_MANA) < m_creature->GetMaxPower(POWER_MANA)*0.2)
+			{
+				if(isTimerReady(Potion_cd))
+				{
+					doCast(m_creature, MANAPOTION);
+					//MonsterSay("MANA POTION", LANG_UNIVERSAL, NULL);
+					Potion_cd = Potion_cd;
+				} else {
+					if(oom_spam == false)
+					{
+						//MonsterSay("OOM", LANG_UNIVERSAL, NULL);
+						oom_spam = true;
+					}
+					ScriptedAI::UpdateAI(diff);
+					//return; //can't do anything without mana
+				}
+			}
+			oom_spam = false;
+
+			ScriptedAI::UpdateAI(diff);
+
+			opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+			if(!opponent && !m_creature->getVictim())
+			{
+				ResetOrGetNextTarget();
+				return;
+			}
+
+			//Armour(diff);
+			CheckSpellSteal(diff);
+			DoNormalAttack(diff);
+			Counter(diff);
+		}
+
+		void Aggro(Unit *who){}
+
+		void Armour(const uint32 diff)
+		{
+			Unit *opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+
+			if(!CastedArmor1 && (opponent->getClass() == CLASS_MAGE || opponent->getClass() == CLASS_PRIEST || opponent->getClass() == CLASS_WARLOCK) && isTimerReady(GC_Timer))
+			{
+				doCast(m_creature, MAGEARMOR, true);
+				CastedArmor1 = true;
+				//MonsterSay("MAGE Armor", LANG_UNIVERSAL, NULL);
+			}
+			else if(!CastedArmor1 && isTimerReady(GC_Timer))
+			{
+				doCast(m_creature, ICEARMOR, true);
+				//MonsterSay("ice armor 2", LANG_UNIVERSAL, NULL);
+				CastedArmor1 = true;
+			} else {
+				doCast(m_creature, ICEARMOR, true);
+				//MonsterSay("ice armor 3", LANG_UNIVERSAL, NULL);
+				CastedArmor1 = true;
+				return;
+			}
+		} //end Armour
+
+
+		void JustDied(Unit *Killer)
+		{
+			master->SetBotCommandState(COMMAND_FOLLOW);
+			state = 1;
+			next_state = 0;
+			next_state_timer = 0;
+		}
+
+		void AttackStart(Unit *u)
+		{
+			Aggro(u);
+			ScriptedAI::AttackStartCaster(u, 31);
+			m_creature->AddThreat(u, 0.001f);
+		}
+
+		void KilledUnit(Unit *)
+		{
+			((Player*)master)->SetBotCommandState(COMMAND_FOLLOW);
+			state = 1;
+			next_state = 0;
+			next_state_timer = 0;
+		}
+
+		void Counter(const uint32 diff)
+		{
+			if(opponent == NULL) return;
+			if(opponent->isDead()) return;
+			if(opponent->IsNonMeleeSpellCasted(true) && isTimerReady(CounterSpell_cd))
+			{
+				doCast(opponent, COUNTERSPELL);
+				CounterSpell_cd = COUNTERSPELL_CD;
+			}
+		}
+
+		void CheckSpellSteal(const uint32 diff)
+		{
+			if(opponent == NULL) return;
+			if(opponent->isDead()) return;
+			if(   //Druids:
+				  HasAuraName(opponent, "Mark of the Wild") ||
+				  HasAuraName(opponent, "Rejuvenation") ||
+				  HasAuraName(opponent, "Regrowth") ||
+				  //opponent->HasAura(33763) || //lifebloom
+				  //Mage:
+				  //opponent->HasAura(12043) || //POM
+				  //Warlock:
+				  HasAuraName(opponent, "Demon Armor") ||
+				  HasAuraName(opponent, "Fel Armor") ||
+				  //Priest:
+				  HasAuraName(opponent, "Power Word: Shield") ||
+				  HasAuraName(opponent, "Power Word: Fortitude"))
+			{
+				if(isTimerReady(GC_Timer))
+					doCast(opponent, SPELLSTEAL);
+			}
+		}
+
+
+
+		void DoNormalAttack(const uint32 diff)
+		{
+			AttackerSet m_attackers = master->getAttackers();
+			if(opponent == NULL) return;
+			if(opponent->isDead()) return;
+			bool defensive = false;
+
+			//opponent is attacking me, go defensive, ie point blank spells
+			if(opponent->getVictim() && opponent->getVictim()->GetGUID() == m_creature->GetGUID())
+				defensive = true;
+
+			//sLog->outError("%s: state = %u, next_state = %u, next_state_time = %u", m_creature->GetName(), state, next_state, next_state_timer);
+
+			switch(state)
+			{
+				case 0:
+					if(next_state_timer <= 0)
+						state = next_state;
+					else
+						--next_state_timer;
+
+					break;
+				case 1:
+					if(opponent->GetHealth()*100 > 80)
+						//state = 2;
+						state = 6;
+					else
+						state = 5;
+					break;
+				case 2:
+					if(isTimerReady(GC_Timer))
+					{
+						//MonsterSay("POLYMORPH", LANG_UNIVERSAL, NULL);
+						//doCast(opponent, POLYMORPH);
+						//next_state_timer = 21;
+						next_state_timer = 2;
+						next_state = 3;
+						state = 0;
+					}
+				case 3:
+					if(opponent->HasAura(POLYMORPH) || m_creature->HasAura(POM))
+					{
+						next_state_timer = (m_creature->HasAura(POM)) ? 15 : 61;
+						int damage = 957 + rand()%(1215-957+1) + 1.15*BONUS_DAMAGE;
+						//m_creature->CastCustomSpell(opponent, PYROBLAST, &damage, NULL, NULL, false, NULL, NULL);
+						doCast(opponent, PYROBLAST);
+						//MonsterSay("PYROBLAST", LANG_UNIVERSAL, NULL);
+						//GC_Timer = 1500;
+						next_state = 4;
+						state = 0;
+					} else state = 5;
+					break;
+				case 4:
+					if(isTimerReady(PoM_cd))
+					{
+						int damage = 957 + rand()%(1215-957+1) + 1.15*BONUS_DAMAGE;
+						//m_creature->CastCustomSpell(opponent, PYROBLAST, &damage, NULL, NULL, false, NULL, NULL);
+						doCast(opponent, PYROBLAST);
+						//MonsterSay("PYROBLAST", LANG_UNIVERSAL, NULL);
+						PoM_cd = POM_CD;
+						next_state = 5;
+						state = 0;
+						next_state_timer = 5;
+					}
+					else state = 5;
+					break;
+				case 5:
+					if(m_creature->GetPower(POWER_MANA)*100/m_creature->GetMaxPower(POWER_MANA) < 25.0)
+						break;
+
+					if(m_creature->GetHealth() < m_creature->GetMaxHealth()*0.3 && isTimerReady(FirstAid_cd))
+					{
+						doCast(opponent, FROSTNOVA);
+						GiveManaBack();
+						FrostNova_cd = FROSTNOVA_CD;
+						//MonsterSay("FROSTNOVA", LANG_UNIVERSAL, NULL);
+						next_state = 8;
+						next_state_timer = 15;
+						state = 0;
+					}
+					if(LIVINGBOMB && isTimerReady(Living_Bomb_cd))
+					{
+						doCast(opponent, LIVINGBOMB);
+						GiveManaBack();
+						Living_Bomb_cd = LIVING_BOMB_CD;
+						//MonsterSay("LIVING BOMB", LANG_UNIVERSAL, NULL);
+						next_state = 7;
+						next_state_timer = 2;
+						state = 0;
+					}
+					else if(isTimerReady(Scorch_cd))
+					{
+						//MonsterSay("SCORCH", LANG_UNIVERSAL, NULL);
+						doCast(opponent, SCORCH);
+						Scorch_cd = SCORCH_CD;
+						next_state = 7;
+						next_state_timer = 5;
+						state = 0;
+					}
+					else if(isTimerReady(GC_Timer))
+					{
+						int damage = 377 + rand()%(407-377+1) + 0.2128*BONUS_DAMAGE;
+						//m_creature->CastCustomSpell(opponent, ARCANEEXPLOSION, &damage, NULL, NULL, false, NULL, NULL);
+						if(ARCANEEXPLOSION > 0 && defensive)
+							 doCast(opponent, ARCANEEXPLOSION);
+						else
+							 doCast(opponent, FIREBALL);
+						GiveManaBack();
+						//MonsterSay("Arcane Explosion", LANG_UNIVERSAL, NULL);
+						next_state = 7;
+						next_state_timer = 2;
+						state = 0;
+					}
+					/*if(isTimerReady(Combustion_cd))
+					{
+						doCast(m_creature, COMBUSTION);
+						Combustion_cd = COMBUSTION_CD;
+						//MonsterSay("COMBUSTION", LANG_UNIVERSAL, NULL);
+						next_state = 6;
+						next_state_timer = 15;
+						state = 0;
+					}
+					else if(BLIZZARD && isTimerReady (Blizzard_cd) && m_attackers.size() > 1)
+					{
+						doCast(opponent, 62576);
+						//GiveManaBack();
+						Blizzard_cd = BLIZZARD_CD;
+						//MonsterSay("Blizzard", LANG_UNIVERSAL, NULL);
+						//sLog->outError("blizzard - %u", BLIZZARD);
+						//GiveManaBack();
+						next_state = 6;
+						next_state_timer = 100;
+						state = 0;
+					}*/
+					else if(FIREBLAST && isTimerReady(FireBlast_cd) && !defensive)
+					{
+						int damage = 677 + rand()%(802-677+1) + 0.4286*BONUS_DAMAGE;
+						//m_creature->CastCustomSpell(opponent, FIREBLAST, &damage, NULL, NULL, false, NULL, NULL);
+						doCast(opponent, FIREBLAST);
+						GiveManaBack();
+						FireBlast_cd = FIREBLAST_CD;
+						//MonsterSay("FIREBLAST", LANG_UNIVERSAL, NULL);
+						next_state = 7;
+						next_state_timer = 3;
+						state = 0;
+					}
+					else if(BLASTWAVE && isTimerReady(BlastWave_cd) && defensive && !opponent->HasAura(BLASTWAVE))
+					{
+						int damage = 628 + rand()%(739-628+1) + 0.1357*BONUS_DAMAGE;
+						//m_creature->CastCustomSpell(opponent, BLASTWAVE, &damage, NULL, NULL, false, NULL, NULL);
+						doCast(opponent, BLASTWAVE);
+						GiveManaBack();
+						BlastWave_cd = BLASTWAVE_CD;
+						//MonsterSay("BLAST WAVE", LANG_UNIVERSAL, NULL);
+						next_state = 7;
+						next_state_timer = 2;
+						state = 0;
+					}
+					else if(DRAGONBREATH && isTimerReady(DragonBreath_cd) && defensive && !opponent->HasAura(DRAGONBREATH))
+					{
+						int damage = 693 + rand()%(806-693+1) + 0.1357*BONUS_DAMAGE;
+						//m_creature->CastCustomSpell(opponent, DRAGONBREATH, &damage, NULL, NULL, false, NULL, NULL);
+						doCast(opponent, DRAGONBREATH);
+						GiveManaBack();
+						//MonsterSay("Dragon Breath", LANG_UNIVERSAL, NULL);
+						DragonBreath_cd = DRAGONBREATH_CD;
+						next_state = 6;
+						next_state_timer = 2;
+						state = 0;
+					}
+
+					break;
+				case 6:
+					if(isTimerReady(GC_Timer))
+					{
+						int damage = 645 + rand()%(822-645+1) + 1.00*BONUS_DAMAGE;
+						//m_creature->CastCustomSpell(opponent, FIREBALL, &damage, NULL, NULL, false, NULL, NULL);
+						doCast(opponent, FIREBALL);
+						GiveManaBack();
+						next_state = 5;
+						//MonsterSay("Fireball", LANG_UNIVERSAL, NULL);
+						next_state_timer = 3;
+						state = 0;
+					}
+					break;
+				case 7:
+					if(//HasAuraName(opponent, "Ice Block") ||
+						  HasAuraName(opponent, ICEBLOCK) ||
+						  HasAuraName(opponent, "Divine Shield") ||
+						  opponent->HasAura(5573)) //divine protection
+					{
+						doCast(m_creature, BANDAGE);
+						FirstAid_cd = FirstAid_cd;
+						state = 9;
+					}
+					else state = 5;
+					break;
+				case 8:
+					doCast(opponent, BLINK);   //Needs some serious testing
+					//blink is not working, so comment out for now
+					//blink = true;
+					//m_creature->Say("BLINK", LANG_UNIVERSAL, NULL);
+					//GC_Timer = 1500;
+					//MonsterSay("Blink", LANG_UNIVERSAL, NULL);
+					next_state = 9;
+					next_state_timer = 5;
+					state = 0;
+					break;
+				case 9:
+					/*if(blink)
+					{
+						wait = true;
+						wait_timer = 60;
+						doCast(m_creature, BANDAGE);
+						FirstAid_cd = FirstAid_cd;
+						//m_creature->Say("BANDAGE", LANG_UNIVERSAL, NULL);
+						blink = false;
+						//GC_Timer = 1500;
+						next_state = 10;
+						next_state_timer = 35;
+					} else*/
+						next_state = 5;
+					state = 0;
+					break;
+				case 10:
+					if(!m_creature->HasAura(BANDAGE))
+						state = 5;
+					break;
+				default:
+					state = 1;
+			}
+		}
+
+		void ReduceCD(const uint32 diff)
+		{
+			if(Living_Bomb_cd > 0)  --Living_Bomb_cd;
+			if(FireBlast_cd > 0)    --FireBlast_cd;
+			if(Blizzard_cd > 0)     --Blizzard_cd;
+			if(BlastWave_cd > 0)    --BlastWave_cd;
+			if(CounterSpell_cd > 0) --CounterSpell_cd;
+			if(FrostNova_cd > 0)    --FrostNova_cd;
+			if(PoM_cd > 0)          --PoM_cd;
+			if(Ward_cd > 0)         --Ward_cd;
+			if(Scorch_cd > 0)       --Scorch_cd;
+			if(DragonBreath_cd > 0) --DragonBreath_cd;
+			if(Blink_cd > 0)        --Blink_cd;
+			if(Combustion_cd > 0)   --Combustion_cd;
+			if(Potion_cd > 0)       --Potion_cd;
+			if(Evocation_cd > 0)    --Evocation_cd;
+			if(FirstAid_cd >0)      --FirstAid_cd;
+			if(GC_Timer > 0)        --GC_Timer;
+		}
+
+		void ReceiveBowEmote(Player *player)
+		{
+			((mage_botAI*)m_creature->AI())->doCast(player, ARCANEINTELLECT, true );
+		}
+	};
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/scripts/Bots/bot_mage_ai.h b/src/server/scripts/Bots/bot_mage_ai.h
new file mode 100644
index 0000000..7c0384b
--- /dev/null
+++ b/src/server/scripts/Bots/bot_mage_ai.h
@@ -0,0 +1,127 @@
+
+#include "bot_ai.h"
+
+
+uint32 FireBlast_cd;
+uint32 BlastWave_cd;
+uint32 CounterSpell_cd;
+uint32 FrostNova_cd;
+uint32 PoM_cd;
+uint32 Ward_cd;
+uint32 Blizzard_cd;
+uint32 DragonBreath_cd;
+uint32 Blink_cd;
+uint32 Combustion_cd;
+uint32 Scorch_cd;
+uint32 Potion_cd;
+uint32 Evocation_cd;
+uint32 Living_Bomb_cd;
+uint32 FirstAid_cd;
+uint32 GC_Timer;
+uint32 blink_timer;
+//uint32 wait_timer;
+
+bool CastedDampenMagic;
+bool CastedArcaneIntellect;
+bool CastedArmor1;
+//bool wait;
+bool blink;
+
+//arcane spells cooldown
+#define ARCANETORRENT_CD 120
+#define EVOCATION_CD 4800
+#define COUNTERSPELL_CD 240
+#define POM_CD 1200
+#define BLINK_CD 1500
+
+//fire spells cooldown
+#define BLASTWAVE_CD 350
+#define DRAGONBREATH_CD 450
+#define WARD_CD 300
+#define FIREBLAST_CD 650 //8000 if not fire mage
+#define COMBUSTION_CD 1800
+#define SCORCH_CD 900
+#define LIVING_BOMB_CD 600
+
+//frost spells cooldown
+#define FROSTNOVA_CD 250
+#define CONEOFCOLD_CD 100
+#define ICEBLOCK_CD 3000
+#define BLIZZARD_CD 300
+
+//arcane spells
+#define DAMPENMAGIC     SPELL_DAMPENMAGIC_A[SPELL_LEVEL]
+#define MANASHIELD      SPELL_MANASHIELD_A[SPELL_LEVEL]
+#define MAGEARMOR       SPELL_MAGEARMOR_A[SPELL_LEVEL]
+#define SPELLSTEAL      SPELL_SPELLSTEAL_A[SPELL_LEVEL]
+#define ARCANEMISSILES  SPELL_ARCANEMISSILES_A[SPELL_LEVEL]
+#define ARCANEINTELLECT SPELL_ARCANEINTELLECT_A[SPELL_LEVEL]
+#define ARCANEEXPLOSION SPELL_ARCANEEXPLOSION_A[SPELL_LEVEL]
+#define POLYMORPH       SPELL_POLYMORPH_A[SPELL_LEVEL]
+#define COUNTERSPELL    2139
+#define EVOCATION       12051
+#define POM             12043
+#define REMCURSE        15729
+#define BLINK           38932
+#define ARCANETORRENT   28730
+
+
+
+//fire spells
+#define FIREBALL        SPELL_FIREBALL_A[SPELL_LEVEL]
+#define BLASTWAVE       SPELL_BLASTWAVE_A[SPELL_LEVEL]
+#define DRAGONBREATH    SPELL_DRAGONBREATH_A[SPELL_LEVEL]
+#define FIREBLAST       SPELL_FIREBLAST_A[SPELL_LEVEL]
+#define FIREWARD        SPELL_FIREWARD_A[SPELL_LEVEL]
+#define PYROBLAST       SPELL_PYROBLAST_A[SPELL_LEVEL]
+#define COMBUSTION      SPELL_COMBUSTION_A[SPELL_LEVEL]
+#define SCORCH          SPELL_SCORCH_A[SPELL_LEVEL]
+#define MOLTENARMOR     30482
+#define LIVINGBOMB      SPELL_LIVING_BOMB_A[SPELL_LEVEL]
+
+//frost spells
+#define FROSTNOVA       SPELL_FROSTNOVA_A[SPELL_LEVEL]
+#define FROSTWARD       SPELL_FROSTWARD_A[SPELL_LEVEL]
+#define CONEOFCOLD      SPELL_CONEOFCOLD_A[SPELL_LEVEL]
+#define ICEARMOR        SPELL_ICEARMOR_A[SPELL_LEVEL]
+#define ICEBLOCK        45438
+#define BLIZZARD        SPELL_BLIZZARD_A[SPELL_LEVEL]
+
+
+//others
+#define BONUS_DAMAGE 986 //Spell Bonus
+#define BANDAGE 27031
+#define MANAPOTION 28499
+#define REJUVEPOTION 28517
+#define HEALINGPOTION 28495
+
+//arcane spells
+uint32 SPELL_DAMPENMAGIC_A[] = { 0, 8450, 8451, 10173, 10173, 10174, 33944, 43015, 43015 };
+uint32 SPELL_MANASHIELD_A[] = { 0, 0, 1463, 8495, 10191, 10192, 27131, 43019, 43020 };
+uint32 SPELL_MAGEARMOR_A[] = { 0, 0, 0, 6117, 22782, 22783, 27125, 43023, 43024 };
+uint32 SPELL_SPELLSTEAL_A[] = { 0, 0, 0, 0, 0, 0, 0, 30449, 30449 };
+uint32 SPELL_ARCANEMISSILES_A[] = {5143, 5144, 5145, 8416, 8417, 10212, 27075, 42843, 42846 };
+uint32 SPELL_ARCANEINTELLECT_A[] = { 1459, 1460, 1461, 1461, 10156, 10157, 10157, 27126, 42995};
+uint32 SPELL_ARCANEEXPLOSION_A[] = { 0, 1449, 8437, 8439, 10201, 10202, 27080, 42990, 42921 };
+uint32 SPELL_POLYMORPH_A[] = { 0, 0, 12824, 12824, 12825, 12825, 28271, 28272, 61721 };
+
+//fire spells
+uint32 SPELL_FIREBALL_A[] = { 143, 145, 8400, 8401, 10148, 25306, 38692, 42834, 42834 };
+uint32 SPELL_BLASTWAVE_A[] = { 0, 0, 0, 11113, 13019, 13020, 13021, 42944, 42945 };
+uint32 SPELL_DRAGONBREATH_A[] = { 0, 0, 0, 0, 0, 31661, 31661, 31661, 31661 };
+uint32 SPELL_FIREBLAST_A[] = {2136, 2137, 2138, 8412, 10197, 10199, 10199, 10199, 10199 };
+uint32 SPELL_FIREWARD_A[] = { 0, 0, 543, 8457, 8458, 10223, 10225, 27128, 43010 };
+uint32 SPELL_COMBUSTION_A[] = { 0, 0, 0, 0, 11129, 11129, 11129, 11129, 11129 };
+uint32 SPELL_PYROBLAST_A[] = { 0, 0, 11366, 12522, 12525, 12526, 27132, 42890, 42891 };
+uint32 SPELL_SCORCH_A[] = { 0, 0, 2948, 8445, 10205, 10207, 27073, 27074, 42859 };
+uint32 SPELL_LIVING_BOMB_A[] = { 0, 0, 0, 0, 0, 44457, 44457, 44457, 44457 };
+
+//frost spells
+uint32 SPELL_FROSTNOVA_A[] = {0, 122, 865, 6131, 10230, 27088, 42917, 42917, 42917 };
+uint32 SPELL_FROSTWARD_A[] = { 0, 0, 6143, 8461, 8462, 10177, 28609, 32796, 43012 };
+uint32 SPELL_CONEOFCOLD_A[] = { 0, 0, 120, 8492, 10159, 10161, 27087, 42930, 42931 };
+uint32 SPELL_ICEARMOR_A[] = {0, 0, 0, 7302, 7320, 10219, 10220, 27124, 43008  };
+uint32 SPELL_BLIZZARD_A[] = { 0, 0, 10, 8427, 10185, 10186, 10187, 27085, 42940 };
+
+
+
diff --git a/src/server/scripts/Bots/bot_paladin_ai.cpp b/src/server/scripts/Bots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..1725374
--- /dev/null
+++ b/src/server/scripts/Bots/bot_paladin_ai.cpp
@@ -0,0 +1,276 @@
+#include "ScriptPCH.h"
+#include "bot_paladin_ai.h"
+#include "Group.h"
+
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new paladin_botAI(pCreature);
+    }
+
+	struct paladin_botAI : public bot_ai
+	{
+		paladin_botAI(Creature *c) :bot_ai(c)
+		{
+			Reset();
+		}
+
+		bool oom_spam;
+
+		Unit *opponent;
+
+		int32 LOH_Timer;
+		int32 HOJ_Timer;
+
+		void Reset()
+		{
+			oom_spam = false;
+
+			opponent = NULL;
+
+			GC_Timer = 0;
+			LOH_Timer = 0;
+			HOJ_Timer = 0;
+
+			if (master) {
+				setStats(CLASS_PALADIN, m_creature->getRace(), master->getLevel());
+		   }
+		}
+
+		bool CureTarget(Unit *target)
+		{
+			if (!isTimerReady(GC_Timer)) return false;
+			if (HasAuraName(target, "Withering Heat"))
+			{
+	//sLog->outError ("PaladingBotAI.CureTarget: curing %s of withering heat");
+				doCast(target, CLEANSE);
+			}
+			if (HasAuraName(target, "Ancient Dread"))
+			{
+	//sLog->outError ("PaladingBotAI.CureTarget: curing %s of Ancient Dread");
+				doCast(target, CLEANSE);
+			}
+					if (HasAuraName(target, "Ancient Dread"))
+			{
+	//sLog->outError ("PaladingBotAI.CureTarget: curing %s of Ancient Dread");
+				doCast(target, CLEANSE);
+			}
+			if (HasAuraName(target, "Arcane Buffet"))
+			{
+	//sLog->outError ("PaladingBotAI.CureTarget: curing %s of Arcane Buffet");
+				doCast(target, CLEANSE);
+			}
+			if (HasAuraName(target, "Shadow Buffet"))
+			{
+	//sLog->outError ("PaladingBotAI.CureTarget: curing %s of Shadow Buffet");
+				doCast(target, CLEANSE);
+			}
+			if (HasAuraName(target, "Flame Buffet"))
+			{
+	//sLog->outError ("PaladingBotAI.CureTarget: curing %s of Flame Buffet");
+				doCast(target, CLEANSE);
+			}
+			if (HasAuraName(target, "Frost Buffet"))
+			{
+	//sLog->outError ("PaladingBotAI.CureTarget: curing %s of Frost Buffet");
+				doCast(target, CLEANSE);
+			}
+			return true;
+		}
+
+		bool HealTarget(Unit *target, uint8 hp)
+		{
+			if (!isTimerReady(GC_Timer)) return false;
+			if (m_creature->IsNonMeleeSpellCasted(true)) return false;
+			if(!target || target->isDead()) return false;
+			if(hp < 25 && isTimerReady(LOH_Timer))
+			{
+				// 33% to cast loh, else just do a fast heal
+				uint64 m_rand = urand(1, 3);
+				switch(m_rand)
+				{
+					 case 1: {
+						std::string loh = "Lay of Hands on ";
+						loh += target->GetName();
+						loh += ".";
+
+						m_creature->MonsterSay(loh.c_str(), LANG_UNIVERSAL, NULL);
+
+						doCast(target, LAY_OF_HANDS);
+						LOH_Timer = 1600;
+						return true;
+					}
+					case 2:
+					case 3: {
+						doCast(target, FLASH_OF_LIGHT);
+						GiveManaBack(15);
+						return true;
+					}
+				}
+
+			}
+			if(hp < 60) { doCast(target, FLASH_OF_LIGHT); GiveManaBack(15); return true; }
+			if(hp < 80) { doCast(target, HOLY_LIGHT); GiveManaBack(20); return true; }
+
+			return true;
+		} //end HealTarget
+
+
+		void UpdateAI(const uint32 diff)
+		{
+			if(IAmDead()) return;
+
+			ReduceCD(diff);
+
+		   // opponent = master->getVictim() ? master->getVictim() : SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+			opponent = m_creature->getVictim();
+			if(!opponent )
+			{
+				ResetOrGetNextTarget();
+				DoNonCombatActions();
+				return;
+			}
+
+			m_creature->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+			m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+			if(m_creature->GetHealth() < m_creature->GetMaxHealth()*0.5 && isTimerReady(Potion_cd))
+			{
+				doCast(m_creature, HEALINGPOTION);
+				Potion_cd = Potion_cd;
+			}
+
+			oom_spam = false;
+
+			//buff and heal master's group
+			if(master->GetGroup())
+			{
+				BuffAndHealGroup(master);
+				CureGroup(master);
+			}
+
+			// Heal myself
+			HealTarget (m_creature, m_creature->GetHealth()*100 / m_creature->GetMaxHealth());
+
+
+
+			DoNormalAttack(diff);
+			Counter(diff);
+
+			ScriptedAI::UpdateAI(diff);
+		}
+
+		void Aggro(Unit *who){
+		}
+
+		void Armour(const uint32 diff)
+		{
+
+		} //end Armour
+
+		void DoNonCombatActions()
+		{
+			if (m_creature->HasAura(DEVOTION_AURA)) Aura = DEVOTIONAURA;
+			else if (m_creature->HasAura(FIRE_RESISTANCE_AURA)) Aura = FIRERESISTANCEAURA;
+			else Aura = NOAURA;
+
+			//buff myself
+			if(!master->HasAura(DEVOTION_AURA) && isTimerReady(GC_Timer)) {
+				doCast(m_creature, DEVOTION_AURA, true);
+			}
+			else
+			// I already have devotion aura and its not mine, cast different aura
+			if (master->HasAura(DEVOTION_AURA) &&
+				!master->HasAura(DEVOTION_AURA, m_creature->GetGUID()) &&
+				Aura == NOAURA &&
+				isTimerReady(GC_Timer))
+				doCast(m_creature, FIRE_RESISTANCE_AURA, true);
+
+			if(!m_creature->HasAura(SEAL_OF_LIGHT) && isTimerReady(GC_Timer))
+				doCast(m_creature, SEAL_OF_LIGHT, true);
+
+			//buff and heal master's group
+			if(master->GetGroup())
+			{
+				RezGroup(REDEMPTION, master);
+				BuffAndHealGroup(master);
+				CureGroup(master);
+			}
+
+		}
+
+		void BuffTarget(Unit *target)
+		{
+			if(!target) return;
+			switch(target->getClass())
+			{
+			case CLASS_MAGE:
+			case CLASS_PRIEST:
+			case CLASS_WARLOCK:
+				if (!HasAuraName(target, GetSpellName(BLESSING_OF_WISDOM))) doCast(target, BLESSING_OF_WISDOM, true);
+				break;
+			case CLASS_PALADIN:
+				if (!HasAuraName(target, GetSpellName(BLESSING_OF_SANCTUARY))) doCast(target, BLESSING_OF_SANCTUARY, true);
+				break;
+			default:
+				if (!HasAuraName(target, GetSpellName(BLESSING_OF_KINGS))) doCast(target, BLESSING_OF_KINGS, true);
+				break;
+			}
+
+		}
+
+
+		void JustDied(Unit *Killer)
+		{
+			master->SetBotCommandState(COMMAND_FOLLOW);
+		}
+
+		void AttackStart(Unit *u)
+		{
+			Aggro(u);
+			ScriptedAI::AttackStart(u);
+		}
+
+		void KilledUnit(Unit *)
+		{
+			((Player*)master)->SetBotCommandState(COMMAND_FOLLOW);
+		}
+
+		void Counter(const uint32 diff)
+		{
+			if(opponent == NULL) return;
+			if(opponent->isDead()) return;
+			if(opponent->IsNonMeleeSpellCasted(true) && isTimerReady(HOJ_Timer))
+			{
+				doCast(opponent, HAMMER_OF_JUSTICE);
+				HOJ_Timer = 600;
+			}
+		}
+
+		void DoNormalAttack(const uint32 diff)
+		{
+			if(!opponent->HasAura(JUDGEMENT_OF_LIGHT) && isTimerReady(GC_Timer))
+				doCast(opponent, JUDGEMENT_OF_LIGHT, true);
+
+		}
+
+		void ReduceCD(const uint32 diff)
+		{
+			if(GC_Timer > 0)        --GC_Timer;
+			if(LOH_Timer > 0)       --LOH_Timer;
+			if(HOJ_Timer > 0)       --HOJ_Timer;
+		}
+		void ReceiveBowEmote(Player *player)
+		{
+			BuffTarget(player);
+		}
+	};
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/scripts/Bots/bot_paladin_ai.h b/src/server/scripts/Bots/bot_paladin_ai.h
new file mode 100644
index 0000000..f6ccab8
--- /dev/null
+++ b/src/server/scripts/Bots/bot_paladin_ai.h
@@ -0,0 +1,62 @@
+
+#include "bot_ai.h"
+
+
+enum AURAS {
+    DEVOTIONAURA,
+    FIRERESISTANCEAURA,
+    NOAURA
+} ;
+
+AURAS Aura;
+
+
+// misc
+#define BANDAGE 27031
+#define MANAPOTION 28499
+#define REJUVEPOTION 28517
+#define HEALINGPOTION 28495
+
+// Heals
+#define FLASH_OF_LIGHT                FLASH_OF_LIGHT_A[SPELL_LEVEL]
+#define HOLY_LIGHT                    HOLY_LIGHT_A[SPELL_LEVEL]
+#define LAY_OF_HANDS                  LAY_OF_HANDS_A[SPELL_LEVEL]
+#define REDEMPTION                    REDEMPTION_A[SPELL_LEVEL]
+
+#define CLEANSE                         CLEANSE_A[SPELL_LEVEL]
+
+uint32 FLASH_OF_LIGHT_A[] = {0, 0, 19939, 19940, 19941, 19942, 27137, 48784, 48785, 48785};
+uint32 HOLY_LIGHT_A[] = {635, 647, 1026, 3472, 10328, 10329, 27135, 48781, 48782, 48782};
+uint32 LAY_OF_HANDS_A[] = {0, 633, 633, 2800, 2800, 10310, 10310, 27154, 48788, 48788};
+uint32 REDEMPTION_A[] = {0, 7328, 10322, 10324, 20772, 20772, 20773, 48949, 48950, 48950};
+uint32 CLEANSE_A[] = {0, 0, 0, 0, 4987, 4987, 4987, 4987, 4987};
+
+// Seals
+#define SEAL_OF_LIGHT	        SEAL_OF_LIGHT_A[SPELL_LEVEL]
+#define JUDGEMENT_OF_LIGHT      JUDGEMENT_OF_LIGHT_A[SPELL_LEVEL]
+
+uint32 SEAL_OF_LIGHT_A[] = {0, 0, 0, 20165, 20165, 20165, 20165, 20165, 20165, 20165};
+uint32 JUDGEMENT_OF_LIGHT_A[] = {0, 0, 0, 20185, 20185, 20185, 20185, 20185, 20185, 20185};
+
+// Blessings
+#define BLESSING_OF_WISDOM      BLESSING_OF_WISDOM_A[SPELL_LEVEL]
+#define BLESSING_OF_KINGS       BLESSING_OF_KINGS_A[SPELL_LEVEL]
+#define BLESSING_OF_SANCTUARY   BLESSING_OF_SANCTUARY_A[SPELL_LEVEL]
+
+uint32 BLESSING_OF_WISDOM_A[] = {0, 19742, 19850, 19852, 19853, 19854, 25290, 48935, 48936, 48936};
+uint32 BLESSING_OF_KINGS_A[] = {0, 0, 56525, 56525, 56525, 56525, 56525, 56525, 56525, 56525};
+uint32 BLESSING_OF_SANCTUARY_A[] = {0, 0, 0, 67480, 67480, 67480, 67480, 67480, 67480, 67480};
+
+
+// Auras
+#define FIRE_RESISTANCE_AURA      FIRE_RESISTANCE_AURA_A[SPELL_LEVEL]
+#define DEVOTION_AURA             DEVOITION_AURA_A[SPELL_LEVEL]
+
+uint32 FIRE_RESISTANCE_AURA_A[] = {0, 0, 0, 19891, 19899, 19899, 19900, 27153, 48947, 48947};
+uint32 DEVOITION_AURA_A[] = {465, 10290, 643, 10291, 1032, 10292, 10293, 48941, 48942, 48942};
+
+
+// Others
+#define HAMMER_OF_JUSTICE         HAMMER_OF_JUSTICE_A[SPELL_LEVEL]
+
+uint32 HAMMER_OF_JUSTICE_A[] = {0, 853, 5588, 5588, 5589, 10308, 10308, 37369, 37369};
diff --git a/src/server/scripts/Bots/bot_priest_ai.cpp b/src/server/scripts/Bots/bot_priest_ai.cpp
new file mode 100644
index 0000000..f6a6941
--- /dev/null
+++ b/src/server/scripts/Bots/bot_priest_ai.cpp
@@ -0,0 +1,276 @@
+#include "ScriptPCH.h"
+#include "bot_priest_ai.h"
+#include "Group.h"
+
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new priest_botAI(pCreature);
+    }
+
+	struct priest_botAI : public bot_ai
+	{
+		priest_botAI(Creature *c) :bot_ai(c)
+		{
+			Reset();
+		}
+
+		int32 Heal_Timer;
+		int32 Renew_Timer;
+		int32 Self_Renew_Timer;
+		int32 PWS_Timer;
+		int32 Others_Heal_Timer;
+		int32 Oom_timer;
+		int32 Fade_Timer;
+		int32 Potion_Timer;
+		int32 Rez_Timer;
+
+		Unit *mobsTarget;
+
+		void Reset()
+		{
+			GC_Timer = 0;
+			Heal_Timer = 0;
+			Renew_Timer = 0;
+			Self_Renew_Timer = 0;
+			PWS_Timer = 0;
+			Others_Heal_Timer = 0;
+			Oom_timer = 0;
+			Fade_Timer = 0;
+			Potion_Timer = 0;
+			Rez_Timer = 0;
+
+			if (master) {
+				setStats(CLASS_PRIEST, m_creature->getRace(), master->getLevel());
+			}
+		}
+
+		void EnterEvadeMode(){ Oom_timer = 0; }
+
+		void Aggro(Unit *who){}
+
+		void AttackStart(Unit *u)
+		{
+			   m_creature->GetMotionMaster()->MoveFollow(master, urand(5, 10), PET_FOLLOW_ANGLE);
+
+		}
+
+		void KilledUnit(Unit *)
+		{
+			((Player*)master)->SetBotCommandState(COMMAND_FOLLOW);
+		}
+
+		void MoveInLineOfSight(Unit *target)
+		{
+			if (master==NULL || master==0) return;
+
+			if(target->GetGUID() == master->GetGUID()) return;
+
+			if(!target->IsFriendlyTo(master)) return;
+
+			if(target->isAlive() && ((target->GetHealth()*100) < 100))
+				m_creature->CastSpell(target, SPELL_HEAL, false);
+		}
+
+		bool isTimerReady(int32 timer)
+		{
+			if(timer <= 0 && GC_Timer <= 0) return true;
+			else                            return false;
+		} //end isTimerReady
+
+		void decrementTimers()
+		{
+			if(GC_Timer > 0)          --GC_Timer;
+			if(Heal_Timer > 0)        --Heal_Timer;
+			if(Others_Heal_Timer > 0) --Others_Heal_Timer;
+			if(Fade_Timer > 0)        --Fade_Timer;
+			if(Self_Renew_Timer > 0)  --Self_Renew_Timer;
+			if(Renew_Timer > 0)       --Renew_Timer;
+			if(PWS_Timer > 0)         --PWS_Timer;
+			if(Potion_Timer > 0)      --Potion_Timer;
+		} //end decrementTImers
+
+		void UpdateAI(const uint32 diff)
+		{
+			decrementTimers();
+
+			if(IAmDead()) return;
+
+			if(!m_creature->isInCombat())
+			{
+				DoNonCombatActions();
+			}
+
+			//buff and heal master's group
+			BuffAndHealGroup(master);
+
+
+			//check group members
+			Group::MemberSlotList const &a =((Player*)master)->GetGroup()->GetMemberSlots();
+			for(Group::member_citerator itr = a.begin(); itr != a.end(); itr++)
+			{
+				Player *tPlayer = ((Player *)master)->GetObjPlayer(itr->guid);
+				if(tPlayer == NULL) continue;
+			}
+
+			//if low on mana, drink a potion
+			if(m_creature->GetPower(POWER_MANA) < 400 && isTimerReady(Potion_Timer))
+			{
+				 doCast(m_creature, MANAPOTION, true);
+				 Potion_Timer = 1500;
+			}
+			//if after drinking a potion still low on mana
+			//let everyone know that you are oom.
+			if(m_creature->GetPower(POWER_MANA)/m_creature->GetMaxPower(POWER_MANA) < 10)
+			{
+				if(Oom_timer == 0)
+				{
+					//MonsterSay("OOM", LANG_UNIVERSAL, NULL);
+					Oom_timer = 1;
+				}
+			}
+
+			// Heal myself
+			if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 90)
+			{
+				if(Fade_Timer <= 0 && m_creature->isInCombat() &&
+					isTimerReady(Fade_Timer))
+				{
+					doCast(m_creature, SPELL_FADE);
+					Fade_Timer = 30;
+					return;
+				}
+
+
+				HealTarget (m_creature, m_creature->GetHealth()*100 / m_creature->GetMaxHealth());
+
+			}
+
+			//now try to heal bots and pets.  DoSelectLowestHpFriendly will get
+			//everyone in group including bots and pets.  Unfortunately it can
+			//not be triggered for % of lost HP, so we just set it to -1000.
+			//This means low level players wont be healed because they wont have
+			//enough HP.
+			if(isTimerReady(Others_Heal_Timer))
+			{
+				Unit *target;
+				if(target = DoSelectLowestHpFriendly(40, 1000))
+				{
+					doCast(target, SPELL_HEAL, false);
+					GiveManaBack();
+					Others_Heal_Timer = 50;
+				}
+				else if(target = DoSelectLowestHpFriendly(40, 500))
+				{
+					if(!target->HasAura(SPELL_RENEW, 0))
+					{
+						doCast(target, SPELL_RENEW, false);
+						GiveManaBack();
+						Others_Heal_Timer = 100;
+					}
+				}
+			} //end if isTimerReady(Others_Heal_Timer)
+		} //end UpdateAI
+
+		bool HealTarget(Unit *target, uint8 hp)
+		{
+		   if (!isTimerReady(GC_Timer)) return false;
+			if (m_creature->IsNonMeleeSpellCasted(true)) return false;
+			if(!target || target->isDead()) return false;
+		   // if(hp < 60) { doCast(target, FLASH_OF_LIGHT); GiveManaBack(15); return true; }
+		   // if(hp < 80) { doCast(target, HOLY_LIGHT); GiveManaBack(20); return true; }
+
+		   if((hp < 50) &&
+				isTimerReady(PWS_Timer) &&
+				!target->isDead())
+			{
+				doCast(target, SPELL_PW_SHIELD);
+				PWS_Timer = 120;
+				//free (buff);
+			}
+
+			if((hp < 90) &&
+				hp >75 &&
+				isTimerReady(Renew_Timer))
+			{
+				doCast(target, SPELL_RENEW, true);
+				GiveManaBack();
+				Renew_Timer = 90;
+				Heal_Timer = Heal_Timer + 5; //wait 5 seconds before casting a real heal
+				return true;
+			}
+
+			if((hp < 75) &&
+				isTimerReady(Heal_Timer) &&
+				!target->isDead())
+			{
+				doCast(target, SPELL_HEAL);
+				GiveManaBack();
+				Heal_Timer = 10;
+				return true;
+			}
+
+			return true;
+		}
+
+		void BuffTarget(Unit *target)
+		{
+			if (!HasAuraName(target, GetSpellName(SPELL_FORTITUDE))) {
+				doCast(target, SPELL_FORTITUDE, false);
+				GiveManaBack();
+			}
+			if (!HasAuraName(target, GetSpellName(SPELL_PRAYER_OF_SHADOW))) {
+				doCast(target, SPELL_PRAYER_OF_SHADOW, false);
+				GiveManaBack();
+			}
+		}
+
+		void DoNonCombatActions()
+		{
+			   //if eating or drinking don't do anything
+				if(m_creature->HasAura(10256) || m_creature->HasAura(1137)) return;
+
+				Feast();
+
+				//buff master
+				if(!HasAuraName(master, SPELL_PRAYER_OF_SHADOW, 0) && isTimerReady(GC_Timer)) doCast(master, SPELL_PRAYER_OF_SHADOW, true);
+				if(!HasAuraName(master, FEAR_WARD, 0) && isTimerReady(GC_Timer)) doCast(master, FEAR_WARD, true);
+				if(!HasAuraName(master, DIVINE_SPIRIT, 0) && isTimerReady(GC_Timer)) {
+					doCast(master, DIVINE_SPIRIT, true);
+					GiveManaBack();
+				}
+
+				//buff myself
+				if(!m_creature->HasAura(SPELL_INNER_FIRE, 0) && isTimerReady(GC_Timer)) doCast(m_creature, SPELL_INNER_FIRE, true);
+				if(!m_creature->HasAura(SPELL_FORTITUDE, 0) && isTimerReady(GC_Timer)) doCast(m_creature, SPELL_FORTITUDE, true);
+				//if(m_creature->getRace() == RACE_UNDEAD_PLAYER && !m_creature->HasAura(SPELL_TOUCH_OF_WEAKNESS, 0) && isTimerReady(GC_Timer)) doCast(m_creature, SPELL_TOUCH_OF_WEAKNESS);
+
+	//buff and heal master's group
+			if(master->GetGroup())
+			{
+				RezGroup(SPELL_RESURRECTION, master);
+				//BuffAndHealGroup(master);
+			   // CureGroup(master);
+			}
+
+
+		}
+
+		void ReceiveBowEmote(Player *player)
+		{
+			((priest_botAI*)m_creature->AI())->doCast(player, SPELL_FORTITUDE, true);
+			((priest_botAI*)m_creature->AI())->doCast(player, SPELL_PRAYER_OF_SHADOW, false);
+		}
+
+	}; //end priest_bot
+};
+
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/scripts/Bots/bot_priest_ai.h b/src/server/scripts/Bots/bot_priest_ai.h
new file mode 100644
index 0000000..09bf1bb
--- /dev/null
+++ b/src/server/scripts/Bots/bot_priest_ai.h
@@ -0,0 +1,33 @@
+#include "bot_ai.h"
+
+
+#define FEAR_WARD   6346
+
+#define SPELL_PW_SHIELD           SPELL_PW_SHIELD_A[SPELL_LEVEL]
+//#define SPELL_DIVINE_SPIRIT     14818
+
+#define SPELL_FORTITUDE           SPELL_FORTITUDE_A[SPELL_LEVEL]
+#define SPELL_HEAL                SPELL_HEAL_A[SPELL_LEVEL]
+#define SPELL_RENEW               SPELL_RENEW_A[SPELL_LEVEL]
+#define SPELL_FADE                SPELL_FADE_A[SPELL_LEVEL]
+#define SPELL_RESURRECTION        SPELL_RESURRECTION_A[SPELL_LEVEL]
+//define SPELL_VAMPIRIC_EMBRACE
+//#define SPELL_INNER_FOCUS       14751
+
+//BUFFS
+#define SPELL_INNER_FIRE          SPELL_INNER_FIRE_A[SPELL_LEVEL]
+#define SPELL_PRAYER_OF_SHADOW    SPELL_PRAYER_OF_SHADOW_A[SPELL_LEVEL]
+#define DIVINE_SPIRIT               DIVINE_SPIRIT_A[SPELL_LEVEL]
+//#define SPELL_TOUCH_OF_WEAKNESS 19265 //rank 5
+
+uint32 SPELL_FORTITUDE_A[] = { 1243, 1244, 1245, 2791, 10937, 10938, 25389, 48161, 48161 };
+uint32 SPELL_RENEW_A[] = { 8362, 11640, 6075, 6077, 10927, 10928, 25315, 48068, 48068 };
+uint32 SPELL_HEAL_A[] = { 29170, 29170, 2055, 6064, 10963, 10964, 10965, 25213, 25213 };
+uint32 SPELL_PW_SHIELD_A[] = { 17, 592, 3747, 6066, 10899, 10900, 10901, 25218, 25218 };
+uint32 SPELL_FADE_A[] = { 586, 586, 586, 586, 586, 586, 586, 586, 586 };
+uint32 SPELL_PRAYER_OF_SHADOW_A[] = { 0, 0, 0, 0, 0, 27683, 27683, 39374, 39374, 39374 };
+
+uint32 SPELL_INNER_FIRE_A[] = { 588, 7128, 602, 1006, 10951, 10952, 25431, 25431, 48040, 48040 };
+uint32 DIVINE_SPIRIT_A[] = {0, 0, 0, 14752, 14818, 14819, 27841, 25312, 48073, 48073};
+
+uint32 SPELL_RESURRECTION_A[] = { 2006, 2006, 2006, 2010, 10880, 10881, 20770, 25435, 25435 };
diff --git a/src/server/scripts/Bots/bot_rogue_ai.cpp b/src/server/scripts/Bots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..671c339
--- /dev/null
+++ b/src/server/scripts/Bots/bot_rogue_ai.cpp
@@ -0,0 +1,314 @@
+#include "ScriptPCH.h"
+#include "bot_rogue_ai.h"
+#include "Group.h"
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new rogue_botAI(pCreature);
+    }
+
+struct rogue_botAI : public bot_ai
+{
+    rogue_botAI(Creature *c) : bot_ai(c)
+    {
+        Reset();
+    }
+
+    int32 GC_Timer;                // global cooldown
+    int32 BS_Timer;
+    int32 SinisterStrike_Timer;
+    int32 Eviscerate_Timer;
+    int32 SliceDice_Timer;
+    int32 Rupture_Timer;
+    int32 Kick_Timer;
+    int32 Poison_Timer;
+    int32 Potion_Timer;
+    int32 Shadowstep_Timer;
+    int32 Mutilate_Timer;
+
+    uint8 energy;
+    uint8 comboPoints;
+
+    Unit *opponent;
+
+    void Reset()
+    {
+        GC_Timer = 0;
+        BS_Timer = 50;
+        Mutilate_Timer = 0;
+        SinisterStrike_Timer = 30;
+        Eviscerate_Timer = 90;
+        SliceDice_Timer = 75;
+        Rupture_Timer = 80;
+        Kick_Timer = 20;
+        Poison_Timer = 15;
+        Potion_Timer=0;
+        Shadowstep_Timer = 0;
+        comboPoints = 0;
+        energy = 100;
+
+        opponent = NULL;
+
+        m_creature->setPowerType(POWER_ENERGY);
+        m_creature->SetMaxPower(POWER_ENERGY, 100);
+        m_creature->SetPower(POWER_ENERGY, 100);
+
+        if (master) {
+            //        if (!m_creature->HasAura(61331)) m_creature->AddAura(61331,m_creature);  // Aggression
+            //         if (!m_creature->HasAura(14137)) m_creature->AddAura(14137,m_creature);  // Lethality
+            //          if (!m_creature->HasAura(14166)) m_creature->AddAura(14166,m_creature);  // Improved Slice and Dice
+            //           if (!m_creature->HasAura(14164)) m_creature->AddAura(14164,m_creature);  // Improved Eviserate
+
+            setStats(CLASS_ROGUE, m_creature->getRace(), master->getLevel());
+
+            if (m_creature->getLevel()>70 && !m_creature->HasAura(37169)) m_creature->AddAura(37169,m_creature);  // Death Mantle item set
+        }
+
+    }
+
+    void EnterEvadeMode(){}
+
+    void Aggro(Unit *who){}
+
+    void MoveInLineOfSight(Unit *target){}
+
+    bool isTimerReady(int32 timer)
+    {
+        if(timer <= 0 && GC_Timer <= 0) return true;
+        else                            return false;
+    } //end isTimerReady
+
+    void doCast(Unit *victim, uint32 spellId, bool triggered = false)
+    {
+        if(spellId == 0) return;
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+        GC_Timer = 10;
+        DoCast(victim, spellId, triggered);
+    } //end doCast
+
+    void decrementTimers()
+    {
+        if(GC_Timer > 0)             --GC_Timer;
+        if(BS_Timer > 0)             --BS_Timer;
+        if(Kick_Timer > 0)           --Kick_Timer;
+        if(SliceDice_Timer > 0)      --SliceDice_Timer;
+        if(SinisterStrike_Timer > 0) --SinisterStrike_Timer;
+        if(Eviscerate_Timer > 0)     --Eviscerate_Timer;
+        if(Rupture_Timer > 0)        --Rupture_Timer;
+        if(Poison_Timer > 0)         --Poison_Timer;
+        if(Potion_Timer > 0)         --Potion_Timer;
+        if(Shadowstep_Timer > 0)     --Shadowstep_Timer;
+        if (Mutilate_Timer > 0)            Mutilate_Timer--;
+    } //end decrementTImers
+
+    void KilledUnit(Unit *)
+    {
+        ((Player*)master)->SetBotCommandState(COMMAND_FOLLOW);
+    }
+
+    void AttackStart(Unit *u)
+    {
+        Aggro(u);
+        ScriptedAI::AttackStart(u);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        decrementTimers();
+
+        if(IAmDead()) return;
+
+        opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+        if(!opponent && !m_creature->getVictim())
+        {
+            comboPoints = 0;
+            energy = 100;
+            ResetOrGetNextTarget();
+            return;
+        }
+
+        m_creature->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+        m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+        energy += 5;
+        if(comboPoints > 5) comboPoints = 5;
+
+        //interrupt any spells
+        if(opponent->IsNonMeleeSpellCasted(true) && energy >= 25)
+        {
+            if(isTimerReady(Kick_Timer))
+            {
+                doCast(opponent, KICK);
+                Kick_Timer = 100;
+                energy -= 25;
+            }
+            else if(comboPoints > 0)
+            {
+                switch(comboPoints)
+                {
+                    case 1: doCast(opponent, KIDNEY_SHOT_1); --comboPoints; break;
+                    case 2: doCast(opponent, KIDNEY_SHOT_2); comboPoints-=2; break;
+                    default: doCast(opponent, KIDNEY_SHOT_3); comboPoints-=3; break;
+                }
+                energy -= 25;
+            }
+        }
+
+        if(!opponent->isInFrontInMap(m_creature, 5) && isTimerReady(BS_Timer))
+        {
+            doCast(opponent, BACKSTAB);
+            BS_Timer = 50;
+            energy -= 60;
+        }
+        else if(isTimerReady(Shadowstep_Timer) && energy > 10 && m_creature->GetDistance(opponent) < 25)
+        {
+            //doCast(opponent, SHADOWSTEP);
+            Shadowstep_Timer = 300;
+            energy -= 10;
+
+            //NPCs can't really shadowstep so fake it
+            float x = opponent->GetPositionX();
+            float y = opponent->GetPositionY();
+            float z = opponent->GetPositionZ();
+            float o = opponent->GetOrientation();
+
+            m_creature->Relocate(x-4, y-4, z, o);
+            m_creature->SendMonsterMoveWithSpeed(x-4, y-4, 1, 0);
+            doCast(opponent, BACKSTAB);
+            return;
+        }
+
+        if(isTimerReady(SliceDice_Timer) && comboPoints > 0 && !m_creature->HasAura(SLICE_DICE))
+        {
+            doCast(opponent, SLICE_DICE);
+
+            // since npcs don't use combo points, they can only case
+            // first level of spell.  So only remove 1 combo point
+            --comboPoints;
+
+            SliceDice_Timer = 75;
+            energy -= 25;
+        }
+
+        if (isTimerReady(Mutilate_Timer) &&
+            energy>60) {
+            // TODO: calculate correct dmg for mutilate (dont forget poison bonus)
+            // for now use same formula as evicerate
+            uint32 base_attPower = m_creature->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+            //float minDmg = m_creature->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            float minDmg = m_creature->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+            int damage = irand(int32(base_attPower*5*0.03f),int32(base_attPower*5*0.07f))+minDmg+m_creature->getLevel();
+
+            // compensate for lack of attack power
+            damage = damage*(rand()%4+1);
+
+            m_creature->CastCustomSpell(opponent, MUTILATE, &damage, NULL, NULL, false, NULL, NULL);
+
+            //doCast (m_creature, MUTILATE);
+            Mutilate_Timer = 75;
+            ++comboPoints;
+            energy -= 60;
+        }
+
+        if (isTimerReady(Eviscerate_Timer) && comboPoints>0) {
+            uint32 base_attPower = m_creature->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+            //float minDmg = m_creature->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            float minDmg = m_creature->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+            int damage = irand(int32(base_attPower*5*0.03f),int32(base_attPower*5*0.07f))+minDmg+m_creature->getLevel();
+//sLog->outError ("EVISCERTE: base_attPower = %u", base_attPower);
+//sLog->outError("\tminDmg = %f", minDmg);
+//sLog->outError("\tmaxDmg = %f", m_creature->GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE));
+//sLog->outError ("\tMINDAMAGE after setting it = %f", m_creature->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE));
+
+// compensate for lack of attack power
+//sLog->outError ("\tdamage before = %u", damage);
+            damage = damage*(rand()%4+1);
+//sLog->outError ("\tdamage after = %u", damage);
+            // Eviscerate and Envenom Bonus Damage (Deathmantle item set effect)
+            if(m_creature->HasAura(37169))
+                damage += comboPoints*40;
+
+            m_creature->CastCustomSpell(opponent, EVISCERATE, &damage, NULL, NULL, false, NULL, NULL);
+            //doCast(opponent, EVISCERATE);
+            comboPoints=0;
+
+            energy -= 30;
+            Eviscerate_Timer = 90;
+         //   return;
+        }
+
+        if(isTimerReady(SinisterStrike_Timer) && comboPoints < 5)
+        {
+            doCast(opponent, SINISTER_STRIKE);
+            //m_creature->Say("sinister strike", LANG_UNIVERSAL, NULL);
+            ++comboPoints;
+            SinisterStrike_Timer = 20;
+            energy -= 40;
+        }
+
+        if(isTimerReady(Rupture_Timer))
+        {
+            doCast(opponent, RUPTURE);
+            comboPoints = 0;
+            Rupture_Timer = 80;
+            energy -= 40;
+        }
+
+        /*if(!opponent->HasAuraType(SPELL_AURA_MOD_DISARM))
+            doCast(opponent, DISMANTLE);*/
+
+        /*
+            since npc can't really use poison, we'll pretend that we were able to poison his blades.
+        */
+        if(isTimerReady(Poison_Timer))
+        {
+            //Deadly Poison has 40% chance of proccing
+            switch(rand()%5)
+            {
+                case 0:
+                case 1:
+                case 2:
+                    break;
+                case 4:
+                case 5:
+                    if(DEADLY_POISON) DoCast(opponent, DEADLY_POISON, true); break;
+            }
+
+            //Wound Poison has 50% chance of procing
+            switch(rand()%2)
+            {
+                case 0:
+                     break;
+                case 1:
+                    if(WOUND_POISON) DoCast(opponent, WOUND_POISON, true); break;
+                    break;
+            }
+
+            Poison_Timer = 15;
+        }
+
+        //if low on health, drink a potion
+        if(m_creature->GetHealth() < m_creature->GetMaxHealth()*0.6 && isTimerReady(Potion_Timer))
+        {
+            doCast(m_creature, HEALINGPOTION);
+            Potion_Timer = 1500;
+        }
+
+        m_creature->SetPower(POWER_ENERGY, energy);
+
+        ScriptedAI::UpdateAI(diff);
+    } //end UpdateAI
+
+
+}; //end rogue_bot
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/scripts/Bots/bot_rogue_ai.h b/src/server/scripts/Bots/bot_rogue_ai.h
new file mode 100644
index 0000000..e0dad9b
--- /dev/null
+++ b/src/server/scripts/Bots/bot_rogue_ai.h
@@ -0,0 +1,31 @@
+#include "bot_ai.h"
+
+
+#define BACKSTAB        BACKSTAB_A[SPELL_LEVEL]
+#define SINISTER_STRIKE SINISTER_STRIKE_A[SPELL_LEVEL]
+#define SLICE_DICE      SLICE_DICE_A[SPELL_LEVEL]
+#define EVISCERATE      EVISCERATE_A[SPELL_LEVEL]
+#define KICK            KICK_A[SPELL_LEVEL]
+#define RUPTURE         RUPTURE_A[SPELL_LEVEL]
+#define WOUND_POISON    WOUND_POISON_A[SPELL_LEVEL]
+#define DEADLY_POISON   DEADLY_POISON_A[SPELL_LEVEL]
+#define DISMANTLE       DISMANTLE_A[SPELL_LEVEL]
+#define KIDNEY_SHOT_1   8643
+#define KIDNEY_SHOT_2   30832
+#define KIDNEY_SHOT_3   41389
+#define SHADOWSTEP      SHADOWSTEP_A[SPELL_LEVEL]
+#define MUTILATE        MUTILATE_A[SPELL_LEVEL]
+
+
+uint32 MUTILATE_A[] = {0, 0, 0, 0, 48664, 48664, 48664,48664, 48664};
+uint32 BACKSTAB_A[] = { 53, 2589, 2591, 8721, 11279, 11280, 11281, 25300, 25300 };
+uint32 SINISTER_STRIKE_A[] = { 1757, 1758, 1759, 8621, 11293, 11294, 26862, 48638, 48638 };
+uint32 SLICE_DICE_A[] = { 0, 5171, 5171, 5171, 6774, 6774, 6774, 6774, 6774, 6774 };
+uint32 EVISCERATE_A[]= { 11300, 11300, 11300, 11300, 11300, 11300, 11300, 11300, 11300 };
+uint32 KICK_A[] = { 0, 1766, 1767, 1767, 1768, 1769, 38768, 38768, 38768 };
+uint32 RUPTURE_A[] = { 0, 0, 1943, 8640, 11273, 11274, 11275, 26867, 48672, 48672 };
+uint32 WOUND_POISON_A[] = { 0, 0, 0, 13218, 13222, 13223, 13224, 27189, 57974, 57974 };
+uint32 DEADLY_POISON_A[] = { 0, 0, 0, 2818, 2819, 11354, 26968, 57969, 57969 };
+uint32 DISMANTLE_A[] = { 0, 0, 51722, 51722, 51722, 51722, 51722, 51722, 51722 };
+uint32 SHADOWSTEP_A[] = { 0, 0, 0, 0, 0, 36554, 36554, 36554, 36554 };
+
diff --git a/src/server/scripts/Bots/bot_shaman_ai.cpp b/src/server/scripts/Bots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..c2b5f5e
--- /dev/null
+++ b/src/server/scripts/Bots/bot_shaman_ai.cpp
@@ -0,0 +1,386 @@
+#include "ScriptPCH.h"
+#include "bot_shaman_ai.h"
+#include "Group.h"
+
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new shaman_botAI(pCreature);
+    }
+
+struct shaman_botAI : public bot_ai
+{
+    shaman_botAI(Creature *c) : bot_ai(c)
+    {
+        Reset();
+    }
+
+    int32 GC_Timer; //global cooldown
+    int32 Heal_Timer;
+    int32 Lesser_Healing_Timer;
+    int32 Self_Lesser_Healing_Timer;
+    int32 Flame_Shock_Timer;
+    int32 Earth_Shock_Timer;
+    int32 Lightning_Bolt_Timer;
+    int32 Others_Heal_Timer;
+    int32 Oom_timer;
+    int32 Potion_Timer;
+    int32 Rez_Timer;
+    int32 Earth_Totem_Timer;
+    int32 Water_Totem_Timer;
+    int32 Fire_Totem_Timer;
+    int32 Wind_Totem_Timer;
+
+    Unit *mobsTarget;
+    Unit *opponent;
+
+    void Reset()
+    {
+        GC_Timer = 0;
+        Heal_Timer = 0;
+        Lesser_Healing_Timer = 0;
+        Self_Lesser_Healing_Timer = 0;
+        Flame_Shock_Timer = 20;
+        Lightning_Bolt_Timer = 60;
+        Earth_Shock_Timer = 150;
+        Others_Heal_Timer = 0;
+        Oom_timer = 0;
+
+        Earth_Totem_Timer = 0;
+        Fire_Totem_Timer = 0;
+        Water_Totem_Timer = 0;
+        Wind_Totem_Timer = 0;
+
+        Potion_Timer = 0;
+        Rez_Timer = 0;
+
+        opponent = NULL;
+
+        if (master) {
+            setStats(CLASS_SHAMAN, m_creature->getRace(), master->getLevel());
+       }
+    }
+
+    bool isTimerReady(int32 timer)
+    {
+        if(timer <= 0 && GC_Timer <= 0) return true;
+        else                            return false;
+    } //end isTimerReady
+
+    void doCast(Unit *victim, uint32 spellId, bool triggered = false)
+    {
+        if(spellId == 0) return;
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+        GC_Timer = 40;
+        DoCast(victim, spellId, triggered);
+    } //end doCast
+
+    void decrementTimers()
+    {
+        if(GC_Timer > 0)             --GC_Timer;
+        if(Heal_Timer > 0)           --Heal_Timer;
+        if(Others_Heal_Timer > 0)    --Others_Heal_Timer;
+        if(Flame_Shock_Timer > 0)    --Flame_Shock_Timer;
+        if(Earth_Shock_Timer > 0)    --Earth_Shock_Timer;
+        if(Lightning_Bolt_Timer > 0) --Lightning_Bolt_Timer;
+        if(Rez_Timer > 0)            --Rez_Timer;
+        if(Potion_Timer > 0)         --Potion_Timer;
+        if(Earth_Totem_Timer > 0)    --Earth_Totem_Timer;
+        if(Fire_Totem_Timer > 0)     --Fire_Totem_Timer;
+        if(Water_Totem_Timer > 0)    --Water_Totem_Timer;
+        if(Wind_Totem_Timer > 0)     --Wind_Totem_Timer;
+    } //end decrementTImers
+
+    void KilledUnit(Unit *)
+    {
+        ((Player*)master)->SetBotCommandState(COMMAND_FOLLOW);
+    }
+
+    void Aggro(Unit *who){}
+
+    void EnterEvadeMode(){ Oom_timer = 0; }
+
+    void UpdateAI(const uint32 diff)
+    {
+        decrementTimers();
+
+        if(IAmDead()) return;
+
+        if(m_creature->GetPower(POWER_MANA) < 400 &&
+        isTimerReady(Potion_Timer))
+        {
+            doCast(m_creature, MANAPOTION);
+            Potion_Timer = 150;
+        }
+        if(m_creature->GetPower(POWER_MANA)/m_creature->GetMaxPower(POWER_MANA) < 10)
+        {
+            if(Oom_timer == 0)
+            {
+                //MonsterSay("OOM", LANG_UNIVERSAL, NULL);
+                Oom_timer = 1;
+            }
+        }
+
+        BuffAndHealGroup(master);
+
+        // Heal myself
+        HealTarget (m_creature, m_creature->GetHealth()*100 / m_creature->GetMaxHealth());
+
+        //the rest are combat so return if not fighting
+        opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+        if(!opponent && !m_creature->getVictim())
+        {
+            DoNonCombatActions();
+            ResetOrGetNextTarget();
+            return;
+        }
+
+        //Cast totems.
+        if(m_creature->isInCombat() &&
+        isTimerReady(Earth_Totem_Timer) &&
+        !master->HasAura(SPELL_STONESKIN_AURA, 0))
+        {
+            doCast(m_creature, SPELL_STONESKIN_TOTEM);
+            GiveManaBack();
+            Earth_Totem_Timer = 90;
+            return;
+        }
+
+        if(m_creature->isInCombat() &&
+        isTimerReady(Fire_Totem_Timer))
+        {
+            doCast(m_creature, SPELL_SEARING_TOTEM);
+            GiveManaBack();
+            Fire_Totem_Timer = 180;
+            return;
+        }
+
+        if(m_creature->isInCombat() &&
+        isTimerReady(Wind_Totem_Timer))
+        {
+            doCast(m_creature, SPELL_WINDFURY_TOTEM);
+            GiveManaBack();
+            Wind_Totem_Timer = 180;
+            return;
+        }
+
+        if(m_creature->isInCombat())
+        {
+            switch(master->getClass())
+            {
+                case CLASS_WARRIOR:
+                case CLASS_DEATH_KNIGHT:
+                case CLASS_ROGUE:
+                {
+                    if(isTimerReady(Water_Totem_Timer) &&
+                    !master->HasAura(SPELL_HEALINGSTREAM_AURA))
+                    {
+                        doCast(m_creature, SPELL_HEALINGSTREAM_TOTEM);
+                        Water_Totem_Timer = 90;
+                        GiveManaBack();
+                        return;
+                    }
+                    break;
+                }
+                default: //everyone else gets a mana totem
+                {
+                    if(isTimerReady (Water_Totem_Timer) &&
+                    !master->HasAura(SPELL_MANASPRING_AURA, 0))
+                    {
+                        doCast(m_creature, SPELL_MANASPRING_TOTEM);
+                        Water_Totem_Timer = 90;
+                        GiveManaBack();
+                        return;
+                    }
+                }
+            } //end switch
+
+        }
+
+
+        if(isTimerReady(Flame_Shock_Timer))
+        {
+            doCast(opponent, SPELL_FLAME_SHOCK);
+            Flame_Shock_Timer = 120;
+            return;
+        }
+
+        if(isTimerReady(Lightning_Bolt_Timer))
+        {
+            doCast(opponent, SPELL_LIGHTNING_BOLT);
+            Lightning_Bolt_Timer = 180;
+            return;
+        }
+
+        if(isTimerReady(Earth_Shock_Timer))
+        {
+            doCast(opponent, SPELL_EARTH_SHOCK);
+            Earth_Shock_Timer = 250;
+            return;
+        }
+
+        //now try to heal bots and pets.  DoSelectLowestHpFriendly will get
+        //everyone in group including bots and pets.  Unfortunately it can
+        //not be triggered for % of lost HP, so we just set it to -1000.
+        //This means low level players wont be healed because they wont have
+        //enough HP.
+        Unit *target = DoSelectLowestHpFriendly(40, 1000);
+        if(target)
+        {
+            if(CanCast(target, GetSpellStore()->LookupEntry (SPELL_CHAIN_HEAL)))
+            {
+                doCast(target, SPELL_CHAIN_HEAL, false);
+                Others_Heal_Timer = 50;
+            }
+        } else {
+            target = DoSelectLowestHpFriendly(40, 500); //now try someone with less HP lost
+            if(target)
+            {
+                if(CanCast(target, GetSpellStore()->LookupEntry (SPELL_CHAIN_HEAL)))
+                {
+                    doCast(target, SPELL_CHAIN_HEAL, false);
+                    Others_Heal_Timer = 100;
+                }
+            }
+        }
+
+        ScriptedAI::UpdateAI(diff);
+
+    } //end UpdateAI
+
+    void DoNonCombatActions()
+    {
+        Feast();
+
+        if(isTimerReady(GC_Timer) && !m_creature->HasAura(SPELL_LIGHTNING_SHIELD, 0))
+            doCast(m_creature, SPELL_LIGHTNING_SHIELD);
+
+        //Casts buffs
+       // if(!m_creature->isInCombat())
+       // {
+            //if(!m_creature->HasAura(SPELL_WINDFURY_WEAPON, 0)) doCast(m_creature, SPELL_WINDFURY_WEAPON);
+ //           if(isTimerReady(GC_Timer) && !m_creature->HasAura(SPELL_LIGHTNING_SHIELD, 0))
+   //             doCast(m_creature, SPELL_LIGHTNING_SHIELD);
+       // }
+
+
+        //Heal/rez others
+        //
+        //check group members, this doesn't check bots/pets.  They will be done later.  Preference
+        //goes to real players first.
+        //
+        //buff and heal group
+        if(master->GetGroup())
+        {
+            RezGroup(SPELL_SHAMAN_REZZ, master);
+            BuffAndHealGroup(master);
+           // CureGroup(master);
+        }
+
+
+        /* TESTING */
+        Group::MemberSlotList const &a =((Player*)master)->GetGroup()->GetMemberSlots();
+        for(Group::member_citerator itr = a.begin(); itr != a.end(); itr++)
+        {
+            Player *tPlayer = ((Player *)master)->GetObjPlayer(itr->guid);
+            if(tPlayer == NULL) continue;
+            //healing others
+            if(tPlayer->isAlive() &&
+            isTimerReady(Others_Heal_Timer) &&
+            tPlayer->GetGUID() != master->GetGUID() &&
+            tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75 &&
+            CanCast(tPlayer, GetSpellStore()->LookupEntry (SPELL_CHAIN_HEAL)))
+            {
+                doCast(tPlayer, SPELL_CHAIN_HEAL, false);
+                Others_Heal_Timer = 100;
+            }
+
+            //rezzes
+            if(tPlayer->isDead() &&
+            !m_creature->isInCombat() &&
+            //CanCast(tPlayer, GetSpellStore()->LookupEntry (SPELL_SHAMAN_REZZ)) &&
+            m_creature->GetDistance(tPlayer) < 40 &&
+            isTimerReady(Rez_Timer))
+            {
+                char *str = (char *)malloc(32);
+                sprintf(str, "Rezzing %s", tPlayer->GetName());
+                m_creature->MonsterSay(str, LANG_UNIVERSAL, NULL);
+                free(str);
+                doCast(tPlayer, SPELL_SHAMAN_REZZ, false);
+                Rez_Timer = 160;
+            }
+        }
+        /* TESTING */
+
+
+
+/* TESTING */
+        if((master->GetHealth()*100 / master->GetMaxHealth() < 90) && Lesser_Healing_Timer <= 0)
+        {
+            doCast(master, SPELL_LESSER_HEALING);
+            Lesser_Healing_Timer = 90;
+            Heal_Timer = Heal_Timer + 5; //wait 5 seconds before casting a real heal
+            //if(master->isInCombat()) && master->getVictim() == NULL) return;
+            return;
+        } else if(Lesser_Healing_Timer >= 0) --Lesser_Healing_Timer;
+
+        if((master->GetHealth()*100 / master->GetMaxHealth() < 75) && isTimerReady(Heal_Timer))
+        {
+            doCast(master, SPELL_CHAIN_HEAL);
+            Heal_Timer = 10;
+        }
+
+        if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 90)
+        {
+            if(Self_Lesser_Healing_Timer <= 0)
+            {
+                doCast(m_creature, SPELL_LESSER_HEALING);
+                Self_Lesser_Healing_Timer = 90;
+                return;
+            } else if(Self_Lesser_Healing_Timer >= 0)
+                --Self_Lesser_Healing_Timer;
+        }
+/* TESTING */
+        }
+
+    bool HealTarget(Unit *target, uint8 hp)
+    {
+        if (!isTimerReady(GC_Timer)) return false;
+        if (m_creature->IsNonMeleeSpellCasted(true)) return false;
+        if(!target || target->isDead()) return false;
+
+        if(hp < 90 && Lesser_Healing_Timer <= 0)
+        {
+            doCast(target, SPELL_LESSER_HEALING);
+            Lesser_Healing_Timer = 90;
+            Heal_Timer = Heal_Timer + 5; //wait 5 seconds before casting a real heal
+            //if(master->isInCombat()) && master->getVictim() == NULL) return;
+            return true;
+        } else if(Lesser_Healing_Timer >= 0) --Lesser_Healing_Timer;
+
+        if(hp < 75 && isTimerReady(Heal_Timer))
+        {
+            doCast(target, SPELL_CHAIN_HEAL);
+            Heal_Timer = 10;
+        }
+        return true;
+    } //end HealTarget
+
+    void ReceiveBowEmote(Player *player)
+    {
+        doCast(m_creature, SPELL_MANASPRING_TOTEM);
+    }
+
+
+}; //end shaman_bot
+};
+
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/scripts/Bots/bot_shaman_ai.h b/src/server/scripts/Bots/bot_shaman_ai.h
new file mode 100644
index 0000000..0574c5d
--- /dev/null
+++ b/src/server/scripts/Bots/bot_shaman_ai.h
@@ -0,0 +1,48 @@
+#include "bot_ai.h"
+
+#define SPELL_CHAIN_HEAL          SPELL_CHAIN_HEAL_A[SPELL_LEVEL]
+#define SPELL_LESSER_HEALING      SPELL_LESSER_HEALING_A[SPELL_LEVEL]
+
+#define SPELL_SHAMAN_REZZ         SPELL_SHAMAN_REZZ_A[SPELL_LEVEL]
+
+//Nukes
+#define SPELL_FLAME_SHOCK         SPELL_FLAME_SHOCK_A[SPELL_LEVEL]
+#define SPELL_LIGHTNING_BOLT      SPELL_LIGHTNING_BOLT_A[SPELL_LEVEL]
+#define SPELL_EARTH_SHOCK         SPELL_EARTH_SHOCK_A[SPELL_LEVEL]
+
+//BUFFS
+//#define SPELL_WINDFURY_WEAPON   10486 //rank 3
+#define SPELL_LIGHTNING_SHIELD    SPELL_LIGHTNING_SHIELD_A[SPELL_LEVEL]
+#define SPELL_STONESKIN_AURA      SPELL_STONESKIN_AURA_A[SPELL_LEVEL]
+#define SPELL_HEALINGSTREAM_AURA  SPELL_HEALINGSTREAM_AURA_A[SPELL_LEVEL]
+#define SPELL_MANASPRING_AURA     SPELL_MANASPRING_AURA_A[SPELL_LEVEL]
+
+//Totems
+#define SPELL_STONESKIN_TOTEM     SPELL_STONESKIN_TOTEM_A[SPELL_LEVEL]
+#define SPELL_HEALINGSTREAM_TOTEM SPELL_HEALINGSTREAM_TOTEM_A[SPELL_LEVEL]
+#define SPELL_MANASPRING_TOTEM    SPELL_MANASPRING_TOTEM_A[SPELL_LEVEL]
+#define SPELL_SEARING_TOTEM       SPELL_SEARING_TOTEM_A[SPELL_LEVEL]
+#define SPELL_WINDFURY_TOTEM      SPELL_WINDFURY_TOTEM_A[SPELL_LEVEL]
+
+uint32 SPELL_CHAIN_HEAL_A[] = { 0, 0, 0, 0, 1064, 10623, 25422, 25423, 55459, 55459 };
+uint32 SPELL_LESSER_HEALING_A[] = { 0, 0, 8004, 8010, 10466, 10467, 10468, 25420, 49275, 49275 };
+
+uint32 SPELL_LIGHTNING_BOLT_A[] = { 403, 548, 915, 6041, 10392, 15207, 25448, 45296, 45296 };
+uint32 SPELL_FLAME_SHOCK_A[] = { 0, 8050, 8052, 8053, 10447, 10448, 29228, 25457, 49232, 49232 };
+uint32 SPELL_EARTH_SHOCK_A[] = { 8042, 8045, 8046, 10412, 10413, 10414, 10414, 25454, 49230, 49230 };
+
+uint32 SPELL_LIGHTNING_SHIELD_A[] = {324, 325, 905, 945, 8134, 10431, 25469, 25472, 49280, 49280 };
+uint32 SPELL_SHAMAN_REZZ_A[] = {0, 2008, 20609, 20610, 20776, 20776, 20777, 25590, 49277, 49277 };
+
+uint32 SPELL_STONESKIN_AURA_A[] = { 8072, 8156, 8156, 10403, 10404, 10405, 25506, 58752, 58752, 58752 };
+uint32 SPELL_STONESKIN_TOTEM_A[] = { 8071, 8154, 8155, 10406, 10407, 10408, 25508, 25509, 25509, 25509 };
+
+uint32 SPELL_HEALINGSTREAM_AURA_A[] = { 0, 0, 5672, 6371, 6372, 10460, 10461, 25566, 58765, 58765 };
+uint32 SPELL_HEALINGSTREAM_TOTEM_A[] = { 0, 0, 5394, 6375, 6377, 10462, 10463, 25567, 58757, 58757 };
+
+uint32 SPELL_MANASPRING_AURA_A[] = { 0, 0, 5677, 10491, 10493, 10494, 25569, 25569, 58775, 58775 };
+uint32 SPELL_MANASPRING_TOTEM_A[] = { 0, 0, 5675, 10495, 10496, 10497, 25570, 25570, 58771, 58771 };
+
+uint32 SPELL_SEARING_TOTEM_A[] = { 0, 3599, 6363, 6364, 6365, 10437, 10438, 25533, 58699, 58699 };
+
+uint32 SPELL_WINDFURY_TOTEM_A[] = { 0, 0, 0, 0, 8512, 8512, 8512, 8512, 8512, 8512 };
diff --git a/src/server/scripts/Bots/bot_warlock_ai.cpp b/src/server/scripts/Bots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..109a65c
--- /dev/null
+++ b/src/server/scripts/Bots/bot_warlock_ai.cpp
@@ -0,0 +1,292 @@
+#include "ScriptPCH.h"
+#include "bot_warlock_ai.h"
+#include "Group.h"
+
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new warlock_botAI(pCreature);
+    }
+
+	struct warlock_botAI : public bot_ai
+	{
+		warlock_botAI(Creature *c) :bot_ai(c)
+		{
+			Reset();
+			pet = NULL;
+		}
+
+		bool oom_spam;
+
+		uint8 state;
+		uint8 next_state;
+		uint32 next_state_timer;
+
+		Creature *pet;
+		Unit *opponent;
+
+		void Reset()
+		{
+			FirstAid_cd = 0;
+			GC_Timer = 0;
+
+			conflagarate_cd = 0;
+			chaos_bolt_cd = 0;
+
+			oom_spam = false;
+
+			uint8 state = 1;
+			next_state = 0;
+			next_state_timer = 0;
+
+			opponent = NULL;
+
+			if (master) {
+				setStats(CLASS_WARLOCK, m_creature->getRace(), master->getLevel());
+
+				if (!m_creature->HasAura(56235)) m_creature->AddAura(56235,m_creature);  // Glyph of Conflagrate
+				if (!m_creature->HasAura(63302)) m_creature->AddAura(63302,m_creature);  // Glyph of Haunt
+				if (!m_creature->HasAura(17834)) m_creature->AddAura(17834,m_creature);  // Improved Immolation
+				if (!m_creature->HasAura(17814)) m_creature->AddAura(17814,m_creature);  // Improved Corruption
+
+			}
+		}
+
+		void CreatePet()
+		{
+			pet = master->GetBotsPet(60237);
+
+			if(pet == NULL)
+				return;
+
+			pet->UpdateCharmAI();
+			pet->setFaction(m_creature->getFaction());
+			pet->SetReactState(REACT_DEFENSIVE);
+			pet->GetMotionMaster()->MoveFollow(m_creature, PET_FOLLOW_DIST*urand(1, 2),PET_FOLLOW_ANGLE);
+			CharmInfo *charmInfonewbot = pet->InitCharmInfo();
+			pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+			pet->UpdateStats(STAT_STRENGTH);
+			pet->UpdateStats(STAT_AGILITY);
+			pet->SetLevel(master->getLevel());
+
+			float val2 = master->getLevel()*4.0f + pet->GetStat(STAT_STRENGTH)*2.0f;
+
+			val2=100.0;
+			uint32 attPowerMultiplier=1;
+			pet->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, uint32(val2));
+			pet->UpdateAttackPowerAndDamage();
+			pet->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, uint32(val2 * attPowerMultiplier));
+			pet->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, uint32(val2 * attPowerMultiplier)*2+master->getLevel());
+			pet->UpdateDamagePhysical(BASE_ATTACK);
+
+		}
+
+		void UpdateAI(const uint32 diff)
+		{
+
+			ReduceCD();
+
+			if(IAmDead()) return;
+
+			if(pet && pet != NULL && pet->isDead())
+			{
+				master->SetBotsPetDied();
+				pet = NULL;
+			}
+
+			//if we think we have a pet, but master doesn't, it means we teleported
+			if(pet && master->m_botHasPet == false)
+			{
+				master->SetBotsPetDied();
+				pet = NULL;
+			}
+
+			m_creature->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+			m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+			if(m_creature->GetHealth() < m_creature->GetMaxHealth()*0.3 && isTimerReady(Potion_cd))
+			{
+				doCast(m_creature, HEALINGPOTION);
+				Potion_cd = Potion_cd;
+			}
+			if(m_creature->GetPower(POWER_MANA) < m_creature->GetMaxPower(POWER_MANA)*0.2)
+			{
+				if(isTimerReady(Potion_cd))
+				{
+					doCast(m_creature, MANAPOTION);
+					//MonsterSay("MANA POTION", LANG_UNIVERSAL, NULL);
+					Potion_cd = Potion_cd;
+				} else {
+					if(oom_spam == false)
+					{
+						//MonsterSay("OOM", LANG_UNIVERSAL, NULL);
+						oom_spam = true;
+					}
+					ScriptedAI::UpdateAI(diff);
+					//return; //can't do anything without mana
+			   }
+			}
+			oom_spam = false;
+
+			ScriptedAI::UpdateAI(diff);
+
+			opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+			if(!opponent && !m_creature->getVictim())
+			{
+				ResetOrGetNextTarget();
+
+				//to reduce the number of crashes, remove pet whenever we are not in combat
+				if(pet != NULL && pet->isAlive())
+				{
+					master->SetBotsPetDied();
+					pet = NULL;
+				}
+
+				return;
+			}
+
+			if(pet == NULL)
+				CreatePet();
+
+			if (pet && pet->isAlive() &&
+				!pet->isInCombat() &&
+				m_creature->getVictim()) {
+				pet->Attack (m_creature->getVictim(), true);
+				pet->GetMotionMaster()->MoveChase(m_creature->getVictim(), 1, 0);
+			}
+
+			if(m_creature->HasUnitState(UNIT_STAT_CASTING))
+				return;
+
+			DoNormalAttack(diff);
+		}
+
+		void Aggro(Unit *who){}
+
+		void JustDied(Unit *Killer)
+		{
+			master->SetBotCommandState(COMMAND_FOLLOW);
+			state = 1;
+			next_state = 0;
+			next_state_timer = 0;
+			if(pet && pet != NULL)
+			{
+				master->SetBotsPetDied();
+				pet = NULL;
+			}
+		}
+
+		void AttackStart(Unit *u)
+		{
+			Aggro(u);
+			ScriptedAI::AttackStartCaster(u, 25);
+		}
+
+		void KilledUnit(Unit *)
+		{
+			((Player*)master)->SetBotCommandState(COMMAND_FOLLOW);
+			if(pet && pet->isAlive()) pet->GetMotionMaster()->MoveFollow(m_creature, PET_FOLLOW_DIST*urand(1, 2), PET_FOLLOW_ANGLE);
+		}
+
+		void DoNormalAttack(const uint32 diff)
+		{
+			AttackerSet m_attackers = master->getAttackers();
+			if(opponent == NULL) return;
+			if(opponent->isDead()) return;
+
+			//double check that pet didn't just die
+			if(pet && pet != NULL && pet->isDead())
+			{
+				master->SetBotsPetDied();
+				pet = NULL;
+			}
+
+			//send in the pet
+			if(pet && pet != NULL && pet->isAlive() && !pet->isInCombat()) pet->AI()->AttackStart(opponent);
+
+			if(!isTimerReady(GC_Timer)) return;
+
+			if(opponent->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+			{
+				//MonsterSay("Mob is fleeing!", LANG_UNIVERSAL, NULL);
+				return;
+			}
+
+
+			//if(RAIN_OF_FIRE && m_attackers.size() > 1)
+			//{
+				//doCast(opponent, RAIN_OF_FIRE);
+				//return;
+			//}
+			if(CURSE_OF_THE_ELEMENTS && !HasAuraName(opponent, CURSE_OF_THE_ELEMENTS))
+			{
+				doCast(opponent, CURSE_OF_THE_ELEMENTS);
+				GiveManaBack();
+				//return;
+			}
+
+			if(CORRUPTION && !HasAuraName (opponent, CORRUPTION, m_creature->GetGUID()))
+			{
+				doCast(opponent, CORRUPTION);
+				GiveManaBack();
+				//return;
+			}
+
+			if(HAUNT && !HasAuraName (opponent, HAUNT, m_creature->GetGUID()))
+			{
+				doCast(opponent, HAUNT);
+				GiveManaBack();
+				return;
+			}
+
+			if(UNSTABLE_AFFLICTION && !HasAuraName (opponent, UNSTABLE_AFFLICTION, m_creature->GetGUID()))
+			{
+				doCast(opponent, UNSTABLE_AFFLICTION);
+				GiveManaBack();
+				return;
+			}
+
+			if(!HasAuraName(opponent, IMMOLATE, m_creature->GetGUID()))
+			{
+				doCast(opponent, IMMOLATE);
+				GiveManaBack();
+				return;
+			} else if(CONFLAGRATE && isTimerReady(conflagarate_cd))
+			{
+				doCast(opponent, CONFLAGRATE);
+				conflagarate_cd = CONFLAGRATE_CD;
+				GiveManaBack();
+				return;
+			}
+
+			if(CHAOS_BOLT && isTimerReady(chaos_bolt_cd))
+			{
+				doCast(opponent, CHAOS_BOLT);
+				GiveManaBack();
+				chaos_bolt_cd = CHAOS_BOLT_CD;
+				return;
+			} else
+				doCast(opponent, SHADOW_BOLT);
+			GiveManaBack();
+		} //DoNormalAttack
+
+		void ReduceCD()
+		{
+			if(Potion_cd > 0)       --Potion_cd;
+			if(FirstAid_cd > 0)     --FirstAid_cd;
+			if(GC_Timer > 0)        --GC_Timer;
+
+			if(conflagarate_cd > 0) --conflagarate_cd;
+			if(chaos_bolt_cd > 0)   --chaos_bolt_cd;
+		}
+	};
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+}
diff --git a/src/server/scripts/Bots/bot_warlock_ai.h b/src/server/scripts/Bots/bot_warlock_ai.h
new file mode 100644
index 0000000..4778772
--- /dev/null
+++ b/src/server/scripts/Bots/bot_warlock_ai.h
@@ -0,0 +1,42 @@
+#include "bot_ai.h"
+
+
+uint32 conflagarate_cd;
+uint32 chaos_bolt_cd;
+
+#define CONFLAGRATE_CD  100
+#define CHAOS_BOLT_CD   120
+#define RAIN_OF_FIRE_CD 300
+
+#define PET_VOIDWALKER 697
+
+//Curses
+#define CURSE_OF_THE_ELEMENTS SPELL_CURSE_OF_THE_ELEMENTS_A[SPELL_LEVEL]
+
+//DESTRUCTION
+#define SHADOW_BOLT         SPELL_SHADOW_BOLT_A[SPELL_LEVEL]
+#define IMMOLATE            SPELL_IMMOLATE_A[SPELL_LEVEL]
+#define CONFLAGRATE         SPELL_CONFLAGRATE_A[SPELL_LEVEL]
+#define CHAOS_BOLT          SPELL_CHAOS_BOLT_A[SPELL_LEVEL]
+#define RAIN_OF_FIRE        SPELL_RAIN_OF_FIRE_A[SPELL_LEVEL]
+
+//AFFLICTION
+#define HAUNT               SPELL_HAUNT_A[SPELL_LEVEL]
+#define CORRUPTION          SPELL_CORRUPTION_A[SPELL_LEVEL]
+#define UNSTABLE_AFFLICTION SPELL_UNSTABLE_AFFLICTION_A[SPELL_LEVEL]
+
+//curses
+uint32 SPELL_CURSE_OF_THE_ELEMENTS_A[] = { 0, 0, 0, 1490, 11721, 11721, 11722, 27728, 47865 };
+
+//destruction spells
+uint32 SPELL_SHADOW_BOLT_A[] = { 686, 705, 1088, 7641, 11659, 11660, 25307, 47808, 47809 };
+uint32 SPELL_IMMOLATE_A[] = { 348, 707, 1094, 2941, 11665, 11667, 25309, 47810, 47811 };
+uint32 SPELL_CONFLAGRATE_A[] = { 0, 0, 0, 0, 17962, 17962, 17962, 17962, 17962 };
+uint32 SPELL_CHAOS_BOLT_A[] = { 0, 0, 0, 0, 0, 50796, 50796, 50796, 50796 };
+uint32 SPELL_RAIN_OF_FIRE_A[] = { 0, 0, 5740, 6219, 11677, 11678, 11678, 27212, 27212 };
+
+//affliction spells
+uint32 SPELL_HAUNT_A[] = { 0, 0, 0, 0, 0, 0, 59164, 59164, 59164 };
+uint32 SPELL_CORRUPTION_A[] = { 172, 6222, 7648, 11671, 11672, 25311, 47812, 47835, 47836 };
+uint32 SPELL_UNSTABLE_AFFLICTION_A[] = { 0, 0, 0, 0, 0, 30404, 30405, 47843,  47843 };
+
diff --git a/src/server/scripts/Bots/bot_warrior_ai.cpp b/src/server/scripts/Bots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..54a8b55
--- /dev/null
+++ b/src/server/scripts/Bots/bot_warrior_ai.cpp
@@ -0,0 +1,502 @@
+    /* ScriptData
+    SDName: pvp_warrior
+    SD%Complete: 0
+    SDComment: paytheo help from Gasilli
+    SDCategory: Custom
+    EndScriptData */
+#include "ScriptPCH.h"
+//#include "../../game/Player.h"
+#include "bot_warrior_ai.h"
+#include "Group.h"
+
+bool castDemoralizingShout;
+bool battleStance;
+bool defensiveStance;
+bool berserkerStance;
+
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new warrior_botAI(pCreature);
+    }
+
+	struct warrior_botAI : public bot_ai
+	{
+		warrior_botAI(Creature *c) : bot_ai(c)
+		{
+			Reset();
+		}
+
+		uint32 charge_cd;
+		uint32 deathWish_cd;
+		uint32 mortalStrike_cd;
+		uint32 overpower_cd;
+		uint32 retaliation_recklessness_shieldwall_cd;
+		uint32 berserkerRage_cd;
+		uint32 challengingShout_cd;
+		uint32 battleShout_cd;
+		uint32 intercept_cd;
+		uint32 intimidatingShout_cd;
+		uint32 pummel_cd;
+		uint32 whirlwind_cd;
+		uint32 bloodrage_cd;
+		uint32 disarm_cd;
+		uint32 intervene_cd;
+		uint32 shieldBash_cd;
+		uint32 spellReflection_cd;
+		uint32 potion_cd;
+		uint32 firstAid_cd;
+		uint32 pvpTrinket_cd;
+		uint32 taunt_cd;
+		uint32 sunder_cd;
+		uint32 rage;
+		uint32 yellRage;
+		uint32 GCD;
+		int32 Noggenfogger_Timer;
+
+
+		void Reset()
+		{
+			charge_cd = 0;
+			deathWish_cd = 0;
+			mortalStrike_cd = 0;
+			overpower_cd = 0;
+			retaliation_recklessness_shieldwall_cd = 0;
+			berserkerRage_cd = 0;
+			challengingShout_cd = 0;
+			battleShout_cd = 0;
+			intercept_cd = 0;
+			intimidatingShout_cd = 0;
+			pummel_cd = 0;
+			whirlwind_cd = 0;
+			bloodrage_cd = 0;
+			disarm_cd = 0;
+			intervene_cd = 0;
+			shieldBash_cd = 0;
+			spellReflection_cd = 0;
+			potion_cd = 0;
+			firstAid_cd = 0;
+			pvpTrinket_cd = 0;
+			taunt_cd = 0;
+			sunder_cd = 0;
+			rage = 0;
+			yellRage = 0;
+			GCD = 0;
+			castDemoralizingShout = false;
+			battleStance = true;
+			defensiveStance = false;
+			berserkerStance = false;
+
+			Noggenfogger_Timer = 0;
+			m_creature->setPowerType(POWER_RAGE);
+
+			if (master) {
+				setStats(CLASS_WARRIOR, m_creature->getRace(), master->getLevel());
+			}
+		}
+
+		void EnterEvadeMode(){}
+
+		void doCast(Unit *victim, uint32 spellId, bool triggered = false)
+		{
+			if(spellId == 0) return;
+
+			GCD = 2000;
+			DoCast(victim, spellId, triggered);
+		} //end doCast
+
+		bool isTimerReady(int32 timer, uint32 diff)
+		{
+			if(timer <= 0 && GCD < diff)    return true;
+			else                            return false;
+		}
+
+
+		void UpdateAI(const uint32 diff)
+		{
+			ReduceCD(diff);
+
+			if(IAmDead()) return;
+
+			//Use Noggenfogger potion if a tauren
+			if(master->GetBotRace() == RACE_TAUREN &&
+			isTimerReady(Noggenfogger_Timer, diff))
+			{
+				uint64 m_rand = urand(1, 2);
+				switch(m_rand)
+				{
+					case 1:
+							doCast(m_creature, SPELL_NOGGENFOGGER_SKELETON, true);
+							break;
+					case 2:
+							doCast(m_creature, SPELL_NOGGENFOGGER_SMALL, true);
+							break;
+				}
+				Noggenfogger_Timer = 6000; //10 minutes
+			}
+
+
+			Unit *opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+			if(!opponent && !m_creature->getVictim())
+			{
+				ResetOrGetNextTarget();
+				if(rage > 0)
+				{
+					--rage;
+					//m_creature->SetPower(POWER_RAGE, rage*10);
+				}
+				return;
+			}
+
+			rage = m_creature->GetPower(POWER_RAGE);
+
+			m_creature->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+			m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+			if(m_creature->GetHealth() < m_creature->GetMaxHealth()*0.2 &&
+				potion_cd<diff && GCD < diff)
+			{
+				doCast(m_creature, HEALINGPOTION);
+				potion_cd = POTIONCD;
+			}
+
+			if(!m_creature->HasAura(BATTLESHOUT) && rage > 10 && GCD < diff &&
+				battleShout_cd<diff)
+			{
+				doCast(m_creature, BATTLESHOUT);
+				//rage -= 10;
+				battleShout_cd = BATTLESHOUT_CD;
+			}
+
+			//if(rage > 100)
+			//{
+				//rage = 0;
+			//}
+
+			if(bloodrage_cd < diff       &&
+				m_creature->isInCombat() &&
+				opponent                 &&
+				GCD < diff)
+			{
+				doCast(m_creature, BLOODRAGE);
+				bloodrage_cd = BLOODRAGE_CD;
+				//rage += 10;
+			}
+
+			if(!m_creature->SelectVictim() || !m_creature->getVictim())
+			{
+				ResetOrGetNextTarget();
+				return;
+			}
+
+			BreakCC(diff);
+			Attack(diff);
+
+			ScriptedAI::UpdateAI(diff);
+		}
+
+
+		void AttackStart(Unit *u)
+		{
+			Aggro(u);
+			ScriptedAI::AttackStart(u);
+		}
+
+		void Aggro(Unit *who)
+		{
+			//Unit *opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+			Unit *opponent = who;
+
+			if(!opponent) return;
+
+			if((m_creature->GetDistance(opponent) > 15) &&
+			(m_creature->GetDistance(opponent) < 25) &&
+			charge_cd <= 0)
+			{
+				doCast(opponent, CHARGE);
+				charge_cd = CHARGE_CD;
+			}
+
+			if(opponent->getClass() == CLASS_ROGUE ||
+			opponent->getClass() == CLASS_WARRIOR  ||
+			opponent->getClass() == CLASS_SHAMAN   ||
+			opponent->getClass() == CLASS_DRUID    ||
+			opponent->getClass() == CLASS_PALADIN  ||
+			opponent->getClass() == CLASS_HUNTER)
+				castDemoralizingShout = true;
+		} //end Aggro
+
+		void KilledUnit(Unit *Victim)
+		{
+			master->SetBotCommandState(COMMAND_FOLLOW);
+			//DoPlaySoundToSet(m_creature, 8852);
+			//m_creature->Yell("Haha! Im just getting warmed up!", LANG_UNIVERSAL, NULL);
+		}
+
+		void JustDied(Unit *Killer)
+		{
+			DoPlaySoundToSet(m_creature, 8860);
+			master->SetBotCommandState(COMMAND_FOLLOW);
+			//m_creature->Yell("An honorable.. death..", LANG_UNIVERSAL, NULL);
+		}
+
+		void BreakCC(const uint32 diff)
+		{
+			 if(pvpTrinket_cd < diff && GCD < diff)
+			 {
+				 if(m_creature->HasAuraType(SPELL_AURA_MOD_ROOT)  ||
+				 m_creature->HasAuraType(SPELL_AURA_MOD_CONFUSE)  || //dragons breath/blind/poly
+				 m_creature->HasAura(8983)                        || //Druid bash rank 3
+				 m_creature->HasAura(27006)                       || //Druid pounce rank 4
+				 m_creature->HasAura(33786)                       || //Druid cyclone
+				 m_creature->HasAura(22570, 1)                    || //Druid maim
+				 m_creature->HasAura(10308)                       || //Paladin hammer of justice rank 4
+				 m_creature->HasAura(30414, 1)                    || //Warlock shadowfury rank 3
+				 m_creature->HasAura(6215)                        || //Warlock fear rank 3 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+				 m_creature->HasAura(17928)                       || //Warlock howlofterror rank 3 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+				 m_creature->HasAura(10890)                       || //Priest psychic scream rank 4 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+				 m_creature->HasAura(14902)                       || //Rogue Cheap shot
+				 m_creature->HasAura(8643)                        || //Rogue Kidney shot Rank 2
+				 m_creature->HasAura(38764, 2)                    || //Rogue Gouge Rank 6 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+				 m_creature->HasAura(12809))                         //Warrior concussion blow
+				{
+					doCast(m_creature, PVPTRINKET); //I think it would be better to instead of applying individual spells that apply the
+					pvpTrinket_cd = PVPTRINKET_CD;  //effect SPELL_AURA_MOD_STUN, just add that type and start removing bad choices e.g. impact.
+				}
+
+				if(m_creature->HasAura(11297) && m_creature->GetDistance(m_creature->getVictim()) < 10)
+				{   //if warrior sapped and creature is less then 10 yards from warrior, cast pvp trinket and attempt to demoralizing shout him out of stealth
+					doCast(m_creature, PVPTRINKET);
+					pvpTrinket_cd = PVPTRINKET_CD;
+					castDemoralizingShout = true;
+				}
+			}
+		} //BreakCC
+
+		void Attack(const uint32 diff)
+		{
+			//Unit *opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+			Unit *opponent = m_creature->getVictim();
+			if(!opponent) return;
+
+			if((m_creature->GetDistance(opponent) > 13)      &&
+			(m_creature->GetDistance(opponent) < 25)         &&
+			!m_creature->HasAuraType(SPELL_AURA_MOD_ROOT)    &&
+			!m_creature->HasAuraType(SPELL_AURA_MOD_STUN)    &&
+			!m_creature->HasAuraType(SPELL_AURA_MOD_CONFUSE) &&
+			(intercept_cd < diff)                            &&
+			(rage > 10)                                      &&
+			(GCD < diff))
+			{
+				if(berserkerStance == true)
+				{
+					doCast(opponent, INTERCEPT, true);
+					intercept_cd = INTERCEPT_CD;
+					//rage -= 10;
+				} else stanceChange(3);
+			}
+
+			if(disarm_cd < diff                                           &&
+				(opponent->GetHealth()*100/opponent->GetMaxHealth()) < 80 &&
+				rage > 15                                                 &&
+				!HasAuraName(opponent, GetSpellName(DISARM))              &&
+				GCD < diff)
+			{
+				if(opponent->getClass() == CLASS_ROGUE  ||
+					opponent->getClass() == CLASS_WARRIOR   ||
+					opponent->getClass() == CLASS_SHAMAN    ||
+					opponent->getClass() == CLASS_PALADIN)
+				{
+					if(defensiveStance == true)
+					{
+						doCast(opponent, DISARM, true);
+						//rage -= 15;
+						disarm_cd = DISARM_CD;
+					} else stanceChange(2);
+				}
+			}
+
+			//opponent is not attacking me so try to taunt it
+			if(opponent->getVictim() &&
+			   opponent->getVictim()->GetGUID() != m_creature->GetGUID() &&
+			   taunt_cd < diff &&
+			   GCD < diff)
+			{
+				if(battleStance != true)
+				{
+					doCast(m_creature, DEFENSIVESTANCE, true);
+					defensiveStance = true;
+				}
+				doCast(opponent, TAUNT, true);
+				doCast(m_creature, TAUNT_VISUAL, true);
+				taunt_cd = TAUNT_CD;
+			}
+
+	/*        if(sunder_cd < diff && GCD < diff)
+			{
+	sLog->outError ("SUNDER");
+				doCast(opponent, SUNDER, true);
+				//rage -= 15;
+				sunder_cd = SUNDER_CD;
+			}
+	*/
+			if((opponent->GetHealth()*100/opponent->GetMaxHealth()) < 15 &&
+				rage > 15                                                    &&
+				GCD < diff)
+			{
+				if(battleStance == true || berserkerStance == true)
+				{
+					int damage = (rage*4 + (m_creature->getLevel()*10))/2;
+
+					m_creature->CastCustomSpell(opponent, EXECUTE, &damage, NULL, NULL, false, NULL, NULL);
+					//rage = 0;
+					//m_creature->SetPower(POWER_RAGE, 0);
+					GCD = 20;
+				} else stanceChange(5);
+			}
+
+			if(mortalStrike_cd < diff               &&
+			   rage > 15                               &&
+			   GCD < diff)
+			{
+				doCast(opponent, MORTALSTRIKE, true);
+				mortalStrike_cd = MORTALSTRIKE_CD;
+				//rage -= 15;
+			}
+
+			if(castDemoralizingShout == true         &&
+			   !opponent->HasAura(DEMORALIZINGSHOUT)    &&
+			   rage < 10 && GCD < diff)
+			{
+				doCast(opponent, DEMORALIZINGSHOUT, true);
+				//rage -= 10;
+				castDemoralizingShout = false;
+			}
+
+			if(opponent->IsNonMeleeSpellCasted(true) &&
+			   pummel_cd < diff                         &&
+			   rage > 10                                &&
+			   GCD < diff)
+			{
+				if(berserkerStance == true)
+				{
+					doCast(opponent, PUMMEL, true);
+					pummel_cd = PUMMEL_CD;
+					//rage -= 10;
+				} else stanceChange(3);
+			}
+
+			if(whirlwind_cd < diff                &&
+			   rage > 25                             &&
+			   GCD < diff)
+			{
+				if(berserkerStance == true)
+				{
+					doCast(opponent, WHIRLWIND, true);
+					whirlwind_cd = WHIRLWIND_CD;
+					//rage -= 25;
+				} else stanceChange(3);
+			}
+
+			if(!opponent->HasAura(REND)                 &&
+			   rage > 10                                &&
+			   GCD < diff)
+			{
+				if(battleStance == true || defensiveStance == true)
+				{
+					doCast(opponent, REND, true);
+					//rage -= 10;
+				} else stanceChange(1);
+			}
+
+			if(!opponent->HasAura(HAMSTRING, 1)         &&
+				rage > 10                               &&
+				GCD < diff)
+			{
+				if(battleStance == true ||
+				berserkerStance == true)
+				{
+					doCast(opponent, HAMSTRING, true);
+					//rage -= 10;
+				} else stanceChange(5);
+			}
+
+		}
+
+		void stanceChange(uint32 stance)
+		{
+		 //if(rage > 20)
+			 //rage = 20;
+
+			if(stance == 5)
+			{
+				switch(rand()%2)
+				{
+				case 0:
+					stance = 1; break;
+				case 1:
+					stance = 3; break;
+				}
+			}
+
+			battleStance = false;
+			defensiveStance = false;
+			berserkerStance = false;
+
+			switch(stance)
+			{
+			case 1:
+				doCast(m_creature, BATTLESTANCE);
+				battleStance = true;
+				break;
+			case 2:
+				doCast(m_creature, DEFENSIVESTANCE);
+				defensiveStance = true;
+				break;
+			case 3:
+				doCast(m_creature, BERSERKERSTANCE);
+				berserkerStance = true;
+				break;
+			}
+		}
+
+		void ReduceCD(const uint32 diff)
+		{
+			if(!(deathWish_cd < diff))                  deathWish_cd -= diff;
+			if(!(mortalStrike_cd < diff))               mortalStrike_cd -= diff;
+			if(!(overpower_cd < diff))                 overpower_cd -= diff;
+			if(!(retaliation_recklessness_shieldwall_cd < diff))  retaliation_recklessness_shieldwall_cd -= diff;
+			if(!(berserkerRage_cd < diff))              berserkerRage_cd -= diff;
+			if(!(intercept_cd < diff))                  intercept_cd -= diff;
+			if(!(intimidatingShout_cd < diff))          intimidatingShout_cd -= diff;
+			if(!(pummel_cd < diff))                     pummel_cd -= diff;
+			if(!(whirlwind_cd < diff))                  whirlwind_cd -= diff;
+			if(!(bloodrage_cd < diff))                  bloodrage_cd -= diff;
+			if(!(disarm_cd < diff))                     disarm_cd -= diff;
+			if(!(intervene_cd < diff))                  intervene_cd -= diff;
+			if(!(shieldBash_cd < diff))                 shieldBash_cd -= diff;
+			if(!(spellReflection_cd < diff))            spellReflection_cd -= diff;
+			if(!(potion_cd < diff))                     potion_cd -= diff;
+			if(!(yellRage < diff))                      yellRage -= diff;
+			if(!(firstAid_cd < diff))                   firstAid_cd -= diff;
+			if(!(taunt_cd < diff))                      taunt_cd -= diff;
+			if(!(sunder_cd < diff))                     sunder_cd -= diff;
+			if(!(battleShout_cd < diff))                battleShout_cd -= diff;
+			if(!(GCD < diff))                           GCD -= diff;
+			else                                        GCD = 0;
+
+			if(charge_cd > 0)                           --charge_cd; //this is treated different
+			if(Noggenfogger_Timer >= 0)                --Noggenfogger_Timer;
+
+		}
+	};
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/scripts/Bots/bot_warrior_ai.h b/src/server/scripts/Bots/bot_warrior_ai.h
new file mode 100644
index 0000000..8d1e0ef
--- /dev/null
+++ b/src/server/scripts/Bots/bot_warrior_ai.h
@@ -0,0 +1,87 @@
+#include "bot_ai.h"
+
+
+//Cooldown/Timers
+#define CHARGE_CD 100
+#define DEATHWISH_CD 180000
+#define MORTALSTRIKE_CD 7000
+#define OVERPOWER_CD 5000
+#define RETALIATION_RECKLESSNESS_SHIELDWALL_CD 1800000
+#define BERSERKERRAGE_CD 30000
+#define INTERCEPT_CD 15000
+#define INTIMIDATINGSHOUT_CD 120000
+#define PUMMEL_CD 10000
+#define WHIRLWIND_CD 10000
+#define BLOODRAGE_CD 60000
+#define DISARM_CD 60000
+#define INTERVENE_CD 30000
+#define BATTLESHOUT_CD 30000
+#define SHIELDBASH_CD 12000
+#define SPELLREFLECTION_CD 10000
+#define PVPTRINKET_CD 120000
+#define TAUNT_CD 8000
+#define SUNDER_CD 8000
+
+//others
+#define PVPTRINKET 42292
+#define YELLRAGE_CD 5000
+
+#define SPELL_NOGGENFOGGER_SMALL    16595
+#define SPELL_NOGGENFOGGER_SKELETON    16591
+
+//spells
+#define TAUNT              355
+#define TAUNT_VISUAL       34105
+#define CHALLENGING_SHOUT   1161
+
+/*
+ *  Some spells NPCs can't seem to cast.  So for those that I couldn't
+ *  get to work, I used an NPC equivalent version.  Most of these don't
+ *  have different levels so it is one spell for all levels.  This
+ *  leads it to be over/under powered in some levels.  Oh well.
+ *  An example is BattleShout.
+ */
+
+//Defensive Stance
+#define DEFENSIVESTANCE     71
+#define DISARM              676 //DISARM_A[SPELL_LEVEL]
+#define BLOODRAGE           29131 //2687 original warrior spell
+
+
+//Berserker Stance
+#define BERSERKERSTANCE     7366 //2458 original warrior spell
+#define BERSERKERRAGE       18499
+
+//#define BATTLESHOUT       26043
+#define COMMANDINGSHOUT     469
+#define BATTLESHOUT         BATTLESHOUT_A[SPELL_LEVEL]
+//#define EXECUTE           EXECUTE_A[SPELL_LEVEL]
+#define EXECUTE             38959 //25236 original warrior spell
+#define WHIRLWIND           WHIRLDWIND_A[SPELL_LEVEL]
+//#define PUMMEL            PUMMEL_A[SPELL_LEVEL]
+#define PUMMEL              15615 //6554 original warrior spell
+//#define DEMORALIZINGSHOUT 29584 //25203 original warrior spell
+#define DEMORALIZINGSHOUT   29584 //25203 original warrior spell
+#define INTERCEPT           27577 //25275 original warrior spell
+
+
+//Battle Stance
+#define BATTLESTANCE        7165 //2457 original warrior one
+//#define CHARGE            CHARGE_A[SPELL_LEVEL]
+#define CHARGE              37511 //11578 original warrior one
+#define HAMSTRING           HAMSTRING_A[SPELL_LEVEL]
+#define REND                REND_A[SPELL_LEVEL]
+#define MORTALSTRIKE        MORTALSTRIKE_A[SPELL_LEVEL]
+#define SUNDER              SUNDER_A[SPELL_LEVEL]
+
+
+//uint32 BATTLESHOUT_A[] = { 6673, 5242, 6192, 11549, 11550, 11551, 25289, 2048, 47436 };
+uint32 BATTLESHOUT_A[] = { 9128, 9128, 9128, 27578, 27578, 26043, 26043, 26043, 26043 };
+uint32 REND_A[] = { 772, 6546, 6547, 6548, 11572, 11573, 11574, 25208, 46845 };
+uint32 CHARGE_A[] = { 100, 100, 6178, 11578, 11578, 11578, 11578, 11578, 11578 };
+uint32 HAMSTRING_A[] = { 1715, 1715, 1715, 7372, 7372, 7373, 7373, 25212, 25212 };
+uint32 EXECUTE_A[] = { 1715, 1715, 1715, 7372, 7372, 7373, 7373, 25212, 25212 };
+uint32 WHIRLDWIND_A[] = { 0, 0, 0, 0, 1680, 1680, 1680, 1680, 1680 };
+uint32 PUMMEL_A[] = { 0, 0, 0, 0, 6552, 6552, 6552, 6552, 6552 };
+uint32 MORTALSTRIKE_A[] = { 0, 0, 0, 0, 12294, 21552, 21553, 25248, 47485 };
+uint32 SUNDER_A[] = { 0, 7386, 7405, 8380, 11596, 11597, 25225, 47467, 47467 };
diff --git a/src/server/scripts/Bots/script_bot_giver.cpp b/src/server/scripts/Bots/script_bot_giver.cpp
new file mode 100644
index 0000000..00a90a7
--- /dev/null
+++ b/src/server/scripts/Bots/script_bot_giver.cpp
@@ -0,0 +1,233 @@
+#include "ScriptPCH.h"
+#include <cstring>
+#include "Group.h"
+
+//This function is called when the player opens the gossip menubool
+class script_bot_giver : public CreatureScript
+{
+	public:
+
+		script_bot_giver()
+            : CreatureScript("script_bot_giver")
+        {
+        }
+
+		bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 action)
+		{
+			switch(sender)
+			{
+				case 6006: SendCreateNPCBotMenu(player, creature, action); break;
+				case 6001: SendCreateNPCBot(player, creature, action); break;
+				case 6002: SendCreatePlayerBotMenu(player, creature, action); break;
+				case 6003: SendCreatePlayerBot(player, creature, action); break;
+				case 6004: SendRemovePlayerBotMenu(player, creature, action); break;
+				case 6005: SendRemovePlayerBot(player, creature, action); break;
+			}
+			return true;
+		}
+
+		bool OnGossipHello(Player *player, Creature *creature)
+		{
+			WorldSession *session = player->GetSession();
+			uint8 count = 0;
+
+			for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+			{
+				if(count == 0)
+					player->ADD_GOSSIP_ITEM(0, "Abandon Your Player?", 6004, GOSSIP_ACTION_INFO_DEF + 100);
+
+				++count;
+			}
+
+			if(player->HaveBot())
+			{
+				player->ADD_GOSSIP_ITEM(0, "Abandon Your Minion?", 6001, GOSSIP_ACTION_INFO_DEF + 101);
+			} else
+				player->ADD_GOSSIP_ITEM(0, "Recruit a Minion", 6006, GOSSIP_ACTION_INFO_DEF + 2);
+
+			if(count < player->GetMaxPlayerBot()) player->ADD_GOSSIP_ITEM(0, "Recruit a Player", 6002, GOSSIP_ACTION_INFO_DEF + 1);
+
+			player->PlayerTalkClass->SendGossipMenu(907, creature->GetGUID());
+			return true;
+		}
+
+		void SendCreatePlayerBot(Player *player, Creature *creature, uint32 action)
+		{
+			std::list<std::string> *names;
+			names = player->GetCharacterList();
+			if(names == NULL || names->empty())
+			{
+				player->CLOSE_GOSSIP_MENU();
+				return;
+			}
+
+			int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+
+			std::list<std::string>::iterator iter, next;
+			for(iter = names->begin(); iter != names->end(); iter++)
+			{
+				if (x==0) player->CreatePlayerBot((*iter).c_str());
+				else {
+					if(x == 1)
+					{
+						player->CreatePlayerBot((*iter).c_str());
+						break;
+					}
+					--x;
+				}
+			}
+
+			player->CLOSE_GOSSIP_MENU();
+		} //end SendCreatePlayerBot
+
+		void SendCreatePlayerBotMenu(Player *player, Creature *creature, uint32 action)
+		{
+			std::list<std::string> *names;
+			names = player->GetCharacterList();
+			if(names == NULL || names->empty())
+			{
+				player->CLOSE_GOSSIP_MENU();
+				return;
+			}
+
+            player->PlayerTalkClass->ClearMenus();
+			player->ADD_GOSSIP_ITEM(9, "ADD ALL" , 6003, GOSSIP_ACTION_INFO_DEF + 1);
+			int8 x = 2;
+
+			std::list<std::string>::iterator iter, next;
+			for(iter = names->begin(); iter != names->end(); iter++)
+			{
+				//sLog->outError("character : %s", (*iter).c_str());
+				player->ADD_GOSSIP_ITEM(9, (*iter).c_str() , 6003, GOSSIP_ACTION_INFO_DEF + x);
+				++x;
+			}
+			player->SEND_GOSSIP_MENU(907, creature->GetGUID());
+		} //end SendCreatePlayerBotMenu
+
+		void SendRemovePlayerBotAll(Player *player, Creature *creature) {
+			for (int8 x = 2; x<=10; x++ )
+			{
+				SendRemovePlayerBot (player, creature, GOSSIP_ACTION_INFO_DEF + 2);
+			}
+		}
+
+		void SendRemovePlayerBot(Player *player, Creature *creature, uint32 action)
+		{
+			int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+
+			if (x == 0) {
+				SendRemovePlayerBotAll(player, creature);
+				return;
+			}
+
+			WorldSession *session = player->GetSession();
+			for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+			{
+				if(x == 1 && itr->second && itr->second->GetGroup())
+				{
+					Player *m_bot = itr->second;
+					Group *m_group = m_bot->GetGroup();
+
+					//removing bot from group
+					if(m_group->IsMember(m_bot->GetGUID()))
+					{
+						//deleting bot from group
+						if(m_group->RemoveMember(m_bot->GetGUID(), GROUP_REMOVEMETHOD_DEFAULT) < 1) // 99 means I'm a bot
+						{
+							//no one left in group so deleting group
+							delete m_group;
+							//sObjectMgr.RemoveGroup(m_group);
+						}
+					}
+					session->LogoutPlayerBot(m_bot->GetGUID(), true);
+					break;
+				}
+				--x;
+			}
+			player->CLOSE_GOSSIP_MENU();
+		} //end SendRemovePlayerBot
+
+		void SendRemovePlayerBotMenu(Player *player, Creature *creature, uint32 action)
+		{
+            player->PlayerTalkClass->ClearMenus();
+			player->ADD_GOSSIP_ITEM(9, "REMOVE ALL", 6005, GOSSIP_ACTION_INFO_DEF + 1);
+
+			uint8 x = 2;
+			WorldSession *session = player->GetSession();
+			for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+			{
+				Player *bot = itr->second;
+				player->ADD_GOSSIP_ITEM(9, bot->GetName(), 6005, GOSSIP_ACTION_INFO_DEF + x);
+				++x;
+			}
+			player->SEND_GOSSIP_MENU(907, creature->GetGUID());
+		} //end SendRemovePlayerBotMenu
+
+		void SendCreateNPCBot(Player *player, Creature *creature, uint32 action)
+		{
+			uint8 bot_class = 0;
+			if(action == GOSSIP_ACTION_INFO_DEF + 101) //abandon bot
+			{
+				if(player->HaveBot())
+					player->SetBotMustDie();
+				player->CLOSE_GOSSIP_MENU();
+				return;
+			}
+			else if(action == GOSSIP_ACTION_INFO_DEF + 1){ //playerbot
+				player->CLOSE_GOSSIP_MENU();
+				return;
+			}
+			else if(action == GOSSIP_ACTION_INFO_DEF + 2)
+				bot_class = CLASS_WARRIOR;
+			else if(action == GOSSIP_ACTION_INFO_DEF + 3)
+				bot_class = CLASS_HUNTER;
+			else if(action == GOSSIP_ACTION_INFO_DEF + 4)
+				bot_class = CLASS_PALADIN;
+			else if(action == GOSSIP_ACTION_INFO_DEF + 5)
+				bot_class = CLASS_SHAMAN;
+			else if(action == GOSSIP_ACTION_INFO_DEF + 6)
+				bot_class = CLASS_ROGUE;
+			else if(action == GOSSIP_ACTION_INFO_DEF + 7)
+				bot_class = CLASS_DRUID;
+			else if(action == GOSSIP_ACTION_INFO_DEF + 8)
+				bot_class = CLASS_MAGE;
+			else if(action == GOSSIP_ACTION_INFO_DEF + 9)
+				bot_class = CLASS_PRIEST;
+			else if(action == GOSSIP_ACTION_INFO_DEF + 10)
+				bot_class = CLASS_WARLOCK;
+			//else if(action == GOSSIP_ACTION_INFO_DEF + 11)
+				//bot_class = CLASS_DEATH_KNIGHT;
+
+			if(bot_class > 0)
+			{
+				//sLog->outError("script_bot_giver.SendCreateNPCBot class = %u", bot_class);
+				player->CreateNPCBot(bot_class);
+			}
+			//else
+				//creature->Say("Invalid selection.", LANG_UNIVERSAL, NULL);
+			player->CLOSE_GOSSIP_MENU();
+			return;
+		}
+
+		void SendCreateNPCBotMenu(Player *player, Creature *creature, uint32 action)
+		{
+            player->PlayerTalkClass->ClearMenus();
+			player->ADD_GOSSIP_ITEM(9, "Recruit a Warrior", 6001, GOSSIP_ACTION_INFO_DEF + 2);
+			player->ADD_GOSSIP_ITEM(9, "Recruit a Hunter", 6001, GOSSIP_ACTION_INFO_DEF + 3);
+			player->ADD_GOSSIP_ITEM(9, "Recruit a Paladin", 6001, GOSSIP_ACTION_INFO_DEF + 4);
+			player->ADD_GOSSIP_ITEM(9, "Recruit a Shaman", 6001, GOSSIP_ACTION_INFO_DEF + 5);
+			player->ADD_GOSSIP_ITEM(9, "Recruit a Rogue", 6001, GOSSIP_ACTION_INFO_DEF + 6);
+			player->ADD_GOSSIP_ITEM(3, "Recruit a Druid", 6001, GOSSIP_ACTION_INFO_DEF + 7);
+			player->ADD_GOSSIP_ITEM(3, "Recruit a Mage", 6001, GOSSIP_ACTION_INFO_DEF + 8);
+			player->ADD_GOSSIP_ITEM(3, "Recruit a Priest", 6001, GOSSIP_ACTION_INFO_DEF + 9);
+			player->ADD_GOSSIP_ITEM(3, "Recruit a Warlock", 6001, GOSSIP_ACTION_INFO_DEF + 10);
+			//player->ADD_GOSSIP_ITEM(9, "Recruit a Death Knight", 1, GOSSIP_ACTION_INFO_DEF + 11);
+			player->SEND_GOSSIP_MENU(907, creature->GetGUID());
+		} //end SendCreateNPCBotMenu
+};
+
+//This function is called when the player clicks an option on the gossip menu
+void AddSC_script_bot_giver()
+{
+    new script_bot_giver();
+}
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index 17d4bfc..d917ab8 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -31,6 +31,9 @@ include(Examples/CMakeLists.txt)
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.h
   ../game/AI/ScriptedAI/ScriptedEscortAI.cpp
   ../game/AI/ScriptedAI/ScriptedCreature.cpp
   ../game/AI/ScriptedAI/ScriptedFollowerAI.cpp
@@ -40,6 +43,7 @@ set(scripts_STAT_SRCS
 
 if(SCRIPTS)
   include(Custom/CMakeLists.txt)
+  include(Bots/CMakeLists.txt)
   include(World/CMakeLists.txt)
   include(OutdoorPvP/CMakeLists.txt)
   include(EasternKingdoms/CMakeLists.txt)
@@ -124,6 +128,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
   ${CMAKE_SOURCE_DIR}/src/server/game/Opcodes
   ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP
   ${CMAKE_SOURCE_DIR}/src/server/game/Pools
   ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
   ${CMAKE_SOURCE_DIR}/src/server/game/Quests
diff --git a/src/server/scripts/Commands/CMakeLists.txt b/src/server/scripts/Commands/CMakeLists.txt
index b688ee3..64f5609 100644
--- a/src/server/scripts/Commands/CMakeLists.txt
+++ b/src/server/scripts/Commands/CMakeLists.txt
@@ -1,5 +1,6 @@
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Commands/cs_anticheat.cpp
   Commands/cs_account.cpp
   Commands/cs_achievement.cpp
   Commands/cs_gm.cpp
diff --git a/src/server/scripts/Commands/cs_anticheat.cpp b/src/server/scripts/Commands/cs_anticheat.cpp
new file mode 100644
index 0000000..4420609
--- /dev/null
+++ b/src/server/scripts/Commands/cs_anticheat.cpp
@@ -0,0 +1,307 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ScriptMgr.h"
+#include "ObjectMgr.h"
+#include "Chat.h"
+
+class anticheat_commandscript : public CommandScript
+{
+public:
+    anticheat_commandscript() : CommandScript("anticheat_commandscript") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand anticheatCommandTable[] =
+        {
+            { "global",         SEC_GAMEMASTER,     true,  &HandleAntiCheatGlobalCommand,         "", NULL },
+            { "player",         SEC_GAMEMASTER,     true,  &HandleAntiCheatPlayerCommand,         "", NULL },
+            { "delete",         SEC_ADMINISTRATOR,  true,  &HandleAntiCheatDeleteCommand,         "", NULL },
+            { "handle",         SEC_ADMINISTRATOR,  true,  &HandleAntiCheatHandleCommand,         "", NULL },
+            { "jail",           SEC_GAMEMASTER,     true,  &HandleAnticheatJailCommand,         "", NULL },
+            { "warn",           SEC_GAMEMASTER,     true,  &HandleAnticheatWarnCommand,         "", NULL },
+            { NULL,             0,                     false, NULL,                                           "", NULL }
+        };
+
+        static ChatCommand commandTable[] =
+        {
+            { "anticheat",      SEC_GAMEMASTER,     true, NULL,                     "",  anticheatCommandTable},
+            { NULL,             0,                  false, NULL,                               "", NULL }
+        };
+
+        return commandTable;
+    }
+
+    static bool HandleAnticheatWarnCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        Player* pTarget = NULL;
+        
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        if (command)
+        {
+            strCommand = command;
+            normalizePlayerName(strCommand);
+
+            pTarget = sObjectMgr->GetPlayer(strCommand.c_str()); //get player by name
+        }else 
+            pTarget = handler->getSelectedPlayer();
+
+        if (!pTarget)
+            return false;
+        
+        WorldPacket data;
+
+        // need copy to prevent corruption by strtok call in LineFromMessage original string
+        char* buf = strdup("The anticheat system has reported several times that you may be cheating. You will be monitored to confirm if this is accurate.");
+        char* pos = buf;
+
+        while (char* line = handler->LineFromMessage(pos))
+        {
+            handler->FillSystemMessageData(&data, line);
+            pTarget->GetSession()->SendPacket(&data);
+        }
+
+        free(buf);
+        return true;
+    }
+
+    static bool HandleAnticheatJailCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        Player* pTarget = NULL;
+        
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        if (command)
+        {
+            strCommand = command;
+            normalizePlayerName(strCommand);
+
+            pTarget = sObjectMgr->GetPlayer(strCommand.c_str()); //get player by name
+        }else 
+            pTarget = handler->getSelectedPlayer();
+
+        if (!pTarget)
+        {
+            handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (pTarget == handler->GetSession()->GetPlayer())
+            return false;
+    
+        // teleport both to jail.
+        pTarget->TeleportTo(1,16226.5f,16403.6f,-64.5f,3.2f);
+        handler->GetSession()->GetPlayer()->TeleportTo(1,16226.5f,16403.6f,-64.5f,3.2f);
+
+        WorldLocation loc;
+
+        // the player should be already there, but no :(
+        // pTarget->GetPosition(&loc);
+
+        loc.m_mapId = 1;
+        loc.m_positionX = 16226.5f;
+        loc.m_positionY = 16403.6f;
+        loc.m_positionZ = -64.5f;
+        loc.m_orientation = 3.2f;
+
+        pTarget->SetHomebind(loc,876);
+        return true;
+    }
+
+    static bool HandleAntiCheatDeleteCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " "); //get entered name
+
+        if (!command)
+            return true;
+        
+        strCommand = command;
+        
+        if (strCommand.compare("deleteall") == 0)
+            CharacterDatabase.PExecute("DELETE FROM players_reports_status;");
+        else
+        {
+            normalizePlayerName(strCommand);
+            Player* pPlayer = sObjectMgr->GetPlayer(strCommand.c_str()); //get player by name
+
+            if (!pPlayer)
+                handler->PSendSysMessage("Player doesn't exist");
+            else
+                CharacterDatabase.PExecute("DELETE FROM players_reports_status WHERE guid=%u;",pPlayer->GetGUIDLow());
+        }
+
+        return true;
+    }
+
+    static bool HandleAntiCheatPlayerCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        uint32 uiGUID = 0;
+        Player* player = NULL;
+        
+        if (command)
+        {
+            strCommand = command;
+
+            normalizePlayerName(strCommand);
+            player = sObjectMgr->GetPlayer(strCommand.c_str()); //get player by name
+
+            if (player)
+                uiGUID = player->GetGUIDLow();
+        }else 
+        {
+            player = handler->getSelectedPlayer();
+            if (player)
+                uiGUID = player->GetGUIDLow();  
+        }
+
+        if (uiGUID == 0)
+        {
+            handler->PSendSysMessage("There is no player.");
+            return true;
+        }
+        
+
+        uint32 average = player->anticheatData.average;
+        uint32 total_reports = player->anticheatData.total_reports;
+        uint32 speed_reports = player->anticheatData.type_reports[0];
+        uint32 fly_reports = player->anticheatData.type_reports[1];
+        uint32 jump_reports = player->anticheatData.type_reports[3];
+        uint32 waterwalk_reports = player->anticheatData.type_reports[2];
+        uint32 teleportplane_reports = player->anticheatData.type_reports[4];
+
+        handler->PSendSysMessage("Information about player %s",player->GetName());
+        handler->PSendSysMessage("Average: %u || Total Reports: %u ",average,total_reports);
+        handler->PSendSysMessage("Speed Reports: %u || Fly Reports: %u || Jump Reports: %u ",speed_reports,fly_reports,jump_reports);
+        handler->PSendSysMessage("Walk On Water Reports: %u  || Teleport To Plane Reports: %u",waterwalk_reports,teleportplane_reports);
+
+        return true;
+    }
+
+    static bool HandleAntiCheatHandleCommand(ChatHandler* handler, const char* args)
+    {
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+        
+        if (!command)
+            return true;
+
+        if (!handler->GetSession()->GetPlayer())
+            return true;
+
+        strCommand = command;
+
+        if (strCommand.compare("on") == 0)
+        {
+            sWorld->setBoolConfig(CONFIG_ANTICHEAT_ENABLE,true);
+            handler->SendSysMessage("The Anticheat System is now: Enabled!");
+        }
+        else if (strCommand.compare("off") == 0)
+        {
+            sWorld->setBoolConfig(CONFIG_ANTICHEAT_ENABLE,false);
+            handler->SendSysMessage("The Anticheat System is now: Disabled!");
+        }
+        
+        return true;
+    }
+
+    static bool HandleAntiCheatGlobalCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+        {
+            handler->PSendSysMessage("The Anticheat System is disabled.");
+            return true;
+        }
+
+        QueryResult resultDB = CharacterDatabase.Query("SELECT guid,average,total_reports FROM players_reports_status WHERE total_reports != 0 ORDER BY average ASC LIMIT 3;");
+        if (!resultDB)
+        {
+            handler->PSendSysMessage("No players found.");
+            return true;
+        } else
+        {
+                handler->SendSysMessage("=============================");
+                handler->PSendSysMessage("Players with the lowest averages:");
+                do
+                {
+                    Field *fieldsDB = resultDB->Fetch();
+     
+                    uint64 guid = fieldsDB[0].GetUInt64();
+                    uint32 average = fieldsDB[1].GetUInt32();
+                    uint32 total_reports = fieldsDB[2].GetUInt32();
+
+                     if (Player* player = sObjectMgr->GetPlayerByLowGUID(guid))
+                         handler->PSendSysMessage("Player: %s Average: %u Total Reports: %u",player->GetName(),average,total_reports);
+
+                } while (resultDB->NextRow());
+        }
+
+        resultDB = CharacterDatabase.Query("SELECT guid,average,total_reports FROM players_reports_status WHERE total_reports != 0 ORDER BY total_reports DESC LIMIT 3;");
+        
+        // this should never happen
+        if (!resultDB)
+        {
+            handler->PSendSysMessage("No players found.");
+            return true;
+        } else
+        {
+            handler->SendSysMessage("=============================");
+            handler->PSendSysMessage("Players with the more reports:");
+            do
+            {
+                Field *fieldsDB = resultDB->Fetch();
+     
+                uint64 guid = fieldsDB[0].GetUInt64();
+                uint32 average = fieldsDB[1].GetUInt32();
+                uint32 total_reports = fieldsDB[2].GetUInt32();
+
+                    if (Player* player = sObjectMgr->GetPlayerByLowGUID(guid))
+                        handler->PSendSysMessage("Player: %s Total Reports: %u Average: %u",player->GetName(),total_reports,average);
+
+            } while (resultDB->NextRow());
+        }
+
+        return true;
+    }
+};
+
+void AddSC_anticheat_commandscript()
+{
+    new anticheat_commandscript();
+}
diff --git a/src/server/scripts/Commands/cs_gm.cpp b/src/server/scripts/Commands/cs_gm.cpp
index 1ed451e..c349e95 100644
--- a/src/server/scripts/Commands/cs_gm.cpp
+++ b/src/server/scripts/Commands/cs_gm.cpp
@@ -120,7 +120,7 @@ public:
         for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
         {
             AccountTypes itr_sec = itr->second->GetSession()->GetSecurity();
-            if ((itr->second->isGameMaster() || (itr_sec > SEC_PLAYER && itr_sec <= AccountTypes(sWorld->getIntConfig(CONFIG_GM_LEVEL_IN_GM_LIST)))) &&
+            if ((itr->second->isGameMaster() || (itr_sec > SEC_MODERATOR && itr_sec <= AccountTypes(sWorld->getIntConfig(CONFIG_GM_LEVEL_IN_GM_LIST)))) &&
                 (!handler->GetSession() || itr->second->IsVisibleGloballyFor(handler->GetSession()->GetPlayer())))
             {
                 if (first)
@@ -153,7 +153,7 @@ public:
     static bool HandleGMListFullCommand(ChatHandler* handler, const char* /*args*/)
     {
         ///- Get the accounts with GM Level >0
-        QueryResult result = LoginDatabase.Query("SELECT a.username,aa.gmlevel FROM account a, account_access aa WHERE a.id=aa.id AND aa.gmlevel > 0");
+        QueryResult result = LoginDatabase.Query("SELECT a.username,aa.gmlevel FROM account a, account_access aa WHERE a.id=aa.id AND aa.gmlevel > 1");
         if (result)
         {
             handler->SendSysMessage(LANG_GMLIST);
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 0dec843..c17e6fe 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -1,5 +1,6 @@
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/resetduel.cpp
 )
 
 message("  -> Prepared: Custom")
diff --git a/src/server/scripts/Custom/npc_teleport.cpp b/src/server/scripts/Custom/npc_teleport.cpp
new file mode 100644
index 0000000..537d7b1
--- /dev/null
+++ b/src/server/scripts/Custom/npc_teleport.cpp
@@ -0,0 +1,222 @@
+/**
+ *
+ * @File : npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+#include <sstream>
+
+#define GOSSIP_SHOW_DEST        1000
+#define GOSSIP_TELEPORT         1001
+#define GOSSIP_NEXT_PAGEC       1002
+#define GOSSIP_PREV_PAGEC       1003
+#define GOSSIP_NEXT_PAGED       1004
+#define GOSSIP_PREV_PAGED       1005
+#define GOSSIP_MAIN_MENU        1006
+
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+#define SPELL_VISUAL_TELEPORT   35517
+
+#define NB_ITEM_PAGE            10
+#define MSG_CAT                 100000
+#define MSG_DEST                100001
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+
+using namespace nsNpcTel;
+
+
+namespace
+{
+    Page PageC, PageD;
+    Page Cat;
+
+    // Conversion function int->string
+    std::string ConvertStr(const int64 &val)
+    {
+        std::ostringstream ostr;
+        ostr << val;
+        return ostr.str();
+    }
+
+    // Conversion function intMoney->stringMoney
+    std::string ConvertMoney(const uint32 &Money)
+    {
+        std::string Str(ConvertStr(Money));
+        uint32 SizeStr = Str.length();
+
+        if (SizeStr > 4)
+            Str = Str.insert(Str.length()-4, "po");
+        if (SizeStr > 2)
+            Str = Str.insert(Str.length()-2, "pa");
+        Str += "pc";
+
+        return Str;
+    }
+
+    // Teleport Player
+    void Teleport(Player * const player, const uint16 &map,
+                  const float &X, const float &Y, const float &Z, const float &orient)
+    {
+        player->CastSpell(player, SPELL_VISUAL_TELEPORT, true);
+        player->TeleportTo(map, X, Y, Z, orient);
+    }
+
+    // Display categories
+    void AffichCat(Player * const player, Creature * const creature)
+    {
+        if (PageC[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGEC, 0);
+
+        VCatDest_t i (PageC[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest.size() && i < (NB_ITEM_PAGE * (PageC[player] + 1)); ++i)
+        {
+            if (TabCatDest[i].IsAllowedToTeleport(player))
+                player->ADD_GOSSIP_ITEM(7, TabCatDest[i].GetName(player->isGameMaster()).c_str(), GOSSIP_SHOW_DEST, i);
+        }
+
+        if (i < TabCatDest.size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGEC, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_CAT, creature->GetGUID());
+    }
+
+    // Display destination categories
+    void AffichDest(Player * const player, Creature * const creature)
+    {
+        if (PageD[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGED, 0);
+
+        CatDest::VDest_t i (PageD[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest[Cat[player]].size() && i < (NB_ITEM_PAGE * (PageD[player] + 1)); ++i)
+        {
+            player->ADD_GOSSIP_ITEM(5, TabCatDest[Cat[player]].GetDest(i).m_name.c_str(), GOSSIP_TELEPORT, i);
+        }
+
+        if (i < TabCatDest[Cat[player]].size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGED, 0);
+
+        if (CatDest::CountOfCategoryAllowedBy(player) > 1)
+            player->ADD_GOSSIP_ITEM(7, MAIN_MENU, GOSSIP_MAIN_MENU, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_DEST, creature->GetGUID());
+    }
+
+    // Verification before teleportation
+    void ActionTeleport(Player * const player, Creature * const creature, const uint32 &id)
+    {
+        Dest dest (TabCatDest[Cat[player]].GetDest(id));
+
+        if (player->getLevel() < dest.m_level && !player->isGameMaster())
+        {
+            std::string msg ("You do not have the required level. This destination requires level " + ConvertStr(dest.m_level) + ".");
+            creature->MonsterWhisper(msg.c_str(), player->GetGUID());
+            return;
+        }
+
+        if (player->GetMoney() < dest.m_cost && !player->isGameMaster())
+        {
+            std::string msg ("You do not have enough money. The price for teleportation is " + ConvertMoney(dest.m_cost) + ".");
+            creature->MonsterWhisper(msg.c_str(), player->GetGUID());
+            return;
+        }
+
+        if (!player->isGameMaster() && dest.m_cost)
+            player->ModifyMoney(-1 * dest.m_cost);
+
+        Teleport(player, dest.m_map, dest.m_X, dest.m_Y, dest.m_Z, dest.m_orient);
+    }
+}
+
+class npc_teleport : public CreatureScript
+{
+public:
+    npc_teleport() : CreatureScript("npc_teleport") {}
+
+bool OnGossipHello(Player *player, Creature *creature)
+{
+    PageC(player) = PageD(player) = Cat(player) = 0;
+
+    if(player->isInCombat())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->MonsterWhisper("You are in combat. Come back later", player->GetGUID());
+        return true;
+    }
+    AffichCat(player, creature);
+    return true;
+}
+
+bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 param)
+{
+    player->PlayerTalkClass->ClearMenus();
+    switch(sender)
+    {
+      // Display destinations
+      case GOSSIP_SHOW_DEST:
+        Cat(player) = param;
+        AffichDest(player, creature);
+        break;
+
+      // Previous categories page
+      case GOSSIP_PREV_PAGEC:
+        --PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Next page categories
+      case GOSSIP_NEXT_PAGEC:
+        ++PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Previous destinations page
+      case GOSSIP_PREV_PAGED:
+        --PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Next destination page
+      case GOSSIP_NEXT_PAGED:
+        ++PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Display main menu
+      case GOSSIP_MAIN_MENU:
+        OnGossipHello(player, creature);
+        break;
+
+      // Teleportation
+      case GOSSIP_TELEPORT:
+        player->CLOSE_GOSSIP_MENU();
+        if(player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0)) {
+            creature->CastSpell(player,38588,false); // Healing effect
+            player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+
+        ActionTeleport(player, creature, param);
+        break;
+    }
+    return true;
+}
+};
+
+void AddSC_npc_teleport()
+{
+    new npc_teleport;
+}
+
diff --git a/src/server/scripts/Custom/resetduel.cpp b/src/server/scripts/Custom/resetduel.cpp
new file mode 100644
index 0000000..25c8ea3
--- /dev/null
+++ b/src/server/scripts/Custom/resetduel.cpp
@@ -0,0 +1,26 @@
+#include "ScriptPCH.h"
+
+class Reset_OnDuelEnd : public PlayerScript
+{
+    public:
+        Reset_OnDuelEnd() : PlayerScript("Reset_OnDuelEnd") {}
+
+    void OnDuelEnd(Player *winner, Player *looser, DuelCompleteType type)
+    {
+        // reset cooldowns in zone 0, 41 and 616
+                if (winner->GetZoneId() == 0 || winner->GetZoneId() == 41 || winner->GetZoneId() == 616)
+                {
+                        winner->RemoveArenaSpellCooldowns();
+                        looser->RemoveArenaSpellCooldowns();
+                        winner->SetHealth(winner->GetMaxHealth());
+                        winner->SetPower(POWER_MANA, winner->GetMaxPower(POWER_MANA));
+                        looser->SetHealth(looser->GetMaxHealth());
+                        looser->SetPower(POWER_MANA, looser->GetMaxPower(POWER_MANA));
+                }
+    }
+};
+
+void AddSC_Reset()
+{
+    new Reset_OnDuelEnd;
+}
diff --git a/src/server/scripts/EasternKingdoms/silvermoon_city.cpp b/src/server/scripts/EasternKingdoms/silvermoon_city.cpp
index afb8bb1..17aa306 100644
--- a/src/server/scripts/EasternKingdoms/silvermoon_city.cpp
+++ b/src/server/scripts/EasternKingdoms/silvermoon_city.cpp
@@ -28,7 +28,7 @@ npc_blood_knight_stillblade
 EndContentData */
 
 #include "ScriptPCH.h"
-
+#define NPC_BLOOD_KNIGHT_STILLBLADE    17768
 /*#######
 # npc_blood_knight_stillblade
 #######*/
@@ -90,7 +90,7 @@ public:
             if ((Spellkind->Id == SPELL_SHIMMERING_VESSEL) && !spellHit &&
                 (Hitter->GetTypeId() == TYPEID_PLAYER) && (CAST_PLR(Hitter)->IsActiveQuest(QUEST_REDEEMING_THE_DEAD)))
             {
-                CAST_PLR(Hitter)->AreaExploredOrEventHappens(QUEST_REDEEMING_THE_DEAD);
+                CAST_PLR(Hitter)->KilledMonsterCredit(NPC_BLOOD_KNIGHT_STILLBLADE, 0);
                 DoCast(me, SPELL_REVIVE_SELF);
                 me->SetStandState(UNIT_STAND_STATE_STAND);
                 me->SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
index f1c80b1..fd70ec0 100644
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -2,6 +2,7 @@ set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   Northrend/isle_of_conquest.cpp
   Northrend/storm_peaks.cpp
+  Northrend/wintergrasp.cpp
   Northrend/Ulduar/HallsOfLightning/instance_halls_of_lightning.cpp
   Northrend/Ulduar/HallsOfLightning/boss_bjarngrim.cpp
   Northrend/Ulduar/HallsOfLightning/halls_of_lightning.h
@@ -143,17 +144,21 @@ set(scripts_STAT_SRCS
   Northrend/VioletHold/boss_xevozz.cpp
   Northrend/VioletHold/boss_erekem.cpp
   Northrend/VioletHold/violet_hold.cpp
-  Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
-  Northrend/IcecrownCitadel/icecrown_citadel.h
-  Northrend/IcecrownCitadel/icecrown_citadel_teleport.cpp
-  Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
-  Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
+  Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
   Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
   Northrend/IcecrownCitadel/boss_festergut.cpp
-  Northrend/IcecrownCitadel/boss_rotface.cpp
+  Northrend/IcecrownCitadel/boss_gunship_battle.cpp
+  Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
+  Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
   Northrend/IcecrownCitadel/boss_professor_putricide.cpp
   Northrend/IcecrownCitadel/boss_blood_prince_council.cpp
-  Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
+  Northrend/IcecrownCitadel/boss_rotface.cpp
+  Northrend/IcecrownCitadel/boss_sindragosa.cpp
+  Northrend/IcecrownCitadel/boss_the_lich_king.cpp
+  Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
+  Northrend/IcecrownCitadel/icecrown_citadel_teleport.cpp
+  Northrend/IcecrownCitadel/icecrown_citadel.h
+  Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
   Northrend/zuldrak.cpp
   Northrend/icecrown.cpp
   Northrend/Gundrak/boss_slad_ran.cpp
@@ -172,6 +177,13 @@ set(scripts_STAT_SRCS
   Northrend/DraktharonKeep/drak_tharon_keep.h
   Northrend/DraktharonKeep/boss_tharon_ja.cpp
   Northrend/DraktharonKeep/boss_dred.cpp
+  Northrend/RubySanctum/boss_baltharus.cpp
+  Northrend/RubySanctum/boss_halion.cpp
+  Northrend/RubySanctum/boss_ragefire.cpp
+  Northrend/RubySanctum/boss_zarithrian.cpp
+  Northrend/RubySanctum/instance_ruby_sanctum.cpp
+  Northrend/RubySanctum/ruby_sanctum.h
+
 )
 
 message("  -> Prepared: Northrend")
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
old mode 100755
new mode 100644
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
old mode 100755
new mode 100644
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp
new file mode 100644
index 0000000..cd85187
--- /dev/null
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "icecrown_citadel.h"
+#include "MapManager.h"
+#include "Transport.h"
+#include "Unit.h"
+
+class transport_gunship : public TransportScript
+{
+    public:
+        transport_gunship() : TransportScript("transport_gunship") { }
+
+        void OnRelocate(Transport* /*transport*/, uint32 /*waypointId*/, uint32 /*mapId*/, float /*x*/, float /*y*/, float /*z*/)
+        {
+        }
+
+        //void OnUpdate(Transport* /*obj*/, uint32 /*diff*/)
+        //{
+        //}
+};
+
+class npc_muradin_bronzebeard_gunship : public CreatureScript
+{
+    public:
+        npc_muradin_bronzebeard_gunship() : CreatureScript("npc_muradin_bronzebeard_gunship") { }
+
+        bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+        {
+            InstanceScript* pInstance = pCreature->GetInstanceScript();
+            if (pInstance && pInstance->GetBossState(DATA_GUNSHIP_BATTLE_EVENT) != DONE)
+            {
+                if (!pCreature->GetTransport())
+                    pPlayer->ADD_GOSSIP_ITEM(0, "START", 631, 1000);
+                else
+                {
+                    pPlayer->ADD_GOSSIP_ITEM(0, "My companions are all accounted for, Muradin. Let's go!", 631, 1001);
+                    pPlayer->ADD_GOSSIP_ITEM(0, "DESPAWN", 631, 1003);
+                }
+                pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+                return true;
+            }
+
+            return false;
+        }
+
+        bool OnGossipSelect(Player* player, Creature* pCreature, uint32 /*sender*/, uint32 action)
+        {
+            player->PlayerTalkClass->ClearMenus();
+            player->CLOSE_GOSSIP_MENU();
+            if (action == 1000)
+            {
+                uint32 entry = THE_SKYBREAKER_ALLIANCE_ICC;
+                const GameObjectInfo *goinfo = sObjectMgr->GetGameObjectInfo(entry);
+                if (!goinfo)
+                    return false;
+
+                Transport *t = new Transport(1431158, goinfo->ScriptId);
+
+                std::set<uint32> unused;
+                if (!t->GenerateWaypoints(goinfo->moTransport.taxiPathId, unused))
+                {
+                    delete t;
+                    return false;
+                }
+
+                theguid = sObjectMgr->GenerateLowGuid(HIGHGUID_MO_TRANSPORT);
+                // creates the Gameobject
+                if (!t->Create(theguid, entry, t->m_WayPoints.begin()->second.mapid, t->m_WayPoints.begin()->second.x, t->m_WayPoints.begin()->second.y, t->m_WayPoints.begin()->second.z, 0.0f, 0, 0))
+                {
+                    delete t;
+                    return false;
+                }
+
+                Map* tMap = player->GetMap();
+                t->SetUInt32Value(GAMEOBJECT_DYNAMIC, 0x10830010);   // dunno, seen in sniffs
+                t->SetFloatValue(GAMEOBJECT_PARENTROTATION+3, 1.0f);
+                t->SetMap(tMap);
+                t->AddToWorld();
+
+                // transmit creation packet
+                for (Map::PlayerList::const_iterator itr = tMap->GetPlayers().begin(); itr != tMap->GetPlayers().end(); ++itr)
+                {
+                    if (Player* pPlayer = itr->getSource())
+                    {
+                        UpdateData transData;
+                        t->BuildCreateUpdateBlockForPlayer(&transData, pPlayer);
+                        WorldPacket packet;
+                        transData.BuildPacket(&packet);
+                        pPlayer->SendDirectMessage(&packet);
+                    }
+                }
+
+                sMapMgr->m_Transports.insert(t); // for updating
+				for (MapManager::TransportSet::const_iterator i = sMapMgr->m_Transports.begin(); i != sMapMgr->m_Transports.end(); ++i)
+
+                    t->AddNPCPassenger((*i)->GetGUID(), (*i)->GetEntry(), (*i)->GetTransOffsetX(), (*i)->GetTransOffsetY(), (*i)->GetTransOffsetZ(), (*i)->GetTransOffsetO());
+
+                t->UpdateNPCPositions();
+            }
+            else if (action == 1001)
+            {
+                if (Transport* skybreaker = pCreature->GetTransport())
+                    skybreaker->BuildStartMovePacket(player->GetMap());
+            }
+            else if (action == 1003)
+            {
+                Transport* skybreaker = pCreature->GetTransport();
+                if (!skybreaker)
+                    return true;
+
+                sMapMgr->m_Transports.erase(skybreaker);
+                for (Transport::PlayerSet::const_iterator itr = skybreaker->GetPassengers().begin(); itr != skybreaker->GetPassengers().end(); ++itr)
+                {
+                    skybreaker->RemovePassenger(*itr);
+                    if (Player* plr = *itr)
+                        plr->SetTransport(NULL);
+                }
+
+                /*for (std::set<uint64>::iterator itr = skybreaker->m_NPCPassengerSet.begin(); itr != skybreaker->m_NPCPassengerSet.end();)
+                    if (Creature *npc = Creature::GetCreature(*player, *(itr++)))
+                        npc->AddObjectToRemoveList();*/
+
+                skybreaker->m_NPCPassengerSet.clear();
+
+                UpdateData transData;
+                skybreaker->BuildOutOfRangeUpdateBlock(&transData);
+                WorldPacket out_packet;
+                transData.BuildPacket(&out_packet);
+
+                for (Map::PlayerList::const_iterator itr = skybreaker->GetMap()->GetPlayers().begin(); itr != skybreaker->GetMap()->GetPlayers().end(); ++itr)
+                    if (skybreaker != itr->getSource()->GetTransport())
+                        itr->getSource()->SendDirectMessage(&out_packet);
+
+                skybreaker->Delete();
+                skybreaker = NULL;
+            }
+
+            return true;
+        }
+        uint64 theguid;
+};
+
+void AddSC_event_gunship_battle()
+{
+    //new transport_gunship();
+    new npc_muradin_bronzebeard_gunship();
+}
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
old mode 100755
new mode 100644
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
old mode 100755
new mode 100644
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
old mode 100755
new mode 100644
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
new file mode 100644
index 0000000..e62f2b5
--- /dev/null
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
@@ -0,0 +1,724 @@
+/*
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+/*
+*Need correct timers
+*Need add  Sindragossa fly in fly phase
+*/
+
+#include "ScriptMgr.h"
+#include "SpellScript.h"
+#include "SpellAuraEffects.h"
+#include "icecrown_citadel.h"
+
+enum Yells
+{
+    SAY_AGGRO            = -1666071,
+    SAY_UNCHAIND_MAGIC   = -1666072,
+    SAY_BLISTERING_COLD  = -1666073,
+    SAY_BREATH           = -1666074,
+    SAY_AIR_PHASE        = -1666075,
+    SAY_PHASE_3          = -1666076,
+    SAY_KILL_1           = -1666077,
+    SAY_KILL_2           = -1666078,
+    SAY_BERSERK          = -1666079,
+    SAY_DEATH            = -1666080
+};
+
+enum Spells
+{
+    SPELL_FROST_AURA          = 70084,
+    SPELL_CLEAVE              = 19983,
+    SPELL_TAIL_SMASH          = 71077,
+    SPELL_FROST_BREATH        = 69649,
+    SPELL_PERMEATING_CHILL    = 70109,
+    SPELL_UNCHAINED_MAGIC     = 69762, // io?ii ociaou iaoaieeo ia ioa
+    SPELL_ICY_TRIP_PULL       = 70117,
+    SPELL_ICY_TRIP_JUMP       = 70122,
+    SPELL_BLISTERING_COLD     = 70123,
+    SPELL_FROST_BOMB_TRIGGER  = 69846,
+    SPELL_FROST_BEACON_EFFECT = 69675,
+    SPELL_FROST_BEACON        = 70126,
+    SPELL_ICE_TOMB            = 70157,
+    SPELL_FROST_BOMB          = 69845,
+    SPELL_MYSTIC_BUFFED       = 70128,
+    SPELL_ASPHYXATION         = 71665,
+    SPELL_FROST_AURA_ADD      = 71387,
+    SPELL_FROST_BREATH_ADD    = 71386,
+    SPELL_ICE_BLAST           = 71376,
+    SPELL_BELLOWING_ROAR      = 36922,
+    SPELL_CLEAVE_ADD          = 40505,
+    SPELL_TAIL_SWEEP          = 71369,
+    SPELL_WITHOUT_ANIMATION   = 40031
+};
+
+enum ePoints
+{
+    POINT_PHASE_FLY                = 1,
+    POINT_PHASE_NORMAL             = 2
+};
+
+/*
+Neia?a eanoeo 69846. Eaoeo o?aiu a iiaa. I?e i?ecaieaiee o?aie aie?ai eaoe ac?ua
+
+Position: X: 4360.1 Y: 2510.012 Z: 203.4833 O: 3.141593
+Position: X: 4391.1 Y: 2476.4 Z: 203.4833 O: 3.141593
+Position: X: 4394.1 Y: 2498.075 Z: 203.4833 O: 3.141593
+Position: X: 4408.1 Y: 2466.511 Z: 203.4833 O: 3.141593
+
+Position: X: 4390.1 Y: 2467.817 Z: 203.4833 O: 3.141593
+Position: X: 4397.1 Y: 2483.4 Z: 203.4833 O: 3.141593
+
+const Position SpawnLoc[]=
+{
+    {4523.889f, 2486.907f, 280.249f, 3.155f}, //fly pos
+    {4407.439f, 2484.905f, 203.374f, 3.166f}, //center
+    {4407.439f, 2484.905f, 230.374f, 3.166f}, //center Z + 30
+    {4671.521f, 2481.815f, 343.365f, 3.166f} //spawn pos
+};*/
+
+class boss_sindragosa : public CreatureScript
+{
+    public:
+        boss_sindragosa() : CreatureScript("boss_sindragosa") { }
+
+        struct boss_sindragosaAI : public BossAI
+        {
+            boss_sindragosaAI(Creature* creature) : BossAI(creature, DATA_SINDRAGOSA_NPC)
+            {
+                instance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                uiPhase = 1;
+
+                uiBreathTimer = 15000;
+                uiTailSmashTimer = 15000;
+                uiBlisteringColdTimer = 30000;
+                uiMarkTimer = 25000;
+                uiBerserkTimer = 600000;
+                uiChangePhaseTimer = 110000;
+                uiUnchainedMagicTimer = 12000;
+                uiBombTimer = 7000;
+                uiCleaveTimer = 5000;
+                uiBombCount = 0;
+
+                me->SetFlying(true);
+                SetCombatMovement(true);
+
+                bMystic = false;
+                bCanSwitch = false;
+
+                if(instance)
+                    instance->SetData(DATA_SINDRAGOSA_EVENT, NOT_STARTED);
+
+                if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
+                    me->GetMotionMaster()->MovementExpired();
+            }
+
+            void EnterCombat(Unit* /*who*/)
+            {
+                if(instance)
+                    instance->SetData(DATA_SINDRAGOSA_EVENT, IN_PROGRESS);
+
+                DoCast(me, SPELL_FROST_AURA);
+                DoCast(me, SPELL_PERMEATING_CHILL);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                if (!instance)
+                    return;
+
+                DoScriptText(SAY_DEATH, me);
+
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_UNCHAINED_MAGIC);
+                instance->SetData(DATA_SINDRAGOSA_EVENT, DONE);
+                if(instance->GetData(DATA_ALL_YOU_CAN_EAT) == DONE)
+                    instance->DoCompleteAchievement(RAID_MODE(ACHIEV_ALL_YOU_CAN_EAT_10,ACHIEV_ALL_YOU_CAN_EAT_25));
+            }
+
+            void KilledUnit(Unit* victim)
+            {
+                if (victim->GetTypeId() == TYPEID_PLAYER)
+                    DoScriptText(RAND(SAY_KILL_1,SAY_KILL_2), me);
+            }
+
+            void MovementInform(uint32 type, uint32 id)
+            {
+                if(type != POINT_MOTION_TYPE)
+                    return;
+
+                if(id == POINT_PHASE_FLY)
+                    uiPhase = 2;
+                else
+                {
+                    SetCombatMovement(true);
+                    me->SetReactState(REACT_AGGRESSIVE);
+                    uiPhase = 1;
+                }
+
+            }
+
+            void JustReachedHome()
+            {
+                if (!instance)
+                    return;
+
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_UNCHAINED_MAGIC);
+                instance->SetData(DATA_SINDRAGOSA_EVENT, FAIL);
+            }
+
+            void DamageTaken(Unit* /*done_by*/, uint32& /*damage*/)
+            {
+                if(uiPhase == 1)
+                {
+                    if(!HealthAbovePct(85) && !bCanSwitch)
+                    {
+                        DoScriptText(SAY_AIR_PHASE, me);
+                        bCanSwitch = true;
+                        SetCombatMovement(false);
+                        me->GetMotionMaster()->MovePoint(POINT_PHASE_FLY, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ() + 28);
+                        me->SetReactState(REACT_PASSIVE);
+                        me->AttackStop();
+                        me->SetInCombatWithZone();
+                    }
+                    if(HealthAbovePct(36))
+                        return;
+
+                    DoScriptText(SAY_PHASE_3, me);
+                    uiPhase = 3;
+                }
+            }
+
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (uiBerserkTimer <= uiDiff)
+                {
+                    DoScriptText(SAY_BERSERK, me);
+                    DoCast(me, SPELL_BERSERK);
+                    uiBerserkTimer = 600000;
+                } else uiBerserkTimer -= uiDiff;
+
+                if(uiPhase == 1)
+                {
+                    if(uiUnchainedMagicTimer <= uiDiff)
+                    {
+                        for (uint8 i = 1; i <= urand(2, 4); ++i)
+                        {
+                            if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, -10.0f, true, -SPELL_UNCHAINED_MAGIC))
+                                DoCast(target, SPELL_UNCHAINED_MAGIC);
+                        }
+                        DoScriptText(SAY_UNCHAIND_MAGIC, me);
+                        uiUnchainedMagicTimer = 12000;
+                    } else uiUnchainedMagicTimer -= uiDiff;
+
+                    if (uiBreathTimer <= uiDiff)
+                    {
+                        DoScriptText(SAY_BREATH, me);
+                        DoCastVictim(SPELL_FROST_BREATH);
+                        uiBreathTimer = 15000;
+                    } else uiBreathTimer -= uiDiff;
+
+                    if (uiCleaveTimer <= uiDiff)
+                    {
+                        DoCastVictim(SPELL_CLEAVE);
+                        uiCleaveTimer = 6000;
+                    } else uiCleaveTimer -= uiDiff;
+
+                    if (uiTailSmashTimer <= uiDiff)
+                    {
+                        DoCast(SPELL_TAIL_SMASH);
+                        uiTailSmashTimer = 15000;
+                    } else uiTailSmashTimer -= uiDiff;
+
+                    if (uiBlisteringColdTimer <= uiDiff)
+                    {
+                        DoCast(SPELL_ICY_TRIP_PULL);
+                        DoCast(SPELL_BLISTERING_COLD);
+                        DoScriptText(SAY_BLISTERING_COLD, me);
+                        uiBlisteringColdTimer = 30000;
+                    } else uiBlisteringColdTimer -= uiDiff;
+                }
+
+                if(uiPhase == 2)
+                {
+                    if (uiMarkTimer < uiDiff)
+                    {
+                        for (uint8 i = 1; i <= RAID_MODE(2,5,2,5); ++i)
+                        {
+                            if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, -SPELL_FROST_BEACON))
+                                DoCast(target, SPELL_FROST_BEACON_EFFECT, true);
+                        }
+                        uiMarkTimer = 25000;
+                    } else uiMarkTimer -= uiDiff;
+
+                    if (uiBombTimer <= uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 150.0f, true))
+                            DoCast(target, SPELL_FROST_BOMB);
+                        ++uiBombCount;
+                        uiBombTimer = 7000;
+                    } else uiBombTimer -= uiDiff;
+
+                    if(uiBombCount >= RAID_MODE(4, 8, 4, 8))
+                    {
+                        uiBombCount = 0;
+                        me->GetMotionMaster()->MovePoint(POINT_PHASE_NORMAL, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ() - 28);
+                    }
+                }
+
+                if(uiPhase == 3)
+                {
+                    if (uiMarkTimer < uiDiff)
+                    {
+                        for (uint8 i = 1; i <= RAID_MODE(2,5,2,5); ++i)
+                        {
+                            if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, -SPELL_FROST_BEACON))
+                                DoCast(target, SPELL_FROST_BEACON);
+                        }
+                        uiMarkTimer = 25000;
+                    } else uiMarkTimer -= uiDiff;
+
+                    if (uiBreathTimer <= uiDiff)
+                    {
+                        DoScriptText(SAY_BREATH, me);
+                        DoCast(SPELL_FROST_BREATH);
+                        uiBreathTimer = 15000;
+                    } else uiBreathTimer -= uiDiff;
+
+                    if(!bMystic)
+                    {
+                       DoCast(me, SPELL_MYSTIC_BUFFED);
+                       bMystic = true;
+                    }
+                }
+
+                if(!bCanSwitch || uiPhase != 1)
+                    return;
+
+                if (uiChangePhaseTimer < uiDiff)
+                {
+                    DoScriptText(SAY_AIR_PHASE, me);
+                    uiPhase = 2;
+                    SetCombatMovement(false);
+                    me->GetMotionMaster()->MovePoint(POINT_PHASE_FLY, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ() + 28);
+                    me->SetReactState(REACT_PASSIVE);
+                    me->AttackStop();
+                    me->SetInCombatWithZone();
+                    uiChangePhaseTimer = 110000;
+                } else uiChangePhaseTimer -= uiDiff;
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            InstanceScript* instance;
+
+            uint8 uiPhase;
+            uint8 uiBombCount;
+            uint32 uiBreathTimer;
+            uint32 uiCleaveTimer;
+            uint32 uiTailSmashTimer;
+            uint32 uiBlisteringColdTimer;
+            uint32 uiBerserkTimer;
+            uint32 uiMarkTimer;
+            uint32 uiChangePhaseTimer;
+            uint32 uiUnchainedMagicTimer;
+            uint32 uiBombTimer;
+
+            bool bMystic;
+            bool bCanSwitch;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new boss_sindragosaAI(creature);
+        }
+};
+
+class npc_ice_tomb : public CreatureScript
+{
+    public:
+        npc_ice_tomb() : CreatureScript("npc_ice_tomb") { }
+
+        struct npc_ice_tombAI: public Scripted_NoMovementAI
+        {
+            npc_ice_tombAI(Creature* creature) : Scripted_NoMovementAI(creature)
+            {
+                uiTargetGUID = 0;
+            }
+
+            void SetGUID(const uint64& guid)
+            {
+                uiTargetGUID = guid;
+            }
+
+            void Reset()
+            {
+                uiTargetGUID = 0;
+            }
+
+            void JustDied(Unit* killer)
+            {
+                if (Player* IceTomb = ObjectAccessor::GetPlayer(*me, uiTargetGUID))
+                {
+                    IceTomb->RemoveAurasDueToSpell(SPELL_ICE_TOMB);
+                    IceTomb->RemoveAurasDueToSpell(SPELL_ASPHYXATION);
+                }
+            }
+
+            void KilledUnit(Unit* victim)
+            {
+                me->Kill(me);
+            }
+
+            void UpdateAI(const uint32 /*uiDiff*/)
+            {
+                if(!uiTargetGUID)
+                    return;
+
+                if (Player* IceTomb = ObjectAccessor::GetPlayer(*me, uiTargetGUID))
+                    if (!IceTomb->HasAura(SPELL_ICE_TOMB))
+                        me->Kill(me);
+            }
+
+        private:
+            uint64 uiTargetGUID;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_ice_tombAI(creature);
+        }
+};
+
+class npc_rimefang : public CreatureScript
+{
+    public:
+        npc_rimefang() : CreatureScript("npc_rimefang") { }
+
+        struct npc_rimefangAI: public ScriptedAI
+        {
+            npc_rimefangAI(Creature* creature) : ScriptedAI(creature)
+            {
+                instance = creature->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                uiFrostBreathTimer = 5000;
+                uiIceBlastTimer = 7000;
+                me->SetReactState(REACT_AGGRESSIVE);
+                me->SetStandState(UNIT_STAND_STATE_SIT);
+                //me->SetFlying(true);
+            }
+
+            void EnterCombat(Unit* /*who*/)
+            {
+                me->SetStandState(UNIT_STAND_STATE_STAND);
+                DoCast(me, SPELL_FROST_AURA_ADD);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                if(instance)
+                    if(instance->GetData(DATA_SINDRAGOSA_EVENT) != DONE)
+                        instance->SetData(DATA_SPAWN, instance->GetData(DATA_SPAWN)+1);
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (uiFrostBreathTimer <= uiDiff)
+                {
+                    DoCastVictim(SPELL_FROST_BREATH_ADD);
+                    uiFrostBreathTimer = 6000;
+                } else uiFrostBreathTimer -= uiDiff;
+
+                if (uiIceBlastTimer <= uiDiff)
+                {
+                    DoCast(me, SPELL_ICE_BLAST);
+                    uiIceBlastTimer = 8000;
+                } else uiIceBlastTimer -= uiDiff;
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            InstanceScript* instance;
+
+            uint32 uiFrostBreathTimer;
+            uint32 uiIceBlastTimer;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_rimefangAI(creature);
+        }
+};
+
+class npc_spinestalker : public CreatureScript
+{
+    public:
+        npc_spinestalker() : CreatureScript("npc_spinestalker") { }
+
+        struct npc_spinestalkerAI: public ScriptedAI
+        {
+            npc_spinestalkerAI(Creature* creature) : ScriptedAI(creature)
+            {
+                instance = creature->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                uiRoarTimer = 14000;
+                uiCleaveTimer = 6000;
+                uiSweepTimer = 7000;
+                me->SetReactState(REACT_AGGRESSIVE);
+                me->SetStandState(UNIT_STAND_STATE_SIT);
+                //me->SetFlying(true);
+            }
+
+            void EnterCombat(Unit* /*who*/)
+            {
+                me->SetStandState(UNIT_STAND_STATE_STAND);
+                DoCast(me, SPELL_FROST_AURA_ADD);
+            }
+
+            void JustDied(Unit* /*killer*/)
+            {
+                if(instance)
+                    if(instance->GetData(DATA_SINDRAGOSA_EVENT) != DONE)
+                        instance->SetData(DATA_SPAWN, instance->GetData(DATA_SPAWN)+1);
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (uiRoarTimer <= uiDiff)
+                {
+                    DoCastAOE(SPELL_BELLOWING_ROAR);
+                    uiRoarTimer = 15000;
+                } else uiRoarTimer -= uiDiff;
+
+                if (uiCleaveTimer <= uiDiff)
+                {
+                    DoCastVictim(SPELL_CLEAVE_ADD);
+                    uiCleaveTimer = 5000;
+                } else uiCleaveTimer -= uiDiff;
+
+                if (uiSweepTimer <= uiDiff)
+                {
+                    DoCast(SPELL_TAIL_SWEEP);
+                    uiSweepTimer = 7000;
+                } else uiSweepTimer -= uiDiff;
+
+                DoMeleeAttackIfReady();
+            }
+        private:
+            InstanceScript* instance;
+
+            uint32 uiRoarTimer;
+            uint32 uiCleaveTimer;
+            uint32 uiSweepTimer;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_spinestalkerAI(creature);
+        }
+};
+
+class spell_sindragosa_ice_tomb : public SpellScriptLoader
+{
+    public:
+        spell_sindragosa_ice_tomb() : SpellScriptLoader("spell_sindragosa_ice_tomb") { } //70157
+
+
+        class spell_sindragosa_ice_tomb_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_sindragosa_ice_tomb_AuraScript)
+
+            void OnPeriodic(AuraEffect const* aurEff)
+            {
+                GetCaster()->CastSpell(GetTarget(), SPELL_ICE_TOMB, true);
+                GetCaster()->CastSpell(GetTarget(), SPELL_ASPHYXATION, true);
+                Creature* tomb = GetCaster()->SummonCreature(NPC_ICE_TOMB, GetCaster()->GetPositionX(), GetCaster()->GetPositionY(), GetCaster()->GetPositionZ(), 0, TEMPSUMMON_CORPSE_DESPAWN);
+                if(tomb)
+                {
+                    tomb->CastSpell(tomb, SPELL_WITHOUT_ANIMATION, true);
+                    tomb->AI()->SetGUID(GetTarget()->GetGUID());
+                }
+            }
+
+            void Register()
+            {
+                OnEffectPeriodic += AuraEffectPeriodicFn(spell_sindragosa_ice_tomb_AuraScript::OnPeriodic, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_sindragosa_ice_tomb_AuraScript();
+        }
+};
+
+class spell_sindragosa_mystic_buffet : public SpellScriptLoader
+{
+    public:
+        spell_sindragosa_mystic_buffet() : SpellScriptLoader("spell_sindragosa_mystic_buffet") { } //70127
+
+
+        class spell_sindragosa_mystic_buffet_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_sindragosa_mystic_buffet_AuraScript)
+
+            void OnApply(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                if (InstanceScript* instance = GetOwner()->GetInstanceScript())
+                    if(GetStackAmount() >= 5)
+                        instance->SetData(DATA_ALL_YOU_CAN_EAT, FAIL);
+                    else
+                        instance->SetData(DATA_ALL_YOU_CAN_EAT, DONE);
+            }
+
+            void Register()
+            {
+                OnEffectApply += AuraEffectApplyFn(spell_sindragosa_mystic_buffet_AuraScript::OnApply, EFFECT_0, SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_sindragosa_mystic_buffet_AuraScript();
+        }
+};
+
+class spell_sindragosa_unchained_magic : public SpellScriptLoader
+{
+    public:
+        spell_sindragosa_unchained_magic() : SpellScriptLoader("spell_sindragosa_unchained_magic") { } //69766
+
+
+        class spell_sindragosa_unchained_magic_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_sindragosa_unchained_magic_AuraScript)
+
+            void OnRemove(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                int32 damage = (GetStackAmount() * 2000);
+                GetTarget()->CastCustomSpell(71044, SPELLVALUE_BASE_POINT0, damage, GetTarget(), true, NULL, aurEff, GetCasterGUID());
+            }
+
+            void Register()
+            {
+                OnEffectRemove += AuraEffectRemoveFn(spell_sindragosa_unchained_magic_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_sindragosa_unchained_magic_AuraScript();
+        }
+};
+
+class spell_sindragosa_ice_tomb_effect : public SpellScriptLoader
+{
+    public:
+        spell_sindragosa_ice_tomb_effect() : SpellScriptLoader("spell_sindragosa_ice_tomb_effect") { }
+
+
+        class spell_sindragosa_ice_tomb_effect_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_sindragosa_ice_tomb_effect_SpellScript);
+
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive() && GetCaster()))
+                    return;
+
+                if (GetHitUnit()->GetTypeId() == TYPEID_PLAYER)
+                    GetCaster()->CastSpell(GetHitUnit(), SPELL_FROST_BEACON, true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_sindragosa_ice_tomb_effect_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_DUMMY);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_sindragosa_ice_tomb_effect_SpellScript();
+        }
+};
+
+class spell_sindragosa_blistering_cold : public SpellScriptLoader
+{
+    public:
+        spell_sindragosa_blistering_cold() : SpellScriptLoader("spell_sindragosa_blistering_cold") { }
+
+
+        class spell_sindragosa_blistering_cold_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_sindragosa_blistering_cold_SpellScript);
+
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive() && GetCaster()))
+                    return;
+
+                GetHitUnit()->CastSpell(GetCaster(), SPELL_ICY_TRIP_JUMP, true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_sindragosa_blistering_cold_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_sindragosa_blistering_cold_SpellScript();
+        }
+};
+
+
+void AddSC_boss_sindragosa()
+{
+    new boss_sindragosa();
+    new npc_spinestalker();
+    new npc_rimefang();
+    new npc_ice_tomb();
+    new spell_sindragosa_ice_tomb();
+    new spell_sindragosa_mystic_buffet(); //for achievement
+    new spell_sindragosa_unchained_magic();
+    new spell_sindragosa_ice_tomb_effect();
+    new spell_sindragosa_blistering_cold();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
new file mode 100644
index 0000000..ee7f936
--- /dev/null
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
@@ -0,0 +1,1369 @@
+/*
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include "ObjectMgr.h"
+#include "ScriptMgr.h"
+#include "ScriptedCreature.h"
+#include "SpellScript.h"
+#include "SpellAuraEffects.h"
+#include "icecrown_citadel.h"
+
+#define GOSSIP_MENU 10600
+//#define GOSSIP_MENU "Long have I waited for this day, hero. Are you and your allies prepared to bring the Lich King to justice? We charge on your command!"
+#define GOSSIP_START_EVENT "We are prepared, Highlord. Let us battle for the fate of Azeroth! For the light of dawn!"
+
+enum Yells
+{
+    SAY_INTRO_1_KING         = -1810001,
+    SAY_INTRO_2_TIRION       = -1810002,
+    SAY_INTRO_3_KING         = -1810003,
+    SAY_INTRO_4_TIRION       = -1810004,
+    SAY_INTRO_5_KING         = -1810005,
+    SAY_AGGRO                = -1810006,
+    SAY_REMORSELESS_WINTER   = -1810007,
+    SAY_RANDOM_1             = -1810008,
+    SAY_RANDOM_2             = -1810009,
+    SAY_KILL_1               = -1810010,
+    SAY_KILL_2               = -1810011,
+    SAY_BERSERK              = -1810012,
+    SAY_ENDING_1_KING        = -1810013,
+    SAY_ENDING_2_KING        = -1810014,
+    SAY_ENDING_3_KING        = -1810015,
+    SAY_ENDING_4_KING        = -1810016,
+    SAY_ENDING_5_TIRION      = -1810017,
+    SAY_ENDING_6_KING        = -1810018,
+    SAY_ENDING_8_TIRION      = -1810020,
+    SAY_ENDING_9_FATHER      = -1810021,
+    SAY_ENDING_10_TIRION     = -1810022,
+    SAY_ENDING_11_FATHER     = -1810023,
+    SAY_ENDING_12_KING       = -1810024,
+    SAY_DEATH_KING           = -1810025,
+    SAY_ESCAPE_FROSTMOURNE   = -1810026,
+    SAY_HARVEST_SOUL         = -1810027,
+    SAY_DEVOURED_FROSTMOURNE = -1810028,
+    SAY_SUMMON_VALKYR        = -1810029,
+    SAY_BROKEN_ARENA         = -1810030,
+    SAY_10_PROZENT           = -1810031,
+    SAY_EMOTE_DEFILE         = -1810032,
+};
+
+enum Spells
+{
+    SPELL_SUMMON_SHAMBLING_HORROR    = 70372,
+    SPELL_SUMMON_DRUDGE_GHOULS       = 70358,
+    SPELL_SUMMON_ICE_SPEHERE         = 69104,
+    SPELL_SUMMON_RAGING_SPIRIT       = 69200,
+    SPELL_SUMMON_VALKYR              = 74361,
+    SPELL_SUMMON_DEFILE              = 72762,
+    SPELL_SUMMON_VILE_SPIRIT         = 70498, //????????
+    SPELL_SUMMON_BROKEN_FROSTMOURNE  = 72406,
+    SPELL_SUMMON_SHADOW_TRAP         = 73539,
+    SPELL_INFEST                     = 70541,
+    SPELL_NECROTIC_PLAGUE            = 70337, //70337 - initial cast
+    SPELL_NECROTIC_PLAGUE_IMMUNITY   = 72846,
+    SPELL_PLAGUE_SIPHON              = 74074,
+    SPELL_REMORSELES_WINTER          = 68981,
+    SPELL_REMORSELES_WINTER_DAMAGE   = 68983,
+    SPELL_PAIN_AND_SUFFERING         = 74115,
+    //SPELL_RANDOM_TALK                = 73985,
+    SPELL_WINGS_OF_THE_DAMNED        = 74352,
+    SPELL_SOUL_REAPER                = 69409,
+    SPELL_SOUL_REAPER_HASTE_AURA     = 69410,
+    SPELL_HARVEST_SOUL_TELEPORT      = 71372, //72597
+    SPELL_HARVEST_SOULS              = 68980,
+    SPELL_QUAKE                      = 72262,
+    SPELL_CHANNEL_KING               = 71769,
+    SPELL_BROKEN_FROSTMOURNE         = 72398,
+    SPELL_BOOM_VISUAL                = 72726,
+    SPELL_ICEBLOCK_TRIGGER           = 71614,
+    SPELL_TIRION_LIGHT               = 71797,
+    SPELL_FROSTMOURNE_TRIGGER        = 72405,
+    SPELL_DISENGAGE                  = 61508,
+    SPELL_FURY_OF_FROSTMOURNE        = 72350,
+    SPELL_REVIVE                     = 72429,
+    SPELL_REVIVE_EFFECT              = 72423,
+    SPELL_CLONE_PLAYER               = 57507,
+    SPELL_DEFILE                     = 72743,
+    SPELL_ICE_PULSE                  = 69091,
+    SPELL_ICE_BURST                  = 69108,
+    SPELL_LIFE_SIPHON                = 73783,
+    SPELL_SOUL_SHRIEK                = 69242,
+    SPELL_WHOCKVAWE                  = 72149,
+    SPELL_ENRAGE                     = 72143,
+    SPELL_BURST                      = 70503,
+    SPELL_VILE_SPIRIT_DISTANCE_CHECK = 70502,
+    SPELL_ICE_BURST_DISTANCE_CHECK   = 69109,
+    SPELL_VILE_SPIRIT_ACTIVE         = 72130,
+    SPELL_RAGING_VISUAL              = 69198,
+    SPELL_REMOVE_WEAPON              = 72399,
+    SPELL_DROP_FROSTMOURNE           = 73017,
+    SPELL_SUMMON_FROSTMOURNE_TRIGGER = 72407,
+    SPELL_WMO_INTACT                 = 50176,
+    SPELL_WMO_DAMAGE                 = 50177,
+    SPELL_PLAY_MOVIE                 = 73159,
+    SPELL_SUMMON_MENETHIL            = 72420, //caster - 38584
+    SPELL_MENETHIL_VISUAL            = 72372,
+    SPELL_VALKYR_CARRY_CAN_CAST      = 74506,
+    SPELL_VALKYR_MOVE_PLAYER         = 68985, //74445
+    SPELL_VALKYR_TARGET_SEARCH       = 69030,
+    SPELL_VALKYR_CHARGE              = 74399,
+    SPELL_VALYR_EJECT_PASSANGER      = 68576,
+    SPELL_LIGH_EFFECT                = 71773,
+    SPELL_EMOTE_SHOUT                = 73213,
+    SPELL_RAGING_GHOUL_VISUAL        = 69636,
+    SPELL_RISEN_WITCH_DOCTOR_SPAWN   = 69639,
+    SPELL_ICE_SPHERE_VISUAL          = 69090,
+    SPELL_TIRION_JUMP                = 71809,
+    SPELL_LICH_KING_STOP_CAST_RES    = 72431,
+    SPELL_FROSTMOURNE_DESPAWN        = 72726,
+    SPELL_SUMMON_FROSTMOURNE         = 74081,
+    SPELL_SOUL_EFFECT                = 72305,
+
+    //SPELL_70501 //Vile Spirit Move Target Search
+};
+
+enum eActions
+{
+    ACTION_PHASESWITCH_1        = 1, //phase 1 and 3
+    ACTION_PHASESWITCH_2        = 2, //phase 2 and 4
+    ACTION_START_EVENT          = 3
+};
+
+enum ePoints
+{
+    POINT_START_EVENT_1              = 3659700,
+    POINT_PLATFORM_CENTRE            = 3659701,
+    POINT_PLATFORM_END               = 3659702,
+    POINT_VALKYR_END                 = 3659703,
+    POINT_VALKYR_ZET                 = 3659704
+};
+
+struct Position StartEvent[]=
+{
+    {465.0731f, -2123.473f, 1040.8569f},
+    {462.8351f, -2123.673f, 1040.9082f},
+    {461.5851f, -2123.673f, 1041.4082f},
+    {445.5851f, -2123.673f, 1056.1582f},
+    {436.0851f, -2123.673f, 1064.6582f}
+};
+
+struct Position MovePos[]=
+{
+    {461.792f, -2125.85f, 1040.860f, 0.0f}, // move
+    {503.156f, -2124.51f, 1040.860f, 0.0f}, // move center X: 505.2118 Y: -2124.353 Z: 840.9403
+    {490.110f, -2124.98f, 1040.860f, 0.0f}, // move tirion frostmourne
+    {467.069f, -2123.58f, 1040.857f, 0.0f}, // move tirion attack
+    {498.004f, 2201.57f, 1046.093f, 0.0f},  // move valkyr
+    {489.297f, -2124.84f, 1040.857f, 0.0f}, //start event tirion move 1
+    {503.682f, -2126.63f, 1040.940f, 0.0f}, //ëè÷ áåæèò ïîñëå âàéïà
+    {508.989f, -2124.55f, 1045.356f, 0.0f} //ëè÷ ïàðõàåò íàä ìå÷åì
+};
+
+/*struct Locations
+{
+    float x,y,z;
+};
+
+static Locations TeleportPoint[]=
+{
+    {959.996f, 212.576f, 193.843f},
+    {932.537f, 231.813f, 193.838f},
+    {958.675f, 254.767f, 193.822f},
+    {946.955f, 201.316f, 192.535f},
+    {944.294f, 149.676f, 197.551f},
+    {930.548f, 284.888f, 193.367f},
+    {965.997f, 278.398f, 195.777f},
+};*/
+
+class boss_the_lich_king : public CreatureScript
+{
+    public:
+        boss_the_lich_king() : CreatureScript("boss_the_lich_king") { }
+
+        struct boss_the_lich_kingAI : public BossAI
+        {
+            boss_the_lich_kingAI(Creature* creature) : BossAI(creature, DATA_LICH_KING), summons(me)
+            {
+                instance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                me->SetReactState(REACT_PASSIVE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+                uiPhase = 1;
+                uiRandomSpeechTimer = 33000;
+                uiBerserkTimer = 900000;
+                uiSummonShamblingHorrorTimer = 20000;
+                uiSummonDrudgeGhoulsTimer = 30000;
+                uiInfestTimer = 30000;
+                uiNecroticPlagueTimer = 30000;
+                uiIcePulsSummonTimer = 10000;
+                uiSummonSpiritTimer = 25000;
+                uiSummonValkyrTimer = 5000;
+                uiSoulReaperTimer = 30000;
+                uiDefileTimer = 25000;
+                uiInfestTimer = 40000;
+                uiSummonVileSpiritTimer = 30000;
+                uiHarvestSoulTimer = 70000;
+                uiSummonShadowTrap = 20000;
+                uiEndingTimer = 1000;
+                uiStage = 1;
+                uiTirionGUID = 0;
+
+                if(!instance)
+                    return;
+
+                instance->SetData(DATA_LICH_KING_EVENT, NOT_STARTED);
+                instance->SetData(DATA_BEEN_WAITING, NOT_STARTED);
+                instance->SetData(DATA_NECK_DEEP, DONE);
+
+                if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
+                    me->GetMotionMaster()->MovementExpired();
+
+                if(SpellEntry* spellRevive = GET_SPELL(SPELL_SUMMON_DEFILE))
+                    spellRevive->DurationIndex = 3;
+
+                if(SpellEntry* lock = GET_SPELL(SPELL_ICEBLOCK_TRIGGER))
+                    lock->Targets = 6; //target chain damage
+
+                if(SpellEntry* reaper = GET_SPELL(SPELL_SOUL_REAPER_HASTE_AURA))
+                    reaper->Targets = 1;
+
+                if(SpellEntry* plague = GET_SPELL(SPELL_PLAGUE_SIPHON)) //hack
+                    plague->Targets = 18;
+
+                if(SpellEntry* raging = GET_SPELL(SPELL_SUMMON_RAGING_SPIRIT))
+                {
+                    raging->DurationIndex = 28;
+                    raging->Effect[0] = 6;
+                }
+            }
+
+            void EnterCombat(Unit* /*pWho*/)
+            {
+                DoScriptText(SAY_AGGRO, me);
+                DoCast(me, SPELL_NECROTIC_PLAGUE_IMMUNITY);
+                if(instance)
+                    uiTirionGUID = instance->GetData64(DATA_TIRION);
+
+                if(instance)
+                    instance->SetData(DATA_LICH_KING_EVENT, IN_PROGRESS);
+            }
+
+            void JustDied(Unit* /*pKiller*/)
+            {
+                if(!instance)
+                    return;
+
+                DoScriptText(SAY_DEATH_KING, me);
+                DoCast(SPELL_PLAY_MOVIE);
+                instance->SetData(DATA_LICH_KING_EVENT, DONE);
+                if(instance->GetData(DATA_BEEN_WAITING) == DONE)
+                    instance->DoCompleteAchievement(RAID_MODE(ACHIEV_BEEN_WAITING_A_LONG_TIME_FOR_THIS_10,ACHIEV_BEEN_WAITING_A_LONG_TIME_FOR_THIS_25));
+                if(instance->GetData(DATA_NECK_DEEP) == FAIL)
+                    instance->DoCompleteAchievement(RAID_MODE(ACHIEV_NECK_DEEP_IN_VILE_10,ACHIEV_NECK_DEEP_IN_VILE_25));
+
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_INFEST);
+
+                summons.DespawnAll();
+            }
+
+            void MovementInform(uint32 type, uint32 id)
+            {
+                if(type != POINT_MOTION_TYPE)
+                    return;
+
+                switch(id)
+                {
+                    case POINT_PLATFORM_CENTRE:
+                        DoScriptText(SAY_REMORSELESS_WINTER, me);
+                        DoCast(me, SPELL_REMORSELES_WINTER);
+                        DoCast(me, SPELL_PAIN_AND_SUFFERING);
+                        DoCast(me, SPELL_WMO_INTACT);
+                        me->GetMotionMaster()->MovementExpired();
+                        break;
+                }
+            }
+
+            void JustReachedHome()
+            {
+                if(!instance)
+                    return;
+
+                instance->SetData(DATA_LICH_KING_EVENT, FAIL);
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_INFEST);
+
+                if(uiTirionGUID)
+                    if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                        tirion->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+
+                summons.DespawnAll();
+            }
+
+            void KilledUnit(Unit* victim)
+            {
+                if (uiPhase != 6 && victim->GetTypeId() == TYPEID_PLAYER)
+                    DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2), me);
+            }
+
+            void JustSummoned(Creature* summoned)
+            {
+                summons.Summon(summoned);
+                switch(summoned->GetEntry())
+                {
+                    case NPC_ICE_SPHERE:
+                        summoned->CastSpell(summoned, SPELL_ICE_BURST_DISTANCE_CHECK, true);
+                        summoned->CastSpell(summoned, SPELL_ICE_PULSE, true);
+                        summoned->CastSpell(summoned, SPELL_ICE_SPHERE_VISUAL, true);
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                        {
+                            summoned->AI()->AttackStart(target);
+                            summoned->GetMotionMaster()->MoveChase(target);
+                        }
+                        break;
+                    case NPC_DEFILE:
+                        summoned->CastSpell(summoned, SPELL_DEFILE, true);
+                        summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        break;
+                    case NPC_RAGING_SPIRIT:
+                        summoned->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+                        //Crash is here
+                        summoned->getVictim()->CastSpell(summoned, SPELL_RAGING_VISUAL, true);
+                        summoned->CastSpell(summoned, SPELL_NECROTIC_PLAGUE_IMMUNITY, true);
+                        break;
+                    case NPC_VILE_SPIRIT:
+                        summoned->CastSpell(summoned, SPELL_VILE_SPIRIT_DISTANCE_CHECK, true);
+                        break;
+                    case NPC_TRIGGER:
+                        summoned->AI()->AttackStart(me);
+                        summoned->SetVisible(false);
+                        summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        break;
+                    case NPC_FROSTMOURNE_TRIGGER:
+                        summoned->CastSpell(summoned, SPELL_BROKEN_FROSTMOURNE, false);
+                        summoned->CastSpell(summoned, SPELL_FROSTMOURNE_TRIGGER, false);
+                        summoned->SetVisible(false);
+                        break;
+                    case NPC_MENETHIL:
+                        DoScriptText(SAY_ENDING_9_FATHER, summoned);
+                        summoned->CastSpell(summoned, SPELL_REVIVE, true);
+                        summoned->CastSpell(summoned, SPELL_MENETHIL_VISUAL, true);
+                        break;
+                    case NPC_VALKYR:
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            summoned->AI()->AttackStart(target);
+                        summoned->CastSpell(summoned, SPELL_WINGS_OF_THE_DAMNED, true);
+                        summoned->CastSpell(summoned, SPELL_VALKYR_CARRY_CAN_CAST, true);
+                        break;
+                    case NPC_DRUDGE_GHOUL:
+                        summoned->CastSpell(summoned, SPELL_RAGING_GHOUL_VISUAL, true);
+                        break;
+                    case NPC_SHAMBLING_HORROR:
+                        summoned->CastSpell(summoned, SPELL_RISEN_WITCH_DOCTOR_SPAWN, true);
+                        break;
+                }
+            }
+
+            void DoAction(const int32 action)
+            {
+                switch(action)
+                {
+                    case ACTION_PHASESWITCH_1:
+                        me->SetReactState(REACT_PASSIVE);
+                        me->AttackStop();
+                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        SetCombatMovement(false);
+                        me->SetInCombatWithZone();
+                        me->GetMotionMaster()->MovePoint(POINT_PLATFORM_CENTRE, MovePos[1]);
+                        break;
+                    case ACTION_PHASESWITCH_2:
+                        uiPhase = uiPhase == 2 ? 3 : 5;
+                        me->SetReactState(REACT_AGGRESSIVE);
+                        me->RemoveAurasDueToSpell(SPELL_PAIN_AND_SUFFERING);
+                        me->SetInCombatWithZone();
+                        SetCombatMovement(true);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        break;
+                }
+            }
+
+            void DamageTaken(Unit* /*done_by*/, uint32& /*damage*/)
+            {
+                switch(uiPhase)
+                {
+                    case 1:
+                        if(!HealthAbovePct(71))
+                        {
+                            uiPhase = 2;
+                            DoAction(ACTION_PHASESWITCH_1);
+                            break;
+                        }
+                    case 3:
+                        if(!HealthAbovePct(41))
+                        {
+                            uiPhase = 4;
+                            DoAction(ACTION_PHASESWITCH_1);
+                            break;
+                        }
+                    case 5:
+                        if(!HealthAbovePct(11))
+                        {
+                            me->SummonCreature(NPC_TRIGGER, MovePos[6], TEMPSUMMON_CORPSE_DESPAWN, 900000);
+                            summons.DespawnAll();
+                            uiPhase = 6; //ending
+                        }
+                        break;
+                }
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if(uiPhase != 6)
+                {
+                    if (uiRandomSpeechTimer < uiDiff)
+                    {
+                        DoScriptText(RAND(SAY_RANDOM_1,SAY_RANDOM_2), me);
+                        uiRandomSpeechTimer = 33000;
+                    } else uiRandomSpeechTimer -= uiDiff;
+
+                    if (uiBerserkTimer < uiDiff)
+                    {
+                        DoScriptText(SAY_BERSERK, me);
+                        DoCast(me, SPELL_BERSERK);
+                        uiBerserkTimer = 900000;
+                    } else uiBerserkTimer -= uiDiff;
+                }
+
+                if(uiPhase == 1)
+                {
+                    if (IsHeroic())
+                    {
+                        if (uiSummonShadowTrap < uiDiff)
+                        {
+                            if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                                DoCast(target, SPELL_SUMMON_SHADOW_TRAP, true);
+                            uiSummonShadowTrap = 30000;
+                        } else uiSummonShadowTrap -= uiDiff;
+                    }
+
+                    if (uiInfestTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_INFEST);
+                        uiInfestTimer = 30000;
+                    } else uiInfestTimer -= uiDiff;
+
+                    if (uiSummonDrudgeGhoulsTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_DRUDGE_GHOULS);
+                        uiSummonDrudgeGhoulsTimer = 20000;
+                    } else uiSummonDrudgeGhoulsTimer -= uiDiff;
+
+                    if (uiSummonShamblingHorrorTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_SHAMBLING_HORROR);
+                        uiSummonShamblingHorrorTimer = 30000;
+                    } else uiSummonShamblingHorrorTimer -= uiDiff;
+
+                    if (uiNecroticPlagueTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_NECROTIC_PLAGUE);
+                    } else uiNecroticPlagueTimer -= uiDiff;
+                }
+
+                if(uiPhase == 2) //transition phase 1
+                {
+                    if (uiSummonSpiritTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_SUMMON_RAGING_SPIRIT);
+                        uiSummonSpiritTimer = 20000;
+                    } else uiSummonSpiritTimer -= uiDiff;
+
+                    if (uiIcePulsSummonTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_ICE_SPEHERE);
+                        uiIcePulsSummonTimer = 15000;
+                    } else uiIcePulsSummonTimer -= uiDiff;
+                }
+
+                if(uiPhase == 3)
+                {
+                    if (uiDefileTimer < uiDiff)
+                    {
+                        DoScriptText(SAY_EMOTE_DEFILE, me);
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))
+                            DoCast(target, SPELL_SUMMON_DEFILE);
+                        uiDefileTimer = 20000;
+                    } else uiDefileTimer -= uiDiff;
+
+                    if (uiSummonValkyrTimer < uiDiff)
+                    {
+                        DoScriptText(SAY_SUMMON_VALKYR, me);
+                        DoCast(SPELL_SUMMON_VALKYR);
+                        uiSummonValkyrTimer = 35000;
+                        uiDefileTimer = 5000; //cast defile after cast valkyr summon
+                    } else uiSummonValkyrTimer -= uiDiff;
+
+                    if (uiSoulReaperTimer < uiDiff)
+                    {
+                        DoCastVictim(SPELL_SOUL_REAPER);
+                        DoCast(SPELL_SOUL_REAPER_HASTE_AURA);
+                        uiSoulReaperTimer = 30000;
+                    } else uiSoulReaperTimer -= uiDiff;
+
+                    if (uiInfestTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_INFEST);
+                        uiInfestTimer = 30000;
+                    } else uiInfestTimer -= uiDiff;
+                }
+
+                if(uiPhase == 4) //transition phase 2
+                {
+                    if (uiSummonSpiritTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_SUMMON_RAGING_SPIRIT);
+                        uiSummonSpiritTimer = 25000;
+                    } else uiSummonSpiritTimer -= uiDiff;
+
+                    if (uiIcePulsSummonTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_ICE_SPEHERE);
+                        uiIcePulsSummonTimer = 15000;
+                    } else uiIcePulsSummonTimer -= uiDiff;
+                }
+
+                if(uiPhase == 5)
+                {
+                    if (uiSummonVileSpiritTimer < uiDiff)
+                    {
+                        DoCast(SPELL_SUMMON_VILE_SPIRIT);
+                        uiSummonVileSpiritTimer = 30000;
+                    } else uiSummonVileSpiritTimer -= uiDiff;
+
+                    if (uiHarvestSoulTimer < uiDiff)
+                    {
+                        DoScriptText(SAY_HARVEST_SOUL, me);
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                            DoCast(target, SPELL_HARVEST_SOULS);
+                        uiHarvestSoulTimer = 70000;
+                    } else uiHarvestSoulTimer -= uiDiff;
+
+                    if (uiSoulReaperTimer < uiDiff)
+                    {
+                        DoCastVictim(SPELL_SOUL_REAPER);
+                        DoCast(SPELL_SOUL_REAPER_HASTE_AURA);
+                        uiSoulReaperTimer = 30000;
+                    } else uiSoulReaperTimer -= uiDiff;
+
+                    if (uiDefileTimer < uiDiff)
+                    {
+                        if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))
+                            DoCast(target, SPELL_SUMMON_DEFILE);
+                        uiDefileTimer = 20000;
+                    } else uiDefileTimer -= uiDiff;
+                }
+
+                if(uiPhase == 6)
+                {
+                    if (uiEndingTimer <= uiDiff)
+                    {
+                        switch(uiStage)
+                        {
+                            case 1:
+                                me->GetMotionMaster()->MoveIdle();
+                                me->SetReactState(REACT_PASSIVE);
+                                me->AttackStop();
+                                me->CastStop();
+                                me->SetInCombatWithZone();
+                                DoScriptText(SAY_10_PROZENT, me);
+                                DoCast(SPELL_FURY_OF_FROSTMOURNE);
+                                uiEndingTimer = 15000;
+                                break;
+                            case 2:
+                                DoScriptText(SAY_ENDING_1_KING, me);
+                                uiEndingTimer = 24000;
+                                break;
+                            case 3:
+                                DoScriptText(SAY_ENDING_2_KING, me);
+                                uiEndingTimer = 25000;
+                                break;
+                            case 4:
+                                me->GetMotionMaster()->MovePoint(0, MovePos[1]);
+                                uiEndingTimer = 4000;
+                                break;
+                            case 5:
+                                DoScriptText(SAY_ENDING_3_KING, me);
+                                DoCast(me, SPELL_CHANNEL_KING);
+                                me->HandleEmoteCommand(EMOTE_ONESHOT_LAUGH);
+                                uiEndingTimer = 28000;
+                                break;
+                            case 6:
+                                DoScriptText(SAY_ENDING_4_KING, me);
+                                uiEndingTimer = 8000;
+                                break;
+                            case 7:
+                            {
+                                if(uiTirionGUID)
+                                    if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                                        DoScriptText(SAY_ENDING_5_TIRION, tirion);
+                                uiEndingTimer = 11000;
+                                break;
+                            }
+                            case 8:
+                            {
+                                if(uiTirionGUID)
+                                    if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                                        tirion->CastSpell(tirion, SPELL_TIRION_LIGHT, true);
+                                uiEndingTimer = 7000;
+                                break;
+                            }
+                            case 9:
+                            {
+                                if(uiTirionGUID)
+                                    if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                                        tirion->GetMotionMaster()->MovePoint(0, MovePos[2]);
+                                uiEndingTimer = 1000;
+                                break;
+                            }
+                            case 10:
+                            {
+                                if(uiTirionGUID)
+                                {
+                                    if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                                    {
+                                        tirion->GetMotionMaster()->MoveJump(517.482910f, -2124.905762f, 1040.861328f, 10.0f, 15.0f);
+                                        tirion->SetUInt32Value(UNIT_NPC_EMOTESTATE, 375);
+                                    }
+                                }
+                                uiEndingTimer = 1000;
+                                break;
+                            }
+                            case 11:
+                                me->RemoveAura(SPELL_CHANNEL_KING);
+                                me->CastSpell(me, SPELL_BOOM_VISUAL, false);
+                                uiEndingTimer = 3000;
+                                break;
+                            case 12:
+                                DoCast(me, SPELL_DROP_FROSTMOURNE);
+                                uiEndingTimer = 1000;
+                                break;
+                            case 13:
+                                DoScriptText(SAY_ENDING_6_KING, me);
+                                uiEndingTimer = 3000;
+                                break;
+                            case 14:
+                                DoCast(me, SPELL_SUMMON_FROSTMOURNE_TRIGGER);
+                                DoCast(me, SPELL_REMOVE_WEAPON);
+                                uiEndingTimer = 2000;
+                                break;
+                            case 15:
+                                me->RemoveAllAuras();
+                                DoPlaySoundToSet(me, SOUND_ENDING_7_KING);
+                                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, 473);
+                                uiEndingTimer = 5000;
+                                break;
+                            case 16:
+                                DoScriptText(SAY_ENDING_8_TIRION, me);
+                                uiEndingTimer = 6000;
+                                break;
+                            case 17:
+                                DoCast(SPELL_SUMMON_MENETHIL);
+                                uiEndingTimer = 3000;
+                                break;
+                            case 18:
+                                DoScriptText(SAY_ENDING_11_FATHER, me);
+                                uiEndingTimer = 6000;
+                                break;
+                            case 19:
+                                DoScriptText(SAY_ENDING_10_TIRION, me);
+                                uiEndingTimer = 5000;
+                                break;
+                            case 20:
+                                {
+                                    DoScriptText(SAY_ENDING_12_KING, me);
+                                    if(uiTirionGUID)
+                                    {
+                                        if(Creature* tirion = Unit::GetCreature(*me, uiTirionGUID))
+                                        {
+                                            tirion->SetReactState(REACT_AGGRESSIVE);
+                                            tirion->AI()->AttackStart(me);
+                                        }
+                                    }
+                                    if(Creature* father = me->FindNearestCreature(NPC_MENETHIL, 25.0f, true))
+                                        father->AI()->AttackStart(me);
+                                    uiEndingTimer = 5000;
+                                    break;
+                                }
+                        }
+                        ++uiStage;
+                    } else uiEndingTimer -= uiDiff;
+                }
+
+                DoMeleeAttackIfReady();
+            }
+        private:
+            InstanceScript* instance;
+
+            uint8 uiStage;
+            uint8 uiPhase;
+
+            uint32 uiEndingTimer;
+            uint32 uiSummonShamblingHorrorTimer;
+            uint32 uiSummonDrudgeGhoulsTimer;
+            uint32 uiSummonShadowTrap;
+            uint32 uiInfestTimer;
+            uint32 uiNecroticPlagueTimer;
+            uint32 uiBerserkTimer;
+            uint32 uiSummonValkyrTimer;
+            uint32 uiSoulReaperTimer;
+            uint32 uiDefileTimer;
+            uint32 uiHarvestSoulTimer;
+            uint32 uiSummonVileSpiritTimer;
+            uint32 uiIcePulsSummonTimer;
+            uint32 uiSummonSpiritTimer;
+            uint32 uiRandomSpeechTimer;
+            uint64 uiTirionGUID;
+
+            SummonList summons;
+
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new boss_the_lich_kingAI(creature);
+        }
+};
+
+class npc_tirion_icc : public CreatureScript
+{
+    public:
+        npc_tirion_icc() : CreatureScript("npc_tirion_icc") { }
+
+        struct npc_tirion_iccAI : public ScriptedAI
+        {
+            npc_tirion_iccAI(Creature* creature) : ScriptedAI(creature)
+            {
+                instance = creature->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                uiIntroTimer = 1000;
+                uiStage = 1;
+                uiLichKingGUID = 0;
+                bIntro = false;
+
+                me->SetReactState(REACT_PASSIVE);
+                me->SetSpeed(MOVE_RUN, 1.8f);
+                me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+            }
+
+            void DoAction(const int32 action)
+            {
+                if(action == ACTION_START_EVENT)
+                {
+                    bIntro = true;
+                    if(instance)
+                        uiLichKingGUID = instance->GetData64(DATA_LICH_KING);
+                }
+            }
+
+            void SpellHit(Unit* /*caster*/, const SpellEntry * spell)
+            {
+                if(spell->Id == SPELL_LIGH_EFFECT)
+                    me->RemoveAurasDueToSpell(SPELL_ICEBLOCK_TRIGGER);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if(!bIntro || !uiLichKingGUID)
+                    return;
+
+                if(uiIntroTimer <= diff)
+                {
+                    switch(uiStage)
+                    {
+                        case 1:
+                            {
+                                if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                {
+                                    lich->SetStandState(UNIT_STAND_STATE_STAND);
+                                    lich->GetMotionMaster()->MovePoint(POINT_START_EVENT_1, MovePos[0]);
+                                }
+                                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_READY2H);
+                                uiIntroTimer = 3000;
+                                break;
+                            }
+                        case 2:
+                        {
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_TALK);
+                            DoScriptText(SAY_INTRO_1_KING, me);
+                            uiIntroTimer = 14000;
+                            break;
+                        }
+                        case 3:
+                        {
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_NONE);
+                            DoScriptText(SAY_INTRO_2_TIRION, me);
+                            uiIntroTimer = 9000;
+                            break;
+                        }
+                        case 4:
+                        {
+                            DoScriptText(SAY_INTRO_3_KING, me);
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_LAUGH);
+                            uiIntroTimer = 3000;
+                            break;
+                        }
+                        case 5:
+                        {
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_POINT_NOSHEATHE);
+                            uiIntroTimer = 2000;
+                            break;
+                        }
+                        case 6:
+                        {
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_NONE);
+                            uiIntroTimer = 18000;
+                            break;
+                        }
+                        case 7:
+                            me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_POINT_NOSHEATHE);
+                            DoScriptText(SAY_INTRO_4_TIRION, me);
+                            uiIntroTimer = 1000;
+                            break;
+                        case 8:
+                            me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_ONESHOT_NONE);
+                            me->GetMotionMaster()->MovePoint(0, MovePos[3]);
+                            uiIntroTimer = 2000;
+                            break;
+                        case 9:
+                        {
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                                lich->CastSpell(me, SPELL_ICEBLOCK_TRIGGER, true);
+                            uiIntroTimer = 2000;
+                            break;
+                        }
+                        case 10:
+                        {
+                            DoScriptText(SAY_INTRO_5_KING, me);
+                            if(Creature* lich = Unit::GetCreature(*me, uiLichKingGUID))
+                            {
+                                lich->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                lich->SetReactState(REACT_AGGRESSIVE);
+                                if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))
+                                    lich->AI()->AttackStart(target);
+                            }
+                            uiIntroTimer = 12000;
+                            break;
+                        }
+                    }
+                    ++uiStage;
+                } else uiIntroTimer -= diff;
+            }
+            private:
+                InstanceScript* instance;
+
+                uint64 uiLichKingGUID;
+                uint32 uiIntroTimer;
+                uint8 uiStage;
+                bool bIntro;
+        };
+
+        bool OnGossipHello(Player* player, Creature* creature)
+        {
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT, GOSSIP_SENDER_MAIN, 999999);
+            player->SEND_GOSSIP_MENU(GOSSIP_MENU, creature->GetGUID());
+
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 /*uiSender*/, uint32 uiAction)
+        {
+            if (uiAction == 999999)
+            {
+                CAST_AI(npc_tirion_icc::npc_tirion_iccAI, creature->AI())->DoAction(ACTION_START_EVENT);
+                creature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                player->CLOSE_GOSSIP_MENU();
+            }
+            return true;
+        }
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_tirion_iccAI(creature);
+        }
+};
+
+class npc_valkyr_icc : public CreatureScript
+{
+    public:
+        npc_valkyr_icc() : CreatureScript("npc_valkyr_icc") { }
+
+        struct npc_valkyr_iccAI : public ScriptedAI
+        {
+            npc_valkyr_iccAI(Creature* creature) : ScriptedAI(creature), vehicle(creature->GetVehicleKit())
+            {
+                ASSERT(vehicle);
+            }
+
+            void Reset()
+            {
+                me->SetFlying(true);
+                bCanCast = false;
+                m_uiLifeSiphonTimer = 3000;
+
+                if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
+                    me->GetMotionMaster()->MovementExpired();
+            }
+
+            void DamageTaken(Unit* /*done_by*/, uint32& /*damage*/)
+            {
+                if(!HealthAbovePct(50) && IsHeroic() && !bCanCast)
+                {
+                    vehicle->RemoveAllPassengers();
+                    me->GetMotionMaster()->MovePoint(POINT_VALKYR_ZET, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ() + 10);
+                }
+            }
+
+            void PassengerBoarded(Unit* who, int8 /*seatId*/, bool apply)
+            {
+                if(apply)
+                    me->GetMotionMaster()->MovePoint(POINT_PLATFORM_END, MovePos[4]);
+            }
+
+            void MovementInform(uint32 type, uint32 id)
+            {
+                if(type != POINT_MOTION_TYPE)
+                    return;
+
+                if(bCanCast)
+                    me->GetMotionMaster()->Clear();
+
+                switch(id)
+                {
+                    case POINT_PLATFORM_END:
+                    {
+                        vehicle->RemoveAllPassengers();
+                        float x,y,z = me->GetPositionZ();
+                        me->GetNearPoint2D(x, y, 50, me->GetAngle(me));
+                        me->GetMotionMaster()->MovePoint(POINT_VALKYR_END,x,y,z+15);
+                        break;
+                    }
+                    case POINT_VALKYR_END:
+                        me->DespawnOrUnsummon();
+                        break;
+                    case POINT_VALKYR_ZET:
+                        bCanCast = true;
+                        break;
+                }
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim() || !bCanCast)
+                    return;
+
+                if (m_uiLifeSiphonTimer < uiDiff)
+                {
+                    DoCastVictim(SPELL_LIFE_SIPHON);
+                    m_uiLifeSiphonTimer = 3000;
+                } else m_uiLifeSiphonTimer -= uiDiff;
+            }
+        private:
+            uint32 m_uiLifeSiphonTimer;
+            bool bCanCast;
+
+            Vehicle* vehicle;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_valkyr_iccAI(creature);
+        }
+};
+
+class npc_vile_spirit_icc : public CreatureScript
+{
+    public:
+        npc_vile_spirit_icc() : CreatureScript("npc_vile_spirit_icc") { }
+
+        struct npc_vile_spirit_iccAI : public ScriptedAI
+        {
+            npc_vile_spirit_iccAI(Creature* creature) : ScriptedAI(creature) { }
+
+            void Reset()
+            {
+                uiMoveTimer = 15000;
+                SetCombatMovement(false);
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (uiMoveTimer < uiDiff)
+                {
+                    DoCast(me, SPELL_VILE_SPIRIT_ACTIVE);
+                    SetCombatMovement(true);
+                    if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 100, true))
+                        me->AddThreat(target, 100000.0f);
+                    uiMoveTimer = 1500000;
+                } else uiMoveTimer -= uiDiff;
+            }
+        private:
+            uint32 uiMoveTimer;
+        };
+
+        CreatureAI* GetAI(Creature* creature) const
+        {
+            return new npc_vile_spirit_iccAI(creature);
+        }
+};
+
+class spell_lich_king_necrotic_plague : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_necrotic_plague() : SpellScriptLoader("spell_lich_king_necrotic_plague") { } //70338
+
+        class spell_lich_king_necrotic_plague_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_lich_king_necrotic_plague_AuraScript)
+
+            void OnApply(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*mode*/)
+            {
+                if (InstanceScript* instance = GetCaster()->GetInstanceScript())
+                {
+                    SetStackAmount(instance->GetData(DATA_NECROTIC_STACK));
+                    instance->SetData(DATA_NECROTIC_STACK, GetStackAmount() + 1);
+                    if(GetStackAmount() >= 30)
+                        instance->SetData(DATA_BEEN_WAITING, DONE);
+                }
+            }
+
+            void Register()
+            {
+                OnEffectApply += AuraEffectApplyFn(spell_lich_king_necrotic_plague_AuraScript::OnApply, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_lich_king_necrotic_plague_AuraScript();
+        }
+};
+
+class spell_lich_king_infection : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_infection() : SpellScriptLoader("spell_lich_king_infection") { } //70541
+
+
+        class spell_lich_king_infection_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_lich_king_infection_AuraScript)
+
+            void OnPeriodic(AuraEffect const* aurEff)
+            {
+                PreventDefaultAction();
+                if(GetTarget()->GetHealthPct() < 90 || !GetCaster())
+                    return;
+
+                GetTarget()->RemoveAurasDueToSpell(SPELL_INFEST);
+            }
+
+            void Register()
+            {
+               OnEffectPeriodic += AuraEffectPeriodicFn(spell_lich_king_infection_AuraScript::OnPeriodic, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_lich_king_infection_AuraScript();
+        }
+};
+
+class spell_lich_king_valkyr_summon : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_valkyr_summon() : SpellScriptLoader("spell_lich_king_valkyr_summon") { } //74361
+
+
+        class spell_lich_king_valkyr_summon_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_lich_king_valkyr_summon_AuraScript);
+
+            void OnApply(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                if (Unit* caster = GetCaster())
+                {
+                    uint32 spawnMod = caster->GetMap()->GetSpawnMode();
+                    SetDuration(spawnMod == 1 || spawnMod == 3 ? 3000 : 1000);
+                }
+            }
+
+            void HandleTriggerSpell(AuraEffect const* aurEff)
+            {
+                PreventDefaultAction();
+                if (Unit* caster = GetCaster())
+                {
+                    uint8 triggerSpellId = GetSpellProto()->EffectTriggerSpell[aurEff->GetEffIndex()];
+                    float x, y, z;
+                    caster->GetPosition(x, y, z);
+                    caster->CastSpell(x, y, z + 6, triggerSpellId, true, NULL, NULL, GetCasterGUID(), caster);
+                }
+            }
+
+            void Register()
+            {
+                OnEffectPeriodic += AuraEffectPeriodicFn(spell_lich_king_valkyr_summon_AuraScript::HandleTriggerSpell, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
+                OnEffectApply += AuraEffectApplyFn(spell_lich_king_valkyr_summon_AuraScript::OnApply, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_lich_king_valkyr_summon_AuraScript();
+        }
+};
+
+class spell_lich_king_winter : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_winter() : SpellScriptLoader("spell_lich_king_winter") { } //68981
+
+
+        class spell_lich_king_winter_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_lich_king_winter_AuraScript)
+
+            void OnRemove(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                if (Unit* caster = GetCaster())
+                {
+                    caster->CastSpell(caster, SPELL_QUAKE, true);
+                    DoScriptText(SAY_BROKEN_ARENA, caster);
+                }
+            }
+
+            void Register()
+            {
+                OnEffectRemove += AuraEffectRemoveFn(spell_lich_king_winter_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_lich_king_winter_AuraScript();
+        }
+};
+
+class spell_lich_king_quake : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_quake() : SpellScriptLoader("spell_lich_king_quake") { } //72262
+
+
+        class spell_lich_king_quake_AuraScript : public AuraScript
+        {
+            PrepareAuraScript(spell_lich_king_quake_AuraScript)
+
+            void OnRemove(AuraEffect const* aurEff, AuraEffectHandleModes /*mode*/)
+            {
+                if(!GetCaster() || !GetOwner())
+                    return;
+
+                GetCaster()->CastSpell(GetCaster(), SPELL_WMO_DAMAGE, true);
+                if (InstanceScript* instance = GetTarget()->GetInstanceScript())
+                    if (Creature* lichKing = Unit::GetCreature(*GetTarget(), instance->GetData64(DATA_LICH_KING)))
+                        lichKing->AI()->DoAction(ACTION_PHASESWITCH_2);
+            }
+
+            void Register()
+            {
+                OnEffectRemove += AuraEffectRemoveFn(spell_lich_king_quake_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+            }
+        };
+
+        AuraScript* GetAuraScript() const
+        {
+            return new spell_lich_king_quake_AuraScript();
+        }
+};
+
+class spell_vile_spirit_distance_check : public SpellScriptLoader
+{
+    public:
+        spell_vile_spirit_distance_check() : SpellScriptLoader("spell_vile_spirit_distance_check") { }
+
+
+        class spell_vile_spirit_distance_check_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_vile_spirit_distance_check_SpellScript);
+
+
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive()))
+                    return;
+
+                if(Unit* caster = GetCaster())
+                {
+                    caster->CastSpell(caster, SPELL_BURST, true);
+
+                    if (InstanceScript* instance = caster->GetInstanceScript())
+                        instance->SetData(DATA_NECK_DEEP, FAIL);
+                }
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_vile_spirit_distance_check_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_DUMMY);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_vile_spirit_distance_check_SpellScript();
+        }
+};
+
+class spell_ice_burst_distance_check : public SpellScriptLoader
+{
+    public:
+        spell_ice_burst_distance_check() : SpellScriptLoader("spell_ice_burst_distance_check") { }
+
+
+        class spell_ice_burst_distance_check_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_ice_burst_distance_check_SpellScript);
+
+
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive()))
+                    return;
+
+                if(Unit* caster = GetCaster())
+                    caster->CastSpell(caster, SPELL_ICE_BURST, true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_ice_burst_distance_check_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_DUMMY);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_ice_burst_distance_check_SpellScript();
+        }
+};
+
+class spell_lich_king_play_movie : public SpellScriptLoader
+{
+    public:
+        spell_lich_king_play_movie() : SpellScriptLoader("spell_lich_king_play_movie") { }
+
+
+        class spell_lich_king_play_movie_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_lich_king_play_movie_SpellScript);
+
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive()))
+                    return;
+
+                if (GetHitUnit()->GetTypeId() == TYPEID_PLAYER)
+                    GetHitUnit()->ToPlayer()->SendMovieStart(MOVIE_ID_ARTHAS_DEATH);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_lich_king_play_movie_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_lich_king_play_movie_SpellScript();
+        }
+};
+
+class spell_valkyr_carry_can_cast : public SpellScriptLoader
+{
+    public:
+        spell_valkyr_carry_can_cast() : SpellScriptLoader("spell_valkyr_carry_can_cast") { }
+
+
+        class spell_valkyr_carry_can_cast_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_valkyr_carry_can_cast_SpellScript);
+
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive() && GetCaster()))
+                    return;
+
+                if (GetHitUnit()->GetTypeId() == TYPEID_PLAYER)
+                    GetHitUnit()->CastSpell(GetCaster(), SPELL_VALKYR_MOVE_PLAYER, true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_valkyr_carry_can_cast_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_valkyr_carry_can_cast_SpellScript();
+        }
+};
+
+void AddSC_boss_lichking()
+{
+    new boss_the_lich_king();
+    new npc_tirion_icc();
+    new npc_valkyr_icc();
+    new npc_vile_spirit_icc();
+    new spell_lich_king_necrotic_plague();
+    new spell_lich_king_infection();
+    new spell_lich_king_valkyr_summon();
+    new spell_lich_king_winter();
+    new spell_vile_spirit_distance_check();
+    new spell_ice_burst_distance_check();
+    new spell_lich_king_quake();
+    new spell_lich_king_play_movie();
+    new spell_valkyr_carry_can_cast();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
new file mode 100644
index 0000000..027aaa9
--- /dev/null
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
@@ -0,0 +1,1424 @@
+/*
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+#include "ScriptPCH.h"
+#include "icecrown_citadel.h"
+
+enum Yells
+{
+    SAY_AGGRO       = -1666063,
+    SAY_BELOW_25    = -1666066,
+    SAY_ABOVE_75    = -1666065,
+    SAY_DEATH       = -1666067,
+    SAY_PDEATH      = -1666068,
+    SAY_END         = -1666070,
+    SAY_FAILURES    = -1666069,
+    SAY_OPEN_PORTAL = -1666064
+};
+
+enum Spells
+{
+    SPELL_FEIGN_DEATH                   = 71598,
+    SPELL_CORRUPTION    = 70904,
+    SPELL_DREAM_SLIP    = 71196,
+    SPELL_RAGE          = 71189,
+    SPELL_COLUMN_PRE    = 70704,
+    SPELL_COLUMN_EFFECT_10N = 70702,
+    SPELL_COLUMN_EFFECT_10H_25N = 71746,
+    SPELL_COLUMN_EFFECT_25H = 72020,
+   
+    SPELL_SUMMON_ROT_WORMS_AURA = 70675,
+    SPELL_SUMMON_ROT_WORM_VISUAL = 70668,
+
+    SPELL_DREAM_STATE   = 70766,
+    SPELL_VIGOR         = 70873,
+    SPELL_TWISTED_NIGHTMARES = 71941,
+    SPELL_CLOUD_VISUAL  = 70876,
+    SPELL_PORTAL_N_PRE  = 71301,
+    SPELL_PORTAL_N_NPC  = 71305,
+    SPELL_PORTAL_H_PRE  = 71977,
+    SPELL_PORTAL_H_NPC  = 71987,
+    SPELL_SUMMON_PORTAL_TO_DREAM = 72482,
+    SPELL_DREAM_PORTAL_VISUAL = 71304,
+    SPELL_DREAM_PORTAL_VISUAL_2 = 70763,
+
+    SPELL_COPY_DAMAGE                   = 71948, 
+    //SPELL_SUMMON_SUPPRESSOR_PERIODIC    = 70912,
+    //SPELL_SUMMON_FIRE_SKELETON_PERIODIC = 70913,
+    //SPELL_SUMMON_ZOMBIE_PERIODIC        = 70914,
+    //SPELL_SUMMON_ABOMINATION_PERIODIC   = 70915,
+    //SPELL_SUMMON_ARCHMAGE_PERIODIC      = 70916,
+    //SPELL_SUMMON_SUPPRESSOR             = 70935,
+
+    SPEEL_CLEAR_AURA                    = 75863,
+    SPELL_CANCEL_ALL_AURAS              = 71721, 
+
+    SPELL_NIGHTMARE_DAMAGE              = 71946,
+
+    //Blistering Zombie spells
+    SPELL_ACID_BURST_10N                = 70744,
+    SPELL_ACID_BURST_10H                = 72017,
+    SPELL_ACID_BURST_25N                = 71733,
+    SPELL_ACID_BURST_25H                = 72018,
+
+    SPELL_CORROSION_10N                 = 70751,
+    SPELL_CORROSION_10H                 = 71738,
+    SPELL_CORROSION_25N                 = 72021,
+    SPELL_CORROSION_25H                 = 72022,
+    //Gluttonous Abomination spell
+    SPELL_GUT_SPRAY_10N                 = 70633,
+    SPELL_GUT_SPRAY_10H                 = 72025,
+    SPELL_GUT_SPRAY_25N                 = 71283,
+    SPELL_GUT_SPRAY_25H                 = 72026,
+
+    SPELL_FLESH_ROT_10N                 = 72963,
+    SPELL_FLESH_ROT_10H                 = 72964,
+    SPELL_FLESH_ROT_25N                 = 72965,
+    SPELL_FLESH_ROT_25H                 = 72966,
+    //Risen Archmage spells
+    SPELL_FROSTBOLT_VOLLEY              = 70759,
+    SPELL_SUMMON_MANA_VOID              = 71179,
+
+    SPELL_FIREBALL                      = 70754,
+    SPELL_LAY_WASTE                     = 69325,
+    SPELL_SUPPRESSION                   = 70588
+};
+
+enum eEvents
+{
+    EVENT_SUMMON_DREAM_CLOUD        = 1,
+    EVENT_DESPAWN                   = 3,
+    EVENT_DESPAWN_AND_FAIL_ACHIEVEMENT = 20,
+    //Events played when boss is healed up to 100%
+    EVENT_BERSERK                   = 4,
+    EVENT_EVADE_TO_DREAM_SLIP       = 5,
+
+    //Adds
+    EVENT_SUMMON_ARCHMAGE           = 8,
+    EVENT_SUMMON_ZOMBIE             = 17,
+    EVENT_SUMMON_ABOMINATION        = 18,
+    EVENT_SUMMON_SUPPRESSOR          = 9,
+    EVENT_SUMMON_BLAZING_SKELETON   = 10,
+    EVENT_CAST_COLUMN_OF_FROST      = 11,
+    EVENT_HASTEN_SUMMON_TIMER       = 12,
+
+    //Portals
+    EVENT_SUMMON_PORTALS_TO_DREAM   = 2,
+    EVENT_OPEN_PORTAL_TO_DREAM      = 6,
+    EVENT_EXPLODE                   = 13,
+    EVENT_CLOUD_EMULATE_DESPAWN     = 14,
+    EVENT_CLOUD_EMULATE_RESPAWN     = 15,
+    EVENT_INTRO                     = 7,
+
+    EVENT_CHECK_WIPE                = 16,
+    EVENT_CAST_ROT_WORM_SPAWN_ANIMATION = 19,
+
+    EVENT_GUT_SPRAY                 = 21,
+    EVENT_ENABLE_CASTING            = 22, 
+    EVENT_FROSTBOLT_VOLLEY          = 23,
+    EVENT_SUMMON_MANA_VOID          = 24,
+    EVENT_CAST_SUPPRESSION          = 25,
+
+    EVENT_CAST_FIREBALL             = 26,
+    EVENT_CAST_LAY_WASTE            = 27
+};
+enum eValithriaData
+{
+    DATA_INSTANCE_DIFFICULTY = 1,
+    DATA_SUMMONED_LAST_PORTALS = 2
+};
+enum eActions
+{
+    ACTION_WIPE = 1
+};
+
+
+const Position Pos[] =
+{
+    {4239.579102f, 2566.753418f, 364.868439f, 0.0f}, //normal 0,1
+    {4240.688477f, 2405.794678f, 364.868591f, 0.0f}, // normal
+    {4165.112305f, 2405.872559f, 364.872925f, 0.0f}, //2,3
+    {4166.216797f, 2564.197266f, 364.873047f, 0.0f}
+};
+
+void Cleanup(Creature *me, InstanceScript *instance, float radius)
+{
+    //Despawn heroic mode-specific mobs
+    UnsummonSpecificCreaturesNearby(me, NPC_PORTAL_HEROIC_MODE_PRE, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_PORTAL_HEROIC_MODE_NPC, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_NIGHTMARE_CLOUD, radius);
+    
+    //Despawn normal mode-specific mobs
+    UnsummonSpecificCreaturesNearby(me, NPC_PORTAL_NORMAL_MODE_PRE, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_PORTAL_NORMAL_MODE_NPC, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_DREAM_CLOUD, radius);
+
+    UnsummonSpecificCreaturesNearby(me, NPC_ZOMBIE, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_SKELETON, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_ARCHMAGE, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_SUPPRESSOR, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_ABOMINATION, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_ROT_WORM, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_COLUMN_OF_FROST, radius);
+    UnsummonSpecificCreaturesNearby(me, NPC_MANA_VOID, radius);
+
+    instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_VIGOR);
+    instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_TWISTED_NIGHTMARES);
+    instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_DREAM_STATE);
+    instance->DoRemoveAurasDueToSpellOnPlayers(((ScriptedAI*)me->AI())->RAID_MODE<uint32>(SPELL_ACID_BURST_10N, SPELL_ACID_BURST_25N, SPELL_ACID_BURST_10H, SPELL_ACID_BURST_25H));
+    instance->DoRemoveAurasDueToSpellOnPlayers(((ScriptedAI*)me->AI())->RAID_MODE<uint32>(SPELL_CORROSION_10N, SPELL_CORROSION_25N, SPELL_CORROSION_10H, SPELL_CORROSION_25H));
+    instance->DoRemoveAurasDueToSpellOnPlayers(((ScriptedAI*)me->AI())->RAID_MODE<uint32>(SPELL_FLESH_ROT_10N, SPELL_FLESH_ROT_25N, SPELL_FLESH_ROT_10H, SPELL_FLESH_ROT_25H));
+}
+
+
+class boss_valithria : public CreatureScript
+{
+    public:
+        boss_valithria() : CreatureScript("boss_valithria") { }
+
+        struct boss_valithriaAI : public BossAI
+        {
+            boss_valithriaAI(Creature* pCreature) : BossAI(pCreature, DATA_VALITHRIA_DREAMWALKER)
+            {
+                //Make Valithria immune to column of frost in case it's spawned near her
+                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);
+                me->SetSpeed(MOVE_RUN, 0.0f, true);
+                me->SetSpeed(MOVE_WALK, 0.0f, true);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_9); // 3.0.3 - makes you unable to attack everything
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                DoCast(me, SPEEL_CLEAR_AURA);
+                DoCast(me, SPELL_CORRUPTION);
+                me->SetHealth(uint32(me->GetMaxHealth() / 2));
+
+                bIntro = false;
+                bEnd = false;
+                bAboveHP = false;
+                bBelowHP = false;
+                bSummonedLastPortals = false;
+                DoCast(SPELL_COPY_DAMAGE);
+                if(SpellEntry* copy = GET_SPELL(SPELL_COPY_DAMAGE))
+                    copy->Targets = 18;
+
+            }
+            void DoAction(const int32 action)
+            {
+                if (action == EVENT_INTRO)
+                {
+                    Reset();
+                    if (Creature* combatTrigger = me->GetCreature(*me, instance->GetData64(DATA_VALITHRIA_COMBAT_TRIGGER)))
+                        me->getThreatManager().addThreat(combatTrigger, 1.0f);
+                    
+                    me->GetInstanceScript()->SetData(DATA_PORTAL_JOCKEY_ACHIEVEMENT, (uint32)true);
+                    if (IsHeroic())
+                        DoCast(me, SPELL_NIGHTMARE_DAMAGE);
+                    events.ScheduleEvent(EVENT_INTRO, 10000);
+                }
+                if (action == ACTION_WIPE)
+                {
+                    events.Reset();
+                    DoScriptText(SAY_FAILURES, me);
+                    DoCast(me, SPELL_RAGE);
+                    instance->SetData(DATA_VALITHRIA_DREAMWALKER_EVENT, FAIL);
+                    Cleanup(me, instance, 100.0f);
+                    if (Creature* combatTrigger = me->GetCreature(*me, instance->GetData64(DATA_VALITHRIA_COMBAT_TRIGGER)))
+                        combatTrigger->AI()->EnterEvadeMode();
+                    me->RemoveAllAuras();
+                    DoCast(me, SPELL_CORRUPTION);
+                    me->SetHealth(uint32(me->GetMaxHealth() / 2));
+                    EnterEvadeMode();
+                    return;
+                }
+            }
+ 
+            uint32 GetData(uint32 id)
+            {
+                switch (id)
+                {
+                    case DATA_INSTANCE_DIFFICULTY:
+                        return RAID_MODE(10, 25, 10, 25);
+                    case DATA_SUMMONED_LAST_PORTALS:
+                        return bSummonedLastPortals;
+                }
+                return BossAI::GetData(id);
+            }
+
+            void CheckHealth()
+            {
+                //Prevent healing while encounter isn't in progress
+                if (instance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) != IN_PROGRESS)
+                {
+                    me->SetHealth(uint32(me->GetMaxHealth() / 2));
+                    return;
+                }
+                switch (instance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT))
+                {
+                    case DONE:
+                        return;
+                    case NOT_STARTED:
+                    {
+                        //Disallow healing while encounter isn't in progress
+                        if (Creature* combatTrigger = me->GetCreature(*me, instance->GetData64(DATA_VALITHRIA_COMBAT_TRIGGER)))
+                            combatTrigger->AI()->EnterEvadeMode();
+                        break;
+                    }
+                    default:
+                        break;
+                }
+                if (HealthBelowPct(2))
+                {
+                    DoAction(ACTION_WIPE);
+                    return;
+                }
+                if (!bAboveHP && HealthAbovePct(74))
+                {
+                    DoScriptText(SAY_ABOVE_75, me);
+                    //Need to increase her in size
+                    bAboveHP = true;
+                    bBelowHP = false;
+                }
+                if (!bBelowHP && HealthBelowPct(26))
+                {
+                    DoScriptText(SAY_BELOW_25, me);
+                    //Need to decrease her in size
+                    bBelowHP = true;
+                    bAboveHP = false;
+                }
+                if (bSummonedLastPortals && HealthBelowPct(91))
+                {
+                    //Reset summoning last 3 portals event
+                    bSummonedLastPortals = false;
+                }
+                if (!bSummonedLastPortals && HealthAbovePct(94))
+                {
+                    bSummonedLastPortals = true;
+                    //It's very much worth noting that if Dreamwalker spawns 3 portals when almost healed to 100%
+                    for (uint8 i = 0; i < 3; ++i)
+                        DoCast(RAID_MODE(SPELL_PORTAL_N_PRE,SPELL_PORTAL_N_PRE,SPELL_PORTAL_H_PRE,SPELL_PORTAL_H_PRE));
+                }
+                if (!bEnd && HealthAbovePct(99))
+                {
+                    DoScriptText(SAY_END, me);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                    me->SetReactState(REACT_PASSIVE);
+                    DoCast(me, SPELL_CANCEL_ALL_AURAS);
+                    me->RemoveAurasDueToSpell(SPELL_CORRUPTION);
+                    bEnd = true;
+                    events.Reset();
+                    events.ScheduleEvent(EVENT_BERSERK, 1000);
+                    if (instance->GetData(DATA_PORTAL_JOCKEY_ACHIEVEMENT))
+                        instance->DoCompleteAchievement(RAID_MODE(ACHIEV_PORTAL_JOCKEY_10, ACHIEV_PORTAL_JOCKEY_25, ACHIEV_PORTAL_JOCKEY_10, ACHIEV_PORTAL_JOCKEY_25)); 
+                }
+            }
+
+            void DamageTaken(Unit* /*done_by*/, uint32& /*damage*/)
+            {
+                CheckHealth();
+            }
+
+            void HealReceived(Unit* /*done_by*/, uint32& /*addhealth*/)
+            {
+                CheckHealth();
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_INTRO:
+                        {
+                            DoScriptText(SAY_AGGRO, me);
+                            //events.ScheduleEvent(EVENT_SUMMON_ADDS, 10000);
+                            events.ScheduleEvent(EVENT_SUMMON_PORTALS_TO_DREAM, 35000);
+                            break;
+                        }
+                        case EVENT_SUMMON_PORTALS_TO_DREAM:
+                        {
+                            DoScriptText(SAY_OPEN_PORTAL, me);
+                            //DoCast(SPELL_SUMMON_PORTAL_TO_DREAM);
+                            //Need to check, maybe, this isn't required
+                            for(uint8 p = 0; p < RAID_MODE<uint8>(3, 8, 3, 8); ++p)
+                                DoCast(RAID_MODE(SPELL_PORTAL_N_PRE,SPELL_PORTAL_N_PRE,SPELL_PORTAL_H_PRE,SPELL_PORTAL_H_PRE));
+                            if (Creature* valithriaAlternative = Unit::GetCreature(*me, instance->GetData64(DATA_VALITHRIA_ALTERNATIVE)))
+                                valithriaAlternative->AI()->DoAction(EVENT_SUMMON_DREAM_CLOUD);
+                            events.ScheduleEvent(EVENT_SUMMON_PORTALS_TO_DREAM, 50000);
+                            break;
+                        }
+                        case EVENT_BERSERK:
+                        {
+                            DoCast(me, SPELL_RAGE);
+                            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                            events.ScheduleEvent(EVENT_EVADE_TO_DREAM_SLIP, 6000);
+                            break;
+                        }
+                        case EVENT_EVADE_TO_DREAM_SLIP:
+                        {
+                            DoCast(SPELL_DREAM_SLIP);
+                            events.ScheduleEvent(EVENT_DESPAWN, 1000);
+                            break;
+                        }
+                        case EVENT_DESPAWN:
+                        {
+                            Cleanup(me, instance, 100.0f);
+                            instance->SetData(DATA_VALITHRIA_DREAMWALKER_EVENT, DONE);
+                            if (Creature* combatTrigger = me->GetCreature(*me, instance->GetData64(DATA_VALITHRIA_COMBAT_TRIGGER)))
+                                combatTrigger->DespawnOrUnsummon();
+                            me->DespawnOrUnsummon();
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+            }
+
+        private:
+
+            bool bIntro;
+            bool bEnd;
+            bool bAboveHP;
+            bool bBelowHP;
+            bool bSummonedLastPortals;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new boss_valithriaAI(pCreature);
+        }
+};
+
+//Dream related NCPs and spells
+class npc_valithria_alternative : public CreatureScript
+{
+    public:
+        npc_valithria_alternative() : CreatureScript("npc_valithria_alternative") { }
+
+        struct npc_valithria_alternativeAI : public ScriptedAI
+        {
+            npc_valithria_alternativeAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = pCreature->GetInstanceScript();
+                numberOfClouds = RAID_MODE<uint8>(15, 50, 15, 50);
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                me->SetPhaseMask(16, true);
+                me->AddUnitMovementFlag(MOVEMENTFLAG_CAN_FLY);
+                me->SendMovementFlagUpdate();
+                me->SetFlying(true);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                //events.ScheduleEvent(EVENT_SUMMON_DREAM_CLOUD, 15000);
+                me->GetPosition(x,y,z);
+                bAlreadySummonedClouds = false;
+            }
+            void DoAction(const int32 action)
+            {
+                //Clouds do not respawn in heroic mode
+                if (action == EVENT_SUMMON_DREAM_CLOUD && !(IsHeroic() && bAlreadySummonedClouds))
+                {
+                    bAlreadySummonedClouds = true;
+                    const uint32 cloudEntry = IsHeroic() ? NPC_NIGHTMARE_CLOUD : NPC_DREAM_CLOUD;
+                    UnsummonSpecificCreaturesNearby(me, cloudEntry, 80.0f);
+                    float angle, summonX, summonY, summonZ, distMin = 20.0f, distMax = 35.0f, zVariation = 15.0f, summonDist;
+                    //Summon Dream clouds in a circle pattern, but randomize their positions a little (random angle and random Z coordinate)
+                    for(uint8 i = 0; i <= numberOfClouds; ++i) //need correct count
+                    {
+                        //angle = (float)rand_norm() * static_cast<float>(2 * M_PI);
+                        //Distribute portals evenly around the boss, with a little angle variation
+                        angle = static_cast<float>(2 * M_PI) * i / numberOfClouds + (float)rand_norm() * 0.07;
+                        summonDist = distMin + (distMax - distMin) * (float)rand_norm();
+                        summonX = x + summonDist * cos(angle);
+                        summonY = y + summonDist * sin(angle);
+                        summonZ = z + (float)rand_norm() * zVariation - zVariation / 2.0f;
+                        //Trinity::NormalizeMapCoord(summonX);
+                        //Trinity::NormalizeMapCoord(summonY);
+                        me->SummonCreature(cloudEntry, summonX, summonY, summonZ, 0, TEMPSUMMON_TIMED_DESPAWN, IsHeroic() ? 600000 : 50000);
+                    }
+                }
+            }
+
+        private:
+            InstanceScript* pInstance;
+            bool bAlreadySummonedClouds;
+            float x, y, z;
+            uint8 numberOfClouds;
+            EventMap events;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_valithria_alternativeAI(pCreature);
+        }
+}; 
+
+class npc_dreamportal_icc : public CreatureScript
+{
+    public:
+        npc_dreamportal_icc() : CreatureScript("npc_dreamportal_icc") { }
+
+        struct npc_dreamportal_iccAI : public Scripted_NoMovementAI
+        {
+            npc_dreamportal_iccAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
+            {
+                pInstance = pCreature->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+                me->SetSpeed(MOVE_WALK, 0.0f);
+                me->SetSpeed(MOVE_RUN, 0.0f);
+                me->SetReactState(REACT_PASSIVE);
+                events.Reset();
+                if (Creature* valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER)))
+                    if (valithria->GetAI()->GetData(DATA_SUMMONED_LAST_PORTALS))
+                        //Last 3 portals should be opened almost immediately after they were summoned
+                        events.ScheduleEvent(EVENT_OPEN_PORTAL_TO_DREAM, 1000);
+                    else
+                        events.ScheduleEvent(EVENT_OPEN_PORTAL_TO_DREAM, 15000);
+            }
+            void DoAction(const int32 action)
+            {
+                if (action == EVENT_SPELLCLICK)
+                    events.ScheduleEvent(EVENT_DESPAWN, 100);
+            }
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_OPEN_PORTAL_TO_DREAM:
+                        {
+                            if(me->GetEntry() == NPC_PORTAL_NORMAL_MODE_PRE)
+                            {
+                                me->UpdateEntry(NPC_PORTAL_NORMAL_MODE_NPC);
+                                if (urand(0, 1))
+                                    DoCast(me, SPELL_DREAM_PORTAL_VISUAL);
+                                else
+                                    DoCast(me, SPELL_DREAM_PORTAL_VISUAL_2);
+                            }
+                            else
+                                if(me->GetEntry() == NPC_PORTAL_HEROIC_MODE_PRE)
+                                {
+                                    me->UpdateEntry(NPC_PORTAL_HEROIC_MODE_NPC);
+                                    if (urand(0, 1))
+                                        DoCast(me, SPELL_DREAM_PORTAL_VISUAL);
+                                    else
+                                        DoCast(me, SPELL_DREAM_PORTAL_VISUAL_2);
+                                }
+                            events.ScheduleEvent(EVENT_DESPAWN_AND_FAIL_ACHIEVEMENT, 15000);
+                            break;
+                        }
+                        case EVENT_DESPAWN_AND_FAIL_ACHIEVEMENT:
+                        {
+                            me->GetInstanceScript()->SetData(DATA_PORTAL_JOCKEY_ACHIEVEMENT, (uint32)false);
+                            me->DespawnOrUnsummon();
+                            break;
+                        }
+                        case EVENT_DESPAWN:
+                        {
+                            me->DespawnOrUnsummon();
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+                
+
+            }
+
+        private:
+            EventMap events;
+            uint32 m_uiChangeTimer;
+            InstanceScript *pInstance;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_dreamportal_iccAI(pCreature);
+        }
+};
+
+class npc_dreamcloud_icc : public CreatureScript 
+{
+    public:
+        npc_dreamcloud_icc() : CreatureScript("npc_dreamcloud_icc") { }
+
+        struct npc_dreamcloud_iccAI : public ScriptedAI
+        {
+            npc_dreamcloud_iccAI(Creature* pCreature) : ScriptedAI(pCreature) { }
+
+            void Reset()
+            {
+                canApplyBuff = true;
+                events.Reset();
+                me->SetPhaseMask(16, true);
+                DoCast(SPELL_CLOUD_VISUAL);
+                me->AddUnitMovementFlag(MOVEMENTFLAG_CAN_FLY);
+                me->SendMovementFlagUpdate();
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetReactState(REACT_AGGRESSIVE);
+            }
+
+            void MoveInLineOfSight(Unit *who)
+            {
+                if (canApplyBuff && me->IsWithinDistInMap(who, 5.0f, true) && who->GetTypeId() == TYPEID_PLAYER)
+                {
+                    canApplyBuff = false;
+                    //Cloud will explode in about 1-2 seconds after player touch it
+                    events.ScheduleEvent(EVENT_EXPLODE, 1500);
+                }
+                ScriptedAI::MoveInLineOfSight(who);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_EXPLODE:
+                        {
+                            //Apply buff to player
+                            const uint32 spellId = IsHeroic() ? SPELL_TWISTED_NIGHTMARES : SPELL_VIGOR;
+                            //Apply buff only if player is within 5 feet of the cloud
+                            DoCast(me, spellId, true);
+
+                            //Just show explode animation effect
+                            events.ScheduleEvent(EVENT_CLOUD_EMULATE_DESPAWN, 2000);
+                            break;
+                        }
+                        case EVENT_CLOUD_EMULATE_DESPAWN:
+                        {
+                            me->SetVisible(false);
+                            //In normal mode, the clouds have a very fast respawn so you wont run the risk of running out of them. 
+                            if (!IsHeroic())
+                                events.ScheduleEvent(EVENT_CLOUD_EMULATE_RESPAWN, 7000);
+                            break;
+                        }
+                        case EVENT_CLOUD_EMULATE_RESPAWN:
+                        {
+                            me->SetVisible(true);
+                            canApplyBuff = true;
+                        }
+                        default:
+                            break;
+                    }
+                }
+            }
+        private:
+            EventMap events;
+            bool canApplyBuff;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_dreamcloud_iccAI(pCreature);
+        }
+};
+
+class spell_valithria_summon_portal : public SpellScriptLoader
+{
+    public:
+        spell_valithria_summon_portal() : SpellScriptLoader("spell_valithria_summon_portal") { }
+
+        class spell_valithria_summon_portal_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_valithria_summon_portal_SpellScript);
+
+            void ChangeSummonPos(SpellEffIndex /*effIndex*/)
+            {
+                if (Creature *valithria = GetCaster()->ToCreature())
+                {
+                    uint32 instanceDifficulty = valithria->GetAI()->GetData(DATA_INSTANCE_DIFFICULTY);
+                    float x, y, distMin = 15.0f, distMax = 30.0f;
+                    valithria->GetPosition(x, y);
+                    float maxAngle = ((instanceDifficulty == 25) ?  static_cast<float>(2 * M_PI) :  static_cast<float>(M_PI));
+                    //Decrease ange by 90 degreese because portals should be spawned in front of boss in 10-man modes
+                    float angle = (float)rand_norm() * maxAngle - static_cast<float>(M_PI) / 2.0f;
+                    float summonDist = distMin + (distMax - distMin) * (float)rand_norm();
+                    float summonX = x + summonDist * cos(angle);
+                    float summonY = y + summonDist * sin(angle);
+
+                    WorldLocation* summonPos = GetTargetDest();
+                    summonPos->Relocate(summonX, summonY); 
+                }
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_valithria_summon_portal_SpellScript::ChangeSummonPos, EFFECT_0, SPELL_EFFECT_SUMMON);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_valithria_summon_portal_SpellScript();
+        }
+};
+
+class spell_valithria_vigor : public SpellScriptLoader
+{
+    public:
+        spell_valithria_vigor() : SpellScriptLoader("spell_valithria_vigor") { }
+
+        class spell_valithria_vigor_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_valithria_vigor_SpellScript);
+
+            bool Load()
+            {
+                playersAuraStacks.clear();
+                return true;
+            }
+
+            void EnsureThatAurasStack()
+            {
+                if (!(GetHitUnit() && GetHitUnit()->isAlive()))
+                    return;
+                if (GetHitUnit()->GetGUID() == GetCaster()->GetGUID())
+                    return;
+
+                if (Unit *who = GetHitUnit())
+                {
+                    uint32 curSpellId = GetSpellInfo()->Id;
+                    if (Aura* existingAura = who->GetAura(curSpellId))
+                    {
+                        playersAuraStacks[who->GetGUID()] = existingAura->GetStackAmount();
+                    }
+                }
+            }
+
+            void RemoveImmunity()
+            {
+                if (Unit* target = GetHitUnit())
+                {
+                    if (playersAuraStacks[target->GetGUID()])
+                    {
+                        if (Aura* existingAura = GetHitUnit()->GetAura(GetSpellInfo()->Id))
+                        {
+                            existingAura->SetStackAmount(playersAuraStacks[target->GetGUID()]+1);
+                            existingAura->RefreshDuration();
+                        }
+                    }
+                }
+            }
+
+            void Register()
+            {
+                BeforeHit += SpellHitFn(spell_valithria_vigor_SpellScript::EnsureThatAurasStack);
+                AfterHit += SpellHitFn(spell_valithria_vigor_SpellScript::RemoveImmunity);
+            }
+        private:
+            std::map<uint64, uint8> playersAuraStacks;
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_valithria_vigor_SpellScript();
+        }
+};
+
+//End of Dream related NPCs and spells
+class npc_column_of_frost_icc : public CreatureScript 
+{
+    public:
+        npc_column_of_frost_icc() : CreatureScript("npc_column_of_frost_icc") { }
+
+        struct npc_column_of_frost_iccAI : public ScriptedAI
+        {
+            npc_column_of_frost_iccAI(Creature* pCreature) : ScriptedAI(pCreature) { }
+            void Reset()
+            {
+                events.ScheduleEvent(EVENT_CAST_COLUMN_OF_FROST, 2000);
+                //Knockback value fix
+                me->SetFloatValue(UNIT_FIELD_COMBATREACH, 50.0f);
+            }
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_COLUMN_OF_FROST:
+                        {
+                            uint32 effectId = RAID_MODE<uint32>(SPELL_COLUMN_EFFECT_10N, SPELL_COLUMN_EFFECT_10H_25N, SPELL_COLUMN_EFFECT_10H_25N, SPELL_COLUMN_EFFECT_25H);
+                            DoCast(me, effectId, true);
+                            events.ScheduleEvent(EVENT_DESPAWN, 3500);
+                            break;
+                        }
+                        case EVENT_DESPAWN:
+                            me->DespawnOrUnsummon();
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+        private:
+            EventMap events;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_column_of_frost_iccAI(pCreature);
+        }
+};
+
+class npc_icc_combat_stalker : public CreatureScript
+{
+    public:
+        npc_icc_combat_stalker() : CreatureScript("npc_icc_combat_stalker") { }
+
+        struct npc_icc_combat_stalkerAI : public ScriptedAI
+        {
+            npc_icc_combat_stalkerAI(Creature* pCreature) : ScriptedAI(pCreature), summons(me)
+            {
+                pInstance = me->GetInstanceScript();
+            }
+
+            void DamageTaken(Unit* /*done_by*/, uint32& damage)
+            {
+                damage = 0;
+                me->SetFullHealth();
+            }
+            void JustDied(Unit* killer)
+            {
+                if (Creature* valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER)))
+                    DoScriptText(SAY_FAILURES, me);
+            }
+            void EnterCombat(Unit* who)
+            {   
+                bSummonColumns = false;
+                bSummonZombies = true;
+                bSummonAbominations = true;
+                bSummonArchmages = true;
+                bSummonSkeletons = true;
+                bSummonSuppressors = true;
+
+                events.Reset();
+                events.ScheduleEvent(EVENT_CHECK_WIPE, 1000);
+                if (Creature* valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER)))
+                    AttackStart(valithria);
+                me->getThreatManager().addThreat(who, 5000);
+                DoZoneInCombat(me);
+                m_uiSummonSkeletonTimer = 60000;
+                m_uiSummonSuppressorTimer = 60000;
+                events.ScheduleEvent(EVENT_SUMMON_ZOMBIE, 17000);
+                events.ScheduleEvent(EVENT_SUMMON_ARCHMAGE, 2000);
+                events.ScheduleEvent(EVENT_SUMMON_ABOMINATION, 10000);
+                events.ScheduleEvent(EVENT_SUMMON_SUPPRESSOR, 20000);
+                events.ScheduleEvent(EVENT_SUMMON_BLAZING_SKELETON, 5000);
+
+                events.ScheduleEvent(EVENT_HASTEN_SUMMON_TIMER, 30000);
+                events.ScheduleEvent(EVENT_CHECK_WIPE, 1000);
+                pInstance->SetData(DATA_VALITHRIA_DREAMWALKER_EVENT, IN_PROGRESS);
+                if (Creature* valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER)))
+                    valithria->AI()->DoAction(EVENT_INTRO);
+
+            }
+
+            void MoveInLineOfSight(Unit *who)
+            {
+                if (!pInstance)
+                    return;
+                if (pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) == IN_PROGRESS)
+                    return;
+                if (me->IsWithinDistInMap(who, 80.0f, true) && who->GetTypeId() == TYPEID_PLAYER)
+                    AttackStart(who);
+                ScriptedAI::MoveInLineOfSight(who);
+            }
+
+            void EnterEvadeMode()
+            {
+                me->getThreatManager().clearReferences();
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
+                summons.DespawnAll();
+                events.Reset();
+                ScriptedAI::EnterEvadeMode();
+            }
+
+            void JustSummoned(Creature* pSummoned)
+            {
+                if (Creature* valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER)))
+                    pSummoned->AI()->AttackStart(valithria);
+                summons.Summon(pSummoned);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                if (Creature* valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER)))
+                    DoScriptText(SAY_PDEATH, valithria);
+            }
+
+            void SummonCreature(uint32 entry, uint8 probability)
+            {
+                bool bSuccessfully = false;
+                for (int i = 0; i < RAID_MODE(2,4,2,4); ++i)
+                    if (urand(0, 100) < probability)
+                    {
+                        bSuccessfully = true;
+                        DoSummon(entry, Pos[i]);
+                    }
+                //Nobody was summoned - summon at least one
+                if (!bSuccessfully)
+                    DoSummon(entry, Pos[urand(0, RAID_MODE(1,3,1,3))]);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!pInstance || pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) != IN_PROGRESS)
+                    return;
+                events.Update(diff);
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CHECK_WIPE:
+                        {
+                            if (!SelectTarget(SELECT_TARGET_RANDOM, 0, 60.0f, true))
+                            {
+                                if (Creature* valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER)))
+                                    valithria->AI()->DoAction(ACTION_WIPE);
+                                return;
+                            }
+                            else
+                                events.ScheduleEvent(EVENT_CHECK_WIPE, 1000);
+                            break;
+                        }
+                        case EVENT_SUMMON_ZOMBIE:
+                        {
+                            if (bSummonZombies)
+                            {
+                                SummonCreature(NPC_ZOMBIE, 50);
+                            }
+                            events.ScheduleEvent(EVENT_SUMMON_ZOMBIE, 30000);
+                            break;
+                        }
+                        case EVENT_SUMMON_ARCHMAGE:
+                        {
+                            if (bSummonArchmages)
+                                SummonCreature(NPC_ARCHMAGE, 75);
+                            events.ScheduleEvent(EVENT_SUMMON_ARCHMAGE, 60000);
+                            break;
+                        }
+                        case EVENT_SUMMON_ABOMINATION:
+                        {
+                            if (bSummonAbominations)
+                                SummonCreature(NPC_ABOMINATION, 80);
+                            events.ScheduleEvent(EVENT_SUMMON_ABOMINATION, 60000);
+                            break;
+                        }
+                        case EVENT_SUMMON_SUPPRESSOR:
+                        {
+                            if (bSummonSuppressors)
+                                SummonCreature(NPC_SUPPRESSOR, 60);
+                            events.ScheduleEvent(EVENT_SUMMON_SUPPRESSOR, urand(m_uiSummonSuppressorTimer-2000, m_uiSummonSuppressorTimer+2000));
+                            break;
+                        }
+                        case EVENT_SUMMON_BLAZING_SKELETON:
+                        {
+                            if (bSummonSkeletons)
+                                SummonCreature(NPC_SKELETON, 80);
+                            events.ScheduleEvent(EVENT_SUMMON_BLAZING_SKELETON, urand(m_uiSummonSkeletonTimer-2000, m_uiSummonSkeletonTimer+2000));
+                            break;
+                        }
+                        case EVENT_HASTEN_SUMMON_TIMER:
+                        {
+                            //After 7/? (10/25 player) minutes, Suppressors and Blazing Skeletons start to spawn continuously
+                            //(which usually leads to a quick wipe)
+                            m_uiSummonSuppressorTimer -= 5000;
+                            m_uiSummonSkeletonTimer -= 5000;
+                            if (m_uiSummonSuppressorTimer < 2000)
+                                m_uiSummonSuppressorTimer = 2000;
+                            if (m_uiSummonSkeletonTimer < 2000)
+                                m_uiSummonSkeletonTimer = 2000;
+                            events.ScheduleEvent(EVENT_HASTEN_SUMMON_TIMER, 30000);
+                            break;
+                        }
+                        default: 
+                            break;
+                    }
+                }
+
+            }
+            private:
+                InstanceScript* pInstance;
+
+                uint32 m_uiSummonSkeletonTimer, m_uiSummonSuppressorTimer;
+                SummonList summons;
+                EventMap events;
+                bool bSummonColumns, bSummonZombies, bSummonSuppressors, bSummonArchmages, bSummonSkeletons, bSummonAbominations;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_icc_combat_stalkerAI(pCreature);
+        }
+};
+class npc_icc_valithria_rot_worm : public CreatureScript
+{
+    public:
+        npc_icc_valithria_rot_worm() : CreatureScript("npc_icc_valithria_rot_worm") { }
+
+        struct npc_icc_valithria_rot_wormAI : public ScriptedAI
+        {
+
+            npc_icc_valithria_rot_wormAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+            }
+            void Reset()
+            {
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_ROT_WORM_SPAWN_ANIMATION, 500);
+            }
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_ROT_WORM_SPAWN_ANIMATION:  
+                            DoCast(me, SPELL_SUMMON_ROT_WORM_VISUAL);
+                            break;
+                        default: 
+                            break;
+                    }
+                }
+                DoMeleeAttackIfReady();
+            }
+        private:
+            EventMap events;
+        };
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_icc_valithria_rot_wormAI(pCreature);
+        }
+};
+
+class npc_icc_valithria_gluttonous_abomination : public CreatureScript
+{
+    public:
+        npc_icc_valithria_gluttonous_abomination() : CreatureScript("npc_icc_valithria_gluttonous_abomination") { }
+
+        struct npc_icc_valithria_gluttonous_abominationAI : public ScriptedAI
+        {
+
+            npc_icc_valithria_gluttonous_abominationAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = pCreature->GetInstanceScript();
+                valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER));
+            }
+            void Reset()
+            {
+                bGutSprayReady = false;
+                events.Reset();
+            }
+            void JustDied(Unit *pKiller)
+            {
+                Position pos;
+                me->GetPosition(&pos);
+                Creature *rotSummoner = DoSummon(NPC_TRIGGER, pos, 3000, TEMPSUMMON_TIMED_DESPAWN);
+                rotSummoner->CastSpell(rotSummoner, SPELL_SUMMON_ROT_WORMS_AURA, true);
+                rotSummoner->SetVisible(false);
+                rotSummoner->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim())
+                    return;
+                if (!me->isInCombat())
+                    return;
+                events.Update(diff);
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_DESPAWN:
+                            me->DespawnOrUnsummon();
+                            break;
+                        case EVENT_GUT_SPRAY:
+                            bGutSprayReady = true;
+                            events.ScheduleEvent(EVENT_GUT_SPRAY, 5000);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+                if (me->IsWithinMeleeRange(me->getVictim()))
+                    if (bGutSprayReady)
+                        bGutSprayReady = !DoSpellAttackIfReady(RAID_MODE<uint32>(SPELL_GUT_SPRAY_10N, SPELL_GUT_SPRAY_25N, SPELL_GUT_SPRAY_10H, SPELL_GUT_SPRAY_25H));
+                DoMeleeAttackIfReady();
+            }
+        private:
+            bool bGutSprayReady;
+            EventMap events;  
+            InstanceScript *pInstance;
+            Creature *valithria;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_icc_valithria_gluttonous_abominationAI(pCreature);
+        }
+};
+
+class npc_icc_valithria_mana_void : public CreatureScript
+{
+    public:
+        npc_icc_valithria_mana_void() : CreatureScript("npc_icc_valithria_mana_void") { }
+
+        struct npc_icc_valithria_mana_voidAI : public ScriptedAI
+        {
+
+            npc_icc_valithria_mana_voidAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+            }
+            void Reset()
+            {
+                events.ScheduleEvent(EVENT_DESPAWN, 30000);
+            }
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_DESPAWN:
+                            me->DespawnOrUnsummon();
+                            break;
+                    }
+                }
+            }
+        private:
+            EventMap events;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_icc_valithria_mana_voidAI(pCreature);
+        }
+};
+
+class npc_icc_valithria_blistering_zombie : public CreatureScript
+{
+    public:
+        npc_icc_valithria_blistering_zombie() : CreatureScript("npc_icc_valithria_blistering_zombie") { }
+
+        struct npc_icc_valithria_blistering_zombieAI : public ScriptedAI
+        {
+
+            npc_icc_valithria_blistering_zombieAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = pCreature->GetInstanceScript();
+                valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER));
+            }
+            void Reset()
+            {
+                events.Reset();
+            }
+            void DamageDealt(Unit* target, uint32& damage, DamageEffectType damageType)
+            {
+                if (damageType != DIRECT_DAMAGE)
+                    return;
+                DoCast(target, RAID_MODE<uint32>(SPELL_CORROSION_10N, SPELL_CORROSION_25N, SPELL_CORROSION_10H, SPELL_CORROSION_25H));
+            }
+            void EnterCombat(Unit *who)
+            {
+                events.Reset();
+                events.ScheduleEvent(EVENT_EXPLODE, 25000);
+            }
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim())
+                    return;
+                if (!me->isInCombat())
+                    return;
+                events.Update(diff);
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_EXPLODE:
+                            DoCast(me, RAID_MODE<uint32>(SPELL_ACID_BURST_10N, SPELL_ACID_BURST_25N, SPELL_ACID_BURST_10H, SPELL_ACID_BURST_25H));
+                            events.ScheduleEvent(EVENT_EXPLODE, 25000);
+                            break;
+                        case EVENT_DESPAWN:
+                            me->DespawnOrUnsummon();
+                            break;
+                    }
+                }
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            EventMap events;
+            InstanceScript *pInstance;
+            Creature *valithria;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_icc_valithria_blistering_zombieAI(pCreature);
+        }
+};
+
+class npc_icc_valithria_risen_archmage : public CreatureScript
+{
+    public:
+        npc_icc_valithria_risen_archmage() : CreatureScript("npc_icc_valithria_risen_archmage") { }
+
+        struct npc_icc_valithria_risen_archmageAI : public ScriptedAI
+        {
+
+            npc_icc_valithria_risen_archmageAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = pCreature->GetInstanceScript();
+                valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER));
+            }
+            void Reset()
+            {
+                events.Reset();
+            }
+            void EnterCombat(Unit *who)
+            {
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_COLUMN_OF_FROST, 4000);
+                events.ScheduleEvent(EVENT_FROSTBOLT_VOLLEY, 8000);
+                events.ScheduleEvent(EVENT_SUMMON_MANA_VOID, 14000);
+            }
+            void KilledUnit(Unit* victim)
+            {
+                DoStopAttack();
+                DoResetThreat();
+            }
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim())
+                    return;
+                if (!me->isInCombat())
+                    return;
+                events.Update(diff);
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_COLUMN_OF_FROST:
+                            if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))
+                                DoCast(pTarget, SPELL_COLUMN_PRE);
+                            events.ScheduleEvent(EVENT_CAST_COLUMN_OF_FROST, 10000);
+                            break;
+                        case EVENT_FROSTBOLT_VOLLEY:
+                            DoCast(me, SPELL_FROSTBOLT_VOLLEY);
+                            events.ScheduleEvent(EVENT_FROSTBOLT_VOLLEY, 5000);
+                            break;
+                        case EVENT_SUMMON_MANA_VOID:
+                        {
+                            if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))
+                                DoCast(pTarget, SPELL_SUMMON_MANA_VOID);
+                            events.ScheduleEvent(EVENT_SUMMON_MANA_VOID, 15000);
+                            break;
+                        }
+                    }
+                }
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            EventMap events;
+            InstanceScript *pInstance;
+            Creature *valithria;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_icc_valithria_risen_archmageAI(pCreature);
+        }
+};
+
+class npc_icc_valithria_supressor : public CreatureScript
+{
+    public:
+        npc_icc_valithria_supressor() : CreatureScript("npc_icc_valithria_supressor") { }
+
+        struct npc_icc_valithria_supressorAI : public ScriptedAI
+        {
+            npc_icc_valithria_supressorAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = pCreature->GetInstanceScript();
+                valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER));
+            }
+            void Reset()
+            {
+                events.Reset();
+            }
+            void EnterCombat(Unit *who)
+            {
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_SUPPRESSION, 8000);
+            }
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim())
+                    return;
+                if (!me->isInCombat())
+                    return;
+                events.Update(diff);
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_SUPPRESSION:
+                            DoCast(valithria, SPELL_SUPPRESSION);
+                            events.ScheduleEvent(EVENT_CAST_SUPPRESSION, 1000);
+                            break;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            EventMap events;
+            InstanceScript *pInstance;
+            Creature *valithria;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_icc_valithria_supressorAI(pCreature);
+        }
+};
+
+class npc_icc_valithria_blazing_skeleton : public CreatureScript
+{
+    public:
+        npc_icc_valithria_blazing_skeleton() : CreatureScript("npc_icc_valithria_blazing_skeleton") { }
+
+        struct npc_icc_valithria_blazing_skeletonAI : public ScriptedAI
+        {
+            npc_icc_valithria_blazing_skeletonAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = pCreature->GetInstanceScript();
+                valithria = Unit::GetCreature(*me, pInstance->GetData64(DATA_VALITHRIA_DREAMWALKER));
+            }
+            void Reset()
+            {
+                events.Reset();
+            }
+            void EnterCombat(Unit *who)
+            {
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_FIREBALL, 4000);
+                events.ScheduleEvent(EVENT_CAST_LAY_WASTE, 8000);
+            }
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim())
+                    return;
+                if (!me->isInCombat())
+                    return;
+                events.Update(diff);
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_FIREBALL:
+                            DoCast(me->getVictim(), SPELL_FIREBALL);
+                            events.ScheduleEvent(EVENT_CAST_FIREBALL, 5000);
+                            break;
+                        case EVENT_CAST_LAY_WASTE:
+                            DoCast(SPELL_LAY_WASTE);
+                            events.ScheduleEvent(EVENT_CAST_LAY_WASTE, 20000);
+                            break;
+                    }
+                }
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            EventMap events;
+            InstanceScript *pInstance;
+            Creature *valithria;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_icc_valithria_blazing_skeletonAI(pCreature);
+        }
+};
+
+void AddSC_boss_valithria()
+{
+    new boss_valithria();
+    new npc_dreamportal_icc();
+    new npc_dreamcloud_icc();
+    new npc_icc_combat_stalker();
+    new npc_valithria_alternative();
+    new spell_valithria_summon_portal();
+    new spell_valithria_vigor();
+    new npc_column_of_frost_icc();
+    new npc_icc_valithria_gluttonous_abomination();
+    new npc_icc_valithria_mana_void();
+    new npc_icc_valithria_rot_worm();
+    new npc_icc_valithria_blistering_zombie();
+    new npc_icc_valithria_supressor();
+    new npc_icc_valithria_risen_archmage();
+    new npc_icc_valithria_blazing_skeleton();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
old mode 100755
new mode 100644
index 6eac43f..5998158
--- a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
+++ b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
@@ -27,6 +27,12 @@ enum SharedSpells
     SPELL_BERSERK2  = 47008
 };
 
+enum eEnums
+{
+    SOUND_ENDING_7_KING                   = 17360,
+    MOVIE_ID_ARTHAS_DEATH                 = 16
+};
+
 enum TeleporterSpells
 {
     LIGHT_S_HAMMER_TELEPORT         = 70781,
@@ -41,33 +47,48 @@ enum TeleporterSpells
 enum DataTypes
 {
     // Encounter States/Boss GUIDs
-    DATA_LORD_MARROWGAR             = 0,
-    DATA_LADY_DEATHWHISPER          = 1,
-    DATA_GUNSHIP_EVENT              = 2,
-    DATA_DEATHBRINGER_SAURFANG      = 3,
-    DATA_FESTERGUT                  = 4,
-    DATA_ROTFACE                    = 5,
-    DATA_PROFESSOR_PUTRICIDE        = 6,
-    DATA_BLOOD_PRINCE_COUNCIL       = 7,
-    DATA_BLOOD_QUEEN_LANA_THEL      = 8,
-    DATA_VALITHRIA_DREAMWALKER      = 9,
-    DATA_SINDRAGOSA                 = 10,
-    DATA_THE_LICH_KING              = 11,
+    DATA_LORD_MARROWGAR              = 0,
+    DATA_LADY_DEATHWHISPER           = 1,
+    DATA_GUNSHIP_BATTLE_EVENT        = 2,
+    DATA_DEATHBRINGER_SAURFANG       = 3,
+    DATA_FESTERGUT                   = 4,
+    DATA_ROTFACE                     = 5,
+    DATA_PROFESSOR_PUTRICIDE         = 6,
+    DATA_BLOOD_PRINCE_COUNCIL        = 7,
+    DATA_BLOOD_QUEEN_LANA_THEL       = 8,
+    DATA_VALITHRIA_DREAMWALKER_EVENT = 9,
+    DATA_SINDRAGOSA_EVENT            = 10,
+    DATA_LICH_KING_EVENT             = 11,
 
     // Additional data
-    DATA_SAURFANG_EVENT_NPC         = 12,
-    DATA_BONED_ACHIEVEMENT          = 13,
-    DATA_OOZE_DANCE_ACHIEVEMENT     = 14,
-    DATA_PUTRICIDE_TABLE            = 15,
-    DATA_NAUSEA_ACHIEVEMENT         = 16,
-    DATA_ORB_WHISPERER_ACHIEVEMENT  = 17,
-    DATA_PRINCE_KELESETH_GUID       = 18,
-    DATA_PRINCE_TALDARAM_GUID       = 19,
-    DATA_PRINCE_VALANAR_GUID        = 20,
-    DATA_BLOOD_PRINCES_CONTROL      = 21,
+    DATA_SAURFANG_EVENT_NPC          = 12,
+    DATA_BONED_ACHIEVEMENT           = 13,
+    DATA_OOZE_DANCE_ACHIEVEMENT      = 14,
+    DATA_PUTRICIDE_TABLE             = 15,
+    DATA_NAUSEA_ACHIEVEMENT          = 16,
+    DATA_ORB_WHISPERER_ACHIEVEMENT   = 17,
+    DATA_PRINCE_KELESETH_GUID        = 18,
+    DATA_PRINCE_TALDARAM_GUID        = 19,
+    DATA_PRINCE_VALANAR_GUID         = 20,
+    DATA_BLOOD_PRINCES_CONTROL       = 21,
+	DATA_SPAWN                       = 22,
+    DATA_LICH_KING                   = 23,
+    DATA_TIRION                      = 24,
+    DATA_ANGLE                       = 25,
+    DATA_BONED                       = 26,
+    DATA_ALL_YOU_CAN_EAT             = 27,
+    DATA_BEEN_WAITING                = 28,
+    DATA_NECK_DEEP                   = 29,
+    DATA_NECROTIC_STACK              = 30,
+	DATA_VALITHRIA_DREAMWALKER       = 31,
+	DATA_VALITHRIA_ALTERNATIVE       = 32,
+    DATA_VALITHRIA_COMBAT_TRIGGER    = 33,
+	DATA_SINDRAGOSA_NPC              = 34,
+	DATA_PORTAL_JOCKEY_ACHIEVEMENT   = 35,
+	
 };
 
-#define MAX_ENCOUNTER 12
+#define MAX_ENCOUNTER 13
 
 enum CreaturesIds
 {
@@ -150,6 +171,49 @@ enum CreaturesIds
 
     // Blood-Queen Lana'thel
     NPC_BLOOD_QUEEN_LANA_THEL                   = 37955,
+
+	// Valithria Dreamwalker
+	NPC_VALITHRIA_DREAMWALKER                   = 36789,
+	NPC_VALITHRIA_ALTERNATIVE                   = 37950,
+	NPC_COMBAT_TRIGGER                          = 38752,
+	NPC_CLOUD                                   = 37985,
+	NPC_PORTAL_NORMAL_MODE_PRE                  = 38186,
+    NPC_PORTAL_NORMAL_MODE_NPC                  = 37945,
+    NPC_PORTAL_HEROIC_MODE_PRE                  = 38429,
+    NPC_PORTAL_HEROIC_MODE_NPC                  = 38430,
+	NPC_PORTAL                                  = 37945,
+	NPC_NIGHMARE                                = 38421,
+    NPC_ABOMINATION                             = 37886,
+    NPC_SKELETON                                = 36791,
+    NPC_ARCHMAGE                                = 37868,
+    NPC_SUPPRESSER                              = 37863,
+    NPC_ZOMBIE                                  = 37934,
+	NPC_DREAM_CLOUD                             = 37985,
+    NPC_NIGHTMARE_CLOUD                         = 38421,
+    NPC_COLUMN_OF_FROST                         = 37918,
+	NPC_ROT_WORM                                = 37907,
+	NPC_MANA_VOID                               = 38068,
+
+	// Sindragosa
+	NPC_SINDRAGOSA                              = 36853,
+    NPC_ICE_TOMB                                = 36980,
+	NPC_SUPPRESSOR                              = 37863,
+
+	// Lich King
+	NPC_LICH_KING                               = 36597,
+    NPC_TIRION_ICC                              = 38995,
+    NPC_MENETHIL                                = 38579,
+    NPC_FROSTMOURNE_TRIGGER                     = 38584,
+    NPC_TERENAS_F                               = 36823, //for frostmourne
+    NPC_SPIRIT_WARDEN_F                         = 36824,
+    NPC_ICE_SPHERE                              = 36633,
+    NPC_DRUDGE_GHOUL                            = 37695,
+    NPC_SHAMBLING_HORROR                        = 37698,
+    NPC_VALKYR                                  = 36609,
+    NPC_DEFILE                                  = 38757,
+    NPC_RAGING_SPIRIT                           = 36701,
+    NPC_TRIGGER                                 = 38667,
+    NPC_VILE_SPIRIT                             = 37799,
 };
 
 enum GameObjectsIds
@@ -163,6 +227,10 @@ enum GameObjectsIds
     GO_ORATORY_OF_THE_DAMNED_ENTRANCE       = 201563,
     GO_LADY_DEATHWHISPER_ELEVATOR           = 202220,
 
+	// Gunship
+	THE_SKYBREAKER_HORDE_ICC                = 201811,
+    THE_SKYBREAKER_ALLIANCE_ICC             = 201580,
+
     // Deathbringer Saurfang
     GO_SAURFANG_S_DOOR                      = 201825,
     GO_DEATHBRINGER_S_CACHE_10N             = 202239,
@@ -170,6 +238,7 @@ enum GameObjectsIds
     GO_DEATHBRINGER_S_CACHE_10H             = 202238,
     GO_DEATHBRINGER_S_CACHE_25H             = 202241,
     GO_SCOURGE_TRANSPORTER_SAURFANG         = 202244,
+	CITADEL_TELEPORT                        = 202235,
 
     // Professor Putricide
     GO_ORANGE_PLAGUE_MONSTER_ENTRANCE       = 201371,
@@ -194,11 +263,25 @@ enum GameObjectsIds
     // Valithria Dreamwalker
     GO_GREEN_DRAGON_BOSS_ENTRANCE           = 201375,
     GO_GREEN_DRAGON_BOSS_EXIT               = 201374,
+    DREAMWALKER_CACHE_10_N                  = 201959,
+    DREAMWALKER_CACHE_25_N                  = 202338,
+    DREAMWALKER_CACHE_10_H                  = 202339,
+    DREAMWALKER_CACHE_25_H                  = 202340,
+    DRAGON_DOOR_1                           = 201375,
+    DRAGON_DOOR_2                           = 201374,
+    DRAGON_DOOR_3                           = 201379,
+    DREAMWALKER_DOOR_1                      = 201380,
+    DREAMWALKER_DOOR_2                      = 201381,
+    DREAMWALKER_DOOR_3                      = 201382,
+    DREAMWALKER_DOOR_4                      = 201383,
+	VALITHRIA_ELEVATOR                      = 202234,
 
     // Sindragosa
     GO_SINDRAGOSA_ENTRANCE_DOOR             = 201373,
     GO_SINDRAGOSA_SHORTCUT_ENTRANCE_DOOR    = 201369,
     GO_SINDRAGOSA_SHORTCUT_EXIT_DOOR        = 201379,
+    SINDRAGOSSA_DOOR_1                      = 201373,
+    SINDRAGOSSA_DOOR_2                      = 201369,
 };
 
 enum AchievementCriteriaIds
@@ -234,6 +317,18 @@ enum AchievementCriteriaIds
     CRITERIA_ONCE_BITTEN_TWICE_SHY_25N  = 13012,
     CRITERIA_ONCE_BITTEN_TWICE_SHY_10V  = 13011,
     CRITERIA_ONCE_BITTEN_TWICE_SHY_25V  = 13013,
+
+	// Sindragosa
+	ACHIEV_ALL_YOU_CAN_EAT_10           = 4580,
+    ACHIEV_ALL_YOU_CAN_EAT_25           = 4620,
+	ACHIEV_PORTAL_JOCKEY_10             = 4579,
+    ACHIEV_PORTAL_JOCKEY_25             = 4619,
+
+	// Lich King
+	ACHIEV_BEEN_WAITING_A_LONG_TIME_FOR_THIS_10 = 4601,
+    ACHIEV_BEEN_WAITING_A_LONG_TIME_FOR_THIS_25 = 4621,
+	ACHIEV_NECK_DEEP_IN_VILE_10                 = 4581,
+    ACHIEV_NECK_DEEP_IN_VILE_25                 = 4622,
 };
 
 enum SharedActions
@@ -249,5 +344,6 @@ enum SharedActions
     ACTION_ROTFACE_DEATH        = -366272,
     ACTION_CHANGE_PHASE         = -366780
 };
-
+void DespawnAllCreaturesAround(Creature *ref, uint32 entry);
+void UnsummonSpecificCreaturesNearby(Creature *ref, uint32 entry, float radius);
 #endif // DEF_ICECROWN_CITADEL_H
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel_teleport.cpp b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel_teleport.cpp
old mode 100755
new mode 100644
index 7875f3a..e3bdcdf
--- a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel_teleport.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel_teleport.cpp
@@ -37,13 +37,13 @@ class icecrown_citadel_teleport : public GameObjectScript
                     player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Oratory of the Damned.", GOSSIP_SENDER_ICC_PORT, ORATORY_OF_THE_DAMNED_TELEPORT);
                 if (instance->GetBossState(DATA_LADY_DEATHWHISPER) == DONE)
                     player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Rampart of Skulls.", GOSSIP_SENDER_ICC_PORT, RAMPART_OF_SKULLS_TELEPORT);
-                if (instance->GetBossState(DATA_GUNSHIP_EVENT) == DONE)
+                if (instance->GetBossState(DATA_GUNSHIP_BATTLE_EVENT) == DONE)
                     player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Deathbringer's Rise.", GOSSIP_SENDER_ICC_PORT, DEATHBRINGER_S_RISE_TELEPORT);
                 if (instance->GetBossState(DATA_DEATHBRINGER_SAURFANG) == DONE)
                     player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Upper Spire.", GOSSIP_SENDER_ICC_PORT, UPPER_SPIRE_TELEPORT);
-                if (instance->GetBossState(DATA_VALITHRIA_DREAMWALKER) == DONE)
+                if (instance->GetBossState(DATA_VALITHRIA_DREAMWALKER_EVENT) == DONE)
                     player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Sindragosa's Lair", GOSSIP_SENDER_ICC_PORT, SINDRAGOSA_S_LAIR_TELEPORT);
-                if (instance->GetBossState(DATA_PROFESSOR_PUTRICIDE) == DONE && instance->GetBossState(DATA_BLOOD_QUEEN_LANA_THEL) == DONE && instance->GetBossState(DATA_SINDRAGOSA) == DONE)
+                if (instance->GetBossState(DATA_PROFESSOR_PUTRICIDE) == DONE && instance->GetBossState(DATA_BLOOD_QUEEN_LANA_THEL) == DONE && instance->GetBossState(DATA_SINDRAGOSA_EVENT) == DONE)
                     player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to The Frozen Throne", GOSSIP_SENDER_ICC_PORT, FROZEN_THRONE_TELEPORT);
             }
 
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp b/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
old mode 100755
new mode 100644
index 758bb92..05fa883
--- a/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
@@ -22,6 +22,11 @@
 #include "Map.h"
 #include "icecrown_citadel.h"
 
+const Position SpawnLoc[]=
+{
+    {4671.521f, 2481.815f, 343.365f, 3.166f} //spawn pos
+};
+
 static const DoorData doorData[] =
 {
     {GO_LORD_MARROWGAR_S_ENTRANCE,           DATA_LORD_MARROWGAR,        DOOR_TYPE_ROOM,    BOUNDARY_N   },
@@ -36,11 +41,11 @@ static const DoorData doorData[] =
     {GO_BLOOD_ELF_COUNCIL_DOOR_RIGHT,        DATA_BLOOD_PRINCE_COUNCIL,  DOOR_TYPE_PASSAGE, BOUNDARY_E   },
     {GO_DOODAD_ICECROWN_BLOODPRINCE_DOOR_01, DATA_BLOOD_QUEEN_LANA_THEL, DOOR_TYPE_ROOM,    BOUNDARY_S   },
     {GO_DOODAD_ICECROWN_GRATE_01,            DATA_BLOOD_QUEEN_LANA_THEL, DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
-    {GO_GREEN_DRAGON_BOSS_ENTRANCE,          DATA_VALITHRIA_DREAMWALKER, DOOR_TYPE_ROOM,    BOUNDARY_N   },
-    {GO_GREEN_DRAGON_BOSS_EXIT,              DATA_VALITHRIA_DREAMWALKER, DOOR_TYPE_PASSAGE, BOUNDARY_S   },
-    {GO_SINDRAGOSA_ENTRANCE_DOOR,            DATA_SINDRAGOSA,            DOOR_TYPE_ROOM,    BOUNDARY_S   },
-    {GO_SINDRAGOSA_SHORTCUT_ENTRANCE_DOOR,   DATA_SINDRAGOSA,            DOOR_TYPE_ROOM,    BOUNDARY_E   },
-    {GO_SINDRAGOSA_SHORTCUT_EXIT_DOOR,       DATA_SINDRAGOSA,            DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_GREEN_DRAGON_BOSS_ENTRANCE,          DATA_VALITHRIA_DREAMWALKER_EVENT, DOOR_TYPE_ROOM,    BOUNDARY_N   },
+    {GO_GREEN_DRAGON_BOSS_EXIT,              DATA_VALITHRIA_DREAMWALKER_EVENT, DOOR_TYPE_PASSAGE, BOUNDARY_S   },
+    {SINDRAGOSSA_DOOR_2,                     DATA_SINDRAGOSA_EVENT,      DOOR_TYPE_ROOM,    BOUNDARY_S   },
+    {SINDRAGOSSA_DOOR_2,                     DATA_SINDRAGOSA_EVENT,      DOOR_TYPE_ROOM,    BOUNDARY_E   },
+    {GO_SINDRAGOSA_SHORTCUT_EXIT_DOOR,       DATA_SINDRAGOSA_EVENT,      DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
     {0,                                      0,                          DOOR_TYPE_ROOM,    BOUNDARY_NONE} // END
 };
 
@@ -55,6 +60,7 @@ class instance_icecrown_citadel : public InstanceMapScript
             {
                 SetBossNumber(MAX_ENCOUNTER);
                 LoadDoorData(doorData);
+				uiDifficulty = map->GetDifficulty();
                 teamInInstance = 0;
                 ladyDeathwisperElevator = 0;
                 deathbringerSaurfang = 0;
@@ -72,6 +78,21 @@ class instance_icecrown_citadel : public InstanceMapScript
                 memset(bloodCouncil, 0, 3*sizeof(uint64));
                 bloodCouncilController = 0;
                 bloodQueenLanaThel = 0;
+				uiValithriaDreamwalker  = 0;
+                uiValithriaAlternative = 0;
+                uiValithriaCombatTrigger= 0;
+				uiDragonDoor1           = 0;
+                uiDragonDoor2           = 0;
+                uiDragonDoor3           = 0;
+                uiRoostDoor1            = 0;
+                uiRoostDoor2            = 0;
+                uiRoostDoor3            = 0;
+                uiRoostDoor4            = 0;
+				uiCitadelTp             = 0;
+                uiValithriaTransporter  = 0;
+                uiSindragossaTransporter = 0;
+                uiSindragosaDoor1       = 0;
+                uiSindragosaDoor2       = 0;
                 isBonedEligible = true;
                 isOozeDanceEligible = true;
                 isNauseaEligible = true;
@@ -124,6 +145,22 @@ class instance_icecrown_citadel : public InstanceMapScript
                         if (teamInInstance == ALLIANCE)
                             creature->UpdateEntry(NPC_JEDEBIA, ALLIANCE);
                         break;
+                    case NPC_VALITHRIA_DREAMWALKER:
+                        uiValithriaDreamwalker = creature->GetGUID();
+                        break;
+                    case NPC_VALITHRIA_ALTERNATIVE:
+                        uiValithriaAlternative = creature->GetGUID();
+                        break;
+                    case NPC_COMBAT_TRIGGER:
+                    {
+                        uiValithriaCombatTrigger = creature->GetGUID();
+                        creature->SetReactState(REACT_AGGRESSIVE);
+                        creature->SetSpeed(MOVE_RUN, 0.0f, true);
+                        creature->SetSpeed(MOVE_WALK, 0.0f, true);
+                        creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_SELECTABLE);
+                        creature->SetVisible(false);
+                        break;
+                    }
                     case NPC_HARAGG_THE_UNSEEN:
                         if (teamInInstance == ALLIANCE)
                             creature->UpdateEntry(NPC_NIBY_THE_ALMIGHTY, ALLIANCE);
@@ -193,8 +230,8 @@ class instance_icecrown_citadel : public InstanceMapScript
                     case GO_DOODAD_ICECROWN_GRATE_01:
                     case GO_GREEN_DRAGON_BOSS_ENTRANCE:
                     case GO_GREEN_DRAGON_BOSS_EXIT:
-                    case GO_SINDRAGOSA_ENTRANCE_DOOR:
-                    case GO_SINDRAGOSA_SHORTCUT_ENTRANCE_DOOR:
+                    //case GO_SINDRAGOSA_ENTRANCE_DOOR:
+                    //case GO_SINDRAGOSA_SHORTCUT_ENTRANCE_DOOR:
                     case GO_SINDRAGOSA_SHORTCUT_EXIT_DOOR:
                         AddDoor(go, true);
                         break;
@@ -206,6 +243,9 @@ class instance_icecrown_citadel : public InstanceMapScript
                             go->SetGoState(GO_STATE_READY);
                         }
                         break;
+                    case VALITHRIA_ELEVATOR:
+                        uiValithriaTransporter = go->GetGUID();
+                        break;
                     case GO_SAURFANG_S_DOOR:
                         saurfangDoor = go->GetGUID();
                         break;
@@ -215,9 +255,33 @@ class instance_icecrown_citadel : public InstanceMapScript
                     case GO_DEATHBRINGER_S_CACHE_25H:
                         deathbringersCache = go->GetGUID();
                         break;
+					case DREAMWALKER_CACHE_10_N:
+                    case DREAMWALKER_CACHE_25_N:
+                    case DREAMWALKER_CACHE_10_H:
+                    case DREAMWALKER_CACHE_25_H:
+                        uiDreamwalkerCache = go->GetGUID();
+                        break;
                     case GO_SCOURGE_TRANSPORTER_SAURFANG:
                         saurfangTeleport = go->GetGUID();
                         break;
+                    case DREAMWALKER_DOOR_1:
+                        uiRoostDoor1 = go->GetGUID();
+                        break;
+                    case DREAMWALKER_DOOR_2:
+                        uiRoostDoor2 = go->GetGUID();
+                        break;
+                    case DREAMWALKER_DOOR_3:
+                        uiRoostDoor3 = go->GetGUID();
+                        break;
+                    case DREAMWALKER_DOOR_4:
+                        uiRoostDoor4 = go->GetGUID();
+                        break;
+                    case SINDRAGOSSA_DOOR_1:
+                        uiSindragosaDoor1 = go->GetGUID();
+                        break;
+                    case SINDRAGOSSA_DOOR_2:
+                        uiSindragosaDoor2 = go->GetGUID();
+                        break;
                     case GO_SCIENTIST_AIRLOCK_DOOR_COLLISION:
                         putricideCollision = go->GetGUID();
                         if (GetBossState(DATA_FESTERGUT) == DONE && GetBossState(DATA_ROTFACE) == DONE)
@@ -247,6 +311,11 @@ class instance_icecrown_citadel : public InstanceMapScript
                         if (GetBossState(DATA_ROTFACE) == DONE)
                             HandleGameObject(putricidePipes[1], true, go);
                         break;
+                    case CITADEL_TELEPORT:
+                        uiCitadelTp = go->GetGUID();
+                        if (GetBossState(DATA_DEATHBRINGER_SAURFANG) == DONE)
+                            HandleGameObject(uiCitadelTp, true, go);
+                        break;
                     case GO_DRINK_ME:
                         putricideTable = go->GetGUID();
                         break;
@@ -313,6 +382,12 @@ class instance_icecrown_citadel : public InstanceMapScript
                         return bloodCouncilController;
                     case DATA_BLOOD_QUEEN_LANA_THEL:
                         return bloodQueenLanaThel;
+					case DATA_VALITHRIA_DREAMWALKER:
+						return uiValithriaDreamwalker;
+                    case DATA_VALITHRIA_ALTERNATIVE:
+						return uiValithriaAlternative;
+                    case DATA_VALITHRIA_COMBAT_TRIGGER:
+						return uiValithriaCombatTrigger;
                     default:
                         break;
                 }
@@ -328,7 +403,7 @@ class instance_icecrown_citadel : public InstanceMapScript
                 switch (type)
                 {
                     case DATA_LADY_DEATHWHISPER:
-                        SetBossState(DATA_GUNSHIP_EVENT, state);    // TEMP HACK UNTIL GUNSHIP SCRIPTED
+                        SetBossState(DATA_GUNSHIP_BATTLE_EVENT, state);    // TEMP HACK UNTIL GUNSHIP SCRIPTED
                         if (state == DONE)
                             if (GameObject* elevator = instance->GetGameObject(ladyDeathwisperElevator))
                             {
@@ -336,11 +411,26 @@ class instance_icecrown_citadel : public InstanceMapScript
                                 elevator->SetGoState(GO_STATE_READY);
                             }
                         break;
+                    case DATA_GUNSHIP_BATTLE_EVENT:
+                        switch(state)
+                        {
+                            case DONE:
+                                break;
+                            case NOT_STARTED:
+                                break;
+                        }
+                        break;
                     case DATA_DEATHBRINGER_SAURFANG:
                         switch (state)
                         {
                             case DONE:
                                 DoRespawnGameObject(deathbringersCache, 7*DAY);
+								HandleGameObject(saurfangDoor, true);
+                            if (GameObject* CitadelTp = instance->GetGameObject(uiCitadelTp))
+                            {
+                                CitadelTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                CitadelTp->SetGoState(GOState(0));
+                            }
                             case NOT_STARTED:
                                 if (GameObject* teleporter = instance->GetGameObject(saurfangTeleport))
                                 {
@@ -384,9 +474,66 @@ class instance_icecrown_citadel : public InstanceMapScript
                             HandleGameObject(putricidePipes[1], true);
                         }
                         break;
-                    case DATA_VALITHRIA_DREAMWALKER:
-                    case DATA_SINDRAGOSA:
-                    case DATA_THE_LICH_KING:
+					case DATA_VALITHRIA_DREAMWALKER_EVENT:
+                        if(state == DONE)
+                        {
+                            if (GameObject* pChest = instance->GetGameObject(uiDreamwalkerCache))
+                                pChest->SetRespawnTime(pChest->GetRespawnDelay());
+
+                            if (GameObject* SindragossaTp = instance->GetGameObject(uiSindragossaTp))
+                            {
+                                SindragossaTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                SindragossaTp->SetGoState(GOState(0));
+                            }
+                            if (GameObject* go = instance->GetGameObject(uiValithriaTransporter))
+                            {
+                                go->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
+                                go->SetGoState(GO_STATE_READY);
+                            }
+                            if (GameObject* go = instance->GetGameObject(uiSindragossaTransporter))
+                            {
+                                go->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
+                                go->SetGoState(GO_STATE_READY);
+                            }
+                            HandleGameObject(uiDragonDoor1, true);
+                            HandleGameObject(uiDragonDoor2, true);
+                            HandleGameObject(uiDragonDoor3, true);
+                        }
+                        if(state == NOT_STARTED || state == FAIL)
+                        {
+                            if (GameObject* SindragossaTp = instance->GetGameObject(uiSindragossaTp))
+                                SindragossaTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                            HandleGameObject(uiDragonDoor1, true);
+                            HandleGameObject(uiRoostDoor3, false);
+                            HandleGameObject(uiRoostDoor2, false);
+                            HandleGameObject(uiRoostDoor1, false);
+                            HandleGameObject(uiRoostDoor4, false);
+                        }
+                        if(state == IN_PROGRESS)
+                        {
+                            HandleGameObject(uiDragonDoor1, false);
+                            HandleGameObject(uiRoostDoor3, true);
+                            HandleGameObject(uiRoostDoor2, true);
+                            if (uiDifficulty == RAID_DIFFICULTY_25MAN_NORMAL || uiDifficulty == RAID_DIFFICULTY_25MAN_HEROIC)
+                            {
+                                HandleGameObject(uiRoostDoor1, true);
+                                HandleGameObject(uiRoostDoor4, true);
+                            }
+                        }
+                        //uiEncounter[9] = data;
+                        break;
+                    case DATA_SINDRAGOSA_EVENT:
+                        if(state == DONE)
+                        {
+                            HandleGameObject(uiSindragosaDoor1, true);
+                            HandleGameObject(uiSindragosaDoor2, true);
+                        }
+                        break;
+                    case DATA_LICH_KING_EVENT:
+                        break;
+                    case DATA_SPAWN:
+                        if(state >= 2)
+                            Creature* sindragosa = instance->SummonCreature(NPC_SINDRAGOSA, SpawnLoc[0]);
                         break;
                     default:
                         break;
@@ -395,16 +542,6 @@ class instance_icecrown_citadel : public InstanceMapScript
                  return true;
             }
 
-            uint32 GetCompletedEncounterMask() const
-            {
-                uint32 mask = 0;
-                for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
-                    if (GetBossState(i) == DONE)
-                        mask |= 1 << i;
-
-                return mask;
-            }
-
             void SetData(uint32 type, uint32 data)
             {
                 switch (type)
@@ -473,7 +610,7 @@ class instance_icecrown_citadel : public InstanceMapScript
 
                 switch (bossId)
                 {
-                    case DATA_THE_LICH_KING:
+                    case DATA_LICH_KING_EVENT:
                         if (!CheckPlagueworks(bossId))
                             return false;
                         if (!CheckCrimsonHalls(bossId))
@@ -481,11 +618,8 @@ class instance_icecrown_citadel : public InstanceMapScript
                         if (!CheckFrostwingHalls(bossId))
                             return false;
                         break;
-                    case DATA_SINDRAGOSA:
-                    case DATA_VALITHRIA_DREAMWALKER:
-                        if (!CheckFrostwingHalls(bossId))
-                            return false;
-                        break;
+                    case DATA_SINDRAGOSA_EVENT:
+                    case DATA_VALITHRIA_DREAMWALKER_EVENT:
                     case DATA_BLOOD_QUEEN_LANA_THEL:
                     case DATA_BLOOD_PRINCE_COUNCIL:
                         if (!CheckCrimsonHalls(bossId))
@@ -511,7 +645,7 @@ class instance_icecrown_citadel : public InstanceMapScript
             {
                 switch (bossId)
                 {
-                    case DATA_THE_LICH_KING:
+                    case DATA_LICH_KING_EVENT:
                         if (GetBossState(DATA_PROFESSOR_PUTRICIDE) != DONE)
                             return false;
                         // no break
@@ -530,7 +664,7 @@ class instance_icecrown_citadel : public InstanceMapScript
             {
                 switch (bossId)
                 {
-                    case DATA_THE_LICH_KING:
+                    case DATA_LICH_KING_EVENT:
                         if (GetBossState(DATA_BLOOD_QUEEN_LANA_THEL) != DONE)
                             return false;
                         // no break
@@ -549,12 +683,12 @@ class instance_icecrown_citadel : public InstanceMapScript
             {
                 switch (bossId)
                 {
-                    case DATA_THE_LICH_KING:
-                        if (GetBossState(DATA_SINDRAGOSA) != DONE)
+                    case DATA_LICH_KING_EVENT:
+                        if (GetBossState(DATA_SINDRAGOSA_EVENT) != DONE)
                             return false;
                         // no break
-                    case DATA_SINDRAGOSA:
-                        if (GetBossState(DATA_VALITHRIA_DREAMWALKER) != DONE)
+                    case DATA_SINDRAGOSA_EVENT:
+                        if (GetBossState(DATA_BLOOD_PRINCE_COUNCIL) != DONE)
                             return false;
                         break;
                     default:
@@ -568,11 +702,11 @@ class instance_icecrown_citadel : public InstanceMapScript
             {
                 switch (bossId)
                 {
-                    case DATA_THE_LICH_KING:
-                    case DATA_SINDRAGOSA:
+                    case DATA_LICH_KING_EVENT:
+                    case DATA_SINDRAGOSA_EVENT:
                     case DATA_BLOOD_QUEEN_LANA_THEL:
                     case DATA_PROFESSOR_PUTRICIDE:
-                    case DATA_VALITHRIA_DREAMWALKER:
+                    case DATA_VALITHRIA_DREAMWALKER_EVENT:
                     case DATA_BLOOD_PRINCE_COUNCIL:
                     case DATA_ROTFACE:
                     case DATA_FESTERGUT:
@@ -580,10 +714,10 @@ class instance_icecrown_citadel : public InstanceMapScript
                             return false;
                         // no break
                     case DATA_DEATHBRINGER_SAURFANG:
-                        if (GetBossState(DATA_GUNSHIP_EVENT) != DONE)
+                        if (GetBossState(DATA_GUNSHIP_BATTLE_EVENT) != DONE)
                             return false;
                         // no break
-                    case DATA_GUNSHIP_EVENT:
+                    case DATA_GUNSHIP_BATTLE_EVENT:
                         if (GetBossState(DATA_LADY_DEATHWHISPER) != DONE)
                             return false;
                         // no break
@@ -657,6 +791,24 @@ class instance_icecrown_citadel : public InstanceMapScript
             uint64 bloodCouncil[3];
             uint64 bloodCouncilController;
             uint64 bloodQueenLanaThel;
+			uint64 uiDreamwalkerCache;
+			uint64 uiValithriaDreamwalker;
+            uint64 uiValithriaAlternative;
+            uint64 uiValithriaCombatTrigger;
+			uint64 uiDragonDoor1;
+            uint64 uiDragonDoor2;
+            uint64 uiDragonDoor3;
+            uint64 uiRoostDoor1;
+            uint64 uiRoostDoor2;
+            uint64 uiRoostDoor3;
+            uint64 uiRoostDoor4;
+            uint8 uiDifficulty;
+			uint64 uiCitadelTp;
+			uint64 uiSindragossaTp;
+			uint64 uiSindragossaTransporter;
+			uint64 uiSindragosaDoor1;
+			uint64 uiSindragosaDoor2;
+			uint64 uiValithriaTransporter;
             uint32 teamInInstance;
             bool isBonedEligible;
             bool isOozeDanceEligible;
@@ -670,6 +822,26 @@ class instance_icecrown_citadel : public InstanceMapScript
         }
 };
 
+void DespawnAllCreaturesAround(Creature *ref, uint32 entry)
+{
+    while (Unit *unit = ref->FindNearestCreature(entry, 80.0f, true))
+        if (Creature *creature = unit->ToCreature())
+            creature->DespawnOrUnsummon();
+}
+void UnsummonSpecificCreaturesNearby(Creature *ref, uint32 entry, float radius)
+{
+    std::list<Creature*> allCreaturesWithEntry;
+    GetCreatureListWithEntryInGrid(allCreaturesWithEntry, ref, entry, radius);
+    for(std::list<Creature*>::iterator itr = allCreaturesWithEntry.begin(); itr != allCreaturesWithEntry.end(); ++itr)
+    {
+        Creature *candidate = *itr;
+
+        if (!candidate)
+            continue;
+        if (TempSummon* summon = candidate->ToTempSummon())
+            summon->DespawnOrUnsummon();
+    }
+}
 void AddSC_instance_icecrown_citadel()
 {
     new instance_icecrown_citadel();
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp b/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
new file mode 100644
index 0000000..73d9c96
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
@@ -0,0 +1,365 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eScriptTexts
+{
+    SAY_AGGRO           = -1752001,
+    SAY_SLAY1           = -1752002,
+    SAY_SLAY2           = -1752003,
+    SAY_DEATH           = -1752004,
+    SAY_SUMMON_CLONE    = -1752005,
+
+    SAY_XERESTRASZA_1  = -1752008,
+    SAY_XERESTRASZA_2  = -1752009,
+    SAY_XERESTRASZA_3  = -1752010,
+    SAY_XERESTRASZA_4  = -1752011,
+    SAY_XERESTRASZA_5  = -1752012,
+    SAY_XERESTRASZA_6  = -1752013,
+    SAY_XERESTRASZA_7  = -1752014,
+    SAY_XERESTRASZA_8  = -1752015,
+    SAY_XERESTRASZA_9  = -1752016
+};
+
+enum eSpells
+{
+    SPELL_CLEAVE            = 40504,
+    SPELL_REPELLING_WAVE    = 74509,
+    SPELL_ENERVATING_BRAND  = 74502,
+    SPELL_BLADE_TEMPEST     = 75125,
+    SPELL_SUMMON_CLONE      = 74511
+};
+
+enum eEvents
+{
+    EVENT_CAST_CLEAVE           = 1,
+    EVENT_CAST_REPELLING_WAVE   = 2,
+    EVENT_CAST_ENERVATING_BRAND = 3,
+    EVENT_CAST_BLADE_TEMPEST    = 4,
+    EVENT_CAST_SUMMON_CLONE     = 5,
+    
+    ACTION_START_EVENT          = 6,
+    EVENT_XERESTRASZA_3         = 7,
+    EVENT_XERESTRASZA_4         = 8,
+    EVENT_XERESTRASZA_5         = 9,
+    EVENT_XERESTRASZA_6         = 10,
+    EVENT_XERESTRASZA_7         = 11,
+    EVENT_XERESTRASZA_8         = 12,
+    EVENT_XERESTRASZA_9         = 13,
+
+    EVENT_START_PHASE_TWO       = 14
+};
+
+enum ePhases
+{
+    PHASE_ALL = 0,
+    PHASE_1   = 1,
+    PHASE_2   = 2,
+
+    PHASE_1_MASK  = 1 << PHASE_1,
+    PHASE_2_MASK  = 1 << PHASE_2
+};
+
+Creature* pXerestrasza;
+
+class boss_baltharus : public CreatureScript
+{
+    public:
+        boss_baltharus() : CreatureScript("boss_baltharus") { }
+
+        struct boss_baltharusAI : public BossAI
+        {
+            boss_baltharusAI(Creature* pCreature) : BossAI(pCreature, DATA_BALTHARUS)
+            {
+                ASSERT(instance);
+            }
+
+            void Reset()
+            {
+                instance->SetBossState(DATA_BALTHARUS, NOT_STARTED);
+                events.Reset();
+                events.SetPhase(PHASE_1);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(7000,7500));
+            }
+
+            void EnterCombat(Unit*)
+            {
+                instance->SetBossState(DATA_BALTHARUS, IN_PROGRESS);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void JustSummoned(Creature *summon)
+            {
+                summons.Summon(summon);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustReachedHome()
+            {
+                summons.DespawnAll();
+                instance->SetData(DATA_BALTHARUS, FAIL);
+            }
+
+            void JustDied(Unit*)
+            {
+                DoScriptText(SAY_DEATH, me);
+                instance->SetData(DATA_BALTHARUS, DONE);
+                if (GameObject* flame = GetClosestGameObjectWithEntry(me, GO_FIRE_FIELD, 200.0f))
+                    flame->RemoveFromWorld();
+
+                if (instance->GetBossState(DATA_RAGEFIRE)==DONE)
+                {
+                   if (GameObject* flame = GetClosestGameObjectWithEntry(me, GO_FLAME_WALLS, 200.0f))
+                       flame->RemoveFromWorld();
+                }
+                pXerestrasza->AI()->DoAction(ACTION_START_EVENT);
+                _JustDied();
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_CLEAVE:
+                            DoCastVictim(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                            break;
+                        case EVENT_START_PHASE_TWO:
+                            DoScriptText(SAY_SUMMON_CLONE, me);
+                            DoCast(SPELL_SUMMON_CLONE);
+                            DoCastAOE(SPELL_REPELLING_WAVE,true);
+                            break;
+                        case EVENT_CAST_ENERVATING_BRAND:
+                            DoCastVictim(SPELL_ENERVATING_BRAND, true);
+                            events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                            break;
+                        case EVENT_CAST_BLADE_TEMPEST:
+                            DoCastAOE(SPELL_BLADE_TEMPEST);
+                            events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(30000,35000));
+                            break;
+                    }
+                }
+
+                if (!(events.GetPhaseMask() & PHASE_2_MASK))
+                {
+                    if (me->GetHealth() <= ((me->GetMaxHealth() / 100) * 50))
+                    {
+                        events.SetPhase(PHASE_2);
+                        events.ScheduleEvent(EVENT_START_PHASE_TWO, 1000,0,PHASE_2);
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new boss_baltharusAI(pCreature);
+        }
+
+};
+
+class boss_baltharus_summon : public CreatureScript
+{
+    public:
+        boss_baltharus_summon() : CreatureScript("boss_baltharus_summon") { }
+
+        struct boss_baltharus_summonAI : public ScriptedAI
+        {
+            boss_baltharus_summonAI(Creature* pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(20000,25000));
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_CLEAVE:
+                            DoCastVictim(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+                            break;
+                        case EVENT_CAST_ENERVATING_BRAND:
+                            DoCastVictim(SPELL_ENERVATING_BRAND);
+                            events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+                            break;
+                        case EVENT_CAST_BLADE_TEMPEST:
+                            DoCast(SPELL_BLADE_TEMPEST);
+                            events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(30000,45000));
+                            break;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new boss_baltharus_summonAI(pCreature);
+        }
+
+};
+
+class npc_xerestrasza : public CreatureScript
+{
+    public:
+        npc_xerestrasza() : CreatureScript("npc_xerestrasza") { }
+
+        struct npc_xerestraszaAI : public ScriptedAI
+        {
+            npc_xerestraszaAI(Creature *pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = me->GetInstanceScript();
+                pXerestrasza = me;
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                bIntro = false;
+                pInstance->SetData(DATA_XERESTRASZA,NOT_STARTED);
+            }
+
+            void MoveInLineOfSight(Unit*)
+            {
+                if (!bIntro)
+                {
+                    DoScriptText(SAY_XERESTRASZA_1, me);
+                    pInstance->SetData(DATA_XERESTRASZA,NOT_STARTED);
+                    bIntro = true;
+                }
+            }
+
+            void DoAction(const int32 action)
+            {
+                if (action == ACTION_START_EVENT)
+                {
+                    me->GetMotionMaster()->MovePoint(1, 3153.5490f, 385.53f, 86.33f);
+                    pInstance->SetData(DATA_XERESTRASZA,IN_PROGRESS);
+                    DoScriptText(SAY_XERESTRASZA_2, me);
+                    events.ScheduleEvent(EVENT_XERESTRASZA_3,9000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_4,20000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_5,31000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_6,42000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_7,53000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_8,64000); 
+                    events.ScheduleEvent(EVENT_XERESTRASZA_9,75000); 
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_XERESTRASZA_3:
+                            DoScriptText(SAY_XERESTRASZA_3, me);
+                            break;
+                        case EVENT_XERESTRASZA_4:
+                            DoScriptText(SAY_XERESTRASZA_4, me);
+                            break;
+                        case EVENT_XERESTRASZA_5:
+                            DoScriptText(SAY_XERESTRASZA_5, me);
+                            break;
+                        case EVENT_XERESTRASZA_6:
+                            DoScriptText(SAY_XERESTRASZA_6, me);
+                            break;
+                        case EVENT_XERESTRASZA_7:
+                            DoScriptText(SAY_XERESTRASZA_7, me);
+                            break;
+                        case EVENT_XERESTRASZA_8:
+                            DoScriptText(SAY_XERESTRASZA_8, me);
+                            break;
+                        case EVENT_XERESTRASZA_9:
+                            DoScriptText(SAY_XERESTRASZA_9, me);
+                            pInstance->SetData(DATA_XERESTRASZA,DONE);
+                            break;
+                    }
+                }
+            }
+
+        private:
+            bool bIntro;
+            EventMap events;
+            InstanceScript* pInstance;
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_xerestraszaAI(pCreature);
+        }
+};
+
+
+void AddSC_boss_baltharus()
+{
+    new boss_baltharus();
+    new boss_baltharus_summon();
+    new npc_xerestrasza();
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp b/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
new file mode 100644
index 0000000..d0d73b3
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
@@ -0,0 +1,807 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eTexts
+{
+    SAY_SPAWN       = -1752027,
+    SAY_AGGRO       = -1752028,
+    SAY_SLAY1       = -1752029,
+    SAY_SLAY2       = -1752030,
+    SAY_DEATH       = -1752031,
+    SAY_BERSERK     = -1752032,
+    SAY_SPECIAL1    = -1752033,
+    SAY_SPECIAL2    = -1752034,
+    SAY_PHASE2      = -1752035,
+    SAY_PHASE3      = -1752036
+};
+
+enum eSpells
+{
+    SPELL_FIRE_PILLAR               = 76006,
+    SPELL_FIERY_EXPLOSION           = 76010,
+    // All
+    SPELL_TWILIGHT_PRECISION        = 78243,
+    SPELL_CLEAVE                    = 74524,
+    SPELL_TAIL_LASH                 = 74531,
+    SPELL_BERSEK                    = 26662,
+    SPELL_TWILIGHT_DIVISION         = 75063,
+    SPELL_SUMMON_TWILIGHT_PORTAL    = 74809,
+
+    SPELL_METEOR_TARGET             = 74641,
+    SPELL_METEOR_STRIKE             = 74637,
+    SPELL_METEOR_DAMAGE             = 74648,
+    SPELL_METEOR_FLAME              = 74713,
+
+    // Halion
+    SPELL_FLAME_BREATH_10_NORMAL    = 74525,
+    SPELL_FLAME_BREATH_25_NORMAL    = 74526,
+    SPELL_FLAME_BREATH_10_HEROIC    = 74527,
+    SPELL_FLAME_BREATH_25_HEROIC    = 74528,
+    SPELL_FIERY_COMBUSTION          = 74562,
+
+    // Twilight Halion
+    SPELL_DUSK_SHROUD               = 75476,
+    SPELL_SOUL_CONSUMPTION          = 74792,
+    SPELL_DARK_BREATH_10_NORMAL     = 74806,
+    SPELL_DARK_BREATH_25_NORMAL     = 75954,
+    SPELL_DARK_BREATH_10_HEROIC     = 75955,
+    SPELL_DARK_BREATH_25_HEROIC     = 75956,
+
+    SPELL_AURE_TWILIGHT             = 74807
+};
+
+struct SpellsCorporeality
+{
+    uint32 SpellId1;
+    uint32 SpellId2;
+};
+
+static const SpellsCorporeality sCorporeality[11] =
+{
+    {74827, 74832},
+    {74828, 74833},
+    {74829, 74834},
+    {74830, 74835},
+    {74831, 74836},
+    {74832, 74827},
+    {74833, 74828},
+    {74834, 74829},
+    {74835, 74830},
+    {74836, 74831},
+    {74826, 74826}
+};
+
+enum eEvents
+{
+    EVENT_CAST_TWILIGHT_PRECISION   = 1,
+    EVENT_CAST_CLEAVE               = 2,
+    EVENT_CAST_FIERY_COMBUSTION     = 3,
+    EVENT_CAST_TAIL_LASH            = 4,
+    EVENT_CAST_FLAME_BREATH         = 5,
+    EVENT_CAST_DARK_BREATH          = 6,
+    EVENT_CAST_SOUL_CONSUMPTION     = 7,
+    EVENT_CAST_DUSK_SHROUD          = 8,
+    EVENT_FLAME_WALL                = 9,
+    EVENT_CAST_BERSEK               = 10,
+    EVENT_DPS                       = 11,
+    EVENT_METEOR_STRIKE             = 12,
+    EVENT_METEOR_DAMAGE             = 13,
+    EVENT_METEOR_FLAME              = 14,
+    EVENT_FIRE_PILLAR               = 15
+};
+
+enum ePhases
+{
+    PHASE_ALL = 0,
+    PHASE_1   = 1,
+    PHASE_2   = 2,
+    PHASE_3   = 3,
+
+    PHASE_1_MASK  = 1 << PHASE_1,
+    PHASE_2_MASK  = 1 << PHASE_2,
+    PHASE_3_MASK  = 1 << PHASE_3
+};
+
+Creature* pHalion;
+Creature* pTwilight;
+uint32 HalionDamage, TwilightDamage;
+uint32 HalionAura, TwilightAura;
+
+class boss_halion : public CreatureScript
+{
+    public:
+        boss_halion() : CreatureScript("boss_halion") { }
+
+        struct boss_halionAI : public BossAI
+        {
+            boss_halionAI(Creature *pCreature) : BossAI(pCreature, DATA_HALION)
+                {
+                    ASSERT(instance);
+                    pHalion = me;
+                }
+
+            void Reset()
+            {
+                if (instance->GetData(DATA_TWILIGHT_HALION)==IN_PROGRESS || instance->GetBossState(DATA_HALION)==IN_PROGRESS)
+                    return;
+
+              /*  if (instance->GetBossState(DATA_ZARITHRIAN)!=DONE || instance->GetBossState(DATA_RAGEFIRE)!=DONE || instance->GetBossState(DATA_BALTHARUS)!=DONE)
+                {
+                    me->SetVisible(false);
+                    me->SetReactState(REACT_PASSIVE);
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                }
+                else 
+				{
+                    me->SetVisible(true);
+                    me->SetReactState(REACT_AGGRESSIVE);
+                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+				}*/
+
+                instance->SetBossState(DATA_HALION, NOT_STARTED);
+                events.Reset();
+                events.SetPhase(PHASE_1);
+                events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 1000);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(20000,25000));
+                events.ScheduleEvent(EVENT_CAST_FIERY_COMBUSTION, 15000);
+                events.ScheduleEvent(EVENT_METEOR_STRIKE, 20000);
+                events.ScheduleEvent(SPELL_BERSEK, 9999999);
+                PercentDamage = 0;
+                HalionDamage = 0;
+                HalionAura = 0;
+                RemoveAllGO();
+            }
+
+            void RemoveAllGO()
+            {
+                if (GameObject* flame1 = GetClosestGameObjectWithEntry(me, GO_FLAME_WALLS2, 100.0f))
+                    flame1->RemoveFromWorld();
+
+                if (GameObject* flame2 = GetClosestGameObjectWithEntry(me, GO_FLAME_WALLS3, 100.0f))
+                    flame2->RemoveFromWorld();
+
+                if (GameObject* portal1 = GetClosestGameObjectWithEntry(me, GO_TWILIGHT_PORTAL1, 100.0f))
+                    portal1->RemoveFromWorld();
+
+                if (GameObject* portal2 = GetClosestGameObjectWithEntry(me, GO_TWILIGHT_PORTAL2, 100.0f))
+                    portal2->RemoveFromWorld();
+            }
+
+            void MeteorStrike()
+            {
+                float x,y,z;
+                Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0);
+                if (pTarget)
+                {
+                    pTarget->GetPosition(x,y,z);
+                    me->SummonCreature(NPC_METEOR_STRIKE, x, y, z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 999999);
+                }
+            }
+
+            void EnterCombat(Unit*)
+            {
+                instance->SetBossState(DATA_HALION, IN_PROGRESS);
+                
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    return;
+                }
+                
+                events.ScheduleEvent(EVENT_FLAME_WALL, 3000,0,PHASE_1);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void CastCorporeality()
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                uint32 TotalDamage = HalionDamage+TwilightDamage;
+                if (TotalDamage > 0)
+                {
+                    PercentDamage = HalionDamage * 100 / TotalDamage;
+                }
+                else
+                {
+                    PercentDamage = 50;
+                }
+                HalionDamage = 0;
+                TwilightDamage = 0;
+                if (TwilightAura!=0)
+                {
+                    pTwilight->RemoveAurasDueToSpell(TwilightAura);
+                }
+                if (HalionAura!=0)
+                {
+                    pHalion->RemoveAurasDueToSpell(HalionAura);
+                }
+
+                uint8 idAura;
+                if (PercentDamage < 5)
+                {
+                    idAura = 9;
+                }
+                else if (PercentDamage < 15)
+                {
+                    idAura = 8;
+                }
+                else if (PercentDamage < 25)
+                {
+                    idAura = 7;
+                }
+                else if (PercentDamage < 35)
+                {
+                    idAura = 6;
+                }
+                else if (PercentDamage < 45)
+                {
+                    idAura = 5;
+                }
+                else if (PercentDamage < 55)
+                {
+                    idAura = 10;
+                }
+                else if (PercentDamage < 65)
+                {
+                    idAura = 0;
+                }
+                else if (PercentDamage < 75)
+                {
+                    idAura = 1;
+                }
+                else if (PercentDamage < 85)
+                {
+                    idAura = 2;
+                }
+                else if (PercentDamage < 95)
+                {
+                    idAura = 3;
+                }
+                else
+                {
+                    idAura = 4;
+                }
+                pHalion->CastSpell(pHalion, sCorporeality[idAura].SpellId1, true);
+                pTwilight->CastSpell(pTwilight, sCorporeality[idAura].SpellId2, true);
+                HalionAura=sCorporeality[idAura].SpellId1;
+                TwilightAura=sCorporeality[idAura].SpellId2;
+            }
+
+            void SetPhase3()
+            {
+                events.SetPhase(PHASE_3);
+                if (GameObject* portal = me->SummonGameObject(GO_TWILIGHT_PORTAL2, 3154.56f, 535.418f, 72.8889f, 4.47206f, 0, 0, 0.786772f, -0.617243f, 99999999))
+                {
+                    portal->SetPhaseMask(32,true);
+                    portal->SetRespawnTime(9999999);
+                }
+                events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                pHalion->SetHealth(pTwilight->GetHealth());
+            }
+
+            void DamageTaken(Unit* /*who*/, uint32 &dmg)
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                HalionDamage += dmg;    
+                
+                instance->SetData(DATA_DAMAGE, me->GetHealth() >= dmg ? me->GetHealth() - dmg : 0);
+            }
+
+            void JustSummoned(Creature *summon)
+            {
+                if (summon->GetEntry()==NPC_TWILIGHT_HALION)
+                {
+                    summon->SetPhaseMask(32,true);
+                    summons.Summon(summon);
+                }
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustReachedHome()
+            {
+                    instance->SetBossState(DATA_HALION,FAIL);
+                    RemoveAllGO();
+            }
+
+            void JustDied(Unit*)
+            {
+                _JustDied();
+                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+                RemoveAllGO();
+                DoScriptText(SAY_DEATH, me);
+                switch(instance->instance->GetDifficulty())
+                {
+                    case RAID_DIFFICULTY_10MAN_NORMAL:
+                        instance->DoCompleteAchievement(TWILIGHT_DESTROYER_NORMAL_10);
+                    case RAID_DIFFICULTY_10MAN_HEROIC:
+                        instance->DoCompleteAchievement(TWILIGHT_DESTROYER_HEROIC_10);
+                    case RAID_DIFFICULTY_25MAN_NORMAL:
+                        instance->DoCompleteAchievement(TWILIGHT_DESTROYER_NORMAL_25);
+                    case RAID_DIFFICULTY_25MAN_HEROIC:
+                        instance->DoCompleteAchievement(TWILIGHT_DESTROYER_HEROIC_25);
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    if (instance->GetData(DATA_DAMAGE) > 0)
+                        me->SetHealth(instance->GetData(DATA_DAMAGE));
+                    else
+                        if (instance->GetData(DATA_TWILIGHT_HALION)==IN_PROGRESS)
+                            me->SetHealth(1);
+                }
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                if ((events.GetPhaseMask() & PHASE_1_MASK) || (events.GetPhaseMask() & PHASE_3_MASK))
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_TWILIGHT_PRECISION:
+                                DoCast(me, SPELL_TWILIGHT_PRECISION); // not working
+                                me->AddAura(SPELL_TWILIGHT_PRECISION, me); //test
+                                break;
+                            case EVENT_FLAME_WALL:
+                                if (GameObject* go_flame1 = me->SummonGameObject(GO_FLAME_WALLS2, 3154.56f, 535.418f, 72.8889f, 4.47206f, 0, 0, 0.786772f, -0.617243f, 999999))
+                                {
+                                    go_flame1->SetPhaseMask(1,true);
+                                }
+                                if (GameObject* go_flame2 = me->SummonGameObject(GO_FLAME_WALLS3, 3154.56f, 535.418f, 72.8889f, 4.47206f, 0, 0, 0.786772f, -0.617243f, 999999))
+                                {
+                                    go_flame2->SetPhaseMask(32,true);
+                                }
+                                break;
+                            case EVENT_CAST_TAIL_LASH:
+                                DoCast(SPELL_TAIL_LASH);
+                                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                                break;
+                            case EVENT_CAST_CLEAVE:
+                                DoCast(SPELL_CLEAVE);
+                                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                                break;
+                            case EVENT_METEOR_STRIKE:
+                                MeteorStrike();
+                                events.ScheduleEvent(EVENT_METEOR_STRIKE, 20000);
+                                break;
+                            case EVENT_CAST_FLAME_BREATH:
+                                DoCast(RAID_MODE(SPELL_FLAME_BREATH_10_NORMAL, SPELL_FLAME_BREATH_25_NORMAL, SPELL_FLAME_BREATH_10_HEROIC, SPELL_FLAME_BREATH_25_HEROIC));
+                                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(20000,25000));break;
+                            case EVENT_DPS:
+                                CastCorporeality();
+                                events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                                break;
+                            case EVENT_CAST_FIERY_COMBUSTION:
+                                Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0);
+                                if (pTarget && !pTarget->HasAura(SPELL_FIERY_COMBUSTION))
+                                    DoCast(pTarget, SPELL_FIERY_COMBUSTION);
+                                events.ScheduleEvent(EVENT_CAST_FIERY_COMBUSTION, 15000);
+                                break;
+                        }
+                    }
+                }
+
+                /*if ((events.GetPhaseMask() & PHASE_1_MASK) && me->HealthBelowPct(75))
+                {
+                    events.SetPhase(PHASE_2);
+                    instance->SetBossState(DATA_HALION, SPECIAL);
+                    DoScriptText(SAY_PHASE2, me);
+                    me->SetReactState(REACT_PASSIVE);
+                    me->AttackStop();
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    DoCast(me, SPELL_SUMMON_TWILIGHT_PORTAL);
+                    DoCast(me, SPELL_TWILIGHT_DIVISION);
+                    me->SummonCreature(NPC_TWILIGHT_HALION,SpawnPosHalion);
+                    me->SetVisible(false);
+                }*/
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            uint32 PercentDamage;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+                return new boss_halionAI(pCreature);
+        }
+
+};
+
+class boss_twilight_halion : public CreatureScript
+{
+    public:
+        boss_twilight_halion() : CreatureScript("boss_twilight_halion") { }
+
+        struct boss_twilight_halionAI : public ScriptedAI
+        {
+            boss_twilight_halionAI(Creature *pCreature) : ScriptedAI(pCreature)
+                {
+                    pInstance = me->GetInstanceScript();
+                    pTwilight = me;
+                }
+
+            void Reset()
+            {
+                if (pInstance->GetBossState(DATA_HALION)!=SPECIAL)
+                    return;
+                me->SetReactState(REACT_AGGRESSIVE);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                events.Reset();
+                events.SetPhase(PHASE_2);
+                events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 1000);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                events.ScheduleEvent(EVENT_CAST_DUSK_SHROUD, urand(15000,20000));
+                events.ScheduleEvent(EVENT_CAST_DARK_BREATH, urand(20000,25000));
+                events.ScheduleEvent(EVENT_CAST_SOUL_CONSUMPTION, urand(15000,25000));
+                events.ScheduleEvent(EVENT_CAST_BERSEK, 9999999);
+                me->SetMaxHealth(pHalion->GetMaxHealth());
+                TwilightDamage = 0;
+            }
+
+            void EnterCombat(Unit*)
+            {
+                me->SetHealth(pHalion->GetHealth());
+                pInstance->SetData(DATA_TWILIGHT_HALION,IN_PROGRESS);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    if (pInstance->GetData(DATA_DAMAGE) != 0)
+                        me->SetHealth(pInstance->GetData(DATA_DAMAGE));
+                    else
+                        me->SetHealth(1);
+                }
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_TWILIGHT_PRECISION:
+                            DoCast(me, SPELL_TWILIGHT_PRECISION);
+                            break;
+                        case EVENT_CAST_TAIL_LASH:
+                            DoCast(SPELL_TAIL_LASH);
+                            events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000));
+                            break;
+                        case EVENT_CAST_DARK_BREATH:
+                            DoCast(RAID_MODE(SPELL_DARK_BREATH_10_NORMAL, SPELL_DARK_BREATH_25_NORMAL, SPELL_DARK_BREATH_10_HEROIC, SPELL_DARK_BREATH_25_HEROIC));
+                            events.ScheduleEvent(EVENT_CAST_DARK_BREATH, urand(20000,25000));break;
+                        case EVENT_CAST_CLEAVE:
+                            DoCast(SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000);
+                            break;
+                        case EVENT_CAST_DUSK_SHROUD:
+                            DoCastAOE(SPELL_DUSK_SHROUD,true);
+                            events.ScheduleEvent(EVENT_CAST_DUSK_SHROUD, urand(15000,20000));
+                            break;
+                        case EVENT_CAST_SOUL_CONSUMPTION:
+                            DoCast(SPELL_SOUL_CONSUMPTION);
+                            events.ScheduleEvent(EVENT_CAST_SOUL_CONSUMPTION, urand(15000,25000));
+                            break;
+                        case EVENT_CAST_BERSEK:
+                            DoCast(me, SPELL_BERSEK);
+                            events.ScheduleEvent(EVENT_CAST_BERSEK, 9999999);
+                            break;
+                        case EVENT_DPS:
+                            if (pInstance->GetBossState(DATA_HALION)==SPECIAL)
+                                CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->CastCorporeality();
+                            events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                            break;
+                    }
+                }
+
+                if ((events.GetPhaseMask() & PHASE_2_MASK) && me->HealthBelowPct(50))
+                {
+                    pInstance->SetData(DATA_DAMAGE, me->GetHealth());
+                    events.SetPhase(PHASE_3);
+                    DoScriptText(SAY_PHASE3, me);
+                    pHalion->SetReactState(REACT_AGGRESSIVE);
+                    pHalion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    pHalion->SetVisible(true);
+                    CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->SetPhase3();
+                    events.ScheduleEvent(EVENT_DPS, 5000,0,PHASE_3);
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+            void DamageTaken(Unit* /*who*/, uint32 &dmg)
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                TwilightDamage += dmg;    
+
+                pInstance->SetData(DATA_DAMAGE, me->GetHealth() >= dmg ? me->GetHealth() - dmg : 0);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustReachedHome()
+            {
+                pInstance->SetData(DATA_TWILIGHT_HALION, FAIL);
+                if (pInstance->GetBossState(DATA_HALION)==SPECIAL)
+                    pInstance->SetBossState(DATA_HALION,FAIL);
+                CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->Reset();
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+            }
+
+            void JustDied(Unit*)
+            {
+                pInstance->SetData(DATA_TWILIGHT_HALION,DONE);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_AURE_TWILIGHT);
+            }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+                return new boss_twilight_halionAI(pCreature);
+        }
+
+};
+
+class spell_halion_portal : public SpellScriptLoader
+{
+    public:
+        spell_halion_portal() : SpellScriptLoader("spell_halion_portal") { }
+
+        class spell_halion_portal_SpellScript : public SpellScript
+        {
+            PrepareSpellScript(spell_halion_portal_SpellScript)
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                PreventHitDefaultEffect(EFFECT_0);
+                GetHitPlayer()->RemoveAurasDueToSpell(SPELL_AURE_TWILIGHT);
+                GetHitPlayer()->SetPhaseMask(1,true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_halion_portal_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_APPLY_AURA);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_portal_SpellScript();
+        }
+};
+
+class npc_meteor_strike : public CreatureScript
+{
+    public:
+        npc_meteor_strike() : CreatureScript("npc_meteor_strike") { }
+
+        struct npc_meteor_strikeAI : public ScriptedAI
+        {
+            npc_meteor_strikeAI(Creature *pCreature) : ScriptedAI(pCreature){ }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                DoCast(me, SPELL_METEOR_STRIKE);
+                events.Reset();
+                events.ScheduleEvent(EVENT_METEOR_DAMAGE, 7000);
+                events.ScheduleEvent(EVENT_METEOR_STRIKE, 1000);
+                me->ForcedDespawn(15000);
+                angle = (float)(urand(0,62)/10);
+                dist = 0;
+                count = 0;
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_METEOR_STRIKE:
+                            DoCastAOE(SPELL_METEOR_TARGET);
+                            break;
+                        case EVENT_METEOR_DAMAGE:
+                            DoCastAOE(SPELL_METEOR_DAMAGE);
+                            events.ScheduleEvent(EVENT_METEOR_FLAME, 1000);
+                            break;
+                        case EVENT_METEOR_FLAME:
+                            float x, y;
+                            dist += 5;
+                            count ++;
+                            me->GetNearPoint2D(x, y, dist, angle);
+                            me->SummonCreature(NPC_METEOR_FLAME,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            me->GetNearPoint2D(x, y, dist, angle+M_PI);
+                            me->SummonCreature(NPC_METEOR_FLAME,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            me->GetNearPoint2D(x, y, dist, angle+3*M_PI/2);
+                            me->SummonCreature(NPC_METEOR_FLAME,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            me->GetNearPoint2D(x, y, dist, angle+M_PI/2);
+                            me->SummonCreature(NPC_METEOR_FLAME,x,y,me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,999999);
+                            if (count < 8)
+                                events.ScheduleEvent(EVENT_METEOR_FLAME, 1000);
+                            break;
+                    }
+                }
+            }
+
+        private:
+            EventMap events;
+            float dist, angle;
+            uint8 count;
+
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_meteor_strikeAI(pCreature);
+        }
+};
+
+class npc_spell_meteor_strike : public CreatureScript
+{
+    public:
+        npc_spell_meteor_strike() : CreatureScript("npc_spell_meteor_strike") { }
+
+        struct npc_spell_meteor_strikeAI : public ScriptedAI
+        {
+            npc_spell_meteor_strikeAI(Creature *pCreature) : ScriptedAI(pCreature){ }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                me->ForcedDespawn(10000);
+            }
+
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_spell_meteor_strikeAI(pCreature);
+        }
+};
+
+class npc_meteor_flame : public CreatureScript
+{
+    public:
+        npc_meteor_flame() : CreatureScript("npc_meteor_flame") { }
+
+        struct npc_meteor_flameAI : public ScriptedAI
+        {
+            npc_meteor_flameAI(Creature *pCreature) : ScriptedAI(pCreature){ }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                DoCast(me,SPELL_METEOR_FLAME);
+ 
+                me->ForcedDespawn(10000);
+            }
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_meteor_flameAI(pCreature);
+        }
+};
+
+class npc_summon_halion : public CreatureScript
+{
+    public:
+        npc_summon_halion() : CreatureScript("npc_summon_halion") { }
+
+        struct npc_summon_halionAI : public ScriptedAI
+        {
+            npc_summon_halionAI(Creature *pCreature) : ScriptedAI(pCreature){ }
+
+            void Reset()
+            {
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetReactState(REACT_PASSIVE);
+                events.Reset();
+                events.ScheduleEvent(EVENT_FIRE_PILLAR, 10000);
+                DoCast(me,SPELL_FIRE_PILLAR);
+ 
+                me->ForcedDespawn(20000);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_FIRE_PILLAR:
+                            DoCastAOE(SPELL_FIERY_EXPLOSION);
+                            pHalion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                            pHalion->SetVisible(true);
+                            pHalion->SetReactState(REACT_AGGRESSIVE);
+                            break;
+                    }
+                }
+            }
+
+        private:
+            EventMap events;
+
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_summon_halionAI(pCreature);
+        }
+};
+
+void AddSC_boss_halion()
+{
+    new boss_halion();
+    new boss_twilight_halion();
+    new spell_halion_portal();
+    new npc_meteor_strike();
+    new npc_spell_meteor_strike();
+    new npc_meteor_flame();
+    new npc_summon_halion();
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp b/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
new file mode 100644
index 0000000..c7c201e
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
@@ -0,0 +1,191 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eScriptTexts
+{
+    SAY_AGGRO           = -1752022,
+    SAY_SLAY1           = -1752023,
+    SAY_SLAY2           = -1752024,
+    SAY_DEATH           = -1752025
+};
+
+enum eSpells
+{
+    SPELL_CONFLAGRATION     = 74456,
+    SPELL_ENRAGE            = 78722,
+    SPELL_FLAME_BREATH_10   = 74403,
+    SPELL_FLAME_BREATH_25   = 74404,
+    SPELL_FLAME_BEACON      = 74453
+};
+
+enum eEvents
+{
+    EVENT_CAST_CONFLAGRATION      = 1,
+    EVENT_CAST_ENRAGE             = 2,
+    EVENT_CAST_FLAME_BREATH       = 3,
+    EVENT_CAST_FLAME_BEACON       = 4,
+    EVENT_CAST_CONFLAGRATION_FLY  = 5,
+    EVENT_CAST_CONFLAGRATION_CAST = 6
+};
+
+#define TARGETS_10 2
+#define TARGETS_25 5
+
+class boss_ragefire : public CreatureScript
+{
+    public:
+        boss_ragefire() : CreatureScript("boss_ragefire") { }
+
+        struct boss_ragefireAI : public BossAI
+        {
+            boss_ragefireAI(Creature *pCreature) : BossAI(pCreature, DATA_RAGEFIRE)
+            {
+                ASSERT(instance);
+                me->SetUnitMovementFlags(MOVEMENTFLAG_CAN_FLY);
+            }
+
+            void Reset()
+            {
+                instance->SetBossState(DATA_RAGEFIRE, NOT_STARTED);
+                playerList.clear();
+                bConflagration = false;
+                events.Reset();
+                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION, urand(45000,55000));
+                events.ScheduleEvent(EVENT_CAST_ENRAGE, urand(25000,35000));
+                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(10000,15000));
+            }
+
+            void EnterCombat(Unit*)
+            {
+                instance->SetBossState(DATA_RAGEFIRE, IN_PROGRESS);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustDied(Unit*)
+            {
+                _JustDied();
+                DoScriptText(SAY_DEATH, me);
+                instance->SetBossState(DATA_RAGEFIRE, DONE);
+                if (instance->GetBossState(DATA_BALTHARUS)==DONE)
+                {
+                   if (GameObject* flame = GetClosestGameObjectWithEntry(me, GO_FLAME_WALLS, 200.0f))
+                       flame->RemoveFromWorld();
+                }
+            }
+
+            void JustReachedHome()
+            {
+                instance->SetBossState(DATA_RAGEFIRE, FAIL);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                if (!bConflagration)
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_CONFLAGRATION:
+                                bConflagration = true;
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION_FLY, 1000);
+                                break;
+                            case EVENT_CAST_ENRAGE:
+                                DoCast(SPELL_ENRAGE);
+                                events.ScheduleEvent(EVENT_CAST_ENRAGE, urand(25000,35000));
+                                break;
+                            case EVENT_CAST_FLAME_BREATH:
+                                DoCast(RAID_MODE(SPELL_FLAME_BREATH_10,SPELL_FLAME_BREATH_25,SPELL_FLAME_BREATH_10,SPELL_FLAME_BREATH_25));
+                                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(10000,15000));
+                                break;
+                        }
+                    }
+                }
+                else
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_CONFLAGRATION_FLY:
+                                me->GetMotionMaster()->MovePoint(1, (float)3159.04, (float)676.08, (float)103.05);
+                                SelectTargetList(playerList, RAID_MODE(TARGETS_10,TARGETS_25,TARGETS_10,TARGETS_25), SELECT_TARGET_RANDOM, 0, true);
+                                for (std::list<Unit*>::const_iterator itr = playerList.begin(); itr != playerList.end(); ++itr)
+                                {
+                                    Unit *pTemp = (*itr);
+                                    me->CastSpell(pTemp, SPELL_FLAME_BEACON, true);
+                                }
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION_CAST, 5000);
+                                break;
+                            case EVENT_CAST_CONFLAGRATION_CAST:
+                                for (std::list<Unit*>::const_iterator itr = playerList.begin(); itr != playerList.end(); ++itr)
+                                {
+                                    Unit *pTemp = (*itr);
+                                    me->CastSpell(pTemp, SPELL_CONFLAGRATION, true);
+                                }
+                                playerList.clear();
+                                me->GetMotionMaster()->MoveTargetedHome();
+                                bConflagration = false;
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION, urand(45000,55000));
+                                break;
+                        }
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            bool bConflagration;
+            std::list<Unit *> playerList;
+
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new boss_ragefireAI(pCreature);
+        }
+
+};
+
+
+void AddSC_boss_ragefire()
+{
+    new boss_ragefire();
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp b/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
new file mode 100644
index 0000000..1ba0135
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
@@ -0,0 +1,230 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/> 
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eTexts
+{
+    SAY_AGGRO = -1752017,
+    SAY_SLAY1 = -1752018,
+    SAY_SLAY2 = -1752019,
+    SAY_DEATH = -1752020
+};
+
+enum eSpells
+{
+    SPELL_CLEAVE_ARMOR          = 74367,
+    SPELL_INTIMIDATING_ROAR     = 74384,
+    SPELL_SUMMON_FLAMECALLER    = 74398,
+
+    SPELL_BLAST_NOVA_10         = 74392,
+    SPELL_BLAST_NOVA_25         = 74393,
+    SPELL_LAVA_GOUT_10          = 74394,
+    SPELL_LAVA_GOUT_25          = 74395
+};
+
+enum eEvents
+{
+    EVENT_CAST_CLEAVE_ARMOR         = 1,
+    EVENT_CAST_INTIMIDATING_ROAR    = 2,
+    EVENT_CAST_SUMMON_FLAMECALLER   = 3,
+
+    EVENT_CAST_BLAST_NOVA           = 4,
+    EVENT_CAST_LAVA_GOUT            = 5,
+    EVENT_MOVE_TO_RANDOM_PLAYER     = 6
+};
+
+static const Position SpawnPos[4] =
+{
+    {3022.67f, 479.01f, 89.23f, 2.38f},
+    {3016.55f, 510.26f, 90.03f, 0.89f},
+    {3039.37f, 590.13f, 87.90f, 3.74f},
+    {3018.86f, 549.40f, 89.25f, 5.23f}
+};
+
+Creature* pZarithrian;
+
+class boss_zarithrian : public CreatureScript
+{
+    public:
+        boss_zarithrian() : CreatureScript("boss_zarithrian") { }
+
+        struct boss_zarithrianAI : public BossAI
+        {
+            boss_zarithrianAI(Creature *pCreature) : BossAI(pCreature, DATA_ZARITHRIAN)
+            {
+                ASSERT(instance);
+                pZarithrian = me;
+            }
+
+            void Reset()
+            {
+                instance->SetBossState(DATA_ZARITHRIAN, NOT_STARTED);
+                events.Reset();
+                summons.DespawnAll();
+                summons.clear();
+                events.ScheduleEvent(EVENT_CAST_CLEAVE_ARMOR, urand(3500,4500));
+                events.ScheduleEvent(EVENT_CAST_INTIMIDATING_ROAR, urand(10000,11000));
+                events.ScheduleEvent(EVENT_CAST_SUMMON_FLAMECALLER, urand(40000,50000));
+            }
+
+            void EnterCombat(Unit*)
+            {
+                instance->SetBossState(DATA_ZARITHRIAN, IN_PROGRESS);
+                DoScriptText(SAY_AGGRO, me);
+            }
+
+            void KilledUnit(Unit* /*victim*/)
+            {
+                DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+            }
+
+            void JustSummoned(Creature *summon)
+            {
+                summons.Summon(summon);
+            }
+
+            void JustReachedHome()
+            {
+                summons.DespawnAll();
+                instance->SetData(DATA_ZARITHRIAN, FAIL);
+            }
+
+            void JustDied(Unit*)
+            {
+                _JustDied();
+                instance->SetBossState(DATA_ZARITHRIAN, DONE);
+                DoScriptText(SAY_DEATH, me);
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_CLEAVE_ARMOR:
+                            DoCastVictim(SPELL_CLEAVE_ARMOR);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE_ARMOR, urand(3500,4500));
+                            break;
+                        case EVENT_CAST_INTIMIDATING_ROAR:
+                            DoCastAOE(SPELL_INTIMIDATING_ROAR);
+                            events.ScheduleEvent(EVENT_CAST_INTIMIDATING_ROAR, urand(10000,11000));
+                            break;
+                        case EVENT_CAST_SUMMON_FLAMECALLER:
+                            if (Creature* pCreature1 = me->SummonCreature(NPC_ONYX_FLAMECALLER,SpawnPos[0]))
+                            {
+                                pCreature1->GetMotionMaster()->MovePoint(1,SpawnPos[1]);
+                            }
+                            if (Creature* pCreature2 = me->SummonCreature(NPC_ONYX_FLAMECALLER,SpawnPos[2]))
+                            {
+                                pCreature2->GetMotionMaster()->MovePoint(1,SpawnPos[3]);
+                            }
+                            events.ScheduleEvent(EVENT_CAST_SUMMON_FLAMECALLER, urand(40000,50000));
+                            break;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new boss_zarithrianAI(pCreature);
+        }
+
+};
+
+class npc_onyx_flamecaller : public CreatureScript
+{
+    public:
+        npc_onyx_flamecaller() : CreatureScript("npc_onyx_flamecaller") { }
+
+        struct npc_onyx_flamecallerAI : public ScriptedAI
+        {
+            npc_onyx_flamecallerAI(Creature *pCreature) : ScriptedAI(pCreature)
+            {
+                pInstance = me->GetInstanceScript();
+            }
+
+            void Reset()
+            {
+                events.Reset();
+                events.ScheduleEvent(EVENT_MOVE_TO_RANDOM_PLAYER, 3000);
+                events.ScheduleEvent(EVENT_CAST_BLAST_NOVA, urand(15000,25000));
+                events.ScheduleEvent(EVENT_CAST_LAVA_GOUT, urand(30000,35000));
+            }
+
+             void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_MOVE_TO_RANDOM_PLAYER:
+                            if (pZarithrian)
+                            {
+                                me->GetMotionMaster()->MovePoint(2,pZarithrian->GetPositionX(),pZarithrian->GetPositionY(),pZarithrian->GetPositionZ());
+                             }
+                            break;
+                        case EVENT_CAST_BLAST_NOVA:
+                            DoCast(RAID_MODE(SPELL_BLAST_NOVA_10,SPELL_BLAST_NOVA_25,SPELL_BLAST_NOVA_10,SPELL_BLAST_NOVA_25));
+                            events.ScheduleEvent(EVENT_CAST_BLAST_NOVA, urand(15000,25000));
+                            break;
+                        case EVENT_CAST_LAVA_GOUT:
+                            DoCast(RAID_MODE(SPELL_LAVA_GOUT_10,SPELL_LAVA_GOUT_25,SPELL_LAVA_GOUT_10,SPELL_LAVA_GOUT_25));
+                            events.ScheduleEvent(EVENT_CAST_LAVA_GOUT, urand(30000,35000));
+                            break;
+                    }
+                }
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            EventMap events;
+            InstanceScript* pInstance;
+        };
+        
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+            return new npc_onyx_flamecallerAI(pCreature);
+        }
+};
+
+void AddSC_boss_zarithrian()
+{
+    new boss_zarithrian();
+    new npc_onyx_flamecaller();
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp b/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
new file mode 100644
index 0000000..b87b855
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
@@ -0,0 +1,269 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/>
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+static const DoorData doorData[5] =
+{
+    {GO_FIRE_FIELD,   DATA_BALTHARUS,       DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS,  DATA_BALTHARUS,       DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS,  DATA_RAGEFIRE,        DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS,  DATA_ZARITHRIAN,      DOOR_TYPE_ROOM,    BOUNDARY_N   },
+    {0,               0,                    DOOR_TYPE_ROOM,    BOUNDARY_NONE}
+};
+
+class instance_ruby_sanctum : public InstanceMapScript
+{
+    public:
+        instance_ruby_sanctum() : InstanceMapScript("instance_ruby_sanctum", 724) { }
+
+        struct instance_ruby_sanctum_InstanceMapScript : public InstanceScript
+        {
+            instance_ruby_sanctum_InstanceMapScript(Map *pMap) : InstanceScript(pMap)
+            {
+                SetBossNumber(MAX_ENCOUNTER);
+                LoadDoorData(doorData);
+
+                m_uiDataDamage = 0;
+
+                m_uiXerestrasza = 0;
+                m_uiTwilightHalion = 0;
+
+                m_uiHalionPortalGUID = 0;
+                m_uiTwilightPortalGUID = 0;
+                m_uiBaltharusGUID = 0;
+                m_uiZarithrianGUID = 0;
+                m_uiRagefireGUID = 0;
+                m_uiHalionGUID = 0;
+                m_uiXerestraszaGUID = 0;
+                m_uiTwilightHalionGUID = 0;
+                m_uiGOFlameWallsGUID = 0;
+                m_uiGOTwilightWallsGUID = 0;
+            }
+
+            void OnCreatureCreate(Creature *pCreature)
+            {
+                switch(pCreature->GetEntry())
+                {
+                    case NPC_BALTHARUS:     m_uiBaltharusGUID = pCreature->GetGUID();   break;
+                    case NPC_RAGEFIRE:      m_uiRagefireGUID = pCreature->GetGUID();    break;
+                    case NPC_XERESTRASZA:   m_uiXerestraszaGUID = pCreature->GetGUID(); break;
+                    case NPC_ZARITHRIAN:
+                        m_uiZarithrianGUID = pCreature->GetGUID();
+                        if (GetBossState(DATA_RAGEFIRE)==DONE && GetBossState(DATA_BALTHARUS)==DONE)
+                        {
+                            pCreature->SetReactState(REACT_AGGRESSIVE);
+                            pCreature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
+                        else
+                        {
+                            pCreature->SetReactState(REACT_PASSIVE);
+                            pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
+                        break;
+                    case NPC_HALION:        
+                        m_uiHalionGUID = pCreature->GetGUID();
+                        if (GetBossState(DATA_ZARITHRIAN)==DONE && GetBossState(DATA_RAGEFIRE)==DONE && GetBossState(DATA_BALTHARUS)==DONE)
+                        {
+                            pCreature->SetVisible(true);
+                            pCreature->SetReactState(REACT_AGGRESSIVE);
+                            pCreature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
+                        else
+                        {
+                            pCreature->SetVisible(false);
+                            pCreature->SetReactState(REACT_PASSIVE);
+                            pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        }
+                        break;
+                    case NPC_TWILIGHT_HALION: m_uiTwilightHalionGUID = pCreature->GetGUID(); break;
+                }
+            }
+
+            void OnGameObjectCreate(GameObject* pGo, bool add)
+            {
+                switch (pGo->GetEntry())
+                {
+                    case GO_FIRE_FIELD:
+                    case GO_FLAME_WALLS:
+                    //case GO_FLAME_WALLS2:
+                        AddDoor(pGo, add);
+                        break;
+                    case GO_TWILIGHT_PORTAL1: m_uiHalionPortalGUID = pGo->GetGUID(); break;
+                    case GO_TWILIGHT_PORTAL2: m_uiTwilightPortalGUID = pGo->GetGUID(); break;
+                    case GO_FLAME_WALLS2:     m_uiGOFlameWallsGUID = pGo->GetGUID(); break;
+                    case GO_FLAME_WALLS3:     m_uiGOTwilightWallsGUID = pGo->GetGUID(); break;
+                    default: break;
+                }
+            }
+
+            void SetData(uint32 uiType, uint32 uiData)
+            {
+                switch(uiType)
+                {
+                    case DATA_XERESTRASZA:     m_uiXerestrasza    = uiData; break;
+                    case DATA_TWILIGHT_HALION: m_uiTwilightHalion = uiData; break;
+                    case DATA_DAMAGE:          m_uiDataDamage     = uiData; break;   
+                }
+            }
+
+            uint32 GetData(uint32 uiType)
+            {
+                switch(uiType)
+                {
+                    case DATA_XERESTRASZA:     return m_uiXerestrasza;    break;
+                    case DATA_TWILIGHT_HALION: return m_uiTwilightHalion; break;
+                    case DATA_DAMAGE:          return m_uiDataDamage;     break;
+                }
+                return 0;
+            }
+
+            void BossZarithrian()
+            {
+                if (Creature* Zarithrian = instance->GetCreature(GetData64(DATA_ZARITHRIAN)))
+                {
+                    Zarithrian->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    Zarithrian->SetReactState(REACT_AGGRESSIVE);
+                }
+            }
+
+            bool SetBossState(uint32 type, EncounterState state)
+            {
+                if (!InstanceScript::SetBossState(type, state))
+                    return false;
+
+                switch (type)
+                {
+                    case DATA_BALTHARUS:
+                        if (state==DONE)
+                        {
+                            if (GetBossState(DATA_RAGEFIRE)==DONE)
+                            {
+                                BossZarithrian();
+                            }
+                        }
+                        break;
+                    case DATA_RAGEFIRE: 
+                        if (state==DONE)
+                        {
+                            if (GetBossState(DATA_BALTHARUS)==DONE)
+                            {
+                                BossZarithrian();
+                            }
+                        }
+                        break;
+                    case DATA_ZARITHRIAN:
+                        if (GetBossState(DATA_BALTHARUS)==DONE && GetBossState(DATA_RAGEFIRE)==DONE)
+                        {
+                            if (state==DONE)
+                            {
+                                if (Creature* halion = instance->GetCreature(GetData64(DATA_HALION)))
+                                {
+                                    halion->SummonCreature(NPC_SUMMON_HALIOH,SpawnPosHalion,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,20000);
+                                }
+                            }
+                        }
+                        break;
+                    case DATA_HALION: break;
+                }
+
+                return true;
+            }
+
+            uint64 GetData64(uint32 uiData)
+            {
+                switch(uiData)
+                {
+                    case DATA_BALTHARUS:       return m_uiBaltharusGUID;      break;
+                    case DATA_ZARITHRIAN:      return m_uiZarithrianGUID;     break;
+                    case DATA_RAGEFIRE:        return m_uiRagefireGUID;       break;
+                    case DATA_HALION:          return m_uiHalionGUID;         break;
+                    case DATA_TWILIGHT_HALION: return m_uiTwilightHalionGUID; break;
+                    case DATA_XERESTRASZA:     return m_uiXerestraszaGUID;    break;
+                    case GO_TWILIGHT_PORTAL1:  return m_uiHalionPortalGUID;   break;
+                    case GO_TWILIGHT_PORTAL2:  return m_uiTwilightPortalGUID; break;
+                    case GO_FLAME_WALLS2:      return m_uiGOFlameWallsGUID;   break; 
+                    case GO_FLAME_WALLS3:      return m_uiGOTwilightWallsGUID;   break; 
+                    default: break;
+                }
+                return 0;
+            }
+
+            std::string GetSaveData()
+            {
+                std::ostringstream saveStream;
+                saveStream << GetBossSaveData() << " " << m_uiXerestrasza;
+                return saveStream.str();
+            }
+
+            void Load(const char* strIn)
+            {
+                if (!strIn)
+                {
+                    return;
+                }
+
+                std::istringstream loadStream(strIn);
+
+                uint32 tmpState;
+                
+                for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+                {
+                    loadStream >> tmpState;
+                    if (tmpState == IN_PROGRESS || tmpState > SPECIAL)
+                        tmpState = NOT_STARTED;
+                    SetBossState(i, EncounterState(tmpState));
+                }
+
+                loadStream >> m_uiXerestrasza;
+            }
+
+            private:
+                uint32 m_uiXerestrasza;
+                uint32 m_uiTwilightHalion;
+                uint32 m_uiDataDamage;
+
+                uint64 m_uiBaltharusGUID;
+                uint64 m_uiZarithrianGUID;
+                uint64 m_uiRagefireGUID;
+                uint64 m_uiHalionGUID;
+                uint64 m_uiXerestraszaGUID;
+                uint64 m_uiTwilightHalionGUID;
+                uint64 m_uiHalionPortalGUID;
+                uint64 m_uiTwilightPortalGUID;
+                uint64 m_uiGOFlameWallsGUID;
+                uint64 m_uiGOTwilightWallsGUID;
+        };
+        
+        InstanceScript* GetInstanceScript (InstanceMap *pMap) const
+        {
+            return new instance_ruby_sanctum_InstanceMapScript(pMap);
+        }
+};
+
+
+void AddSC_instance_ruby_sanctum()
+{
+    new instance_ruby_sanctum();
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h b/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h
new file mode 100644
index 0000000..506ae4b
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h
@@ -0,0 +1,74 @@
+/* Copyright (C) 2010 Easy for Trinity <http://trinity-core.ru/>
+ *
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2010 Myth Project <http://bitbucket.org/sun/myth-core/>
+ *
+ * Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DEF_RUBY_SANCTUM_H
+#define DEF_RUBY_SANCTUM_H
+
+static const Position SpawnPosHalion = {3144.93f, 527.233f, 72.8887f, 0.110395f};
+
+enum eData
+{
+    DATA_BALTHARUS       = 0,
+    DATA_RAGEFIRE        = 1,
+    DATA_ZARITHRIAN      = 2,
+    DATA_HALION          = 3,
+    MAX_ENCOUNTER        = 4,
+    DATA_XERESTRASZA     = 5,
+    DATA_TWILIGHT_HALION = 6,
+    DATA_DAMAGE          = 7
+};
+
+enum eAchievementData
+{
+    TWILIGHT_DESTROYER_NORMAL_10    = 4817,
+    TWILIGHT_DESTROYER_NORMAL_25    = 4815,
+    TWILIGHT_DESTROYER_HEROIC_10    = 4818,
+    TWILIGHT_DESTROYER_HEROIC_25    = 4816
+};
+
+enum eCreature
+{
+    NPC_BALTHARUS        = 39751,
+    NPC_BALTHARUS_SUMMON = 39899,
+    NPC_ZARITHRIAN       = 39746,
+    NPC_RAGEFIRE         = 39747,
+    NPC_HALION           = 39863,
+    NPC_TWILIGHT_HALION  = 40142,
+    NPC_XERESTRASZA      = 40429,
+    NPC_ONYX_FLAMECALLER = 39814,
+    NPC_METEOR_STRIKE    = 40041,
+    NPC_METEOR_FLAME     = 40042,
+    NPC_SUMMON_HALIOH    = 40044
+};
+
+enum eGameObject
+{
+    GO_FIRE_FIELD       = 203005,
+    GO_FLAME_WALLS      = 203006,
+    GO_FLAME_WALLS2     = 203007,
+    GO_FLAME_WALLS3     = 203624,
+    GO_TWILIGHT_PORTAL1 = 202794,
+    GO_TWILIGHT_PORTAL2 = 202796
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
index 904566e..09b6bf6 100644
--- a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
+++ b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
@@ -17,6 +17,8 @@
 
 #include "ScriptPCH.h"
 #include "vault_of_archavon.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 
 /* Vault of Archavon encounters:
 1 - Archavon the Stone Watcher event
@@ -43,6 +45,21 @@ class instance_archavon : public InstanceMapScript
                 ToravonGUID = 0;
             }
 
+            void OnPlayerEnter(Player *m_player)
+            {
+                if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                {
+                    if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+                    {
+                       if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (m_player->ToPlayer()->GetTeam() == ALLIANCE))
+                       return;
+                       else if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (m_player->ToPlayer()->GetTeam() == HORDE))
+                       return;
+                       else m_player->CastSpell(m_player, SPELL_TELEPORT_FORTRESS, true);
+                    }
+                }
+            }
+
             void OnCreatureCreate(Creature* creature)
             {
                 switch (creature->GetEntry())
diff --git a/src/server/scripts/Northrend/grizzly_hills.cpp b/src/server/scripts/Northrend/grizzly_hills.cpp
index 67e0ad5..94dfc7e 100644
--- a/src/server/scripts/Northrend/grizzly_hills.cpp
+++ b/src/server/scripts/Northrend/grizzly_hills.cpp
@@ -29,6 +29,7 @@ EndContentData */
 
 #include "ScriptPCH.h"
 #include "ScriptedEscortAI.h"
+#include "ScriptedFollowerAI.h"
 
 #define GOSSIP_ITEM1 "You're free to go Orsonn, but first tell me what's wrong with the furbolg."
 #define GOSSIP_ITEM2 "What happened then?"
@@ -798,6 +799,217 @@ public:
     };
 };
 
+/*######
+## Quest 13666 & 13673:  Une lame digne d'un champion!
+######*/
+
+enum eLakeFrog
+{
+	SPELL_WARTSBGONE_LIP_BALM = 62574,
+	SPELL_FROG_LOVE = 62537,
+	SPELL_WARTS = 62581,
+	NPC_MAIDEN_OF_ASHWOOD_LAKE = 33220,
+	MAIDEN_SPAWN
+};
+
+//Script de la grenouille
+class npc_lake_frog : public CreatureScript
+{
+public:
+	npc_lake_frog(): CreatureScript("npc_lake_frog"){}
+
+	struct npc_lake_frogAI : public FollowerAI // FollowerAI:Permet au npc de suivre une cible
+	{
+		npc_lake_frogAI(Creature *c) : FollowerAI(c) {}
+
+		uint32 uiFollowTimer; //Temps de poursuite (15 sec)
+		bool following;	//Si la grenouille est en train de suivre le joueur
+
+		void Reset ()
+		{
+			following=false;
+			uiFollowTimer=15000; // 15 sec
+		}
+
+		void UpdateAI(const uint32 diff)
+		{
+			if(following)
+			{
+				if(uiFollowTimer <= diff)
+				{
+					SetFollowComplete();
+					me->DisappearAndDie();		//dÃ©pop
+					me->Respawn(true);
+					Reset();
+				}
+				else uiFollowTimer-=diff;
+			}
+		}
+
+		void ReceiveEmote(Player* pPlayer, uint32 emote)
+		{
+			if(following) //Si la grenouille a dÃ©ja recu un /bisou il ne se passe rien
+				return;
+
+			if(emote==TEXTEMOTE_KISS) // Si on fait /bisou
+			{
+				if(!pPlayer->HasAura(SPELL_WARTSBGONE_LIP_BALM))
+					pPlayer->AddAura(SPELL_WARTS,pPlayer);
+				else if(roll_chance_i(10)) // 10% de chance de trouver la grenouille
+				{
+					pPlayer->SummonCreature(NPC_MAIDEN_OF_ASHWOOD_LAKE,me->GetPositionX(),me->GetPositionY(),me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN,30000);
+					me->DisappearAndDie();		//dÃ©pop
+					me->Respawn(true); //Repop 15 secondes plus tard
+				}
+				else
+				{
+					pPlayer->RemoveAura(SPELL_WARTSBGONE_LIP_BALM);	//On enleve le buff mis par l'objet de quete
+					me->AddAura(SPELL_FROG_LOVE,me); //On ajoute l'aura a la grenouille (les coeurs)
+					StartFollow(pPlayer, 35, NULL); //La grenouille suis le joueur
+					following=true;
+				}
+			}
+		}
+
+	};
+
+	CreatureAI* GetAI(Creature* pCreature) const
+	{
+		return new npc_lake_frogAI(pCreature);
+	}
+};
+
+//Script de la princesse
+#define MAIDEN_DEFAULT_TEXTID 14319
+#define MAIDEN_REWARD_TEXTID 14320
+#define GOSSIP_HELLO_MAIDEN "Delighted to have helped, ma'am. Were you once the guardian of a Send legendary. Would you know From where I could find it?"
+#define SPELL_SUMMON_ASHWOOD_BRAND 62554
+
+class npc_maiden_of_ashwood_lake : public CreatureScript
+{
+public:
+	npc_maiden_of_ashwood_lake(): CreatureScript("npc_maiden_of_ashwood_lake"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		if(!pPlayer->HasItemCount(44981,1,true))
+		{
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_MAIDEN, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+			pPlayer->SEND_GOSSIP_MENU(MAIDEN_DEFAULT_TEXTID, pCreature->GetGUID());
+			pCreature->ForcedDespawn(10000);
+			return true;
+		}
+
+		pPlayer->SEND_GOSSIP_MENU(MAIDEN_DEFAULT_TEXTID, pCreature->GetGUID());
+		return true;
+	}
+
+	bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+		switch(uiAction)
+		{
+			case GOSSIP_ACTION_INFO_DEF+1:
+				pPlayer->CastSpell(pPlayer,SPELL_SUMMON_ASHWOOD_BRAND,true);
+				pPlayer->SEND_GOSSIP_MENU(MAIDEN_REWARD_TEXTID, pCreature->GetGUID());
+				break;
+		}
+		return true;
+	}
+};
+
+//Quete : Une arme remarquable
+//Quand on utilise l'item:
+//Pop du gameobject 194239 <<NENUFAR
+//Pop du npc 33723
+
+//pop de gob 194238
+#define NPC_TEXTID_MAIDEN_OF_DRAK_MAR_01 -1850000
+#define NPC_TEXTID_MAIDEN_OF_DRAK_MAR_02 -1850001
+#define NPC_TEXTID_MAIDEN_OF_DRAK_MAR_03 -1850002
+#define NPC_TEXTID_MAIDEN_OF_DRAK_MAR_04 -1850003
+#define MAIDEN_OF_DRAK_MAR_TIMER_00 2000
+#define MAIDEN_OF_DRAK_MAR_TIMER_01 5000
+#define MAIDEN_OF_DRAK_MAR_TIMER_02 6000
+#define MAIDEN_OF_DRAK_MAR_TIMER_03 7000
+#define MAIDEN_OF_DRAK_MAR_TIMER_04 20000
+#define MAIDEN_OF_DRAK_MAR_GOB_01 194239
+#define MAIDEN_OF_DRAK_MAR_GOB_02 194238
+//Summon la dame :X: 4602.977 Y: -1600.141 Z: 156.7834 O: 0.7504916
+
+class npc_maiden_of_drak_mar : public CreatureScript
+{
+public:
+	npc_maiden_of_drak_mar(): CreatureScript("npc_maiden_of_drak_mar"){}
+
+	struct npc_maiden_of_drak_marAI : public ScriptedAI
+	{
+		uint32 phase;
+		uint32 uiPhaseTimer;
+		uint64 firstGobGuid;
+		uint64 secondGobGuid;
+
+		npc_maiden_of_drak_marAI(Creature *c) : ScriptedAI(c)
+		{
+			phase = 0;
+			uiPhaseTimer = MAIDEN_OF_DRAK_MAR_TIMER_00;
+			if(GameObject* go = me->SummonGameObject(MAIDEN_OF_DRAK_MAR_GOB_01,4602.977f,-1600.141f,156.7834f,0.7504916f,0,0,0,0,0))
+				firstGobGuid = go->GetGUID(); //Pop du nÃ©nuphar
+		}
+
+		void UpdateAI(const uint32 diff)
+		{
+			if(uiPhaseTimer <= diff)
+			{
+				phase++;
+					switch(phase)
+					{
+						case 1:
+							DoScriptText(NPC_TEXTID_MAIDEN_OF_DRAK_MAR_01, me);
+							uiPhaseTimer = MAIDEN_OF_DRAK_MAR_TIMER_01;
+							break;
+						case 2:
+							DoScriptText(NPC_TEXTID_MAIDEN_OF_DRAK_MAR_02, me);
+							uiPhaseTimer = MAIDEN_OF_DRAK_MAR_TIMER_02;
+							break;
+						case 3:
+							DoScriptText(NPC_TEXTID_MAIDEN_OF_DRAK_MAR_03, me);
+							uiPhaseTimer = MAIDEN_OF_DRAK_MAR_TIMER_03;
+							break;
+						case 4:
+							DoScriptText(NPC_TEXTID_MAIDEN_OF_DRAK_MAR_04, me);
+							if(GameObject* go = me->SummonGameObject(MAIDEN_OF_DRAK_MAR_GOB_02,4603.351f,-1599.288f,156.8822f,2.234018f,0,0,0,0,0))
+								secondGobGuid = go->GetGUID(); //Pop de la lame
+							uiPhaseTimer = MAIDEN_OF_DRAK_MAR_TIMER_04;
+							break;
+						case 5:
+							if(GameObject* go = GameObject::GetGameObject(*me,firstGobGuid))
+								go->RemoveFromWorld();// DÃ©pop du nÃ©nuphar
+							if(GameObject* go = GameObject::GetGameObject(*me,secondGobGuid))
+								go->RemoveFromWorld();// DÃ©pop de la lame
+							me->ForcedDespawn();// disparition du pnj
+							break;
+						default:// Ne devrait jamais arriver
+							if(GameObject* go = GameObject::GetGameObject(*me,firstGobGuid))
+								go->RemoveFromWorld();// DÃ©pop du nÃ©nuphar
+							if(GameObject* go = GameObject::GetGameObject(*me,secondGobGuid))
+								go->RemoveFromWorld();// DÃ©pop de la lame
+							me->ForcedDespawn();// disparition du pnj
+							break;
+					}
+			}
+			else
+			{
+				uiPhaseTimer -= diff;
+			}
+		}
+	};
+
+	CreatureAI* GetAI(Creature* pCreature) const
+	{
+		return new npc_maiden_of_drak_marAI(pCreature);
+	}
+};
+
 void AddSC_grizzly_hills()
 {
     new npc_orsonn_and_kodian;
@@ -809,4 +1021,7 @@ void AddSC_grizzly_hills()
     new npc_wounded_skirmisher;
     new npc_lightning_sentry();
     new npc_venture_co_straggler();
+    new npc_lake_frog;
+    new npc_maiden_of_ashwood_lake;
+    new npc_maiden_of_drak_mar;
 }
diff --git a/src/server/scripts/Northrend/icecrown.cpp b/src/server/scripts/Northrend/icecrown.cpp
index 808717a..53c18a1 100644
--- a/src/server/scripts/Northrend/icecrown.cpp
+++ b/src/server/scripts/Northrend/icecrown.cpp
@@ -157,7 +157,7 @@ enum eSquireDavid
 
     NPC_ARGENT_VALIANT                                  = 33448,
 
-    GOSSIP_TEXTID_SQUIRE                                = 14407
+    GOSSIP_TEXTID_SQUIRE_DAVID                                = 14407
 };
 
 #define GOSSIP_SQUIRE_ITEM_1 "I am ready to fight!"
@@ -177,19 +177,20 @@ public:
             pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_SQUIRE_ITEM_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
         }
 
-        pPlayer->SEND_GOSSIP_MENU(GOSSIP_TEXTID_SQUIRE, pCreature->GetGUID());
+        pPlayer->SEND_GOSSIP_MENU(GOSSIP_TEXTID_SQUIRE_DAVID, pCreature->GetGUID());
         return true;
     }
 
     bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
     {
-        pPlayer->PlayerTalkClass->ClearMenus();
-        if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
-        {
-            pPlayer->CLOSE_GOSSIP_MENU();
-            pCreature->SummonCreature(NPC_ARGENT_VALIANT,8575.451f,952.472f,547.554f,0.38f);
-        }
-        return true;
+	    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+	    {
+		pPlayer->CLOSE_GOSSIP_MENU();
+		pCreature->SummonCreature(NPC_ARGENT_VALIANT,8575.451,952.472,547.554,0.38);
+	    }
+	    //else
+		//pPlayer->SEND_GOSSIP_MENU(???, pCreature->GetGUID()); Missing text
+	    return true;
     }
 };
 
@@ -201,10 +202,25 @@ enum eArgentValiant
 {
     SPELL_CHARGE                = 63010,
     SPELL_SHIELD_BREAKER        = 65147,
+    SPELL_DEFEND		= 62719,
+    SPELL_THRUST		= 62544,
 
     NPC_ARGENT_VALIANT_CREDIT   = 24108
 };
 
+enum eValiantText
+{
+	NPC_FACTION_VAILIANT_TEXT_SAY_START_1 	= -1850004,//	Tenez-vous prÃªt !
+	NPC_FACTION_VAILIANT_TEXT_SAY_START_2 	= -1850005,//	Que le combat commence !
+	NPC_FACTION_VAILIANT_TEXT_SAY_START_3 	= -1850006,//	PrÃ©parez-vous !
+	NPC_ARGENT_VAILIANT_TEXT_SAY_START 		= -1850007,//	Vous pensez avoir la vaillance en vous ? Nous verrons.
+	NPC_ARGENT_VAILIANT_TEXT_SAY_WIN 		= -1850008,//	Impressionnante dÃ©monstration. Je pense que vous Ãªtes tout Ã  fait en mesure de rejoindre les rangs des vaillants.
+	NPC_ARGENT_VAILIANT_TEXT_SAY_LOOSE 		= -1850009,//	J'ai gagnÃ©. Vous aurez sans doute plus de chance la prochaine fois.
+	NPC_FACTION_VAILIANT_TEXT_SAY_WIN_1 	= -1850010,//	Je suis vaincue. Joli combat !
+	NPC_FACTION_VAILIANT_TEXT_SAY_WIN_2 	= -1850011,//	On dirait que j'ai sous-estimÃ© vos compÃ©tences. Bien jouÃ©.
+	NPC_FACTION_VAILIANT_TEXT_SAY_LOOSE 	= -1850012,//	J'ai gagnÃ©. Vous aurez sans doute plus de chance la prochaine fois.
+};
+
 class npc_argent_valiant : public CreatureScript
 {
 public:
@@ -214,17 +230,21 @@ public:
     {
         npc_argent_valiantAI(Creature* pCreature) : ScriptedAI(pCreature)
         {
+	    me->CastSpell(me, SPELL_DEFEND, true);
+	    me->CastSpell(me, SPELL_DEFEND, true);
             pCreature->GetMotionMaster()->MovePoint(0,8599.258f,963.951f,547.553f);
             pCreature->setFaction(35); //wrong faction in db?
         }
 
         uint32 uiChargeTimer;
         uint32 uiShieldBreakerTimer;
+	uint32 uiDefendTimer;
 
         void Reset()
         {
             uiChargeTimer = 7000;
             uiShieldBreakerTimer = 10000;
+	    uiDefendTimer = 10000;
         }
 
         void MovementInform(uint32 uiType, uint32 /*uiId*/)
@@ -237,15 +257,54 @@ public:
 
         void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
         {
-            if (uiDamage > me->GetHealth() && pDoneBy->GetTypeId() == TYPEID_PLAYER)
-            {
-                uiDamage = 0;
-                CAST_PLR(pDoneBy)->KilledMonsterCredit(NPC_ARGENT_VALIANT_CREDIT,0);
-                me->setFaction(35);
-                me->DespawnOrUnsummon(5000);
-                me->SetHomePosition(me->GetPositionX(),me->GetPositionY(),me->GetPositionZ(),me->GetOrientation());
-                EnterEvadeMode();
-            }
+		if(pDoneBy)
+		{
+			if (uiDamage > me->GetHealth() && (pDoneBy->GetTypeId() == TYPEID_PLAYER || pDoneBy->GetOwner()))
+			{
+				DoScriptText(NPC_ARGENT_VAILIANT_TEXT_SAY_WIN, me);
+				uiDamage = 0;
+
+				if(pDoneBy->GetOwner())
+					(pDoneBy->GetOwner())->ToPlayer()->KilledMonsterCredit(NPC_ARGENT_VALIANT_CREDIT,0);
+				if(pDoneBy->GetTypeId() == TYPEID_PLAYER)
+					pDoneBy->ToPlayer()->KilledMonsterCredit(NPC_ARGENT_VALIANT_CREDIT,0);
+
+				me->setFaction(35);
+				me->ForcedDespawn(5000);
+				me->SetHomePosition(me->GetPositionX(),me->GetPositionY(),me->GetPositionZ(),me->GetOrientation());
+				EnterEvadeMode();
+			}
+		}
+        }
+
+        void KilledUnit(Unit* /*victim*/)
+        {
+			me->setFaction(35);
+			me->ForcedDespawn(5000);
+			DoScriptText(NPC_ARGENT_VAILIANT_TEXT_SAY_LOOSE, me);
+			me->CombatStop(true);
+        }
+
+        void DoMeleeAttackIfReady()
+	{
+		if (me->HasUnitState(UNIT_STAT_CASTING))
+		    return;
+
+		//Make sure our attack is ready and we aren't currently casting before checking distance
+		if (me->isAttackReady())
+		{
+		    //If we are within range melee the target
+		    if (me->IsWithinMeleeRange(me->getVictim()))
+		    {
+		        DoCastVictim(SPELL_THRUST);
+		        me->resetAttackTimer();
+		    }
+		}
+	}
+
+	void EnterCombat(Unit* /*who*/)
+        {
+		DoScriptText(NPC_ARGENT_VAILIANT_TEXT_SAY_START, me);
         }
 
         void UpdateAI(const uint32 uiDiff)
@@ -265,6 +324,12 @@ public:
                 uiShieldBreakerTimer = 10000;
             } else uiShieldBreakerTimer -= uiDiff;
 
+            if (uiDefendTimer <= uiDiff)
+            {
+	        me->CastSpell(me, SPELL_DEFEND, true);
+	        uiDefendTimer = 10000;
+            } else uiDefendTimer -= uiDiff;
+
             DoMeleeAttackIfReady();
         }
     };
@@ -423,6 +488,943 @@ public:
     }
 };
 
+/*######
+## npc_vendor_argent_tournament
+######*/
+const uint32 ArgentTournamentVendor[10][4] =
+{
+	{33553,13726,2,14460}, // Orc
+	{33554,13726,8,14464}, // Troll
+	{33556,13728,6,14458}, // Tauren
+	{33555,13729,5,14459}, // Undead
+	{33557,13731,10,14465}, // Blood Elf
+	{33307,13699,1,14456}, // Human
+	{33310,13713,3,14457}, // Dwarf
+	{33653,13725,4,14463}, // Night Elf
+	{33650,13723,7,14462}, // Gnome
+	{33657,13724,11,14461} // Draenei
+};
+
+class npc_vendor_argent_tournament : public CreatureScript
+{
+public:
+	npc_vendor_argent_tournament(): CreatureScript("npc_vendor_argent_tournament"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		bool npcCheck = false;
+		bool questCheck = false;
+		bool raceCheck = false;
+		uint32 textId = 0;
+
+		for(int i = 0; (i < 10) && !npcCheck; i++)
+		{
+			if(pCreature->GetEntry() == ArgentTournamentVendor[i][0])
+			{
+				npcCheck = true;
+				questCheck = pPlayer->GetQuestStatus(ArgentTournamentVendor[i][1]) == QUEST_STATUS_COMPLETE;
+				raceCheck = pPlayer->getRace() == ArgentTournamentVendor[i][2];
+				textId = ArgentTournamentVendor[i][3];
+			}
+		}
+
+		if(questCheck || raceCheck)
+			pPlayer->SEND_VENDORLIST(pCreature->GetGUID());
+		else
+		    pPlayer->SEND_GOSSIP_MENU(textId, pCreature->GetGUID());
+		return true;
+	}
+
+};
+
+/*######
+* quest_givers_argent_tournament
+######*/
+
+class quest_givers_argent_tournament : public CreatureScript
+{
+public:
+	quest_givers_argent_tournament(): CreatureScript("quest_givers_argent_tournament"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		//uint64 const guid = pCreature->GetGUID();
+
+	        if (pCreature->isQuestGiver())
+		{
+			Object *pObject = (Object*)pCreature;
+			QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+			QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+			QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+			qm.ClearMenu();
+
+			for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+				if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+					qm.AddMenuItem(quest_id, 4);
+				else if (status == QUEST_STATUS_INCOMPLETE)
+					qm.AddMenuItem(quest_id, 4);
+				//else if (status == QUEST_STATUS_AVAILABLE)
+				//    qm.AddMenuItem(quest_id, 2);
+			}
+
+			bool EligibilityAlliance = pPlayer->GetQuestStatus(13686) == QUEST_STATUS_COMPLETE;
+			bool EligibilityHorde = pPlayer->GetQuestStatus(13687) == QUEST_STATUS_COMPLETE;
+
+			for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+				if (!pQuest) continue;
+
+				switch(quest_id)
+				{
+					case 13707: // Valiant Of Orgrimmar
+					case 13708: // Valiant Of Sen'jin
+					case 13709: // Valiant Of Thunder Bluff
+					case 13710: // Valiant Of Undercity
+					case 13711: // Valiant Of Silvermoon
+						if(!EligibilityHorde)
+						{
+							QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					case 13593: // Valiant Of Stormwind
+					case 13703: // Valiant Of Ironforge
+					case 13706: // Valiant Of Darnassus
+					case 13704: // Valiant Of Gnomeregan
+					case 13705: // Valiant Of The Exodar
+						if(!EligibilityAlliance)
+						{
+							QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					default:
+						QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+						if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 4);
+						else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 2);
+						break;
+				}
+			}
+		}
+	    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+	    return true;
+	}
+
+};
+
+/*######
+* npc_training_dummy_argent
+######*/
+#define SPELL_DEFEND_AURA 62719
+#define SPELL_DEFEND_AURA_1 64100
+#define SPELL_ARGENT_CHARGE 68321
+#define SPELL_ARGENT_BREAK_SHIELD 62626
+#define SPELL_ARGENT_MELEE 62544
+
+class npc_training_dummy_argent : public CreatureScript
+{
+public:
+	npc_training_dummy_argent(): CreatureScript("npc_training_dummy_argent"){}
+
+	struct npc_training_dummy_argentAI : Scripted_NoMovementAI
+	{
+	    npc_training_dummy_argentAI(Creature *c) : Scripted_NoMovementAI(c)
+	    {
+		m_Entry = c->GetEntry();
+	    }
+
+	    uint64 m_Entry;
+	    uint32 ResetTimer;
+	    uint32 DespawnTimer;
+		uint32 ShielTimer;
+	    void Reset()
+	    {
+		me->SetControlled(true,UNIT_STAT_STUNNED);//disable rotate
+		me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);//imune to knock aways like blast wave
+		me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+		ResetTimer = 10000;
+		DespawnTimer = 15000;
+			ShielTimer=0;
+	    }
+
+	    void EnterEvadeMode()
+	    {
+		if (!_EnterEvadeMode())
+		    return;
+
+		Reset();
+	    }
+
+	    void DamageTaken(Unit * /*done_by*/, uint32 &damage)
+	    {
+		ResetTimer = 10000;
+		damage = 0;
+	    }
+
+	    void EnterCombat(Unit * /*who*/)
+	    {
+		if (m_Entry != 2674 && m_Entry != 2673)
+		    return;
+	    }
+
+		void SpellHit(Unit* caster,const SpellEntry* spell)
+		{
+			if(caster->GetOwner())
+			{
+				if(m_Entry==33272)
+					if(spell->Id==SPELL_ARGENT_CHARGE)
+						if(!me->GetAura(SPELL_DEFEND_AURA))
+							caster->GetOwner()->ToPlayer()->KilledMonsterCredit(33340, 0);
+				if(m_Entry==33229){
+					if(spell->Id==SPELL_ARGENT_MELEE)
+					{
+						caster->GetOwner()->ToPlayer()->KilledMonsterCredit(33341, 0);
+						me->CastSpell(caster,62709,true);
+					}
+				}
+
+			}
+
+			if(m_Entry==33243)
+					if(spell->Id==SPELL_ARGENT_BREAK_SHIELD)
+						if(!me->GetAura(SPELL_DEFEND_AURA))
+							if(caster->GetTypeId()==TYPEID_PLAYER)
+								caster->ToPlayer()->KilledMonsterCredit(33339, 0);
+		}
+
+
+	    void UpdateAI(const uint32 diff)
+	    {
+			if (ShielTimer <= diff)
+			{
+				if(m_Entry==33243)
+					me->CastSpell(me,SPELL_DEFEND_AURA,true);
+
+				if(m_Entry==33272 && !me->GetAura(SPELL_DEFEND_AURA_1))
+						me->CastSpell(me,SPELL_DEFEND_AURA_1,true);
+				ShielTimer = 8000;
+			}
+			else
+				ShielTimer -= diff;
+
+		if (!UpdateVictim())
+		    return;
+		if (!me->HasUnitState(UNIT_STAT_STUNNED))
+		    me->SetControlled(true,UNIT_STAT_STUNNED);//disable rotate
+
+		if (m_Entry != 2674 && m_Entry != 2673)
+		{
+		    if (ResetTimer <= diff)
+		    {
+			EnterEvadeMode();
+			ResetTimer = 10000;
+		    }
+		    else
+			ResetTimer -= diff;
+		    return;
+		}
+		else
+		{
+		    if (DespawnTimer <= diff)
+			me->ForcedDespawn();
+		    else
+			DespawnTimer -= diff;
+		}
+	    }
+	    void MoveInLineOfSight(Unit * /*who*/){return;}
+	};
+
+	CreatureAI* GetAI(Creature* pCreature) const
+	{
+	    return new npc_training_dummy_argentAI(pCreature);
+	}
+
+};
+
+/*######
+* npc_quest_givers_for_crusaders
+######*/
+
+class npc_quest_givers_for_crusaders : public CreatureScript
+{
+public:
+	npc_quest_givers_for_crusaders(): CreatureScript("npc_quest_givers_for_crusaders"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		if (pPlayer->HasTitle(TITLE_CRUSADER))
+			if (pCreature->isQuestGiver())
+				pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+		pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+		return true;
+	}
+
+};
+
+/*######
+* npc_crusader_rhydalla
+######*/
+
+class npc_crusader_rhydalla : public CreatureScript
+{
+public:
+	npc_crusader_rhydalla(): CreatureScript("npc_crusader_rhydalla"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		// uint64 const guid = pCreature->GetGUID();
+
+		if (pCreature->isQuestGiver())
+		{
+			Object *pObject = (Object*)pCreature;
+			QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+			QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+			QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+			qm.ClearMenu();
+
+			for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+				if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+					qm.AddMenuItem(quest_id, 4);
+				else if (status == QUEST_STATUS_INCOMPLETE)
+					qm.AddMenuItem(quest_id, 4);
+				//else if (status == QUEST_STATUS_AVAILABLE)
+				//    qm.AddMenuItem(quest_id, 2);
+			}
+
+			for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+				if (!pQuest) continue;
+				QuestStatus status;
+				bool allowed=false;
+				switch(quest_id)
+				{
+					case 13664: // The Black Knigh's Fall
+						allowed = (pPlayer->GetQuestStatus(13700) == QUEST_STATUS_COMPLETE) || (pPlayer->GetQuestStatus(13701) == QUEST_STATUS_COMPLETE);
+						if(allowed)
+						{
+							status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					default:
+						status = pPlayer->GetQuestStatus(quest_id);
+
+						if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 4);
+						else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 2);
+						break;
+				}
+			}
+		}
+	    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+	    return true;
+	}
+
+};
+
+/*######
+* npc_eadric_the_pure
+######*/
+
+class npc_eadric_the_pure : public CreatureScript
+{
+public:
+	npc_eadric_the_pure(): CreatureScript("npc_eadric_the_pure"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		// uint64 const guid = pCreature->GetGUID();
+
+		if (pCreature->isQuestGiver())
+		{
+			Object *pObject = (Object*)pCreature;
+			QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+			QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+			QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+			qm.ClearMenu();
+
+			for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+				if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+					qm.AddMenuItem(quest_id, 4);
+				else if (status == QUEST_STATUS_INCOMPLETE)
+					qm.AddMenuItem(quest_id, 4);
+				//else if (status == QUEST_STATUS_AVAILABLE)
+				//    qm.AddMenuItem(quest_id, 2);
+			}
+
+			for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+				if (!pQuest) continue;
+				QuestStatus status;
+				bool allowed=false;
+				switch(quest_id)
+				{
+					case 13682: // Alliance Threat From Above
+					case 13809: // Horde Threat From Above
+						allowed = (pPlayer->GetQuestStatus(13664) == QUEST_STATUS_COMPLETE) && pPlayer->GetQuestRewardStatus(13664);
+						if(allowed)
+						{
+							status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					default:
+						status = pPlayer->GetQuestStatus(quest_id);
+
+						if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 4);
+						else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 2);
+						break;
+				}
+			}
+		}
+	    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+	    return true;
+	}
+
+};
+
+/*######
+* npc_justicar_mariel_trueheart
+######*/
+
+class npc_justicar_mariel_trueheart : public CreatureScript
+{
+public:
+	npc_justicar_mariel_trueheart(): CreatureScript("npc_justicar_mariel_trueheart"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		// uint64 const guid = pCreature->GetGUID();
+
+		if (pCreature->isQuestGiver())
+		{
+			Object *pObject = (Object*)pCreature;
+			QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+			QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+			QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+			qm.ClearMenu();
+
+			for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+				if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+					qm.AddMenuItem(quest_id, 4);
+				else if (status == QUEST_STATUS_INCOMPLETE)
+					qm.AddMenuItem(quest_id, 4);
+				//else if (status == QUEST_STATUS_AVAILABLE)
+				//    qm.AddMenuItem(quest_id, 2);
+			}
+
+			for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+				if (!pQuest) continue;
+				QuestStatus status;
+				bool allowed=false;
+				switch(quest_id)
+				{
+					case 13795: // The Scourgebane
+						allowed = (pPlayer->GetQuestStatus(13702) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13702)) || (pPlayer->GetQuestStatus(13732) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13732)) || (pPlayer->GetQuestStatus(13735) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13735)) || (pPlayer->GetQuestStatus(13733) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13733)) || (pPlayer->GetQuestStatus(13734) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13734)) || (pPlayer->GetQuestStatus(13736) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13736)) || (pPlayer->GetQuestStatus(13737) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13737)) || (pPlayer->GetQuestStatus(13738) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13738)) || (pPlayer->GetQuestStatus(13739) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13739)) || (pPlayer->GetQuestStatus(13740) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13740)); // If the player has finished any of the "A Champion Rises" quests
+						if(allowed)
+						{
+							status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					default:
+						status = pPlayer->GetQuestStatus(quest_id);
+
+						if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 4);
+						else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 2);
+						break;
+				}
+			}
+		}
+	    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+	    return true;
+	}
+
+};
+
+/*######
+* npc_crok_scourgebane
+######*/
+
+class npc_crok_scourgebane : public CreatureScript
+{
+public:
+	npc_crok_scourgebane(): CreatureScript("npc_crok_scourgebane"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		// uint64 const guid = pCreature->GetGUID();
+
+		if (pCreature->isQuestGiver())
+		{
+			Object *pObject = (Object*)pCreature;
+			QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+			QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+			QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+			qm.ClearMenu();
+
+			for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+				if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+					qm.AddMenuItem(quest_id, 4);
+				else if (status == QUEST_STATUS_INCOMPLETE)
+					qm.AddMenuItem(quest_id, 4);
+				//else if (status == QUEST_STATUS_AVAILABLE)
+				//    qm.AddMenuItem(quest_id, 2);
+			}
+
+			for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+				if (!pQuest) continue;
+				QuestStatus status;
+				bool allowed=false;
+				switch(quest_id)
+				{
+					case 13788: // DK Threat From Above (Alliance)
+					case 13812: // DK Threat From Above (Horde)
+						allowed = (pPlayer->GetQuestStatus(13664) == QUEST_STATUS_COMPLETE) && pPlayer->GetQuestRewardStatus(13664);
+						if(allowed)
+						{
+							status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					default:
+						status = pPlayer->GetQuestStatus(quest_id);
+
+						if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 4);
+						else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 2);
+						break;
+				}
+			}
+		}
+	    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+	    return true;
+	}
+
+};
+
+/*
+* Npc Jeran Lockwood (33973)
+*/
+#define JERAN_DEFAULT_TEXTID 14453
+#define JERAN_QUEST_TEXTID 14431
+#define JERAN_RP_TEXTID 14434
+#define GOSSIP_HELLO_JERAN_1 "Montrez-moi comment m'entraÃÂ®ner sur une cible de mÃÂªlÃÂ©e."
+#define GOSSIP_HELLO_JERAN_2 "Parlez-moi de la dÃÂ©fense et du coup de lance."
+#define SPELL_CREDIT_JERAN 64113
+
+class npc_jeran_lockwood : public CreatureScript
+{
+public:
+	npc_jeran_lockwood(): CreatureScript("npc_jeran_lockwood"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		if((pPlayer->GetQuestStatus(13828) == QUEST_STATUS_INCOMPLETE) || (pPlayer->GetQuestStatus(13829) == QUEST_STATUS_INCOMPLETE))
+		{
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_JERAN_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_JERAN_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+		pPlayer->SEND_GOSSIP_MENU(JERAN_QUEST_TEXTID, pCreature->GetGUID());
+		}
+		else
+		{
+			pPlayer->SEND_GOSSIP_MENU(JERAN_DEFAULT_TEXTID, pCreature->GetGUID());
+		}
+		return true;
+	}
+
+	bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+		switch(uiAction)
+		{
+			case GOSSIP_ACTION_INFO_DEF+1:
+				pPlayer->CastSpell(pPlayer,SPELL_CREDIT_JERAN,true);
+				pPlayer->CLOSE_GOSSIP_MENU();
+				break;
+			case GOSSIP_ACTION_INFO_DEF+2:
+				pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_JERAN_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+				pPlayer->SEND_GOSSIP_MENU(JERAN_RP_TEXTID, pCreature->GetGUID());
+				break;
+		}
+		return true;
+	}
+
+};
+
+/*
+* Npc Rugan Steelbelly (33972)
+*/
+#define RUGAN_DEFAULT_TEXTID 14453
+#define RUGAN_QUEST_TEXTID 14436
+#define RUGAN_RP_TEXTID 14437
+#define GOSSIP_HELLO_RUGAN_1 "Montrez-moi comment m'entraÃÂ®ner sur une cible de charge."
+#define GOSSIP_HELLO_RUGAN_2 "Parlez-moi de la charge"
+#define SPELL_CREDIT_RUGAN 64114
+
+class npc_rugan_steelbelly : public CreatureScript
+{
+public:
+	npc_rugan_steelbelly(): CreatureScript("npc_rugan_steelbelly"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		if((pPlayer->GetQuestStatus(13837) == QUEST_STATUS_INCOMPLETE) || (pPlayer->GetQuestStatus(13839) == QUEST_STATUS_INCOMPLETE))
+		{
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_RUGAN_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_RUGAN_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+		pPlayer->SEND_GOSSIP_MENU(RUGAN_QUEST_TEXTID, pCreature->GetGUID());
+		}
+		else
+		{
+			pPlayer->SEND_GOSSIP_MENU(RUGAN_DEFAULT_TEXTID, pCreature->GetGUID());
+		}
+		return true;
+	}
+
+	bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+		switch(uiAction)
+		{
+			case GOSSIP_ACTION_INFO_DEF+1:
+				pPlayer->CastSpell(pPlayer,SPELL_CREDIT_RUGAN,true);
+				pPlayer->CLOSE_GOSSIP_MENU();
+				break;
+			case GOSSIP_ACTION_INFO_DEF+2:
+				pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_RUGAN_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+				pPlayer->SEND_GOSSIP_MENU(RUGAN_RP_TEXTID, pCreature->GetGUID());
+				break;
+		}
+		return true;
+	}
+
+};
+
+/*
+* Npc Valis Windchaser
+*/
+#define VALIS_DEFAULT_TEXTID 14453
+#define VALIS_QUEST_TEXTID 14438
+#define VALIS_RP_TEXTID 14439
+#define GOSSIP_HELLO_VALIS_1 "Montrez-moi comment m'entraÃÂ®ner sur une cible Ã distance."
+#define GOSSIP_HELLO_VALIS_2 "Expliquez-moi comment utiliser le brise-bouclier."
+#define SPELL_CREDIT_VALIS 64115
+class npc_valis_windchaser : public CreatureScript
+{
+public:
+	npc_valis_windchaser(): CreatureScript("npc_valis_windchaser"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		//Si il a la quete
+		if((pPlayer->GetQuestStatus(13835) == QUEST_STATUS_INCOMPLETE) ||
+			(pPlayer->GetQuestStatus(13838) == QUEST_STATUS_INCOMPLETE))
+		{
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_VALIS_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_VALIS_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+		pPlayer->SEND_GOSSIP_MENU(VALIS_QUEST_TEXTID, pCreature->GetGUID());
+		}
+		//Sinon Texte par dÃ©faut
+		else
+			pPlayer->SEND_GOSSIP_MENU(VALIS_DEFAULT_TEXTID, pCreature->GetGUID());
+		return true;
+	}
+
+	bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+		switch (uiAction)
+		{
+			case GOSSIP_ACTION_INFO_DEF+1:
+				pPlayer->CastSpell(pPlayer,SPELL_CREDIT_VALIS,true);//Cast du sort de credit quest (valide l'objectif)
+				pPlayer->CLOSE_GOSSIP_MENU();//Ferme la fenetre du gossip cotÃ© client
+			break;
+			case GOSSIP_ACTION_INFO_DEF+2:
+				//Raconte un blabla
+				pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_VALIS_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+			pPlayer->SEND_GOSSIP_MENU(VALIS_RP_TEXTID, pCreature->GetGUID());
+			break;
+		}
+		return true;
+	}
+
+};
+
+/*######
+## npc_squire_danny
+######*/
+
+enum eSquireDanny
+{
+    QUEST_THE_VALIANT_S_CHALLENGE_0 = 13699,
+    QUEST_THE_VALIANT_S_CHALLENGE_1 = 13713,
+    QUEST_THE_VALIANT_S_CHALLENGE_2 = 13723,
+    QUEST_THE_VALIANT_S_CHALLENGE_3 = 13724,
+    QUEST_THE_VALIANT_S_CHALLENGE_4 = 13725,
+    QUEST_THE_VALIANT_S_CHALLENGE_5 = 13726,
+    QUEST_THE_VALIANT_S_CHALLENGE_6 = 13727,
+    QUEST_THE_VALIANT_S_CHALLENGE_7 = 13728,
+    QUEST_THE_VALIANT_S_CHALLENGE_8 = 13729,
+    QUEST_THE_VALIANT_S_CHALLENGE_9 = 13731,
+
+    NPC_ARGENT_CHAMPION = 33707,
+
+    GOSSIP_TEXTID_SQUIRE_DANNY = 14407
+};
+
+#define GOSSIP_SQUIRE_ITEM_1 "I am ready to fight!"
+#define GOSSIP_SQUIRE_ITEM_2 "How do the Argent Crusader raiders fight?"
+
+class npc_squire_danny : public CreatureScript
+{
+public:
+	npc_squire_danny(): CreatureScript("npc_squire_danny"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+	    if (pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_0) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_1) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_2) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_3) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_4) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_5) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_6) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_7) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_8) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_9) == QUEST_STATUS_INCOMPLETE)
+	    {
+		pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_SQUIRE_ITEM_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+		pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_SQUIRE_ITEM_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+	    }
+
+	    pPlayer->SEND_GOSSIP_MENU(GOSSIP_TEXTID_SQUIRE_DANNY, pCreature->GetGUID());
+	    return true;
+	}
+
+	bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+	    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+	    {
+		pPlayer->CLOSE_GOSSIP_MENU();
+		pCreature->SummonCreature(NPC_ARGENT_CHAMPION,8562.836914,1099.153931,556.787598,5.026550); // TODO (RÃ©cupÃ©rer les coordonnÃ©es rÃ©elles)
+	    }
+	    //else
+		//pPlayer->SEND_GOSSIP_MENU(???, pCreature->GetGUID()); Missing text
+	    return true;
+	}
+
+};
+
+/*######
+## npc_argent_champion
+######*/
+
+enum eArgentChampion
+{
+    SPELL_CHARGE_CHAMPION                = 63010,
+    SPELL_SHIELD_BREAKER_CHAMPION        = 65147,
+    SPELL_DEFEND_CHAMPION		= 62719,
+    SPELL_THRUST_CHAMPION		= 62544,
+
+    NPC_ARGENT_CHAMPION_CREDIT   = 33708
+};
+
+enum eChampionText
+{
+	NPC_FACTION_CHAMPION_TEXT_SAY_START_1 	= -1850004,//	Tenez-vous prÃªt !
+	NPC_FACTION_CHAMPION_TEXT_SAY_START_2 	= -1850005,//	Que le combat commence !
+	NPC_FACTION_CHAMPION_TEXT_SAY_START_3 	= -1850006,//	PrÃ©parez-vous !
+	NPC_ARGENT_CHAMPION_TEXT_SAY_START 		= -1850007,//	Vous pensez avoir la vaillance en vous ? Nous verrons.
+	NPC_ARGENT_CHAMPION_TEXT_SAY_WIN 		= -1850008,//	Impressionnante dÃ©monstration. Je pense que vous Ãªtes tout Ã  fait en mesure de rejoindre les rangs des vaillants.
+	NPC_ARGENT_CHAMPION_TEXT_SAY_LOOSE 		= -1850009,//	J'ai gagnÃ©. Vous aurez sans doute plus de chance la prochaine fois.
+	NPC_FACTION_CHAMPION_TEXT_SAY_WIN_1 	= -1850010,//	Je suis vaincue. Joli combat !
+	NPC_FACTION_CHAMPION_TEXT_SAY_WIN_2 	= -1850011,//	On dirait que j'ai sous-estimÃ© vos compÃ©tences. Bien jouÃ©.
+	NPC_FACTION_CHAMPION_TEXT_SAY_LOOSE 	= -1850012,//	J'ai gagnÃ©. Vous aurez sans doute plus de chance la prochaine fois.
+};
+
+class npc_argent_champion : public CreatureScript
+{
+public:
+	npc_argent_champion(): CreatureScript("npc_argent_champion"){}
+
+	struct npc_argent_championAI : public ScriptedAI
+	{
+	    npc_argent_championAI(Creature* pCreature) : ScriptedAI(pCreature)
+	    {
+		me->CastSpell(me, SPELL_DEFEND_CHAMPION, true);
+		me->CastSpell(me, SPELL_DEFEND_CHAMPION, true);
+		pCreature->GetMotionMaster()->MovePoint(0,8552.469727,1124.128784,556.787598); // TODO (Trouver les coordonnÃ©es exactes)
+		pCreature->setFaction(35); //wrong faction in db?
+	    }
+
+	    uint32 uiChargeTimer;
+	    uint32 uiShieldBreakerTimer;
+	    uint32 uiDefendTimer;
+
+	    void Reset()
+	    {
+		uiChargeTimer = 7000;
+		uiShieldBreakerTimer = 10000;
+	    }
+
+	    void MovementInform(uint32 uiType, uint32 /*uiId*/)
+	    {
+		if (uiType != POINT_MOTION_TYPE)
+		    return;
+
+		me->setFaction(14);
+	    }
+
+	    void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+	    {
+			if(pDoneBy)
+			{
+				if (uiDamage > me->GetHealth() && (pDoneBy->GetTypeId() == TYPEID_PLAYER || pDoneBy->GetOwner()))
+				{
+					DoScriptText(NPC_ARGENT_CHAMPION_TEXT_SAY_WIN, me);
+					uiDamage = 0;
+
+					if(pDoneBy->GetOwner())
+						(pDoneBy->GetOwner())->ToPlayer()->KilledMonsterCredit(NPC_ARGENT_CHAMPION_CREDIT,0);
+					if(pDoneBy->GetTypeId() == TYPEID_PLAYER)
+						pDoneBy->ToPlayer()->KilledMonsterCredit(NPC_ARGENT_CHAMPION_CREDIT,0);
+
+					me->setFaction(35);
+					me->ForcedDespawn(5000);
+					me->SetHomePosition(me->GetPositionX(),me->GetPositionY(),me->GetPositionZ(),me->GetOrientation());
+					EnterEvadeMode();
+				}
+			}
+	    }
+
+	    void KilledUnit(Unit* /*victim*/)
+	    {
+		me->setFaction(35);
+		me->ForcedDespawn(5000);
+		DoScriptText(NPC_ARGENT_CHAMPION_TEXT_SAY_LOOSE, me);
+		me->CombatStop(true);
+	    }
+
+	    void DoMeleeAttackIfReady()
+		{
+			if (me->HasUnitState(UNIT_STAT_CASTING))
+			    return;
+
+			//Make sure our attack is ready and we aren't currently casting before checking distance
+			if (me->isAttackReady())
+			{
+			    //If we are within range melee the target
+			    if (me->IsWithinMeleeRange(me->getVictim()))
+			    {
+				DoCastVictim(SPELL_THRUST_CHAMPION);
+				me->resetAttackTimer();
+			    }
+			}
+		}
+
+	    void EnterCombat(Unit* /*who*/)
+	    {
+		DoScriptText(NPC_ARGENT_CHAMPION_TEXT_SAY_START, me);
+	    }
+
+	    void UpdateAI(const uint32 uiDiff)
+	    {
+		if (!UpdateVictim())
+		    return;
+
+		if (uiChargeTimer <= uiDiff)
+		{
+		    DoCastVictim(SPELL_CHARGE_CHAMPION);
+		    uiChargeTimer = 7000;
+		} else uiChargeTimer -= uiDiff;
+
+		if (uiShieldBreakerTimer <= uiDiff)
+		{
+		    DoCastVictim(SPELL_SHIELD_BREAKER_CHAMPION);
+		    uiShieldBreakerTimer = 10000;
+		} else uiShieldBreakerTimer -= uiDiff;
+
+		if (uiDefendTimer <= uiDiff)
+		{
+		    me->CastSpell(me, SPELL_DEFEND_CHAMPION, true);
+		    uiDefendTimer = 10000;
+		} else uiDefendTimer -= uiDiff;
+
+		DoMeleeAttackIfReady();
+	    }
+	};
+
+	CreatureAI* GetAI(Creature* pCreature) const
+	{
+	    return new npc_argent_championAI (pCreature);
+	}
+
+};
+
 void AddSC_icecrown()
 {
     new npc_arete;
@@ -432,4 +1434,17 @@ void AddSC_icecrown()
     new npc_argent_tournament_post;
     new npc_alorah_and_grimmin;
     new npc_guardian_pavilion;
+    new npc_vendor_argent_tournament;
+    new quest_givers_argent_tournament;
+    new npc_training_dummy_argent;
+    new npc_quest_givers_for_crusaders;
+    new npc_justicar_mariel_trueheart;
+    new npc_crusader_rhydalla;
+    new npc_eadric_the_pure;
+    new npc_crok_scourgebane;
+    new npc_valis_windchaser;
+    new npc_rugan_steelbelly;
+    new npc_jeran_lockwood;
+    new npc_squire_danny;
+    new npc_argent_champion;
 }
diff --git a/src/server/scripts/Northrend/wintergrasp.cpp b/src/server/scripts/Northrend/wintergrasp.cpp
new file mode 100644
index 0000000..c493daa
--- /dev/null
+++ b/src/server/scripts/Northrend/wintergrasp.cpp
@@ -0,0 +1,90 @@
+/* Copyright (C) 2008 - 2009 Trinity <http://www.trinitycore.org/>
+*
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ScriptPCH.h"
+#include "OutdoorPvPWG.h"
+
+#define GOSSIP_HELLO_DEMO1  "Build catapult."
+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
+
+class npc_demolisher_engineerer : public CreatureScript
+{
+public:
+    npc_demolisher_engineerer() : CreatureScript("npc_demolisher_engineerer") { }
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if (pCreature->isQuestGiver())
+        pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+    if(pPlayer->isGameMaster() || pCreature->GetZoneScript() && pCreature->GetZoneScript()->GetData(pCreature->GetDBTableGUIDLow()))
+    {
+        if (pPlayer->HasAura(SPELL_CORPORAL))
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+        else if (pPlayer->HasAura(SPELL_LIEUTENANT))
+        {
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+1);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+2);
+        }
+    }
+    else
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+9);
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    if(pPlayer->isGameMaster() || pCreature->GetZoneScript() && pCreature->GetZoneScript()->GetData(pCreature->GetDBTableGUIDLow()))
+    {
+        switch(uiAction - GOSSIP_ACTION_INFO_DEF)
+        {
+            case 0: pPlayer->CastSpell(pPlayer, 56663, false, NULL, NULL, pCreature->GetGUID()); break;
+            case 1: pPlayer->CastSpell(pPlayer, 56575, false, NULL, NULL, pCreature->GetGUID()); break;
+            case 2: pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? 61408 : 56661, false, NULL, NULL, pCreature->GetGUID()); break;
+        }
+    }
+
+    return true;
+}
+
+    CreatureAI* GetAI(Creature* pCreature) const
+    {
+        return new npc_demolisher_engineererAI(pCreature);
+    }
+
+    struct npc_demolisher_engineererAI : public ScriptedAI
+    {
+        npc_demolisher_engineererAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            me->SetReactState(REACT_PASSIVE);
+        }
+    };
+
+};
+void AddSC_wintergrasp()
+{
+    new npc_demolisher_engineerer();
+}
\ No newline at end of file
diff --git a/src/server/scripts/OutdoorPvP/CMakeLists.txt b/src/server/scripts/OutdoorPvP/CMakeLists.txt
index 5232705..7c39e9f 100644
--- a/src/server/scripts/OutdoorPvP/CMakeLists.txt
+++ b/src/server/scripts/OutdoorPvP/CMakeLists.txt
@@ -12,6 +12,8 @@ set(scripts_STAT_SRCS
   OutdoorPvP/OutdoorPvPHP.h
   OutdoorPvP/OutdoorPvPZM.h
   OutdoorPvP/OutdoorPvPNA.h
+  OutdoorPvP/OutdoorPvPWG.cpp
+  OutdoorPvP/OutdoorPvPWG.h
 )
 
 message("  -> Prepared: Outdoor PVP Zones")
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
new file mode 100644
index 0000000..0a7745b
--- /dev/null
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
@@ -0,0 +1,2306 @@
+/*
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "OutdoorPvPWG.h"
+#include "SpellAuras.h"
+#include "Vehicle.h"
+#include "ObjectMgr.h"
+#include "World.h"
+#include "Group.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "ScriptedCreature.h"
+#include "ScriptPCH.h"
+
+Creature* FortressSpirit;
+uint32 entry;
+uint32 guide_entry;
+uint32 guide_entry_fortress_horde;
+uint32 guide_entry_fortress_alliance;
+
+/* Vehicle teleport system*/
+Map* pMap;
+
+OutdoorPvPWG::OutdoorPvPWG()
+{
+    m_TypeId = OUTDOOR_PVP_WG;
+    m_LastResurrectTime = 0; // Temporal copy of BG system till 3.2
+}
+
+void _LoadTeamPair(TeamPairMap &pairMap, const TeamPair *pair)
+{
+    while((*pair)[0])
+    {
+        pairMap[(*pair)[0]] = (*pair)[1];
+        pairMap[(*pair)[1]] = (*pair)[0];
+        ++pair;
+    }
+}
+
+void _RespawnCreatureIfNeeded(Creature *cr, uint32 entry)
+{
+    if (cr)
+    {
+        cr->UpdateEntry(entry); // SetOriginalEntry as used before may lead to crash
+        if (entry != cr->GetEntry() || !cr->isAlive())
+            cr->Respawn(true);
+        cr->SetVisible(true);
+    }
+}
+
+bool OutdoorPvPWG::SetupOutdoorPvP()
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+        return false;
+    }
+
+    //load worlstates
+    QueryResult result = CharacterDatabase.PQuery("SELECT `entry`, `value` from `worldstates` where `entry` in ('31001','31002','31003') order by `entry`");
+     
+    m_WSSaveTimer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+
+    if (result)
+    {
+        do
+        {
+            Field *fields = result->Fetch();
+            switch (fields[0].GetUInt32())
+            {
+                case 31001:
+                    m_wartime = fields[1].GetBool();
+                    break;
+                case 31002:
+                    m_timer = fields[1].GetUInt32();
+                    break;
+                case 31003:
+                    m_defender = TeamId(fields[1].GetUInt32());
+                    break;
+            }
+        }while(result->NextRow());
+    }
+    else
+    {
+        m_wartime = false;
+        m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME) * MINUTE * IN_MILLISECONDS;
+        m_defender = TeamId(rand()%2);
+    }
+
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    m_changeDefender = false;
+    m_workshopCount[TEAM_ALLIANCE] = 0;
+    m_workshopCount[TEAM_HORDE] = 0;
+    m_tenacityStack = 0;
+    m_gate = NULL;
+
+    std::list<uint32> engGuids;
+    std::list<uint32> spiritGuids;
+
+    // Store Eng, spirit guide guids and questgiver for later use
+    result = WorldDatabase.PQuery("SELECT guid, id FROM creature WHERE creature.map=571"
+        " AND creature.id IN (%u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u);",
+        CRE_ENG_A, CRE_ENG_H, CRE_SPI_A, CRE_SPI_H, 31101, 31051, 31102, 31052,
+        31107, 31109, 31151, 31153, 31106, 31108, 31053, 31054, 31091, 31036);
+    if (!result)
+        sLog->outError("Cannot find siege workshop master or spirit guides in creature!");
+    else
+    {
+        do
+        {
+            Position posHorde, posAlli;
+            Field *fields = result->Fetch();
+            switch(fields[1].GetUInt32())
+            {
+                case CRE_ENG_A:
+                case CRE_ENG_H:
+                    engGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case CRE_SPI_A:
+                case CRE_SPI_H:
+                    spiritGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case 31051:
+                    posHorde.Relocate(5081.7f, 2173.73f, 365.878f, 0.855211f);
+                    posAlli.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31101:
+                    posHorde.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    posAlli.Relocate(5016.57f, 3677.53f, 362.982f, 5.7525f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31052:
+                    posHorde.Relocate(5100.07f, 2168.89f, 365.779f, 1.97222f);
+                    posAlli.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31102:
+                    posHorde.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    posAlli.Relocate(5030.44f, 3659.82f, 363.194f, 1.83336f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31109:
+                    posHorde.Relocate(5080.4f, 2199.0f, 359.489f, 2.96706f);
+                    posAlli.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31107:
+                    posHorde.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    posAlli.Relocate(5008.64f, 3659.91f, 361.07f, 4.0796f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31153:
+                    posHorde.Relocate(5088.49f, 2188.18f, 365.647f, 5.25344f);
+                    posAlli.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31151:
+                    posHorde.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    posAlli.Relocate(5032.33f, 3680.7f, 363.018f, 3.43167f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31108:
+                    posHorde.Relocate(5095.67f, 2193.28f, 365.924f, 4.93928f);
+                    posAlli.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31106:
+                    posHorde.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    posAlli.Relocate(5032.66f, 3674.28f, 363.053f, 2.9447f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31054:
+                    posHorde.Relocate(5088.61f, 2167.66f, 365.689f, 0.680678f);
+                    posAlli.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31053:
+                    posHorde.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    posAlli.Relocate(5032.44f, 3668.66f, 363.11f, 2.87402f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31036:
+                    posHorde.Relocate(5078.28f, 2183.7f, 365.029f, 1.46608f);
+                    posAlli.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31091:
+                    posHorde.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    posAlli.Relocate(5022.43f, 3659.91f, 361.61f, 1.35426f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                default:
+                    break;
+            }
+        }while(result->NextRow());
+    }
+
+    // Select POI
+    AreaPOIList areaPOIs;
+    float minX = 9999, minY = 9999, maxX = -9999, maxY = -9999;
+    for (uint32 i = 0; i < sAreaPOIStore.GetNumRows(); ++i)
+    {
+        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
+        if (poiInfo && poiInfo->zoneId == ZONE_WINTERGRASP)
+        {
+            areaPOIs.push_back(poiInfo);
+            if (minX > poiInfo->x) minX = poiInfo->x;
+            if (minY > poiInfo->y) minY = poiInfo->y;
+            if (maxX < poiInfo->x) maxX = poiInfo->x;
+            if (maxY < poiInfo->y) maxY = poiInfo->y;
+        }
+    }
+    minX -= 20; minY -= 20; maxX += 20; maxY += 20;
+
+    // Coords: 4290.330078, 1790.359985 - 5558.379883, 4048.889893
+    result = WorldDatabase.PQuery("SELECT guid FROM gameobject,gameobject_template"
+        " WHERE gameobject.map=571"
+        " AND gameobject.position_x>%f AND gameobject.position_y>%f"
+        " AND gameobject.position_x<%f AND gameobject.position_y<%f"
+        " AND gameobject_template.type=33"
+        " AND gameobject.id=gameobject_template.entry",
+        minX, minY, maxX, maxY);
+    if (!result)
+        return false;
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        uint32 guid = fields[0].GetUInt32();
+        GameObjectData const * goData = sObjectMgr->GetGOData(guid);
+        if (!goData) // this should not happen
+            continue;
+
+        float x = goData->posX, y = goData->posY;
+        float minDist = 100;
+        AreaPOIList::iterator poi = areaPOIs.end();
+        for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end(); ++itr)
+        {
+            if (!(*itr)->icon[1]) // note: may for other use
+                continue;
+
+            float dist = (abs((*itr)->x - x) + abs((*itr)->y - y));
+            if (minDist > dist)
+            {
+                minDist = dist;
+                poi = itr;
+            }
+        }
+
+        if (poi == areaPOIs.end())
+            continue;
+
+        // add building to the list
+        TeamId teamId = x > POS_X_CENTER-300 ? getDefenderTeam() : getAttackerTeam();
+        m_buildingStates[guid] = new BuildingState((*poi)->worldState, teamId, getDefenderTeam() != TEAM_ALLIANCE);
+        if ((*poi)->id == 2246)
+            m_gate = m_buildingStates[guid];
+        areaPOIs.erase(poi);
+
+        // add capture point
+        uint32 capturePointEntry = 0;
+
+        switch(goData->id)
+        {    
+            //West Goblin Workshops
+            case 192028: // NW
+            case 192030: // W
+            case 192032: // SW
+                capturePointEntry = 190475;
+                break;
+            //East Goblin Workshops
+            case 192029: // NE
+            case 192031: // E
+            case 192033: // SE
+                capturePointEntry = 190487;
+                break;
+        }
+
+        if (capturePointEntry)
+        {
+            uint32 engGuid = 0;
+            uint32 spiritGuid = 0;
+            // Find closest Eng to Workshop
+            float minDist = 100;
+            for (std::list<uint32>::iterator itr = engGuids.begin(); itr != engGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr->GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    engGuid = *itr;
+                }
+            }
+
+            if (!engGuid)
+            {
+                sLog->outError("Cannot find nearby siege workshop master!");
+                continue;
+            }
+            else
+                engGuids.remove(engGuid);
+            // Find closest Spirit Guide to Workshop
+            minDist = 255;
+            for (std::list<uint32>::iterator itr = spiritGuids.begin(); itr != spiritGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr->GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    spiritGuid = *itr;
+                }
+            }
+
+            // Inside fortress won't be capturable
+            OPvPCapturePointWG *workshop = new OPvPCapturePointWG(this, m_buildingStates[guid]);
+            if (goData->posX < POS_X_CENTER && !workshop->SetCapturePointData(capturePointEntry, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2), goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ))
+            {
+                delete workshop;
+                sLog->outError("Cannot add capture point!");
+                continue;
+            }
+            // West fortress Workshop fix
+            if(goData->id==192028 || goData->id==192029)
+                workshop->m_capturePointGUID = goData->id;
+
+            const CreatureData *creData = sObjectMgr->GetCreatureData(engGuid);
+            if (!creData)
+                continue;
+
+            workshop->m_engEntry = const_cast<uint32*>(&creData->id);
+            const_cast<CreatureData*>(creData)->displayid = 0;
+            workshop->m_engGuid = engGuid;
+
+            // Back spirit is linked to one of the inside workshops, 1 workshop wont have spirit
+            if (spiritGuid)
+            {
+                spiritGuids.remove(spiritGuid);
+
+                const CreatureData *spiritData = sObjectMgr->GetCreatureData(spiritGuid);
+                if (!spiritData)
+                    continue;
+
+                workshop->m_spiEntry = const_cast<uint32*>(&spiritData->id);
+                const_cast<CreatureData*>(spiritData)->displayid = 0;
+                workshop->m_spiGuid = spiritGuid;
+            }
+            else
+                workshop->m_spiGuid = 0;
+            workshop->m_workshopGuid = guid;
+            AddCapturePoint(workshop);
+            m_buildingStates[guid]->type = BUILDING_WORKSHOP;
+            workshop->SetTeamByBuildingState();
+        }
+    }while(result->NextRow());
+
+    engGuids.clear();
+    spiritGuids.clear();
+
+    if (!m_gate)
+    {
+        sLog->outError("Cannot find wintergrasp fortress gate!");
+        return false;
+    }
+
+    // Load Graveyard
+    GraveYardMap::const_iterator graveLow  = sObjectMgr->mGraveYardMap.lower_bound(ZONE_WINTERGRASP);
+    GraveYardMap::const_iterator graveUp   = sObjectMgr->mGraveYardMap.upper_bound(ZONE_WINTERGRASP);
+    for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end();)
+    {
+        if ((*itr)->icon[1] == 8)
+        {
+            // find or create grave yard
+            const WorldSafeLocsEntry *loc = sObjectMgr->GetClosestGraveYard((*itr)->x, (*itr)->y, (*itr)->z, (*itr)->mapId, 0);
+            if (!loc)
+            {
+                ++itr;
+                continue;
+            }
+
+            GraveYardMap::const_iterator graveItr;
+            for (graveItr = graveLow; graveItr != graveUp; ++graveItr)
+                if (graveItr->second.safeLocId == loc->ID)
+                    break;
+            if (graveItr == graveUp)
+            {
+                GraveYardData graveData;
+                graveData.safeLocId = loc->ID;
+                graveData.team = 0;
+                graveItr = sObjectMgr->mGraveYardMap.insert(std::make_pair(ZONE_WINTERGRASP, graveData));
+            }
+
+            for (BuildingStateMap::iterator stateItr = m_buildingStates.begin(); stateItr != m_buildingStates.end(); ++stateItr)
+            {
+                if (stateItr->second->worldState == (*itr)->worldState)
+                {
+                    stateItr->second->graveTeam = const_cast<uint32*>(&graveItr->second.team);
+                    break;
+                }
+            }
+            areaPOIs.erase(itr++);
+        }
+        else
+            ++itr;
+    }
+
+    //Titan Relic
+    sObjectMgr->AddGOData(192829, 571, 5440.0f, 2840.8f, 420.43f + 10.0f, 0);
+
+    _LoadTeamPair(m_goDisplayPair, OutdoorPvPWGGODisplayPair);
+    _LoadTeamPair(m_creEntryPair, OutdoorPvPWGCreEntryPair);
+
+    sWorld->SendWintergraspState();
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+
+    RemoveOfflinePlayerWGAuras();
+
+    RegisterZone(ZONE_WINTERGRASP);
+
+    if (m_wartime)
+    {
+        uint32 m_WSTimer = m_timer;
+        StartBattle();
+        m_timer = m_WSTimer;
+    }
+
+    return true;
+}
+
+void OutdoorPvPWG::ProcessEvent(GameObject *obj, uint32 eventId)
+{     
+    if (obj->GetEntry() == 192829) // Titan Relic
+    {
+        if (obj->GetGOInfo()->goober.eventId == eventId && isWarTime() && /*MaingateDestroyed==true &&*/ m_gate &&  m_gate->damageState == DAMAGE_DESTROYED)
+        {
+            m_changeDefender = true;
+            m_timer = 0;
+        }
+    }
+    else if (obj->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(obj->GetDBTableGUIDLow());
+        if (itr == m_buildingStates.end())
+            return;
+        std::string msgStr;
+        switch(eventId)
+        { // TODO - Localized msgs of GO names
+            case 19672: case 19675: // Flamewatch Tower
+                msgStr = "Flamewatch";
+                break;
+            case 18553: case 19677: // Shadowsight Tower
+                msgStr = "Shadowsight";
+                break;
+            case 19673: case 19676: // Winter's Edge Tower
+                msgStr = "Winter's Edge";
+                break;
+            case 19776: case 19778: // E Workshop damaged
+                msgStr = "Sunken Ring";
+                break;
+            case 19777: case 19779: // W Workshop damaged
+                msgStr = "Broken Temple";
+                break;
+            case 19782: case 19786: // NW Workshop damaged
+                msgStr = "north-western";
+                break;
+            case 19783: case 19787: // NE Workshop damaged
+                msgStr = "north-eastern";
+                break;
+            case 19784: case 19788: // SW Workshop damaged
+                msgStr = "Westpark";
+                break;
+            case 19785: case 19789: // SE Workshop damaged
+                msgStr = "Eastpark";
+                break;
+            case 19657: case 19661: // NW Wintergrasp Keep Tower damaged
+                msgStr = "north-western";
+                break;
+            case 19658: case 19663: // NE Wintergrasp Keep Tower damaged
+                msgStr = "north-eastern";
+                break;
+            case 19659: case 19662: // SW Wintergrasp Keep Tower damaged
+                msgStr = "south-western";
+                break;
+            case 19660: case 19664: // SE Wintergrasp Keep Tower damaged
+                msgStr = "south-eastern";
+                break;
+            default:
+                msgStr = "";
+        }
+
+        BuildingState *state = itr->second;
+        if (eventId == obj->GetGOInfo()->building.damagedEvent)
+        {
+           if (obj->GetEntry()==191810)
+            {
+               //obj->TakenDamage(30000);
+               MaingateDestroyed=true;
+            }
+
+            state->damageState = DAMAGE_DAMAGED;
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DAMAGED), msgStr.c_str(), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    break;
+                case BUILDING_WALL:
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+                        else 
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    break;
+                case BUILDING_TOWER:
+                    ++m_towerDamagedCount[state->GetTeam()];
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DAMAGED), msgStr.c_str());
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    break;
+            }
+        }
+        else if (eventId == obj->GetGOInfo()->building.destroyedEvent)
+        {
+            state->damageState = DAMAGE_DESTROYED;
+
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                    ModifyWorkshopCount(state->GetTeam(), false);
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DESTROYED), msgStr.c_str(), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    break;
+                case BUILDING_WALL:
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else 
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    break;
+                case BUILDING_TOWER:
+                     --m_towerDamagedCount[state->GetTeam()];
+                     ++m_towerDestroyedCount[state->GetTeam()];
+                     if (state->GetTeam() == getAttackerTeam())
+                     {
+                        TeamCastSpell(getAttackerTeam(), -SPELL_TOWER_CONTROL);
+                        TeamCastSpell(getDefenderTeam(), -SPELL_TOWER_CONTROL);
+                        uint32 attStack = 3 - m_towerDestroyedCount[getAttackerTeam()];
+                        if (m_towerDestroyedCount[getAttackerTeam()])
+                            for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), m_towerDestroyedCount[getAttackerTeam()]);
+
+                        if (attStack!=0)
+						{
+                            for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), attStack);
+						}
+                         else
+                        {
+                            if (m_timer < 600000)
+                                m_timer = 0;
+                            else
+                                m_timer = m_timer - 600000; // - 10 mins
+                        }
+                    }
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DESTROYED), msgStr.c_str());
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+
+                     // Add Support of Quests Toppling the Towers & Southern Sabotage
+						if (obj->GetEntry()==190356 || obj->GetEntry()==190357 || obj->GetEntry()==190358)
+                        (*itr)->RewardPlayerAndGroupAtEvent(TOWER_PVP_DESTROYED, obj);
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress destroyed Siege
+                    }
+                    break;
+            }
+            BroadcastStateChange(state);
+        }
+    }
+}
+
+void OutdoorPvPWG::RemoveOfflinePlayerWGAuras()
+{
+    // if server crashed while in battle there could be players with rank or tenacity
+    CharacterDatabase.PExecute("DELETE FROM character_aura WHERE spell IN (%u, %u, %u, %u, %u)",
+         SPELL_RECRUIT, SPELL_CORPORAL, SPELL_LIEUTENANT, SPELL_TENACITY, SPELL_TOWER_CONTROL);
+}
+
+void OutdoorPvPWG::ModifyWorkshopCount(TeamId team, bool add)
+{
+    if (team == TEAM_NEUTRAL)
+        return;
+
+    if (add)
+        ++m_workshopCount[team];
+    else if (m_workshopCount[team])
+        --m_workshopCount[team];
+    else
+        sLog->outError("OutdoorPvPWG::ModifyWorkshopCount: negative workshop count!");
+
+    SendUpdateWorldState(MaxVehNumWorldState[team], m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP);
+}
+
+uint32 OutdoorPvPWG::GetCreatureEntry(uint32 guidlow, const CreatureData *data)
+{
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+    {
+        TeamPairMap::const_iterator itr = m_creEntryPair.find(data->id);
+        if (itr != m_creEntryPair.end())
+        {
+            const_cast<CreatureData*>(data)->displayid = 0;
+            return itr->second;
+        }
+    }
+    return data->id;
+}
+
+OutdoorPvPWGCreType OutdoorPvPWG::GetCreatureType(uint32 entry) const
+{
+    // VEHICLES, GUARDS and TURRETS gives kill credit
+    // OTHER Not in wartime
+    // TURRET Only during wartime
+    // SPECIAL like "OTHER" but no despawn conditions
+    // Entries like Case A: Case: B have their own despawn function
+    switch(entry)
+    {
+        case 27881: // Catapult
+        case 28094: // Demolisher
+        case 28312: // Alliance Siege Engine
+        case 32627: // Horde Siege Engine
+        case 28319: // Siege turret
+        case 32629: // Siege turret
+            return CREATURE_SIEGE_VEHICLE;
+        case 28366: // Wintergrasp Tower cannon
+            return CREATURE_TURRET;
+        case CRE_ENG_A: // Alliance Engineer
+        case CRE_ENG_H: // Horde Engineer
+            return CREATURE_ENGINEER;
+        case 30739:case 30740: // Champions
+        case 32307:case 32308: // Guards
+            return CREATURE_GUARD;
+        case CRE_SPI_A: // Dwarven Spirit Guide
+        case CRE_SPI_H: // Taunka Spirit Guide
+            return CREATURE_SPIRIT_GUIDE;
+        case 6491: // Spirit Healers
+            return CREATURE_SPIRIT_HEALER;
+        case 31101:case 31051: // Hoodoo Master & Sorceress
+        case 31102:case 31052: // Vieron Blazefeather & Bowyer
+        case 31107:case 31109: // Lieutenant & Senior Demolitionist
+        case 31151:case 31153: // Tactical Officer
+        case 31106:case 31108: // Siegesmith & Siege Master
+        case 31053:case 31054: // Primalist & Anchorite
+        case 31091:case 31036: // Commander
+            return CREATURE_QUESTGIVER;
+        case 32615:case 32626: // Warbringer && Brigadier General
+        case 32296:case 32294: // Quartermaster
+        case 39173:case 39172: // Ros'slai && Marshal Magruder
+        case 30870:case 30869: // Flight Masters
+            return CREATURE_SPECIAL;
+        default:
+            return CREATURE_OTHER; // Revenants, Elementals, etc
+    }
+}
+
+void OutdoorPvPWG::OnCreatureCreate(Creature *creature)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->isSummon())
+                return;
+
+            TeamId team;
+            if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
+                team = TEAM_ALLIANCE;
+            else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
+                team = TEAM_HORDE;
+            else
+                return;
+
+            if (uint32 engLowguid = GUID_LOPART(((TempSummon*)creature)->GetSummonerGUID()))
+            {
+                if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(engLowguid))
+                {
+                    if (CanBuildVehicle(workshop))
+                        m_vehicles[team].insert(creature);
+                    else
+                    {
+                        creature->setDeathState(DEAD);
+                        creature->SetRespawnTime(DAY);
+                        return;
+                    }
+                }
+
+                if (m_tenacityStack > 0 && team == TEAM_ALLIANCE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, m_tenacityStack);
+                else if (m_tenacityStack < 0 && team == TEAM_HORDE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, -m_tenacityStack);
+            }
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+            break;
+        }
+        case CREATURE_QUESTGIVER:
+            m_questgivers[creature->GetDBTableGUIDLow()] = creature;
+            break;
+        case CREATURE_ENGINEER:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_engineer = creature;
+                        break;
+                    }
+            }
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_spiritguide = creature;
+                        break;
+                    }
+            }
+            creature->CastSpell(creature, SPELL_SPIRITUAL_IMMUNITY, true);
+        case CREATURE_SPIRIT_HEALER:
+        case CREATURE_TURRET:
+        case CREATURE_OTHER:
+            UpdateCreatureInfo(creature);
+        default:
+            m_creatures.insert(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnCreatureRemove(Creature *creature)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->isSummon())
+                return;
+
+            TeamId team;
+            // the faction may be changed in uncharm
+            // TODO: now you have to wait until the corpse of vehicle disappear to build a new one
+            if (m_vehicles[TEAM_ALLIANCE].erase(creature))
+                team = TEAM_ALLIANCE;
+            else if (m_vehicles[TEAM_HORDE].erase(creature))
+                team = TEAM_HORDE;
+            else
+                return;
+
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+            break;
+        }
+        case CREATURE_QUESTGIVER:
+            m_questgivers.erase(creature->GetDBTableGUIDLow());
+            break;
+        case CREATURE_ENGINEER:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_engineer = NULL;
+                        break;
+                    }
+            }
+            m_creatures.erase(creature); // prevents crash, but i think it's wrong
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_spiritguide = NULL;
+                        break;
+                    }
+            }
+            m_creatures.erase(creature); // prevents crash, but i think it's wrong
+            break;
+        default:
+            m_creatures.erase(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectCreate(GameObject *go)
+{
+    OutdoorPvP::OnGameObjectCreate(go);
+
+    if (UpdateGameObjectInfo(go))
+        m_gobjects.insert(go);
+
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
+        if (itr != m_buildingStates.end())
+        {
+            itr->second->building = go;
+            if (go->GetGOInfo()->displayId == 7878 || go->GetGOInfo()->displayId == 7900)
+                itr->second->type = BUILDING_TOWER;
+            if (itr->second->damageState == DAMAGE_INTACT && !itr->second->health)
+            {
+                itr->second->health = go->GetGOValue()->building.health;
+                go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+            else
+            {
+                go->GetGOValue()->building.health = itr->second->health;
+                if (itr->second->damageState == DAMAGE_DAMAGED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+                else if (itr->second->damageState == DAMAGE_DESTROYED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectRemove(GameObject *go)
+{
+    OutdoorPvP::OnGameObjectRemove(go);
+
+    if (UpdateGameObjectInfo(go))
+        m_gobjects.erase(go);
+
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
+        if (itr != m_buildingStates.end())
+            itr->second->building = NULL;
+    }
+}
+
+void OutdoorPvPWG::UpdateAllWorldObject()
+{
+    // update cre and go factions
+    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
+        UpdateGameObjectInfo(*itr);
+    for (CreatureSet::iterator itr = m_creatures.begin(); itr != m_creatures.end(); ++itr)
+        UpdateCreatureInfo(*itr);
+    for (QuestGiverMap::iterator itr = m_questgivers.begin(); itr != m_questgivers.end(); ++itr)
+        UpdateQuestGiverPosition((*itr).first, (*itr).second);
+
+    // rebuild and update building states
+    RebuildAllBuildings();
+
+    // update capture points
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            workshop->SetTeamByBuildingState();
+}
+
+void OutdoorPvPWG::RebuildAllBuildings()
+{
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+    {
+        if (itr->second->building && itr->second->building->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+        {
+            UpdateGameObjectInfo(itr->second->building);
+            itr->second->building->Rebuild();
+            itr->second->health = itr->second->building->GetGOValue()->building.health;
+            itr->second->damageState = DAMAGE_INTACT;
+        }
+        else
+            itr->second->health = 0;
+        itr->second->SetTeam(getDefenderTeam() == TEAM_ALLIANCE ? OTHER_TEAM(itr->second->defaultTeam) : itr->second->defaultTeam);
+    }
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+}
+
+void OutdoorPvPWG::SendInitWorldStatesTo(Player *player) const
+{
+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_buildingStates.size()*8)));
+    data << uint32(571);
+    data << uint32(ZONE_WINTERGRASP);
+    data << uint32(0);
+    data << uint16(4+2+4+m_buildingStates.size());
+
+    data << uint32(3803) << uint32(getDefenderTeam() == TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3802) << uint32(getDefenderTeam() != TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3801) << uint32(isWarTime() ? 0 : 1);
+    data << uint32(3710) << uint32(isWarTime() ? 1 : 0);
+
+    for (uint32 i = 0; i < 2; ++i)
+        data << ClockWorldState[i] << m_clock[i];
+
+    data << uint32(3490) << uint32(m_vehicles[TEAM_HORDE].size());
+    data << uint32(3491) << m_workshopCount[TEAM_HORDE] * MAX_VEHICLE_PER_WORKSHOP;
+    data << uint32(3680) << uint32(m_vehicles[TEAM_ALLIANCE].size());
+    data << uint32(3681) << m_workshopCount[TEAM_ALLIANCE] * MAX_VEHICLE_PER_WORKSHOP;
+
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+        itr->second->FillData(data);
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        BroadcastPacket(data);
+}
+
+void OutdoorPvPWG::BroadcastStateChange(BuildingState *state) const
+{
+    if (m_sendUpdate)
+        for (uint32 team = 0; team < 2; ++team)
+            for (PlayerSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
+                state->SendUpdate(*p_itr);
+}
+
+// Called at Start and Battle End
+bool OutdoorPvPWG::UpdateCreatureInfo(Creature *creature)
+{
+    if (!creature)
+        return false;
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_TURRET:
+            if (isWarTime())
+            {
+                if (!creature->isAlive())
+                    creature->Respawn(true);
+                creature->setFaction(WintergraspFaction[getDefenderTeam()]);
+                creature->SetVisible(true);
+            }
+            else
+            {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->SetVisible(false);
+                creature->setFaction(35);
+            }
+            return false;
+        case CREATURE_OTHER:
+            if (isWarTime())
+            {
+                creature->SetVisible(false);
+                creature->setFaction(35);
+            }
+            else
+            {
+                creature->RestoreFaction();
+                creature->SetVisible(true);
+            }
+            return false;
+        case CREATURE_SPIRIT_GUIDE:
+            /*Vehicle teleport system*/
+            pMap = creature->GetMap();
+            if (isWarTime())
+            {
+				/* Uncomment if want to enable ressurect for both factions at graveyard
+                if (creature->GetAreaId() == 4575) // Select Fortress Spirit
+                {
+                    FortressSpirit = creature;
+                    if (getDefenderTeam() == TEAM_ALLIANCE) // Fortress Spirit Alliance
+                            FortressSpirit->UpdateEntry(CRE_SPI_A);
+                    if (getDefenderTeam() == TEAM_HORDE) // Fortress Spirit Horde
+                        FortressSpirit->UpdateEntry(CRE_SPI_H);
+                }*/
+                creature->SetVisible(true);
+            }
+            else
+                creature->SetVisible(false);
+
+            return false;
+        case CREATURE_SPIRIT_HEALER:
+            creature->SetVisible(isWarTime() ? false : true);
+            return false;
+        case CREATURE_ENGINEER:
+           return false;
+        case CREATURE_SIEGE_VEHICLE:
+            if (!isWarTime())
+            {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->DisappearAndDie();
+            }
+            return false;
+        case CREATURE_GUARD:
+        case CREATURE_SPECIAL:
+        {
+            TeamPairMap::const_iterator itr = m_creEntryPair.find(creature->GetCreatureData()->id);
+            if (itr != m_creEntryPair.end())
+            {
+                entry = getDefenderTeam() == TEAM_ALLIANCE ? itr->second : itr->first;
+                _RespawnCreatureIfNeeded(creature, entry);
+            }
+            return false;
+        }
+        default:
+            return false;
+    }
+}
+
+bool OutdoorPvPWG::UpdateQuestGiverPosition(uint32 guid, Creature *creature)
+{
+    assert(guid);
+    Position pos = m_qgPosMap[std::pair<uint32, bool>(guid, getDefenderTeam() == TEAM_HORDE)];
+
+    if (creature && creature->IsInWorld())
+    {
+        // if not questgiver or position is the same, do nothing
+        if (creature->GetPositionX() == pos.GetPositionX() &&
+            creature->GetPositionY() == pos.GetPositionY() &&
+            creature->GetPositionZ() == pos.GetPositionZ())
+            return false;
+
+        if (creature->isAlive() && creature->isInCombat())
+        {
+            creature->CombatStop(true);
+            creature->getHostileRefManager().deleteReferences();
+        }
+        creature->SetHomePosition(pos);
+        creature->DestroyForNearbyPlayers();
+        if (!creature->GetMap()->IsLoaded(pos.GetPositionX(), pos.GetPositionY()))
+            creature->GetMap()->LoadGrid(pos.GetPositionX(), pos.GetPositionY());
+        creature->GetMap()->CreatureRelocation(creature, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
+        if (!creature->isAlive())
+            creature->Respawn(true);
+    }
+    else
+        sObjectMgr->MoveCreData(guid, 571, pos);
+
+    return true;
+}
+
+// Return false = Need to rebuild at battle End/Start
+//        true  = no need to rebuild (ie: Banners or teleporters)
+bool OutdoorPvPWG::UpdateGameObjectInfo(GameObject *go) const
+{
+    uint32 attFaction = 35;
+    uint32 defFaction = 35;
+
+    if (isWarTime())
+    {
+        attFaction = WintergraspFaction[getAttackerTeam()];
+        defFaction = WintergraspFaction[getDefenderTeam()];
+    }
+
+    switch(go->GetGOInfo()->displayId)
+    {
+        case 8244: // Defender's Portal - Vehicle Teleporter
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getDefenderTeam()]);
+            return true;
+        case 7967: // Titan relic
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getAttackerTeam()]);
+            return true;
+
+        case 8165: // Wintergrasp Keep Door
+        case 7877: // Wintergrasp Fortress Wall
+        case 7878: // Wintergrasp Keep Tower
+        case 7906: // Wintergrasp Fortress Gate
+        case 7909: // Wintergrasp Wall
+            go->SetUInt32Value(GAMEOBJECT_FACTION, defFaction);
+            return false;
+        case 7900: // Flamewatch Tower - Shadowsight Tower - Winter's Edge Tower
+            go->SetUInt32Value(GAMEOBJECT_FACTION, attFaction);
+            return false;
+        case 8208: // Goblin Workshop
+            OPvPCapturePointWG *workshop = GetWorkshopByGOGuid(go->GetGUID());
+            if (workshop)
+                go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[workshop->m_buildingState->GetTeam()]);
+            return false;
+    }
+
+    // Note: this is only for test, still need db support
+    TeamPairMap::const_iterator itr = m_goDisplayPair.find(go->GetGOInfo()->displayId);
+    if (itr != m_goDisplayPair.end())
+    {
+        go->SetUInt32Value(GAMEOBJECT_DISPLAYID, getDefenderTeam() == TEAM_ALLIANCE ?
+            itr->second : itr->first);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPWG::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (plr->getLevel() < 75)
+        {
+            plr->CastSpell(plr, SPELL_TELEPORT_DALARAN, true);
+            return;
+        }
+        if (plr->getLevel() > 74)
+        {
+            if (!plr->HasAura(SPELL_RECRUIT) && !plr->HasAura(SPELL_CORPORAL)
+                && !plr->HasAura(SPELL_LIEUTENANT))
+                plr->CastSpell(plr, SPELL_RECRUIT, true);
+
+            if (plr->GetTeamId() == getAttackerTeam())
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            else
+                if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+        }
+    }
+
+    SendInitWorldStatesTo(plr);
+    OutdoorPvP::HandlePlayerEnterZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+// Reapply Auras if needed
+void OutdoorPvPWG::HandlePlayerResurrects(Player * plr, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (plr->getLevel() > 74)
+        {
+            // Tenacity
+            if (plr->GetTeamId() == TEAM_ALLIANCE && m_tenacityStack > 0 ||
+                plr->GetTeamId() == TEAM_HORDE && m_tenacityStack < 0)
+            {
+                if (plr->HasAura(SPELL_TENACITY))
+                    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+                int32 newStack = m_tenacityStack < 0 ? -m_tenacityStack : m_tenacityStack;
+                if (newStack > 20)
+                    newStack = 20;
+                plr->SetAuraStack(SPELL_TENACITY, plr, newStack);
+            }
+
+            // Tower Control
+            if (plr->GetTeamId() == getAttackerTeam())
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            else
+                if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+        }
+    }
+    OutdoorPvP::HandlePlayerResurrects(plr, zone);
+}
+
+void OutdoorPvPWG::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (!plr->GetSession()->PlayerLogout())
+    {
+        if (plr->GetVehicle()) // dismiss in change zone case
+            plr->GetVehicle()->Dismiss();
+        plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+    }
+    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+void OutdoorPvPWG::PromotePlayer(Player *killer) const
+{
+    Aura * aur;
+    if (aur = killer->GetAura(SPELL_RECRUIT))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_RECRUIT);
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK1);
+        }
+        else
+            killer->CastSpell(killer, SPELL_RECRUIT, true);
+    }
+    else if (aur = killer->GetAura(SPELL_CORPORAL))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_CORPORAL);
+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK2);
+        }
+        else
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+    }
+}
+
+void OutdoorPvPWG::HandleKill(Player *killer, Unit *victim)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED) || !isWarTime())
+        return;
+
+    bool ok = false;
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim->getLevel() >= 70)
+            ok = true;
+        killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+    }
+    else
+    {
+        switch(GetCreatureType(victim->GetEntry()))
+        {
+            case CREATURE_SIEGE_VEHICLE:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL_V, victim);
+                ok = true;
+                break;
+            case CREATURE_GUARD:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+                ok = true;
+                break;
+            case CREATURE_TURRET:
+                ok = true;
+                break;
+        }
+    }
+
+    if (ok)
+    {
+        if (Group *pGroup = killer->GetGroup())
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                if (itr->getSource()->IsAtGroupRewardDistance(killer) && itr->getSource()->getLevel() > 74)
+                    PromotePlayer(itr->getSource());
+        else if (killer->getLevel() > 74)
+            PromotePlayer(killer);
+    }
+}
+
+// Recalculates Tenacity and applies it to Players / Vehicles
+void OutdoorPvPWG::UpdateTenacityStack()
+{
+    if (!isWarTime())
+        return;
+
+    TeamId team = TEAM_NEUTRAL;
+    uint32 allianceNum = 0;
+    uint32 hordeNum = 0;
+    int32 newStack = 0;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_ALLIANCE].begin(); itr != m_players[TEAM_ALLIANCE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++allianceNum;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_HORDE].begin(); itr != m_players[TEAM_HORDE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++hordeNum;
+
+    if (allianceNum && hordeNum)
+        if (allianceNum < hordeNum)
+            newStack = int32((float(hordeNum) / float(allianceNum) - 1)*4); // positive, should cast on alliance
+        else if (allianceNum > hordeNum)
+            newStack = int32((1 - float(allianceNum) / float(hordeNum))*4); // negative, should cast on horde
+ 
+    if (newStack == m_tenacityStack)
+        return;
+
+    if (m_tenacityStack > 0 && newStack <= 0) // old buff was on alliance
+        team = TEAM_ALLIANCE;
+    else if (m_tenacityStack < 0 && newStack >= 0) // old buff was on horde
+        team = TEAM_HORDE;
+
+    m_tenacityStack = newStack;
+
+    // Remove old buff
+    if (team != TEAM_NEUTRAL)
+    {
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
+    }
+
+    // Apply new buff
+    if (newStack)
+    {
+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
+        if (newStack < 0)
+            newStack = -newStack;
+        if (newStack > 20)
+            newStack = 20;
+
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->SetAuraStack(SPELL_TENACITY, (*itr), newStack);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->SetAuraStack(SPELL_TENACITY_VEHICLE, (*itr), newStack);
+    }
+}
+
+void OutdoorPvPWG::UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod)
+{
+    uint32 value = timer%mod;
+    if (m_clock[digit] != value)
+    {
+        m_clock[digit] = value;
+        SendUpdateWorldState(ClockWorldState[digit], uint32(timer + time(NULL)));
+        sWorld->SetWintergrapsTimer(uint32(timer + time(NULL)), digit);
+    }
+}
+
+void OutdoorPvPWG::UpdateClock()
+{
+    uint32 timer = m_timer / 1000;
+    if (!isWarTime())
+        UpdateClockDigit(timer, 1, 10);
+    else
+        UpdateClockDigit(timer, 0, 10);
+
+    //Announce in all world, comment it if you don't like/need it
+    // Announce 30 minutes left
+    if ((m_timer>1800000) && (m_timer<1802000) && (m_wartime==false))
+        sWorld->SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_30);
+
+    // Announce 10 minutes left
+    if ((m_timer>600000) && (m_timer<602000) && (m_wartime==false))
+        sWorld->SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_10);
+}
+
+bool OutdoorPvPWG::Update(uint32 diff)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return false;
+
+    if (m_timer > diff)
+    {
+        m_timer -= diff;
+
+        if (isWarTime())
+        {
+            OutdoorPvP::Update(diff); // update capture points
+
+            /*********************************************************/
+            /***      BATTLEGROUND VEHICLE TELEPORTER SYSTEM       ***/
+            /*********************************************************/
+            if (pMap)
+            {
+                Map::PlayerList const &PlayerList = pMap->GetPlayers();
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (getDefenderTeam() == TEAM_ALLIANCE)
+                    {
+                        if (i->getSource()->ToPlayer()->GetTeam() == ALLIANCE)
+                        {
+                            if (i->getSource()->GetDistance2d(5314.51f, 2703.69f) <= 5 && i->getSource()->IsOnVehicle(i->getSource()->GetVehicleCreatureBase()) && i->getSource()->isAlive())
+                            {
+                                Creature* Old = i->getSource()->GetVehicleCreatureBase();
+                                if (Old->GetEntry() == 28319) // Alliance Turret
+                                {
+                                    i->getSource()->ExitVehicle();
+                                    i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    Old->SetVisible(true);
+                                    Old->ToTempSummon()->UnSummon();
+                                }
+                                else
+                                {
+                                    Unit* Driver = Old->GetVehicleKit()->GetPassenger(0);
+                                    Unit* Passenger1 = Old->GetVehicleKit()->GetPassenger(1);
+                                    Unit* Passenger2 = Old->GetVehicleKit()->GetPassenger(2);
+                                    Unit* Passenger3 = Old->GetVehicleKit()->GetPassenger(3);
+                                    if (Driver && Driver->isAlive())
+                                    {
+                                        Creature* New = i->getSource()->SummonCreature(Old->GetEntry(), 5141.191406f, 2841.045410f, 408.703217f, 3.163321f, TEMPSUMMON_MANUAL_DESPAWN);
+                                        New->SetPower(POWER_MANA, Old->GetPower(POWER_MANA));
+                                        New->SetPower(POWER_RAGE, Old->GetPower(POWER_RAGE));
+                                        New->SetPower(POWER_FOCUS, Old->GetPower(POWER_FOCUS));
+                                        New->SetPower(POWER_ENERGY, Old->GetPower(POWER_ENERGY));
+                                        New->SetHealth(Old->GetHealth());
+                                        New->SetRespawnTime(Old->GetRespawnTime());
+                                        Old->GetVehicleKit()->Uninstall();
+                                        Old->SetVisible(true);
+                                        Old->ForcedDespawn();
+                                        Vehicle *vehicle = New->GetVehicleKit();
+                                        Driver->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        Driver->EnterVehicle(vehicle, 0);
+                                        if (Passenger1 && Passenger1->isAlive())
+                                            Passenger1->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        if (Passenger2 && Passenger2->isAlive())
+                                            Passenger2->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        if (Passenger3 && Passenger3->isAlive())
+                                            Passenger3->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    }
+                                }
+                            }
+                            if (i->getSource()->GetDistance2d(5316.25f, 2977.04f) <= 5 && i->getSource()->IsOnVehicle(i->getSource()->GetVehicleCreatureBase()))
+                            {
+                                Creature* Old = i->getSource()->GetVehicleCreatureBase();
+                                if (Old->GetEntry() == 28319) // Alliance Turret
+                                {
+                                    i->getSource()->ExitVehicle();
+                                    i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    Old->SetVisible(true);
+                                    Old->ToTempSummon()->UnSummon();
+                                }
+                                else
+                                {
+                                    Unit* Driver = Old->GetVehicleKit()->GetPassenger(0);
+                                    Unit* Passenger1 = Old->GetVehicleKit()->GetPassenger(1);
+                                    Unit* Passenger2 = Old->GetVehicleKit()->GetPassenger(2);
+                                    Unit* Passenger3 = Old->GetVehicleKit()->GetPassenger(3);
+                                    if (Driver && Driver->isAlive())
+                                    {
+                                        Creature* New = i->getSource()->SummonCreature(Old->GetEntry(), 5141.191406f, 2841.045410f, 408.703217f, 3.163321f, TEMPSUMMON_MANUAL_DESPAWN);
+                                        New->SetPower(POWER_MANA, Old->GetPower(POWER_MANA));
+                                        New->SetPower(POWER_RAGE, Old->GetPower(POWER_RAGE));
+                                        New->SetPower(POWER_FOCUS, Old->GetPower(POWER_FOCUS));
+                                        New->SetPower(POWER_ENERGY, Old->GetPower(POWER_ENERGY));
+                                        New->SetHealth(Old->GetHealth());
+                                        New->SetRespawnTime(Old->GetRespawnTime());
+                                        Old->GetVehicleKit()->Uninstall();
+                                        Old->SetVisible(true);
+                                        Old->ForcedDespawn();
+                                        Vehicle *vehicle = New->GetVehicleKit();
+                                        Driver->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        Driver->EnterVehicle(vehicle, 0);
+                                        if (Passenger1 && Passenger1->isAlive())
+                                            Passenger1->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        if (Passenger2 && Passenger2->isAlive())
+                                            Passenger2->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        if (Passenger3 && Passenger3->isAlive())
+                                            Passenger3->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    }
+                                }
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (i->getSource()->ToPlayer()->GetTeam() == HORDE)
+                        {
+                            if (i->getSource()->GetDistance2d(5314.51f, 2703.69f) <= 5 && i->getSource()->IsOnVehicle(i->getSource()->GetVehicleCreatureBase()) && i->getSource()->isAlive())
+                            {
+                                Creature* Old = i->getSource()->GetVehicleCreatureBase();
+                                if (Old->GetEntry() == 32629) // Horde Turret
+                                {
+                                    i->getSource()->ExitVehicle();
+                                    i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    Old->SetVisible(true);
+                                    Old->ToTempSummon()->UnSummon();
+                                }
+                                else
+                                {
+                                    Unit* Driver = Old->GetVehicleKit()->GetPassenger(0);
+                                    Unit* Passenger1 = Old->GetVehicleKit()->GetPassenger(1);
+                                    Unit* Passenger2 = Old->GetVehicleKit()->GetPassenger(2);
+                                    Unit* Passenger3 = Old->GetVehicleKit()->GetPassenger(3);
+                                    if (Driver && Driver->isAlive())
+                                    {
+                                        Creature* New = i->getSource()->SummonCreature(Old->GetEntry(), 5141.191406f, 2841.045410f, 408.703217f, 3.163321f, TEMPSUMMON_MANUAL_DESPAWN);
+                                        New->SetPower(POWER_MANA, Old->GetPower(POWER_MANA));
+                                        New->SetPower(POWER_RAGE, Old->GetPower(POWER_RAGE));
+                                        New->SetPower(POWER_FOCUS, Old->GetPower(POWER_FOCUS));
+                                        New->SetPower(POWER_ENERGY, Old->GetPower(POWER_ENERGY));
+                                        New->SetHealth(Old->GetHealth());
+                                        New->SetRespawnTime(Old->GetRespawnTime());
+                                        Old->GetVehicleKit()->Uninstall();
+                                        Old->SetVisible(true);
+                                        Old->ForcedDespawn();
+                                        Vehicle *vehicle = New->GetVehicleKit();
+                                        Driver->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        Driver->EnterVehicle(vehicle, 0);
+                                        if (Passenger1 && Passenger1->isAlive())
+                                            Passenger1->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        if (Passenger2 && Passenger2->isAlive())
+                                            Passenger2->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        if (Passenger3 && Passenger3->isAlive())
+                                            Passenger3->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    }
+                                }
+                            }
+                            if (i->getSource()->GetDistance2d(5316.25f, 2977.04f) <= 5 && i->getSource()->IsOnVehicle(i->getSource()->GetVehicleCreatureBase()))
+                            {
+                                Creature* Old = i->getSource()->GetVehicleCreatureBase();
+                                if (Old->GetEntry() == 32629) // Horde Turret
+                                {
+                                    i->getSource()->ExitVehicle();
+                                    i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    Old->SetVisible(true);
+                                    Old->ToTempSummon()->UnSummon();
+                                }
+                                else
+                                {
+                                    Unit* Driver = Old->GetVehicleKit()->GetPassenger(0);
+                                    Unit* Passenger1 = Old->GetVehicleKit()->GetPassenger(1);
+                                    Unit* Passenger2 = Old->GetVehicleKit()->GetPassenger(2);
+                                    Unit* Passenger3 = Old->GetVehicleKit()->GetPassenger(3);
+                                    if (Driver && Driver->isAlive())
+                                    {
+                                        Creature* New = i->getSource()->SummonCreature(Old->GetEntry(), 5141.191406f, 2841.045410f, 408.703217f, 3.163321f, TEMPSUMMON_MANUAL_DESPAWN);
+                                        New->SetPower(POWER_MANA, Old->GetPower(POWER_MANA));
+                                        New->SetPower(POWER_RAGE, Old->GetPower(POWER_RAGE));
+                                        New->SetPower(POWER_FOCUS, Old->GetPower(POWER_FOCUS));
+                                        New->SetPower(POWER_ENERGY, Old->GetPower(POWER_ENERGY));
+                                        New->SetHealth(Old->GetHealth());
+                                        New->SetRespawnTime(Old->GetRespawnTime());
+                                        Old->GetVehicleKit()->Uninstall();
+                                        Old->SetVisible(true);
+                                        Old->ForcedDespawn();
+                                        Vehicle *vehicle = New->GetVehicleKit();
+                                        Driver->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        Driver->EnterVehicle(vehicle, 0);
+                                        if (Passenger1 && Passenger1->isAlive())
+                                            Passenger1->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        if (Passenger2 && Passenger2->isAlive())
+                                            Passenger2->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                        if (Passenger3 && Passenger3->isAlive())
+                                            Passenger3->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            /*********************************************************/
+            /***        BATTLEGROUND RESSURECTION SYSTEM           ***/
+            /*********************************************************/
+
+            //this should be handled by spell system
+            m_LastResurrectTime += diff;
+            if (m_LastResurrectTime >= RESURRECTION_INTERVAL)
+            {
+                if (GetReviveQueueSize())
+                {
+                    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+                    {
+                        Creature* sh = NULL;
+                        for (std::vector<uint64>::const_iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+                        {
+                            Player *plr = sObjectMgr->GetPlayer(*itr2);
+                            if (!plr)
+                                continue;
+                            if (!sh && plr->IsInWorld())
+                            {
+                                sh = plr->GetMap()->GetCreature(itr->first);
+                                // only for visual effect
+                                if (sh)
+                                    // Spirit Heal, effect 117
+                                    sh->CastSpell(sh, SPELL_SPIRIT_HEAL, true);
+                            }
+
+                            // Resurrection visual
+                            if (sh && plr->GetDistance2d(sh) <= 18.0f)
+                            {
+                                plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
+                                m_ResurrectQueue.push_back(*itr2);
+                            }
+                        }
+                        (itr->second).clear();
+                    }
+
+                    m_ReviveQueue.clear();
+                    m_LastResurrectTime = 0;
+                }
+                else
+                    // queue is clear and time passed, just update last resurrection time
+                    m_LastResurrectTime = 0;
+            }
+            else if (m_LastResurrectTime > 500)    // Resurrect players only half a second later, to see spirit heal effect on NPC
+            {
+                for (std::vector<uint64>::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+                {
+                    Player *plr = sObjectMgr->GetPlayer(*itr);
+                    if (!plr)
+                        continue;
+                    plr->ResurrectPlayer(1.0f);
+                    plr->CastSpell(plr, 6962, true);
+                    plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
+                    sObjectAccessor->ConvertCorpseForPlayer(*itr);
+                }
+                m_ResurrectQueue.clear();
+            }
+        }
+        UpdateClock();
+    }
+    else
+    {
+        m_sendUpdate = false;
+        int32 entry = LANG_BG_WG_DEFENDED;
+
+        if (m_changeDefender)
+        {
+            m_changeDefender = false;
+            m_defender = getAttackerTeam();
+            entry = LANG_BG_WG_CAPTURED;
+        }
+        if (isWarTime())
+        {
+            if (m_timer != 1) // 1 = forceStopBattle
+                sWorld->SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(entry), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+            EndBattle();
+        }
+        else
+        {
+            if (m_timer != 1) // 1 = forceStartBattle
+                sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_STARTS));
+            StartBattle();
+        }
+
+        UpdateAllWorldObject();
+        UpdateClock();
+        SendInitWorldStatesTo();
+        m_sendUpdate = true;
+    }
+
+    if (m_WSSaveTimer < diff)
+    {
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31001', `value`='%d', `comment`='wg m_wartime'",m_wartime);
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31002', `value`='%d', `comment`='wg m_timer'",m_timer);
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31003', `value`='%d', `comment`='wg m_defender'",m_defender);
+        m_WSSaveTimer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+    }
+    else
+        m_WSSaveTimer -= diff;
+
+   return false;
+}
+
+void OutdoorPvPWG::forceStartBattle()
+{// Uptime will do all the work
+    m_wartime = false;
+
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_START));
+    }
+    sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceStopBattle()
+{// Uptime will do all the work.
+
+    if (!isWarTime())
+        m_wartime = true;
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_STOP));
+    }
+       sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceChangeTeam()
+{
+    m_changeDefender = true;
+    m_timer = 1;
+    sWorld->SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_SWITCH_FACTION), sObjectMgr->GetTrinityStringForDBCLocale(getAttackerTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+    if (isWarTime())
+        forceStartBattle();
+    else
+        forceStopBattle();
+}
+
+// Can be forced by gm's while in battle so have to reset in case it was wartime
+void OutdoorPvPWG::StartBattle()
+{
+    uint32 CountDef=0;
+    uint32 CountAtk=0;
+    m_wartime = true;
+    MaingateDestroyed = false;
+    m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME) * MINUTE * IN_MILLISECONDS;
+
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        if ((*itr)->getLevel() < 75)
+            (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        else
+        {
+            CountDef++;
+            (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+            (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+            (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+            (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+        }
+    }
+
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        if ((*itr)->getLevel() < 75)
+            (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        else
+        {
+            CountAtk++;
+            (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+            (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+            (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+            (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+        }
+    }
+
+    if (sWorld->getBoolConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE))
+    {
+        if ((CountAtk < sWorld->getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK)) || (CountDef < sWorld->getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF)))
+        {
+            if (CountAtk<=CountDef)
+                sWorld->SendWorldText(LANG_BG_WG_WORLD_NO_ATK);
+            if (CountDef<CountAtk)
+            {  
+                sWorld->SendWorldText(LANG_BG_WG_WORLD_NO_DEF);
+                m_changeDefender=true;
+            }
+            forceStopBattle();
+            return;
+        }
+    }
+
+	//Uncomment to tele Defenders inside Fortress
+    //TeamCastSpell(getDefenderTeam(), SPELL_TELEPORT_FORTRESS);
+
+    //Remove Essence of Wintergrasp to all players
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+    sWorld->UpdateAreaDependentAuras();
+
+    // Remove All Wintergrasp auras. Add Recruit rank and Tower Control
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() > 74)
+        {
+            (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), 3);
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+        }
+    }
+
+    // Remove All Wintergrasp auras. Add Recruit rank
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() > 74)
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+    }
+    UpdateTenacityStack();
+    // Update timer in players battlegrounds tab
+    sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::EndBattle()
+{
+    // Cast Essence of Wintergrasp to all players (CheckCast will determine who to cast)
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    sWorld->UpdateAreaDependentAuras();
+    //Sound on End Battle
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        if (getDefenderTeam()==TEAM_ALLIANCE)
+            TeamIDsound=OutdoorPvP_WG_SOUND_ALLIANCE_WINS; //Allience Win
+        else
+            TeamIDsound=OutdoorPvP_WG_SOUND_HORDE_WINS;  //Horde Win
+        (*itr)->PlayDirectSound(TeamIDsound) ; // SoundOnEndWin
+    }
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+        (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_NEAR_VICTORY) ; // SoundOnEndLoose
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        // destroyed all vehicles
+        while(!m_vehicles[team].empty())
+        {
+            Creature *veh = *m_vehicles[team].begin();
+            m_vehicles[team].erase(m_vehicles[team].begin());
+            veh->setDeathState(JUST_DIED);
+        }
+
+        if (m_players[team].empty())
+            continue;
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            // When WG ends the zone is cleaned including corpses, revive all players if dead
+            if ((*itr)->isDead())
+            {
+                (*itr)->ResurrectPlayer(1.0f);
+                sObjectAccessor->ConvertCorpseForPlayer((*itr)->GetGUID());
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+            (*itr)->CombatStop(true);
+            (*itr)->getHostileRefManager().deleteReferences();
+        }
+
+        if (m_timer == 1) // Battle End was forced so no reward.
+        {
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            {
+                (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+            }
+            continue;
+        }
+
+        // calculate rewards
+        uint32 intactNum = 0;
+        uint32 damagedNum = 0;
+        for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                if (workshop->m_buildingState->GetTeam() == team)
+                    if (workshop->m_buildingState->damageState == DAMAGE_DAMAGED)
+                        ++damagedNum;
+                    else if (workshop->m_buildingState->damageState == DAMAGE_INTACT)
+                        ++intactNum;
+
+        uint32 spellRewardId = team == getDefenderTeam() ? SPELL_VICTORY_REWARD : SPELL_DEFEAT_REWARD;
+        uint32 baseHonor = 0;
+        uint32 marks = 0;
+        uint32 playersWithRankNum = 0;
+        uint32 honor = 0;
+
+        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+        {
+            // Calculate Level 70+ with Corporal or Lieutenant rank
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+                if ((*itr)->getLevel() > 74 && ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL)))
+                    ++playersWithRankNum;
+            baseHonor = team == getDefenderTeam() ? sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE) : sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER) * m_towerDamagedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER) * m_towerDestroyedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING) * intactNum);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING) * damagedNum);
+            if (playersWithRankNum)
+                baseHonor /= playersWithRankNum;
+        }
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            if ((*itr)->getLevel() < 75)
+                continue; // No rewards for level <75
+
+            // give rewards
+            if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+            {
+                if (team == getDefenderTeam())
+                {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 3;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 2;
+                        honor = baseHonor;
+                    }
+                    else
+                    {
+                        marks = 1;
+                        honor = 0;
+                    }
+                }
+                else
+                {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else
+                    {
+                        marks = 0;
+                        honor = 0;
+                    }
+                }
+                (*itr)->RewardHonor(NULL, 1, honor);
+                RewardMarkOfHonor(*itr, marks);
+                (*itr)->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, spellRewardId);
+            }
+            else
+            {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    // TODO - Honor from SpellReward should be shared by team players
+                    // TODO - Marks should be given depending on Rank but 3 are given
+                    // each time so Won't give any to recruits
+                    (*itr)->CastSpell(*itr, spellRewardId, true);
+                    for (uint32 i = 0; i < intactNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_INTACT_BUILDING, true);
+                    for (uint32 i = 0; i < damagedNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_BUILDING, true);
+                    for (uint32 i = 0; i < m_towerDamagedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_TOWER, true);
+                    for (uint32 i = 0; i < m_towerDestroyedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DESTROYED_TOWER, true);
+                }
+            }
+            if (team == getDefenderTeam())
+            {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    (*itr)->AreaExploredOrEventHappens(A_VICTORY_IN_WG);
+                    (*itr)->AreaExploredOrEventHappens(H_VICTORY_IN_WG);
+                }
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        }
+    }
+
+    m_wartime = false;
+    m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL) * MINUTE * IN_MILLISECONDS;
+    RemoveOfflinePlayerWGAuras();
+    // Update timer in players battlegrounds tab
+    sWorld->SendWintergraspState();
+}
+
+bool OutdoorPvPWG::CanBuildVehicle(OPvPCapturePointWG *workshop) const
+{
+    TeamId team = workshop->m_buildingState->GetTeam();
+    if (team == TEAM_NEUTRAL)
+        return false;
+
+    return isWarTime()
+        && workshop->m_buildingState->damageState != DAMAGE_DESTROYED
+        && m_vehicles[team].size() < m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP;
+}
+
+uint32 OutdoorPvPWG::GetData(uint32 id)
+{
+    // if can build more vehicles
+    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(id))
+        return CanBuildVehicle(workshop) ? 1 : 0;
+
+    return 0;
+}
+
+void OutdoorPvPWG::RewardMarkOfHonor(Player *plr, uint32 count)
+{
+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
+    if (plr->HasAura(SPELL_AURA_PLAYER_INACTIVE))
+        return;
+    if (count == 0)
+        return;
+
+    ItemPosCountVec dest;
+    uint32 no_space_count = 0;
+    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
+
+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
+    {
+        sLog->outErrorDb("Wintergrasp reward item (Entry %u) not exist in `item_template`.", WG_MARK_OF_HONOR);
+        return;
+    }
+
+    if (msg != EQUIP_ERR_OK) // convert to possible store amount
+        count -= no_space_count;
+
+    if (count != 0 && !dest.empty()) // can add some
+        if (Item* item = plr->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
+            plr->SendNewItem(item, count, true, false);
+}
+
+void OutdoorPvPWG::LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli)
+{
+    m_qgPosMap[std::pair<uint32, bool>(guid, true)] = posHorde,
+    m_qgPosMap[std::pair<uint32, bool>(guid, false)] = posAlli,
+    m_questgivers[guid] = NULL;
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+        sObjectMgr->MoveCreData(guid, 571, posAlli);
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshop(uint32 lowguid) const
+{
+    if (OPvPCapturePoint *cp = GetCapturePoint(lowguid))
+        return dynamic_cast<OPvPCapturePointWG*>(cp);
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByEngGuid(uint32 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_engGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByGOGuid(uint64 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_workshopGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+/*########################################################
+ * Copy of Battleground system to make Spirit Guides Work
+ *#######################################################*/
+void OutdoorPvPWG::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid)
+{
+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+    uint32 time_ = 30000 - GetLastResurrectTime();      // resurrect every 30 seconds
+    if (time_ == uint32(-1))
+        time_ = 0;
+    data << guid << time_;
+    pl->GetSession()->SendPacket(&data);
+}
+
+void OutdoorPvPWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    m_ReviveQueue[npc_guid].push_back(player_guid);
+
+    Player *plr = sObjectMgr->GetPlayer(player_guid);
+    if (!plr)
+        return;
+
+    plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
+}
+
+void OutdoorPvPWG::RemovePlayerFromResurrectQueue(uint64 player_guid)
+{
+    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+    {
+        for (std::vector<uint64>::iterator itr2 =(itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+        {
+            if (*itr2 == player_guid)
+            {
+                (itr->second).erase(itr2);
+
+                Player *plr = sObjectMgr->GetPlayer(player_guid);
+                if (!plr)
+                    return;
+
+                plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
+
+                return;
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateAllianceDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = sObjectMgr->GetPlayer(*itr);
+            if (!plr)
+                continue;
+
+            if (plr->getFaction() == ALLIANCE)
+            {
+                if (ClosestGrave)
+                    plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+                else
+                    ClosestGrave = sObjectMgr->GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateHordeDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = sObjectMgr->GetPlayer(*itr);
+            if (!plr)
+                continue;
+            if (plr->getFaction() == HORDE)
+            {
+                if (ClosestGrave)
+                    plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+                else
+                    ClosestGrave = sObjectMgr->GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+            }
+        }
+    }
+}
+
+OPvPCapturePointWG::OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state) : OPvPCapturePoint(opvp), m_buildingState(state), m_wintergrasp(opvp), m_engineer(NULL), m_engGuid(0), m_spiritguide(NULL), m_spiritguide_horde(NULL), m_spiritguide_alliance(NULL), m_spiGuid(0) { }
+
+void OPvPCapturePointWG::SetTeamByBuildingState()
+{
+    if (m_buildingState->GetTeam() == TEAM_ALLIANCE)
+    {
+        m_value = m_maxValue;
+        m_State = OBJECTIVESTATE_ALLIANCE;
+    }
+    else if (m_buildingState->GetTeam() == TEAM_HORDE)
+    {
+        m_value = -m_maxValue;
+        m_State = OBJECTIVESTATE_HORDE;
+    }
+    else
+    {
+        m_value = 0;
+        m_State = OBJECTIVESTATE_NEUTRAL;
+    }
+
+    if (m_team != m_buildingState->GetTeam())
+    {
+        TeamId oldTeam = m_team;
+        m_team = m_buildingState->GetTeam();
+        ChangeTeam(oldTeam);
+    }
+
+    SendChangePhase();
+}
+
+void OPvPCapturePointWG::ChangeTeam(TeamId oldTeam)
+{
+    entry = 0;
+    guide_entry = 0;
+    guide_entry_fortress_horde = 0;
+    guide_entry_fortress_alliance = 0;
+
+    if (oldTeam != TEAM_NEUTRAL)
+        m_wintergrasp->ModifyWorkshopCount(oldTeam, false);
+
+    if (m_team != TEAM_NEUTRAL)
+    {
+        entry = m_team == TEAM_ALLIANCE ? CRE_ENG_A : CRE_ENG_H;
+        guide_entry = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_H;
+        guide_entry_fortress_horde = m_team == TEAM_HORDE ? CRE_SPI_H : CRE_SPI_H;
+        guide_entry_fortress_alliance = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_A;
+        m_wintergrasp->ModifyWorkshopCount(m_team, true);
+    }
+
+    if (m_capturePoint)
+        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
+
+    m_buildingState->SetTeam(m_team);
+    // TODO: this may be sent twice
+    m_wintergrasp->BroadcastStateChange(m_buildingState);
+    
+    if (m_buildingState->building)
+        m_buildingState->building->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_team]);
+
+    if (entry)
+    {
+        if (m_engGuid)
+        {
+            *m_engEntry = entry;
+            _RespawnCreatureIfNeeded(m_engineer, entry);
+        }
+        if (m_spiGuid)
+        {
+            if (m_wintergrasp->getAttackerTeam() == TEAM_ALLIANCE)
+            {
+                *m_spiEntry = guide_entry;
+                _RespawnCreatureIfNeeded(m_spiritguide_horde, guide_entry_fortress_horde);
+                m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide_horde); // Horde
+                _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+                m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide); // Alliance
+            }
+            else
+            {
+                *m_spiEntry = guide_entry;
+                _RespawnCreatureIfNeeded(m_spiritguide_alliance, guide_entry_fortress_alliance);
+                m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide_alliance); // Alliance
+                _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+                m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide); // Horde
+            }
+        }
+    }
+    else if (m_engineer)
+        m_engineer->SetVisible(false);
+
+    sLog->outDebug("Wintergrasp workshop now belongs to %u.", (uint32)m_buildingState->GetTeam());
+}
+
+class OutdoorPvP_wintergrasp : public OutdoorPvPScript
+{
+    public:
+        OutdoorPvP_wintergrasp() : OutdoorPvPScript("outdoorpvp_wg") { }
+        
+        OutdoorPvP* GetOutdoorPvP() const
+        {
+            return new OutdoorPvPWG();
+        }
+};
+
+void AddSC_outdoorpvp_wg()
+{
+    new OutdoorPvP_wintergrasp();
+}
\ No newline at end of file
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
new file mode 100644
index 0000000..2daa3b1
--- /dev/null
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
@@ -0,0 +1,341 @@
+/*
+ * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
+ *
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef OUTDOOR_PVP_WG_
+#define OUTDOOR_PVP_WG_
+
+#include "OutdoorPvP.h"
+#include "BattlegroundMgr.h"
+#include "Player.h"
+
+#define ZONE_DALARAN             4395
+#define ZONE_WINTERGRASP         4197
+#define POS_X_CENTER             5100
+#define MAX_VEHICLE_PER_WORKSHOP    4
+
+const uint32 WintergraspFaction[3] = {1802, 1801, 35};
+const uint32 WG_MARK_OF_HONOR = 43589;
+const uint32 VehNumWorldState[2] = {3680,3490};
+const uint32 MaxVehNumWorldState[2] = {3681,3491};
+const uint32 ClockWorldState[2] = {3781,4354};
+
+enum OutdoorPvPWGSpell
+{
+    // Wartime auras
+    SPELL_RECRUIT                                = 37795,
+    SPELL_CORPORAL                               = 33280,
+    SPELL_LIEUTENANT                             = 55629,
+    SPELL_TENACITY                               = 58549,
+    SPELL_TENACITY_VEHICLE                       = 59911,
+    SPELL_TOWER_CONTROL                          = 62064,
+    SPELL_SPIRITUAL_IMMUNITY                     = 58729,
+
+    // Reward spells
+    SPELL_VICTORY_REWARD                         = 56902,
+    SPELL_DEFEAT_REWARD                          = 58494,
+    SPELL_DAMAGED_TOWER                          = 59135,
+    SPELL_DESTROYED_TOWER                        = 59136,
+    SPELL_DAMAGED_BUILDING                       = 59201,
+    SPELL_INTACT_BUILDING                        = 59203,
+
+    SPELL_TELEPORT_ALLIENCE_CAMP                 = 58632,
+    SPELL_TELEPORT_HORDE_CAMP                    = 58633,
+    SPELL_TELEPORT_FORTRESS                      = 59096,
+
+    SPELL_TELEPORT_DALARAN                       = 53360,
+    SPELL_VICTORY_AURA                           = 60044,
+};
+
+const uint16 GameEventWintergraspDefender[2] = {50, 51};
+
+enum OutdoorPvP_WG_Sounds
+{
+    OutdoorPvP_WG_SOUND_KEEP_CLAIMED            = 8192,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE  = 8173,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE     = 8213,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE = 8212,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE    = 8174,
+    OutdoorPvP_WG_SOUND_NEAR_VICTORY            = 8456,
+    OutdoorPvP_WG_SOUND_HORDE_WINS              = 8454,
+    OutdoorPvP_WG_SOUND_ALLIANCE_WINS           = 8455,
+    OutdoorPvP_WG_SOUND_WORKSHOP_Horde          = 6205,
+    OutdoorPvP_WG_SOUND_WORKSHOP_ALLIANCE       = 6298,
+    OutdoorPvP_WG_HORDE_CAPTAIN                 = 8333,
+    OutdoorPvP_WG_ALLIANCE_CAPTAIN              = 8232,
+    OutdoorPvP_WG_SOUND_START_BATTLE            = 3439, //Standart BG Start sound
+};
+
+enum DataId
+{
+     DATA_ENGINEER_DIE,
+};
+
+enum OutdoorPvP_WG_KeepStatus
+{
+    OutdoorPvP_WG_KEEP_TYPE_NEUTRAL             = 0,
+    OutdoorPvP_WG_KEEP_TYPE_CONTESTED           = 1,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_CONTESTED    = 1,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_CONTESTED   = 2,
+    OutdoorPvP_WG_KEEP_TYPE_OCCUPIED            = 3,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_OCCUPIED     = 3,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_OCCUPIED    = 4
+};
+
+enum OutdoorPVPWGStatus
+{
+    WORLDSTATE_WINTERGRASP_CONTROLING_FACTION,
+    WORLDSTATE_VALUE_COUNT,
+};
+
+enum OutdoorPvPWGCreType
+{
+    CREATURE_OTHER,
+    CREATURE_SIEGE_VEHICLE,
+    CREATURE_TURRET,
+    CREATURE_ENGINEER,
+    CREATURE_GUARD,
+    CREATURE_SPECIAL,
+    CREATURE_SPIRIT_GUIDE,
+    CREATURE_SPIRIT_HEALER,
+    CREATURE_QUESTGIVER,
+};
+
+enum OutdoorPvPWGBuildingType
+{
+    BUILDING_WALL,
+    BUILDING_WORKSHOP,
+    BUILDING_TOWER,
+};
+
+enum OutdoorPvPWGDamageState
+{ // Do not change order
+    DAMAGE_INTACT,
+    DAMAGE_DAMAGED,
+    DAMAGE_DESTROYED,
+};
+
+typedef uint32 TeamPair[2];
+
+enum OutdoorPvPWGQuest
+{
+    A_VICTORY_IN_WG                              = 13181,
+    H_VICTORY_IN_WG                              = 13183,
+    CRE_PVP_KILL                                 = 31086, //Quest Objective - Fixme: this should be handled by DB
+    CRE_PVP_KILL_V                               = 31093, //Quest Objective - Fixme: this should be handled by DB.
+    TOWER_PVP_DESTROYED                          = 35074, //Quest Objective - Toppling the Towers & Southern Sabotage
+};
+
+enum OutdoorPvPWGCreEntry
+{
+    CRE_ENG_A                                    = 30499,
+    CRE_ENG_H                                    = 30400,
+    CRE_SPI_A                                    = 31842,
+    CRE_SPI_H                                    = 31841,
+};
+
+const TeamPair OutdoorPvPWGCreEntryPair[] =
+{
+    {32307, 32308}, // Guards
+    {30739, 30740}, // Champions
+    {32296, 32294}, // Quartermaster
+    {39173, 39172}, // Ros'slai & Marshal Magruder
+    {32615, 32626}, // Warbringer & Brigadier General
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const TeamPair OutdoorPvPWGGODisplayPair[] =
+{
+    {5651, 5652},
+    {8256, 8257},
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const uint32 AreaPOIIconId[3][3] = {{7,8,9},{4,5,6},{1,2,3}};
+typedef std::list<const AreaPOIEntry *> AreaPOIList;
+
+struct BuildingState
+{
+    explicit BuildingState(uint32 _worldState, TeamId _team, bool asDefault)
+         : worldState(_worldState), health(0)
+         , defaultTeam(asDefault ? _team : OTHER_TEAM(_team)), team(_team), damageState(DAMAGE_INTACT)
+         , building(NULL), type(BUILDING_WALL), graveTeam(NULL)
+    { }
+    uint32 worldState;
+    uint32 health;
+    TeamId defaultTeam;
+    OutdoorPvPWGDamageState damageState;
+    GameObject *building;
+    uint32 *graveTeam;
+    OutdoorPvPWGBuildingType type;
+
+    void SendUpdate(Player *player) const
+    {
+        player->SendUpdateWorldState(worldState, AreaPOIIconId[team][damageState]);
+    }
+
+    void FillData(WorldPacket &data) const
+    {
+        data << worldState << AreaPOIIconId[team][damageState];
+    }
+
+    TeamId GetTeam() const { return team; }
+    void SetTeam(TeamId t)
+    {
+        team = t;
+        if(graveTeam)
+            if (uint32 newTeam = TeamId2Team[t])
+                *graveTeam = newTeam;
+    }
+
+    private:
+        TeamId team;
+};
+
+typedef std::map<uint32, uint32> TeamPairMap;
+class OPvPCapturePointWG;
+
+class OutdoorPvPWG : public OutdoorPvP
+{
+    protected:
+        typedef std::map<uint32, BuildingState *> BuildingStateMap;
+        typedef std::set<Creature*> CreatureSet;
+        typedef std::set<GameObject*> GameObjectSet;
+        typedef std::map<std::pair<uint32, bool>, Position> QuestGiverPositionMap;
+        typedef std::map<uint32, Creature*> QuestGiverMap;
+
+    public:
+        OutdoorPvPWG();
+        bool SetupOutdoorPvP();
+        int TeamIDsound;
+        bool MaingateDestroyed;
+        uint32 GetCreatureEntry(uint32 guidlow, const CreatureData *data);
+        void OnCreatureCreate(Creature *creature);
+        void OnGameObjectCreate(GameObject *go);
+        void OnCreatureRemove(Creature *creature);
+        void OnGameObjectRemove(GameObject *go);
+        void ProcessEvent(GameObject *obj, uint32 eventId);
+        void HandlePlayerEnterZone(Player *plr, uint32 zone);
+        void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+        void HandlePlayerResurrects(Player * plr, uint32 zone);
+        void HandleKill(Player *killer, Unit *victim);
+        bool Update(uint32 diff);
+        void BroadcastStateChange(BuildingState *state) const;
+        uint32 GetData(uint32 id);
+        void SetData(uint32 id, uint32 value) { };
+        void ModifyWorkshopCount(TeamId team, bool add);
+        uint32 GetTimer() const { return m_timer / 1000; };
+        bool isWarTime() const { return m_wartime; };
+        void setTimer(uint32 timer) { if (timer >= 0) m_timer = timer; };
+        uint32 GetNumPlayersA() const { return m_players[TEAM_ALLIANCE].size(); };
+        uint32 GetNumPlayersH() const { return m_players[TEAM_HORDE].size(); };
+        TeamId getDefenderTeam() const { return m_defender; };
+        TeamId getAttackerTeam() const { return OTHER_TEAM(m_defender); };
+        void forceChangeTeam();
+        void forceStopBattle();
+        void forceStartBattle();
+        // Temporal BG specific till 3.2
+        void SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid);
+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
+        void RemovePlayerFromResurrectQueue(uint64 player_guid);
+        void RelocateAllianceDeadPlayers(Creature *cr);
+        void RelocateHordeDeadPlayers(Creature *cr);
+        // BG end
+        void SendInitWorldStatesTo(Player *player = NULL) const;
+        uint32 m_timer;
+
+    protected:
+        // Temporal BG specific till 3.2
+        std::vector<uint64> m_ResurrectQueue;               // Player GUID
+        uint32 m_LastResurrectTime;
+        // Spirit Guide guid + Player list GUIDS
+        std::map<uint64, std::vector<uint64> >  m_ReviveQueue;
+
+        uint32 GetLastResurrectTime() const { return m_LastResurrectTime; }
+        uint32 GetReviveQueueSize() const { return m_ReviveQueue.size(); }
+        // BG end
+        TeamId m_defender;
+        int32 m_tenacityStack;
+
+        BuildingStateMap m_buildingStates;
+        BuildingState *m_gate;
+
+        CreatureSet m_creatures;
+        CreatureSet m_vehicles[2];
+        GameObjectSet m_gobjects;
+        GameObjectSet m_gobjectsDestroyable;
+        QuestGiverMap m_questgivers;
+
+        TeamPairMap m_creEntryPair, m_goDisplayPair;
+        QuestGiverPositionMap m_qgPosMap;
+
+        bool m_wartime;
+        bool m_changeDefender;
+        uint32 m_clock[2];
+        uint32 m_workshopCount[2];
+        uint32 m_towerDestroyedCount[2];
+        uint32 m_towerDamagedCount[2];
+        uint32 m_WSSaveTimer;
+
+        OPvPCapturePointWG *GetWorkshop(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByEngGuid(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByGOGuid(uint64 lowguid) const;
+
+        void StartBattle();
+        void EndBattle();
+        void UpdateClock();
+        void UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod);
+        void PromotePlayer(Player *player) const;
+        void UpdateTenacityStack();
+        void UpdateAllWorldObject();
+        bool UpdateCreatureInfo(Creature *creature);
+        bool UpdateGameObjectInfo(GameObject *go) const;
+        bool CanBuildVehicle(OPvPCapturePointWG *workshop) const;
+        OutdoorPvPWGCreType GetCreatureType(uint32 entry) const;
+
+        void RebuildAllBuildings();
+        void RemoveOfflinePlayerWGAuras();
+        void RewardMarkOfHonor(Player *player, uint32 count);
+        void MoveQuestGiver(uint32 guid);
+        void LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli);
+        bool UpdateQuestGiverPosition(uint32 guid, Creature *creature);
+};
+
+class OPvPCapturePointWG : public OPvPCapturePoint
+{
+    public:
+        explicit OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state);
+        void SetTeamByBuildingState();
+        void ChangeState() { }
+        void ChangeTeam(TeamId oldteam);
+        uint32 *m_spiEntry;
+        uint32 m_spiGuid;
+        Creature *m_spiritguide;
+        Creature *m_spiritguide_horde;
+        Creature *m_spiritguide_alliance;
+        uint32 *m_engEntry;
+        uint32 m_engGuid;
+        Creature *m_engineer;
+        uint32 m_workshopGuid;
+        BuildingState *m_buildingState;
+
+    protected:
+        OutdoorPvPWG *m_wintergrasp;
+};
+#endif
\ No newline at end of file
diff --git a/src/server/shared/Common.h b/src/server/shared/Common.h
index cefefa7..77a76dc 100755
--- a/src/server/shared/Common.h
+++ b/src/server/shared/Common.h
@@ -19,6 +19,10 @@
 #ifndef TRINITYCORE_COMMON_H
 #define TRINITYCORE_COMMON_H
 
+#ifndef PLAYERBOT_EXISTS
+#define PLAYERBOT_EXISTS
+#endif
+
 // config.h needs to be included 1st
 // TODO this thingy looks like hack ,but its not, need to
 // make separate header however, because It makes mess here.
diff --git a/src/server/shared/Database/Implementation/LoginDatabase.cpp b/src/server/shared/Database/Implementation/LoginDatabase.cpp
index 6f34700..c012a2a 100755
--- a/src/server/shared/Database/Implementation/LoginDatabase.cpp
+++ b/src/server/shared/Database/Implementation/LoginDatabase.cpp
@@ -47,6 +47,7 @@ bool LoginDatabaseConnection::Open()
     PREPARE_STATEMENT(LOGIN_SET_IP_NOT_BANNED, "DELETE FROM ip_banned WHERE ip = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_SET_ACCOUNT_BANNED, "INSERT INTO account_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, ?, ?, 1)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_SET_ACCOUNT_NOT_BANNED, "UPDATE account_banned SET active = 0 WHERE id = ? AND active != 0", CONNECTION_ASYNC)
+	PREPARE_STATEMENT(LOGIN_SET_ACCOUNT_PREMIUM, "UPDATE account_premium SET active = 0 WHERE unsetdate<=UNIX_TIMESTAMP() AND unsetdate<>setdate", CONNECTION_ASYNC)
 
     /* ############## END OF LOADING PREPARED STATEMENTS ############## */
 
diff --git a/src/server/shared/Database/Implementation/LoginDatabase.h b/src/server/shared/Database/Implementation/LoginDatabase.h
index d512607..3182c02 100755
--- a/src/server/shared/Database/Implementation/LoginDatabase.h
+++ b/src/server/shared/Database/Implementation/LoginDatabase.h
@@ -62,6 +62,7 @@ enum LoginDatabaseStatements
     LOGIN_SET_IP_NOT_BANNED,
     LOGIN_SET_ACCOUNT_BANNED,
     LOGIN_SET_ACCOUNT_NOT_BANNED,
+	LOGIN_SET_ACCOUNT_PREMIUM,
 
     MAX_LOGINDATABASE_STATEMENTS,
 };
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index d0ccc61..ba5da45 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2021,10 +2021,18 @@ Rate.Drop.Item.ReferencedAmount = 1
 #        Default:     1 - (Rate.XP.Kill)
 #                     1 - (Rate.XP.Quest)
 #                     1 - ( Rate.XP.Explore)
+#    Rate.XP.Kill.Premium
+#    Rate.XP.Quest.Premium
+#    Rate.XP.Explore.Premium
+#        XP rates Premium modifier
+#        Default: 1
 
 Rate.XP.Kill    = 1
 Rate.XP.Quest   = 1
 Rate.XP.Explore = 1
+Rate.XP.Kill.Premium    = 1
+Rate.XP.Quest.Premium   = 1
+Rate.XP.Explore.Premium = 1
 
 #
 #    Rate.RepairCost
@@ -2491,6 +2499,272 @@ Network.TcpNodelay = 1
 #
 ###################################################################################################
 
+###############################################################################
+# AUCTION HOUSE BOT SETTINGS
+#
+#    AuctionHouseBot.DEBUG
+#        Enable/Disable Debugging output
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.DEBUG_FILTERS
+#        Enable/Disable Debugging output from Filters
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableSeller
+#        Enable/Disable the part of AHBot that puts items up for auction
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableBuyer
+#        Enable/Disable the part of AHBot that buys items from players
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.UseBuyPriceForSeller
+#        Should the Seller use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    AuctionHouseBot.UseBuyPriceForBuyer
+#        Should the Buyer use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    Auction House Bot character data
+#        AuctionHouseBot.Account is the account number
+#         (in realmd->account table) of the player you want to run
+#         as the auction bot.
+#        AuctionHouseBot.GUID is the GUID (in characters->characters table)
+#         of the player you want to run as the auction bot.
+#    Default: 0 (Auction House Bot disabled)
+#
+#    AuctionHouseBot.ItemsPerCycle
+#        Number of Items to Add/Remove from the AH during mass operations
+#    Default 200
+#
+###############################################################################
+
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.DEBUG_FILTERS = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 1
+#
+#    AuctionHouseBot.VendorItems
+#        Include items that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.VendorTradeGoods
+#        Include Trade Goods that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.LootItems
+#        Include items that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.LootTradeGoods
+#        Include Trade Goods that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.OtherItems
+#        Include misc. items.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.OtherTradeGoods
+#        Include misc. Trade Goods.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.Bonding_types
+#        Indicates which bonding types to allow seller to put up for auction
+#            No_Bind
+#             Default 1 (True)
+#            Bind_When_Picked_Up
+#             Default 0 (False)
+#            Bind_When_Equipped
+#             Default 1 (True)
+#            Bind_When_Use
+#             Default 1 (True)
+#            Bind_Quest_Item
+#             Default 0 (False)
+#
+#    AuctionHouseBot.DisableBeta_PTR_Unused
+#        Disable certain items that are usually unavailable to Players
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisablePermEnchant
+#        Disable Items with a Permanent Enchantment
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableConjured
+#        Disable Conjured Items
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableGems
+#        Disable Gems
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoney
+#        Disable Items that are used as money
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoneyLoot
+#        Disable Items that have Money as a loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableLootable
+#        Disable Items that have other items as loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableKeys
+#        Disable Items that are keys
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableDuration
+#        Disable Items with a duration
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel
+#        Disable items that are BOP or Quest Item
+#        with a Required level that is less than the Item Level
+#        (This prevents a level 10 with a level 60 weapon or armor)
+#        (May need further refinement)
+#    Default 0 (False)
+#
+###############################################################################
+
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisableBeta_PTR_Unused = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 2
+#
+#     These Filters are boolean (0 or 1) and will disable items that are
+#     specifically meant for the Class named.
+#     (UnusedClass is Class 10, which was skipped for some reason)
+#     Default 0 (allowed)
+#
+###############################################################################
+
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 3
+#
+#    AuctionHouseBot.DisableItemsBelowLevel
+#        Prevent Seller from listing Items below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveLevel
+#        Prevent Seller from listing Items above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowLevel
+#        Prevent Seller from listing Trade Goods below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveLevel
+#        Prevent Seller from listing Trade Goods above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowGUID
+#        Prevent Seller from listing Items below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveGUID
+#        Prevent Seller from listing Items above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowGUID
+#        Prevent Seller from listing Trade Goods below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveGUID
+#        Prevent Seller from listing Trade Goods above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqLevel
+#        Prevent Seller from listing Items below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqLevel
+#        Prevent Seller from listing Items above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqLevel
+#        Prevent Seller from listing Trade Goods below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqLevel
+#        Prevent Seller from listing Trade Goods above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqSkillRank
+#        Prevent Seller from listing Items below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqSkillRank
+#        Prevent Seller from listing Items above this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqSkillRank
+#        Prevent Seller from listing Trade Goods below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqSkillRank
+#        Prevent Seller from listing Trade Goods above this Required Skill Rank
+#    Default 0 (Off)
+#
+###############################################################################
+
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
 ###################################################################################################
 # CONSOLE AND REMOTE ACCESS
 #
@@ -2553,6 +2827,20 @@ SOAP.IP = "127.0.0.1"
 SOAP.Port = 7878
 
 #
+
+#     Anticheat.Enable
+#        Description: Enables or disables the Anticheat System functionality
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)  
+
+Anticheat.Enable = 1
+
+#     Anticheat.ReportsForIngameWarnings
+#        Description: How many reports the player must have to notify to GameMasters ingame when he generates a new report.
+#        Default:     70
+
+Anticheat.ReportsForIngameWarnings = 70
+      
 ###################################################################################################
 
 ###################################################################################################
@@ -2745,3 +3033,133 @@ LevelReq.Mail = 1
 
 #
 ###################################################################################################
+# BOT CONFIGURATION
+#
+#    Bot.FollowDistanceMin
+#    Bot.FollowDistanceMax
+#        Min. and max. follow distance for bots
+#        Default: 0.5 / 2.0
+#    Bot.MaxPlayerBots
+#        Maximum number of Player Bots allowed per account
+#        Default: 9
+#    Bot.PlayerBotsFly
+#        If PlayerBots fly with you when you use the flight master
+#        Default: 0
+#        0 = false
+#        1 = true
+#    Bot.LootMethod
+#        Type of loot method
+#        Default: 2
+#        0 = Free for all
+#        1 = Round robin
+#        2 = Master loot
+#        3 = Group loot
+#        4 = Need before greed
+#    Bot.SaveOrgLocation
+#        Puts playerbots back to their original location after use
+#        Default: 0
+#        0 = false - keep playerbots where they were camped out
+#        1 = true - puts playerbots back to where they were originally summoned
+################################################################################
+Bot.FollowDistanceMin = 0.5
+Bot.FollowDistanceMax = 2.0
+Bot.MaxPlayerBots = 9
+Bot.PlayerBotsFly=0
+Bot.LootMethod=2
+Bot.SaveOrgLocation=0
+
+#######################################################################
+#   OutdoorPvP.Wintergrasp.Enabled
+#       Determines whether the Wintergrasp battle is enabled or not.
+#        Default: 0 = Disable
+#                 1 = Enable
+#
+#   OutdoorPvP.Wintergrasp.SaveState.Period
+#      Interval of Save Wintergrasp State Data  to restore it after crash/shutdown/restart
+#      Interval (in milliseconds)
+#      Default (10000 milliseconds)
+#      Warning:  Do not set it less 1 second!
+#
+#   OutdoorPvP.Wintergrasp.StartTime
+#       The start time of the first battle after server starts (in minutes)
+#       Default: 30
+#
+#   OutdoorPvP.Wintergrasp.BattleTime
+#       Time limit of a battle (in minutes)
+#       Default: 30
+#
+#   OutdoorPvP.Wintergrasp.Interval
+#       Interval between battles (in minutes)
+#       Default: 150
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorRewards
+#       Defines whether custom honor rewards should be given to player
+#        for partaking in the Wintergrasp Battle.
+#        Default: 0 = Disable
+#                 1 = Enable
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorBattleWin
+#       Defines the amount of honor points that should be given to the
+#        team winning the Wintergrasp Battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 3000
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorBattleLose
+#       Defines the amount of honor points that should be given to the
+#        team losing the Wintergrasp Battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 1250
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDamageTower
+#       Defines the amount of honor points that should be given to the
+#        team for damaging a tower.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower
+#       Defines the amount of honor points that should be given to the
+#        team for destroying a tower.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding
+#       Defines the amount of honor points that should be given to the
+#        team for damaged buildings after the battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding
+#      Defines the amount of honor points that should be given to the
+#        team for intact buildings after the battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 1500
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Enable
+#		Enable or Disable antifarm system
+#              (Default: 0)
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Atk
+#		Min count atack players for antifarm
+#              (Default: 5)
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Def
+#		Min count defense players for antifarm
+#              (Default: 5)
+#
+##########################################################
+
+OutdoorPvP.Wintergrasp.Enabled = 1
+OutdoorPvP.Wintergrasp.SaveState.Period = 60000
+OutdoorPvP.Wintergrasp.StartTime = 30
+OutdoorPvP.Wintergrasp.BattleTime = 30
+OutdoorPvP.Wintergrasp.Interval = 150
+OutdoorPvP.Wintergrasp.CustomHonorRewards = 0
+OutdoorPvP.Wintergrasp.CustomHonorBattleWin = 3000
+OutdoorPvP.Wintergrasp.CustomHonorBattleLose = 1250
+OutdoorPvP.Wintergrasp.CustomHonorDamageTower = 750
+OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower = 750
+OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding = 750
+OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding = 1500
+OutdoorPvP.Wintergrasp.Antifarm.Enable = 1
+OutdoorPvP.Wintergrasp.Antifarm.Atk = 1
+OutdoorPvP.Wintergrasp.Antifarm.Def = 1
\ No newline at end of file
-- 
1.7.2.3

