From 24fbd49d4c7f115b0713de0363bf683274740737 Mon Sep 17 00:00:00 2001
From: root <root@deb.privatedns.com>
Date: Mon, 19 Aug 2013 03:04:31 -0400
Subject: [PATCH] 2013_08_19-All

---
 README.NPCTELEPORT                                 |   14 +
 doc/AuctionHouseBot.txt                            |  235 ++
 sql/Bots/character_NPC_bots.sql                    |   12 +
 ...world_bot_helper_locales_gossip_menu_option.sql |   92 +
 sql/Bots/world_bots.sql                            |  524 ++++
 sql/VIPAccounts/auth_VIPAccount.sql                |    8 +
 sql/tools/setup_ahbot.sql                          |   72 +
 sql/tools/setup_npc_teleport.sql                   |  119 +
 src/server/authserver/Server/AuthSocket.cpp        |    1 +
 src/server/game/AI/NpcBots/bot_GridNotifiers.h     |  461 +++
 src/server/game/AI/NpcBots/bot_ai.cpp              | 3214 ++++++++++++++++++++
 src/server/game/AI/NpcBots/bot_ai.h                |  359 +++
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        | 1092 +++++++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       |  340 +++
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         |  935 ++++++
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      | 1014 ++++++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       |  859 ++++++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |  894 ++++++
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       |  474 +++
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |  458 +++
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      | 1192 ++++++++
 src/server/game/AI/NpcBots/botcommands.cpp         |  633 ++++
 src/server/game/AI/NpcBots/bothelper.cpp           |  421 +++
 src/server/game/AI/NpcBots/bothelper.h             |   32 +
 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp  |  376 +++
 src/server/game/AI/ScriptedAI/sc_npc_teleport.h    |  151 +
 .../AuctionHouseBot/AuctionHouseBot.cpp            | 2003 ++++++++++++
 .../AuctionHouse/AuctionHouseBot/AuctionHouseBot.h | 1257 ++++++++
 src/server/game/AuctionHouse/AuctionHouseMgr.cpp   |   11 +-
 src/server/game/AuctionHouse/AuctionHouseMgr.h     |    2 +
 src/server/game/CMakeLists.txt                     |    4 +
 src/server/game/Entities/Creature/Creature.cpp     |  134 +
 src/server/game/Entities/Creature/Creature.h       |   39 +
 .../game/Entities/Creature/TemporarySummon.cpp     |    8 +
 src/server/game/Entities/Object/Object.cpp         |   11 +
 src/server/game/Entities/Player/Player.cpp         |  859 +++++-
 src/server/game/Entities/Player/Player.h           |   63 +
 src/server/game/Entities/Unit/StatSystem.cpp       |    4 +
 src/server/game/Entities/Unit/Unit.cpp             |  214 ++
 src/server/game/Groups/Group.cpp                   |   12 +
 src/server/game/Groups/Group.h                     |    3 +
 src/server/game/Handlers/AuctionHouseHandler.cpp   |    1 +
 src/server/game/Handlers/CharacterHandler.cpp      |   25 +
 src/server/game/Handlers/MiscHandler.cpp           |   35 +
 src/server/game/Handlers/NPCHandler.cpp            |   16 +
 src/server/game/Mails/Mail.cpp                     |    8 +
 src/server/game/Maps/Map.cpp                       |    3 +
 src/server/game/Miscellaneous/Formulas.h           |    4 +-
 src/server/game/Scripting/ScriptLoader.cpp         |   39 +-
 src/server/game/Scripting/ScriptMgr.cpp            |    3 +
 src/server/game/Server/WorldSession.cpp            |   20 +-
 src/server/game/Server/WorldSession.h              |   23 +-
 src/server/game/Server/WorldSocket.cpp             |   13 +-
 src/server/game/World/World.cpp                    |    5 +
 src/server/game/World/World.h                      |    3 +
 src/server/scripts/CMakeLists.txt                  |    4 +
 src/server/scripts/Commands/CMakeLists.txt         |    1 +
 src/server/scripts/Commands/cs_ah_bot.cpp          |  482 +++
 src/server/scripts/Custom/CMakeLists.txt           |    3 +
 src/server/scripts/Custom/changernpc.cpp           |   77 +
 src/server/scripts/Custom/levelnpc.cpp             |  192 ++
 src/server/scripts/Custom/npc_teleport.cpp         |  222 ++
 src/server/scripts/Custom/summon.cpp               |   46 +
 src/server/scripts/Spells/spell_priest.cpp         |    4 +
 .../Database/Implementation/CharacterDatabase.cpp  |    7 +
 .../Database/Implementation/CharacterDatabase.h    |    7 +
 .../Database/Implementation/LoginDatabase.cpp      |    1 +
 .../shared/Database/Implementation/LoginDatabase.h |    1 +
 .../Database/Implementation/WorldDatabase.cpp      |    4 +
 .../shared/Database/Implementation/WorldDatabase.h |    4 +
 src/server/worldserver/worldserver.conf.dist       |  400 ++-
 71 files changed, 20246 insertions(+), 13 deletions(-)
 create mode 100644 README.NPCTELEPORT
 create mode 100644 doc/AuctionHouseBot.txt
 create mode 100644 sql/Bots/character_NPC_bots.sql
 create mode 100644 sql/Bots/world_bot_helper_locales_gossip_menu_option.sql
 create mode 100644 sql/Bots/world_bots.sql
 create mode 100644 sql/VIPAccounts/auth_VIPAccount.sql
 create mode 100644 sql/tools/setup_ahbot.sql
 create mode 100644 sql/tools/setup_npc_teleport.sql
 create mode 100644 src/server/game/AI/NpcBots/bot_GridNotifiers.h
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/bothelper.cpp
 create mode 100644 src/server/game/AI/NpcBots/bothelper.h
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.h
 create mode 100644 src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
 create mode 100644 src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
 create mode 100644 src/server/scripts/Commands/cs_ah_bot.cpp
 create mode 100644 src/server/scripts/Custom/changernpc.cpp
 create mode 100644 src/server/scripts/Custom/levelnpc.cpp
 create mode 100644 src/server/scripts/Custom/npc_teleport.cpp
 create mode 100644 src/server/scripts/Custom/summon.cpp

diff --git a/README.NPCTELEPORT b/README.NPCTELEPORT
new file mode 100644
index 0000000..015c9c2
--- /dev/null
+++ b/README.NPCTELEPORT
@@ -0,0 +1,14 @@
+NPC Teleport for Trinity
+
+Original author : Wilibald09
+
+Allows you to add a custom NPC for teleporting, using .npc add 100000.
+The default NPC is entry 100000.
+
+All settings are located in the DB, so you can customize and add destinations,
+set level restrictions and also charge the player for teleporting.
+
+Installation:
+
+Run the query setup_npc_teleport.sql located in the trinity sql directory on
+your world DB. This will setup the DB and you can customize from there.
diff --git a/doc/AuctionHouseBot.txt b/doc/AuctionHouseBot.txt
new file mode 100644
index 0000000..8170bd2
--- /dev/null
+++ b/doc/AuctionHouseBot.txt
@@ -0,0 +1,235 @@
+Populates the auction houses with items. It can make the game feel a bit more
+like official on small servers. Items and prices are chosen randomly based on
+the parameters you define. If an auction expires, auctions are deleted quietly.
+AHBot will not buy it's own items, and will not receive mail from the AH
+or get returned mail.
+
+===============================================================================
+~~HOW TO CONFIGURE~~
+===============================================================================
+Step 1.) Create a character that you are going to use as the auction house bot
+         character. This character will be the auction's owner for all the
+         items created by the bot.
+Step 2.) Go into the realm database and note the account number for the
+         character.
+Step 3.) Go into the characters database and note the character's GUID.
+Step 4.) Log in at least once with this character.
+         (Do not change the configuration before this)
+Step 5.) Tune the configuration options in the configuration file and the
+         Database.
+
+#These are the settings in the configuration file:
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+AuctionHouseBot.DEBUG enables (1) or disables (0) Debug output
+AuctionHouseBot.EnableSeller enables (1) or disables (0) the Seller
+AuctionHouseBot.EnableBuyer enables (1) or disables (0) the Buyer
+AuctionHouseBot.UseBuyPriceForSeller Use SellPrice (0) or BuyPrice (1) for determining prices
+AuctionHouseBot.UseBuyPriceForBuyer Use SellPrice (0) or BuyPrice (1) for determining prices
+AuctionHouseBot.Account is the account number (in realmd->account table) of the player you want to run as the auction bot. Note: a value of 0 will disable the bot.
+AuctionHouseBot.GUID is the GUID (in characters->characters table) of the player you want to run as the auction bot. Note: a value of 0 will disable the bot.
+AuctionHouseBot.ItemsPerCycle determines how many items are added each time AHBot is run (once per minute, by default)
+
+#These are the Filters For filtering certain items/trade goods from the AH
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+
+AuctionHouseBot.VendorItems is a boolean value (0 or 1) that indicates whether to include Vendor only items
+AuctionHouseBot.VendorTradeGoods is a boolean value (0 or 1) that indicates whether to include Vendor only Trade Goods
+AuctionHouseBot.LootItems  is a boolean value (0 or 1) that indicates whether to include Loot/Fish/Skin/etc. only items
+AuctionHouseBot.LootTradeGoods  is a boolean value (0 or 1) that indicates whether to include Loot/Fish/Skin/etc. only Trade Goods
+AuctionHouseBot.OtherItems  is a boolean value (0 or 1) that indicates whether to include Other items not covered by the first 2
+AuctionHouseBot.OtherTradeGoods  is a boolean value (0 or 1) that indicates whether to include Other Trade Goods not covered by the first 2
+AuctionHouseBot.No_Bind is a boolean value (0 or 1) that indicates whether to include items with a bonding of 0
+AuctionHouseBot.Bind_When_Picked_Up = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 1
+AuctionHouseBot.Bind_When_Equipped = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 2
+AuctionHouseBot.Bind_When_Use = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 3
+AuctionHouseBot.Bind_Quest_Item = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 4
+AuctionHouseBot.DisabledItems is a list of item ids separated by space that will Disable certain items that are usually unavailable to Players
+AuctionHouseBot.DisablePermEnchant is a boolean value (0 or 1) that will Disable Items with a Permanent Enchantment
+AuctionHouseBot.DisableConjured is a boolean value (0 or 1) that will Disable Conjured Items
+AuctionHouseBot.DisableGems is a boolean value (0 or 1) that will Disable Gems
+AuctionHouseBot.DisableMoney is a boolean value (0 or 1) that will Disable Items that are used as money
+AuctionHouseBot.DisableMoneyLoot is a boolean value (0 or 1) that will Disable Items that have Money as a loot
+AuctionHouseBot.DisableLootable is a boolean value (0 or 1) that will Disable Items that have other items as loot
+AuctionHouseBot.DisableKeys is a boolean value (0 or 1) that will Disable Items that are keys
+AuctionHouseBot.DisableDuration is a boolean value (0 or 1) that will Disable Items with a duration
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel is a boolean value (0 or 1) that will Disable items that are BOP or Quest Item with a Required level that is less than the Item Level
+
+#These Filters are boolean (0 or 1) and will disable items that are
+#specifically meant for the Class named.
+#(UnusedClass is Class 10, which was skipped for some reason)
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+#These are the Filters For filtering certain items/trade goods from the AH
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
+#These are the settings in the Database:
+#Each Auctionhouse has it's own set of these
+
+MinItems = 0
+#The Minimum number of items you want to keep in the auction houses.
+#(default 0 - minimum will be the same as maximum).
+#If it is higher than the value of the corresponding maxItems setting,
+#it will be set down to match the maxItems setting.
+
+MaxItems = 0
+#The Maximum number of items you want to keep in the auction houses.
+
+#These must add up to 100 each one is the percentage
+#of the auction items that should be trade goods of
+#that quality. A value of 0 will disable.
+
+PercentGreyTradeGoods = 0
+PercentWhiteTradeGoods = 27
+PercentGreenTradeGoods = 12
+PercentBlueTradeGoods = 10
+PercentPurpleTradeGoods = 1
+PercentOrangeTradeGoods = 0
+PercentYellowTradeGoods = 0
+
+PercentGreyItems = 0
+PercentWhiteItems = 10
+PercentGreenItems = 30
+PercentBlueItems = 8
+PercentPurpleItems = 2
+PercentOrangeItems = 0
+PercentYellowItems = 0
+
+#MinPrice(Color)    is the minimum price adjustment for items. For example the default is 150, which means 150%. So if an item vendors for 1g it would go to auction for a minimum of 1.5g.
+#MaxPrice(Color)    is the maximum price adjustment for items.
+#MinBidPrice(Color) these two control the starting bid as a percent of the buyout price. For example, if MinBidPrice is 30 and MaxBidPrice is 80 the starting bid for the auction will randomly be between 30-80% of the randomly chosen buyout price.
+#MaxBidPrice(Color) these two control the starting bid as a percent of the buyout price. For example, if MinBidPrice is 30 and MaxBidPrice is 80 the starting bid for the auction will randomly be between 30-80% of the randomly chosen buyout price.
+#MaxStack(Color)    is maximum stack size to create for this quality type. A value of zero will disable the maximum stack size for this quality allowing the bot to create stacks (of random size) of items as big as the item type allows.
+
+MinPriceGrey = 100
+MaxPriceGrey = 150
+MinBidPriceGrey = 70
+MaxBidPriceGrey = 100
+MaxStackGrey = 0
+MinPriceWhite = 150
+MaxPriceWhite = 250
+MinBidPriceWhite = 70
+MaxBidPriceWhite = 100
+MaxStackWhite = 0
+MinPriceGreen = 800
+MaxPriceGreen = 1400
+MinBidPriceGreen = 80
+MaxBidPriceGreen = 100
+MaxStackGreen = 0
+MinPriceBlue = 1250
+MaxPriceBlue = 1750
+MinBidPriceBlue = 75
+MaxBidPriceBlue = 100
+MaxStackBlue = 0
+MinPricePurple = 2250
+MaxPricePurple = 4550
+MinBidPricePurple = 80
+MaxBidPricePurple = 100
+MaxStackPurple = 0
+MinPriceOrange = 4250
+MaxPriceOrange = 5550
+MinBidPriceOrange = 80
+MaxBidPriceOrange = 100
+MaxStackOrange = 0
+MinPriceYellow = 5250
+MaxPriceYellow = 6550
+MinBidPriceYellow = 80
+MaxBidPriceYellow = 100
+MaxStackYellow = 0
+
+#These are the multipliers that are applied to the vendor price for an item, that determines if AHBot will buy it or not.
+#1 means AHBot will pay the same as (or less than) a vendor would pay, 2 means up to twice as much, etc.
+
+BuyerPriceGrey = 1
+BuyerPriceWhite = 3
+BuyerPriceGreen = 5
+BuyerPriceBlue = 12
+BuyerPricePurple = 15
+BuyerPriceOrange = 20
+BuyerPriceYellow = 22
+
+#BuyerBiddingInterval is the time (in minutes) between bids.
+#BuyerBidsPerInterval is the number of bids the buyer will make in a cycle
+
+BuyerBiddingInterval = 1
+BuyerBidsPerInterval = 1
+
+
+
+How to use ahcommands from the console (CLI) or in game with GM level 3 players:
+ahbotoptions - will display usage instructions
+ahbotoptions help - will display the list of commands
+
+ahexpire - will expire all the auctions in the requested auction house that were created by AHBot.
+minitems - will set the minimum number of items in the AH before it starts being filled again.
+maxitems - will set the maximum number of items in the AH.
+percentages - will set the percentage of each quality in the AH
+minprice - will set the minimum price multiplier for auctions.
+maxprice - will set the maximum price multiplier for auctions.
+minbidprice - will set the minimum starting bid as a percent of the buyout price for auctions.
+maxbidprice - will set the maximum starting bid as a percent of the buyout price for auctions.
+maxstack - will set the maximum number of items in stacks for auctions. 0 will set the maximum to the maximum for that item type.
+buyerprice - will set the bid price multiplier for auctions.
+biddinginterval - will set the number of minutes between bids on auctions.
+bidsperinterval - will set the number of bids to enter per cycle.
+
+The auction house IDs are:
+2 - Alliance
+6 - Horde
+7 - Neutral
+
+
+AHBot Originally made by Chris K. Currently maintained by Paradox
+Much thanks to Chris K, grether and Dolomit6!
+AHBot Now includes AHBuyer created by Kerbe as a derivative of AHBot, and later modified by Paradox
diff --git a/sql/Bots/character_NPC_bots.sql b/sql/Bots/character_NPC_bots.sql
new file mode 100644
index 0000000..723043e
--- /dev/null
+++ b/sql/Bots/character_NPC_bots.sql
@@ -0,0 +1,12 @@
+DROP TABLE IF EXISTS `character_npcbot`;
+CREATE TABLE `character_npcbot` (
+  `owner` int(10) default NULL,
+  `entry` int(10) default NULL,
+  `race` tinyint(3) default NULL,
+  `class` tinyint(3) default NULL,
+  `istank` tinyint(3) default NULL,
+  PRIMARY KEY  (`owner`,`entry`)
+)  ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+
+
diff --git a/sql/Bots/world_bot_helper_locales_gossip_menu_option.sql b/sql/Bots/world_bot_helper_locales_gossip_menu_option.sql
new file mode 100644
index 0000000..a9f5c6b
--- /dev/null
+++ b/sql/Bots/world_bot_helper_locales_gossip_menu_option.sql
@@ -0,0 +1,92 @@
+delete from `locales_gossip_menu_option` where `menu_id` = '60000';
+
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','1','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','2','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','3','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','4','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','5','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','6','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','7','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','8','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','9','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','10','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','11','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','12','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','13','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','14','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','15','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','16','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','17','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','18','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','19','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','20','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','21','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','22','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','23','star','star','star','star','star','star','star','star',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','24','circle','circle','circle','circle','circle','circle','circle','circle',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','25','diamond','diamond','diamond','diamond','diamond','diamond','diamond','diamond',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','26','triangle','triangle','triangle','triangle','triangle','triangle','triangle','triangle',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','27','moon','moon','moon','moon','moon','moon','moon','moon',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','28','square','square','square','square','square','square','square','square',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','29','cross','cross','cross','cross','cross','cross','cross','cross',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','30','skull','skull','skull','skull','skull','skull','skull','skull',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','31','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','32','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','33','more bot available','more bot available','more bot available','more bot available','more bot available','more bot available','more bot available','more bot available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','34','more bots available','more bots available','more bots available','more bots available','more bots available','more bots available','more bots available','more bots available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','35','bot available','bot available','bot available','bot available','bot available','bot available','bot available','bot available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','36','bots available','bots available','bots available','bots available','bots available','bots available','bots available','bots available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+
+
+-- Custom section
+-- to change text displayed in botgiver's dialog you shoul
+-- 1) translate text to your language
+-- 2) place translated text in empty quotes below, (id = original id in `locales_gossip_menu_option`)
+-- 3) replace `option_text_loc1` with your locale index
+-- LOCALE_koKR        `option_text_loc1`
+-- LOCALE_frFR          `option_text_loc2`
+-- LOCALE_deDE        `option_text_loc3`
+-- LOCALE_zhCN        `option_text_loc4`
+-- LOCALE_zhTW       `option_text_loc5`
+-- LOCALE_esES         `option_text_loc6`
+-- LOCALE_esMX       `option_text_loc7`
+-- LOCALE_ruRU        `option_text_loc8`
+-- 4) run the queue below lol
+-- 5) you most likely need to save your translation for later
+
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 1;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 2;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 3;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 4;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 5;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 6;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 7;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 8;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 9;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 10;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 11;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 12;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 13;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 14;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 15;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 16;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 17;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 18;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 19;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 20;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 21;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 22;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 23;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 24;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 25;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 26;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 27;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 28;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 29;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 30;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 31;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 32;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 33;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 34;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 35;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 36;
diff --git a/sql/Bots/world_bots.sql b/sql/Bots/world_bots.sql
new file mode 100644
index 0000000..abd7bdd
--- /dev/null
+++ b/sql/Bots/world_bots.sql
@@ -0,0 +1,524 @@
+
+-- GENERAL --
+
+delete from `creature_template` where entry between 60001 and 60238;
+
+insert into `creature_template` 
+(`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, 
+`minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, 
+`rangeattacktime`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, 
+`type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, 
+`spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, 
+`questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) 
+values 
+('60001','0','0','0','0','0','5001','0','5001','0','Khelden','Mage Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60002','0','0','0','0','0','1294','0','1294','0','Zaldimar','Mage Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60003','0','0','0','0','0','1484','0','1484','0','Maginor','Mage Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60004','0','0','0','0','0','3344','0','3344','0','Anetta','Priest Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60005','0','0','0','0','0','1495','0','1495','0','Laurena','Priest Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60006','0','0','0','0','0','1295','0','1295','0','Josetta','Priest Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60007','0','0','0','0','0','3345','0','3345','0','Drusilla','Warlock Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60008','0','0','0','0','0','1930','0','1930','0','Alamar','Warlock Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60009','0','0','0','0','0','1469','0','1469','0','Demisette','Warlock Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60010','0','0','0','0','0','12749','0','12749','0','Nalesette','Hunter Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60011','0','0','0','0','0','3401','0','3401','0','Branstock','Priest Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60012','0','0','0','0','0','3395','0','3395','0','Thorgas','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60013','0','0','0','0','0','3343','0','3343','0','Llane','Warrior Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60014','0','0','0','0','0','3399','0','3399','0','Thran','Warrior Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60015','0','0','0','0','0','1300','0','1300','0','Lyria','Warrior Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60016','0','0','0','0','0','3351','0','3351','0','Jorik','Rogue Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60017','0','0','0','0','0','3407','0','3407','0','Solm','Rogue Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60018','0','0','0','0','0','1297','0','1297','0','Keryn','Rogue Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60019','0','0','0','0','0','1507','0','1507','0','Osborne','Rogue Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60020','0','0','0','0','0','3346','0','3346','0','Sammuel','Paladin Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60021','0','0','0','0','0','3393','0','3393','0','Bob','Paladin Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60022','0','0','0','0','0','1299','0','1299','0','Wilhelm','Paladin Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60023','0','0','0','0','0','1499','0','1499','0','Brisombre','Paladin Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60024','0','0','0','0','0','10216','0','10216','0','Marry','Mage Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60025','0','0','0','0','0','4552','0','4552','0','Haromm','Shaman Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60026','0','0','0','0','0','4567','0','4567','0','Kartosh','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60027','0','0','0','0','0','3429','0','3429','0','MaxanAnvol','Priest Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60028','0','0','0','0','0','10215','0','10215','0','Magis','Mage Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60029','0','0','0','0','0','3431','0','3431','0','GranVivehache','Warrior Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60030','0','0','0','0','0','1622','0','1622','0','Azar','Paladin Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60031','0','0','0','0','0','3436','0','3436','0','Hogral','Rogue Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60032','0','0','0','0','0','3053','0','3053','0','Kelstrum','Warrior Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60033','0','0','0','0','0','1578','0','1578','0','Dannal','Warrior Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60034','0','0','0','0','0','1579','0','1579','0','SombreDuesten','Priest Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60035','0','0','0','0','0','1592','0','1592','0','Isabella','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60036','0','0','0','0','0','1581','0','1581','0','Maximillion','Warlock Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60037','0','0','0','0','0','1604','0','1604','0','Rupert','Warlock Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60038','0','0','0','0','0','1600','0','1600','0','Cain','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60039','0','0','0','0','0','1602','0','1602','0','SombreBeryl','Priest Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60041','0','0','0','0','0','10548','0','10548','0','Milituus','Mage Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60042','0','0','0','0','0','2810','0','2810','0','Lexington','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60043','0','0','0','0','0','2123','0','2123','0','Siln','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60044','0','0','0','0','0','19598','0','19598','0','Umbrua','Shaman Bot','','0','80','80','2','1640','1640','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60045','0','0','0','0','0','2102','0','2102','0','Tigor','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60046','0','0','0','0','0','2082','0','2082','0','Beram','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60047','0','0','0','0','0','2106','0','2106','0','Turak','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60048','0','0','0','0','0','2121','0','2121','0','Sheal','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60049','0','0','0','0','0','2115','0','2115','0','Kym','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60050','0','0','0','0','0','2112','0','2112','0','Kary','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60051','0','0','0','0','0','2087','0','2087','0','Holt','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60052','0','0','0','0','0','2105','0','2105','0','Urek','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60053','0','0','0','0','0','2103','0','2103','0','Torm','Warrior Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60054','0','0','0','0','0','2096','0','2096','0','Sark','Warrior Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60055','0','0','0','0','0','17211','0','17211','0','Kerra','Warrior Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60056','0','0','0','0','0','2139','0','2139','0','Miles Welsh','Priest Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60057','0','0','0','0','0','2138','0','2138','0','Malakai','Priest Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60058','0','0','0','0','0','2137','0','2137','0','Cobb','Priest Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60059','0','0','0','0','0','2134','0','2134','0','Shymm','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','1','0','0','0','0','0','0','0','0','0','0','143','145','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60060','0','0','0','0','0','6058','0','6058','0','Ursyn','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60061','0','0','0','0','0','2135','0','2135','0','Thurston','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60062','0','0','0','0','0','3793','0','3793','0','Harutt','Warrior Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60063','0','0','0','0','0','3819','0','3819','0','Gart','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','8','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60064','0','0','0','0','0','3810','0','3810','0','Lanka','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60065','0','0','0','0','0','10180','0','10180','0','Meela','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60066','0','0','0','0','0','3794','0','3794','0','Krang','Warrior Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60067','0','0','0','0','0','10734','0','10734','0','Gennia','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60068','0','0','0','0','0','3811','0','3811','0','Yaw','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60069','0','0','0','0','0','3816','0','3816','0','Narm','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60070','0','0','0','0','0','1880','0','1880','0','Frang','Warrior Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60071','0','0','0','0','0','1882','0','1882','0','Jenshan','Hunter Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60072','0','0','0','0','0','1884','0','1884','0','Nartok','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60073','0','0','0','0','0','1878','0','1878','0','Shikrik','Shaman Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60074','0','0','0','0','0','3743','0','3743','0','Tarshaw','Warrior Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60075','0','0','0','0','0','3744','0','3744','0','Thotar','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60076','0','0','0','0','0','3745','0','3745','0','Dhugru','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60077','0','0','0','0','0','3746','0','3746','0','Swart','Shaman Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60078','0','0','0','0','0','1324','0','1324','0','Groldar','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60079','0','0','0','0','0','1325','0','1325','0','Mirket','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60080','0','0','0','0','0','1326','0','1326','0','Zevrost','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60081','0','0','0','0','0','1360','0','1360','0','Kardris','Shaman Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60082','0','0','0','0','0','1373','0','1373','0','Ormak','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60083','0','0','0','0','0','1374','0','1374','0','Grezz','Warrior Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60084','0','0','0','0','0','1375','0','1375','0','Sorek','Warrior Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60085','0','0','0','0','0','4231','0','4231','0','Siantsu','Shaman Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60086','0','0','0','0','0','4239','0','4239','0','Xorjuul','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60087','0','0','0','0','0','4241','0','4241','0','Siandur','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60088','0','0','0','0','0','4242','0','4242','0','Zelmak','Warrior Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60089','0','0','0','0','0','7915','0','7915','0','ClaudeErksine','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60090','0','0','0','0','0','1721','0','1721','0','Alyissia','Warrior Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60091','0','0','0','0','0','1725','0','1725','0','FrahunMurmombre','Rogue Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60092','0','0','0','0','0','1733','0','1733','0','Shanda','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60093','0','0','0','0','0','1732','0','1732','0','Mardant','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60094','0','0','0','0','0','1707','0','1707','0','Kyra','Warrior Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60095','0','0','0','0','0','1704','0','1704','0','Jannok','Rogue Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60096','0','0','0','0','0','1708','0','1708','0','Laurna','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60097','0','0','0','0','0','1706','0','1706','0','Kal','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60098','0','0','0','0','0','4296','0','4296','0','Harruk','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60099','0','0','0','0','0','4299','0','4299','0','Reban','Hunter bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60100','0','0','0','0','0','4304','0','4304','0','Bolyun','Hunter Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60101','0','0','0','0','0','1897','0','1897','0','Taijin','Priest Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60102','0','0','0','0','0','4068','0','4068','0','Kenjai','Priest Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60103','0','0','0','0','0','2066','0','2066','0','Danlaar','Hunter Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60104','0','0','0','0','0','2196','0','2196','0','Ariasta','Warrior Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60105','0','0','0','0','0','2198','0','2198','0','Sildanair','Warrior Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60106','0','0','0','0','0','2200','0','2200','0','Astarii','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60107','0','0','0','0','0','2201','0','2201','0','Jandria','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60108','0','0','0','0','0','2202','0','2202','0','Lariia','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60109','0','0','0','0','0','2231','0','2231','0','Syurna','Rogue Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60110','0','0','0','0','0','7669','0','7669','0','Elissa','Mage Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60111','0','0','0','0','0','2252','0','2252','0','Erion','Rogue Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60112','0','0','0','0','0','2243','0','2243','0','Anishar','Rogue Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60113','0','0','0','0','0','2250','0','2250','0','Denatharion','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60114','0','0','0','0','0','2255','0','2255','0','Fylerian','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60115','0','0','0','0','0','2416','0','2416','0','Caelyb','Hunter Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60116','0','0','0','0','0','2675','0','2675','0','Kaal','Warlock Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60117','0','0','0','0','0','16800','0','16800','0','Lana','Warlock Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60118','0','0','0','0','0','2646','0','2646','0','Richard','Warlock Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60119','0','0','0','0','0','10214','0','10214','0','Kaelystia','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','6','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60120','0','0','0','0','0','2644','0','2644','0','Pierce','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60121','0','0','0','0','0','2657','0','2657','0','Anastasia','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60122','0','0','0','0','0','2620','0','2620','0','Chris','Warrior Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60123','0','0','0','0','0','2658','0','2658','0','Angela','Warrior Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60124','0','0','0','0','0','2614','0','2614','0','Baltus','Warrior Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60125','0','0','0','0','0','3054','0','3054','0','Kelv','Warrior Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60126','0','0','0','0','0','3055','0','3055','0','Bilban','Warrior Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60127','0','0','0','0','0','3056','0','3056','0','Daera','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60128','0','0','0','0','0','3072','0','3072','0','Olmin','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60129','0','0','0','0','0','3073','0','3073','0','Regnus','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60130','0','0','0','0','0','3086','0','3086','0','Theodrus','Priest Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60131','0','0','0','0','0','3066','0','3066','0','Braenna','Priest Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60132','0','0','0','0','0','3085','0','3085','0','Toldren','Priest Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60134','0','0','0','0','0','3108','0','3108','0','Bink','Mage Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60135','0','0','0','0','0','10214','0','10214','0','Juli','Mage Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60136','0','0','0','0','0','3109','0','3109','0','Nittegousse','Mage Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60137','0','0','0','0','0','3089','0','3089','0','Valgar','Paladin Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60138','0','0','0','0','0','3088','0','3088','0','Beldruk','Paladin Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60139','0','0','0','0','0','3087','0','3087','0','Brandur','Paladin Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60140','0','0','0','0','0','3101','0','3101','0','Hulfdan','Rogue Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60141','0','0','0','0','0','3100','0','3100','0','Ormyr','Rogue Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60142','0','0','0','0','0','3113','0','3113','0','Phenwick','Rogue Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60143','0','0','0','0','0','3115','0','3115','0','Coeurdechardon','Warlock Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60144','0','0','0','0','0','3116','0','3116','0','Eglantin','Warlock Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60145','0','0','0','0','0','3122','0','3122','0','Alexander','Warlock Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60146','0','0','0','0','0','3280','0','3280','0','Wu','Warrior Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60147','0','0','0','0','0','3287','0','3287','0','Ilsa','Warrior Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60148','0','0','0','0','0','3283','0','3283','0','Joshua','Priest Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60149','0','0','0','0','0','3284','0','3284','0','Arthur','Paladin Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60150','0','0','0','0','0','3289','0','3289','0','Katherine','Paladin Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60151','0','0','0','0','0','3291','0','3291','0','Deline','Warlock Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60152','0','0','0','0','0','3286','0','3286','0','Sandahl','Warlock Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60153','0','0','0','0','0','3292','0','3292','0','Jennea','Mage Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60154','0','0','0','0','0','19803','0','19803','0','Elsharin','Mage Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60155','0','0','0','0','0','3299','0','3299','0','Kaerbrus','Hunter Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60156','0','0','0','0','0','3300','0','3300','0','Sheldras','Druid Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60157','0','0','0','0','0','3301','0','3301','0','Theridran','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60158','0','0','0','0','0','3312','0','3312','0','Einris','Hunter Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60159','0','0','0','0','0','3309','0','3309','0','Ulfir','Hunter Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60160','0','0','0','0','0','3310','0','3310','0','Thorfin','Hunter Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60161','0','0','0','0','0','10171','0','10171','0','UnThuwa','Mage Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60162','0','0','0','0','0','4524','0','4524','0','Pephredo','Mage Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60163','0','0','0','0','0','4522','0','4522','0','Enyo','Mage Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60164','0','0','0','0','0','4526','0','4526','0','Mai','Mage Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60165','0','0','0','0','0','4523','0','4523','0','Deino','Mage Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60166','0','0','0','0','0','4665','0','4665','0','Birgitte','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60167','0','0','0','0','0','12849','0','12849','0','Thuul','Mage Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60168','0','0','0','0','0','4690','0','4690','0','Zayus','Priest Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60169','0','0','0','0','0','10473','0','10473','0','Xyera','Priest Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60170','0','0','0','0','0','4711','0','4711','0','Urkyo','Priest Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60171','0','0','0','0','0','6060','0','6060','0','Uthelnay','Mage Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60172','0','0','0','0','0','6072','0','6072','0','Dink','Mage Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60173','0','0','0','0','0','6071','0','6071','0','Darnath','Warrior Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60174','0','0','0','0','0','7356','0','7356','0','Karman','Paladin Bot','','0','80','80','2','894','894','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60175','0','0','0','0','0','11037','0','11037','0','Evencane','Warrior Bot','','0','80','80','2','894','894','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60176','0','0','0','0','0','7357','0','7357','0','Jannos','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60177','0','0','0','0','0','7538','0','7538','0','Alenndaar','Hunter Bot','','0','80','80','2','1076','1076','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60178','0','0','0','0','0','10738','0','10738','0','Golhine','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60179','0','0','0','0','0','9337','0','9337','0','Hesuwa','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60180','0','0','0','0','0','9336','0','9336','0','Xao\'tsu','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60181','0','0','0','0','0','9338','0','9338','0','Belia','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60182','0','0','0','0','0','10245','0','10245','0','Dargh','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60183','0','0','0','0','0','11044','0','11044','0','Meideros','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60184','0','0','0','0','0','11048','0','11048','0','Presse','Priest Bot','','0','80','80','2','1076','1076','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60185','0','0','0','0','0','11053','0','11053','0','Rohan','Priest Bot','','0','80','80','2','122','122','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60186','0','0','0','0','0','12053','0','12053','0','Loganaar','Druid Bot','','0','80','80','2','994','994','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60187','0','0','0','0','0','13171','0','13171','0','Romano','Rogue Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60188','0','0','0','0','0','13341','0','13341','0','Sagorne','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60189','0','0','0','0','0','15522','0','15522','0','Julia','Mage Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60190','0','0','0','0','0','15511','0','15511','0','Jesthenis','Paladin Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60191','0','0','0','0','0','15524','0','15524','0','Invocateur','Warlock Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60192','0','0','0','0','0','15518','0','15518','0','Matrone','Priest Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60193','0','0','0','0','0','2659','0','2659','0','Eclaireur','Rogue Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60194','0','0','0','0','0','15520','0','15520','0','Sallina','Hunter Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60195','0','0','0','0','0','16685','0','16685','0','Noellene','Paladin Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60196','0','0','0','0','0','16707','0','16707','0','Ponaris','Priest Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60197','0','0','0','0','0','16222','0','16222','0','Keilnei','Hunter Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60198','0','0','0','0','0','16223','0','16223','0','Valaatu','Mage Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60199','0','0','0','0','0','16224','0','16224','0','Aurelon','Paladin Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60200','0','0','0','0','0','16225','0','16225','0','Zalduun','Priest Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60201','0','0','0','0','0','16226','0','16226','0','Kore','Warrior Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60202','0','0','0','0','0','16787','0','16787','0','Alamma','Warlock Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60203','0','0','0','0','0','16800','0','16800','0','Talionia','Warlock Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('60204','0','0','0','0','0','16831','0','16831','0','Zanien','Hunter Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60205','0','0','0','0','0','16781','0','16781','0','Zaedana','Mage Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60206','0','0','0','0','0','16824','0','16824','0','Quithas','Mage Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60207','0','0','0','0','0','16739','0','16739','0','Harene','Druid Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60208','0','0','0','0','0','16778','0','16778','0','Tana','Hunter Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60209','0','0','0','0','0','16816','0','16816','0','Oninath','Hunter Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60210','0','0','0','0','0','16829','0','16829','0','Bachi','Paladin Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60211','0','0','0','0','0','16767','0','16767','0','Zelanis','Rogue Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60212','0','0','0','0','0','16798','0','16798','0','Elara','Rogue Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('60213','0','0','0','0','0','16858','0','16858','0','Shalannius','Druid Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('60214','0','0','0','0','0','17434','0','17434','0','Deremiis','Hunter Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60215','0','0','0','0','0','17247','0','17247','0','Caedmos','Priest Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60216','0','0','0','0','0','17225','0','17225','0','Baatun','Paladin Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60217','0','0','0','0','0','17212','0','17212','0','Ahonan','Warrior Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60218','0','0','0','0','0','17598','0','17598','0','Firmanvaar','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60219','0','0','0','0','0','16860','0','16860','0','Actron','Hunter Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60220','0','0','0','0','0','17213','0','17213','0','Behomat','Warrior Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60221','0','0','0','0','0','17600','0','17600','0','Nobundo','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60222','0','0','0','0','0','17599','0','17599','0','Tuluun','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60223','0','0','0','0','0','16914','0','16914','0','Sulaa','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60224','0','0','0','0','0','17215','0','17215','0','Ruada','Warrior Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('60225','0','0','0','0','0','17233','0','17233','0','Semid','Mage Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60226','0','0','0','0','0','17232','0','17232','0','Guvan','Priest Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60227','0','0','0','0','0','17234','0','17234','0','Tullas','Paladin Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60228','0','0','0','0','0','17488','0','17488','0','Killac','Hunter bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('60229','0','0','0','0','0','17226','0','17226','0','Jol','Paladin Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60230','0','0','0','0','0','17248','0','17248','0','Fallat','Priest Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('60231','0','0','0','0','0','17243','0','17243','0','Harnan','Mage Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60232','0','0','0','0','0','17241','0','17241','0','Bati','Mage Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('60233','0','0','0','0','0','17792','0','17792','0','Hobahken','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60234','0','0','0','0','0','6820','0','6820','0','Gurrag','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('60235','0','0','0','0','0','19596','0','19596','0','Auberose','Paladin Bot','','0','80','80','2','1602','1602','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('60236','0','0','0','0','0','10335','10335','10335','10335','Afina','Priest Bot','','0','80','80','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','2','0','0','0','7','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','priest_bot','0'),
+('60237','0','0','0','0','0','1132','0','1132','0','Voidwalker','Warlock\'s Pet Bot',NULL,'0','80','80','2','14','14','0','1.2','1.3','1','0','2','3','0','0','1','2000','2000','1','0','0','0','16','0','0','1','0','0','0','0','3','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','voidwalker_bot','0'),
+('60238','0','0','0','0','0','1105','0','0','0','Hunter\'s Pet',NULL,NULL,'0','80','80','0','14','14','0','1.1','1.14286','1','0','87','117','0','214','1','2000','0','1','0','0','0','7','0','0','1','0','61','90','21','1','1','0','0','0','0','0','0','0','0','0','5708','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','149','1','0','0','','0');
+
+-- EQUIPS --
+
+delete from `creature_equip_template` where entry between 60001 and 60238;
+
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60001','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60002','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60003','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60004','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60005','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60006','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60007','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60008','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60009','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60010','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60011','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60012','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60013','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60014','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60015','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60016','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60017','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60018','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60019','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60020','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60021','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60022','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60023','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60024','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60025','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60026','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60027','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60028','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60029','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60030','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60031','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60032','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60033','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60034','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60035','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60036','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60037','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60038','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60039','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60041','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60042','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60043','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60044','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60045','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60046','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60047','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60048','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60049','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60050','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60051','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60052','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60053','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60054','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60055','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60056','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60057','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60058','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60059','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60060','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60061','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60062','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60063','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60064','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60065','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60066','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60067','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60068','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60069','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60070','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60071','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60072','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60073','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60074','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60075','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60076','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60077','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60078','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60079','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60080','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60081','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60082','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60083','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60084','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60085','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60086','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60087','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60088','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60089','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60090','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60091','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60092','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60093','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60094','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60095','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60096','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60097','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60098','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60099','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60100','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60101','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60102','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60103','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60104','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60105','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60106','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60107','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60108','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60109','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60110','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60111','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60112','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60113','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60114','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60115','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60116','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60117','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60118','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60119','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60120','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60121','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60122','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60123','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60124','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60125','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60126','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60127','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60128','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60129','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60130','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60131','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60132','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60134','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60135','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60136','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60137','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60138','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60139','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60140','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60141','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60142','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60143','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60144','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60145','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60146','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60147','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60148','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60149','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60150','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60151','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60152','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60153','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60154','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60155','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60156','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60157','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60158','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60159','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60160','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60161','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60162','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60163','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60164','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60165','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60166','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60167','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60168','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60169','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60170','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60171','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60172','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60173','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60174','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60175','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60176','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60177','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60178','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60179','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60180','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60181','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60182','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60183','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60184','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60185','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60186','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60187','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60188','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60189','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60191','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60192','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60193','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60194','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60195','1','12584','18826','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60196','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60197','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60198','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60199','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60200','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60201','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60202','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60203','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60204','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60205','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60206','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60207','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60208','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60209','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60210','1','12584','18826','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60211','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60212','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60213','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60214','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60215','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60216','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60217','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60218','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60219','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60220','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60221','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60222','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60223','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60224','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60225','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60226','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60227','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60229','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60230','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60231','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60232','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60233','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60234','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60235','1','29175','18826','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('60236','1','31289','0','0');
+
+
+
+-- Customize section
+-- You can create your own values to be in line with your own server if these are not acceptable.
+
+-- Add flags_extra
+SET @EX_NO_BLOCK = 16;
+SET @EX_NO_CRUSH = 32;
+SET @EX_NO_XP = 64;
+SET @EX_DIMINISH = 1048576;
+SET @FLAGS_EX = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH;
+
+-- minions
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=4, minlevel:=80, maxlevel:=80, baseattacktime:=2200, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 60000 && entry < 60239 and subname='Druid Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=3, minlevel:=80, maxlevel:=80, baseattacktime:=2800, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 60000 && entry < 60239 and subname='Hunter Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=1, minlevel:=80, maxlevel:=80, baseattacktime:=3800, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 60000 && entry < 60239 and subname='Mage Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=4, minlevel:=80, maxlevel:=80, baseattacktime:=2300, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 60000 && entry < 60239 and subname='Paladin Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=1, minlevel:=80, maxlevel:=80, baseattacktime:=3600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 60000 && entry < 60239 and subname='Priest Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=2, minlevel:=80, maxlevel:=80, baseattacktime:=1600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 60000 && entry < 60239 and subname='Rogue Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=2, minlevel:=80, maxlevel:=80, baseattacktime:=2600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 60000 && entry < 60239 and subname='Shaman Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=1, minlevel:=80, maxlevel:=80, baseattacktime:=3500, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 60000 && entry < 60239 and subname='Warlock Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=3, maxdmg:=5, minlevel:=80, maxlevel:=80, baseattacktime:=3400, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 60000 && entry < 60239 and subname='Warrior Bot';
+
+-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		
+-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	
+-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		
+-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	
+-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		
+-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		
+-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	
+-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	
+-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	
+
+-- pets
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 2, maxdmg:= 3, minlevel:=80, maxlevel:=80, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry between 60001 and 60239 and name='Voidwalker';
+
+
diff --git a/sql/VIPAccounts/auth_VIPAccount.sql b/sql/VIPAccounts/auth_VIPAccount.sql
new file mode 100644
index 0000000..df317ed
--- /dev/null
+++ b/sql/VIPAccounts/auth_VIPAccount.sql
@@ -0,0 +1,8 @@
+CREATE TABLE IF NOT EXISTS `account_premium` (
+  `id` int(11) NOT NULL default '0' COMMENT 'Account id',
+  `setdate` bigint(40) NOT NULL default '0',
+  `unsetdate` bigint(40) NOT NULL default '0',
+  `premium_type` tinyint(4) unsigned NOT NULL default '1',
+  `active` tinyint(4) NOT NULL default '1',
+  PRIMARY KEY  (`id`,`setdate`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Premium Accounts';
\ No newline at end of file
diff --git a/sql/tools/setup_ahbot.sql b/sql/tools/setup_ahbot.sql
new file mode 100644
index 0000000..767a01e
--- /dev/null
+++ b/sql/tools/setup_ahbot.sql
@@ -0,0 +1,72 @@
+CREATE TABLE `auctionhousebot` (
+    `auctionhouse` INT(11) NOT NULL DEFAULT '0' COMMENT 'mapID of the auctionhouse.',
+    `name` CHAR(25) NULL DEFAULT NULL COMMENT 'Text name of the auctionhouse.',
+    `minitems` INT(11) NULL DEFAULT '0' COMMENT 'This is the minimum number of items you want to keep in the auction house. a 0 here will make it the same as the maximum.',
+    `maxitems` INT(11) NULL DEFAULT '0' COMMENT 'This is the number of items you want to keep in the auction house.',
+    `percentgreytradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Grey Trade Goods auction items',
+    `percentwhitetradegoods` INT(11) NULL DEFAULT '27' COMMENT 'Sets the percentage of the White Trade Goods auction items',
+    `percentgreentradegoods` INT(11) NULL DEFAULT '12' COMMENT 'Sets the percentage of the Green Trade Goods auction items',
+    `percentbluetradegoods` INT(11) NULL DEFAULT '10' COMMENT 'Sets the percentage of the Blue Trade Goods auction items',
+    `percentpurpletradegoods` INT(11) NULL DEFAULT '1' COMMENT 'Sets the percentage of the Purple Trade Goods auction items',
+    `percentorangetradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Orange Trade Goods auction items',
+    `percentyellowtradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Yellow Trade Goods auction items',
+    `percentgreyitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Grey auction items',
+    `percentwhiteitems` INT(11) NULL DEFAULT '10' COMMENT 'Sets the percentage of the non trade White auction items',
+    `percentgreenitems` INT(11) NULL DEFAULT '30' COMMENT 'Sets the percentage of the non trade Green auction items',
+    `percentblueitems` INT(11) NULL DEFAULT '8' COMMENT 'Sets the percentage of the non trade Blue auction items',
+    `percentpurpleitems` INT(11) NULL DEFAULT '2' COMMENT 'Sets the percentage of the non trade Purple auction items',
+    `percentorangeitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Orange auction items',
+    `percentyellowitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Yellow auction items',
+    `minpricegrey` INT(11) NULL DEFAULT '100' COMMENT 'Minimum price of Grey items (percentage).',
+    `maxpricegrey` INT(11) NULL DEFAULT '150' COMMENT 'Maximum price of Grey items (percentage).',
+    `minpricewhite` INT(11) NULL DEFAULT '150' COMMENT 'Minimum price of White items (percentage).',
+    `maxpricewhite` INT(11) NULL DEFAULT '250' COMMENT 'Maximum price of White items (percentage).',
+    `minpricegreen` INT(11) NULL DEFAULT '800' COMMENT 'Minimum price of Green items (percentage).',
+    `maxpricegreen` INT(11) NULL DEFAULT '1400' COMMENT 'Maximum price of Green items (percentage).',
+    `minpriceblue` INT(11) NULL DEFAULT '1250' COMMENT 'Minimum price of Blue items (percentage).',
+    `maxpriceblue` INT(11) NULL DEFAULT '1750' COMMENT 'Maximum price of Blue items (percentage).',
+    `minpricepurple` INT(11) NULL DEFAULT '2250' COMMENT 'Minimum price of Purple items (percentage).',
+    `maxpricepurple` INT(11) NULL DEFAULT '4550' COMMENT 'Maximum price of Purple items (percentage).',
+    `minpriceorange` INT(11) NULL DEFAULT '3250' COMMENT 'Minimum price of Orange items (percentage).',
+    `maxpriceorange` INT(11) NULL DEFAULT '5550' COMMENT 'Maximum price of Orange items (percentage).',
+    `minpriceyellow` INT(11) NULL DEFAULT '5250' COMMENT 'Minimum price of Yellow items (percentage).',
+    `maxpriceyellow` INT(11) NULL DEFAULT '6550' COMMENT 'Maximum price of Yellow items (percentage).',
+    `minbidpricegrey` INT(11) NULL DEFAULT '70' COMMENT 'Starting bid price of Grey items as a percentage of the randomly chosen buyout price. Default: 70',
+    `maxbidpricegrey` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Grey items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricewhite` INT(11) NULL DEFAULT '70' COMMENT 'Starting bid price of White items as a percentage of the randomly chosen buyout price. Default: 70',
+    `maxbidpricewhite` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of White items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricegreen` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Green items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpricegreen` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Green items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceblue` INT(11) NULL DEFAULT '75' COMMENT 'Starting bid price of Blue items as a percentage of the randomly chosen buyout price. Default: 75',
+    `maxbidpriceblue` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Blue items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricepurple` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Purple items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpricepurple` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Purple items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceorange` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Orange items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpriceorange` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Orange items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceyellow` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Yellow items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpriceyellow` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Yellow items as a percentage of the randomly chosen buyout price. Default: 100',
+    `maxstackgrey` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackwhite` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackgreen` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackblue` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackpurple` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackorange` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackyellow` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `buyerpricegrey` INT(11) NULL DEFAULT '1' COMMENT 'Multiplier to vendorprice when buying grey items from auctionhouse',
+    `buyerpricewhite` INT(11) NULL DEFAULT '3' COMMENT 'Multiplier to vendorprice when buying white items from auctionhouse',
+    `buyerpricegreen` INT(11) NULL DEFAULT '5' COMMENT 'Multiplier to vendorprice when buying green items from auctionhouse',
+    `buyerpriceblue` INT(11) NULL DEFAULT '12' COMMENT 'Multiplier to vendorprice when buying blue items from auctionhouse',
+    `buyerpricepurple` INT(11) NULL DEFAULT '15' COMMENT 'Multiplier to vendorprice when buying purple items from auctionhouse',
+    `buyerpriceorange` INT(11) NULL DEFAULT '20' COMMENT 'Multiplier to vendorprice when buying orange items from auctionhouse',
+    `buyerpriceyellow` INT(11) NULL DEFAULT '22' COMMENT 'Multiplier to vendorprice when buying yellow items from auctionhouse',
+    `buyerbiddinginterval` INT(11) NULL DEFAULT '1' COMMENT 'Interval how frequently AHB bids on each AH. Time in minutes',
+    `buyerbidsperinterval` INT(11) NULL DEFAULT '1' COMMENT 'number of bids to put in per bidding interval',
+    PRIMARY KEY (`auctionhouse`)
+)
+ENGINE=InnoDB
+ROW_FORMAT=DEFAULT;
+
+insert  into `auctionhousebot`(`auctionhouse`,`name`,`minitems`,`maxitems`,`percentgreytradegoods`,`percentwhitetradegoods`,`percentgreentradegoods`,`percentbluetradegoods`,`percentpurpletradegoods`,`percentorangetradegoods`,`percentyellowtradegoods`,`percentgreyitems`,`percentwhiteitems`,`percentgreenitems`,`percentblueitems`,`percentpurpleitems`,`percentorangeitems`,`percentyellowitems`,`minpricegrey`,`maxpricegrey`,`minpricewhite`,`maxpricewhite`,`minpricegreen`,`maxpricegreen`,`minpriceblue`,`maxpriceblue`,`minpricepurple`,`maxpricepurple`,`minpriceorange`,`maxpriceorange`,`minpriceyellow`,`maxpriceyellow`,`minbidpricegrey`,`maxbidpricegrey`,`minbidpricewhite`,`maxbidpricewhite`,`minbidpricegreen`,`maxbidpricegreen`,`minbidpriceblue`,`maxbidpriceblue`,`minbidpricepurple`,`maxbidpricepurple`,`minbidpriceorange`,`maxbidpriceorange`,`minbidpriceyellow`,`maxbidpriceyellow`,`maxstackgrey`,`maxstackwhite`,`maxstackgreen`,`maxstackblue`,`maxstackpurple`,`maxstackorange`,`maxstackyellow`,`buyerpricegrey`,`buyerpricewhite`,`buyerpricegreen`,`buyerpriceblue`,`buyerpricepurple`,`buyerpriceorange`,`buyerpriceyellow`,`buyerbiddinginterval`,`buyerbidsperinterval`) values
+(2,'Alliance',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1),
+(6,'Horde',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1),
+(7,'Neutral',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1);
diff --git a/sql/tools/setup_npc_teleport.sql b/sql/tools/setup_npc_teleport.sql
new file mode 100644
index 0000000..03b9e93
--- /dev/null
+++ b/sql/tools/setup_npc_teleport.sql
@@ -0,0 +1,119 @@
+DROP TABLE IF EXISTS `custom_npc_tele_category`;
+CREATE TABLE `custom_npc_tele_category` (
+  `id` int(6) unsigned NOT NULL default '0',
+  `name` varchar(255) NOT NULL default '',
+  `flag` tinyint(3) unsigned NOT NULL default '0',
+  `data0` bigint(20) unsigned NOT NULL default '0',
+  `data1` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_destination`;
+CREATE TABLE `custom_npc_tele_destination` (
+  `id` int(6) unsigned NOT NULL auto_increment,
+  `name` char(100) NOT NULL default '',
+  `pos_X` float NOT NULL default '0',
+  `pos_Y` float NOT NULL default '0',
+  `pos_Z` float NOT NULL default '0',
+  `map` smallint(5) unsigned NOT NULL default '0',
+  `orientation` float NOT NULL default '0',
+  `level` tinyint(3) unsigned NOT NULL default '0',
+  `cost` int(10) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_association`;
+CREATE TABLE `custom_npc_tele_association` (
+  `cat_id` int(6) unsigned NOT NULL default '0',
+  `dest_id` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`cat_id`, `dest_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+TRUNCATE `custom_npc_tele_category`;
+INSERT INTO `custom_npc_tele_category`
+   (`id`, `name`, `flag`, `data0`, `data1`)
+VALUES
+   (1, 'Cities', 0, 1, 0),
+   (2, 'Cities', 0, 2, 0),
+   (3, 'Battlegrounds', 0, 1, 0),
+   (4, 'Battlegrounds', 0, 2, 0),
+   (5, 'Arenas', 0, 0, 0),
+   (6, '[Instances Lvl 1-60]', 0, 0, 0),
+   (7, '[Instances Lvl 60+]', 5, 60, 0),
+   (8, '[Instances Lvl 70+]', 5, 70, 0),
+   (9, 'Destinations MJ', 3, 0, 0);
+
+TRUNCATE `custom_npc_tele_destination`;
+INSERT INTO `custom_npc_tele_destination`
+   (`id`, `name`, `pos_X`, `pos_Y`, `pos_Z`, `map`, `orientation`, `level`, `cost`)
+VALUES
+   (1, 'Alterac Valley', 883.187, -489.375, 96.7618, 30, 3.06932, 0, 0),
+   (2, 'Alterac Valley', -818.155, -623.043, 54.0884, 30, 2.1, 0, 0),
+   (3, 'Arathi Basin', 686.053, 683.165, -12.9149, 529, 0.18, 0, 0),
+   (4, 'Arathi Basin', 1308.68, 1306.03, -9.0107, 529, 3.91285, 0, 0),
+   (5, 'Black Temple', -3610.72, 324.988, 37.4, 530, 3.28298, 0, 0),
+   (6, 'Blackfathom Deeps', 4254.58, 664.74, -29.04, 1, 1.97, 0, 0),
+   (7, 'Blackrock Depths', -7301.03, -913.19, 165.37, 0, 0.08, 0, 0),
+   (8, 'Blackrock Spire', -7535.43, -1212.04, 285.45, 0, 5.29, 0, 0),
+   (9, 'Blackwing Lair', -7665.55, -1102.49, 400.679, 469, 0, 0, 0),
+   (10, 'Caverns of Time', -8173.66, -4746.36, 33.8423, 1, 4.93989, 0, 0),
+   (11, 'Circle of Blood', 2839.44, 5930.17, 11.1002, 530, 3.16284, 0, 0),
+   (12, 'Coilfang Reservoir', 517.288, 6976.28, 32.0072, 530, 0, 0, 0),
+   (13, 'Darnassus', 9947.52, 2482.73, 1316.21, 1, 0, 0, 0),
+   (14, 'Dire Maul', -3982.47, 1127.79, 161.02, 1, 0.05, 0, 0),
+   (15, 'Exodar', -4073.03, -12020.4, -1.47, 530, 0, 0, 0),
+   (16, 'Eye of the Storm', 2487.72, 1609.12, 1224.64, 566, 3.35671, 0, 0),
+   (17, 'Eye of the Storm', 1843.73, 1529.77, 1224.43, 566, 0.297579, 0, 0),
+   (18, 'Goldshire', -9464, 62, 56, 0, 0, 0, 0),
+   (19, 'Gruul\'s Lair', 3539.01, 5082.36, 1.69107, 530, 0, 0, 0),
+   (20, 'Gurubashi', -13261.3, 168.294, 35.0792, 0, 1.00688, 0, 0),
+   (21, 'Hellfire Citadel', -305.816, 3056.4, -2.47318, 530, 2.01, 0, 0),
+   (22, 'Ironforge', -4924.07, -951.95, 501.55, 0, 5.4, 0, 0),
+   (23, 'Isle Of Quel\'Danas', 12947.4, -6893.31, 5.68398, 530, 3.09154, 0, 0),
+   (24, 'Karazhan', -11118.8, -2010.84, 47.0807, 0, 0, 0, 0),
+   (25, 'Maraudon', -1433.33, 2955.34, 96.21, 1, 4.82, 0, 0),
+   (26, 'Molten Core', 1121.45, -454.317, -101.33, 230, 3.5, 0, 0),
+   (27, 'Naxxramas', 3125.18, -3748.02, 136.049, 0, 0, 0, 0),
+   (28, 'Onyxia\'s Lair', -4707.44, -3726.82, 54.6723, 1, 3.8, 0, 0),
+   (29, 'Orgrimmar', 1552.5, -4420.66, 8.94802, 1, 0, 0, 0),
+   (30, 'Razor Hill', 315.721, -4743.4, 10.4867, 1, 0, 0, 0),
+   (31, 'Razorfen Downs', -4645.08, -2470.85, 85.53, 1, 4.39, 0, 0),
+   (32, 'Razorfen Kraul', -4484.04, -1739.4, 86.47, 1, 1.23, 0, 0),
+   (33, 'Ring of Trials', -1999.94, 6581.71, 11.32, 530, 2.3, 0, 0),
+   (34, 'Ruins of Ahn\'Qiraj', -8409.03, 1498.83, 27.3615, 1, 2.49757, 0, 0),
+   (35, 'Scholomance', 1219.01, -2604.66, 85.61, 0, 0.5, 0, 0),
+   (36, 'Shadowfang Keep', -254.47, 1524.68, 76.89, 0, 1.56, 0, 0),
+   (37, 'Shattrath City', -1850.21, 5435.82, -10.9614, 530, 3.40391, 0, 0),
+   (38, 'Silvermoon', 9338.74, -7277.27, 13.7895, 530, 0, 0, 0),
+   (39, 'Stormwind', -8960.14, 516.266, 96.3568, 0, 0, 0, 0),
+   (40, 'Stratholme', 3263.54, -3379.46, 143.59, 0, 0, 0, 0),
+   (41, 'Tempest Keep', 3089.58, 1399.05, 187.653, 530, 4.79407, 0, 0),
+   (42, 'Temple of Ahn\'Qiraj', -8245.84, 1983.74, 129.072, 1, 0.936195, 0, 0),
+   (43, 'The Deadmines', -11212, 1658.58, 25.67, 0, 1.45, 0, 0),
+   (44, 'The Maul', -3761.49, 1133.43, 132.083, 1, 4.57259, 0, 0),
+   (45, 'The Scarlet Monastery', 2843.89, -693.74, 139.32, 0, 5.11, 0, 0),
+   (46, 'The Sunken Temple', -10346.9, -3851.9, -43.41, 0, 6.09, 0, 0),
+   (47, 'The Wailing Caverns', -722.53, -2226.3, 16.94, 1, 2.71, 0, 0),
+   (48, 'Thunder Bluff', -1290, 147.034, 129.682, 1, 4.919, 0, 0),
+   (49, 'Uldaman', -6119.7, -2957.3, 204.11, 0, 0.03, 0, 0),
+   (50, 'Undercity', 1819.71, 238.79, 60.5321, 0, 0, 0, 0),
+   (51, 'Warsong Gulch', 930.851, 1431.57, 345.537, 489, 0.015704, 0, 0),
+   (52, 'Warsong Gulch', 1525.95, 1481.66, 352.001, 489, 3.20756, 0, 0),
+   (53, 'Zul\'Aman', 6846.95, -7954.5, 170.028, 530, 4.61501, 0, 0),
+   (54, 'Zul\'Farrak', -6839.39, -2911.03, 8.87, 1, 0.41, 0, 0),
+   (55, 'Zul\'Gurub', -11916.7, -1212.82, 92.2868, 0, 4.6095, 0, 0),
+   (56, 'Ile des MJ', 16254, 16276.9, 14.5082, 1, 1.70269, 0, 0);
+
+TRUNCATE `custom_npc_tele_association`;
+INSERT INTO `custom_npc_tele_association`
+  (`cat_id`, `dest_id`)
+VALUES
+  (1, 13), (1, 15), (1, 18), (1, 22), (1, 23), (1, 37), (1, 39), (2, 23), (2, 29), (2, 30), (2, 37), (2, 38), (2, 48), (2, 50), (3, 1), (3, 4), (3, 16), (3, 52), (4, 2), (4, 3), (4, 17), (4, 51), (5, 11), (5, 20), (5, 33), (5, 44), (6, 6), (6, 7), (6, 8), (6, 14), (6, 25), (6, 31), (6, 32), (6, 35), (6, 36), (6, 40), (6, 43), (6, 45), (6, 46), (6, 47), (6, 49), (6, 54), (7, 9), (7, 26), (7, 27), (7, 28), (7, 34), (7, 42), (7, 55), (8, 5), (8, 10), (8, 12), (8, 19), (8, 21), (8, 24), (8, 41), (8, 53), (9, 56);
+
+-- `npc_text`
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100000, 'Choose your Category.'),
+   (100001, 'Choose your Destination.');
+
+-- `creature_template`
+INSERT INTO `creature_template` VALUES (100000, 0, 0, 0, 0, 0, 26502, 0, 0, 0, 'Abisal Vortex', '', '', 0, 83, 83, 0, 35, 35, 1, 1, 1.14286, 2, 1, 509, 683, 0, 805, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 371, 535, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 'npc_teleport', 1);
diff --git a/src/server/authserver/Server/AuthSocket.cpp b/src/server/authserver/Server/AuthSocket.cpp
index c2131f5..b2010b6 100644
--- a/src/server/authserver/Server/AuthSocket.cpp
+++ b/src/server/authserver/Server/AuthSocket.cpp
@@ -429,6 +429,7 @@ bool AuthSocket::_HandleLogonChallenge()
             if (!locked)
             {
                 //set expired bans to inactive
+                LoginDatabase.Execute(LoginDatabase.GetPreparedStatement(LOGIN_UPD_ACCOUNT_PREMIUM));
                 LoginDatabase.Execute(LoginDatabase.GetPreparedStatement(LOGIN_UPD_EXPIRED_ACCOUNT_BANS));
 
                 // If the account is banned, reject the logon attempt
diff --git a/src/server/game/AI/NpcBots/bot_GridNotifiers.h b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
new file mode 100644
index 0000000..fe37656
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
@@ -0,0 +1,461 @@
+/*
+Name: bot_GridNotifiers
+%Complete: 91+
+Comment: Custom grid notifiers for Bot system by Graff (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/grids
+*/
+
+#ifndef _BOT_GRIDNOTIFIERS_H
+#define _BOT_GRIDNOTIFIERS_H
+
+#include "Group.h"
+#include "Player.h"
+#include "SpellAuras.h"
+#include "bot_ai.h"
+
+class NearestHostileUnitCheck
+{
+    public:
+        explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const* m_ai, bool targetCCed = false) : 
+        me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed) { }
+        bool operator()(Unit* u)
+        {
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!ai->CanBotAttack(u, byspell))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (!AttackCCed && (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE)))
+                return false;//do not allow CCed units if checked
+            //if (u->HasUnitState(UNIT_STATE_CASTING) && (u->GetTypeId() == TYPEID_PLAYER || u->IsPet()))
+            //    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+            //        if (Spell* spell = u->GetCurrentSpell(i))
+            //            if (ai->IsInBotParty(spell->m_targets.GetUnitTarget()))
+            //                return true;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+            return true;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool byspell;
+        bot_ai const* ai;
+        bool AttackCCed;
+        NearestHostileUnitCheck(NearestHostileUnitCheck const&);
+};
+
+class HostileDispelTargetCheck
+{
+    public:
+        explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const* m_ai = NULL) : 
+        me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { }
+        bool operator()(Unit* u)
+        {
+            if (u->IsWithinDistInMap(me, m_range) && 
+                u->IsAlive() && 
+                u->InSamePhase(me) && 
+                u->IsInCombat() && 
+                u->isTargetableForAttack() && 
+                u->IsVisible() && 
+                u->GetReactionTo(me) < REP_NEUTRAL && 
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (checksteal && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449))) return false;//immune to steal
+                if (!checksteal)
+                {
+                    if (me->getLevel() >= 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(32375))) return false;//immune to mass dispel
+                    if (me->getLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527))) return false;//immune to direct dispel
+                }
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    SpellInfo const* Info = aura->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                    AuraApplication* aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        const std::string name = Info->SpellName[0];
+                        if (name == "Vengeance" || name == "Bloody Vengeance")
+                            continue;
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool checksteal;
+        bot_ai const* ai;
+        HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+};
+
+class AffectedTargetCheck
+{
+    public:
+        explicit AffectedTargetCheck(uint64 casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) : 
+        caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType)
+        { if (checker->GetTypeId() != TYPEID_PLAYER) return; gr = checker->GetGroup(); }
+        bool operator()(Unit* u)
+        {
+            if (caster && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+                return false;
+            if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
+            if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
+            if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
+            if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
+
+            if (u->IsAlive() && checker->IsWithinDistInMap(u, m_range))
+            {
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    if (aura->GetId() == spell)
+                        if (caster == 0 || aura->GetCasterGUID() == caster)
+                            return true;
+                }
+            }
+            return false;
+        }
+    private:
+        uint64 const caster;
+        float m_range;
+        uint32 const spell;
+        Player const* checker;
+        uint8 needhostile;
+        Group const* gr;
+        AffectedTargetCheck(AffectedTargetCheck const&);
+};
+
+class PolyUnitCheck
+{
+    public:
+        explicit PolyUnitCheck(Unit const* unit, float dist, Unit const* currTarget) : me(unit), m_range(dist), mytar(currTarget) {}
+        bool operator()(Unit* u)
+        {
+            if (u == mytar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat() || !u->IsAlive() || !u->GetVictim())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID && 
+                u->GetCreatureType() != CREATURE_TYPE_BEAST)
+                return false;
+            if (me->GetDistance(u) < 6 || mytar->GetDistance(u) < 5 || u->GetHealthPct() < 70)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (!u->IsHostileTo(me))
+                return false;
+            if (u->IsPolymorphed() || 
+                u->isFrozen() || 
+                u->isInRoots() || 
+                u->HasAura(51514)/*hex*/ || 
+                u->HasAura(20066)/*repentance*/ || 
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(339)) || //entangling roots
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(16914)) || //hurricane
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(10)) || //blizzard
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(2121)) || //flamestrike
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(20116)) || //consecration
+                u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(12826)))//Polymorph rank 4
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        Unit const* mytar;
+        PolyUnitCheck(PolyUnitCheck const&);
+};
+
+class FearUnitCheck
+{
+    public:
+        explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+        bool operator()(Unit* u)
+        {
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (u->getAttackers().size() > 1 && u->GetVictim() != me)
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->isFeared())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782)))//fear rank1
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        FearUnitCheck(FearUnitCheck const&);
+};
+
+class StunUnitCheck
+{
+    public:
+        explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
+        bool operator()(Unit* u)
+        {
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetVictim() == u)
+                return false;
+            if (me->GetTypeId() == TYPEID_UNIT)
+                if (Player* mymaster = me->ToCreature()->GetBotOwner())
+                    if (mymaster->GetVictim() == u)
+                        return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (!(u->GetCreatureType() == CREATURE_TYPE_HUMANOID || 
+                u->GetCreatureType() == CREATURE_TYPE_DEMON || 
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN || 
+                u->GetCreatureType() == CREATURE_TYPE_GIANT || 
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (me->GetDistance(u) < 10)//do not allow close cast to prevent break due to consecration
+                return false;
+            if (u->IsPolymorphed() || 
+                u->HasAura(51514)/*hex*/ || 
+                u->HasAura(20066)/*repentance*/ || 
+                u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackleundead*/)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066)))//repentance
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        StunUnitCheck(StunUnitCheck const&);
+};
+
+class UndeadCCUnitCheck
+{
+    public:
+        explicit UndeadCCUnitCheck(Unit const* unit, float dist = 30, uint32 spell = 0) : me(unit), m_range(dist), m_spellId(spell) { if (!spell) return; }
+        bool operator()(Unit* u)
+        {
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->GetVictim() == u && u->GetVictim() == me)
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            //most horrible hacks
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                u->GetCreatureType() != CREATURE_TYPE_DEMON && 
+                (m_spellId == 2812 || m_spellId == 10318 || //holy
+                m_spellId == 27139 || m_spellId == 48816 || //wra
+                m_spellId == 48817 ||                       //th or
+                m_spellId == 10326))                        //turn evil
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && 
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        uint32 m_spellId;
+        UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+};
+
+class RootUnitCheck
+{
+    public:
+        explicit RootUnitCheck(Unit const* unit, Unit const* mytarget, float dist = 30, uint32 spell = 0) : me(unit), curtar(mytarget), m_range(dist), m_spellId(spell)
+        { if (!spell) return; }
+        bool operator()(Unit* u)
+        {
+            if (u == curtar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetDistance(u) < 8)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->isFrozen() || u->isInRoots())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->IsPolymorphed() || 
+                u->HasAura(51514)/*hex*/ || 
+                u->HasAura(20066)/*repentance*/ || 
+                u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackleundead*/)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        Unit const* curtar;
+        float m_range;
+        uint32 m_spellId;
+        RootUnitCheck(RootUnitCheck const&);
+};
+
+class CastingUnitCheck
+{
+    public:
+        explicit CastingUnitCheck(Unit const* unit, float dist = 30, bool friendly = false, uint32 spell = 0) : me(unit), m_range(dist), m_friend(friendly), m_spell(spell) { if (!m_spell) return; }
+        bool operator()(Unit* u)
+        {
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!m_friend && !u->isTargetableForAttack())
+                return false;
+            //if (!m_friend && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))//prevent double silence
+            //    return false;
+            if (!u->IsNonMeleeSpellCasted(false))
+                return false;
+            if (m_friend == (u->GetReactionTo(me) < REP_FRIENDLY))
+                return false;
+            if (m_spell == 10326 && //turn evil
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                return false;
+            if (m_spell == 20066 && //repentance
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID || 
+                u->GetCreatureType() == CREATURE_TYPE_DEMON || 
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN || 
+                u->GetCreatureType() == CREATURE_TYPE_GIANT || 
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (!m_spell || !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spell)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool m_friend;
+        uint32 m_spell;
+        CastingUnitCheck(CastingUnitCheck const&);
+};
+
+class SecondEnemyCheck
+{
+    public:
+        explicit SecondEnemyCheck(Unit const* unit, float dist, Unit const* currtarget, bot_ai const* m_ai) : me(unit), m_range(dist), mytar(currtarget), ai(m_ai) {}
+        bool operator()(Unit* u)
+        {
+            if (u == mytar)
+                return false;//We need to find SECONDARY target
+            if (!u->IsInCombat())
+                return false;
+            if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range + 1.f))//distance check
+                return false;
+            if (mytar->GetDistance(u) > 4)//not close enough to each other
+                return false;
+
+            if (ai->CanBotAttack(u))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        Unit const* mytar;
+        bot_ai const* ai;
+        SecondEnemyCheck(SecondEnemyCheck const&);
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
new file mode 100644
index 0000000..42d7366
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.cpp
@@ -0,0 +1,3214 @@
+/*
+NpcBot System by Graff (onlysuffering@gmail.com)
+Original patch (npcbot part only) from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+TODO:
+Convert doCast events (CD etc.) into SpellHit()- and SpellHitTarget()-based
+Implement heal/tank/DD modes
+Implement Racial Abilities
+Implement Equipment Change (maybe)
+I NEED MORE
+*/
+
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "CellImpl.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "ScriptedGossip.h"
+#include "SpellAuraEffects.h"
+
+const uint8 GroupIconsFlags[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+bot_minion_ai::bot_minion_ai(Creature* creature): bot_ai(creature)
+{
+    Potion_cd = 0;
+    pvpTrinket_cd = 30000;
+    rezz_cd = 0;
+    evade_cd = 0;
+    myangle = 0.f;
+    classinfo = new PlayerClassLevelInfo;
+}
+bot_minion_ai::~bot_minion_ai()
+{
+    delete classinfo;
+}
+
+bot_pet_ai::bot_pet_ai(Creature* creature): bot_ai(creature)
+{
+    m_creatureOwner = me->GetCreatureOwner();
+    basearmor = 0;
+}
+bot_pet_ai::~bot_pet_ai(){}
+
+bot_ai::bot_ai(Creature* creature) : ScriptedAI(creature)
+{
+    master = me->GetBotOwner();
+    m_spellpower = 0;
+    haste = 0;
+    hit = 0.f;
+    regen_mp5 = 0.f;
+    m_TankGuid = 0;
+    tank = NULL;
+    extank = NULL;
+    info = NULL;
+    clear_cd = 2;
+    temptimer = 0;
+    wait = 15;
+    GC_Timer = 0;
+    checkAurasTimer = 20;
+    cost = 0;
+    doHealth = false;
+    doMana = false;
+    //shouldUpdateStats = true;
+    pos.m_positionX = 0.f;
+    pos.m_positionY = 0.f;
+    pos.m_positionZ = 0.f;
+    aftercastTargetGuid = 0;
+    currentSpell = 0;
+    dmgmult_melee = sConfigMgr->GetFloatDefault("Bot.DamageMult.Melee", 1.0);
+    dmgmult_spell = sConfigMgr->GetFloatDefault("Bot.DamageMult.Spell", 1.0);
+    dmgmult_melee = std::max(dmgmult_melee, 0.01f);
+    dmgmult_spell = std::max(dmgmult_spell, 0.01f);
+    dmgmult_melee = std::min(dmgmult_melee, 10.f);
+    dmgmult_spell = std::min(dmgmult_spell, 10.f);
+    dmgmod_melee = Creature::_GetDamageMod(me->GetCreatureTemplate()->rank);
+    dmgmod_spell = me->GetSpellDamageMod(me->GetCreatureTemplate()->rank);
+    healTargetIconFlags = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
+}
+bot_ai::~bot_ai(){}
+
+SpellCastResult bot_ai::checkBotCast(Unit* victim, uint32 spellId, uint8 botclass) const
+{
+    if (spellId == 0) return SPELL_FAILED_DONT_REPORT;
+    if (!CheckImmunities(spellId, victim)) return SPELL_FAILED_DONT_REPORT;
+    if (InDuel(victim)) return SPELL_FAILED_DONT_REPORT;
+
+    switch (botclass)
+    {
+        case CLASS_MAGE:
+        case CLASS_PRIEST:
+        case CLASS_DRUID:
+        case CLASS_WARLOCK:
+        case CLASS_SHAMAN:
+            if (Feasting() && !master->IsInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return SPELL_FAILED_DONT_REPORT;
+            return SPELL_CAST_OK;
+        case CLASS_PALADIN:
+            //Crusader Strike
+            if (spellId != 35395 && spellId != MANAPOTION && spellId != HEALINGPOTION && me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))
+                return SPELL_FAILED_DONT_REPORT;
+            return SPELL_CAST_OK;
+        case CLASS_WARRIOR:
+            //BladeStorm
+            if (me->HasAura(46924/*67541*/))
+                return SPELL_FAILED_DONT_REPORT;
+            return SPELL_CAST_OK;
+        case CLASS_ROGUE:
+        case CLASS_HUNTER:
+        case CLASS_DEATH_KNIGHT:
+        default:
+            return SPELL_CAST_OK;
+    }
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, bool triggered, uint64 originalCaster)
+{
+    if (spellId == 0) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting()) return false;
+    if (!victim || !victim->IsInWorld() || me->GetMap() != victim->FindMap()) return false;
+
+    info = sSpellMgr->GetSpellInfo(spellId);
+    if (!info)
+        return false;
+
+    if (spellId == MANAPOTION)
+    {
+        value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+        me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+        return true;
+    }
+
+    if (me->GetShapeshiftForm() != FORM_NONE && info->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
+        removeFeralForm(true, true);
+
+    if (spellId != HEALINGPOTION && spellId != MANAPOTION)
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+    {
+        //std::ostringstream msg;
+        //msg << "casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
+        //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+        me->Relocate(victim);
+    }
+
+    TriggerCastFlags flags = triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE;
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+    Spell* spell = new Spell(me, info, flags, originalCaster);
+    spell->prepare(&targets);//sets current spell if succeed
+
+    bool casted = triggered;//triggered casts are casted immediately
+    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+        if (Spell* curspell = me->GetCurrentSpell(i))
+            if (curspell == spell)
+                casted = true;
+
+    if (!casted)
+    {
+        //failed to cast
+        //delete spell;//crash due to invalid event added to master's eventmap
+        return false;
+    }
+
+    currentSpell = spellId;
+
+    switch (me->GetBotClass())
+    {
+        case CLASS_ROGUE:
+        case CAT:
+            value = int32(1000.f - 1000.f*(float(haste) / 100.f));
+            break;
+        default:
+            value = int32(1500.f - 1500.f*(float(haste) / 100.f));
+            break;
+    }
+    GC_Timer = std::max<uint32>(value, 500);
+
+    return true;
+}
+//Follow point calculation
+void bot_minion_ai::CalculatePos(Position & pos)
+{
+    uint8 followdist = master->GetBotFollowDist();
+    Unit* followTarget = master;
+    float mydist, angle;
+    if (master->GetBotTankGuid() == me->GetGUID())
+    {
+        mydist = frand(3.5f, 6.5f); //stand a bit farther
+        angle = (M_PI/2.f) / 16.f * frand(-3.f, 3.f); //in front +-pi/5
+    }
+    else
+    {
+        switch (me->GetBotClass())
+        {
+            case CLASS_WARRIOR: case CLASS_DEATH_KNIGHT: case CLASS_PALADIN: case BEAR:
+                mydist = frand(0.2f, 1.f);
+                angle = (M_PI/2.f) / 8.f * RAND(frand(5.f, 10.f), frand(-10.f, -5.f)); //to the sides +-(pi/3 to pi/1.6)
+                break;
+            case CLASS_WARLOCK: case CLASS_PRIEST: case CLASS_MAGE: case CAT:
+                mydist = frand(0.15f, 0.8f);
+                angle = (M_PI/2.f) / 6.f * frand(10.5f, 13.5f); //behind pi+-pi/4.5
+                break;
+            default:
+                mydist = frand(0.3f, 1.2f);
+                angle = (M_PI/2.f) / 6.f * frand(9.f, 15.f); //behind pi+-pi/3
+                break;
+        }
+    }
+    //myangle = angle used last time
+    //if difference between last angle and cur angle is too big, use new angle
+    //else use last angle (prevent constant struggling)
+    if (abs(abs(myangle) - abs(angle)) > M_PI/3.f)
+        myangle = angle;
+    else
+        angle = myangle;
+    mydist += followdist > 10 ? float(followdist - 10)/4.f : 0.f; //distance from 10+ is reduced
+    mydist = std::min<float>(mydist, 35.f); //do not spread bots too much
+    angle += followTarget->GetOrientation();
+    float x(0),y(0),z(0);
+    float size = me->GetObjectSize()/3.f;
+    bool over = false;
+    for (uint8 i = 0; i != 5 + over; ++i)
+    {
+        if (over)
+        {
+            mydist *= 0.2f;
+            break;
+        }
+        followTarget->GetNearPoint(me, x, y, z, size, mydist, angle);
+        if (!master->IsWithinLOS(x,y,z)) //try to get much closer to master
+        {
+            mydist *= 0.4f - float(i*0.07f);
+            size *= 0.1f;
+            if (size < 0.1)
+                size = 0.f;
+            if (size == 0.f && me->GetPositionZ() < followTarget->GetPositionZ())
+                z += 0.25f; //prevent going underground
+        }
+        else
+            over = true;
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+
+    //            T   
+    //           TTT
+    //    mmmmmmmm mmmmmmmm 
+    //   mmmmmmm MMM mmmmmmm 
+    //   mmmmm rrrrrrr mmmmm 
+    //    ddd rrrrrrrrr ddd
+    //     ddddddddddddddd
+    //       ddddddddddd
+    //         
+    //MMM - player
+    //TTT - bot tank
+    //m - melee (warrior, paladin, deathknight)
+    //d - default (druid, shaman, rogue, hunter)
+    //r - ranged/support (priest, warlock, mage)
+}
+// Movement set
+void bot_minion_ai::SetBotCommandState(CommandStates st, bool force, Position* newpos)
+{
+    if (me->isDead() || IAmDead())
+        return;
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (CCed(me, true)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
+        if (!newpos)
+            CalculatePos(pos);
+        else
+        {
+            pos.m_positionX = newpos->m_positionX;
+            pos.m_positionY = newpos->m_positionY;
+            pos.m_positionZ = newpos->m_positionZ;
+        }
+        if (me->getStandState() == UNIT_STAND_STATE_SIT && !Feasting())
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+        me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
+        //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
+    }
+    else if (st == COMMAND_STAY)
+    {
+        me->StopMoving();
+        me->GetMotionMaster()->Clear();
+        me->GetMotionMaster()->MoveIdle();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+    if (Creature* m_botsPet = me->GetBotsPet())
+        m_botsPet->SetBotCommandState(st, force);
+}
+
+void bot_pet_ai::SetBotCommandState(CommandStates st, bool force, Position* /*newpos*/)
+{
+    if (me->isDead() || IAmDead())
+        return;
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (CCed(me, true)) return;
+        Unit* followtarget = m_creatureOwner;
+        if (CCed(m_creatureOwner))
+            followtarget = master;
+        if (followtarget == m_creatureOwner)
+        {
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(master)*0.75f < me->GetDistance(m_creatureOwner))
+                me->GetMotionMaster()->MoveFollow(m_creatureOwner, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+        }
+        else
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(m_creatureOwner)*0.75f < me->GetDistance(master))
+                me->GetMotionMaster()->MoveFollow(master, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+    }
+    else if (st == COMMAND_STAY)//NUY
+    {
+        me->StopMoving();
+        me->GetMotionMaster()->Clear();
+        me->GetMotionMaster()->MoveIdle();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+}
+// Get Maintank
+void bot_ai::FindTank()
+{
+    if (tank == me)
+        extank = me;
+    //check group flags in DB
+    tank = _GetBotGroupMainTank(master->GetGroup());
+    //check if master has set tank
+    if (!tank)
+        tank = master->GetBotTankGuid() != 0 ? sObjectAccessor->GetObjectInWorld(master->GetBotTankGuid(), (Unit*)NULL) : NULL;
+    //check if we have tank flag in master's motmap
+    if (!tank)
+        tank = master->GetBotTank(me->GetEntry());
+    //at last try to find tank by class if master is too lazy to set it
+    if (!tank)
+    {
+        Player* owner = master;
+        uint8 Class = owner->getClass();
+        if (owner->IsAlive() && 
+            (Class == CLASS_WARRIOR || Class == CLASS_PALADIN || Class == CLASS_DEATH_KNIGHT))
+            tank = owner;
+        else if (owner != master && master->IsAlive())
+        {
+            Class = master->getClass();
+            if (Class == CLASS_WARRIOR || Class == CLASS_PALADIN || Class == CLASS_DEATH_KNIGHT)
+                tank = master;
+        }
+    }
+    //it happens to every bot so they all will know who the tank is
+    if (tank != extank)
+        me->SetBotTank(tank);
+    if (tank == me)
+    {
+        //if tank set by entry let master get right guid and set tank in botmap
+        if (master->GetBotTankGuid() != me->GetGUID())
+            master->SetBotTank(me->GetGUID());
+    }
+}
+//Get Group maintank
+Unit* bot_ai::_GetBotGroupMainTank(Group* group)
+{
+    if (!group)
+        return NULL;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAINTANK);
+    stmt->setUInt32(0, group->GetGUID());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    //QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid, memberFlags FROM `group_member` WHERE `guid`='%u'", group->GetGUID());
+    if (!result)
+        return NULL;
+    Unit* unit = NULL;
+    do
+    {
+        Field* field = result->Fetch();
+        uint32 lowGuid = field[0].GetInt32();
+        uint8 flags = field[1].GetInt8();
+        if (flags & MEMBER_FLAG_MAINTANK)
+        {
+            Group::MemberSlotList const &members = group->GetMemberSlots();
+            for (Group::MemberSlotList::const_iterator itr = members.begin(); itr != members.end(); ++itr)
+                if (GUID_LOPART(itr->guid) == lowGuid)
+                    unit = ObjectAccessor::FindUnit(itr->guid);
+        }
+    } while (result->NextRow() && !unit);
+    return unit;
+}
+// Buffs And Heal (really)
+void bot_minion_ai::BuffAndHealGroup(Player* gPlayer, uint32 diff)
+{
+    if (GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        if (!master->IsInWorld() || master->IsBeingTeleported())
+            return;
+        if (HealTarget(master, GetHealthPCT(master), diff))
+            return;
+        if (BuffTarget(master, diff))
+            return;
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || u->isDead()) continue;
+            if (HealTarget(u, GetHealthPCT(u), diff))
+                return;
+            if (Creature* cre = u->ToCreature())
+                if (cre->GetIAmABot() || cre->IsPet())
+                    if (BuffTarget(u, diff))
+                        return;
+        }
+        return;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        if (!tPlayer->m_Controlled.empty())
+            Bots = true;
+        if (tPlayer->isDead()) continue;
+        if (HealTarget(tPlayer, GetHealthPCT(tPlayer), diff))
+            return;
+        if (BuffTarget(tPlayer, diff))
+            return;
+    }
+    if (Bots)
+    {
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || tPlayer->m_Controlled.empty()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || u->isDead()) continue;
+                if (HealTarget(u, GetHealthPCT(u), diff))
+                    return;
+                if (Creature* cre = u->ToCreature())
+                    if (cre->GetIAmABot() || cre->IsPet())
+                        if (BuffTarget(u, diff))
+                            return;
+            }
+        }
+    }
+    //check if we have pointed heal target
+    for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+    {
+        if (healTargetIconFlags & GroupIconsFlags[i])
+        {
+            if (uint64 guid = pGroup->GetTargetIcons()[i])//check this one
+            {
+                if (Unit* unit = sObjectAccessor->FindUnit(guid))
+                {
+                    if (unit->IsAlive() && me->GetMap() == unit->FindMap() && 
+                        master->GetVictim() != unit && unit->GetVictim() != master && 
+                        unit->GetReactionTo(master) >= REP_NEUTRAL)
+                    {
+                        HealTarget(unit, GetHealthPCT(unit), diff);
+                        //CureTarget(unit, getCureSpell(), diff);
+                    }
+                }
+            }
+        }
+    }
+}
+// Attempt to resurrect dead players using class spells
+// Target is either player or its corpse
+void bot_minion_ai::RezGroup(uint32 REZZ, Player* gPlayer)
+{
+    if (!REZZ || !gPlayer || me->IsMounted()) return;
+    if (IsCasting()) return;
+    if (rezz_cd > 0) return;
+
+    //sLog->outBasic("RezGroup by %s", me->GetName().c_str());
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        Unit* target = master;
+        if (master->IsAlive()) return;
+        if (master->isRessurectRequested()) return; //resurrected
+        if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)master->GetCorpse();
+        if (!target || !target->IsInWorld()) return;
+        if (me->GetMap() != target->FindMap()) return;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            me->MonsterWhisper("Rezzing You", master->GetGUID());
+            rezz_cd = 60;
+        }
+        return;
+    }
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        Unit* target = tPlayer;
+        if (!tPlayer || tPlayer->IsAlive()) continue;
+        if (tPlayer->isRessurectRequested()) continue; //resurrected
+        if (Rand() > 5) continue;
+        if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)tPlayer->GetCorpse();
+        if (!target || !target->IsInWorld()) continue;
+        if (master->GetMap() != target->FindMap()) continue;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            me->MonsterWhisper("Rezzing You", tPlayer->GetGUID());
+            if (tPlayer != master)
+            {
+                std::string rezstr = "Rezzing ";
+                rezstr += tPlayer->GetName();
+                me->MonsterWhisper(rezstr.c_str(), master->GetGUID());
+            }
+            rezz_cd = 60;
+            return;
+        }
+    }
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_minion_ai::CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell || GC_Timer > diff) return;
+    if (me->getLevel() < 10 || pTarget->getLevel() < 10) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+    if (!master->GetMap()->IsRaid() && Rand() > 75) return;
+    //sLog->outBasic("%s: CureGroup() on %s", me->GetName().c_str(), pTarget->GetName().c_str());
+    Group* pGroup = pTarget->GetGroup();
+    if (!pGroup)
+    {
+        if (CureTarget(master, cureSpell, diff))
+            return;
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* cre = master->GetBotMap(i)->_Cre();
+            if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+            if (CureTarget(cre, cureSpell, diff))
+                return;
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (me->GetDistance(tPlayer) > 30) continue;
+            if (CureTarget(tPlayer, cureSpell, diff))
+                return;
+        }
+        if (!Bots) return;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+            {
+                Creature* cre = tPlayer->GetBotMap(i)->_Cre();
+                if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+                if (CureTarget(cre, cureSpell, diff))
+                    return;
+            }
+        }
+    }
+}
+
+bool bot_minion_ai::CureTarget(Unit* target, uint32 cureSpell, uint32 diff)
+{
+    return CanCureTarget(target, cureSpell, diff) ? doCast(target, cureSpell) : false;
+}
+// determines if unit has something to cure
+bool bot_minion_ai::CanCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const
+{
+    if (!cureSpell || GC_Timer > diff) return false;
+    if (!target || target->isDead()) return false;
+    if (me->getLevel() < 10 || target->getLevel() < 10) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting() || Feasting()) return false;
+    if (me->GetDistance(target) > 30) return false;
+    if (!IsInBotParty(target)) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
+
+    if (dispelMask == 0)
+        return false;
+
+    DispelChargesList dispel_list;
+    GetBotDispellableAuraList(target, me, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_minion_ai::GetBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const
+{
+    if (dispelMask & (1 << DISPEL_DISEASE) && target->HasAura(50536))
+        dispelMask &= ~(1 << DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            if (aurApp->IsPositive() == target->IsFriendlyTo(caster))
+                continue;
+
+            uint8 charges = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                dispelList.push_back(std::make_pair(aura, charges));
+        }
+    }
+}
+
+bool bot_ai::HasAuraName(Unit* unit, uint32 spellId, uint64 casterGuid, bool exclude) const
+{
+    if (!spellId) return false;
+    SpellInfo const* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo) return false;
+
+    uint8 loc = master->GetSession()->GetSessionDbcLocale();
+    const std::string name = pSpellInfo->SpellName[loc];
+    if (name.length() == 0) return false;
+
+    return HasAuraName(unit, name, casterGuid, exclude);
+}
+
+bool bot_ai::HasAuraName(Unit* unit, const std::string spell, uint64 casterGuid, bool exclude) const
+{
+    if (spell.length() == 0) return false;
+
+    uint8 loc = master->GetSession()->GetSessionDbcLocale();
+    if (!unit || unit->isDead()) return false;
+
+    Unit::AuraMap const& vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[loc];
+        if (spell == name)
+            if (casterGuid == 0 || (casterGuid != 0 && exclude == (casterGuid != itr->second->GetCasterGUID())))
+                return true;
+    }
+    return false;
+}
+//LIST AURAS
+// Debug: Returns bot's info to called player
+void bot_ai::listAuras(Player* player, Unit* unit) const
+{
+    if (!IsInBotParty(player)) return;
+    if (!IsInBotParty(unit)) return;
+    ChatHandler ch(player->GetSession());
+    std::ostringstream botstring;
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+        botstring << "player";
+    else if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        if (unit->ToCreature()->GetIAmABot())
+        {
+            botstring << "minion bot, master: ";
+            std::string const& ownername = unit->ToCreature()->GetBotOwner()->GetName();
+            botstring << ownername;
+        }
+        else if (unit->ToCreature()->GetIAmABotsPet())
+        {
+            Player* owner = unit->ToCreature()->GetBotOwner();
+            Creature* creowner = unit->ToCreature()->GetBotPetAI()->GetCreatureOwner();
+            std::string const& ownername = owner ? owner->GetName() : "none";
+            std::string const& creownername = creowner ? creowner->GetName() : "none";
+            botstring << "pet bot, master: ";
+            botstring << ownername;
+            botstring << ", creature owner: ";
+            botstring << creownername;
+            if (creowner)
+                botstring << " (" << creowner->GetGUIDLow() << ')';
+        }
+    }
+    ch.PSendSysMessage("ListAuras for %s, %s", unit->GetName().c_str(), botstring.str().c_str());
+    uint8 locale = player->GetSession()->GetSessionDbcLocale();
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        if (!spellInfo)
+            continue;
+        uint32 id = spellInfo->Id;
+        SpellInfo const* learnSpellInfo = sSpellMgr->GetSpellInfo(spellInfo->Effects[0].TriggerSpell);
+        const std::string name = spellInfo->SpellName[locale];
+        std::ostringstream spellmsg;
+        spellmsg << id << " - |cffffffff|Hspell:" << id << "|h[" << name;
+        spellmsg << ' ' << localeNames[locale] << "]|h|r";
+        uint32 talentcost = GetTalentSpellCost(id);
+        uint32 rank = 0;
+        if (talentcost > 0 && spellInfo->GetNextRankSpell())
+            rank = talentcost;
+        else if (learnSpellInfo && learnSpellInfo->GetNextRankSpell())
+            rank = spellInfo->GetRank();
+        if (rank > 0)
+            spellmsg << " Rank " << rank;
+        if (talentcost > 0)
+            spellmsg << " [talent]";
+        if (spellInfo->IsPassive())
+            spellmsg << " [passive]";
+        if (unit->GetTypeId() == TYPEID_PLAYER && unit->ToPlayer()->HasSpell(id))
+            spellmsg << " [known]";
+
+        ch.PSendSysMessage(spellmsg.str().c_str());
+    }
+    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+    {
+        std::string mystat;
+        switch (i)
+        {
+            case STAT_STRENGTH: mystat = "str"; break;
+            case STAT_AGILITY: mystat = "agi"; break;
+            case STAT_STAMINA: mystat = "sta"; break;
+            case STAT_INTELLECT: mystat = "int"; break;
+            case STAT_SPIRIT: mystat = "spi"; break;
+            default: mystat = "unk stat"; break;
+        }
+        ch.PSendSysMessage("%s: %f", mystat.c_str(), unit->GetTotalStatValue(Stats(i)));
+    }
+    ch.PSendSysMessage("Melee AP: %f", unit->GetTotalAttackPowerValue(BASE_ATTACK));
+    ch.PSendSysMessage("Ranged AP: %f", unit->GetTotalAttackPowerValue(RANGED_ATTACK));
+    ch.PSendSysMessage("armor: %u", unit->GetArmor());
+    ch.PSendSysMessage("crit: %f pct", unit->GetUnitCriticalChance(BASE_ATTACK, me));
+    ch.PSendSysMessage("dodge: %f pct", unit->GetUnitDodgeChance());
+    ch.PSendSysMessage("parry: %f pct", unit->GetUnitParryChance());
+    ch.PSendSysMessage("Damage taken melee: %f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL));
+    ch.PSendSysMessage("Damage taken spell: %f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC));
+    ch.PSendSysMessage("Damage range mainhand: min: %f, max: %f", unit->GetFloatValue(UNIT_FIELD_MINDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    ch.PSendSysMessage("Damage range offhand: min: %f, max: %f", unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+    ch.PSendSysMessage("Damage range ranged: min: %f, max: %f", unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+    ch.PSendSysMessage("Damage mult mainhand: %f", unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    ch.PSendSysMessage("Damage mult offhand: %f", unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+    ch.PSendSysMessage("Damage mult ranged: %f", unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+    ch.PSendSysMessage("Attack time mainhand: %f", float(unit->GetAttackTime(BASE_ATTACK))/1000.f);
+    ch.PSendSysMessage("Attack time offhand: %f", float(unit->GetAttackTime(OFF_ATTACK))/1000.f);
+    ch.PSendSysMessage("Attack time ranged: %f", float(unit->GetAttackTime(RANGED_ATTACK))/1000.f);
+    if (unit == me)
+        ch.PSendSysMessage("melee damage mult: %f", dmgmult_melee);
+    ch.PSendSysMessage("base hp: %u", unit->GetCreateHealth());
+    ch.PSendSysMessage("total hp: %u", unit->GetMaxHealth());
+    ch.PSendSysMessage("base mana: %u", unit->GetCreateMana());
+    ch.PSendSysMessage("total mana: %u", unit->GetMaxPower(POWER_MANA));
+    //DEBUG1
+    //ch.PSendSysMessage("STATS: ");
+    //ch.PSendSysMessage("Health");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_PCT));
+    //ch.PSendSysMessage("Mana");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_PCT));
+    //ch.PSendSysMessage("Stamina");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT));
+    //ch.PSendSysMessage("Intellect");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT));
+    //ch.PSendSysMessage("Spirit");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_PCT));
+    //END DEBUG1
+    if (unit == me)
+    {
+        ch.PSendSysMessage("spellpower: %u", m_spellpower - m_spellpower % 50);
+        ch.PSendSysMessage("spell damage mult: %f", dmgmult_spell);
+        ch.PSendSysMessage("mana regen: %f", regen_mp5 - (int32(regen_mp5) % 45));
+        ch.PSendSysMessage("haste: %u *10 pct", haste);
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            const char* resist = NULL;
+            switch (i)
+            {
+                case 1: resist = "holy";   break;
+                case 2: resist = "fire";   break;
+                case 3: resist = "nature"; break;
+                case 4: resist = "frost";  break;
+                case 5: resist = "shadow"; break;
+                case 6: resist = "arcane"; break;
+            }
+            ch.PSendSysMessage("Resistance %s: %u", resist, me->GetResistance(SpellSchools(i)));
+        }
+        ch.PSendSysMessage("BotCommandState: %s", m_botCommandState == COMMAND_FOLLOW ? "Follow" : m_botCommandState == COMMAND_ATTACK ? "Attack" : m_botCommandState == COMMAND_STAY ? "Stay" : m_botCommandState == COMMAND_ABANDON ? "Reset" : "none");
+        ch.PSendSysMessage("Follow distance: %u", master->GetBotFollowDist());
+        //ch.PSendSysMessage("healTargetIconFlags: %u", healTargetIconFlags);
+        if (tank != NULL && tank->IsInWorld())
+        {
+            if (tank == me)
+                ch.PSendSysMessage("Is a MainTank!");
+            else
+                ch.PSendSysMessage("Maintank is %s", tank->GetName().c_str());
+        }
+        //debug
+        //if (IsPetAI()) GetPetAI()->ListSpells(&ch);
+    }
+}
+//SETSTATS
+// Health, Armor, Powers, Combat Ratings, and global update setup
+void bot_minion_ai::setStats(uint8 myclass, uint8 myrace, uint8 mylevel, bool force)
+{
+    if (myrace == 0 || myclass == 0) return;
+    if (myclass != BEAR && myclass != CAT && (master->isDead() || (!shouldUpdateStats && !force))) return;
+    /*sLog->outBasic("setStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
+        me->GetName().c_str(), myclass, myrace, mylevel, master->GetName().c_str());*/
+
+    mylevel = std::min<uint8>(mylevel, 80);
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+        InitSpells();
+
+    //PHASE
+    if (!me->InSamePhase(master))
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+    //INIT STATS
+    //partially receive master's stats and get base class stats, we'll need all this later
+    uint8 tempclass = myclass == BEAR || myclass == CAT ? CLASS_DRUID : myclass;
+    sObjectMgr->GetPlayerClassLevelInfo(tempclass, mylevel, classinfo);
+    const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->getClass());//use creature class
+    float value;
+    if (force)
+        for (uint8 i = STAT_STAMINA; i < MAX_STATS; i++)
+            me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i)));
+
+    //MAXSTAT
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+    {
+        value = master->GetTotalStatValue(Stats(i));
+        if (i == 0 || value > stat)
+            stat = value;//Get Hightest stat (on first cycle just set base value)
+    }
+    stat = std::max(stat - 18.f, 0.f); //base value for all stats is 18 (isn't counted in any way)
+
+    //INIT CLASS MODIFIERS
+    switch (myclass)
+    {
+        case CLASS_WARRIOR:      ap_mod = 1.3f;  spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
+        case CLASS_DEATH_KNIGHT: ap_mod = 1.2f;  spp_mod = 1.0f; armor_mod = 1.15f; crit_mod = 0.9f; haste_mod = 0.65f; dodge_mod = 0.8f;  parry_mod = 2.0f;  break;//NYI
+        case CLASS_PALADIN:      ap_mod = 1.0f;  spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
+        case CLASS_ROGUE:        ap_mod = 1.5f;  spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;//NYI
+        case CLASS_HUNTER:       ap_mod = 1.15f; spp_mod = 0.0f; armor_mod = 0.85f; crit_mod = 1.2f; haste_mod = 1.25f; dodge_mod = 1.2f;  parry_mod = 1.2f;  break;//NYI
+        case CLASS_SHAMAN:       ap_mod = 0.9f;  spp_mod = 1.0f; armor_mod = 0.9f;  crit_mod = 1.2f; haste_mod = 1.65f; dodge_mod = 0.8f;  parry_mod = 0.5f;  break;//NYI
+        case CLASS_DRUID:        ap_mod = 0.0f;  spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case CLASS_MAGE:         ap_mod = 0.0f;  spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;          
+        case CLASS_PRIEST:       ap_mod = 0.0f;  spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case CLASS_WARLOCK:      ap_mod = 0.0f;  spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case BEAR:               ap_mod = 2.0f;  spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
+        case CAT:                ap_mod = 1.5f;  spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
+        default:                 ap_mod = 0.0f;  spp_mod = 0.0f; armor_mod = 0.0f;  crit_mod = 0.0f; haste_mod = 0.00f; dodge_mod = 0.0f;  parry_mod = 0.0f;  break;
+    }
+    if (spp_mod != 0.f && mylevel > 39)
+        spp_mod *= (float(mylevel - 39))/41.f;// gain spell power slowly
+
+    //DAMAGE
+    _OnMeleeDamageUpdate(myclass);
+    
+    //ARMOR
+    //sLog->outBasic("Unpdating %s's ARMOR: ", me->GetName().c_str());
+    //sLog->outBasic("armor mod: %f", armor_mod);
+    armor_mod *= (master->GetModifierValue(UNIT_MOD_ARMOR, BASE_PCT) + master->GetModifierValue(UNIT_MOD_ARMOR, TOTAL_PCT))/2.f;
+    //sLog->outBasic("armor mod * master's modifier: %f", armor_mod);
+    value = float(classstats->BaseArmor);
+    //sLog->outBasic("base armor: %f", value);
+    value += float(master->GetArmor())/5.f;
+    //sLog->outBasic("base armor + 1/5 of master's armor: %f", value);
+    value *= armor_mod;
+    //sLog->outBasic("multiplied by armor mod (total base armor): %f", value);
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();//buffs will be took in consideration here
+
+    //RESISTANCES
+    //sLog->outBasic("Unpdating %s's RESISTANCES: ", me->GetName().c_str());
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(master->GetResistance(SpellSchools(i)));
+        //sLog->outBasic("master's resistance %u: %f, setting %f (triple) to bot", uint32(UNIT_MOD_RESISTANCE_START + i), value, value*3);
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, value*2.5f + float(mylevel*2));
+        //me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_PCT, 1.f);
+        me->UpdateResistances(i);
+    }
+    //DAMAGE TAKEN
+    float directReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
+    float magicReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC);
+    value = (directReduction + magicReduction)/2.f;// average
+    if (value > 1.f)
+        value -= 1.f;
+    else
+        value = 1.f - value;//get reduction even if master's is 1.0+
+    value = std::min(0.42f, value);
+    value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
+    if (mylevel > 77)
+        value += float(mylevel - 77)*6.f;// + 3 stacks for high level
+    RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
+
+    //HEALTH
+    _OnHealthUpdate(myclass, mylevel);
+
+    //HASTE
+    value = 0.f;
+    for (uint8 i = CR_HASTE_MELEE; i != CR_HASTE_SPELL + 1; ++i)
+        if (float rating = master->GetRatingBonusValue(CombatRating(i)))
+            if (rating > value)//master got some haste
+                value = rating;//get hightest pct
+    for (uint8 i = EQUIPMENT_SLOT_BACK; i < EQUIPMENT_SLOT_END; ++i)
+        if (Item* item = master->GetItemByPos(0, i))//inventory weapons
+            if (item->GetTemplate()->ItemLevel >= 277)//bears ICC 25H LK items or Wrathful items
+                value += 10.f;//only weapons so we can add 1 to 3 stacks (rogue, warr, sham...)
+    value *= haste_mod;
+    if (isMeleeClass(myclass))
+        value *= 0.67f;//nerf melee haste by 1/3
+    value = value/10.f + float(mylevel/39);//get bonus at 78
+    if (myclass == CAT)//give cat lots of haste
+        value += float(mylevel/16);//or 20 (+ 4-5 stacks);
+    RefreshAura(HASTE,  uint8(value));//spell haste
+    RefreshAura(HASTE2, uint8(value) + uint8(myclass == CLASS_ROGUE));//melee haste
+    haste = uint8(value);//for show only
+
+    //HIT
+    int32 melee_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_HIT_CHANCE) + master->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);
+    int32 spell_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_SPELL_HIT_CHANCE) + master->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT, SPELL_SCHOOL_MASK_SPELL);
+    value = float(melee_hit > spell_hit ? melee_hit : spell_hit)*1.5f;//hightest, buff hit chance for bots
+    hit = value/3.f;
+    RefreshAura(PRECISION,  int8(hit) + mylevel/39);//melee
+    RefreshAura(PRECISION2, int8(hit) + mylevel/39);//spell
+
+    //CRIT
+    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
+    value = master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me);
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if can
+    value *= crit_mod;
+    RefreshAura(CRITS, int8(value/5.f) + mylevel/39);
+    if (myclass == CLASS_PRIEST)
+        RefreshAura(HOLYCRIT, int8(value/7.f));//add holy crit to healers
+
+    //PARRY
+    value = master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if possible
+    value *= parry_mod;
+    if (master->GetBotTankGuid() == me->GetGUID() && myclass != CAT && myclass != BEAR)//feral cannot parry so let it be base 5%
+        value += 10.f;
+    if (value > 55.f)
+        value = 55.f;
+    float parryAndDodge = value;//set temp value, this is needed to keep total avoidance within 65%
+    RefreshAura(PARRY, int8(value/5.f));//5% per stack aplied
+
+    //DODGE
+    value = master->GetUnitDodgeChance();
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if possible
+    value *= dodge_mod;
+    if (master->GetBotTankGuid() == me->GetGUID())
+        value += 10.f;
+    if (value > 55.f)
+        value = 55.f;
+    if (parryAndDodge + value > 55.f)
+        value = 55.f - parryAndDodge;//do not allow avoidance to be more than 65% (base 5+5)
+    if (myclass == CLASS_ROGUE)
+        value += 6.f;
+    RefreshAura(DODGE, int8(value/5.f));
+
+    //MANA
+    _OnManaUpdate(myclass, mylevel);
+
+    //MANA REGEN
+    if (mylevel >= 40 && me->getPowerType() == POWER_MANA)
+    {
+        regen_mp5 = master->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
+        //TOO COMPLICATED
+        //regen_mp5 = (master->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + sqrt(master->GetStat(STAT_INTELLECT)) * master->OCTRegenMPPerSpirit()) / 5.f;
+        //Unit::AuraEffectList const& regenAura = master->GetAuraEffectsByType(SPELL_AURA_MOD_MANA_REGEN_FROM_STAT);
+        //for (Unit::AuraEffectList::const_iterator i = regenAura.begin(); i != regenAura.end(); ++i)
+        //    regen_mp5 += master->GetStat(Stats((*i)->GetMiscValue())) * (*i)->GetAmount() / 500.f;
+        //regen_mp5 *= 0.8f;//custom modifier
+        float regen_mp5_a = stat * 0.2f;
+        //regen_mp5 += master->GetTotalStatValue(STAT_SPIRIT) * 0.1f;
+        regen_mp5 = regen_mp5 > regen_mp5_a ? regen_mp5 : regen_mp5_a;
+        if (regen_mp5 >= 45.f)
+        {
+            me->RemoveAurasDueToSpell(MANAREGEN100);
+            me->RemoveAurasDueToSpell(MANAREGEN45);
+            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5/100.f) + mylevel/20);
+            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5/45.f)  + mylevel/20);
+        }
+    }
+
+    //SPELL POWER
+    if (mylevel >= 40 && spp_mod != 0.f)
+    {
+        //sLog->outBasic("Updating spellpower for %s:", me->GetName().c_str());
+        //sLog->outBasic("spp_mod: %f", spp_mod);
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
+            if (power > sppower || i == SPELL_SCHOOL_HOLY)
+                sppower = power;
+        }
+        //sppower = master->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC);//"Spell Power" stat
+        //sLog->outBasic("Master's spell power: %i", sppower);
+        atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
+        atpower *= 0.67f;
+        //sLog->outBasic("Master's 2/3 of attack power: %f", atpower);
+        m_spellpower = sppower > atpower ? sppower : atpower;
+        //sLog->outBasic("Chosen stat value: %i", m_spellpower);
+        m_spellpower = int32(float(m_spellpower)*spp_mod);
+        //sLog->outBasic("spellpower * mod: %i", m_spellpower);
+        if (myclass == CLASS_MAGE)
+            RefreshAura(FIREDAM_86, m_spellpower/4/86 + (mylevel >= 78)*2); //(86,172,258,344,430,516,602,688...) // fire spp, do not touch this
+        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
+        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower/50);
+        else if (mylevel < 80) RefreshAura(SPELL_BONUS_150, m_spellpower/150 + 1);
+        else                   RefreshAura(SPELL_BONUS_250, m_spellpower/250 + 2);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    //SetStats for pet
+    if (Creature* pet = me->GetBotsPet())
+        if (bot_pet_ai* petai = pet->GetBotPetAI())
+            petai->setStats(mylevel, bot_pet_ai::GetPetType(pet), force);
+
+    shouldUpdateStats = false;
+}
+void bot_pet_ai::setStats(uint8 mylevel, uint8 petType, bool force)
+{
+    if (petType == PET_TYPE_NONE || petType >= MAX_PET_TYPES) return;
+    if (!shouldUpdateStats && !force) return;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "setStats(): Updating pet bot %s, type: %u, level %u, owner: %s, master: %s", me->GetName().c_str(), petType, mylevel, m_creatureOwner->GetName().c_str(), master->GetName().c_str());
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+        InitSpells();
+
+    //PHASE
+    if (!me->InSamePhase(master))
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+
+    ////INIT STATS
+    uint8 botclass = m_creatureOwner->GetBotClass();
+    if (botclass == BEAR || botclass == CAT)
+        botclass = CLASS_DRUID;
+    //sObjectMgr->GetPlayerClassLevelInfo(botclass, m_creatureOwner->getLevel(), &classinfo);
+    //const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->GetBotClass());//use creature class
+    //if (force)
+    //    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; i++)
+    //        me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i))*0.5f);
+
+    //MAXSTAT
+    float value;
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+    {
+        value = master->GetTotalStatValue(Stats(i));
+        if (i == 0 || value > stat)
+            stat = value;//Get Hightest stat (on first cycle just set base value)
+    }
+    stat = std::max(stat - 18.f, 0.f);//remove base
+
+    //INIT CLASS MODIFIERS
+    //STAT -- 'mod' -- used stat values to apply
+    //WARLOCK
+    //Stamina x0.3  -- health
+    //Armor   x0.35 -- armor
+    //Int     x0.3  -- crit/mana
+    //Spd     x0.15 -- spd (if has mana)
+    //AP      x0.57 -- attack power (if melee pet)
+    //Resist  x0.4  -- resistances
+    //MAGE
+    //
+    //SHAMAN
+    //
+    //HUNTER
+    //Other   x1.0  -- use as default
+    switch (petType)
+    {
+        case PET_TYPE_VOIDWALKER:       ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;
+        //case PET_TYPE_FELHUNTER:        ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_FELGUARD:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_SUCCUBUS:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_IMP:              ap_mod = 0.f;   spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+
+        //case PET_TYPE_WATER_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_FIRE_ELEMENTAL:   ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+        //case PET_TYPE_EARTH_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_VULTURE:          ap_mod = 0.9f;  spp_mod = 1.0f; crit_mod = 1.2f; break;//NYI
+        default:                        ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;
+    }
+    //case CLASS_WARRIOR:      ap_mod = 1.3f;  spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
+    //case CLASS_DEATH_KNIGHT: ap_mod = 1.2f;  spp_mod = 1.0f; armor_mod = 1.15f; crit_mod = 0.9f; haste_mod = 0.65f; dodge_mod = 0.8f;  parry_mod = 2.0f;  break;//NYI
+    //case CLASS_PALADIN:      ap_mod = 1.0f;  spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
+    //case CLASS_ROGUE:        ap_mod = 1.5f;  spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;//NYI
+    //case CLASS_HUNTER:       ap_mod = 1.15f; spp_mod = 0.0f; armor_mod = 0.85f; crit_mod = 1.2f; haste_mod = 1.25f; dodge_mod = 1.2f;  parry_mod = 1.2f;  break;//NYI
+    //case CLASS_SHAMAN:       ap_mod = 0.9f;  spp_mod = 1.0f; armor_mod = 0.9f;  crit_mod = 1.2f; haste_mod = 1.65f; dodge_mod = 0.8f;  parry_mod = 0.5f;  break;//NYI
+    //case CLASS_DRUID:        ap_mod = 0.0f;  spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case CLASS_MAGE:         ap_mod = 0.0f;  spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;          
+    //case CLASS_PRIEST:       ap_mod = 0.0f;  spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case CLASS_WARLOCK:      ap_mod = 0.0f;  spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case BEAR:               ap_mod = 2.0f;  spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
+    //case CAT:                ap_mod = 1.5f;  spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
+
+    if (spp_mod != 0.f && mylevel > 39)
+        spp_mod *= (float(mylevel - 39))/41.f;// gain spell power slowly
+
+    //DAMAGE
+    if (ap_mod > 0.f)//do not bother casters
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case CLASS_WARLOCK:
+                value = float(m_creatureOwner->GetBotAI()->GetSpellPower());
+                break;
+            default://some weird class or NYI
+                value = 0.f;
+                break;
+        }
+        //Calculate ap
+        //set base strength
+        me->SetModifierValue(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, me->GetCreateStat(STAT_STRENGTH) - 9.f);
+        //calc attack power (strength and minion's spd)
+        atpower = me->GetTotalAuraModValue(UNIT_MOD_STAT_STRENGTH)*2.f + value*ap_mod;
+        //set value
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage();
+    }
+    
+    //ARMOR
+    value = float(basearmor);
+    //get minion's armor and give 35% to pet (just as for real pets)
+    value += m_creatureOwner->GetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE)*0.35f;
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();//buffs will be took in consideration here
+
+    //RESISTANCES
+    //based on minion's resistances gain x0.4
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(master->GetResistance(SpellSchools(i)));
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, 0.4f*(value*2.5f + float(mylevel*2)));
+        me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    //just get minion's reduction and apply to pet
+    value = m_creatureOwner->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
+    if (value > 1.f)
+        value -= 1.f;
+    else
+        value = 1.f - value;//get reduction even if owner's is 1.0+
+    value = std::min(0.42f, value);
+    value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
+    RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
+
+    //HEALTH
+    _OnHealthUpdate(petType, mylevel);
+
+//////RATINGS//////
+    //ok now, pet receives 100% of its master's ratings
+
+    //HASTE
+    haste = m_creatureOwner->GetBotAI()->GetHaste();
+    RefreshAura(HASTE,  haste);//spell haste
+    RefreshAura(HASTE2, haste);//melee haste
+
+    //HIT
+    hit = m_creatureOwner->GetBotAI()->GetHitRating();
+    RefreshAura(PRECISION,  int8(hit) + mylevel/39);//melee
+    RefreshAura(PRECISION2, int8(hit) + mylevel/39);//spell
+
+    //CRIT
+    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
+    value = master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me);
+    if (crit_mod != 1.0f)
+        value *= crit_mod;
+    RefreshAura(CRITS, int8(value/5.f) + mylevel/39);
+
+    //PARRY
+    value = master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+    if (master->GetBotTankGuid() == me->GetGUID())//feral cannot parry so let it be base 5%
+        value += 10.f;
+    if (value > 65.f)
+        value = 65.f;
+    float parryAndDodge = value;//set temp value, this is needed to keep total avoidance within 75%
+    RefreshAura(PARRY, int8(value/5.f));
+
+    //DODGE
+    value = master->GetUnitDodgeChance();
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if possible
+    if (master->GetBotTankGuid() == me->GetGUID())
+        value += 10.f;
+    if (value > 65.f)
+        value = 65.f;
+    if (parryAndDodge + value > 65.f)
+        value = 65.f - parryAndDodge;//do not allow avoidance to be more than 75% (base 5+5)
+    RefreshAura(DODGE, int8(value/5.f));
+
+    //MANA
+    _OnManaUpdate(petType, mylevel);
+
+    //MANA REGEN
+    if (mylevel >= 40 && me->getPowerType() == POWER_MANA)
+    {
+        //let regen rate be same as stats rate x0.3
+        regen_mp5 = m_creatureOwner->GetBotAI()->GetManaRegen()*0.3f;
+        if (regen_mp5 >= 45.f)
+        {
+            me->RemoveAurasDueToSpell(MANAREGEN100);
+            me->RemoveAurasDueToSpell(MANAREGEN45);
+            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5/100.f) + mylevel/20);
+            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5/45.f)  + mylevel/20);
+        }
+    }
+
+    //SPELL POWER
+    if (mylevel >= 40 && spp_mod != 0.f)
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case CLASS_WARLOCK:
+                value = float(m_creatureOwner->GetBotAI()->GetSpellPower());
+                break;
+            default://some weird class or NYI
+                value = 0.f;
+                break;
+        }
+        m_spellpower = int32(value*spp_mod);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
+        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower/50);
+        else if (mylevel < 80) RefreshAura(SPELL_BONUS_150, m_spellpower/150 + 1);
+        else                   RefreshAura(SPELL_BONUS_250, m_spellpower/250 + 2);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    shouldUpdateStats = false;
+}
+//Emotion-based action 
+void bot_ai::ReceiveEmote(Player* player, uint32 emote)
+{
+    switch (emote)
+    {
+        case TEXT_EMOTE_BONK:
+            listAuras(player, me);
+            break;
+        case TEXT_EMOTE_SALUTE:
+            listAuras(player, player);
+            break;
+        case TEXT_EMOTE_STAND:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_STAY);
+            me->MonsterWhisper("Standing Still.", player->GetGUID());
+            break;
+        case TEXT_EMOTE_WAVE:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_FOLLOW, true);
+            me->MonsterWhisper("Following!", player->GetGUID());
+            break;
+        default:
+            break;
+    }
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_ai::IsInBotParty(Unit* unit) const
+{
+    if (!unit) return false;
+    if (unit == me || unit == master) return true;
+
+    //cheap check
+    if (Group* gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if (healTargetIconFlags & GroupIconsFlags[i])
+                if (uint64 guid = gr->GetTargetIcons()[i])//check this one
+                    if (guid == unit->GetGUID())
+                        if (unit->GetReactionTo(master) >= REP_NEUTRAL && 
+                            master->GetVictim() != unit && 
+                            unit->GetVictim() != master)
+                            return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature* cre = unit->ToCreature())
+    {
+        //npcbot/npcbot's pet case
+        if (Player* owner = cre->GetBotOwner())
+        {
+            if (owner == master)
+                return true;
+        }
+        //pets, minions, guardians etc.
+        else
+        {
+            uint64 ownerGuid = unit->GetOwnerGUID();
+            //controlled by group member
+            if (Group* gr = master->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+        }
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/reapplies aura stacks
+bool bot_ai::RefreshAura(uint32 spell, int8 count, Unit* target) const
+{
+    if (!spell)
+        return false;
+    if (!target)
+        target = me;
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell);
+    if (!spellInfo)
+        return false;
+    //if (!spellInfo->IsPassive())
+    //{
+    //    TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot_ai::RefreshAura(): %s received spell %u (%s) which is not a passive spell!", target->GetName().c_str(), spell, spellInfo->SpellName[0]);
+    //    //return false;
+    //}
+    if (target->HasAura(spell))
+        target->RemoveAurasDueToSpell(spell);
+    if (count > 0)
+        for (uint8 i = 0; i < count; ++i)
+            target->AddAura(spellInfo, MAX_EFFECT_MASK, target);
+    return true;
+}
+//CHECKAURAS
+//Updates bot's condition once a while
+void bot_minion_ai::CheckAuras(bool force)
+{
+    if (checkAurasTimer > 0 && !force) return;
+    opponent = me->GetVictim(); //safe
+    if (checkAurasTimer == 0)
+    {
+        checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
+        if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
+        {
+            if (opponent)
+            {
+                switch (me->GetBotClass())
+                {
+                    case CLASS_MAGE: case CLASS_DRUID: case CLASS_WARLOCK: case CLASS_PRIEST:/* case CLASS_SHAMAN:*/
+                        CalculateAttackPos(opponent, attackpos);
+                        if (me->GetDistance(attackpos) > 8)
+                            GetInPosition(true, true, opponent, &attackpos);
+                        break;
+                    default:
+                        if (me->GetDistance(opponent) > 1.5f)
+                            GetInPosition(true, false);
+                        break;
+                }
+            }
+        }
+        if (shouldUpdateStats)
+            setStats(me->GetBotClass(), me->getRace(), master->getLevel());
+        else
+        {
+            UpdateHealth();
+            UpdateMana();
+        }
+        if (rezz_cd > 0)
+            --rezz_cd;
+        if (clear_cd > 0)
+            --clear_cd;
+        else
+        {
+            FindTank();
+            clear_cd = 15;
+        }
+        return;
+    }
+    else if (force)
+    {
+        if (!opponent)
+        {
+            if (master->isDead())
+            {
+                //If ghost move to corpse, else move to dead player
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                {
+                    Corpse* corpse = master->GetCorpse();
+                    if (corpse && me->GetMap() == corpse->FindMap() && !me->IsInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) && !IsCasting() && !CCed(me) && me->GetDistance(corpse) > 5)
+                        me->GetMotionMaster()->MovePoint(corpse->GetMapId(), *corpse);
+                }
+                else
+                {
+                    if (m_botCommandState != COMMAND_FOLLOW || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
+                        Follow(true);
+                }
+            }
+            else if (m_botCommandState != COMMAND_STAY && !IsCasting())
+            {
+                CalculatePos(pos);
+                uint8 followdist = master->GetBotFollowDist();
+                if (me->GetExactDist(&pos) > (followdist > 8 ? 4 + followdist/2*(!master->isMoving()) : 8))
+                    Follow(true, &pos); // check if doing nothing
+            }
+        }
+        if (!IsCasting())
+        {
+            if (me->IsInCombat())
+            {
+                if (me->GetSheath() != SHEATH_STATE_MELEE)
+                    me->SetSheath(SHEATH_STATE_MELEE);
+            }
+            else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
+                me->SetSheath(SHEATH_STATE_UNARMED);
+        }
+        UpdateMountedState();
+        UpdateStandState();
+        UpdateRations();
+    }
+}
+void bot_pet_ai::CheckAuras(bool /*force*/)
+{
+    if (checkAurasTimer > 0) return;
+    checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
+    if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
+    {
+        opponent = me->GetVictim();
+        if (opponent)
+        {
+            switch (GetPetType(me))
+            {
+                case PET_TYPE_IMP:
+                    CalculateAttackPos(opponent, attackpos);
+                    if (me->GetDistance(attackpos) > 8)
+                        GetInPosition(true, true, opponent, &attackpos);
+                    break;
+                default:
+                    if (me->GetDistance(opponent) > 1.5f)
+                        GetInPosition(true, false);
+                    break;
+            }
+        }
+    }
+    if (clear_cd > 0)
+        --clear_cd;
+    else
+    {
+        FindTank();
+        clear_cd = 15;
+    }
+    return;
+}
+
+bool bot_ai::CanBotAttack(Unit* target, int8 byspell) const
+{
+    if (!target) return false;
+    uint8 followdist = master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    return
+       (target->IsAlive() &&
+       target->IsVisible() &&
+       (master->isDead() || target->GetTypeId() == TYPEID_PLAYER || target->IsPet() ||
+       (target->GetDistance(master) < foldist && me->GetDistance(master) < followdist)) &&//if master is killed pursue to the end
+        target->isTargetableForAttack() &&
+        !IsInBotParty(target) &&
+        (target->IsHostileTo(master) ||
+        (target->GetReactionTo(master) < REP_FRIENDLY && master->GetVictim() == target && (master->IsInCombat() || target->IsInCombat())) ||//master has pointed this target
+        target->IsHostileTo(me)) &&//if master is controlled
+        //target->IsWithinLOSInMap(me) &&
+        (byspell == -1 || !target->IsImmunedToDamage(byspell ? SPELL_SCHOOL_MASK_MAGIC : SPELL_SCHOOL_MASK_NORMAL)));
+}
+//GETTARGET
+//Returns attack target or 'no target'
+//uses follow distance if range isn't set
+Unit* bot_ai::getTarget(bool byspell, bool ranged, bool &reset) const
+{
+    //check if no need to change target
+    Unit* u = master->GetVictim();
+    Unit* mytar = me->GetVictim();
+    if (!mytar && IsMinionAI())
+        if (Creature* pet = me->GetBotsPet())
+            mytar = pet->GetVictim();
+
+    if (u && u == mytar)
+    {
+        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s continues attack common target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;//forced
+    }
+    //Follow if...
+    uint8 followdist = master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if (!u && master->IsAlive() && (me->GetDistance(master) > foldist || (mytar && master->GetDistance(mytar) > foldist && me->GetDistance(master) > foldist)))
+    {
+        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s cannot attack target %s, too far away", me->GetName().c_str(), mytar ? mytar->GetName().c_str() : "");
+        return NULL;
+    }
+
+    if (u && (master->IsInCombat() || u->IsInCombat()) && !InDuel(u) && !IsInBotParty(u))
+    {
+        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s starts attack master's target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;
+    }
+
+    if (CanBotAttack(mytar, byspell) && !InDuel(mytar))
+    {
+        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s continues attack its target %s", me->GetName().c_str(), mytar->GetName().c_str());
+        if (me->GetDistance(mytar) > (ranged ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
+            reset = true;
+        return mytar;
+    }
+
+    if (followdist == 0 && master->IsAlive())
+        return NULL; //do not bother
+
+    //check group
+    Group* gr = master->GetGroup();
+    if (!gr)
+    {
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = master->GetBotMap(i)->_Cre();
+            if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+            u = bot->GetVictim();
+            if (u && CanBotAttack(u, byspell) && 
+                (bot->IsInCombat() || u->IsInCombat()) && 
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+            Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+            if (!pet || !pet->InSamePhase(me)) continue;
+            u = pet->GetVictim();
+            if (u && CanBotAttack(u, byspell) && 
+                (pet->IsInCombat() || u->IsInCombat()) && 
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+        }
+    }
+    else
+    {
+        for (GroupReference* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+        {
+            Player* pl = ref->GetSource();
+            if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+            if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+            u = pl->GetVictim();
+            if (u && pl != master && CanBotAttack(u, byspell) && 
+                (pl->IsInCombat() || u->IsInCombat()) && 
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName().c_str(), pl->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+            if (!pl->HaveBot()) continue;
+            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+            {
+                Creature* bot = pl->GetBotMap(i)->_Cre();
+                if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                if (!bot->IsInWorld()) continue;
+                if (me->GetMap() != bot->FindMap()) continue;
+                u = bot->GetVictim();
+                if (u && CanBotAttack(u, byspell) && 
+                    (bot->IsInCombat() || u->IsInCombat()) && 
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+                Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+                if (!pet || !pet->InSamePhase(me)) continue;
+                if (!pet->IsInWorld()) continue;
+                if (me->GetMap() != pet->FindMap()) continue;
+                u = pet->GetVictim();
+                if (u && CanBotAttack(u, byspell) && 
+                    (pet->IsInCombat() || u->IsInCombat()) && 
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+            }
+        }
+    }
+
+    //check targets around
+    Unit* t = NULL;
+    float maxdist = InitAttackRange(float(followdist), ranged);
+    //first cycle we search non-cced target, then, if not found, check all
+    for (uint8 i = 0; i != 2; ++i)
+    {
+        if (!t)
+        {
+            bool attackCC = i;
+
+            CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+            Cell cell(p);
+            cell.SetNoCreate();
+
+            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC);
+            Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(master, t, check);
+            me->VisitNearbyObject(maxdist, searcher);
+        }
+    }
+
+    if (t && opponent && t != opponent)
+    {
+        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s has Found new target %s", me->GetName().c_str(), t->GetName().c_str());
+        reset = true;
+    }
+    return t;
+}
+//'CanAttack' function
+bool bot_ai::CheckAttackTarget(uint8 botOrPetType)
+{
+    bool byspell = false, ranged = false, reset = false;
+    if (IsMinionAI())
+    {
+        switch (botOrPetType)
+        {
+            case CLASS_DRUID:
+                byspell = me->GetShapeshiftForm() == FORM_NONE || 
+                    me->GetShapeshiftForm() == FORM_TREE || 
+                    me->GetShapeshiftForm() == FORM_MOONKIN;
+                ranged = byspell;
+                break;
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_WARLOCK:
+            case CLASS_SHAMAN:
+                byspell = true;
+                ranged = true;
+                break;
+            case CLASS_HUNTER:
+                ranged = true;
+                break;
+            default:
+                break;
+        }
+    }
+    else
+    {
+        switch (botOrPetType)
+        {
+            case PET_TYPE_IMP:
+                byspell = true;
+                ranged = true;
+                break;
+            default:
+                break;
+        }
+    }
+
+    opponent = getTarget(byspell, ranged, reset);
+    if (!opponent)
+    {
+        me->AttackStop();
+        return false;
+    }
+
+    if (reset)
+        m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
+
+    if (opponent != me->GetVictim())
+        me->Attack(opponent, !ranged);
+    return true;
+}
+//POSITION
+void bot_ai::CalculateAttackPos(Unit* target, Position& pos) const
+{
+    uint8 followdist = master->GetBotFollowDist();
+    float x(0),y(0),z(0),
+        dist = float(6 + urand(followdist/4, followdist/3)),
+        angle = target->GetAngle(me);
+    dist = std::min(dist, 20.f);
+    if (me->GetIAmABotsPet())
+        dist *= 0.5f;
+    float clockwise = RAND(1.f,-1.f);
+    for (uint8 i = 0; i != 5; ++i)
+    {
+        target->GetNearPoint(me, x, y, z, me->GetObjectSize()/2.f, dist, angle);
+        bool toofaraway = master->GetDistance(x,y,z) > (followdist > 30 ? 30.f : followdist < 20 ? 20.f : float(followdist));
+        bool outoflos = !target->IsWithinLOS(x,y,z);
+        if (toofaraway || outoflos)
+        {
+            if (toofaraway)
+                angle = target->GetAngle(master) + frand(0.f, M_PI*0.5f) * clockwise;
+            if (outoflos)
+                dist *= 0.5f;
+        }
+        else
+        {
+            dist *= 0.75f;
+            break;
+        }
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_ai::GetInPosition(bool force, bool ranged, Unit* newtarget, Position* mypos)
+{
+    if (me->HasUnitState(UNIT_STATE_ROOT)) return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || m_botCommandState == COMMAND_STAY) && !force)
+        return;
+    if (IsCasting())
+        return;
+    uint8 followdist = master->GetBotFollowDist();
+    if (ranged)
+    {
+        if (newtarget->GetTypeId() == TYPEID_PLAYER && 
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3)) return;//do not allow constant runaway from player
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetDistance(attackpos) > 8)
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+    }
+    else
+        me->GetMotionMaster()->MoveChase(newtarget);
+    if (newtarget != me->GetVictim())
+        me->Attack(newtarget, !ranged);
+}
+
+bool bot_ai::MoveBehind(Unit& target) const
+{
+    if (me->HasUnitState(UNIT_STATE_ROOT)) return false;
+    if (target.IsWithinCombatRange(me, ATTACK_DISTANCE) &&
+        target.HasInArc(M_PI, me)                       &&
+        tank != me &&
+        (me->GetBotClass() == CLASS_ROGUE ? target.GetVictim() != me || CCed(&target) : target.GetVictim() != me && !CCed(&target)))
+    {
+        float x(0),y(0),z(0);
+        target.GetNearPoint(me, x, y, z, me->GetObjectSize()/3, 0.1f, me->GetAngle(&target));
+        me->GetMotionMaster()->MovePoint(target.GetMapId(), x, y, z);
+        return true;
+    }
+    return false;
+}
+//MOUNT SUPPORT
+void bot_minion_ai::UpdateMountedState()
+{
+    //DEBUG
+    if (master->IsMounted() && me->IsMounted())
+    {
+        if ((master->HasAuraType(SPELL_AURA_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_FLYING)))
+        {
+            //creature don't benefit from mount flight speed, so force it
+            if (me->GetSpeed(MOVE_FLIGHT) != master->GetSpeed(MOVE_FLIGHT)/2)
+            me->SetSpeed(MOVE_FLIGHT, master->GetSpeed(MOVE_FLIGHT)/2);
+        }
+        return;
+    }
+    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
+    bool mounted = me->IsMounted();
+    if ((!master->IsMounted() || aura != mounted || (me->IsInCombat() && opponent)) && (aura || mounted))
+    {
+        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+        me->Dismount();
+        return;
+    }
+    //END DEBUG
+    if (me->IsInCombat() || IsCasting() || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING)) //IsInWater() is too much calculations
+        return;
+    //fly
+    //if ((master->IsMounted() && master->HasAuraType(SPELL_AURA_FLY))/* || master->HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_FLYING)*/)
+    //{
+    //    if (!me->IsMounted() || !me->HasAuraType(SPELL_AURA_FLY))
+    //    {
+    //        //if (me->GetBotClass() == CLASS_DRUID && InitSpell(FLY_FORM))//TODO
+    //        //{
+    //        //}
+    //        //else
+    //        {
+    //            uint32 mount = 0;
+    //            Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+    //            if (!mounts.empty())
+    //                mount = mounts.front()->GetId();
+    //            if (mount)
+    //            {
+    //                if (me->HasAuraType(SPELL_AURA_MOUNTED))
+    //                        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+    //                if (doCast(me, mount))
+    //                {
+    //                    if (Feasting())
+    //                    {
+    //                        me->RemoveAurasDueToSpell(DRINK);
+    //                        me->RemoveAurasDueToSpell(EAT);
+    //                    }
+    //                }
+    //            }
+    //        }
+    //    }
+    //}
+    ////ground
+    /*else */
+    if (master->IsMounted() && !me->IsMounted() && !master->IsInCombat() && !me->IsInCombat() && !me->GetVictim())
+    {
+        uint32 mount = 0;
+        Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        if (!mounts.empty())
+            mount = mounts.front()->GetId();
+        if (mount)
+        {
+            if (me->HasAuraType(SPELL_AURA_MOUNTED))
+                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+            if (Feasting())
+            {
+                me->RemoveAurasDueToSpell(DRINK);
+                me->RemoveAurasDueToSpell(EAT);
+            }
+            if (doCast(me, mount))
+            {
+                return;
+            }
+        }
+    }
+}
+//STANDSTATE
+void bot_minion_ai::UpdateStandState() const
+{
+    if (master->getStandState() == UNIT_STAND_STATE_STAND && 
+        me->getStandState() == UNIT_STAND_STATE_SIT && 
+        !(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    if ((master->getStandState() == UNIT_STAND_STATE_SIT || Feasting()) && !me->IsInCombat() && !me->isMoving() && 
+        me->getStandState() == UNIT_STAND_STATE_STAND)
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+
+}
+//RATIONS
+void bot_minion_ai::UpdateRations() const
+{
+    if (me->IsInCombat() || CCed(me))
+    {
+        if (me->HasAura(EAT))   me->RemoveAurasDueToSpell(EAT);
+        if (me->HasAura(DRINK)) me->RemoveAurasDueToSpell(DRINK);
+    }
+
+    //drink
+    if (me->getPowerType() == POWER_MANA && !me->IsMounted() && !me->isMoving() && !CCed(me) && 
+        !me->IsInCombat() && !IsCasting() && urand(0, 100) < 20 && GetManaPCT(me) < 80 && 
+        !me->HasAura(DRINK))
+    {
+        me->CastSpell(me, DRINK);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA) && me->HasAura(DRINK))
+        me->ModifyPower(POWER_MANA, me->GetCreateMana()/20);
+
+    //eat
+    if (!me->IsMounted() && !me->isMoving() && !CCed(me) && 
+        !me->IsInCombat() && !IsCasting() && urand(0, 100) < 20 && GetHealthPCT(me) < 80 && 
+        !me->HasAura(EAT))
+    {
+        me->CastSpell(me, EAT);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (me->GetHealth() < me->GetMaxHealth() && me->HasAura(EAT))
+        me->SetHealth(me->GetHealth() + me->GetCreateHealth()/20);
+
+    //check
+    if (me->GetHealth() >= me->GetMaxHealth() && me->HasAura(EAT))
+        me->RemoveAurasDueToSpell(EAT);
+
+    if (me->getPowerType() == POWER_MANA && 
+        me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA) && 
+        me->HasAura(DRINK))
+        me->RemoveAurasDueToSpell(DRINK);
+}
+//PASSIVES
+// Used to apply common passives (run once)
+void bot_ai::ApplyPassives(uint8 botOrPetType) const
+{
+    //me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+    //me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+    //apply +healing taken
+    if (master->getLevel() >= 60) RefreshAura(BOR);//+40%
+    if (IsMinionAI())
+    {
+        //apply -threat mod
+        switch (botOrPetType)
+        {
+            case CLASS_WARRIOR:
+                RefreshAura(RCP,1);//-27%
+                break;
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_ROGUE:
+                RefreshAura(RCP,3);//-87%
+                break;
+            default:
+                RefreshAura(RCP,2);//-54%
+                break;
+        }
+    }
+    else
+    {
+        switch (botOrPetType)
+        {
+            case PET_TYPE_VOIDWALKER:
+                RefreshAura(DEFENSIVE_STANCE_PASSIVE,2);
+                break;
+            default:
+                break;
+        }
+    }
+}
+//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
+bool bot_ai::InDuel(Unit* target) const
+{
+    if (!target) return false;
+    bool isbot = target->GetTypeId() == TYPEID_UNIT && (target->ToCreature()->GetIAmABot() || target->ToCreature()->GetIAmABotsPet());
+    Player* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : isbot ? target->ToCreature()->GetBotOwner() : NULL;
+    if (!player)
+    {
+        if (!target->IsControlledByPlayer())
+            return false;
+        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
+    }
+
+    return (player && player->duel && (IsInBotParty(player) || IsInBotParty(player->duel->opponent)));
+}
+//Used to find target for priest's dispels and mage's spellsteal (also shaman's purge in future)
+//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
+Unit* bot_minion_ai::FindHostileDispelTarget(float dist, bool stealable) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    HostileDispelTargetCheck check(me, dist, stealable, this);
+    Trinity::UnitLastSearcher <HostileDispelTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds single target affected by given spell (and given caster if is)
+//Can check:
+//    hostile targets  (hostile = 0) <default>
+//    our party players (hostile = 1)
+//    our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any target in range  (hostile = any other value)
+Unit* bot_minion_ai::FindAffectedTarget(uint32 spellId, uint64 caster, float dist, uint8 hostile) const
+{
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    CellCoord p(Trinity::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
+    Trinity::UnitLastSearcher <AffectedTargetCheck> searcher(master, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
+
+    return unit;
+}
+//Finds target for mage's polymorph (maybe for Hex in future)
+Unit* bot_minion_ai::FindPolyTarget(float dist, Unit* currTarget) const
+{
+    if (!currTarget)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    PolyUnitCheck check(me, dist, currTarget);
+    Trinity::UnitLastSearcher <PolyUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for direct fear (warlock)
+Unit* bot_minion_ai::FindFearTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    FearUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <FearUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for paladin's repentance
+Unit* bot_minion_ai::FindRepentanceTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    StunUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <StunUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for priest's shackles
+Unit* bot_minion_ai::FindUndeadCCTarget(float dist, uint32 spellId/* = 0*/) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    UndeadCCUnitCheck check(me, dist, spellId);
+    Trinity::UnitLastSearcher <UndeadCCUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for druid's Entangling Roots
+Unit* bot_minion_ai::FindRootTarget(float dist, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    RootUnitCheck check(me, me->GetVictim(), dist, spellId);
+    Trinity::UnitLastSearcher <RootUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds casting target (friend or enemy)
+Unit* bot_minion_ai::FindCastingTarget(float dist, bool isFriend, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    CastingUnitCheck check(me, dist, isFriend, spellId);
+    Trinity::UnitLastSearcher <CastingUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+// Returns target for AOE spell (blizzard, hurricane etc.) based on attackers count
+// Cycles through BotParty, first checks player and, if checked, npcbots
+// If checked, can return friendly target as target for AOE spell
+Unit* bot_minion_ai::FindAOETarget(float dist, bool checkbots, bool targetfriend) const
+{
+    if (me->isMoving() || IsCasting()) return NULL;//prevent aoe casts while running away
+    Unit* unit = NULL;
+    Group* pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        AttackerSet m_attackers = master->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if ((*iter)->isMoving()) continue;
+                if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                    continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = master->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = master;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (!checkbots)
+            return unit;
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = master->GetBotMap(i)->_Cre();
+            if (!bot || bot->isDead() || !bot->IsInWorld() || me->GetDistance(bot) > dist) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || (*iter)->isDead()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                        continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+            if (unit) return unit;
+        }//end for
+        return unit;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (!tPlayer) continue;
+        if (checkbots && tPlayer->HaveBot())
+            Bots = true;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (tPlayer->isDead() || me->GetMap() != tPlayer->FindMap()) continue;
+        if (me->GetDistance(tPlayer) > 40) continue;
+
+        AttackerSet m_attackers = tPlayer->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if ((*iter)->isMoving()) continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = tPlayer->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = tPlayer;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (unit) return unit;
+    }//end for
+    if (!Bots) return NULL;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+            if (!bot || bot->isDead() || me->GetMap() != bot->FindMap()) continue;
+            if (!bot->IsInWorld()) continue;
+            if (me->GetDistance(bot) > 40) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || (*iter)->isDead()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+        }//end for
+        if (unit) return unit;
+    }//end for
+    return unit;
+}
+// Finds secondary target for spells like Cleave, Swipe, Mind Sear etc.
+Unit* bot_minion_ai::FindSplashTarget(float dist, Unit* To) const
+{
+    if (!To)
+        To = me->GetVictim();
+    if (!To)
+        return NULL;
+
+    if (me->GetDistance(To) > dist)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    SecondEnemyCheck check(me, dist, To, this);
+    Trinity::UnitLastSearcher <SecondEnemyCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+
+//////////
+//Internal
+//////////
+
+//Using rist-rank spell as source, returns spell of max rank allowed for given caster
+uint32 bot_ai::InitSpell(Unit* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+        return 0;//weird spell with no info, disable it
+
+    uint8 lvl = caster->getLevel();
+    if (lvl < info->BaseLevel)//only 1st rank spells check
+        return 0;//cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell;//cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id);//can use next rank, forward check
+    }
+
+    return spell;//max rank, use this
+}
+//Health magement for minions
+//Including health calcs, set and regeneration
+void bot_minion_ai::_OnHealthUpdate(uint8 myclass, uint8 mylevel) const
+{
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "_OnHealthUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = me->GetHealthPct();// needs for regeneration
+    uint32 m_basehp = classinfo->basehealth;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "class base health: %u", m_basehp);
+    me->SetCreateHealth(m_basehp);
+    float stammod;
+    switch (myclass)
+    {
+        case CLASS_WARRIOR: case CLASS_DEATH_KNIGHT: case BEAR:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 16.f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 13.f;
+                    break;
+                default: stammod = 9.8f; break;
+            }
+            break;
+        case CLASS_PALADIN:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 15.5f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 12.5f;
+                    break;
+                case CLASS_PALADIN:
+                    stammod = 9.8f;
+                    break;
+                default: stammod = 9.f; break;
+            }
+            break;
+        case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 9.8f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 8.f;
+                    break;
+                default: stammod = 5.f; break;
+            }
+            break;
+        case CLASS_DRUID: case CAT: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 12.f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 9.8f;
+                    break;
+                default: stammod = 8.f; break;
+            }
+            break;
+        default: stammod = 10.f;
+            break;
+    }
+    stammod -= 0.3f;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "stammod: %f", stammod);
+    
+    //manually pick up stamina from bot's buffs
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
+    stamValue = std::max(stamValue - 18.f, 1.f); //remove base stamina (not calculated into health)
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
+    int32 hp_add = int32(stamValue * 10.f);
+    //pick up master's stamina from items
+    float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT) - 0.1f), 1.f);
+    float base_stam = master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE);
+    base_stam = std::max(base_stam - 18.f, 0.f); //remove base stamina (not calculated into health)
+    stamValue = base_stam * master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT) * total_pct;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
+    hp_add += int32(stamValue*stammod);
+    //float stamstat = stat * 0.5f;
+    //if (stamValue > stamstat)
+    //{
+    //    //sLog->outBasic("selected stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
+    //    hp_add += int32(stamValue * stammod);
+    //}
+    //else
+    //{
+    //    //sLog->outBasic("selected stat to health add: stamStat (%f), value: %f", stamstat, stamstat*stammod);
+    //    hp_add += int32(stamstat * stammod);
+    //}
+    //sLog->outBasic("health to add after master's stat mod: %i", hp_add);
+    int32 miscVal = me->getGender()*mylevel;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to remove from gender mod: %i", -miscVal);
+    hp_add -= miscVal;//less hp for females lol
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to add after gender mod: %i", hp_add);
+    //miscVal = myrace*(mylevel/5);
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to add from race mod: %i", miscVal);
+    //hp_add += miscVal;//draenei tanks lol
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to add after race mod: %i", hp_add);
+    miscVal = master->GetNpcBotSlot(me->GetGUID()) * (mylevel/5);
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to remove from slot mod: %i", -miscVal);
+    hp_add -= miscVal;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to add after slot mod: %i", hp_add);
+    uint32 m_totalhp = m_basehp + hp_add;//m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "total base health: %u", m_totalhp);
+    if (master->GetBotTankGuid() == me->GetGUID())
+    {
+        m_totalhp = (m_totalhp * 135) / 100;//35% hp bonus for tanks
+        //sLog->outBasic("total base health (isTank): %u", m_totalhp);
+    }
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));//replaces base 18900 hp at 80 lvl
+    me->UpdateMaxHealth();//will use our values we just set (update base health and buffs)
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "overall hp: %u", me->GetMaxHealth());
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f));//restore pct
+    if (!me->IsInCombat())
+        me->SetHealth(me->GetHealth() + m_basehp / 100);//regenerate
+}
+//Mana management for minions
+//Including calcs and set
+void bot_minion_ai::_OnManaUpdate(uint8 myclass, uint8 mylevel) const
+{
+    if (me->getPowerType() != POWER_MANA)
+        return;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "_OnManaUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = classinfo->basemana > 0 ? classinfo->basemana : me->GetCreateMana();
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "classinfo base mana = %f", m_basemana);
+    me->SetCreateMana(m_basemana);//set base mana, critical
+    float manamod = 15.f;//here we set mana multiplier from intellect as we gain mana from MASTER's stats mostly
+    switch (myclass)
+    {
+        case CLASS_PALADIN: case CLASS_HUNTER: manamod =  4.5f; break;
+        case CLASS_SHAMAN:                     manamod = 11.5f; break;
+        case CLASS_DRUID:                      manamod = 12.5f; break;
+        case CLASS_PRIEST:                     manamod = 16.5f; break;
+        case CLASS_MAGE: case CLASS_WARLOCK:   manamod = 10.5f; break;
+        default:                                                break;
+    }
+    //manamod += 1.f;//custom
+    //manamod *= 0.70f;//custom
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "Manamod: %f", manamod);
+    float intValue = me->GetTotalStatValue(STAT_INTELLECT);
+    intValue = std::max(intValue - 18.f, 1.f); //remove base int (not calculated into mana)
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot's stats to mana add: Int (%f), value: %f", intValue, intValue * manamod);
+    m_basemana += intValue * 15.f;
+    //pick up master's intellect from items if master has mana
+    if (master->getPowerType() == POWER_MANA)
+    {
+        float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT) - 0.1f), 1.f);
+        intValue = std::max(master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE) - 18.f, 1.f); //remove base int (not calculated into mana)
+        intValue = intValue * master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT) * total_pct;
+    }
+    else// pick up maxstat
+        intValue = stat * 0.5f;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "mana add from master's stat: %f", intValue * manamod);
+    m_basemana += intValue * manamod;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "base mana + mana from master's intellect or stat: %f", m_basemana);
+    //intValue = me->GetTotalAuraModValue(UNIT_MOD_STAT_INTELLECT);
+    //sLog->outBasic("Intellect from buffs: %f", intValue);
+    //m_basemana += uint32(intValue) * manamod;
+    //sLog->outBasic("base mana + mana from intellect + mana from buffs: %u", m_basemana);
+    uint8 otherVal = me->getGender()*3*mylevel;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "mana to add from gender mod: %u", otherVal);
+    m_basemana += float(otherVal);//more mana for females lol
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "base mana after gender mod: %f", m_basemana);
+    otherVal = master->GetNpcBotSlot(me->GetGUID()) * (mylevel/5);// only to make mana unique
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "mana to remove from slot mod: %i", -int8(otherVal));
+    m_basemana -= otherVal;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "base mana after slot mod: %f", m_basemana);
+    float m_totalmana = m_basemana;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "total mana to set: %f", m_totalmana);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_totalmana);
+    me->UpdateMaxPower(POWER_MANA);
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "Overall mana to set: %u", me->GetMaxPower(POWER_MANA));
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f));//restore pct
+    //No Regen
+}
+//Melee damage for minions (melee classes only)
+//Calculation is based on master's attack power if melee/hunter or spellpower 
+void bot_minion_ai::_OnMeleeDamageUpdate(uint8 myclass) const
+{
+    if (ap_mod == 0.f) return; //do not bother casters
+    //sLog->outBasic("_OnMeleeDamageUpdate: Updating bot %s", me->GetName().c_str());
+    float my_ap_mod = ap_mod;
+    float mod = master->getClass() == CLASS_HUNTER ? (master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT))/2.f : 
+        (master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT))/2.f;
+    mod = std::max(mod, 1.f); // x1 is Minimum
+    mod = std::min(mod, 2.5f); // x2.5 is Maximum
+    //sLog->outBasic("got base damage modifier: %f", mod);
+    mod -= (mod - 1.f)*0.33f;//reduce bonus by 33%
+    //sLog->outBasic("damage modifier truencated to %f, applying", mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT, mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT, mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);
+    me->SetCanDualWield(myclass == CLASS_ROGUE || myclass == CLASS_SHAMAN);
+    //Rogue has mainhand attack speed 1900, other dual-wielders - 2800 or 2600 or 2400
+    if (myclass == CLASS_ROGUE)
+        me->SetAttackTime(BASE_ATTACK, 1900);
+    if (me->CanDualWield())
+        me->SetAttackTime(OFF_ATTACK, myclass == CLASS_ROGUE ? 1400 : 1800);
+    //me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);//NUY
+    mod = (mod - 1.f)*0.5f;
+    //sLog->outBasic("reduced damage modifier to gain bonus: %f", mod);
+    //sLog->outBasic("base ap modifier is %f", my_ap_mod);
+    my_ap_mod *= 0.5f;
+    //sLog->outBasic("ap modifier multiplied to %f", my_ap_mod);
+    my_ap_mod += my_ap_mod > 0.f ? mod : 0.f; //add reduced master's multiplier if can have damage
+    //sLog->outBasic("ap modifier + mod = %f", my_ap_mod);
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_PCT, my_ap_mod);
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_PCT, my_ap_mod);
+
+    int32 sppower = 0;
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
+        if (power > sppower)
+            sppower = power;
+    }
+    //sLog->outBasic("master's spellpower is %i, multiplying...", sppower);
+    sppower *= 1.5f;
+    //sLog->outBasic("got spellpower of %i", sppower);
+    //atpower = float(master->GetInt32Value(master->getClass() == CLASS_HUNTER ? UNIT_FIELD_RANGED_ATTACK_POWER : UNIT_FIELD_ATTACK_POWER));
+    float atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
+    //sLog->outBasic("master's base attack power is %f", atpower);
+    atpower = sppower > atpower ? sppower : atpower;//highest stat is used (either 1.5x spellpower or attack power)
+    //sLog->outBasic("chosen attack power stat value: %f", atpower);
+    //sLog->outBasic("expected attack power: %f", atpower*ap_mod);
+
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+    if (myclass == CLASS_HUNTER || myclass == CLASS_ROGUE)
+    {
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage(true);
+    }
+    me->UpdateAttackPowerAndDamage();
+    //sLog->outBasic("listing stats: ");
+    //sLog->outBasic("attack power main hand: %f", me->GetTotalAttackPowerValue(BASE_ATTACK));
+    //sLog->outBasic("attack power off hand: %f", me->GetTotalAttackPowerValue(OFF_ATTACK));
+    //sLog->outBasic("attack power ranged: %f", me->GetTotalAttackPowerValue(RANGED_ATTACK));
+    //sLog->outBasic("damage multiplier main hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    //sLog->outBasic("damage multiplier off hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+    //sLog->outBasic("damage multiplier ranged: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+    //sLog->outBasic("Damage range main hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    //sLog->outBasic("Damage range off hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+    //sLog->outBasic("Damage range ranged: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+}
+//Health for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnHealthUpdate(uint8 /*petType*/, uint8 mylevel) const
+{
+    float hp_mult = 10.f;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:
+            hp_mult = 11.f;
+            break;
+        default:
+            break;
+    }
+    float pct = me->GetHealthPct();// needs for regeneration
+    //Use simple checks and calcs
+    //0.3 hp for bots (inaccurate but cheap)
+    uint32 m_basehp = me->GetCreateHealth()/2;
+    //pick up stamina from buffs
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
+    stamValue = std::max(stamValue - 18.f, 1.f); //remove base stamina (not calculated into health)
+    uint32 hp_add = uint32(stamValue*hp_mult);
+    hp_add += (m_creatureOwner->GetMaxHealth() - m_creatureOwner->GetCreateHealth())*0.3f;
+    uint8 miscVal = GetPetType(me)*mylevel;
+    hp_add -= miscVal;
+    uint32 m_totalhp = m_basehp + hp_add;
+    if (master->GetBotTankGuid() == me->GetGUID())
+        m_totalhp = (m_totalhp*135) / 100;//35% hp bonus for tanks
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));
+    me->UpdateMaxHealth();//will use values set (update base health and buffs)
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth())*pct / 100.f));//restore pct
+    if (!me->IsInCombat())
+        me->SetHealth(me->GetHealth() + m_basehp / 100);//regenerate
+}
+//Mana for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnManaUpdate(uint8 /*petType*/, uint8 mylevel) const
+{
+    if (me->getPowerType() != POWER_MANA)
+        return;
+
+    float mana_mult = 15.f;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:
+            mana_mult = 11.5f;
+            break;
+        default:
+            break;
+    }
+    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    //Use simple checks and calcs
+    //0.3 mana for bots (inaccurate but cheap)
+    float m_basemana = float(me->GetCreateMana());
+    m_basemana += (std::max<float>(me->GetTotalStatValue(STAT_INTELLECT) - 18.f, 1.f))*mana_mult; //remove base stamina (not calculated into mana)
+    m_basemana += float(m_creatureOwner->GetMaxPower(POWER_MANA) - m_creatureOwner->GetCreateMana())*0.3f;
+    m_basemana -= float(GetPetType(me)*mylevel);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA))*pct / 100.f));//restore pct
+}
+//Sends all master's bots a message to not try to evade for a certain period of time
+void bot_ai::SendPartyEvadeAbort() const
+{
+    for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        if (Creature* bot = master->GetBotMap(i)->_Cre())
+            if (bot_minion_ai* ai = bot->GetBotMinionAI())
+                ai->SetEvadeTimer(50);
+}
+//Removes buggy bots' threat from party, so no 'stuck in combat' bugs form bot mod
+//optionally interrupts casted spell if target is dead for bot and it's pet
+void bot_minion_ai::_OnEvade()
+{
+    if (me->HasUnitState(UNIT_STATE_CASTING))
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = me->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (u->isDead() && !IsInBotParty(u))
+                            me->InterruptSpell(CurrentSpellTypes(i), false, false);
+
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet && m_botsPet->HasUnitState(UNIT_STATE_CASTING))
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = m_botsPet->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (u->isDead() && !IsInBotParty(u))
+                            m_botsPet->InterruptSpell(CurrentSpellTypes(i), false, false);
+
+    if (Rand() > 10) return;
+    if (!master->IsInCombat() && !me->IsInCombat() && (!m_botsPet || !m_botsPet->IsInCombat())) return;
+    if (CheckAttackTarget(GetBotClassForCreature(me)))
+        return;
+    //ChatHandler ch(master);
+    //ch.PSendSysMessage("_OnEvade() by bot %s", me->GetName().c_str());
+    if (master->IsInCombat())
+    {
+        HostileRefManager& mgr = master->getHostileRefManager();
+        if (!mgr.isEmpty())
+        {
+            std::set<Unit*> Set;
+            HostileReference* ref = mgr.getFirst();
+            while (ref)
+            {
+                if (ref->GetSource() && ref->GetSource()->GetOwner())
+                    Set.insert(ref->GetSource()->GetOwner());
+                ref = ref->next();
+            }
+            for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+            {
+                Unit* unit = (*i);
+                if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                {
+                    //ch.PSendSysMessage("_OnEvade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), master->GetName().c_str());
+                    mgr.deleteReference(unit);
+                }
+            }
+        }
+    }
+    else
+    {
+        SendPartyEvadeAbort();
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* cre = master->GetBotMap(i)->_Cre();
+            if (!cre) continue;
+            if (cre->IsInCombat())
+            {
+                cre->DeleteThreatList();
+                HostileRefManager& mgr = cre->getHostileRefManager();
+                if (!mgr.isEmpty())
+                {
+                    std::set<Unit*> Set;
+                    HostileReference* ref = mgr.getFirst();
+                    while (ref)
+                    {
+                        if (ref->GetSource() && ref->GetSource()->GetOwner())
+                            Set.insert(ref->GetSource()->GetOwner());
+                        ref = ref->next();
+                    }
+                    for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                    {
+                        Unit* unit = (*i);
+                        if (!unit->InSamePhase(me)) continue;
+                        if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                        {
+                            //ch.PSendSysMessage("_OnEvade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), cre->GetName().c_str());
+                            mgr.deleteReference(unit);
+                        }
+                    }
+                }
+                //if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
+                //{
+                //    if (cre->IsInCombat())
+                //    {
+                //        //ch.PSendSysMessage("_OnEvade(): %s's HostileRef is empty! Combatstop!", cre->GetName().c_str());
+                //        cre->ClearInCombat();
+                //    }
+                //}
+            }
+
+            Creature* m_botsPet = cre->GetBotsPet();
+            if (!m_botsPet || !m_botsPet->IsInCombat()) continue;
+            m_botsPet->DeleteThreatList();
+            HostileRefManager& mgr = m_botsPet->getHostileRefManager();
+            if (!mgr.isEmpty())
+            {
+                std::set<Unit*> Set;
+                HostileReference* ref = mgr.getFirst();
+                while (ref)
+                {
+                    if (ref->GetSource() && ref->GetSource()->GetOwner())
+                        Set.insert(ref->GetSource()->GetOwner());
+                    ref = ref->next();
+                }
+                for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                {
+                    Unit* unit = (*i);
+                    if (!unit->InSamePhase(me)) continue;
+                    if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                    {
+                        //ch.PSendSysMessage("_OnEvade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), m_botsPet->GetName().c_str());
+                        mgr.deleteReference(unit);
+                    }
+                }
+            }
+            //if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
+            //{
+            //    if (m_botsPet->IsInCombat())
+            //    {
+            //        //ch.PSendSysMessage("_OnEvade(): %s's HostileRef is empty! Combatstop!", pet->GetName().c_str());
+            //        m_botsPet->ClearInCombat();
+            //    }
+            //}
+        }
+    }
+}
+//SpellHit()... OnSpellHit()
+void bot_ai::OnSpellHit(Unit* /*caster*/, SpellInfo const* spell)
+{
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 auraname = spell->Effects[i].ApplyAuraName;
+        //remove pet on mount
+        if (auraname == SPELL_AURA_MOUNTED)
+            me->SetBotsPetDied();
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT)
+        {
+            doHealth = true;
+            doMana = true;
+        }
+        else
+        {
+            if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH || 
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 || 
+                auraname == SPELL_AURA_230 ||  // SPELL_AURA_MOD_INCREASE_HEALTH_2
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+                doHealth = true;
+            else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY || 
+                auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+                doMana = true;
+        }
+    }
+}
+//Messed up
+//Hp + Mana update
+//target update
+//returns fake wait time between overall AI updates (if it is even understandable)
+uint8 bot_ai::GetWait()
+{
+    if (doHealth)
+    {
+        doHealth = false;
+        _OnHealthUpdate(me->GetBotClass(), master->getLevel());
+    }
+    if (doMana)
+    {
+        doMana = false;
+        _OnManaUpdate(me->GetBotClass(), master->getLevel());
+    }
+    CheckAuras(true);
+    //0 to 2 plus 1 for every 3 bots except first one
+    return (1 + (master->GetNpcBotsCount() - 1)/3 + (irand(0,100) <= 50)*int8(RAND(-1,1)));
+}
+//Damage Mods
+//1) Apply class-specified damage/crit chance/crit damage bonuses
+//2) Apply bot damage multiplier
+//3) Remove Creature damage multiplier (make independent from original config)
+//Bug with config reload (creatures do not update their damage on reload) is not bot-related but still annoying
+void bot_ai::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    ApplyClassDamageMultiplierMelee(damage, damageinfo);
+    damage = int32(float(damage)*dmgmult_melee/dmgmod_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    ApplyClassDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(float(damage)*dmgmult_melee/dmgmod_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(float(damage)*dmgmult_spell/dmgmod_spell);
+}
+//////////
+//GOSSIP//
+//////////
+//Implemented: Mage,.. and nothing more...
+bool bot_minion_ai::OnGossipHello(Player* player, Creature* creature)
+{
+    switch (creature->GetBotClass())
+    {
+        case CLASS_MAGE:
+            if (creature->IsInCombat())
+            {
+                player->CLOSE_GOSSIP_MENU();
+                break;
+            }
+            player->ADD_GOSSIP_ITEM(0, "I need food", 6001, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(0, "I need drink", 6001, GOSSIP_ACTION_INFO_DEF + 2);
+            player->PlayerTalkClass->SendGossipMenu(GOSSIP_SERVE_MASTER, creature->GetGUID());
+            break;
+        default:
+            player->CLOSE_GOSSIP_MENU();
+            break;
+    }
+    return true;
+}
+//GossipSelect
+//Mage: rations implemented
+bool bot_minion_ai::OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+{
+    if (!IsInBotParty(player))
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->MonsterWhisper("Get away from me!", player->GetGUID());
+        return false;
+    }
+    switch (creature->GetBotClass())
+    {
+        case CLASS_MAGE:
+            switch (sender)
+            {
+                case 6001:// food/drink
+                {
+                    //Prevent high-leveled consumables for low-level characters
+                    Unit* checker;
+                    if (player->getLevel() < creature->getLevel())
+                        checker = player;
+                    else
+                        checker = creature;
+
+                    // Conjure Refreshment rank 1
+                    uint32 food = InitSpell(checker, 42955);
+                    bool iswater = (action == GOSSIP_ACTION_INFO_DEF + 2);
+                    if (!food)
+                    {
+                        if (!iswater)// Conjure Food rank 1
+                            food = InitSpell(checker, 587);
+                        else// Conjure Water rank 1
+                            food = InitSpell(checker, 5504);
+                    }
+                    if (!food)
+                    {
+                        std::string errorstr = "I can't conjure ";
+                        errorstr += iswater ? "water" : "food";
+                        errorstr += " yet";
+                        creature->MonsterWhisper(errorstr.c_str(), player->GetGUID());
+                        //player->PlayerTalkClass->ClearMenus();
+                        //return OnGossipHello(player, creature);
+                        player->CLOSE_GOSSIP_MENU();
+                        return false;
+                    }
+                    player->CLOSE_GOSSIP_MENU();
+                    SpellInfo const* Info = sSpellMgr->GetSpellInfo(food);
+                    Spell* foodspell = new Spell(creature, Info, TRIGGERED_NONE, player->GetGUID());
+                    SpellCastTargets targets;
+                    targets.SetUnitTarget(player);
+                    //TODO implement checkcast for bots
+                    SpellCastResult result = creature->IsMounted() || CCed(creature) ? SPELL_FAILED_CUSTOM_ERROR : foodspell->CheckPetCast(player);
+                    if (result != SPELL_CAST_OK)
+                    {
+                        foodspell->finish(false);
+                        delete foodspell;
+                        creature->MonsterWhisper("I can't do it right now", player->GetGUID());
+                        creature->SendPetCastFail(food, result);
+                    }
+                    else
+                    {
+                        aftercastTargetGuid = player->GetGUID();
+                        foodspell->prepare(&targets);
+                        creature->MonsterWhisper("Here you go...", player->GetGUID());
+                    }
+                    break;
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    return true;
+}
+//Summons pet for bot
+void bot_minion_ai::SummonBotsPet(uint32 entry)
+{
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet)
+        me->SetBotsPetDied();
+
+    uint8 mylevel = std::min<uint8>(master->getLevel(), 80);
+    uint32 originalentry = bot_pet_ai::GetPetOriginalEntry(entry);
+    if (!originalentry)
+    {
+        //annoy master
+        me->MonsterWhisper("Why am I trying to summon unknown pet!?", master->GetGUID());
+        return;
+    }
+    uint32 armor = 0;
+    float x(0),y(0),z(0);
+    me->GetClosePoint(x, y, z, me->GetObjectSize());
+    m_botsPet = me->SummonCreature(entry, x, y, z, 0, TEMPSUMMON_DEAD_DESPAWN);
+
+    if (!m_botsPet)
+    {
+        me->MonsterWhisper("Failed to summon pet!", master->GetGUID());
+        return;
+    }
+
+    //std::string name = sObjectMgr->GeneratePetName(originalentry);//voidwalker
+    //if (!name.empty())
+    //    m_botsPet->SetName(name);
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS);
+    stmt->setUInt32(0, originalentry);
+    stmt->setUInt8(1, mylevel);
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    //QueryResult result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi, sta, inte, spi FROM `pet_levelstats` WHERE `creature_entry` = '%u' AND `level` = '%u'", originalentry, mylevel);
+
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        uint32 hp = fields[0].GetUInt16();
+        uint32 mana = fields[1].GetUInt16();
+        armor = fields[2].GetUInt32();
+        uint32 str = fields[3].GetUInt16();
+        uint32 agi = fields[4].GetUInt16();
+        uint32 sta = fields[5].GetUInt16();
+        uint32 inte = fields[6].GetUInt16();
+        uint32 spi = fields[7].GetUInt16();
+
+        m_botsPet->SetCreateHealth(hp);
+        m_botsPet->SetMaxHealth(hp);
+        m_botsPet->SetCreateMana(mana);
+        m_botsPet->SetMaxPower(POWER_MANA, mana);
+
+        m_botsPet->SetCreateStat(STAT_STRENGTH, str);
+        m_botsPet->SetCreateStat(STAT_AGILITY, agi);
+        m_botsPet->SetCreateStat(STAT_STAMINA, sta);
+        m_botsPet->SetCreateStat(STAT_INTELLECT, inte);
+        m_botsPet->SetCreateStat(STAT_SPIRIT, spi);
+    }
+
+    m_botsPet->SetBotOwner(master);
+    m_botsPet->SetCreatureOwner(me);
+    m_botsPet->SetBotClass(bot_pet_ai::GetPetClass(m_botsPet));
+    master->SetMinion((Minion*)m_botsPet, true);
+    m_botsPet->SetUInt64Value(UNIT_FIELD_CREATEDBY, me->GetGUID());
+    m_botsPet->DeleteThreatList();
+    m_botsPet->AddUnitTypeMask(UNIT_MASK_MINION);
+    //m_botsPet->SetLevel(master->getLevel());
+    m_botsPet->AIM_Initialize();
+    m_botsPet->InitBotAI(true);
+    m_botsPet->setFaction(master->getFaction());
+    //bot_pet_ai* petai = m_botsPet->GetBotPetAI();
+    //petai->SetCreatureOwner(me);
+    //petai->SetBaseArmor(armor);
+    //petai->setStats(mylevel, bot_pet_ai::GetPetType(m_botsPet), true);
+    m_botsPet->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    me->SetBotsPet(m_botsPet);
+
+    m_botsPet->SendUpdateToPlayer(master);
+}
+
+uint16 bot_ai::Rand() const
+{
+    return urand(0, 100 + (master->GetNpcBotsCount() - 1) * 10);
+}
+//Used for outside checks for druid
+uint8 bot_minion_ai::GetBotClassForCreature(Creature* bot)
+{
+    uint8 botClass = bot->GetBotClass();
+    switch (botClass)
+    {
+        case CAT: case BEAR:
+            return CLASS_DRUID;
+        default:
+            return botClass;
+    }
+}
+//Returns pet type (maybe unneeded)
+uint8 bot_pet_ai::GetPetType(Creature* pet)
+{
+    switch (pet->GetEntry())
+    {
+        case PET_VOIDWALKER:
+            return PET_TYPE_VOIDWALKER;
+    }
+    return PET_TYPE_NONE;
+}
+//Returns pet's class
+uint8 bot_pet_ai::GetPetClass(Creature* pet)
+{
+    switch (GetPetType(pet))
+    {
+        case PET_TYPE_IMP:
+            return CLASS_MAGE;
+        default:
+            return CLASS_PALADIN;
+    }
+}
+//Return entry used to summon real pets
+uint32 bot_pet_ai::GetPetOriginalEntry(uint32 entry)
+{
+    switch (entry)
+    {
+        case PET_VOIDWALKER:
+            return ORIGINAL_ENTRY_VOIDWALKER;
+        default:
+            return 0;
+    }
+}
+//PvP trinket for minions
+void bot_minion_ai::BreakCC(uint32 diff)
+{
+    if (pvpTrinket_cd <= diff && CCed(me, true) && (me->GetVictim() || !me->getAttackers().empty()))
+    {
+        temptimer = GC_Timer;
+        if (doCast(me, PVPTRINKET))
+        {
+            pvpTrinket_cd = PVPTRINKET_CD;
+            GC_Timer = temptimer;
+            return;
+        }
+    }
+}
+//Returns attack range based on given range
+//If mounted: 20%
+//If ranged: 125%
+//If master is dead: max range
+float bot_ai::InitAttackRange(float origRange, bool ranged) const
+{
+    if (me->IsMounted())
+        origRange *= 0.2f;
+    else
+    {
+        if (ranged)
+            origRange *= 1.25f;
+        if (master->isDead())
+            origRange += sWorld->GetMaxVisibleDistanceOnContinents();
+    }
+    return origRange;
+}
+//Force bots to start attack anyone who tries to DAMAGE me or master
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_minion_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (me->GetVictim())
+        return;
+    if (InDuel(attacker))
+        return;
+    bool byspell = false, ranged = false;
+    switch (GetBotClassForCreature(me))
+    {
+        case CLASS_DRUID:
+            byspell = me->GetShapeshiftForm() == FORM_NONE || 
+                me->GetShapeshiftForm() == FORM_TREE || 
+                me->GetShapeshiftForm() == FORM_MOONKIN;
+            ranged = byspell;
+            break;
+        case CLASS_PRIEST:
+        case CLASS_MAGE:
+        case CLASS_WARLOCK:
+        case CLASS_SHAMAN:
+            byspell = true;
+            ranged = true;
+            break;
+        case CLASS_HUNTER:
+            ranged = true;
+            break;
+        default:
+            break;
+    }
+    float maxdist = InitAttackRange(float(master->GetBotFollowDist()), ranged);//use increased range
+    if (!attacker->IsWithinDist(me, maxdist))
+        return;
+    if (!CanBotAttack(attacker, byspell))
+        return;
+
+    m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
+    me->Attack(attacker, !ranged);
+}
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
new file mode 100644
index 0000000..bcd0c73
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.h
@@ -0,0 +1,359 @@
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#include "ScriptedCreature.h"
+
+enum CommonValues
+{
+//COMMON SPELLS
+    MANAPOTION                          = 32453,//"???" forgot 0_o
+    HEALINGPOTION                       = 15504,//"Drinks Holy Elixir to heal the caster"
+    DRINK                               = 66041,//"Restores 4% mana per sec for 30 sec"
+    EAT                                 = 66478,//"Restores Health"
+    PVPTRINKET                          = 42292,//PvP Trinket no CD
+//COMMON CDs
+    POTION_CD                           = 60000,//default 60sec potion cd
+    PVPTRINKET_CD                       = 120000,//default 2 min pvp trinket cd
+//COMMON PASSIVES
+  //1) "Increase(d) @whatever"
+    //SPELL_BONUS_10                      = 33021,//10spp
+    SPELL_BONUS_50                      = 45011,//50spp
+    SPELL_BONUS_150                     = 28141,//150spp
+    SPELL_BONUS_250                     = 69709,//250spp
+    FIREDAM_86                          = 33816,//86 fire spp
+    MANAREGEN45                         = 35867,//45 mp5
+    MANAREGEN100                        = 45216,//100 mp5
+  //2) Talents
+    HASTE    /*Gift of the EarthMother*/= 51183,//rank 5 10% spell haste
+    HASTE2   /*Blood Frenzy - warrior*/ = 29859,//rank2 10% haste, bonus for rend (warriors only)//13789//rank 3 10% haste 6% dodge
+    CRITS    /*Thundering Strikes-sham*/= 16305,//rank 5 5% crit
+    HOLYCRIT /*Holy Spec - priest*/     = 15011,//rank 5 5% holy crit
+    DODGE    /*Anticipation - paladin*/ = 20100,//rank 5 5% dodge
+    PARRY    /*Deflection - warrior*/   = 16466,//rank 5 5% parry
+    PRECISION /*Precision - warrior*/   = 29592,//rank 3 3% melee hit
+    PRECISION2/*Precision - mage*/      = 29440,//rank 3 3% spell hit
+    DMG_TAKEN/*Deadened Nerves - rogue*/= 31383,//rank 3 (-6%)
+  //3) Pet/Special
+    THREAT   /*Tank Class Passive*/     = 57339,//+43% threat
+    BOR      /*Blood of Rhino - pet*/   = 53482,//rank 2 +40% healing taken
+    RCP      /*Rogue Class Passive*/    = 21184,//-27% threat caused
+    DEFENSIVE_STANCE_PASSIVE            = 7376, //+threat/damage reduction
+//COMMON GOSSIPS
+    GOSSIP_SERVE_MASTER                 = 2279  //"I live only to serve the master."
+};
+
+//TODO: slow fall / water walking for master
+//enum HoverSpells
+//{
+//    LEVITATE                            = 1706,
+//    SLOW_FALL                           = 130,
+//    //WATER_WALKING                       = 546,
+//};
+
+enum DruidStances//bot's temp set class
+{
+    BEAR        = 15,
+    CAT         = 25,
+    //TRAVEL      = 35,                   //NUY
+    //FLY         = 45,                   //NUY
+};
+
+enum BotPetTypes
+{
+    PET_TYPE_NONE,
+//Warlock
+    PET_TYPE_IMP,
+    PET_TYPE_VOIDWALKER,
+    PET_TYPE_SUCCUBUS,
+    PET_TYPE_FELHUNTER,
+    PET_TYPE_FELGUARD,
+//Mage
+    PET_TYPE_WATER_ELEMENTAL,
+//Shaman
+    //PET_TYPE_GHOSTLY_WOLF,
+    PET_TYPE_FIRE_ELEMENTAL,
+    PET_TYPE_EARTH_ELEMENTAL,
+//Hunter
+    PET_TYPE_VULTURE,
+
+    MAX_PET_TYPES
+};
+
+enum WarlockBotPets
+{
+    //PET_IMP                     = ,
+    PET_VOIDWALKER              = 60237,
+    //PET_SUCCUBUS                = 
+};
+
+enum HunterBotPets
+{
+    PET_VULTURE                 = 60238
+};
+
+enum BotPetsOriginalEntries
+{
+    ORIGINAL_ENTRY_VOIDWALKER   = 1860
+};
+
+class bot_ai : public ScriptedAI
+{
+    public:
+        virtual ~bot_ai();
+        bot_ai(Creature* creature);
+        //Player* GetMaster() const { return master; }
+        virtual bool IsMinionAI() const = 0;
+        virtual bool IsPetAI() const = 0;
+        virtual void SetBotCommandState(CommandStates /*st*/, bool /*force*/ = false, Position* /*newpos*/ = NULL) = 0;
+        virtual const bot_minion_ai* GetMinionAI() const { return NULL; }
+        virtual const bot_pet_ai* GetPetAI() const { return NULL; }
+        bool IsInBotParty(Unit* unit) const;
+        bool CanBotAttack(Unit* target, int8 byspell = 0) const;
+        bool InDuel(Unit* target) const;
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        inline void SendPartyEvadeAbort() const;
+        inline void SetShouldUpdateStats() { shouldUpdateStats = true; }
+        inline void UpdateHealth() { doHealth = true; }
+        inline void UpdateMana() { doMana = true; }
+        inline void SetBotTank(Unit* newtank) { tank = newtank; m_TankGuid = newtank ? newtank->GetGUID() : 0; }
+        static Unit* GetBotGroupMainTank(Group* group) { return _GetBotGroupMainTank(group); }
+        inline float GetManaRegen() const { return regen_mp5; }
+        inline float GetHitRating() const { return hit; }
+        inline uint64 GetBotTankGuid() const { return m_TankGuid; }
+        inline int32 GetSpellPower() const { return m_spellpower; }
+        inline uint8 GetHaste() const { return haste; }
+
+        virtual void OnBotSummon(Creature* /*summon*/) {}
+        virtual void UnsummonAll() {}
+
+        void ReceiveEmote(Player* player, uint32 emote);
+        void ApplyPassives(uint8 botOrPetType) const;
+
+        static inline bool CCed(Unit* target, bool root = false)
+        {
+            return target ? target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && target->HasUnitState(UNIT_STATE_ROOT)) : true;
+        }
+    protected:
+        static uint32 InitSpell(Unit* caster, uint32 spell);
+
+        bool HasAuraName(Unit* unit, const std::string spell, uint64 casterGuid = 0, bool exclude = false) const;
+        bool HasAuraName(Unit* unit, uint32 spellId, uint64 casterGuid = 0, bool exclude = false) const;
+        bool RefreshAura(uint32 spell, int8 count = 1, Unit* target = NULL) const;
+        bool CheckAttackTarget(uint8 botOrPetType);
+        bool MoveBehind(Unit &target) const;
+        bool CheckImmunities(uint32 spell, Unit* target = NULL) const { return (spell && target && !target->ToCorpse() && target->IsHostileTo(me) ? !target->IsImmunedToDamage(sSpellMgr->GetSpellInfo(spell)) : true); }
+
+        //everything cast-related
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false, uint64 originalCaster = 0);
+        SpellCastResult checkBotCast(Unit* victim, uint32 spellId, uint8 botclass) const;
+        virtual void removeFeralForm(bool /*force*/ = false, bool /*init*/ = true, uint32 /*diff*/ = 0) {}
+
+        inline bool Feasting() const { return (me->HasAura(EAT) || me->HasAura(DRINK)); }
+        static inline bool isMeleeClass(uint8 m_class) { return (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT || m_class == BEAR); }
+        inline bool IsChanneling(Unit* u = NULL) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        inline bool IsCasting(Unit* u = NULL) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCasted(false)); }
+
+        void GetInPosition(bool force = false, bool ranged = true, Unit* newtarget = NULL, Position* pos = NULL);
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+        void FindTank();
+        void listAuras(Player* player, Unit* unit) const;
+        void CalculateAttackPos(Unit* target, Position &pos) const;
+
+        virtual void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+        virtual void ApplyClassDamageMultiplierMelee(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
+        virtual void CheckAuras(bool /*force*/ = false) {}
+        virtual void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        virtual void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual void DoNonCombatActions(uint32 const /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        virtual void InitSpells() {}
+        virtual void _OnHealthUpdate(uint8 /*myclass*/, uint8 /*mylevel*/) const = 0;
+        virtual void _OnManaUpdate(uint8 /*myclass*/, uint8 /*mylevel*/) const = 0;
+        //virtual void _OnMeleeDamageUpdate(uint8 /*myclass*/) const = 0;
+
+        //virtual void ReceiveEmote(Player* /*player*/, uint32 /*emote*/) {}
+        //virtual void CommonTimers(uint32 diff) = 0;
+
+        virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        virtual bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
+
+        uint8 GetWait();
+        inline float InitAttackRange(float origRange, bool ranged) const;
+        uint16 Rand() const;
+        static inline uint32 GetLostHP(Unit* unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        static inline uint8 GetHealthPCT(Unit* hTarget) { if (!hTarget || hTarget->isDead()) return 100; return (hTarget->GetHealth()*100/hTarget->GetMaxHealth()); }
+        static inline uint8 GetManaPCT(Unit* hTarget) { if (!hTarget || hTarget->isDead() || hTarget->getPowerType() != POWER_MANA) return 100; return (hTarget->GetPower(POWER_MANA)*100/hTarget->GetMaxPower(POWER_MANA)); }
+
+        Unit* getTarget(bool byspell, bool ranged, bool &reset) const;
+
+        CommandStates GetBotCommandState() const { return m_botCommandState; }
+
+        typedef std::set<Unit*> AttackerSet;
+
+        Player* master;
+        Unit* opponent;
+        Unit* tank;
+        CommandStates m_botCommandState;
+        SpellInfo const* info;
+        Position pos, attackpos;
+        float stat, atpower, maxdist, regen_mp5, hit,
+            ap_mod, spp_mod, crit_mod;
+        uint64 aftercastTargetGuid;
+        int32 cost, value, sppower, m_spellpower;
+        uint32 GC_Timer, temptimer, checkAurasTimer, wait, currentSpell;
+        uint8 clear_cd, haste, healTargetIconFlags;
+        bool doHealth, doMana, shouldUpdateStats;
+
+    private:
+        static Unit* _GetBotGroupMainTank(Group* group);
+        static inline float _getAttackDistance(float distance) { return distance > 0.f ? distance*0.72 : 0.f; }
+        Unit* extank;
+        float dmgmult_melee, dmgmult_spell;
+        float dmgmod_melee, dmgmod_spell;
+        uint64 m_TankGuid;
+};
+
+class bot_minion_ai : public bot_ai
+{
+    public:
+        virtual ~bot_minion_ai();
+        bot_minion_ai(Creature* creature);
+        const bot_minion_ai* GetMinionAI() const { return this; }
+        bool IsMinionAI() const { return true; }
+        bool IsPetAI() const { return false; }
+        void SummonBotsPet(uint32 entry);
+        inline bool IAmDead() const { return (!master || me->isDead()); }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 const /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 const /*diff*/) { return false; }
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        void CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff);
+        bool CureTarget(Unit* target, uint32 cureSpell, uint32 diff);
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 const /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void setStats(uint8 myclass, uint8 myrace, uint8 mylevel, bool force = false);
+
+        static bool OnGossipHello(Player* player, Creature* creature);
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
+
+        void InitSpells() {}
+        void _OnHealthUpdate(uint8 myclass, uint8 mylevel) const;
+        void _OnManaUpdate(uint8 myclass, uint8 mylevel) const;
+        void _OnMeleeDamageUpdate(uint8 myclass) const;
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        inline void SetEvadeTimer(uint8 time) { evade_cd = time; }
+
+        static inline uint8 GetBotClassForCreature(Creature* bot);
+
+    protected:
+        void BuffAndHealGroup(Player* gPlayer, uint32 diff);
+        void RezGroup(uint32 REZZ, Player* gPlayer);
+
+        void Follow(bool force = false, Position* newpos = NULL)
+        {
+            if (force || 
+                (me->IsAlive() && (!me->IsInCombat() || !opponent) && m_botCommandState != COMMAND_STAY))
+                SetBotCommandState(COMMAND_FOLLOW, force, newpos);
+        }
+
+        inline void Evade() { _OnEvade(); }
+
+        virtual void BreakCC(uint32 diff);
+
+        void CommonTimers(uint32 diff)
+        {
+            if (pvpTrinket_cd > diff)       pvpTrinket_cd -= diff;
+            if (Potion_cd > diff)           Potion_cd -= diff;
+            if (GC_Timer > diff)            GC_Timer -= diff;
+            if (temptimer > diff)           temptimer -= diff;
+            if (checkAurasTimer != 0)       --checkAurasTimer;
+            if (wait != 0)                  --wait;
+            if (evade_cd != 0)              --evade_cd;
+        }
+
+        Unit* FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
+        Unit* FindAffectedTarget(uint32 spellId, uint64 caster = 0, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
+        Unit* FindPolyTarget(float dist = 30, Unit* currTarget = NULL) const;
+        Unit* FindFearTarget(float dist = 30) const;
+        Unit* FindRepentanceTarget(float dist = 20) const;
+        Unit* FindUndeadCCTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindRootTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindCastingTarget(float dist = 10, bool isFriend = false, uint32 spellId = 0) const;
+        Unit* FindAOETarget(float dist = 30, bool checkbots = false, bool targetfriend = true) const;
+        Unit* FindSplashTarget(float dist = 5, Unit* To = NULL) const;
+
+        uint32 Potion_cd, pvpTrinket_cd;
+
+    private:
+        bool CanCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const;
+        void GetBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const;
+        void CalculatePos(Position& pos);
+        void UpdateMountedState();
+        void UpdateStandState() const;
+        void UpdateRations() const;
+        void _OnEvade();
+        PlayerClassLevelInfo* classinfo;
+        float myangle, armor_mod, haste_mod, dodge_mod, parry_mod;
+        uint8 rezz_cd, evade_cd;
+};
+
+class bot_pet_ai : public bot_ai
+{
+    public:
+        virtual ~bot_pet_ai();
+        bot_pet_ai(Creature* creature);
+        const bot_pet_ai* GetPetAI() const { return this; }
+        Creature* GetCreatureOwner() const { return m_creatureOwner; }
+        bool IsMinionAI() const { return false; }
+        bool IsPetAI() const { return true; }
+        inline bool IAmDead() const { return (!master || !m_creatureOwner || me->isDead()); }
+        //void SetCreatureOwner(Creature* newowner) { m_creatureOwner = newowner; }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 const /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 const /*diff*/) { return false; }
+        //void BuffAndHealGroup(Player* /*gPlayer*/, uint32 const /*diff*/) {}
+        //void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        //void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 const /*diff*/) {}
+        //bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 const /*diff*/) { return false; }
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 const /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void setStats(uint8 mylevel, uint8 petType, bool force = false);
+
+        static uint8 GetPetType(Creature* pet);
+        static uint8 GetPetClass(Creature* pet);
+        static uint32 GetPetOriginalEntry(uint32 entry);
+
+        //debug
+        //virtual void ListSpells(ChatHandler* /*handler*/) const {}
+
+        void InitSpells() {}
+        void _OnHealthUpdate(uint8 petType, uint8 mylevel) const;
+        void _OnManaUpdate(uint8 petType, uint8 mylevel) const;
+        //void _OnMeleeDamageUpdate(uint8 /*myclass*/) const {}
+        void SetBaseArmor(uint32 armor) { basearmor = armor; }
+
+    protected:
+        void CommonTimers(uint32 diff)
+        {
+            if (GC_Timer > diff)            GC_Timer -= diff;
+            if (temptimer > diff)           temptimer -= diff;
+            if (checkAurasTimer != 0)       --checkAurasTimer;
+            if (wait != 0)                  --wait;
+        }
+
+        Creature* m_creatureOwner;
+    private:
+        uint32 basearmor;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
new file mode 100644
index 0000000..36a9bc8
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
@@ -0,0 +1,1092 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Druid NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Maybe 30%
+TODO: Feral Spells (from scratch), More Forms, Balance Spells + treants...
+*/
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new bot_druid_ai(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct bot_druid_ai : public bot_minion_ai
+    {
+        bot_druid_ai(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_DRUID) != SPELL_CAST_OK)
+                return false;
+
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (swiftness && info->CalcCastTime() > 0)
+            {
+                DoCast(victim, spellId, true);
+                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                me->RemoveAurasDueToSpell(CRIT_50, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                swiftness = false;
+                return true;
+            }
+            if (spellId == BEAR_FORM || spellId == CAT_FORM)
+            {
+                me->ModifyPower(POWER_MANA, - int32(info->CalcPowerCost(me, info->GetSchoolMask())));
+                mana = me->GetPower(POWER_MANA);
+                if (Unit* u = me->GetVictim())
+                    GetInPosition(true, false, u);
+            }
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result && 
+                //spellId != BEAR_FORM && spellId != CAT_FORM && 
+                spellId != MANAPOTION && spellId != WARSTOMP && 
+                me->HasAura(OMEN_OF_CLARITY_BUFF))
+            {
+                cost = info->CalcPowerCost(me, info->GetSchoolMask());
+                clearcast = true;
+                power = me->getPowerType();
+            }
+            return result;
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { removeFeralForm(true, false); master->SetNpcBotDied(me->GetGUID()); }
+
+        void warstomp(uint32 diff)
+        {
+            if (me->getRace() != RACE_TAUREN) return;
+            if (Warstomp_Timer > diff) return;
+            if (me->GetShapeshiftForm() != FORM_NONE)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+            {
+                Unit* u = me->SelectNearestTarget(5);
+                if (u && u->IsInCombat() && u->isTargetableForAttack())
+                {
+                    if (doCast(me, WARSTOMP))
+                    {
+                        Warstomp_Timer = 30000; //30sec
+                        return;
+                    }
+                }
+            }
+            for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if (!(*iter)->isTargetableForAttack()) continue;
+                if (me->GetDistance((*iter)) <= 5)
+                {
+                    if (doCast(me, WARSTOMP))
+                        Warstomp_Timer = 30000; //30sec
+                }
+            }
+        }
+
+        bool DamagePossible()
+        {
+            return true;
+            //return (GetManaPCT(me) < 30 || GetHealthPCT(master) < 50);
+            /*if (GetHealthPCT(master) < 75 || GetHealthPCT(me) < 75) return false;
+
+            if (Group* pGroup = master->GetGroup())
+            {
+                uint8 LHPcount = 0;
+                uint8 DIScount = 0;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
+                        ++LHPcount;
+                    Unit::AuraApplicationMap const& auras = tPlayer->GetAppliedAuras();
+                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                        if (itr->second->GetBase()->GetSpellInfo()->Dispel == DISPEL_POISON)
+                            ++DIScount;
+                }
+                uint8 members = master->GetGroup()->GetMembersCount();
+
+                if (members > 10)
+                {
+                    if (LHPcount > 1 || DIScount > 2) return false;
+                }
+                if (members > 4)
+                {
+                    if (LHPcount > 0 || DIScount > 1) return false;
+                }
+                if (members < 5)
+                {
+                    if (LHPcount > 0 || DIScount > 0) return false;
+                }
+            }//endif unitlist
+
+            Unit* u = master->GetVictim();
+            if (master->getAttackers().size() > 4 || 
+              (!master->getAttackers().empty() && 
+                u != NULL && u->GetHealth() > me->GetMaxHealth()*17))
+                return false;
+
+            return true;*/
+        }
+
+        void removeFeralForm(bool force = false, bool init = true, uint32 diff = 0)
+        {
+            if (!force && formtimer > diff) return;
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                case FORM_DIREBEAR:
+                case FORM_BEAR:
+                    me->RemoveAurasDueToSpell(BEAR_FORM);
+                    break;
+                case FORM_CAT:
+                    me->RemoveAurasDueToSpell(CAT_FORM);
+                    me->RemoveAurasDueToSpell(ENERGIZE);
+                    break;
+                default:
+                    break;
+                }
+                SetStats(CLASS_DRUID, init);
+            }
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u); 
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, me->GetShapeshiftForm() == FORM_NONE);
+        }
+
+        void doBearActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_RAGE) return;
+
+            if (GetHealthPCT(me) < 75)
+                HealTarget(me, GetHealthPCT(me), diff);
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (MangleB_Timer <= diff && rage >= 200 && doCast(opponent, MANGLE_BEAR))
+            {
+                MangleB_Timer = 6000 - me->getLevel()/4 * 100;
+                return;
+            }
+
+            if (GC_Timer <= diff && rage >= 200 && doCast(opponent, SWIPE))
+                return;
+
+        }//end doBearActions
+
+        void doCatActions(uint32 diff)
+        {
+            if (GetHealthPCT(me) < 75)
+                HealTarget(me, GetHealthPCT(me), diff);
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+            uint32 energy = me->GetPower(POWER_ENERGY);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+            //{ wait = 5; return; }
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (Mangle_Cat_Timer <= diff && energy > 45 && doCast(opponent, MANGLE_CAT))
+                Mangle_Cat_Timer = 6000;
+            if (Rake_Timer <= diff && energy > 40 && doCast(opponent, RAKE))
+                Rake_Timer = 10000;
+            if (Shred_Timer <= diff && energy > 60 && !opponent->HasInArc(M_PI, me) && doCast(opponent, SHRED))
+                Shred_Timer = 12000;
+            if (Rip_Timer <= diff && energy > 30 && doCast(opponent, RIP))
+                Rip_Timer = 15000;
+            if (Claw_Timer <= diff && energy > 45 && doCast(opponent, CLAW))
+                Claw_Timer = GC_Timer;
+        }//end doCatActions
+
+        void doBalanceActions(uint32 diff)
+        {
+            removeFeralForm(true, true);
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //range check (melee) to prevent fake casts
+            if (me->GetExactDist(opponent) > 30 || !DamagePossible()) return;
+
+            if (HURRICANE && Hurricane_Timer <= diff && GC_Timer <= diff && Rand() > 35 && !IsCasting())
+            {
+                Unit* target = FindAOETarget(30, true);
+                if (target && doCast(target, HURRICANE))
+                {
+                    Hurricane_Timer = 5000;
+                    return;
+                }
+                Hurricane_Timer = 2000;//fail
+            }
+            if (GC_Timer <= diff && !opponent->HasAura(FAIRIE_FIRE))
+                if (doCast(opponent, FAIRIE_FIRE))
+                    return;
+            if (Rand() > 30 && Moonfire_Timer <= diff && GC_Timer <= diff && 
+                !opponent->HasAura(MOONFIRE, me->GetGUID()))
+                if (doCast(opponent, MOONFIRE))
+                {
+                    Moonfire_Timer = 5000;
+                    return;
+                }
+            if (Rand() > 30 && Starfire_Timer <= diff && GC_Timer <= diff && 
+                doCast(opponent, STARFIRE))
+            {
+                Starfire_Timer = 11000;
+                return;
+            }
+            if (Rand() > 50 && Wrath_Timer <= diff && GC_Timer <= diff && 
+                doCast(opponent, WRATH))
+            {
+                Wrath_Timer = uint32(sSpellMgr->GetSpellInfo(WRATH)->CalcCastTime()/100 * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 1);
+                return;
+            }
+        }
+
+        bool MassGroupHeal(Player* gPlayer, uint32 diff)
+        {
+            if (!gPlayer || GC_Timer > diff) return false;
+            if (!TRANQUILITY && !WILD_GROWTH) return false;
+            if (Tranquility_Timer > diff && Wild_Growth_Timer > diff) return false;
+            if (Rand() > 30) return false;
+            if (IsCasting()) return false; // if I'm already casting
+            Group* pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            uint8 LHPcount = 0;
+            uint8 pct = 100;
+            Unit* healTarget = NULL;
+            for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 39) continue;
+                if (GetHealthPCT(tPlayer) < 80)
+                {
+                    if (GetHealthPCT(tPlayer) < pct)
+                    {
+                        pct = GetHealthPCT(tPlayer);
+                        healTarget = tPlayer;
+                    }
+                    ++LHPcount;
+                    if (LHPcount > 2) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && bot->IsInWorld() && bot->GetExactDist(me) < 40 && GetHealthPCT(bot) < 80)
+                        {
+                            if (GetHealthPCT(bot) < pct)
+                            {
+                                pct = GetHealthPCT(bot);
+                                healTarget = bot;
+                            }
+                            ++LHPcount;
+                            if (LHPcount > 2) break;
+                        }
+                    }
+                }
+            }
+            if (LHPcount > 2 && TRANQUILITY && Tranquility_Timer <= diff && 
+                doCast(me, TRANQUILITY))
+                { Tranquility_Timer = 45000; return true; }
+            if (LHPcount > 0 && WILD_GROWTH && Wild_Growth_Timer <= diff && 
+                doCast(healTarget, WILD_GROWTH))
+                { Wild_Growth_Timer = 6000; return true; }
+            return false;
+        }//end MassGroupHeal
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if ((me->GetShapeshiftForm() == FORM_DIREBEAR || me->GetShapeshiftForm() == FORM_BEAR) && 
+                me->getPowerType() != POWER_RAGE)
+                me->setPowerType(POWER_RAGE);
+            if (me->GetShapeshiftForm() == FORM_CAT && me->getPowerType() != POWER_ENERGY)
+                me->setPowerType(POWER_ENERGY);
+            if (me->GetShapeshiftForm() == FORM_NONE && me->getPowerType() != POWER_MANA)
+                me->setPowerType(POWER_MANA);
+            if (IAmDead()) return;
+            if (!me->GetVictim())
+                Evade();
+            else if (me->GetShapeshiftForm() == FORM_DIREBEAR ||
+                me->GetShapeshiftForm() == FORM_BEAR ||
+                me->GetShapeshiftForm() == FORM_CAT)
+                DoMeleeAttackIfReady();
+
+            if (me->GetShapeshiftForm() == FORM_DIREBEAR || me->GetShapeshiftForm() == FORM_BEAR)
+            {
+                rage = me->GetPower(POWER_RAGE);
+                if (ragetimer2 <= diff)
+                {
+                    if (me->IsInCombat() && me->getLevel() >= 30)
+                    {
+                        if (rage < 990 && rage >= 0)
+                            me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
+                        else
+                            me->SetPower(POWER_RAGE, 1000);//max
+                    }
+                    ragetimer2 = 2000;
+                }
+                if (ragetimer <= diff)
+                {
+                    if (!me->IsInCombat())
+                    {
+                        if (rage > 10.f*rageLossMult)
+                            me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult));//-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0);//min
+                    }
+                    ragetimer = 1500;
+                    if (rage > 1000) me->SetPower(POWER_RAGE, 1000);
+                    if (rage < 10) me->SetPower(POWER_RAGE, 0);
+                }
+            }
+            if (clearcast && me->HasAura(OMEN_OF_CLARITY_BUFF) && !me->IsNonMeleeSpellCasted(false))
+            {
+                me->ModifyPower(POWER_MANA, cost);
+                me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            BreakCC(diff);
+            if (CCed(me)) return;
+            warstomp(diff);
+
+            if (me->getPowerType() == POWER_MANA && GetManaPCT(me) < 20 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+
+            //Heal master
+            if (GetHealthPCT(master) < 85)
+                HealTarget(master, GetHealthPCT(master), diff);
+            //Innervate
+            if (INNERVATE && Innervate_Timer <= diff && GC_Timer <= diff)
+            {
+                doInnervate();
+                if (Innervate_Timer <= diff)//if failed or not found target
+                    Innervate_Timer = 3000;//set delay
+            }
+
+            MassGroupHeal(master, diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                CheckBattleRez(diff);
+            BuffAndHealGroup(master, diff);
+            CureTarget(master, CURE_POISON, diff);
+            CureGroup(master, CURE_POISON, diff);
+
+            if (!CheckAttackTarget(CLASS_DRUID))
+                return;
+
+            //debug
+            opponent = me->GetVictim();
+
+            if (GetHealthPCT(me) < 75)
+            {
+                HealTarget(me, GetHealthPCT(me), diff);
+                return;
+            }
+
+            if (IsCasting()) return;//Casting heal or something
+            CheckRoots(diff);
+
+            if (DamagePossible() && opponent != NULL)
+            {
+                Unit* u = opponent->GetVictim();
+                //if the target is attacking us, we want to go bear
+                if (BEAR_FORM && !CCed(opponent) && 
+                    (u == me || (tank == me && IsInBotParty(u))) || 
+                    (!me->getAttackers().empty() && (*me->getAttackers().begin()) == opponent && opponent->GetMaxHealth() > me->GetMaxHealth()*2))
+                {
+                    //if we don't have bear yet
+                    if (me->GetShapeshiftForm() != FORM_DIREBEAR && 
+                        me->GetShapeshiftForm() != FORM_BEAR && 
+                        formtimer <= diff && 
+                        doCast(me, BEAR_FORM))
+                    {
+                        SetStats(BEAR);
+                        formtimer = 1500;
+                    }
+                    if (me->GetShapeshiftForm() == FORM_DIREBEAR || 
+                        me->GetShapeshiftForm() == FORM_BEAR)
+                        doBearActions(diff);
+                }
+                else
+                if (CAT_FORM && master->GetVictim() != opponent && tank && 
+                    u == tank && u != me && 
+                    opponent->GetMaxHealth() < tank->GetMaxHealth()*3)
+                {
+                    //if we don't have cat yet
+                    if (me->GetShapeshiftForm() != FORM_CAT && formtimer <= diff)
+                    {
+                        if (doCast(me, CAT_FORM))
+                        {
+                            SetStats(CAT);
+                            formtimer = 1500;
+                        }
+                    }
+                    if (me->GetShapeshiftForm() == FORM_CAT)
+                        doCatActions(diff);
+                }
+                else if (tank != me)
+                    doBalanceActions(diff);
+            }
+            else if (tank != me)
+                doBalanceActions(diff);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (hp > 95) return false;
+            if (!target || target->isDead()) return false;
+            if (tank == me && hp > 35) return false;
+            if (hp > 50 && me->GetShapeshiftForm() != FORM_NONE) return false;//do not waste heal if in feral or so
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid() - 50*me->GetShapeshiftForm()) return false;
+            if (me->GetExactDist(target) > 40) return false;
+
+            if ((hp < 15 || (hp < 35 && target->getAttackers().size() > 2)) && 
+                Nature_Swiftness_Timer <= diff && (target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (NATURES_SWIFTNESS && doCast(me, NATURES_SWIFTNESS) && RefreshAura(CRIT_50, 2))//need to be critical
+                {
+                    swiftness = true;
+                    if (doCast(target, HEALING_TOUCH, true))
+                    {
+                        Nature_Swiftness_Timer = 120000;//2 min
+                        Heal_Timer = 3000;
+                        return true;
+                    }
+                }
+            }
+            if (SWIFTMEND && (hp < 25 || GetLostHP(target) > 5000) && Swiftmend_Timer <= 3000 && 
+                (HasAuraName(target, REGROWTH) || HasAuraName(target, REJUVENATION)))
+            {
+                if (doCast(target, SWIFTMEND))
+                {
+                    Swiftmend_Timer = 10000;
+                    if (GetHealthPCT(target) > 75)
+                        return true;
+                    else if (!target->getAttackers().empty())
+                    {
+                        if (doCast(target, REGROWTH))
+                        {
+                            GC_Timer = 300;
+                            return true;
+                        }
+                    }
+                }
+            }
+            if (hp > 35 && (hp < 75 || GetLostHP(target) > 3000) && Heal_Timer <= diff && NOURISH)
+            {
+                switch (urand(1,3))
+                {
+                    case 1:
+                    case 2:
+                        if (doCast(target, NOURISH))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                    case 3:
+                        if (doCast(target, HEALING_TOUCH))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                }
+            }
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = tank == target && boss;
+            if (( (hp < 80 || GetLostHP(target) > 3500 || tanking) && 
+                Regrowth_Timer <= diff && GC_Timer <= diff && !target->HasAura(REGROWTH, me->GetGUID()) )
+                || 
+                (target->HasAura(REGROWTH, me->GetGUID()) && target->HasAura(REJUVENATION, me->GetGUID()) && 
+                (hp < 70 || GetLostHP(target) > 3000) && Regrowth_Timer <= diff && GC_Timer <= diff))
+            {
+                if (doCast(target, REGROWTH))
+                { Regrowth_Timer = 2000; return true; }
+            }
+            if (hp > 25 && (hp < 90 || GetLostHP(target) > 2000 || tanking) && GC_Timer <= diff && 
+                !HasAuraName(target, REJUVENATION, me->GetGUID()))
+            {
+                if (doCast(target, REJUVENATION))
+                {
+                    if (!target->getAttackers().empty() && (hp < 75 || GetLostHP(target) > 4000))
+                        if (SWIFTMEND && Swiftmend_Timer <= diff && doCast(target, SWIFTMEND))
+                            Swiftmend_Timer = 10000;
+                    GC_Timer = 500;
+                    return true;
+                }
+            }
+            if (LIFEBLOOM != 0 && GC_Timer <= diff && 
+                ((hp < 85 && hp > 40) || (hp > 70 && tanking) || 
+                (hp < 70 && hp > 25 && HasAuraName(target, REGROWTH) && HasAuraName(target, REJUVENATION)) || 
+                (GetLostHP(target) > 1500 && hp > 35)))
+            {
+                Aura* bloom = target->GetAura(LIFEBLOOM, me->GetGUID());
+                if ((!bloom || bloom->GetStackAmount() < 3) && doCast(target, LIFEBLOOM))
+                    return true;
+            }
+            if (hp > 30 && (hp < 70 || GetLostHP(target) > 3000) && Heal_Timer <= diff && 
+                doCast(target, HEALING_TOUCH))
+            {
+                Heal_Timer = 3000;
+                return true;
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 40) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (target && target->IsAlive() && me->GetExactDist(target) < 30)
+            {
+                if (!HasAuraName(target, MARK_OF_THE_WILD))
+                    if (doCast(target, MARK_OF_THE_WILD))
+                        return true;
+                if (!HasAuraName(target, THORNS))
+                    if (doCast(target, THORNS))
+                        return true;
+            }
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            //if eating or drinking don't do anything
+            if (GC_Timer > diff || me->IsMounted()) return;
+
+            RezGroup(REVIVE, master);
+
+            if (Feasting()) return;
+
+            if (BuffTarget(master, diff))
+            {
+                /*GC_Timer = 800;*/
+                return;
+            }
+            if (BuffTarget(me, diff))
+            {
+                /*GC_Timer = 800;*/
+                return;
+            }
+        }
+
+        void doInnervate(uint8 minmanaval = 30)
+        {
+            Unit* iTarget = NULL;
+
+            if (master->IsInCombat() && GetManaPCT(master) < 20 && !master->HasAura(INNERVATE))
+                iTarget = master;
+            else if (me->IsInCombat() && GetManaPCT(me) < 20 && !me->HasAura(INNERVATE))
+                iTarget = me;
+
+            Group* group = master->GetGroup();
+            if (!iTarget && !group)//first check master's bots
+            {
+                for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+                {
+                    Creature* bot = master->GetBotMap(i)->_Cre();
+                    if (!bot || !bot->IsInCombat() || bot->isDead()) continue;
+                    if (me->GetExactDist(bot) > 30) continue;
+                    if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                    {
+                        iTarget = bot;
+                        break;
+                    }
+                }
+            }
+            if (!iTarget)//cycle through player members...
+            {
+                for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (tPlayer == NULL || !tPlayer->IsInWorld() || !tPlayer->IsInCombat() || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (GetManaPCT(tPlayer) < minmanaval && !tPlayer->HasAura(INNERVATE))
+                    {
+                        iTarget = tPlayer;
+                        break;
+                    }
+                }
+            }
+            if (!iTarget)//... and their bots.
+            {
+                for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (!bot || bot->isDead()) continue;
+                        if (me->GetExactDist(bot) > 30) continue;
+                        if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                        {
+                            iTarget = bot;
+                            break;
+                        }
+                    }
+                }
+            }
+
+            if (iTarget && doCast(iTarget, INNERVATE))
+            {
+                if (iTarget->GetTypeId() == TYPEID_PLAYER)
+                    me->MonsterWhisper("Innervate on You!", iTarget->GetGUID());
+                Innervate_Timer = iTarget->GetTypeId() == TYPEID_PLAYER ? 60000 : 30000;//1 min if player and 30 sec if bot
+            }
+        }
+
+        void CheckRoots(uint32 diff)
+        {
+            if (!ENTANGLING_ROOTS || GC_Timer > diff) return;
+            if (me->GetShapeshiftForm() != FORM_NONE) return;
+            if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60)) return;
+            if (Unit* target = FindRootTarget(30, ENTANGLING_ROOTS))
+                if (doCast(target, ENTANGLING_ROOTS))
+                    return;
+        }
+
+        void CheckBattleRez(uint32 diff)
+        {
+            if (!REBIRTH || Rebirth_Timer > diff || Rand() > 10 || IsCasting() || me->IsMounted()) return;
+            Group* gr = master->GetGroup();
+            if (!gr)
+            {
+                Unit* target = master;
+                if (master->IsAlive()) return;
+                if (master->isRessurectRequested()) return; //ressurected
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)master->GetCorpse();
+                if (!target || !target->IsInWorld())
+                    return;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    Rebirth_Timer = 1500;
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, REBIRTH))//rezzing
+                {
+                    me->MonsterWhisper("Rezzing You", master->GetGUID());
+                    Rebirth_Timer = me->getLevel() >= 60 ? 300000 : 600000; //5-10 min (improved possible)
+                }
+                return;
+            }
+            for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                Unit* target = tPlayer;
+                if (!tPlayer || tPlayer->IsAlive()) continue;
+                if (tPlayer->isRessurectRequested()) continue; //ressurected
+                if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)tPlayer->GetCorpse();
+                if (!target || !target->IsInWorld()) continue;
+                if (master->GetMap() != target->FindMap()) continue;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(target->GetMapId(), *target);
+                    Rebirth_Timer = 1500;
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, REBIRTH))//rezzing
+                {
+                    me->MonsterWhisper("Rezzing You", tPlayer->GetGUID());
+                    Rebirth_Timer = me->getLevel() >= 60 ? 300000 : 600000; //5-10 min (improved possible)
+                    return;
+                }
+            }
+        }
+
+        void SetStats(uint8 form, bool init = true)
+        {
+            switch (form)
+            {
+                case BEAR:
+                    me->SetBotClass(BEAR);
+                    if (me->getPowerType() != POWER_RAGE)
+                    {
+                        me->setPowerType(POWER_RAGE);
+                        me->SetMaxPower(POWER_RAGE, 1000);
+                    }
+                    if (me->getLevel() >= 15)
+                        me->SetPower(POWER_RAGE, 200);
+                    else
+                        me->SetPower(POWER_RAGE, 0);
+                    if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK))
+                        RefreshAura(LEADER_OF_THE_PACK);
+                    setStats(BEAR, me->getRace(), master->getLevel());
+                    break;
+                case CAT:
+                    me->SetBotClass(CAT);
+                    if (me->getPowerType() != POWER_ENERGY)
+                    {
+                        me->setPowerType(POWER_ENERGY);
+                        me->SetMaxPower(POWER_ENERGY, 100);
+                        me->SetPower(POWER_ENERGY, 0);
+                    }
+                    if (me->getLevel() >= 15)
+                        me->SetPower(POWER_ENERGY, 60);
+                    else
+                        me->SetPower(POWER_ENERGY, 0);
+                    if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK))
+                        RefreshAura(LEADER_OF_THE_PACK);
+                    RefreshAura(ENERGIZE, me->getLevel()/40 + master->Has310Flyer(false));
+                    setStats(CAT, me->getRace(), master->getLevel());
+                    break;
+                case CLASS_DRUID:
+                    me->SetBotClass(CLASS_DRUID);
+                    if (me->getPowerType() != POWER_MANA)
+                        me->setPowerType(POWER_MANA);
+                    if (init)
+                        me->SetPower(POWER_MANA, mana);
+                    setStats(CLASS_DRUID, me->getRace(), master->getLevel());
+                    break;
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Regrowth_Timer = 0;
+            Swiftmend_Timer = 0;
+            Wild_Growth_Timer = 0;
+            Tranquility_Timer = 0;
+            Nature_Swiftness_Timer = 0;
+            Rebirth_Timer = 0;
+            Warstomp_Timer = 0;
+            MangleB_Timer = 0;
+            Claw_Timer = 0;
+            Rake_Timer = 0;
+            Shred_Timer = 0;
+            Rip_Timer = 0;
+            Mangle_Cat_Timer = 0;
+            Moonfire_Timer = 0;
+            Starfire_Timer = 0;
+            Wrath_Timer = 0;
+            Hurricane_Timer = 0;
+            Innervate_Timer = 0;
+            formtimer = 0;
+            clearcast = false;
+            swiftness = false;
+            power = POWER_MANA;
+            mana = 0;
+            rage = 0;
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            ragetimer = 0;
+            ragetimer2 = 0;
+
+            if (master)
+            {
+                setStats(CLASS_DRUID, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_DRUID);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (MangleB_Timer > diff)               MangleB_Timer -= diff;
+            if (Claw_Timer > diff)                  Claw_Timer -= diff;
+            if (Rake_Timer > diff)                  Rake_Timer -= diff;
+            if (Shred_Timer > diff)                 Shred_Timer -= diff;
+            if (Mangle_Cat_Timer > diff)            Mangle_Cat_Timer -= diff;
+            if (Moonfire_Timer > diff)              Moonfire_Timer -= diff;
+            if (Starfire_Timer > diff)              Starfire_Timer -= diff;
+            if (Wrath_Timer > diff)                 Wrath_Timer -= diff;
+            if (Hurricane_Timer > diff)             Hurricane_Timer -= diff;
+            if (Innervate_Timer > diff)             Innervate_Timer -= diff;
+            if (Rip_Timer > diff)                   Rip_Timer -= diff;
+            if (Regrowth_Timer > diff)              Regrowth_Timer -= diff;
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (Swiftmend_Timer > diff)             Swiftmend_Timer -= diff;
+            if (Wild_Growth_Timer > diff)           Wild_Growth_Timer -= diff;
+            if (Nature_Swiftness_Timer > diff)      Nature_Swiftness_Timer -= diff;
+            if (Tranquility_Timer > diff)           Tranquility_Timer -= diff;
+            if (Rebirth_Timer > diff)               Rebirth_Timer -= diff;
+            if (Warstomp_Timer > diff)              Warstomp_Timer -= diff;
+            if (formtimer > diff)                   formtimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            MARK_OF_THE_WILD                        = InitSpell(me, MARK_OF_THE_WILD_1);
+            THORNS                                  = InitSpell(me, THORNS_1);
+            HEALING_TOUCH                           = InitSpell(me, HEALING_TOUCH_1);
+            REGROWTH                                = InitSpell(me, REGROWTH_1);
+            REJUVENATION                            = InitSpell(me, REJUVENATION_1);
+            LIFEBLOOM                               = InitSpell(me, LIFEBLOOM_1);
+            NOURISH                                 = InitSpell(me, NOURISH_1);
+     /*tal*/WILD_GROWTH                 = lvl >= 60 ? InitSpell(me, WILD_GROWTH_1) : 0;
+     /*tal*/SWIFTMEND                   = lvl >= 40 ? InitSpell(me, SWIFTMEND_1) : 0;
+            TRANQUILITY                             = InitSpell(me, TRANQUILITY_1);
+            REVIVE                                  = InitSpell(me, REVIVE_1);
+            REBIRTH                                 = InitSpell(me, REBIRTH_1);
+            BEAR_FORM                               = InitSpell(me, BEAR_FORM_1);
+            SWIPE                                   = InitSpell(me, SWIPE_1);
+     /*tal*/MANGLE_BEAR                 = lvl >= 50 ? InitSpell(me, MANGLE_BEAR_1) : 0;
+            BASH                                    = InitSpell(me, BASH_1);
+            CAT_FORM                                = InitSpell(me, CAT_FORM_1);
+            CLAW                                    = InitSpell(me, CLAW_1);
+            RAKE                                    = InitSpell(me, RAKE_1);
+            SHRED                                   = InitSpell(me, SHRED_1);
+            RIP                                     = InitSpell(me, RIP_1);
+     /*tal*/MANGLE_CAT                  = lvl >= 50 ? InitSpell(me, MANGLE_CAT_1) : 0;
+            MOONFIRE                                = InitSpell(me, MOONFIRE_1);
+            STARFIRE                                = InitSpell(me, STARFIRE_1);
+            WRATH                                   = InitSpell(me, WRATH_1);
+            HURRICANE                               = InitSpell(me, HURRICANE_1);
+            FAIRIE_FIRE                             = InitSpell(me, FAIRIE_FIRE_1);
+            CURE_POISON                             = InitSpell(me, CURE_POISON_1);
+            INNERVATE                               = InitSpell(me, INNERVATE_1);
+            ENTANGLING_ROOTS                        = InitSpell(me, ENTANGLING_ROOTS_1);
+     /*tal*/NATURES_SWIFTNESS           = lvl >= 30 ? InitSpell(me, NATURES_SWIFTNESS_1) : 0;
+            WARSTOMP                                = WARSTOMP_1;
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 78)
+                RefreshAura(SPELLDMG2, 3); //+18%
+            else if (level >= 65)
+                RefreshAura(SPELLDMG2, 2); //+12%
+            else if (level >= 50)
+                RefreshAura(SPELLDMG2); //+6%
+            if (level >= 45)
+                RefreshAura(NATURAL_PERFECTION3); //4%
+            else if (level >= 43)
+                RefreshAura(NATURAL_PERFECTION2); //3%
+            else if (level >= 41)
+                RefreshAura(NATURAL_PERFECTION1); //2%
+            if (level >= 50)
+                RefreshAura(LIVING_SEED3); //100%
+            else if (level >= 48)
+                RefreshAura(LIVING_SEED2); //66%
+            else if (level >= 46)
+                RefreshAura(LIVING_SEED1); //33%
+            if (level >= 55)
+                RefreshAura(REVITALIZE3, 5); //75% (15%)x5
+            else if (level >= 53)
+                RefreshAura(REVITALIZE2, 3); //30% (10%)x3
+            else if (level >= 51)
+                RefreshAura(REVITALIZE1, 3); //15%  (5%)x3
+            if (level >= 70)
+                RefreshAura(OMEN_OF_CLARITY, 3); //x3
+            else if (level >= 40)
+                RefreshAura(OMEN_OF_CLARITY, 2); //x2
+            else if (level >= 20)
+                RefreshAura(OMEN_OF_CLARITY); //x1
+            if (level >= 45)
+                RefreshAura(GLYPH_SWIFTMEND); //no comsumption
+            if (level >= 40)
+                RefreshAura(GLYPH_INNERVATE); //no comsumption
+            if (level >= 20)
+                RefreshAura(NATURESGRACE);
+            if (level >= 78)
+            {
+                RefreshAura(T9_RESTO_P4_BONUS);
+                RefreshAura(T8_RESTO_P4_BONUS);
+                RefreshAura(T9_BALANCE_P2_BONUS);
+                RefreshAura(T10_BALANCE_P2_BONUS);
+                RefreshAura(T10_BALANCE_P4_BONUS);
+            }
+        }
+
+    private:
+        uint32
+   /*Buffs*/MARK_OF_THE_WILD, THORNS, 
+/*Heal/Rez*/HEALING_TOUCH, REGROWTH, REJUVENATION, LIFEBLOOM, NOURISH, WILD_GROWTH, SWIFTMEND, TRANQUILITY, REVIVE, REBIRTH, 
+    /*Bear*/BEAR_FORM, SWIPE, MANGLE_BEAR, BASH, 
+     /*Cat*/CAT_FORM, CLAW, RAKE, SHRED, RIP, MANGLE_CAT, 
+ /*Balance*/MOONFIRE, STARFIRE, WRATH, HURRICANE, FAIRIE_FIRE, 
+    /*Misc*/CURE_POISON, INNERVATE, ENTANGLING_ROOTS, NATURES_SWIFTNESS, WARSTOMP;
+        //Timers/other
+/*Heal*/uint32 Heal_Timer, Regrowth_Timer, Swiftmend_Timer, Wild_Growth_Timer,
+/*Heal*/    Tranquility_Timer, Nature_Swiftness_Timer, Rebirth_Timer;
+/*Bear*/uint32 MangleB_Timer;
+/*Cat*/ uint32 Claw_Timer, Rake_Timer, Shred_Timer, Rip_Timer, Mangle_Cat_Timer;
+/*Bal*/ uint32 Moonfire_Timer, Starfire_Timer, Wrath_Timer, Hurricane_Timer, Innervate_Timer;
+/*Misc*/uint32 formtimer, ragetimer, ragetimer2, Warstomp_Timer;
+/*Chck*/bool clearcast, swiftness;
+/*Misc*/Powers power; uint32 mana, rage;
+/*Misc*/float rageIncomeMult, rageLossMult;
+
+        enum DruidBaseSpells
+        {
+            MARK_OF_THE_WILD_1                  = 1126,
+            THORNS_1                            = 467,
+            HEALING_TOUCH_1                     = 5185,
+            REGROWTH_1                          = 8936,
+            REJUVENATION_1                      = 774,
+            LIFEBLOOM_1                         = 33763,
+            NOURISH_1                           = 50464,
+     /*tal*/WILD_GROWTH_1                       = 48438,
+     /*tal*/SWIFTMEND_1                         = 18562,
+            TRANQUILITY_1                       = 740,
+            REVIVE_1                            = 50769,
+            REBIRTH_1                           = 20484,
+            BEAR_FORM_1                         = 5487,
+            SWIPE_1                             = 779,
+     /*tal*/MANGLE_BEAR_1                       = 33878,
+            BASH_1                              = 5211,
+            CAT_FORM_1                          = 768,
+            CLAW_1                              = 1082,
+            RAKE_1                              = 1822,
+            SHRED_1                             = 5221,
+            RIP_1                               = 1079,
+     /*tal*/MANGLE_CAT_1                        = 33876,
+            MOONFIRE_1                          = 8921,
+            STARFIRE_1                          = 2912,
+            WRATH_1                             = 5176,
+            HURRICANE_1                         = 16914,
+            FAIRIE_FIRE_1                       = 770,
+            CURE_POISON_1                       = 8946,
+            INNERVATE_1                         = 29166,
+            ENTANGLING_ROOTS_1                  = 339,
+     /*tal*/NATURES_SWIFTNESS_1                 = 17116,
+            WARSTOMP_1                          = 20549,
+        };
+        enum DruidPassives
+        {
+        //Talents
+            OMEN_OF_CLARITY                     = 16864,//clearcast
+            NATURESGRACE                        = 61346,//haste 20% for 3 sec
+            NATURAL_PERFECTION1                 = 33881,
+            NATURAL_PERFECTION2                 = 33882,
+            NATURAL_PERFECTION3                 = 33883,
+            LIVING_SEED1                        = 48496,//rank 1
+            LIVING_SEED2                        = 48499,//rank 2
+            LIVING_SEED3                        = 48500,//rank 3
+            REVITALIZE1                         = 48539,//rank 1
+            REVITALIZE2                         = 48544,//rank 2
+            REVITALIZE3                         = 48545,//rank 3
+  /*Talent*/LEADER_OF_THE_PACK                  = 24932,
+        //Glyphs
+            GLYPH_SWIFTMEND                     = 54824,//no consumption
+            GLYPH_INNERVATE                     = 54832,//self regen
+        //other
+            T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
+            T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal 
+            T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
+            T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
+            T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
+            SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            SPELLDMG2/*Earth and Moon - druid*/ = 48511,//rank3 6% dam
+            ENERGIZE                            = 27787,//Rogue Armor Energize (chance: +35 energy on hit)
+            CRIT_50                             = 23434,//50% spell crit
+        };
+        enum DruidSpecial
+        {
+            //NATURESGRACEBUFF                    = 16886,
+            OMEN_OF_CLARITY_BUFF                = 16870,
+        };
+    };
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..435df78
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
@@ -0,0 +1,340 @@
+#include "bot_ai.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+//#include "SpellAuras.h"
+/*
+Hunter NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 1%
+TODO:
+*/
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new hunter_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct hunter_botAI : public bot_minion_ai
+    {
+        hunter_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        //void CreatePet()
+        //{
+
+        //    pet = me->GetBotsPet(60238);
+
+        //    if (pet == NULL)
+        //        return;
+
+        //    pet->UpdateCharmAI();
+        //    pet->setFaction(me->getFaction());
+        //    pet->SetReactState(REACT_DEFENSIVE);
+        //    pet->GetMotionMaster()->MoveFollow(me, PET_FOLLOW_DIST*urand(1, 2),PET_FOLLOW_ANGLE);
+        //    CharmInfo* charmInfonewbot = pet->InitCharmInfo();
+        //    pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+        //    pet->UpdateStats(STAT_STRENGTH);
+        //    pet->UpdateStats(STAT_AGILITY);
+        //    pet->SetLevel(master->getLevel());
+
+        //    /*float val2 = master->getLevel()*4.f + pet->GetStat(STAT_STRENGTH)*5.f;
+
+        //    val2=100.0;
+        //    uint32 attPowerMultiplier=1;
+        //    pet->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, uint32(val2));
+        //    pet->UpdateAttackPowerAndDamage();
+        //    pet->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, uint32(val2 * attPowerMultiplier));
+        //    pet->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, uint32(val2 * attPowerMultiplier)*3+master->getLevel());
+        //    pet->UpdateDamagePhysical(BASE_ATTACK);*/
+
+        //}
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_HUNTER) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions(uint32 const /*diff*/)
+        {}
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+
+            if (IAmDead()) return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            //if (pet && pet != NULL && pet->isDead())
+            //{
+            //    me->SetBotsPetDied();
+            //    pet = NULL;
+            //}
+
+            //if we think we have a pet, but master doesn't, it means we teleported
+            //if (pet && !me->getBotsPet())
+            //{
+            //    me->SetBotsPetDied();
+            //    pet = NULL;
+            //}
+
+            DoNormalAttack(diff);
+            ScriptedAI::UpdateAI(diff);
+
+            //if low on health, drink a potion
+            if (GetHealthPCT(me) < 65)
+            {
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+            }
+
+            //if low on mana, drink a potion
+            if (GetManaPCT(me) < 65 && Potion_cd <= diff)
+            {
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+            }
+
+            opponent = SelectTarget(SELECT_TARGET_TOPAGGRO, 0);
+            if (!opponent && !me->GetVictim())
+            {
+                me->CombatStop();
+                //ResetOrGetNextTarget();
+
+                //to reduce the number of crashes, remove pet whenever we are not in combat
+                //if (pet != NULL && pet->IsAlive())
+                //{
+                //    me->SetBotsPetDied();
+                //    pet = NULL;
+                //}
+                return;
+            }
+
+            //if (pet == NULL)
+            //    CreatePet();
+
+            //if (pet && pet->IsAlive() &&
+            //    !pet->IsInCombat() &&
+            //    me->GetVictim())
+            //{
+            //    pet->Attack (me->GetVictim(), true);
+            //    pet->GetMotionMaster()->MoveChase(me->GetVictim(), 1, 0);
+            //}
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            if (!opponent || opponent->isDead()) return;
+
+            // try to get rid of enrage effect
+            if (TRANQ_SHOT && (HasAuraName(opponent, "Enrage") || (HasAuraName(opponent, "Frenzy")))) 
+            {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                me->MonsterSay("Tranquil shot!", LANG_UNIVERSAL, opponent->GetGUID());
+                doCast(opponent, TRANQ_SHOT, true);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // silence it
+            if (SILENCING_SHOT && opponent->HasUnitState(UNIT_STATE_CASTING) && SilencingShot_Timer <= diff)
+            {
+                doCast(opponent, SILENCING_SHOT);
+                SilencingShot_Timer = 25000;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // mark it
+            if (!HasAuraName(opponent, "Hunter's Mark"))
+            {
+                doCast(opponent, HUNTERS_MARK);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // sting it
+            if (SCORPID_STING && !opponent->HasAura(SCORPID_STING, me->GetGUID())) 
+            {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, SCORPID_STING);
+               // me->MonsterSay("Scorpid Sting!", LANG_UNIVERSAL, NULL);
+               // doCast(opponent, AUTO_SHOT);
+               // return;
+            }
+
+             if (CHIMERA_SHOT && ChimeraShot_Timer <= diff && GC_Timer <= diff)
+             {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, CHIMERA_SHOT);
+                ChimeraShot_Timer = 10000;
+               // me->MonsterSay("Chimera Sting!", LANG_UNIVERSAL, NULL);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            if (ARCANE_SHOT && ArcaneShot_cd <= diff && GC_Timer <= diff)
+            {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, ARCANE_SHOT);
+               // me->MonsterSay("Arcane shot!", LANG_UNIVERSAL, NULL);
+                ArcaneShot_cd = 60;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            if (AIMED_SHOT && AimedShot_Timer <= diff && GC_Timer <= diff)
+            {
+                me->InterruptNonMeleeSpells( true, AUTO_SHOT );
+                doCast(opponent, AIMED_SHOT);
+               // me->MonsterSay("Aimed shot!", LANG_UNIVERSAL, NULL);
+                AimedShot_Timer = 120;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+            //Temp Feign death For Debug
+            AttackerSet b_attackers = me->getAttackers();
+            if (!b_attackers.empty())
+            {
+            for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                if (*iter && (*iter)->GetVictim()->GetGUID() == me->GetGUID() && 
+                    me->GetDistance(*iter) < 10 && 
+                    Feign_Death_Timer <= diff && GC_Timer <= diff)
+                {
+                    doCast(me, FEIGN_DEATH, true);
+                    opponent->AddThreat(me, -100000);
+                    me->CombatStop();
+                    Feign_Death_Timer = 25000;
+                    me->CombatStart(opponent);
+                }
+            }
+
+            doCast(opponent, AUTO_SHOT);
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            ArcaneShot_cd = 0;
+            ChimeraShot_Timer = 0;
+            SilencingShot_Timer = 0;
+            AimedShot_Timer = 0;
+            Feign_Death_Timer = 0;
+
+            if (master)
+            {
+                setStats(CLASS_HUNTER, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_HUNTER);
+             }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (ArcaneShot_cd > diff)               ArcaneShot_cd -= diff;
+            if (ChimeraShot_Timer > diff)           ChimeraShot_Timer -= diff;
+            if (SilencingShot_Timer > diff)         SilencingShot_Timer -= diff;
+            if (AimedShot_Timer > diff)             AimedShot_Timer -= diff;
+            if (Feign_Death_Timer > diff)           Feign_Death_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            AUTO_SHOT                               = AUTO_SHOT_1;
+            TRANQ_SHOT                              = InitSpell(me, TRANQ_SHOT_1);
+            SCORPID_STING                           = InitSpell(me, SCORPID_STING_1);
+            HUNTERS_MARK                            = InitSpell(me, HUNTERS_MARK_1);
+            ARCANE_SHOT                             = InitSpell(me, ARCANE_SHOT_1);
+            CHIMERA_SHOT                = lvl >= 60 ? CHIMERA_SHOT_1 : 0;
+            AIMED_SHOT                  = lvl >= 20 ? InitSpell(me, AIMED_SHOT_1) : 0;
+            SILENCING_SHOT              = lvl >= 50 ? SILENCING_SHOT_1 : 0;
+            ASPECT_OF_THE_DRAGONHAWK                = InitSpell(me, ASPECT_OF_THE_DRAGONHAWK_1);
+            FEIGN_DEATH                             = InitSpell(me, FEIGN_DEATH_1);
+        }
+
+        void ApplyClassPassives()
+        { }
+
+    private:
+        uint32
+        AUTO_SHOT, TRANQ_SHOT, SCORPID_STING, HUNTERS_MARK, ARCANE_SHOT, CHIMERA_SHOT, AIMED_SHOT, 
+        SILENCING_SHOT, ASPECT_OF_THE_DRAGONHAWK, FEIGN_DEATH;
+        //Timers
+        uint32 ArcaneShot_cd, ChimeraShot_Timer, SilencingShot_Timer, AimedShot_Timer, Feign_Death_Timer;
+
+        enum HunterBaseSpells
+        {
+            AUTO_SHOT_1                         = 75,
+            TRANQ_SHOT_1                        = 19801,
+            SCORPID_STING_1                     = 3043,
+            HUNTERS_MARK_1                      = 14325,
+            ARCANE_SHOT_1                       = 3044,
+            CHIMERA_SHOT_1                      = 53209,
+            AIMED_SHOT_1                        = 19434,
+            SILENCING_SHOT_1                    = 34490,
+            ASPECT_OF_THE_DRAGONHAWK_1          = 61846,
+            FEIGN_DEATH_1                       = 5384,
+        };
+
+        enum HunterPassives
+        {
+        };
+
+        enum HunterSpecial
+        {
+        };
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
new file mode 100644
index 0000000..2eb54e7
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
@@ -0,0 +1,935 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Mage NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45%
+TODO: Ice Lance, Deep Freeze, Mana Gems, Pet etc...
+*/
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new mage_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct mage_botAI : public bot_minion_ai
+    {
+        mage_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_MAGE) != SPELL_CAST_OK)
+                return false;
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result && spellId != MANAPOTION && me->HasAura(CLEARCASTBUFF))
+            {
+                cost = info->CalcPowerCost(me, info->GetSchoolMask());
+                clearcast = true;
+            }
+
+            return result;
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == (COMMAND_ATTACK) && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, true);
+        }
+
+        void Counter()
+        {
+            Unit* u = me->GetVictim();
+            bool cSpell = CounterSpell_cd <= 5000;
+            bool blast = FireBlast_cd <= 3000 && !(u && u->ToCreature() && (u->ToCreature()->isWorldBoss() || u->ToCreature()->IsDungeonBoss())) && me->HasAura(IMPACT_BUFF);
+            if (!cSpell && !blast) return;
+            if (u && u->IsNonMeleeSpellCasted(false))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (cSpell && doCast(u, COUNTERSPELL))
+                    CounterSpell_cd = 15000;
+                else if (blast && doCast(u, FIREBLAST))
+                    FireBlast_cd = 6000;
+                GC_Timer = temptimer;
+            }
+            else if (cSpell)
+            {
+                if (Unit* target = FindCastingTarget(30))
+                {
+                    temptimer = GC_Timer;
+                    if (me->IsNonMeleeSpellCasted(false))
+                        me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, COUNTERSPELL))
+                    {
+                        CounterSpell_cd = 15000;
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void CheckSpellSteal(uint32 diff)
+        {
+            if (!SPELLSTEAL || Rand() > 25 || GC_Timer > diff || IsCasting()) return;
+            Unit* target = FindHostileDispelTarget(30, true);
+            if (target && doCast(target, SPELLSTEAL))
+                GC_Timer = 800;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted()) return;
+            if (Feasting()) return;
+
+            if (!HasAuraName(me, DAMPENMAGIC) && 
+                doCast(me, DAMPENMAGIC))
+            { /*GC_Timer = 800;*/ return; }
+
+            if (!HasAuraName(me, ICEARMOR) && 
+                doCast(me, ICEARMOR))
+            { /*GC_Timer = 800;*/ return; }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || !target || target->isDead() || Rand() > 50) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+            if (target->getPowerType() == POWER_MANA && 
+                !HasAuraName(target, ARCANEINTELLECT) && 
+                doCast(target, ARCANEINTELLECT))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            return false;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->GetVictim())
+                Evade();
+            if (clearcast && me->HasAura(CLEARCASTBUFF) && !me->IsNonMeleeSpellCasted(false))
+            {
+                me->ModifyPower(POWER_MANA, cost);
+                me->RemoveAurasDueToSpell(CLEARCASTBUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF1))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF2))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            BreakCC(diff);
+            if (CCed(me) && (!ICEBLOCK || !me->HasAura(ICEBLOCK))) return;//TODO
+
+            CheckBlink(diff);
+            CheckPoly(diff);
+            CheckPots(diff);
+            CureTarget(master, REMOVE_CURSE, diff);
+            CureTarget(me, REMOVE_CURSE, diff);
+            CureGroup(master, REMOVE_CURSE, diff);
+
+            FocusMagic(diff);
+            BuffAndHealGroup(master, diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            
+            if (!CheckAttackTarget(CLASS_MAGE))
+                return;
+
+            CheckPoly2();//this should go AFTER getting opponent
+
+            Counter();
+            CheckSpellSteal(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            Unit* u = me->SelectNearestTarget(20);
+            //ICE_BARRIER
+            if (ICE_BARRIER && Ice_Barrier_cd <= diff && u && u->GetVictim() == me && 
+                u->GetDistance(me) < 8 && !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, ICE_BARRIER))
+                {
+                    Ice_Barrier_cd = 41000 - me->getLevel()*200;//down to 25 sec on 80
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if ((!ICE_BARRIER || Ice_Barrier_cd > diff) && 
+                BLINK && Blink_cd < 3000 && u && u->GetVictim() == me && 
+                !me->HasAura(ICE_BARRIER) && u->GetDistance(me) < 6)
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, BLINK))
+                {
+                    Blink_cd = 15000 - me->getLevel()/4 * 100;
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            if (me->HasAura(ICEBLOCK))
+                if (((GetManaPCT(me) > 45 && GetHealthPCT(me) > 80) || b_attackers.empty()) && Iceblock_cd <= 57000 && tank)
+                    me->RemoveAurasDueToSpell(ICEBLOCK);
+            //ICEBLOCK
+            if (ICEBLOCK && Rand() < 50 && !b_attackers.empty() && tank && Iceblock_cd <= diff && 
+                (GetManaPCT(me) < 15 || GetHealthPCT(me) < 45 || b_attackers.size() > 4) && 
+                !me->HasAura(ICEBLOCK))
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, ICEBLOCK))
+                {
+                    Iceblock_cd = 60000;
+                    return;
+                }
+            }
+
+            if (IsCasting()) return;
+
+            BOLT = (CCed(opponent, true) || (opponent->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED) && me->HasAura(COMBUSTION))) ? FIREBALL : FROSTBOLT;
+            NOVA = BOLT == FIREBALL && BLASTWAVE ? BLASTWAVE : FROSTNOVA ? FROSTNOVA : 0;
+
+            float dist = me->GetExactDist(opponent);
+            if (dist > 30)
+                return;
+
+            if (COMBUSTION && Rand() < 15 && 
+                (opponent->GetMaxHealth() > master->GetMaxHealth()*10 || 
+                m_attackers.size() > 1 || b_attackers.size() > 2))
+            {
+                if (!HasAuraName(me, "Combustion") && Combustion_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, COMBUSTION))
+                    {
+                        Combustion_cd = 60000;
+                        //Reset timers for fun
+                        Nova_cd = 0; FireBlast_cd = 0; DragonBreath_cd = 0;
+                    }
+                    GC_Timer = temptimer;
+                }
+            }
+            //DAMAGE
+            //PYROBLAST
+            if (PYROBLAST && Rand() < 75 && Pyroblast_cd <= diff && GC_Timer <= diff && 
+                b_attackers.size() < 2 && dist < 30 && opponent->IsPolymorphed() && 
+                doCast(opponent, PYROBLAST))
+                Pyroblast_cd = 50;
+            //nova //TODO: SEPARATE
+            u = me->SelectNearestTarget(7);
+            if (u && NOVA && Nova_cd <= diff && !CCed(u, true) && IsInBotParty(u->GetVictim()))
+            {
+                Unit* tar = u->GetVictim();
+                if (tar && IsInBotParty(tar) && doCast(me, NOVA))
+                {
+                    Nova_cd = 15000;
+                    return;
+                }
+            }
+            //living bomb
+            if (LIVINGBOMB && Rand() < 25 && Living_Bomb_cd <= diff && GC_Timer <= diff && 
+                dist < 30 && opponent->GetHealth() > me->GetHealth()/2 && 
+                !opponent->HasAura(LIVINGBOMB, me->GetGUID()) && 
+                doCast(opponent, LIVINGBOMB))
+            {
+                Living_Bomb_cd = 6000;
+                GC_Timer = 500;
+                return;
+            }
+            //cone of cold
+            if (CONEOFCOLD && ConeofCold_cd <= diff && GC_Timer <= diff && dist < 7 && 
+                me->HasInArc(M_PI, opponent) && 
+                doCast(opponent, CONEOFCOLD))
+            {
+                ConeofCold_cd = 14000;
+                GC_Timer = 500;
+                return;
+            }
+            //dragon's breath
+            u = me->SelectNearestTarget(7);
+            if (DRAGONBREATH && u && DragonBreath_cd <= diff && GC_Timer <= diff && 
+                me->HasInArc(M_PI, opponent) && !HasAuraName(u, FROSTNOVA) && 
+                doCast(opponent, DRAGONBREATH))
+            {
+                DragonBreath_cd = 25000;
+                GC_Timer = 800;
+                return;
+            }
+            /*//blast wave //TODO Separate again
+            u = me->SelectNearestTarget(8);
+            if (BLASTWAVE != 0 && u && isTimerReady(BlastWave_cd) && 
+                !HasAuraName(u, FROSTNOVA) && !HasAuraName(u, DRAGONBREATH) && 
+                doCast(me, BLASTWAVE))
+            {
+                BlastWave_cd = BLASTWAVE_CD;
+                GC_Timer = 800;
+            }*/
+            //fire blast
+            if (FireBlast_cd <= diff && GC_Timer <= diff && dist < 20 && 
+                Rand() < 20 + 80*(!opponent->HasAuraType(SPELL_AURA_MOD_STUN) && me->HasAura(IMPACT_BUFF)) && 
+                doCast(opponent, FIREBLAST))
+            {
+                FireBlast_cd = 6000;
+                GC_Timer = 500;
+                return;
+            }
+            //flamestrike
+            if (GC_Timer <= diff && Rand() < 60 && me->HasAura(FIRESTARTERBUFF))
+            {
+                Unit* FStarget = FindAOETarget(30, true, false);
+                if (FStarget && doCast(FStarget, FLAMESTRIKE, true))
+                {
+                    me->RemoveAurasDueToSpell(FIRESTARTERBUFF);
+                    GC_Timer = 0;
+                    return;
+                }
+            }
+            //blizzard
+            if (BLIZZARD && Rand() < 80 && Blizzard_cd <= diff)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, BLIZZARD))
+                {
+                    Blizzard_cd = 5000;
+                    return;
+                }
+                Blizzard_cd = 2000;//fail
+            }
+            //Frost of Fire Bolt
+            if (Rand() < 75 && Bolt_cd <= diff && dist < 30 && 
+                doCast(opponent, BOLT))
+            {
+                Bolt_cd = uint32(float(sSpellMgr->GetSpellInfo(BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200);
+                return;
+            }
+            //Arcane Missiles
+            if (Rand() < 10 && GC_Timer <= diff && !me->isMoving() && dist < 20 && 
+                doCast(opponent, ARCANEMISSILES))
+                return;
+        }
+
+        void CheckPoly(uint32 diff)
+        {
+            if (polyCheckTimer <= diff)
+            {
+                Polymorph = FindAffectedTarget(POLYMORPH, me->GetGUID());
+                polyCheckTimer = 2000;
+            }
+        }
+
+        void CheckPoly2()
+        {
+            if (Polymorph == false && GC_Timer < 500)
+            {
+                if (Unit* target = FindPolyTarget(30, me->GetVictim()))
+                {
+                    if (doCast(target, POLYMORPH))
+                    {
+                        Polymorph = true;
+                        polyCheckTimer = 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckPots(uint32 diff)
+        {
+            if (GetHealthPCT(me) < 70 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(me) < 35)
+            {
+                if (Evocation_cd <= diff && !me->isMoving() && me->getAttackers().empty() && doCast(me, EVOCATION))
+                    Evocation_cd = 60000;
+                else if (Potion_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, MANAPOTION))
+                        Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+        }
+
+        void CheckBlink(uint32 diff)
+        {
+            if (GetBotCommandState() == COMMAND_STAY || me->IsMounted()) return;
+            if (Blink_cd > diff || me->getLevel() < 20 || IsCasting()) return;
+            if (me->GetExactDist(master) > std::max(float(master->GetBotFollowDist()), 25.f)/* && me->IsWithinLOSInMap(master)*/)
+            {
+                me->SetFacingTo(me->GetAngle(master));
+                if (doCast(me, BLINK))
+                {
+                    Blink_cd = 15000 - me->getLevel()/4 * 100; //13 sec with improved
+                    GC_Timer = 500;
+                }
+                return;
+            }
+            if (!me->getAttackers().empty() && me->GetExactDist(master) > 15)
+            {
+                if (Unit* op = me->SelectNearestTarget(10))
+                {
+                    if (op->GetVictim() == me)
+                    {
+                        me->SetFacingTo(me->GetAngle(master));
+                        if (doCast(me, BLINK))
+                        {
+                            Blink_cd = 15000 - me->getLevel()/4 * 100; //13 sec with improved
+                            GC_Timer = 500;
+                        }
+                    }
+                }
+            }
+        }
+
+        void FocusMagic(uint32 diff)
+        {
+            if (!FOCUSMAGIC || me->getLevel() < 20 || fmCheckTimer > diff || GC_Timer > diff || Rand() < 50 || IsCasting())
+                return;
+            if (Unit* target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 2))
+            {
+                fmCheckTimer = 30000;
+                return;
+            }
+            else
+            {
+                Group* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (master->getPowerType() == POWER_MANA && !master->HasAura(FOCUSMAGIC) && me->GetExactDist(master) < 30)
+                    target = master;
+                }
+                else
+                {
+                    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || pPlayer->isDead()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if ((pPlayer->getClass() == CLASS_MAGE || 
+                            pPlayer->getClass() == CLASS_PRIEST || 
+                            pPlayer->getClass() == CLASS_SHAMAN || 
+                            pPlayer->getClass() == CLASS_DRUID || 
+                            pPlayer->getClass() == CLASS_PALADIN || 
+                            pPlayer->getClass() == CLASS_WARLOCK) && 
+                            !pPlayer->HasAura(FOCUSMAGIC) && me->GetExactDist(pPlayer) < 30)
+                        {
+                            target = pPlayer;
+                            break;
+                        }
+                    }
+                    if (!target)
+                    {
+                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            for (uint8 i = 0; i != pPlayer->GetMaxNpcBots(); ++i)
+                            {
+                                Creature* cre = pPlayer->GetBotMap(i)->_Cre();
+                                if (!cre || cre == me || cre->isDead() || cre->getPowerType() != POWER_MANA) continue;
+                                if ((cre->GetBotClass() == CLASS_MAGE || 
+                                    cre->GetBotClass() == CLASS_PRIEST || 
+                                    cre->GetBotClass() == CLASS_SHAMAN || 
+                                    cre->GetBotClass() == CLASS_DRUID || 
+                                    cre->GetBotClass() == CLASS_WARLOCK) && 
+                                    !cre->HasAura(FOCUSMAGIC) && me->GetExactDist(cre) < 30)
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+                if (target && doCast(target, FOCUSMAGIC))
+                {
+                    GC_Timer = 500;
+                    fmCheckTimer = 30000;
+                    return;
+                }
+            }
+            fmCheckTimer = 5000;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Combustion: 10% per stack
+                if (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask())
+                    if (Aura* combustion = me->GetAura(COMBUSTION_BUFF))
+                        aftercrit += float(combustion->GetStackAmount()*10);
+                //Incineration: 6% additional critical chance for Fire Blast, Scorch, Arcane Blast and Cone of Cold
+                if (lvl >= 10 &&
+                    (spellId == FIREBLAST ||
+                    spellId == CONEOFCOLD/* ||
+                    spellId == ARCANEBLAST ||
+                    spellId == SCORCH*/))
+                    aftercrit += 6.f;
+                //World In Flames: 6% additional critical chance for
+                //Flamestrike, Pyroblast, Blast Wave, Dragon's Breath, Living Bomb, Blizzard and Arcane Explosion
+                if (lvl >= 15 &&
+                    (spellId == FLAMESTRIKE ||
+                    spellId == PYROBLAST ||
+                    spellId == BLASTWAVE ||
+                    spellId == DRAGONBREATH/* ||
+                    spellId == ARCANEXPLOSION ||
+                    spellId == LIVINGBOMB ||    //cannot be handled here
+                    spellId == BLIZZARD*/))    //cannot be handled here
+                    aftercrit += 6.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Spell Power: 50% additional crit damage bonus for All spells
+                if (lvl >= 55)
+                    pctbonus += 0.333f;
+                //Ice Shards: 50% additional crit damage bonus for Frost spells
+                else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.333f;
+            }
+            //Improved Cone of Cold: 35% bonus damage for Cone of Cold
+            if (lvl >= 30 && spellId == CONEOFCOLD)
+                pctbonus += 0.35f;
+            //Fire Power: 10% bonus damage for Fire spells
+            if (lvl >= 35 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* /*target*/, SpellInfo const* spell)
+        {
+            if (aftercastTargetGuid != 0)
+            {
+                //only players for now
+                if (!IS_PLAYER_GUID(aftercastTargetGuid))
+                {
+                    aftercastTargetGuid = 0;
+                    return;
+                }
+                Player* pTarget = sObjectAccessor->FindPlayer(aftercastTargetGuid);
+                aftercastTargetGuid = 0;
+                if (!pTarget/* || me->GetDistance(pTarget) > 15*/)
+                    return;
+
+                //handle effects
+                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch (spell->Effects[i].Effect)
+                    {
+                        case SPELL_EFFECT_CREATE_ITEM:
+                        case SPELL_EFFECT_CREATE_ITEM_2:
+                        {
+                            uint32 newitemid = spell->Effects[i].ItemType;
+                            if (newitemid)
+                            {
+                                ItemPosCountVec dest;
+                                ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(newitemid);
+                                if (!pProto)
+                                    return;
+                                uint32 count = pProto->GetMaxStackSize();
+                                uint32 no_space = 0;
+                                InventoryResult msg = pTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, count, &no_space);
+                                if (msg != EQUIP_ERR_OK)
+                                {
+                                    if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
+                                        count -= no_space;
+                                    else
+                                    {
+                                        // if not created by another reason from full inventory or unique items amount limitation
+                                        pTarget->SendEquipError(msg, NULL, NULL, newitemid);
+                                        continue;
+                                    }
+                                }
+                                if (count)
+                                {
+                                    Item* pItem = pTarget->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
+                                    if (!pItem)
+                                    {
+                                        pTarget->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+                                        continue;
+                                    }
+                                    //unsafe possible
+                                    pItem->SetUInt32Value(ITEM_FIELD_CREATOR, me->GetGUIDLow());
+
+                                    pTarget->SendNewItem(pItem, count, true, false, true);
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Pyroblast_cd = 0;
+            FireBlast_cd = 0;
+            DragonBreath_cd = 0;
+            Combustion_cd = 30000;//30 sec for reset
+            Ice_Barrier_cd = 0;
+            Iceblock_cd = 0;
+            ConeofCold_cd = 0;
+            Blizzard_cd = 10000;
+            CounterSpell_cd = 0;
+            Evocation_cd = 0;
+            Blink_cd = 0;
+            Bolt_cd = 0;
+            Nova_cd = 0;
+            polyCheckTimer = 0;
+            fmCheckTimer = 0;
+            Polymorph = false;
+            clearcast = false;
+            BOLT = FROSTBOLT;//default frost
+            NOVA = BLASTWAVE != 0 ? BLASTWAVE : FROSTNOVA;
+
+            if (master)
+            {
+                setStats(CLASS_MAGE, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_MAGE);
+           }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Pyroblast_cd > diff)            Pyroblast_cd -= diff;
+            if (Ice_Barrier_cd > diff)          Ice_Barrier_cd -= diff;
+            if (Iceblock_cd > diff)             Iceblock_cd -= diff;
+            if (ConeofCold_cd > diff)           ConeofCold_cd -= diff;
+            if (Living_Bomb_cd > diff)          Living_Bomb_cd -= diff;
+            if (FireBlast_cd > diff)            FireBlast_cd -= diff;
+            if (Bolt_cd > diff)                 Bolt_cd -= diff;
+            if (Blizzard_cd > diff)             Blizzard_cd -= diff;
+            if (CounterSpell_cd > diff)         CounterSpell_cd -= diff;
+            if (Nova_cd > diff)                 Nova_cd -= diff;
+            if (DragonBreath_cd > diff)         DragonBreath_cd -= diff;
+            if (Blink_cd > diff)                Blink_cd -= diff;
+            if (Combustion_cd > diff)           Combustion_cd -= diff;
+            if (Evocation_cd > diff)            Evocation_cd -= diff;
+            if (polyCheckTimer > diff)          polyCheckTimer -= diff;
+            if (fmCheckTimer > diff)            fmCheckTimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            DAMPENMAGIC                             = InitSpell(me, DAMPENMAGIC_1);
+            ARCANEINTELLECT                         = InitSpell(me, ARCANEINTELLECT_1);
+            ARCANEMISSILES                          = InitSpell(me, ARCANEMISSILES_1); 
+            POLYMORPH                               = InitSpell(me, POLYMORPH_1);
+            COUNTERSPELL                            = InitSpell(me, COUNTERSPELL_1);
+            SPELLSTEAL                              = InitSpell(me, SPELLSTEAL_1);
+            EVOCATION                               = InitSpell(me, EVOCATION_1);
+            BLINK                                   = InitSpell(me, BLINK_1);
+            REMOVE_CURSE                            = InitSpell(me, REMOVE_CURSE_1);
+            //INVISIBILITY                            = InitSpell(me, INVISIBILITY_1);
+            FIREBALL                                = InitSpell(me, FIREBALL_1);
+            BLASTWAVE                   = lvl >= 30 ? InitSpell(me, BLASTWAVE_1) : 0;
+            DRAGONBREATH                = lvl >= 40 ? InitSpell(me, DRAGONBREATH_1) : 0;
+            FIREBLAST                               = InitSpell(me, FIREBLAST_1);
+            PYROBLAST                   = lvl >= 20 ? InitSpell(me, PYROBLAST_1) : 0;
+            LIVINGBOMB                  = lvl >= 60 ? InitSpell(me, LIVINGBOMB_1) : 0;
+            FLAMESTRIKE                             = InitSpell(me, DAMPENMAGIC_1);
+            COMBUSTION                  = lvl >= 50 ? COMBUSTION_1 : 0;
+            FROSTBOLT                               = InitSpell(me, FROSTBOLT_1);
+            FROSTNOVA                               = InitSpell(me, FROSTNOVA_1);
+            CONEOFCOLD                              = InitSpell(me, CONEOFCOLD_1);
+            BLIZZARD                                = InitSpell(me, BLIZZARD_1);
+            ICEARMOR                    = lvl >= 20 ? InitSpell(me, ICEARMOR_1) : InitSpell(me, FROSTARMOR_1);
+            ICE_BARRIER                 = lvl >= 40 ? InitSpell(me, ICE_BARRIER_1) : 0;
+            ICEBLOCK                                = InitSpell(me, ICEBLOCK_1);
+            FOCUSMAGIC                  = lvl >= 20 ? FOCUSMAGIC_1 : 0;
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            //Dam+(-Hit)
+            if (level >= 50)
+                RefreshAura(ARCTIC_WINDS,3); //+15%/-15%
+            else if (level >= 25)
+                RefreshAura(ARCTIC_WINDS,2); //+10%/-10%
+            else if (level >= 10)
+                RefreshAura(ARCTIC_WINDS); //+5%/-5%
+            //CHILL
+            if (level >= 30)
+                RefreshAura(WINTERS_CHILL3); //100%
+            else if (level >= 25)
+                RefreshAura(WINTERS_CHILL2); //66%
+            else if (level >= 20)
+                RefreshAura(WINTERS_CHILL1); //33%
+            //Imp Blizzard
+            if (level >= 20)
+                RefreshAura(IMPROVED_BLIZZARD); //50% slow
+            //Frostbite
+            if (level >= 80)
+                FROSTBITE = FROSTBITE3;
+            else if (level >= 50)
+                FROSTBITE = FROSTBITE2;
+            else if (level >= 10)
+                FROSTBITE = FROSTBITE1;
+            if (level >= 60)
+                RefreshAura(FROSTBITE,3);//3x
+            else if (level >= 30)
+                RefreshAura(FROSTBITE,2);//2x
+            else if (level >= 10)
+                RefreshAura(FROSTBITE);//1x
+            //Shattered Barrier
+            if (level >= 45)
+                RefreshAura(SHATTERED_BARRIER);
+            //Bonus
+            if (level >= 65)
+                RefreshAura(ARCANE_INSTABILITY,4); //+12%dmg crit
+            else if (level >= 55)
+                RefreshAura(ARCANE_INSTABILITY,3); //+9%dmg crit
+            else if (level >= 45)
+                RefreshAura(ARCANE_INSTABILITY,2); //+6%dmg crit
+            else if (level >= 35)
+                RefreshAura(ARCANE_INSTABILITY); //+3%dmg crit
+            //Absorb
+            if (level >= 50)
+                RefreshAura(INCANTERS_ABSORPTION3);
+            else if (level >= 45)
+                RefreshAura(INCANTERS_ABSORPTION2);
+            else if (level >= 40)
+                RefreshAura(INCANTERS_ABSORPTION1);
+            //Shatter
+            if (level >= 35)
+                RefreshAura(SHATTER3);
+            else if (level >= 30)
+                RefreshAura(SHATTER2);
+            else if (level >= 25)
+                RefreshAura(SHATTER1);
+            //ClearCasting
+            if (level >= 75)
+                RefreshAura(CLEARCAST,3);//30%
+            else if (level >= 40)
+                RefreshAura(CLEARCAST,2);//20%
+            else if (level >= 15)
+                RefreshAura(CLEARCAST);//10%
+            //Fingers
+            if (level >= 45)
+                RefreshAura(FINGERS_OF_FROST);//15%
+            //Potency
+            if (level >= 40)
+                RefreshAura(ARCANE_POTENCY2);//30% bonus
+            else if (level >= 35)
+                RefreshAura(ARCANE_POTENCY1);//15% bonus
+            //Ignite
+            if (level >= 15)
+                RefreshAura(IGNITE);
+            //Impact
+            if (level >= 60)
+                RefreshAura(IMPACT,2);
+            else if (level >= 20)
+                RefreshAura(IMPACT);
+            //Imp. Counterspell
+            if (level >= 35)
+                RefreshAura(IMPROVED_COUNTERSPELL2);//4 sec
+            else if (level >= 25)
+                RefreshAura(IMPROVED_COUNTERSPELL1);//2 sec
+            //Firestarter
+            if (level >= 55)
+                RefreshAura(FIRESTARTER2);//100% chance
+            else if (level >= 45)
+                RefreshAura(FIRESTARTER1);//50% chance
+            //Spells
+            if (LIVINGBOMB != 0)
+                RefreshAura(GLYPH_LIVING_BOMB);
+            if (POLYMORPH != 0)
+                RefreshAura(GLYPH_POLYMORPH);
+        }
+
+    private:
+        uint32
+  /*Arcane*/DAMPENMAGIC, ARCANEINTELLECT, ARCANEMISSILES, POLYMORPH, COUNTERSPELL, FOCUSMAGIC,
+  /*Arcane*/SPELLSTEAL, EVOCATION, BLINK, REMOVE_CURSE, /*INVISIBILITY,*/
+    /*Fire*/FIREBALL, FIREBLAST, FLAMESTRIKE, PYROBLAST, COMBUSTION, BLASTWAVE, DRAGONBREATH, LIVINGBOMB,
+   /*Frost*/FROSTBOLT, FROSTNOVA, CONEOFCOLD, BLIZZARD, ICEARMOR, ICEBLOCK, ICE_BARRIER, FROSTBITE;
+        //Timers
+/*fire*/uint32 Pyroblast_cd, FireBlast_cd, DragonBreath_cd, Living_Bomb_cd, Combustion_cd;
+/*frst*/uint32 Ice_Barrier_cd, ConeofCold_cd, Blizzard_cd, Iceblock_cd;
+/*arcn*/uint32 CounterSpell_cd, Blink_cd, Evocation_cd;
+/*exc.*/uint32 Bolt_cd, Nova_cd;
+/*exc.*/uint32 BOLT, NOVA;
+/*exc.*/uint32 polyCheckTimer, fmCheckTimer;
+        //Check
+/*exc.*/bool Polymorph, clearcast;
+
+        enum MageBaseSpells// all orignals
+        {
+            DAMPENMAGIC_1                       = 604, 
+            ARCANEINTELLECT_1                   = 1459, 
+            ARCANEMISSILES_1                    = 5143, 
+            POLYMORPH_1                         = 118,
+            COUNTERSPELL_1                      = 2139,
+            SPELLSTEAL_1                        = 30449,
+            EVOCATION_1                         = 12051,
+            BLINK_1                             = 1953,
+            REMOVE_CURSE_1                      = 475,
+            //INVISIBILITY_1                      = 0,
+            FIREBALL_1                          = 133,
+            BLASTWAVE_1                         = 11113,
+            DRAGONBREATH_1                      = 31661,
+            FIREBLAST_1                         = 2136,
+            PYROBLAST_1                         = 11366,
+            LIVINGBOMB_1                        = 44457,
+            FLAMESTRIKE_1                       = 2120,
+            COMBUSTION_1                        = 11129,
+            FROSTBOLT_1                         = 116,
+            FROSTNOVA_1                         = 122,
+            CONEOFCOLD_1                        = 120,
+            BLIZZARD_1                          = 10,
+            FROSTARMOR_1                        = 168,
+            ICEARMOR_1                          = 7302,
+            ICE_BARRIER_1                       = 11426,
+            ICEBLOCK_1                          = 45438,
+            FOCUSMAGIC_1                        = 54646,
+        };
+
+        enum MagePassives
+        {
+            SHATTERED_BARRIER                   = 54787,//rank 2
+            ARCTIC_WINDS                        = 31678,//rank 5
+            WINTERS_CHILL1                      = 11180,
+            WINTERS_CHILL2                      = 28592,
+            WINTERS_CHILL3                      = 28593,
+            FROSTBITE1                          = 11071,
+            FROSTBITE2                          = 12496,
+            FROSTBITE3                          = 12497,
+            IMPROVED_BLIZZARD                   = 12488,//rank 3
+            CLEARCAST /*Arcane Concentration*/  = 12577,//rank 5
+            ARCANE_POTENCY1                     = 31571,
+            ARCANE_POTENCY2                     = 31572,
+            SHATTER1                            = 11170,
+            SHATTER2                            = 12982,
+            SHATTER3                            = 12983,
+            INCANTERS_ABSORPTION1               = 44394,
+            INCANTERS_ABSORPTION2               = 44395,
+            INCANTERS_ABSORPTION3               = 44396,
+            FINGERS_OF_FROST                    = 44545,//rank 2
+            ARCANE_INSTABILITY                  = 15060,//rank 3
+            IMPROVED_COUNTERSPELL1              = 11255,
+            IMPROVED_COUNTERSPELL2              = 12598,
+            IGNITE                              = 12848,
+            FIRESTARTER1                        = 44442,
+            FIRESTARTER2                        = 44443,
+            IMPACT                              = 12358,
+            GLYPH_LIVING_BOMB                   = 63091,
+            GLYPH_POLYMORPH                     = 56375,
+        };
+        enum MageSpecial
+        {
+            CLEARCASTBUFF                       = 12536,
+            IMPACT_BUFF                         = 64343,
+            FIRESTARTERBUFF                     = 54741,
+            ARCANE_POTENCY_BUFF1                = 57529,
+            ARCANE_POTENCY_BUFF2                = 57531,
+            COMBUSTION_BUFF                     = 28682
+        };
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..8d83da3
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
@@ -0,0 +1,1014 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "WorldSession.h"
+/*
+Paladin NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45-50%
+TODO: Repentance Work Improve, Tanking, Shield Abilities, Auras
+*/
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new paladin_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct paladin_botAI : public bot_minion_ai
+    {
+        paladin_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_PALADIN) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void HOFGroup(Player* pTarget, uint32 diff)
+        {
+            if (!HOF || HOF_Timer > diff || GC_Timer > diff || Rand() > 60) return;
+            if (IsCasting()) return;//I'm busy
+
+            if (Group* pGroup = pTarget->GetGroup())
+            {
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer) continue;
+                    if (HOFTarget(tPlayer, diff))
+                        return;
+                }
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* cre = tPlayer->GetBotMap(i)->_Cre();
+                        if (!cre || !cre->IsInWorld()) continue;
+                        if (HOFTarget(cre, diff))
+                            return;
+                    }
+                }
+            }
+        }
+
+        bool HOFTarget(Unit* target, uint32 diff)
+        {
+            if (!HOF || HOF_Timer > diff || GC_Timer > diff) return false;
+            if (!target || target->isDead()) return false;
+            if (target->ToCreature() && Rand() > 25) return false;
+            if (me->GetExactDist(target) > 30) return false;//too far away
+            if (HasAuraName(target, HOF)) return false;     //Alredy has HOF
+
+            Unit::AuraMap const &auras = target->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            {
+                Aura* aura = i->second;
+                if (aura->IsPassive()) continue;//most
+                if (aura->GetDuration() < 2000) continue;
+                if (AuraApplication* app = aura->GetApplicationOfTarget(target->GetGUID()))
+                    if (app->IsPositive()) continue;
+                SpellInfo const* spellInfo = aura->GetSpellInfo();
+                if (spellInfo->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+                if (me->getLevel() >= 40 && (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_STUN)))
+                {
+                    if (doCast(target, HOF))
+                    {
+                        if (target->ToCreature())
+                            HOF_Timer = 10000;//10 sec for selfcast after stun
+                        else
+                            HOF_Timer = 15000;//improved
+                        HOFGuid = target->GetGUID();
+                        return true;
+                    }
+                }
+       /*else */if (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_SNARE) || 
+                    spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_ROOT))
+                {
+                    uint32 spell = (spellInfo->Dispel == DISPEL_MAGIC || spellInfo->Dispel == DISPEL_DISEASE || spellInfo->Dispel == DISPEL_POISON) && CLEANSE ? CLEANSE : HOF;
+                    if (doCast(target, spell))
+                    {
+                        if (spell == HOF)
+                        {
+                            if (target->ToCreature())
+                                HOF_Timer = 5000;//5 sec for bots
+                            else
+                                HOF_Timer = 15000;//improved
+                            if (me->getLevel() >= 40)
+                                HOFGuid = target->GetGUID();
+                        }
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(Player* hTarget, uint32 diff)
+        {
+            if (!HOS || HOS_Timer > diff || GC_Timer > diff || Rand() > 30) return;
+            if (IsCasting()) return;
+            if (Group* pGroup = hTarget->GetGroup())
+            {
+                bool bots = false;
+                float threat;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* HOSPlayer = itr->GetSource();
+                    if (!HOSPlayer) continue;
+                    if (HOSPlayer->HaveBot())
+                        bots = true;
+                    if (HOSPlayer->isDead()) continue;
+                    if (tank && HOSPlayer == tank) continue;//tanks do not need it
+                    if (master->GetMap() != HOSPlayer->FindMap() || !HOSPlayer->IsInWorld() || me->GetExactDist(HOSPlayer) > 30) continue;
+                    if (HasAuraName(HOSPlayer, HOS)) continue;
+                    AttackerSet h_attackers = HOSPlayer->getAttackers();
+                    if (h_attackers.empty()) continue;
+                    for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        threat = (*iter)->getThreatManager().getThreat(HOSPlayer);
+                        if (threat < 25.f) continue;//too small threat
+                        if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                        if (HOSPlayer->GetDistance((*iter)) > 10) continue;
+                        if (HOSTarget(HOSPlayer, diff)) return;
+                    }//end for
+                }//end for
+                if (!bots) return;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl) continue;
+                    if (!pl->HaveBot()) continue;
+                    if (master->GetMap() != pl->FindMap()) continue;
+                    if (!pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                    for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* cre = pl->GetBotMap(i)->_Cre();
+                        if (!cre || cre->isDead()) continue;
+                        if (tank && cre == tank) continue;
+                        if (me->GetExactDist(cre) > 30) continue;
+                        if (HasAuraName(cre, HOS)) continue;     //Alredy has HOS
+                        AttackerSet h_attackers = cre->getAttackers();
+                        if (h_attackers.empty()) continue;
+                        for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                        {
+                            if (!(*iter)) continue;
+                            if ((*iter)->isDead()) continue;
+                            if (!(*iter)->CanHaveThreatList()) continue;
+                            threat = (*iter)->getThreatManager().getThreat(cre);
+                            if (threat < 25.f) continue;//too small threat
+                            if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                            if (cre->GetDistance((*iter)) > 10) continue;
+                            if (HOSTarget(cre, diff)) return;
+                        }//end for
+                    }//end for
+                }//end for
+            }//end if
+        }
+
+        bool HOSTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!HOS || HOS_Timer > diff || GC_Timer > diff || Rand() > 50) return false;
+            if (tank && target == tank) return false;       //tanks do not need it
+            if (IsCasting()) return false;          //I'm busy casting
+            if (me->GetExactDist(target) > 30) return false; //too far away
+            if (HasAuraName(target, HOS)) return false;     //Alredy has HOS
+
+            AttackerSet h_attackers = target->getAttackers();
+            if (h_attackers.empty()) return false; //no aggro
+            float threat;
+            uint8 Tattackers = 0;
+            for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if ((*iter)->isDead()) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                threat = (*iter)->getThreatManager().getThreat(target);
+                if (threat < 25.f) continue;//too small threat
+                if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                if (target->GetDistance((*iter)) <= 10)
+                    Tattackers++;
+            }
+            if (Tattackers > 0 && doCast(target, HOS))
+            {
+                for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    if ((*iter)->getThreatManager().getThreat(target) > 0.f)
+                        (*iter)->getThreatManager().modifyThreatPercent(target, -(30 + 50*(target->HasAura(586))));//Fade
+                HOS_Timer = 25000 - 20000*IS_CREATURE_GUID(target->GetGUID());
+                return true;
+            }
+            return false;
+        }
+        //Holy_Shock setup (Modify HERE)
+        bool HS(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!HOLY_SHOCK || HS_Timer > diff || GC_Timer > diff) return false;
+            if (IsCasting()) return false;
+            if (target->GetTypeId() == TYPEID_PLAYER && (target->IsCharmed() || target->isPossessed())) return false;//do not damage friends under control
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (doCast(target, HOLY_SHOCK))
+            {
+                HS_Timer = target->ToCreature() ? 3500 : 5000;
+                return true;
+            }
+            return false;
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (hp > 97) return false;
+            //sLog->outBasic("HealTarget() by %s on %s", me->GetName().c_str(), target->GetName().c_str());
+            if (Rand() > 40 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 35) return false;
+            if (IsCasting()) return false;
+            if (HAND_OF_PROTECTION && BOP_Timer <= diff && IS_PLAYER_GUID(target->GetGUID()) && 
+                (master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID()) || target == master) && 
+                ((hp < 30 && !target->getAttackers().empty()) || (hp < 50 && target->getAttackers().size() > 3)) && 
+                me->GetExactDist(target) < 30 && 
+                !HasAuraName(target, HAND_OF_PROTECTION) && 
+                !HasAuraName(target, "Forbearance"))
+            {
+                if (doCast(target, HAND_OF_PROTECTION))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        me->MonsterWhisper("BOP on you!", target->GetGUID());
+                    BOP_Timer = 60000; //1 min
+                    if (!HasAuraName(target, "Forbearance"))
+                        me->AddAura(25771, target);//Forbearance
+                    if (HasAuraName(target, "Forbearance") && !target->HasAura(HAND_OF_PROTECTION))
+                        me->AddAura(HAND_OF_PROTECTION, target);
+                }
+                return true;
+            }
+            else if (hp < 20 && !HasAuraName(target, HAND_OF_PROTECTION))
+            {
+                // 20% to cast loh, else just do a Shock
+                switch (rand()%3)
+                {
+                    case 1:
+                        if (LAY_ON_HANDS && LOH_Timer <= diff && hp < 20 && 
+                            target->GetTypeId() == TYPEID_PLAYER && 
+                            (target->IsInCombat() || !target->getAttackers().empty()) && 
+                            !HasAuraName(target, "Forbearance"))
+                        {
+                            if (doCast(target, LAY_ON_HANDS))
+                            {
+                                me->MonsterWhisper("Lay of Hands on you!", target->GetGUID());
+                                LOH_Timer = 60000; //1 min
+                                return true;
+                            }
+                        }
+                    case 2:
+                        if (GC_Timer > diff) return false;
+                        if (FLASH_OF_LIGHT && doCast(target, FLASH_OF_LIGHT))
+                            return true;
+                    case 3:
+                        if (GC_Timer > diff) return false;
+                        if (HOLY_SHOCK && HS_Timer <= diff && HS(target, diff))
+                            return true;
+                }
+            }
+            if (GC_Timer > diff) return false;
+            Unit* u = target->GetVictim();
+            if (SACRED_SHIELD && SSH_Timer <= diff && target->GetTypeId() == TYPEID_PLAYER && 
+                (hp < 65 || target->getAttackers().size() > 1 || (u && u->GetMaxHealth() > target->GetMaxHealth()*10 && target->IsInCombat())) && 
+                !target->HasAura(SACRED_SHIELD) && 
+                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master))
+            {
+                Unit* aff = FindAffectedTarget(SACRED_SHIELD, me->GetGUID(), 50, 1);//use players since we cast only on them
+                if ((!aff || (aff->getAttackers().empty() && tank != aff)) && 
+                    doCast(target, SACRED_SHIELD))
+                {
+                    SSH_Timer = 3000;
+                    return true;
+                }
+            }
+            if (HOLY_SHOCK && (hp < 85 || GetLostHP(target) > 6000) && HS_Timer <= diff)
+                if (HS(target, diff))
+                    return true;
+            if ((hp > 35 && (hp < 75 || GetLostHP(target) > 8000)) || (!FLASH_OF_LIGHT && hp < 85))
+                if (doCast(target, HOLY_LIGHT))
+                    return true;
+            if (FLASH_OF_LIGHT && (hp < 90 || GetLostHP(target) > 1500))
+                if (doCast(target, FLASH_OF_LIGHT))
+                    return true;
+            return false;
+        }//end HealTarget
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, false);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (HOFGuid != 0)
+            {
+                if (Unit* ally = sObjectAccessor->FindUnit(HOFGuid))
+                    if (Aura* hof = ally->GetAura(HOF, me->GetGUID()))
+                        hof->SetDuration(hof->GetDuration() + 4000);//Guardian's Favor part 2 (handled separately)
+                HOFGuid = 0;
+            }
+            if (IAmDead()) return;
+            if (me->GetVictim())
+                DoMeleeAttackIfReady();
+            else
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            BreakCC(diff);
+            //HOFTarget(me, diff);//self stun cure goes FIRST
+            if (CCed(me)) return;
+
+            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(me) < 40 && DIVINE_PLEA && Divine_Plea_Timer <= diff)
+                if (doCast(me, DIVINE_PLEA))
+                    Divine_Plea_Timer = 45000;
+
+            CureTarget(me, CLEANSE, diff);//maybe unnecessary but this goes FIRST
+            HOFTarget(master, diff);//maybe unnecessary
+            CureTarget(master, CLEANSE, diff);//maybe unnecessary
+            BuffAndHealGroup(master, diff);
+            HOSTarget(master, diff);
+            CureGroup(master, CLEANSE, diff);
+            HOFGroup(master, diff);
+            HOSGroup(master, diff);
+
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff
+            if (SEAL_OF_COMMAND && GC_Timer <= diff && !me->HasAura(SEAL_OF_COMMAND) && 
+                doCast(me, SEAL_OF_COMMAND))
+                GC_Timer = 500;
+
+            // Heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(CLASS_PALADIN))
+                return;
+
+            Repentance(diff);
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted()) return;
+
+            RezGroup(REDEMPTION, master);
+
+            if (Feasting()) return;
+
+            //aura
+            if (master->IsAlive() && me->GetExactDist(master) < 20)
+            {
+                uint8 myAura;
+                if (me->HasAura(DEVOTION_AURA, me->GetGUID()))
+                    myAura = DEVOTIONAURA;
+                else if (me->HasAura(CONCENTRATION_AURA, me->GetGUID()))
+                    myAura = CONCENTRATIONAURA;
+                else myAura = NOAURA;
+
+                if (myAura != NOAURA)
+                    return; //do not bother
+
+                Aura* concAura = master->GetAura(CONCENTRATION_AURA);
+                Aura* devAura = master->GetAura(DEVOTION_AURA);
+                if (devAura && concAura) return;
+                if (devAura && devAura->GetCasterGUID() == me->GetGUID()) return;
+                if (concAura && concAura->GetCasterGUID() == me->GetGUID()) return;
+
+                if ((master->getClass() == CLASS_MAGE || 
+                    master->getClass() == CLASS_PRIEST || 
+                    master->getClass() == CLASS_WARLOCK || 
+                    master->getClass() == CLASS_DRUID || devAura) && 
+                    !concAura && 
+                    doCast(me, CONCENTRATION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+                if (!devAura && doCast(me, DEVOTION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead() || GC_Timer > diff || Rand() > 30) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+            if (HasAuraName(target, "Blessing of Wisdom", me->GetGUID()) || 
+                HasAuraName(target, "Blessing of Might", me->GetGUID()) || 
+                HasAuraName(target, "Blessing of Kings", me->GetGUID()) || 
+                HasAuraName(target, "Blessing of Sanctuary", me->GetGUID()))
+                return false;
+            //if (HasAuraName(target, "Greater Blessing of Wisdom", me->GetGUID()) || 
+            //    HasAuraName(target, "Greater Blessing of Might", me->GetGUID()) || 
+            //    HasAuraName(target, "Greater Blessing of Kings", me->GetGUID()) || 
+            //    HasAuraName(target, "Greater Blessing of Sanctuary", me->GetGUID()))
+            //    return false;
+            bool wisdom = HasAuraName(target, BLESSING_OF_WISDOM) || HasAuraName(target, "Greater Blessing of Wisdom");
+            bool kings = HasAuraName(target, BLESSING_OF_KINGS) || HasAuraName(target, "Greater Blessing of Kings");
+            bool sanctuary = HasAuraName(target, BLESSING_OF_SANCTUARY) || HasAuraName(target, "Greater Blessing of Sanctuary");
+            bool might = (HasAuraName(target, BLESSING_OF_MIGHT) || HasAuraName(target, "Greater Blessing of Might") || HasAuraName(target, "Battle Shout"));
+
+            uint8 Class = 0;
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                Class = target->ToPlayer()->getClass();
+            else if (target->ToCreature())
+                Class = target->ToCreature()->GetBotClass();
+            switch (Class)
+            {
+            case CLASS_PRIEST:
+                if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
+                    return true;
+                else if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                    return true;
+                break;
+            case CLASS_DEATH_KNIGHT:
+            case CLASS_WARRIOR:
+            case CLASS_PALADIN:
+            case CLASS_ROGUE:
+            case CLASS_HUNTER:
+            case CLASS_SHAMAN:
+                if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                    return true;
+                else if (!might && doCast(target, BLESSING_OF_MIGHT))
+                    return true;
+                else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                    return true;
+                else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                    return true;
+                break;
+            default:
+                if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                    return true;
+                else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                    return true;
+                else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                    return true;
+                else if (!might && doCast(target, BLESSING_OF_MIGHT))
+                    return true;
+                break;
+            }
+            return false;
+        }
+
+        void Repentance(uint32 diff, Unit* target = NULL)
+        {
+            if (target && Repentance_Timer < 25000 && doCast(target, REPENTANCE))
+            {
+                temptimer = GC_Timer;
+                Repentance_Timer = 45000;
+                GC_Timer = temptimer;
+                return;
+            }
+            if (REPENTANCE && Repentance_Timer <= diff)
+            {
+                Unit* u = FindRepentanceTarget();
+                if (u && u->GetVictim() != me && doCast(u, REPENTANCE))
+                    Repentance_Timer = 45000;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (Rand() > 60 || IsCasting()) return;
+            Unit* target = Repentance_Timer < 25000 ? FindCastingTarget(20, false, REPENTANCE) : NULL;
+            if (target)
+                Repentance(diff, target);//first check repentance
+            else if (TURN_EVIL && Turn_Evil_Timer < 1500)
+            {
+                target = FindCastingTarget(20, false, TURN_EVIL);
+                temptimer = GC_Timer;
+                if (target && doCast(target, TURN_EVIL, true))
+                    Turn_Evil_Timer = 3000;
+                GC_Timer = temptimer;
+            }
+            else if (HOLY_WRATH && Holy_Wrath_Timer < 8000)
+            {
+                target = FindCastingTarget(8, false, TURN_EVIL);//here we check target as with turn evil cuz of same requirements
+                temptimer = GC_Timer;
+                if (target && doCast(me, HOLY_WRATH))
+                    Holy_Wrath_Timer = 23000 - me->getLevel() * 100; //23 - 0...8 sec (15 sec on 80 as with glyph)
+                GC_Timer = temptimer;
+            }
+            else if (HAMMER_OF_JUSTICE && HOJ_Timer <= 7000/* && GC_Timer <= diff*/)
+            {
+                target = FindCastingTarget(10);
+                if (target && doCast(opponent, HAMMER_OF_JUSTICE))
+                    HOJ_Timer = 65000 - master->getLevel()*500; //25 sec on 80
+            }
+        }
+
+        void TurnEvil(uint32 diff)
+        {
+            if (!TURN_EVIL || Turn_Evil_Timer > diff || GC_Timer > diff || Rand() > 50 || 
+                FindAffectedTarget(TURN_EVIL, me->GetGUID(), 50))
+                return;
+            Unit* target = FindUndeadCCTarget(20, TURN_EVIL);
+            if (target && 
+                (target != me->GetVictim() || GetHealthPCT(me) < 70 || target->GetVictim() == master) && 
+                doCast(target, TURN_EVIL, true))
+            {
+                Turn_Evil_Timer = 3000;
+                return;
+            }
+            else
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) && 
+                !CCed(opponent) && 
+                opponent->GetVictim() && tank && opponent->GetVictim() != tank && opponent->GetVictim() != me && 
+                GetHealthPCT(me) < 90 && 
+                doCast(opponent, TURN_EVIL, true))
+                Turn_Evil_Timer = 3000;
+        }
+
+        void Wrath(uint32 diff)
+        {
+            if (!HOLY_WRATH || Holy_Wrath_Timer > diff || GC_Timer > diff || Rand() > 50)
+                return;
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) && 
+                me->GetExactDist(opponent) <= 8 && doCast(me, HOLY_WRATH))
+                Holy_Wrath_Timer = 23000 - me->getLevel() * 100; //23 - 0...8 sec (15 sec on 80 as with glyph)
+            else 
+            {
+                Unit* target = FindUndeadCCTarget(8, HOLY_WRATH);
+                if (target && doCast(me, HOLY_WRATH))
+                    Holy_Wrath_Timer = 23000 - me->getLevel() * 100; //23 - 0...8 sec (15 sec on 80 as with glyph)
+            }
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+            TurnEvil(diff);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+            //{ wait = 5; return; }
+
+            if (HOW && HOW_Timer <= diff && GC_Timer <= diff && Rand() < 50 && GetHealthPCT(opponent) < 20 && 
+                me->GetExactDist(opponent) < 30)
+                if (doCast(opponent, HOW))
+                    HOW_Timer = 6000; //6 sec
+
+            Unit* u = opponent->GetVictim();
+            if (Rand() < 50 && HANDOFRECKONING && Hand_Of_Reckoning_Timer <= diff && me->GetExactDist(opponent) < 30 && 
+                u && u != me && u != tank && (IsInBotParty(u) || tank == me))//No GCD
+            {
+                Creature* cre = opponent->ToCreature();
+                temptimer = GC_Timer;
+                if (((cre && cre->isWorldBoss() && !isMeleeClass(u->getClass())) || 
+                    GetHealthPCT(u) < GetHealthPCT(me) - 5 || tank == me) && 
+                    doCast(opponent, HANDOFRECKONING))
+                    Hand_Of_Reckoning_Timer = 8000 - (me == tank)*2000;
+                GC_Timer = temptimer;
+            }
+
+            if (Rand() < 20 && HAMMER_OF_JUSTICE && HOJ_Timer <= diff && GC_Timer <= diff && 
+                !CCed(opponent) && me->GetExactDist(opponent) < 10)
+                if (doCast(opponent, HAMMER_OF_JUSTICE))
+                    HOJ_Timer = 65000 - master->getLevel()*500; //25 sec on 80
+
+            if (JUDGEMENT_OF_LIGHT && JOL_Timer <= diff && GC_Timer <= diff && Rand() < 50 && 
+                me->GetExactDist(opponent) < 10 && me->HasAura(SEAL_OF_COMMAND))
+                if (doCast(opponent, JUDGEMENT_OF_LIGHT))
+                    JOL_Timer = 8000;
+
+            if (Rand() < 50 && CONSECRATION && Consecration_cd <= diff && GC_Timer <= diff && 
+                me->GetDistance(opponent) < 7 && !opponent->isMoving())
+                if (doCast(me, CONSECRATION))
+                    Consecration_cd = 8000;
+
+            if (Rand() < 25 && AVENGING_WRATH && AW_Timer <= diff && 
+                (opponent->GetHealth() > master->GetMaxHealth()*2/3))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, AVENGING_WRATH))
+                    AW_Timer = 60000; //1 min
+                GC_Timer = temptimer;
+            }
+
+            if (CRUSADER_STRIKE && Crusader_cd <= diff && GC_Timer <= diff && me->GetDistance(opponent) < 5)
+                if (doCast(opponent, CRUSADER_STRIKE))
+                    Crusader_cd = 12000 - me->getLevel() * 100;//4 sec on 80
+
+            if (EXORCISM && Exorcism_Timer <= diff && GC_Timer <= diff && me->GetExactDist(opponent) < 30 && 
+                (tank != me || opponent->GetVictim() == me || opponent->IsVehicle() || opponent->ToPlayer()))
+                if (doCast(opponent, EXORCISM/*, true)*/))//possible instacast here
+                    Exorcism_Timer = 15000;
+
+            Wrath(diff);
+
+            if (DIVINE_STORM && DS_Timer <= diff && GC_Timer <= diff && me->GetExactDist(opponent) < 7)
+                if (doCast(opponent, DIVINE_STORM))
+                    DS_Timer = 10000 - me->getLevel()/4 * 100; //10 - 2 sec
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Fanaticism: 18% additional critical chance for all Judgements (not shure which check is right)
+                if (lvl >= 45 && (spellInfo->Category == SPELLCATEGORY_JUDGEMENT || spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT))
+                    aftercrit += 18.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+            //Sanctity of Battle: 15% bonus damage for Exorcism and Crusader Strike
+            if (lvl >= 25 && spellId == EXORCISM)
+                pctbonus += 0.15f;
+            //The Art of War (damage part): 10% bonus damage for Judgements, Crusader Strike and Divine Storm
+            if (lvl >= 40 &&
+                (spellInfo->Category == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT || 
+                spellId == CRUSADER_STRIKE ||
+                spellId == DIVINE_STORM))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Sanctified Wrath: 50% additional critical chance for Hammer of Wrath
+                if (lvl >= 45 && spellId == HOW)
+                    aftercrit += 50.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Crusader_cd = 0;
+            Consecration_cd = 0;
+            LOH_Timer = 0;
+            HOJ_Timer = 0;
+            HOF_Timer = 0;
+            JOL_Timer = 0;
+            HS_Timer = 0;
+            BOP_Timer = 0;
+            HOW_Timer = 0;
+            DS_Timer = 0;
+            AW_Timer = 10000;
+            HOS_Timer = 0;
+            SSH_Timer = 0;
+            Hand_Of_Reckoning_Timer = 0;
+            Divine_Plea_Timer = 0;
+            Repentance_Timer = 0;
+            Exorcism_Timer = 0;
+            Holy_Wrath_Timer = 0;
+            Turn_Evil_Timer = 0;
+
+            HOFGuid = 0;
+
+            if (master)
+            {
+                setStats(CLASS_PALADIN, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_PALADIN);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (HOW_Timer > diff)                   HOW_Timer -= diff;
+            if (DS_Timer > diff)                    DS_Timer -= diff;
+            if (AW_Timer > diff)                    AW_Timer -= diff;
+            if (HOS_Timer > diff)                   HOS_Timer -= diff;
+            if (HS_Timer > diff)                    HS_Timer -= diff;
+            if (BOP_Timer > diff)                   BOP_Timer -= diff;
+            if (Consecration_cd > diff)             Consecration_cd -= diff;
+            if (Crusader_cd > diff)                 Crusader_cd -= diff;
+            if (LOH_Timer > diff)                   LOH_Timer -= diff;
+            if (HOJ_Timer > diff)                   HOJ_Timer -= diff;
+            if (HOF_Timer > diff)                   HOF_Timer -= diff;
+            if (JOL_Timer > diff)                   JOL_Timer -= diff;
+            if (SSH_Timer > diff)                   SSH_Timer -= diff;
+            if (Hand_Of_Reckoning_Timer > diff)     Hand_Of_Reckoning_Timer -= diff;
+            if (Divine_Plea_Timer > diff)           Divine_Plea_Timer -= diff;
+            if (Repentance_Timer > diff)            Repentance_Timer -= diff;
+            if (Exorcism_Timer > diff)              Exorcism_Timer -= diff;
+            if (Holy_Wrath_Timer > diff)            Holy_Wrath_Timer -= diff;
+            if (Turn_Evil_Timer > diff)             Turn_Evil_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            FLASH_OF_LIGHT                          = InitSpell(me, FLASH_OF_LIGHT_1);
+            HOLY_LIGHT                              = InitSpell(me, HOLY_LIGHT_1);
+            LAY_ON_HANDS                            = InitSpell(me, LAY_ON_HANDS_1);
+            SACRED_SHIELD                           = InitSpell(me, SACRED_SHIELD_1);
+            HOLY_SHOCK                  = lvl >= 40 ? InitSpell(me, HOLY_SHOCK_1) : 0;
+            CLEANSE                                 = InitSpell(me, CLEANSE_1);
+            REDEMPTION                              = InitSpell(me, REDEMPTION_1);
+            HAMMER_OF_JUSTICE                       = InitSpell(me, HAMMER_OF_JUSTICE_1);
+            REPENTANCE                  = lvl >= 45 ? REPENTANCE_1 : 0;
+            TURN_EVIL                               = InitSpell(me, TURN_EVIL_1);
+            HOLY_WRATH                              = InitSpell(me, HOLY_WRATH_1);
+            EXORCISM                                = InitSpell(me, EXORCISM_1);
+            SEAL_OF_COMMAND             = lvl >= 25 ? SEAL_OF_COMMAND_1 : 0;
+            CRUSADER_STRIKE             = lvl >= 20 ? CRUSADER_STRIKE_1 : 0;//exception
+            JUDGEMENT_OF_LIGHT                      = InitSpell(me, JUDGEMENT_OF_LIGHT_1);
+            CONSECRATION                            = InitSpell(me, CONSECRATION_1);
+            DIVINE_STORM                = lvl >= 60 ? DIVINE_STORM_1 : 0;
+            HOW /*Hammer of Wrath*/                 = InitSpell(me, HOW_1);
+            AVENGING_WRATH                          = InitSpell(me, AVENGING_WRATH_1);
+            BLESSING_OF_MIGHT                       = InitSpell(me, BLESSING_OF_MIGHT_1);
+            BLESSING_OF_WISDOM                      = InitSpell(me, BLESSING_OF_WISDOM_1);
+            BLESSING_OF_KINGS                       = InitSpell(me, BLESSING_OF_KINGS_1);
+            BLESSING_OF_SANCTUARY       = lvl >= 30 ? BLESSING_OF_SANCTUARY_1 : 0;
+            DEVOTION_AURA                           = InitSpell(me, DEVOTION_AURA_1);
+            CONCENTRATION_AURA                      = InitSpell(me, CONCENTRATION_AURA_1);
+            DIVINE_PLEA                             = InitSpell(me, DIVINE_PLEA_1);
+            HAND_OF_PROTECTION                      = InitSpell(me, HAND_OF_PROTECTION_1);
+            HOF/*Hand of Freedom*/                  = InitSpell(me, HOF_1);
+            HOS /*Hand of salvation*/               = InitSpell(me, HOS_1);
+            HANDOFRECKONING                         = InitSpell(me, HANDOFRECKONING_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            //1 - SPD 3% crit 3%
+            if (level >= 78)
+                RefreshAura(SPELLDMG,5); //+15%
+            else if (level >= 75)
+                RefreshAura(SPELLDMG,4); //+12%
+            else if (level >= 55)
+                RefreshAura(SPELLDMG,3); //+9%
+            else if (level >= 35)
+                RefreshAura(SPELLDMG,2); //+6%
+            else if (level >= 15)
+                RefreshAura(SPELLDMG); //+3%
+            //2 - SPD 6%
+            if (level >= 55)
+                RefreshAura(SPELLDMG2,3); //+18%
+            else if (level >= 35)
+                RefreshAura(SPELLDMG2,2); //+12%
+            else if (level >= 15)
+                RefreshAura(SPELLDMG2); //+6%
+            //Talents
+            if (level >= 55)
+                RefreshAura(PURE);
+            if (level >= 35)
+                RefreshAura(WISE);
+            if (level >= 50)
+                RefreshAura(RECKONING5); //10%
+            else if (level >= 45)
+                RefreshAura(RECKONING4); //8%
+            else if (level >= 40)
+                RefreshAura(RECKONING3); //6%
+            else if (level >= 35)
+                RefreshAura(RECKONING2); //4%
+            else if (level >= 30)
+                RefreshAura(RECKONING1); //2%
+            //if (level >= 50)
+            //    RefreshAura(RIGHTEOUS_VENGEANCE3);
+            //else if (level >= 47)
+            //    RefreshAura(RIGHTEOUS_VENGEANCE2);
+            //else if (level >= 45)
+            //    RefreshAura(RIGHTEOUS_VENGEANCE1);
+            if (level >= 30)
+                RefreshAura(VENGEANCE3);
+            else if (level >= 27)
+                RefreshAura(VENGEANCE2);
+            else if (level >= 25)
+                RefreshAura(VENGEANCE1);
+            if (level >= 60)
+                RefreshAura(SHOFL3);
+            else if (level >= 55)
+                RefreshAura(SHOFL2);
+            else if (level >= 50)
+                RefreshAura(SHOFL1);
+            if (level >= 45)
+                RefreshAura(SACRED_CLEANSING);
+            if (level >= 35)
+                RefreshAura(DIVINE_PURPOSE);
+            if (level >= 25)
+                RefreshAura(VINDICATION2);
+            else if (level >= 20)
+                RefreshAura(VINDICATION1);
+            if (level >= 30)
+                RefreshAura(LAYHANDS);
+            if (level >= 20)
+                RefreshAura(FANATICISM,2); //-60% aggro
+            if (level >= 15)
+                RefreshAura(GLYPH_HOLY_LIGHT); //10% heal
+            //if (level >= 70)
+            //    RefreshAura(PALADIN_T9_2P_BONUS); //Righteous Vengeance Crits
+        }
+
+    private:
+        uint32
+   /*Heals*/FLASH_OF_LIGHT, HOLY_LIGHT, HOLY_SHOCK, LAY_ON_HANDS, SACRED_SHIELD,
+      /*CC*/HAMMER_OF_JUSTICE, REPENTANCE, TURN_EVIL,
+  /*Damage*/SEAL_OF_COMMAND, HOLY_WRATH, EXORCISM, CRUSADER_STRIKE, JUDGEMENT_OF_LIGHT,
+  /*Damage*/CONSECRATION, DIVINE_STORM, AVENGING_WRATH, HOW,//hammer of wrath
+/*Blessing*/BLESSING_OF_MIGHT, BLESSING_OF_WISDOM, BLESSING_OF_KINGS, BLESSING_OF_SANCTUARY,
+   /*Auras*/DEVOTION_AURA, CONCENTRATION_AURA,
+   /*Hands*/HAND_OF_PROTECTION, HOF, HOS, HANDOFRECKONING,
+    /*Misc*/CLEANSE, REDEMPTION, DIVINE_PLEA;
+        //Timers
+        uint32 Crusader_cd, Consecration_cd, Exorcism_Timer, Holy_Wrath_Timer, JOL_Timer, HOF_Timer,
+            HS_Timer, HOW_Timer, DS_Timer, HOS_Timer, SSH_Timer, Hand_Of_Reckoning_Timer, Turn_Evil_Timer,
+            LOH_Timer, HOJ_Timer, BOP_Timer, AW_Timer, Divine_Plea_Timer, Repentance_Timer;
+        uint64 HOFGuid;
+
+        enum PaladinBaseSpells// all orignals
+        {
+            FLASH_OF_LIGHT_1                    = 19750,
+            HOLY_LIGHT_1                        = 635,
+            LAY_ON_HANDS_1                      = 633,
+            REDEMPTION_1                        = 7328,
+            HOF_1  /*Hand of Freedom*/          = 1044,
+            SACRED_SHIELD_1                     = 53601,
+            HOLY_SHOCK_1                        = 20473,
+            CLEANSE_1                           = 4987,
+            HAND_OF_PROTECTION_1                = 1022,
+            HOS_1 /*Hand of salvation*/         = 1038,
+            SEAL_OF_COMMAND_1                   = 20375,
+            HANDOFRECKONING_1                   = 62124,
+            DIVINE_PLEA_1                       = 54428,
+            REPENTANCE_1                        = 20066,
+            TURN_EVIL_1                         = 10326,
+            CRUSADER_STRIKE_1                   = 35395,
+            JUDGEMENT_OF_LIGHT_1                = 20271,
+            CONSECRATION_1                      = 26573,
+            HAMMER_OF_JUSTICE_1                 = 853,
+            DIVINE_STORM_1                      = 53385,
+            HOW_1   /*Hammer of Wrath*/         = 24275,
+            EXORCISM_1                          = 879,
+            HOLY_WRATH_1                        = 2812,
+            AVENGING_WRATH_1                    = 31884,
+            BLESSING_OF_MIGHT_1                 = 19740,
+            BLESSING_OF_WISDOM_1                = 19742,
+            BLESSING_OF_KINGS_1                 = 20217,
+            BLESSING_OF_SANCTUARY_1             = 20911,
+            DEVOTION_AURA_1                     = 465,
+            CONCENTRATION_AURA_1                = 19746,
+        };
+        enum PaladinPassives
+        {
+        //Talents
+            DIVINE_PURPOSE                      = 31872,
+            PURE/*Judgements of the Pure*/      = 54155,
+            WISE/*Judgements of the Wise*/      = 31878,
+            SACRED_CLEANSING                    = 53553,//rank 3
+            RECKONING1                          = 20177,
+            RECKONING2                          = 20179,
+            RECKONING3                          = 20181,
+            RECKONING4                          = 20180,
+            RECKONING5                          = 20182,
+            VINDICATION1                        = 9452 ,//rank 1
+            VINDICATION2                        = 26016,//rank 2
+            LAYHANDS  /*Improved LOH rank 2*/   = 20235,
+            FANATICISM                          = 31881,//rank 3
+            //RIGHTEOUS_VENGEANCE1                = 53380,//rank 1
+            //RIGHTEOUS_VENGEANCE2                = 53381,//rank 2
+            //RIGHTEOUS_VENGEANCE3                = 53382,//rank 3
+            VENGEANCE1                          = 20049,//rank 1
+            VENGEANCE2                          = 20056,//rank 2
+            VENGEANCE3                          = 20057,//rank 3
+            SHOFL1      /*Sheath of Light*/     = 53501,//rank 1
+            SHOFL2                              = 53502,//rank 2
+            SHOFL3                              = 53503,//rank 3
+        //Glyphs
+            GLYPH_HOLY_LIGHT                    = 54937,
+        //other
+            SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            SPELLDMG2/*Earth and Moon - druid*/ = 48511,//rank3 6% dam
+            //PALADIN_T9_2P_BONUS                 = 67188,//Righteous Vengeance Crits
+        };
+
+        enum PaladinSpecial
+        {
+            NOAURA,
+            DEVOTIONAURA,
+            CONCENTRATIONAURA,
+        };
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
new file mode 100644
index 0000000..9c7aa1b
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
@@ -0,0 +1,859 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+//#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Priest NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 50%
+TODO: maybe remove Divine Spirit or so, too much buffs
+*/
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new priest_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct priest_botAI : public bot_minion_ai
+    {
+        priest_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_PRIEST) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        bool MassGroupHeal(Player* player, uint32 diff)
+        {
+            if (!PRAYER_OF_HEALING && !DIVINE_HYMN) return false;
+            if (!player->GetGroup()) return false;
+            if (Rand() > 30) return false;
+            if (IsCasting()) return false;
+
+            if (DIVINE_HYMN && Divine_Hymn_Timer <= diff)
+            {
+                Group* gr = player->GetGroup();
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || 
+                        !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() || 
+                        tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 35) continue;
+                        uint8 pct = 50 + tPlayer->getAttackers().size()*10;
+                        pct = pct < 80 ? pct : 80;
+                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
+                            ++LHPcount;
+                    }
+                    if (LHPcount > 1)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && GetHealthPCT(bot) < 40 && me->GetExactDist(bot) < 30)
+                            ++LHPcount;
+                        if (LHPcount > 1)
+                            break;
+                    }
+                }
+                if (LHPcount > 1 && doCast(me, DIVINE_HYMN))
+                {
+                    Divine_Hymn_Timer = 180000; //3 min
+                    return true;
+                }
+            }
+            if (PRAYER_OF_HEALING)
+            {
+                Group* gr = player->GetGroup();
+                Unit* castTarget = NULL;
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->GetMap() || 
+                        !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() || 
+                        tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 25) continue;
+                        if (GetHealthPCT(tPlayer) < 85)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(tPlayer) < lowestPCT)
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 2)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && GetHealthPCT(bot) < 70 && me->GetExactDist(bot) < 15)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            lowestPCT = GetHealthPCT(bot);
+                            castTarget = bot;
+                        }
+                        if (LHPcount > 2)
+                            break;
+                    }
+                }
+                if (LHPcount > 2 && castTarget && doCast(castTarget, PRAYER_OF_HEALING))
+                    return true;
+            }
+            return false;
+        }//end MassGroupHeal
+
+        bool ShieldTarget(Unit* target, uint32 diff)
+        {
+            if (PWS_Timer > diff || Rand() > 50 || IsCasting()) return false;
+            if (target->HasAura(WEAKENED_SOUL)) return false;
+            if (HasAuraName(target, PW_SHIELD)) return false;
+            //if (me->GetExactDist(target) > 40) return false;//checked already in HealTarget()
+
+            if (!target->getAttackers().empty() || GetHealthPCT(target) < 33 || target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+            {
+                if (doCast(target, PW_SHIELD))
+                {
+                    if (me->getLevel() >= 30 || // improved
+                        (target->ToCreature() && target->ToCreature()->GetIAmABot()))
+                        PWS_Timer = 0;
+                    else
+                        PWS_Timer = 4000;
+                    GC_Timer = 800;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            GetInPosition(force, true);
+            SetBotCommandState(COMMAND_ATTACK);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->GetVictim())
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            Disperse(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+            DoDevCheck(diff);
+
+            if (GetManaPCT(me) < 33 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            //check possible fear
+            doDefend(diff);
+            //buff and heal master's group
+            MassGroupHeal(master, diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, DISPELMAGIC, diff);
+            CureGroup(master, CURE_DISEASE, diff);
+            //ShieldGroup(master);
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckDispel(diff);
+                CheckSilence(diff);
+            }
+
+            if (me->IsInCombat())
+                CheckShackles(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_PRIEST))
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (GetHealthPCT(master) > 90 && GetManaPCT(me) > 35 && GetHealthPCT(me) > 90 && 
+                (m_attackers.size() < 4 || b_attackers.size() + m_attackers.size() < 3) && 
+                !IsCasting())
+                //general rule
+            {
+                opponent = me->GetVictim();
+                if (opponent)
+                {
+                    if (!IsCasting())
+                        StartAttack(opponent);
+                }
+                else
+                    return;
+                bool isBoss = opponent->GetTypeId() == TYPEID_UNIT ? opponent->ToCreature()->isWorldBoss() : false;
+                if (me->GetExactDist(opponent) < 30)
+                {
+                    if (SW_DEATH && Rand() < 50 && SW_Death_Timer <= diff && 
+                        (GetHealthPCT(opponent) < 15 || opponent->GetHealth() < me->GetMaxHealth()/6) && 
+                        doCast(opponent, SW_DEATH))
+                    {
+                        SW_Death_Timer = 10000;
+                        return;
+                    }
+                    if (Rand() < 30 && GC_Timer <= diff && !opponent->HasAura(SW_PAIN, me->GetGUID()) && 
+                        opponent->GetHealth() > me->GetMaxHealth()/4 && 
+                        doCast(opponent, SW_PAIN))
+                        return;
+                    if (VAMPIRIC_TOUCH && GC_Timer <= diff && !isBoss && Rand() < 50 && !opponent->HasAura(VAMPIRIC_TOUCH, me->GetGUID()) && 
+                        opponent->GetHealth() > me->GetMaxHealth()/4 && 
+                        doCast(opponent, VAMPIRIC_TOUCH))
+                        return;
+                    if (DEVOURING_PLAGUE && GC_Timer <= diff && !isBoss && Rand() < 30 && !Devcheck && !opponent->HasAura(DEVOURING_PLAGUE, me->GetGUID()) && 
+                        opponent->GetHealth() > me->GetMaxHealth()/3 && 
+                        doCast(opponent, DEVOURING_PLAGUE))
+                        return;
+                    if (Mind_Blast_Timer <= diff && GC_Timer <= 300 && !isBoss && Rand() < 50 && (!VAMPIRIC_TOUCH || HasAuraName(opponent, VAMPIRIC_TOUCH)) && 
+                        doCast(opponent, MIND_BLAST))
+                    {
+                        Mind_Blast_Timer = 7500 - me->getLevel()/4*100;//5.5 sec on 80 lvl (as improved)
+                        return;
+                    }
+                    if (MIND_FLAY && Mind_Flay_Timer <= diff && GC_Timer <= 300 && !isBoss && !me->isMoving() && Rand() < 40 && me->GetExactDist(opponent) < 30 && 
+                        
+                        (opponent->isMoving() || opponent->GetHealth() < me->GetMaxHealth()/3 || 
+                        (opponent->HasAura(SW_PAIN, me->GetGUID()) && 
+                        opponent->HasAura(DEVOURING_PLAGUE, me->GetGUID()))) && 
+                        doCast(opponent, MIND_FLAY))
+                    {
+                        Mind_Flay_Timer = 3000;
+                        return;
+                    }
+                    if (MIND_SEAR && GC_Timer <= diff && !me->isMoving() && !opponent->isMoving() && Rand() < 50 && 
+                        opponent->HasAura(SW_PAIN, me->GetGUID()) && 
+                        opponent->HasAura(DEVOURING_PLAGUE, me->GetGUID()))
+                        if (Unit* u = FindSplashTarget(30, opponent))
+                            if (doCast(u, MIND_SEAR))
+                                return;
+                }//endif opponent
+            }//endif damage
+            //check horror after dots/damage
+            if (PSYCHIC_HORROR && Psychic_Horror_Timer <= diff && Rand() < 30 && 
+                opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                opponent->GetHealth() > me->GetMaxHealth()/5 && 
+                me->GetExactDist(opponent) < 30 && !HasAuraName(opponent, PSYCHIC_HORROR) && 
+                !CCed(opponent))
+            {
+                if (doCast(opponent, PSYCHIC_HORROR))
+                {
+                    Psychic_Horror_Timer = 60000;
+                    return;
+                }
+            }
+        }//end UpdateAI
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (hp > 98) return false;
+            if (!target || target->isDead() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
+
+            //GUARDIAN SPIRIT
+            if (GUARDIAN_SPIRIT && Guardian_Spirit_Timer <= diff && Rand() < 70 && 
+                target->IsInCombat() && !target->getAttackers().empty() && 
+                hp < (5 + std::min(20, uint8(target->getAttackers().size())*5)) && 
+                (master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID()) || target == master) && 
+                !target->HasAura(GUARDIAN_SPIRIT))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(target, GUARDIAN_SPIRIT))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        if (target->HasAura(GUARDIAN_SPIRIT, me->GetGUID()))
+                            me->MonsterWhisper("Guardin Spirit on you!", target->GetGUID());
+                        Guardian_Spirit_Timer = 90000;//1.5 min
+                    }
+                    else
+                        Guardian_Spirit_Timer = 30000;//30 sec for creatures
+                    GC_Timer = temptimer;
+                    return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            //PAIN SUPPRESSION
+            if (hp < 35 && PAIN_SUPPRESSION && Pain_Suppression_Timer <= diff && Rand() < 50 && 
+                (target->IsInCombat() || !target->getAttackers().empty()) && 
+                !target->HasAura(PAIN_SUPPRESSION))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, PAIN_SUPPRESSION))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        if (target->HasAura(PAIN_SUPPRESSION, me->GetGUID()))
+                            me->MonsterWhisper("Pain Suppression on you!", target->GetGUID());
+                        Pain_Suppression_Timer = 45000;//45 sec
+                    }
+                    else
+                        Pain_Suppression_Timer = 15000;//15 sec for creatures
+                    GC_Timer = temptimer;
+                    return true;
+                }
+            }
+
+            //Now Heals Requires GCD
+            if ((hp < 80 || !target->getAttackers().empty()) && 
+                PWS_Timer <= diff && ShieldTarget(target, diff))
+                return true;
+
+            //PENANCE/Greater Heal
+            if (hp < 75 || GetLostHP(target) > 4000)
+            {
+                if (PENANCE && Penance_Timer <= diff && 
+                    !me->isMoving() && //better check then stop moving every try (furthermore it doesn't always work properly)
+                    (target->GetTypeId() != TYPEID_PLAYER || !(target->ToPlayer()->IsCharmed() || target->ToPlayer()->isPossessed())) && 
+                    doCast(target, PENANCE))
+                {
+                    Penance_Timer = 8000;
+                    return true;
+                }
+                else if (Heal_Timer <= diff && GC_Timer <= diff && hp > 50 && doCast(target, HEAL))
+                {
+                    Heal_Timer = 2500;
+                    return true;
+                }
+            }
+            //Flash Heal
+            if (((hp > 75 && hp < 90) || hp < 50 || GetLostHP(target) > 1500) && 
+                GC_Timer <= diff && FLASH_HEAL && 
+                doCast(target, FLASH_HEAL))
+                    return true;
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = tank == target && boss;
+            //Renew
+            if (((hp < 98 && hp > 70) || GetLostHP(target) > 500 || tanking) && 
+                !HasAuraName(target, RENEW, me->GetGUID()) && 
+                GC_Timer <= diff && doCast(target, RENEW))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 60) return false;
+            if (!target || target->isDead() || me->GetExactDist(target) > 30) return false;
+
+            if (Fear_Ward_Timer <= diff && !HasAuraName(target, FEAR_WARD) && doCast(target, FEAR_WARD))
+            {
+                Fear_Ward_Timer = target->GetTypeId() == TYPEID_PLAYER ? 60000 : 30000;//30sec for bots
+                GC_Timer = 800;
+                return true;
+            }
+
+            if (target == me)
+            {
+                if (!me->HasAura(INNER_FIRE) && doCast(me, INNER_FIRE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+                if (VAMPIRIC_EMBRACE && !me->HasAura(VAMPIRIC_EMBRACE) && doCast(me, VAMPIRIC_EMBRACE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (Rand() < 70 && !HasAuraName(target, PW_FORTITUDE) && doCast(target, PW_FORTITUDE))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            if (Rand() < 30 && !HasAuraName(target, SHADOW_PROTECTION) && doCast(target, SHADOW_PROTECTION))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            if (Rand() < 30 && !HasAuraName(target, DIVINE_SPIRIT) && doCast(target, DIVINE_SPIRIT))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (Rand() > 50 || GC_Timer > diff || me->IsMounted()) return;
+
+            RezGroup(RESURRECTION, master);
+
+            if (Feasting()) return;
+
+            if (BuffTarget(master, diff))
+                return;
+            if (BuffTarget(me, diff))
+                return;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (CheckDispelTimer > diff || Rand() > 25 || IsCasting())
+                return;
+            Unit* target = FindHostileDispelTarget();
+            if (target && doCast(target, DISPELMAGIC))
+            {
+                CheckDispelTimer = 3000;
+                GC_Timer = 500;
+            }
+            CheckDispelTimer = 1000;
+        }
+
+        void CheckShackles(uint32 diff)
+        {
+            if (!SHACKLE_UNDEAD || ShackleTimer > diff || GC_Timer > diff || IsCasting())
+                return;
+            if (FindAffectedTarget(SHACKLE_UNDEAD, me->GetGUID()))
+                return;
+            Unit* target = FindUndeadCCTarget(30, SHACKLE_UNDEAD);
+            if (target && doCast(target, SHACKLE_UNDEAD))
+            {
+                ShackleTimer = 3000;
+                GC_Timer = 800;
+            }
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (IsCasting()) return;
+            temptimer = GC_Timer;
+            if (SILENCE && Silence_Timer <= diff)
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, SILENCE))
+                        Silence_Timer = 30000;
+            }
+            else if (PSYCHIC_HORROR && Psychic_Horror_Timer <= 20000)
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, PSYCHIC_HORROR))
+                        Psychic_Horror_Timer = 60000;
+            }
+            GC_Timer = temptimer;
+        }
+
+        void doDefend(uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            //fear master's attackers
+            if (!m_attackers.empty() && PSYCHIC_SCREAM && Fear_Timer <= diff && 
+                (master != tank || GetHealthPCT(master) < 75))
+            {
+                uint8 tCount = 0;
+                for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                {
+                    if (!(*iter)) continue;
+                    if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                    if (me->GetExactDist((*iter)) > 7) continue;
+                    if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                    if (me->IsValidAttackTarget(*iter))
+                        ++tCount;
+                }
+                if (tCount > 1 && doCast(me, PSYCHIC_SCREAM))
+                {
+                    Fear_Timer = 24000;//with improved 24 sec
+                    return;
+                }
+            }
+
+            // Defend myself (psychic horror)
+            if (!b_attackers.empty() && PSYCHIC_SCREAM && Fear_Timer <= diff)
+            {
+                uint8 tCount = 0;
+                for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter)) continue;
+                    if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                    if (me->GetExactDist((*iter)) > 7) continue;
+                    if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                    if (me->IsValidAttackTarget(*iter))
+                        ++tCount;
+                }
+                if (tCount > 0 && doCast(me, PSYCHIC_SCREAM))
+                {
+                    Fear_Timer = 24000;//with improved 24 sec
+                    return;
+                }
+            }
+            // Heal myself
+            if (GetHealthPCT(me) < 99 && !b_attackers.empty())
+            {
+                if (ShieldTarget(me, diff)) return;
+
+                if (FADE && Fade_Timer <= diff && me->IsInCombat())
+                {
+                    if (b_attackers.empty()) return; //no aggro
+                    uint8 Tattackers = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->ToCreature()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if (me->GetExactDist((*iter)) <= 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, FADE))
+                        {
+                            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                                if ((*iter)->getThreatManager().getThreat(me) > 0.f)
+                                    (*iter)->getThreatManager().modifyThreatPercent(me, -50);
+                            Fade_Timer = 6000;
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                if (GetHealthPCT(me) < 90 && HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            }
+        }
+
+        void DoDevCheck(uint32 diff)
+        {
+            if (DevcheckTimer <= diff)
+            {
+                Devcheck = FindAffectedTarget(DEVOURING_PLAGUE, me->GetGUID());
+                DevcheckTimer = 5000;
+            }
+        }
+
+        void Disperse(uint32 diff)
+        {
+            if (!DISPERSION || GC_Timer > diff || Dispersion_Timer > diff || IsCasting()) return;
+            //attackers case
+            if ((me->getAttackers().size() > 3 && Fade_Timer > diff && GetHealthPCT(me) < 90) || 
+                (GetHealthPCT(me) < 20 && me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) || 
+                (GetManaPCT(me) < 30) || 
+                (me->getAttackers().size() > 1 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, DISPERSION))
+                    Dispersion_Timer = 75000;//with glyph
+                GC_Timer = temptimer;
+                return;
+            }
+            Dispersion_Timer = 2000;//fail
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Divine_Hymn_Timer = 0;
+            Pain_Suppression_Timer = 0;
+            Guardian_Spirit_Timer = 0;
+            PWS_Timer = 0;
+            Fade_Timer = 0;
+            Fear_Timer = 0;
+            Mind_Blast_Timer = 0;
+            SW_Death_Timer = 0;
+            Fear_Ward_Timer = 0;
+            Psychic_Horror_Timer = 0;
+            Silence_Timer = 0;
+            Dispersion_Timer = 0;
+            Mind_Flay_Timer = 0;
+            Penance_Timer = 0;
+            CheckDispelTimer = 0;
+            ShackleTimer = 0;
+            DevcheckTimer = 20;
+            Devcheck = false;
+
+            if (master)
+            {
+                setStats(CLASS_PRIEST, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_PRIEST);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Heal_Timer > diff)                 Heal_Timer -= diff;
+            if (Fade_Timer > diff)                 Fade_Timer -= diff;
+            if (Divine_Hymn_Timer > diff)          Divine_Hymn_Timer -= diff;
+            if (Pain_Suppression_Timer > diff)     Pain_Suppression_Timer -= diff;
+            if (Guardian_Spirit_Timer > diff)      Guardian_Spirit_Timer -= diff;
+            if (PWS_Timer > diff)                  PWS_Timer -= diff;
+            if (Fear_Timer > diff)                 Fear_Timer -= diff;
+            if (Mind_Blast_Timer > diff)           Mind_Blast_Timer -= diff;
+            if (SW_Death_Timer > diff)             SW_Death_Timer -= diff;
+            if (Fear_Ward_Timer > diff)            Fear_Ward_Timer -= diff;
+            if (Psychic_Horror_Timer > diff)       Psychic_Horror_Timer -= diff;
+            if (Silence_Timer > diff)              Silence_Timer -= diff;
+            if (Dispersion_Timer > diff)           Dispersion_Timer -= diff;
+            if (Mind_Flay_Timer > diff)            Mind_Flay_Timer -= diff;
+            if (Penance_Timer > diff)              Penance_Timer -= diff;
+            if (CheckDispelTimer > diff)           CheckDispelTimer -= diff;
+            if (ShackleTimer > diff)               ShackleTimer -= diff;
+            if (DevcheckTimer > diff)              DevcheckTimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            DISPELMAGIC                = lvl >= 70 ? MASS_DISPEL_1 : InitSpell(me, DISPEL_MAGIC_1);
+            CURE_DISEASE                            = InitSpell(me, CURE_DISEASE_1);
+            FEAR_WARD                               = InitSpell(me, FEAR_WARD_1);
+  /*Talent*/PAIN_SUPPRESSION            = lvl >= 50 ? PAIN_SUPPRESSION_1 : 0;
+            PSYCHIC_SCREAM                          = InitSpell(me, PSYCHIC_SCREAM_1);
+            FADE                                    = InitSpell(me, FADE_1);
+  /*Talent*/PSYCHIC_HORROR              = lvl >= 50 ? PSYCHIC_HORROR_1 : 0;
+  /*Talent*/SILENCE                     = lvl >= 30 ? SILENCE_1 : 0;
+  /*Talent*/PENANCE                     = lvl >= 60 ? InitSpell(me, PENANCE_1) : 0;
+  /*Talent*/VAMPIRIC_EMBRACE            = lvl >= 30 ? VAMPIRIC_EMBRACE_1 : 0;
+  /*Talent*/DISPERSION                  = lvl >= 60 ? DISPERSION_1 : 0;
+            MIND_SEAR                               = InitSpell(me, MIND_SEAR_1);
+  /*Talent*/GUARDIAN_SPIRIT             = lvl >= 60 ? GUARDIAN_SPIRIT_1 : 0;
+            SHACKLE_UNDEAD                          = InitSpell(me, SHACKLE_UNDEAD_1);
+            HEAL                        = lvl >= 40 ? InitSpell(me, GREATER_HEAL_1) : lvl >= 16 ? InitSpell(me, NORMAL_HEAL_1) : InitSpell(me, LESSER_HEAL_1);
+            RENEW                                   = InitSpell(me, RENEW_1);
+            FLASH_HEAL                              = InitSpell(me, FLASH_HEAL_1);
+            PRAYER_OF_HEALING                       = InitSpell(me, PRAYER_OF_HEALING_1);
+            DIVINE_HYMN                             = InitSpell(me, DIVINE_HYMN_1);
+            RESURRECTION                            = InitSpell(me, RESURRECTION_1);
+            PW_SHIELD                               = InitSpell(me, PW_SHIELD_1);
+            INNER_FIRE                              = InitSpell(me, INNER_FIRE_1);
+            PW_FORTITUDE                            = InitSpell(me, PW_FORTITUDE_1);
+            SHADOW_PROTECTION                       = InitSpell(me, SHADOW_PROTECTION_1);
+            DIVINE_SPIRIT                           = InitSpell(me, DIVINE_SPIRIT_1);
+            SW_PAIN                                 = InitSpell(me, SW_PAIN_1);
+            MIND_BLAST                              = InitSpell(me, MIND_BLAST_1);
+            SW_DEATH                                = InitSpell(me, SW_DEATH_1);
+            DEVOURING_PLAGUE                        = InitSpell(me, DEVOURING_PLAGUE_1);
+  /*Talent*/MIND_FLAY                   = lvl >= 20 ? InitSpell(me, MIND_FLAY_1) : 0;
+  /*Talent*/VAMPIRIC_TOUCH              = lvl >= 50 ? InitSpell(me, VAMPIRIC_TOUCH_1) : 0;
+        }
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 65)
+                RefreshAura(BORROWED_TIME); //25%haste/40%bonus
+            if (level >= 55)
+                RefreshAura(DIVINE_AEGIS); //30%
+            if (level >= 55)
+                RefreshAura(EMPOWERED_RENEW3); //15%
+            else if (level >= 50)
+                RefreshAura(EMPOWERED_RENEW2); //10%
+            else if (level >= 45)
+                RefreshAura(EMPOWERED_RENEW1); //5%
+            if (level >= 45)
+                RefreshAura(BODY_AND_SOUL1); //30%
+            if (level >= 50)
+                RefreshAura(PAINANDSUFFERING3); //100%
+            else if (level >= 48)
+                RefreshAura(PAINANDSUFFERING2); //66%
+            else if (level >= 45)
+                RefreshAura(PAINANDSUFFERING1); //33%
+            if (level >= 50)
+                RefreshAura(MISERY3); //3%
+            else if (level >= 48)
+                RefreshAura(MISERY2); //2%
+            else if (level >= 45)
+                RefreshAura(MISERY1); //1%
+            if (level >= 45)
+                RefreshAura(GRACE); //100%
+            if (level >= 35)
+                RefreshAura(IMP_DEV_PLAG); //30%
+            if (level >= 25)
+                RefreshAura(INSPIRATION3); //10%
+            else if (level >= 23)
+                RefreshAura(INSPIRATION2); //6%
+            else if (level >= 20)
+                RefreshAura(INSPIRATION1); //3%
+            if (level >= 30)
+                RefreshAura(SHADOW_WEAVING3); //100%
+            else if (level >= 28)
+                RefreshAura(SHADOW_WEAVING2); //66%
+            else if (level >= 25)
+                RefreshAura(SHADOW_WEAVING1); //33%
+            if (level >= 15)
+            {
+                RefreshAura(GLYPH_SW_PAIN);
+                RefreshAura(GLYPH_PW_SHIELD); //20% heal
+            }
+            if (level >= 40)
+                RefreshAura(SHADOWFORM); //allows dots to crit, passive
+            if (level >= 70)
+                RefreshAura(PRIEST_T10_2P_BONUS);
+        }
+
+    private:
+        uint32
+   /*Buffs*/INNER_FIRE, PW_FORTITUDE, DIVINE_SPIRIT, SHADOW_PROTECTION,
+    /*Disc*/FEAR_WARD, PAIN_SUPPRESSION, SHACKLE_UNDEAD, PW_SHIELD, DISPELMAGIC, CURE_DISEASE, PENANCE,
+    /*Holy*/HEAL, FLASH_HEAL, RENEW, PRAYER_OF_HEALING, DIVINE_HYMN, GUARDIAN_SPIRIT, RESURRECTION,
+  /*Shadow*/SW_PAIN, MIND_BLAST, SW_DEATH, DEVOURING_PLAGUE, MIND_FLAY, VAMPIRIC_TOUCH,
+  /*Shadow*/PSYCHIC_SCREAM, FADE, PSYCHIC_HORROR, VAMPIRIC_EMBRACE, DISPERSION, MIND_SEAR, SILENCE;
+        //Timers/other
+/*Disc*/uint32 Penance_Timer, PWS_Timer, Pain_Suppression_Timer, Fear_Ward_Timer;
+/*Holy*/uint32 Heal_Timer, Divine_Hymn_Timer, Guardian_Spirit_Timer;
+/*Shdw*/uint32 Fade_Timer, Fear_Timer, Mind_Blast_Timer, SW_Death_Timer, Mind_Flay_Timer,
+/*Shdw*/    Psychic_Horror_Timer, Silence_Timer, Dispersion_Timer;
+/*Misc*/uint16 CheckDispelTimer, ShackleTimer, DevcheckTimer;
+/*Misc*/bool Devcheck;
+
+        enum PriestBaseSpells
+        {
+            DISPEL_MAGIC_1                      = 527,
+            MASS_DISPEL_1                       = 32375,
+            CURE_DISEASE_1                      = 528,
+            FEAR_WARD_1                         = 6346,
+  /*Talent*/PAIN_SUPPRESSION_1                  = 33206,
+            PSYCHIC_SCREAM_1                    = 8122,
+            FADE_1                              = 586,
+  /*Talent*/PSYCHIC_HORROR_1                    = 64044,
+  /*Talent*/SILENCE_1                           = 15487,
+  /*Talent*/PENANCE_1                           = 47540,
+  /*Talent*/VAMPIRIC_EMBRACE_1                  = 15286,
+  /*Talent*/DISPERSION_1                        = 47585,
+            MIND_SEAR_1                         = 48045,
+  /*Talent*/GUARDIAN_SPIRIT_1                   = 47788,
+            SHACKLE_UNDEAD_1                    = 9484,
+            LESSER_HEAL_1                       = 2050,
+            NORMAL_HEAL_1                       = 2054,
+            GREATER_HEAL_1                      = 2060,
+            RENEW_1                             = 139,
+            FLASH_HEAL_1                        = 2061,
+            PRAYER_OF_HEALING_1                 = 596,
+            DIVINE_HYMN_1                       = 64843,
+            RESURRECTION_1                      = 2006,
+            PW_SHIELD_1                         = 17,
+            INNER_FIRE_1                        = 588,
+            PW_FORTITUDE_1                      = 1243,
+            SHADOW_PROTECTION_1                 = 976,
+            DIVINE_SPIRIT_1                     = 14752,
+            SW_PAIN_1                           = 589,
+            MIND_BLAST_1                        = 8092,
+            SW_DEATH_1                          = 32379,
+            DEVOURING_PLAGUE_1                  = 2944,
+  /*Talent*/MIND_FLAY_1                         = 15407,
+  /*Talent*/VAMPIRIC_TOUCH_1                    = 34914,
+        };
+        enum PriestPassives
+        {
+            SHADOWFORM  /*For DOT crits*/   = 49868,
+        //Talents
+            IMP_DEV_PLAG                    = 63627,//rank 3
+            MISERY1                         = 33191,
+            MISERY2                         = 33192,
+            MISERY3                         = 33193,
+            PAINANDSUFFERING1               = 47580,
+            PAINANDSUFFERING2               = 47581,
+            PAINANDSUFFERING3               = 47582,
+            SHADOW_WEAVING1                 = 15257,
+            SHADOW_WEAVING2                 = 15331,
+            SHADOW_WEAVING3                 = 15332,
+            DIVINE_AEGIS                    = 47515,//rank 3
+            BORROWED_TIME                   = 52800,//rank 5
+            GRACE                           = 47517,//rank 2
+            EMPOWERED_RENEW1                = 63534,
+            EMPOWERED_RENEW2                = 63542,
+            EMPOWERED_RENEW3                = 63543,
+            INSPIRATION1                    = 14892,
+            INSPIRATION2                    = 15362,
+            INSPIRATION3                    = 15363,
+            BODY_AND_SOUL1                  = 64127,
+        //Glyphs
+            GLYPH_SW_PAIN                   = 55681,
+            GLYPH_PW_SHIELD                 = 55672,
+        //other
+            PRIEST_T10_2P_BONUS             = 70770,//33% renew
+        };
+        enum PriestSpecial
+        {
+            WEAKENED_SOUL                   = 6788,
+        };
+    }; //end priest_bot
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..b3c5158
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
@@ -0,0 +1,894 @@
+#include "bot_ai.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Rogue NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 25% maybe...
+TODO:
+*/
+#define DMGMIN              1
+#define DMGMAX              2
+#define MAX_COMBO_POINTS    5
+#define EVISCERATE_MAX_RANK 12
+const uint32 EVSCRDamage[EVISCERATE_MAX_RANK+1][MAX_COMBO_POINTS+1][DMGMAX+1] = 
+{
+    { { 0,0,0 }, { 0,0,0 },     { 0,0,0 },      { 0,0,0 },       { 0,0,0 },       { 0,0,0 }       },
+    { { 0,0,0 }, { 0,6,11 },    { 0,12,16 },    { 0,17,22 },     { 0,22,28 },     { 0,28,34 }     },
+    { { 0,0,0 }, { 0,14,23 },   { 0,26,34 },    { 0,37,46 },     { 0,48,58 },     { 0,60,70 }     },
+    { { 0,0,0 }, { 0,25,49 },   { 0,45,59 },    { 0,64,79 },     { 0,83,99 },     { 0,103,119 }   },
+    { { 0,0,0 }, { 0,41,62 },   { 0,73,93 },    { 0,104,125 },   { 0,135,157 },   { 0,167,189 }   },
+    { { 0,0,0 }, { 0,60,91 },   { 0,106,136 },  { 0,151,182 },   { 0,196,228 },   { 0,242,274 }   },
+    { { 0,0,0 }, { 0,93,138 },  { 0,165,209 },  { 0,236,281 },   { 0,307,353 },   { 0,379,425 }   },
+    { { 0,0,0 }, { 0,144,213 }, { 0,255,323 },  { 0,365,434 },   { 0,475,545 },   { 0,586,656 }   },
+    { { 0,0,0 }, { 0,199,296 }, { 0,351,447 },  { 0,502,599 },   { 0,653,751 },   { 0,805,903 }   },
+    { { 0,0,0 }, { 0,224,333 }, { 0,395,503 },  { 0,565,674 },   { 0,735,845 },   { 0,906,1016 }  },
+    { { 0,0,0 }, { 0,245,366 }, { 0,431,551 },  { 0,616,737 },   { 0,801,923 },   { 0,987,1109 }  },
+    { { 0,0,0 }, { 0,405,614 }, { 0,707,915 },  { 0,1008,1217 }, { 0,1309,1519 }, { 0,1611,1821 } },
+    { { 0,0,0 }, { 0,497,752 }, { 0,868,1122 }, { 0,1238,1493 }, { 0,1608,1864 }, { 0,1979,2235 } }
+};
+#define RUPTURE_MAX_RANK    9
+const uint32 RuptureDamage[RUPTURE_MAX_RANK+1][MAX_COMBO_POINTS+1] = 
+{
+    { 0, 0,   0,   0,    0,    0    },
+    { 0, 41,  61,  86,   114,  147  },
+    { 0, 61,  91,  128,  170,  219  },
+    { 0, 89,  131, 182,  240,  307  },
+    { 0, 129, 186, 254,  331,  419  },
+    { 0, 177, 256, 350,  457,  579  },
+    { 0, 273, 381, 506,  646,  803  },
+    { 0, 325, 461, 620,  800,  1003 },
+    { 0, 489, 686, 914,  1171, 1459 },
+    { 0, 581, 816, 1088, 1395, 1739 }
+};
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new rogue_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct rogue_botAI : public bot_minion_ai
+    {
+        rogue_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_ROGUE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, false);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { comboPoints = 0; tempComboPoints = 0; master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions(uint32 /*diff*/)
+        {}
+
+        //This method should be used to emulate energy usage reduction
+        void modenergy(int32 mod, bool set = false)
+        {
+            //can't set enery to -x (2 cases)
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && energy < uint32(abs(mod)))
+                return;
+
+            if (set)
+                energy = mod;
+            else
+                energy += mod;
+
+            energy = std::min<uint32>(energy, 100);
+            me->SetPower(POWER_ENERGY, energy);
+        }
+
+        uint32 getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+            return energy;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (KidneyTarget)
+            {
+                //kidney shot is casted as rank 1 (1 or 2 secs) so add duration accordingly
+                //i.e. kedney rank 1, points = 5, we have aura with duration 1 sec so add 4 more secs
+                //tempComboPoints -= 1;
+                if (tempComboPoints)
+                {
+                    if (Unit* u = sObjectAccessor->FindUnit(KidneyTarget))
+                    {
+                        if (Aura* kidney = u->GetAura(KIDNEY_SHOT, me->GetGUID()))
+                        {
+                            uint32 dur = kidney->GetDuration() + tempComboPoints*1000;
+                            kidney->SetDuration(dur);
+                            kidney->SetMaxDuration(dur);
+                        }
+                    }
+                    else//spell is failed to hit: restore cp
+                    {
+                        if (comboPoints == 0)
+                            comboPoints = tempComboPoints;
+                    }
+                    tempComboPoints = 0;
+                }
+                KidneyTarget = 0;
+            }
+            else if (RuptureTarget)
+            {
+                //tempComboPoints -= 1;
+                if (tempComboPoints)
+                {
+                    if (Unit* u = sObjectAccessor->FindUnit(RuptureTarget))
+                    {
+                        if (Aura* rupture = u->GetAura(RUPTURE, me->GetGUID()))
+                        {
+                            uint32 dur = rupture->GetDuration() + tempComboPoints*2000;
+                            rupture->SetDuration(dur);
+                            rupture->SetMaxDuration(dur);
+                        }
+                    }
+                    else//spell is failed to hit: restore cp
+                    {
+                        if (comboPoints == 0)
+                            comboPoints = tempComboPoints;
+                    }
+                    tempComboPoints = 0;
+                }
+                RuptureTarget = 0;
+            }
+            else if (tempDICE)
+            {
+                //tempComboPoints -= 1;
+                if (tempComboPoints)
+                {
+                    if (Aura* dice = me->GetAura(SLICE_DICE))
+                    {
+                        uint32 dur = (dice->GetDuration()*3)/2 + tempComboPoints*4500;//with Improved Slice and Dice
+                        dice->SetDuration(dur);
+                        dice->SetMaxDuration(dur);
+                    }
+                    tempComboPoints = 0;
+                }
+                tempDICE = false;
+            }
+            if (IAmDead()) return;
+            if (me->GetVictim())
+                DoMeleeAttackIfReady();
+            else
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            if (checkAurasTimer == 0)
+                CheckAuras();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 33 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_ROGUE))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            comboPoints = std::min<uint8>(comboPoints, 5);
+            //AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            if (BLADE_FLURRY && Blade_Flurry_Timer <= diff && meleedist <= 5 && 
+                Rand() < 30 && getenergy() >= 25 && FindSplashTarget(7, opponent))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, BLADE_FLURRY))
+                {
+                    Blade_Flurry_Timer = 90000;
+                    GC_Timer = temptimer;
+                    return;//return here to allow cast only on next update
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //KICK
+            if (KICK && Kick_Timer <= diff && meleedist <= 5 && Rand() < 80 && getenergy() >= 25 &&
+                opponent->IsNonMeleeSpellCasted(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, KICK))
+                {
+                    Kick_Timer = 8000;//improved
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //SHADOWSTEP
+            if (SHADOWSTEP && Shadowstep_Timer <= diff && dist < 25 &&
+                (opponent->GetVictim() != me || opponent->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 30 && getenergy() >= 10)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, SHADOWSTEP))
+                {
+                    Shadowstep_Timer = 20000;
+                    GC_Timer = temptimer;
+                    //return;
+                }
+                //doCast(opponent, BACKSTAB, true);
+            }
+            //BACKSTAB
+            if (BACKSTAB && GC_Timer <= diff && meleedist <= 5 && comboPoints < 5 &&
+                /*Rand() < 90 && */getenergy() >= 60 && !opponent->HasInArc(M_PI, me))
+            {
+                if (doCast(opponent, BACKSTAB))
+                    return;
+            }
+            //SINISTER STRIKE
+            if (SINISTER_STRIKE && GC_Timer <= diff && meleedist <= 5 && comboPoints < 5 &&
+                Rand() < 25 && getenergy() >= 45)
+            {
+                if (doCast(opponent, SINISTER_STRIKE))
+                    return;
+            }
+            //SLICE AND DICE
+            if (SLICE_DICE && Slice_Dice_Timer <= diff && GC_Timer <= diff && dist < 20 && comboPoints > 1 &&
+                (b_attackers.size() <= 1 || Blade_Flurry_Timer > 80000) && Rand() < 30 && getenergy() >= 25)
+            {
+                if (doCast(opponent, SLICE_DICE))
+                {
+                    //DICE = true;
+                    //tempDICE = true;
+                    //tempComboPoints = comboPoints;
+                    ////comboPoints = 0;
+                    return;
+                }
+            }
+            //KIDNEY SHOT
+            if (KIDNEY_SHOT && GC_Timer <= diff && Kidney_Timer <= diff && meleedist <= 5 && comboPoints > 0 &&
+                !CCed(opponent) && getenergy() >= 25 && ((Rand() < 15 + comboPoints*15 && opponent->GetVictim() == me && comboPoints > 2) || opponent->IsNonMeleeSpellCasted(false)))
+            {
+                if (doCast(opponent, KIDNEY_SHOT))
+                {
+                    KidneyTarget = opponent->GetGUID();
+                    tempComboPoints = comboPoints;
+                    //comboPoints = 0;
+                    Kidney_Timer = 20000;
+                    return;
+                }
+            }
+            //EVISCERATE
+            if (EVISCERATE && GC_Timer <= diff && meleedist <= 5 && comboPoints > 2 &&
+                getenergy() >= 35 && Rand() < comboPoints*15)
+            {
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(EVISCERATE);
+                uint8 rank = spellInfo->GetRank();
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                float combo = float(comboPoints);
+                int32 damage = int32(urand(EVSCRDamage[rank][comboPoints][DMGMIN], EVSCRDamage[rank][comboPoints][DMGMAX]));//base damage
+                damage += irand(int32(ap*combo*0.03f), int32(ap*combo*0.07f));//ap bonus
+
+                //PlaceHolder::damage bonuses
+                // Eviscerate and Envenom Bonus Damage (Deathmantle item set effect)
+                //if (me->HasAura(37169))
+                //    damage += comboPoints*100;
+
+                currentSpell = EVISCERATE;
+                me->CastCustomSpell(opponent, EVISCERATE, &damage, NULL, NULL, false);
+                return;
+            }
+            //MUTILATE
+            //if (isTimerReady(Mutilate_Timer) && energy>60) 
+            //{
+            //    // TODO: calculate correct dmg for mutilate (dont forget poison bonus)
+            //    // for now use same formula as evicerate
+            //    uint32 base_attPower = me->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+            //    //float minDmg = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            //    float minDmg = me->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+            //    int damage = irand(int32(base_attPower*7*0.03f),int32(base_attPower*7*0.08f))+minDmg+me->getLevel();
+
+            //    // compensate for lack of attack power
+            //    damage = damage*(rand()%4+1);
+
+            //    me->CastCustomSpell(opponent, MUTILATE, &damage, NULL, NULL, false, NULL, NULL);
+
+            //    //doCast (me, MUTILATE);
+            //    Mutilate_Timer = 10;
+            //    comboPoints+=3;
+            //    energy -= 60;
+            //}
+
+            //RUPTURE
+            if (RUPTURE && Rupture_Timer <= diff && GC_Timer <= diff && meleedist <= 5 && comboPoints > 2 &&
+                opponent->GetHealth() > me->GetMaxHealth()/3 && getenergy() >= 25 && Rand() < 50 + 50*opponent->isMoving())
+            {
+                //no damage range for rupture
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(RUPTURE);
+                uint8 rank = spellInfo->GetRank();
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                float AP_per_combo[6] = {0.0f, 0.015f, 0.024f, 0.03f, 0.03428571f, 0.0375f};
+                float divider[6] = {0.0f, 4.f, 5.f, 6.f, 7.f, 8.f};//duration/2 = number of ticks
+                int32 damage = int32(RuptureDamage[rank][comboPoints]/divider[comboPoints]);//base damage
+                damage += int32(ap*AP_per_combo[comboPoints]);//ap bonus is strict - applied to every tick
+
+                currentSpell = RUPTURE;
+                me->CastCustomSpell(opponent, RUPTURE, &damage, NULL, NULL, false);
+                return;
+                //if (doCast(opponent, RUPTURE))
+                //{
+                //    RuptureTarget = opponent->GetGUID();
+                //    tempComboPoints = comboPoints;
+                //    Rupture_Timer = 6000 + (comboPoints-1)*2000;
+                //    //comboPoints = 0;
+                //    return;
+                //}
+            }
+            //DISMANTLE
+            if (DISMANTLE && Dismantle_Timer <= diff && meleedist <= 5 &&
+                opponent->GetTypeId() == TYPEID_PLAYER && 
+                Rand() < 20 && getenergy() >= 25 && !CCed(opponent) &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) && 
+                opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, DISMANTLE))
+                {
+                    Dismantle_Timer = 60000;
+                    GC_Timer = temptimer;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Puncturing Wounds: 30% additional critical chance for Backstab
+                if (lvl >= 15 && spellId == BACKSTAB)
+                    aftercrit += 30.f;
+                //Puncturing Wounds: 15% additional critical chance for Mutilate
+                else if (spellId == MUTILATE)
+                    aftercrit += 15.f;
+                //Glyph of Eviscerate: 10% additional critical chance for Eviscerate
+                else if (spellId == EVISCERATE)
+                    aftercrit += 10.f;
+                //Improved Ambush: 50% additional critical chance for Ambush
+                //else if (spellId == AMBUSH)
+                //    crit_chance += 50.f;
+                if (lvl >= 50 && spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS) && me->HasAura(TURN_THE_TABLES_EFFECT))
+                    aftercrit += 6.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Lethality: 30% crit damage bonus for non-stealth combo-generating abilities (on 25 lvl)
+                if (lvl >= 25 && !(spellInfo->Attributes & SPELL_ATTR0_ONLY_STEALTHED) &&
+                    spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS))
+                    pctbonus += 0.15f;
+            }
+            //Shadowstep: 20% bonus damage to all abilities once
+            //if (shadowstep == true)
+            //{
+            //    shadowstep = false;
+            //    me->RemoveAurasDueToSpell(SHADOWSTEP_EFFECT_DAMAGE);
+            //    pctbonus += 0.2f;
+            //}
+            //Find Weakness: 6% bonus damage to all abilities
+            if (lvl >= 45)
+                pctbonus += 0.06f;
+            //DeathDealer set bonus: 15% damage bonus for Eviscerate
+            if (lvl >= 60 && spellId == EVISCERATE)
+                pctbonus += 0.15f;
+            //Imoroved Eviscerate: 20% damage bonus for Eviscerate
+            if (spellId == EVISCERATE)
+                pctbonus += 0.2f;
+            //Opportunity: 20% damage bonus for Backstab, Mutilate, Garrote and Ambush
+            if (spellId == BACKSTAB || spellId == MUTILATE/* || 
+                spellId == GARROTE || spellId == AMBUSH*/)
+                pctbonus += 0.2f;
+            //Aggression: 15% damage bonus for Sinister Strike, Backstab and Eviscerate
+            if (lvl >= 30 && (spellId == SINISTER_STRIKE || spellId == BACKSTAB || spellId == EVISCERATE))
+                pctbonus += 0.15f;
+            //Blood Spatter: 30% bonus damage for Rupture and Garrote
+            if (lvl >= 15 && (spellId == RUPTURE/* || spellId == GARROTE*/))
+                pctbonus += 0.3f;
+            //Serrated Blades: 30% bonus damage for Rupture
+            if (lvl >= 20 && spellId == RUPTURE)
+                pctbonus += 0.3f;
+            //Surprise Attacks: 10% bonus damage for Sinister Strike, Backstab, Shiv, Hemmorhage and Gouge
+            if (lvl >= 50 && (spellId == SINISTER_STRIKE || spellId == BACKSTAB/* ||
+                spellId == SHIV || spellId == HEMMORHAGE || spellId == GOUGE*/))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (!WOUND_POISON && !MIND_NUMBING_POISON)
+                return;
+
+            if (damageType == DIRECT_DAMAGE/* || damageType == SPELL_DIRECT_DAMAGE*/)
+            {
+                if (victim && me->GetExactDist(victim) <= 30)
+                {
+                    switch (rand()%2)
+                    {
+                        case 0:
+                            break;
+                        case 1:
+                        {
+                            switch (rand()%2)
+                            {
+                                case 0:
+                                    if (WOUND_POISON)
+                                    {
+                                        currentSpell = WOUND_POISON;
+                                        DoCast(victim, WOUND_POISON, true);
+                                    }
+                                    break;
+                                case 1:
+                                    if (MIND_NUMBING_POISON)
+                                    {
+                                        currentSpell = MIND_NUMBING_POISON;
+                                        DoCast(victim, MIND_NUMBING_POISON, true);
+                                    }
+                                    break;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            if (currentSpell == 0)
+                return;
+
+            if (spellId == SLICE_DICE)
+            {
+                tempDICE = true;
+                tempComboPoints = comboPoints;
+                Slice_Dice_Timer = 15000 + (comboPoints-1)*4500;
+            }
+            else if (spellId == RUPTURE)
+            {
+                RuptureTarget = target->GetGUID();
+                tempComboPoints = comboPoints;
+                Rupture_Timer = 8000 + (comboPoints-1)*2000;
+                GC_Timer = 800;
+            }
+            else if (spellId == EVISCERATE)
+                GC_Timer = 800;
+
+            //if (spellId == EVISCERATE || spellId == KIDNEY_SHOT || spellId == SLICE_DICE || spellId == RUPTURE/* || spellId == EXPOSE_ARMOR || spellId == ENVENOM*/)
+            //Relentless Strikes
+            if (spell->NeedsComboPoints())
+            {
+                //std::ostringstream msg;
+                //msg << "casting ";
+                //if (spellId == EVISCERATE)
+                //    msg << "Eviscerate, ";
+                //else if (spellId == RUPTURE)
+                //    msg << "Rupture, ";
+                //else if (spellId == SLICE_DICE)
+                //    msg << "Slice and Dice, ";
+                //else if (spellId == KIDNEY_SHOT)
+                //    msg << "Kidney Shot, ";
+                ////else if (spellId == EXPOSE_ARMOR)
+                ////    msg << "Expose Armor, ";
+                ////else if (spellId == ENVENOM)
+                ////    msg << "Envenom, ";
+                //msg << "combo points: " << uint32(std::min<uint32>(comboPoints,5));
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (rand()%100 < 1 + 20*(comboPoints > 5 ? 5 : comboPoints))
+                    DoCast(me, RELENTLESS_STRIKES_EFFECT, true);
+                tempComboPoints = comboPoints;
+                //CP adding effects are handled before actual finisher so use temp value
+                //std::ostringstream msg2;
+                //msg2 << "cp set to 0";
+                if (tempAddCP)
+                {
+                    //msg2 << " + " << uint32(tempAddCP) << " (temp)";
+                    comboPoints = tempAddCP;
+                    tempAddCP = 0;
+                }
+                else
+                    comboPoints = 0;
+                //me->MonsterWhisper(msg2.str().c_str(), master->GetGUID());
+            }
+            else if (spellId == SINISTER_STRIKE ||
+                spellId == BACKSTAB/* ||
+                spellId == GOUGE ||
+                spellId == HEMORRHAGE ||
+                spellId == SHOSTLY_STRIKE*/)
+            {
+                ++comboPoints;
+                //std::ostringstream msg;
+                //msg << "1 cp generated ";
+                //if (spellId == SINISTER_STRIKE)
+                //    msg << "(Sinister Strike)";
+                //else if (spellId == BACKSTAB)
+                //    msg << "(Backstab)";
+                //msg << " set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == MUTILATE/* ||
+                spellId == AMBUSH*/)
+            {
+                comboPoints += 2;
+                //std::ostringstream msg;
+                //msg << "2 cp generated (Mutilate), set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == SEAL_FATE_EFFECT ||
+                spellId == RUTHLESSNESS_EFFECT)
+            {
+                ++tempAddCP;
+                //std::ostringstream msg;
+                //msg << "1 temp cp generated ";
+                //if (spellId == SEAL_FATE_EFFECT)
+                //    msg << "(Seal Fate)";
+                //else if (spellId == RUTHLESSNESS_EFFECT)
+                //    msg << "(Ruthleness)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+            }
+
+            if (spellId == SINISTER_STRIKE)
+            {
+                //Improved Sinister Strike
+                //instead of restoring energy we should override current value
+                if (me->getLevel() >= 10)
+                    modenergy(-40, true);//45 - 5
+            }
+            //Glyph of Sinister Strike (50% to add cp on crit)
+            //Seal Fate means crit so this glyph is enabled from lvl 35)
+            if (spellId == SEAL_FATE_EFFECT && currentSpell == SINISTER_STRIKE && rand()%100 >= 50)
+            {
+                ++tempAddCP;
+                //me->MonsterWhisper("1 temp cp generated (glyph of SS)", master->GetGUID());
+            }
+            //Slaughter from the Shadows energy restore
+            //instead of restoring energy we should override current value
+            if (me->getLevel() >= 55)
+            {
+                if (spellId == BACKSTAB/* || spellId == AMBUSH*/)
+                    modenergy(-40, true);
+                //else if (spellId == HEMORRHAGE)
+                //    modenergy(-30, true);
+            }
+
+            //if (spellId == SHADOWSTEP)
+            //{
+            //    Shadowstep_eff_Timer = 10000;
+            //    shadowstep = true;
+            //}
+
+            //move behind on Kidney Shot and Gouge (optionally)
+            if (spellId == KIDNEY_SHOT/* || spellId == GOUGE*/)
+                if (MoveBehind(*target))
+                    wait = 3;
+
+            if (spellId == currentSpell)
+                currentSpell = 0;
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Mutilate_Timer = 0;
+            Rupture_Timer = 0;
+            Dismantle_Timer = 0;
+            Kick_Timer = 0;
+            Kidney_Timer = 0;
+            Shadowstep_Timer = 0;
+            Blade_Flurry_Timer = 0;
+            Slice_Dice_Timer = 0;
+            //Shadowstep_eff_Timer = 0;
+
+            comboPoints = 0;
+            tempComboPoints = 0;
+            tempAddCP = 0;
+
+            KidneyTarget = 0;
+            RuptureTarget = 0;
+
+            tempDICE = false;
+            spellHitTarget = true;
+            //shadowstep = false;
+
+            me->setPowerType(POWER_ENERGY);
+            //10 energy gained per stack
+            RefreshAura(GLADIATOR_VIGOR, 10);
+
+            if (master)
+            {
+                setStats(CLASS_ROGUE, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_ROGUE);
+            }
+
+            me->SetPower(POWER_ENERGY, me->GetMaxPower(POWER_ENERGY));
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Kick_Timer > diff)                  Kick_Timer -= diff;
+            if (Rupture_Timer > diff)               Rupture_Timer -= diff;
+            if (Shadowstep_Timer > diff)            Shadowstep_Timer -= diff;
+            if (Mutilate_Timer > diff)              Mutilate_Timer -= diff;
+            if (Kidney_Timer > diff)                Kidney_Timer -= diff;
+            if (Dismantle_Timer > diff)             Dismantle_Timer -= diff;
+            if (Blade_Flurry_Timer > diff)          Blade_Flurry_Timer -= diff;
+            if (Slice_Dice_Timer > diff)            Slice_Dice_Timer -= diff;
+            //if (Shadowstep_eff_Timer > diff)        Shadowstep_eff_Timer -= diff;
+            //else if (shadowstep)                    shadowstep = false;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            BACKSTAB                                = InitSpell(me, BACKSTAB_1);
+            SINISTER_STRIKE                         = InitSpell(me, SINISTER_STRIKE_1);
+            SLICE_DICE                              = InitSpell(me, SLICE_DICE_1);
+            EVISCERATE                              = InitSpell(me, EVISCERATE_1);
+            KICK                                    = InitSpell(me, KICK_1);
+            RUPTURE                                 = InitSpell(me, RUPTURE_1);
+            KIDNEY_SHOT                             = InitSpell(me, KIDNEY_SHOT_1);
+            MUTILATE                    = lvl >= 50 ? InitSpell(me, MUTILATE_1) : 0;
+            SHADOWSTEP                  = lvl >= 50 ? SHADOWSTEP_1 : 0;
+            DISMANTLE                               = InitSpell(me, DISMANTLE_1);
+            BLADE_FLURRY                = lvl >= 30 ? BLADE_FLURRY_1 : 0;
+
+            WOUND_POISON                            = InitSpell(me, WOUND_POISON_1);
+            MIND_NUMBING_POISON                     = InitSpell(me, MIND_NUMBING_POISON_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            //if (level >= 78)
+            //    RefreshAura(ROGUE_ARMOR_ENERGIZE,2);
+            //else if (level >= 60)
+            //    RefreshAura(ROGUE_ARMOR_ENERGIZE);
+            if (level >= 70)
+                RefreshAura(COMBAT_POTENCY5,2);
+            else if (level >= 55)
+                RefreshAura(COMBAT_POTENCY5);
+            else if (level >= 52)
+                RefreshAura(COMBAT_POTENCY4);
+            else if (level >= 49)
+                RefreshAura(COMBAT_POTENCY3);
+            else if (level >= 47)
+                RefreshAura(COMBAT_POTENCY2);
+            else if (level >= 45)
+                RefreshAura(COMBAT_POTENCY1);
+            if (level >= 35)
+                RefreshAura(SEAL_FATE5);
+            else if (level >= 32)
+                RefreshAura(SEAL_FATE4);
+            else if (level >= 29)
+                RefreshAura(SEAL_FATE3);
+            else if (level >= 27)
+                RefreshAura(SEAL_FATE2);
+            else if (level >= 25)
+                RefreshAura(SEAL_FATE1);
+            if (level >= 78)
+                RefreshAura(VITALITY,4);
+            else if (level >= 70)
+                RefreshAura(VITALITY,3);
+            else if (level >= 55)
+                RefreshAura(VITALITY,2);
+            else if (level >= 40)
+                RefreshAura(VITALITY);
+            if (level >= 55)
+                RefreshAura(TURN_THE_TABLES);
+            if (level >= 40)
+                RefreshAura(DEADLY_BREW);
+            if (level >= 35)
+                RefreshAura(BLADE_TWISTING1);//allow rank 1 only
+            if (level >= 35)
+                RefreshAura(QUICK_RECOVERY2);
+            else if (level >= 30)
+                RefreshAura(QUICK_RECOVERY1);
+            if (level >= 30)
+                RefreshAura(IMPROVED_KIDNEY_SHOT);
+            if (level >= 10)
+                RefreshAura(GLYPH_BACKSTAB);
+            if (level >= 10)
+                RefreshAura(SURPRISE_ATTACKS);
+
+            //On 25 get Glyph of Vigor
+            if (level >= 25)
+                RefreshAura(ROGUE_VIGOR,2);
+            else if (level >= 20)
+                RefreshAura(ROGUE_VIGOR);
+        }
+
+    private:
+        uint32
+            BACKSTAB, SINISTER_STRIKE, SLICE_DICE, EVISCERATE, KICK, RUPTURE, KIDNEY_SHOT, MUTILATE,
+            SHADOWSTEP, DISMANTLE, BLADE_FLURRY,
+            WOUND_POISON, MIND_NUMBING_POISON;
+        //Timers/other
+        uint64 KidneyTarget, RuptureTarget;
+        uint32 Rupture_Timer, Dismantle_Timer,
+            Kick_Timer, Shadowstep_Timer, Mutilate_Timer, Kidney_Timer,
+            Blade_Flurry_Timer, Slice_Dice_Timer/*, Shadowstep_eff_Timer*/;
+        uint32 energy;
+        uint8 comboPoints, tempComboPoints, tempAddCP;
+        bool tempDICE, spellHitTarget/*, shadowstep*/;
+
+        enum RogueBaseSpells
+        {
+            BACKSTAB_1                          = 53,
+            SINISTER_STRIKE_1                   = 1757,
+            SLICE_DICE_1                        = 5171,
+            EVISCERATE_1                        = 2098,//11300
+            KICK_1                              = 1766,
+            RUPTURE_1                           = 1943,
+            KIDNEY_SHOT_1                       = 408,//8643
+  /*Talent*/MUTILATE_1                          = 1329,//48666
+  /*Talent*/SHADOWSTEP_1                        = 36554,
+            DISMANTLE_1                         = 51722,
+            BLADE_FLURRY_1                      = 33735,
+
+            WOUND_POISON_1                      = 13218,
+            MIND_NUMBING_POISON_1               = 5760
+        };
+
+        enum RoguePassives
+        {
+            //Talents
+            SEAL_FATE1                          = 14189,
+            SEAL_FATE2                          = 14190,
+            SEAL_FATE3                          = 14193,
+            SEAL_FATE4                          = 14194,
+            SEAL_FATE5                          = 14195,
+            COMBAT_POTENCY1                     = 35541,
+            COMBAT_POTENCY2                     = 35550,
+            COMBAT_POTENCY3                     = 35551,
+            COMBAT_POTENCY4                     = 35552,
+            COMBAT_POTENCY5                     = 35553,
+            QUICK_RECOVERY1                     = 31244,
+            QUICK_RECOVERY2                     = 31245,
+            BLADE_TWISTING1                     = 31124,
+            //BLADE_TWISTING2                     = 31126,
+            VITALITY                            = 61329,//rank 3
+            DEADLY_BREW                         = 51626,//rank 2
+            IMPROVED_KIDNEY_SHOT                = 14176,//rank 3
+            TURN_THE_TABLES                     = 51629,//rank 3
+            SURPRISE_ATTACKS                    = 32601,
+            ROGUE_VIGOR                         = 14983,
+            //Other
+            //ROGUE_ARMOR_ENERGIZE/*Deathmantle*/ = 27787,
+            GLADIATOR_VIGOR                     = 21975,
+            GLYPH_BACKSTAB                      = 56800
+        };
+
+        enum RogueSpecial
+        {
+            //WOUND_POISON                        = 13218,
+            //DEADLY_POISON                       = 2818,
+            //MIND_NUMBING_POISON                 = 5760,
+            RELENTLESS_STRIKES_EFFECT           = 14181,
+            RUTHLESSNESS_EFFECT                 = 14157,
+            SEAL_FATE_EFFECT                    = 14189,
+            //SHADOWSTEP_EFFECT_DAMAGE            = 36563,
+            TURN_THE_TABLES_EFFECT              = 52910
+        };
+    };
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..cbe11fa
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
@@ -0,0 +1,474 @@
+#include "bot_ai.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "Totem.h"
+/*
+Shaman NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 1%
+TODO:
+*/
+enum TotemSlot
+{
+    T_FIRE  = 0,
+    T_WATER = 1,
+    T_EARTH = 2,
+    T_AIR   = 3,
+    MAX_TOTEMS
+};
+typedef std::pair<uint64, Position> BotTotem;
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new shaman_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct shaman_botAI : public bot_minion_ai
+    {
+        shaman_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_SHAMAN) != SPELL_CAST_OK)
+                return false;
+            uint64 originalCaster = me->GetGUID();
+            return bot_ai::doCast(victim, spellId, triggered, originalCaster);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            GetInPosition(force, false/*STYLE == MELEE*//*SPEC == ENCHANCEMENT*/);
+            SetBotCommandState(COMMAND_ATTACK);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void CheckTotems(uint32 diff)
+        {
+            //update rate
+            if (Rand() > 50)
+                return;
+            //Unsummon
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0 && me->GetDistance(_totems[i].second) > 18)
+                {
+                    Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
+                    //reset
+                    _totems[i].first = 0;
+                    if (!to)
+                    {
+                        TC_LOG_ERROR(LOG_FILTER_PLAYER, "%s has lost totem in slot %u! Despawned normally?", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+            if (GC_Timer > diff || IsCasting() || me->GetDistance(master) > 15 || Feasting())
+                return;
+            //Summon
+            //TODO: role-based totems (attack/heal)
+            if (me->IsInCombat())
+            {
+                if (WINDFURY_TOTEM && !_totems[T_AIR].first)
+                {
+                    if (doCast(me, WINDFURY_TOTEM))
+                        return;
+                }
+                else if (STONESKIN_TOTEM && !_totems[T_EARTH].first)
+                {
+                    if (doCast(me, STONESKIN_TOTEM))
+                        return;
+                }
+
+                if (Unit* u = me->GetVictim())
+                {
+                    if (SEARING_TOTEM && Searing_Totem_Timer <= diff)
+                    {
+                        if (me->GetExactDist(u) < (u->isMoving() ? 10 : 25))
+                        {
+                            if (doCast(me, SEARING_TOTEM))
+                            {
+                                Searing_Totem_Timer = 30000;
+                                return;
+                            }
+                        }
+                    }
+                }
+            }
+            else if (!me->isMoving() && !master->isMoving())
+            {
+                if (!_totems[T_WATER].first)
+                {
+                    uint8 manapct = GetManaPCT(master);
+                    uint8 hppct = GetHealthPCT(master);
+                    if (HEALINGSTREAM_TOTEM &&
+                        (master->getPowerType() != POWER_MANA || !MANASPRING_TOTEM || hppct < 25 || manapct > hppct) &&
+                        hppct < 98)
+                    {
+                        if (doCast(me, HEALINGSTREAM_TOTEM))
+                            return;
+                    }
+                    else if (MANASPRING_TOTEM && manapct < 98)
+                    {
+                        if (doCast(me, MANASPRING_TOTEM))
+                            return;
+                    }
+                }
+            }
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->GetVictim()) Evade();
+            if (me->GetVictim())
+                DoMeleeAttackIfReady();
+            else
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+
+            BuffAndHealGroup(master, diff);
+            CheckTotems(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff myself
+            if (LIGHTNING_SHIELD && GC_Timer <= diff && !me->HasAura(LIGHTNING_SHIELD))
+                if (doCast(me, LIGHTNING_SHIELD))
+                    GC_Timer = 500;
+
+            if (!CheckAttackTarget(CLASS_SHAMAN))
+                return;
+
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void Counter(uint32 const /*diff*/)
+        {}
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            //float meleedist = me->GetDistance(opponent);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            if (Shock_Timer <= diff && GC_Timer <= diff && dist < 20)
+            {
+                if (!opponent->HasAura(FLAME_SHOCK, me->GetGUID()))
+                {
+                    if (doCast(opponent, FLAME_SHOCK))
+                    {
+                        Shock_Timer = 9000;
+                        return;
+                    }
+                }
+                else if (!opponent->HasAura(EARTH_SHOCK))
+                {
+                    if (doCast(opponent, EARTH_SHOCK))
+                    {
+                        Shock_Timer = 9000;
+                        return;
+                    }
+                }
+            }
+
+            if (Lightning_Bolt_Timer <= diff && GC_Timer <= diff && dist < 25)
+            {
+                if (doCast(opponent, LIGHTNING_BOLT))
+                {
+                    Lightning_Bolt_Timer = uint32(float(sSpellMgr->GetSpellInfo(LIGHTNING_BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200);
+                    return;
+                }
+            }
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 50 || me->IsMounted()) return;
+
+            RezGroup(ANCESTRAL_SPIRIT, master);
+
+            //if (Feasting()) return;
+            //BuffAndHealGroup(master, diff);
+            //CureGroup(master, diff);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (hp > 95) return false;
+            if (!target || target->isDead() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
+
+            //PLACEHOLDER: Instant spell req. interrupt current spell
+
+            if (IsCasting()) return false;
+
+            
+            /*if (hp < 70 && Heal_Timer <= diff)
+            {
+                doCast(target, HEALING_WAVE);
+            }
+            else */if (hp < 90 && Heal_Timer <= diff)
+            {
+                doCast(target, CHAIN_HEAL);
+            }
+            else if (hp < 95)
+            {
+                doCast(target, LESSER_HEAL);
+                return true;
+            }
+            return true;
+        }
+
+        //void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& /*crit*/) const
+        //{
+        //    uint32 spellId = spellInfo->Id;
+        //    uint8 lvl = me->getLevel();
+        //    float fdamage = float(damage);
+        //    //1) apply additional crit chance. This new chance roll will replace original (balance unsafe)
+        //    if (!crit)
+        //    {
+        //        float crit_chance = me->GetUnitCriticalChance(BASE_ATTACK, me);
+        //        float aftercrit = crit_chance;
+
+        //        //second roll (may be illogical)
+        //        if (aftercrit > crit_chance)
+        //            crit = roll_chance_f(aftercrit);
+        //    }
+
+        //    2) apply bonus damage mods
+        //    float pctbonus = 0.0f;
+        //    if (crit)
+        //    {
+        //    }
+
+        //    fdamage *= (1.0f + pctbonus);
+        //    damage = int32(fdamage);
+        //    //last: overall multiplier
+        //    bot_ai::ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+        //}
+
+        void DamageDealt(Unit* /*victim*/, uint32& /*damage*/, DamageEffectType /*damageType*/)
+        {
+        }
+
+        void OnBotSummon(Creature* summon)
+        {
+            TempSummon* totem = summon->ToTempSummon();
+            if (!totem)
+            {
+                TC_LOG_ERROR(LOG_FILTER_PLAYER, "shaman bot %s summoned creature %s which is not a temp summon...");
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:
+                    slot = T_FIRE;
+                    break;
+                case SUMMON_TYPE_TOTEM_EARTH:
+                    slot = T_EARTH;
+                    break;
+                case SUMMON_TYPE_TOTEM_WATER:
+                    slot = T_WATER;
+                    break;
+                case SUMMON_TYPE_TOTEM_AIR:
+                    slot = T_AIR;
+                    break;
+                default:
+                    TC_LOG_ERROR(LOG_FILTER_PLAYER, "unknown totem type %u", totem->m_Properties->Id);
+                    return;
+            }
+            _totems[slot].first = summon->GetGUID();
+            _totems[slot].second.Relocate(*summon);
+            //TC_LOG_ERROR(LOG_FILTER_PLAYER, "shaman bot: summoned %s (type %u) at x='%f', y='%f', z='%f'",
+            //    summon->GetName().c_str(), slot, _totems[slot].second.GetPositionX(), _totems[slot].second.GetPositionY(), _totems[slot].second.GetPositionZ());
+
+            summon->SetDisplayId(me->GetModelForTotem(PlayerTotemType(totem->m_Properties->Id)));
+            //summon->SetDisplayId(summon->GetNativeDisplayId());
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void UnsummonAll()
+        {
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0)
+                {
+                    Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
+                    if (!to)
+                    {
+                        TC_LOG_ERROR(LOG_FILTER_PLAYER, "%s has no totem in slot %u during remove!", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Shock_Timer = 0;
+            Lightning_Bolt_Timer = 0;
+            Searing_Totem_Timer = 0;
+
+            if (master)
+            {
+                setStats(CLASS_SHAMAN, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_SHAMAN);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Heal_Timer > diff)              Heal_Timer -= diff;
+            if (Shock_Timer > diff)             Shock_Timer -= diff;
+            if (Lightning_Bolt_Timer > diff)    Lightning_Bolt_Timer -= diff;
+            if (Searing_Totem_Timer > diff)     Searing_Totem_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            //uint8 lvl = me->getLevel();
+            CHAIN_HEAL                              = InitSpell(me, CHAIN_HEAL_1);
+            LESSER_HEAL                             = InitSpell(me, LESSER_HEAL_1);
+            ANCESTRAL_SPIRIT                        = InitSpell(me, ANCESTRAL_SPIRIT_1);
+            FLAME_SHOCK                             = InitSpell(me, FLAME_SHOCK_1);
+            EARTH_SHOCK                             = InitSpell(me, EARTH_SHOCK_1);
+            LIGHTNING_BOLT                          = InitSpell(me, LIGHTNING_BOLT_1);
+            LIGHTNING_SHIELD                        = InitSpell(me, LIGHTNING_SHIELD_1);
+            STONESKIN_TOTEM                         = InitSpell(me, STONESKIN_TOTEM_1);
+            HEALINGSTREAM_TOTEM                     = InitSpell(me, HEALINGSTREAM_TOTEM_1);
+            MANASPRING_TOTEM                        = InitSpell(me, MANASPRING_TOTEM_1);
+            SEARING_TOTEM                           = InitSpell(me, SEARING_TOTEM_1);
+            WINDFURY_TOTEM                          = InitSpell(me, WINDFURY_TOTEM_1);
+        }
+
+        void ApplyClassPassives()
+        {
+        }
+
+    private:
+        BotTotem _totems[MAX_TOTEMS];
+        uint32
+            CHAIN_HEAL, LESSER_HEAL, ANCESTRAL_SPIRIT,
+            FLAME_SHOCK, EARTH_SHOCK, LIGHTNING_BOLT, LIGHTNING_SHIELD,
+            STONESKIN_TOTEM, HEALINGSTREAM_TOTEM, MANASPRING_TOTEM, SEARING_TOTEM, WINDFURY_TOTEM;
+        //Timers
+        uint32 Heal_Timer, Shock_Timer, Lightning_Bolt_Timer, Searing_Totem_Timer;
+
+        enum ShamanBaseSpells
+        {
+            CHAIN_HEAL_1                        = 1064,
+            LESSER_HEAL_1                       = 8004,
+            ANCESTRAL_SPIRIT_1                  = 2008,
+            FLAME_SHOCK_1                       = 8050,
+            EARTH_SHOCK_1                       = 8042,
+            LIGHTNING_BOLT_1                    = 403,
+            LIGHTNING_SHIELD_1                  = 324,
+            STONESKIN_TOTEM_1                   = 8071,
+            HEALINGSTREAM_TOTEM_1               = 5394,
+            MANASPRING_TOTEM_1                  = 5675,
+            SEARING_TOTEM_1                     = 3599,
+            WINDFURY_TOTEM_1                    = 8512,
+        };
+
+        enum ShamanPassives
+        {
+        };
+
+        enum ShamanSpecial
+        {
+            STONESKIN_AURA                      = 8072,
+            HEALINGSTREAM_AURA                  = 5672,
+            MANASPRING_AURA                     = 5677,
+        };
+    };
+};
+
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..9060024
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
@@ -0,0 +1,458 @@
+#include "bot_ai.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+
+/*
+Warlock NpcBot (reworked by Graff onlysuffering@gmail.com)
+Voidwalker pet AI included
+Complete - 3%
+TODO:
+*/
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warlock_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct warlock_botAI : public bot_minion_ai
+    {
+        warlock_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { me->SetBotsPetDied(); master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions()
+        {}
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            GetInPosition(force, true);
+            SetBotCommandState(COMMAND_ATTACK);
+            fear_cd = std::max<uint32>(fear_cd, 1000);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->GetVictim())
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            if (CCed(me)) return;
+
+            //if pet is dead or unreachable
+            Creature* m_botsPet = me->GetBotsPet();
+            if (!m_botsPet || m_botsPet->FindMap() != master->GetMap() || (me->GetDistance2d(m_botsPet) > sWorld->GetMaxVisibleDistanceOnContinents() - 20.f))
+                if (master->getLevel() >= 10 && !me->IsInCombat() && !IsCasting() && !me->IsMounted())
+                    SummonBotsPet(PET_VOIDWALKER);
+
+            //TODO: implement healthstone
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(CLASS_WARLOCK))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            //TODO: add more damage spells
+
+            if (fear_cd <= diff && GC_Timer <= diff)
+            { CheckFear(); fear_cd = 2000; }
+
+            if (RAIN_OF_FIRE && Rand() < 25 && Rain_of_fire_cd <= diff && GC_Timer <= diff)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, RAIN_OF_FIRE))
+                {
+                    Rain_of_fire_cd = 5000;
+                    return;
+                }
+                Rain_of_fire_cd = 2000;//fail
+            }
+
+            if (Rand() < 25 && CURSE_OF_THE_ELEMENTS && GC_Timer <= diff && !HasAuraName(opponent, CURSE_OF_THE_ELEMENTS) && 
+                doCast(opponent, CURSE_OF_THE_ELEMENTS))
+            {
+                GC_Timer = 800;
+                return;
+            }
+
+            if (GC_Timer <= 0 && Rand() < 25 && !opponent->HasAura(CORRUPTION, me->GetGUID()) && 
+                doCast(opponent, CORRUPTION))
+                { return; }
+
+            if (HAUNT && Rand() < 25 && Haunt_cd <= diff && GC_Timer <= diff && !opponent->HasAura(HAUNT, me->GetGUID()) && 
+                doCast(opponent, HAUNT))
+            {
+                Haunt_cd = 8000;
+                return;
+            }
+
+            if (GC_Timer <= diff && Rand() < 15 && !Afflicted(opponent))
+            {
+                if (conflagarate_cd <= 8000 && doCast(opponent, IMMOLATE))
+                    return;
+                else if (UNSTABLE_AFFLICTION && doCast(opponent, UNSTABLE_AFFLICTION))
+                    return;
+            }
+
+            if (CONFLAGRATE && Rand() < 35 && conflagarate_cd <= diff && GC_Timer <= diff && 
+                HasAuraName(opponent, IMMOLATE) && 
+                doCast(opponent, CONFLAGRATE))
+            {
+                conflagarate_cd = 10000;
+                return;
+            }
+
+            if (CHAOS_BOLT && Rand() < 50 && chaos_bolt_cd <= diff && GC_Timer <= diff && doCast(opponent, CHAOS_BOLT))
+            {
+                chaos_bolt_cd = 16000 - me->getLevel() * 100;
+                return;
+            }
+
+            if (GC_Timer <= diff && doCast(opponent, SHADOW_BOLT))
+                return;
+
+        }
+
+        uint8 Afflicted(Unit* target)
+        {
+            if (!target || target->isDead()) return 0;
+            bool aff = HasAuraName(target, UNSTABLE_AFFLICTION, me->GetGUID());
+            bool imm = HasAuraName(target, IMMOLATE, me->GetGUID());
+            if (imm) return 1;
+            if (aff) return 2;
+            return 0;
+        }
+
+        void CheckFear()
+        {
+            if (Unit* u = FindAffectedTarget(FEAR, me->GetGUID()))
+                if (Aura* aura = u->GetAura(FEAR, me->GetGUID()))
+                    if (aura->GetDuration() > 3000)
+                        return;
+            Unit* feartarget = FindFearTarget();
+            if (feartarget && doCast(feartarget, FEAR)) {}
+        }
+
+        //void SummonedCreatureDies(Creature* summon, Unit* /*killer*/)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPetDied();
+        //}
+
+        //void SummonedCreatureDespawn(Creature* summon)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPet(NULL);
+        //}
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Rain_of_fire_cd = 0;
+            Haunt_cd = 0;
+            conflagarate_cd = 0;
+            chaos_bolt_cd = 0;
+            fear_cd = 0;
+
+            if (master)
+            {
+                setStats(CLASS_WARLOCK, me->getRace(), master->getLevel(), true);
+                //TODO: passives
+                ApplyClassPassives();
+                ApplyPassives(CLASS_WARLOCK);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Rain_of_fire_cd > diff)     Rain_of_fire_cd -= diff;
+            if (Haunt_cd > diff)            Haunt_cd -= diff;
+            if (conflagarate_cd > diff)     conflagarate_cd -= diff;
+            if (chaos_bolt_cd > diff)       chaos_bolt_cd -= diff;
+            if (fear_cd > diff)             fear_cd -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            CURSE_OF_THE_ELEMENTS                   = InitSpell(me, CURSE_OF_THE_ELEMENTS_1);
+            SHADOW_BOLT                             = InitSpell(me, SHADOW_BOLT_1);
+            IMMOLATE                                = InitSpell(me, IMMOLATE_1);
+            CONFLAGRATE                 = lvl >= 40 ? CONFLAGRATE_1 : 0;
+  /*Talent*/CHAOS_BOLT                  = lvl >= 60 ? InitSpell(me, CHAOS_BOLT_1) : 0;
+            RAIN_OF_FIRE                            = InitSpell(me, RAIN_OF_FIRE_1);
+  /*Talent*/HAUNT                       = lvl >= 60 ? InitSpell(me, HAUNT_1) : 0;
+            CORRUPTION                              = InitSpell(me, CORRUPTION_1);
+  /*Talent*/UNSTABLE_AFFLICTION         = lvl >= 50 ? InitSpell(me, UNSTABLE_AFFLICTION_1) : 0;
+            FEAR                                    = InitSpell(me, FEAR_1);
+        }
+
+        void ApplyClassPassives() {}
+
+    private:
+        uint32 
+  /*Curses*/CURSE_OF_THE_ELEMENTS, 
+/*Destruct*/SHADOW_BOLT, IMMOLATE, CONFLAGRATE, CHAOS_BOLT, RAIN_OF_FIRE, 
+ /*Afflict*/HAUNT, CORRUPTION, UNSTABLE_AFFLICTION, 
+   /*Other*/FEAR;
+        //Timers
+        uint32 Rain_of_fire_cd, Haunt_cd, conflagarate_cd, chaos_bolt_cd, fear_cd;
+
+        enum WarlockBaseSpells// all orignals
+        {
+            CURSE_OF_THE_ELEMENTS_1             = 1490,
+            SHADOW_BOLT_1                       = 686,
+            IMMOLATE_1                          = 348,
+            CONFLAGRATE_1                       = 17962,
+            CHAOS_BOLT_1                        = 50796,
+            RAIN_OF_FIRE_1                      = 5740,
+            HAUNT_1                             = 59164,
+            CORRUPTION_1                        = 172,
+            UNSTABLE_AFFLICTION_1               = 30404,
+            FEAR_1                              = 6215,
+        };
+        enum WarlockPassives
+        {
+        };
+    };
+};
+
+class voidwalker_bot : public CreatureScript
+{
+public:
+    voidwalker_bot() : CreatureScript("voidwalker_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new voidwalker_botAI(creature);
+    }
+
+    struct voidwalker_botAI : public bot_pet_ai
+    {
+        voidwalker_botAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_NONE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { m_creatureOwner->SetBotsPetDied(); }
+
+        void DoNonCombatActions()
+        {}
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            GetInPosition(force, false);
+            SetBotCommandState(COMMAND_ATTACK);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (me->GetVictim())
+                DoMeleeAttackIfReady();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            if (CCed(me)) return;
+
+            //TODO: add checks to help owner
+
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(PET_TYPE_VOIDWALKER))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //TORMENT
+            if (Torment_cd <= diff && me->GetDistance(opponent) <= 5 && (!tank || tank == me || opponent->GetVictim() == m_creatureOwner))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, TORMENT))
+                    Torment_cd = 5000;
+                GC_Timer = temptimer;
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (m_creatureOwner->IsAIEnabled)
+                if (bot_minion_ai* ai = m_creatureOwner->GetBotMinionAI())
+                    ai->OnOwnerDamagedBy(u);
+        }
+
+        //debug
+        //void ListSpells(ChatHandler* ch) const
+        //{
+        //    ch->PSendSysMessage("Spells list:");
+        //    ch->PSendSysMessage("Torment: %u", TORMENT);
+        //    ch->PSendSysMessage("End of spells list.");
+        //}
+
+        void Reset()
+        {
+            Torment_cd = 0;
+
+            if (master && m_creatureOwner)
+            {
+                setStats(master->getLevel(), PET_TYPE_VOIDWALKER, true);
+                ApplyPassives(PET_TYPE_VOIDWALKER);
+                ApplyClassPassives();
+                SetBaseArmor(162 * master->getLevel());
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Torment_cd > diff)              Torment_cd -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            TORMENT                             = InitSpell(me, TORMENT_1);
+        }
+
+        void ApplyClassPassives() {}
+
+    private:
+        uint32 
+            TORMENT;
+        //Timers
+        uint32 Torment_cd;
+
+        enum VoidwalkerBaseSpells
+        {
+            TORMENT_1                           = 3716,
+        };
+        enum VoidwalkerPassives
+        {
+        };
+    };
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+    new voidwalker_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..f155ef2
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
@@ -0,0 +1,1192 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Warrior NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 50-55%
+TODO: Solve 'DeathWish + Enrage', Thunder Clap, Piercing Howl, Challenging Shout, other tanking stuff
+*/
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warrior_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct warrior_botAI : public bot_minion_ai
+    {
+        warrior_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (rendTarget)
+            {
+                //Glyph of Rending: Increases Rend duration by 6 sec.
+                if (Unit* u = sObjectAccessor->FindUnit(rendTarget))
+                {
+                    if (Aura* rend = u->GetAura(REND, me->GetGUID()))
+                    {
+                        uint32 dur = rend->GetDuration() + 6000;
+                        rend->SetDuration(dur);
+                        rend->SetMaxDuration(dur);
+                    }
+                }
+                rendTarget = 0;
+            }
+            if (IAmDead()) return;
+            if (me->GetVictim())
+                DoMeleeAttackIfReady();
+            else
+                Evade();
+
+            if (ragetimer2 <= diff)
+            {
+                if (me->IsInCombat() && me->getLevel() >= 20)
+                {
+                    if (getrage() < 990)
+                        me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
+                    else
+                        me->SetPower(POWER_RAGE, 1000);//max
+                }
+                ragetimer2 = 2000;
+            }
+            if (ragetimer <= diff)
+            {
+                if (!me->IsInCombat() && !HasAuraName(me, BLOODRAGE_1))
+                {
+                    if (getrage() > uint32(10.f*rageLossMult))
+                        me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult));//-1 rage per 1.5 sec
+                    else
+                        me->SetPower(POWER_RAGE, 0);//min
+                }
+                ragetimer = 1500;
+                //if (getrage() > 1000) me->SetPower(POWER_RAGE, 1000);
+                //if (getrage() < 10) me->SetPower(POWER_RAGE, 0);
+            }
+
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            if (checkAurasTimer == 0)
+            {
+                SS = SWEEPING_STRIKES && me->HasAura(SWEEPING_STRIKES);
+                CheckAuras();
+            }
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            CheckIntervene(diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_WARRIOR))
+            {
+                if (tank != me && !me->IsInCombat() && battleStance != true && master->getAttackers().empty() && stancetimer <= diff)
+                    stanceChange(diff, 1);
+                return;
+            }
+
+            if (Rand() < 30 && battleShout_cd <= diff && GC_Timer <= diff && getrage() > 100 && 
+                !HasAuraName(master, BATTLESHOUT) && 
+                !HasAuraName(master, "Blessing of Might") && 
+                !HasAuraName(master, "Greater Blessing of Might") && 
+                master->IsWithinLOSInMap(me) && 
+                doCast(me, BATTLESHOUT))
+                battleShout_cd = BATTLESHOUT_CD;
+
+            if (Rand() < 20 && BLOODRAGE && bloodrage_cd <= diff && me->IsInCombat() && getrage() < 500 && 
+                !me->HasAura(ENRAGED_REGENERATION))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, BLOODRAGE))
+                {
+                    bloodrage_cd = BLOODRAGE_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == (COMMAND_ATTACK) && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, false);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions(uint32 const /*diff*/)
+        {}
+
+        void modrage(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && rage < uint32(abs(mod)))
+                return;
+
+            if (set)
+                rage = mod*10;
+            else
+                rage += mod*10;
+            me->SetPower(POWER_RAGE, rage);
+        }
+
+        uint32 getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            return rage;
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_DISORIENTED)))
+            {
+                if (BERSERKERRAGE && !me->HasAura(ENRAGED_REGENERATION) && 
+                    berserkerRage_cd <= diff && GC_Timer <= diff && doCast(me, BERSERKERRAGE))
+                {
+                    berserkerRage_cd = BERSERKERRAGE_CD;
+                    if (me->getLevel() >= 40)
+                        modrage(20);
+                    return;
+                }
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            //Keep stance in raid if tank
+            if (master->GetBotTankGuid() == me->GetGUID() && 
+                defensiveStance != true && stancetimer <= diff/* && 
+                (!master->GetGroup() || master->GetGroup()->isRaidGroup())*/)
+                stanceChange(diff, 2);
+            //SelfHeal
+            if (ENRAGED_REGENERATION)
+            {
+                if (Rand() < 20 && GetHealthPCT(me) < 40 && getrage() > 150 && regen_cd <= diff && 
+                    me->HasAuraWithMechanic(MECHANIC_ENRAGED))//no GC_Timer
+                {
+                    temptimer = 0;
+                    if (doCast(me, ENRAGED_REGENERATION))
+                    {
+                        regen_cd = ENRAGED_REGENERATION_CD;
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+                //maybe not needed part
+                if (me->HasAura(ENRAGED_REGENERATION))
+                {
+                    if (HasAuraName(me, "Enrage"))
+                        me->RemoveAurasWithMechanic(MECHANIC_ENRAGED);
+                    if (HasAuraName(me, BLOODRAGE))
+                        me->RemoveAurasDueToSpell(BLOODRAGE);
+                    if (HasAuraName(me, DEATHWISH))
+                        me->RemoveAurasDueToSpell(DEATHWISH);
+                    if (HasAuraName(me, BERSERKERRAGE))
+                        me->RemoveAurasDueToSpell(BERSERKERRAGE);
+                }
+            }//end SelfHeal
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+            //charge + warbringer
+            if (CHARGE && charge_cd <= diff && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) && 
+                (me->getLevel() >= 50 || 
+                (!me->IsInCombat() && (battleStance == true || stanceChange(diff, 1)))))
+            {
+                temptimer = GC_Timer;
+                if (me->getLevel() >= 50)
+                    me->RemoveMovementImpairingAuras();
+                if (doCast(opponent, CHARGE, me->IsInCombat()))
+                {
+                    charge_cd = CHARGE_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //intercept
+            if (INTERCEPT && intercept_cd <= diff && 
+                getrage() > 100 && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) && 
+                !CCed(opponent) && (berserkerStance == true || stanceChange(diff, 3)))
+            {
+                if (doCast(opponent, INTERCEPT))
+                {
+                    intercept_cd = INTERCEPT_CD;
+                    //modrage(-10);
+                    return;
+                }
+            }
+            //FEAR
+            if (Rand() < 70 && INTIMIDATING_SHOUT && getrage() > 250 && intimidatingShout_cd <= diff && GC_Timer <= diff)
+            {
+                if (opponent->IsNonMeleeSpellCasted(false, false, true) && dist <= 8 && 
+                    !(opponent->ToCreature() && opponent->ToCreature()->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                {
+                    if (doCast(opponent, INTIMIDATING_SHOUT))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        return;
+                    }
+                }
+                Unit* fearTarget = NULL;
+                bool triggered = false;
+                uint8 tCount = 0;
+                //fear master's attackers
+                if (!m_attackers.empty() && 
+                    ((master->getClass() != CLASS_DEATH_KNIGHT && 
+                    master->getClass() != CLASS_WARRIOR && 
+                    master->getClass() != CLASS_PALADIN) || 
+                    GetHealthPCT(master) < 70))
+                {
+                    for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, INTIMIDATING_SHOUT, triggered))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        if (triggered)
+                            modrage(-25);
+                        return;
+                    }
+                }
+                //Defend myself
+                if (b_attackers.size() > 1)
+                {
+                    tCount = 0;
+                    fearTarget = NULL;
+                    triggered = false;
+                    for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 0) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 0 && doCast(fearTarget, INTIMIDATING_SHOUT, triggered))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        if (triggered)
+                            modrage(-25);
+                        return;
+                    }
+                }
+            }//end FEAR
+            //OVERPOWER
+            if (OVERPOWER && getrage() > 50 && meleedist <= 5 && GC_Timer <= diff && (battleStance == true || stancetimer <= diff))
+            {
+                bool blood = me->HasAura(TASTE_FOR_BLOOD_BUFF);
+                if ((((opponent->GetTypeId() == TYPEID_PLAYER && UNRELENTING_ASSAULT && blood && opponent->IsNonMeleeSpellCasted(false) && overpower_cd <= 3000) || 
+                    (opponent->IsNonMeleeSpellCasted(false) && blood) || 
+                    (overpower_cd <= diff && blood))))
+                {
+                    if (battleStance == true || stanceChange(diff, 1))
+                    {
+                        if (doCast(opponent, OVERPOWER))
+                        {
+                            overpower_cd = 5000;
+                            if (blood)
+                                me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+                            return;
+                        }
+                    }
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+            //{ wait = 5; return; }
+            //HAMSTRING
+            if (HAMSTRING && Rand() < 50 && getrage() > 100 && GC_Timer <= diff && meleedist <= 5 && opponent->isMoving() && 
+                (battleStance == true || berserkerStance == true || stancetimer <= diff) && 
+                !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (battleStance == true || berserkerStance == true || stanceChange(diff, 5))
+                    if (doCast(opponent, HAMSTRING))
+                        return;
+            }
+            //UBERS
+            //Dont use RETA unless capable circumstances
+            if (Rand() < 20 && uber_cd <= diff && GC_Timer <= diff)//mod here
+            {
+                if (RETALIATION && b_attackers.size() > 4 && 
+                    (battleStance == true || stanceChange(diff, 1)))
+                {
+                    if (doCast(me, RETALIATION))
+                    {
+                        uber_cd = UBER_CD;
+                        return;
+                    }
+                }
+                //Dont use RECKL unless capable circumstances
+                if (RECKLESSNESS && tank != me && 
+                    (m_attackers.size() > 3 || opponent->GetHealth() > me->GetHealth()*10) && 
+                    (berserkerStance == true || stanceChange(diff, 3)))
+                {
+                    if (doCast(me, RECKLESSNESS))
+                    {
+                        uber_cd = UBER_CD;
+                        return;
+                    }
+                }
+            }
+            //DEATHWISH
+            if (DEATHWISH && Rand() < 20 && deathwish_cd <= diff && GC_Timer <= diff && 
+                getrage() > 100 && opponent->GetHealth() > me->GetHealth()/2 && 
+                !me->HasAura(ENRAGED_REGENERATION))//mod here
+            {
+                if (doCast(me, DEATHWISH))
+                {
+                    //modrage(-10);
+                    deathwish_cd = DEATHWISH_CD;
+                    return;
+                }
+            }
+            //TAUNT
+            Unit* u = opponent->GetVictim();
+            if (TAUNT && taunt_cd <= diff && u && u != me && u != tank && dist <= 30 &&
+                (IsInBotParty(u) || tank == me) && !CCed(opponent) && 
+                (defensiveStance == true || (stancetimer <= diff && stanceChange(diff, 2))))//No GCD
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, TAUNT, true))
+                {
+                    taunt_cd = TAUNT_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //EXECUTE
+            if (EXECUTE && tank != me && Rand() < 70 && GC_Timer <= diff && getrage() > 150 && meleedist <= 5 && GetHealthPCT(opponent) < 20 && 
+                (battleStance == true || berserkerStance == true || stancetimer <= diff))
+            {
+                if ((battleStance == true || berserkerStance == true || stanceChange(diff, 5)) && 
+                    doCast(opponent, EXECUTE))
+                {
+                    //sudden death
+                    if (me->getLevel() >= 50 && getrage() <= 400)
+                        modrage(10, true);
+                    else if (getrage() > 300)
+                        modrage(-30);
+                    else
+                        modrage(0, true);
+                    return;
+                }
+            }
+            //SUNDER
+            if (SUNDER && Rand() < 35 && meleedist <= 5 && tank == me && 
+                opponent->GetHealth() > me->GetMaxHealth() && 
+                GC_Timer <= diff && getrage() > 150 && (sunder_cd <= diff || getrage() > 500))
+            {
+                Aura* sunder = opponent->GetAura(SUNDER, me->GetGUID());
+                if ((!sunder || sunder->GetStackAmount() < 5 || sunder->GetDuration() < 15000) && 
+                    doCast(opponent, SUNDER))
+                {
+                    sunder_cd = SUNDER_CD;
+                    GC_Timer = 1000;
+                    return;
+                }
+            }
+            //SS
+            if (SWEEPING_STRIKES && sweeping_strikes_cd <= diff && tank != me && Rand() < 20 && 
+                (battleStance == true || berserkerStance == true || stancetimer <= diff) && 
+                (b_attackers.size() > 1 || FindSplashTarget(7, opponent)))
+            {
+                temptimer = GC_Timer;
+                if ((battleStance == true || berserkerStance == true || stanceChange(diff, 5)) && 
+                    doCast(me, SWEEPING_STRIKES, true))//no rage use as with glyph
+                {
+                    SS = true;
+                    sweeping_strikes_cd = SWEEPING_STRIKES_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //WHIRLWIND
+            if (WHIRLWIND && Rand() < 50 && whirlwind_cd <= diff && GC_Timer <= diff && getrage() >= 250 && 
+               (FindSplashTarget(7, opponent) || (getrage() > 500 && dist <= 7)) && 
+               (berserkerStance == true || stancetimer <= diff))
+            {
+                if ((berserkerStance == true || stanceChange(diff, 3)) && 
+                    doCast(me, WHIRLWIND))
+                {
+                    whirlwind_cd = WHIRLWIND_CD;
+                    return;
+                }
+            }
+            //BLADESTORM
+            if (BLADESTORM && bladestorm_cd <= diff && GC_Timer <= diff && 
+               getrage() >= 250 && (Rand() < 20 || me->HasAura(RECKLESSNESS)) && 
+               (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()))
+            {
+                if (doCast(me, BLADESTORM))
+                {
+                    bladestorm_cd = BLADESTORM_CD;
+                    return;
+                }
+            }
+            //Mortal Strike
+            if (MORTALSTRIKE && getrage() > 300 && meleedist <= 5 && mortalStrike_cd <= diff && GC_Timer <= diff)
+            {
+                if (doCast(opponent, MORTALSTRIKE/*, true*/))
+                {
+                    mortalStrike_cd = MORTALSTRIKE_CD;
+                    slam_cd = 0;//reset here
+                }
+            }
+            //Slam
+            bool triggered = mortalStrike_cd == 7000;
+            if (SLAM && Rand() < (30 + triggered*60) && slam_cd <= diff && getrage() > 150 && meleedist <= 5)
+            {
+                if (doCast(opponent, SLAM, triggered))
+                {
+                    slam_cd = 4500;//4.5sec (must be > MORTALSTRIKE_CD/2)
+                    if (triggered)
+                        modrage(-15);
+                    return;
+                }
+            }
+            //PUMMEL
+            if (PUMMEL && Rand() < 80 && pummel_cd <= diff && getrage() > 100 && meleedist <= 5 && 
+                opponent->IsNonMeleeSpellCasted(false) && 
+                (berserkerStance == true || stancetimer <= diff))
+            {
+                temptimer = GC_Timer;
+                if ((berserkerStance == true || stanceChange(diff, 3)) && 
+                    doCast(opponent, PUMMEL))
+                {
+                    pummel_cd = PUMMEL_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //REND
+            if (REND && Rand() < 30 && getrage() > 100 && GC_Timer <= diff && meleedist <= 5 && 
+                opponent->GetHealth() > me->GetHealth()/2 && 
+                (battleStance == true || defensiveStance == true || stancetimer <= diff) && 
+                !opponent->HasAura(REND, me->GetGUID()))
+            {
+                if ((battleStance == true || defensiveStance == true || stanceChange(diff, 1)) && 
+                    doCast(opponent, REND))
+                {
+                    rendTarget = opponent->GetGUID();
+                    return;
+                }
+            }
+            //Cleave
+            if (Rand() < 30 && CLEAVE && cleave_cd <= diff && me->getLevel() >= 20 && getrage() > 200 && meleedist <= 5)//noGC_Timer
+            {
+                temptimer = GC_Timer;
+                u = FindSplashTarget(5);
+                if (u && doCast(opponent, CLEAVE))
+                {
+                    rage -= 200;//not visible
+                    cleave_cd = me->getAttackTimer(BASE_ATTACK);//once per swing, prevents rage loss
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            else {}//HEROIC STRIKE placeholder
+            //DISARM DEPRECATED
+            /*if (disarm_cd <= diff && meleedist < 5 &&
+                (opponent->GetVictim()->GetGUID() == master->GetGUID() || 
+                opponent->GetVictim()->GetGUID() == m_creature->GetGUID()) &&
+                getrage() > 15 &&
+                !HasAuraName(opponent, GetSpellName(DISARM)) &&
+                GC_Timer <= diff)
+            {
+                if (opponent->getClass() == CLASS_ROGUE  ||
+                    opponent->getClass() == CLASS_WARRIOR   ||
+                    opponent->getClass() == CLASS_SHAMAN    ||
+                    opponent->getClass() == CLASS_PALADIN)
+                {
+                    if (defensiveStance == true)
+                    {
+                        doCast(opponent, DISARM, true);
+                        //rage -= 100;
+                        disarm_cd = DISARM_CD;
+                    }
+                    else stanceChange(diff, 2);
+                }
+            }*/
+        }//end Attack
+
+        void CheckIntervene(uint32 diff)
+        {
+            if (INTERVENE && intervene_cd <= diff && getrage() > 100 && Rand() < ((tank == me) ? 80 : 30) && 
+                (defensiveStance == true || (stancetimer <= diff && !SS)))
+            {
+                if (!master->IsInCombat() && master->getAttackers().empty() && master->isMoving())
+                {
+                    float mydist = me->GetExactDist(master);
+                    if (mydist < 25 && mydist > 18 && (defensiveStance == true || stanceChange(diff, 2)))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(master, INTERVENE))
+                        {
+                            //modrage(-10);
+                            intervene_cd = INTERVENE_CD;
+                            GC_Timer = temptimer;
+                            Follow(true);
+                            return;
+                        }
+                    }
+                }
+                //sLog->outBasic("%s: Intervene check.", me->GetName().c_str());
+                Group* gr = master->GetGroup();
+                if (!gr)
+                {
+                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() && 
+                        me->getAttackers().size() <= master->getAttackers().size())
+                    {
+                        float dist = me->GetExactDist(master);
+                        if (dist > 25 || dist < 10) return;
+                        if (!(defensiveStance == true || stanceChange(diff, 2))) return;
+                        temptimer = GC_Timer;
+                        if (doCast(master, INTERVENE))
+                        {
+                            //modrage(-10);
+                            intervene_cd = INTERVENE_CD;
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                else
+                {
+                    bool Bots = false;
+                    float dist;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        //sLog->outBasic("checking player %s", tPlayer->GetName().c_str());
+                        if (tPlayer->HaveBot())
+                            Bots = true;
+                        if (tPlayer->isDead() || GetHealthPCT(tPlayer) > 90 || tank == tPlayer) continue;
+                        //sLog->outBasic("alive and health < 80%");
+                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
+                        //sLog->outBasic("attackers checked");
+                        dist = me->GetExactDist(tPlayer);
+                        if (dist > 25 || dist < 10) continue;
+                        //sLog->outBasic("and whithin reach");
+                        if ((defensiveStance == true || stanceChange(diff, 2)))
+                        {
+                            //sLog->outBasic("defensive stance acuired, attempt cast");
+                            temptimer = GC_Timer;
+                            if (doCast(tPlayer, INTERVENE))
+                            {
+                                //sLog->outBasic("cast succeed");
+                                //modrage(-10);
+                                intervene_cd = INTERVENE_CD;
+                                GC_Timer = temptimer;
+                                return;
+                            }
+                        }
+                    }
+                    if (!Bots) return;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || !tPlayer->HaveBot()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                        {
+                            Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                            if (!bot || bot == me || bot->isDead()) continue;
+                            if (GetHealthPCT(bot) > 90 || tank == bot) continue;
+                            dist = me->GetExactDist(bot);
+                            if (dist > 25 || dist < 10) continue;
+                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
+                            if ((defensiveStance == true || stanceChange(diff, 2)))
+                            {
+                                //sLog->outBasic("defensive stance acuired, attempt cast");
+                                temptimer = GC_Timer;
+                                if (doCast(bot, INTERVENE))
+                                {
+                                    //sLog->outBasic("cast succeed");
+                                    //modrage(-10);
+                                    intervene_cd = INTERVENE_CD/2; //half for bot
+                                    GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            switch (spell->Id)
+            {
+            case OVERPOWER_1:
+                if (target->GetTypeId() != TYPEID_UNIT || //only creatures lol
+                    !UNRELENTING_ASSAULT)
+                    return;
+                if (target->HasUnitState(UNIT_STATE_CASTING))
+                {
+                    uint32 spell = 0;
+                    if (me->HasAura(UNRELENTING_ASSAULT2))
+                        spell = UNRELENTING_ASSAULT_SPELL2;
+                    else if (me->HasAura(UNRELENTING_ASSAULT1))
+                        spell = UNRELENTING_ASSAULT_SPELL1;
+                    if (!spell)
+                        return;
+                    target->CastSpell(target, spell, true);
+                }
+                break;
+            default:
+                break;
+            }
+        }
+
+        bool stanceChange(uint32 diff, uint8 stance)
+        {
+            if (!(stancetimer <= diff) || !stance)
+                return false;
+
+            if (stance == 5)
+            {
+                switch (urand(0,1))
+                {
+                    case 0:
+                        stance = 1;
+                        break;
+                    case 1:
+                        stance = me->getLevel() < 30 ? 1 : 3;
+                        break;
+                }
+            }
+            if (stance == 2 && (me->getLevel() < 10 || SS))
+                return false;
+            if (stance == 3 && me->getLevel() < 30)
+                return false;
+
+            temptimer = GC_Timer;
+            uint32 temprage = 0;
+            uint32 myrage = me->GetPower(POWER_RAGE);
+            if (me->getLevel() >= 15)
+                temprage = myrage > 250 ? 250 : myrage;
+            else if (me->getLevel() >= 10)
+                temprage = myrage > 100 ? 100 : myrage;
+            switch (stance)
+            {
+                case 1:
+                    if (doCast(me, BATTLESTANCE))
+                    {
+                        if (me->HasAura(BATTLESTANCE)) 
+                        {
+                            battleStance = true;
+                            defensiveStance = false;
+                            berserkerStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 2100 - me->getLevel()*20;//2100-1600 on 80
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 2:
+                    if (doCast(me, DEFENSIVESTANCE))
+                    {
+                        if (me->HasAura(DEFENSIVESTANCE))
+                        {
+                            defensiveStance = true;
+                            battleStance = false;
+                            berserkerStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 2100 - me->getLevel()*20;//2100-1600 on 80
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 3:
+                    if (doCast(me, BERSERKERSTANCE))
+                    {
+                        if (me->HasAura(BERSERKERSTANCE))
+                        {
+                            berserkerStance = true;
+                            battleStance = false;
+                            defensiveStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 2100 - me->getLevel()*20;//2100-1600 on 80
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+            GC_Timer = temptimer;
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+                if (lvl >= 15 && spellId == CLEAVE /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
+                    aftercrit += 15.f;
+                //Improved Overpower: 50% additional critical chance for Overpower
+                if (lvl >= 20 && spellId == OVERPOWER)
+                    aftercrit += 50.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Impale: 20% crit damage bonus for all abilities
+                if (lvl >= 20)
+                    pctbonus += 0.10f;
+            }
+            //Improved Rend: 20% bonus damage for Rend
+            if (spellId == REND)
+                pctbonus += 0.2f;
+            //Improved Whirlwind: 20% bonus damage for Whirlwind
+            if (lvl >= 40 && spellId == WHIRLWIND)
+                pctbonus += 0.2f;
+            //Glyph of Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 40 && spellId == MORTALSTRIKE)
+                pctbonus += 0.1f;
+            //Unrelenting Assault (part 2): 20% bonus damage for Overpower and Revenge
+            if (lvl >= 45 && (spellId == OVERPOWER/* || spellId == REVENGE*/))
+                pctbonus += 0.2f;
+            //Improved Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 45 && spellId == MORTALSTRIKE)
+                pctbonus += 0.1f;
+            //Undending Fury: 10% bonus damage for Whirlwind, Slam and Bloodthirst
+            if (lvl >= 55 && (spellId == WHIRLWIND || spellId == SLAM /*|| spellId == BLOODTHIRST*/))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            slam_cd = 0;
+            regen_cd = 20000;
+            sweeping_strikes_cd = 0;
+            charge_cd = 0;
+            deathwish_cd = 0;
+            mortalStrike_cd = 0;
+            overpower_cd = 0;
+            uber_cd = 0;
+            berserkerRage_cd = 0;
+            battleShout_cd = 0;
+            intercept_cd = 0;
+            intimidatingShout_cd = 0;
+            pummel_cd = 0;
+            whirlwind_cd = 5000;
+            cleave_cd = 0;
+            bladestorm_cd = 10000;
+            bloodrage_cd = 0;
+            intervene_cd = 0;
+            taunt_cd = 0;
+            sunder_cd = 0;
+            stancetimer = 0;
+            ragetimer = 1500;
+            ragetimer2 = 3000;
+
+            rendTarget = 0;
+
+            battleStance = true;
+            defensiveStance = false;
+            berserkerStance = false;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            me->setPowerType(POWER_RAGE);
+            rage = 0;
+
+            if (master)
+            {
+                setStats(CLASS_WARRIOR, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_WARRIOR);
+                //mob generates abnormal amounts rage so increase/reduce rate with level(from 188% down to 30% at level 80)//not seems to work
+                //for (int8 i = 0; i < 3; ++i)
+                //    me->ApplyEffectModifiers(sSpellMgr->GetSpellInfo(29623), i, float(90 - master->getLevel()*2));
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (regen_cd > diff)                    regen_cd -= diff;
+            if (slam_cd > diff)                     slam_cd -= diff;
+            if (battleShout_cd > diff)              battleShout_cd -= diff;
+            if (sweeping_strikes_cd > diff)         sweeping_strikes_cd -= diff;
+            if (deathwish_cd > diff)                deathwish_cd -= diff;
+            if (mortalStrike_cd > diff)             mortalStrike_cd -= diff;
+            if (overpower_cd > diff)                overpower_cd -= diff;
+            if (uber_cd > diff)                     uber_cd -= diff;
+            if (berserkerRage_cd > diff)            berserkerRage_cd -= diff;
+            if (charge_cd > diff)                   charge_cd -= diff;
+            if (intercept_cd > diff)                intercept_cd -= diff;
+            if (intimidatingShout_cd > diff)        intimidatingShout_cd -= diff;
+            if (pummel_cd > diff)                   pummel_cd -= diff;
+            if (whirlwind_cd > diff)                whirlwind_cd -= diff;
+            if (bladestorm_cd > diff)               bladestorm_cd -= diff;
+            if (cleave_cd > diff)                   cleave_cd -= diff;
+            if (bloodrage_cd > diff)                bloodrage_cd -= diff;
+            if (intervene_cd > diff)                intervene_cd -= diff;
+            if (taunt_cd > diff)                    taunt_cd -= diff;
+            if (sunder_cd > diff)                   sunder_cd -= diff;
+
+            if (stancetimer > diff)                 stancetimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            //CHALLENGING_SHOUT                       = InitSpell(me, CHALLENGING_SHOUT_1);
+            INTIMIDATING_SHOUT                      = InitSpell(me, INTIMIDATING_SHOUT_1);
+            ENRAGED_REGENERATION                    = InitSpell(me, ENRAGED_REGENERATION_1);
+            CHARGE                                  = InitSpell(me, CHARGE_1);
+            OVERPOWER                               = InitSpell(me, OVERPOWER_1);
+   /*Quest*/TAUNT                       = lvl >= 10 ? TAUNT_1 : 0;
+            //DISARM                                  = InitSpell(DISARM_1);
+            BLOODRAGE                               = InitSpell(me, BLOODRAGE_1);
+            BERSERKERRAGE                           = InitSpell(me, BERSERKERRAGE_1);
+            INTERCEPT                               = InitSpell(me, INTERCEPT_1);
+            CLEAVE                                  = InitSpell(me, CLEAVE_1);
+            HAMSTRING                               = InitSpell(me, HAMSTRING_1);
+            INTERVENE                               = InitSpell(me, INTERVENE_1);
+            WHIRLWIND                               = InitSpell(me, WHIRLWIND_1);
+  /*Talent*/BLADESTORM                  = lvl >= 60 ? BLADESTORM_1 : 0;
+            BATTLESHOUT                             = InitSpell(me, BATTLESHOUT_1);
+            REND                                    = InitSpell(me, REND_1);
+            EXECUTE                                 = InitSpell(me, EXECUTE_1);
+            PUMMEL                                  = InitSpell(me, PUMMEL_1);
+  /*Talent*/MORTALSTRIKE                = lvl >= 40 ? InitSpell(me, MORTALSTRIKE_1) : 0;
+            SLAM                                    = InitSpell(me, SLAM_1);
+   /*Quest*/SUNDER                      = lvl >= 10 ? InitSpell(me, SUNDER_1) : 0;
+  /*Talent*/SWEEPING_STRIKES            = lvl >= 30 ? SWEEPING_STRIKES_1 : 0;
+            BATTLESTANCE                            = BATTLESTANCE_1;
+   /*Quest*/DEFENSIVESTANCE             = lvl >= 10 ? DEFENSIVESTANCE_1 : 0;
+   /*Quest*/BERSERKERSTANCE             = lvl >= 30 ? BERSERKERSTANCE_1 : 0;
+            RECKLESSNESS                            = InitSpell(me, RECKLESSNESS_1);
+            RETALIATION                             = InitSpell(me, RETALIATION_1);
+  /*Talent*/DEATHWISH                   = lvl >= 30 ? DEATHWISH_1 : 0;
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 70)
+                RefreshAura(WC5); //10%
+            else if (level >= 68)
+                RefreshAura(WC4); //8%
+            else if (level >= 66)
+                RefreshAura(WC3); //6%
+            else if (level >= 64)
+                RefreshAura(WC2); //4%
+            else if (level >= 62)
+                RefreshAura(WC1); //2%
+            if (level >= 39)
+                RefreshAura(FLURRY5); //30%
+            else if (level >= 38)
+                RefreshAura(FLURRY4); //24%
+            else if (level >= 37)
+                RefreshAura(FLURRY3); //18%
+            else if (level >= 36)
+                RefreshAura(FLURRY2); //12%
+            else if (level >= 35)
+                RefreshAura(FLURRY1); //6%
+            if (level >= 60)
+                RefreshAura(SWORD_SPEC5,2);//twice
+            else if (level >= 50)
+                RefreshAura(SWORD_SPEC5);//once
+            else if (level >= 45)
+                RefreshAura(SWORD_SPEC4);//once
+            else if (level >= 40)
+                RefreshAura(SWORD_SPEC3);//once
+            else if (level >= 35)
+                RefreshAura(SWORD_SPEC2);//once
+            else if (level >= 30)
+                RefreshAura(SWORD_SPEC1);//once
+            if (level >= 60)
+                RefreshAura(RAMPAGE);
+            if (level >= 55)
+                RefreshAura(TRAUMA2);//30%
+            else if (level >= 35)
+                RefreshAura(TRAUMA1);//15%
+            if (level >= 50)
+            {
+                RefreshAura(UNRELENTING_ASSAULT2);
+                UNRELENTING_ASSAULT = true;
+            }
+            else if (level >= 45)
+            {
+                RefreshAura(UNRELENTING_ASSAULT1);
+                UNRELENTING_ASSAULT = true;
+            }
+            if (level >= 45)
+                RefreshAura(BLOOD_FRENZY);
+            if (level >= 40)
+                RefreshAura(SECOND_WIND);
+            if (level >= 40)
+                RefreshAura(TOUGHNESS,2);//-60%
+            else if (level >= 15)
+                RefreshAura(TOUGHNESS);//-30%
+            if (level >= 40)
+                RefreshAura(IMP_HAMSTRING,2);//30%
+            else if (level >= 35)
+                RefreshAura(IMP_HAMSTRING);//15%
+            if (level >= 30)
+                RefreshAura(TASTE_FOR_BLOOD3);//100%
+            else if (level >= 28)
+                RefreshAura(TASTE_FOR_BLOOD2);//66%
+            else if (level >= 25)
+                RefreshAura(TASTE_FOR_BLOOD1);//33%
+            if (level >= 30)
+                RefreshAura(BLOOD_CRAZE3);
+            else if (level >= 25)
+                RefreshAura(BLOOD_CRAZE2);
+            else if (level >= 20)
+                RefreshAura(BLOOD_CRAZE1);
+            //BloodRage Absorb
+            if (level >= 60)
+                RefreshAura(WARRIOR_T10_4P);
+        }
+
+    private:
+        uint32
+  /*Shouts*/INTIMIDATING_SHOUT, BATTLESHOUT, CHALLENGING_SHOUT, 
+ /*Charges*/CHARGE, INTERCEPT, INTERVENE, 
+  /*Damage*/OVERPOWER, CLEAVE, REND, EXECUTE, WHIRLWIND, BLADESTORM, MORTALSTRIKE, SLAM, 
+ /*Stances*/BATTLESTANCE, DEFENSIVESTANCE, BERSERKERSTANCE, 
+   /*Ubers*/RECKLESSNESS, RETALIATION, DEATHWISH, 
+  /*Others*/TAUNT, DISARM, BLOODRAGE, ENRAGED_REGENERATION, BERSERKERRAGE, HAMSTRING, PUMMEL, SUNDER, SWEEPING_STRIKES;
+
+        //CDs/Timers/misc
+/*shts*/uint32 battleShout_cd, intimidatingShout_cd;
+/*chrg*/uint32 charge_cd, intercept_cd, intervene_cd;;
+ /*Dmg*/uint32 mortalStrike_cd, overpower_cd, slam_cd, whirlwind_cd, cleave_cd, bladestorm_cd;
+/*else*/uint32 regen_cd, sweeping_strikes_cd, deathwish_cd, uber_cd, berserkerRage_cd, pummel_cd, 
+            bloodrage_cd, taunt_cd, sunder_cd;
+/*tmrs*/uint32 stancetimer, ragetimer, ragetimer2;
+/*misc*/uint64 rendTarget;
+/*misc*/uint32 rage;
+/*misc*/float rageIncomeMult, rageLossMult;
+/*Chck*/bool battleStance, defensiveStance, berserkerStance, SS, UNRELENTING_ASSAULT;
+
+        enum WarriorBaseSpells
+        {
+            //CHALLENGING_SHOUT_1                     = 1161,
+            INTIMIDATING_SHOUT_1                    = 5246,
+            ENRAGED_REGENERATION_1                  = 55694,
+            CHARGE_1                                = 11578,
+            OVERPOWER_1                             = 7384,
+            TAUNT_1                                 = 355,
+            //DISARM_1                                = 676,
+            BLOODRAGE_1                             = 2687,
+            BERSERKERRAGE_1                         = 18499,
+            INTERCEPT_1                             = 20252,
+            CLEAVE_1                                = 845,//59992,
+            HAMSTRING_1                             = 1715,
+            INTERVENE_1                             = 3411,
+            WHIRLWIND_1                             = 1680,
+            BLADESTORM_1                            = 46924,//67541,
+            BATTLESHOUT_1                           = 6673,
+            REND_1                                  = 772,
+            EXECUTE_1                               = 5308,
+            PUMMEL_1                                = 6552,
+            MORTALSTRIKE_1                          = 12294,
+            SLAM_1                                  = 1464,
+            SUNDER_1                                = 7386,//16145,
+            SWEEPING_STRIKES_1                      = 12328,
+            BATTLESTANCE_1                          = 2457,//7165, //2457, original warrior one
+            DEFENSIVESTANCE_1                       = 71,//71, original warrior one
+            BERSERKERSTANCE_1                       = 2458,//7366, //2458, original warrior spell
+            RECKLESSNESS_1                          = 13847,//1719, original warrior spell
+            RETALIATION_1                           = 22857,//20230, original warrior spell
+            DEATHWISH_1                             = 12292,
+        };
+        enum WarriorPassives
+        {
+        //Talents
+            WC1  /*WRECKING CREW1*/                 = 46867,
+            WC2  /*WRECKING CREW2*/                 = 56611,
+            WC3  /*WRECKING CREW3*/                 = 56612,
+            WC4  /*WRECKING CREW4*/                 = 56613,
+            WC5  /*WRECKING CREW5*/                 = 56614,
+            FLURRY1                                 = 16256,
+            FLURRY2                                 = 16281,
+            FLURRY3                                 = 16282,
+            FLURRY4                                 = 16283,
+            FLURRY5                                 = 16284,
+            SWORD_SPEC1                             = 12281,
+            SWORD_SPEC2                             = 12812,
+            SWORD_SPEC3                             = 12813,
+            SWORD_SPEC4                             = 12814,
+            SWORD_SPEC5                             = 12815,
+            BLOOD_CRAZE1                            = 16487,
+            BLOOD_CRAZE2                            = 16489,
+            BLOOD_CRAZE3                            = 16492,
+            TASTE_FOR_BLOOD1                        = 56636,
+            TASTE_FOR_BLOOD2                        = 56637,
+            TASTE_FOR_BLOOD3                        = 56638,
+            UNRELENTING_ASSAULT1                    = 46859,
+            UNRELENTING_ASSAULT2                    = 46860,
+            TRAUMA1                                 = 46854,
+            TRAUMA2                                 = 46855,
+            BLOOD_FRENZY                            = 29859,
+            RAMPAGE                                 = 29801,
+            SECOND_WIND                             = 29838,//rank 2
+            TOUGHNESS                               = 12764,//rank 5
+            IMP_HAMSTRING                           = 23695,//rank 3
+        //other
+            WARRIOR_T10_4P                          = 70844,
+        };
+        enum WarriorSpecial
+        {
+            TASTE_FOR_BLOOD_BUFF                    = 60503,
+            UNRELENTING_ASSAULT_SPELL1              = 64849,
+            UNRELENTING_ASSAULT_SPELL2              = 64850,
+        };
+        enum WarriorCooldowns
+        {
+            ENRAGED_REGENERATION_CD = 90000, //1.5 min
+            SWEEPING_STRIKES_CD     = 30000,
+            CHARGE_CD               = 15000,
+            DEATHWISH_CD            = 90000, //1.5 min
+            MORTALSTRIKE_CD         = 7000,
+            UBER_CD                 = 150000, //RETALIATION_RECKLESSNESS_SHIELDWALL 2.5 min NEED SEPARATE
+            BERSERKERRAGE_CD        = 25000,
+            INTERCEPT_CD            = 15000,
+            INTIMIDATINGSHOUT_CD    = 45000,
+            PUMMEL_CD               = 10000,
+            WHIRLWIND_CD            = 8000,
+            BLADESTORM_CD           = 60000,
+            BLOODRAGE_CD            = 40000,
+            //DISARM_CD               = 40000,
+            INTERVENE_CD            = 25000,
+            BATTLESHOUT_CD          = 25000,
+            //SPELLREFLECTION_CD      = 8000,
+            TAUNT_CD                = 8000,
+            SUNDER_CD               = 7000,
+        };
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
new file mode 100644
index 0000000..f8dbfc6
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommands.cpp
@@ -0,0 +1,633 @@
+/*
+Name: script_bot_commands
+%Complete: ???
+Comment: Npcbot related commands
+Category: commandscripts/custom/
+*/
+
+#include "bot_ai.h"
+#include "bothelper.h"
+#include "Chat.h"
+#include "Config.h"
+#include "Group.h"
+#include "Language.h"
+#include "Player.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+
+class script_bot_commands : public CommandScript
+{
+public:
+    script_bot_commands() : CommandScript("script_bot_commands") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand npcbotCommandTable[] =
+        {
+            { "info",           SEC_PLAYER,         false, &HandleNpcBotInfoCommand,                    "", NULL },
+            { "add",            SEC_PLAYER,         false, &HandleNpcBotAddCommand,                     "", NULL },
+            { "revive",         SEC_MODERATOR,      false, &HandleNpcBotReviveCommand,                  "", NULL },
+            { "remove",         SEC_PLAYER,         false, &HandleNpcBotRemoveCommand,                  "", NULL },
+            { "reset",          SEC_PLAYER,         false, &HandleNpcBotResetCommand,                   "", NULL },
+            { "command",        SEC_PLAYER,         false, &HandleNpcBotCommandCommand,                 "", NULL },
+            { "distance",       SEC_PLAYER,         false, &HandleNpcBotDistanceCommand,                "", NULL },
+            { "helper",         SEC_PLAYER,         false, &HandleBotHelperCommand,                     "", NULL },
+            //{ "reloadequips",   SEC_ADMINISTRATOR,  false, &HandleReloadEquipsCommand,                  "", NULL },
+            { NULL,             0,                  false, NULL,                                        "", NULL }
+        };
+
+        static ChatCommand commandTable[] =
+        {
+            { "maintank",       SEC_PLAYER,         false, &HandleMainTankCommand,                      "", NULL },
+            { "mt",             SEC_PLAYER,         false, &HandleMainTankCommand,                      "", NULL },
+            { "npcbot",         SEC_PLAYER,         false, NULL,                          "", npcbotCommandTable },
+            { NULL,             0,                  false, NULL,                                        "", NULL }
+        };
+        return commandTable;
+    }
+
+    //static bool HandleReloadEquipsCommand(ChatHandler* handler, const char* /*args*/)
+    //{
+    //    sLog->outInfo(LOG_FILTER_GENERAL, "Re-Loading Creature Equips...");
+    //    sObjectMgr->LoadEquipmentTemplates();
+    //    handler->SendGlobalGMSysMessage("DB table `creature_equip_template` (creature equipment) reloaded.");
+    //    return true;
+    //}
+
+    static bool HandleBotHelperCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        handler->SetSentErrorMessage(true);
+        if (/*player->IsInCombat() ||*/
+            player->isDead() ||
+            !player->IsAlive() ||
+            player->IsInFlight() ||
+            player->IsCharmed() ||
+            bot_ai::CCed(player))
+        {
+            handler->SendSysMessage("You cannot do this right now");
+            return false;
+        }
+        //close current menu
+        player->PlayerTalkClass->SendCloseGossip();
+        if (player->GetTrader())
+            player->GetSession()->SendCancelTrade();
+
+        BotHelper* hlpr = player->GetBotHelper();
+        if (!hlpr)
+        {
+            hlpr = new BotHelper(player);
+            player->SetBotHelper(hlpr);
+        }
+        return hlpr->OnGossipHello(player);
+    }
+
+    static bool HandleMainTankCommand(ChatHandler* handler, const char* args)
+    {
+        Group* group = handler->GetSession()->GetPlayer()->GetGroup();
+        if (!group)
+        {
+            handler->PSendSysMessage("Must be in a group to use main tank command.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        uint64 myguid = handler->GetSession()->GetPlayer()->GetGUID();
+        if (!group->IsLeader(myguid) && !group->IsAssistant(myguid))
+        {
+            handler->PSendSysMessage("you have no permission to set main tank.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!*args)
+        {
+            if (uint64 selection = handler->GetSession()->GetPlayer()->GetSelection())
+            {
+                if (group->IsMember(selection))
+                {
+                    if (Unit* u = ObjectAccessor::FindUnit(selection))
+                    {
+                        bool isabot = u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->GetIAmABot();
+                        if (isabot && group->GetMemberSlots().size() < 3 && handler->GetSession()->GetSecurity() == SEC_PLAYER)
+                        {
+                            handler->PSendSysMessage("Your party is too small to set a npcbot main tank.");
+                            handler->SetSentErrorMessage(true);
+                            return false;
+                        }
+                        group->RemoveUniqueGroupMemberFlag(MEMBER_FLAG_MAINTANK);
+                        Group::MemberSlotList const& members = group->GetMemberSlots();
+                        for (Group::MemberSlotList::const_iterator itr = members.begin(); itr != members.end(); ++itr)
+                        {
+                            uint8 flags = itr->flags;
+                            if (group->isRaidGroup())
+                            {
+                                //try to set flags in group (will fail if not raid)
+                                group->SetGroupMemberFlag(itr->guid, itr->guid == selection, MEMBER_FLAG_MAINTANK);
+                            }
+                            else //force flags for non-raid group (DB only) this will allow bots to find tank
+                            {
+                                if (itr->guid == selection && !(flags & MEMBER_FLAG_MAINTANK))
+                                    flags |= MEMBER_FLAG_MAINTANK;
+                            }
+                            //store result if DB
+                            if (itr->guid != selection || !group->isRaidGroup())
+                            {
+                                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GROUP_MEMBER_FLAG);
+                                stmt->setUInt8(0, flags);
+                                stmt->setUInt32(1, GUID_LOPART(itr->guid));
+                                CharacterDatabase.Execute(stmt);
+                            }
+                            //send result to players and their bots
+                            if (!IS_PLAYER_GUID(itr->guid))
+                                continue;
+                            if (Player* player = ObjectAccessor::FindPlayer(itr->guid))
+                            {
+                                ChatHandler chp(player->GetSession());
+                                chp.PSendSysMessage("Main tank is set to %s.", u->GetName().c_str());
+                                player->SetBotTank(selection);
+                                if (player->HaveBot())
+                                {
+                                    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                                    {
+                                        Creature* cre = player->GetBotMap(i)->_Cre();
+                                        if (cre)
+                                            cre->SetBotTank(u);
+                                    }
+                                }
+                            }
+                        }
+                        u->HandleEmoteCommand(EMOTE_ONESHOT_CHEER);
+                        handler->SetSentErrorMessage(true);
+                        return true;
+                    }
+                }
+            }
+            if (Unit* unit = bot_ai::GetBotGroupMainTank(group))
+            {
+                bool bot = unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->GetIAmABot();
+                handler->PSendSysMessage("Main tank is %s (%s%s).", unit->GetName().c_str(), (bot ? "npcbot" : "player"), (unit->IsAlive() ? "" : ", dead"));
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->PSendSysMessage(".maintank");
+            handler->PSendSysMessage("Allows to set a main tank in bot party (can be used on npcbots). Determines npcbots' actions");
+            handler->PSendSysMessage("Npcbot maintank also receives damage reduction, avoidance and threat generation bonus");
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        else
+        {
+            //clear tank in whole bot party
+            std::string cmdStr = strtok((char*)args, " ");
+            if (!cmdStr.compare("clear") || !cmdStr.compare("cl") || !cmdStr.compare("cle") ||
+                !cmdStr.compare("reset") || !cmdStr.compare("res"))
+            {
+                Group::MemberSlotList const& members = group->GetMemberSlots();
+                for (Group::MemberSlotList::const_iterator itr = members.begin(); itr != members.end(); ++itr)
+                {
+                    uint8 flags = itr->flags;
+                    if (group->isRaidGroup())
+                    {
+                        if (flags & MEMBER_FLAG_MAINTANK)
+                            group->SetGroupMemberFlag(itr->guid, false, MEMBER_FLAG_MAINTANK);
+                    }
+                    else
+                    {
+                        if (itr->flags & MEMBER_FLAG_MAINTANK)
+                            flags &= ~MEMBER_FLAG_MAINTANK;
+                    }
+                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GROUP_MEMBER_FLAG);
+                    stmt->setUInt8(0, flags);
+                    stmt->setUInt32(1, GUID_LOPART(itr->guid));
+                    CharacterDatabase.Execute(stmt);
+                    if (!IS_PLAYER_GUID(itr->guid))
+                        continue;
+                    Player* player = ObjectAccessor::FindPlayer(itr->guid);
+                    if (!player) continue;
+                    ChatHandler(player->GetSession()).PSendSysMessage("Main tank has been reset by %s.", handler->GetSession()->GetPlayer()->GetName().c_str());
+                    player->SetBotTank(0);
+                    if (player->HaveBot())
+                    {
+                        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                        {
+                            Creature* cre = player->GetBotMap(i)->_Cre();
+                            if (cre)
+                                cre->SetBotTank(NULL);
+                        }
+                    }
+                }
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+        }
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotInfoCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->GetSelection())
+        {
+            handler->PSendSysMessage(".npcbot info");
+            handler->PSendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your party memebers");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master || (owner->GetGroup() ? !owner->GetGroup()->IsMember(master->GetGUID()) : master->GetGUID() != owner->GetGUID()))
+        {
+            handler->PSendSysMessage("You should select self or one of your party memebers.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!master->HaveBot())
+        {
+            handler->PSendSysMessage("%s has no NpcBots!", master->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Listing NpcBots for %s", master->GetName().c_str());
+        handler->PSendSysMessage("Owned NpcBots: %u", master->GetNpcBotsCount());
+        for (uint8 i = CLASS_WARRIOR; i != MAX_CLASSES; ++i)
+        {
+            uint8 count = 0;
+            uint8 alivecount = 0;
+            for (uint8 pos = 0; pos != master->GetMaxNpcBots(); ++pos)
+            {
+                if (Creature* cre = master->GetBotMap(pos)->_Cre())
+                {
+                    if (cre->GetBotClass() == i)
+                    {
+                        ++count;
+                        if (cre->IsAlive())
+                            ++alivecount;
+                    }
+                }
+            }
+            char const* bclass;
+            switch (i)
+            {
+            case CLASS_WARRIOR:         bclass = "Warriors";        break;
+            case CLASS_PALADIN:         bclass = "Paladins";        break;
+            case CLASS_MAGE:            bclass = "Mages";           break;
+            case CLASS_PRIEST:          bclass = "Priests";         break;
+            case CLASS_WARLOCK:         bclass = "Warlocks";        break;
+            case CLASS_DRUID:           bclass = "Druids";          break;
+            case CLASS_DEATH_KNIGHT:    bclass = "DeathKnights";    break;
+            case CLASS_ROGUE:           bclass = "Rogues";          break;
+            case CLASS_SHAMAN:          bclass = "Shamans";         break;
+            case CLASS_HUNTER:          bclass = "Hunters";         break;
+            default:                    bclass = "Unknown Class";   break;
+            }
+            if (count > 0)
+                handler->PSendSysMessage("%s: %u (alive: %u)", bclass, count, alivecount);
+        }
+        return true;
+    }
+
+    static bool HandleNpcBotDistanceCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            if (owner->HaveBot())
+            {
+                handler->PSendSysMessage("bot follow distance is %u", owner->GetBotFollowDist());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage(".npcbot distance");
+            handler->PSendSysMessage("Sets 'distance to target' at which bots will follow you");
+            handler->PSendSysMessage("if set to 0, bots will not attack anything unless you point them");
+            handler->PSendSysMessage("min: 0, max: 75");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* distance = strtok((char*)args, " ");
+        int8 dist = -1;
+
+        if (distance)
+            dist = (int8)atoi(distance);
+
+        if (dist >= 0 && dist <= 75)
+        {
+            owner->SetBotFollowDist(dist);
+            if (!owner->IsInCombat() && owner->HaveBot())
+            {
+                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+                {
+                    Creature* cre = owner->GetBotMap(i)->_Cre();
+                    if (!cre || !cre->IsInWorld()) continue;
+                    owner->SendBotCommandState(cre, COMMAND_FOLLOW);
+                }
+            }
+            Group* gr = owner->GetGroup();
+            if (gr && owner->GetMap()->Instanceable() && /*gr->isRaidGroup() &&*/ gr->IsLeader(owner->GetGUID()))
+            {
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (pl && pl->IsInWorld() && pl->GetMap() == owner->GetMap())
+                    {
+                        pl->SetBotFollowDist(dist);
+                        if (!pl->IsInCombat() && pl->HaveBot())
+                        {
+                            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+                            {
+                                Creature* cre = pl->GetBotMap(i)->_Cre();
+                                if (!cre || !cre->IsInWorld()) continue;
+                                pl->SendBotCommandState(cre, COMMAND_FOLLOW);
+                            }
+                        }
+                    }
+                }
+            }
+            handler->PSendSysMessage("bot follow distance set to %u", dist);
+            return true;
+        }
+        handler->SendSysMessage("follow distance should be between 0 and 75");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotCommandCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            handler->PSendSysMessage(".npcbot command <command>");
+            handler->PSendSysMessage("Forces npcbots to either follow you or hold position.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* command = strtok((char*)args, " ");
+        int8 state = -1;
+        if (!strncmp(command, "s", 2) || !strncmp(command, "st", 3) || !strncmp(command, "stay", 5) || !strncmp(command, "stand", 6))
+            state = COMMAND_STAY;
+        else if (!strncmp(command, "f", 2) || !strncmp(command, "follow", 7) || !strncmp(command, "fol", 4) || !strncmp(command, "fo", 3))
+            state = COMMAND_FOLLOW;
+        if (state >= 0 && owner->HaveBot())
+        {
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature* cre = owner->GetBotMap(i)->_Cre();
+                if (!cre || !cre->IsInWorld()) continue;
+                owner->SendBotCommandState(cre, CommandStates(state));
+            }
+            return true;
+        }
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotRemoveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        uint64 guid = owner->GetSelection();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot remove");
+            handler->PSendSysMessage("Remove selected npcbots. Select yourself to remove all npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (guid == owner->GetGUID())
+        {
+            if (owner->HaveBot())
+            {
+                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+                    owner->RemoveBot(owner->GetBotMap(i)->_Guid(), true);
+
+                if (!owner->HaveBot())
+                {
+                    handler->PSendSysMessage("Npcbots successfully removed");
+                    handler->SetSentErrorMessage(true);
+                    return true;
+                }
+                handler->PSendSysMessage("Some npcbots were not removed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage("Npcbots are not found!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        
+        Creature* cre = ObjectAccessor::GetCreature(*owner, guid);
+        if (cre && cre->GetIAmABot())
+        {
+            Player* master = cre->GetBotOwner();
+            if (!master || (master->GetGUID() != owner->GetGUID()))
+            {
+                handler->PSendSysMessage("You can only remove your own bots");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            uint8 pos = master->GetNpcBotSlot(guid);
+            master->RemoveBot(cre->GetGUID(), true);
+            if (master->GetBotMap(pos)->_Cre() == NULL)
+            {
+                handler->PSendSysMessage("NpcBot successfully removed");
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->PSendSysMessage("NpcBot was NOT removed for some stupid reason!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        handler->PSendSysMessage("You should select self or your npcbot!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotResetCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Player* master = NULL;
+        bool all = false;
+        uint64 guid = owner->GetSelection();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot reset");
+            handler->PSendSysMessage("Reset selected npcbot, or all npcbots if used on self");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (IS_PLAYER_GUID(guid))
+        {
+            master = owner;
+            all = true;
+        }
+        else if (IS_CREATURE_GUID(guid))
+        {
+            if (Creature* cre = ObjectAccessor::GetCreature(*owner, guid))
+                master = cre->GetBotOwner();
+        }
+        if (master && master->GetGUID() == owner->GetGUID())
+        {
+            if (master->IsInCombat() && master->GetSession()->GetSecurity() == SEC_PLAYER)
+            {
+                handler->PSendSysMessage("Cannot reset bots in combat!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("Npcbots are not found!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            {
+                if (all)
+                    master->RemoveBot(master->GetBotMap(i)->_Guid());
+                else if (master->GetBotMap(i)->_Guid() == guid)
+                {
+                    master->RemoveBot(guid);
+                    break;
+                }
+            }
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot reset");
+        handler->PSendSysMessage("Reset selected npcbot. Cannot be used in combat");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+    //For debug purposes only
+    static bool HandleNpcBotReviveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        if (handler->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            handler->PSendSysMessage("Revive command is disabled");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (owner->InBattleground())
+        {
+            handler->PSendSysMessage("Bot revival is disabled in pvp matches");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->IsInFlight())
+        {
+            handler->PSendSysMessage("Bot revival is disabled in flight");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->HaveBot())
+        {
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature* bot = owner->GetBotMap(i)->_Cre();
+                if (!bot) continue;
+                if (bot->isDead())
+                {
+                    owner->SetBot(bot);
+                    owner->CreateBot(0, 0, 0, false, true);
+                }
+            }
+            handler->PSendSysMessage("NpcBots revived");
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot revive");
+        handler->PSendSysMessage("Revive your npcbots if you are all hopelessly dead");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotAddCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        uint64 sel = owner->GetSelection();
+        if (!*args || sel != owner->GetGUID())
+        {
+            handler->PSendSysMessage(".npcbot add");
+            handler->PSendSysMessage("Allows to create npcbot of given class, you should select yourself");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->RestrictBots())
+        {
+            handler->GetSession()->SendNotification("This place is restricted for NpcBots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->isDead())
+        {
+            owner->GetSession()->SendNotification("You're dead!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetGroup() && owner->GetGroup()->isRaidGroup() && owner->GetGroup()->IsFull())
+        {
+            handler->PSendSysMessage("Group is full, aborted");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetNpcBotsCount() >= owner->GetMaxNpcBots())
+        {
+            handler->PSendSysMessage("NpcBots limit exceed");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* bclass = strtok((char*)args, " ");
+        uint8 botclass = CLASS_NONE;
+
+        if (!strncmp(bclass, "deathknight", 12) || !strncmp(bclass, "dk", 3) || !strncmp(bclass, "de", 3))
+            botclass = CLASS_DEATH_KNIGHT;
+        else if (!strncmp(bclass, "druid", 6) || !strncmp(bclass, "dru", 4) || !strncmp(bclass, "dr", 3))
+            botclass = CLASS_DRUID;
+        else if (!strncmp(bclass, "hunter", 7) || !strncmp(bclass, "hunt", 5) || !strncmp(bclass, "hu", 3))
+            botclass = CLASS_HUNTER;
+        else if (!strncmp(bclass, "mage", 5) || !strncmp(bclass, "ma", 3))
+            botclass = CLASS_MAGE;
+        else if (!strncmp(bclass, "paladin", 8) || !strncmp(bclass, "pal", 4) || !strncmp(bclass, "pa", 3))
+            botclass = CLASS_PALADIN;
+        else if (!strncmp(bclass, "priest", 7) || !strncmp(bclass, "pri", 4) || !strncmp(bclass, "pr", 3))
+            botclass = CLASS_PRIEST;
+        else if (!strncmp(bclass, "rogue", 6) || !strncmp(bclass, "rog", 4) || !strncmp(bclass, "ro", 3))
+            botclass = CLASS_ROGUE;
+        else if (!strncmp(bclass, "shaman", 7) || !strncmp(bclass, "sha", 4) || !strncmp(bclass, "sh", 3))
+            botclass = CLASS_SHAMAN;
+        else if (!strncmp(bclass, "warlock", 8) || !strncmp(bclass, "warl", 5) || !strncmp(bclass, "lock", 5))
+            botclass = CLASS_WARLOCK;
+        else if (!strncmp(bclass, "warrior", 8) || !strncmp(bclass, "warr", 5))
+            botclass = CLASS_WARRIOR;
+
+        if (botclass == CLASS_NONE)
+        {
+            handler->PSendSysMessage("Wrong bot class");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint8 bots = owner->GetNpcBotsCount();
+        owner->CreateNPCBot(botclass);
+        owner->RefreshBot(0);
+        if (owner->GetNpcBotsCount() > bots)
+        {
+            if (owner->IsInCombat())
+                handler->PSendSysMessage("NpcBot successfully created (%s). Will appear out of combat", owner->GetName().c_str());
+            else
+                handler->PSendSysMessage("NpcBot successfully created (%s).", owner->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage("NpcBot is NOT created for some reason!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+};
+
+void AddSC_script_bot_commands()
+{
+    new script_bot_commands();
+}
diff --git a/src/server/game/AI/NpcBots/bothelper.cpp b/src/server/game/AI/NpcBots/bothelper.cpp
new file mode 100644
index 0000000..f9e401d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bothelper.cpp
@@ -0,0 +1,421 @@
+/*
+Bot Helper by Graff (onlysuffering@gmail.com)
+Type: empty-type player-to-self dialog-like manager for npcbot mod
+Complete: ???
+Category: scripts/custom/bots
+*/
+
+#include "bothelper.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Language.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "ScriptedCreature.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+
+const uint8 GroupIcons[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+enum HelperActions
+{
+    ACTION_ENABLE                                               = 1,
+    ACTION_DISABLE                                              = 2,
+    ACTION_TOGGLE                                               = 3
+};
+
+enum BotgiverTexIDs
+{
+    ABANDON_MINION                                              = 3,
+    RECRUIT_MINION                                              = 4,
+    ABOUT_STR                                                   = 5,
+    ADD_ALL                                                     = 6,
+    REMOVE_ALL                                                  = 7,
+    RECRUIT_WARRIOR                                             = 8,
+    RECRUIT_HUNTER                                              = 9,
+    RECRUIT_PALADIN                                             = 10,
+    RECRUIT_SHAMAN                                              = 11,
+    RECRUIT_ROGUE                                               = 12,
+    RECRUIT_DRUID                                               = 13,
+    RECRUIT_MAGE                                                = 14,
+    RECRUIT_PRIEST                                              = 15,
+    RECRUIT_WARLOCK                                             = 16,
+    RECRUIT_DEATH_KNIGHT                                        = 17,
+    ABOUT_BASIC_STR1                                            = 18,
+    ABOUT_BASIC_STR2                                            = 19,
+    ABOUT_BASIC_STR3                                            = 20,
+    ABOUT_ICONS_STR1                                            = 21,
+    ABOUT_ICONS_STR2                                            = 22,
+    ICON_STRING_STAR                                            = 23,
+    ICON_STRING_CIRCLE                                          = 24,
+    ICON_STRING_DIAMOND                                         = 25,
+    ICON_STRING_TRIANGLE                                        = 26,
+    ICON_STRING_MOON                                            = 27,
+    ICON_STRING_SQUARE                                          = 28,
+    ICON_STRING_CROSS                                           = 29,
+    ICON_STRING_SKULL                                           = 30,
+    ICON_STRING_UNKNOWN                                         = 31,
+    NO_MORE_AVAILABLE                                           = 32,
+    ONE_MORE_AVAILABLE                                          = 33,
+    SOME_MORE_AVAILABLE                                         = 34,
+    ONE_AVAILABLE                                               = 35,
+    SOME_AVAILABLE                                              = 36,
+
+    ENABLE_STRING,
+    DISABLE_STRING,
+    TOGGLE_STRING,
+    BACK_STRING,
+    ALL_STRING,
+    MAX_STRINGS
+};
+
+enum HelperGossip
+{
+    SENDER_CREATE_NBOT_MENU                                     = 1,
+    SENDER_CREATE_NBOT                                          = 2,
+    SENDER_REMOVE_NBOT_MENU                                     = 7,
+    SENDER_REMOVE_NBOT                                          = 8,
+
+    SENDER_INFO_WHISPER                                         = 9,
+
+    SENDER_MAIN_PAGE,
+    MAX_SENDERS
+};
+
+BotHelper::BotHelper(Player* const master) : _master(master) { }
+BotHelper::~BotHelper() {}
+
+bool BotHelper::OnGossipSelect(Player* player, uint32 sender, uint32 action)
+{
+    switch (sender)
+    {
+        case SENDER_MAIN_PAGE:                          OnGossipHello(player);                              break;
+
+        case SENDER_CREATE_NBOT_MENU:                   SendCreateNPCBotMenu(player, action);               break;
+        case SENDER_CREATE_NBOT:                        SendCreateNPCBot(player, action);                   break;
+        case SENDER_REMOVE_NBOT_MENU:                   SendRemoveNPCBotMenu(player, action);               break;
+        case SENDER_REMOVE_NBOT:                        SendRemoveNPCBot(player, action);                   break;
+
+        case SENDER_INFO_WHISPER:                       SendBotHelpWhisper(player, action);                 break;
+
+        default:
+            break;
+    }
+    return true;
+}
+
+bool BotHelper::OnGossipHello(Player* player)
+{
+    player->PlayerTalkClass->ClearMenus(); //in case of return;
+
+    uint8 count = 0;
+
+    uint8 maxNBcount = player->GetMaxNpcBots();
+
+    bool allowNBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true) && !player->RestrictBots();
+
+    std::string tempstr;
+
+    if (player->HaveBot())
+    {
+        count = player->GetNpcBotsCount();
+        if (count > 0)
+        {
+            tempstr = "Abandon my Minion";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(4, 0, GetLocaleStringForTextID(tempstr, ABANDON_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_REMOVE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 4, "", 0);
+        }
+        if (count < maxNBcount && allowNBots)
+        {
+            tempstr = "Recruit a Minion";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(2, 0, GetLocaleStringForTextID(tempstr, RECRUIT_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 2, "", 0);
+        }
+    }
+    else if (allowNBots && maxNBcount != 0)
+    {
+        tempstr = "Recruit a Minion";
+        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(2, 0, GetLocaleStringForTextID(tempstr, RECRUIT_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 2, "", 0);
+    }
+
+    tempstr = "Tell me about these bots";
+    player->PlayerTalkClass->GetGossipMenu().AddMenuItem(6, 0, GetLocaleStringForTextID(tempstr, ABOUT_STR, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_INFO_WHISPER, GOSSIP_ACTION_INFO_DEF + 6, "", 0);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+    return true;
+}
+
+void BotHelper::SendRemoveNPCBot(Player* player, uint32 action)
+{
+    int8 x = action - GOSSIP_ACTION_INFO_DEF;
+    if (x == 1)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+        return;
+    }
+    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+    {
+        if (!player->GetBotMap(i)->_Cre())
+            continue;
+        if (x == 2)
+        {
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+            break;
+        }
+        --x;
+    }
+    player->CLOSE_GOSSIP_MENU();
+}
+
+void BotHelper::SendRemoveNPCBotMenu(Player* player, uint32 /*action*/)
+{
+    player->PlayerTalkClass->ClearMenus();
+    if (player->GetNpcBotsCount() == 1)
+    {
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+        player->CLOSE_GOSSIP_MENU();
+        return;
+    }
+    std::string tempstr = "REMOVE ALL";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, REMOVE_ALL, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_REMOVE_NBOT, GOSSIP_ACTION_INFO_DEF + 1);
+
+    uint8 x = 2;
+    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+    {
+        Creature* bot = player->GetBotMap(i)->_Cre();
+        if (!bot) continue;
+        player->ADD_GOSSIP_ITEM(9, bot->GetName(), SENDER_REMOVE_NBOT, GOSSIP_ACTION_INFO_DEF + x);
+        ++x;
+    }
+
+    tempstr = "BACK";
+    player->ADD_GOSSIP_ITEM(0, GetLocaleStringForTextID(tempstr, BACK_STRING, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_MAIN_PAGE, GOSSIP_ACTION_INFO_DEF + x);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+}
+
+void BotHelper::SendCreateNPCBot(Player* player, uint32 action)
+{
+    uint8 bot_class = 0;
+    if (action == GOSSIP_ACTION_INFO_DEF + 1)//"Back"
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return;
+    }
+    else if (action == GOSSIP_ACTION_INFO_DEF + 2)
+        bot_class = CLASS_WARRIOR;
+    //else if (action == GOSSIP_ACTION_INFO_DEF + 3)
+    //    bot_class = CLASS_HUNTER;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 4)
+        bot_class = CLASS_PALADIN;
+    //else if (action == GOSSIP_ACTION_INFO_DEF + 5)
+    //    bot_class = CLASS_SHAMAN;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 6)
+        bot_class = CLASS_ROGUE;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 7)
+        bot_class = CLASS_DRUID;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 8)
+        bot_class = CLASS_MAGE;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 9)
+        bot_class = CLASS_PRIEST;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 10)
+        bot_class = CLASS_WARLOCK;
+    //else if (action == GOSSIP_ACTION_INFO_DEF + 11)
+    //    bot_class = CLASS_DEATH_KNIGHT;
+
+    if (bot_class != 0)
+        player->CreateNPCBot(bot_class);
+    player->CLOSE_GOSSIP_MENU();
+    return;
+}
+
+void BotHelper::SendCreateNPCBotMenu(Player* player, uint32 /*action*/)
+{
+    std::string cost = player->GetNpcBotCostStr();
+    player->PlayerTalkClass->ClearMenus();
+
+    std::string tempstr = "Recruit a Warrior ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_WARRIOR, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 2);
+    //tempstr = "Recruit a Hunter ";
+    //player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_HUNTER, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 3);
+    tempstr = "Recruit a Paladin ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_PALADIN, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 4);
+    //tempstr = "Recruit a Shaman ";
+    //player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_SHAMAN, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 5);
+    tempstr = "Recruit a Rogue ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_ROGUE, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 6);
+    tempstr = "Recruit a Druid ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_DRUID, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 7);
+    tempstr = "Recruit a Mage ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_MAGE, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 8);
+    tempstr = "Recruit a Priest ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_PRIEST, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 9);
+    tempstr = "Recruit a Warlock ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_WARLOCK, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 10);
+    //tempstr = "Recruit a Death Knight ";
+    //player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_DEATH_KNIGHT, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 11);
+
+    std::ostringstream buff;
+    uint8 bots = player->GetNpcBotsCount();
+    uint8 maxNBcount = player->GetMaxNpcBots();
+    uint32 freeNBSlots = maxNBcount - bots;
+
+    if (freeNBSlots == 0)
+    {
+        tempstr = "no more bots available";
+        buff << GetLocaleStringForTextID(tempstr, NO_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+    }
+    else
+    {
+        buff << freeNBSlots;
+        buff << ' ';
+        if (freeNBSlots == 1)
+        {
+            if (bots == 0)
+            {
+                tempstr = "bot available";
+                buff << GetLocaleStringForTextID(tempstr, ONE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+            else
+            {
+                tempstr = "more bot available";
+                buff << GetLocaleStringForTextID(tempstr, ONE_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+        }
+        else
+        {
+            if (bots == 0)
+            {
+                tempstr = "bots available";
+                buff << GetLocaleStringForTextID(tempstr, SOME_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+            else
+            {
+                tempstr = "more bots available";
+                buff << GetLocaleStringForTextID(tempstr, SOME_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+        }
+    }
+    player->ADD_GOSSIP_ITEM(0, buff.str(), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 12);
+
+    tempstr = "BACK";
+    player->ADD_GOSSIP_ITEM(0, GetLocaleStringForTextID(tempstr, BACK_STRING, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_MAIN_PAGE, GOSSIP_ACTION_INFO_DEF + 13);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+}
+
+void BotHelper::SendBotHelpWhisper(Player* player, uint32 /*action*/)
+{
+    player->CLOSE_GOSSIP_MENU();
+    ChatHandler ch(player->GetSession());
+    //Basic
+    std::string tempstr = "To see list of available npcbot commands type .npcbot or .npcb";
+    std::string msg2 = GetLocaleStringForTextID(tempstr, ABOUT_BASIC_STR2, player->GetSession()->GetSessionDbLocaleIndex());
+    tempstr = "You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan";
+    std::string msg3 = GetLocaleStringForTextID(tempstr, ABOUT_BASIC_STR3, player->GetSession()->GetSessionDbLocaleIndex());
+    ch.SendSysMessage(msg2.c_str());
+    ch.SendSysMessage(msg3.c_str());
+    //Heal Icons
+    uint8 mask = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
+    std::string msg4 = "";
+    if (mask == 255)
+    {
+        tempstr = "If you want your npcbots to heal someone out of your party set any raid target icon on them";
+        msg4 = GetLocaleStringForTextID(tempstr, ABOUT_ICONS_STR1, player->GetSession()->GetSessionDbLocaleIndex());
+        ch.SendSysMessage(msg4.c_str());
+    }
+    else if (mask != 0)
+    {
+        tempstr = "If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ";
+        msg4 = GetLocaleStringForTextID(tempstr, ABOUT_ICONS_STR2, player->GetSession()->GetSessionDbLocaleIndex());
+        std::string iconrow = "";
+        uint8 count = 0;
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (mask & GroupIcons[i])
+            {
+                if (count != 0)
+                    iconrow += ", ";
+                ++count;
+                switch (i)
+                {
+                    case 0:
+                        tempstr = "star";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_STAR, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 1:
+                        tempstr = "circle";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_CIRCLE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 2:
+                        tempstr = "diamond";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_DIAMOND, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 3:
+                        tempstr = "triangle";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_TRIANGLE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 4:
+                        tempstr = "moon";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_MOON, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 5:
+                        tempstr = "square";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_SQUARE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 6:
+                        tempstr = "cross";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_CROSS, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 7:
+                        tempstr = "skull";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_SKULL, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    default:
+                        tempstr = "unknown icon";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_UNKNOWN, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                }
+            }
+        }
+        msg4 += iconrow;
+        ch.SendSysMessage(msg4.c_str());
+    }
+}
+
+std::string BotHelper::GetLocaleStringForTextID(std::string& textValue, uint32 textId, int32 localeIdx)
+{
+    if (textId >= MAX_STRINGS)
+    {
+        TC_LOG_ERROR(LOG_FILTER_PLAYER, "botgiver:GetLocaleStringForTextID:: unknown text id: %u!", uint32(textId));
+        return textValue;
+    }
+
+    if (localeIdx == DEFAULT_LOCALE)
+        return textValue; //use default
+
+    if (localeIdx < 0)
+    {
+        TC_LOG_ERROR(LOG_FILTER_PLAYER, "botgiver:GetLocaleStringForTextID:: unknown locale: %i! Sending default locale text...", localeIdx);
+        return textValue;
+    }
+
+    uint32 idxEntry = MAKE_PAIR32(60000, textId);
+    if (GossipMenuItemsLocale const* no = sObjectMgr->GetGossipMenuItemsLocale(idxEntry))
+        ObjectMgr::GetLocaleString(no->OptionText, localeIdx, textValue);
+    return textValue;
+}
diff --git a/src/server/game/AI/NpcBots/bothelper.h b/src/server/game/AI/NpcBots/bothelper.h
new file mode 100644
index 0000000..1310b4d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bothelper.h
@@ -0,0 +1,32 @@
+#ifndef _BOTHLP_H
+#define _BOTHLP_H
+
+#include "Common.h"
+
+class Player;
+
+class BotHelper
+{
+    public:
+        BotHelper(Player* const master);
+        ~BotHelper();
+
+        Player* GetOwner() const { return _master; }
+
+        static bool OnGossipHello(Player* player);
+        static bool OnGossipSelect(Player* player, uint32 sender, uint32 action);
+
+    private:
+        static void SendRemoveNPCBot(Player* player, uint32 action);
+        static void SendRemoveNPCBotMenu(Player* player, uint32 /*action*/);
+        static void SendCreateNPCBot(Player* player, uint32 action);
+        static void SendCreateNPCBotMenu(Player* player, uint32 /*action*/);
+
+
+        static void SendBotHelpWhisper(Player* player, uint32 /*action*/);
+        static std::string GetLocaleStringForTextID(std::string& textValue, uint32 textId, int32 localeIdx = 0);
+
+        Player* const _master;
+};
+
+#endif
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
new file mode 100644
index 0000000..467f1e0
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
@@ -0,0 +1,376 @@
+/**
+ *
+ * @File : sc_npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 28/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+//#include "ProgressBar.h"
+
+#define TELE    nsNpcTel::CatDest
+#define PAGE    nsNpcTel::Page
+#define PAGEI   PAGE::Instance
+
+
+nsNpcTel::VCatDest nsNpcTel::TabCatDest;
+
+
+uint32 PAGE::operator [] (Player * const player) const
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i].GetPageId();
+    }
+    return 0;
+}
+
+PAGE::Instance & PAGE::operator () (Player * const player)
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i];
+    }
+    m_TabInstance.push_back(Instance(player));
+    return m_TabInstance.back();
+}
+
+PAGE::Instance & PAGEI::operator = (const uint32 &id)
+{
+    m_PageId = id;
+    return *this;
+}
+
+PAGE::Instance & PAGEI::operator ++ (void)
+{
+    ++m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator ++ (int32)
+{
+    Instance tmp (*this);
+    ++m_PageId;
+    return tmp;
+}
+
+PAGE::Instance & PAGEI::operator -- (void)
+{
+    --m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator -- (int32)
+{
+    Instance tmp (*this);
+    --m_PageId;
+    return tmp;
+}
+
+TELE::CatDest(const uint32 &id, const std::string &name,
+              const Flag &flag, const uint64 &data0, const uint32 &data1)
+    : m_id(id), m_name(name), m_flag(flag), m_data0(data0), m_data1(data1)
+{
+    m_TabDest.clear();
+}
+
+std::string TELE::GetName(const bool IsGM /* = false */) const
+{
+    if (!IsGM || m_flag != FLAG_TEAM)
+        return m_name;
+
+    switch (m_data0)
+    {
+      case TEAM_HORDE:      return std::string(m_name + " (H)");
+      case TEAM_ALLIANCE:   return std::string(m_name + " (A)");
+    }
+    return m_name;
+}
+
+bool TELE::IsAllowedToTeleport(Player * const player) const
+{
+    if (player->IsGameMaster())
+    {
+        if (m_flag == FLAG_GMLEVEL)
+            return player->GetSession()->GetSecurity() >= m_data0;
+        return true;
+    }
+
+    switch (m_flag)
+    {
+      case FLAG_TEAM:
+        switch (m_data0)
+        {
+          case TEAM_HORDE:      return player->GetTeam() == HORDE;
+          case TEAM_ALLIANCE:   return player->GetTeam() == ALLIANCE;
+          case TEAM_ALL:        return true;
+        }
+
+      case FLAG_GUILD:
+        return player->GetGuildId() == m_data0;
+
+      case FLAG_GMLEVEL:
+        return player->GetSession()->GetSecurity() >= m_data0;
+
+      case FLAG_ISGM:
+        return player->IsGameMaster();
+
+      case FLAG_ACCOUNT:
+        return player->GetSession()->GetAccountId() == m_data0;
+
+      case FLAG_LEVEL:
+        return player->getLevel() >= m_data0;
+
+      case FLAG_ITEM:
+        return player->HasItemCount(m_data0, m_data1, true);
+
+      case FLAG_QUEST:
+        if (m_data1 < MAX_QUEST_STATUS)
+            return player->GetQuestStatus(m_data0) == m_data1;
+        return player->GetQuestRewardStatus(m_data0);
+
+      case FLAG_GENDER:
+        return player->getGender() == m_data0;
+
+      case FLAG_RACE:
+        return player->getRace() == m_data0;
+
+      case FLAG_CLASS:
+        return player->getClass() == m_data0;
+
+      case FLAG_REPUTATION:
+        return player->GetReputationRank(m_data0) >= m_data1;
+
+      case FLAG_PLAYER:
+        return player->GetGUID() == m_data0;
+    }
+
+    sLog->outError(LOG_FILTER_GENERAL, "Invalid flag (category: %u). Important problem...", GetCatID());
+    return false;
+}
+
+uint32 TELE::CountOfCategoryAllowedBy(Player * const player)
+{
+    uint32 count (0);
+    for (VCatDest_t i(0); i < TabCatDest.size(); ++i)
+    {
+        if (TabCatDest[i].IsAllowedToTeleport(player))
+            ++count;
+    }
+    return count;
+}
+
+bool nsNpcTel::IsValidData(const uint32 &cat,   const Flag &flag,
+                           const uint64 &data0, const uint32 &data1)
+{
+    switch(flag)
+    {
+      case FLAG_TEAM:
+        if (data1)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (category: %u).", cat);
+        if (data0 < MAX_FLAG_TEAM)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (Team) (category: %u).", cat);
+        return false;
+
+      case FLAG_GUILD:
+        if (data1)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (GuildID) (category: %u).", cat);
+        return false;
+
+      case FLAG_GMLEVEL:
+        if (data1)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (GmLevel) (category: %u).", cat);
+        return false;
+
+      case FLAG_ISGM:
+        if (data0)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (category: %u).", cat);
+        if (data1)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (category: %u).", cat);
+        return true;
+
+      case FLAG_ACCOUNT:
+        if (data1)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (AccountID) (category: %u).", cat);
+        return false;
+
+      case FLAG_LEVEL:
+        if (data1)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (Level) (category: %u).", cat);
+        return false;
+
+      case FLAG_ITEM:
+        if (!data0)
+        {
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (ItemID) (category: %u).", cat);
+            return false;
+        }
+        if (data1)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (Item Count) (category: %u).", cat);
+        return false;
+
+      case FLAG_QUEST:
+        if (!data0)
+        {
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (QuestID) (category: %u).", cat);
+            return false;
+        }
+        if (data1 < MAX_QUEST_STATUS + 1)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (Quest Status) (category: %u).", cat);
+        return false;
+
+      case FLAG_GENDER:
+        if (data1)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (category: %u).", cat);
+        if (data0 < GENDER_NONE)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (Gender) (category: %u).", cat);
+        return false;
+
+      case FLAG_RACE:
+        if (data1)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_RACES)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (Race) (category: %u).", cat);
+        return false;
+
+      case FLAG_CLASS:
+        if (data1)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_CLASSES)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (Class) (category: %u).", cat);
+        return false;
+
+      case FLAG_REPUTATION:
+        if (!data0)
+        {
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (Faction/Reputation) (category: %u).", cat);
+            return false;
+        }
+        if (data1 <= REP_EXALTED)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (Faction/Reputation) (category: %u).", cat);
+        return false;
+
+      case FLAG_PLAYER:
+        if (data1)
+            sLog->outError(LOG_FILTER_GENERAL, "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError(LOG_FILTER_GENERAL, "Invalid data0 (PlayerGuid) (category: %u).", cat);
+        return false;
+    }
+
+    sLog->outError(LOG_FILTER_GENERAL, "Invalid flag (category: %u).", cat);
+    return false;
+}
+
+void LoadNpcTele(void)
+{
+    const char *Table[] =
+    {
+        "custom_npc_tele_category",
+        "custom_npc_tele_destination",
+        "custom_npc_tele_association",
+    };
+
+
+    QueryResult result = WorldDatabase.PQuery(
+        "SELECT `flag`, `data0`, `data1`, `cat_id`, C.`name` `namecat`, D.`name` `namedest`, "
+        //      0        1        2        3                  4                   5
+               "`pos_X`, `pos_Y`, `pos_Z`, `orientation`, `map`, `level`, `cost` "
+        //      6        7        8        9              10     11       12
+        "FROM `%s` C, `%s` D, `%s` A "
+        "WHERE C.`id` = `cat_id` AND D.`id` = `dest_id` "
+        "ORDER BY `namecat`, `cat_id`, `namedest`", Table[0], Table[1], Table[2]);
+
+    nsNpcTel::TabCatDest.clear();
+
+    if (result)
+    {
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading %s, %s and %s...", Table[0], Table[1], Table[2]);
+        // barGoLink bar(result->GetRowCount());
+
+        uint32 catid = 0;
+        uint32 nbDest = 0;
+        bool IsValidCat = true;
+        bool FirstTime = true;
+
+        do
+        {
+            // bar.step();
+            Field *fields = result->Fetch();
+
+            if (!IsValidCat && catid == fields[3].GetUInt32() && !FirstTime)
+                continue;
+
+            IsValidCat = true;
+            FirstTime = false;
+
+            if (!nsNpcTel::IsValidData(fields[3].GetUInt32(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                       fields[1].GetUInt64(), fields[2].GetUInt32()))
+            {
+                IsValidCat = false;
+                catid = fields[3].GetUInt32();
+                continue;
+            }
+
+            if (catid != fields[3].GetUInt32())
+            {
+                catid = fields[3].GetUInt32();
+                nsNpcTel::CatDest categorie (catid, fields[4].GetString(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                             fields[1].GetUInt64(), fields[2].GetUInt32());
+                nsNpcTel::TabCatDest.push_back(categorie);
+            }
+
+            nsNpcTel::Dest item =
+            {
+                fields[5].GetString(),   // Name
+                fields[6].GetFloat(),       // X
+                fields[7].GetFloat(),       // Y
+                fields[8].GetFloat(),       // Z
+                fields[9].GetFloat(),       // Orientation
+                fields[10].GetUInt16(),     // Map
+                fields[11].GetUInt8(),      // Level
+                fields[12].GetUInt32(),     // Cost
+            };
+
+            nsNpcTel::TabCatDest.back().AddDest(item);
+            ++nbDest;
+        } while (result->NextRow());
+
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "");
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loaded %u npc_teleport.", nbDest);
+    } else sLog->outError(LOG_FILTER_GENERAL, "WARNING >> Loaded 0 npc_teleport.");
+}
+
+
+#undef TELE
+#undef PAGE
+#undef PAGEI
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.h b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
new file mode 100644
index 0000000..4830245
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
@@ -0,0 +1,151 @@
+/**
+ *
+ * @File : sc_npc_teleport.h
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#ifndef SC_NPC_TELEPORT_H
+#define SC_NPC_TELEPORT_H
+
+#include <vector>
+
+
+namespace nsNpcTel
+{
+    // Different types of permissions
+    enum Flag
+    {
+        FLAG_TEAM       = 0,
+        FLAG_GUILD      = 1,
+        FLAG_GMLEVEL    = 2,
+        FLAG_ISGM       = 3,
+        FLAG_ACCOUNT    = 4,
+        FLAG_LEVEL      = 5,
+        FLAG_ITEM       = 6,
+        FLAG_QUEST      = 7,
+        FLAG_GENDER     = 8,
+        FLAG_RACE       = 9,
+        FLAG_CLASS      = 10,
+        FLAG_REPUTATION = 11,
+        FLAG_PLAYER     = 12,
+        MAX_FLAG,
+    };
+
+    // Different parameters of FLAG_TEAM
+    enum
+    {
+        TEAM_ALL        = 0,
+        TEAM_ALLIANCE   = 1,
+        TEAM_HORDE      = 2,
+        MAX_FLAG_TEAM,
+    };
+
+    // Structure representing the destinations
+    struct Dest
+    {
+        std::string m_name;
+        float       m_X, m_Y, m_Z, m_orient;
+        uint16      m_map;
+        uint8       m_level;
+        uint32      m_cost;
+    };
+
+    // Class representing the categories of destinations
+    class CatDest
+    {
+      public:
+
+        typedef std::vector<Dest> VDest;
+        typedef VDest::size_type  VDest_t;
+
+        CatDest(const uint32 &id, const std::string &name,
+                const Flag &flag, const uint64 &data0, const uint32 &data1);
+
+        void   AddDest  (const Dest &item)       { m_TabDest.push_back(item); }
+        Dest   GetDest  (const uint32 &id) const { return m_TabDest[id]; }
+        uint32 GetCatID (void)             const { return m_id; }
+        uint32 size     (void)             const { return m_TabDest.size(); }
+
+        std::string GetName(const bool IsGM = false)    const;
+        bool IsAllowedToTeleport(Player * const player) const;
+
+        static uint32 CountOfCategoryAllowedBy(Player * const player);
+
+      private:
+
+        uint32      m_id;
+        std::string m_name;
+        Flag        m_flag;
+        uint64      m_data0;
+        uint32      m_data1;
+        VDest       m_TabDest;
+    };
+
+    // Class page for current player
+    class Page
+    {
+      protected:
+
+        // Class instance for current player
+        class Instance
+        {
+          public:
+
+            Instance(Player * const player, const uint32 &PageId = 0)
+                : m_player(player), m_PageId(PageId) {}
+
+            Instance & operator =  (const uint32 &id);
+            Instance & operator ++ (void);
+            Instance   operator ++ (int32);
+            Instance & operator -- (void);
+            Instance   operator -- (int32);
+
+            uint32   GetPageId(void) const { return m_PageId; }
+            Player * GetPlayer(void) const { return m_player; }
+
+          private:
+
+            Player *m_player;
+            uint32  m_PageId;
+        };
+
+
+      public:
+
+        typedef std::vector<Instance> VInst;
+        typedef VInst::size_type      VInst_t;
+
+        Page(void) { m_TabInstance.clear(); }
+
+        Instance &   operator () (Player * const player);
+        uint32 operator [] (Player * const player) const;
+
+
+      private:
+
+        VInst m_TabInstance;
+    };
+
+    typedef std::vector <CatDest> VCatDest;
+    typedef VCatDest::size_type   VCatDest_t;
+
+    // Verification of data integrity
+    bool IsValidData(const uint32 &cat,   const Flag &flag,
+                     const uint64 &data0, const uint32 &data1);
+
+    extern VCatDest TabCatDest;
+}
+
+// Loading contents of database
+void LoadNpcTele(void);
+
+extern WorldDatabaseWorkerPool WorldDatabase;
+
+#endif
diff --git a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
new file mode 100644
index 0000000..e42de84
--- /dev/null
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
@@ -0,0 +1,2003 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ObjectMgr.h"
+#include "AuctionHouseMgr.h"
+#include "AuctionHouseBot.h"
+#include "Player.h"
+#include <vector>
+
+using namespace std;
+vector<uint32> npcItems;
+vector<uint32> glyphItemsBin;
+vector<uint32> lootItems;
+vector<uint32> greyTradeGoodsBin;
+vector<uint32> whiteTradeGoodsBin;
+vector<uint32> greenTradeGoodsBin;
+vector<uint32> blueTradeGoodsBin;
+vector<uint32> purpleTradeGoodsBin;
+vector<uint32> orangeTradeGoodsBin;
+vector<uint32> yellowTradeGoodsBin;
+vector<uint32> greyItemsBin;
+vector<uint32> whiteItemsBin;
+vector<uint32> greenItemsBin;
+vector<uint32> blueItemsBin;
+vector<uint32> purpleItemsBin;
+vector<uint32> orangeItemsBin;
+vector<uint32> yellowItemsBin;
+
+AuctionHouseBot::AuctionHouseBot()
+{
+    debug_Out = false;
+    debug_Out_Filters = false;
+    AHBSeller = false;
+    AHBBuyer = false;
+
+    //Begin Filters
+
+    Vendor_Items = false;
+    Loot_Items = false;
+    Other_Items = false;
+    Vendor_TGs = false;
+    Loot_TGs = false;
+    Other_TGs = false;
+
+    No_Bind = false;
+    Bind_When_Picked_Up = false;
+    Bind_When_Equipped = false;
+    Bind_When_Use = false;
+    Bind_Quest_Item = false;
+
+    DisablePermEnchant = false;
+    DisableConjured = false;
+    DisableGems = false;
+    DisableMoney = false;
+    DisableMoneyLoot = false;
+    DisableLootable = false;
+    DisableKeys = false;
+    DisableDuration = false;
+    DisableBOP_Or_Quest_NoReqLevel = false;
+
+    DisableWarriorItems = false;
+    DisablePaladinItems = false;
+    DisableHunterItems = false;
+    DisableRogueItems = false;
+    DisablePriestItems = false;
+    DisableDKItems = false;
+    DisableShamanItems = false;
+    DisableMageItems = false;
+    DisableWarlockItems = false;
+    DisableUnusedClassItems = false;
+    DisableDruidItems = false;
+
+    DisableItemsBelowLevel = 0;
+    DisableItemsAboveLevel = 0;
+    DisableTGsBelowLevel = 0;
+    DisableTGsAboveLevel = 0;
+    DisableItemsBelowGUID = 0;
+    DisableItemsAboveGUID = 0;
+    DisableTGsBelowGUID = 0;
+    DisableTGsAboveGUID = 0;
+    DisableItemsBelowReqLevel = 0;
+    DisableItemsAboveReqLevel = 0;
+    DisableTGsBelowReqLevel = 0;
+    DisableTGsAboveReqLevel = 0;
+    DisableItemsBelowReqSkillRank = 0;
+    DisableItemsAboveReqSkillRank = 0;
+    DisableTGsBelowReqSkillRank = 0;
+    DisableTGsAboveReqSkillRank = 0;
+	//glyphs patch
+	SellGlyphs = false;
+	GlyphsCount = 0;
+	DisableGlyphBelowLevel = 0;
+	DisableGlyphAboveLevel = 0;
+	GlyphBuyOutPriceMin = 0;
+	GlyphBuyOutPriceMax = 0;
+	GlyphBidPriceMin = 0;
+	GlyphBidPriceMax = 0;
+	// <- end glyphs patch
+
+    //End Filters
+
+    _lastrun_a = time(NULL);
+    _lastrun_h = time(NULL);
+    _lastrun_n = time(NULL);
+
+    AllianceConfig = AHBConfig(2);
+    HordeConfig = AHBConfig(6);
+    NeutralConfig = AHBConfig(7);
+}
+
+AuctionHouseBot::~AuctionHouseBot()
+{
+}
+
+void AuctionHouseBot::addNewAuctions(Player *AHBplayer, AHBConfig *config)
+{
+	bool glyphMode = false;
+
+    if (!AHBSeller)
+    {
+        if (debug_Out) sLog->outInfo(LOG_FILTER_GENERAL, "AHSeller: Disabled");
+        return;
+    }
+
+    uint32 minItems = config->GetMinItems();
+    uint32 maxItems = config->GetMaxItems();
+
+    if (maxItems == 0)
+    {
+        //if (debug_Out) sLog->outInfo(LOG_FILTER_GENERAL, "AHSeller: Auctions disabled");
+        return;
+    }
+
+    AuctionHouseEntry const* ahEntry =  sAuctionMgr->GetAuctionHouseEntry(config->GetAHFID());
+    if (!ahEntry)
+    {
+        return;
+    }
+    AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+    if (!auctionHouse)
+    {
+        return;
+    }
+
+    uint32 auctions = auctionHouse->Getcount();
+
+    uint32 items = 0;
+
+    if (auctions >= minItems)
+    {
+        glyphMode = true;
+        //if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHSeller: Auctions above minimum");
+        return;
+    }
+
+	if(SellGlyphs)
+	{
+		if(GlyphsCount <= 0)
+			GlyphsCount = 400;
+    if (auctions >= minItems)
+        glyphMode = true;
+
+    if (auctions >= maxItems)
+    {
+        //if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHSeller: Auctions at or above maximum");
+        return;
+    }
+
+    if ((maxItems - auctions) >= ItemsPerCycle)
+        items = ItemsPerCycle;
+    else
+        items = (maxItems - auctions);
+		if(auctions >= (maxItems + GlyphsCount))
+			return;
+
+		if (((maxItems + GlyphsCount) - auctions) >= ItemsPerCycle)
+			items = ItemsPerCycle;
+		else
+			items = ((maxItems + GlyphsCount) - auctions);
+	}
+	else
+	{
+
+    if (auctions >= minItems)
+        {
+        //if (debug_Out) sLog.outString("AHSeller: Auctions above minimum");
+            return;
+        }
+
+		if (auctions >= maxItems)
+		{
+			//if (debug_Out) sLog.outString("AHSeller: Auctions at or above maximum");
+			return;
+		}
+
+		if ((maxItems - auctions) >= ItemsPerCycle)
+			items = ItemsPerCycle;
+		else
+			items = (maxItems - auctions);
+	}
+
+    if (debug_Out) sLog->outInfo(LOG_FILTER_GENERAL, "AHSeller: Adding %u Auctions", items);
+
+    uint32 AuctioneerGUID = 0;
+
+    switch (config->GetAHID())
+    {
+    case 2:
+        AuctioneerGUID = 79707; //Human in stormwind.
+        break;
+    case 6:
+        AuctioneerGUID = 4656; //orc in Orgrimmar
+        break;
+    case 7:
+        AuctioneerGUID = 23442; //goblin in GZ
+        break;
+    default:
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHSeller: GetAHID() - Default switch reached");
+        AuctioneerGUID = 23442; //default to neutral 7
+        break;
+    }
+
+    if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHSeller: Current Auctineer GUID is %u", AuctioneerGUID);
+
+    uint32 greyTGcount = config->GetPercents(AHB_GREY_TG);
+    uint32 whiteTGcount = config->GetPercents(AHB_WHITE_TG);
+    uint32 greenTGcount = config->GetPercents(AHB_GREEN_TG);
+    uint32 blueTGcount = config->GetPercents(AHB_BLUE_TG);
+    uint32 purpleTGcount = config->GetPercents(AHB_PURPLE_TG);
+    uint32 orangeTGcount = config->GetPercents(AHB_ORANGE_TG);
+    uint32 yellowTGcount = config->GetPercents(AHB_YELLOW_TG);
+    uint32 greyIcount = config->GetPercents(AHB_GREY_I);
+    uint32 whiteIcount = config->GetPercents(AHB_WHITE_I);
+    uint32 greenIcount = config->GetPercents(AHB_GREEN_I);
+    uint32 blueIcount = config->GetPercents(AHB_BLUE_I);
+    uint32 purpleIcount = config->GetPercents(AHB_PURPLE_I);
+    uint32 orangeIcount = config->GetPercents(AHB_ORANGE_I);
+    uint32 yellowIcount = config->GetPercents(AHB_YELLOW_I);
+/*    uint32 total = greyTGcount + whiteTGcount + greenTGcount + blueTGcount
+        + purpleTGcount + orangeTGcount + yellowTGcount
+        + whiteIcount + greenIcount + blueIcount + purpleIcount
+        + orangeIcount + yellowIcount;
+*/
+    uint32 greyTGoods = config->GetItemCounts(AHB_GREY_TG);
+    uint32 whiteTGoods = config->GetItemCounts(AHB_WHITE_TG);
+    uint32 greenTGoods = config->GetItemCounts(AHB_GREEN_TG);
+    uint32 blueTGoods = config->GetItemCounts(AHB_BLUE_TG);
+    uint32 purpleTGoods = config->GetItemCounts(AHB_PURPLE_TG);
+    uint32 orangeTGoods = config->GetItemCounts(AHB_ORANGE_TG);
+    uint32 yellowTGoods = config->GetItemCounts(AHB_YELLOW_TG);
+
+    uint32 greyItems = config->GetItemCounts(AHB_GREY_I);
+    uint32 whiteItems = config->GetItemCounts(AHB_WHITE_I);
+    uint32 greenItems = config->GetItemCounts(AHB_GREEN_I);
+    uint32 blueItems = config->GetItemCounts(AHB_BLUE_I);
+    uint32 purpleItems = config->GetItemCounts(AHB_PURPLE_I);
+    uint32 orangeItems = config->GetItemCounts(AHB_ORANGE_I);
+    uint32 yellowItems = config->GetItemCounts(AHB_YELLOW_I);
+    if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHSeller: %u items", items);
+
+    // only insert a few at a time, so as not to peg the processor
+    for (uint32 cnt = 1; cnt <= items; cnt++)
+    {
+    if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHSeller: %u count", cnt);
+        uint32 itemID = 0;
+        uint32 itemColor = 99;
+        uint32 loopbreaker = 0;
+        while (itemID == 0 && loopbreaker <= 50)
+        {
+            ++loopbreaker;
+            uint32 choice = urand(0, 13);
+			if(glyphMode)
+				choice = 14;
+            itemColor = choice;
+            switch (choice)
+            {
+            case 0:
+                {
+                    if ((greyItemsBin.size() > 0) && (greyItems < greyIcount))
+                        itemID = greyItemsBin[urand(0, greyItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 1:
+                {
+                    if ((whiteItemsBin.size() > 0) && (whiteItems < whiteIcount))
+                        itemID = whiteItemsBin[urand(0, whiteItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 2:
+                {
+                    if ((greenItemsBin.size() > 0) && (greenItems < greenIcount))
+                        itemID = greenItemsBin[urand(0, greenItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 3:
+                {
+                    if ((blueItemsBin.size() > 0) && (blueItems < blueIcount))
+                        itemID = blueItemsBin[urand(0, blueItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 4:
+                {
+                    if ((purpleItemsBin.size() > 0) && (purpleItems < purpleIcount))
+                        itemID = purpleItemsBin[urand(0, purpleItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 5:
+                {
+                    if ((orangeItemsBin.size() > 0) && (orangeItems < orangeIcount))
+                        itemID = orangeItemsBin[urand(0, orangeItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 6:
+                {
+                    if ((yellowItemsBin.size() > 0) && (yellowItems < yellowIcount))
+                        itemID = yellowItemsBin[urand(0, yellowItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 7:
+                {
+                    if ((greyTradeGoodsBin.size() > 0) && (greyTGoods < greyTGcount))
+                        itemID = greyTradeGoodsBin[urand(0, greyTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 8:
+                {
+                    if ((whiteTradeGoodsBin.size() > 0) && (whiteTGoods < whiteTGcount))
+                        itemID = whiteTradeGoodsBin[urand(0, whiteTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 9:
+                {
+                    if ((greenTradeGoodsBin.size() > 0) && (greenTGoods < greenTGcount))
+                        itemID = greenTradeGoodsBin[urand(0, greenTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 10:
+                {
+                    if ((blueTradeGoodsBin.size() > 0) && (blueTGoods < blueTGcount))
+                        itemID = blueTradeGoodsBin[urand(0, blueTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 11:
+                {
+                    if ((purpleTradeGoodsBin.size() > 0) && (purpleTGoods < purpleTGcount))
+                        itemID = purpleTradeGoodsBin[urand(0, purpleTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 12:
+                {
+                    if ((orangeTradeGoodsBin.size() > 0) && (orangeTGoods < orangeTGcount))
+                        itemID = orangeTradeGoodsBin[urand(0, orangeTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 13:
+                {
+                    if ((yellowTradeGoodsBin.size() > 0) && (yellowTGoods < yellowTGcount))
+                        itemID = yellowTradeGoodsBin[urand(0, yellowTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+			case 14:
+                {
+					if (glyphItemsBin.size() > 0)
+						itemID = glyphItemsBin[urand(0, glyphItemsBin.size() - 1)];
+					else continue;
+                    break;
+                }
+            default:
+                {
+                    if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHSeller: itemID Switch - Default Reached");
+                    break;
+                }
+            }
+
+            if (itemID == 0)
+            {
+                if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHSeller: Item::CreateItem() - ItemID is 0");
+                continue;
+            }
+
+            ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(itemID);
+            if (prototype == NULL)
+            {
+                if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHSeller: Huh?!?! prototype == NULL");
+                continue;
+            }
+
+            Item* item = Item::CreateItem(itemID, 1, AHBplayer);
+            if (item == NULL)
+            {
+                if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHSeller: Item::CreateItem() returned NULL");
+                break;
+            }
+            item->AddToUpdateQueueOf(AHBplayer);
+
+            uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(itemID);
+            if (randomPropertyId != 0)
+                item->SetItemRandomProperties(randomPropertyId);
+
+            uint64 buyoutPrice = 0;
+            uint64 bidPrice = 0;
+            uint32 stackCount = 1;
+
+            switch (SellMethod)
+            {
+            case 0:
+                buyoutPrice  = prototype->SellPrice;
+                break;
+            case 1:
+                buyoutPrice  = prototype->BuyPrice;
+                break;
+            }
+
+            if (prototype->Quality <= AHB_MAX_QUALITY)
+            {
+				if(!glyphMode)
+				{
+                if (config->GetMaxStack(prototype->Quality) > 1 && item->GetMaxStackCount() > 1)
+                    stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(prototype->Quality)));
+                else if (config->GetMaxStack(prototype->Quality) == 0 && item->GetMaxStackCount() > 1)
+                    stackCount = urand(1, item->GetMaxStackCount());
+                else
+                    stackCount = 1;
+                buyoutPrice *= urand(config->GetMinPrice(prototype->Quality), config->GetMaxPrice(prototype->Quality));
+                buyoutPrice /= 100;
+                bidPrice = buyoutPrice * urand(config->GetMinBidPrice(prototype->Quality), config->GetMaxBidPrice(prototype->Quality));
+                bidPrice /= 100;
+				}
+				else
+				{
+					buyoutPrice = urand(GlyphBuyOutPriceMin, GlyphBuyOutPriceMax);
+					bidPrice = urand(GlyphBidPriceMin, GlyphBidPriceMax);
+					if(buyoutPrice<bidPrice)
+						bidPrice = buyoutPrice - 1;
+					stackCount = 1;
+				}
+            }
+            else
+            {
+                // quality is something it shouldn't be, let's get out of here
+                if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: Quality %u not Supported", prototype->Quality);
+                item->RemoveFromUpdateQueueOf(AHBplayer);
+                continue;
+            }
+
+            uint32 etime = urand(1,3);
+            switch(etime)
+            {
+            case 1:
+                etime = 43200;
+                break;
+            case 2:
+                etime = 86400;
+                break;
+            case 3:
+                etime = 172800;
+                break;
+            default:
+                etime = 86400;
+                break;
+            }
+            item->SetCount(stackCount);
+
+            uint32 dep =  sAuctionMgr->GetAuctionDeposit(ahEntry, etime, item, stackCount);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            AuctionEntry* auctionEntry = new AuctionEntry;
+            auctionEntry->Id = sObjectMgr->GenerateAuctionID();
+            auctionEntry->auctioneer = AuctioneerGUID;
+            auctionEntry->itemGUIDLow = item->GetGUIDLow();
+            auctionEntry->itemEntry = item->GetEntry();
+            auctionEntry->owner = AHBplayer->GetGUIDLow();
+            auctionEntry->startbid = bidPrice * stackCount;
+            auctionEntry->buyout = buyoutPrice * stackCount;
+            auctionEntry->bidder = 0;
+            auctionEntry->bid = 0;
+            auctionEntry->deposit = dep;
+            auctionEntry->expire_time = (time_t) etime + time(NULL);
+            auctionEntry->auctionHouseEntry = ahEntry;
+            item->SaveToDB(trans);
+            item->RemoveFromUpdateQueueOf(AHBplayer);
+            sAuctionMgr->AddAItem(item);
+            auctionHouse->AddAuction(auctionEntry);
+            auctionEntry->SaveToDB(trans);
+            CharacterDatabase.CommitTransaction(trans);
+
+            switch(itemColor)
+            {
+            case 0:
+                ++greyItems;
+                break;
+            case 1:
+                ++whiteItems;
+                break;
+            case 2:
+                ++greenItems;
+                break;
+            case 3:
+                ++blueItems;
+                break;
+            case 4:
+                ++purpleItems;
+                break;
+            case 5:
+                ++orangeItems;
+                break;
+            case 6:
+                ++yellowItems;
+                break;
+            case 7:
+                ++greyTGoods;
+                break;
+            case 8:
+                ++whiteTGoods;
+                break;
+            case 9:
+                ++greenTGoods;
+                break;
+            case 10:
+                ++blueTGoods;
+                break;
+            case 11:
+                ++purpleTGoods;
+                break;
+            case 12:
+                ++orangeTGoods;
+                break;
+            case 13:
+                ++yellowTGoods;
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+void AuctionHouseBot::addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session)
+{
+    if (!AHBBuyer)
+    {
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: Disabled");
+        return;
+    }
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT id FROM auctionhouse WHERE itemowner<>%u AND buyguid<>%u", AHBplayerGUID, AHBplayerGUID);
+
+    if (!result)
+        return;
+
+    if (result->GetRowCount() == 0)
+        return;
+
+    // Fetches content of selected AH
+    AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+    vector<uint32> possibleBids;
+
+    do
+    {
+        uint32 tmpdata = result->Fetch()->GetUInt32();
+        possibleBids.push_back(tmpdata);
+    }while (result->NextRow());
+
+    for (uint32 count = 1; count <= config->GetBidsPerInterval(); ++count)
+    {
+        // Do we have anything to bid? If not, stop here.
+        if (possibleBids.empty())
+        {
+            //if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: I have no items to bid on.");
+            count = config->GetBidsPerInterval();
+            continue;
+        }
+
+        // Choose random auction from possible auctions
+        uint32 vectorPos = urand(0, possibleBids.size() - 1);
+        vector<uint32>::iterator iter = possibleBids.begin();
+        advance(iter, vectorPos);
+
+        // from auctionhousehandler.cpp, creates auction pointer & player pointer
+        AuctionEntry* auction = auctionHouse->GetAuction(*iter);
+
+        // Erase the auction from the vector to prevent bidding on item in next iteration.
+        possibleBids.erase(iter);
+
+        if (!auction)
+            continue;
+
+        // get exact item information
+        Item *pItem =  sAuctionMgr->GetAItem(auction->itemGUIDLow);
+        if (!pItem)
+        {
+            if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: Item %u doesn't exist, perhaps bought already?", auction->itemGUIDLow);
+            continue;
+        }
+
+        // get item prototype
+        ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(auction->itemEntry);
+
+        // check which price we have to use, startbid or if it is bidded already
+        uint32 currentprice;
+        if (auction->bid)
+            currentprice = auction->bid;
+        else
+            currentprice = auction->startbid;
+
+        // Prepare portion from maximum bid
+        double bidrate = static_cast<double>(urand(1, 100)) / 100;
+        long double bidMax = 0;
+
+        // check that bid has acceptable value and take bid based on vendorprice, stacksize and quality
+        switch (BuyMethod)
+        {
+        case 0:
+            {
+                if (prototype->Quality <= AHB_MAX_QUALITY)
+                {
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality))
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality);
+                }
+                else
+                {
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: Quality %u not Supported", prototype->Quality);
+                    continue;
+                }
+                break;
+            }
+        case 1:
+            {
+                if (prototype->Quality <= AHB_MAX_QUALITY)
+                {
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality))
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality);
+                }
+                else
+                {
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: Quality %u not Supported", prototype->Quality);
+                    continue;
+                }
+                break;
+            }
+        }
+
+        // check some special items, and do recalculating to their prices
+        switch (prototype->Class)
+        {
+            // ammo
+        case 6:
+            bidMax = 0;
+            break;
+        default:
+            break;
+        }
+
+        if (bidMax == 0)
+        {
+            // quality check failed to get bidmax, let's get out of here
+            continue;
+        }
+
+        // Calculate our bid
+        long double bidvalue = currentprice + ((bidMax - currentprice) * bidrate);
+        // Convert to uint32
+        uint32 bidprice = static_cast<uint32>(bidvalue);
+
+        // Check our bid is high enough to be valid. If not, correct it to minimum.
+        if ((currentprice + auction->GetAuctionOutBid()) > bidprice)
+            bidprice = currentprice + auction->GetAuctionOutBid();
+
+        if (debug_Out)
+        {
+            sLog->outInfo(LOG_FILTER_GENERAL, "-------------------------------------------------");
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Info for Auction #%u:", auction->Id);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: AuctionHouse: %u", auction->GetHouseId());
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Auctioneer: %u", auction->auctioneer);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Owner: %u", auction->owner);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Bidder: %u", auction->bidder);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Starting Bid: %u", auction->startbid);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Current Bid: %u", currentprice);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Buyout: %u", auction->buyout);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Deposit: %u", auction->deposit);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Expire Time: %u", uint32(auction->expire_time));
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Bid Rate: %f", bidrate);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Bid Max: %Lf", bidMax);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Bid Value: %Lf", bidvalue);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Bid Price: %u", bidprice);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Item GUID: %u", auction->itemGUIDLow);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Item Template: %u", auction->itemEntry);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Item Info:");
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Item ID: %u", prototype->ItemId);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Buy Price: %u", prototype->BuyPrice);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Sell Price: %u", prototype->SellPrice);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Bonding: %u", prototype->Bonding);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Quality: %u", prototype->Quality);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Item Level: %u", prototype->ItemLevel);
+            sLog->outInfo(LOG_FILTER_GENERAL, "AHBuyer: Ammo Type: %u", prototype->AmmoType);
+            sLog->outInfo(LOG_FILTER_GENERAL, "-------------------------------------------------");
+        }
+
+        // Check whether we do normal bid, or buyout
+        if ((bidprice < auction->buyout) || (auction->buyout == 0))
+        {
+
+            if (auction->bidder > 0)
+            {
+                if (auction->bidder == AHBplayer->GetGUIDLow())
+                {
+                    //pl->ModifyMoney(-int32(price - auction->bid));
+                }
+                else
+                {
+                    // mail to last bidder and return money
+                    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                    sAuctionMgr->SendAuctionOutbiddedMail(auction , bidprice, session->GetPlayer(), trans);
+                    CharacterDatabase.CommitTransaction(trans);
+                    //pl->ModifyMoney(-int32(price));
+                }
+           }
+
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = bidprice;
+
+            // Saving auction into database
+            CharacterDatabase.PExecute("UPDATE auctionhouse SET buyguid = '%u',lastbid = '%u' WHERE id = '%u'", auction->bidder, auction->bid, auction->Id);
+        }
+        else
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            //buyout
+            if ((auction->bidder) && (AHBplayer->GetGUIDLow() != auction->bidder))
+            {
+                sAuctionMgr->SendAuctionOutbiddedMail(auction, auction->buyout, session->GetPlayer(), trans);
+            }
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = auction->buyout;
+
+            // Send mails to buyer & seller
+            sAuctionMgr->SendAuctionSalePendingMail(auction, trans);
+            sAuctionMgr->SendAuctionSuccessfulMail(auction, trans);
+            sAuctionMgr->SendAuctionWonMail(auction, trans);
+            auction->DeleteFromDB( trans);
+            uint32 itemEntry = auction->itemEntry;
+            sAuctionMgr->RemoveAItem(auction->itemGUIDLow);
+            auctionHouse->RemoveAuction(auction, itemEntry);
+            CharacterDatabase.CommitTransaction(trans);
+        }
+    }
+}
+
+void AuctionHouseBot::Update()
+{
+    time_t _newrun = time(NULL);
+    if ((!AHBSeller) && (!AHBBuyer))
+        return;
+
+    WorldSession _session(AHBplayerAccount, NULL, SEC_PLAYER, false, true, 0, LOCALE_enUS, 0, 0);
+    Player _AHBplayer(&_session);
+    _AHBplayer.Initialize(AHBplayerGUID);
+    sObjectAccessor->AddObject(&_AHBplayer);
+
+    // Add New Bids
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        addNewAuctions(&_AHBplayer, &AllianceConfig);
+        if (((_newrun - _lastrun_a) >= (AllianceConfig.GetBiddingInterval() * MINUTE)) && (AllianceConfig.GetBidsPerInterval() > 0))
+        {
+            //if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_a));
+            //if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: Bidding on Alliance Auctions");
+            addNewAuctionBuyerBotBid(&_AHBplayer, &AllianceConfig, &_session);
+            _lastrun_a = _newrun;
+        }
+
+        addNewAuctions(&_AHBplayer, &HordeConfig);
+        if (((_newrun - _lastrun_h) >= (HordeConfig.GetBiddingInterval() * MINUTE)) && (HordeConfig.GetBidsPerInterval() > 0))
+        {
+            //if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_h));
+            //if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: Bidding on Horde Auctions");
+            addNewAuctionBuyerBotBid(&_AHBplayer, &HordeConfig, &_session);
+            _lastrun_h = _newrun;
+        }
+    }
+
+    addNewAuctions(&_AHBplayer, &NeutralConfig);
+    if (((_newrun - _lastrun_n) >= (NeutralConfig.GetBiddingInterval() * MINUTE)) && (NeutralConfig.GetBidsPerInterval() > 0))
+    {
+        //if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_n));
+        //if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBuyer: Bidding on Neutral Auctions");
+        addNewAuctionBuyerBotBid(&_AHBplayer, &NeutralConfig, &_session);
+        _lastrun_n = _newrun;
+    }
+    sObjectAccessor->RemoveObject(&_AHBplayer);
+}
+
+void AuctionHouseBot::Initialize()
+{
+    debug_Out = sConfigMgr->GetBoolDefault("AuctionHouseBot.DEBUG", false);
+    debug_Out_Filters = sConfigMgr->GetBoolDefault("AuctionHouseBot.DEBUG_FILTERS", false);
+
+    AHBSeller = sConfigMgr->GetBoolDefault("AuctionHouseBot.EnableSeller", false);
+    AHBBuyer = sConfigMgr->GetBoolDefault("AuctionHouseBot.EnableBuyer", false);
+    SellMethod = sConfigMgr->GetBoolDefault("AuctionHouseBot.UseBuyPriceForSeller", false);
+    BuyMethod = sConfigMgr->GetBoolDefault("AuctionHouseBot.UseBuyPriceForBuyer", false);
+
+    AHBplayerAccount = sConfigMgr->GetIntDefault("AuctionHouseBot.Account", 0);
+    AHBplayerGUID = sConfigMgr->GetIntDefault("AuctionHouseBot.GUID", 0);
+    ItemsPerCycle = sConfigMgr->GetIntDefault("AuctionHouseBot.ItemsPerCycle", 200);
+
+    //Begin Filters
+
+    Vendor_Items = sConfigMgr->GetBoolDefault("AuctionHouseBot.VendorItems", false);
+    Loot_Items = sConfigMgr->GetBoolDefault("AuctionHouseBot.LootItems", true);
+    Other_Items = sConfigMgr->GetBoolDefault("AuctionHouseBot.OtherItems", false);
+    Vendor_TGs = sConfigMgr->GetBoolDefault("AuctionHouseBot.VendorTradeGoods", false);
+    Loot_TGs = sConfigMgr->GetBoolDefault("AuctionHouseBot.LootTradeGoods", true);
+    Other_TGs = sConfigMgr->GetBoolDefault("AuctionHouseBot.OtherTradeGoods", false);
+
+    No_Bind = sConfigMgr->GetBoolDefault("AuctionHouseBot.No_Bind", true);
+    Bind_When_Picked_Up = sConfigMgr->GetBoolDefault("AuctionHouseBot.Bind_When_Picked_Up", false);
+    Bind_When_Equipped = sConfigMgr->GetBoolDefault("AuctionHouseBot.Bind_When_Equipped", true);
+    Bind_When_Use = sConfigMgr->GetBoolDefault("AuctionHouseBot.Bind_When_Use", true);
+    Bind_Quest_Item = sConfigMgr->GetBoolDefault("AuctionHouseBot.Bind_Quest_Item", false);
+
+    std::string disabledItems = sConfigMgr->GetStringDefault("AuctionHouseBot.DisabledItems", "");
+    DisableItemStore.clear();
+    Tokenizer tokens(disabledItems, ' ');
+    for (Tokenizer::const_iterator iter = tokens.begin(); iter != tokens.end(); ++iter)
+    {
+        uint32 id = uint32(atol(*iter));
+        DisableItemStore.insert(id);
+    }
+
+    DisablePermEnchant = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisablePermEnchant", false);
+    DisableConjured = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableConjured", false);
+    DisableGems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableGems", false);
+    DisableMoney = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableMoney", false);
+    DisableMoneyLoot = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableMoneyLoot", false);
+    DisableLootable = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableLootable", false);
+    DisableKeys = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableKeys", false);
+    DisableDuration = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableDuration", false);
+    DisableBOP_Or_Quest_NoReqLevel = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel", false);
+
+    DisableWarriorItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableWarriorItems", false);
+    DisablePaladinItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisablePaladinItems", false);
+    DisableHunterItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableHunterItems", false);
+    DisableRogueItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableRogueItems", false);
+    DisablePriestItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisablePriestItems", false);
+    DisableDKItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableDKItems", false);
+    DisableShamanItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableShamanItems", false);
+    DisableMageItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableMageItems", false);
+    DisableWarlockItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableWarlockItems", false);
+    DisableUnusedClassItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableUnusedClassItems", false);
+    DisableDruidItems = sConfigMgr->GetBoolDefault("AuctionHouseBot.DisableDruidItems", false);
+
+    DisableItemsBelowLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsBelowLevel", 0);
+    DisableItemsAboveLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsAboveLevel", 0);
+    DisableTGsBelowLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsBelowLevel", 0);
+    DisableTGsAboveLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsAboveLevel", 0);
+    DisableItemsBelowGUID = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsBelowGUID", 0);
+    DisableItemsAboveGUID = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsAboveGUID", 0);
+    DisableTGsBelowGUID = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsBelowGUID", 0);
+    DisableTGsAboveGUID = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsAboveGUID", 0);
+    DisableItemsBelowReqLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsBelowReqLevel", 0);
+    DisableItemsAboveReqLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsAboveReqLevel", 0);
+    DisableTGsBelowReqLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsBelowReqLevel", 0);
+    DisableTGsAboveReqLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsAboveReqLevel", 0);
+    DisableItemsBelowReqSkillRank = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsBelowReqSkillRank", 0);
+    DisableItemsAboveReqSkillRank = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableItemsAboveReqSkillRank", 0);
+    DisableTGsBelowReqSkillRank = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsBelowReqSkillRank", 0);
+    DisableTGsAboveReqSkillRank = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableTGsAboveReqSkillRank", 0);
+	SellGlyphs = sConfigMgr->GetBoolDefault("AuctionHouseBot.SellGlyphs", false);
+	GlyphsCount = sConfigMgr->GetIntDefault("AuctionHouseBot.GlyphsCount", 0);
+	DisableGlyphBelowLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableGlyphBelowLevel", 0);
+	DisableGlyphAboveLevel = sConfigMgr->GetIntDefault("AuctionHouseBot.DisableGlyphAboveLevel", 0);
+	GlyphBuyOutPriceMin = sConfigMgr->GetIntDefault("AuctionHouseBot.GlyphBuyOutPriceMin", 0);
+	GlyphBuyOutPriceMax = sConfigMgr->GetIntDefault("AuctionHouseBot.GlyphBuyOutPriceMax", 0);
+	GlyphBidPriceMin = sConfigMgr->GetIntDefault("AuctionHouseBot.GlyphBidPriceMin", 0);
+	GlyphBidPriceMax = sConfigMgr->GetIntDefault("AuctionHouseBot.GlyphBidPriceMax", 0);
+    //End Filters
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        LoadValues(&AllianceConfig);
+        LoadValues(&HordeConfig);
+    }
+    LoadValues(&NeutralConfig);
+
+    //
+    // check if the AHBot account/GUID in the config actually exists
+    //
+
+    if ((AHBplayerAccount != 0) || (AHBplayerGUID != 0))
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT 1 FROM characters WHERE account = %u AND guid = %u", AHBplayerAccount, AHBplayerGUID);
+        if (!result)
+       {
+           sLog->outError(LOG_FILTER_SERVER_LOADING, "AuctionHouseBot: The account/GUID-information set for your AHBot is incorrect (account: %u guid: %u)", AHBplayerAccount, AHBplayerGUID);
+           return;
+        }
+    }
+
+    if (AHBSeller)
+    {
+        QueryResult results = QueryResult(NULL);
+        char npcQuery[] = "SELECT distinct item FROM npc_vendor";
+        results = WorldDatabase.Query(npcQuery);
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                npcItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+        }
+        else
+        {
+            if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: \"%s\" failed", npcQuery);
+        }
+
+		if(SellGlyphs)
+		{
+			if(DisableGlyphBelowLevel > 80)
+				DisableGlyphBelowLevel = 0;
+			if(DisableGlyphAboveLevel < DisableGlyphBelowLevel)
+				DisableGlyphAboveLevel = DisableGlyphBelowLevel;
+			if(DisableGlyphAboveLevel == 0)
+				DisableGlyphAboveLevel = 85;
+
+			if(GlyphBidPriceMin <= 0)
+				GlyphBidPriceMin = 8000;
+			if(GlyphBidPriceMin > GlyphBidPriceMax)
+				GlyphBidPriceMax = GlyphBidPriceMin;
+			if(GlyphBuyOutPriceMin <= 0)
+				GlyphBuyOutPriceMin = 10000;
+			if(GlyphBuyOutPriceMin > GlyphBuyOutPriceMax)
+				GlyphBuyOutPriceMax = GlyphBuyOutPriceMin;
+
+
+			results = WorldDatabase.PQuery("SELECT entry FROM itemEntry WHERE class = 16 AND RequiredLevel >= %u AND RequiredLevel <= %u", DisableGlyphBelowLevel, DisableGlyphAboveLevel);
+			if (results != NULL)
+			{
+				do
+				{
+					Field* fields = results->Fetch();
+					glyphItemsBin.push_back(fields[0].GetUInt32());
+
+				} while (results->NextRow());
+			}
+			else
+			{
+				//if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: query glyphs failed");
+			}
+		}
+        char lootQuery[] = "SELECT item FROM creature_loot_template UNION "
+            "SELECT item FROM reference_loot_template UNION "
+            "SELECT item FROM disenchant_loot_template UNION "
+            "SELECT item FROM fishing_loot_template UNION "
+            "SELECT item FROM gameobject_loot_template UNION "
+            "SELECT item FROM item_loot_template UNION "
+            "SELECT item FROM milling_loot_template UNION "
+            "SELECT item FROM pickpocketing_loot_template UNION "
+            "SELECT item FROM prospecting_loot_template UNION "
+            "SELECT item FROM skinning_loot_template";
+
+        results = WorldDatabase.Query(lootQuery);
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                lootItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+        }
+        else
+        {
+            if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: \"%s\" failed", lootQuery);
+        }
+
+        ItemTemplateContainer const* its = sObjectMgr->GetItemTemplateStore();
+        for (ItemTemplateContainer::const_iterator itr = its->begin(); itr != its->end(); ++itr)
+        {
+
+
+
+            switch (itr->second.Bonding)
+            {
+            case NO_BIND:
+                if (!No_Bind)
+                    continue;
+                break;
+            case BIND_WHEN_PICKED_UP:
+                if (!Bind_When_Picked_Up)
+                    continue;
+                break;
+            case BIND_WHEN_EQUIPED:
+                if (!Bind_When_Equipped)
+                    continue;
+                break;
+            case BIND_WHEN_USE:
+                if (!Bind_When_Use)
+                    continue;
+                break;
+            case BIND_QUEST_ITEM:
+                if (!Bind_Quest_Item)
+                    continue;
+                break;
+            default:
+                continue;
+                break;
+            }
+
+            switch (SellMethod)
+            {
+            case 0:
+                if (itr->second.SellPrice == 0)
+                    continue;
+                break;
+            case 1:
+                if (itr->second.BuyPrice == 0)
+                    continue;
+                break;
+            }
+
+            if (itr->second.Quality > 6)
+                continue;
+
+            if ((Vendor_Items == 0) && !(itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorItem = true;
+                }
+
+                if (isVendorItem)
+                    continue;
+            }
+
+            if ((Vendor_TGs == 0) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorTG = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorTG); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorTG = true;
+                }
+
+                if (isVendorTG)
+                    continue;
+            }
+
+            if ((Loot_Items == 0) && !(itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootItem = true;
+                }
+
+                if (isLootItem)
+                    continue;
+            }
+
+            if ((Loot_TGs == 0) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isLootTG = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootTG); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootTG = true;
+                }
+
+                if (isLootTG)
+                    continue;
+            }
+
+            if ((Other_Items == 0) && !(itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorItem = false;
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorItem = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootItem = true;
+                }
+                if ((!isLootItem) && (!isVendorItem))
+                    continue;
+            }
+
+            if ((Other_TGs == 0) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorTG = false;
+                bool isLootTG = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorTG); i++)
+                {
+                    if (itr->second.ItemId == npcItems[i])
+                        isVendorTG = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootTG); i++)
+                {
+                    if (itr->second.ItemId == lootItems[i])
+                        isLootTG = true;
+                }
+                if ((!isLootTG) && (!isVendorTG))
+                    continue;
+            }
+
+            // Disable items by Id
+            if (DisableItemStore.find(itr->second.ItemId) != DisableItemStore.end())
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (PTR/Beta/Unused Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable permanent enchants items
+            if ((DisablePermEnchant) && (itr->second.Class == ITEM_CLASS_PERMANENT))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Permanent Enchant Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable conjured items
+            if ((DisableConjured) && (itr->second.IsConjuredConsumable()))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Conjured Consumable)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable gems
+            if ((DisableGems) && (itr->second.Class == ITEM_CLASS_GEM))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Gem)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable money
+            if ((DisableMoney) && (itr->second.Class == ITEM_CLASS_MONEY))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Money)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable moneyloot
+            if ((DisableMoneyLoot) && (itr->second.MinMoneyLoot > 0))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (MoneyLoot)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable lootable items
+            if ((DisableLootable) && (itr->second.Flags & 4))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Lootable Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable Keys
+            if ((DisableKeys) && (itr->second.Class == ITEM_CLASS_KEY))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Quest Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items with duration
+            if ((DisableDuration) && (itr->second.Duration > 0))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Has a Duration)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items which are BOP or Quest Items and have a required level lower than the item level
+            if ((DisableBOP_Or_Quest_NoReqLevel) && ((itr->second.Bonding == BIND_WHEN_PICKED_UP || itr->second.Bonding == BIND_QUEST_ITEM) && (itr->second.RequiredLevel < itr->second.ItemLevel)))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (BOP or BQI and Required Level is less than Item Level)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Warrior
+            if ((DisableWarriorItems) && (itr->second.AllowableClass == 1))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Warrior Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Paladin
+            if ((DisablePaladinItems) && (itr->second.AllowableClass == 2))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Paladin Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Hunter
+            if ((DisableHunterItems) && (itr->second.AllowableClass == 4))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Hunter Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Rogue
+            if ((DisableRogueItems) && (itr->second.AllowableClass == 8))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Rogue Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Priest
+            if ((DisablePriestItems) && (itr->second.AllowableClass == 16))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Priest Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for DK
+            if ((DisableDKItems) && (itr->second.AllowableClass == 32))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (DK Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Shaman
+            if ((DisableShamanItems) && (itr->second.AllowableClass == 64))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Shaman Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Mage
+            if ((DisableMageItems) && (itr->second.AllowableClass == 128))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Mage Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Warlock
+            if ((DisableWarlockItems) && (itr->second.AllowableClass == 256))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Warlock Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Unused Class
+            if ((DisableUnusedClassItems) && (itr->second.AllowableClass == 512))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Unused Item)", itr->second.ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Druid
+            if ((DisableDruidItems) && (itr->second.AllowableClass == 1024))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Druid Item)", itr->second.ItemId);
+                continue;
+            }
+
+             // Disable Items below level X
+            if ((DisableItemsBelowLevel) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel < DisableItemsBelowLevel))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items above level X
+            if ((DisableItemsAboveLevel) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel > DisableItemsAboveLevel))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+           // Disable Trade Goods below level X
+            if ((DisableTGsBelowLevel) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel < DisableTGsBelowLevel))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Trade Good %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+           // Disable Trade Goods above level X
+            if ((DisableTGsAboveLevel) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemLevel > DisableTGsAboveLevel))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Trade Good %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items below GUID X
+            if ((DisableItemsBelowGUID) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId < DisableItemsBelowGUID))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items above GUID X
+            if ((DisableItemsAboveGUID) && (itr->second.Class != ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId > DisableItemsAboveGUID))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Item Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Trade Goods below GUID X
+            if ((DisableTGsBelowGUID) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId < DisableTGsBelowGUID))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Trade Goods above GUID X
+            if ((DisableTGsAboveGUID) && (itr->second.Class == ITEM_CLASS_TRADE_GOODS) && (itr->second.ItemId > DisableTGsAboveGUID))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (Trade Good Level = %u)", itr->second.ItemId, itr->second.ItemLevel);
+                continue;
+            }
+
+            // Disable Items for level lower than X
+            if ((DisableItemsBelowReqLevel) && (itr->second.RequiredLevel < DisableItemsBelowReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Items for level higher than X
+            if ((DisableItemsAboveReqLevel) && (itr->second.RequiredLevel > DisableItemsAboveReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Trade Goods for level lower than X
+            if ((DisableTGsBelowReqLevel) && (itr->second.RequiredLevel < DisableTGsBelowReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Trade Good %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Trade Goods for level higher than X
+            if ((DisableTGsAboveReqLevel) && (itr->second.RequiredLevel > DisableTGsAboveReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Trade Good %u disabled (RequiredLevel = %u)", itr->second.ItemId, itr->second.RequiredLevel);
+                continue;
+            }
+
+            // Disable Items that require skill lower than X
+            // if ((DisableItemsBelowReqSkillRank) && (itr->second.RequiredSkillRank < DisableItemsBelowReqSkillRank))
+            // {
+            //    if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+            //    continue;
+            // }
+
+            // Disable Items that require skill higher than X
+            // if ((DisableItemsAboveReqSkillRank) && (itr->second.RequiredSkillRank > DisableItemsAboveReqSkillRank))
+            // {
+            //    if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+            //    continue;
+            // }
+
+            // Disable Trade Goods that require skill lower than X
+            // if ((DisableTGsBelowReqSkillRank) && (itr->second.RequiredSkillRank < DisableTGsBelowReqSkillRank))
+            // {
+            //    if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+            //    continue;
+            // }
+
+            // Disable Trade Goods that require skill higher than X
+            // if ((DisableTGsAboveReqSkillRank) && (itr->second.?RequiredSkillRank > DisableTGsAboveReqSkillRank))
+            // {
+            //    if (debug_Out_Filters) sLog->outError(LOG_FILTER_GENERAL, "AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", itr->second.ItemId, itr->second.RequiredSkillRank);
+            //    continue;
+            // }
+
+            switch (itr->second.Quality)
+            {
+            case AHB_GREY:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    greyTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    greyItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_WHITE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    whiteTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    whiteItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_GREEN:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    greenTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    greenItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_BLUE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    blueTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    blueItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_PURPLE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    purpleTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    purpleItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_ORANGE:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    orangeTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    orangeItemsBin.push_back(itr->second.ItemId);
+                break;
+
+            case AHB_YELLOW:
+                if (itr->second.Class == ITEM_CLASS_TRADE_GOODS)
+                    yellowTradeGoodsBin.push_back(itr->second.ItemId);
+                else
+                    yellowItemsBin.push_back(itr->second.ItemId);
+                break;
+            }
+        }
+
+        if ((greyTradeGoodsBin.size() == 0) &&
+            (whiteTradeGoodsBin.size() == 0) &&
+            (greenTradeGoodsBin.size() == 0) &&
+            (blueTradeGoodsBin.size() == 0) &&
+            (purpleTradeGoodsBin.size() == 0) &&
+            (orangeTradeGoodsBin.size() == 0) &&
+            (yellowTradeGoodsBin.size() == 0) &&
+            (greyItemsBin.size() == 0) &&
+            (whiteItemsBin.size() == 0) &&
+            (greenItemsBin.size() == 0) &&
+            (blueItemsBin.size() == 0) &&
+            (purpleItemsBin.size() == 0) &&
+            (orangeItemsBin.size() == 0) &&
+            (yellowItemsBin.size() == 0))
+        {
+            sLog->outError(LOG_FILTER_SERVER_LOADING, "AuctionHouseBot: No items");
+            AHBSeller = 0;
+        }
+
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "AuctionHouseBot:");
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u grey trade goods", uint32(greyTradeGoodsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u white trade goods", uint32(whiteTradeGoodsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u green trade goods", uint32(greenTradeGoodsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u blue trade goods", uint32(blueTradeGoodsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u purple trade goods", uint32(purpleTradeGoodsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u orange trade goods", uint32(orangeTradeGoodsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u yellow trade goods", uint32(yellowTradeGoodsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u grey items", uint32(greyItemsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u white items", uint32(whiteItemsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u green items", uint32(greenItemsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u blue items", uint32(blueItemsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u purple items", uint32(purpleItemsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u orange items", uint32(orangeItemsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u yellow items", uint32(yellowItemsBin.size()));
+        sLog->outInfo(LOG_FILTER_SERVER_LOADING, "loaded %u glyph items", uint32(glyphItemsBin.size()));
+    }
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "AuctionHouseBot and AuctionHouseBuyer have been loaded.");
+}
+
+void AuctionHouseBot::IncrementItemCounts(AuctionEntry* ah)
+{
+    // from auctionhousehandler.cpp, creates auction pointer & player pointer
+
+    // get exact item information
+    Item *pItem =  sAuctionMgr->GetAItem(ah->itemGUIDLow);
+    if (!pItem)
+    {
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBot: Item %u doesn't exist, perhaps bought already?", ah->itemGUIDLow);
+        return;
+    }
+
+    // get item prototype
+    ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(ah->itemEntry);
+
+    AHBConfig *config;
+
+    FactionTemplateEntry const* u_entry = sFactionTemplateStore.LookupEntry(ah->GetHouseFaction());
+    if (!u_entry)
+    {
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_ALLIANCE)
+    {
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBot: %u returned as House Faction. Alliance", ah->GetHouseFaction());
+        config = &AllianceConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_HORDE)
+    {
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBot: %u returned as House Faction. Horde", ah->GetHouseFaction());
+        config = &HordeConfig;
+    }
+    else
+    {
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+
+    config->IncItemCounts(prototype->Class, prototype->Quality);
+}
+
+void AuctionHouseBot::DecrementItemCounts(AuctionEntry* ah, uint32 itemEntry)
+{
+    // get item prototype
+    ItemTemplate const* prototype = sObjectMgr->GetItemTemplate(itemEntry);
+
+    AHBConfig *config;
+
+    FactionTemplateEntry const* u_entry = sFactionTemplateStore.LookupEntry(ah->GetHouseFaction());
+    if (!u_entry)
+    {
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_ALLIANCE)
+    {
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBot: %u returned as House Faction. Alliance", ah->GetHouseFaction());
+        config = &AllianceConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_HORDE)
+    {
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBot: %u returned as House Faction. Horde", ah->GetHouseFaction());
+        config = &HordeConfig;
+    }
+    else
+    {
+        if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+
+    config->DecItemCounts(prototype->Class, prototype->Quality);
+}
+
+void AuctionHouseBot::Commands(uint32 command, uint32 ahMapID, uint32 col, char* args)
+{
+    AHBConfig *config = NULL;
+    switch (ahMapID)
+    {
+    case 2:
+        config = &AllianceConfig;
+        break;
+    case 6:
+        config = &HordeConfig;
+        break;
+    case 7:
+        config = &NeutralConfig;
+        break;
+    }
+    std::string color;
+    switch (col)
+    {
+    case AHB_GREY:
+        color = "grey";
+        break;
+    case AHB_WHITE:
+        color = "white";
+        break;
+    case AHB_GREEN:
+        color = "green";
+        break;
+    case AHB_BLUE:
+        color = "blue";
+        break;
+    case AHB_PURPLE:
+        color = "purple";
+        break;
+    case AHB_ORANGE:
+        color = "orange";
+        break;
+    case AHB_YELLOW:
+        color = "yellow";
+        break;
+    default:
+        break;
+    }
+    switch (command)
+    {
+    case 0:     //ahexpire
+        {
+            AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+
+            AuctionHouseObject::AuctionEntryMap::iterator itr;
+            itr = auctionHouse->GetAuctionsBegin();
+
+            while (itr != auctionHouse->GetAuctionsEnd())
+            {
+                if (itr->second->owner == AHBplayerGUID)
+                {
+                    itr->second->expire_time = sWorld->GetGameTime();
+                    uint32 id = itr->second->Id;
+                    uint32 expire_time = itr->second->expire_time;
+                    CharacterDatabase.PExecute("UPDATE auctionhouse SET time = '%u' WHERE id = '%u'", expire_time, id);
+                }
+                ++itr;
+            }
+        }
+        break;
+    case 1:     //min items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minitems = '%u' WHERE auctionhouse = '%u'", minItems, ahMapID);
+            config->SetMinItems(minItems);
+        }
+        break;
+    case 2:     //max items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxitems = '%u' WHERE auctionhouse = '%u'", maxItems, ahMapID);
+            config->SetMaxItems(maxItems);
+            config->CalculatePercents();
+        }
+        break;
+    case 3:     //min time Deprecated (Place holder for future commands)
+        break;
+    case 4:     //max time Deprecated (Place holder for future commands)
+        break;
+    case 5:     //percentages
+        {
+            char * param1 = strtok(args, " ");
+            char * param2 = strtok(NULL, " ");
+            char * param3 = strtok(NULL, " ");
+            char * param4 = strtok(NULL, " ");
+            char * param5 = strtok(NULL, " ");
+            char * param6 = strtok(NULL, " ");
+            char * param7 = strtok(NULL, " ");
+            char * param8 = strtok(NULL, " ");
+            char * param9 = strtok(NULL, " ");
+            char * param10 = strtok(NULL, " ");
+            char * param11 = strtok(NULL, " ");
+            char * param12 = strtok(NULL, " ");
+            char * param13 = strtok(NULL, " ");
+            char * param14 = strtok(NULL, " ");
+            uint32 greytg = (uint32) strtoul(param1, NULL, 0);
+            uint32 whitetg = (uint32) strtoul(param2, NULL, 0);
+            uint32 greentg = (uint32) strtoul(param3, NULL, 0);
+            uint32 bluetg = (uint32) strtoul(param4, NULL, 0);
+            uint32 purpletg = (uint32) strtoul(param5, NULL, 0);
+            uint32 orangetg = (uint32) strtoul(param6, NULL, 0);
+            uint32 yellowtg = (uint32) strtoul(param7, NULL, 0);
+            uint32 greyi = (uint32) strtoul(param8, NULL, 0);
+            uint32 whitei = (uint32) strtoul(param9, NULL, 0);
+            uint32 greeni = (uint32) strtoul(param10, NULL, 0);
+            uint32 bluei = (uint32) strtoul(param11, NULL, 0);
+            uint32 purplei = (uint32) strtoul(param12, NULL, 0);
+            uint32 orangei = (uint32) strtoul(param13, NULL, 0);
+            uint32 yellowi = (uint32) strtoul(param14, NULL, 0);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            trans->PAppend("UPDATE auctionhousebot SET percentgreytradegoods = '%u' WHERE auctionhouse = '%u'", greytg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentwhitetradegoods = '%u' WHERE auctionhouse = '%u'", whitetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreentradegoods = '%u' WHERE auctionhouse = '%u'", greentg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentbluetradegoods = '%u' WHERE auctionhouse = '%u'", bluetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentpurpletradegoods = '%u' WHERE auctionhouse = '%u'", purpletg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentorangetradegoods = '%u' WHERE auctionhouse = '%u'", orangetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentyellowtradegoods = '%u' WHERE auctionhouse = '%u'", yellowtg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreyitems = '%u' WHERE auctionhouse = '%u'", greyi, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentwhiteitems = '%u' WHERE auctionhouse = '%u'", whitei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreenitems = '%u' WHERE auctionhouse = '%u'", greeni, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentblueitems = '%u' WHERE auctionhouse = '%u'", bluei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentpurpleitems = '%u' WHERE auctionhouse = '%u'", purplei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentorangeitems = '%u' WHERE auctionhouse = '%u'", orangei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentyellowitems = '%u' WHERE auctionhouse = '%u'", yellowi, ahMapID);
+            CharacterDatabase.CommitTransaction( trans);
+            config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        }
+        break;
+    case 6:     //min prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minPrice, ahMapID);
+            config->SetMinPrice(col, minPrice);
+        }
+        break;
+    case 7:     //max prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxPrice, ahMapID);
+            config->SetMaxPrice(col, maxPrice);
+        }
+        break;
+    case 8:     //min bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minBidPrice, ahMapID);
+            config->SetMinBidPrice(col, minBidPrice);
+        }
+        break;
+    case 9:     //max bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxBidPrice, ahMapID);
+            config->SetMaxBidPrice(col, maxBidPrice);
+        }
+        break;
+    case 10:        //max stacks
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxStack = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxstack%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxStack, ahMapID);
+            config->SetMaxStack(col, maxStack);
+        }
+        break;
+    case 11:        //buyer bid prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 buyerPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), buyerPrice, ahMapID);
+            config->SetBuyerPrice(col, buyerPrice);
+        }
+        break;
+    case 12:        //buyer bidding interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbiddinginterval = '%u' WHERE auctionhouse = '%u'", bidInterval, ahMapID);
+            config->SetBiddingInterval(bidInterval);
+        }
+        break;
+    case 13:        //buyer bids per interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidsPerInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbidsperinterval = '%u' WHERE auctionhouse = '%u'", bidsPerInterval, ahMapID);
+            config->SetBidsPerInterval(bidsPerInterval);
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+void AuctionHouseBot::LoadValues(AHBConfig *config)
+{
+    if (debug_Out)
+        sLog->outError(LOG_FILTER_GENERAL, "Start Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u", config->GetAHID())->Fetch()->GetCString());
+    if (AHBSeller)
+    {
+        //load min and max items
+        config->SetMinItems(CharacterDatabase.PQuery("SELECT minitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxItems(CharacterDatabase.PQuery("SELECT maxitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load percentages
+        uint32 greytg = CharacterDatabase.PQuery("SELECT percentgreytradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitetg = CharacterDatabase.PQuery("SELECT percentwhitetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greentg = CharacterDatabase.PQuery("SELECT percentgreentradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluetg = CharacterDatabase.PQuery("SELECT percentbluetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purpletg = CharacterDatabase.PQuery("SELECT percentpurpletradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangetg = CharacterDatabase.PQuery("SELECT percentorangetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowtg = CharacterDatabase.PQuery("SELECT percentyellowtradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greyi = CharacterDatabase.PQuery("SELECT percentgreyitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitei = CharacterDatabase.PQuery("SELECT percentwhiteitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greeni = CharacterDatabase.PQuery("SELECT percentgreenitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluei = CharacterDatabase.PQuery("SELECT percentblueitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purplei = CharacterDatabase.PQuery("SELECT percentpurpleitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangei = CharacterDatabase.PQuery("SELECT percentorangeitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowi = CharacterDatabase.PQuery("SELECT percentyellowitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        //load min and max prices
+        config->SetMinPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load min and max bid prices
+        config->SetMinBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load max stacks
+        config->SetMaxStack(AHB_GREY, CharacterDatabase.PQuery("SELECT maxstackgrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxstackwhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxstackgreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxstackblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxstackpurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxstackorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxstackyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog->outError(LOG_FILTER_GENERAL, "minItems                = %u", config->GetMinItems());
+            sLog->outError(LOG_FILTER_GENERAL, "maxItems                = %u", config->GetMaxItems());
+            sLog->outError(LOG_FILTER_GENERAL, "percentGreyTradeGoods   = %u", config->GetPercentages(AHB_GREY_TG));
+            sLog->outError(LOG_FILTER_GENERAL, "percentWhiteTradeGoods  = %u", config->GetPercentages(AHB_WHITE_TG));
+            sLog->outError(LOG_FILTER_GENERAL, "percentGreenTradeGoods  = %u", config->GetPercentages(AHB_GREEN_TG));
+            sLog->outError(LOG_FILTER_GENERAL, "percentBlueTradeGoods   = %u", config->GetPercentages(AHB_BLUE_TG));
+            sLog->outError(LOG_FILTER_GENERAL, "percentPurpleTradeGoods = %u", config->GetPercentages(AHB_PURPLE_TG));
+            sLog->outError(LOG_FILTER_GENERAL, "percentOrangeTradeGoods = %u", config->GetPercentages(AHB_ORANGE_TG));
+            sLog->outError(LOG_FILTER_GENERAL, "percentYellowTradeGoods = %u", config->GetPercentages(AHB_YELLOW_TG));
+            sLog->outError(LOG_FILTER_GENERAL, "percentGreyItems        = %u", config->GetPercentages(AHB_GREY_I));
+            sLog->outError(LOG_FILTER_GENERAL, "percentWhiteItems       = %u", config->GetPercentages(AHB_WHITE_I));
+            sLog->outError(LOG_FILTER_GENERAL, "percentGreenItems       = %u", config->GetPercentages(AHB_GREEN_I));
+            sLog->outError(LOG_FILTER_GENERAL, "percentBlueItems        = %u", config->GetPercentages(AHB_BLUE_I));
+            sLog->outError(LOG_FILTER_GENERAL, "percentPurpleItems      = %u", config->GetPercentages(AHB_PURPLE_I));
+            sLog->outError(LOG_FILTER_GENERAL, "percentOrangeItems      = %u", config->GetPercentages(AHB_ORANGE_I));
+            sLog->outError(LOG_FILTER_GENERAL, "percentYellowItems      = %u", config->GetPercentages(AHB_YELLOW_I));
+            sLog->outError(LOG_FILTER_GENERAL, "minPriceGrey            = %u", config->GetMinPrice(AHB_GREY));
+            sLog->outError(LOG_FILTER_GENERAL, "maxPriceGrey            = %u", config->GetMaxPrice(AHB_GREY));
+            sLog->outError(LOG_FILTER_GENERAL, "minPriceWhite           = %u", config->GetMinPrice(AHB_WHITE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxPriceWhite           = %u", config->GetMaxPrice(AHB_WHITE));
+            sLog->outError(LOG_FILTER_GENERAL, "minPriceGreen           = %u", config->GetMinPrice(AHB_GREEN));
+            sLog->outError(LOG_FILTER_GENERAL, "maxPriceGreen           = %u", config->GetMaxPrice(AHB_GREEN));
+            sLog->outError(LOG_FILTER_GENERAL, "minPriceBlue            = %u", config->GetMinPrice(AHB_BLUE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxPriceBlue            = %u", config->GetMaxPrice(AHB_BLUE));
+            sLog->outError(LOG_FILTER_GENERAL, "minPricePurple          = %u", config->GetMinPrice(AHB_PURPLE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxPricePurple          = %u", config->GetMaxPrice(AHB_PURPLE));
+            sLog->outError(LOG_FILTER_GENERAL, "minPriceOrange          = %u", config->GetMinPrice(AHB_ORANGE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxPriceOrange          = %u", config->GetMaxPrice(AHB_ORANGE));
+            sLog->outError(LOG_FILTER_GENERAL, "minPriceYellow          = %u", config->GetMinPrice(AHB_YELLOW));
+            sLog->outError(LOG_FILTER_GENERAL, "maxPriceYellow          = %u", config->GetMaxPrice(AHB_YELLOW));
+            sLog->outError(LOG_FILTER_GENERAL, "minBidPriceGrey         = %u", config->GetMinBidPrice(AHB_GREY));
+            sLog->outError(LOG_FILTER_GENERAL, "maxBidPriceGrey         = %u", config->GetMaxBidPrice(AHB_GREY));
+            sLog->outError(LOG_FILTER_GENERAL, "minBidPriceWhite        = %u", config->GetMinBidPrice(AHB_WHITE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxBidPriceWhite        = %u", config->GetMaxBidPrice(AHB_WHITE));
+            sLog->outError(LOG_FILTER_GENERAL, "minBidPriceGreen        = %u", config->GetMinBidPrice(AHB_GREEN));
+            sLog->outError(LOG_FILTER_GENERAL, "maxBidPriceGreen        = %u", config->GetMaxBidPrice(AHB_GREEN));
+            sLog->outError(LOG_FILTER_GENERAL, "minBidPriceBlue         = %u", config->GetMinBidPrice(AHB_BLUE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxBidPriceBlue         = %u", config->GetMinBidPrice(AHB_BLUE));
+            sLog->outError(LOG_FILTER_GENERAL, "minBidPricePurple       = %u", config->GetMinBidPrice(AHB_PURPLE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxBidPricePurple       = %u", config->GetMaxBidPrice(AHB_PURPLE));
+            sLog->outError(LOG_FILTER_GENERAL, "minBidPriceOrange       = %u", config->GetMinBidPrice(AHB_ORANGE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxBidPriceOrange       = %u", config->GetMaxBidPrice(AHB_ORANGE));
+            sLog->outError(LOG_FILTER_GENERAL, "minBidPriceYellow       = %u", config->GetMinBidPrice(AHB_YELLOW));
+            sLog->outError(LOG_FILTER_GENERAL, "maxBidPriceYellow       = %u", config->GetMaxBidPrice(AHB_YELLOW));
+            sLog->outError(LOG_FILTER_GENERAL, "maxStackGrey            = %u", config->GetMaxStack(AHB_GREY));
+            sLog->outError(LOG_FILTER_GENERAL, "maxStackWhite           = %u", config->GetMaxStack(AHB_WHITE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxStackGreen           = %u", config->GetMaxStack(AHB_GREEN));
+            sLog->outError(LOG_FILTER_GENERAL, "maxStackBlue            = %u", config->GetMaxStack(AHB_BLUE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxStackPurple          = %u", config->GetMaxStack(AHB_PURPLE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxStackOrange          = %u", config->GetMaxStack(AHB_ORANGE));
+            sLog->outError(LOG_FILTER_GENERAL, "maxStackYellow          = %u", config->GetMaxStack(AHB_YELLOW));
+        }
+        //AuctionHouseEntry const* ahEntry =  sAuctionMgr->GetAuctionHouseEntry(config->GetAHFID());
+        AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+
+        config->ResetItemCounts();
+        uint32 auctions = auctionHouse->Getcount();
+
+        if (auctions)
+        {
+            for (AuctionHouseObject::AuctionEntryMap::const_iterator itr = auctionHouse->GetAuctionsBegin(); itr != auctionHouse->GetAuctionsEnd(); ++itr)
+            {
+                AuctionEntry *Aentry = itr->second;
+                Item *item =  sAuctionMgr->GetAItem(Aentry->itemGUIDLow);
+                if (item)
+                {
+                    ItemTemplate const *prototype = item->GetTemplate();
+                    if (prototype)
+                    {
+                        switch (prototype->Quality)
+                        {
+                        case 0:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_GREY_TG);
+                            else
+                                config->IncItemCounts(AHB_GREY_I);
+                            break;
+                        case 1:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_WHITE_TG);
+                            else
+                                config->IncItemCounts(AHB_WHITE_I);
+                            break;
+                        case 2:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_GREEN_TG);
+                            else
+                                config->IncItemCounts(AHB_GREEN_I);
+                            break;
+                        case 3:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_BLUE_TG);
+                            else
+                                config->IncItemCounts(AHB_BLUE_I);
+                            break;
+                        case 4:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_PURPLE_TG);
+                            else
+                                config->IncItemCounts(AHB_PURPLE_I);
+                            break;
+                        case 5:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_ORANGE_TG);
+                            else
+                                config->IncItemCounts(AHB_ORANGE_I);
+                            break;
+                        case 6:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_YELLOW_TG);
+                            else
+                                config->IncItemCounts(AHB_YELLOW_I);
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        if (debug_Out)
+        {
+            sLog->outError(LOG_FILTER_GENERAL, "Current Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetCString());
+            sLog->outError(LOG_FILTER_GENERAL, "Grey Trade Goods\t%u\tGrey Items\t%u", config->GetItemCounts(AHB_GREY_TG), config->GetItemCounts(AHB_GREY_I));
+            sLog->outError(LOG_FILTER_GENERAL, "White Trade Goods\t%u\tWhite Items\t%u", config->GetItemCounts(AHB_WHITE_TG), config->GetItemCounts(AHB_WHITE_I));
+            sLog->outError(LOG_FILTER_GENERAL, "Green Trade Goods\t%u\tGreen Items\t%u", config->GetItemCounts(AHB_GREEN_TG), config->GetItemCounts(AHB_GREEN_I));
+            sLog->outError(LOG_FILTER_GENERAL, "Blue Trade Goods\t%u\tBlue Items\t%u", config->GetItemCounts(AHB_BLUE_TG), config->GetItemCounts(AHB_BLUE_I));
+            sLog->outError(LOG_FILTER_GENERAL, "Purple Trade Goods\t%u\tPurple Items\t%u", config->GetItemCounts(AHB_PURPLE_TG), config->GetItemCounts(AHB_PURPLE_I));
+            sLog->outError(LOG_FILTER_GENERAL, "Orange Trade Goods\t%u\tOrange Items\t%u", config->GetItemCounts(AHB_ORANGE_TG), config->GetItemCounts(AHB_ORANGE_I));
+            sLog->outError(LOG_FILTER_GENERAL, "Yellow Trade Goods\t%u\tYellow Items\t%u", config->GetItemCounts(AHB_YELLOW_TG), config->GetItemCounts(AHB_YELLOW_I));
+        }
+    }
+    if (AHBBuyer)
+    {
+        //load buyer bid prices
+        config->SetBuyerPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT buyerpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT buyerpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT buyerpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT buyerpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT buyerpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT buyerpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT buyerpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load bidding interval
+        config->SetBiddingInterval(CharacterDatabase.PQuery("SELECT buyerbiddinginterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load bids per interval
+        config->SetBidsPerInterval(CharacterDatabase.PQuery("SELECT buyerbidsperinterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog->outError(LOG_FILTER_GENERAL, "buyerPriceGrey          = %u", config->GetBuyerPrice(AHB_GREY));
+            sLog->outError(LOG_FILTER_GENERAL, "buyerPriceWhite         = %u", config->GetBuyerPrice(AHB_WHITE));
+            sLog->outError(LOG_FILTER_GENERAL, "buyerPriceGreen         = %u", config->GetBuyerPrice(AHB_GREEN));
+            sLog->outError(LOG_FILTER_GENERAL, "buyerPriceBlue          = %u", config->GetBuyerPrice(AHB_BLUE));
+            sLog->outError(LOG_FILTER_GENERAL, "buyerPricePurple        = %u", config->GetBuyerPrice(AHB_PURPLE));
+            sLog->outError(LOG_FILTER_GENERAL, "buyerPriceOrange        = %u", config->GetBuyerPrice(AHB_ORANGE));
+            sLog->outError(LOG_FILTER_GENERAL, "buyerPriceYellow        = %u", config->GetBuyerPrice(AHB_YELLOW));
+            sLog->outError(LOG_FILTER_GENERAL, "buyerBiddingInterval    = %u", config->GetBiddingInterval());
+            sLog->outError(LOG_FILTER_GENERAL, "buyerBidsPerInterval    = %u", config->GetBidsPerInterval());
+        }
+    }
+    if (debug_Out) sLog->outError(LOG_FILTER_GENERAL, "End Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetCString());
+}
diff --git a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
new file mode 100644
index 0000000..648a44d
--- /dev/null
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
@@ -0,0 +1,1257 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef AUCTION_HOUSE_BOT_H
+#define AUCTION_HOUSE_BOT_H
+
+#include "World.h"
+#include "Config.h"
+#include "ItemPrototype.h"
+
+#define AHB_GREY        0
+#define AHB_WHITE       1
+#define AHB_GREEN       2
+#define AHB_BLUE        3
+#define AHB_PURPLE      4
+#define AHB_ORANGE      5
+#define AHB_YELLOW      6
+#define AHB_MAX_QUALITY 6
+#define AHB_GREY_TG     0
+#define AHB_WHITE_TG    1
+#define AHB_GREEN_TG    2
+#define AHB_BLUE_TG     3
+#define AHB_PURPLE_TG   4
+#define AHB_ORANGE_TG   5
+#define AHB_YELLOW_TG   6
+#define AHB_GREY_I      7
+#define AHB_WHITE_I     8
+#define AHB_GREEN_I     9
+#define AHB_BLUE_I      10
+#define AHB_PURPLE_I    11
+#define AHB_ORANGE_I    12
+#define AHB_YELLOW_I    13
+#define AHB_GLYPH		14
+
+class AHBConfig
+{
+private:
+    uint32 AHID;
+    uint32 AHFID;
+    uint32 minItems;
+    uint32 maxItems;
+    uint32 percentGreyTradeGoods;
+    uint32 percentWhiteTradeGoods;
+    uint32 percentGreenTradeGoods;
+    uint32 percentBlueTradeGoods;
+    uint32 percentPurpleTradeGoods;
+    uint32 percentOrangeTradeGoods;
+    uint32 percentYellowTradeGoods;
+    uint32 percentGreyItems;
+    uint32 percentWhiteItems;
+    uint32 percentGreenItems;
+    uint32 percentBlueItems;
+    uint32 percentPurpleItems;
+    uint32 percentOrangeItems;
+    uint32 percentYellowItems;
+    uint32 minPriceGrey;
+    uint32 maxPriceGrey;
+    uint32 minBidPriceGrey;
+    uint32 maxBidPriceGrey;
+    uint32 maxStackGrey;
+    uint32 minPriceWhite;
+    uint32 maxPriceWhite;
+    uint32 minBidPriceWhite;
+    uint32 maxBidPriceWhite;
+    uint32 maxStackWhite;
+    uint32 minPriceGreen;
+    uint32 maxPriceGreen;
+    uint32 minBidPriceGreen;
+    uint32 maxBidPriceGreen;
+    uint32 maxStackGreen;
+    uint32 minPriceBlue;
+    uint32 maxPriceBlue;
+    uint32 minBidPriceBlue;
+    uint32 maxBidPriceBlue;
+    uint32 maxStackBlue;
+    uint32 minPricePurple;
+    uint32 maxPricePurple;
+    uint32 minBidPricePurple;
+    uint32 maxBidPricePurple;
+    uint32 maxStackPurple;
+    uint32 minPriceOrange;
+    uint32 maxPriceOrange;
+    uint32 minBidPriceOrange;
+    uint32 maxBidPriceOrange;
+    uint32 maxStackOrange;
+    uint32 minPriceYellow;
+    uint32 maxPriceYellow;
+    uint32 minBidPriceYellow;
+    uint32 maxBidPriceYellow;
+    uint32 maxStackYellow;
+
+    uint32 buyerPriceGrey;
+    uint32 buyerPriceWhite;
+    uint32 buyerPriceGreen;
+    uint32 buyerPriceBlue;
+    uint32 buyerPricePurple;
+    uint32 buyerPriceOrange;
+    uint32 buyerPriceYellow;
+    uint32 buyerBiddingInterval;
+    uint32 buyerBidsPerInterval;
+
+    uint32 greytgp;
+    uint32 whitetgp;
+    uint32 greentgp;
+    uint32 bluetgp;
+    uint32 purpletgp;
+    uint32 orangetgp;
+    uint32 yellowtgp;
+    uint32 greyip;
+    uint32 whiteip;
+    uint32 greenip;
+    uint32 blueip;
+    uint32 purpleip;
+    uint32 orangeip;
+    uint32 yellowip;
+
+    uint32 greyTGoods;
+    uint32 whiteTGoods;
+    uint32 greenTGoods;
+    uint32 blueTGoods;
+    uint32 purpleTGoods;
+    uint32 orangeTGoods;
+    uint32 yellowTGoods;
+
+    uint32 greyItems;
+    uint32 whiteItems;
+    uint32 greenItems;
+    uint32 blueItems;
+    uint32 purpleItems;
+    uint32 orangeItems;
+    uint32 yellowItems;
+
+public:
+    AHBConfig(uint32 ahid)
+    {
+        AHID = ahid;
+        switch(ahid)
+        {
+        case 2:
+            AHFID = 55;
+            break;
+        case 6:
+            AHFID = 29;
+            break;
+        case 7:
+            AHFID = 120;
+            break;
+        default:
+            AHFID = 120;
+            break;
+        }
+    }
+    AHBConfig()
+    {
+    }
+    uint32 GetAHID()
+    {
+        return AHID;
+    }
+    uint32 GetAHFID()
+    {
+        return AHFID;
+    }
+    void SetMinItems(uint32 value)
+    {
+        minItems = value;
+    }
+    uint32 GetMinItems()
+    {
+        if ((minItems == 0) && (maxItems))
+            return maxItems;
+        else if ((maxItems) && (minItems > maxItems))
+            return maxItems;
+        else
+            return minItems;
+    }
+    void SetMaxItems(uint32 value)
+    {
+        maxItems = value;
+    // CalculatePercents() needs to be called, but only if
+    // SetPercentages() has been called at least once already.
+    }
+    uint32 GetMaxItems()
+    {
+        return maxItems;
+    }
+    void SetPercentages(uint32 greytg, uint32 whitetg, uint32 greentg, uint32 bluetg, uint32 purpletg, uint32 orangetg, uint32 yellowtg, uint32 greyi, uint32 whitei, uint32 greeni, uint32 bluei, uint32 purplei, uint32 orangei, uint32 yellowi)
+    {
+        uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+
+        if (totalPercent == 0)
+        {
+            maxItems = 0;
+        }
+        else if (totalPercent != 100)
+        {
+            greytg = 0;
+            whitetg = 27;
+            greentg = 12;
+            bluetg = 10;
+            purpletg = 1;
+            orangetg = 0;
+            yellowtg = 0;
+            greyi = 0;
+            whitei = 10;
+            greeni = 30;
+            bluei = 8;
+            purplei = 2;
+            orangei = 0;
+            yellowi = 0;
+        }
+        percentGreyTradeGoods = greytg;
+        percentWhiteTradeGoods = whitetg;
+        percentGreenTradeGoods = greentg;
+        percentBlueTradeGoods = bluetg;
+        percentPurpleTradeGoods = purpletg;
+        percentOrangeTradeGoods = orangetg;
+        percentYellowTradeGoods = yellowtg;
+        percentGreyItems = greyi;
+        percentWhiteItems = whitei;
+        percentGreenItems = greeni;
+        percentBlueItems = bluei;
+        percentPurpleItems = purplei;
+        percentOrangeItems = orangei;
+        percentYellowItems = yellowi;
+        CalculatePercents();
+    }
+    uint32 GetPercentages(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return percentGreyTradeGoods;
+            break;
+        case AHB_WHITE_TG:
+            return percentWhiteTradeGoods;
+            break;
+        case AHB_GREEN_TG:
+            return percentGreenTradeGoods;
+            break;
+        case AHB_BLUE_TG:
+            return percentBlueTradeGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return percentPurpleTradeGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return percentOrangeTradeGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return percentYellowTradeGoods;
+            break;
+        case AHB_GREY_I:
+            return percentGreyItems;
+            break;
+        case AHB_WHITE_I:
+            return percentWhiteItems;
+            break;
+        case AHB_GREEN_I:
+            return percentGreenItems;
+            break;
+        case AHB_BLUE_I:
+            return percentBlueItems;
+            break;
+        case AHB_PURPLE_I:
+            return percentPurpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return percentOrangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return percentYellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetMinPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minPriceGrey == 0)
+                    return 100;
+                else if (minPriceGrey > maxPriceGrey)
+                    return maxPriceGrey;
+                else
+                    return minPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minPriceWhite == 0)
+                    return 150;
+                else if (minPriceWhite > maxPriceWhite)
+                    return maxPriceWhite;
+                else
+                    return minPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minPriceGreen == 0)
+                    return 200;
+                else if (minPriceGreen > maxPriceGreen)
+                    return maxPriceGreen;
+                else
+                    return minPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minPriceBlue == 0)
+                    return 250;
+                else if (minPriceBlue > maxPriceBlue)
+                    return maxPriceBlue;
+                else
+                    return minPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minPricePurple == 0)
+                    return 300;
+                else if (minPricePurple > maxPricePurple)
+                    return maxPricePurple;
+                else
+                    return minPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minPriceOrange == 0)
+                    return 400;
+                else if (minPriceOrange > maxPriceOrange)
+                    return maxPriceOrange;
+                else
+                    return minPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minPriceYellow == 0)
+                    return 500;
+                else if (minPriceYellow > maxPriceYellow)
+                    return maxPriceYellow;
+                else
+                    return minPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxPriceGrey == 0)
+                    return 150;
+                else
+                    return maxPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxPriceWhite == 0)
+                    return 250;
+                else
+                    return maxPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxPriceGreen == 0)
+                    return 300;
+                else
+                    return maxPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxPriceBlue == 0)
+                    return 350;
+                else
+                    return maxPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxPricePurple == 0)
+                    return 450;
+                else
+                    return maxPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxPriceOrange == 0)
+                    return 550;
+                else
+                    return maxPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxPriceYellow == 0)
+                    return 650;
+                else
+                    return maxPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMinBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minBidPriceGrey > 100)
+                    return 100;
+                else
+                    return minBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minBidPriceWhite > 100)
+                    return 100;
+                else
+                    return minBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minBidPriceGreen > 100)
+                    return 100;
+                else
+                    return minBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minBidPriceBlue > 100)
+                    return 100;
+                else
+                    return minBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minBidPricePurple > 100)
+                    return 100;
+                else
+                    return minBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minBidPriceOrange > 100)
+                    return 100;
+                else
+                    return minBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minBidPriceYellow > 100)
+                    return 100;
+                else
+                    return minBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxBidPriceGrey > 100)
+                    return 100;
+                else
+                    return maxBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxBidPriceWhite > 100)
+                    return 100;
+                else
+                    return maxBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxBidPriceGreen > 100)
+                    return 100;
+                else
+                    return maxBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxBidPriceBlue > 100)
+                    return 100;
+                else
+                    return maxBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxBidPricePurple > 100)
+                    return 100;
+                else
+                    return maxBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxBidPriceOrange > 100)
+                    return 100;
+                else
+                    return maxBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxBidPriceYellow > 100)
+                    return 100;
+                else
+                    return maxBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxStack(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxStackGrey = value;
+            break;
+        case AHB_WHITE:
+            maxStackWhite = value;
+            break;
+        case AHB_GREEN:
+            maxStackGreen = value;
+            break;
+        case AHB_BLUE:
+            maxStackBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxStackPurple = value;
+            break;
+        case AHB_ORANGE:
+            maxStackOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxStackYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxStack(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                return maxStackGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                return maxStackWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                return maxStackGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                return maxStackBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                return maxStackPurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                return maxStackOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                return maxStackYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetBuyerPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            buyerPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            buyerPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            buyerPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            buyerPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            buyerPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            buyerPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            buyerPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetBuyerPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            return buyerPriceGrey;
+            break;
+        case AHB_WHITE:
+            return buyerPriceWhite;
+            break;
+        case AHB_GREEN:
+            return buyerPriceGreen;
+            break;
+        case AHB_BLUE:
+            return buyerPriceBlue;
+            break;
+        case AHB_PURPLE:
+            return buyerPricePurple;
+            break;
+        case AHB_ORANGE:
+            return buyerPriceOrange;
+            break;
+        case AHB_YELLOW:
+            return buyerPriceYellow;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBiddingInterval(uint32 value)
+    {
+        buyerBiddingInterval = value;
+    }
+    uint32 GetBiddingInterval()
+    {
+        return buyerBiddingInterval;
+    }
+    void CalculatePercents()
+    {
+        greytgp = (uint32) (((double)percentGreyTradeGoods / 100.0) * maxItems);
+        whitetgp = (uint32) (((double)percentWhiteTradeGoods / 100.0) * maxItems);
+        greentgp = (uint32) (((double)percentGreenTradeGoods / 100.0) * maxItems);
+        bluetgp = (uint32) (((double)percentBlueTradeGoods / 100.0) * maxItems);
+        purpletgp = (uint32) (((double)percentPurpleTradeGoods / 100.0) * maxItems);
+        orangetgp = (uint32) (((double)percentOrangeTradeGoods / 100.0) * maxItems);
+        yellowtgp = (uint32) (((double)percentYellowTradeGoods / 100.0) * maxItems);
+        greyip = (uint32) (((double)percentGreyItems / 100.0) * maxItems);
+        whiteip = (uint32) (((double)percentWhiteItems / 100.0) * maxItems);
+        greenip = (uint32) (((double)percentGreenItems / 100.0) * maxItems);
+        blueip = (uint32) (((double)percentBlueItems / 100.0) * maxItems);
+        purpleip = (uint32) (((double)percentPurpleItems / 100.0) * maxItems);
+        orangeip = (uint32) (((double)percentOrangeItems / 100.0) * maxItems);
+        yellowip = (uint32) (((double)percentYellowItems / 100.0) * maxItems);
+        uint32 total = greytgp + whitetgp + greentgp + bluetgp + purpletgp + orangetgp + yellowtgp + greyip + whiteip + greenip + blueip + purpleip + orangeip + yellowip;
+        int32 diff = (maxItems - total);
+        if (diff < 0)
+        {
+            if ((whiteip - diff) > 0)
+                whiteip -= diff;
+            else if ((greenip - diff) > 0)
+                greenip -= diff;
+        }
+        else if (diff < 0)
+        {
+            whiteip += diff;
+        }
+    }
+    uint32 GetPercents(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greytgp;
+            break;
+        case AHB_WHITE_TG:
+            return whitetgp;
+            break;
+        case AHB_GREEN_TG:
+            return greentgp;
+            break;
+        case AHB_BLUE_TG:
+            return bluetgp;
+            break;
+        case AHB_PURPLE_TG:
+            return purpletgp;
+            break;
+        case AHB_ORANGE_TG:
+            return orangetgp;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowtgp;
+            break;
+        case AHB_GREY_I:
+            return greyip;
+            break;
+        case AHB_WHITE_I:
+            return whiteip;
+            break;
+        case AHB_GREEN_I:
+            return greenip;
+            break;
+        case AHB_BLUE_I:
+            return blueip;
+            break;
+        case AHB_PURPLE_I:
+            return purpleip;
+            break;
+        case AHB_ORANGE_I:
+            return orangeip;
+            break;
+        case AHB_YELLOW_I:
+            return yellowip;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+
+    void DecItemCounts(uint32 Class, uint32 Quality)
+    {
+        switch(Class)
+        {
+        case ITEM_CLASS_TRADE_GOODS:
+            DecItemCounts(Quality);
+            break;
+        default:
+            DecItemCounts(Quality + 7);
+            break;
+        }
+    }
+
+    void DecItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            --greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            --whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            --greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            --blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            --purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            --orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            --yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            --greyItems;
+            break;
+        case AHB_WHITE_I:
+            --whiteItems;
+            break;
+        case AHB_GREEN_I:
+            --greenItems;
+            break;
+        case AHB_BLUE_I:
+            --blueItems;
+            break;
+        case AHB_PURPLE_I:
+            --purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            --orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            --yellowItems;
+            break;
+        default:
+            break;
+        }
+    }
+
+    void IncItemCounts(uint32 Class, uint32 Quality)
+    {
+        switch(Class)
+        {
+        case ITEM_CLASS_TRADE_GOODS:
+            IncItemCounts(Quality);
+            break;
+        default:
+            IncItemCounts(Quality + 7);
+            break;
+        }
+    }
+
+    void IncItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            ++greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            ++whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            ++greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            ++blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            ++purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            ++orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            ++yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            ++greyItems;
+            break;
+        case AHB_WHITE_I:
+            ++whiteItems;
+            break;
+        case AHB_GREEN_I:
+            ++greenItems;
+            break;
+        case AHB_BLUE_I:
+            ++blueItems;
+            break;
+        case AHB_PURPLE_I:
+            ++purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            ++orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            ++yellowItems;
+            break;
+        default:
+            break;
+        }
+    }
+
+    void ResetItemCounts()
+    {
+        greyTGoods = 0;
+        whiteTGoods = 0;
+        greenTGoods = 0;
+        blueTGoods = 0;
+        purpleTGoods = 0;
+        orangeTGoods = 0;
+        yellowTGoods = 0;
+
+        greyItems = 0;
+        whiteItems = 0;
+        greenItems = 0;
+        blueItems = 0;
+        purpleItems = 0;
+        orangeItems = 0;
+        yellowItems = 0;
+    }
+
+    uint32 TotalItemCounts()
+    {
+        return(
+        greyTGoods +
+        whiteTGoods +
+        greenTGoods +
+        blueTGoods +
+        purpleTGoods +
+        orangeTGoods +
+        yellowTGoods +
+
+        greyItems +
+        whiteItems +
+        greenItems +
+        blueItems +
+        purpleItems +
+        orangeItems +
+        yellowItems);
+    }
+
+    uint32 GetItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            return whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            return greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            return blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            return greyItems;
+            break;
+        case AHB_WHITE_I:
+            return whiteItems;
+            break;
+        case AHB_GREEN_I:
+            return greenItems;
+            break;
+        case AHB_BLUE_I:
+            return blueItems;
+            break;
+        case AHB_PURPLE_I:
+            return purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return yellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBidsPerInterval(uint32 value)
+    {
+        buyerBidsPerInterval = value;
+    }
+    uint32 GetBidsPerInterval()
+    {
+        return buyerBidsPerInterval;
+    }
+    ~AHBConfig()
+    {
+    }
+};
+class AuctionHouseBot
+{
+private:
+
+    bool debug_Out;
+    bool debug_Out_Filters;
+
+    bool AHBSeller;
+    bool AHBBuyer;
+    bool BuyMethod;
+    bool SellMethod;
+
+    uint32 AHBplayerAccount;
+    uint32 AHBplayerGUID;
+    uint32 ItemsPerCycle;
+
+    //Begin Filters
+
+    bool Vendor_Items;
+    bool Loot_Items;
+    bool Other_Items;
+    bool Vendor_TGs;
+    bool Loot_TGs;
+    bool Other_TGs;
+
+    bool No_Bind;
+    bool Bind_When_Picked_Up;
+    bool Bind_When_Equipped;
+    bool Bind_When_Use;
+    bool Bind_Quest_Item;
+
+    bool DisablePermEnchant;
+    bool DisableConjured;
+    bool DisableGems;
+    bool DisableMoney;
+    bool DisableMoneyLoot;
+    bool DisableLootable;
+    bool DisableKeys;
+    bool DisableDuration;
+    bool DisableBOP_Or_Quest_NoReqLevel;
+
+    bool DisableWarriorItems;
+    bool DisablePaladinItems;
+    bool DisableHunterItems;
+    bool DisableRogueItems;
+    bool DisablePriestItems;
+    bool DisableDKItems;
+    bool DisableShamanItems;
+    bool DisableMageItems;
+    bool DisableWarlockItems;
+    bool DisableUnusedClassItems;
+    bool DisableDruidItems;
+
+    uint32 DisableItemsBelowLevel;
+    uint32 DisableItemsAboveLevel;
+    uint32 DisableTGsBelowLevel;
+    uint32 DisableTGsAboveLevel;
+    uint32 DisableItemsBelowGUID;
+    uint32 DisableItemsAboveGUID;
+    uint32 DisableTGsBelowGUID;
+    uint32 DisableTGsAboveGUID;
+    uint32 DisableItemsBelowReqLevel;
+    uint32 DisableItemsAboveReqLevel;
+    uint32 DisableTGsBelowReqLevel;
+    uint32 DisableTGsAboveReqLevel;
+    uint32 DisableItemsBelowReqSkillRank;
+    uint32 DisableItemsAboveReqSkillRank;
+    uint32 DisableTGsBelowReqSkillRank;
+    uint32 DisableTGsAboveReqSkillRank;
+
+    std::set<uint32> DisableItemStore;
+	bool SellGlyphs;
+	uint32 GlyphsCount;
+	uint32 DisableGlyphBelowLevel;
+	uint32 DisableGlyphAboveLevel;
+	uint32 GlyphBuyOutPriceMin;
+	uint32 GlyphBuyOutPriceMax;
+	uint32 GlyphBidPriceMin;
+	uint32 GlyphBidPriceMax;
+
+    //End Filters
+
+    AHBConfig AllianceConfig;
+    AHBConfig HordeConfig;
+    AHBConfig NeutralConfig;
+
+    time_t _lastrun_a;
+    time_t _lastrun_h;
+    time_t _lastrun_n;
+
+    inline uint32 minValue(uint32 a, uint32 b) { return a <= b ? a : b; };
+    void addNewAuctions(Player *AHBplayer, AHBConfig *config);
+    void addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session);
+
+    friend class ACE_Singleton<AuctionHouseBot, ACE_Null_Mutex>;
+    AuctionHouseBot();
+
+public:
+    ~AuctionHouseBot();
+    void Update();
+    void Initialize();
+    void LoadValues(AHBConfig*);
+    void DecrementItemCounts(AuctionEntry* ah, uint32 item_template);
+    void IncrementItemCounts(AuctionEntry* ah);
+    void Commands(uint32, uint32, uint32, char*);
+    uint32 GetAHBplayerGUID() { return AHBplayerGUID; };
+};
+
+#define auctionbot (*ACE_Singleton<AuctionHouseBot, ACE_Null_Mutex>::instance())
+
+#endif
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index 8b99454..3b763d2 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -173,7 +173,7 @@ void AuctionHouseMgr::SendAuctionSuccessfulMail(AuctionEntry* auction, SQLTransa
         uint32 profit = auction->bid + auction->deposit - auction->GetAuctionCut();
 
         //FIXME: what do if owner offline
-        if (owner)
+        if (owner && owner->GetGUIDLow() != auctionbot.GetAHBplayerGUID())
         {
             owner->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_EARNED_BY_AUCTIONS, profit);
             owner->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_AUCTION_SOLD, auction->bid);
@@ -201,7 +201,7 @@ void AuctionHouseMgr::SendAuctionExpiredMail(AuctionEntry* auction, SQLTransacti
     // owner exist
     if (owner || owner_accId)
     {
-        if (owner)
+        if (owner && owner->GetGUIDLow() != auctionbot.GetAHBplayerGUID())
             owner->GetSession()->SendAuctionOwnerNotification(auction);
 
         MailDraft(auction->BuildAuctionMailSubject(AUCTION_EXPIRED), AuctionEntry::BuildAuctionMailBody(0, 0, auction->buyout, auction->deposit, 0))
@@ -223,6 +223,9 @@ void AuctionHouseMgr::SendAuctionOutbiddedMail(AuctionEntry* auction, uint32 new
     // old bidder exist
     if (oldBidder || oldBidder_accId)
     {
+        if (oldBidder && !newBidder)
+            oldBidder->GetSession()->SendAuctionBidderNotification(auction->GetHouseId(), auction->Id, auctionbot.GetAHBplayerGUID(), newPrice, auction->GetAuctionOutBid(), auction->itemEntry);
+
         if (oldBidder && newBidder)
             oldBidder->GetSession()->SendAuctionBidderNotification(auction->GetHouseId(), auction->Id, newBidder->GetGUID(), newPrice, auction->GetAuctionOutBid(), auction->itemEntry);
 
@@ -414,10 +417,12 @@ void AuctionHouseObject::AddAuction(AuctionEntry* auction)
 
     AuctionsMap[auction->Id] = auction;
     sScriptMgr->OnAuctionAdd(this, auction);
+    auctionbot.IncrementItemCounts(auction);
 }
 
-bool AuctionHouseObject::RemoveAuction(AuctionEntry* auction, uint32 /*itemEntry*/)
+bool AuctionHouseObject::RemoveAuction(AuctionEntry* auction, uint32 itemEntry)
 {
+    auctionbot.DecrementItemCounts(auction, itemEntry);
     bool wasInMap = AuctionsMap.erase(auction->Id) ? true : false;
 
     sScriptMgr->OnAuctionRemove(this, auction);
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.h b/src/server/game/AuctionHouse/AuctionHouseMgr.h
index 4892821..2a688f5 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.h
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.h
@@ -25,6 +25,8 @@
 #include "DatabaseEnv.h"
 #include "DBCStructure.h"
 
+#include "AuctionHouseBot/AuctionHouseBot.h"
+
 class Item;
 class Player;
 class WorldPacket;
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index f455610..5bec069 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -13,6 +13,7 @@ file(GLOB_RECURSE sources_Achievements Achievements/*.cpp Achievements/*.h)
 file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
 file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
 file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
+file(GLOB_RECURSE sources_AuctionHouseBot AuctionHouse/AuctionHouseBot/*.cpp AuctionHouse/AuctionHouseBot/*.h)
 file(GLOB_RECURSE sources_Battlefield Battlefield/*.cpp Battlefield/*.h)
 file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
 file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
@@ -63,6 +64,7 @@ set(game_STAT_SRCS
   ${sources_Addons}
   ${sources_AI}
   ${sources_AuctionHouse}
+  ${sources_AuctionHouseBot}
   ${sources_Battlefield}
   ${sources_Battlegrounds}
   ${sources_Calendar}
@@ -129,11 +131,13 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Achievements
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/NpcBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/EventAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
+  ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse/AuctionHouseBot
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlefield/Zones
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 2af7824..6c91f51 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -54,6 +54,9 @@
 
 // apply implementation of the singletons
 
+// npcbot
+#include "bot_ai.h"
+
 TrainerSpell const* TrainerSpellData::Find(uint32 spell_id) const
 {
     TrainerSpellMap::const_iterator itr = spellList.find(spell_id);
@@ -165,6 +168,13 @@ m_creatureInfo(NULL), m_creatureData(NULL), m_path_id(0), m_formation(NULL)
     ResetLootMode(); // restore default loot mode
     TriggerJustRespawned = false;
     m_isTempWorldObject = false;
+
+    //bot
+    m_bot_owner = NULL;
+    m_creature_owner = NULL;
+    m_bots_pet = NULL;
+    m_bot_class = CLASS_NONE;
+    bot_AI = NULL;
 }
 
 Creature::~Creature()
@@ -233,6 +243,8 @@ void Creature::RemoveCorpse(bool setSpawnTime)
 {
     if (getDeathState() != CORPSE)
         return;
+    if (bot_AI)
+        return;
 
     m_corpseRemoveTime = time(NULL);
     setDeathState(DEAD);
@@ -2635,3 +2647,125 @@ void Creature::SetDisplayId(uint32 modelId)
         SetFloatValue(UNIT_FIELD_COMBATREACH, minfo->combat_reach * GetObjectScale());
     }
 }
+
+void Creature::SetIAmABot(bool bot)
+{
+    if (!bot)
+    {
+        bot_AI->UnsummonAll();
+        IsAIEnabled = false;
+        bot_AI = NULL;
+        SetUInt64Value(UNIT_FIELD_CREATEDBY, 0);
+    }
+}
+
+void Creature::SetBotsPetDied()
+{
+    if (!m_bots_pet)
+        return;
+    m_bots_pet->SetCharmerGUID(0);
+    m_bots_pet->SetCreatureOwner(NULL);
+    //m_bots_pet->GetBotPetAI()->SetCreatureOwner(NULL);
+    m_bots_pet->SetIAmABot(false);
+    m_bot_owner->SetMinion((Minion*)m_bots_pet, false);
+    m_bots_pet->CleanupsBeforeDelete();
+    m_bots_pet->AddObjectToRemoveList();
+    m_bots_pet = NULL;
+}
+
+void Creature::SetBotTank(Unit* newtank)
+{
+    if (!bot_AI || !IsAIEnabled)
+        return;
+    uint64 tankGuid = bot_AI->GetBotTankGuid();
+    if (newtank && newtank->GetGUID() == tankGuid) return;
+    Creature* oldtank = tankGuid && IS_CREATURE_GUID(tankGuid) ? sObjectAccessor->GetObjectInWorld(tankGuid, (Creature* )NULL) : NULL;
+    if (oldtank && oldtank->IsInWorld() && (oldtank->GetIAmABot() || oldtank->GetIAmABotsPet()))
+    {
+        oldtank->RemoveAurasDueToSpell(DEFENSIVE_STANCE_PASSIVE);
+        uint8 ClassOrPetType = oldtank->GetIAmABotsPet() ? bot_pet_ai::GetPetType(oldtank) : oldtank->GetBotClass();
+        oldtank->GetBotAI()->ApplyPassives(ClassOrPetType);
+    }
+    if (newtank == this)
+    {
+        for (uint8 i = 0; i < 3; ++i)
+            AddAura(DEFENSIVE_STANCE_PASSIVE, this);
+        if (Player* owner = m_bot_owner)
+        {
+            switch (urand(1,5))
+            {
+            case 1: MonsterWhisper("I am tank here!", owner->GetGUID()); break;
+            case 2: MonsterWhisper("I will tank now.", owner->GetGUID()); break;
+            case 3: MonsterWhisper("I gonna tank", owner->GetGUID()); break;
+            case 4: MonsterWhisper("I think I will be best tank here...", owner->GetGUID()); break;
+            case 5: MonsterWhisper("I AM the tank!", owner->GetGUID()); break;
+            }
+        }
+        bot_AI->UpdateHealth();
+        if (!IsInCombat())
+            SetBotCommandState(COMMAND_FOLLOW, true);
+    }
+    bot_AI->SetBotTank(newtank);
+}
+
+void Creature::SetBotCommandState(CommandStates st, bool force)
+{
+    if (bot_AI && IsAIEnabled)
+        bot_AI->SetBotCommandState(st, force);
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
+}
+void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+
+bool Creature::GetIAmABot() const
+{
+    return bot_AI ? bot_AI->IsMinionAI() : false;
+}
+
+bool Creature::GetIAmABotsPet() const
+{
+    return bot_AI ? bot_AI->IsPetAI() : false;
+}
+
+bot_minion_ai* Creature::GetBotMinionAI() const
+{
+    return IsAIEnabled && bot_AI && bot_AI->IsMinionAI() ? const_cast<bot_minion_ai*>(bot_AI->GetMinionAI()) : NULL;
+}
+
+bot_pet_ai* Creature::GetBotPetAI() const
+{
+    return IsAIEnabled && bot_AI && bot_AI->IsPetAI() ? const_cast<bot_pet_ai*>(bot_AI->GetPetAI()) : NULL;
+}
+
+void Creature::InitBotAI(bool asPet)
+{
+    ASSERT(!bot_AI);
+
+    if (asPet)
+        bot_AI = (bot_pet_ai*)AI();
+    else
+        bot_AI = (bot_minion_ai*)AI();
+}
+
+void Creature::SetBotShouldUpdateStats()
+{
+    if (bot_AI) bot_AI->SetShouldUpdateStats();
+}
+
+void Creature::OnBotSummon(Creature* summon)
+{
+    if (bot_AI) bot_AI->OnBotSummon(summon);
+}
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index 34084dd..bf25feb 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -37,6 +37,11 @@ class Player;
 class SpellInfo;
 class WorldSession;
 
+// npcbot
+class bot_ai;
+class bot_minion_ai;
+class bot_pet_ai;
+
 enum CreatureFlagsExtra
 {
     CREATURE_FLAG_EXTRA_INSTANCE_BIND   = 0x00000001,       // creature kill bind instance with killer and killer's group
@@ -703,6 +708,32 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
 
         bool m_isTempWorldObject; //true when possessed
 
+        //Bot commands
+        Player* GetBotOwner() const { return m_bot_owner; }
+        void SetBotOwner(Player* newowner) { m_bot_owner = newowner; }
+        Creature* GetCreatureOwner() const { return m_creature_owner; }
+        void SetCreatureOwner(Creature* newCreOwner) { m_creature_owner = newCreOwner; } 
+        Creature* GetBotsPet() const { return m_bots_pet; }
+        void SetBotsPetDied();
+        void SetBotsPet(Creature* newpet) { /*ASSERT (!m_bots_pet);*/ m_bots_pet = newpet; }
+        void SetIAmABot(bool bot = true);
+        bool GetIAmABot() const;
+        bool GetIAmABotsPet() const;
+        void SetBotClass(uint8 myclass) { m_bot_class = myclass; }
+        uint8 GetBotClass() const { return m_bot_class; }
+        void SetBotTank(Unit* newtank);
+        bot_ai* GetBotAI() const { return bot_AI; }
+        bot_minion_ai* GetBotMinionAI() const;
+        bot_pet_ai* GetBotPetAI() const;
+        void InitBotAI(bool asPet = false);
+        void SetBotCommandState(CommandStates st, bool force = false);
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void SetBotShouldUpdateStats();
+        void OnBotSummon(Creature* summon);
+        //Bot commands
+
     protected:
         bool CreateFromProto(uint32 guidlow, uint32 Entry, uint32 vehId, uint32 team, const CreatureData* data = NULL);
         bool InitEntry(uint32 entry, uint32 team=ALLIANCE, const CreatureData* data=NULL);
@@ -753,6 +784,14 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
         bool IsInvisibleDueToDespawn() const;
         bool CanAlwaysSee(WorldObject const* obj) const;
     private:
+        //bot system
+        Player* m_bot_owner;
+        Creature* m_creature_owner;
+        Creature* m_bots_pet;
+        bot_ai* bot_AI;
+        uint8 m_bot_class;
+        //end bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0);
 
         //WaypointMovementGenerator vars
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index 05bedf9..99f959f 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -253,6 +253,14 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+    //npcbot
+    if (GetIAmABot() || GetIAmABotsPet())
+    {
+        //TC_LOG_ERROR("TempSummon::UnSummon(): Trying to unsummon Bot %s(owner: %s). Aborted", GetName(), GetBotOwner()->GetName());
+        return;
+    }
+    //end npcbots
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index ec6a3e5..81a0622 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -2225,6 +2225,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner);
             break;
         case UNIT_MASK_TOTEM:
+            //npcbot: totem emul step 1
+            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+                summon = new Totem(properties, summoner->ToCreature()->GetBotOwner());
+            else
+            //end npcbot
             summon = new Totem(properties, summoner);
             break;
         case UNIT_MASK_MINION:
@@ -2248,6 +2253,12 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature());
     summon->InitSummon();
 
+    //npcbot: totem emul step 2
+    if (mask == UNIT_MASK_TOTEM)
+        if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+            summoner->ToCreature()->OnBotSummon(summon);
+    //end npcbot
+
     //ObjectAccessor::UpdateObjectVisibility(summon);
 
     return summon;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 2ff86f8..2543f52 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -78,6 +78,10 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+//Bot
+#include "Config.h"
+#include "bothelper.h"
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 #define PLAYER_SKILL_INDEX(x)       (PLAYER_SKILL_INFO_1_1 + ((x)*3))
@@ -520,6 +524,18 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPct(xp, (*i)->GetAmount());
 
+        //npcbot 4.2.2.1. Apply NpcBot XP reduction
+        if (player->HaveBot() && player->GetNpcBotsCount() > 1)
+        {
+            if (uint8 xp_rate = player->GetNpcBotXpReduction())
+            {
+                int32 ratePct = 100 - (player->GetNpcBotsCount() - 1) * xp_rate;
+                ratePct = std::max<int32>(ratePct, 10); // minimum
+                //ratePct = std::min<int32>(ratePct, 100); // maximum // dead code
+                xp = xp * ratePct / 100;
+            }
+        }
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
@@ -857,6 +873,30 @@ Player::Player(WorldSession* session): Unit(true)
 
     m_ChampioningFaction = 0;
 
+    ///////////////////// Bot System ////////////////////////
+    _botHlpr = NULL;
+    //Npcbot
+    m_botTimer = 500;
+    m_bot = NULL;
+    m_botTankGuid = 0;
+    m_enableNpcBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true);
+    m_followdist = sConfigMgr->GetIntDefault("Bot.BaseFollowDistance", 30);
+    m_maxNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.MaxNpcBots", 1), MAX_NPCBOTS);
+    uint8 maxcbots = sConfigMgr->GetIntDefault("Bot.MaxNpcBotsPerClass", 1);
+    m_maxClassNpcBots = maxcbots > 0 ? maxcbots : MAX_NPCBOTS;
+    m_xpReductionNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.XpReductionPercent", 0), 100);
+    m_enableAllNpcBots = sConfigMgr->GetBoolDefault("Bot.AllowAllClasses", false);
+    m_enableNpcBotsArenas = sConfigMgr->GetBoolDefault("Bot.EnableInArenas", true);
+    m_enableNpcBotsBGs = sConfigMgr->GetBoolDefault("Bot.EnableInBGs", true);
+    m_enableNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.EnableInDungeons", true);
+    m_enableNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.EnableInRaids", true);
+    m_limitNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Dungeons", false);
+    m_limitNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Raids", false);
+    m_NpcBotsCost = sConfigMgr->GetIntDefault("Bot.Cost", 0);
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        m_botmap[i] = new NpcBotMap();
+    ///////////////////// End Bot System ////////////////////////
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -909,6 +949,16 @@ Player::~Player()
     delete m_achievementMgr;
     delete m_reputationMgr;
 
+    if (_botHlpr)
+    {
+        delete _botHlpr;
+        _botHlpr = NULL;
+    }
+
+    //Npcbot mod: delete botmap
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        delete m_botmap[i];
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1832,6 +1882,17 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    //NpcBot mod: Update
+    if (m_botTimer > 0)
+    {
+        if (p_time >= m_botTimer)
+            m_botTimer = 0;
+        else
+            m_botTimer -= p_time;
+    }
+    else
+        RefreshBot(p_time);
 }
 
 void Player::setDeathState(DeathState s)
@@ -2208,6 +2269,13 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         if (!sMapMgr->CanPlayerEnter(mapid, this, false))
             return false;
 
+        //Npcbot mod: prevent crash on InstanceMap::DestroyInstance()... Unit::RemoveFromWorld()
+        //if last player being kicked out of instance while having npcbots
+        //we must remove creature Before it will be removed in Map::UnloadAll()
+        if (GetMapId() != mapid)
+            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+                RemoveBot(m_botmap[i]->m_guid);
+
         //I think this always returns true. Correct me if I am wrong.
         // If the map is not created, assume it is possible to enter it.
         // It will be created in the WorldPortAck.
@@ -2455,6 +2523,764 @@ void Player::RemoveFromWorld()
     }
 }
 
+void Player::RefreshBot(uint32 diff)
+{
+    if (m_botTimer > 0) return;
+    m_botTimer = 100 + IsInFlight()*3000;//x2 ms //temp hack
+    if (!HaveBot()) return;
+
+    //addition for revive timer (maybe we should check whole party?)
+    bool partyInCombat = IsInCombat();
+    if (!partyInCombat)
+    {
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        {
+            if (Creature* bot = m_botmap[i]->m_creature)
+            {
+                if (bot->IsInCombat())
+                {
+                    partyInCombat = true;
+                    break;
+                }
+                else if (Creature* pet = bot->GetBotsPet())
+                {
+                    if (pet->IsInCombat())
+                    {
+                        partyInCombat = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        uint64 guid = m_botmap[i]->m_guid;
+        m_bot = m_botmap[i]->m_creature;
+        if (!m_bot || !m_bot->IsInWorld())
+            continue;
+        //BOT REVIVE SUPPORT
+        //Do not allow bot to be revived if master is in battle
+        if (!partyInCombat)
+        {
+            if (m_botmap[i]->m_reviveTimer > diff)
+            {
+                if (!IsInCombat())
+                    m_botmap[i]->m_reviveTimer -= diff;
+            }
+            else if (m_botmap[i]->m_reviveTimer > 0)
+                m_botmap[i]->m_reviveTimer = 0;
+        }
+        if ((m_bot->isDead() || !m_bot->IsAlive()) && IsAlive() && !IsInCombat() && !InArena() && !IsInFlight() && 
+            !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) && 
+            m_botmap[i]->m_reviveTimer == 0 && 
+            !HasInvisibilityAura() && !HasStealthAura())
+        {
+            CreateBot(0, 0, 0, false, true);//revive
+            continue;
+        }
+        //BOT MUST DIE SUPPORT
+        if (IsInFlight() || !GetGroup() || !GetGroup()->IsMember(m_bot->GetGUID()))//even if bot is dead
+        {
+            RemoveBot(guid, !IsInFlight());
+            continue;
+        }
+        //TELEPORT/OUTRUN SUPPORT
+        if (!IsInFlight() && IsAlive() && (m_bot->IsAlive() || m_bot->GetMapId() != GetMapId()))
+        {
+            float maxdist;
+            if (GetMap()->IsDungeon())
+                maxdist = sWorld->GetMaxVisibleDistanceInInstances();
+            else if (GetMap()->IsBattlegroundOrArena())
+                maxdist = sWorld->GetMaxVisibleDistanceInBGArenas();
+            else
+                maxdist = sWorld->GetMaxVisibleDistanceOnContinents();
+
+            maxdist += 20.0f; //allow player to recall it by moving back
+
+            if (abs(m_bot->GetPositionX() - GetPositionX()) > maxdist ||
+                abs(m_bot->GetPositionY() - GetPositionY()) > maxdist ||
+                m_bot->GetMapId() != GetMapId() || RestrictBots())
+            {
+                RemoveBot(guid);
+                continue;
+            }
+        }
+        m_bot = NULL;
+    }//end for botmap
+    //BOT CREATION/RECREATION SUPPORT
+    if (!IsInFlight() && IsAlive() && !HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT) && GetBotMustBeCreated() && !RestrictBots())
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry != 0 && m_botmap[pos]->m_guid == 0)
+                CreateBot(m_botmap[pos]->m_entry, m_botmap[pos]->m_race, m_botmap[pos]->m_class, m_botmap[pos]->tank);
+}
+
+void Player::SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, bool istank)
+{
+    if (m_enableNpcBots == false)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact your administration.");
+        ClearBotMustBeCreated(0, 0, true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry == 0)
+        {
+            m_botmap[pos]->m_guid = 0;//we need it to make sure Player::CreateBot will find this slot
+            m_botmap[pos]->m_entry = m_entry;
+            m_botmap[pos]->m_race = m_race;
+            m_botmap[pos]->m_class = m_class;
+            m_botmap[pos]->tank = istank;
+            break;
+        }
+    }
+}
+
+bool Player::GetBotMustBeCreated()
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry != 0 && 
+            (m_botmap[pos]->m_guid == 0 || !sObjectAccessor->FindUnit(m_botmap[pos]->m_guid)))
+        {
+            m_botmap[pos]->m_guid = 0;
+            return true;
+        }
+    }
+    return false;
+}
+
+void Player::ClearBotMustBeCreated(uint64 guidOrSlot, bool guid, bool fully)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if ((guid == true && m_botmap[pos]->m_guid == guidOrSlot) || 
+            (guid == false && pos == guidOrSlot) || 
+            fully)
+        {
+            m_botmap[pos]->m_guid = 0;
+            m_botmap[pos]->m_entry = 0;
+            m_botmap[pos]->m_race = 0;
+            m_botmap[pos]->m_class = 0;
+            m_botmap[pos]->m_creature = NULL;
+            m_botmap[pos]->tank = false;
+            if (!fully)
+                break;
+        }
+    }
+}
+
+void Player::RemoveBot(uint64 guid, bool final, bool eraseFromDB)
+{
+    if (guid == 0) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i]->m_guid == guid)
+        {
+            m_bot = m_botmap[i]->m_creature;
+            break;
+        }
+    }
+    if (!m_bot)
+        m_bot = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL);
+    if (m_bot)
+    {
+        //do not disband group unless not in dungeon or forced or on logout (Check WorldSession::LogoutPlayer())
+        Group* gr = GetGroup();
+        if (gr && gr->IsMember(guid))
+        {
+            if (gr->GetMembersCount() > 2 || /*!GetMap()->Instanceable() || */(final && eraseFromDB))
+                gr->RemoveMember(guid);
+            else //just cleanup
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_MEMBER);
+                stmt->setUInt32(0, GUID_LOPART(guid));
+                CharacterDatabase.Execute(stmt);
+            }
+        }
+
+        m_bot->SetBotsPetDied();
+        m_bot->SetCharmerGUID(0);
+        //m_bot->SetBotOwner(NULL);
+        m_bot->SetIAmABot(false);
+        SetMinion((Minion*)m_bot, false);
+        m_bot->CleanupsBeforeDelete();
+        m_bot->AddObjectToRemoveList();
+
+        if (final)//on logout or by command
+        {
+            ClearBotMustBeCreated(guid);
+            if (eraseFromDB)//by command
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt32(1, m_bot->GetEntry());
+                CharacterDatabase.Execute(stmt);
+                //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_bot->GetEntry());
+            }
+        }
+        else
+        {
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            {
+                if (m_botmap[pos]->m_guid == guid)
+                {
+                    m_botmap[pos]->m_guid = 0;//reset guid so it can be set during recreation
+                    m_botmap[pos]->m_creature = NULL;
+                }
+            }
+        }
+        m_bot = NULL;
+    }
+}
+
+void Player::CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool istank, bool revive)
+{
+    if (IsBeingTeleported() || IsInFlight()) return; //don't create bot yet
+    if (isDead() && !revive) return; //not to revive by command so abort
+    if (IsInCombat()) return;
+
+    if (m_bot != NULL && revive)
+    {
+        m_bot->SetHealth(uint32(float(m_bot->GetCreateHealth()) * 0.15f));//15% of base health
+        if (m_bot->getPowerType() == POWER_MANA)
+            m_bot->SetPower(POWER_MANA, m_bot->GetCreateMana());
+        m_bot->setDeathState(ALIVE);
+        m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+        return;
+    }
+    if (m_enableNpcBots == false && revive == false)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact administration.");
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        return;
+    }
+    if (!botentry || !botrace || !botclass)
+    {
+        TC_LOG_ERROR(LOG_FILTER_PLAYER, "ERROR! CreateBot(): player %s (%u) trying to create bot with entry = %u, race = %u, class = %u, ignored", GetName().c_str(), GetGUIDLow(), botentry, botrace, botclass);
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        return;
+    }
+    //npcbot counter is already increased in SetBotMustBeCreated()
+    if (GetNpcBotsCount() > GetMaxNpcBots())
+    {
+        ChatHandler ch(GetSession());
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        ch.PSendSysMessage("Youre exceed max npcbots");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    //instance limit check
+    if ((m_limitNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) || (m_limitNpcBotsRaids && GetMap()->IsRaid()))
+    {
+        InstanceMap* map = (InstanceMap*)GetMap();
+        uint32 count = 0;
+        Map::PlayerList const& plMap = map->GetPlayers();
+        for (Map::PlayerList::const_iterator itr = plMap.begin(); itr != plMap.end(); ++itr)
+            if (Player* player = itr->GetSource())
+                count += (1 + player->GetNpcBotsCount());
+
+        //check "more" cuz current bot is queued and we are to choose to remove it or not
+        if (count > map->GetMaxPlayers())
+        {
+            ChatHandler ch(GetSession());
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+                if (m_botmap[pos]->m_entry == botentry)
+                    ClearBotMustBeCreated(pos, false);
+            ch.PSendSysMessage("Instance players limit exceed");
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+    if (GetGroup() && GetGroup()->isRaidGroup() && GetGroup()->IsFull())
+    {
+        ChatHandler ch(GetSession());
+        ch.PSendSysMessage("Your group is Full!");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_entry == botentry)
+            if (m_botmap[pos]->m_reviveTimer != 0)
+                return;
+
+    m_bot = SummonCreature(botentry, *this);
+
+    //check if we have free slot
+    bool _set = false;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry == botentry && m_botmap[pos]->m_guid == 0)
+        {
+            m_botmap[pos]->m_guid = m_bot->GetGUID();
+            m_botmap[pos]->m_creature = m_bot;//this will save some time but we need guid as well
+            m_botmap[pos]->tank = istank;
+            _set = true;
+            break;
+        }
+    }
+    if (!_set)
+    {
+        TC_LOG_ERROR(LOG_FILTER_PLAYER, "character %s (%u) is failed to create npcbot! Removing all bots", GetName().c_str(), GetGUIDLow());
+
+        m_bot->CombatStop();
+        m_bot->CleanupsBeforeDelete();
+        m_bot->AddObjectToRemoveList();
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            RemoveBot(m_botmap[pos]->m_guid, true);
+        ClearBotMustBeCreated(0, false, true);
+        return;
+    }
+
+    m_bot->SetBotOwner(this);
+    m_bot->SetUInt64Value(UNIT_FIELD_CREATEDBY, GetGUID());
+    SetMinion((Minion*)m_bot, true);
+    m_bot->CombatStop();
+    m_bot->DeleteThreatList();
+    m_bot->AddUnitTypeMask(UNIT_MASK_MINION);
+
+    m_bot->SetByteValue(UNIT_FIELD_BYTES_0, 0, botrace);
+    m_bot->setFaction(getFaction());
+    m_bot->SetLevel(getLevel());
+    m_bot->SetBotClass(botclass);
+    m_bot->AIM_Initialize();
+    m_bot->InitBotAI();
+    m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    //entry is unique for each master's bot so clean it up just in case
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT);
+    stmt->setUInt32(0, GetGUIDLow());
+    stmt->setUInt32(1, botentry);
+    trans->Append(stmt);
+    //CharacterDatabase.Execute(stmt);
+    //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), botentry);
+    //add the new entry
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+    stmt->setUInt32(0, GetGUIDLow());
+    stmt->setUInt32(1, botentry);
+    stmt->setUInt8(2, botrace);
+    stmt->setUInt8(3, botclass);
+    stmt->setUInt8(4, uint8(istank));
+    trans->Append(stmt);
+    CharacterDatabase.CommitTransaction(trans);
+    //CharacterDatabase.Execute(stmt);
+    //CharacterDatabase.PExecute("INSERT INTO `character_npcbot` (owner,entry,race,class,istank) VALUES ('%u','%u','%u','%u','%u')", GetGUIDLow(), botentry, botrace, botclass, uint8(istank));
+    //If we have a group, just add bot
+    if (Group* gr = GetGroup())
+    {
+        if (!gr->IsFull())
+        {
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else if (!gr->isRaidGroup()) //non-raid group is full
+        {
+            gr->ConvertToRaid();
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else //raid group is full
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(this))
+        {
+            delete gr;
+            return;
+        }
+        sGroupMgr->AddGroup(gr);
+        if (!gr->AddMember((Player*)m_bot))
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+
+    if (Group* gr = GetGroup())
+    {
+        Group::MemberSlotList const a = gr->GetMemberSlots();
+        //try to remove 'absent' bots
+        for (Group::member_citerator itr = a.begin(); itr != a.end(); ++itr)
+        {
+            if (itr->guid == 0)
+                continue;
+            if (IS_PLAYER_GUID(itr->guid))
+                continue;
+            if (!sObjectAccessor->FindUnit(itr->guid))
+                gr->RemoveMember(itr->guid);
+        }
+    }
+
+} //end Player::CreateBot
+
+uint8 Player::GetNpcBotsCount() const
+{
+    uint8 bots = 0;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_entry != 0)
+            ++bots;
+    return bots;
+}
+
+uint8 Player::GetMaxNpcBots() const
+{
+    return (GetSession()->GetSecurity() == SEC_PLAYER) ?  m_maxNpcBots : MAX_NPCBOTS;
+}
+
+bool Player::HaveBot() const
+{
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_entry != 0)
+            return true;
+    return false;
+}
+
+void Player::SendBotCommandState(Creature* cre, CommandStates state)
+{
+    if (!cre) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_creature == cre)
+            cre->SetBotCommandState(state, true);
+}
+//finds bot's slot into master's botmap
+uint8 Player::GetNpcBotSlot(uint64 guid) const
+{
+    if (guid)
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            if (m_botmap[i]->m_guid == guid)
+                return i;
+    return 0;
+}
+
+void Player::SetBotTank(uint64 guid)
+{
+    m_botTankGuid = guid;
+    if (guid == 0 || !IS_CREATURE_GUID(guid)) //reset tank or set player - remove from all npcbots
+    {
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        {
+            if (m_botmap[i]->tank == true)
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_TANK);
+                stmt->setUInt8(0, uint8(0));
+                stmt->setUInt32(1, GetGUIDLow());
+                stmt->setUInt32(2, m_botmap[i]->m_entry);
+                CharacterDatabase.Execute(stmt);
+                //CharacterDatabase.PExecute("UPDATE `character_npcbot` SET `istank` = '0' WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_botmap[i]->m_entry);
+                m_botmap[i]->tank = false;
+            }
+        }
+        return;
+    }
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i]->tank == true)
+        {
+            if (m_botmap[i]->m_guid != guid)
+            {
+                m_botmap[i]->tank = false;
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_TANK);
+                stmt->setUInt8(0, uint8(0));
+                stmt->setUInt32(1, GetGUIDLow());
+                stmt->setUInt32(2, m_botmap[i]->m_entry);
+                CharacterDatabase.Execute(stmt);
+                //CharacterDatabase.PExecute("UPDATE `character_npcbot` SET `istank` = '0' WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_botmap[i]->m_entry);
+            }
+        }
+        else if (m_botmap[i]->m_guid == guid)
+        {
+            m_botmap[i]->tank = true;
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_TANK);
+            stmt->setUInt8(0, uint8(1));
+            stmt->setUInt32(1, GetGUIDLow());
+            stmt->setUInt32(2, m_botmap[i]->m_entry);
+            CharacterDatabase.Execute(stmt);
+            //CharacterDatabase.PExecute("UPDATE `character_npcbot` SET `istank` = '1' WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_botmap[i]->m_entry);
+            break;
+        }
+    }
+}
+
+Unit* Player::GetBotTank(uint32 entry)
+{
+    if (!entry) return NULL;
+
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_entry == entry && m_botmap[i]->tank == true)
+            return m_botmap[i]->m_creature;
+
+    return NULL;
+}
+
+void Player::SetNpcBotDied(uint64 guid)
+{
+    if (!guid) return;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_guid == guid)
+        {
+            m_botmap[pos]->m_reviveTimer = 15000;
+            break;
+        }
+}
+
+bool Player::RestrictBots() const
+{
+    return
+        (!m_enableNpcBotsBGs && GetMap()->IsBattleground()) ||
+        (!m_enableNpcBotsArenas && GetMap()->IsBattleArena()) ||
+        (!m_enableNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) ||
+        (!m_enableNpcBotsRaids && GetMap()->IsRaid());
+}
+
+uint32 Player::GetNpcBotCost() const
+{
+    return m_NpcBotsCost ? uint32((m_NpcBotsCost / 80.f) * getLevel()) : 0;
+}
+
+std::string Player::GetNpcBotCostStr() const
+{
+    std::ostringstream money;
+
+    if (uint32 cost = GetNpcBotCost())
+    {
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold != 0)
+            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver != 0)
+            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+    }
+    return money.str();
+}
+
+//NPCbot base setup
+void Player::CreateNPCBot(uint8 bot_class)
+{
+    //check if we have too many bots of that class
+    if (HaveBot())
+    {
+        uint8 count = 0;
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            if (m_botmap[i]->m_class == bot_class)
+                ++count;
+        if (count >= m_maxClassNpcBots)
+        {
+            //SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+            ChatHandler ch(GetSession());
+            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, m_maxClassNpcBots);
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+
+    //check if not allowed class is chosen
+    if (!m_enableAllNpcBots &&
+        (bot_class != CLASS_WARRIOR &&
+        bot_class != CLASS_PALADIN &&
+        bot_class != CLASS_PRIEST &&
+        bot_class != CLASS_MAGE &&
+        bot_class != CLASS_DRUID &&
+        bot_class != CLASS_WARLOCK &&
+        bot_class != CLASS_ROGUE))
+    {
+        ChatHandler ch(GetSession());
+        const char* bclass;
+        switch (bot_class)
+        {
+            case CLASS_DEATH_KNIGHT:    bclass = "DeathKnight"; break;
+            case CLASS_SHAMAN:          bclass = "Shaman"; break;
+            case CLASS_HUNTER:          bclass = "Hunter"; break;
+            default:                    bclass = "Unknown Class"; break;
+        }
+        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::CreateNPCBot(): Character %u tried to create npcbot of class %s, which is not allowed on your server!", GetGUIDLow(), bclass);
+        ch.PSendSysMessage("You've tried to create npcbot of class %s, which is not allowed on this server!", bclass);
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    //check if player cannot afford a bot
+    uint32 cost = GetNpcBotCost();
+    if (GetMoney() < cost)
+    {
+        ChatHandler ch(GetSession());
+        std::string str = "You don't have enough money (";
+        str += GetNpcBotCostStr();
+        str += ")!";
+        ch.SendSysMessage(str.c_str());
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_TEMPLATE);
+    std::ostringstream classStr;
+
+    switch (bot_class)
+    {
+        case CLASS_ROGUE:
+            classStr << "rogue_bot";    break;
+        case CLASS_PRIEST:
+            classStr << "priest_bot";   break;
+        case CLASS_DRUID:
+            classStr << "druid_bot";    break;
+        case CLASS_SHAMAN:
+            classStr << "shaman_bot";   break;
+        case CLASS_MAGE:
+            classStr << "mage_bot";     break;
+        case CLASS_WARLOCK:
+            classStr << "warlock_bot";  break;
+        case CLASS_WARRIOR:
+            classStr << "warrior_bot";  break;
+        case CLASS_PALADIN:
+            classStr << "paladin_bot";  break;
+        case CLASS_HUNTER:
+            classStr << "hunter_bot";   break;
+        //case CLASS_DEATH_KNIGHT:
+        //    classStr << "dk_bot";       break;
+        default:
+            ChatHandler ch(GetSession());
+            ch.PSendSysMessage("ERROR! unknown bot_class %u", bot_class);
+            ch.SetSentErrorMessage(true);
+            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::CreateNPCBot() player %u(%s) tried to create bot of unknown/unsupported class %u!", GetGUIDLow(), GetName().c_str(), bot_class);
+            return;
+    }
+
+    stmt->setString(0, classStr.str());
+    stmt->setUInt8(1, bot_class);
+
+    //maybe we should remove this check? ;Ü
+    switch (getRace())
+    {
+        case RACE_NONE:
+        case RACE_HUMAN:
+        case RACE_DWARF:
+        case RACE_NIGHTELF:
+        case RACE_GNOME:
+        case RACE_DRAENEI:
+            stmt->setUInt8(2, uint8(1));
+            stmt->setUInt8(3, uint8(3));
+            stmt->setUInt8(4, uint8(4));
+            stmt->setUInt8(5, uint8(7));
+            stmt->setUInt8(6, uint8(11));
+            break;
+
+        case RACE_ORC:
+        case RACE_UNDEAD_PLAYER:
+        case RACE_TAUREN:
+        case RACE_TROLL:
+        case RACE_BLOODELF:
+            stmt->setUInt8(2, uint8(2));
+            stmt->setUInt8(3, uint8(5));
+            stmt->setUInt8(4, uint8(6));
+            stmt->setUInt8(5, uint8(8));
+            stmt->setUInt8(6, uint8(10));
+            break;
+    }
+
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    if (!result)
+    {
+        TC_LOG_FATAL(LOG_FILTER_PLAYER, "Player::CreateNPCBot() CANNOT create bot of class %u, not found in DB", bot_class);
+        return;
+    }
+
+    uint32 entry = 0;
+    uint32 bot_race = 0;
+
+    //find a bot to add
+    //first check randomly selected bot, second check any bot we can add
+    typedef std::list< std::pair<uint32, uint8> > NpcBotsDataTemplate;
+    NpcBotsDataTemplate npcBotsData;
+    do
+    {
+        Field* fields = result->Fetch();
+        uint32 temp_entry = fields[0].GetUInt32();
+        uint8 temp_race = fields[1].GetUInt8();
+        npcBotsData.push_back(std::pair<uint32, uint8>(temp_entry, temp_race));
+    } while (result->NextRow());
+
+    uint32 m_rand = urand(1, uint32(result->GetRowCount()));
+    uint32 tmp_rand = 1;
+    std::list< std::pair<uint32, uint8> >::const_iterator itr = npcBotsData.begin();
+    bool haveSameBot = false;
+    bool moveback = false;
+    bool forcedCheck = false;
+    bool secondCheck = false;
+    while (true)
+    {
+        if (itr == npcBotsData.end()) //end of list is reached (selected bot is checked)
+        {
+            moveback = true;
+            --itr; //tmp_rand is not needed anymore
+            continue;
+        }
+        if (moveback && itr == npcBotsData.begin()) //search is finished, nothing found
+            break;
+        if (tmp_rand == m_rand || haveSameBot)
+        {
+            bool canAdd = true;
+            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            {
+                if (m_botmap[i]->m_entry == itr->first)
+                {
+                    haveSameBot = true;
+                    canAdd = false;
+                    if (!secondCheck)
+                        forcedCheck = true;
+                    secondCheck = true;
+                    break;
+                }
+            }
+            if (canAdd)
+            {
+                entry = itr->first;
+                bot_race = itr->second;
+                break;
+            }
+            if (forcedCheck)
+            {
+                itr = npcBotsData.begin(); //reset searcher pos
+                forcedCheck = false;
+                continue;
+            }
+        }
+        //move through
+        if (moveback)
+            --itr;
+        else
+        {
+            ++itr;
+            ++tmp_rand;
+        }
+    }
+
+    if (!entry || !bot_race)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("No more bots of this class available");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    SetBotMustBeCreated(entry, bot_race, bot_class);
+
+    if (cost)
+        ModifyMoney(-(int32(cost)));
+}
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2936,6 +3762,26 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
+        if (Player* player = ObjectAccessor::FindPlayer(guid))
+        {
+            if (player->HaveBot())
+            {
+                uint8 players = 0;
+                Group::MemberSlotList const& members = group->GetMemberSlots();
+                for (Group::member_citerator itr = members.begin(); itr!= members.end(); ++itr)
+                {
+                    if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
+                        ++players;
+                }
+
+                //remove npcbots so group will be disbanded if only 1 player
+                for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                    player->RemoveBot(player->GetBotMap(i)->m_guid, players <= 1);
+                group = player->GetGroup();
+                if (!group)
+                    return; //group has been disbanded
+            }
+        }
         group->RemoveMember(guid, method, kicker, reason);
         group = NULL;
     }
@@ -4988,6 +5834,13 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
 
+            //npcbot - erase npcbots
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOTS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+            //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u'", guid);
+            //end npcbot
+
             CharacterDatabase.CommitTransaction(trans);
             break;
         }
@@ -6890,7 +7743,8 @@ void Player::CheckAreaExploreAndOutdoor()
                 {
                     XP = uint32(sObjectMgr->GetBaseXP(areaEntry->area_level)*sWorld->getRate(RATE_XP_EXPLORE));
                 }
-
+                if(GetSession()->IsPremium())
+                XP *= sWorld->getRate(RATE_XP_EXPLORE_PREMIUM);
                 GiveXP(XP, NULL);
                 SendExplorationExperience(area, XP);
             }
@@ -15236,6 +16090,9 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
         AddPct(XP, (*i)->GetAmount());
 
     int32 moneyRew = 0;
+    if (GetSession()->IsPremium())
+        XP *= sWorld->getRate(RATE_XP_QUEST_PREMIUM);
+
     if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
         GiveXP(XP, NULL);
     else
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 6cc8c0c..a2cc254 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -52,6 +52,11 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+// NpcBot mod
+struct NpcBotMap;
+#define MAX_NPCBOTS 40
+class BotHelper;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2294,6 +2299,39 @@ class Player : public Unit, public GridObject<Player>
         std::string GetMapAreaAndZoneString();
         std::string GetCoordsMapAreaAndZoneString();
 
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        void SetBotHelper(BotHelper* hlpr) { ASSERT (!_botHlpr); _botHlpr = hlpr; }
+        BotHelper* GetBotHelper() const { return _botHlpr; }
+        void RefreshBot(uint32 p_time);
+        void CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool istank = false, bool revive = false);
+        void CreateNPCBot(uint8 botclass);
+        uint8 GetNpcBotSlot(uint64 guid) const;
+        void SendBotCommandState(Creature* cre, CommandStates state);
+        bool HaveBot() const;
+        void RemoveBot(uint64 guid, bool final = false, bool eraseFromDB = true);
+        void SetBot(Creature* cre) { m_bot = cre; }
+        uint8 GetNpcBotsCount() const;
+        void SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, bool istank = false);
+        void ClearBotMustBeCreated(uint64 value, bool guid = true, bool fully = false);
+        bool GetBotMustBeCreated();
+        uint64 GetBotTankGuid() const { return m_botTankGuid; }
+        void SetBotTank(uint64 guid);
+        Unit* GetBotTank(uint32 entry);
+        uint8 GetBotFollowDist() const { return m_followdist; }
+        void SetBotFollowDist(int8 dist) { m_followdist = dist; }
+        void SetNpcBotDied(uint64 guid);
+        NpcBotMap const* GetBotMap(uint8 pos) const { return m_botmap[pos]; }
+        uint8 GetMaxNpcBots() const;
+        uint8 GetNpcBotXpReduction() const { return m_xpReductionNpcBots; }
+        bool RestrictBots() const;
+        uint32 GetNpcBotCost() const;
+        std::string GetNpcBotCostStr() const;
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         WhisperListContainer WhisperList;
@@ -2556,6 +2594,31 @@ class Player : public Unit, public GridObject<Player>
         uint8 m_grantableLevels;
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        BotHelper* _botHlpr;
+        Creature* m_bot;
+        int8 m_followdist;
+        uint64 m_botTankGuid;
+        uint8 m_maxNpcBots;
+        uint8 m_maxClassNpcBots;
+        uint8 m_xpReductionNpcBots;
+        bool m_enableNpcBots;
+        bool m_enableAllNpcBots;
+        bool m_enableNpcBotsArenas;
+        bool m_enableNpcBotsBGs;
+        bool m_enableNpcBotsDungeons;
+        bool m_enableNpcBotsRaids;
+        bool m_limitNpcBotsDungeons;
+        bool m_limitNpcBotsRaids;
+        uint32 m_NpcBotsCost;
+        uint32 m_botTimer;
+        NpcBotMap* m_botmap[MAX_NPCBOTS];
+        /*********************************************************/
+        /***                END BOT SYSTEM                     ***/
+        /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index e6cc30c..8fc1452 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -181,6 +181,10 @@ bool Player::UpdateAllStats()
     for (int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; ++i)
         UpdateResistances(i);
 
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (Creature* bot = GetBotMap(i)->_Cre())
+            bot->SetBotShouldUpdateStats();
+
     return true;
 }
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 57a920a..f4d1fe2 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -345,6 +345,17 @@ void Unit::Update(uint32 p_time)
                 m_CombatTimer -= p_time;
         }
     }
+    // update combat timer also for npcbots
+    if (IsInCombat() && GetTypeId() == TYPEID_UNIT && !GetVictim() && (ToCreature()->GetIAmABot() || ToCreature()->GetIAmABotsPet()))
+    {
+        if (m_HostileRefManager.isEmpty())
+        {
+            if (m_CombatTimer <= p_time)
+                ClearInCombat();
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
 
     // not implemented before 3.0.2
     if (uint32 base_att = getAttackTimer(BASE_ATTACK))
@@ -576,6 +587,12 @@ uint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDam
         if (pet && pet->IsAlive())
             pet->AI()->OwnerAttackedBy(this);
 
+        // NpcBot mod: also signal owned npcbots
+        for (ControlList::const_iterator itr = victim->ToPlayer()->m_Controlled.begin(); itr != victim->ToPlayer()->m_Controlled.end(); ++itr)
+            if (Creature* cre = (*itr)->ToCreature())
+                if (cre->GetIAmABot() && cre->IsAIEnabled)
+                    cre->AI()->OwnerAttackedBy(this);
+
         if (victim->ToPlayer()->GetCommandStatus(CHEAT_GOD))
             return 0;
     }
@@ -988,6 +1005,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_RANGED:
         case SPELL_DAMAGE_CLASS_MELEE:
         {
+            //Npcbot mod: apply bot damage mods
+            if (Creature* bot = ToCreature())
+                if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                    bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+
             // Physical Damage
             if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
             {
@@ -1045,6 +1067,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_NONE:
         case SPELL_DAMAGE_CLASS_MAGIC:
         {
+            //Npcbot mod: apply bot damage mods
+            if (Creature* bot = ToCreature())
+                if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                    bot->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+
             // If crit add critical bonus
             if (crit)
             {
@@ -1161,6 +1188,11 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     // Script Hook For CalculateMeleeDamage -- Allow scripts to change the Damage pre class mitigation calculations
     sScriptMgr->ModifyMeleeDamage(damageInfo->target, damageInfo->attacker, damage);
 
+    //Npcbot mod: apply bot damage mods
+    if (Creature* bot = ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo);
+
     // Calculate armor reduction
     if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))
     {
@@ -10430,6 +10462,7 @@ bool Unit::isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMas
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
     if (IS_CREATURE_GUID(GetGUID()) && !(IsTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438)
+        if (!ToCreature()->GetIAmABot())
         return false;
 
     // not critting spell
@@ -13130,6 +13163,11 @@ bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, f
             break;
     }
 
+    if (Player* master = ToPlayer())
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            if (Creature* bot = master->GetBotMap(i)->_Cre())
+                bot->SetBotShouldUpdateStats();
+
     return true;
 }
 
@@ -16554,6 +16592,182 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form) const
                 break;
         }
     }
+    else if (ToCreature() && ToCreature()->GetIAmABot())
+    {
+        Player const *player = ToCreature()->GetBotOwner();
+        //let's make druids alike for each player
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on master's Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                // Based on master's Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male master
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female master
+                    else switch (skinColor)
+                    {
+                        case 10: // White
+                            return 29409;
+                        case 6: // Light Brown
+                        case 7:
+                            return 29410;
+                        case 4: // Brown
+                        case 5:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_DIREBEAR:
+            case FORM_BEAR:
+                // Based on Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                // Based on Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                            return 29418;
+                        case 2: // White
+                        case 3:
+                            return 29419;
+                        case 6: // Light Brown/Grey
+                        case 7:
+                        case 8:
+                        case 9:
+                            return 29420;
+                        case 10: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_FLIGHT:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 20857;
+                return 20872;
+            case FORM_FLIGHT_EPIC:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 21243;
+                return 21244;
+            default:
+                break;
+        }
+    }
 
     uint32 modelid = 0;
     SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index f43e49a..5eb199f 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -110,6 +110,9 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+        m_lootMethod = FREE_FOR_ALL;
+    else
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -365,6 +368,8 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
     player->SetGroupInvite(NULL);
     if (player->GetGroup())
     {
@@ -380,6 +385,7 @@ bool Group::AddMember(Player* player)
     InstanceGroupBind* bind = GetBoundInstance(player);
     if (bind && bind->save->GetInstanceId() == player->GetInstanceId())
         player->m_InstanceValid = true;
+    }
 
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
@@ -405,6 +411,8 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -480,6 +488,7 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    }
 
     return true;
 }
@@ -603,6 +612,9 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod& method /*= GROUP_REMOV
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot
+        if (GetMembersCount() < ((isBGGroup() || isLFGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index 356a1a5..190a855 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -307,6 +307,9 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //Bot
+        uint64 const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(uint64 guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/AuctionHouseHandler.cpp b/src/server/game/Handlers/AuctionHouseHandler.cpp
index d193852..36de446 100644
--- a/src/server/game/Handlers/AuctionHouseHandler.cpp
+++ b/src/server/game/Handlers/AuctionHouseHandler.cpp
@@ -22,6 +22,7 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+#include "AuctionHouseBot.h"
 #include "AuctionHouseMgr.h"
 #include "Log.h"
 #include "Language.h"
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 0554820..dc57efe 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -48,6 +48,9 @@
 #include "WorldSession.h"
 
 
+//bot
+#include "Config.h"
+
 class LoginQueryHolder : public SQLQueryHolder
 {
     private:
@@ -1022,6 +1025,28 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
 
     m_playerLoading = false;
 
+    //the only place where we check if it has NPC bots
+    if (sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true))
+    {
+        if (QueryResult result = CharacterDatabase.PQuery("SELECT entry,race,class,istank FROM `character_npcbot` WHERE `owner` = '%u'", pCurrChar->GetGUIDLow()))
+        {
+            uint32 m_bot_entry = 0;
+            uint8 m_bot_race = 0;
+            uint8 m_bot_class = 0;
+            uint8 Tank = 0;
+            do
+            {
+                Field* fields = result->Fetch();
+                m_bot_entry = fields[0].GetUInt32();
+                m_bot_race = fields[1].GetUInt8();
+                m_bot_class = fields[2].GetInt8();
+                Tank = fields[3].GetInt8();
+                if (m_bot_entry && m_bot_race && m_bot_class)
+                    pCurrChar->SetBotMustBeCreated(m_bot_entry, m_bot_race, m_bot_class, bool(Tank));
+            } while (result->NextRow());
+        }
+    }
+
     sScriptMgr->OnPlayerLogin(pCurrChar);
     delete holder;
 }
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index e8d781a..3fb87c2 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -56,6 +56,9 @@
 #include "Battlefield.h"
 #include "BattlefieldMgr.h"
 
+//Bot
+#include "bothelper.h"
+
 void WorldSession::HandleRepopRequestOpcode(WorldPacket& recvData)
 {
     TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_REPOP_REQUEST Message");
@@ -111,6 +114,16 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             return;
         }
     }
+    //Bot
+    else if (IS_PLAYER_GUID(guid))
+    {
+        if (guid != _player->GetGUID())
+        {
+            TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) not found.", uint32(GUID_LOPART(guid)));
+            return;
+        }
+    }
+    //end Bot
     else if (IS_GAMEOBJECT_GUID(guid))
     {
         go = _player->GetMap()->GetGameObject(guid);
@@ -148,6 +161,17 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             if (!sScriptMgr->OnGossipSelectCode(_player, unit, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str()))
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
+        //Bot
+        else if (guid == _player->GetGUID())
+        {
+            if (!_player->GetBotHelper())
+            {
+                TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip select.", uint32(GUID_LOPART(guid)));
+                return;
+            }
+            //_player->GetBotHelper()->OnCodedGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str());
+        }
+        //end Bot
         else
         {
             go->AI()->GossipSelectCode(_player, menuId, gossipListId, code.c_str());
@@ -162,6 +186,17 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             if (!sScriptMgr->OnGossipSelect(_player, unit, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId)))
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
+        //Bot
+        else if (guid == _player->GetGUID())
+        {
+            if (!_player->GetBotHelper())
+            {
+                TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip select.", uint32(GUID_LOPART(guid)));
+                return;
+            }
+            _player->GetBotHelper()->OnGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId));
+        }
+        //end Bot
         else
         {
             go->AI()->GossipSelect(_player, menuId, gossipListId);
diff --git a/src/server/game/Handlers/NPCHandler.cpp b/src/server/game/Handlers/NPCHandler.cpp
index e3921ee..defc147 100644
--- a/src/server/game/Handlers/NPCHandler.cpp
+++ b/src/server/game/Handlers/NPCHandler.cpp
@@ -38,6 +38,9 @@
 #include "CreatureAI.h"
 #include "SpellInfo.h"
 
+//Bot
+#include "bothelper.h"
+
 enum StableResultCode
 {
     STABLE_ERR_MONEY        = 0x01,                         // "you don't have enough money"
@@ -295,6 +298,19 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket& recvData)
     uint64 guid;
     recvData >> guid;
 
+    //Bot
+    if (guid == _player->GetGUID())
+    {
+        if (!_player->GetBotHelper())
+        {
+            TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip hello.", uint32(GUID_LOPART(guid)));
+            return;
+        }
+        _player->GetBotHelper()->OnGossipHello(_player);
+        return;
+    }
+    //end Bot
+
     Creature* unit = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
     if (!unit)
     {
diff --git a/src/server/game/Mails/Mail.cpp b/src/server/game/Mails/Mail.cpp
index 2fa0a03..5cb8a17 100644
--- a/src/server/game/Mails/Mail.cpp
+++ b/src/server/game/Mails/Mail.cpp
@@ -27,6 +27,7 @@
 #include "Item.h"
 #include "AuctionHouseMgr.h"
 #include "CalendarMgr.h"
+#include "AuctionHouseBot.h"
 
 MailSender::MailSender(Object* sender, MailStationery stationery) : m_stationery(stationery)
 {
@@ -184,6 +185,13 @@ void MailDraft::SendMailTo(SQLTransaction& trans, MailReceiver const& receiver,
 
     uint32 mailId = sObjectMgr->GenerateMailID();
 
+    if (receiver.GetPlayerGUIDLow() == auctionbot.GetAHBplayerGUID())
+    {
+        if (sender.GetMailMessageType() == MAIL_AUCTION)        // auction mail with items
+            deleteIncludedItems(trans, true);
+        return;
+    }
+
     time_t deliver_time = time(NULL) + deliver_delay;
 
     //expire time if COD 3 days, if no COD 30 days, if auction sale pending 1 hour
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 5ce4c05..5d82d33 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -2182,7 +2182,10 @@ uint32 Map::GetPlayersCountExceptGMs() const
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
         if (!itr->GetSource()->IsGameMaster())
+        {
             ++count;
+            count += itr->GetSource()->GetNpcBotsCount();
+        }
     return count;
 }
 
diff --git a/src/server/game/Miscellaneous/Formulas.h b/src/server/game/Miscellaneous/Formulas.h
index f779e3d..02e7222 100644
--- a/src/server/game/Miscellaneous/Formulas.h
+++ b/src/server/game/Miscellaneous/Formulas.h
@@ -179,8 +179,8 @@ namespace Trinity
                     else
                         gain *= 2;
                 }
-
-                gain = uint32(gain * sWorld->getRate(RATE_XP_KILL));
+                float premium_rate = player->GetSession()->IsPremium() ? sWorld->getRate(RATE_XP_KILL_PREMIUM) : 1.0f;
+                gain = uint32(gain * sWorld->getRate(RATE_XP_KILL)*premium_rate);
             }
 
             sScriptMgr->OnGainCalculation(gain, player, u);
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index ed0972c..b48bb12 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -23,6 +23,12 @@ void AddSC_example_escort();
 void AddSC_example_gossip_codebox();
 void AddSC_example_misc();
 void AddSC_example_commandscript();
+void AddSC_summon();
+void AddSC_levelnpc();
+void AddSC_npc_changer();
+
+//TeleNPC2
+void AddSC_npc_teleport();
 
 // spells
 void AddSC_deathknight_spell_scripts();
@@ -46,6 +52,7 @@ void AddSC_SmartSCripts();
 //Commands
 void AddSC_account_commandscript();
 void AddSC_achievement_commandscript();
+void AddSC_ah_bot_commandscript();
 void AddSC_arena_commandscript();
 void AddSC_ban_commandscript();
 void AddSC_bf_commandscript();
@@ -700,6 +707,7 @@ void AddCommandScripts()
 {
     AddSC_account_commandscript();
     AddSC_achievement_commandscript();
+    AddSC_ah_bot_commandscript();
     AddSC_arena_commandscript();
     AddSC_ban_commandscript();
     AddSC_bf_commandscript();
@@ -1336,6 +1344,17 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
+//Bots
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_script_bot_commands();
 
 #endif
 
@@ -1343,6 +1362,24 @@ void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
-
+    // TeleNPC2
+    AddSC_npc_teleport();
+    // Item Summon
+    AddSC_summon();
+    // Level NPC
+    AddSC_levelnpc();
+    // Changer NPC
+    void AddSC_npc_changer();
+    // Bots
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_script_bot_commands();
 #endif
 }
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index 0dc96b3..49f654c 100644
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -23,6 +23,7 @@
 #include "ObjectMgr.h"
 #include "OutdoorPvPMgr.h"
 #include "ScriptLoader.h"
+#include "sc_npc_teleport.h"
 #include "ScriptSystem.h"
 #include "Transport.h"
 #include "Vehicle.h"
@@ -176,6 +177,8 @@ void ScriptMgr::Initialize()
     uint32 oldMSTime = getMSTime();
 
     LoadDatabase();
+       // Load TeleNPC2 - maybe not the best place to load it ...
+       LoadNpcTele();
 
     TC_LOG_INFO(LOG_FILTER_SERVER_LOADING, "Loading C++ scripts");
 
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 5519f1d..88d9555 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -96,12 +96,13 @@ bool WorldSessionFilter::Process(WorldPacket* packet)
 }
 
 /// WorldSession constructor
-WorldSession::WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter):
+WorldSession::WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, bool ispremium, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter):
     m_muteTime(mute_time),
     m_timeOutTime(0),
     _player(NULL),
     m_Socket(sock),
     _security(sec),
+    _ispremium(ispremium),
     _accountId(id),
     m_expansion(expansion),
     _warden(NULL),
@@ -411,6 +412,20 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool save)
 {
+    uint8 nBotCount = 0;
+    if (_player)
+    {
+        //remove npcbots but do not delete from DB so they can be reacqured on next login
+        for (uint8 i = 0; i != _player->GetMaxNpcBots(); ++i)
+        {
+            if (_player->GetBotMap(i)->_Guid())
+            {
+                _player->RemoveBot(_player->GetBotMap(i)->_Guid(), true, false);
+                ++nBotCount;
+            }
+        }
+    }
+
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -504,6 +519,9 @@ void WorldSession::LogoutPlayer(bool save)
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
         if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+            //bot d) if has no NpcBots or not in instance (trying to save instance)
+            if (nBotCount == 0 || !_player->GetMap()->Instanceable())
+            //end bot
             _player->RemoveFromGroup();
 
         //! Send update to group and reset stored max enchanting level
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index bf79b34..b821bbd 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -187,11 +187,30 @@ class CharacterCreateInfo
         uint8 CharCount;
 };
 
+//npcbot
+struct NpcBotMap
+{
+    friend class Player;
+    protected:
+        NpcBotMap() : m_guid(0), m_entry(0), m_race(0), m_class(0), m_creature(NULL), m_reviveTimer(0), tank(false) {}
+        uint64 m_guid;
+        uint32 m_entry;
+        uint8  m_race;
+        uint8  m_class;
+        Creature* m_creature;
+        uint32 m_reviveTimer;
+        bool tank;
+    public:
+        uint64 _Guid() const { return m_guid; }
+        Creature* _Cre() const { return m_creature; }
+};
+//end bot mods
+
 /// Player session in the World
 class WorldSession
 {
     public:
-        WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter);
+        WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, bool ispremium, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter);
         ~WorldSession();
 
         bool PlayerLoading() const { return m_playerLoading; }
@@ -223,6 +242,7 @@ class WorldSession
         void InvalidateRBACData(); // Used to force LoadPermissions at next HasPermission check
 
         AccountTypes GetSecurity() const { return _security; }
+        bool IsPremium() const { return _ispremium; }
         uint32 GetAccountId() const { return _accountId; }
         Player* GetPlayer() const { return _player; }
         std::string const& GetPlayerName() const;
@@ -937,6 +957,7 @@ class WorldSession
         AccountTypes _security;
         uint32 _accountId;
         uint8 m_expansion;
+        bool _ispremium;
 
         typedef std::list<AddonInfo> AddonsList;
 
diff --git a/src/server/game/Server/WorldSocket.cpp b/src/server/game/Server/WorldSocket.cpp
index 625ebff..7333457 100644
--- a/src/server/game/Server/WorldSocket.cpp
+++ b/src/server/game/Server/WorldSocket.cpp
@@ -746,6 +746,7 @@ int WorldSocket::HandleAuthSession(WorldPacket& recvPacket)
     uint32 id;
     LocaleConstant locale;
     std::string account;
+    bool isPremium = false;
     SHA1Hash sha;
     uint32 clientBuild;
     uint32 unk2, unk3, unk5, unk6, unk7;
@@ -876,6 +877,16 @@ int WorldSocket::HandleAuthSession(WorldPacket& recvPacket)
         return -1;
     }
 
+    QueryResult premresult =
+        LoginDatabase.PQuery ("SELECT 1 "
+                                "FROM account_premium "
+                                "WHERE id = '%u' "
+                                "AND active = 1",
+                                id);
+    if (premresult) // if account premium
+    {
+        isPremium = true;
+    }
     // Check locked state for server
     AccountTypes allowedAccountType = sWorld->GetPlayerSecurityLimit();
     TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "Allowed Level: %u Player Level %u", allowedAccountType, AccountTypes(security));
@@ -931,7 +942,7 @@ int WorldSocket::HandleAuthSession(WorldPacket& recvPacket)
     LoginDatabase.Execute(stmt);
 
     // NOTE ATM the socket is single-threaded, have this in mind ...
-    ACE_NEW_RETURN(m_Session, WorldSession(id, this, AccountTypes(security), expansion, mutetime, locale, recruiter, isRecruiter), -1);
+    ACE_NEW_RETURN(m_Session, WorldSession(id, this, AccountTypes(security), isPremium, expansion, mutetime, locale, recruiter, isRecruiter), -1);
 
     m_Crypt.Init(&k);
 
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 410fbee..2ed5db6 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -73,6 +73,7 @@
 #include "CharacterDatabaseCleaner.h"
 #include "ScriptMgr.h"
 #include "WeatherMgr.h"
+#include "AuctionHouseBot.h"
 #include "CreatureTextMgr.h"
 #include "SmartAI.h"
 #include "Channel.h"
@@ -1792,6 +1793,9 @@ void World::SetInitialWorldSettings()
 
     LoadCharacterNameData();
 
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Initialize AuctionHouseBot...");
+    auctionbot.Initialize();
+
     uint32 startupDuration = GetMSTimeDiffToNow(startupBegin);
 
     TC_LOG_INFO(LOG_FILTER_WORLDSERVER, "World initialized in %u minutes %u seconds", (startupDuration / 60000), ((startupDuration % 60000) / 1000));
@@ -1959,6 +1963,7 @@ void World::Update(uint32 diff)
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
+        auctionbot.Update();
         m_timers[WUPDATE_AUCTIONS].Reset();
 
         ///- Update mails (return old mails with item, or delete them)
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 12586ed..2ce4245 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -352,8 +352,11 @@ enum Rates
     RATE_DROP_ITEM_REFERENCED_AMOUNT,
     RATE_DROP_MONEY,
     RATE_XP_KILL,
+    RATE_XP_KILL_PREMIUM,
     RATE_XP_QUEST,
+    RATE_XP_QUEST_PREMIUM,
     RATE_XP_EXPLORE,
+    RATE_XP_EXPLORE_PREMIUM,
     RATE_REPAIRCOST,
     RATE_REPUTATION_GAIN,
     RATE_REPUTATION_LOWLEVEL_KILL,
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index 5be634d..a881e3f 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -24,6 +24,9 @@ include(Examples/CMakeLists.txt)
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.h
   ../game/AI/ScriptedAI/ScriptedEscortAI.cpp
   ../game/AI/ScriptedAI/ScriptedCreature.cpp
   ../game/AI/ScriptedAI/ScriptedFollowerAI.cpp
@@ -77,6 +80,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse/AuctionHouseBot
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
diff --git a/src/server/scripts/Commands/CMakeLists.txt b/src/server/scripts/Commands/CMakeLists.txt
index ce31fa1..b1ff5b2 100644
--- a/src/server/scripts/Commands/CMakeLists.txt
+++ b/src/server/scripts/Commands/CMakeLists.txt
@@ -12,6 +12,7 @@ set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   Commands/cs_account.cpp
   Commands/cs_achievement.cpp
+  Commands/cs_ah_bot.cpp
   Commands/cs_arena.cpp
   Commands/cs_ban.cpp
   Commands/cs_bf.cpp
diff --git a/src/server/scripts/Commands/cs_ah_bot.cpp b/src/server/scripts/Commands/cs_ah_bot.cpp
new file mode 100644
index 0000000..3092cd3
--- /dev/null
+++ b/src/server/scripts/Commands/cs_ah_bot.cpp
@@ -0,0 +1,482 @@
+/*
+ * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* ScriptData
+Name: ah_bot_commandscript
+%Complete: 100
+Comment: All ah_bot related commands
+Category: commandscripts
+EndScriptData */
+
+#include "ScriptMgr.h"
+#include "Chat.h"
+#include "AuctionHouseBot.h"
+
+class ah_bot_commandscript : public CommandScript
+{
+public:
+    ah_bot_commandscript() : CommandScript("ah_bot_commandscript") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand commandTable[] =
+        {
+            { "ahbotoptions",   SEC_GAMEMASTER,     true,   &HandleAHBotOptionsCommand,     "", NULL },
+            { NULL,             0,                  false,  NULL,                           "", NULL }
+        };
+        return commandTable;
+    }
+
+    static bool HandleAHBotOptionsCommand(ChatHandler* handler, const char*args)
+    {
+        uint32 ahMapID = 0;
+        char* opt = strtok((char*)args, " ");
+        char* ahMapIdStr = strtok(NULL, " ");
+
+        if (ahMapIdStr)
+        {
+            ahMapID = uint32(strtoul(ahMapIdStr, NULL, 0));
+            switch (ahMapID)
+            {
+                case 2:
+                case 6:
+                case 7:
+                    break;
+                default:
+                    opt = NULL;
+                    break;
+            }
+        }
+
+        if (!opt)
+        {
+            handler->PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+            handler->PSendSysMessage("Try ahbotoptions help to see a list of options.");
+            return false;
+        }
+
+        int l = strlen(opt);
+
+        if (strncmp(opt, "help", l) == 0)
+        {
+            handler->PSendSysMessage("AHBot commands:");
+            handler->PSendSysMessage("ahexpire");
+            handler->PSendSysMessage("minitems");
+            handler->PSendSysMessage("maxitems");
+            //handler->PSendSysMessage("");
+            //handler->PSendSysMessage("");
+            handler->PSendSysMessage("percentages");
+            handler->PSendSysMessage("minprice");
+            handler->PSendSysMessage("maxprice");
+            handler->PSendSysMessage("minbidprice");
+            handler->PSendSysMessage("maxbidprice");
+            handler->PSendSysMessage("maxstack");
+            handler->PSendSysMessage("buyerprice");
+            handler->PSendSysMessage("bidinterval");
+            handler->PSendSysMessage("bidsperinterval");
+            return true;
+        }
+        else if (strncmp(opt, "ahexpire", l) == 0)
+        {
+            if (!ahMapIdStr)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions ahexpire $ahMapID (2, 6 or 7)");
+                return false;
+            }
+
+            auctionbot.Commands(0, ahMapID, NULL, NULL);
+        }
+        else if (strncmp(opt, "minitems", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            if (!ahMapIdStr || !param1)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions minitems $ahMapID (2, 6 or 7) $minItems");
+                return false;
+            }
+
+            auctionbot.Commands(1, ahMapID, NULL, param1);
+        }
+        else if (strncmp(opt, "maxitems", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            if (!ahMapIdStr || !param1)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxitems $ahMapID (2, 6 or 7) $maxItems");
+                return false;
+            }
+
+            auctionbot.Commands(2, ahMapID, NULL, param1);
+        }
+        else if (strncmp(opt, "mintime", l) == 0)
+        {
+            handler->PSendSysMessage("ahbotoptions mintime has been deprecated");
+            return false;
+            /*
+            char* param1 = strtok(NULL, " ");
+            if (!ahMapIdStr || !param1)
+            {
+                PSendSysMessage("Syntax is: ahbotoptions mintime $ahMapID (2, 6 or 7) $mintime");
+                return false;
+            }
+
+            auctionbot.Commands(3, ahMapID, NULL, param1);
+            */
+        }
+        else if (strncmp(opt, "maxtime", l) == 0)
+        {
+            handler->PSendSysMessage("ahbotoptions maxtime has been deprecated");
+            return false;
+            /*
+            char* param1 = strtok(NULL, " ");
+            if (!ahMapIdStr || !param1)
+            {
+                PSendSysMessage("Syntax is: ahbotoptions maxtime $ahMapID (2, 6 or 7) $maxtime");
+                return false;
+            }
+
+            auctionbot.Commands(4, ahMapID, NULL, param1);
+            */
+        }
+        else if (strncmp(opt, "percentages", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+            char* param3 = strtok(NULL, " ");
+            char* param4 = strtok(NULL, " ");
+            char* param5 = strtok(NULL, " ");
+            char* param6 = strtok(NULL, " ");
+            char* param7 = strtok(NULL, " ");
+            char* param8 = strtok(NULL, " ");
+            char* param9 = strtok(NULL, " ");
+            char* param10 = strtok(NULL, " ");
+            char* param11 = strtok(NULL, " ");
+            char* param12 = strtok(NULL, " ");
+            char* param13 = strtok(NULL, " ");
+            char* param14 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param14)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+                handler->PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+                handler->PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+                handler->PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+                handler->PSendSysMessage("The total must add up to 100%");
+                return false;
+            }
+
+            uint32 greytg = uint32(strtoul(param1, NULL, 0));
+            uint32 whitetg = uint32(strtoul(param2, NULL, 0));
+            uint32 greentg = uint32(strtoul(param3, NULL, 0));
+            uint32 bluetg = uint32(strtoul(param3, NULL, 0));
+            uint32 purpletg = uint32(strtoul(param5, NULL, 0));
+            uint32 orangetg = uint32(strtoul(param6, NULL, 0));
+            uint32 yellowtg = uint32(strtoul(param7, NULL, 0));
+            uint32 greyi = uint32(strtoul(param8, NULL, 0));
+            uint32 whitei = uint32(strtoul(param9, NULL, 0));
+            uint32 greeni = uint32(strtoul(param10, NULL, 0));
+            uint32 bluei = uint32(strtoul(param11, NULL, 0));
+            uint32 purplei = uint32(strtoul(param12, NULL, 0));
+            uint32 orangei = uint32(strtoul(param13, NULL, 0));
+            uint32 yellowi = uint32(strtoul(param14, NULL, 0));
+            uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+
+            if (totalPercent == 0 || totalPercent != 100)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+                handler->PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+                handler->PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+                handler->PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+                handler->PSendSysMessage("The total must add up to 100%");
+                return false;
+            }
+
+            char param[100];
+            param[0] = '\0';
+            strcat(param, param1);
+            strcat(param, " ");
+            strcat(param, param2);
+            strcat(param, " ");
+            strcat(param, param3);
+            strcat(param, " ");
+            strcat(param, param4);
+            strcat(param, " ");
+            strcat(param, param5);
+            strcat(param, " ");
+            strcat(param, param6);
+            strcat(param, " ");
+            strcat(param, param7);
+            strcat(param, " ");
+            strcat(param, param8);
+            strcat(param, " ");
+            strcat(param, param9);
+            strcat(param, " ");
+            strcat(param, param10);
+            strcat(param, " ");
+            strcat(param, param11);
+            strcat(param, " ");
+            strcat(param, param12);
+            strcat(param, " ");
+            strcat(param, param13);
+            strcat(param, " ");
+            strcat(param, param14);
+            auctionbot.Commands(5, ahMapID, NULL, param);
+        }
+        else if (strncmp(opt, "minprice", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+
+            if (strncmp(param1, "grey", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, "orange", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(6, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "maxprice", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+            if (!ahMapIdStr || !param1 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+            if (strncmp(param1, "grey", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, "orange",l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(7, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "minbidprice", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param2 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+
+            uint32 minBidPrice = uint32(strtoul(param2, NULL, 0));
+            if (minBidPrice < 1 || minBidPrice > 100)
+            {
+                handler->PSendSysMessage("The min bid price multiplier must be between 1 and 100");
+                return false;
+            }
+
+            if (strncmp(param1, "grey", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, "orange", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(8, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "maxbidprice", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+
+            uint32 maxBidPrice = uint32(strtoul(param2, NULL, 0));
+            if (maxBidPrice < 1 || maxBidPrice > 100)
+            {
+                handler->PSendSysMessage("The max bid price multiplier must be between 1 and 100");
+                return false;
+            }
+
+            if (strncmp(param1, "grey", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, " orange", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(9, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions max bidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "maxstack",l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+                return false;
+            }
+
+            uint32 maxStack = uint32(strtoul(param2, NULL, 0));
+            if (maxStack < 0)
+            {
+                 handler->PSendSysMessage("maxstack can't be a negative number.");
+                return false;
+            }
+
+            if (strncmp(param1, "grey",l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, "orange", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(10, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "buyerprice", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+            char* param2 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1 || !param2)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+                return false;
+            }
+
+            if (strncmp(param1, "grey", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_GREY, param2);
+            else if (strncmp(param1, "white", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_WHITE, param2);
+            else if (strncmp(param1, "green", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_GREEN, param2);
+            else if (strncmp(param1, "blue", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_BLUE, param2);
+            else if (strncmp(param1, "purple", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_PURPLE, param2);
+            else if (strncmp(param1, "orange", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_ORANGE, param2);
+            else if (strncmp(param1, "yellow", l) == 0)
+                auctionbot.Commands(11, ahMapID, AHB_YELLOW, param2);
+            else
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+                return false;
+            }
+        }
+        else if (strncmp(opt, "bidinterval", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions bidinterval $ahMapID (2, 6 or 7) $interval(in minutes)");
+                return false;
+            }
+
+            auctionbot.Commands(12, ahMapID, NULL, param1);
+        }
+        else if (strncmp(opt, "bidsperinterval", l) == 0)
+        {
+            char* param1 = strtok(NULL, " ");
+
+            if (!ahMapIdStr || !param1)
+            {
+                handler->PSendSysMessage("Syntax is: ahbotoptions bidsperinterval $ahMapID (2, 6 or 7) $bids");
+                return false;
+            }
+
+            auctionbot.Commands(13, ahMapID, NULL, param1);
+        }
+        else
+        {
+            handler->PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+            handler->PSendSysMessage("Try ahbotoptions help to see a list of options.");
+            return false;
+        }
+
+        return true;
+    }
+};
+
+void AddSC_ah_bot_commandscript()
+{
+    new ah_bot_commandscript();
+}
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 99cf026..cc54e3b 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -10,6 +10,9 @@
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/summon.cpp
+  Custom/levelnpc.cpp
+  Custom/changernpc.cpp
 )
 
 message("  -> Prepared: Custom")
diff --git a/src/server/scripts/Custom/changernpc.cpp b/src/server/scripts/Custom/changernpc.cpp
new file mode 100644
index 0000000..f6a47cc
--- /dev/null
+++ b/src/server/scripts/Custom/changernpc.cpp
@@ -0,0 +1,77 @@
+/*
+<--------------------------------------------------------------------------->
+ - Developer(s): Ghostcrawler336
+ - Complete: 100%
+ - ScriptName: 'Faction / Race Changer' 
+ - Comment: Untested
+ - Updated - 8/7/2013 or 7/8/2013
+<--------------------------------------------------------------------------->
+*/
+#include "ScriptPCH.h"
+
+enum  defines
+{
+ faction_token = 99998, // Faction Change Token
+ race_token = 99998 // Race Change Token
+};
+
+class npc_changer : public CreatureScript
+{
+	public:
+		npc_changer() : CreatureScript("npc_changer"){}
+
+		bool OnGossipHello(Player * pPlayer, Creature * pCreature)
+		{
+			
+			
+			pPlayer->ADD_GOSSIP_ITEM(4, "Change My Race (10 DP)", GOSSIP_SENDER_MAIN, 0);
+		    pPlayer->ADD_GOSSIP_ITEM(4, "Change My Faction (15 DP)", GOSSIP_SENDER_MAIN, 1);
+			pPlayer->PlayerTalkClass->SendGossipMenu(9425, pCreature->GetGUID());
+			return true;
+		}
+
+		bool OnGossipSelect(Player * Player, Creature * Creature, uint32 /*uiSender*/, uint32 uiAction)
+		{
+			if(!Player)
+				return true;
+
+			switch(uiAction)
+			{
+				case 0:
+					if(Player->HasItemCount(race_token, 10))
+					{
+						Player->DestroyItemCount(race_token, 10, true, false);
+						Player->SetAtLoginFlag(AT_LOGIN_CHANGE_RACE);
+						Player->GetSession()->SendNotification("You need to relog, to change your race!");
+						Player->PlayerTalkClass->SendCloseGossip();
+					}
+					else
+					{
+						Player->GetSession()->SendNotification("You need atleast 10 Donation Chips!");
+						Player->PlayerTalkClass->SendCloseGossip();
+					}
+					break;
+				case 1:
+					if(Player->HasItemCount(faction_token, 15))
+					{
+						Player->DestroyItemCount(faction_token, 15, true, false);
+						Player->SetAtLoginFlag(AT_LOGIN_CHANGE_FACTION);
+						Player->GetSession()->SendNotification("You need to relog, to change your faction!");
+						Player->PlayerTalkClass->SendCloseGossip();
+					}
+					else
+					{
+						Player->GetSession()->SendNotification("You need atleast 15 Donation Chips!");
+						Player->PlayerTalkClass->SendCloseGossip();
+					}
+					break;
+			}
+			return true;
+		}
+
+};
+
+void AddSC_npc_changer()
+{
+	new npc_changer();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/levelnpc.cpp b/src/server/scripts/Custom/levelnpc.cpp
new file mode 100644
index 0000000..c850bf1
--- /dev/null
+++ b/src/server/scripts/Custom/levelnpc.cpp
@@ -0,0 +1,192 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Created by LordPsyan for Flaminglegion.net
+ *
+ */
+
+#include "ScriptPCH.h"
+#include "Config.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define SPELL_RESURRECTION_SICKNESS_15007  15007
+
+class levelnpc : public CreatureScript
+{
+public:
+    levelnpc() : CreatureScript("levelnpc") {}
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+	if(ConfigMgr::GetBoolDefault("LevelNPC.OnlyGMs", false)) // If LevelNPC.OnlyGMs is enabled in trinitycore.conf
+		if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+		{
+			pCreature->MonsterWhisper("Sorry, I can only add levels to Platinum Members.", pPlayer->GetGUID());
+			return true;
+		}
+
+	bool EnableLevel60 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel60", true);
+//	bool EnableLevel100 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel100", true);
+//	bool EnableLevel150 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel150", true);
+//	bool EnableLevel200 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel200", true);
+//	bool EnableLevel255 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel255", true);
+    if (pPlayer->GetTeam() == ALLIANCE)
+	{
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+		pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+	}
+	else
+	{
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+		pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+	}
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+
+return true;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->isInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+	return;
+}
+
+	bool EnableLevel60 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel60", true);
+//	bool EnableLevel100 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel100", true);
+//	bool EnableLevel150 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel150", true);
+//	bool EnableLevel200 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel200", true);
+//	bool EnableLevel255 = ConfigMgr::GetBoolDefault("LevelNPC.EnableLevel255", true);
+	
+//Mony Check
+if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+{
+if (!pPlayer->HasItemCount((ConfigMgr::GetIntDefault("LevelNPC.ItemEntryNum",0)), 0))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You need at least 10 Donation chips.", pPlayer->GetGUID());
+	return;
+}
+}
+else if(pPlayer->GetMoney() < (ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer->GetGUID());
+	return;
+}
+
+switch(uiAction)
+{
+
+//////////////////////////////////////////////////Leveling///////////////////////////////////////////////////////////////
+case 1000: //Leveling
+	if(EnableLevel60 && pPlayer->getLevel() < 60)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "(1 Donation Chip) Instant 60 ->"         , GOSSIP_SENDER_MAIN, 1001);
+/*	if(EnableLevel100 && pPlayer->getLevel() < 100 && pPlayer->getLevel() >= 80)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "(2 Donation Chips) Instant 100 ->"        , GOSSIP_SENDER_MAIN, 1002);
+	if(EnableLevel150 && pPlayer->getLevel() < 150 && pPlayer->getLevel() >= 100)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "(5 Donation Chips) Instant 150 ->"        , GOSSIP_SENDER_MAIN, 1003);
+	if(EnableLevel200 && pPlayer->getLevel() < 200 && pPlayer->getLevel() >= 150)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "(10 Donation Chips) Instant 200 ->"       , GOSSIP_SENDER_MAIN, 1004);
+	if(EnableLevel255 && pPlayer->getLevel() < 255 && pPlayer->getLevel() >= 200)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "(20 Donation Chips) Instant 255 ->"       , GOSSIP_SENDER_MAIN, 1005);*/
+		pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                       , GOSSIP_SENDER_MAIN, 3000);
+	pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+case 3000: //Leveling
+	if(EnableLevel60)
+		pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+case 1001: // Leveling
+	pPlayer->GiveLevel(60);
+	if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99998, 10, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+/*case 1002: // Leveling
+	pPlayer->GiveLevel(100);
+	if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99998, 2, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1003: // Leveling
+	pPlayer->GiveLevel(150);
+	if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99998, 5, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1004: // Leveling
+	pPlayer->GiveLevel(200);
+	if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99998, 10, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1005: // Leveling
+	pPlayer->GiveLevel(255);
+	if(ConfigMgr::GetBoolDefault("LevelNPC.UseTokens", true))
+	pPlayer->DestroyItemCount(99998, 20, true);
+	else
+	pPlayer->ModifyMoney(-(ConfigMgr::GetIntDefault("LevelNPC.SkillGoldCost",0)));
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;*/
+case 5000://Remove Res Sickness
+	if(!pPlayer->HasAura(SPELL_RESURRECTION_SICKNESS_15007,0))
+	{
+		pCreature->MonsterWhisper("You don't have resurrection sickness.", pPlayer->GetGUID());
+		OnGossipHello(pPlayer, pCreature);
+		return;
+	}
+
+	pCreature->CastSpell(pPlayer,38588,false); // Healing effect
+	pPlayer->RemoveAurasDueToSpell(SPELL_RESURRECTION_SICKNESS_15007,0);
+	pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+ pPlayer->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+	// Main menu
+	pPlayer->PlayerTalkClass->ClearMenus();
+	if (uiSender == GOSSIP_SENDER_MAIN)
+	SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_levelnpc()
+{
+
+new levelnpc();
+
+}
diff --git a/src/server/scripts/Custom/npc_teleport.cpp b/src/server/scripts/Custom/npc_teleport.cpp
new file mode 100644
index 0000000..b85f341
--- /dev/null
+++ b/src/server/scripts/Custom/npc_teleport.cpp
@@ -0,0 +1,222 @@
+/**
+ *
+ * @File : npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+#include <sstream>
+
+#define GOSSIP_SHOW_DEST        1000
+#define GOSSIP_TELEPORT         1001
+#define GOSSIP_NEXT_PAGEC       1002
+#define GOSSIP_PREV_PAGEC       1003
+#define GOSSIP_NEXT_PAGED       1004
+#define GOSSIP_PREV_PAGED       1005
+#define GOSSIP_MAIN_MENU        1006
+
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+#define SPELL_VISUAL_TELEPORT   35517
+
+#define NB_ITEM_PAGE            10
+#define MSG_CAT                 100000
+#define MSG_DEST                100001
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+
+using namespace nsNpcTel;
+
+
+namespace
+{
+    Page PageC, PageD;
+    Page Cat;
+
+    // Conversion function int->string
+    std::string ConvertStr(const int64 &val)
+    {
+        std::ostringstream ostr;
+        ostr << val;
+        return ostr.str();
+    }
+
+    // Conversion function intMoney->stringMoney
+    std::string ConvertMoney(const uint32 &Money)
+    {
+        std::string Str(ConvertStr(Money));
+        uint32 SizeStr = Str.length();
+
+        if (SizeStr > 4)
+            Str = Str.insert(Str.length()-4, "po");
+        if (SizeStr > 2)
+            Str = Str.insert(Str.length()-2, "pa");
+        Str += "pc";
+
+        return Str;
+    }
+
+    // Teleport Player
+    void Teleport(Player * const player, const uint16 &map,
+                  const float &X, const float &Y, const float &Z, const float &orient)
+    {
+        player->CastSpell(player, SPELL_VISUAL_TELEPORT, true);
+        player->TeleportTo(map, X, Y, Z, orient);
+    }
+
+    // Display categories
+    void AffichCat(Player * const player, Creature * const creature)
+    {
+        if (PageC[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGEC, 0);
+
+        VCatDest_t i (PageC[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest.size() && i < (NB_ITEM_PAGE * (PageC[player] + 1)); ++i)
+        {
+            if (TabCatDest[i].IsAllowedToTeleport(player))
+                player->ADD_GOSSIP_ITEM(7, TabCatDest[i].GetName(player->IsGameMaster()).c_str(), GOSSIP_SHOW_DEST, i);
+        }
+
+        if (i < TabCatDest.size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGEC, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_CAT, creature->GetGUID());
+    }
+
+    // Display destination categories
+    void AffichDest(Player * const player, Creature * const creature)
+    {
+        if (PageD[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGED, 0);
+
+        CatDest::VDest_t i (PageD[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest[Cat[player]].size() && i < (NB_ITEM_PAGE * (PageD[player] + 1)); ++i)
+        {
+            player->ADD_GOSSIP_ITEM(5, TabCatDest[Cat[player]].GetDest(i).m_name.c_str(), GOSSIP_TELEPORT, i);
+        }
+
+        if (i < TabCatDest[Cat[player]].size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGED, 0);
+
+        if (CatDest::CountOfCategoryAllowedBy(player) > 1)
+            player->ADD_GOSSIP_ITEM(7, MAIN_MENU, GOSSIP_MAIN_MENU, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_DEST, creature->GetGUID());
+    }
+
+    // Verification before teleportation
+    void ActionTeleport(Player * const player, Creature * const creature, const uint32 &id)
+    {
+        Dest dest (TabCatDest[Cat[player]].GetDest(id));
+
+        if (player->getLevel() < dest.m_level && !player->IsGameMaster())
+        {
+            std::string msg ("You do not have the required level. This destination requires level " + ConvertStr(dest.m_level) + ".");
+            creature->MonsterWhisper(msg.c_str(), player->GetGUID());
+            return;
+        }
+
+        if (player->GetMoney() < dest.m_cost && !player->IsGameMaster())
+        {
+            std::string msg ("You do not have enough money. The price for teleportation is " + ConvertMoney(dest.m_cost) + ".");
+            creature->MonsterWhisper(msg.c_str(), player->GetGUID());
+            return;
+        }
+
+        if (!player->IsGameMaster() && dest.m_cost)
+            player->ModifyMoney(-1 * dest.m_cost);
+
+        Teleport(player, dest.m_map, dest.m_X, dest.m_Y, dest.m_Z, dest.m_orient);
+    }
+}
+
+class npc_teleport : public CreatureScript
+{
+public:
+    npc_teleport() : CreatureScript("npc_teleport") {}
+
+bool OnGossipHello(Player *player, Creature *creature)
+{
+    PageC(player) = PageD(player) = Cat(player) = 0;
+
+    if(player->IsInCombat())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->MonsterWhisper("You are in combat. Come back later", player->GetGUID());
+        return true;
+    }
+    AffichCat(player, creature);
+    return true;
+}
+
+bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 param)
+{
+    player->PlayerTalkClass->ClearMenus();
+    switch(sender)
+    {
+      // Display destinations
+      case GOSSIP_SHOW_DEST:
+        Cat(player) = param;
+        AffichDest(player, creature);
+        break;
+
+      // Previous categories page
+      case GOSSIP_PREV_PAGEC:
+        --PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Next page categories
+      case GOSSIP_NEXT_PAGEC:
+        ++PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Previous destinations page
+      case GOSSIP_PREV_PAGED:
+        --PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Next destination page
+      case GOSSIP_NEXT_PAGED:
+        ++PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Display main menu
+      case GOSSIP_MAIN_MENU:
+        OnGossipHello(player, creature);
+        break;
+
+      // Teleportation
+      case GOSSIP_TELEPORT:
+        player->CLOSE_GOSSIP_MENU();
+        if(player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0)) {
+            creature->CastSpell(player,38588,false); // Healing effect
+            player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+
+        ActionTeleport(player, creature, param);
+        break;
+    }
+    return true;
+}
+};
+
+void AddSC_npc_teleport()
+{
+    new npc_teleport;
+}
+// End of TeleNPC2
diff --git a/src/server/scripts/Custom/summon.cpp b/src/server/scripts/Custom/summon.cpp
new file mode 100644
index 0000000..70a45de
--- /dev/null
+++ b/src/server/scripts/Custom/summon.cpp
@@ -0,0 +1,46 @@
+#include "ScriptPCH.h"
+ 
+class summon : public ItemScript
+{
+        public:
+                summon() : ItemScript("summon")
+                {
+                }
+                bool OnUse(Player* pPlayer, Item* pItem, SpellCastTargets const& /*targets*/)
+                {
+   uint32 sSpell = 18282; //Icerune Visual Spell when used
+   if (pPlayer->IsInCombat())
+   {
+        pPlayer->GetSession()->SendNotification("You are in combat.");
+   }
+  
+   else if (pPlayer->isMoving())
+   {
+        pPlayer->GetSession()->SendNotification("You can not do that while moving.");
+   }
+  
+   else if (pPlayer->FindNearestCreature(80410, 40) || pPlayer->FindNearestCreature(100000, 8))
+   {
+        pPlayer->GetSession()->SendNotification("Teleportercan not be summoned because another Teleporter is within range.");
+   }
+  
+   else
+   {
+        float x, y, z, o = pPlayer->GetOrientation();
+  
+        if (o >= 3.141592)
+         o = o - 3.141592;
+        else
+         o = o + 3.141592;
+        pPlayer->GetClosePoint(x, y, z, pPlayer->GetObjectSize());
+        Creature* pCreature = pPlayer->SummonCreature(100000, x, y, z+2.2, o, TEMPSUMMON_TIMED_DESPAWN, 500000);
+        pCreature->CastSpell(pCreature, 63660);
+        return false;
+   }
+  return false;
+                }
+};
+void AddSC_summon()
+{
+        new summon();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 0d3da30..41db076 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -413,6 +413,7 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load() OVERRIDE
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -455,6 +456,8 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot())
+                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target) && !caster->IsValidAttackTarget(target))
                         return SPELL_FAILED_BAD_TARGETS;
@@ -596,6 +599,7 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load() OVERRIDE
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.cpp b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
index 7e23761..c8de500 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
@@ -597,4 +597,11 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_UPD_CHAR_PET_SLOT_BY_ID, "UPDATE character_pet SET slot = ? WHERE owner = ? AND id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_ID, "DELETE FROM character_pet WHERE id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_SLOT, "DELETE FROM character_pet WHERE owner = ? AND (slot = ? OR slot > ?)", CONNECTION_ASYNC);
+
+    // Bot
+    PrepareStatement(CHAR_DEL_NPCBOT, "DELETE FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_NPCBOTS, "DELETE FROM character_npcbot WHERE owner = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT, "INSERT INTO character_npcbot (owner, entry, race, class, istank) VALUES (?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_MAINTANK, "SELECT memberGuid, memberFlags FROM group_member WHERE guid = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_TANK, "UPDATE character_npcbot SET istank = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
 }
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.h b/src/server/shared/Database/Implementation/CharacterDatabase.h
index f97dd63..ee42ed3 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.h
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.h
@@ -529,6 +529,13 @@ enum CharacterDatabaseStatements
     CHAR_DEL_ITEMCONTAINER_MONEY,
     CHAR_INS_ITEMCONTAINER_MONEY,
 
+    // Bot
+    CHAR_DEL_NPCBOT,
+    CHAR_DEL_NPCBOTS,
+    CHAR_INS_NPCBOT,
+    CHAR_SEL_MAINTANK,
+    CHAR_UPD_NPCBOT_TANK,
+
     MAX_CHARACTERDATABASE_STATEMENTS
 };
 
diff --git a/src/server/shared/Database/Implementation/LoginDatabase.cpp b/src/server/shared/Database/Implementation/LoginDatabase.cpp
index 6113dd6..5d6777c 100644
--- a/src/server/shared/Database/Implementation/LoginDatabase.cpp
+++ b/src/server/shared/Database/Implementation/LoginDatabase.cpp
@@ -25,6 +25,7 @@ void LoginDatabaseConnection::DoPrepareStatements()
     PrepareStatement(LOGIN_SEL_REALMLIST, "SELECT id, name, address, localAddress, localSubnetMask, port, icon, flag, timezone, allowedSecurityLevel, population, gamebuild FROM realmlist WHERE flag <> 3 ORDER BY name", CONNECTION_SYNCH);
     PrepareStatement(LOGIN_DEL_EXPIRED_IP_BANS, "DELETE FROM ip_banned WHERE unbandate<>bandate AND unbandate<=UNIX_TIMESTAMP()", CONNECTION_ASYNC);
     PrepareStatement(LOGIN_UPD_EXPIRED_ACCOUNT_BANS, "UPDATE account_banned SET active = 0 WHERE active = 1 AND unbandate<>bandate AND unbandate<=UNIX_TIMESTAMP()", CONNECTION_ASYNC);
+    PrepareStatement(LOGIN_UPD_ACCOUNT_PREMIUM, "UPDATE account_premium SET active = 0 WHERE unsetdate<=UNIX_TIMESTAMP() AND unsetdate<>setdate", CONNECTION_ASYNC);
     PrepareStatement(LOGIN_SEL_IP_BANNED, "SELECT * FROM ip_banned WHERE ip = ?", CONNECTION_SYNCH);
     PrepareStatement(LOGIN_INS_IP_AUTO_BANNED, "INSERT INTO ip_banned (ip, bandate, unbandate, bannedby, banreason) VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, 'Trinity realmd', 'Failed login autoban')", CONNECTION_ASYNC);
     PrepareStatement(LOGIN_SEL_IP_BANNED_ALL, "SELECT ip, bandate, unbandate, bannedby, banreason FROM ip_banned WHERE (bandate = unbandate OR unbandate > UNIX_TIMESTAMP()) ORDER BY unbandate", CONNECTION_SYNCH);
diff --git a/src/server/shared/Database/Implementation/LoginDatabase.h b/src/server/shared/Database/Implementation/LoginDatabase.h
index 97cf91f..c7bf2d6 100644
--- a/src/server/shared/Database/Implementation/LoginDatabase.h
+++ b/src/server/shared/Database/Implementation/LoginDatabase.h
@@ -105,6 +105,7 @@ enum LoginDatabaseStatements
     LOGIN_SEL_ACCOUNT_INFO,
     LOGIN_SEL_ACCOUNT_ACCESS_GMLEVEL_TEST,
     LOGIN_SEL_ACCOUNT_ACCESS,
+    LOGIN_UPD_ACCOUNT_PREMIUM,
     LOGIN_SEL_ACCOUNT_RECRUITER,
     LOGIN_SEL_BANS,
     LOGIN_SEL_ACCOUNT_WHOIS,
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.cpp b/src/server/shared/Database/Implementation/WorldDatabase.cpp
index a36023a..8dc7d0e 100644
--- a/src/server/shared/Database/Implementation/WorldDatabase.cpp
+++ b/src/server/shared/Database/Implementation/WorldDatabase.cpp
@@ -93,4 +93,8 @@ void WorldDatabaseConnection::DoPrepareStatements()
     PrepareStatement(WORLD_DEL_DISABLES, "DELETE FROM disables WHERE entry = ? AND sourceType = ?", CONNECTION_ASYNC);
     // 0: uint8
     PrepareStatement(WORLD_SEL_REQ_XP, "SELECT xp_for_next_level FROM player_xp_for_level WHERE lvl = ?", CONNECTION_SYNCH);
+
+    // Bot
+    PrepareStatement(WORLD_SEL_NPCBOT_TEMPLATE, "SELECT entry, trainer_race FROM creature_template WHERE scriptname = ? and trainer_class = ? and trainer_race IN (?, ?, ?, ?, ?)", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS, "SELECT hp, mana, armor, str, agi, sta, inte, spi FROM pet_levelstats WHERE creature_entry = ? AND level = ?", CONNECTION_SYNCH);
 }
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.h b/src/server/shared/Database/Implementation/WorldDatabase.h
index 171627b..05ae43e 100644
--- a/src/server/shared/Database/Implementation/WorldDatabase.h
+++ b/src/server/shared/Database/Implementation/WorldDatabase.h
@@ -114,6 +114,10 @@ enum WorldDatabaseStatements
     WORLD_DEL_DISABLES,
     WORLD_SEL_REQ_XP,
 
+    // Bot
+    WORLD_SEL_NPCBOT_TEMPLATE,
+    WORLD_SEL_NPCBOT_PET_LEVELSTATS,
+
     MAX_WORLDDATABASE_STATEMENTS
 };
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index c4e19e8..a43fe07 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -1765,14 +1765,20 @@ Rate.Drop.Item.ReferencedAmount = 1
 #    Rate.XP.Kill
 #    Rate.XP.Quest
 #    Rate.XP.Explore
+#    Rate.XP.Kill.Premium
+#    Rate.XP.Quest.Premium
+#    Rate.XP.Explore.Premium
 #        Description: Experience rates.
 #        Default:     1 - (Rate.XP.Kill)
 #                     1 - (Rate.XP.Quest)
 #                     1 - (Rate.XP.Explore)
 
-Rate.XP.Kill    = 1
-Rate.XP.Quest   = 1
-Rate.XP.Explore = 1
+Rate.XP.Kill            = 1
+Rate.XP.Kill.Premium    = 1
+Rate.XP.Quest           = 1
+Rate.XP.Quest.Premium   = 1
+Rate.XP.Explore         = 1
+Rate.XP.Explore.Premium = 1
 
 #
 #    Rate.RepairCost
@@ -2321,6 +2327,288 @@ Network.TcpNodelay = 1
 #
 ###################################################################################################
 
+###############################################################################
+# AUCTION HOUSE BOT SETTINGS
+#
+#    AuctionHouseBot.DEBUG
+#        Enable/Disable Debugging output
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.DEBUG_FILTERS
+#        Enable/Disable Debugging output from Filters
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableSeller
+#        Enable/Disable the part of AHBot that puts items up for auction
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableBuyer
+#        Enable/Disable the part of AHBot that buys items from players
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.UseBuyPriceForSeller
+#        Should the Seller use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    AuctionHouseBot.UseBuyPriceForBuyer
+#        Should the Buyer use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    Auction House Bot character data
+#        AuctionHouseBot.Account is the account number
+#         (in realmd->account table) of the player you want to run
+#         as the auction bot.
+#        AuctionHouseBot.GUID is the GUID (in characters->characters table)
+#         of the player you want to run as the auction bot.
+#    Default: 0 (Auction House Bot disabled)
+#
+#    AuctionHouseBot.ItemsPerCycle
+#        Number of Items to Add/Remove from the AH during mass operations
+#    Default 200
+#
+###############################################################################
+
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.DEBUG_FILTERS = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 1
+#
+#    AuctionHouseBot.VendorItems
+#        Include items that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.VendorTradeGoods
+#        Include Trade Goods that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.LootItems
+#        Include items that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.LootTradeGoods
+#        Include Trade Goods that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.OtherItems
+#        Include misc. items.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.OtherTradeGoods
+#        Include misc. Trade Goods.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.Bonding_types
+#        Indicates which bonding types to allow seller to put up for auction
+#            No_Bind
+#             Default 1 (True)
+#            Bind_When_Picked_Up
+#             Default 0 (False)
+#            Bind_When_Equipped
+#             Default 1 (True)
+#            Bind_When_Use
+#             Default 1 (True)
+#            Bind_Quest_Item
+#             Default 0 (False)
+#
+#    AuctionHouseBot.DisabledItems
+#        Disable certain items that are usually unavailable to Players. List of ids separated by space
+#    Default "21878 27774 27811 28117 28112" (PTR items)
+#
+#    AuctionHouseBot.DisablePermEnchant
+#        Disable Items with a Permanent Enchantment
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableConjured
+#        Disable Conjured Items
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableGems
+#        Disable Gems
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoney
+#        Disable Items that are used as money
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoneyLoot
+#        Disable Items that have Money as a loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableLootable
+#        Disable Items that have other items as loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableKeys
+#        Disable Items that are keys
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableDuration
+#        Disable Items with a duration
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel
+#        Disable items that are BOP or Quest Item
+#        with a Required level that is less than the Item Level
+#        (This prevents a level 10 with a level 60 weapon or armor)
+#        (May need further refinement)
+#    Default 0 (False)
+#
+###############################################################################
+
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+AuctionHouseBot.DisabledItems = "21878 27774 27811 28117 28112"
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 2
+#
+#     These Filters are boolean (0 or 1) and will disable items that are
+#     specifically meant for the Class named.
+#     (UnusedClass is Class 10, which was skipped for some reason)
+#     Default 0 (allowed)
+#
+###############################################################################
+
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 3
+#
+#    AuctionHouseBot.DisableItemsBelowLevel
+#        Prevent Seller from listing Items below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveLevel
+#        Prevent Seller from listing Items above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowLevel
+#        Prevent Seller from listing Trade Goods below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveLevel
+#        Prevent Seller from listing Trade Goods above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowGUID
+#        Prevent Seller from listing Items below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveGUID
+#        Prevent Seller from listing Items above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowGUID
+#        Prevent Seller from listing Trade Goods below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveGUID
+#        Prevent Seller from listing Trade Goods above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqLevel
+#        Prevent Seller from listing Items below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqLevel
+#        Prevent Seller from listing Items above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqLevel
+#        Prevent Seller from listing Trade Goods below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqLevel
+#        Prevent Seller from listing Trade Goods above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqSkillRank
+#        Prevent Seller from listing Items below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqSkillRank
+#        Prevent Seller from listing Items above this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqSkillRank
+#        Prevent Seller from listing Trade Goods below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqSkillRank
+#        Prevent Seller from listing Trade Goods above this Required Skill Rank
+#    Default 0 (Off)
+#
+###############################################################################
+
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
+###############################################################################
+# AUCTION HOUSE BOT GLYPHS PART
+#
+#    AuctionHouseBot.SellGlyphs
+#    Default 0 (Off)
+#
+###############################################################################
+
+AuctionHouseBot.SellGlyphs = 0
+AuctionHouseBot.GlyphsCount = 0
+AuctionHouseBot.DisableGlyphBelowLevel = 0
+AuctionHouseBot.DisableGlyphAboveLevel = 0
+AuctionHouseBot.GlyphBuyOutPriceMin = 0
+AuctionHouseBot.GlyphBuyOutPriceMax = 0
+AuctionHouseBot.GlyphBidPriceMin = 0
+AuctionHouseBot.GlyphBidPriceMax = 0
+
 ###################################################################################################
 # CONSOLE AND REMOTE ACCESS
 #
@@ -2794,3 +3082,109 @@ Log.Async.Enable = 0
 
 #
 ###################################################################################################
+
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#     Bot.EnableNpcBots
+#        Enable NpcBot system
+#        Default: 1 - enable
+#                       0 - disable
+
+Bot.EnableNpcBots = 1
+
+#    Bot.MaxNpcBots
+#        Maximum number of Npc Bots allowed per character (disabled for GM accounts)
+#        Default: 1
+#        Recomended: 4
+#        Max: 9
+#        Absolute Max: 39
+
+Bot.MaxNpcBots = 1
+
+#    Bot.MaxNpcBotsPerClass
+#        Maximum Npc Bots of each class allowed per character
+#        If set to 0, no restriction
+#        Default: 1
+
+Bot.MaxNpcBotsPerClass = 1
+
+#    Bot.BaseFollowDistance
+#        Default follow distance set at login
+#        Default: 30
+
+Bot.BaseFollowDistance = 30
+
+#    Bot.XpReductionPercent
+#        Since bot party can be pretty large, it can become an exploit to farm xp so you can reduce xp gain here
+#        PERCENT of  'XP.KILL'  reward reduction from each Npc Bots used (Starting with second)
+#        Example:
+#            You have 3 bots, xp reduction is 20 then reduction will be ((3-1)*20) = 40%; 60% exp gained only
+#        Note: Minimum xp rate will be 10%
+#        Min: 0
+#        Max: 90
+#        Default: 0
+
+Bot.XpReductionPercent = 0
+
+#    Bot.HealTargetIconsMask
+#        Icon number bitmask which bots are using to search for additional targets to heal (out of party)
+#        1 - Star
+#        2 - Circle
+#        4 - Diamond
+#        8 - Triangle
+#        16 - Moon
+#        32 - Square
+#        64 - Cross
+#        128 - Skull
+#        Example: to check Star, Triangle and Square we need 1+8+32 = 41
+#        Note that many creatures cannot accept heal
+#        Min: 0 (Disable)
+#        Max: 255 (Any Icon)
+#        Default: 8 (Triangle)
+
+Bot.HealTargetIconsMask = 8
+
+#    Bot.DamageMult
+#        Myltiplier for bot's damage dealt. Allows to balance bots' compared to players' damage
+#        Any damage done by bots will be modified
+#        Range: 0.01 - 10.0
+#        Default: 1.0
+
+Bot.DamageMult.Melee = 1.0
+Bot.DamageMult.Spell = 1.0
+
+#    Bot.EnableIn... Arenas/BGs/Dungeons/Raids
+#        Allows to restrict bots usage in PvE and/or PvP
+#        Default: true for all
+
+Bot.EnableInArenas = 1
+Bot.EnableInBGs = 1
+Bot.EnableInDungeons = 1
+Bot.EnableInRaids = 1
+
+#    Bot.InstanceLimit... Dungeons/Raids
+#        If set to 1 will apply instance players limitation to bots
+#        Default: false for all
+
+Bot.InstanceLimit.Dungeons = 0
+Bot.InstanceLimit.Raids = 0
+
+#    Bot.Cost
+#        Bot recruitment cost (in copper)
+#        Note: this value is set for lvl 80 characters. Cost will be reduced for lower levels
+#        Default: 0
+
+Bot.Cost = 0
+
+#    Bot.AllowAllClasses
+#        If set to 0 will not allow to create bots (through command) with classes which not yet implemented (in development)
+#        and not shown in botgiver's dialog
+#        Warning: Enabling this can cause crashes!
+#        Default: 0
+
+Bot.AllowAllClasses = 0
+
+#
+###################################################################################################
-- 
1.7.10.4

