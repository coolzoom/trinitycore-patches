From 33f16cbc4bceae75518b199e06f91f1acc862dce Mon Sep 17 00:00:00 2001
From: root <root@deb.privatedns.com>
Date: Sat, 15 Jan 2011 22:35:55 -0500
Subject: [PATCH 2/2] 11031-ALL-COMPLETE

---
 README.NPCTELEPORT                                 |   14 +
 doc/AuctionHouseBot.txt                            |  236 +++
 sql/All/DalaranSewers.sql                          |    4 +
 sql/All/character_VIPAccount.sql                   |    8 +
 sql/All/characters_jail.sql                        |   66 +
 sql/All/setup_ahbot.sql                            |   72 +
 sql/All/setup_npc_teleport.sql                     |  119 ++
 sql/All/world_argenttournament.sql                 |  425 +++++
 sql/All/world_command_Deutsch.sql                  |    7 +
 sql/All/world_command_English.sql                  |    7 +
 sql/All/world_command_Francais.sql                 |    7 +
 sql/All/world_creature_template.sql                |    5 +
 sql/All/world_guildhouses.sql                      |   54 +
 sql/All/world_ruby_sanctum.sql                     |   66 +
 sql/All/world_trinity_string.sql                   |   40 +
 sql/CMakeLists.txt                                 |    1 +
 src/server/authserver/Server/AuthSocket.cpp        |    3 +
 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp  |  373 ++++
 src/server/game/AI/ScriptedAI/sc_npc_teleport.h    |  151 ++
 .../AuctionHouseBot/AuctionHouseBot.cpp            | 1884 ++++++++++++++++++++
 .../AuctionHouse/AuctionHouseBot/AuctionHouseBot.h | 1247 +++++++++++++
 src/server/game/AuctionHouse/AuctionHouseMgr.cpp   |   13 +-
 src/server/game/AuctionHouse/AuctionHouseMgr.h     |    2 +
 .../game/Battlegrounds/Zones/BattlegroundDS.cpp    |   42 +
 .../game/Battlegrounds/Zones/BattlegroundDS.h      |    9 +-
 src/server/game/CMakeLists.txt                     |    3 +
 src/server/game/Chat/Chat.cpp                      |    7 +-
 src/server/game/Chat/Chat.h                        |    7 +
 src/server/game/Chat/Commands/Level0.cpp           |   51 +-
 src/server/game/Chat/Commands/Level1.cpp           |  286 +++
 src/server/game/Chat/Commands/Level2.cpp           |   89 +-
 src/server/game/Chat/Commands/Level3.cpp           |  497 ++++++
 src/server/game/Entities/Player/Player.cpp         |  207 +++-
 src/server/game/Entities/Player/Player.h           |   40 +
 src/server/game/Entities/Unit/Unit.h               |    1 +
 src/server/game/Globals/ObjectMgr.cpp              |  137 ++-
 src/server/game/Globals/ObjectMgr.h                |   29 +-
 src/server/game/Mails/Mail.cpp                     |    8 +
 src/server/game/Miscellaneous/Formulas.h           |    4 +-
 src/server/game/Miscellaneous/Language.h           |   36 +
 src/server/game/Scripting/ScriptLoader.cpp         |   26 +
 src/server/game/Scripting/ScriptMgr.cpp            |    3 +
 .../Protocol/Handlers/AuctionHouseHandler.cpp      |    1 +
 .../Server/Protocol/Handlers/MovementHandler.cpp   |  417 +++++-
 .../game/Server/Protocol/Handlers/PetHandler.cpp   |    9 +
 .../game/Server/Protocol/Handlers/TaxiHandler.cpp  |   99 +-
 src/server/game/Server/WorldSession.cpp            |    4 +-
 src/server/game/Server/WorldSession.h              |    4 +-
 src/server/game/Server/WorldSocket.cpp             |   13 +-
 src/server/game/Spells/SpellEffects.cpp            |   38 +-
 src/server/game/World/World.cpp                    |   65 +-
 src/server/game/World/World.h                      |   15 +-
 src/server/scripts/CMakeLists.txt                  |    3 +
 src/server/scripts/Commands/cs_gm.cpp              |    4 +-
 src/server/scripts/Custom/CMakeLists.txt           |    2 +
 src/server/scripts/Custom/guildmaster.cpp          |  339 ++++
 src/server/scripts/Custom/npc_teleport.cpp         |  222 +++
 src/server/scripts/Custom/resetduel.cpp            |   26 +
 .../scripts/EasternKingdoms/silvermoon_city.cpp    |    4 +-
 src/server/scripts/Northrend/CMakeLists.txt        |    7 +
 .../Northrend/RubySanctum/boss_baltharus.cpp       |  340 ++++
 .../scripts/Northrend/RubySanctum/boss_halion.cpp  |  521 ++++++
 .../Northrend/RubySanctum/boss_ragefire.cpp        |  174 ++
 .../Northrend/RubySanctum/boss_zarithrian.cpp      |  116 ++
 .../RubySanctum/instance_ruby_sanctum.cpp          |  234 +++
 .../scripts/Northrend/RubySanctum/ruby_sanctum.h   |  130 ++
 src/server/scripts/Northrend/grizzly_hills.cpp     |  215 +++
 src/server/scripts/Northrend/icecrown.cpp          | 1051 +++++++++++-
 .../shared/Database/Implementation/LoginDatabase.h |    4 +-
 src/server/worldserver/worldserver.conf.dist       |  298 +++
 70 files changed, 10568 insertions(+), 73 deletions(-)
 create mode 100644 README.NPCTELEPORT
 create mode 100644 doc/AuctionHouseBot.txt
 create mode 100644 sql/All/DalaranSewers.sql
 create mode 100644 sql/All/character_VIPAccount.sql
 create mode 100644 sql/All/characters_jail.sql
 create mode 100644 sql/All/setup_ahbot.sql
 create mode 100644 sql/All/setup_npc_teleport.sql
 create mode 100644 sql/All/world_argenttournament.sql
 create mode 100644 sql/All/world_command_Deutsch.sql
 create mode 100644 sql/All/world_command_English.sql
 create mode 100644 sql/All/world_command_Francais.sql
 create mode 100644 sql/All/world_creature_template.sql
 create mode 100644 sql/All/world_guildhouses.sql
 create mode 100644 sql/All/world_ruby_sanctum.sql
 create mode 100644 sql/All/world_trinity_string.sql
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.h
 create mode 100644 src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
 create mode 100644 src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
 create mode 100644 src/server/scripts/Custom/guildmaster.cpp
 create mode 100644 src/server/scripts/Custom/npc_teleport.cpp
 create mode 100644 src/server/scripts/Custom/resetduel.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
 create mode 100644 src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h

diff --git a/README.NPCTELEPORT b/README.NPCTELEPORT
new file mode 100644
index 0000000..015c9c2
--- /dev/null
+++ b/README.NPCTELEPORT
@@ -0,0 +1,14 @@
+NPC Teleport for Trinity
+
+Original author : Wilibald09
+
+Allows you to add a custom NPC for teleporting, using .npc add 100000.
+The default NPC is entry 100000.
+
+All settings are located in the DB, so you can customize and add destinations,
+set level restrictions and also charge the player for teleporting.
+
+Installation:
+
+Run the query setup_npc_teleport.sql located in the trinity sql directory on
+your world DB. This will setup the DB and you can customize from there.
diff --git a/doc/AuctionHouseBot.txt b/doc/AuctionHouseBot.txt
new file mode 100644
index 0000000..cc15a08
--- /dev/null
+++ b/doc/AuctionHouseBot.txt
@@ -0,0 +1,236 @@
+Populates the auction houses with items. It can make the game feel a bit more
+like official on small servers. Items and prices are chosen randomly based on
+the parameters you define. If an auction expires, auctions are deleted quietly.
+AHBot will not buy it's own items, and will not receive mail from the AH
+or get returned mail.
+
+===============================================================================
+~~HOW TO CONFIGURE~~
+===============================================================================
+Step 1.) Create a character that you are going to use as the auction house bot
+         character. This character will be the auction's owner for all the
+         items created by the bot.
+Step 2.) Go into the realm database and note the account number for the
+         character.
+Step 3.) Go into the characters database and note the character's GUID.
+Step 4.) Log in at least once with this character.
+         (Do not change the configuration before this)
+Step 5.) Tune the configuration options in the configuration file and the
+         Database.
+
+#These are the settings in the configuration file:
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+AuctionHouseBot.DEBUG enables (1) or disables (0) Debug output
+AuctionHouseBot.EnableSeller enables (1) or disables (0) the Seller
+AuctionHouseBot.EnableBuyer enables (1) or disables (0) the Buyer
+AuctionHouseBot.UseBuyPriceForSeller Use SellPrice (0) or BuyPrice (1) for determining prices
+AuctionHouseBot.UseBuyPriceForBuyer Use SellPrice (0) or BuyPrice (1) for determining prices
+AuctionHouseBot.Account is the account number (in realmd->account table) of the player you want to run as the auction bot. Note: a value of 0 will disable the bot.
+AuctionHouseBot.GUID is the GUID (in characters->characters table) of the player you want to run as the auction bot. Note: a value of 0 will disable the bot.
+AuctionHouseBot.ItemsPerCycle determines how many items are added each time AHBot is run (once per minute, by default)
+
+#These are the Filters For filtering certain items/trade goods from the AH
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisableBeta_PTR_Unused = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+
+AuctionHouseBot.VendorItems is a boolean value (0 or 1) that indicates whether to include Vendor only items
+AuctionHouseBot.VendorTradeGoods is a boolean value (0 or 1) that indicates whether to include Vendor only Trade Goods
+AuctionHouseBot.LootItems  is a boolean value (0 or 1) that indicates whether to include Loot/Fish/Skin/etc. only items
+AuctionHouseBot.LootTradeGoods  is a boolean value (0 or 1) that indicates whether to include Loot/Fish/Skin/etc. only Trade Goods
+AuctionHouseBot.OtherItems  is a boolean value (0 or 1) that indicates whether to include Other items not covered by the first 2
+AuctionHouseBot.OtherTradeGoods  is a boolean value (0 or 1) that indicates whether to include Other Trade Goods not covered by the first 2
+AuctionHouseBot.No_Bind is a boolean value (0 or 1) that indicates whether to include items with a bonding of 0
+AuctionHouseBot.Bind_When_Picked_Up = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 1
+AuctionHouseBot.Bind_When_Equipped = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 2
+AuctionHouseBot.Bind_When_Use = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 3
+AuctionHouseBot.Bind_Quest_Item = is a boolean value (0 or 1) that indicates whether to include items with a bonding of 4
+AuctionHouseBot.DisableBeta_PTR_Unused is a boolean value (0 or 1) that will Disable certain items that are usually unavailable to Players
+AuctionHouseBot.DisablePermEnchant is a boolean value (0 or 1) that will Disable Items with a Permanent Enchantment
+AuctionHouseBot.DisableConjured is a boolean value (0 or 1) that will Disable Conjured Items
+AuctionHouseBot.DisableGems is a boolean value (0 or 1) that will Disable Gems
+AuctionHouseBot.DisableMoney is a boolean value (0 or 1) that will Disable Items that are used as money
+AuctionHouseBot.DisableMoneyLoot is a boolean value (0 or 1) that will Disable Items that have Money as a loot
+AuctionHouseBot.DisableLootable is a boolean value (0 or 1) that will Disable Items that have other items as loot
+AuctionHouseBot.DisableKeys is a boolean value (0 or 1) that will Disable Items that are keys
+AuctionHouseBot.DisableDuration is a boolean value (0 or 1) that will Disable Items with a duration
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel is a boolean value (0 or 1) that will Disable items that are BOP or Quest Item with a Required level that is less than the Item Level
+
+#These Filters are boolean (0 or 1) and will disable items that are
+#specifically meant for the Class named.
+#(UnusedClass is Class 10, which was skipped for some reason)
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+#These are the Filters For filtering certain items/trade goods from the AH
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
+#These are the settings in the Database:
+#Each Auctionhouse has it's own set of these
+
+MinItems = 0
+#The Minimum number of items you want to keep in the auction houses.
+#(default 0 - minimum will be the same as maximum).
+#If it is higher than the value of the corresponding maxItems setting,
+#it will be set down to match the maxItems setting.
+
+MaxItems = 0
+#The Maximum number of items you want to keep in the auction houses.
+
+#These must add up to 100 each one is the percentage
+#of the auction items that should be trade goods of
+#that quality. A value of 0 will disable.
+
+PercentGreyTradeGoods = 0
+PercentWhiteTradeGoods = 27
+PercentGreenTradeGoods = 12
+PercentBlueTradeGoods = 10
+PercentPurpleTradeGoods = 1
+PercentOrangeTradeGoods = 0
+PercentYellowTradeGoods = 0
+
+PercentGreyItems = 0
+PercentWhiteItems = 10
+PercentGreenItems = 30
+PercentBlueItems = 8
+PercentPurpleItems = 2
+PercentOrangeItems = 0
+PercentYellowItems = 0
+
+#MinPrice(Color)    is the minimum price adjustment for items. For example the default is 150, which means 150%. So if an item vendors for 1g it would go to auction for a minimum of 1.5g.
+#MaxPrice(Color)    is the maximum price adjustment for items.
+#MinBidPrice(Color) these two control the starting bid as a percent of the buyout price. For example, if MinBidPrice is 30 and MaxBidPrice is 80 the starting bid for the auction will randomly be between 30-80% of the randomly chosen buyout price.
+#MaxBidPrice(Color) these two control the starting bid as a percent of the buyout price. For example, if MinBidPrice is 30 and MaxBidPrice is 80 the starting bid for the auction will randomly be between 30-80% of the randomly chosen buyout price.
+#MaxStack(Color)    is maximum stack size to create for this quality type. A value of zero will disable the maximum stack size for this quality allowing the bot to create stacks (of random size) of items as big as the item type allows.
+
+MinPriceGrey = 100
+MaxPriceGrey = 150
+MinBidPriceGrey = 70
+MaxBidPriceGrey = 100
+MaxStackGrey = 0
+MinPriceWhite = 150
+MaxPriceWhite = 250
+MinBidPriceWhite = 70
+MaxBidPriceWhite = 100
+MaxStackWhite = 0
+MinPriceGreen = 800
+MaxPriceGreen = 1400
+MinBidPriceGreen = 80
+MaxBidPriceGreen = 100
+MaxStackGreen = 0
+MinPriceBlue = 1250
+MaxPriceBlue = 1750
+MinBidPriceBlue = 75
+MaxBidPriceBlue = 100
+MaxStackBlue = 0
+MinPricePurple = 2250
+MaxPricePurple = 4550
+MinBidPricePurple = 80
+MaxBidPricePurple = 100
+MaxStackPurple = 0
+MinPriceOrange = 4250
+MaxPriceOrange = 5550
+MinBidPriceOrange = 80
+MaxBidPriceOrange = 100
+MaxStackOrange = 0
+MinPriceYellow = 5250
+MaxPriceYellow = 6550
+MinBidPriceYellow = 80
+MaxBidPriceYellow = 100
+MaxStackYellow = 0
+
+#These are the multipliers that are applied to the vendor price for an item, that determines if AHBot will buy it or not.
+#1 means AHBot will pay the same as (or less than) a vendor would pay, 2 means up to twice as much, etc.
+
+BuyerPriceGrey = 1
+BuyerPriceWhite = 3
+BuyerPriceGreen = 5
+BuyerPriceBlue = 12
+BuyerPricePurple = 15
+BuyerPriceOrange = 20
+BuyerPriceYellow = 22
+
+#BuyerBiddingInterval is the time (in minutes) between bids.
+#BuyerBidsPerInterval is the number of bids the buyer will make in a cycle
+
+BuyerBiddingInterval = 1
+BuyerBidsPerInterval = 1
+
+
+
+How to use ahcommands from the console (CLI) or in game with GM level 3 players:
+ahbotoptions - will display usage instructions
+ahbotoptions help - will display the list of commands
+
+ahexpire - will expire all the auctions in the requested auction house that were created by AHBot.
+minitems - will set the minimum number of items in the AH before it starts being filled again.
+maxitems - will set the maximum number of items in the AH.
+percentages - will set the percentage of each quality in the AH
+minprice - will set the minimum price multiplier for auctions.
+maxprice - will set the maximum price multiplier for auctions.
+minbidprice - will set the minimum starting bid as a percent of the buyout price for auctions.
+maxbidprice - will set the maximum starting bid as a percent of the buyout price for auctions.
+maxstack - will set the maximum number of items in stacks for auctions. 0 will set the maximum to the maximum for that item type.
+buyerprice - will set the bid price multiplier for auctions.
+biddinginterval - will set the number of minutes between bids on auctions.
+bidsperinterval - will set the number of bids to enter per cycle.
+
+The auction house IDs are:
+2 - Alliance
+6 - Horde
+7 - Neutral
+
+
+AHBot Originally made by Chris K. Currently maintained by Paradox
+Much thanks to Chris K, grether and Dolomit6!
+AHBot Now includes AHBuyer created by Kerbe as a derivative of AHBot, and later modified by Paradox
diff --git a/sql/All/DalaranSewers.sql b/sql/All/DalaranSewers.sql
new file mode 100644
index 0000000..5d2676e
--- /dev/null
+++ b/sql/All/DalaranSewers.sql
@@ -0,0 +1,4 @@
+UPDATE `world`.`gameobject_template` SET `flags` = '36' WHERE `gameobject_template`.`entry` =192642 LIMIT 1 ;
+UPDATE `world`.`gameobject_template` SET `flags` = '36' WHERE `gameobject_template`.`entry` =192643 LIMIT 1 ;
+UPDATE `world`.`battleground_template` SET `MinPlayersPerTeam` = '0', `MaxPlayersPerTeam` = '2' WHERE `battleground_template`.`id` =10 LIMIT 1 ;
+DELETE FROM `disables` WHERE `entry` = 10 ;
diff --git a/sql/All/character_VIPAccount.sql b/sql/All/character_VIPAccount.sql
new file mode 100644
index 0000000..df317ed
--- /dev/null
+++ b/sql/All/character_VIPAccount.sql
@@ -0,0 +1,8 @@
+CREATE TABLE IF NOT EXISTS `account_premium` (
+  `id` int(11) NOT NULL default '0' COMMENT 'Account id',
+  `setdate` bigint(40) NOT NULL default '0',
+  `unsetdate` bigint(40) NOT NULL default '0',
+  `premium_type` tinyint(4) unsigned NOT NULL default '1',
+  `active` tinyint(4) NOT NULL default '1',
+  PRIMARY KEY  (`id`,`setdate`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='Premium Accounts';
\ No newline at end of file
diff --git a/sql/All/characters_jail.sql b/sql/All/characters_jail.sql
new file mode 100644
index 0000000..c8c080a
--- /dev/null
+++ b/sql/All/characters_jail.sql
@@ -0,0 +1,66 @@
+/*
+MySQL Data Transfer
+Source Host: localhost
+Source Database: characters
+Target Host: localhost
+Target Database: characters
+Date: 25.04.2010 00:00:00
+*/
+DROP TABLE IF EXISTS `jail`;
+SET FOREIGN_KEY_CHECKS=0;
+-- ----------------------------
+-- Table structure for jail
+-- ----------------------------
+CREATE TABLE `jail` (
+  `guid` int(11) unsigned NOT NULL COMMENT 'GUID of the jail brother',
+  `char` varchar(13) NOT NULL COMMENT 'Jailed charname',
+  `release` int(11) unsigned NOT NULL COMMENT 'Release time for the char',
+  `amnestietime` int(11) NOT NULL,
+  `reason` varchar(255) NOT NULL COMMENT 'Reason for the jail',
+  `times` int(11) unsigned NOT NULL COMMENT 'How many times this char already was jailed',
+  `gmacc` int(11) unsigned NOT NULL COMMENT 'Used GM acc to jail this char',
+  `gmchar` varchar(13) NOT NULL COMMENT 'Used GM char to jail this char',
+  `lasttime` timestamp NOT NULL default '0000-00-00 00:00:00' on update CURRENT_TIMESTAMP COMMENT 'Last time jailed',
+  `duration` int(11) unsigned NOT NULL default '0' COMMENT 'Duration of the jail',
+  PRIMARY KEY  (`guid`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Jail table for Trinitycore by WarHead Edited by SPGM';
+
+-- ----------------------------
+-- Records
+-- ----------------------------
+DROP TABLE IF EXISTS `jail_conf`;
+SET FOREIGN_KEY_CHECKS=0;
+-- ----------------------------
+-- Table structure for jail_conf
+-- ----------------------------
+
+CREATE TABLE `jail_conf` (
+  `id` int(11) NOT NULL auto_increment,
+  `obt` varchar(50) default NULL,
+  `jail_conf` int(11) default NULL,
+  `jail_tele` float default NULL,
+  `help_ger` varchar(255) character set latin1 default '',
+  `help_enq` varchar(255) default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;
+
+-- ----------------------------
+-- Records
+-- ----------------------------
+INSERT INTO `jail_conf` VALUES ('1', 'm_jailconf_max_jails', '3', null, 'Hier legst ihre fest nach wie fielen Jails der Char gelöscht werden \r\nStandart = 3\r\n ', 'How many time the characters can be Jailed before being deleted\r\nDefault = 3');
+INSERT INTO `jail_conf` VALUES ('2', 'm_jailconf_max_duration', '672', null, 'Hier legst ihre fest wie hoch der maximale Jail Time in Stunden \r\nStandart = 672\r\n', 'Here put how high the maximum Jail Time in hours\r\nDefault = 672');
+INSERT INTO `jail_conf` VALUES ('3', 'm_jailconf_min_reason', '25', null, 'Hier legst ihre die minimalen Zeichen fest die als Grund angeben müsst  \r\nStandart = 25\r\n\r\n', 'Here list how many characters are needed as the minimum reason\r\nDefault = 25');
+INSERT INTO `jail_conf` VALUES ('4', 'm_jailconf_warn_player', '1', null, 'Hier legst ihre fest wann der Char gewarnt wirt  bevor er gelöscht wird \r\nStandart = 1\r\n', 'How many time to warn the player before jailing them\r\nDefault = 1');
+INSERT INTO `jail_conf` VALUES ('5', 'm_jailconf_amnestie', '180', null, 'Hier legst ihre in Tagen fest wann der Jail Status  auf 0 zurückgesetzt wird   \r\nStandart = 180 Tage (das entspricht ca. ½ Jahr)  \r\n                     0  Tage (Aus)\r\n', 'This is how many in days when the Jail is status is set to 0\r\nStandard = 180 days (approximately ½ year)\r\n                     0 days (off)');
+INSERT INTO `jail_conf` VALUES ('6', 'm_jailconf_ally_x', null, '31.7282', 'Teleport Alliance  X Achse \r\nStandart = 31,7282\r\n', 'Teleport Alliance  X Axis \r\nStandart = 31,7282\r\n');
+INSERT INTO `jail_conf` VALUES ('7', 'm_jailconf_ally_y', null, '135.794', 'Teleport Alliance  Y Achse \r\nStandart = 135,794\r\n', 'Teleport Alliance  Y Axis \r\nStandart = 135,794\r\n');
+INSERT INTO `jail_conf` VALUES ('8', 'm_jailconf_ally_z', null, '-40.0508', 'Teleport Alliance  Z Achse \r\nStandart = -40,0508', 'Teleport Alliance  Z Axis \r\nStandart = -40,0508');
+INSERT INTO `jail_conf` VALUES ('9', 'm_jailconf_ally_o', null, '4.73516', 'Teleport Alliance  blickrichtung\r\nStandart = 4,73516', 'Teleport Alliance  Orientation\r\nStandart = 4,73516');
+INSERT INTO `jail_conf` VALUES ('10', 'm_jailconf_ally_m', '35', null, 'Teleport Alliance  Mape\r\nStandart = 35', 'Teleport Alliance  Map\r\nStandart = 35');
+INSERT INTO `jail_conf` VALUES ('11', 'm_jailconf_horde_x', null, '2179.85', 'Teleport Horde  X Achse \r\nStandart = \r\n', 'Teleport Horde  X Axis \r\nStandart = \r\n');
+INSERT INTO `jail_conf` VALUES ('12', 'm_jailconf_horde_y', null, '-4763.96', 'Teleport Horde  Y Achse \r\nStandart = -4763,96', 'Teleport Horde  Y Axis \r\nStandart = -4763,96');
+INSERT INTO `jail_conf` VALUES ('13', 'm_jailconf_horde_z', null, '54.911', 'Teleport Horde  Z Achse \r\nStandart = 54,911', 'Teleport Horde  Z Axis \r\nStandart = 54,911');
+INSERT INTO `jail_conf` VALUES ('14', 'm_jailconf_horde_o', null, '4.44216', 'Teleport  Horde  blickrichtung\r\nStandart = 4,44216', 'Teleport  Horde  Orientation\r\nStandart = 4,44216');
+INSERT INTO `jail_conf` VALUES ('15', 'm_jailconf_horde_m', '1', null, 'Teleport Horde  Mape\r\nStandart = 1', 'eleport Horde  Map\r\nStandart = 1');
+INSERT INTO `jail_conf` VALUES ('16', 'm_jailconf_ban', '0', null, 'Nach wie vielen Jail soll der  Account Gebant werden\r\nStandart = 0  (aus)\r\n', 'After how many jails the account will be Banned\r\nDefault = 0 (off)');
+INSERT INTO `jail_conf` VALUES ('17', 'm_jailconf_radius', '10', null, 'Legt den Bewegung Radius in Metern waren des Jails fest\r\nStandart = 10\r\n', 'Sets the range of motion in meters of the jail\r\nDefault = 10');
diff --git a/sql/All/setup_ahbot.sql b/sql/All/setup_ahbot.sql
new file mode 100644
index 0000000..9a5a4f7
--- /dev/null
+++ b/sql/All/setup_ahbot.sql
@@ -0,0 +1,72 @@
+CREATE TABLE `auctionhousebot` (
+    `auctionhouse` INT(11) NOT NULL DEFAULT '0' COMMENT 'mapID of the auctionhouse.',
+    `name` CHAR(25) NULL DEFAULT NULL COMMENT 'Text name of the auctionhouse.',
+    `minitems` INT(11) NULL DEFAULT '0' COMMENT 'This is the minimum number of items you want to keep in the auction house. a 0 here will make it the same as the maximum.',
+    `maxitems` INT(11) NULL DEFAULT '0' COMMENT 'This is the number of items you want to keep in the auction house.',
+    `percentgreytradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Grey Trade Goods auction items',
+    `percentwhitetradegoods` INT(11) NULL DEFAULT '27' COMMENT 'Sets the percentage of the White Trade Goods auction items',
+    `percentgreentradegoods` INT(11) NULL DEFAULT '12' COMMENT 'Sets the percentage of the Green Trade Goods auction items',
+    `percentbluetradegoods` INT(11) NULL DEFAULT '10' COMMENT 'Sets the percentage of the Blue Trade Goods auction items',
+    `percentpurpletradegoods` INT(11) NULL DEFAULT '1' COMMENT 'Sets the percentage of the Purple Trade Goods auction items',
+    `percentorangetradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Orange Trade Goods auction items',
+    `percentyellowtradegoods` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the Yellow Trade Goods auction items',
+    `percentgreyitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Grey auction items',
+    `percentwhiteitems` INT(11) NULL DEFAULT '10' COMMENT 'Sets the percentage of the non trade White auction items',
+    `percentgreenitems` INT(11) NULL DEFAULT '30' COMMENT 'Sets the percentage of the non trade Green auction items',
+    `percentblueitems` INT(11) NULL DEFAULT '8' COMMENT 'Sets the percentage of the non trade Blue auction items',
+    `percentpurpleitems` INT(11) NULL DEFAULT '2' COMMENT 'Sets the percentage of the non trade Purple auction items',
+    `percentorangeitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Orange auction items',
+    `percentyellowitems` INT(11) NULL DEFAULT '0' COMMENT 'Sets the percentage of the non trade Yellow auction items',
+    `minpricegrey` INT(11) NULL DEFAULT '100' COMMENT 'Minimum price of Grey items (percentage).',
+    `maxpricegrey` INT(11) NULL DEFAULT '150' COMMENT 'Maximum price of Grey items (percentage).',
+    `minpricewhite` INT(11) NULL DEFAULT '150' COMMENT 'Minimum price of White items (percentage).',
+    `maxpricewhite` INT(11) NULL DEFAULT '250' COMMENT 'Maximum price of White items (percentage).',
+    `minpricegreen` INT(11) NULL DEFAULT '800' COMMENT 'Minimum price of Green items (percentage).',
+    `maxpricegreen` INT(11) NULL DEFAULT '1400' COMMENT 'Maximum price of Green items (percentage).',
+    `minpriceblue` INT(11) NULL DEFAULT '1250' COMMENT 'Minimum price of Blue items (percentage).',
+    `maxpriceblue` INT(11) NULL DEFAULT '1750' COMMENT 'Maximum price of Blue items (percentage).',
+    `minpricepurple` INT(11) NULL DEFAULT '2250' COMMENT 'Minimum price of Purple items (percentage).',
+    `maxpricepurple` INT(11) NULL DEFAULT '4550' COMMENT 'Maximum price of Purple items (percentage).',
+    `minpriceorange` INT(11) NULL DEFAULT '3250' COMMENT 'Minimum price of Orange items (percentage).',
+    `maxpriceorange` INT(11) NULL DEFAULT '5550' COMMENT 'Maximum price of Orange items (percentage).',
+    `minpriceyellow` INT(11) NULL DEFAULT '5250' COMMENT 'Minimum price of Yellow items (percentage).',
+    `maxpriceyellow` INT(11) NULL DEFAULT '6550' COMMENT 'Maximum price of Yellow items (percentage).',
+    `minbidpricegrey` INT(11) NULL DEFAULT '70' COMMENT 'Starting bid price of Grey items as a percentage of the randomly chosen buyout price. Default: 70',
+    `maxbidpricegrey` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Grey items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricewhite` INT(11) NULL DEFAULT '70' COMMENT 'Starting bid price of White items as a percentage of the randomly chosen buyout price. Default: 70',
+    `maxbidpricewhite` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of White items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricegreen` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Green items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpricegreen` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Green items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceblue` INT(11) NULL DEFAULT '75' COMMENT 'Starting bid price of Blue items as a percentage of the randomly chosen buyout price. Default: 75',
+    `maxbidpriceblue` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Blue items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpricepurple` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Purple items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpricepurple` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Purple items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceorange` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Orange items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpriceorange` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Orange items as a percentage of the randomly chosen buyout price. Default: 100',
+    `minbidpriceyellow` INT(11) NULL DEFAULT '80' COMMENT 'Starting bid price of Yellow items as a percentage of the randomly chosen buyout price. Default: 80',
+    `maxbidpriceyellow` INT(11) NULL DEFAULT '100' COMMENT 'Starting bid price of Yellow items as a percentage of the randomly chosen buyout price. Default: 100',
+    `maxstackgrey` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackwhite` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackgreen` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackblue` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackpurple` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackorange` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `maxstackyellow` INT(11) NULL DEFAULT '0' COMMENT 'Stack size limits for item qualities - a value of 0 will disable a maximum stack size for that quality, which will allow the bot to create items in stack as large as the item allows.',
+    `buyerpricegrey` INT(11) NULL DEFAULT '1' COMMENT 'Multiplier to vendorprice when buying grey items from auctionhouse',
+    `buyerpricewhite` INT(11) NULL DEFAULT '3' COMMENT 'Multiplier to vendorprice when buying white items from auctionhouse',
+    `buyerpricegreen` INT(11) NULL DEFAULT '5' COMMENT 'Multiplier to vendorprice when buying green items from auctionhouse',
+    `buyerpriceblue` INT(11) NULL DEFAULT '12' COMMENT 'Multiplier to vendorprice when buying blue items from auctionhouse',
+    `buyerpricepurple` INT(11) NULL DEFAULT '15' COMMENT 'Multiplier to vendorprice when buying purple items from auctionhouse',
+    `buyerpriceorange` INT(11) NULL DEFAULT '20' COMMENT 'Multiplier to vendorprice when buying orange items from auctionhouse',
+    `buyerpriceyellow` INT(11) NULL DEFAULT '22' COMMENT 'Multiplier to vendorprice when buying yellow items from auctionhouse',
+    `buyerbiddinginterval` INT(11) NULL DEFAULT '1' COMMENT 'Interval how frequently AHB bids on each AH. Time in minutes',
+    `buyerbidsperinterval` INT(11) NULL DEFAULT '1' COMMENT 'number of bids to put in per bidding interval',
+    PRIMARY KEY (`auctionhouse`)
+)
+ENGINE=InnoDB
+ROW_FORMAT=DEFAULT
+
+insert  into `auctionhousebot`(`auctionhouse`,`name`,`minitems`,`maxitems`,`percentgreytradegoods`,`percentwhitetradegoods`,`percentgreentradegoods`,`percentbluetradegoods`,`percentpurpletradegoods`,`percentorangetradegoods`,`percentyellowtradegoods`,`percentgreyitems`,`percentwhiteitems`,`percentgreenitems`,`percentblueitems`,`percentpurpleitems`,`percentorangeitems`,`percentyellowitems`,`minpricegrey`,`maxpricegrey`,`minpricewhite`,`maxpricewhite`,`minpricegreen`,`maxpricegreen`,`minpriceblue`,`maxpriceblue`,`minpricepurple`,`maxpricepurple`,`minpriceorange`,`maxpriceorange`,`minpriceyellow`,`maxpriceyellow`,`minbidpricegrey`,`maxbidpricegrey`,`minbidpricewhite`,`maxbidpricewhite`,`minbidpricegreen`,`maxbidpricegreen`,`minbidpriceblue`,`maxbidpriceblue`,`minbidpricepurple`,`maxbidpricepurple`,`minbidpriceorange`,`maxbidpriceorange`,`minbidpriceyellow`,`maxbidpriceyellow`,`maxstackgrey`,`maxstackwhite`,`maxstackgreen`,`maxstackblue`,`maxstackpurple`,`maxstackorange`,`maxstackyellow`,`buyerpricegrey`,`buyerpricewhite`,`buyerpricegreen`,`buyerpriceblue`,`buyerpricepurple`,`buyerpriceorange`,`buyerpriceyellow`,`buyerbiddinginterval`,`buyerbidsperinterval`) values
+(2,'Alliance',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1),
+(6,'Horde',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1),
+(7,'Neutral',250,250,0,27,12,10,1,0,0,0,10,30,8,2,0,0,100,150,150,250,800,1400,1250,1750,2250,4550,3250,5550,5250,6550,70,100,70,100,80,100,75,100,80,100,80,100,80,100,0,0,3,2,1,1,1,1,3,5,12,15,20,22,1,1);
\ No newline at end of file
diff --git a/sql/All/setup_npc_teleport.sql b/sql/All/setup_npc_teleport.sql
new file mode 100644
index 0000000..03b9e93
--- /dev/null
+++ b/sql/All/setup_npc_teleport.sql
@@ -0,0 +1,119 @@
+DROP TABLE IF EXISTS `custom_npc_tele_category`;
+CREATE TABLE `custom_npc_tele_category` (
+  `id` int(6) unsigned NOT NULL default '0',
+  `name` varchar(255) NOT NULL default '',
+  `flag` tinyint(3) unsigned NOT NULL default '0',
+  `data0` bigint(20) unsigned NOT NULL default '0',
+  `data1` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_destination`;
+CREATE TABLE `custom_npc_tele_destination` (
+  `id` int(6) unsigned NOT NULL auto_increment,
+  `name` char(100) NOT NULL default '',
+  `pos_X` float NOT NULL default '0',
+  `pos_Y` float NOT NULL default '0',
+  `pos_Z` float NOT NULL default '0',
+  `map` smallint(5) unsigned NOT NULL default '0',
+  `orientation` float NOT NULL default '0',
+  `level` tinyint(3) unsigned NOT NULL default '0',
+  `cost` int(10) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_association`;
+CREATE TABLE `custom_npc_tele_association` (
+  `cat_id` int(6) unsigned NOT NULL default '0',
+  `dest_id` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`cat_id`, `dest_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+TRUNCATE `custom_npc_tele_category`;
+INSERT INTO `custom_npc_tele_category`
+   (`id`, `name`, `flag`, `data0`, `data1`)
+VALUES
+   (1, 'Cities', 0, 1, 0),
+   (2, 'Cities', 0, 2, 0),
+   (3, 'Battlegrounds', 0, 1, 0),
+   (4, 'Battlegrounds', 0, 2, 0),
+   (5, 'Arenas', 0, 0, 0),
+   (6, '[Instances Lvl 1-60]', 0, 0, 0),
+   (7, '[Instances Lvl 60+]', 5, 60, 0),
+   (8, '[Instances Lvl 70+]', 5, 70, 0),
+   (9, 'Destinations MJ', 3, 0, 0);
+
+TRUNCATE `custom_npc_tele_destination`;
+INSERT INTO `custom_npc_tele_destination`
+   (`id`, `name`, `pos_X`, `pos_Y`, `pos_Z`, `map`, `orientation`, `level`, `cost`)
+VALUES
+   (1, 'Alterac Valley', 883.187, -489.375, 96.7618, 30, 3.06932, 0, 0),
+   (2, 'Alterac Valley', -818.155, -623.043, 54.0884, 30, 2.1, 0, 0),
+   (3, 'Arathi Basin', 686.053, 683.165, -12.9149, 529, 0.18, 0, 0),
+   (4, 'Arathi Basin', 1308.68, 1306.03, -9.0107, 529, 3.91285, 0, 0),
+   (5, 'Black Temple', -3610.72, 324.988, 37.4, 530, 3.28298, 0, 0),
+   (6, 'Blackfathom Deeps', 4254.58, 664.74, -29.04, 1, 1.97, 0, 0),
+   (7, 'Blackrock Depths', -7301.03, -913.19, 165.37, 0, 0.08, 0, 0),
+   (8, 'Blackrock Spire', -7535.43, -1212.04, 285.45, 0, 5.29, 0, 0),
+   (9, 'Blackwing Lair', -7665.55, -1102.49, 400.679, 469, 0, 0, 0),
+   (10, 'Caverns of Time', -8173.66, -4746.36, 33.8423, 1, 4.93989, 0, 0),
+   (11, 'Circle of Blood', 2839.44, 5930.17, 11.1002, 530, 3.16284, 0, 0),
+   (12, 'Coilfang Reservoir', 517.288, 6976.28, 32.0072, 530, 0, 0, 0),
+   (13, 'Darnassus', 9947.52, 2482.73, 1316.21, 1, 0, 0, 0),
+   (14, 'Dire Maul', -3982.47, 1127.79, 161.02, 1, 0.05, 0, 0),
+   (15, 'Exodar', -4073.03, -12020.4, -1.47, 530, 0, 0, 0),
+   (16, 'Eye of the Storm', 2487.72, 1609.12, 1224.64, 566, 3.35671, 0, 0),
+   (17, 'Eye of the Storm', 1843.73, 1529.77, 1224.43, 566, 0.297579, 0, 0),
+   (18, 'Goldshire', -9464, 62, 56, 0, 0, 0, 0),
+   (19, 'Gruul\'s Lair', 3539.01, 5082.36, 1.69107, 530, 0, 0, 0),
+   (20, 'Gurubashi', -13261.3, 168.294, 35.0792, 0, 1.00688, 0, 0),
+   (21, 'Hellfire Citadel', -305.816, 3056.4, -2.47318, 530, 2.01, 0, 0),
+   (22, 'Ironforge', -4924.07, -951.95, 501.55, 0, 5.4, 0, 0),
+   (23, 'Isle Of Quel\'Danas', 12947.4, -6893.31, 5.68398, 530, 3.09154, 0, 0),
+   (24, 'Karazhan', -11118.8, -2010.84, 47.0807, 0, 0, 0, 0),
+   (25, 'Maraudon', -1433.33, 2955.34, 96.21, 1, 4.82, 0, 0),
+   (26, 'Molten Core', 1121.45, -454.317, -101.33, 230, 3.5, 0, 0),
+   (27, 'Naxxramas', 3125.18, -3748.02, 136.049, 0, 0, 0, 0),
+   (28, 'Onyxia\'s Lair', -4707.44, -3726.82, 54.6723, 1, 3.8, 0, 0),
+   (29, 'Orgrimmar', 1552.5, -4420.66, 8.94802, 1, 0, 0, 0),
+   (30, 'Razor Hill', 315.721, -4743.4, 10.4867, 1, 0, 0, 0),
+   (31, 'Razorfen Downs', -4645.08, -2470.85, 85.53, 1, 4.39, 0, 0),
+   (32, 'Razorfen Kraul', -4484.04, -1739.4, 86.47, 1, 1.23, 0, 0),
+   (33, 'Ring of Trials', -1999.94, 6581.71, 11.32, 530, 2.3, 0, 0),
+   (34, 'Ruins of Ahn\'Qiraj', -8409.03, 1498.83, 27.3615, 1, 2.49757, 0, 0),
+   (35, 'Scholomance', 1219.01, -2604.66, 85.61, 0, 0.5, 0, 0),
+   (36, 'Shadowfang Keep', -254.47, 1524.68, 76.89, 0, 1.56, 0, 0),
+   (37, 'Shattrath City', -1850.21, 5435.82, -10.9614, 530, 3.40391, 0, 0),
+   (38, 'Silvermoon', 9338.74, -7277.27, 13.7895, 530, 0, 0, 0),
+   (39, 'Stormwind', -8960.14, 516.266, 96.3568, 0, 0, 0, 0),
+   (40, 'Stratholme', 3263.54, -3379.46, 143.59, 0, 0, 0, 0),
+   (41, 'Tempest Keep', 3089.58, 1399.05, 187.653, 530, 4.79407, 0, 0),
+   (42, 'Temple of Ahn\'Qiraj', -8245.84, 1983.74, 129.072, 1, 0.936195, 0, 0),
+   (43, 'The Deadmines', -11212, 1658.58, 25.67, 0, 1.45, 0, 0),
+   (44, 'The Maul', -3761.49, 1133.43, 132.083, 1, 4.57259, 0, 0),
+   (45, 'The Scarlet Monastery', 2843.89, -693.74, 139.32, 0, 5.11, 0, 0),
+   (46, 'The Sunken Temple', -10346.9, -3851.9, -43.41, 0, 6.09, 0, 0),
+   (47, 'The Wailing Caverns', -722.53, -2226.3, 16.94, 1, 2.71, 0, 0),
+   (48, 'Thunder Bluff', -1290, 147.034, 129.682, 1, 4.919, 0, 0),
+   (49, 'Uldaman', -6119.7, -2957.3, 204.11, 0, 0.03, 0, 0),
+   (50, 'Undercity', 1819.71, 238.79, 60.5321, 0, 0, 0, 0),
+   (51, 'Warsong Gulch', 930.851, 1431.57, 345.537, 489, 0.015704, 0, 0),
+   (52, 'Warsong Gulch', 1525.95, 1481.66, 352.001, 489, 3.20756, 0, 0),
+   (53, 'Zul\'Aman', 6846.95, -7954.5, 170.028, 530, 4.61501, 0, 0),
+   (54, 'Zul\'Farrak', -6839.39, -2911.03, 8.87, 1, 0.41, 0, 0),
+   (55, 'Zul\'Gurub', -11916.7, -1212.82, 92.2868, 0, 4.6095, 0, 0),
+   (56, 'Ile des MJ', 16254, 16276.9, 14.5082, 1, 1.70269, 0, 0);
+
+TRUNCATE `custom_npc_tele_association`;
+INSERT INTO `custom_npc_tele_association`
+  (`cat_id`, `dest_id`)
+VALUES
+  (1, 13), (1, 15), (1, 18), (1, 22), (1, 23), (1, 37), (1, 39), (2, 23), (2, 29), (2, 30), (2, 37), (2, 38), (2, 48), (2, 50), (3, 1), (3, 4), (3, 16), (3, 52), (4, 2), (4, 3), (4, 17), (4, 51), (5, 11), (5, 20), (5, 33), (5, 44), (6, 6), (6, 7), (6, 8), (6, 14), (6, 25), (6, 31), (6, 32), (6, 35), (6, 36), (6, 40), (6, 43), (6, 45), (6, 46), (6, 47), (6, 49), (6, 54), (7, 9), (7, 26), (7, 27), (7, 28), (7, 34), (7, 42), (7, 55), (8, 5), (8, 10), (8, 12), (8, 19), (8, 21), (8, 24), (8, 41), (8, 53), (9, 56);
+
+-- `npc_text`
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100000, 'Choose your Category.'),
+   (100001, 'Choose your Destination.');
+
+-- `creature_template`
+INSERT INTO `creature_template` VALUES (100000, 0, 0, 0, 0, 0, 26502, 0, 0, 0, 'Abisal Vortex', '', '', 0, 83, 83, 0, 35, 35, 1, 1, 1.14286, 2, 1, 509, 683, 0, 805, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 371, 535, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 'npc_teleport', 1);
diff --git a/sql/All/world_argenttournament.sql b/sql/All/world_argenttournament.sql
new file mode 100644
index 0000000..4379f9d
--- /dev/null
+++ b/sql/All/world_argenttournament.sql
@@ -0,0 +1,425 @@
+-- Horde
+-- Premiere quete : Le tournoi d'argent
+DELETE FROM `creature_questrelation` WHERE `quest`=13668;
+INSERT INTO `creature_questrelation` (`id`, `quest`) VALUES (33817, 13668);
+-- Icone monture de la horde
+UPDATE `creature_template` SET IconName='vehichleCursor' WHERE entry IN (33842,33796,33798,33791,33792,33799);
+-- Vehicule id des monture
+UPDATE `creature_template` SET `VehicleId`=349 WHERE entry IN (33320,33321,33322,33323,33324);
+-- Vitesse des montures
+UPDATE creature_template SET speed_run = 1.571429 WHERE entry IN (33844, 33320, 33321, 33322, 33323, 33324);
+-- Spells des montures
+UPDATE `creature_template` SET `spell1`=62544, `spell2`=62575, `spell3`=62960, `spell4`=62552, `spell5`=64077 WHERE `entry` IN (33844, 33320, 33321, 33322, 33323, 33324);
+-- Immune to Confuse
+UPDATE `creature_template` SET `mechanic_immune_mask` = `mechanic_immune_mask` | 2 WHERE `entry` IN (33844, 33320, 33321, 33322, 33323, 33324);
+
+-- Ajouts des spellclick_spells pour les montures Ã  l'Ã©curie
+DELETE FROM `npc_spellclick_spells` WHERE npc_entry IN (33842,33796,33798,33791,33792,33799);
+INSERT INTO `npc_spellclick_spells` (`npc_entry`, `spell_id`, `quest_start`, `quest_start_active`, `quest_end`, `cast_flags`, `aura_required`, `aura_forbidden`, `user_type`) VALUES
+(33842, 63791, 13668, 1, 13680, 1, 0, 0, 0), -- Aspirant
+-- Orgrimmar
+(33799, 62783, 13726, 0, 0, 1, 0, 0, 0), -- Champion Of Orgrimmar
+(33799, 62783, 13691, 0, 0, 1, 0, 0, 0), -- A Valiant Of Orgrimmar
+(33799, 62783, 13707, 0, 0, 1, 0, 0, 0), -- Valiant Of Orgrimmar
+-- Sen'jin
+(33796, 62784, 13727, 0, 0, 1, 0, 0, 0), -- Champion Of Sen'jin
+(33796, 62784, 13693, 0, 0, 1, 0, 0, 0), -- A Valiant Of Sen'jin
+(33796, 62784, 13708, 0, 0, 1, 0, 0, 0), -- Valiant Of Sen'jin
+-- Thunder Bluff
+(33792, 62785, 13728, 0, 0, 1, 0, 0, 0), -- Champion Of Thunder Bluff
+(33792, 62785, 13694, 0, 0, 1, 0, 0, 0), -- A Valiant Of Thunder Bluff
+(33792, 62785, 13709, 0, 0, 1, 0, 0, 0), -- Valiant Of Thunder Bluff
+-- Undercity
+(33798, 62787, 13729, 0, 0, 1, 0, 0, 0), -- Champion Of Undercity
+(33798, 62787, 13695, 0, 0, 1, 0, 0, 0), -- A Valiant Of Undercity
+(33798, 62787, 13710, 0, 0, 1, 0, 0, 0), -- Valiant Of Undercity
+-- Silvermoon
+(33791, 62786, 13731, 0, 0, 1, 0, 0, 0), -- Champion Of Silvermoon
+(33791, 62786, 13696, 0, 0, 1, 0, 0, 0), -- A Valiant Of Silvermoon
+(33791, 62786, 13711, 0, 0, 1, 0, 0, 0); -- Valiant Of Silvermoon
+
+-- Horde ArgentTournament
+	-- Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13668;
+UPDATE `quest_template` SET `PrevQuestId`=13668, `NextQuestId`=13678, `ExclusiveGroup`=-13829, `NextQuestInChain`=0 WHERE `entry` IN (13829, 13839, 13838);
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13680 WHERE `entry`=13678;
+	-- Daily Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=-13678, `NextQuestId`=0, `ExclusiveGroup`=13673, `NextQuestInChain`=0 WHERE `entry`=13673;
+UPDATE `quest_template` SET `PrevQuestId`=-13678, `NextQuestId`=0, `ExclusiveGroup`=13673, `NextQuestInChain`=0 WHERE `entry`=13675;
+UPDATE `quest_template` SET `PrevQuestId`=-13678, `NextQuestId`=0, `ExclusiveGroup`=13673, `NextQuestInChain`=0 WHERE `entry`=13674;
+UPDATE `quest_template` SET `PrevQuestId`=-13678, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13676;
+UPDATE `quest_template` SET `PrevQuestId`=-13678, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13677;
+	-- End Of Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13678, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13680;
+	-- Valiant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13680 WHERE `entry` IN (13691, 13693, 13694, 13695, 13696);
+
+UPDATE `quest_template` SET `RequiredRaces`=2, `NextQuestId`=13697, `NextQuestInChain`=13697, `ExclusiveGroup`=13691 WHERE `entry`=13691;
+UPDATE `quest_template` SET `RequiredRaces`=128, `NextQuestId`=13719, `NextQuestInChain`=13719, `ExclusiveGroup`=13693 WHERE `entry`=13693;
+UPDATE `quest_template` SET `RequiredRaces`=32, `NextQuestId`=13720, `NextQuestInChain`=13720, `ExclusiveGroup`=13694 WHERE `entry`=13694;
+UPDATE `quest_template` SET `RequiredRaces`=16, `NextQuestId`=13721, `NextQuestInChain`=13721, `ExclusiveGroup`=13695 WHERE `entry`=13695;
+UPDATE `quest_template` SET `RequiredRaces`=512, `NextQuestId`=13722, `NextQuestInChain`=13722, `ExclusiveGroup`=13696 WHERE `entry`=13696;
+
+-- INFOS DEV -- Premiere Quete (AdmissibilitÃ©) : 13687 -- Deuxieme Quete (Champion) : 13701
+UPDATE `quest_template` SET `PrevQuestId`=13701 WHERE `entry` IN (13707, 13708, 13709, 13710, 13711); -- TOScript into the core (check of 13687)
+
+UPDATE `quest_template` SET `NextQuestId`=13697, `NextQuestInChain`=13697, `ExclusiveGroup`=13691 WHERE `entry`=13707;
+UPDATE `quest_template` SET `NextQuestId`=13719, `NextQuestInChain`=13719, `ExclusiveGroup`=13693 WHERE `entry`=13708;
+UPDATE `quest_template` SET `NextQuestId`=13720, `NextQuestInChain`=13720, `ExclusiveGroup`=13694 WHERE `entry`=13709;
+UPDATE `quest_template` SET `NextQuestId`=13721, `NextQuestInChain`=13721, `ExclusiveGroup`=13695 WHERE `entry`=13710;
+UPDATE `quest_template` SET `NextQuestId`=13722, `NextQuestInChain`=13722, `ExclusiveGroup`=13696 WHERE `entry`=13711;
+
+UPDATE `quest_template` SET `PrevQuestId`=0, `ExclusiveGroup`=0 WHERE `entry` IN (13697, 13719, 13720, 13721, 13722);
+
+UPDATE `quest_template` SET `NextQuestId`=13726, `NextQuestInChain`=13726 WHERE `entry`=13697;
+UPDATE `quest_template` SET `NextQuestId`=13727, `NextQuestInChain`=13727  WHERE `entry`=13719;
+UPDATE `quest_template` SET `NextQuestId`=13728, `NextQuestInChain`=13728  WHERE `entry`=13720;
+UPDATE `quest_template` SET `NextQuestId`=13729, `NextQuestInChain`=13729  WHERE `entry`=13721;
+UPDATE `quest_template` SET `NextQuestId`=13731, `NextQuestInChain`=13731  WHERE `entry`=13722;
+	-- Valiant Daily Quests
+		-- A Blade Fit For A Champion
+		-- The Edge Of Winter
+		-- A Worthy Weapon
+UPDATE `quest_template` SET `PrevQuestId`=-13697, `NextQuestId`=0, `ExclusiveGroup`=13762, `NextQuestInChain`=0 WHERE `entry` IN (13762, 13763, 13764);
+UPDATE `quest_template` SET `PrevQuestId`=-13719, `NextQuestId`=0, `ExclusiveGroup`=13768, `NextQuestInChain`=0 WHERE `entry` IN (13768, 13769, 13770);
+UPDATE `quest_template` SET `PrevQuestId`=-13720, `NextQuestId`=0, `ExclusiveGroup`=13773, `NextQuestInChain`=0 WHERE `entry` IN (13773, 13774, 13775);
+UPDATE `quest_template` SET `PrevQuestId`=-13721, `NextQuestId`=0, `ExclusiveGroup`=13778, `NextQuestInChain`=0 WHERE `entry` IN (13778, 13779, 13780);
+UPDATE `quest_template` SET `PrevQuestId`=-13722, `NextQuestId`=0, `ExclusiveGroup`=13783, `NextQuestInChain`=0 WHERE `entry` IN (13783, 13784, 13785);
+		-- A Valiant's Field Training
+		-- The Grand Melee
+		-- At The Enemy's Gates
+UPDATE `quest_template` SET `PrevQuestId`=-13697, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13765, 13767, 13856);
+UPDATE `quest_template` SET `PrevQuestId`=-13719, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13771, 13772, 13857);
+UPDATE `quest_template` SET `PrevQuestId`=-13720, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13776, 13777, 13858);
+UPDATE `quest_template` SET `PrevQuestId`=-13721, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13781, 13782, 13860);
+UPDATE `quest_template` SET `PrevQuestId`=-13722, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13786, 13787, 13859);
+	-- End Of Valiant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13697, `NextQuestId`=13736, `ExclusiveGroup`=0, `NextQuestInChain`=13736 WHERE `entry`=13726;
+UPDATE `quest_template` SET `PrevQuestId`=13719, `NextQuestId`=13737, `ExclusiveGroup`=0, `NextQuestInChain`=13737 WHERE `entry`=13727;
+UPDATE `quest_template` SET `PrevQuestId`=13720, `NextQuestId`=13738, `ExclusiveGroup`=0, `NextQuestInChain`=13738 WHERE `entry`=13728;
+UPDATE `quest_template` SET `PrevQuestId`=13721, `NextQuestId`=13739, `ExclusiveGroup`=0, `NextQuestInChain`=13739 WHERE `entry`=13729;
+UPDATE `quest_template` SET `PrevQuestId`=13722, `NextQuestId`=13740, `ExclusiveGroup`=0, `NextQuestInChain`=13740 WHERE `entry`=13731;
+	-- A Champion Rises (Final Quest of a Branch)
+UPDATE `quest_template` SET `PrevQuestId`=13726, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13736;
+UPDATE `quest_template` SET `PrevQuestId`=13727, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13737;
+UPDATE `quest_template` SET `PrevQuestId`=13728, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13738;
+UPDATE `quest_template` SET `PrevQuestId`=13729, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13739;
+UPDATE `quest_template` SET `PrevQuestId`=13740, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13740;
+
+-- Debug Quest Requirements
+UPDATE `quest_template` SET `RequiredRaces`=690 WHERE `entry` IN (13697, 13719, 13720, 13721, 13722);
+UPDATE `quest_template` SET `RequiredRaces`=690 WHERE `entry` IN (13726, 13727, 13728, 13729, 13731);
+UPDATE `quest_template` SET `RequiredRaces`=690 WHERE `entry` IN (13736, 13737, 13738, 13739, 13740);
+
+-- Alliance
+-- Premiere quete : Le tournoi d'argent
+DELETE FROM `creature_questrelation` WHERE `quest`=13667;
+INSERT INTO `creature_questrelation` (`id`, `quest`) VALUES (33817, 13667);
+-- Icone monture de la horde
+UPDATE `creature_template` SET IconName='vehichleCursor' WHERE `entry` IN (33843,33794,33800,33793,33795,33790);
+-- Vehicule id des montures
+UPDATE `creature_template` SET `VehicleId`=349 WHERE `entry` IN (33319,33317,33318,33217,33316);
+-- Vitesse des montures
+UPDATE `creature_template` SET `speed_run`= 1.571429 WHERE `entry` IN (33845, 33319, 33317, 33318, 33217, 33316);
+-- Spells des montures
+UPDATE `creature_template` SET `spell1`=62544, `spell2`=62575, `spell3`=62960, `spell4`=62552, `spell5`=64077 WHERE `entry` IN (33845, 33319, 33317, 33318, 33217, 33316);
+-- Immune to Confuse
+UPDATE `creature_template` SET `mechanic_immune_mask` = `mechanic_immune_mask` | 2 WHERE `entry` IN (33845, 33319, 33317, 33318, 33217, 33316);
+
+-- Ajouts des spellclick_spells pour les montures Ã  l'Ã©curie
+DELETE FROM `npc_spellclick_spells` WHERE npc_entry IN (33843,33800,33795,33790,33793,33794);
+
+INSERT INTO `npc_spellclick_spells` (`npc_entry`, `spell_id`, `quest_start`, `quest_start_active`, `quest_end`, `cast_flags`, `aura_required`, `aura_forbidden`, `user_type`) VALUES
+(33843, 63792, 13667, 1, 13679, 1, 0, 0, 0), -- Aspirant
+-- Darnassus
+(33794, 62782, 13725, 0, 0, 1, 0, 0, 0), -- Champion Of Darnassus
+(33794, 62782, 13689, 0, 0, 1, 0, 0, 0), -- A Valiant Of Darnassus
+(33794, 62782, 13706, 0, 0, 1, 0, 0, 0), -- Valiant Of Darnassus
+-- Hurlevent
+(33800, 62774, 13699, 0, 0, 1, 0, 0, 0), -- Champion Of Sen'jin
+(33800, 62774, 13593, 0, 0, 1, 0, 0, 0), -- A Valiant Of Sen'jin
+(33800, 62774, 13684, 0, 0, 1, 0, 0, 0), -- Valiant Of Sen'jin
+-- Gnomregan
+(33793, 62780, 13723, 0, 0, 1, 0, 0, 0), -- Champion Of Thunder Bluff
+(33793, 62780, 13688, 0, 0, 1, 0, 0, 0), -- A Valiant Of Thunder Bluff
+(33793, 62780, 13704, 0, 0, 1, 0, 0, 0), -- Valiant Of Thunder Bluff
+-- Forgefer
+(33795, 62779, 13713, 0, 0, 1, 0, 0, 0), -- Champion Of Forgefer
+(33795, 62779, 13685, 0, 0, 1, 0, 0, 0), -- A Valiant Of Undercity
+(33795, 62779, 13703, 0, 0, 1, 0, 0, 0), -- Valiant Of Forgefer
+-- Exodar
+(33790, 62781, 13724, 0, 0, 1, 0, 0, 0), -- Champion Of Exodar
+(33790, 62781, 13690, 0, 0, 1, 0, 0, 0), -- A Valiant Of Exodar
+(33790, 62781, 13705, 0, 0, 1, 0, 0, 0); -- Valiant Of Exodar
+
+
+-- Alliance ArgentTournament
+	-- Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13667;
+UPDATE `quest_template` SET `PrevQuestId`=13667, `NextQuestId`=13672, `ExclusiveGroup`=-13828, `NextQuestInChain`=0 WHERE `entry` IN (13828, 13837, 13835);
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13679 WHERE `entry`=13672;
+	-- Daily Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=-13672, `NextQuestId`=0, `ExclusiveGroup`=13666, `NextQuestInChain`=0 WHERE `entry`=13666;
+UPDATE `quest_template` SET `PrevQuestId`=-13672, `NextQuestId`=0, `ExclusiveGroup`=13666, `NextQuestInChain`=0 WHERE `entry`=13670;
+UPDATE `quest_template` SET `PrevQuestId`=-13672, `NextQuestId`=0, `ExclusiveGroup`=13666, `NextQuestInChain`=0 WHERE `entry`=13669;
+UPDATE `quest_template` SET `PrevQuestId`=-13672, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13671;
+UPDATE `quest_template` SET `PrevQuestId`=-13672, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13625;
+	-- End Of Aspirant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13672, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13679;
+	-- Valiant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13679 WHERE `entry` IN (13684, 13685, 13689, 13688, 13690);
+
+UPDATE `quest_template` SET `RequiredRaces`=1, `NextQuestId`=13718, `NextQuestInChain`=13718, `ExclusiveGroup`=13684 WHERE `entry`=13684;
+UPDATE `quest_template` SET `RequiredRaces`=4, `NextQuestId`=13714, `NextQuestInChain`=13714, `ExclusiveGroup`=13685 WHERE `entry`=13685;
+UPDATE `quest_template` SET `RequiredRaces`=8, `NextQuestId`=13717, `NextQuestInChain`=13717, `ExclusiveGroup`=13689 WHERE `entry`=13689;
+UPDATE `quest_template` SET `RequiredRaces`=64, `NextQuestId`=13715, `NextQuestInChain`=13715, `ExclusiveGroup`=13688 WHERE `entry`=13688;
+UPDATE `quest_template` SET `RequiredRaces`=1024, `NextQuestId`=13716, `NextQuestInChain`=13716, `ExclusiveGroup`=13690 WHERE `entry`=13690;
+
+-- INFOS DEV -- Premiere Quete (AdmissibilitÃ©) : 13686 -- Deuxieme Quete (Champion) : 13700
+UPDATE `quest_template` SET `PrevQuestId`=13700 WHERE `entry` IN (13593, 13703, 13706, 13704, 13705); -- TOScript into the core (check of 13686)
+
+UPDATE `quest_template` SET `NextQuestId`=13718, `NextQuestInChain`=13718, `ExclusiveGroup`=13718 WHERE `entry`=13593;
+UPDATE `quest_template` SET `NextQuestId`=13714, `NextQuestInChain`=13714, `ExclusiveGroup`=13714 WHERE `entry`=13703;
+UPDATE `quest_template` SET `NextQuestId`=13717, `NextQuestInChain`=13717, `ExclusiveGroup`=13717 WHERE `entry`=13706;
+UPDATE `quest_template` SET `NextQuestId`=13715, `NextQuestInChain`=13715, `ExclusiveGroup`=13715 WHERE `entry`=13704;
+UPDATE `quest_template` SET `NextQuestId`=13716, `NextQuestInChain`=13716, `ExclusiveGroup`=13716 WHERE `entry`=13705;
+
+UPDATE `quest_template` SET `PrevQuestId`=0, `ExclusiveGroup`=0 WHERE `entry` IN (13718, 13714, 13717, 13715, 13716);
+
+UPDATE `quest_template` SET `NextQuestId`=13699, `NextQuestInChain`=13699 WHERE `entry`=13718;
+UPDATE `quest_template` SET `NextQuestId`=13713, `NextQuestInChain`=13713  WHERE `entry`=13714;
+UPDATE `quest_template` SET `NextQuestId`=13725, `NextQuestInChain`=13725  WHERE `entry`=13717;
+UPDATE `quest_template` SET `NextQuestId`=13723, `NextQuestInChain`=13723  WHERE `entry`=13715;
+UPDATE `quest_template` SET `NextQuestId`=13724, `NextQuestInChain`=13724  WHERE `entry`=13716;
+	-- Valiant Daily Quests
+		-- A Blade Fit For A Champion
+		-- The Edge Of Winter
+		-- A Worthy Weapon
+UPDATE `quest_template` SET `PrevQuestId`=-13718, `NextQuestId`=0, `ExclusiveGroup`=13603, `NextQuestInChain`=0 WHERE `entry` IN (13603, 13600, 13616);
+UPDATE `quest_template` SET `PrevQuestId`=-13714, `NextQuestId`=0, `ExclusiveGroup`=13741, `NextQuestInChain`=0 WHERE `entry` IN (13741, 13742, 13743);
+UPDATE `quest_template` SET `PrevQuestId`=-13717, `NextQuestId`=0, `ExclusiveGroup`=13757, `NextQuestInChain`=0 WHERE `entry` IN (13757, 13758, 13759);
+UPDATE `quest_template` SET `PrevQuestId`=-13715, `NextQuestId`=0, `ExclusiveGroup`=13746, `NextQuestInChain`=0 WHERE `entry` IN (13746, 13747, 13748);
+UPDATE `quest_template` SET `PrevQuestId`=-13716, `NextQuestId`=0, `ExclusiveGroup`=13752, `NextQuestInChain`=0 WHERE `entry` IN (13752, 13753, 13754);
+		-- A Valiant's Field Training
+		-- The Grand Melee
+		-- At The Enemy's Gates
+UPDATE `quest_template` SET `PrevQuestId`=-13718, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13592, 13665, 13847);
+UPDATE `quest_template` SET `PrevQuestId`=-13714, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13744, 13745, 13851);
+UPDATE `quest_template` SET `PrevQuestId`=-13717, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13760, 13761, 13855);
+UPDATE `quest_template` SET `PrevQuestId`=-13715, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13749, 13750, 13852);
+UPDATE `quest_template` SET `PrevQuestId`=-13716, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry` IN (13755, 13756, 13854);
+	-- End Of Valiant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13718, `NextQuestId`=13702, `ExclusiveGroup`=0, `NextQuestInChain`=13702 WHERE `entry`=13699;
+UPDATE `quest_template` SET `PrevQuestId`=13714, `NextQuestId`=13732, `ExclusiveGroup`=0, `NextQuestInChain`=13732 WHERE `entry`=13713;
+UPDATE `quest_template` SET `PrevQuestId`=13717, `NextQuestId`=13735, `ExclusiveGroup`=0, `NextQuestInChain`=13735 WHERE `entry`=13725;
+UPDATE `quest_template` SET `PrevQuestId`=13715, `NextQuestId`=13733, `ExclusiveGroup`=0, `NextQuestInChain`=13733 WHERE `entry`=13723;
+UPDATE `quest_template` SET `PrevQuestId`=13716, `NextQuestId`=13734, `ExclusiveGroup`=0, `NextQuestInChain`=13734 WHERE `entry`=13724;
+	-- A Champion Rises (Final Quest of a Branch)
+UPDATE `quest_template` SET `PrevQuestId`=13699, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13702;
+UPDATE `quest_template` SET `PrevQuestId`=13713, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13732;
+UPDATE `quest_template` SET `PrevQuestId`=13725, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13735;
+UPDATE `quest_template` SET `PrevQuestId`=13723, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13733;
+UPDATE `quest_template` SET `PrevQuestId`=13734, `NextQuestId`=13794, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13734;
+
+-- Debug Quest Requirements
+UPDATE `quest_template` SET `RequiredRaces`=1101 WHERE `entry` IN (13718, 13714, 13717, 13715, 13716);
+UPDATE `quest_template` SET `RequiredRaces`=1101 WHERE `entry` IN (13699, 13713, 13725, 13723, 13724);
+UPDATE `quest_template` SET `RequiredRaces`=1101 WHERE `entry` IN (13702, 13732, 13735, 13733, 13734);
+
+
+-- Black Night chain
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=13641, `ExclusiveGroup`=13633, `NextQuestInChain`=13641 WHERE `entry` IN (13633, 13634);
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13643 WHERE `entry`=13641;
+UPDATE `quest_template` SET `PrevQuestId`=13641, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13654 WHERE `entry`=13643;
+UPDATE `quest_template` SET `PrevQuestId`=13643, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13663 WHERE `entry`=13654;
+UPDATE `quest_template` SET `PrevQuestId`=13654, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=13664 WHERE `entry`=13663;
+UPDATE `quest_template` SET `PrevQuestId`=13663, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=14016 WHERE `entry`=13664;
+UPDATE `quest_template` SET `PrevQuestId`=13664, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=14017 WHERE `entry`=14016;
+UPDATE `quest_template` SET `PrevQuestId`=14016, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=14017;
+
+-- Champion Dailies
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13794; -- Eadric the Pure -- Works yet, but might bug with The Scourgebane
+UPDATE `quest_template` SET `PrevQuestId`=0, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13795; -- The Scourgebane
+	-- Among The Champions
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13790; -- Alliance Among The Champions
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13793; -- Alliance DK Among The Champions
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13811; -- Horde Among The Champions
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13814; -- Horde DK Among The Champions
+	-- Battle Before The Citadel
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13861; -- Alliance Battle Before The Citadel
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13864; -- Alliance DK Battle Before The Citadel
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13862; -- Horde Battle Before The Citadel
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13863; -- Horde DK Battle Before The Citadel
+	-- Taking Battle To The Enemy
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13789; -- Alliance Taking Battle To The Enemy
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13791; -- Alliance DK Taking Battle To The Enemy
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13810; -- Horde Taking Battle To The Enemy
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13813; -- Horde DK Taking Battle To The Enemy
+	-- Threat From Above
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13682; -- Alliance Threat From Above
+UPDATE `quest_template` SET `RequiredRaces`=1101, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13788; -- Alliance DK Threat From Above
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13794, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13809; -- Horde Threat From Above
+UPDATE `quest_template` SET `RequiredRaces`=690, `PrevQuestId`=13795, `NextQuestId`=0, `ExclusiveGroup`=0, `NextQuestInChain`=0 WHERE `entry`=13812; -- Horde DK Threat From Above
+
+-- Crusader dailies
+	-- Mistcaller Yngvar
+	-- Drottinn Hrothgar
+	-- Ornolf The Scarred
+	-- Deathspeaker Kharos
+UPDATE `quest_template` SET `ExclusiveGroup`=14102, `NextQuestId`=0, `NextQuestInChain`=0 WHERE `entry` IN (14102, 14101, 14104, 14105);
+	-- The Fate Of The Fallen
+	-- Get Kraken!
+	-- Identifying the Remains
+UPDATE `quest_template` SET `ExclusiveGroup`=14107, `NextQuestId`=0, `NextQuestInChain`=0 WHERE `entry` IN (14107, 14108, 14095);
+
+-- Covenant Quests
+UPDATE `quest_template` SET `PrevQuestId`=13700, `RequiredMinRepFaction`=1094, `RequiredMinRepValue`=42000, `NextQuestId`=0, `NextQuestInChain`=0 WHERE `entry` IN (14112, 14076, 14090, 14096, 14152, 14080, 14077, 14074); -- Alliance
+UPDATE `quest_template` SET `PrevQuestId`=13701, `RequiredMinRepFaction`=1124, `RequiredMinRepValue`=42000, `NextQuestId`=0, `NextQuestInChain`=0 WHERE `entry` IN (14145, 14092, 14141, 14142, 14136, 14140, 14144, 14143); -- Horde
+	-- What Do You Feed A Yeti, Anyway?
+	-- Breakfast Of Champions
+	-- Gormok Wants His Snobolds
+UPDATE `quest_template` SET `ExclusiveGroup`=14112 WHERE `entry` IN (14112, 14145, 14076, 14092, 14090, 14141); -- A1, H1, A2, H2, A3, H3
+	-- You've Really Done It This Time, Kul
+	--
+	-- Rescue At Sea
+	-- Stop The Agressors
+	-- The Light's Mercy
+	-- A Leg Up
+UPDATE `quest_template` SET `ExclusiveGroup`=14152 WHERE `entry` IN (14152, 14136, 14080, 14140, 14077, 14144, 14074, 14143); -- A1, H1, A2, H2, A3, H3, A4, H4
+
+-- Champion Marker
+UPDATE `quest_template` SET `NextQuestId`=13846, `ExclusiveGroup`=13700 WHERE `entry` IN (13700, 13701); -- Alliance, Horde
+
+-- Contributin' To The Cause
+UPDATE `quest_template` SET `RequiredMaxRepFaction`=1106, `RequiredMaxRepValue`=42000 WHERE `entry`=13846;
+
+-- Goblin Dailies Removing
+	-- The Blastbolt Brothers
+	-- A Chip Off the Ulduar Block
+	-- Jack Me Some Lumber
+DELETE FROM `creature_questrelation` WHERE `quest` IN (13820, 13681, 13627);
+
+-- DK Quests Restrictions
+	-- The Scourgebane
+	-- Taking Battle To The Enemy (A, H)
+	-- Threat From Above (A, H)
+	-- Among the Champions (A, H)
+	-- Battle Before The Citadel (A, H)
+UPDATE `quest_template` SET `SkillOrClassMask`=-32 WHERE `entry` IN (13795, 13791, 13813, 13788, 13812, 13793, 13814, 13864, 13863);
+-- Non DK Quests Restrictions
+	-- Eadric The Pure
+	-- Taking Battle To The Enemy (A, H)
+	-- Threat From Above (A, H)
+	-- Among the Champions (A, H)
+	-- Battle Before The Citadel (A, H)
+UPDATE `quest_template` SET `SkillOrClassMask`=-1503 WHERE `entry` IN (13794, 13788, 13789, 13810, 13682, 13809, 13790, 13811, 13861, 13862);
+
+-- Teleports Locations
+DELETE FROM `spell_target_position` WHERE `id` IN (63986,63987);
+INSERT INTO `spell_target_position` (`id`,`target_map`,`target_position_x`,`target_position_y`,`target_position_z`,`target_orientation`) VALUES
+(63986,571,8574.87,700.595,547.29,5.48),
+(63987,571,8460,700,547.4,3.839);
+
+-- Armor Modificator set to null for Targets
+UPDATE `creature_template` SET `Armor_mod`=0 WHERE `entry` IN (33243, 33272, 33229);
+
+-- Add Scripts to NPCs
+UPDATE `creature_template` SET `ScriptName`='npc_quest_givers_argent_tournament' WHERE `entry` IN (33593, 33592, 33225, 33312, 33335, 33379, 33373, 33361, 33403, 33372);
+UPDATE `creature_template` SET `ScriptName`='npc_quest_givers_for_crusaders' WHERE `entry` IN (34882, 35094);
+UPDATE `creature_template` SET `ScriptName`='npc_crusader_rhydalla' WHERE `entry`=33417;
+UPDATE `creature_template` SET `ScriptName`='npc_eadric_the_pure' WHERE `entry`=33759;
+UPDATE `creature_template` SET `ScriptName`='npc_crok_scourgebane' WHERE `entry`=33762;
+UPDATE `creature_template` SET `ScriptName`='npc_valis_windchaser' WHERE `entry`=33974;
+UPDATE `creature_template` SET `ScriptName`='npc_rugan_steelbelly' WHERE `entry`=33972;
+UPDATE `creature_template` SET `ScriptName`='npc_jeran_lockwood' WHERE `entry`=33973;
+UPDATE `creature_template` SET `ScriptName`='npc_training_dummy_argent' WHERE `entry`=33229;
+UPDATE `creature_template` SET `ScriptName`='npc_training_dummy_argent' WHERE `entry`=33272;
+UPDATE `creature_template` SET `ScriptName`='npc_training_dummy_argent' WHERE `entry`=33243;
+
+-- Debug QuestRelation A2
+DELETE FROM `creature_questrelation` WHERE `quest` IN (13828, 13672, 13679, 13684, 13685, 13689, 13688, 13690);
+INSERT `creature_questrelation` (`id`, `quest`) VALUES (33625, 13828), (33625, 13672), (33625, 13679), (33625, 13684), (33625, 13685), (33625,13689), (33625, 13688), (33625, 13690);
+
+-- Debug QuestRelation H2
+DELETE FROM `creature_questrelation` WHERE `quest` IN (13691, 13693, 13694, 13695, 13696, 13829, 13680, 13678);
+INSERT `creature_questrelation` (`id`, `quest`) VALUES (33542, 13691), (33542, 13693), (33542, 13694), (33542, 13695), (33542, 13696), (33542,13829), (33542, 13680), (33542, 13678);
+
+-- Quest 13666 & 13673:  Une lame digne d'un champion!
+-- Lake Frog
+-- Maiden Of Ahswood Lake
+UPDATE `creature_template` SET `ScriptName` = 'npc_lake_frog' WHERE `creature_template`.`entry` =33211 LIMIT 1 ;
+UPDATE `creature_template` SET `npcflag` = `npcflag` | 1, `ScriptName` = 'npc_maiden_of_ashwood_lake' WHERE `creature_template`.`entry` =33220;
+-- frog speed from sniff
+UPDATE creature_template SET speed_run = 1 WHERE entry = 33211;
+UPDATE creature_template SET speed_walk = 1.6 WHERE entry = 33211;
+
+-- Quest : Le fil de l'hiver
+DELETE FROM creature WHERE guid = '336364';
+INSERT INTO creature VALUES  (336364,33289,571,1,1,0,0,5136.74,-83.3769,347.326,1.44434,300,0,0,12600,3994,0,0,0,0,0);
+DELETE FROM `creature_loot_template` WHERE `entry`=33289 AND `item`=45005;
+INSERT INTO `creature_loot_template` (`entry`, `item`, `ChanceOrQuestChance`) VALUES (33289, 45005, -100);
+
+-- Quete : Une arme remarquable
+DELETE FROM `script_texts` WHERE `entry` IN (-1850000,-1850001,-1850002,-1850003);
+INSERT INTO `script_texts` (`npc_entry`, `entry`, `content_default`, `content_loc2`,`comment`) VALUES
+(0, -1850000, 'Oh, it\'s winter hyacinths? For me?','Oh, it\'s winter hyacinths? For me?',''),
+(0, -1850001, 'I had not brought flowers here for so long.','I had not brought flowers here for so long.',''),
+(0, -1850002, 'The lake is a very lonely place for some years. Travelers no longer come, and evil has invaded the waters.','The lake is a very lonely place for some years. Travelers no longer come, and evil has invaded the waters.',''),
+(0, -1850003, 'Your gift reveals a rare kindness, traveler. I beg you, take this blade as a token of my gratitude. Long ago, another passenger who had left here, but I do not need.','Your gift reveals a rare kindness, traveler. I beg you, take this blade as a token of my gratitude. Long ago, another passenger who had left here, but I do not need.','');
+DELETE FROM `event_scripts` WHERE `id`=20990;
+INSERT INTO `event_scripts` (`id`, `delay`, `command`, `datalong`, `datalong2`, `x`, `y`, `z`, `o`) VALUES (20990, 0, 10, 33273, 42000, 4602.977, -1600.141, 156.7834, 0.7504916);
+UPDATE `creature_template` SET `InhabitType`=5, `ScriptName`='npc_maiden_of_drak_mar' WHERE `entry`=33273;
+DELETE FROM `creature_template_addon` WHERE `entry`=33273;
+INSERT INTO `creature_template_addon` (`entry`, `emote`) VALUES (33273, 13); -- 13 = EMOTE_STATE_SIT
+
+-- Quete Entrainement sur le terrain:
+UPDATE `creature_template` SET `faction_A`=16,`faction_H`=16 WHERE entry IN (29720,29719,29722);
+INSERT INTO `creature` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`,`npcflag`,`unit_flags`, `dynamicflags`) VALUES
+(NULL, 29720, 571, 1, 1, 0, 0, 8562.48, 2771.93, 759.958, 6.10672, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8584.64, 2760.8, 759.958, 2.59599, 300, 15, 0, 12600, 0, 0, 1,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8617.49, 2735.11, 759.958, 2.32895, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8420.8, 2688.71, 759.957, 1.33806, 300, 15, 0, 12600, 0, 0, 1,0,0,0),
+(NULL, 29719, 571, 1, 1, 0, 0, 8417.11, 2641.07, 759.957, 1.57604, 300, 15, 0, 12600, 0, 0, 1,0,0,0),
+(NULL, 29719, 571, 1, 1, 0, 0, 8435.89, 2596.91, 759.957, 2.30577, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8477.25, 2565.16, 759.957, 2.51783, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29719, 571, 1, 1, 0, 0, 8522.14, 2556.99, 759.957, 3.11709, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8571.58, 2559.95, 759.957, 4.05564, 300, 0, 0, 12600, 0, 0, 0,0,0,0),
+(NULL, 29720, 571, 1, 1, 0, 0, 8609.24, 2589.19, 759.958, 0.155352, 300, 15, 0, 12175, 0, 0, 1,0,0,0),
+(NULL, 29719, 571, 1, 1, 0, 0, 8637.35, 2651.77, 759.958, 4.15303, 300, 15, 0, 12600, 0, 0, 1,0,0,0),
+(NULL, 29719, 571, 1, 1, 0, 0, 8636.85, 2679.47, 759.958, 4.93842, 300, 15, 0, 12175, 0, 0, 1,0,0,0);
+
+-- Texte des vailliants
+-- Quete : Une arme remarquable
+DELETE FROM `script_texts` WHERE `entry` IN (-1850004,-1850005,-1850006,-1850007,-1850008,-1850009,-1850010,-1850011,-1850012);
+INSERT INTO `script_texts` (`npc_entry`, `entry`, `content_default`, `content_loc2`,`comment`) VALUES
+(0, -1850004, 'Get ready!','Get ready!',''),
+(0, -1850005, 'Let the battle begin!','Let the battle begin!',''),
+(0, -1850006, 'Get Set!','Get ready!',''),
+(0, -1850007, 'You think you have the courage in you? We\'ll see.','You think you have the courage in you? We\'ll see.',''),
+(0, -1850008, 'An impressive demonstration. I think you\'re quite able to join the ranks of the brave.','Impressive demonstration. I think you\'re quite able to join the ranks of the valiant.',''),
+(0, -1850009, 'I won. You\'ll probably have more luck next time.','I won. You\'ll probably have more luck next time.',''),
+(0, -1850010, 'I am defeated. Nice fight!','I am defeated. Nice fight!',''),
+(0, -1850011, 'Looks like I underestimated your skills. Well done.','Looks like I underestimated your skills. Well done.',''),
+(0, -1850012, 'I won. You\'ll probably have more luck next time.','I won. You\'ll probably have more luck next time.','');
+
+-- Announcer for start event
+DELETE FROM `creature_template` WHERE `entry` in (35591,35592);
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(35591, 0, 0, 0, 0, 0, 29894, 0, 0, 0, 'Jaeren Sunsworn', '', '', 0, 75, 75, 2, 14, 14, 0, 1, 1, 0, 0, 0, 0, 0, 1, 2000, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_anstart'),
+(35592, 0, 0, 0, 0, 0, 29893, 0, 0, 0, 'Arelas Brightstar', '', '', 0, 75, 75, 2, 14, 14, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 512, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_anstart');
+UPDATE `creature_template` SET `ScriptName` = 'npc_gr' WHERE `entry` = '35492';
+UPDATE `creature_template` SET `ScriptName` = 'npc_anstart' WHERE `entry` IN ('35591', '35592');
+
+UPDATE `creature_template` SET `ScriptName`='npc_vendor_argent_tournament' WHERE `entry` IN (33553, 33554, 33556, 33555, 33557, 33307, 33310, 33653, 33650, 33657);
+UPDATE `creature_template` SET `ScriptName`='quest_givers_argent_tournament' WHERE `entry` IN (33593, 33592, 33225, 33312, 33335, 33379, 33373, 33361, 33403, 33372);
+UPDATE `creature_template` SET `ScriptName`='npc_argent_champion' WHERE `entry`=33707;
+UPDATE `creature_template` SET `ScriptName`='npc_squire_danny' WHERE `entry`=33518;
+UPDATE `creature_template` SET `ScriptName`='npc_justicar_mariel_trueheart' WHERE `entry`=33817;
+
+UPDATE `creature_template` SET `ScriptName` = 'boss_twilight_halion' WHERE `entry` = '40142';
+UPDATE `creature_template` SET `ScriptName` = 'npc_meteor_strike', `flags_extra` = 128 WHERE `entry` = '40041';
+UPDATE `creature_template` SET `ScriptName` = 'npc_spell_meteor_strike', `flags_extra` = 128 WHERE `entry` = '40029';
+UPDATE `creature_template` SET `ScriptName` = 'npc_meteor_flame', `flags_extra` = 128 WHERE `entry` = '40042';
+
+UPDATE `creature_template` SET `name` = 'summon halion', `ScriptName` = 'npc_summon_halion', `flags_extra` = 128 WHERE `entry` = '40044';
+UPDATE `creature_template` SET `ScriptName` = 'npc_onyx_flamecaller' WHERE `entry` = '39814'
\ No newline at end of file
diff --git a/sql/All/world_command_Deutsch.sql b/sql/All/world_command_Deutsch.sql
new file mode 100644
index 0000000..1a2db0b
--- /dev/null
+++ b/sql/All/world_command_Deutsch.sql
@@ -0,0 +1,7 @@
+/* World Command Deutsch */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, security, help) VALUES
+('jail', 1, 'Syntax: .jail Charakter Stunden Grund\nBuchtet den \'Charakter\' für \'Stunden\' aus dem \'Grund\' ein.'),
+('jailinfo', 0, 'Syntax: .jailinfo\nZeigt dir deinen Knast-Status an.'),
+('unjail', 1, 'Syntax: .unjail Charakter\nEntläßt den \'Charakter\' aus dem Knast.'),
+('jailreload', 3, 'Syntax: .jailreload\nLädt die Jail-Konfiguration neu.');
diff --git a/sql/All/world_command_English.sql b/sql/All/world_command_English.sql
new file mode 100644
index 0000000..0176922
--- /dev/null
+++ b/sql/All/world_command_English.sql
@@ -0,0 +1,7 @@
+/* World Command English */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, security, help) VALUES
+('jail', 1, 'Syntax: .jail character hours reason\nJailed the \'character\' for \'hours\' with the \'reason\'.'),
+('jailinfo', 0, 'Syntax: .jailinfo\nShows your jail status.'),
+('unjail', 1, 'Syntax: .unjail character\nRealeases the \'character\' out of the jail.'),
+('jailreload', 3, 'Syntax: .jailreload\nLoads the jail config new.');
diff --git a/sql/All/world_command_Francais.sql b/sql/All/world_command_Francais.sql
new file mode 100644
index 0000000..237f30d
--- /dev/null
+++ b/sql/All/world_command_Francais.sql
@@ -0,0 +1,7 @@
+/* World Command Francais */
+DELETE FROM `command` WHERE name IN ('jail','jailinfo','unjail','jailreload');
+INSERT INTO `command` (name, security, help) VALUES
+('jail', 1, 'Syntaxe: .jail #personage #heures #raison\nEmprisonner un \'personnage\' pendant \'heures\' pour la \'raison\'.'),
+('jailinfo', 0, 'Syntaxe: .jailinfo\nVoir le statut de vos emprisonnements.'),
+('unjail', 1, 'Syntaxe: .unjail #personnages\nLibérer le \'personnage\' de la prison.'),
+('jailreload', 3, 'Syntaxe: .jailreload\nRecharger la configuration du Jail.');
diff --git a/sql/All/world_creature_template.sql b/sql/All/world_creature_template.sql
new file mode 100644
index 0000000..765b402
--- /dev/null
+++ b/sql/All/world_creature_template.sql
@@ -0,0 +1,5 @@
+/**
+* Records Guildhouse Keeper
+*/
+DELETE FROM creature_template WHERE `entry`=13;
+INSERT INTO `creature_template` VALUES ('13', '0', '0', '0', '0', '0', '26789', '0', '0', '0', 'Beltez', 'Guildhouse Keeper', '', '0', '80', '80', '0', '35', '35', '1', '1.48', '1.14286', '0.75', '0', '181', '189', '0', '158', '1', '1400', '1900', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '100', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '', '1', '3', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', 'guildmaster', '0');
diff --git a/sql/All/world_guildhouses.sql b/sql/All/world_guildhouses.sql
new file mode 100644
index 0000000..1c5a5d5
--- /dev/null
+++ b/sql/All/world_guildhouses.sql
@@ -0,0 +1,54 @@
+-- ----------------------------
+-- Table structure for guildhouses
+-- ----------------------------
+CREATE TABLE `guildhouses` (
+  `id` int(8) unsigned NOT NULL auto_increment,
+  `guildId` bigint(20) NOT NULL default '0',
+  `x` double NOT NULL,
+  `y` double NOT NULL,
+  `z` double NOT NULL,
+  `map` int(11) NOT NULL,
+  `comment` varchar(255) NOT NULL default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=42 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
+
+-- ----------------------------
+-- Records
+-- ----------------------------
+INSERT INTO `guildhouses` VALUES ('1', '0', '16222', '16266', '14.2', '1', 'GM Island');
+INSERT INTO `guildhouses` VALUES ('2', '0', '-10711', '2483', '8', '1', 'Tauren village at Veiled Sea (Silithus)');
+INSERT INTO `guildhouses` VALUES ('3', '0', '-8323', '-343', '146', '0', 'Fishing outside an Northshire Abbey (Elwynn Forest');
+INSERT INTO `guildhouses` VALUES ('4', '0', '7368', '-1560', '163', '1', 'Troll Village in mountains (Darkshore)');
+INSERT INTO `guildhouses` VALUES ('5', '0', '-4151', '-1400', '198', '0', 'Dwarven village outside Ironforge (Wetlands)');
+INSERT INTO `guildhouses` VALUES ('6', '0', '-1840', '-4233', '2.14', '0', 'Dwarven village (Arathi Highlands, Forbidding Sea)');
+INSERT INTO `guildhouses` VALUES ('8', '0', '-723', '-1076', '179', '1', 'Tauren camp (Mulgore, Red Rock)');
+INSERT INTO `guildhouses` VALUES ('9', '0', '-206', '1666', '80', '0', 'Shadowfang Keep an outside instance (Silverpine Forest)');
+INSERT INTO `guildhouses` VALUES ('10', '0', '-6374', '1262', '7', '0', 'Harbor house outside Stormwind (Elwynn Forest)');
+INSERT INTO `guildhouses` VALUES ('11', '0', '-8640', '580', '96', '0', 'Empty jail between canals (Stormwind) DELETE');
+INSERT INTO `guildhouses` VALUES ('12', '0', '-4844', '-1066', '502', '0', 'Old Ironforge');
+INSERT INTO `guildhouses` VALUES ('13', '0', '-4863', '-1658', '503.5', '0', 'Ironforge Airport');
+INSERT INTO `guildhouses` VALUES ('14', '0', '1146', '-165', '313', '37', 'Azshara Crater instance (Alliance entrance)');
+INSERT INTO `guildhouses` VALUES ('15', '0', '-123', '858', '298', '37', 'Azshara Crater instance (Horde entrance)');
+INSERT INTO `guildhouses` VALUES ('16', '0', '4303', '-2760', '16.8', '0', 'Quel\'Thalas Tower');
+INSERT INTO `guildhouses` VALUES ('17', '0', '-6161', '-790', '423', '0', 'Crashed gnome airplane (between Dun Morogh and Searing Gorge)');
+INSERT INTO `guildhouses` VALUES ('18', '0', '-11790', '-1640', '54.7', '0', 'Zul\'Gurub an outside instance (Stranglethorn Vale)');
+INSERT INTO `guildhouses` VALUES ('19', '0', '-11805', '-4754', '6', '1', 'Goblin village (Tanaris, South Seas)');
+INSERT INTO `guildhouses` VALUES ('20', '0', '-9296', '670', '132', '0', 'Villains camp outside an Stormwind (Elwynn Forest)');
+INSERT INTO `guildhouses` VALUES ('21', '0', '3414', '-3380', '142.2', '0', 'Stratholm an outside instance');
+INSERT INTO `guildhouses` VALUES ('22', '0', '4654', '-3772', '944', '1', 'Kalimdor Hyjal (Aka World Tree)');
+INSERT INTO `guildhouses` VALUES ('23', '0', '2176', '-4766', '55', '1', 'The Ring of Valor (Aka. Orgrimmar Arena)');
+INSERT INTO `guildhouses` VALUES ('24', '0', '1951.512085', '1530.475586', '247.288147', '1', 'Stonetalon Logging Camp');
+INSERT INTO `guildhouses` VALUES ('25', '0', '2813.660645', '2248.552979', '215.524643', '1', 'Stonetalon Ruins');
+INSERT INTO `guildhouses` VALUES ('28', '0', '9725.27', '-21.43', '20.03', '1', 'Teldrassil Furbold camp');
+INSERT INTO `guildhouses` VALUES ('29', '0', '-3855', '-3479', '579', '0', 'Wetlands mountain camp');
+INSERT INTO `guildhouses` VALUES ('30', '0', '-5362', '-2540', '485', '0', 'Ortell\'s Hideout');
+INSERT INTO `guildhouses` VALUES ('31', '0', '-12865', '-1396', '115', '0', 'Stranglethorn Secret Cave');
+INSERT INTO `guildhouses` VALUES ('32', '0', '-11073', '-1956', '39', '0', 'Karazhan Smiley');
+INSERT INTO `guildhouses` VALUES ('33', '0', '-11084', '-1801', '53', '0', 'Well of the Forgotten (Aka. Karazhan Crypt or Lower Karazhan)');
+INSERT INTO `guildhouses` VALUES ('34', '0', '1683.235474', '286.458801', '-45.451775', '0', 'Undercity Top Tier');
+INSERT INTO `guildhouses` VALUES ('35', '0', '-8521.3', '599.5', '101.399338', '0', 'Stormwind Cut-Throat Alley');
+INSERT INTO `guildhouses` VALUES ('36', '0', '-5933', '452', '509', '0', 'Forgotten gnome camp');
+INSERT INTO `guildhouses` VALUES ('37', '0', '-920.231323', '7096.489258', '170.35289', '530', 'Outland Nagrand : Newton\'s Remains');
+INSERT INTO `guildhouses` VALUES ('38', '0', '-2140.501953', '9142.6875', '137.041855', '530', 'Outland Nagrand : Tomb');
+INSERT INTO `guildhouses` VALUES ('39', '0', '-483.401794', '7461.944824', '186.120987', '530', 'Outland Nagrand: Challe\'s Home for Little Tykes');
+INSERT INTO `guildhouses` VALUES ('40', '0', '2387.753906', '3191.757324', '152.669388', '530', 'Outland Netherstorm: Nova\'s Shrine');
diff --git a/sql/All/world_ruby_sanctum.sql b/sql/All/world_ruby_sanctum.sql
new file mode 100644
index 0000000..4f5df0a
--- /dev/null
+++ b/sql/All/world_ruby_sanctum.sql
@@ -0,0 +1,66 @@
+DELETE FROM `script_texts` WHERE `entry` <= -1752008 AND `entry` >= -1752016;
+DELETE FROM `script_texts` WHERE `entry` <= -1752001 AND `entry` >= -1752006;
+DELETE FROM `script_texts` WHERE `entry` <= -1752017 AND `entry` >= -1752036;
+
+INSERT INTO `script_texts` (`entry`, `content_default`, `content_loc3`, `sound`, `type`, `language`) VALUES
+('-1752008', 'Help! I am trapped within this tree! I require aid!', '0', '17490', '1', '0'),
+('-1752009', 'Thank you! I could not have held out for much longer.... A terrible thing has happened here.', '0', '17491', '1', '0'),
+('-1752010', 'We believed the Sanctum was well-fortified, but we were not prepared for the nature of this assault.', '0', '17492', '0', '0'),
+('-1752011', 'The Black dragonkin materialized from thin air, and set upon us before we could react.', '0', '17493', '0', '0'),
+('-1752012', 'We did not stand a chance. As my brethren perished around me, I managed to retreat here and bar the entrance.', '0', '17494', '0', '0'),
+('-1752013', 'They slaughtered us with cold efficiency, but the true focus of their interest seemed to be the eggs kept here in the Sanctum.', '0', '17495', '0', '0'),
+('-1752014', 'The commander of the forces on the ground here is a cruel brute named Zarithrian, but I fear there are greater powers at work.', '0', '17496', '0', '0'),
+('-1752015', 'In their initial assault, I caught a glimpse of their true leader, a fearsome full-grown twilight dragon.', '0', '17497', '0', '0'),
+('-1752016', 'I know not the extent of their plans, heroes, but I know this: They cannot be allowed to succeed!', '0', '17498', '0', '0'),
+
+( -1752001, "Ah, the entertainment has arrived.", 0, 17520, 1, 0),
+( -1752002, "Baltharus leaves no survivors!", 0, 17521, 1, 0),
+( -1752003, "This world has enough heroes.", 0, 17522, 1, 0),
+( -1752004, "I..Didn''t saw...that coming...", 0, 17523, 1, 0),
+( -1752005, "Twice the pain and half the fun.", 0, 17524, 1, 0),
+( -1752006, "Your power wanes, ancient one.... Soon you will join your friends.", 0, 17525, 1, 0),
+
+( -1752017, "Alexstrasza has chosen capable allies... A pity that I must END YOU!", 0, 17512, 1, 0),
+( -1752018, "You thought you stood a chance?", 0, 17513, 1, 0),
+( -1752019, "It''s for the best.", 0, 17514, 1, 0),
+( -1752020, "HALION! I...", 0, 17515, 1, 0),
+( -1752021, "Turn them to ashes, minions!", 0, 17516, 1, 0),
+
+( -1752022, "You will sssuffer for this intrusion!", 0, 17528, 1, 0),
+( -1752023, "As it should be...", 0, 17529, 1, 0),
+( -1752024, "Halion will be pleased", 0, 17530, 1, 0),
+( -1752025, "Hhrr...Grr..", 0, 17531, 1, 0),
+( -1752026, "Burn in the master's flame!", 0, 17532, 1, 0),
+
+(-1752027, 'Insects! You''re too late. The Ruby Sanctum is lost.',NULL,17499,0,0),
+(-1752028, 'Your world teeters on the brink of annihilation. You will ALL bear witness to the coming of a new age of DESTRUCTION!',NULL,17500,0,0),
+(-1752029, 'Another hero falls.',NULL,17501,0,0),
+(-1752030, 'Hahahahaha.',NULL,17502,0,0),
+(-1752031, 'Relish this victory, mortals, for it will be your last! This world will burn with the master''s return!',NULL,17503,0,0),
+(-1752032, 'Not good enough.',NULL,17504,0,0),
+(-1752033, 'The heavens burn!',NULL,17505,0,0),
+(-1752034, 'Beware the shadow!',NULL,17506,0,0),
+(-1752035, 'You will find only suffering within the realm of twilight! Enter if you dare!',NULL,17507,0,0),
+(-1752036, 'I am the light and the darkness! Cower, mortals, before the herald of Deathwing!',NULL,17508,0,0);
+
+UPDATE `instance_template` SET `script`='instance_ruby_sanctum' WHERE (`map`='724');
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus' WHERE `entry` = '39751';
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus_summon' WHERE `entry` = '39899';
+UPDATE `creature_template` SET `ScriptName` = 'npc_xerestrasza' WHERE `entry` = '40429';
+UPDATE `creature_template` SET `ScriptName` = 'boss_zarithrian' WHERE `entry` = '39746';
+UPDATE `creature_template` SET `ScriptName` = 'boss_ragefire' WHERE `entry` = '39747';
+UPDATE `creature_template` SET `ScriptName` = 'boss_halion' WHERE `entry`= '39863';
+
+
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger`='-74562') AND (`spell_effect`='74610');
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger`='-74792') AND (`spell_effect`='74800');
+INSERT INTO `spell_linked_spell` VALUES (-74562, 74610, 0, 'Fiery Combustion removed -> Combustion');
+INSERT INTO `spell_linked_spell` VALUES (-74792, 74800, 0, 'Soul Consumption removed -> Consumption');
+
+DELETE FROM `creature` WHERE `id`=39863 AND `map`=724;
+INSERT INTO `creature` VALUES (null,39863,724,15,1,0,0,3144.93,527.233,72.8887,0.110395,300,0,0,11156000,0,0,0,0,0,0);
+
+REPLACE `spell_script_names` SET `ScriptName` = 'spell_halion_portal', `spell_id`=74812;
+
+UPDATE `gameobject_template` SET `data10`=74807 WHERE `entry`=202794;
+UPDATE `gameobject_template` SET `data10`=74812 WHERE `entry`=202796;
\ No newline at end of file
diff --git a/sql/All/world_trinity_string.sql b/sql/All/world_trinity_string.sql
new file mode 100644
index 0000000..ed3e80c
--- /dev/null
+++ b/sql/All/world_trinity_string.sql
@@ -0,0 +1,40 @@
+/* World trinity_string */
+SET NAMES 'utf8';
+DELETE FROM trinity_string WHERE `entry` IN (950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983);
+
+INSERT INTO `trinity_string` VALUES ('950', 'You are jailed by \'%s\' for %u hour(s)!', null, 'Vous tes emprisonn par \'%s\' pour %u heures!', 'Du wurdest von \'%s\' für %u Stunde(n) eingebuchtet!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('951', '\'%s\' wrote this as reason: \'%s\'', null, '%s a crit ceci comme tant la raison de votre emprisonnement: %s.', '\'%s\' gab dies als Grund an: \'%s\'', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('952', '\'%s\' was jailed by you for %u hour(s).', null, 'Vous avez emprisonn %s pour %u heures!', '\'%s\' wurde von dir für %u Stunde(n) eingebuchtet.', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('953', 'You was released out of the jail by %s.', null, 'Vous avez t liber de la prison par %s.', '\'%s\' hat dich aus dem Knast entlassen.', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('954', 'You have released %s out of the jail.', null, 'Vous avez liber \'%s\' de la prison.', 'Du hast \'%s\' aus dem Knast geholt.', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('955', 'No reason given or reason is < %u chars!', null, 'Aucune raison d\\\'emprisonnement donne ou la raison est < %u personnages.', 'Du hast keinen Grund angegeben, oder der Grund ist < %u Zeichen!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('956', 'No name given!', null, 'Aucun nom donn!', 'Du hast keinen Namen angegeben!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('957', 'No time given!', null, 'Aucun temps donn!', 'Du hast keine Zeit angegeben!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('958', 'The jailtime must be between 1 and %u hours!', null, 'Le temps d\\\'emprisonnement est situ entre 1 et %u heures!', 'Die Jail-Zeit muss zwischen 1 und %u Std. liegen!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('959', 'The character \'%s\' is not jailed!', null, '\'%s\' n\\\'est pas emprisonn!', 'Der Charakter \'%s\' ist Überhaupt nicht im Knast!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('960', 'Command forbidden for jailed characters!', null, 'Commandes interdites pour les personnages emprisons!', 'Sorry, aber das d?rfen Gefangene nicht!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('961', 'You have %u hour(s) left in the jail.', null, 'Vous avez %u heures  attendre avant de quitter la prison.', 'Du musst noch %u Stunde(n) absitzen.', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('962', 'You have %u minute(s) left in the jail.', null, 'Vous avez %u minutes attendre avant de quitter la prison.', 'Du musst noch %u Minute(n) absitzen.', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('963', 'You\'re a free like a bird! ;-)', null, 'Vous tes libre.', 'Du bist frei wie ein Vogel! ;-)', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('964', '%s was %u times jailed and has %u minute(s) left. Last time jailed by %s. Last reason was: \'%s\'', null, '%s a t librde prison, il avait t emprisonn pour %u et a t libr au aprs %u minutes. Il avait t emprisonn par %s, pour la raison suivante: %s', '\'%s\' war bis jetzt %u mal im Knast, und hat noch %u Minute(n) abzusitzen.\n Zuletzt eingebuchtet von: \'%s\'\nLetzter Grund: %s', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('965', '\'%s\' was never jailed.', null, '\'%s\' n\\\'a jamais t emprisonn.', '\'%s\' hat eine weiße Weste.', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('966', 'You can\'t jail yourself!', null, 'Vous ne pouvez pas vous emprisonner vous-m me!', 'Du kannst dich nicht selber einbuchten!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('967', 'You can\'t unjail yourself!', null, 'Vous ne pouvez pas vous librer vous m me!', 'So weit kommt es noch, daß Knastbruder sich selber befreien! :-(', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('968', '|cffff0000[!!! ATTENTION - IMPORTANT - WARNING !!!\r\n You were already %u times in prison. If you are in Jail for a total of  %u times, your character will be deleted\r\n|cffff0000!!! ATTENTION - IMPORTANT - WARNING !!!]', null, '|cffff0000[!!!ATTENTION - ATTENTION - ATTENTION!!!\r\n Vous étiez déjà %u fois en prison en %u fois, votre personnage supprimé\r\n|cffff0000!!! ATTENTION - ATTENTION - ATTENTION !!!]', '|cffff0000[!!! ACHTUNG - WICHTIG - WARNUNG !!!\r\n Du warst schon %u mal in Knast beim %u mal wird dein Charakter gelöscht\r\n|cffff0000!!! ACHTUNG - WICHTIG - WARNUNG !!!]', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('969', 'The character \'', null, 'Le personnage ', 'Der Charakter \'', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('970', '\' was jailed for ', null, ' a t emprisonn pour ', '\' wurde für ', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('971', ' hour(s) by the GM character \'', null, ' heure(s) par le MJ ', ' Stunde(n) von dem GM-Charakter \'', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('972', '\'. The reason is: ', null, '. La raison est: ', '\' eingebuchtet. Der Grund ist: ', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('973', 'The jail configuration was reloaded.', null, 'La configuration de jail a t recharge.', 'Die Gefängnis-Konfiguration wurde neu geladen.', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('974', '>> Trinity Jail config loaded.', null, '>> Configuration du jail charge.', '>> Gefängnis-Konfiguration geladen.', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('975', 'Can\'t load jail config! Table empty or missed! Use characters_jail.sql!', null, 'Impossible de charger la configuration du jail! Table vide ou innexistante! Appliquez characters_jail.sql!', 'Fehler beim laden der Gef?ngnis-Konfiguration! Der Table \'jail_conf\' ist leer oder nicht vorhanden! Nutze die \'characters_jail.sql\'!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('976', 'Set all jail config settings to default...', null, 'Placez tous les param tres de configuration de prison par d faut.', 'Setze die Konfiguration des Gef?ngnisses auf Standardwerte...', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('977', 'The Character \'%s\'  is jailed and teleportet into the jail.', null, 'Le personnage \'%s\'  est emprisonn et t leport dans la prison.', 'Der Charakter \'%s\'  ist ein Knastbruder und wird in den Knast teleportiert.', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('978', 'The Character \'%s\'  was released out of the jail.', null, 'Le personnage %s  est liber  de prison.', 'Der Charakter \'%s\'  wurde aus dem Knast entlassen.', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('979', 'A character with this name doesn\'t exists!', null, 'Il n\'y a aucun personnage portant ce nom.', 'Ein Charakter mit diesem Namen gibt es nicht!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('980', '|cffff0000[!!! ATTENTION - IMPORTANT - WARNING !!!\r\n You were already %u times in prison. If you are in Jail for a total of  %u times, your account  will be banned!\r\n|cffff0000!!! ATTENTION - IMPORTANT - WARNING !!!]', null, '|cffff0000[!!!ATTENTION - ATTENTION - ATTENTION!!!\r\n Vous avez %u fois en prison en %u fois votre compte sera banni\r\n|cffff0000!!! ATTENTION - ATTENTION - ATTENTION !!!]', '|cffff0000[!!! ACHTUNG - WICHTIG - WARNUNG !!!\r\n Du hast %u mal in Knast beim %u mal wird dein Account gebannt\r\n|cffff0000!!! ACHTUNG - WICHTIG - WARNUNG !!!]', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('981', 'Max. jailtimes reached!', null, 'Nombre maximum d\'Jails atteint!', 'Maximale Anzahl an Jails erreicht!', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('982', 'Robotron', null, 'Robotron', 'Robotron', null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('983', 'Your Jail status was reset to 0 ', null, 'Votre statut a été Jail à 0 ', 'Dein Jail status wurde auf 0 zurück gesatzt', null, null, null, null, null);
+
+
diff --git a/sql/CMakeLists.txt b/sql/CMakeLists.txt
index e1b0921..e1f8feb 100644
--- a/sql/CMakeLists.txt
+++ b/sql/CMakeLists.txt
@@ -11,6 +11,7 @@
 if( WITH_SQL )
   install(
     DIRECTORY
+      All
       updates
       scripts
       base
diff --git a/src/server/authserver/Server/AuthSocket.cpp b/src/server/authserver/Server/AuthSocket.cpp
index 0b7a49f..21a4fe5 100755
--- a/src/server/authserver/Server/AuthSocket.cpp
+++ b/src/server/authserver/Server/AuthSocket.cpp
@@ -349,6 +349,9 @@ bool AuthSocket::_HandleLogonChallenge()
     // Verify that this IP is not in the ip_banned table
     LoginDatabase.Execute(LoginDatabase.GetPreparedStatement(LOGIN_SET_EXPIREDIPBANS));
 
+    LoginDatabase.Execute(
+        LoginDatabase.GetPreparedStatement(LOGIN_SET_ACCOUNT_PREMIUM)
+            );
     const std::string& ip_address = socket().get_remote_address();
     PreparedStatement *stmt = LoginDatabase.GetPreparedStatement(LOGIN_GET_IPBANNED);
     stmt->setString(0, ip_address);
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
new file mode 100644
index 0000000..68565db
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
@@ -0,0 +1,373 @@
+/**
+ *
+ * @File : sc_npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 28/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+
+#define TELE    nsNpcTel::CatDest
+#define PAGE    nsNpcTel::Page
+#define PAGEI   PAGE::Instance
+
+
+nsNpcTel::VCatDest nsNpcTel::TabCatDest;
+
+
+uint32 PAGE::operator [] (Player * const player) const
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i].GetPageId();
+    }
+    return 0;
+}
+
+PAGE::Instance & PAGE::operator () (Player * const player)
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i];
+    }
+    m_TabInstance.push_back(Instance(player));
+    return m_TabInstance.back();
+}
+
+PAGE::Instance & PAGEI::operator = (const uint32 &id)
+{
+    m_PageId = id;
+    return *this;
+}
+
+PAGE::Instance & PAGEI::operator ++ (void)
+{
+    ++m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator ++ (int32)
+{
+    Instance tmp (*this);
+    ++m_PageId;
+    return tmp;
+}
+
+PAGE::Instance & PAGEI::operator -- (void)
+{
+    --m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator -- (int32)
+{
+    Instance tmp (*this);
+    --m_PageId;
+    return tmp;
+}
+
+TELE::CatDest(const uint32 &id, const std::string &name,
+              const Flag &flag, const uint64 &data0, const uint32 &data1)
+    : m_id(id), m_name(name), m_flag(flag), m_data0(data0), m_data1(data1)
+{
+    m_TabDest.clear();
+}
+
+std::string TELE::GetName(const bool IsGM /* = false */) const
+{
+    if (!IsGM || m_flag != FLAG_TEAM)
+        return m_name;
+
+    switch (m_data0)
+    {
+      case TEAM_HORDE:      return std::string(m_name + " (H)");
+      case TEAM_ALLIANCE:   return std::string(m_name + " (A)");
+    }
+    return m_name;
+}
+
+bool TELE::IsAllowedToTeleport(Player * const player) const
+{
+    if (player->isGameMaster())
+    {
+        if (m_flag == FLAG_GMLEVEL)
+            return player->GetSession()->GetSecurity() >= m_data0;
+        return true;
+    }
+
+    switch (m_flag)
+    {
+      case FLAG_TEAM:
+        switch (m_data0)
+        {
+          case TEAM_HORDE:      return player->GetTeam() == HORDE;
+          case TEAM_ALLIANCE:   return player->GetTeam() == ALLIANCE;
+          case TEAM_ALL:        return true;
+        }
+
+      case FLAG_GUILD:
+        return player->GetGuildId() == m_data0;
+
+      case FLAG_GMLEVEL:
+        return player->GetSession()->GetSecurity() >= m_data0;
+
+      case FLAG_ISGM:
+        return player->isGameMaster();
+
+      case FLAG_ACCOUNT:
+        return player->GetSession()->GetAccountId() == m_data0;
+
+      case FLAG_LEVEL:
+        return player->getLevel() >= m_data0;
+
+      case FLAG_ITEM:
+        return player->HasItemCount(m_data0, m_data1, true);
+
+      case FLAG_QUEST:
+        if (m_data1 < MAX_QUEST_STATUS)
+            return player->GetQuestStatus(m_data0) == m_data1;
+        return player->GetQuestRewardStatus(m_data0);
+
+      case FLAG_GENDER:
+        return player->getGender() == m_data0;
+
+      case FLAG_RACE:
+        return player->getRace() == m_data0;
+
+      case FLAG_CLASS:
+        return player->getClass() == m_data0;
+
+      case FLAG_REPUTATION:
+        return player->GetReputationRank(m_data0) >= m_data1;
+
+      case FLAG_PLAYER:
+        return player->GetGUID() == m_data0;
+    }
+
+    sLog->outError("Invalid flag (category: %u). Important problem...", GetCatID());
+    return false;
+}
+
+uint32 TELE::CountOfCategoryAllowedBy(Player * const player)
+{
+    uint32 count (0);
+    for (VCatDest_t i(0); i < TabCatDest.size(); ++i)
+    {
+        if (TabCatDest[i].IsAllowedToTeleport(player))
+            ++count;
+    }
+    return count;
+}
+
+bool nsNpcTel::IsValidData(const uint32 &cat,   const Flag &flag,
+                           const uint64 &data0, const uint32 &data1)
+{
+    switch(flag)
+    {
+      case FLAG_TEAM:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0 < MAX_FLAG_TEAM)
+            return true;
+        sLog->outError("Invalid data0 (Team) (category: %u).", cat);
+        return false;
+
+      case FLAG_GUILD:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError("Invalid data0 (GuildID) (category: %u).", cat);
+        return false;
+
+      case FLAG_GMLEVEL:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        sLog->outError("Invalid data0 (GmLevel) (category: %u).", cat);
+        return false;
+
+      case FLAG_ISGM:
+        if (data0)
+            sLog->outError("Invalid data0 (category: %u).", cat);
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        return true;
+
+      case FLAG_ACCOUNT:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError("Invalid data0 (AccountID) (category: %u).", cat);
+        return false;
+
+      case FLAG_LEVEL:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        sLog->outError("Invalid data0 (Level) (category: %u).", cat);
+        return false;
+
+      case FLAG_ITEM:
+        if (!data0)
+        {
+            sLog->outError("Invalid data0 (ItemID) (category: %u).", cat);
+            return false;
+        }
+        if (data1)
+            return true;
+        sLog->outError("Invalid data1 (Item Count) (category: %u).", cat);
+        return false;
+
+      case FLAG_QUEST:
+        if (!data0)
+        {
+            sLog->outError("Invalid data0 (QuestID) (category: %u).", cat);
+            return false;
+        }
+        if (data1 < MAX_QUEST_STATUS + 1)
+            return true;
+        sLog->outError("Invalid data1 (Quest Status) (category: %u).", cat);
+        return false;
+
+      case FLAG_GENDER:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0 < GENDER_NONE)
+            return true;
+        sLog->outError("Invalid data0 (Gender) (category: %u).", cat);
+        return false;
+
+      case FLAG_RACE:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_RACES)
+            return true;
+        sLog->outError("Invalid data0 (Race) (category: %u).", cat);
+        return false;
+
+      case FLAG_CLASS:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_CLASSES)
+            return true;
+        sLog->outError("Invalid data0 (Class) (category: %u).", cat);
+        return false;
+
+      case FLAG_REPUTATION:
+        if (!data0)
+        {
+            sLog->outError("Invalid data0 (Faction/Reputation) (category: %u).", cat);
+            return false;
+        }
+        if (data1 <= REP_EXALTED)
+            return true;
+        sLog->outError("Invalid data1 (Faction/Reputation) (category: %u).", cat);
+        return false;
+
+      case FLAG_PLAYER:
+        if (data1)
+            sLog->outError("Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        sLog->outError("Invalid data0 (PlayerGuid) (category: %u).", cat);
+        return false;
+    }
+
+    sLog->outError("Invalid flag (category: %u).", cat);
+    return false;
+}
+
+void LoadNpcTele(void)
+{
+    const char *Table[] =
+    {
+        "custom_npc_tele_category",
+        "custom_npc_tele_destination",
+        "custom_npc_tele_association",
+    };
+
+
+    QueryResult result = WorldDatabase.PQuery(
+        "SELECT `flag`, `data0`, `data1`, `cat_id`, C.`name` `namecat`, D.`name` `namedest`, "
+        //      0        1        2        3                  4                   5
+               "`pos_X`, `pos_Y`, `pos_Z`, `orientation`, `map`, `level`, `cost` "
+        //      6        7        8        9              10     11       12
+        "FROM `%s` C, `%s` D, `%s` A "
+        "WHERE C.`id` = `cat_id` AND D.`id` = `dest_id` "
+        "ORDER BY `namecat`, `cat_id`, `namedest`", Table[0], Table[1], Table[2]);
+
+    nsNpcTel::TabCatDest.clear();
+
+    if (result)
+    {
+	    sLog->outString( "TSCR: Loading %s, %s and %s...", Table[0], Table[1], Table[2]);
+
+        uint32 catid = 0;
+        uint32 nbDest = 0;
+        bool IsValidCat = true;
+        bool FirstTime = true;
+
+        do
+        {
+            Field *fields = result->Fetch();
+
+            if (!IsValidCat && catid == fields[3].GetUInt32() && !FirstTime)
+                continue;
+
+            IsValidCat = true;
+            FirstTime = false;
+
+            if (!nsNpcTel::IsValidData(fields[3].GetUInt32(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                       fields[1].GetUInt64(), fields[2].GetUInt32()))
+            {
+                IsValidCat = false;
+                catid = fields[3].GetUInt32();
+                continue;
+            }
+
+            if (catid != fields[3].GetUInt32())
+            {
+                catid = fields[3].GetUInt32();
+                nsNpcTel::CatDest categorie (catid, fields[4].GetString(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                             fields[1].GetUInt64(), fields[2].GetUInt32());
+                nsNpcTel::TabCatDest.push_back(categorie);
+            }
+
+            nsNpcTel::Dest item =
+            {
+                fields[5].GetString(),   // Name
+                fields[6].GetFloat(),       // X
+                fields[7].GetFloat(),       // Y
+                fields[8].GetFloat(),       // Z
+                fields[9].GetFloat(),       // Orientation
+                fields[10].GetUInt16(),     // Map
+                fields[11].GetUInt8(),      // Level
+                fields[12].GetUInt32(),     // Cost
+            };
+
+            nsNpcTel::TabCatDest.back().AddDest(item);
+            ++nbDest;
+        } while (result->NextRow());
+
+        sLog->outString("");
+        sLog->outString("TSCR: >> Loaded %u npc_teleport.", nbDest);
+    } else sLog->outString("TSCR: WARNING >> Loaded 0 npc_teleport.");
+}
+
+
+#undef TELE
+#undef PAGE
+#undef PAGEI
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.h b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
new file mode 100644
index 0000000..4830245
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
@@ -0,0 +1,151 @@
+/**
+ *
+ * @File : sc_npc_teleport.h
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#ifndef SC_NPC_TELEPORT_H
+#define SC_NPC_TELEPORT_H
+
+#include <vector>
+
+
+namespace nsNpcTel
+{
+    // Different types of permissions
+    enum Flag
+    {
+        FLAG_TEAM       = 0,
+        FLAG_GUILD      = 1,
+        FLAG_GMLEVEL    = 2,
+        FLAG_ISGM       = 3,
+        FLAG_ACCOUNT    = 4,
+        FLAG_LEVEL      = 5,
+        FLAG_ITEM       = 6,
+        FLAG_QUEST      = 7,
+        FLAG_GENDER     = 8,
+        FLAG_RACE       = 9,
+        FLAG_CLASS      = 10,
+        FLAG_REPUTATION = 11,
+        FLAG_PLAYER     = 12,
+        MAX_FLAG,
+    };
+
+    // Different parameters of FLAG_TEAM
+    enum
+    {
+        TEAM_ALL        = 0,
+        TEAM_ALLIANCE   = 1,
+        TEAM_HORDE      = 2,
+        MAX_FLAG_TEAM,
+    };
+
+    // Structure representing the destinations
+    struct Dest
+    {
+        std::string m_name;
+        float       m_X, m_Y, m_Z, m_orient;
+        uint16      m_map;
+        uint8       m_level;
+        uint32      m_cost;
+    };
+
+    // Class representing the categories of destinations
+    class CatDest
+    {
+      public:
+
+        typedef std::vector<Dest> VDest;
+        typedef VDest::size_type  VDest_t;
+
+        CatDest(const uint32 &id, const std::string &name,
+                const Flag &flag, const uint64 &data0, const uint32 &data1);
+
+        void   AddDest  (const Dest &item)       { m_TabDest.push_back(item); }
+        Dest   GetDest  (const uint32 &id) const { return m_TabDest[id]; }
+        uint32 GetCatID (void)             const { return m_id; }
+        uint32 size     (void)             const { return m_TabDest.size(); }
+
+        std::string GetName(const bool IsGM = false)    const;
+        bool IsAllowedToTeleport(Player * const player) const;
+
+        static uint32 CountOfCategoryAllowedBy(Player * const player);
+
+      private:
+
+        uint32      m_id;
+        std::string m_name;
+        Flag        m_flag;
+        uint64      m_data0;
+        uint32      m_data1;
+        VDest       m_TabDest;
+    };
+
+    // Class page for current player
+    class Page
+    {
+      protected:
+
+        // Class instance for current player
+        class Instance
+        {
+          public:
+
+            Instance(Player * const player, const uint32 &PageId = 0)
+                : m_player(player), m_PageId(PageId) {}
+
+            Instance & operator =  (const uint32 &id);
+            Instance & operator ++ (void);
+            Instance   operator ++ (int32);
+            Instance & operator -- (void);
+            Instance   operator -- (int32);
+
+            uint32   GetPageId(void) const { return m_PageId; }
+            Player * GetPlayer(void) const { return m_player; }
+
+          private:
+
+            Player *m_player;
+            uint32  m_PageId;
+        };
+
+
+      public:
+
+        typedef std::vector<Instance> VInst;
+        typedef VInst::size_type      VInst_t;
+
+        Page(void) { m_TabInstance.clear(); }
+
+        Instance &   operator () (Player * const player);
+        uint32 operator [] (Player * const player) const;
+
+
+      private:
+
+        VInst m_TabInstance;
+    };
+
+    typedef std::vector <CatDest> VCatDest;
+    typedef VCatDest::size_type   VCatDest_t;
+
+    // Verification of data integrity
+    bool IsValidData(const uint32 &cat,   const Flag &flag,
+                     const uint64 &data0, const uint32 &data1);
+
+    extern VCatDest TabCatDest;
+}
+
+// Loading contents of database
+void LoadNpcTele(void);
+
+extern WorldDatabaseWorkerPool WorldDatabase;
+
+#endif
diff --git a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
new file mode 100644
index 0000000..373aa60
--- /dev/null
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.cpp
@@ -0,0 +1,1884 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ObjectMgr.h"
+#include "AuctionHouseMgr.h"
+#include "AuctionHouseBot.h"
+#include <vector>
+
+using namespace std;
+vector<uint32> npcItems;
+vector<uint32> lootItems;
+vector<uint32> greyTradeGoodsBin;
+vector<uint32> whiteTradeGoodsBin;
+vector<uint32> greenTradeGoodsBin;
+vector<uint32> blueTradeGoodsBin;
+vector<uint32> purpleTradeGoodsBin;
+vector<uint32> orangeTradeGoodsBin;
+vector<uint32> yellowTradeGoodsBin;
+vector<uint32> greyItemsBin;
+vector<uint32> whiteItemsBin;
+vector<uint32> greenItemsBin;
+vector<uint32> blueItemsBin;
+vector<uint32> purpleItemsBin;
+vector<uint32> orangeItemsBin;
+vector<uint32> yellowItemsBin;
+
+AuctionHouseBot::AuctionHouseBot()
+{
+    debug_Out = false;
+    debug_Out_Filters = false;
+    AHBSeller = false;
+    AHBBuyer = false;
+
+    //Begin Filters
+
+    Vendor_Items = false;
+    Loot_Items = false;
+    Other_Items = false;
+    Vendor_TGs = false;
+    Loot_TGs = false;
+    Other_TGs = false;
+
+    No_Bind = false;
+    Bind_When_Picked_Up = false;
+    Bind_When_Equipped = false;
+    Bind_When_Use = false;
+    Bind_Quest_Item = false;
+
+    DisableBeta_PTR_Unused = false;
+    DisablePermEnchant = false;
+    DisableConjured = false;
+    DisableGems = false;
+    DisableMoney = false;
+    DisableMoneyLoot = false;
+    DisableLootable = false;
+    DisableKeys = false;
+    DisableDuration = false;
+    DisableBOP_Or_Quest_NoReqLevel = false;
+
+    DisableWarriorItems = false;
+    DisablePaladinItems = false;
+    DisableHunterItems = false;
+    DisableRogueItems = false;
+    DisablePriestItems = false;
+    DisableDKItems = false;
+    DisableShamanItems = false;
+    DisableMageItems = false;
+    DisableWarlockItems = false;
+    DisableUnusedClassItems = false;
+    DisableDruidItems = false;
+
+    DisableItemsBelowLevel = 0;
+    DisableItemsAboveLevel = 0;
+    DisableTGsBelowLevel = 0;
+    DisableTGsAboveLevel = 0;
+    DisableItemsBelowGUID = 0;
+    DisableItemsAboveGUID = 0;
+    DisableTGsBelowGUID = 0;
+    DisableTGsAboveGUID = 0;
+    DisableItemsBelowReqLevel = 0;
+    DisableItemsAboveReqLevel = 0;
+    DisableTGsBelowReqLevel = 0;
+    DisableTGsAboveReqLevel = 0;
+    DisableItemsBelowReqSkillRank = 0;
+    DisableItemsAboveReqSkillRank = 0;
+    DisableTGsBelowReqSkillRank = 0;
+    DisableTGsAboveReqSkillRank = 0;
+
+    //End Filters
+
+    _lastrun_a = time(NULL);
+    _lastrun_h = time(NULL);
+    _lastrun_n = time(NULL);
+
+    AllianceConfig = AHBConfig(2);
+    HordeConfig = AHBConfig(6);
+    NeutralConfig = AHBConfig(7);
+}
+
+AuctionHouseBot::~AuctionHouseBot()
+{
+}
+
+void AuctionHouseBot::addNewAuctions(Player *AHBplayer, AHBConfig *config)
+{
+    if (!AHBSeller)
+    {
+        if (debug_Out) sLog->outError("AHSeller: Disabled");
+        return;
+    }
+
+    uint32 minItems = config->GetMinItems();
+    uint32 maxItems = config->GetMaxItems();
+
+    if (maxItems == 0)
+    {
+        //if (debug_Out) sLog->outString("AHSeller: Auctions disabled");
+        return;
+    }
+
+    AuctionHouseEntry const* ahEntry =  sAuctionMgr->GetAuctionHouseEntry(config->GetAHFID());
+    if (!ahEntry)
+    {
+        return;
+    }
+    AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+    if (!auctionHouse)
+    {
+        return;
+    }
+
+    uint32 auctions = auctionHouse->Getcount();
+
+    if (auctions >= minItems)
+    {
+        //if (debug_Out) sLog->outString("AHSeller: Auctions above minimum");
+        return;
+    }
+
+    if (auctions >= maxItems)
+    {
+        //if (debug_Out) sLog->outString("AHSeller: Auctions at or above maximum");
+        return;
+    }
+
+    uint32 items = 0;
+    if ((maxItems - auctions) >= ItemsPerCycle)
+        items = ItemsPerCycle;
+    else
+        items = (maxItems - auctions);
+
+    if (debug_Out) sLog->outString("AHSeller: Adding %u Auctions", items);
+
+    uint32 AuctioneerGUID = 0;
+
+    switch (config->GetAHID())
+    {
+    case 2:
+        AuctioneerGUID = 79707; //Human in stormwind.
+        break;
+    case 6:
+        AuctioneerGUID = 4656; //orc in Orgrimmar
+        break;
+    case 7:
+        AuctioneerGUID = 23442; //goblin in GZ
+        break;
+    default:
+        if (debug_Out) sLog->outError("AHSeller: GetAHID() - Default switch reached");
+        AuctioneerGUID = 23442; //default to neutral 7
+        break;
+    }
+
+    if (debug_Out) sLog->outString("AHSeller: Current Auctineer GUID is %u", AuctioneerGUID);
+
+    uint32 greyTGcount = config->GetPercents(AHB_GREY_TG);
+    uint32 whiteTGcount = config->GetPercents(AHB_WHITE_TG);
+    uint32 greenTGcount = config->GetPercents(AHB_GREEN_TG);
+    uint32 blueTGcount = config->GetPercents(AHB_BLUE_TG);
+    uint32 purpleTGcount = config->GetPercents(AHB_PURPLE_TG);
+    uint32 orangeTGcount = config->GetPercents(AHB_ORANGE_TG);
+    uint32 yellowTGcount = config->GetPercents(AHB_YELLOW_TG);
+    uint32 greyIcount = config->GetPercents(AHB_GREY_I);
+    uint32 whiteIcount = config->GetPercents(AHB_WHITE_I);
+    uint32 greenIcount = config->GetPercents(AHB_GREEN_I);
+    uint32 blueIcount = config->GetPercents(AHB_BLUE_I);
+    uint32 purpleIcount = config->GetPercents(AHB_PURPLE_I);
+    uint32 orangeIcount = config->GetPercents(AHB_ORANGE_I);
+    uint32 yellowIcount = config->GetPercents(AHB_YELLOW_I);
+/*    uint32 total = greyTGcount + whiteTGcount + greenTGcount + blueTGcount
+        + purpleTGcount + orangeTGcount + yellowTGcount
+        + whiteIcount + greenIcount + blueIcount + purpleIcount
+        + orangeIcount + yellowIcount;
+*/
+    uint32 greyTGoods = config->GetItemCounts(AHB_GREY_TG);
+    uint32 whiteTGoods = config->GetItemCounts(AHB_WHITE_TG);
+    uint32 greenTGoods = config->GetItemCounts(AHB_GREEN_TG);
+    uint32 blueTGoods = config->GetItemCounts(AHB_BLUE_TG);
+    uint32 purpleTGoods = config->GetItemCounts(AHB_PURPLE_TG);
+    uint32 orangeTGoods = config->GetItemCounts(AHB_ORANGE_TG);
+    uint32 yellowTGoods = config->GetItemCounts(AHB_YELLOW_TG);
+
+    uint32 greyItems = config->GetItemCounts(AHB_GREY_I);
+    uint32 whiteItems = config->GetItemCounts(AHB_WHITE_I);
+    uint32 greenItems = config->GetItemCounts(AHB_GREEN_I);
+    uint32 blueItems = config->GetItemCounts(AHB_BLUE_I);
+    uint32 purpleItems = config->GetItemCounts(AHB_PURPLE_I);
+    uint32 orangeItems = config->GetItemCounts(AHB_ORANGE_I);
+    uint32 yellowItems = config->GetItemCounts(AHB_YELLOW_I);
+    if (debug_Out) sLog->outString("AHSeller: %u items", items);
+
+    // only insert a few at a time, so as not to peg the processor
+    for (uint32 cnt = 1; cnt <= items; cnt++)
+    {
+    if (debug_Out) sLog->outString("AHSeller: %u count", cnt);
+        uint32 itemID = 0;
+        uint32 itemColor = 99;
+        uint32 loopbreaker = 0;
+        while (itemID == 0 && loopbreaker <= 50)
+        {
+            ++loopbreaker;
+            uint32 choice = urand(0, 13);
+            itemColor = choice;
+            switch (choice)
+            {
+            case 0:
+                {
+                    if ((greyItemsBin.size() > 0) && (greyItems < greyIcount))
+                        itemID = greyItemsBin[urand(0, greyItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 1:
+                {
+                    if ((whiteItemsBin.size() > 0) && (whiteItems < whiteIcount))
+                        itemID = whiteItemsBin[urand(0, whiteItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 2:
+                {
+                    if ((greenItemsBin.size() > 0) && (greenItems < greenIcount))
+                        itemID = greenItemsBin[urand(0, greenItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 3:
+                {
+                    if ((blueItemsBin.size() > 0) && (blueItems < blueIcount))
+                        itemID = blueItemsBin[urand(0, blueItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 4:
+                {
+                    if ((purpleItemsBin.size() > 0) && (purpleItems < purpleIcount))
+                        itemID = purpleItemsBin[urand(0, purpleItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 5:
+                {
+                    if ((orangeItemsBin.size() > 0) && (orangeItems < orangeIcount))
+                        itemID = orangeItemsBin[urand(0, orangeItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 6:
+                {
+                    if ((yellowItemsBin.size() > 0) && (yellowItems < yellowIcount))
+                        itemID = yellowItemsBin[urand(0, yellowItemsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 7:
+                {
+                    if ((greyTradeGoodsBin.size() > 0) && (greyTGoods < greyTGcount))
+                        itemID = greyTradeGoodsBin[urand(0, greyTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 8:
+                {
+                    if ((whiteTradeGoodsBin.size() > 0) && (whiteTGoods < whiteTGcount))
+                        itemID = whiteTradeGoodsBin[urand(0, whiteTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 9:
+                {
+                    if ((greenTradeGoodsBin.size() > 0) && (greenTGoods < greenTGcount))
+                        itemID = greenTradeGoodsBin[urand(0, greenTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 10:
+                {
+                    if ((blueTradeGoodsBin.size() > 0) && (blueTGoods < blueTGcount))
+                        itemID = blueTradeGoodsBin[urand(0, blueTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 11:
+                {
+                    if ((purpleTradeGoodsBin.size() > 0) && (purpleTGoods < purpleTGcount))
+                        itemID = purpleTradeGoodsBin[urand(0, purpleTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 12:
+                {
+                    if ((orangeTradeGoodsBin.size() > 0) && (orangeTGoods < orangeTGcount))
+                        itemID = orangeTradeGoodsBin[urand(0, orangeTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            case 13:
+                {
+                    if ((yellowTradeGoodsBin.size() > 0) && (yellowTGoods < yellowTGcount))
+                        itemID = yellowTradeGoodsBin[urand(0, yellowTradeGoodsBin.size() - 1)];
+                    else continue;
+                    break;
+                }
+            default:
+                {
+                    if (debug_Out) sLog->outError("AHSeller: itemID Switch - Default Reached");
+                    break;
+                }
+            }
+
+            if (itemID == 0)
+            {
+                if (debug_Out) sLog->outError("AHSeller: Item::CreateItem() - ItemID is 0");
+                continue;
+            }
+
+            ItemPrototype const* prototype = sObjectMgr->GetItemPrototype(itemID);
+            if (prototype == NULL)
+            {
+                if (debug_Out) sLog->outError("AHSeller: Huh?!?! prototype == NULL");
+                continue;
+            }
+
+            Item* item = Item::CreateItem(itemID, 1, AHBplayer);
+            if (item == NULL)
+            {
+                if (debug_Out) sLog->outError("AHSeller: Item::CreateItem() returned NULL");
+                break;
+            }
+            item->AddToUpdateQueueOf(AHBplayer);
+
+            uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(itemID);
+            if (randomPropertyId != 0)
+                item->SetItemRandomProperties(randomPropertyId);
+
+            uint64 buyoutPrice = 0;
+            uint64 bidPrice = 0;
+            uint32 stackCount = 1;
+
+            switch (SellMethod)
+            {
+            case 0:
+                buyoutPrice  = prototype->SellPrice;
+                break;
+            case 1:
+                buyoutPrice  = prototype->BuyPrice;
+                break;
+            }
+
+            if ((prototype->Quality >= 0) && (prototype->Quality <= AHB_MAX_QUALITY))
+            {
+                if (config->GetMaxStack(prototype->Quality) > 1 && item->GetMaxStackCount() > 1)
+                    stackCount = urand(1, minValue(item->GetMaxStackCount(), config->GetMaxStack(prototype->Quality)));
+                else if (config->GetMaxStack(prototype->Quality) == 0 && item->GetMaxStackCount() > 1)
+                    stackCount = urand(1, item->GetMaxStackCount());
+                else
+                    stackCount = 1;
+                buyoutPrice *= urand(config->GetMinPrice(prototype->Quality), config->GetMaxPrice(prototype->Quality));
+                buyoutPrice /= 100;
+                bidPrice = buyoutPrice * urand(config->GetMinBidPrice(prototype->Quality), config->GetMaxBidPrice(prototype->Quality));
+                bidPrice /= 100;
+            }
+            else
+            {
+                // quality is something it shouldn't be, let's get out of here
+                if (debug_Out) sLog->outError("AHBuyer: Quality %u not Supported", prototype->Quality);
+                item->RemoveFromUpdateQueueOf(AHBplayer);
+                continue;
+            }
+
+            uint32 etime = urand(1,3);
+            switch(etime)
+            {
+            case 1:
+                etime = 43200;
+                break;
+            case 2:
+                etime = 86400;
+                break;
+            case 3:
+                etime = 172800;
+                break;
+            default:
+                etime = 86400;
+                break;
+            }
+            item->SetCount(stackCount);
+
+            uint32 dep =  sAuctionMgr->GetAuctionDeposit(ahEntry, etime, item, stackCount);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            AuctionEntry* auctionEntry = new AuctionEntry;
+            auctionEntry->Id = sObjectMgr->GenerateAuctionID();
+            auctionEntry->auctioneer = AuctioneerGUID;
+            auctionEntry->item_guidlow = item->GetGUIDLow();
+            auctionEntry->item_template = item->GetEntry();
+            auctionEntry->owner = AHBplayer->GetGUIDLow();
+            auctionEntry->startbid = bidPrice * stackCount;
+            auctionEntry->buyout = buyoutPrice * stackCount;
+            auctionEntry->bidder = 0;
+            auctionEntry->bid = 0;
+            auctionEntry->deposit = dep;
+            auctionEntry->expire_time = (time_t) etime + time(NULL);
+            auctionEntry->auctionHouseEntry = ahEntry;
+            item->SaveToDB(trans);
+            item->RemoveFromUpdateQueueOf(AHBplayer);
+            sAuctionMgr->AddAItem(item);
+            auctionHouse->AddAuction(auctionEntry);
+            auctionEntry->SaveToDB(trans);
+            CharacterDatabase.CommitTransaction(trans);
+
+            switch(itemColor)
+            {
+            case 0:
+                ++greyItems;
+                break;
+            case 1:
+                ++whiteItems;
+                break;
+            case 2:
+                ++greenItems;
+                break;
+            case 3:
+                ++blueItems;
+                break;
+            case 4:
+                ++purpleItems;
+                break;
+            case 5:
+                ++orangeItems;
+                break;
+            case 6:
+                ++yellowItems;
+                break;
+            case 7:
+                ++greyTGoods;
+                break;
+            case 8:
+                ++whiteTGoods;
+                break;
+            case 9:
+                ++greenTGoods;
+                break;
+            case 10:
+                ++blueTGoods;
+                break;
+            case 11:
+                ++purpleTGoods;
+                break;
+            case 12:
+                ++orangeTGoods;
+                break;
+            case 13:
+                ++yellowTGoods;
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+void AuctionHouseBot::addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session)
+{
+    if (!AHBBuyer)
+    {
+        if (debug_Out) sLog->outError("AHBuyer: Disabled");
+        return;
+    }
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT id FROM auctionhouse WHERE itemowner<>%u AND buyguid<>%u", AHBplayerGUID, AHBplayerGUID);
+
+    if (!result)
+        return;
+
+    if (result->GetRowCount() == 0)
+        return;
+
+    // Fetches content of selected AH
+    AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+    vector<uint32> possibleBids;
+
+    do
+    {
+        uint32 tmpdata = result->Fetch()->GetUInt32();
+        possibleBids.push_back(tmpdata);
+    }while (result->NextRow());
+
+    for (uint32 count = 1; count <= config->GetBidsPerInterval(); ++count)
+    {
+        // Do we have anything to bid? If not, stop here.
+        if (possibleBids.empty())
+        {
+            //if (debug_Out) sLog->outString("AHBuyer: I have no items to bid on.");
+            count = config->GetBidsPerInterval();
+            continue;
+        }
+
+        // Choose random auction from possible auctions
+        uint32 vectorPos = urand(0, possibleBids.size() - 1);
+        vector<uint32>::iterator iter = possibleBids.begin();
+        advance(iter, vectorPos);
+
+        // from auctionhousehandler.cpp, creates auction pointer & player pointer
+        AuctionEntry* auction = auctionHouse->GetAuction(*iter);
+
+        // Erase the auction from the vector to prevent bidding on item in next iteration.
+        possibleBids.erase(iter);
+
+        if (!auction)
+            continue;
+
+        // get exact item information
+        Item *pItem =  sAuctionMgr->GetAItem(auction->item_guidlow);
+        if (!pItem)
+        {
+            if (debug_Out) sLog->outError("AHBuyer: Item %u doesn't exist, perhaps bought already?", auction->item_guidlow);
+            continue;
+        }
+
+        // get item prototype
+        ItemPrototype const* prototype = sObjectMgr->GetItemPrototype(auction->item_template);
+
+        // check which price we have to use, startbid or if it is bidded already
+        uint32 currentprice;
+        if (auction->bid)
+            currentprice = auction->bid;
+        else
+            currentprice = auction->startbid;
+
+        // Prepare portion from maximum bid
+        double bidrate = static_cast<double>(urand(1, 100)) / 100;
+        long double bidMax = 0;
+
+        // check that bid has acceptable value and take bid based on vendorprice, stacksize and quality
+        switch (BuyMethod)
+        {
+        case 0:
+            {
+                if ((prototype->Quality >= 0) && (prototype->Quality <= AHB_MAX_QUALITY))
+                {
+                    if (currentprice < prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality))
+                        bidMax = prototype->SellPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality);
+                }
+                else
+                {
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out) sLog->outError("AHBuyer: Quality %u not Supported", prototype->Quality);
+                    continue;
+                }
+                break;
+            }
+        case 1:
+            {
+                if ((prototype->Quality >= 0) && (prototype->Quality <= AHB_MAX_QUALITY))
+                {
+                    if (currentprice < prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality))
+                        bidMax = prototype->BuyPrice * pItem->GetCount() * config->GetBuyerPrice(prototype->Quality);
+                }
+                else
+                {
+                    // quality is something it shouldn't be, let's get out of here
+                    if (debug_Out) sLog->outError("AHBuyer: Quality %u not Supported", prototype->Quality);
+                    continue;
+                }
+                break;
+            }
+        }
+
+        // check some special items, and do recalculating to their prices
+        switch (prototype->Class)
+        {
+            // ammo
+        case 6:
+            bidMax = 0;
+            break;
+        default:
+            break;
+        }
+
+        if (bidMax == 0)
+        {
+            // quality check failed to get bidmax, let's get out of here
+            continue;
+        }
+
+        // Calculate our bid
+        long double bidvalue = currentprice + ((bidMax - currentprice) * bidrate);
+        // Convert to uint32
+        uint32 bidprice = static_cast<uint32>(bidvalue);
+
+        // Check our bid is high enough to be valid. If not, correct it to minimum.
+        if ((currentprice + auction->GetAuctionOutBid()) > bidprice)
+            bidprice = currentprice + auction->GetAuctionOutBid();
+
+        if (debug_Out)
+        {
+            sLog->outString("-------------------------------------------------");
+            sLog->outString("AHBuyer: Info for Auction #%u:", auction->Id);
+            sLog->outString("AHBuyer: AuctionHouse: %u", auction->GetHouseId());
+            sLog->outString("AHBuyer: Auctioneer: %u", auction->auctioneer);
+            sLog->outString("AHBuyer: Owner: %u", auction->owner);
+            sLog->outString("AHBuyer: Bidder: %u", auction->bidder);
+            sLog->outString("AHBuyer: Starting Bid: %u", auction->startbid);
+            sLog->outString("AHBuyer: Current Bid: %u", currentprice);
+            sLog->outString("AHBuyer: Buyout: %u", auction->buyout);
+            sLog->outString("AHBuyer: Deposit: %u", auction->deposit);
+            sLog->outString("AHBuyer: Expire Time: %u", auction->expire_time);
+            sLog->outString("AHBuyer: Bid Rate: %f", bidrate);
+            sLog->outString("AHBuyer: Bid Max: %f", bidMax);
+            sLog->outString("AHBuyer: Bid Value: %f", bidvalue);
+            sLog->outString("AHBuyer: Bid Price: %u", bidprice);
+            sLog->outString("AHBuyer: Item GUID: %u", auction->item_guidlow);
+            sLog->outString("AHBuyer: Item Template: %u", auction->item_template);
+            sLog->outString("AHBuyer: Item Info:");
+            sLog->outString("AHBuyer: Item ID: %u", prototype->ItemId);
+            sLog->outString("AHBuyer: Buy Price: %u", prototype->BuyPrice);
+            sLog->outString("AHBuyer: Sell Price: %u", prototype->SellPrice);
+            sLog->outString("AHBuyer: Bonding: %u", prototype->Bonding);
+            sLog->outString("AHBuyer: Quality: %u", prototype->Quality);
+            sLog->outString("AHBuyer: Item Level: %u", prototype->ItemLevel);
+            sLog->outString("AHBuyer: Ammo Type: %u", prototype->AmmoType);
+            sLog->outString("-------------------------------------------------");
+        }
+
+        // Check whether we do normal bid, or buyout
+        if ((bidprice < auction->buyout) || (auction->buyout == 0))
+        {
+
+            if (auction->bidder > 0)
+            {
+                if (auction->bidder == AHBplayer->GetGUIDLow())
+                {
+                    //pl->ModifyMoney(-int32(price - auction->bid));
+                }
+                else
+                {
+                    // mail to last bidder and return money
+                    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                    sAuctionMgr->SendAuctionOutbiddedMail(auction , bidprice, session->GetPlayer(), trans);
+                    CharacterDatabase.CommitTransaction(trans);
+                    //pl->ModifyMoney(-int32(price));
+                }
+           }
+
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = bidprice;
+
+            // Saving auction into database
+            CharacterDatabase.PExecute("UPDATE auctionhouse SET buyguid = '%u',lastbid = '%u' WHERE id = '%u'", auction->bidder, auction->bid, auction->Id);
+        }
+        else
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            //buyout
+            if ((auction->bidder) && (AHBplayer->GetGUIDLow() != auction->bidder))
+            {
+                sAuctionMgr->SendAuctionOutbiddedMail(auction, auction->buyout, session->GetPlayer(), trans);
+            }
+            auction->bidder = AHBplayer->GetGUIDLow();
+            auction->bid = auction->buyout;
+
+            // Send mails to buyer & seller
+            sAuctionMgr->SendAuctionSalePendingMail(auction, trans);
+            sAuctionMgr->SendAuctionSuccessfulMail(auction, trans);
+            sAuctionMgr->SendAuctionWonMail(auction, trans);
+            auction->DeleteFromDB( trans);
+            uint32 item_template = auction->item_template;
+            sAuctionMgr->RemoveAItem(auction->item_guidlow);
+            auctionHouse->RemoveAuction(auction, item_template);
+            CharacterDatabase.CommitTransaction(trans);
+        }
+    }
+}
+
+void AuctionHouseBot::Update()
+{
+    time_t _newrun = time(NULL);
+    if ((!AHBSeller) && (!AHBBuyer))
+        return;
+
+    WorldSession _session(AHBplayerAccount, NULL, SEC_PLAYER, false, true, 0, LOCALE_enUS, 0);
+    Player _AHBplayer(&_session);
+    _AHBplayer.Initialize(AHBplayerGUID);
+    sObjectAccessor->AddObject(&_AHBplayer);
+
+    // Add New Bids
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        addNewAuctions(&_AHBplayer, &AllianceConfig);
+        if (((_newrun - _lastrun_a) >= (AllianceConfig.GetBiddingInterval() * MINUTE)) && (AllianceConfig.GetBidsPerInterval() > 0))
+        {
+            //if (debug_Out) sLog->outString("AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_a));
+            //if (debug_Out) sLog->outString("AHBuyer: Bidding on Alliance Auctions");
+            addNewAuctionBuyerBotBid(&_AHBplayer, &AllianceConfig, &_session);
+            _lastrun_a = _newrun;
+        }
+
+        addNewAuctions(&_AHBplayer, &HordeConfig);
+        if (((_newrun - _lastrun_h) >= (HordeConfig.GetBiddingInterval() * MINUTE)) && (HordeConfig.GetBidsPerInterval() > 0))
+        {
+            //if (debug_Out) sLog->outString("AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_h));
+            //if (debug_Out) sLog->outString("AHBuyer: Bidding on Horde Auctions");
+            addNewAuctionBuyerBotBid(&_AHBplayer, &HordeConfig, &_session);
+            _lastrun_h = _newrun;
+        }
+    }
+
+    addNewAuctions(&_AHBplayer, &NeutralConfig);
+    if (((_newrun - _lastrun_n) >= (NeutralConfig.GetBiddingInterval() * MINUTE)) && (NeutralConfig.GetBidsPerInterval() > 0))
+    {
+        //if (debug_Out) sLog->outString("AHBuyer: %u seconds have passed since last bid", (_newrun - _lastrun_n));
+        //if (debug_Out) sLog->outString("AHBuyer: Bidding on Neutral Auctions");
+        addNewAuctionBuyerBotBid(&_AHBplayer, &NeutralConfig, &_session);
+        _lastrun_n = _newrun;
+    }
+    sObjectAccessor->RemoveObject(&_AHBplayer);
+}
+
+void AuctionHouseBot::Initialize()
+{
+    debug_Out = sConfig->GetBoolDefault("AuctionHouseBot.DEBUG", false);
+    debug_Out_Filters = sConfig->GetBoolDefault("AuctionHouseBot.DEBUG_FILTERS", false);
+
+    AHBSeller = sConfig->GetBoolDefault("AuctionHouseBot.EnableSeller", false);
+    AHBBuyer = sConfig->GetBoolDefault("AuctionHouseBot.EnableBuyer", false);
+    SellMethod = sConfig->GetBoolDefault("AuctionHouseBot.UseBuyPriceForSeller", false);
+    BuyMethod = sConfig->GetBoolDefault("AuctionHouseBot.UseBuyPriceForBuyer", false);
+
+    AHBplayerAccount = sConfig->GetIntDefault("AuctionHouseBot.Account", 0);
+    AHBplayerGUID = sConfig->GetIntDefault("AuctionHouseBot.GUID", 0);
+    ItemsPerCycle = sConfig->GetIntDefault("AuctionHouseBot.ItemsPerCycle", 200);
+
+    //Begin Filters
+
+    Vendor_Items = sConfig->GetBoolDefault("AuctionHouseBot.VendorItems", false);
+    Loot_Items = sConfig->GetBoolDefault("AuctionHouseBot.LootItems", true);
+    Other_Items = sConfig->GetBoolDefault("AuctionHouseBot.OtherItems", false);
+    Vendor_TGs = sConfig->GetBoolDefault("AuctionHouseBot.VendorTradeGoods", false);
+    Loot_TGs = sConfig->GetBoolDefault("AuctionHouseBot.LootTradeGoods", true);
+    Other_TGs = sConfig->GetBoolDefault("AuctionHouseBot.OtherTradeGoods", false);
+
+    No_Bind = sConfig->GetBoolDefault("AuctionHouseBot.No_Bind", true);
+    Bind_When_Picked_Up = sConfig->GetBoolDefault("AuctionHouseBot.Bind_When_Picked_Up", false);
+    Bind_When_Equipped = sConfig->GetBoolDefault("AuctionHouseBot.Bind_When_Equipped", true);
+    Bind_When_Use = sConfig->GetBoolDefault("AuctionHouseBot.Bind_When_Use", true);
+    Bind_Quest_Item = sConfig->GetBoolDefault("AuctionHouseBot.Bind_Quest_Item", false);
+
+    DisableBeta_PTR_Unused = sConfig->GetBoolDefault("AuctionHouseBot.DisableBeta_PTR_Unused", false);
+    DisablePermEnchant = sConfig->GetBoolDefault("AuctionHouseBot.DisablePermEnchant", false);
+    DisableConjured = sConfig->GetBoolDefault("AuctionHouseBot.DisableConjured", false);
+    DisableGems = sConfig->GetBoolDefault("AuctionHouseBot.DisableGems", false);
+    DisableMoney = sConfig->GetBoolDefault("AuctionHouseBot.DisableMoney", false);
+    DisableMoneyLoot = sConfig->GetBoolDefault("AuctionHouseBot.DisableMoneyLoot", false);
+    DisableLootable = sConfig->GetBoolDefault("AuctionHouseBot.DisableLootable", false);
+    DisableKeys = sConfig->GetBoolDefault("AuctionHouseBot.DisableKeys", false);
+    DisableDuration = sConfig->GetBoolDefault("AuctionHouseBot.DisableDuration", false);
+    DisableBOP_Or_Quest_NoReqLevel = sConfig->GetBoolDefault("AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel", false);
+
+    DisableWarriorItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableWarriorItems", false);
+    DisablePaladinItems = sConfig->GetBoolDefault("AuctionHouseBot.DisablePaladinItems", false);
+    DisableHunterItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableHunterItems", false);
+    DisableRogueItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableRogueItems", false);
+    DisablePriestItems = sConfig->GetBoolDefault("AuctionHouseBot.DisablePriestItems", false);
+    DisableDKItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableDKItems", false);
+    DisableShamanItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableShamanItems", false);
+    DisableMageItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableMageItems", false);
+    DisableWarlockItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableWarlockItems", false);
+    DisableUnusedClassItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableUnusedClassItems", false);
+    DisableDruidItems = sConfig->GetBoolDefault("AuctionHouseBot.DisableDruidItems", false);
+
+    DisableItemsBelowLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsBelowLevel", 0);
+    DisableItemsAboveLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsAboveLevel", 0);
+    DisableTGsBelowLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsBelowLevel", 0);
+    DisableTGsAboveLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsAboveLevel", 0);
+    DisableItemsBelowGUID = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsBelowGUID", 0);
+    DisableItemsAboveGUID = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsAboveGUID", 0);
+    DisableTGsBelowGUID = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsBelowGUID", 0);
+    DisableTGsAboveGUID = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsAboveGUID", 0);
+    DisableItemsBelowReqLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsBelowReqLevel", 0);
+    DisableItemsAboveReqLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsAboveReqLevel", 0);
+    DisableTGsBelowReqLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsBelowReqLevel", 0);
+    DisableTGsAboveReqLevel = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsAboveReqLevel", 0);
+    DisableItemsBelowReqSkillRank = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsBelowReqSkillRank", 0);
+    DisableItemsAboveReqSkillRank = sConfig->GetIntDefault("AuctionHouseBot.DisableItemsAboveReqSkillRank", 0);
+    DisableTGsBelowReqSkillRank = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsBelowReqSkillRank", 0);
+    DisableTGsAboveReqSkillRank = sConfig->GetIntDefault("AuctionHouseBot.DisableTGsAboveReqSkillRank", 0);
+
+    //End Filters
+    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    {
+        LoadValues(&AllianceConfig);
+        LoadValues(&HordeConfig);
+    }
+    LoadValues(&NeutralConfig);
+
+    //
+    // check if the AHBot account/GUID in the config actually exists
+    //
+
+    if ((AHBplayerAccount != 0) || (AHBplayerGUID != 0))
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT 1 FROM characters WHERE account = %u AND guid = %u", AHBplayerAccount, AHBplayerGUID);
+        if (!result)
+       {
+           sLog->outError("AuctionHouseBot: The account/GUID-information set for your AHBot is incorrect (account: %u guid: %u)", AHBplayerAccount, AHBplayerGUID);
+           return;
+        }
+    }
+
+    if (AHBSeller)
+    {
+        QueryResult results = QueryResult(NULL);
+        char npcQuery[] = "SELECT distinct item FROM npc_vendor";
+        results = WorldDatabase.Query(npcQuery);
+        if (results != NULL)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                npcItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+        }
+        else
+        {
+            if (debug_Out) sLog->outString("AuctionHouseBot: \"%s\" failed", npcQuery);
+        }
+
+        char lootQuery[] = "SELECT item FROM creature_loot_template UNION "
+            "SELECT item FROM reference_loot_template UNION "
+            "SELECT item FROM disenchant_loot_template UNION "
+            "SELECT item FROM fishing_loot_template UNION "
+            "SELECT item FROM gameobject_loot_template UNION "
+            "SELECT item FROM item_loot_template UNION "
+            "SELECT item FROM milling_loot_template UNION "
+            "SELECT item FROM pickpocketing_loot_template UNION "
+            "SELECT item FROM prospecting_loot_template UNION "
+            "SELECT item FROM skinning_loot_template";
+
+        results = WorldDatabase.Query(lootQuery);
+        if (results != NULL)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                lootItems.push_back(fields[0].GetUInt32());
+
+            } while (results->NextRow());
+        }
+        else
+        {
+            if (debug_Out) sLog->outString("AuctionHouseBot: \"%s\" failed", lootQuery);
+        }
+
+        for (uint32 itemID = 0; itemID < sItemStorage.MaxEntry; itemID++)
+        {
+            ItemPrototype const* prototype = sObjectMgr->GetItemPrototype(itemID);
+
+            if (prototype == NULL)
+                continue;
+
+            switch (prototype->Bonding)
+            {
+            case NO_BIND:
+                if (!No_Bind)
+                    continue;
+                break;
+            case BIND_WHEN_PICKED_UP:
+                if (!Bind_When_Picked_Up)
+                    continue;
+                break;
+            case BIND_WHEN_EQUIPED:
+                if (!Bind_When_Equipped)
+                    continue;
+                break;
+            case BIND_WHEN_USE:
+                if (!Bind_When_Use)
+                    continue;
+                break;
+            case BIND_QUEST_ITEM:
+                if (!Bind_Quest_Item)
+                    continue;
+                break;
+            default:
+                continue;
+                break;
+            }
+
+            switch (SellMethod)
+            {
+            case 0:
+                if (prototype->SellPrice == 0)
+                    continue;
+                break;
+            case 1:
+                if (prototype->BuyPrice == 0)
+                    continue;
+                break;
+            }
+
+            if ((prototype->Quality < 0) || (prototype->Quality > 6))
+                continue;
+
+            if ((Vendor_Items == 0) && !(prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itemID == npcItems[i])
+                        isVendorItem = true;
+                }
+
+                if (isVendorItem)
+                    continue;
+            }
+
+            if ((Vendor_TGs == 0) && (prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorTG = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorTG); i++)
+                {
+                    if (itemID == npcItems[i])
+                        isVendorTG = true;
+                }
+
+                if (isVendorTG)
+                    continue;
+            }
+
+            if ((Loot_Items == 0) && !(prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itemID == lootItems[i])
+                        isLootItem = true;
+                }
+
+                if (isLootItem)
+                    continue;
+            }
+
+            if ((Loot_TGs == 0) && (prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isLootTG = false;
+
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootTG); i++)
+                {
+                    if (itemID == lootItems[i])
+                        isLootTG = true;
+                }
+
+                if (isLootTG)
+                    continue;
+            }
+
+            if ((Other_Items == 0) && !(prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorItem = false;
+                bool isLootItem = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorItem); i++)
+                {
+                    if (itemID == npcItems[i])
+                        isVendorItem = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootItem); i++)
+                {
+                    if (itemID == lootItems[i])
+                        isLootItem = true;
+                }
+                if ((!isLootItem) && (!isVendorItem))
+                    continue;
+            }
+
+            if ((Other_TGs == 0) && (prototype->Class == ITEM_CLASS_TRADE_GOODS))
+            {
+                bool isVendorTG = false;
+                bool isLootTG = false;
+
+                for (unsigned int i = 0; (i < npcItems.size()) && (!isVendorTG); i++)
+                {
+                    if (itemID == npcItems[i])
+                        isVendorTG = true;
+                }
+                for (unsigned int i = 0; (i < lootItems.size()) && (!isLootTG); i++)
+                {
+                    if (itemID == lootItems[i])
+                        isLootTG = true;
+                }
+                if ((!isLootTG) && (!isVendorTG))
+                    continue;
+            }
+
+             //TODO:Make list of items and create a vector
+            // Disable PTR/Beta/Unused items
+            if ((DisableBeta_PTR_Unused) && ((prototype->ItemId == 21878) || (prototype->ItemId == 27774) || (prototype->ItemId == 27811) || (prototype->ItemId == 28117) || (prototype->ItemId == 28112)))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (PTR/Beta/Unused Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable permanent enchants items
+            if ((DisablePermEnchant) && (prototype->Class == ITEM_CLASS_PERMANENT))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Permanent Enchant Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable conjured items
+            if ((DisableConjured) && (prototype->IsConjuredConsumable()))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Conjured Consumable)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable gems
+            if ((DisableGems) && (prototype->Class == ITEM_CLASS_GEM))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Gem)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable money
+            if ((DisableMoney) && (prototype->Class == ITEM_CLASS_MONEY))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Money)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable moneyloot
+            if ((DisableMoneyLoot) && (prototype->MinMoneyLoot > 0))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (MoneyLoot)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable lootable items
+            if ((DisableLootable) && (prototype->Flags & 4))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Lootable Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable Keys
+            if ((DisableKeys) && (prototype->Class == ITEM_CLASS_KEY))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Quest Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items with duration
+            if ((DisableDuration) && (prototype->Duration > 0))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Has a Duration)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items which are BOP or Quest Items and have a required level lower than the item level
+            if ((DisableBOP_Or_Quest_NoReqLevel) && ((prototype->Bonding == BIND_WHEN_PICKED_UP || prototype->Bonding == BIND_QUEST_ITEM) && (prototype->RequiredLevel < prototype->ItemLevel)))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (BOP or BQI and Required Level is less than Item Level)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Warrior
+            if ((DisableWarriorItems) && (prototype->AllowableClass == 1))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Warrior Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Paladin
+            if ((DisablePaladinItems) && (prototype->AllowableClass == 2))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Paladin Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Hunter
+            if ((DisableHunterItems) && (prototype->AllowableClass == 4))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Hunter Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Rogue
+            if ((DisableRogueItems) && (prototype->AllowableClass == 8))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Rogue Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Priest
+            if ((DisablePriestItems) && (prototype->AllowableClass == 16))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Priest Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for DK
+            if ((DisableDKItems) && (prototype->AllowableClass == 32))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (DK Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Shaman
+            if ((DisableShamanItems) && (prototype->AllowableClass == 64))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Shaman Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Mage
+            if ((DisableMageItems) && (prototype->AllowableClass == 128))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Mage Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Warlock
+            if ((DisableWarlockItems) && (prototype->AllowableClass == 256))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Warlock Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Unused Class
+            if ((DisableUnusedClassItems) && (prototype->AllowableClass == 512))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Unused Item)", prototype->ItemId);
+                continue;
+            }
+
+            // Disable items specifically for Druid
+            if ((DisableDruidItems) && (prototype->AllowableClass == 1024))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Druid Item)", prototype->ItemId);
+                continue;
+            }
+
+             // Disable Items below level X
+            if ((DisableItemsBelowLevel) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel < DisableItemsBelowLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Items above level X
+            if ((DisableItemsAboveLevel) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel > DisableItemsAboveLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+           // Disable Trade Goods below level X
+            if ((DisableTGsBelowLevel) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel < DisableTGsBelowLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (Trade Good Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+           // Disable Trade Goods above level X
+            if ((DisableTGsAboveLevel) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->ItemLevel > DisableTGsAboveLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (Trade Good Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Items below GUID X
+            if ((DisableItemsBelowGUID) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->ItemId < DisableItemsBelowGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Items above GUID X
+            if ((DisableItemsAboveGUID) && (prototype->Class != ITEM_CLASS_TRADE_GOODS) && (prototype->ItemId > DisableItemsAboveGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Item Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Trade Goods below GUID X
+            if ((DisableTGsBelowGUID) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->ItemId < DisableTGsBelowGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Trade Good Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Trade Goods above GUID X
+            if ((DisableTGsAboveGUID) && (prototype->Class == ITEM_CLASS_TRADE_GOODS) && (prototype->ItemId > DisableTGsAboveGUID))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (Trade Good Level = %u)", prototype->ItemId, prototype->ItemLevel);
+                continue;
+            }
+
+            // Disable Items for level lower than X
+            if ((DisableItemsBelowReqLevel) && (prototype->RequiredLevel < DisableItemsBelowReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredLevel = %u)", prototype->ItemId, prototype->RequiredLevel);
+                continue;
+            }
+
+            // Disable Items for level higher than X
+            if ((DisableItemsAboveReqLevel) && (prototype->RequiredLevel > DisableItemsAboveReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredLevel = %u)", prototype->ItemId, prototype->RequiredLevel);
+                continue;
+            }
+
+            // Disable Trade Goods for level lower than X
+            if ((DisableTGsBelowReqLevel) && (prototype->RequiredLevel < DisableTGsBelowReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (RequiredLevel = %u)", prototype->ItemId, prototype->RequiredLevel);
+                continue;
+            }
+
+            // Disable Trade Goods for level higher than X
+            if ((DisableTGsAboveReqLevel) && (prototype->RequiredLevel > DisableTGsAboveReqLevel))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Trade Good %u disabled (RequiredLevel = %u)", prototype->ItemId, prototype->RequiredLevel);
+                continue;
+            }
+
+            // Disable Items that require skill lower than X
+            if ((DisableItemsBelowReqSkillRank) && (prototype->RequiredSkillRank < DisableItemsBelowReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", prototype->ItemId, prototype->RequiredSkillRank);
+                continue;
+            }
+
+            // Disable Items that require skill higher than X
+            if ((DisableItemsAboveReqSkillRank) && (prototype->RequiredSkillRank > DisableItemsAboveReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", prototype->ItemId, prototype->RequiredSkillRank);
+                continue;
+            }
+
+            // Disable Trade Goods that require skill lower than X
+            if ((DisableTGsBelowReqSkillRank) && (prototype->RequiredSkillRank < DisableTGsBelowReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", prototype->ItemId, prototype->RequiredSkillRank);
+                continue;
+            }
+
+            // Disable Trade Goods that require skill higher than X
+            if ((DisableTGsAboveReqSkillRank) && (prototype->RequiredSkillRank > DisableTGsAboveReqSkillRank))
+            {
+                if (debug_Out_Filters) sLog->outString("AuctionHouseBot: Item %u disabled (RequiredSkillRank = %u)", prototype->ItemId, prototype->RequiredSkillRank);
+                continue;
+            }
+
+            switch (prototype->Quality)
+            {
+            case AHB_GREY:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    greyTradeGoodsBin.push_back(itemID);
+                else
+                    greyItemsBin.push_back(itemID);
+                break;
+
+            case AHB_WHITE:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    whiteTradeGoodsBin.push_back(itemID);
+                else
+                    whiteItemsBin.push_back(itemID);
+                break;
+
+            case AHB_GREEN:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    greenTradeGoodsBin.push_back(itemID);
+                else
+                    greenItemsBin.push_back(itemID);
+                break;
+
+            case AHB_BLUE:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    blueTradeGoodsBin.push_back(itemID);
+                else
+                    blueItemsBin.push_back(itemID);
+                break;
+
+            case AHB_PURPLE:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    purpleTradeGoodsBin.push_back(itemID);
+                else
+                    purpleItemsBin.push_back(itemID);
+                break;
+
+            case AHB_ORANGE:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    orangeTradeGoodsBin.push_back(itemID);
+                else
+                    orangeItemsBin.push_back(itemID);
+                break;
+
+            case AHB_YELLOW:
+                if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                    yellowTradeGoodsBin.push_back(itemID);
+                else
+                    yellowItemsBin.push_back(itemID);
+                break;
+            }
+        }
+
+        if ((greyTradeGoodsBin.size() == 0) &&
+            (whiteTradeGoodsBin.size() == 0) &&
+            (greenTradeGoodsBin.size() == 0) &&
+            (blueTradeGoodsBin.size() == 0) &&
+            (purpleTradeGoodsBin.size() == 0) &&
+            (orangeTradeGoodsBin.size() == 0) &&
+            (yellowTradeGoodsBin.size() == 0) &&
+            (greyItemsBin.size() == 0) &&
+            (whiteItemsBin.size() == 0) &&
+            (greenItemsBin.size() == 0) &&
+            (blueItemsBin.size() == 0) &&
+            (purpleItemsBin.size() == 0) &&
+            (orangeItemsBin.size() == 0) &&
+            (yellowItemsBin.size() == 0))
+        {
+            sLog->outError("AuctionHouseBot: No items");
+            AHBSeller = 0;
+        }
+
+        sLog->outString("AuctionHouseBot:");
+        sLog->outString("loaded %u grey trade goods", greyTradeGoodsBin.size());
+        sLog->outString("loaded %u white trade goods", whiteTradeGoodsBin.size());
+        sLog->outString("loaded %u green trade goods", greenTradeGoodsBin.size());
+        sLog->outString("loaded %u blue trade goods", blueTradeGoodsBin.size());
+        sLog->outString("loaded %u purple trade goods", purpleTradeGoodsBin.size());
+        sLog->outString("loaded %u orange trade goods", orangeTradeGoodsBin.size());
+        sLog->outString("loaded %u yellow trade goods", yellowTradeGoodsBin.size());
+        sLog->outString("loaded %u grey items", greyItemsBin.size());
+        sLog->outString("loaded %u white items", whiteItemsBin.size());
+        sLog->outString("loaded %u green items", greenItemsBin.size());
+        sLog->outString("loaded %u blue items", blueItemsBin.size());
+        sLog->outString("loaded %u purple items", purpleItemsBin.size());
+        sLog->outString("loaded %u orange items", orangeItemsBin.size());
+        sLog->outString("loaded %u yellow items", yellowItemsBin.size());
+    }
+    sLog->outString("AuctionHouseBot and AuctionHouseBuyer have been loaded.");
+}
+
+void AuctionHouseBot::IncrementItemCounts(AuctionEntry* ah)
+{
+    // from auctionhousehandler.cpp, creates auction pointer & player pointer
+
+    // get exact item information
+    Item *pItem =  sAuctionMgr->GetAItem(ah->item_guidlow);
+    if (!pItem)
+    {
+        if (debug_Out) sLog->outError("AHBot: Item %u doesn't exist, perhaps bought already?", ah->item_guidlow);
+        return;
+    }
+
+    // get item prototype
+    ItemPrototype const* prototype = sObjectMgr->GetItemPrototype(ah->item_template);
+
+    AHBConfig *config;
+
+    FactionTemplateEntry const* u_entry = sFactionTemplateStore.LookupEntry(ah->GetHouseFaction());
+    if (!u_entry)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_ALLIANCE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Alliance", ah->GetHouseFaction());
+        config = &AllianceConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_HORDE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Horde", ah->GetHouseFaction());
+        config = &HordeConfig;
+    }
+    else
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+
+    config->IncItemCounts(prototype->Class, prototype->Quality);
+}
+
+void AuctionHouseBot::DecrementItemCounts(AuctionEntry* ah, uint32 item_template)
+{
+    // get item prototype
+    ItemPrototype const* prototype = sObjectMgr->GetItemPrototype(item_template);
+
+    AHBConfig *config;
+
+    FactionTemplateEntry const* u_entry = sFactionTemplateStore.LookupEntry(ah->GetHouseFaction());
+    if (!u_entry)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_ALLIANCE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Alliance", ah->GetHouseFaction());
+        config = &AllianceConfig;
+    }
+    else if (u_entry->ourMask & FACTION_MASK_HORDE)
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Horde", ah->GetHouseFaction());
+        config = &HordeConfig;
+    }
+    else
+    {
+        if (debug_Out) sLog->outError("AHBot: %u returned as House Faction. Neutral", ah->GetHouseFaction());
+        config = &NeutralConfig;
+    }
+
+    config->DecItemCounts(prototype->Class, prototype->Quality);
+}
+
+void AuctionHouseBot::Commands(uint32 command, uint32 ahMapID, uint32 col, char* args)
+{
+    AHBConfig *config = NULL;
+    switch (ahMapID)
+    {
+    case 2:
+        config = &AllianceConfig;
+        break;
+    case 6:
+        config = &HordeConfig;
+        break;
+    case 7:
+        config = &NeutralConfig;
+        break;
+    }
+    std::string color;
+    switch (col)
+    {
+    case AHB_GREY:
+        color = "grey";
+        break;
+    case AHB_WHITE:
+        color = "white";
+        break;
+    case AHB_GREEN:
+        color = "green";
+        break;
+    case AHB_BLUE:
+        color = "blue";
+        break;
+    case AHB_PURPLE:
+        color = "purple";
+        break;
+    case AHB_ORANGE:
+        color = "orange";
+        break;
+    case AHB_YELLOW:
+        color = "yellow";
+        break;
+    default:
+        break;
+    }
+    switch (command)
+    {
+    case 0:     //ahexpire
+        {
+            AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+
+            AuctionHouseObject::AuctionEntryMap::iterator itr;
+            itr = auctionHouse->GetAuctionsBegin();
+
+            while (itr != auctionHouse->GetAuctionsEnd())
+            {
+                if (itr->second->owner == AHBplayerGUID)
+                {
+                    itr->second->expire_time = sWorld->GetGameTime();
+                    uint32 id = itr->second->Id;
+                    uint32 expire_time = itr->second->expire_time;
+                    CharacterDatabase.PExecute("UPDATE auctionhouse SET time = '%u' WHERE id = '%u'", expire_time, id);
+                }
+                ++itr;
+            }
+        }
+        break;
+    case 1:     //min items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minitems = '%u' WHERE auctionhouse = '%u'", minItems, ahMapID);
+            config->SetMinItems(minItems);
+        }
+        break;
+    case 2:     //max items
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxItems = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxitems = '%u' WHERE auctionhouse = '%u'", maxItems, ahMapID);
+            config->SetMaxItems(maxItems);
+            config->CalculatePercents();
+        }
+        break;
+    case 3:     //min time Deprecated (Place holder for future commands)
+        break;
+    case 4:     //max time Deprecated (Place holder for future commands)
+        break;
+    case 5:     //percentages
+        {
+            char * param1 = strtok(args, " ");
+            char * param2 = strtok(NULL, " ");
+            char * param3 = strtok(NULL, " ");
+            char * param4 = strtok(NULL, " ");
+            char * param5 = strtok(NULL, " ");
+            char * param6 = strtok(NULL, " ");
+            char * param7 = strtok(NULL, " ");
+            char * param8 = strtok(NULL, " ");
+            char * param9 = strtok(NULL, " ");
+            char * param10 = strtok(NULL, " ");
+            char * param11 = strtok(NULL, " ");
+            char * param12 = strtok(NULL, " ");
+            char * param13 = strtok(NULL, " ");
+            char * param14 = strtok(NULL, " ");
+            uint32 greytg = (uint32) strtoul(param1, NULL, 0);
+            uint32 whitetg = (uint32) strtoul(param2, NULL, 0);
+            uint32 greentg = (uint32) strtoul(param3, NULL, 0);
+            uint32 bluetg = (uint32) strtoul(param4, NULL, 0);
+            uint32 purpletg = (uint32) strtoul(param5, NULL, 0);
+            uint32 orangetg = (uint32) strtoul(param6, NULL, 0);
+            uint32 yellowtg = (uint32) strtoul(param7, NULL, 0);
+            uint32 greyi = (uint32) strtoul(param8, NULL, 0);
+            uint32 whitei = (uint32) strtoul(param9, NULL, 0);
+            uint32 greeni = (uint32) strtoul(param10, NULL, 0);
+            uint32 bluei = (uint32) strtoul(param11, NULL, 0);
+            uint32 purplei = (uint32) strtoul(param12, NULL, 0);
+            uint32 orangei = (uint32) strtoul(param13, NULL, 0);
+            uint32 yellowi = (uint32) strtoul(param14, NULL, 0);
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            trans->PAppend("UPDATE auctionhousebot SET percentgreytradegoods = '%u' WHERE auctionhouse = '%u'", greytg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentwhitetradegoods = '%u' WHERE auctionhouse = '%u'", whitetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreentradegoods = '%u' WHERE auctionhouse = '%u'", greentg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentbluetradegoods = '%u' WHERE auctionhouse = '%u'", bluetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentpurpletradegoods = '%u' WHERE auctionhouse = '%u'", purpletg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentorangetradegoods = '%u' WHERE auctionhouse = '%u'", orangetg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentyellowtradegoods = '%u' WHERE auctionhouse = '%u'", yellowtg, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreyitems = '%u' WHERE auctionhouse = '%u'", greyi, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentwhiteitems = '%u' WHERE auctionhouse = '%u'", whitei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentgreenitems = '%u' WHERE auctionhouse = '%u'", greeni, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentblueitems = '%u' WHERE auctionhouse = '%u'", bluei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentpurpleitems = '%u' WHERE auctionhouse = '%u'", purplei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentorangeitems = '%u' WHERE auctionhouse = '%u'", orangei, ahMapID);
+            trans->PAppend("UPDATE auctionhousebot SET percentyellowitems = '%u' WHERE auctionhouse = '%u'", yellowi, ahMapID);
+            CharacterDatabase.CommitTransaction( trans);
+            config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        }
+        break;
+    case 6:     //min prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minPrice, ahMapID);
+            config->SetMinPrice(col, minPrice);
+        }
+        break;
+    case 7:     //max prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxPrice, ahMapID);
+            config->SetMaxPrice(col, maxPrice);
+        }
+        break;
+    case 8:     //min bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 minBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET minbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), minBidPrice, ahMapID);
+            config->SetMinBidPrice(col, minBidPrice);
+        }
+        break;
+    case 9:     //max bid price
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxBidPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxbidprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxBidPrice, ahMapID);
+            config->SetMaxBidPrice(col, maxBidPrice);
+        }
+        break;
+    case 10:        //max stacks
+        {
+            char * param1 = strtok(args, " ");
+            uint32 maxStack = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET maxstack%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), maxStack, ahMapID);
+            config->SetMaxStack(col, maxStack);
+        }
+        break;
+    case 11:        //buyer bid prices
+        {
+            char * param1 = strtok(args, " ");
+            uint32 buyerPrice = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerprice%s = '%u' WHERE auctionhouse = '%u'",color.c_str(), buyerPrice, ahMapID);
+            config->SetBuyerPrice(col, buyerPrice);
+        }
+        break;
+    case 12:        //buyer bidding interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbiddinginterval = '%u' WHERE auctionhouse = '%u'", bidInterval, ahMapID);
+            config->SetBiddingInterval(bidInterval);
+        }
+        break;
+    case 13:        //buyer bids per interval
+        {
+            char * param1 = strtok(args, " ");
+            uint32 bidsPerInterval = (uint32) strtoul(param1, NULL, 0);
+            CharacterDatabase.PExecute("UPDATE auctionhousebot SET buyerbidsperinterval = '%u' WHERE auctionhouse = '%u'", bidsPerInterval, ahMapID);
+            config->SetBidsPerInterval(bidsPerInterval);
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+void AuctionHouseBot::LoadValues(AHBConfig *config)
+{
+    if (debug_Out) sLog->outString(((std::string)("Start Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetString())).c_str());
+    if (AHBSeller)
+    {
+        //load min and max items
+        config->SetMinItems(CharacterDatabase.PQuery("SELECT minitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxItems(CharacterDatabase.PQuery("SELECT maxitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load percentages
+        uint32 greytg = CharacterDatabase.PQuery("SELECT percentgreytradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitetg = CharacterDatabase.PQuery("SELECT percentwhitetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greentg = CharacterDatabase.PQuery("SELECT percentgreentradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluetg = CharacterDatabase.PQuery("SELECT percentbluetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purpletg = CharacterDatabase.PQuery("SELECT percentpurpletradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangetg = CharacterDatabase.PQuery("SELECT percentorangetradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowtg = CharacterDatabase.PQuery("SELECT percentyellowtradegoods FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greyi = CharacterDatabase.PQuery("SELECT percentgreyitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 whitei = CharacterDatabase.PQuery("SELECT percentwhiteitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 greeni = CharacterDatabase.PQuery("SELECT percentgreenitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 bluei = CharacterDatabase.PQuery("SELECT percentblueitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 purplei = CharacterDatabase.PQuery("SELECT percentpurpleitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 orangei = CharacterDatabase.PQuery("SELECT percentorangeitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        uint32 yellowi = CharacterDatabase.PQuery("SELECT percentyellowitems FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32();
+        config->SetPercentages(greytg, whitetg, greentg, bluetg, purpletg, orangetg, yellowtg, greyi, whitei, greeni, bluei, purplei, orangei, yellowi);
+        //load min and max prices
+        config->SetMinPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load min and max bid prices
+        config->SetMinBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT minbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT maxbidpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT minbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxbidpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT minbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxbidpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT minbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxbidpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT minbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxbidpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT minbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxbidpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMinBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT minbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxBidPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxbidpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load max stacks
+        config->SetMaxStack(AHB_GREY, CharacterDatabase.PQuery("SELECT maxstackgrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_WHITE, CharacterDatabase.PQuery("SELECT maxstackwhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_GREEN, CharacterDatabase.PQuery("SELECT maxstackgreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_BLUE, CharacterDatabase.PQuery("SELECT maxstackblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_PURPLE, CharacterDatabase.PQuery("SELECT maxstackpurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_ORANGE, CharacterDatabase.PQuery("SELECT maxstackorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetMaxStack(AHB_YELLOW, CharacterDatabase.PQuery("SELECT maxstackyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog->outString("minItems                = %u", config->GetMinItems());
+            sLog->outString("maxItems                = %u", config->GetMaxItems());
+            sLog->outString("percentGreyTradeGoods   = %u", config->GetPercentages(AHB_GREY_TG));
+            sLog->outString("percentWhiteTradeGoods  = %u", config->GetPercentages(AHB_WHITE_TG));
+            sLog->outString("percentGreenTradeGoods  = %u", config->GetPercentages(AHB_GREEN_TG));
+            sLog->outString("percentBlueTradeGoods   = %u", config->GetPercentages(AHB_BLUE_TG));
+            sLog->outString("percentPurpleTradeGoods = %u", config->GetPercentages(AHB_PURPLE_TG));
+            sLog->outString("percentOrangeTradeGoods = %u", config->GetPercentages(AHB_ORANGE_TG));
+            sLog->outString("percentYellowTradeGoods = %u", config->GetPercentages(AHB_YELLOW_TG));
+            sLog->outString("percentGreyItems        = %u", config->GetPercentages(AHB_GREY_I));
+            sLog->outString("percentWhiteItems       = %u", config->GetPercentages(AHB_WHITE_I));
+            sLog->outString("percentGreenItems       = %u", config->GetPercentages(AHB_GREEN_I));
+            sLog->outString("percentBlueItems        = %u", config->GetPercentages(AHB_BLUE_I));
+            sLog->outString("percentPurpleItems      = %u", config->GetPercentages(AHB_PURPLE_I));
+            sLog->outString("percentOrangeItems      = %u", config->GetPercentages(AHB_ORANGE_I));
+            sLog->outString("percentYellowItems      = %u", config->GetPercentages(AHB_YELLOW_I));
+            sLog->outString("minPriceGrey            = %u", config->GetMinPrice(AHB_GREY));
+            sLog->outString("maxPriceGrey            = %u", config->GetMaxPrice(AHB_GREY));
+            sLog->outString("minPriceWhite           = %u", config->GetMinPrice(AHB_WHITE));
+            sLog->outString("maxPriceWhite           = %u", config->GetMaxPrice(AHB_WHITE));
+            sLog->outString("minPriceGreen           = %u", config->GetMinPrice(AHB_GREEN));
+            sLog->outString("maxPriceGreen           = %u", config->GetMaxPrice(AHB_GREEN));
+            sLog->outString("minPriceBlue            = %u", config->GetMinPrice(AHB_BLUE));
+            sLog->outString("maxPriceBlue            = %u", config->GetMaxPrice(AHB_BLUE));
+            sLog->outString("minPricePurple          = %u", config->GetMinPrice(AHB_PURPLE));
+            sLog->outString("maxPricePurple          = %u", config->GetMaxPrice(AHB_PURPLE));
+            sLog->outString("minPriceOrange          = %u", config->GetMinPrice(AHB_ORANGE));
+            sLog->outString("maxPriceOrange          = %u", config->GetMaxPrice(AHB_ORANGE));
+            sLog->outString("minPriceYellow          = %u", config->GetMinPrice(AHB_YELLOW));
+            sLog->outString("maxPriceYellow          = %u", config->GetMaxPrice(AHB_YELLOW));
+            sLog->outString("minBidPriceGrey         = %u", config->GetMinBidPrice(AHB_GREY));
+            sLog->outString("maxBidPriceGrey         = %u", config->GetMaxBidPrice(AHB_GREY));
+            sLog->outString("minBidPriceWhite        = %u", config->GetMinBidPrice(AHB_WHITE));
+            sLog->outString("maxBidPriceWhite        = %u", config->GetMaxBidPrice(AHB_WHITE));
+            sLog->outString("minBidPriceGreen        = %u", config->GetMinBidPrice(AHB_GREEN));
+            sLog->outString("maxBidPriceGreen        = %u", config->GetMaxBidPrice(AHB_GREEN));
+            sLog->outString("minBidPriceBlue         = %u", config->GetMinBidPrice(AHB_BLUE));
+            sLog->outString("maxBidPriceBlue         = %u", config->GetMinBidPrice(AHB_BLUE));
+            sLog->outString("minBidPricePurple       = %u", config->GetMinBidPrice(AHB_PURPLE));
+            sLog->outString("maxBidPricePurple       = %u", config->GetMaxBidPrice(AHB_PURPLE));
+            sLog->outString("minBidPriceOrange       = %u", config->GetMinBidPrice(AHB_ORANGE));
+            sLog->outString("maxBidPriceOrange       = %u", config->GetMaxBidPrice(AHB_ORANGE));
+            sLog->outString("minBidPriceYellow       = %u", config->GetMinBidPrice(AHB_YELLOW));
+            sLog->outString("maxBidPriceYellow       = %u", config->GetMaxBidPrice(AHB_YELLOW));
+            sLog->outString("maxStackGrey            = %u", config->GetMaxStack(AHB_GREY));
+            sLog->outString("maxStackWhite           = %u", config->GetMaxStack(AHB_WHITE));
+            sLog->outString("maxStackGreen           = %u", config->GetMaxStack(AHB_GREEN));
+            sLog->outString("maxStackBlue            = %u", config->GetMaxStack(AHB_BLUE));
+            sLog->outString("maxStackPurple          = %u", config->GetMaxStack(AHB_PURPLE));
+            sLog->outString("maxStackOrange          = %u", config->GetMaxStack(AHB_ORANGE));
+            sLog->outString("maxStackYellow          = %u", config->GetMaxStack(AHB_YELLOW));
+        }
+        //AuctionHouseEntry const* ahEntry =  sAuctionMgr->GetAuctionHouseEntry(config->GetAHFID());
+        AuctionHouseObject* auctionHouse =  sAuctionMgr->GetAuctionsMap(config->GetAHFID());
+
+        config->ResetItemCounts();
+        uint32 auctions = auctionHouse->Getcount();
+
+        if (auctions)
+        {
+            for (AuctionHouseObject::AuctionEntryMap::const_iterator itr = auctionHouse->GetAuctionsBegin(); itr != auctionHouse->GetAuctionsEnd(); ++itr)
+            {
+                AuctionEntry *Aentry = itr->second;
+                Item *item =  sAuctionMgr->GetAItem(Aentry->item_guidlow);
+                if (item)
+                {
+                    ItemPrototype const *prototype = item->GetProto();
+                    if (prototype)
+                    {
+                        switch (prototype->Quality)
+                        {
+                        case 0:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_GREY_TG);
+                            else
+                                config->IncItemCounts(AHB_GREY_I);
+                            break;
+                        case 1:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_WHITE_TG);
+                            else
+                                config->IncItemCounts(AHB_WHITE_I);
+                            break;
+                        case 2:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_GREEN_TG);
+                            else
+                                config->IncItemCounts(AHB_GREEN_I);
+                            break;
+                        case 3:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_BLUE_TG);
+                            else
+                                config->IncItemCounts(AHB_BLUE_I);
+                            break;
+                        case 4:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_PURPLE_TG);
+                            else
+                                config->IncItemCounts(AHB_PURPLE_I);
+                            break;
+                        case 5:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_ORANGE_TG);
+                            else
+                                config->IncItemCounts(AHB_ORANGE_I);
+                            break;
+                        case 6:
+                            if (prototype->Class == ITEM_CLASS_TRADE_GOODS)
+                                config->IncItemCounts(AHB_YELLOW_TG);
+                            else
+                                config->IncItemCounts(AHB_YELLOW_I);
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        if (debug_Out)
+        {
+            sLog->outString(((std::string)("Current Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetString())).c_str());
+            sLog->outString("Grey Trade Goods\t%u\tGrey Items\t%u", config->GetItemCounts(AHB_GREY_TG), config->GetItemCounts(AHB_GREY_I));
+            sLog->outString("White Trade Goods\t%u\tWhite Items\t%u", config->GetItemCounts(AHB_WHITE_TG), config->GetItemCounts(AHB_WHITE_I));
+            sLog->outString("Green Trade Goods\t%u\tGreen Items\t%u", config->GetItemCounts(AHB_GREEN_TG), config->GetItemCounts(AHB_GREEN_I));
+            sLog->outString("Blue Trade Goods\t%u\tBlue Items\t%u", config->GetItemCounts(AHB_BLUE_TG), config->GetItemCounts(AHB_BLUE_I));
+            sLog->outString("Purple Trade Goods\t%u\tPurple Items\t%u", config->GetItemCounts(AHB_PURPLE_TG), config->GetItemCounts(AHB_PURPLE_I));
+            sLog->outString("Orange Trade Goods\t%u\tOrange Items\t%u", config->GetItemCounts(AHB_ORANGE_TG), config->GetItemCounts(AHB_ORANGE_I));
+            sLog->outString("Yellow Trade Goods\t%u\tYellow Items\t%u", config->GetItemCounts(AHB_YELLOW_TG), config->GetItemCounts(AHB_YELLOW_I));
+        }
+    }
+    if (AHBBuyer)
+    {
+        //load buyer bid prices
+        config->SetBuyerPrice(AHB_GREY, CharacterDatabase.PQuery("SELECT buyerpricegrey FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_WHITE, CharacterDatabase.PQuery("SELECT buyerpricewhite FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_GREEN, CharacterDatabase.PQuery("SELECT buyerpricegreen FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_BLUE, CharacterDatabase.PQuery("SELECT buyerpriceblue FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_PURPLE, CharacterDatabase.PQuery("SELECT buyerpricepurple FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_ORANGE, CharacterDatabase.PQuery("SELECT buyerpriceorange FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        config->SetBuyerPrice(AHB_YELLOW, CharacterDatabase.PQuery("SELECT buyerpriceyellow FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load bidding interval
+        config->SetBiddingInterval(CharacterDatabase.PQuery("SELECT buyerbiddinginterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        //load bids per interval
+        config->SetBidsPerInterval(CharacterDatabase.PQuery("SELECT buyerbidsperinterval FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetUInt32());
+        if (debug_Out)
+        {
+            sLog->outString("buyerPriceGrey          = %u", config->GetBuyerPrice(AHB_GREY));
+            sLog->outString("buyerPriceWhite         = %u", config->GetBuyerPrice(AHB_WHITE));
+            sLog->outString("buyerPriceGreen         = %u", config->GetBuyerPrice(AHB_GREEN));
+            sLog->outString("buyerPriceBlue          = %u", config->GetBuyerPrice(AHB_BLUE));
+            sLog->outString("buyerPricePurple        = %u", config->GetBuyerPrice(AHB_PURPLE));
+            sLog->outString("buyerPriceOrange        = %u", config->GetBuyerPrice(AHB_ORANGE));
+            sLog->outString("buyerPriceYellow        = %u", config->GetBuyerPrice(AHB_YELLOW));
+            sLog->outString("buyerBiddingInterval    = %u", config->GetBiddingInterval());
+            sLog->outString("buyerBidsPerInterval    = %u", config->GetBidsPerInterval());
+        }
+    }
+    if (debug_Out) sLog->outString(((std::string)("End Settings for %s Auctionhouses:", CharacterDatabase.PQuery("SELECT name FROM auctionhousebot WHERE auctionhouse = %u",config->GetAHID())->Fetch()->GetString())).c_str());
+}
diff --git a/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
new file mode 100644
index 0000000..6c3cf82
--- /dev/null
+++ b/src/server/game/AuctionHouse/AuctionHouseBot/AuctionHouseBot.h
@@ -0,0 +1,1247 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef AUCTION_HOUSE_BOT_H
+#define AUCTION_HOUSE_BOT_H
+
+#include "World.h"
+#include "Config.h"
+#include "ItemPrototype.h"
+
+#define AHB_GREY        0
+#define AHB_WHITE       1
+#define AHB_GREEN       2
+#define AHB_BLUE        3
+#define AHB_PURPLE      4
+#define AHB_ORANGE      5
+#define AHB_YELLOW      6
+#define AHB_MAX_QUALITY 6
+#define AHB_GREY_TG     0
+#define AHB_WHITE_TG    1
+#define AHB_GREEN_TG    2
+#define AHB_BLUE_TG     3
+#define AHB_PURPLE_TG   4
+#define AHB_ORANGE_TG   5
+#define AHB_YELLOW_TG   6
+#define AHB_GREY_I      7
+#define AHB_WHITE_I     8
+#define AHB_GREEN_I     9
+#define AHB_BLUE_I      10
+#define AHB_PURPLE_I    11
+#define AHB_ORANGE_I    12
+#define AHB_YELLOW_I    13
+
+class AHBConfig
+{
+private:
+    uint32 AHID;
+    uint32 AHFID;
+    uint32 minItems;
+    uint32 maxItems;
+    uint32 percentGreyTradeGoods;
+    uint32 percentWhiteTradeGoods;
+    uint32 percentGreenTradeGoods;
+    uint32 percentBlueTradeGoods;
+    uint32 percentPurpleTradeGoods;
+    uint32 percentOrangeTradeGoods;
+    uint32 percentYellowTradeGoods;
+    uint32 percentGreyItems;
+    uint32 percentWhiteItems;
+    uint32 percentGreenItems;
+    uint32 percentBlueItems;
+    uint32 percentPurpleItems;
+    uint32 percentOrangeItems;
+    uint32 percentYellowItems;
+    uint32 minPriceGrey;
+    uint32 maxPriceGrey;
+    uint32 minBidPriceGrey;
+    uint32 maxBidPriceGrey;
+    uint32 maxStackGrey;
+    uint32 minPriceWhite;
+    uint32 maxPriceWhite;
+    uint32 minBidPriceWhite;
+    uint32 maxBidPriceWhite;
+    uint32 maxStackWhite;
+    uint32 minPriceGreen;
+    uint32 maxPriceGreen;
+    uint32 minBidPriceGreen;
+    uint32 maxBidPriceGreen;
+    uint32 maxStackGreen;
+    uint32 minPriceBlue;
+    uint32 maxPriceBlue;
+    uint32 minBidPriceBlue;
+    uint32 maxBidPriceBlue;
+    uint32 maxStackBlue;
+    uint32 minPricePurple;
+    uint32 maxPricePurple;
+    uint32 minBidPricePurple;
+    uint32 maxBidPricePurple;
+    uint32 maxStackPurple;
+    uint32 minPriceOrange;
+    uint32 maxPriceOrange;
+    uint32 minBidPriceOrange;
+    uint32 maxBidPriceOrange;
+    uint32 maxStackOrange;
+    uint32 minPriceYellow;
+    uint32 maxPriceYellow;
+    uint32 minBidPriceYellow;
+    uint32 maxBidPriceYellow;
+    uint32 maxStackYellow;
+
+    uint32 buyerPriceGrey;
+    uint32 buyerPriceWhite;
+    uint32 buyerPriceGreen;
+    uint32 buyerPriceBlue;
+    uint32 buyerPricePurple;
+    uint32 buyerPriceOrange;
+    uint32 buyerPriceYellow;
+    uint32 buyerBiddingInterval;
+    uint32 buyerBidsPerInterval;
+
+    uint32 greytgp;
+    uint32 whitetgp;
+    uint32 greentgp;
+    uint32 bluetgp;
+    uint32 purpletgp;
+    uint32 orangetgp;
+    uint32 yellowtgp;
+    uint32 greyip;
+    uint32 whiteip;
+    uint32 greenip;
+    uint32 blueip;
+    uint32 purpleip;
+    uint32 orangeip;
+    uint32 yellowip;
+
+    uint32 greyTGoods;
+    uint32 whiteTGoods;
+    uint32 greenTGoods;
+    uint32 blueTGoods;
+    uint32 purpleTGoods;
+    uint32 orangeTGoods;
+    uint32 yellowTGoods;
+
+    uint32 greyItems;
+    uint32 whiteItems;
+    uint32 greenItems;
+    uint32 blueItems;
+    uint32 purpleItems;
+    uint32 orangeItems;
+    uint32 yellowItems;
+
+public:
+    AHBConfig(uint32 ahid)
+    {
+        AHID = ahid;
+        switch(ahid)
+        {
+        case 2:
+            AHFID = 55;
+            break;
+        case 6:
+            AHFID = 29;
+            break;
+        case 7:
+            AHFID = 120;
+            break;
+        default:
+            AHFID = 120;
+            break;
+        }
+    }
+    AHBConfig()
+    {
+    }
+    uint32 GetAHID()
+    {
+        return AHID;
+    }
+    uint32 GetAHFID()
+    {
+        return AHFID;
+    }
+    void SetMinItems(uint32 value)
+    {
+        minItems = value;
+    }
+    uint32 GetMinItems()
+    {
+        if ((minItems == 0) && (maxItems))
+            return maxItems;
+        else if ((maxItems) && (minItems > maxItems))
+            return maxItems;
+        else
+            return minItems;
+    }
+    void SetMaxItems(uint32 value)
+    {
+        maxItems = value;
+    // CalculatePercents() needs to be called, but only if
+    // SetPercentages() has been called at least once already.
+    }
+    uint32 GetMaxItems()
+    {
+        return maxItems;
+    }
+    void SetPercentages(uint32 greytg, uint32 whitetg, uint32 greentg, uint32 bluetg, uint32 purpletg, uint32 orangetg, uint32 yellowtg, uint32 greyi, uint32 whitei, uint32 greeni, uint32 bluei, uint32 purplei, uint32 orangei, uint32 yellowi)
+    {
+        uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+
+        if (totalPercent == 0)
+        {
+            maxItems = 0;
+        }
+        else if (totalPercent != 100)
+        {
+            greytg = 0;
+            whitetg = 27;
+            greentg = 12;
+            bluetg = 10;
+            purpletg = 1;
+            orangetg = 0;
+            yellowtg = 0;
+            greyi = 0;
+            whitei = 10;
+            greeni = 30;
+            bluei = 8;
+            purplei = 2;
+            orangei = 0;
+            yellowi = 0;
+        }
+        percentGreyTradeGoods = greytg;
+        percentWhiteTradeGoods = whitetg;
+        percentGreenTradeGoods = greentg;
+        percentBlueTradeGoods = bluetg;
+        percentPurpleTradeGoods = purpletg;
+        percentOrangeTradeGoods = orangetg;
+        percentYellowTradeGoods = yellowtg;
+        percentGreyItems = greyi;
+        percentWhiteItems = whitei;
+        percentGreenItems = greeni;
+        percentBlueItems = bluei;
+        percentPurpleItems = purplei;
+        percentOrangeItems = orangei;
+        percentYellowItems = yellowi;
+        CalculatePercents();
+    }
+    uint32 GetPercentages(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return percentGreyTradeGoods;
+            break;
+        case AHB_WHITE_TG:
+            return percentWhiteTradeGoods;
+            break;
+        case AHB_GREEN_TG:
+            return percentGreenTradeGoods;
+            break;
+        case AHB_BLUE_TG:
+            return percentBlueTradeGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return percentPurpleTradeGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return percentOrangeTradeGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return percentYellowTradeGoods;
+            break;
+        case AHB_GREY_I:
+            return percentGreyItems;
+            break;
+        case AHB_WHITE_I:
+            return percentWhiteItems;
+            break;
+        case AHB_GREEN_I:
+            return percentGreenItems;
+            break;
+        case AHB_BLUE_I:
+            return percentBlueItems;
+            break;
+        case AHB_PURPLE_I:
+            return percentPurpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return percentOrangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return percentYellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetMinPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minPriceGrey == 0)
+                    return 100;
+                else if (minPriceGrey > maxPriceGrey)
+                    return maxPriceGrey;
+                else
+                    return minPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minPriceWhite == 0)
+                    return 150;
+                else if (minPriceWhite > maxPriceWhite)
+                    return maxPriceWhite;
+                else
+                    return minPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minPriceGreen == 0)
+                    return 200;
+                else if (minPriceGreen > maxPriceGreen)
+                    return maxPriceGreen;
+                else
+                    return minPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minPriceBlue == 0)
+                    return 250;
+                else if (minPriceBlue > maxPriceBlue)
+                    return maxPriceBlue;
+                else
+                    return minPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minPricePurple == 0)
+                    return 300;
+                else if (minPricePurple > maxPricePurple)
+                    return maxPricePurple;
+                else
+                    return minPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minPriceOrange == 0)
+                    return 400;
+                else if (minPriceOrange > maxPriceOrange)
+                    return maxPriceOrange;
+                else
+                    return minPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minPriceYellow == 0)
+                    return 500;
+                else if (minPriceYellow > maxPriceYellow)
+                    return maxPriceYellow;
+                else
+                    return minPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxPriceGrey == 0)
+                    return 150;
+                else
+                    return maxPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxPriceWhite == 0)
+                    return 250;
+                else
+                    return maxPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxPriceGreen == 0)
+                    return 300;
+                else
+                    return maxPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxPriceBlue == 0)
+                    return 350;
+                else
+                    return maxPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxPricePurple == 0)
+                    return 450;
+                else
+                    return maxPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxPriceOrange == 0)
+                    return 550;
+                else
+                    return maxPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxPriceYellow == 0)
+                    return 650;
+                else
+                    return maxPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMinBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            minBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            minBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            minBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            minBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            minBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            minBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            minBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMinBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (minBidPriceGrey > 100)
+                    return 100;
+                else
+                    return minBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (minBidPriceWhite > 100)
+                    return 100;
+                else
+                    return minBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (minBidPriceGreen > 100)
+                    return 100;
+                else
+                    return minBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (minBidPriceBlue > 100)
+                    return 100;
+                else
+                    return minBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (minBidPricePurple > 100)
+                    return 100;
+                else
+                    return minBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (minBidPriceOrange > 100)
+                    return 100;
+                else
+                    return minBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (minBidPriceYellow > 100)
+                    return 100;
+                else
+                    return minBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxBidPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxBidPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            maxBidPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            maxBidPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            maxBidPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxBidPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            maxBidPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxBidPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxBidPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                if (maxBidPriceGrey > 100)
+                    return 100;
+                else
+                    return maxBidPriceGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                if (maxBidPriceWhite > 100)
+                    return 100;
+                else
+                    return maxBidPriceWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                if (maxBidPriceGreen > 100)
+                    return 100;
+                else
+                    return maxBidPriceGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                if (maxBidPriceBlue > 100)
+                    return 100;
+                else
+                    return maxBidPriceBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                if (maxBidPricePurple > 100)
+                    return 100;
+                else
+                    return maxBidPricePurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                if (maxBidPriceOrange > 100)
+                    return 100;
+                else
+                    return maxBidPriceOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                if (maxBidPriceYellow > 100)
+                    return 100;
+                else
+                    return maxBidPriceYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetMaxStack(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            maxStackGrey = value;
+            break;
+        case AHB_WHITE:
+            maxStackWhite = value;
+            break;
+        case AHB_GREEN:
+            maxStackGreen = value;
+            break;
+        case AHB_BLUE:
+            maxStackBlue = value;
+            break;
+        case AHB_PURPLE:
+            maxStackPurple = value;
+            break;
+        case AHB_ORANGE:
+            maxStackOrange = value;
+            break;
+        case AHB_YELLOW:
+            maxStackYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetMaxStack(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            {
+                return maxStackGrey;
+                break;
+            }
+        case AHB_WHITE:
+            {
+                return maxStackWhite;
+                break;
+            }
+        case AHB_GREEN:
+            {
+                return maxStackGreen;
+                break;
+            }
+        case AHB_BLUE:
+            {
+                return maxStackBlue;
+                break;
+            }
+        case AHB_PURPLE:
+            {
+                return maxStackPurple;
+                break;
+            }
+        case AHB_ORANGE:
+            {
+                return maxStackOrange;
+                break;
+            }
+        case AHB_YELLOW:
+            {
+                return maxStackYellow;
+                break;
+            }
+        default:
+            {
+                return 0;
+                break;
+            }
+        }
+    }
+    void SetBuyerPrice(uint32 color, uint32 value)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            buyerPriceGrey = value;
+            break;
+        case AHB_WHITE:
+            buyerPriceWhite = value;
+            break;
+        case AHB_GREEN:
+            buyerPriceGreen = value;
+            break;
+        case AHB_BLUE:
+            buyerPriceBlue = value;
+            break;
+        case AHB_PURPLE:
+            buyerPricePurple = value;
+            break;
+        case AHB_ORANGE:
+            buyerPriceOrange = value;
+            break;
+        case AHB_YELLOW:
+            buyerPriceYellow = value;
+            break;
+        default:
+            break;
+        }
+    }
+    uint32 GetBuyerPrice(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY:
+            return buyerPriceGrey;
+            break;
+        case AHB_WHITE:
+            return buyerPriceWhite;
+            break;
+        case AHB_GREEN:
+            return buyerPriceGreen;
+            break;
+        case AHB_BLUE:
+            return buyerPriceBlue;
+            break;
+        case AHB_PURPLE:
+            return buyerPricePurple;
+            break;
+        case AHB_ORANGE:
+            return buyerPriceOrange;
+            break;
+        case AHB_YELLOW:
+            return buyerPriceYellow;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBiddingInterval(uint32 value)
+    {
+        buyerBiddingInterval = value;
+    }
+    uint32 GetBiddingInterval()
+    {
+        return buyerBiddingInterval;
+    }
+    void CalculatePercents()
+    {
+        greytgp = (uint32) (((double)percentGreyTradeGoods / 100.0) * maxItems);
+        whitetgp = (uint32) (((double)percentWhiteTradeGoods / 100.0) * maxItems);
+        greentgp = (uint32) (((double)percentGreenTradeGoods / 100.0) * maxItems);
+        bluetgp = (uint32) (((double)percentBlueTradeGoods / 100.0) * maxItems);
+        purpletgp = (uint32) (((double)percentPurpleTradeGoods / 100.0) * maxItems);
+        orangetgp = (uint32) (((double)percentOrangeTradeGoods / 100.0) * maxItems);
+        yellowtgp = (uint32) (((double)percentYellowTradeGoods / 100.0) * maxItems);
+        greyip = (uint32) (((double)percentGreyItems / 100.0) * maxItems);
+        whiteip = (uint32) (((double)percentWhiteItems / 100.0) * maxItems);
+        greenip = (uint32) (((double)percentGreenItems / 100.0) * maxItems);
+        blueip = (uint32) (((double)percentBlueItems / 100.0) * maxItems);
+        purpleip = (uint32) (((double)percentPurpleItems / 100.0) * maxItems);
+        orangeip = (uint32) (((double)percentOrangeItems / 100.0) * maxItems);
+        yellowip = (uint32) (((double)percentYellowItems / 100.0) * maxItems);
+        uint32 total = greytgp + whitetgp + greentgp + bluetgp + purpletgp + orangetgp + yellowtgp + greyip + whiteip + greenip + blueip + purpleip + orangeip + yellowip;
+        int32 diff = (maxItems - total);
+        if (diff < 0)
+        {
+            if ((whiteip - diff) > 0)
+                whiteip -= diff;
+            else if ((greenip - diff) > 0)
+                greenip -= diff;
+        }
+        else if (diff < 0)
+        {
+            whiteip += diff;
+        }
+    }
+    uint32 GetPercents(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greytgp;
+            break;
+        case AHB_WHITE_TG:
+            return whitetgp;
+            break;
+        case AHB_GREEN_TG:
+            return greentgp;
+            break;
+        case AHB_BLUE_TG:
+            return bluetgp;
+            break;
+        case AHB_PURPLE_TG:
+            return purpletgp;
+            break;
+        case AHB_ORANGE_TG:
+            return orangetgp;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowtgp;
+            break;
+        case AHB_GREY_I:
+            return greyip;
+            break;
+        case AHB_WHITE_I:
+            return whiteip;
+            break;
+        case AHB_GREEN_I:
+            return greenip;
+            break;
+        case AHB_BLUE_I:
+            return blueip;
+            break;
+        case AHB_PURPLE_I:
+            return purpleip;
+            break;
+        case AHB_ORANGE_I:
+            return orangeip;
+            break;
+        case AHB_YELLOW_I:
+            return yellowip;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+
+    void DecItemCounts(uint32 Class, uint32 Quality)
+    {
+        switch(Class)
+        {
+        case ITEM_CLASS_TRADE_GOODS:
+            DecItemCounts(Quality);
+            break;
+        default:
+            DecItemCounts(Quality + 7);
+            break;
+        }
+    }
+
+    void DecItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            --greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            --whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            --greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            --blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            --purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            --orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            --yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            --greyItems;
+            break;
+        case AHB_WHITE_I:
+            --whiteItems;
+            break;
+        case AHB_GREEN_I:
+            --greenItems;
+            break;
+        case AHB_BLUE_I:
+            --blueItems;
+            break;
+        case AHB_PURPLE_I:
+            --purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            --orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            --yellowItems;
+            break;
+        default:
+            break;
+        }
+    }
+
+    void IncItemCounts(uint32 Class, uint32 Quality)
+    {
+        switch(Class)
+        {
+        case ITEM_CLASS_TRADE_GOODS:
+            IncItemCounts(Quality);
+            break;
+        default:
+            IncItemCounts(Quality + 7);
+            break;
+        }
+    }
+
+    void IncItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            ++greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            ++whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            ++greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            ++blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            ++purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            ++orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            ++yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            ++greyItems;
+            break;
+        case AHB_WHITE_I:
+            ++whiteItems;
+            break;
+        case AHB_GREEN_I:
+            ++greenItems;
+            break;
+        case AHB_BLUE_I:
+            ++blueItems;
+            break;
+        case AHB_PURPLE_I:
+            ++purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            ++orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            ++yellowItems;
+            break;
+        default:
+            break;
+        }
+    }
+
+    void ResetItemCounts()
+    {
+        greyTGoods = 0;
+        whiteTGoods = 0;
+        greenTGoods = 0;
+        blueTGoods = 0;
+        purpleTGoods = 0;
+        orangeTGoods = 0;
+        yellowTGoods = 0;
+
+        greyItems = 0;
+        whiteItems = 0;
+        greenItems = 0;
+        blueItems = 0;
+        purpleItems = 0;
+        orangeItems = 0;
+        yellowItems = 0;
+    }
+
+    uint32 TotalItemCounts()
+    {
+        return(
+        greyTGoods +
+        whiteTGoods +
+        greenTGoods +
+        blueTGoods +
+        purpleTGoods +
+        orangeTGoods +
+        yellowTGoods +
+
+        greyItems +
+        whiteItems +
+        greenItems +
+        blueItems +
+        purpleItems +
+        orangeItems +
+        yellowItems);
+    }
+
+    uint32 GetItemCounts(uint32 color)
+    {
+        switch(color)
+        {
+        case AHB_GREY_TG:
+            return greyTGoods;
+            break;
+        case AHB_WHITE_TG:
+            return whiteTGoods;
+            break;
+        case AHB_GREEN_TG:
+            return greenTGoods;
+            break;
+        case AHB_BLUE_TG:
+            return blueTGoods;
+            break;
+        case AHB_PURPLE_TG:
+            return purpleTGoods;
+            break;
+        case AHB_ORANGE_TG:
+            return orangeTGoods;
+            break;
+        case AHB_YELLOW_TG:
+            return yellowTGoods;
+            break;
+        case AHB_GREY_I:
+            return greyItems;
+            break;
+        case AHB_WHITE_I:
+            return whiteItems;
+            break;
+        case AHB_GREEN_I:
+            return greenItems;
+            break;
+        case AHB_BLUE_I:
+            return blueItems;
+            break;
+        case AHB_PURPLE_I:
+            return purpleItems;
+            break;
+        case AHB_ORANGE_I:
+            return orangeItems;
+            break;
+        case AHB_YELLOW_I:
+            return yellowItems;
+            break;
+        default:
+            return 0;
+            break;
+        }
+    }
+    void SetBidsPerInterval(uint32 value)
+    {
+        buyerBidsPerInterval = value;
+    }
+    uint32 GetBidsPerInterval()
+    {
+        return buyerBidsPerInterval;
+    }
+    ~AHBConfig()
+    {
+    }
+};
+class AuctionHouseBot
+{
+private:
+
+    bool debug_Out;
+    bool debug_Out_Filters;
+
+    bool AHBSeller;
+    bool AHBBuyer;
+    bool BuyMethod;
+    bool SellMethod;
+
+    uint32 AHBplayerAccount;
+    uint32 AHBplayerGUID;
+    uint32 ItemsPerCycle;
+
+    //Begin Filters
+
+    bool Vendor_Items;
+    bool Loot_Items;
+    bool Other_Items;
+    bool Vendor_TGs;
+    bool Loot_TGs;
+    bool Other_TGs;
+
+    bool No_Bind;
+    bool Bind_When_Picked_Up;
+    bool Bind_When_Equipped;
+    bool Bind_When_Use;
+    bool Bind_Quest_Item;
+
+    bool DisableBeta_PTR_Unused;
+    bool DisablePermEnchant;
+    bool DisableConjured;
+    bool DisableGems;
+    bool DisableMoney;
+    bool DisableMoneyLoot;
+    bool DisableLootable;
+    bool DisableKeys;
+    bool DisableDuration;
+    bool DisableBOP_Or_Quest_NoReqLevel;
+
+    bool DisableWarriorItems;
+    bool DisablePaladinItems;
+    bool DisableHunterItems;
+    bool DisableRogueItems;
+    bool DisablePriestItems;
+    bool DisableDKItems;
+    bool DisableShamanItems;
+    bool DisableMageItems;
+    bool DisableWarlockItems;
+    bool DisableUnusedClassItems;
+    bool DisableDruidItems;
+
+    uint32 DisableItemsBelowLevel;
+    uint32 DisableItemsAboveLevel;
+    uint32 DisableTGsBelowLevel;
+    uint32 DisableTGsAboveLevel;
+    uint32 DisableItemsBelowGUID;
+    uint32 DisableItemsAboveGUID;
+    uint32 DisableTGsBelowGUID;
+    uint32 DisableTGsAboveGUID;
+    uint32 DisableItemsBelowReqLevel;
+    uint32 DisableItemsAboveReqLevel;
+    uint32 DisableTGsBelowReqLevel;
+    uint32 DisableTGsAboveReqLevel;
+    uint32 DisableItemsBelowReqSkillRank;
+    uint32 DisableItemsAboveReqSkillRank;
+    uint32 DisableTGsBelowReqSkillRank;
+    uint32 DisableTGsAboveReqSkillRank;
+
+    //End Filters
+
+    AHBConfig AllianceConfig;
+    AHBConfig HordeConfig;
+    AHBConfig NeutralConfig;
+
+    time_t _lastrun_a;
+    time_t _lastrun_h;
+    time_t _lastrun_n;
+
+    inline uint32 minValue(uint32 a, uint32 b) { return a <= b ? a : b; };
+    void addNewAuctions(Player *AHBplayer, AHBConfig *config);
+    void addNewAuctionBuyerBotBid(Player *AHBplayer, AHBConfig *config, WorldSession *session);
+
+    friend class ACE_Singleton<AuctionHouseBot, ACE_Null_Mutex>;
+    AuctionHouseBot();
+
+public:
+    ~AuctionHouseBot();
+    void Update();
+    void Initialize();
+    void LoadValues(AHBConfig*);
+    void DecrementItemCounts(AuctionEntry* ah, uint32 item_template);
+    void IncrementItemCounts(AuctionEntry* ah);
+    void Commands(uint32, uint32, uint32, char*);
+    uint32 GetAHBplayerGUID() { return AHBplayerGUID; };
+};
+
+#define auctionbot (*ACE_Singleton<AuctionHouseBot, ACE_Null_Mutex>::instance())
+
+#endif
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index 8a04b75..728e018 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -218,7 +218,7 @@ void AuctionHouseMgr::SendAuctionSuccessfulMail(AuctionEntry * auction, SQLTrans
         uint32 profit = auction->bid + auction->deposit - auctionCut;
 
         //FIXME: what do if owner offline
-        if (owner)
+        if (owner && owner->GetGUIDLow() != auctionbot.GetAHBplayerGUID())
         {
             owner->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_EARNED_BY_AUCTIONS, profit);
             owner->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_AUCTION_SOLD, auction->bid);
@@ -248,7 +248,7 @@ void AuctionHouseMgr::SendAuctionExpiredMail(AuctionEntry * auction, SQLTransact
         std::ostringstream subject;
         subject << auction->item_template << ":0:" << AUCTION_EXPIRED << ":0:0";
 
-        if (owner)
+        if (owner && owner->GetGUIDLow() != auctionbot.GetAHBplayerGUID())
             owner->GetSession()->SendAuctionOwnerNotification(auction);
 
         MailDraft(subject.str(), "")                        // TODO: fix body
@@ -273,6 +273,9 @@ void AuctionHouseMgr::SendAuctionOutbiddedMail(AuctionEntry *auction, uint32 new
         std::ostringstream msgAuctionOutbiddedSubject;
         msgAuctionOutbiddedSubject << auction->item_template << ":0:" << AUCTION_OUTBIDDED << ":0:0";
 
+        if (oldBidder && !newBidder)
+            oldBidder->GetSession()->SendAuctionBidderNotification(auction->GetHouseId(), auction->Id, auctionbot.GetAHBplayerGUID(), newPrice, auction->GetAuctionOutBid(), auction->item_template);
+
         if (oldBidder && newBidder)
             oldBidder->GetSession()->SendAuctionBidderNotification(auction->GetHouseId(), auction->Id, newBidder->GetGUID(), newPrice, auction->GetAuctionOutBid(), auction->item_template);
 
@@ -463,11 +466,13 @@ void AuctionHouseObject::AddAuction(AuctionEntry *auction)
 
     AuctionsMap[auction->Id] = auction;
     sScriptMgr->OnAuctionAdd(this, auction);
+	auctionbot.IncrementItemCounts(auction);
 }
 
-bool AuctionHouseObject::RemoveAuction(AuctionEntry *auction, uint32 /*item_template*/)
+bool AuctionHouseObject::RemoveAuction(AuctionEntry *auction, uint32 item_template)
 {
-    bool wasInMap = AuctionsMap.erase(auction->Id) ? true : false;
+    auctionbot.DecrementItemCounts(auction, item_template);
+	bool wasInMap = AuctionsMap.erase(auction->Id) ? true : false;
 
     sScriptMgr->OnAuctionRemove(this, auction);
 
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.h b/src/server/game/AuctionHouse/AuctionHouseMgr.h
index bf9edbc..910eed4 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.h
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.h
@@ -25,6 +25,8 @@
 #include "DatabaseEnv.h"
 #include "DBCStructure.h"
 
+#include "AuctionHouseBot/AuctionHouseBot.h"
+
 class Item;
 class Player;
 class WorldPacket;
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
index 1658f76..ecb14b8 100755
--- a/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundDS.cpp
@@ -37,6 +37,9 @@ BattlegroundDS::BattlegroundDS()
     m_StartMessageIds[BG_STARTING_EVENT_SECOND] = LANG_ARENA_THIRTY_SECONDS;
     m_StartMessageIds[BG_STARTING_EVENT_THIRD]  = LANG_ARENA_FIFTEEN_SECONDS;
     m_StartMessageIds[BG_STARTING_EVENT_FOURTH] = LANG_ARENA_HAS_BEGUN;
+
+    m_knockback = 5000;
+    m_knockbackCheck = true;
 }
 
 BattlegroundDS::~BattlegroundDS()
@@ -76,6 +79,23 @@ void BattlegroundDS::Update(uint32 diff)
     }
     else
         setWaterFallTimer(getWaterFallTimer() - diff);
+
+        if (GetStatus() == STATUS_IN_PROGRESS)
+        {
+                if(m_knockback < diff && m_knockbackCheck)
+                {
+                        for(BattlegroundPlayerMap::const_iterator itr = GetPlayers().begin(); itr != GetPlayers().end();itr++)
+                        {
+                                Player * plr = sObjectMgr->GetPlayer(itr->first);
+                                if (plr->GetTeam() == ALLIANCE && plr->GetDistance2d(1214, 765) <= 50 && plr->GetPositionZ() > 10)
+                                        KnockBackPlayer(plr, 6.15f, 50.00f, 7.00f);
+                                if (plr->GetTeam() == HORDE && plr->GetDistance2d(1369, 817) <= 50 && plr->GetPositionZ() > 10)
+                                        KnockBackPlayer(plr, 3.10f, 50.00f, 7.00f);
+                                plr->RemoveAurasDueToSpell(48018);
+                        }
+                        m_knockbackCheck = false;
+                 } else m_knockback -= diff;
+        }
 }
 
 void BattlegroundDS::StartingEventCloseDoors()
@@ -97,6 +117,9 @@ void BattlegroundDS::StartingEventOpenDoors()
 
     for (uint32 i = BG_DS_OBJECT_WATER_1; i <= BG_DS_OBJECT_WATER_2; ++i)
         SpawnBGObject(i, getWaterFallTimer());
+
+    m_knockback = 5000;
+    m_knockbackCheck = true;
 }
 
 void BattlegroundDS::AddPlayer(Player *plr)
@@ -169,6 +192,8 @@ void BattlegroundDS::Reset()
 {
     //call parent's class reset
     Battleground::Reset();
+    m_knockback = 5000;
+    m_knockbackCheck = true;
 }
 
 
@@ -190,3 +215,20 @@ bool BattlegroundDS::SetupBattleground()
 
     return true;
 }
+
+void BattlegroundDS::KnockBackPlayer(Unit *pPlayer, float angle, float horizontalSpeed, float verticalSpeed)
+{
+    if(pPlayer->GetTypeId() == TYPEID_PLAYER)
+    {
+        WorldPacket data(SMSG_MOVE_KNOCK_BACK, 8+4+4+4+4+2);
+        data.append(pPlayer->GetPackGUID());
+        data << uint32(0);
+        data << float(cos(angle));
+        data << float(sin(angle));
+        data << float(horizontalSpeed);
+        data << float(-verticalSpeed);
+        ((Player*)pPlayer)->GetSession()->SendPacket(&data);
+    }
+    else
+        sLog->outError("The target of KnockBackPlayer must be a player !");
+}
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundDS.h b/src/server/game/Battlegrounds/Zones/BattlegroundDS.h
index 0071a38..057dd35 100755
--- a/src/server/game/Battlegrounds/Zones/BattlegroundDS.h
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundDS.h
@@ -43,10 +43,10 @@ enum BattlegroundDSObjects
 };
 
 enum BattlegroundDSData
-{ // These values are NOT blizzlike... need the correct data!
-    BG_DS_WATERFALL_TIMER_MIN                    = 30000,
+{
+    BG_DS_WATERFALL_TIMER_MIN                    = 35000,
     BG_DS_WATERFALL_TIMER_MAX                    = 60000,
-    BG_DS_WATERFALL_DURATION                     = 10000,
+    BG_DS_WATERFALL_DURATION                     = 30000,
 };
 
 class BattlegroundDSScore : public BattlegroundScore
@@ -81,6 +81,9 @@ class BattlegroundDS : public Battleground
     private:
         uint32 m_waterTimer;
         bool m_waterfallActive;
+        bool m_knockbackCheck;
+        uint32 m_knockback;
+        void KnockBackPlayer(Unit *pPlayer, float angle, float horizontalSpeed, float verticalSpeed);
     protected:
         bool isWaterFallActive() { return m_waterfallActive; };
         void setWaterFallActive(bool active) { m_waterfallActive = active; };
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 323a3ac..c95cc4b 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -17,6 +17,7 @@ file(GLOB_RECURSE sources_Achievements Achievements/*.cpp Achievements/*.h)
 file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
 file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
 file(GLOB_RECURSE sources_AuctionHouse AuctionHouse/*.cpp AuctionHouse/*.h)
+file(GLOB_RECURSE sources_AuctionHouseBot AuctionHouse/AuctionHouseBot/*.cpp AuctionHouse/AuctionHouseBot/*.h)
 file(GLOB_RECURSE sources_Battlegrounds Battlegrounds/*.cpp Battlegrounds/*.h)
 file(GLOB_RECURSE sources_Calendar Calendar/*.cpp Calendar/*.h)
 file(GLOB_RECURSE sources_Chat Chat/*.cpp Chat/*.h)
@@ -66,6 +67,7 @@ set(game_STAT_SRCS
   ${sources_Addons}
   ${sources_AI}
   ${sources_AuctionHouse}
+  ${sources_AuctionHouseBot}
   ${sources_Battlegrounds}
   ${sources_Calendar}
   ${sources_Chat}
@@ -132,6 +134,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
+  ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse/AuctionHouseBot
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
   ${CMAKE_CURRENT_SOURCE_DIR}/Calendar
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index fedf1c3..d3d58b1 100755
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -367,7 +367,12 @@ ChatCommand * ChatHandler::getCommandTable()
 
         { "pet",            SEC_GAMEMASTER,     false, NULL,                                           "", petCommandTable },
         { "ticket",         SEC_MODERATOR,      false,  NULL,                                          "", ticketCommandTable },
-
+	     // Jail by WarHead Edited by LordPsyan
+        { "jail",           SEC_MODERATOR,      false, OldHandler<&ChatHandler::HandleJailCommand>,                "", NULL },
+        { "jailinfo",       SEC_PLAYER,         false, OldHandler<&ChatHandler::HandleJailInfoCommand>,            "", NULL },
+        { "unjail",         SEC_MODERATOR,      false, OldHandler<&ChatHandler::HandleUnJailCommand>,              "", NULL },
+        { "jailreload",     SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleJailReloadCommand>,          "", NULL },
+		{ "ahbotoptions",   SEC_GAMEMASTER,     true,  OldHandler<&ChatHandler::HandleAHBotOptionsCommand>,        "", NULL },
         { "aura",           SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleAuraCommand>,                "", NULL },
         { "unaura",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnAuraCommand>,              "", NULL },
         { "nameannounce",   SEC_MODERATOR,      false, OldHandler<&ChatHandler::HandleNameAnnounceCommand>,        "", NULL },
diff --git a/src/server/game/Chat/Chat.h b/src/server/game/Chat/Chat.h
index 486987d..425959a 100755
--- a/src/server/game/Chat/Chat.h
+++ b/src/server/game/Chat/Chat.h
@@ -131,6 +131,7 @@ class ChatHandler
         bool ShowHelpForCommand(ChatCommand *table, const char* cmd);
         bool ShowHelpForSubCommands(ChatCommand *table, char const* cmd, char const* subcmd);
 
+        bool HandleAHBotOptionsCommand(const char * args);
         bool HandleNameAnnounceCommand(const char* args);
         bool HandleGMNameAnnounceCommand(const char* args);
         bool HandleGMAnnounceCommand(const char* args);
@@ -335,6 +336,12 @@ class ChatHandler
         bool HandleSendMessageCommand(const char * args);*/
 
         bool HandleFlushArenaPointsCommand(const char *args);
+        // Jail by WarHead Edited by spgm
+        bool HandleJailCommand(const char* args);
+		bool HandleJailInfoCommand(const char* args);
+		bool HandleUnJailCommand(const char* args);
+		bool HandleJailReloadCommand(const char* args);
+
         bool HandlePlayAllCommand(const char* args);
         bool HandleRepairitemsCommand(const char* args);
 
diff --git a/src/server/game/Chat/Commands/Level0.cpp b/src/server/game/Chat/Commands/Level0.cpp
index 5deed67..d619806 100755
--- a/src/server/game/Chat/Commands/Level0.cpp
+++ b/src/server/game/Chat/Commands/Level0.cpp
@@ -28,6 +28,7 @@
 #include "SystemConfig.h"
 #include "revision.h"
 #include "Util.h"
+#include "math.h"
 
 bool ChatHandler::HandleHelpCommand(const char* args)
 {
@@ -54,6 +55,13 @@ bool ChatHandler::HandleCommandsCommand(const char* /*args*/)
 
 bool ChatHandler::HandleStartCommand(const char* /*args*/)
 {
+		// Jail by WarHead edited by spgm
+    if (m_session->GetPlayer()->m_jail_isjailed)
+    {
+        SendSysMessage(LANG_JAIL_DENIED);
+        return true;
+    }
+
     Player *chr = m_session->GetPlayer();
 
     if (chr->isInFlight())
@@ -78,7 +86,7 @@ bool ChatHandler::HandleStartCommand(const char* /*args*/)
     }
 
     // cast spell Stuck
-    chr->CastSpell(chr, 7355, false);
+    chr->CastSpell(chr, 8690, false);
     return true;
 }
 
@@ -128,6 +136,13 @@ bool ChatHandler::HandleSaveCommand(const char* /*args*/)
 {
     Player *player = m_session->GetPlayer();
 
+		// Jail by WarHead edited by LordPsyan
+    if (player->m_jail_isjailed)
+    {
+        SendSysMessage(LANG_JAIL_DENIED);
+        return true;
+    }
+
     // save GM account without delay and output message
     if (m_session->GetSecurity() > SEC_PLAYER)
     {
@@ -150,4 +165,38 @@ bool ChatHandler::HandleServerMotdCommand(const char* /*args*/)
     PSendSysMessage(LANG_MOTD_CURRENT, sWorld->GetMotd());
     return true;
 }
+	//Trinity Jail Edited by spgm
+bool ChatHandler::HandleJailInfoCommand(const char* args)
+{
+    time_t localtime;
+    localtime = time(NULL);
+    Player *chr = m_session->GetPlayer();
+
+    if (chr->m_jail_release > 0)
+    {
+        uint32 min_left = (uint32)floor(float(chr->m_jail_release - localtime) / 60);
+
+        if (min_left <= 0)
+        {
+            chr->m_jail_release = 0;
+            chr->_SaveJail();
+            SendSysMessage(LANG_JAIL_NOTJAILED_INFO);
+            return true;
+        }
+        else
+        {
+            if (min_left >= 60) PSendSysMessage(LANG_JAIL_JAILED_H_INFO, (uint32)floor(float(chr->m_jail_release - localtime) / 60 / 60));
+            else PSendSysMessage(LANG_JAIL_JAILED_M_INFO, min_left);
+            PSendSysMessage(LANG_JAIL_REASON, chr->m_jail_gmchar.c_str(), chr->m_jail_reason.c_str());
+
+            return true;
+        }
+    }
+    else
+    {
+        SendSysMessage(LANG_JAIL_NOTJAILED_INFO);
+        return true;
+    }
+    return false;
+}
 
diff --git a/src/server/game/Chat/Commands/Level1.cpp b/src/server/game/Chat/Commands/Level1.cpp
index d5acf4b..cf15ec5 100755
--- a/src/server/game/Chat/Commands/Level1.cpp
+++ b/src/server/game/Chat/Commands/Level1.cpp
@@ -715,6 +715,292 @@ bool ChatHandler::HandleSaveAllCommand(const char* /*args*/)
     return true;
 }
 
+// Jail by WarHead edited by spgm
+bool ChatHandler::HandleJailCommand(const char *args)
+{
+    std::string cname, announce, ban_reason, ban_by;
+    time_t localtime;
+    localtime = time(NULL);
+
+    char *charname = strtok((char*)args, " ");
+    if (charname == NULL)
+    {
+        SendSysMessage(LANG_JAIL_NONAME);
+        return true;
+    } else cname = charname;
+
+    char *timetojail = strtok(NULL, " ");
+    if (timetojail == NULL)
+    {
+        SendSysMessage(LANG_JAIL_NOTIME);
+        return true;
+    }
+
+    uint32 jailtime = (uint32) atoi((char*)timetojail);
+    if (jailtime < 1 || jailtime > sObjectMgr->m_jailconf_max_duration)
+    {
+        PSendSysMessage(LANG_JAIL_VALUE, sObjectMgr->m_jailconf_max_duration);
+        return true;
+    }
+
+    char *reason = strtok(NULL, "\0");
+    std::string jailreason;
+    if (reason == NULL || strlen((const char*)reason) < sObjectMgr->m_jailconf_min_reason)
+    {
+        PSendSysMessage(LANG_JAIL_NOREASON, sObjectMgr->m_jailconf_min_reason);
+        return true;
+    } else jailreason = reason;
+
+    uint64 GUID = sObjectMgr->GetPlayerGUIDByName(cname.c_str());
+    if (GUID == 0)
+    {
+        SendSysMessage(LANG_JAIL_WRONG_NAME);
+        return true;
+    }
+
+    Player *chr = sObjectMgr->GetPlayer(GUID);
+    if (!chr)
+    {
+		uint32 jail_guid = GUID_LOPART(GUID);
+		std::string jail_char = cname;
+		bool jail_isjailed = true;
+		uint32 jail_release = localtime + (jailtime * 60 * 60);
+		uint32 jail_amnestietime = localtime +(60* 60 * 24 * sObjectMgr->m_jailconf_amnestie);
+		std::string jail_reason = jailreason;
+		uint32 jail_times = 0;
+
+		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+		QueryResult result = WorldDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", jail_guid);
+		CharacterDatabase.CommitTransaction(trans);
+
+        if (!result)
+        {
+            jail_times = 1;
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            jail_times = fields[5].GetUInt32()+1;
+        }
+
+        uint32 jail_gmacc = m_session->GetAccountId();
+        std::string jail_gmchar = m_session->GetPlayerName();
+
+        SQLTransaction trans2 = CharacterDatabase.BeginTransaction();
+		if (!result) CharacterDatabase.PExecute("INSERT INTO `jail` VALUES ('%u','%s','%u','%u','%s','%u','%u','%s',CURRENT_TIMESTAMP,'%u')", jail_guid, jail_char.c_str(), jail_release, jail_amnestietime, jail_reason.c_str(), jail_times, jail_gmacc, jail_gmchar.c_str(), jailtime);
+        else CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u', `amnestietime`='%u',`reason`='%s',`times`='%u',`gmacc`='%u',`gmchar`='%s',`duration`='%u' WHERE `guid`='%u' LIMIT 1", jail_release, jail_amnestietime, jail_reason.c_str(), jail_times, jail_gmacc, jail_gmchar.c_str(), jailtime, jail_guid);
+        CharacterDatabase.CommitTransaction(trans2);
+
+        PSendSysMessage(LANG_JAIL_WAS_JAILED, cname.c_str(), jailtime);
+
+        announce = GetTrinityString(LANG_JAIL_ANNOUNCE1);
+        announce += cname;
+        announce += GetTrinityString(LANG_JAIL_ANNOUNCE2);
+        announce += timetojail;
+        announce += GetTrinityString(LANG_JAIL_ANNOUNCE3);
+        announce += m_session->GetPlayerName();
+        announce += GetTrinityString(LANG_JAIL_ANNOUNCE4);
+        announce += jail_reason;
+
+        HandleAnnounceCommand(announce.c_str());
+
+        if ((sObjectMgr->m_jailconf_max_jails == jail_times) && !sObjectMgr->m_jailconf_ban)
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            QueryResult result = WorldDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+            CharacterDatabase.CommitTransaction(trans);
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+
+            Field *fields = result->Fetch();
+
+            Player::DeleteFromDB(GUID, fields[1].GetUInt32());
+        }
+        else if ((sObjectMgr->m_jailconf_max_jails == jail_times) && sObjectMgr->m_jailconf_ban)
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            QueryResult result = WorldDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+            CharacterDatabase.CommitTransaction(trans);
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+            Field *fields = result->Fetch();
+            uint32 acc_id = fields[1].GetUInt32();
+
+            SQLTransaction trans2 = LoginDatabase.BeginTransaction();
+            result = LoginDatabase.PQuery("SELECT * FROM `account` WHERE `id`='%u' LIMIT 1", acc_id);
+            LoginDatabase.CommitTransaction(trans2);
+
+            if (!result)
+            {
+                PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+                return true;
+            }
+            ban_reason = GetTrinityString(LANG_JAIL_BAN_REASON);
+            ban_by = GetTrinityString(LANG_JAIL_BAN_BY);
+
+            SQLTransaction trans3 = LoginDatabase.BeginTransaction();
+            LoginDatabase.PExecute("INSERT IGNORE INTO `account_banned` (`id`,`bandate`,`bannedby`,`banreason`) VALUES ('%u',UNIX_TIMESTAMP,'%s','%s')", acc_id, ban_by.c_str(), ban_reason.c_str());
+            LoginDatabase.CommitTransaction(trans3);
+
+        }
+        return true;
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = WorldDatabase.PQuery("SELECT * FROM `characters` WHERE `guid`='%u' LIMIT 1", chr->GetGUIDLow());
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+        PSendSysMessage(LANG_NO_PLAYER, cname.c_str());
+        return true;
+    }
+
+    Field *fields = result->Fetch();
+
+    if (chr->GetName() == m_session->GetPlayerName())
+    {
+        SendSysMessage(LANG_JAIL_NO_JAIL);
+        return true;
+    }
+
+		chr->SaveToDB();
+
+		chr->m_jail_guid = fields[0].GetUInt32();
+		chr->m_jail_char = fields[3].GetString();
+		chr->m_jail_isjailed = true;
+		chr->m_jail_release = localtime + (jailtime * 60 * 60);
+		chr->m_jail_amnestietime = localtime +(60* 60 * 24 * sObjectMgr->m_jailconf_amnestie);
+		chr->m_jail_reason = jailreason;
+		chr->m_jail_times = chr->m_jail_times+1;
+		chr->m_jail_gmacc = m_session->GetAccountId();
+		chr->m_jail_gmchar = m_session->GetPlayerName();
+		chr->m_jail_duration = jailtime;
+
+		chr->_SaveJail();
+
+		PSendSysMessage(LANG_JAIL_WAS_JAILED, fields[3].GetString().c_str(), jailtime);
+		ChatHandler(chr).PSendSysMessage(LANG_JAIL_YOURE_JAILED, m_session->GetPlayerName(), jailtime);
+		ChatHandler(chr).PSendSysMessage(LANG_JAIL_REASON, m_session->GetPlayerName(), jailreason.c_str());
+
+		announce = GetTrinityString(LANG_JAIL_ANNOUNCE1);
+		announce += fields[3].GetString();
+		announce += GetTrinityString(LANG_JAIL_ANNOUNCE2);
+		announce += timetojail;
+		announce += GetTrinityString(LANG_JAIL_ANNOUNCE3);
+		announce += m_session->GetPlayerName();
+		announce += GetTrinityString(LANG_JAIL_ANNOUNCE4);
+		announce += chr->m_jail_reason;
+
+		HandleAnnounceCommand(announce.c_str());
+
+    if (sObjectMgr->m_jailconf_max_jails == chr->m_jail_times)
+    {
+        chr->GetSession()->KickPlayer();
+        chr->DeleteFromDB(fields[0].GetUInt64(), fields[1].GetUInt32());
+    }
+    else if ((sObjectMgr->m_jailconf_max_jails == chr->m_jail_times) && sObjectMgr->m_jailconf_ban)
+    {
+        uint32 acc_id = chr->GetSession()->GetAccountId();
+        ban_reason = GetTrinityString(LANG_JAIL_BAN_REASON);
+        ban_by = GetTrinityString(LANG_JAIL_BAN_BY);
+
+		SQLTransaction trans = LoginDatabase.BeginTransaction();
+        LoginDatabase.PExecute("INSERT IGNORE INTO `account_banned` (`id`,`bandate`,`bannedby`,`banreason`) VALUES ('%u',UNIX_TIMESTAMP,'%s','%s')", acc_id, ban_by.c_str(), ban_reason.c_str());
+        LoginDatabase.CommitTransaction(trans);
+
+        chr->GetSession()->LogoutPlayer(false);
+    }
+    else chr->GetSession()->LogoutPlayer(false);
+    return true;
+}
+
+bool ChatHandler::HandleUnJailCommand(const char *args)
+{
+    char *charname = strtok((char*)args, " ");
+    std::string cname;
+
+    if (charname == NULL) return false;
+    else cname = charname;
+
+    uint64 GUID = sObjectMgr->GetPlayerGUIDByName(cname.c_str());
+    Player *chr = sObjectMgr->GetPlayer(GUID);
+
+    if (chr)
+    {
+        if (chr->GetName() == m_session->GetPlayerName())
+        {
+            SendSysMessage(LANG_JAIL_NO_UNJAIL);
+            return true;
+        }
+
+        if (chr->m_jail_isjailed)
+        {
+            chr->m_jail_isjailed = false;
+            chr->m_jail_release = 0;
+            chr->m_jail_times = chr->m_jail_times-1;
+
+            chr->_SaveJail();
+
+            if (chr->m_jail_times == 0)
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("DELETE FROM `jail` WHERE `guid`='%u' LIMIT 1", chr->GetGUIDLow());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+
+            PSendSysMessage(LANG_JAIL_WAS_UNJAILED, cname.c_str());
+            ChatHandler(chr).PSendSysMessage(LANG_JAIL_YOURE_UNJAILED, m_session->GetPlayerName());
+            chr->CastSpell(chr,8690,false);
+            //chr->GetSession()->LogoutPlayer(false);
+        } else PSendSysMessage(LANG_JAIL_CHAR_NOTJAILED, cname.c_str());
+        return true;
+    }
+    else
+    {
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(GUID));
+        CharacterDatabase.CommitTransaction(trans);
+
+        if (!result)
+        {
+            PSendSysMessage(LANG_JAIL_CHAR_NOTJAILED, cname.c_str());
+            return true;
+        }
+        else
+        {
+            Field *fields = result->Fetch();
+            uint32 jail_times = fields[4].GetUInt32()-1;
+
+            if (jail_times == 0)
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("DELETE FROM `jail` WHERE `guid`='%u' LIMIT 1", fields[0].GetUInt32());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+            else
+            {
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                CharacterDatabase.PQuery("UPDATE `jail` SET `release`='0',`times`='%u' WHERE `guid`='%u' LIMIT 1", jail_times, fields[0].GetUInt32());
+                CharacterDatabase.CommitTransaction(trans);
+            }
+
+            PSendSysMessage(LANG_JAIL_WAS_UNJAILED, cname.c_str());
+            return true;
+        }
+
+    }
+    return true;
+}
+
 //Send mail by command
 bool ChatHandler::HandleSendMailCommand(const char* args)
 {
diff --git a/src/server/game/Chat/Commands/Level2.cpp b/src/server/game/Chat/Commands/Level2.cpp
index 00962a9..33f21d0 100755
--- a/src/server/game/Chat/Commands/Level2.cpp
+++ b/src/server/game/Chat/Commands/Level2.cpp
@@ -33,6 +33,8 @@
 #include "PoolMgr.h"
 #include "AccountMgr.h"
 #include "WaypointManager.h"
+#include "WaypointMovementGenerator.h"
+#include "math.h"
 #include "Util.h"
 #include <cctype>
 #include <iostream>
@@ -246,6 +248,18 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
     uint32 latency = 0;
     uint8 race;
     uint8 Class;
+    bool p_jail_isjailed;
+    uint32 p_jail_guid;
+    std::string p_jail_char;
+    uint32 p_jail_release;
+    bool p_jail_amnestietime;
+    std::string p_jail_reason;
+    uint32 p_jail_times;
+    uint32 p_jail_gmacc;
+    std::string p_jail_gmchar;
+    std::string p_jail_lasttime;
+    uint32 p_jail_duration;
+    std::string gmname;
 
     // get additional information from Player object
     if (target)
@@ -261,6 +275,18 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         latency = target->GetSession()->GetLatency();
         race = target->getRace();
         Class = target->getClass();
+        p_jail_isjailed = target->m_jail_isjailed;
+		p_jail_guid = target->m_jail_guid;
+		p_jail_char = target->m_jail_char;
+		p_jail_release = target->m_jail_release;
+		p_jail_amnestietime = target->m_jail_amnestietime;
+		p_jail_reason = target->m_jail_reason;
+		p_jail_times =  target->m_jail_times;
+		p_jail_gmacc =  target->m_jail_gmacc;
+		p_jail_gmchar = target->m_jail_gmchar;
+		p_jail_lasttime = target->m_jail_lasttime;
+		p_jail_duration = target->m_jail_duration;
+		gmname = target->GetName();
     }
     // get additional information from DB
     else
@@ -272,8 +298,11 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         //                                                     0          1      2      3        4     5
         QueryResult result = CharacterDatabase.PQuery("SELECT totaltime, level, money, account, race, class FROM characters WHERE guid = '%u'", GUID_LOPART(target_guid));
         if (!result)
+        {
             return false;
-
+		}
+		else
+		{
         Field *fields = result->Fetch();
         total_player_time = fields[0].GetUInt32();
         level = fields[1].GetUInt32();
@@ -281,6 +310,31 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
         accId = fields[3].GetUInt32();
         race = fields[4].GetUInt8();
         Class = fields[5].GetUInt8();
+				}
+
+		QueryResult row = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GUID_LOPART(target_guid));
+
+		if (!row)
+		{
+			 p_jail_isjailed = false;
+		}
+		else
+		{
+
+			Field *data = row->Fetch();
+			p_jail_isjailed = true;
+			p_jail_guid = data[0].GetUInt32();
+			p_jail_char = data[1].GetString();
+			p_jail_release = data[2].GetUInt32();
+			p_jail_amnestietime = data[3].GetUInt32();
+			p_jail_reason = data[4].GetString();
+			p_jail_times = data[5].GetUInt32();
+			p_jail_gmacc = data[6].GetUInt32();
+			p_jail_gmchar = data[7].GetString();
+			p_jail_lasttime = data[8].GetString();
+			p_jail_duration = data[9].GetUInt32();
+			gmname = "";
+		}
     }
 
     std::string username = GetTrinityString(LANG_ERROR);
@@ -354,6 +408,39 @@ bool ChatHandler::HandlePInfoCommand(const char* args)
     uint32 copp = (money % GOLD) % SILVER;
     PSendSysMessage(LANG_PINFO_LEVEL, race_s.c_str(), Class_s.c_str(), timeStr.c_str(), level, gold, silv, copp);
 
+	if (p_jail_times > 0)
+        {
+            if (p_jail_release > 0)
+            {
+                time_t localtime;
+                localtime = time(NULL);
+                uint32 min_left = (uint32)floor(float(p_jail_release - localtime) / 60);
+
+                if (min_left <= 0)
+                {
+                    p_jail_release = 0;
+                    CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u' WHERE `guid`='%u' LIMIT 1", p_jail_release, p_jail_guid);
+                    PSendSysMessage(LANG_JAIL_GM_INFO, p_jail_char.c_str(), p_jail_times, 0, p_jail_gmchar.c_str(), p_jail_reason.c_str());
+                    return true;
+                }
+                else
+                {
+                    PSendSysMessage(LANG_JAIL_GM_INFO, p_jail_char.c_str(), p_jail_times, min_left, p_jail_gmchar.c_str(), p_jail_reason.c_str());
+                    return true;
+                }
+            }
+            else
+            {
+                PSendSysMessage(LANG_JAIL_GM_INFO, p_jail_char.c_str(), p_jail_times, 0, p_jail_gmchar.c_str(), p_jail_reason.c_str());
+                return true;
+            }
+        }
+        else
+        {
+            PSendSysMessage(LANG_JAIL_GM_NOINFO, gmname.c_str());
+            return true;
+        }
+
     return true;
 }
 
diff --git a/src/server/game/Chat/Commands/Level3.cpp b/src/server/game/Chat/Commands/Level3.cpp
index 4043aa9..1e777a3 100755
--- a/src/server/game/Chat/Commands/Level3.cpp
+++ b/src/server/game/Chat/Commands/Level3.cpp
@@ -62,6 +62,496 @@
 #include "Group.h"
 #include "ChannelMgr.h"
 
+#include "AuctionHouseBot.h"
+
+bool ChatHandler::HandleAHBotOptionsCommand(const char *args)
+{
+    uint32 ahMapID = 0;
+    char * opt = strtok((char*)args, " ");
+    char * ahMapIdStr = strtok(NULL, " ");
+    if (ahMapIdStr)
+    {
+        ahMapID = (uint32) strtoul(ahMapIdStr, NULL, 0);
+        switch (ahMapID)
+        {
+        case 2:
+        case 6:
+        case 7:
+            break;
+        default:
+            opt = NULL;
+            break;
+        }
+    }
+    if (!opt)
+    {
+        PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+        PSendSysMessage("Try ahbotoptions help to see a list of options.");
+        return false;
+    }
+    int l = strlen(opt);
+
+    if (strncmp(opt,"help",l) == 0)
+    {
+        PSendSysMessage("AHBot commands:");
+        PSendSysMessage("ahexpire");
+        PSendSysMessage("minitems");
+        PSendSysMessage("maxitems");
+        //PSendSysMessage("");
+        //PSendSysMessage("");
+        PSendSysMessage("percentages");
+        PSendSysMessage("minprice");
+        PSendSysMessage("maxprice");
+        PSendSysMessage("minbidprice");
+        PSendSysMessage("maxbidprice");
+        PSendSysMessage("maxstack");
+        PSendSysMessage("buyerprice");
+        PSendSysMessage("bidinterval");
+        PSendSysMessage("bidsperinterval");
+        return true;
+    }
+    else if (strncmp(opt,"ahexpire",l) == 0)
+    {
+        if (!ahMapIdStr)
+        {
+            PSendSysMessage("Syntax is: ahbotoptions ahexpire $ahMapID (2, 6 or 7)");
+            return false;
+        }
+        auctionbot.Commands(0, ahMapID, NULL, NULL);
+    }
+    else if (strncmp(opt,"minitems",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minitems $ahMapID (2, 6 or 7) $minItems");
+            return false;
+        }
+        auctionbot.Commands(1, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"maxitems",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxitems $ahMapID (2, 6 or 7) $maxItems");
+            return false;
+        }
+        auctionbot.Commands(2, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"mintime",l) == 0)
+    {
+        PSendSysMessage("ahbotoptions mintime has been deprecated");
+        return false;
+        /*
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions mintime $ahMapID (2, 6 or 7) $mintime");
+            return false;
+        }
+        auctionbot.Commands(3, ahMapID, NULL, param1);
+        */
+    }
+    else if (strncmp(opt,"maxtime",l) == 0)
+    {
+        PSendSysMessage("ahbotoptions maxtime has been deprecated");
+        return false;
+        /*
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxtime $ahMapID (2, 6 or 7) $maxtime");
+            return false;
+        }
+        auctionbot.Commands(4, ahMapID, NULL, param1);
+        */
+    }
+    else if (strncmp(opt,"percentages",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        char * param3 = strtok(NULL, " ");
+        char * param4 = strtok(NULL, " ");
+        char * param5 = strtok(NULL, " ");
+        char * param6 = strtok(NULL, " ");
+        char * param7 = strtok(NULL, " ");
+        char * param8 = strtok(NULL, " ");
+        char * param9 = strtok(NULL, " ");
+        char * param10 = strtok(NULL, " ");
+        char * param11 = strtok(NULL, " ");
+        char * param12 = strtok(NULL, " ");
+        char * param13 = strtok(NULL, " ");
+        char * param14 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param14))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+            PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+            PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+            PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+            PSendSysMessage("The total must add up to 100%");
+            return false;
+        }
+        uint32 greytg = (uint32) strtoul(param1, NULL, 0);
+        uint32 whitetg = (uint32) strtoul(param2, NULL, 0);
+        uint32 greentg = (uint32) strtoul(param3, NULL, 0);
+        uint32 bluetg = (uint32) strtoul(param3, NULL, 0);
+        uint32 purpletg = (uint32) strtoul(param5, NULL, 0);
+        uint32 orangetg = (uint32) strtoul(param6, NULL, 0);
+        uint32 yellowtg = (uint32) strtoul(param7, NULL, 0);
+        uint32 greyi = (uint32) strtoul(param8, NULL, 0);
+        uint32 whitei = (uint32) strtoul(param9, NULL, 0);
+        uint32 greeni = (uint32) strtoul(param10, NULL, 0);
+        uint32 bluei = (uint32) strtoul(param11, NULL, 0);
+        uint32 purplei = (uint32) strtoul(param12, NULL, 0);
+        uint32 orangei = (uint32) strtoul(param13, NULL, 0);
+        uint32 yellowi = (uint32) strtoul(param14, NULL, 0);
+        uint32 totalPercent = greytg + whitetg + greentg + bluetg + purpletg + orangetg + yellowtg + greyi + whitei + greeni + bluei + purplei + orangei + yellowi;
+        if ((totalPercent == 0) || (totalPercent != 100))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions percentages $ahMapID (2, 6 or 7) $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14");
+            PSendSysMessage("1 GreyTradeGoods 2 WhiteTradeGoods 3 GreenTradeGoods 4 BlueTradeGoods 5 PurpleTradeGoods");
+            PSendSysMessage("6 OrangeTradeGoods 7 YellowTradeGoods 8 GreyItems 9 WhiteItems 10 GreenItems 11 BlueItems");
+            PSendSysMessage("12 PurpleItems 13 OrangeItems 14 YellowItems");
+            PSendSysMessage("The total must add up to 100%");
+            return false;
+        }
+        char param[100];
+        param[0] = '\0';
+        strcat(param, param1);
+        strcat(param, " ");
+        strcat(param, param2);
+        strcat(param, " ");
+        strcat(param, param3);
+        strcat(param, " ");
+        strcat(param, param4);
+        strcat(param, " ");
+        strcat(param, param5);
+        strcat(param, " ");
+        strcat(param, param6);
+        strcat(param, " ");
+        strcat(param, param7);
+        strcat(param, " ");
+        strcat(param, param8);
+        strcat(param, " ");
+        strcat(param, param9);
+        strcat(param, " ");
+        strcat(param, param10);
+        strcat(param, " ");
+        strcat(param, param11);
+        strcat(param, " ");
+        strcat(param, param12);
+        strcat(param, " ");
+        strcat(param, param13);
+        strcat(param, " ");
+        strcat(param, param14);
+        auctionbot.Commands(5, ahMapID, NULL, param);
+    }
+    else if (strncmp(opt,"minprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(6, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(7, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"minbidprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        uint32 minBidPrice = (uint32) strtoul(param2, NULL, 0);
+        if ((minBidPrice < 1) || (minBidPrice > 100))
+        {
+            PSendSysMessage("The min bid price multiplier must be between 1 and 100");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(8, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions minbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxbidprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxbidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+        uint32 maxBidPrice = (uint32) strtoul(param2, NULL, 0);
+        if ((maxBidPrice < 1) || (maxBidPrice > 100))
+        {
+            PSendSysMessage("The max bid price multiplier must be between 1 and 100");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(9, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions max bidprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"maxstack",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+            return false;
+        }
+        uint32 maxStack = (uint32) strtoul(param2, NULL, 0);
+        if (maxStack < 0)
+        {
+            PSendSysMessage("maxstack can't be a negative number.");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(10, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions maxstack $ahMapID (2, 6 or 7) $color (grey, white, green, blue, purple, orange or yellow) $value");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"buyerprice",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        char * param2 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1) || (!param2))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+            return false;
+        }
+        if (strncmp(param1,"grey",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_GREY, param2);
+        }
+        else if (strncmp(param1,"white",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_WHITE, param2);
+        }
+        else if (strncmp(param1,"green",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_GREEN, param2);
+        }
+        else if (strncmp(param1,"blue",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_BLUE, param2);
+        }
+        else if (strncmp(param1,"purple",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_PURPLE, param2);
+        }
+        else if (strncmp(param1,"orange",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_ORANGE, param2);
+        }
+        else if (strncmp(param1,"yellow",l) == 0)
+        {
+            auctionbot.Commands(11, ahMapID, AHB_YELLOW, param2);
+        }
+        else
+        {
+            PSendSysMessage("Syntax is: ahbotoptions buyerprice $ahMapID (2, 6 or 7) $color (grey, white, green, blue or purple) $price");
+            return false;
+        }
+    }
+    else if (strncmp(opt,"bidinterval",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions bidinterval $ahMapID (2, 6 or 7) $interval(in minutes)");
+            return false;
+        }
+        auctionbot.Commands(12, ahMapID, NULL, param1);
+    }
+    else if (strncmp(opt,"bidsperinterval",l) == 0)
+    {
+        char * param1 = strtok(NULL, " ");
+        if ((!ahMapIdStr) || (!param1))
+        {
+            PSendSysMessage("Syntax is: ahbotoptions bidsperinterval $ahMapID (2, 6 or 7) $bids");
+            return false;
+        }
+        auctionbot.Commands(13, ahMapID, NULL, param1);
+    }
+    else
+    {
+        PSendSysMessage("Syntax is: ahbotoptions $option $ahMapID (2, 6 or 7) $parameter");
+        PSendSysMessage("Try ahbotoptions help to see a list of options.");
+        return false;
+    }
+    return true;
+}
+
 bool ChatHandler::HandleMaxSkillCommand(const char* /*args*/)
 {
     Player* SelectedPlayer = getSelectedPlayer();
@@ -597,6 +1087,13 @@ bool ChatHandler::HandleListItemCommand(const char *args)
     return true;
 }
 
+	bool ChatHandler::HandleJailReloadCommand(const char* arg)
+{
+    sObjectMgr->LoadJailConf();
+    SendSysMessage(LANG_JAIL_RELOAD);
+    return true;
+}
+
 bool ChatHandler::HandleListObjectCommand(const char *args)
 {
     if (!*args)
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 404b3d9..2e6cf6d 100755
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -395,6 +395,21 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
 #pragma warning(default:4355)
 #endif
 
+	m_jail_guid     = 0;
+    m_jail_char     = "";
+    m_jail_amnestie = false;
+    m_jail_warning  = false;
+    m_jail_isjailed = false;
+    m_jail_amnestietime =0;
+    m_jail_release  = 0;
+    m_jail_times    = 0;
+    m_jail_reason   = "";
+    m_jail_gmacc    = 0;
+    m_jail_gmchar   = "";
+    m_jail_lasttime = "";
+    m_jail_duration = 0;
+	// Jail end
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -520,6 +535,26 @@ Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputa
     rest_type=REST_TYPE_NO;
     ////////////////////Rest System/////////////////////
 
+    // movement anticheat
+    m_anti_LastClientTime  = 0;          // last movement client time
+    m_anti_LastServerTime  = 0;          // last movement server time
+    m_anti_DeltaClientTime = 0;          // client side session time
+    m_anti_DeltaServerTime = 0;          // server side session time
+    m_anti_MistimingCount  = 0;          // mistiming count
+
+    m_anti_LastSpeedChangeTime = 0;      // last speed change time
+
+    m_anti_Last_HSpeed =  7.0f;          // horizontal speed, default RUN speed
+    m_anti_Last_VSpeed = -2.3f;          // vertical speed, default max jump height
+
+    m_anti_TeleToPlane_Count = 0;        // Teleport To Plane alarm counter
+
+    m_anti_AlarmCount = 0;               // alarm counter
+
+    m_anti_JumpCount = 0;                // Jump already began, anti air jump check
+    m_anti_JumpBaseZ = 0;                // Z coord before jump (AntiGrav)
+    // end movement anticheat
+
     m_mailsLoaded = false;
     m_mailsUpdated = false;
     unReadMails = 0;
@@ -1284,6 +1319,79 @@ void Player::Update(uint32 p_time)
     Unit::Update(p_time);
     SetCanDelayTeleport(false);
 
+	if (m_jail_isjailed)
+    {
+        time_t localtime;
+        localtime = time(NULL);
+
+        if (m_jail_release <= localtime)
+        {
+            m_jail_isjailed = false;
+            m_jail_release = 0;
+
+            _SaveJail();
+
+            sWorld->SendWorldText(LANG_JAIL_CHAR_FREE, GetName());
+
+			CastSpell(this,8690,false);
+
+            return;
+        }
+
+        if (m_team == ALLIANCE)
+        {
+            if (GetDistance(sObjectMgr->m_jailconf_ally_x, sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z) > sObjectMgr->m_jailconf_radius)
+            {
+                TeleportTo(sObjectMgr->m_jailconf_ally_m, sObjectMgr->m_jailconf_ally_x,
+                    sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z, sObjectMgr->m_jailconf_ally_o);
+                return;
+            }
+        }
+        else
+        {
+            if (GetDistance(sObjectMgr->m_jailconf_horde_x, sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z) > sObjectMgr->m_jailconf_radius)
+            {
+                TeleportTo(sObjectMgr->m_jailconf_horde_m, sObjectMgr->m_jailconf_horde_x,
+                    sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z, sObjectMgr->m_jailconf_horde_o);
+                return;
+            }
+
+        }
+    }
+
+	if (m_jail_warning == true)
+	{
+		m_jail_warning  = false;
+
+		if (sObjectMgr->m_jailconf_warn_player == m_jail_times || sObjectMgr->m_jailconf_warn_player <= m_jail_times)
+		{
+			if ((sObjectMgr->m_jailconf_max_jails-1 == m_jail_times-1) && sObjectMgr->m_jailconf_ban-1)
+			{
+				ChatHandler(this).PSendSysMessage(LANG_JAIL_WARNING_BAN, m_jail_times , sObjectMgr->m_jailconf_max_jails-1);
+			}
+			else
+			{
+				ChatHandler(this).PSendSysMessage(LANG_JAIL_WARNING, m_jail_times , sObjectMgr->m_jailconf_max_jails);
+			}
+
+		}
+				return;
+	}
+if (m_jail_amnestie == true && sObjectMgr->m_jailconf_amnestie > 0)
+{
+	m_jail_amnestie =false;
+	time_t localtime;
+    localtime    = time(NULL);
+
+	if (localtime >  m_jail_amnestietime)
+	{
+		CharacterDatabase.PExecute("DELETE FROM `jail` WHERE `guid` = '%u'",GetGUIDLow());
+		ChatHandler(this).PSendSysMessage(LANG_JAIL_AMNESTII);
+	}
+    return;
+}
+
+
     time_t now = time(NULL);
 
     UpdatePvPFlag(now);
@@ -1464,9 +1572,15 @@ void Player::Update(uint32 p_time)
     }
 
     if (m_deathState == JUST_DIED)
-        KillPlayer();
+        // Prevent death of jailed players
+        if (!m_jail_isjailed) KillPlayer();
+        else
+        {
+            m_deathState = ALIVE;
+            RegenerateAll();
+        }
 
-    if (m_nextSave > 0)
+    if (m_nextSave > 0 && !m_jail_isjailed)
     {
         if (p_time >= m_nextSave)
         {
@@ -1889,6 +2003,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
 
     if ((GetMapId() == mapid && !m_transport) || (GetTransport() && GetMapId() == 628))
     {
+        m_anti_JumpBaseZ = 0;
         //lets reset far teleport flag if it wasn't reset during chained teleports
         SetSemaphoreTeleportFar(false);
         //setup delayed teleport flag
@@ -2047,6 +2162,7 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
 
             m_teleport_dest = WorldLocation(mapid, final_x, final_y, final_z, final_o);
             SetFallInformation(0, final_z);
+            m_anti_JumpBaseZ = 0;
             // if the player is saved before worldportack (at logout for example)
             // this will be used instead of the current location in SaveToDB
 
@@ -4643,6 +4759,7 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             trans->PAppend("DELETE FROM character_queststatus_daily WHERE guid = '%u'",guid);
             trans->PAppend("DELETE FROM character_talent WHERE guid = '%u'",guid);
             trans->PAppend("DELETE FROM character_skills WHERE guid = '%u'",guid);
+            trans->PAppend("DELETE FROM `jail` WHERE `guid` = '%u'",guid);
 
             CharacterDatabase.CommitTransaction(trans);
             break;
@@ -6583,7 +6700,8 @@ void Player::CheckAreaExploreAndOutdoor()
                 {
                     XP = uint32(sObjectMgr->GetBaseXP(p->area_level)*sWorld->getRate(RATE_XP_EXPLORE));
                 }
-
+                if(GetSession()->IsPremium())
+                XP *= sWorld->getRate(RATE_XP_EXPLORE_PREMIUM);
                 GiveXP(XP, NULL);
                 SendExplorationExperience(area,XP);
             }
@@ -14643,6 +14761,9 @@ void Player::RewardQuest(Quest const *pQuest, uint32 reward, Object* questGiver,
     for (Unit::AuraEffectList::const_iterator i = ModXPPctAuras.begin(); i != ModXPPctAuras.end(); ++i)
         AddPctN(XP, (*i)->GetAmount());
 
+    if (GetSession()->IsPremium())
+        XP *= sWorld->getRate(RATE_XP_QUEST_PREMIUM);
+
     int32 moneyRew = 0;
     if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
         GiveXP(XP, NULL);
@@ -16767,10 +16888,77 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
     m_achievementMgr.CheckAllAchievementCriteria();
 
     _LoadEquipmentSets(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS));
+	// Loads the jail datas and if jailed it corrects the position to the corresponding jail
+    _LoadJail();
 
     return true;
 }
 
+void Player::_LoadJail(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail` WHERE `guid`='%u' LIMIT 1", GetGUIDLow());
+    CharacterDatabase.CommitTransaction(trans);
+
+    if (!result)
+    {
+        m_jail_isjailed = false;
+        return;
+    }
+
+		Field *fields = result->Fetch();
+		m_jail_warning = true;
+		m_jail_isjailed = true;
+		m_jail_guid = fields[0].GetUInt32();
+		m_jail_char = fields[1].GetString();
+		m_jail_release = fields[2].GetUInt32();
+		m_jail_amnestietime = fields[3].GetUInt32();
+		m_jail_reason = fields[4].GetString();
+		m_jail_times = fields[5].GetUInt32();
+		m_jail_gmacc = fields[6].GetUInt32();
+		m_jail_gmchar = fields[7].GetString();
+		m_jail_lasttime = fields[8].GetString();
+		m_jail_duration = fields[9].GetUInt32();
+
+    if (m_jail_release == 0)
+    {
+        m_jail_isjailed = false;
+        return;
+    }
+
+    time_t localtime;
+    localtime = time(NULL);
+
+    if (m_jail_release <= localtime)
+    {
+        m_jail_isjailed = false;
+        m_jail_release = 0;
+
+        _SaveJail();
+
+        sWorld->SendWorldText(LANG_JAIL_CHAR_FREE, GetName());
+
+        CastSpell(this,8690,false);
+        return;
+    }
+
+    if (m_jail_isjailed)
+    {
+        if (m_team == ALLIANCE)
+        {
+            TeleportTo(sObjectMgr->m_jailconf_ally_m, sObjectMgr->m_jailconf_ally_x,
+                sObjectMgr->m_jailconf_ally_y, sObjectMgr->m_jailconf_ally_z, sObjectMgr->m_jailconf_ally_o);
+        }
+        else
+        {
+            TeleportTo(sObjectMgr->m_jailconf_horde_m, sObjectMgr->m_jailconf_horde_x,
+                sObjectMgr->m_jailconf_horde_y, sObjectMgr->m_jailconf_horde_z, sObjectMgr->m_jailconf_horde_o);
+        }
+
+        sWorld->SendWorldText(LANG_JAIL_CHAR_TELE, GetName());
+    }
+}
+
 bool Player::isAllowedToLoot(const Creature* creature)
 {
     if (!creature->isDead() || !creature->IsDamageEnoughForLootingAndReward())
@@ -17932,8 +18120,21 @@ bool Player::_LoadHomeBind(PreparedQueryResult result)
 /***                   SAVE SYSTEM                     ***/
 /*********************************************************/
 
+// Saves the jail datas (added by WarHead) edited by spgm.
+void Player::_SaveJail(void)
+{
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT `guid` FROM `jail` WHERE `guid`='%u' LIMIT 1", m_jail_guid);
+    if (!result) CharacterDatabase.PExecute("INSERT INTO `jail` VALUES ('%u','%s','%u', '%u','%s','%u','%u','%s',CURRENT_TIMESTAMP,'%u')", m_jail_guid, m_jail_char.c_str(), m_jail_release, m_jail_amnestietime, m_jail_reason.c_str(), m_jail_times, m_jail_gmacc, m_jail_gmchar.c_str(), m_jail_duration);
+    else CharacterDatabase.PExecute("UPDATE `jail` SET `release`='%u', `amnestietime`='%u',`reason`='%s',`times`='%u',`gmacc`='%u',`gmchar`='%s',`duration`='%u' WHERE `guid`='%u' LIMIT 1", m_jail_release, m_jail_amnestietime, m_jail_reason.c_str(), m_jail_times, m_jail_gmacc, m_jail_gmchar.c_str(), m_jail_duration, m_jail_guid);
+    CharacterDatabase.CommitTransaction(trans);
+}
+
 void Player::SaveToDB()
 {
+	// Jail: Prevent saving of jailed players
+    if (m_jail_isjailed) return;
+
     // delay auto save at any saves (manual, in code, or autosave)
     m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);
 
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index caabac6..84dd121 100755
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -2179,6 +2179,26 @@ class Player : public Unit, public GridObject<Player>
 
         uint32 EnvironmentalDamage(EnviromentalDamage type, uint32 damage);
 
+	    // Jail by WarHead edited by spgm
+        // ---------------
+        // Char datas...
+		bool m_jail_warning;
+		bool m_jail_amnestie;
+		bool m_jail_isjailed;           // Is this player jailed?
+		std::string m_jail_char;        // Name of jailed char
+		uint32 m_jail_guid;             // guid of the jailed char
+		uint32 m_jail_release;          // When is the player a free man/woman?
+		std::string m_jail_reason;      // Why was the char jailed?
+		uint32 m_jail_times;			// How often was the player jailed?
+		uint32 m_jail_amnestietime;
+		uint32 m_jail_gmacc;            // Used GM acc
+		std::string m_jail_gmchar;      // Used GM char
+		std::string m_jail_lasttime;    // Last jail time
+		uint32 m_jail_duration;         // Duration of the jail
+		// Load / save functions...
+		void _LoadJail(void);           // Loads the jail datas
+		void _SaveJail(void);           // Saves the jail datas
+
         /*********************************************************/
         /***               FLOOD FILTER SYSTEM                 ***/
         /*********************************************************/
@@ -2601,6 +2621,26 @@ class Player : public Unit, public GridObject<Player>
         float m_rest_bonus;
         RestType rest_type;
         ////////////////////Rest System/////////////////////
+        // movement anticheat
+        time_t m_anti_LastClientTime;           // last movement client time
+        time_t m_anti_LastServerTime;           // last movement server time
+        time_t m_anti_DeltaClientTime;          // client side session time
+        time_t m_anti_DeltaServerTime;          // server side session time
+        uint32 m_anti_MistimingCount;           // mistiming count
+
+        time_t m_anti_LastSpeedChangeTime;      // last speed change time
+
+        float m_anti_Last_HSpeed;               // horizontal speed, default RUN speed
+        float m_anti_Last_VSpeed;               // vertical speed, default max jump height
+
+        uint32 m_anti_TeleToPlane_Count;        // Teleport To Plane alarm counter
+
+        uint64 m_anti_AlarmCount;               // alarm counter
+
+        uint16 m_anti_JumpCount;                // Jump already began, anti air jump check
+        float m_anti_JumpBaseZ;                 // Z coord before jump
+        // end movement anticheat
+
         uint32 m_resetTalentsCost;
         time_t m_resetTalentsTime;
         uint32 m_usedTalentCount;
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index 97599a4..a5d3ec2 100755
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -2058,6 +2058,7 @@ class Unit : public WorldObject
     protected:
         explicit Unit ();
 
+        GameObject * m_temp_transport;
         UnitAI *i_AI, *i_disabledAI;
 
         void _UpdateSpells(uint32 time);
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 0866297..6297cfb 100755
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -5925,7 +5925,8 @@ void ObjectMgr::LoadAreaTriggerScripts()
     sLog->outString();
 }
 
-uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, uint32 team)
+// use searched_node for search some known node
+uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, uint32 team, uint32 searched_node)
 {
     bool found = false;
     float dist = 10000;
@@ -5935,7 +5936,18 @@ uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, ui
     {
         TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(i);
 
-        if (!node || node->map_id != mapid || (!node->MountCreatureID[team == ALLIANCE ? 1 : 0] && node->MountCreatureID[0] != 32981)) // dk flight
+        if (!node || node->map_id != mapid) continue;
+
+        const float dist2 = pow(node->x - x, 2) + pow(node->y - y, 2) + pow(node->z - z, 2);
+
+        if (searched_node != 0 && i == searched_node)
+        {
+            id = i;
+            dist = dist2;
+            break;
+        }
+
+        if (!node->MountCreatureID[team == ALLIANCE ? 1 : 0] && node->MountCreatureID[0] != 32981) // dk flight
             continue;
 
         uint8  field   = (uint8)((i - 1) / 32);
@@ -5945,7 +5957,7 @@ uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, ui
         if ((sTaxiNodesMask[field] & submask) == 0)
             continue;
 
-        float dist2 = (node->x - x)*(node->x - x)+(node->y - y)*(node->y - y)+(node->z - z)*(node->z - z);
+        //float dist2 = (node->x - x)*(node->x - x)+(node->y - y)*(node->y - y)+(node->z - z)*(node->z - z);
         if (found)
         {
             if (dist2 < dist)
@@ -5961,7 +5973,9 @@ uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, ui
             id = i;
         }
     }
-
+    // movement anticheat fix
+    if (dist > 3600) id = 0;
+    // movement anticheat fix
     return id;
 }
 
@@ -7065,6 +7079,121 @@ uint32 ObjectMgr::GeneratePetNumber()
     return ++m_hiPetNumber;
 }
 
+// Loads the jail conf out of the database
+void ObjectMgr::LoadJailConf(void)
+{
+    SQLTransaction penis = CharacterDatabase.BeginTransaction();
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM `jail_conf`");
+    CharacterDatabase.CommitTransaction(penis);
+
+    if (!result)
+    {
+		sLog->outError(GetTrinityStringForDBCLocale(LANG_JAIL_CONF_ERR1));
+		sLog->outError(GetTrinityStringForDBCLocale(LANG_JAIL_CONF_ERR2));
+
+		m_jailconf_max_jails    = 3;
+		m_jailconf_max_duration = 672;
+		m_jailconf_min_reason   = 25;
+		m_jailconf_warn_player  = 1;
+		m_jailconf_amnestie     = 180;
+
+		m_jailconf_ally_x       = -8673.43;
+		m_jailconf_ally_y       = 631.795;
+		m_jailconf_ally_z       = 96.9406;
+		m_jailconf_ally_o       = 2.1785;
+		m_jailconf_ally_m       = 0;
+
+		m_jailconf_horde_x      = 2179.85;
+		m_jailconf_horde_y      = -4763.96;
+		m_jailconf_horde_z      = 54.911;
+		m_jailconf_horde_o      = 4.44216;
+		m_jailconf_horde_m      = 1;
+
+		m_jailconf_ban          = 0;
+		m_jailconf_radius       = 10;
+
+        return;
+    }
+do
+{
+    Field *fields = result->Fetch();
+    m_jail_obt = fields[1].GetString();
+	if (m_jail_obt == "m_jailconf_max_jails")
+	{
+      m_jailconf_max_jails    = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_max_duration")
+	{
+	  m_jailconf_max_duration = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_min_reason")
+	{
+      m_jailconf_min_reason   = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_warn_player")
+	{
+      m_jailconf_warn_player  = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_amnestie")
+	{
+	  m_jailconf_amnestie     = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_ally_x")
+	{
+      m_jailconf_ally_x       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_y")
+	{
+      m_jailconf_ally_y       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_z")
+	{
+      m_jailconf_ally_z       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_o")
+	{
+      m_jailconf_ally_o       = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_ally_m")
+	{
+      m_jailconf_ally_m       = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_horde_x")
+	{
+      m_jailconf_horde_x      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_y")
+	{
+      m_jailconf_horde_y      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_z")
+	{
+      m_jailconf_horde_z      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_o")
+	{
+      m_jailconf_horde_o      = fields[3].GetFloat();
+	}
+	if (m_jail_obt == "m_jailconf_horde_m")
+	{
+      m_jailconf_horde_m      = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_ban")
+	{
+      m_jailconf_ban = fields[2].GetUInt32();
+	}
+	if (m_jail_obt == "m_jailconf_radius")
+	{
+      m_jailconf_radius = fields[2].GetUInt32();
+	}
+}
+while (result->NextRow());
+
+    sLog->outString("");
+    sLog->outString(GetTrinityStringForDBCLocale(LANG_JAIL_CONF_LOADED));
+    sLog->outString("");
+}
+
 void ObjectMgr::LoadCorpses()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 4efbbc7..aaa7c96 100755
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -680,7 +680,7 @@ class ObjectMgr
         uint32 GetPlayerAccountIdByGUID(const uint64 &guid) const;
         uint32 GetPlayerAccountIdByPlayerName(const std::string& name) const;
 
-        uint32 GetNearestTaxiNode(float x, float y, float z, uint32 mapid, uint32 team);
+        uint32 GetNearestTaxiNode(float x, float y, float z, uint32 mapid, uint32 team, uint32 searched_node);
         void GetTaxiPath(uint32 source, uint32 destination, uint32 &path, uint32 &cost);
         uint32 GetTaxiMountDisplayId(uint32 id, uint32 team, bool allowed_alt_team = false);
 
@@ -835,6 +835,10 @@ class ObjectMgr
         {
             return &mCreatureQuestRelations;
         }
+        QuestRelations* GetCreatureQuestInvolvedRelation()
+        {
+            return &mCreatureQuestInvolvedRelations;
+        }
 
         QuestRelationBounds GetCreatureQuestRelationBounds(uint32 creature_entry)
         {
@@ -927,6 +931,29 @@ class ObjectMgr
         void LoadTrainerSpell();
         void AddSpellToTrainer(uint32 entry, uint32 spell, uint32 spellCost, uint32 reqSkill, uint32 reqSkillValue, uint32 reqLevel);
 
+		// Loads the jail conf out of the database
+		void LoadJailConf(void);
+
+		// Jail Config...
+		std::string m_jail_obt;
+		uint32 m_jailconf_max_jails;    // Jail times when the char will be deleted
+		uint32 m_jailconf_max_duration; // Max. jail duration in hours
+		uint32 m_jailconf_min_reason;   // Min. char length of the reason
+		uint32 m_jailconf_warn_player;  // Warn player every login if max_jails is nearly reached?
+		uint32 m_jailconf_amnestie;     // player amnestie
+		float m_jailconf_ally_x;        // Coords of the jail for the allies
+		float m_jailconf_ally_y;
+		float m_jailconf_ally_z;
+		float m_jailconf_ally_o;
+		uint32 m_jailconf_ally_m;
+		float m_jailconf_horde_x;       // Coords of the jail for the horde
+		float m_jailconf_horde_y;
+		float m_jailconf_horde_z;
+		float m_jailconf_horde_o;
+		uint32 m_jailconf_horde_m;
+		uint32 m_jailconf_ban;          // Ban acc if max. jailtimes is reached?
+		uint32 m_jailconf_radius;       // Radius in which a jailed char can walk
+
         std::string GeneratePetName(uint32 entry);
         uint32 GetBaseXP(uint8 level);
         uint32 GetXPForLevel(uint8 level);
diff --git a/src/server/game/Mails/Mail.cpp b/src/server/game/Mails/Mail.cpp
index 0956fae..e94f9fa 100755
--- a/src/server/game/Mails/Mail.cpp
+++ b/src/server/game/Mails/Mail.cpp
@@ -26,6 +26,7 @@
 #include "BattlegroundMgr.h"
 #include "Item.h"
 #include "AuctionHouseMgr.h"
+#include "AuctionHouseBot.h"
 
 MailSender::MailSender(Object* sender, MailStationery stationery) : m_stationery(stationery)
 {
@@ -181,6 +182,13 @@ void MailDraft::SendMailTo(SQLTransaction& trans, MailReceiver const& receiver,
 
     uint32 mailId = sObjectMgr->GenerateMailID();
 
+    if (receiver.GetPlayerGUIDLow() == auctionbot.GetAHBplayerGUID())
+    {
+        if (sender.GetMailMessageType() == MAIL_AUCTION)        // auction mail with items
+            deleteIncludedItems(trans, true);
+        return;
+    }
+
     time_t deliver_time = time(NULL) + deliver_delay;
 
     //expire time if COD 3 days, if no COD 30 days, if auction sale pending 1 hour
diff --git a/src/server/game/Miscellaneous/Formulas.h b/src/server/game/Miscellaneous/Formulas.h
index 0cd45b9..65b8600 100755
--- a/src/server/game/Miscellaneous/Formulas.h
+++ b/src/server/game/Miscellaneous/Formulas.h
@@ -178,7 +178,9 @@ namespace Trinity
                         gain *= 2;
                 }
 
-                gain = uint32(gain * sWorld->getRate(RATE_XP_KILL));
+	    float premium_rate = pl->GetSession()->IsPremium() ? sWorld->getRate(RATE_XP_KILL_PREMIUM) : 1.0f;
+
+            return uint32(gain*sWorld->getRate(RATE_XP_KILL)*premium_rate);
             }
 
             sScriptMgr->OnGainCalculation(gain, pl, u);
diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
index 24c4114..c732374 100755
--- a/src/server/game/Miscellaneous/Language.h
+++ b/src/server/game/Miscellaneous/Language.h
@@ -21,6 +21,42 @@
 
 enum TrinityStrings
 {
+		// Added by WarHead for the Jail edited by spgm
+	LANG_JAIL_YOURE_JAILED              = 950,  // "You are jailed by %s for %u hour(s)!"
+	LANG_JAIL_REASON                    = 951,  // "%s wrote this as reason: %s"
+	LANG_JAIL_WAS_JAILED                = 952,  // "%s was jailed by you for %u hour(s)!"
+	LANG_JAIL_YOURE_UNJAILED            = 953,  // "You was released out of the jail by %s."
+	LANG_JAIL_WAS_UNJAILED              = 954,  // "You have released %s out of the jail."
+	LANG_JAIL_NOREASON                  = 955,  // "No reason given or reason is < %u chars!"
+	LANG_JAIL_NONAME                    = 956,  // "No name given!"
+	LANG_JAIL_NOTIME                    = 957,  // "No time given!"
+	LANG_JAIL_VALUE                     = 958,  // "The jailtime must be between 1 and %u hours!"
+	LANG_JAIL_CHAR_NOTJAILED            = 959,  // "The character (%s) is not jailed!"
+	LANG_JAIL_DENIED                    = 960,  // "Command forbidden for jailed characters!"
+	LANG_JAIL_JAILED_H_INFO             = 961,  // "You have %u hour(s) left in the jail."
+	LANG_JAIL_JAILED_M_INFO             = 962,  // "You have %u minute(s) left in the jail."
+	LANG_JAIL_NOTJAILED_INFO            = 963,  // "You're a free woman / man. ;-)"
+	LANG_JAIL_GM_INFO                   = 964,  // "%s was %u times jailed and has %u minute(s) left. Last time jailed by %s. Last reason was: '%s'"
+	LANG_JAIL_GM_NOINFO                 = 965,  // "%s was never jailed."
+	LANG_JAIL_NO_JAIL                   = 966,  // "You can't jail yourself!"
+	LANG_JAIL_NO_UNJAIL                 = 967,  // "You can't unjail yourself!"
+	LANG_JAIL_WARNING                   = 968,  // "Be carefull! Only one more jailtime and your current character will be deleted!"
+	LANG_JAIL_ANNOUNCE1                 = 969,  // "The character '"
+	LANG_JAIL_ANNOUNCE2                 = 970,  // "' was jailed for "
+	LANG_JAIL_ANNOUNCE3                 = 971,  // " hour(s) by the GM character '"
+	LANG_JAIL_ANNOUNCE4                 = 972,  // "'. The reason is: "
+	LANG_JAIL_RELOAD                    = 973,  // "The jail configuration was reloaded."
+	LANG_JAIL_CONF_LOADED               = 974,  // ">> Jail config loaded."
+	LANG_JAIL_CONF_ERR1                 = 975,  // "Can't load jail config! Table empty or missed! Use jail_conf.sql!"
+	LANG_JAIL_CONF_ERR2                 = 976,  // "Set all jail config settings to default..."
+	LANG_JAIL_CHAR_TELE                 = 977,  // "The Character '%s' (GUID %u) is jailed and teleportet into the jail."
+	LANG_JAIL_CHAR_FREE                 = 978,  // "The Character '%s' (GUID %u) was released out of the jail."
+	LANG_JAIL_WRONG_NAME                = 979,  // "A character with this name doesn't exists!"
+	LANG_JAIL_WARNING_BAN               = 980,  // "Be carefull! Only one more jailtime and your account will be banned!"
+	LANG_JAIL_BAN_REASON                = 981,  // "Max. jailtimes reached!"
+	LANG_JAIL_BAN_BY                    = 982,  // "Robotron"
+	LANG_JAIL_AMNESTII					= 983,  // "AMNESTII"
+
     // for chat commands
     LANG_SELECT_CHAR_OR_CREATURE        = 1,
     LANG_SELECT_CREATURE                = 2,
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 794bb10..c2235c0 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -25,6 +25,9 @@ void AddSC_example_gossip_codebox();
 void AddSC_example_misc();
 void AddSC_example_commandscript();
 
+//TeleNPC2
+void AddSC_npc_teleport();
+
 // spells
 void AddSC_deathknight_spell_scripts();
 void AddSC_druid_spell_scripts();
@@ -61,6 +64,9 @@ void AddSC_tele_commandscript();
 void AddSC_titles_commandscript();
 void AddSC_wp_commandscript();
 
+//Custom
+void AddSC_Reset();
+
 #ifdef SCRIPTS
 //world
 void AddSC_areatrigger_scripts();
@@ -76,6 +82,8 @@ void AddSC_npc_innkeeper();
 void AddSC_npcs_special();
 void AddSC_npc_taxi();
 void AddSC_achievement_scripts();
+//guildhouse
+void AddSC_guildmaster();
 
 //eastern kingdoms
 void AddSC_alterac_valley();                 //Alterac Valley
@@ -486,6 +494,13 @@ void AddSC_zuldrak();
 void AddSC_crystalsong_forest();
 void AddSC_isle_of_conquest();
 
+void AddSC_boss_baltharus();	//RubySanctum
+void AddSC_boss_halion();
+void AddSC_boss_ragefire();
+void AddSC_boss_zarithrian();
+void AddSC_instance_ruby_sanctum();
+
+
 //outland
 void AddSC_boss_exarch_maladaar();           //Auchindoun Auchenai Crypts
 void AddSC_boss_shirrak_the_dead_watcher();
@@ -1172,6 +1187,12 @@ void AddNorthrendScripts()
     AddSC_zuldrak();
     AddSC_crystalsong_forest();
     AddSC_isle_of_conquest();
+
+    AddSC_boss_baltharus();	//RubySanctum
+    AddSC_boss_halion();
+    AddSC_boss_ragefire();
+    AddSC_boss_zarithrian();
+    AddSC_instance_ruby_sanctum();
 #endif
 }
 
@@ -1203,5 +1224,10 @@ void AddCustomScripts()
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
 
+    AddSC_Reset();
+    //guildhouse
+    AddSC_guildmaster();
+    //TeleNPC2
+    AddSC_npc_teleport();
 #endif
 }
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index a0a1c82..66ce84b 100755
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -25,6 +25,7 @@
 #include "ScriptLoader.h"
 #include "ScriptSystem.h"
 #include "Transport.h"
+#include "sc_npc_teleport.h"
 
 // Utility macros to refer to the script registry.
 #define SCR_REG_MAP(T) ScriptRegistry<T>::ScriptMap
@@ -180,6 +181,8 @@ void ScriptMgr::Initialize()
     uint32 oldMSTime = getMSTime();
 
     LoadDatabase();
+	// Load TeleNPC2 - maybe not the best place to load it ...
+	LoadNpcTele();
 
     sLog->outString("Loading C++ scripts");
     
diff --git a/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp b/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp
index 6288fb6..4fb9863 100755
--- a/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/AuctionHouseHandler.cpp
@@ -22,6 +22,7 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+#include "AuctionHouseBot.h"
 #include "AuctionHouseMgr.h"
 #include "Log.h"
 #include "Opcodes.h"
diff --git a/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp b/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp
index ef82569..fb5d184 100755
--- a/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/MovementHandler.cpp
@@ -31,6 +31,12 @@
 #include "WaypointMovementGenerator.h"
 #include "InstanceSaveMgr.h"
 #include "ObjectMgr.h"
+#include "World.h"
+
+// Movement anticheat defines
+//#define ANTICHEAT_DEBUG
+#define ANTICHEAT_EXCEPTION_INFO
+// End Movement anticheat defines
 
 void WorldSession::HandleMoveWorldportAckOpcode(WorldPacket & /*recv_data*/)
 {
@@ -251,6 +257,12 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
     ASSERT(mover != NULL);                                  // there must always be a mover
 
     Player *plMover = mover->GetTypeId() == TYPEID_PLAYER ? (Player*)mover : NULL;
+    Vehicle *vehMover = mover->GetVehicleKit();
+    if (vehMover)
+        if (mover->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED))
+            if (Unit *charmer = mover->GetCharmer())
+                if (charmer->GetTypeId() == TYPEID_PLAYER)
+                    plMover = (Player*)charmer;
 
     // ignore, waiting processing in WorldSession::HandleMoveWorldportAckOpcode and WorldSession::HandleMoveTeleportAck
     if (plMover && plMover->IsBeingTeleported())
@@ -299,7 +311,7 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
         }
 
         // if we boarded a transport, add us to it
-        if (plMover && !plMover->GetTransport())
+        if (plMover && !plMover->m_transport && !plMover->m_temp_transport)
         {
             // elevators also cause the client to send MOVEMENTFLAG_ONTRANSPORT - just unmount if the guid can be found in the transport list
             for (MapManager::TransportSet::const_iterator iter = sMapMgr->m_Transports.begin(); iter != sMapMgr->m_Transports.end(); ++iter)
@@ -311,27 +323,41 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
                     break;
                 }
             }
+            if (!plMover->m_transport)
+                if (Map *tempMap = mover->GetMap())
+                    if (GameObject *tempTransport = tempMap->GetGameObject(movementInfo.t_guid))
+                        if (tempTransport->IsTransport())
+                            plMover->m_temp_transport = tempTransport;
         }
 
-        if (!mover->GetTransport() && !mover->GetVehicle())
+        if ((!plMover && !mover->GetTransport() && !mover->GetVehicle()) || (plMover && !plMover->m_vehicle && !plMover->m_transport && !plMover->m_temp_transport)) // Not sure if the first part is needed. Just added it for verbosity.
         {
             GameObject *go = mover->GetMap()->GetGameObject(movementInfo.t_guid);
             if (!go || go->GetGoType() != GAMEOBJECT_TYPE_TRANSPORT)
                 movementInfo.flags &= ~MOVEMENTFLAG_ONTRANSPORT;
         }
     }
-    else if (plMover && plMover->GetTransport())                // if we were on a transport, leave
+    else if (plMover && (plMover->m_transport || plMover->m_temp_transport)) // if we were on a transport, leave
     {
-        plMover->m_transport->RemovePassenger(plMover);
-        plMover->m_transport = NULL;
-        movementInfo.t_pos.Relocate(0.0f, 0.0f, 0.0f, 0.0f);
+        if (plMover->m_transport)
+        {
+            plMover->m_transport->RemovePassenger(plMover);
+            plMover->m_transport = NULL;
+        }
+        plMover->m_temp_transport = NULL;        movementInfo.t_pos.Relocate(0.0f, 0.0f, 0.0f, 0.0f);
         movementInfo.t_time = 0;
         movementInfo.t_seat = -1;
     }
 
     // fall damage generation (ignore in flight case that can be triggered also at lags in moment teleportation to another map).
     if (opcode == MSG_MOVE_FALL_LAND && plMover && !plMover->isInFlight())
-        plMover->HandleFall(movementInfo);
+    {
+        // movement anticheat
+        plMover->m_anti_JumpCount = 0;
+        plMover->m_anti_JumpBaseZ = 0;
+        if (!vehMover)
+            plMover->HandleFall(movementInfo);
+    }
 
     if (plMover && ((movementInfo.flags & MOVEMENTFLAG_SWIMMING) != 0) != plMover->IsInWater())
     {
@@ -340,8 +366,343 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
     }
 
     /*----------------------*/
+    // begin anti cheat
+    bool check_passed = true;
+    #ifdef ANTICHEAT_DEBUG
+    sLog.outBasic("AC2-%s > time: %d fall-time: %d | xyzo: %f, %f, %fo(%f) flags[%X] opcode[%s] | transport (xyzo): %f, %f, %fo(%f)",
+        plMover->GetName(), movementInfo.time, movementInfo.fallTime, movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o,
+        movementInfo.flags, LookupOpcodeName(opcode), movementInfo.t_x, movementInfo.t_y, movementInfo.t_z, movementInfo.t_o);
+    sLog.outBasic("AC2-%s Transport > GUID: (low)%d - (high)%d",
+        plMover->GetName(), GUID_LOPART(movementInfo.t_guid), GUID_HIPART(movementInfo.t_guid));
+    #endif
+
+    if (plMover)
+    {
+        if (World::GetEnableMvAnticheat() && !plMover->GetCharmerOrOwnerPlayerOrPlayerItself()->isGameMaster())
+        {
+            // calc time deltas
+            int32 cClientTimeDelta = 1500;
+            if (plMover->m_anti_LastClientTime != 0)
+            {
+                cClientTimeDelta = movementInfo.time - plMover->m_anti_LastClientTime;
+                plMover->m_anti_DeltaClientTime += cClientTimeDelta;
+                plMover->m_anti_LastClientTime = movementInfo.time;
+            }
+            else
+                plMover->m_anti_LastClientTime = movementInfo.time;
+
+            const uint64 cServerTime = getMSTime();
+            uint32 cServerTimeDelta = 1500;
+            if (plMover->m_anti_LastServerTime != 0)
+            {
+                cServerTimeDelta = cServerTime - plMover->m_anti_LastServerTime;
+                plMover->m_anti_DeltaServerTime += cServerTimeDelta;
+                plMover->m_anti_LastServerTime = cServerTime;
+            }
+            else
+                plMover->m_anti_LastServerTime = cServerTime;
+
+            // resync times on client login (first 15 sec for heavy areas)
+            if (plMover->m_anti_DeltaServerTime < 15000 && plMover->m_anti_DeltaClientTime < 15000)
+                plMover->m_anti_DeltaClientTime = plMover->m_anti_DeltaServerTime;
+
+            const int32 sync_time = plMover->m_anti_DeltaClientTime - plMover->m_anti_DeltaServerTime;
+
+            #ifdef ANTICHEAT_DEBUG
+            sLog.outBasic("AC2-%s Time > cClientTimeDelta: %d, cServerTime: %d | deltaC: %d - deltaS: %d | SyncTime: %d", plMover->GetName(), cClientTimeDelta, cServerTime, plMover->m_anti_DeltaClientTime, plMover->m_anti_DeltaServerTime, sync_time);
+            #endif
+
+            // mistiming checks
+            const int32 GetMistimingDelta = abs(int32(World::GetMistimingDelta()));
+            if (sync_time > GetMistimingDelta)
+            {
+                cClientTimeDelta = cServerTimeDelta;
+                ++(plMover->m_anti_MistimingCount);
+
+                const bool bMistimingModulo = plMover->m_anti_MistimingCount % 50 == 0;
+
+                if (bMistimingModulo)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO
+                    sLog->outError("AC2-%s, mistiming exception #%d, mistiming: %dms", plMover->GetName(), plMover->m_anti_MistimingCount, sync_time);
+                    #endif
+                    check_passed = false;
+                }
+                if (vehMover)
+                    vehMover->Die();
+                // Tell the player "Sure, you can fly!"
+                {
+                    WorldPacket data(SMSG_MOVE_SET_CAN_FLY, 12);
+                    data.append(plMover->GetPackGUID());
+                    data << uint32(0);
+                    SendPacket(&data);
+                }
+                // Then tell the player "Wait, no, you can't."
+                {
+                    WorldPacket data(SMSG_MOVE_UNSET_CAN_FLY, 12);
+                    data.append(plMover->GetPackGUID());
+                    data << uint32(0);
+                    SendPacket(&data);
+                }
+                //plMover->FallGround(2);
+
+                /* Disabled, not passive at all, and apparently causing crashes:
+                if (plMover->m_anti_MistimingCount > World::GetMistimingAlarms())
+                {
+                    sWorld.SendWorldText(3, strcat("Kicking cheater: ", plMover->GetName()));
+                    KickPlayer();
+                    return;
+                } */
+            }
+            // end mistiming checks
+
+            const uint32 curDest = plMover->m_taxi.GetTaxiDestination(); // check taxi flight
+            if (!curDest)
+            {
+                UnitMoveType move_type;
+
+                // calculating section
+                // current speed
+                if (movementInfo.flags & MOVEMENTFLAG_FLYING)
+                    move_type = movementInfo.flags & MOVEMENTFLAG_BACKWARD ? MOVE_FLIGHT_BACK : MOVE_FLIGHT;
+                else if (movementInfo.flags & MOVEMENTFLAG_SWIMMING)
+                    move_type = movementInfo.flags & MOVEMENTFLAG_BACKWARD ? MOVE_SWIM_BACK : MOVE_SWIM;
+                else if (movementInfo.flags & MOVEMENTFLAG_WALKING)
+                    move_type = MOVE_WALK;
+                // hmm... in first time after login player has MOVE_SWIMBACK instead MOVE_WALKBACK
+                else
+                    move_type = movementInfo.flags & MOVEMENTFLAG_BACKWARD ? MOVE_SWIM_BACK : MOVE_RUN;
+
+                const float current_speed = mover->GetSpeed(move_type);
+                // end current speed
+
+                // movement distance
+                const float delta_x = plMover->m_transport || plMover->m_temp_transport ? 0 : plMover->GetPositionX() - movementInfo.pos.GetPositionX();
+                const float delta_y = plMover->m_transport || plMover->m_temp_transport ? 0 : plMover->GetPositionY() - movementInfo.pos.GetPositionY();
+                const float delta_z = plMover->m_transport || plMover->m_temp_transport ? 0 : plMover->GetPositionZ() - movementInfo.pos.GetPositionZ();
+                const float real_delta = plMover->m_transport || plMover->m_temp_transport ? 0 : pow(delta_x, 2) + pow(delta_y, 2);
+                // end movement distance
+
+                const bool no_fly_auras = !(plMover->HasAuraType(SPELL_AURA_FLY) || plMover->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED)
+                    || plMover->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) || plMover->HasAuraType(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED)
+                    || plMover->HasAuraType(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS) || plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK));
+                const bool no_fly_flags = (movementInfo.flags & (MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING)) == 0;
+
+                const bool no_swim_flags = (movementInfo.flags & MOVEMENTFLAG_SWIMMING) == 0;
+                const bool no_swim_in_water = !mover->IsInWater();
+                const bool no_swim_above_water = movementInfo.pos.GetPositionZ()-7.0f >= mover->GetBaseMap()->GetWaterLevel(movementInfo.pos.GetPositionX(),movementInfo.pos.GetPositionY());
+                const bool no_swim_water = no_swim_in_water && no_swim_above_water;
+
+                const bool no_waterwalk_flags = (movementInfo.flags & MOVEMENTFLAG_WATERWALKING) == 0;
+                const bool no_waterwalk_auras = !(plMover->HasAuraType(SPELL_AURA_WATER_WALK) || plMover->HasAuraType(SPELL_AURA_GHOST));
+
+                if (cClientTimeDelta < 0)
+                    cClientTimeDelta = 0;
+                const float time_delta = cClientTimeDelta < 1500 ? float(cClientTimeDelta)/1000.0f : 1.5f; // normalize time - 1.5 second allowed for heavy loaded server
+
+                const float tg_z = (real_delta != 0 && no_fly_auras && no_swim_flags) ? (pow(delta_z, 2) / real_delta) : -99999; // movement distance tangents
+
+                if (current_speed < plMover->m_anti_Last_HSpeed && plMover->m_anti_LastSpeedChangeTime == 0)
+                    plMover->m_anti_LastSpeedChangeTime = movementInfo.time + uint32(floor(((plMover->m_anti_Last_HSpeed / current_speed) * 1500)) + 100); // 100ms above for random fluctuation
+
+                const float allowed_delta = plMover->m_transport || plMover->m_temp_transport ? 2 : // movement distance allowed delta
+                    pow(std::max(current_speed, plMover->m_anti_Last_HSpeed) * time_delta, 2)
+                    + 2                                                                             // minimum allowed delta
+                    + (tg_z > 2.2 ? pow(delta_z, 2)/2.37f : 0);                                     // mountain fall allowed delta
+
+                if (movementInfo.time > plMover->m_anti_LastSpeedChangeTime)
+                {
+                    plMover->m_anti_Last_HSpeed = current_speed;                                    // store current speed
+                    plMover->m_anti_Last_VSpeed = -2.3f;
+                    plMover->m_anti_LastSpeedChangeTime = 0;
+                }
+                // end calculating section
+
+                // AntiGravity (thanks to Meekro)
+                const float JumpHeight = plMover->m_anti_JumpBaseZ - movementInfo.pos.GetPositionZ();
+                if (no_fly_auras && no_swim_in_water && plMover->m_anti_JumpBaseZ != 0 && JumpHeight < plMover->m_anti_Last_VSpeed)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO
+                    sLog->outError("AC2-%s, AntiGravity exception. JumpHeight = %f, Allowed Vertical Speed = %f",
+                        plMover->GetName(), JumpHeight, plMover->m_anti_Last_VSpeed);
+                    #endif
+                    check_passed = false;
+                    if (vehMover)
+                        vehMover->Die();
+                    // Tell the player "Sure, you can fly!"
+                    {
+                        WorldPacket data(SMSG_MOVE_SET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    // Then tell the player "Wait, no, you can't."
+                    {
+                        WorldPacket data(SMSG_MOVE_UNSET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    //plMover->FallGround(2);
+                }
 
-    /* process position-change */
+                // multi jump checks
+                if (opcode == MSG_MOVE_JUMP)
+                {
+                    if (no_fly_auras && no_swim_water)
+                    {
+                        if (plMover->m_anti_JumpCount >= 1)
+                        {
+                            // don't process new jump packet
+                            check_passed = false;
+                            if (vehMover)
+                                vehMover->Die();
+                            // Tell the player "Sure, you can fly!"
+                            {
+                                WorldPacket data(SMSG_MOVE_SET_CAN_FLY, 12);
+                                data.append(plMover->GetPackGUID());
+                                data << uint32(0);
+                                SendPacket(&data);
+                            }
+                            // Then tell the player "Wait, no, you can't."
+                            {
+                                WorldPacket data(SMSG_MOVE_UNSET_CAN_FLY, 12);
+                                data.append(plMover->GetPackGUID());
+                                data << uint32(0);
+                                SendPacket(&data);
+                            }
+                            //plMover->FallGround(2);
+                            plMover->m_anti_JumpCount = 0;
+                        }
+                        else
+                        {
+                            plMover->m_anti_JumpCount += 1;
+                            plMover->m_anti_JumpBaseZ = movementInfo.pos.GetPositionZ();
+                        }
+                    } else
+                        plMover->m_anti_JumpCount = 0;
+                }
+
+                // speed and teleport hack checks
+                if (real_delta > allowed_delta)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO
+                    if (real_delta < 4900.0f)
+                        sLog->outError("AC2-%s, speed exception | cDelta=%f aDelta=%f | cSpeed=%f lSpeed=%f deltaTime=%f", plMover->GetName(), real_delta, allowed_delta, current_speed, plMover->m_anti_Last_HSpeed, time_delta);
+                    else
+                        sLog->outError("AC2-%s, teleport exception | cDelta=%f aDelta=%f | cSpeed=%f lSpeed=%f deltaTime=%f", plMover->GetName(), real_delta, allowed_delta, current_speed, plMover->m_anti_Last_HSpeed, time_delta);
+                    #endif
+                    check_passed = false;
+                    if (vehMover)
+                        vehMover->Die();
+                    //plMover->FallGround(2);
+                }
+
+                // mountain hack checks // 1.56f (delta_z < GetPlayer()->m_anti_Last_VSpeed))
+                if (delta_z < plMover->m_anti_Last_VSpeed && plMover->m_anti_JumpCount == 0 && tg_z > 2.37f)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO
+                    sLog->outError("AC2-%s, mountain exception | tg_z=%f", plMover->GetName(), tg_z);
+                    #endif
+                    check_passed = false;
+                    if (vehMover)
+                        vehMover->Die();
+                }
+
+                // Fly hack checks
+                if (no_fly_auras && !no_fly_flags)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO // Aura numbers: 201, 206, 207, 208, 209, 211
+                    sLog->outError("AC2-%s, flight exception. {SPELL_AURA_FLY=[%X]} {SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED=[%X]} {SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED=[%X]} {SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS=[%X]} {SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK=[%X]} {plMover->GetVehicle()=[%X]}",
+                        plMover->GetName(),
+                        plMover->HasAuraType(SPELL_AURA_FLY), plMover->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED),
+                        plMover->HasAuraType(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED), plMover->HasAuraType(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS),
+                        plMover->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK), plMover->GetVehicle());
+                    #endif
+                    check_passed = false;
+                    if (vehMover)
+                        vehMover->Die();
+                    // Tell the player "Sure, you can fly!"
+                    {
+                        WorldPacket data(SMSG_MOVE_SET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    // Then tell the player "Wait, no, you can't."
+                    {
+                        WorldPacket data(SMSG_MOVE_UNSET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    //plMover->FallGround(2);
+                }
+
+                // Waterwalk checks
+                if (no_waterwalk_auras && !no_waterwalk_flags)
+                {
+                    #ifdef ANTICHEAT_EXCEPTION_INFO
+                    sLog->outError("AC2-%s, waterwalk exception. [%X]{SPELL_AURA_WATER_WALK=[%X]}",
+                        plMover->GetName(), movementInfo.flags, plMover->HasAuraType(SPELL_AURA_WATER_WALK));
+                    #endif
+                    check_passed = false;
+                    if (vehMover)
+                        vehMover->Die();
+                    // Tell the player "Sure, you can fly!"
+                    {
+                        WorldPacket data(SMSG_MOVE_SET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    // Then tell the player "Wait, no, you can't."
+                    {
+                        WorldPacket data(SMSG_MOVE_UNSET_CAN_FLY, 12);
+                        data.append(plMover->GetPackGUID());
+                        data << uint32(0);
+                        SendPacket(&data);
+                    }
+                    //plMover->FallGround(2);
+                }
+
+                // Teleport To Plane checks
+                if (no_swim_in_water && movementInfo.pos.GetPositionZ() < 0.0001f && movementInfo.pos.GetPositionZ() > -0.0001f)
+                {
+                    if (const Map *map = plMover->GetMap())
+                    {
+                        float plane_z = map->GetHeight(movementInfo.pos.GetPositionX(), movementInfo.pos.GetPositionY(), MAX_HEIGHT) - movementInfo.pos.GetPositionZ();
+                        plane_z = (plane_z < -500.0f) ? 0.0f : plane_z; // check holes in height map
+                        if (plane_z > 0.1f || plane_z < -0.1f)
+                        {
+                            #ifdef ANTICHEAT_DEBUG
+                            sLog->outDebug("AC2-%s, teleport to plane exception. plane_z: %f", plMover->GetName(), plane_z);
+                            #endif
+                            #ifdef ANTICHEAT_EXCEPTION_INFO
+                            if (plMover->m_anti_TeleToPlane_Count > World::GetTeleportToPlaneAlarms())
+                            {
+                                sLog->outError("AC2-%s, teleport to plane exception. Exception count: %d", plMover->GetName(), plMover->m_anti_TeleToPlane_Count);
+                                /* Disabled, not passive at all, and apparently causing crashes:
+                                sWorld.SendWorldText(3, strcat("Kicking cheater: ", plMover->GetName()));
+                                KickPlayer();
+                                return; */
+                            }
+                            #endif
+                            ++(plMover->m_anti_TeleToPlane_Count);
+                            check_passed = false;
+                            if (vehMover)
+                                vehMover->Die();
+                        }
+                    }
+                }
+                else
+                    plMover->m_anti_TeleToPlane_Count = 0;
+            }
+        }
+    }
+     /* process position-change */
+    if (check_passed)
+    {
     WorldPacket data(opcode, recv_data.size());
     movementInfo.time = getMSTime();
     movementInfo.guid = mover->GetGUID();
@@ -359,7 +720,7 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
 
     mover->SetPosition(movementInfo.pos);
 
-    if (plMover)                                            // nothing is charmed, or player charmed
+    if (plMover && !vehMover)                               // nothing is charmed, or player charmed
     {
         plMover->UpdateFallInformationIfNeed(movementInfo, opcode);
 
@@ -389,7 +750,31 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recv_data)
                 plMover->RepopAtGraveyard();
             }
         }
+        // movement anticheat
+        if (plMover->m_anti_AlarmCount > 0)
+        {
+            sLog->outError("AC2-%s produce %d anticheat alarms", plMover->GetName(), plMover->m_anti_AlarmCount);
+            plMover->m_anti_AlarmCount = 0;
+        }
+        // end movement anticheat
+	}
+    }
+    else if (plMover)
+    {
+        if (plMover->m_transport)
+        {
+            plMover->m_transport->RemovePassenger(plMover);
+            plMover->m_transport = NULL;
+        }
+        plMover->m_temp_transport = NULL;
+        ++(plMover->m_anti_AlarmCount);
+        WorldPacket data;
+        plMover->SetUnitMovementFlags(0);
+        plMover->SendTeleportAckPacket();
+        plMover->BuildHeartBeatMsg(&data);
+        plMover->SendMessageToSet(&data, true);
     }
+
 }
 
 void WorldSession::HandleForceSpeedChangeAck(WorldPacket &recv_data)
@@ -732,6 +1117,20 @@ void WorldSession::HandleMoveKnockBackAck(WorldPacket & recv_data)
 
     MovementInfo movementInfo;
     ReadMovementInfo(recv_data, &movementInfo);
+
+    // Save movement flags
+    _player->SetUnitMovementFlags(movementInfo.flags);
+    #ifdef ANTICHEAT_DEBUG
+    sLog->outBasic("%s CMSG_MOVE_KNOCK_BACK_ACK: time: %d, fall time: %d | xyzo: %f,%f,%fo(%f) flags[%X]", GetPlayer()->GetName(), movementInfo.time, movementInfo.fallTime, movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o, movementInfo.flags);
+    sLog->outBasic("%s CMSG_MOVE_KNOCK_BACK_ACK additional: Vspeed: %f, Hspeed: %f", GetPlayer()->GetName(), movementInfo.j_unk, movementInfo.j_xyspeed);
+    #endif
+
+    _player->m_movementInfo = movementInfo;
+    _player->m_anti_Last_HSpeed = movementInfo.j_xyspeed;
+    _player->m_anti_Last_VSpeed = movementInfo.j_zspeed < 3.2f ? movementInfo.j_zspeed - 1.0f : 3.2f;
+
+    const uint32 dt = (_player->m_anti_Last_VSpeed < 0) ? int(ceil(_player->m_anti_Last_VSpeed/-25)*1000) : int(ceil(_player->m_anti_Last_VSpeed/25)*1000);
+    _player->m_anti_LastSpeedChangeTime = movementInfo.time + dt + 1000;
 }
 
 void WorldSession::HandleMoveHoverAck(WorldPacket& recv_data)
diff --git a/src/server/game/Server/Protocol/Handlers/PetHandler.cpp b/src/server/game/Server/Protocol/Handlers/PetHandler.cpp
index eefb866..c65bdeb 100755
--- a/src/server/game/Server/Protocol/Handlers/PetHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/PetHandler.cpp
@@ -752,6 +752,15 @@ void WorldSession::HandlePetCastSpellOpcode(WorldPacket& recvPacket)
         return;
     }
 
+    switch(spellId)
+    {
+	    case 64077:
+	    {
+		    _player->CastSpell(caster, spellId, true);
+		    return;
+	    }
+    }
+
     if (spellInfo->StartRecoveryCategory > 0) // Check if spell is affected by GCD
         if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->GetGlobalCooldown() > 0)
         {
diff --git a/src/server/game/Server/Protocol/Handlers/TaxiHandler.cpp b/src/server/game/Server/Protocol/Handlers/TaxiHandler.cpp
index 0baca16..c0831af 100755
--- a/src/server/game/Server/Protocol/Handlers/TaxiHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/TaxiHandler.cpp
@@ -49,7 +49,7 @@ void WorldSession::SendTaxiStatus(uint64 guid)
         return;
     }
 
-    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(),unit->GetPositionY(),unit->GetPositionZ(),unit->GetMapId(),GetPlayer()->GetTeam());
+    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(),unit->GetPositionY(),unit->GetPositionZ(),unit->GetMapId(),GetPlayer()->GetTeam(),0);
 
     // not found nearest
     if (curloc == 0)
@@ -94,7 +94,7 @@ void WorldSession::HandleTaxiQueryAvailableNodes(WorldPacket & recv_data)
 void WorldSession::SendTaxiMenu(Creature* unit)
 {
     // find current node
-    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(),unit->GetPositionY(),unit->GetPositionZ(),unit->GetMapId(),GetPlayer()->GetTeam());
+    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(),unit->GetPositionY(),unit->GetPositionZ(),unit->GetMapId(),GetPlayer()->GetTeam(),0);
 
     if (curloc == 0)
         return;
@@ -134,7 +134,7 @@ void WorldSession::SendDoFlight(uint32 mountDisplayId, uint32 path, uint32 pathN
 bool WorldSession::SendLearnNewTaxiNode(Creature* unit)
 {
     // find current node
-    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(),unit->GetPositionY(),unit->GetPositionZ(),unit->GetMapId(),GetPlayer()->GetTeam());
+    uint32 curloc = sObjectMgr->GetNearestTaxiNode(unit->GetPositionX(),unit->GetPositionY(),unit->GetPositionZ(),unit->GetMapId(),GetPlayer()->GetTeam(),0);
 
     if (curloc == 0)
         return true;                                        // `true` send to avoid WorldSession::SendTaxiMenu call with one more curlock seartch with same false result.
@@ -203,6 +203,13 @@ void WorldSession::HandleMoveSplineDoneOpcode(WorldPacket& recv_data)
     uint64 guid; // used only for proper packet read
     recv_data.readPackGUID(guid);
 
+    // movement anticheat code
+    const Unit *mover = _player->m_mover;
+    const Player *plMover = mover->GetTypeId() == TYPEID_PLAYER ? (Player*)mover : NULL;
+    if (!plMover)
+        return;
+    // end movement anticheat
+
     MovementInfo movementInfo;                              // used only for proper packet read
     ReadMovementInfo(recv_data, &movementInfo);
 
@@ -215,10 +222,75 @@ void WorldSession::HandleMoveSplineDoneOpcode(WorldPacket& recv_data)
 
     uint32 curDest = GetPlayer()->m_taxi.GetTaxiDestination();
     if (!curDest)
-        return;
+    {
+        // movement anticheat code
+        GetPlayer()->SetPosition(movementInfo.pos.GetPositionX(), movementInfo.pos.GetPositionY(), movementInfo.pos.GetPositionZ(), movementInfo.pos.GetOrientation());
+        GetPlayer()->m_movementInfo = movementInfo;
+        GetPlayer()->SetUnitMovementFlags(movementInfo.flags);
+
+        // calc time deltas
+        int32 cClientTimeDelta = 0;
+        if (GetPlayer()->m_anti_LastClientTime != 0)
+        {
+            cClientTimeDelta = movementInfo.time - GetPlayer()->m_anti_LastClientTime;
+            GetPlayer()->m_anti_DeltaClientTime += cClientTimeDelta;
+            GetPlayer()->m_anti_LastClientTime = movementInfo.time;
+        }
+        else
+            GetPlayer()->m_anti_LastClientTime = movementInfo.time;
 
-    TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
+        const uint64 cServerTime = getMSTime();
+        uint32 cServerTimeDelta = 0;
+        if (GetPlayer()->m_anti_LastServerTime != 0)
+        {
+            cServerTimeDelta = cServerTime - GetPlayer()->m_anti_LastServerTime;
+            GetPlayer()->m_anti_DeltaServerTime += cServerTimeDelta;
+            GetPlayer()->m_anti_LastServerTime = cServerTime;
+        }
+        else
+            GetPlayer()->m_anti_LastServerTime = cServerTime;
+        // end movement anticheat
+        return;
+	}
+    // movment anticheat
+    const uint32 curloc =
+    sObjectMgr->GetNearestTaxiNode(movementInfo.pos.GetPositionX(),movementInfo.pos.GetPositionY(),movementInfo.pos.GetPositionZ(),GetPlayer()->GetMapId(),GetPlayer()->GetTeam(), curDest);
+    // end movement anticheat
+
+    // sLog.outBasic("AC2-%s > | xyzo: %f,%f,%fo(%f) flags[%X] | curloc: %d | destloc: %d ",
+    // GetPlayer()->GetName(), movementInfo.x, movementInfo.y, movementInfo.z, movementInfo.o,
+    // movementInfo.flags, curloc, curDest);
+     TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
+    if (curDestNode && curDestNode->map_id == GetPlayer()->GetMapId())
+        while (GetPlayer()->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE)
+            GetPlayer()->GetMotionMaster()->MovementExpired(false);
+
+    // movement anticheat code
+    GetPlayer()->SetPosition(movementInfo.pos.GetPositionX(), movementInfo.pos.GetPositionY(), movementInfo.pos.GetPositionZ(), movementInfo.pos.GetOrientation());
+    GetPlayer()->m_movementInfo = movementInfo;
+    GetPlayer()->SetUnitMovementFlags(movementInfo.flags);
+    // calc time deltas
+    int32 cClientTimeDelta = 0;
+    if (GetPlayer()->m_anti_LastClientTime != 0)
+    {
+        cClientTimeDelta = movementInfo.time - GetPlayer()->m_anti_LastClientTime;
+        GetPlayer()->m_anti_DeltaClientTime += cClientTimeDelta;
+        GetPlayer()->m_anti_LastClientTime = movementInfo.time;
+    }
+    else
+        GetPlayer()->m_anti_LastClientTime = movementInfo.time;
 
+    const uint64 cServerTime = getMSTime();
+    uint32 cServerTimeDelta = 0;
+    if (GetPlayer()->m_anti_LastServerTime != 0)
+    {
+        cServerTimeDelta = cServerTime - GetPlayer()->m_anti_LastServerTime;
+        GetPlayer()->m_anti_DeltaServerTime += cServerTimeDelta;
+        GetPlayer()->m_anti_LastServerTime = cServerTime;
+    }
+    else
+        GetPlayer()->m_anti_LastServerTime = cServerTime;
+    // end movement anticheat
     // far teleport case
     if (curDestNode && curDestNode->map_id != GetPlayer()->GetMapId())
     {
@@ -235,6 +307,23 @@ void WorldSession::HandleMoveSplineDoneOpcode(WorldPacket& recv_data)
         }
         return;
     }
+    // movement anticheat fix - disallow unmount from taxi
+    if (curloc != curDest)
+    {
+         // current source node for next destination
+        uint32 sourcenode = GetPlayer()->m_taxi.GetTaxiSource();
+        uint16 MountId = sObjectMgr->GetTaxiMountDisplayId(sourcenode, GetPlayer()->GetTeam());
+
+        uint32 path, cost;
+        sObjectMgr->GetTaxiPath(sourcenode, curDest, path, cost);
+
+        if (path && MountId)
+            SendDoFlight(MountId, path, 1);                 // skip start fly node
+        else
+            GetPlayer()->m_taxi.ClearTaxiDestinations();    // clear problematic path and next
+        return;
+    }
+    // end movement anticheat
 
     uint32 destinationnode = GetPlayer()->m_taxi.NextTaxiDestination();
     if (destinationnode > 0)                              // if more destinations to go
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 0670e20..c775ef7 100755
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -85,9 +85,9 @@ bool WorldSessionFilter::Process(WorldPacket *packet)
 }
 
 /// WorldSession constructor
-WorldSession::WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter):
+WorldSession::WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, bool ispremium, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter):
 m_muteTime(mute_time), m_timeOutTime(0), _player(NULL), m_Socket(sock),
-_security(sec), _accountId(id), m_expansion(expansion), _logoutTime(0),
+_security(sec), _ispremium(ispremium), _accountId(id), m_expansion(expansion), _logoutTime(0),
 m_inQueue(false), m_playerLoading(false), m_playerLogout(false),
 m_playerRecentlyLogout(false), m_playerSave(false),
 m_sessionDbcLocale(sWorld->GetAvailableDbcLocale(locale)),
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 4823d20..8cb0417 100755
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -180,7 +180,7 @@ class WorldSession
 {
     friend class CharacterHandler;
     public:
-        WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter);
+        WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, bool ispremium, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter);
         ~WorldSession();
 
         bool PlayerLoading() const { return m_playerLoading; }
@@ -208,6 +208,7 @@ class WorldSession
         void SendClientCacheVersion(uint32 version);
 
         AccountTypes GetSecurity() const { return _security; }
+        bool IsPremium() const { return _ispremium; }
         uint32 GetAccountId() const { return _accountId; }
         Player* GetPlayer() const { return _player; }
         char const* GetPlayerName() const;
@@ -892,6 +893,7 @@ class WorldSession
         AccountTypes _security;
         uint32 _accountId;
         uint8 m_expansion;
+        bool _ispremium;
 
         time_t _logoutTime;
         bool m_inQueue;                                     // session wait in auth.queue
diff --git a/src/server/game/Server/WorldSocket.cpp b/src/server/game/Server/WorldSocket.cpp
index 084eade..3e02c59 100755
--- a/src/server/game/Server/WorldSocket.cpp
+++ b/src/server/game/Server/WorldSocket.cpp
@@ -773,6 +773,7 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
     //uint8 expansion = 0;
     LocaleConstant locale;
     std::string account;
+	bool isPremium = false;
     SHA1Hash sha1;
     BigNumber v, s, g, N;
     WorldPacket packet, SendAddonPacked;
@@ -928,6 +929,16 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
         return -1;
     }
 
+    QueryResult premresult =
+        LoginDatabase.PQuery ("SELECT 1 "
+                                "FROM account_premium "
+                                "WHERE id = '%u' "
+                                "AND active = 1",
+                                id);
+    if (premresult) // if account premium
+    {
+        isPremium = true;
+    }
     // Check locked state for server
     AccountTypes allowedAccountType = sWorld->GetPlayerSecurityLimit();
     sLog->outDebug("Allowed Level: %u Player Level %u", allowedAccountType, AccountTypes(security));
@@ -983,7 +994,7 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
                             safe_account.c_str());
 
     // NOTE ATM the socket is single-threaded, have this in mind ...
-    ACE_NEW_RETURN (m_Session, WorldSession (id, this, AccountTypes(security), expansion, mutetime, locale, recruiter), -1);
+    ACE_NEW_RETURN (m_Session, WorldSession (id, this, AccountTypes(security), isPremium, expansion, mutetime, locale, recruiter), -1);
 
     m_Crypt.Init(&K);
 
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index d75aaa6..88159f1 100755
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -4452,7 +4452,33 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
                 case 26465:
                     unitTarget->RemoveAuraFromStack(26464);
                     return;
-                // Shadow Flame (All script effects, not just end ones to prevent player from dodging the last triggered spell)
+				case 62575:
+				{
+					if(m_caster->GetOwner())
+						m_caster->GetOwner()->CastSpell(unitTarget,62626,true );
+						return;
+				}
+				case 62960:
+				{
+					if (!unitTarget)
+						return;
+					m_caster->CastSpell(unitTarget,62563,true );
+					m_caster->CastSpell(unitTarget,68321,true );
+					return;
+				}
+				case 62626:
+				case 68321:
+				{
+					if(!unitTarget)
+						return;
+					if (unitTarget->GetAura(62719))
+						unitTarget->RemoveAuraFromStack(62719);
+
+					if(unitTarget->GetAura(64100))
+						unitTarget->RemoveAuraFromStack(64100);
+					return;
+				}
+					// Shadow Flame (All script effects, not just end ones to prevent player from dodging the last triggered spell)
                 case 22539:
                 case 22972:
                 case 22975:
@@ -4913,9 +4939,15 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
                         return;
 
                     if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+			{
                         m_caster->CastSpell(m_caster, 63914, true);
+			DoCreateItem(0,46069);
+			}
                     else
-                        m_caster->CastSpell(m_caster, 63919, true);
+			{
+                        DoCreateItem(0,46070);
+			m_caster->CastSpell(m_caster, 63919, true);
+			}
                     return;
                 }
                 case 71342:                                     // Big Love Rocket
@@ -5257,6 +5289,7 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
                     break;
                 }
                 case 64142:                                 // Upper Deck - Create Foam Sword
+		{
                     if (unitTarget->GetTypeId() != TYPEID_PLAYER)
                         return;
                     Player *plr = unitTarget->ToPlayer();
@@ -5267,6 +5300,7 @@ void Spell::EffectScriptEffect(SpellEffIndex effIndex)
                             return;
                     DoCreateItem(effIndex, itemId[urand(0,4)]);
                     return;
+		}
             }
             break;
         }
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 0f99fc3..704d884 100755
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -71,6 +71,7 @@
 #include "CreatureTextMgr.h"
 #include "SmartAI.h"
 #include "Channel.h"
+#include "AuctionHouseBot.h"
 
 volatile bool World::m_stopEvent = false;
 uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
@@ -83,7 +84,11 @@ float World::m_MaxVisibleDistanceInBGArenas   = DEFAULT_VISIBILITY_BGARENAS;
 int32 World::m_visibility_notify_periodOnContinents = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
 int32 World::m_visibility_notify_periodInInstances  = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
 int32 World::m_visibility_notify_periodInBGArenas   = DEFAULT_VISIBILITY_NOTIFY_PERIOD;
-
+// movement anticheat
+bool World::m_EnableMvAnticheat = true;
+uint32 World::m_TeleportToPlaneAlarms = 50;
+uint32 World::m_MistimingAlarms = 200;
+uint32 World::m_MistimingDelta = 15000;
 /// World constructor
 World::World()
 {
@@ -453,9 +458,13 @@ void World::LoadConfigSettings(bool reload)
     rate_values[RATE_DROP_ITEM_REFERENCED] = sConfig->GetFloatDefault("Rate.Drop.Item.Referenced", 1.0f);
     rate_values[RATE_DROP_ITEM_REFERENCED_AMOUNT] = sConfig->GetFloatDefault("Rate.Drop.Item.ReferencedAmount", 1.0f);
     rate_values[RATE_DROP_MONEY]  = sConfig->GetFloatDefault("Rate.Drop.Money", 1.0f);
-    rate_values[RATE_XP_KILL]     = sConfig->GetFloatDefault("Rate.XP.Kill", 1.0f);
-    rate_values[RATE_XP_QUEST]    = sConfig->GetFloatDefault("Rate.XP.Quest", 1.0f);
-    rate_values[RATE_XP_EXPLORE]  = sConfig->GetFloatDefault("Rate.XP.Explore", 1.0f);
+    rate_values[RATE_XP_KILL]            = sConfig->GetFloatDefault("Rate.XP.Kill", 1.0f);
+    rate_values[RATE_XP_KILL_PREMIUM]    = sConfig->GetFloatDefault("Rate.XP.Kill.Premium", 1.0f);
+    rate_values[RATE_XP_QUEST]           = sConfig->GetFloatDefault("Rate.XP.Quest", 1.0f);
+    rate_values[RATE_XP_QUEST_PREMIUM]   = sConfig->GetFloatDefault("Rate.XP.Quest.Premium", 1.0f);
+    rate_values[RATE_XP_EXPLORE]         = sConfig->GetFloatDefault("Rate.XP.Explore", 1.0f);
+    rate_values[RATE_XP_EXPLORE_PREMIUM] = sConfig->GetFloatDefault("Rate.XP.Explore.Premium", 1.0f);
+
     rate_values[RATE_REPAIRCOST]  = sConfig->GetFloatDefault("Rate.RepairCost", 1.0f);
     if (rate_values[RATE_REPAIRCOST] < 0.0f)
     {
@@ -558,6 +567,41 @@ void World::LoadConfigSettings(bool reload)
         sLog->outError("DurabilityLossChance.Block (%f) must be >=0. Using 0.0 instead.",rate_values[RATE_DURABILITY_LOSS_BLOCK]);
         rate_values[RATE_DURABILITY_LOSS_BLOCK] = 0.0f;
     }
+    // movement anticheat
+    m_EnableMvAnticheat = sConfig->GetBoolDefault("Anticheat.Movement.Enable", true);
+    m_TeleportToPlaneAlarms = sConfig->GetIntDefault("Anticheat.Movement.TeleportToPlaneAlarms", 50);
+    if (m_TeleportToPlaneAlarms < 20)
+    {
+        sLog->outError("Anticheat.Movement.TeleportToPlaneAlarms (%d) must be >= 20. Using 20 instead.", m_TeleportToPlaneAlarms);
+        m_TeleportToPlaneAlarms = 20;
+    }
+    if (m_TeleportToPlaneAlarms > 100)
+    {
+        sLog->outError("Anticheat.Movement.TeleportToPlaneAlarms (%d) must be <= 100. Using 100 instead.", m_TeleportToPlaneAlarms);
+        m_TeleportToPlaneAlarms = 100;
+    }
+    m_MistimingDelta = sConfig->GetIntDefault("Anticheat.Movement.MistimingDelta", 15000);
+    if (m_MistimingDelta < 5000)
+    {
+        sLog->outError("Anticheat.Movement.m_MistimingDelta (%d) must be >= 5000ms. Using 5000ms instead.", m_MistimingDelta);
+        m_MistimingDelta = 5000;
+    }
+    if (m_MistimingDelta > 50000)
+    {
+        sLog->outError("Anticheat.Movement.m_MistimingDelta (%d) must be <= 50000ms. Using 50000ms instead.", m_MistimingDelta);
+        m_MistimingDelta = 50000;
+    }
+    m_MistimingAlarms = sConfig->GetIntDefault("Anticheat.Movement.MistimingAlarms", 200);
+    if (m_MistimingAlarms < 100)
+    {
+        sLog->outError("Anticheat.Movement.MistimingAlarms (%d) must be >= 100. Using 100 instead.", m_MistimingAlarms);
+        m_MistimingAlarms = 100;
+    }
+    if (m_MistimingAlarms > 500)
+    {
+        sLog->outError("Anticheat.Movement.m_MistimingAlarms (%d) must be <= 500. Using 500 instead.", m_MistimingAlarms);
+        m_MistimingAlarms = 500;
+    }
     ///- Read other configuration items from the config file
 
     m_bool_configs[CONFIG_DURABILITY_LOSS_IN_PVP] = sConfig->GetBoolDefault("DurabilityLoss.InPvP", false);
@@ -729,12 +773,6 @@ void World::LoadConfigSettings(bool reload)
     else
         m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = sConfig->GetIntDefault("MaxPlayerLevel", DEFAULT_MAX_LEVEL);
 
-    if (m_int_configs[CONFIG_MAX_PLAYER_LEVEL] > MAX_LEVEL)
-    {
-        sLog->outError("MaxPlayerLevel (%i) must be in range 1..%u. Set to %u.",m_int_configs[CONFIG_MAX_PLAYER_LEVEL],MAX_LEVEL,MAX_LEVEL);
-        m_int_configs[CONFIG_MAX_PLAYER_LEVEL] = MAX_LEVEL;
-    }
-
     m_int_configs[CONFIG_MIN_DUALSPEC_LEVEL] = sConfig->GetIntDefault("MinDualSpecLevel", 40);
 
     m_int_configs[CONFIG_START_PLAYER_LEVEL] = sConfig->GetIntDefault("StartPlayerLevel", 1);
@@ -1571,6 +1609,9 @@ void World::SetInitialWorldSettings()
     ///- Handle outdated emails (delete/return)
     sLog->outString("Returning old mails...");
     sObjectMgr->ReturnOrDeleteOldMails(false);
+	// Loads the jail conf out of the database
+    sLog->outString("Loading JailConfing...");
+    sObjectMgr->LoadJailConf();
 
     sLog->outString("Loading Autobroadcasts...");
     LoadAutobroadcasts();
@@ -1706,6 +1747,9 @@ void World::SetInitialWorldSettings()
     sLog->outString("Calculate random battleground reset time..." );
     InitRandomBGResetTime();
 
+    sLog->outString("Initialize AuctionHouseBot...");
+    auctionbot.Initialize();
+
     // possibly enable db logging; avoid massive startup spam by doing it here.
     if (sLog->GetLogDBLater())
     {
@@ -1872,6 +1916,7 @@ void World::Update(uint32 diff)
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
+        auctionbot.Update();
         m_timers[WUPDATE_AUCTIONS].Reset();
 
         ///- Update mails (return old mails with item, or delete them)
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 87c37b0..0eee5ae 100755
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -335,8 +335,11 @@ enum Rates
     RATE_DROP_ITEM_REFERENCED_AMOUNT,
     RATE_DROP_MONEY,
     RATE_XP_KILL,
+    RATE_XP_KILL_PREMIUM,
     RATE_XP_QUEST,
+    RATE_XP_QUEST_PREMIUM,
     RATE_XP_EXPLORE,
+    RATE_XP_EXPLORE_PREMIUM,
     RATE_REPAIRCOST,
     RATE_REPUTATION_GAIN,
     RATE_REPUTATION_LOWLEVEL_KILL,
@@ -711,6 +714,12 @@ class World
         static int32 GetVisibilityNotifyPeriodOnContinents(){ return m_visibility_notify_periodOnContinents; }
         static int32 GetVisibilityNotifyPeriodInInstances() { return m_visibility_notify_periodInInstances;  }
         static int32 GetVisibilityNotifyPeriodInBGArenas()  { return m_visibility_notify_periodInBGArenas;   }
+        // movement anticheat
+        static bool GetEnableMvAnticheat()       { return m_EnableMvAnticheat;     }
+        static uint32 GetTeleportToPlaneAlarms() { return m_TeleportToPlaneAlarms; }
+        static uint32 GetMistimingDelta()        { return m_MistimingDelta;        }
+        static uint32 GetMistimingAlarms()       { return m_MistimingAlarms;       }
+        // end movement anticheat
 
         void ProcessCliCommands();
         void QueueCliCommand(CliCommandHolder* commandHolder) { cliCmdQueue.add(commandHolder); }
@@ -807,7 +816,11 @@ class World
         static int32 m_visibility_notify_periodOnContinents;
         static int32 m_visibility_notify_periodInInstances;
         static int32 m_visibility_notify_periodInBGArenas;
-
+        // movement anticheat enable flag
+        static bool m_EnableMvAnticheat;
+        static uint32 m_TeleportToPlaneAlarms;
+        static uint32 m_MistimingDelta;
+        static uint32 m_MistimingAlarms;
         // CLI command holder to be thread safe
         ACE_Based::LockedQueue<CliCommandHolder*,ACE_Thread_Mutex> cliCmdQueue;
 
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index 17d4bfc..90eae34 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -31,6 +31,9 @@ include(Examples/CMakeLists.txt)
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.h
   ../game/AI/ScriptedAI/ScriptedEscortAI.cpp
   ../game/AI/ScriptedAI/ScriptedCreature.cpp
   ../game/AI/ScriptedAI/ScriptedFollowerAI.cpp
diff --git a/src/server/scripts/Commands/cs_gm.cpp b/src/server/scripts/Commands/cs_gm.cpp
index 1ed451e..c349e95 100644
--- a/src/server/scripts/Commands/cs_gm.cpp
+++ b/src/server/scripts/Commands/cs_gm.cpp
@@ -120,7 +120,7 @@ public:
         for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
         {
             AccountTypes itr_sec = itr->second->GetSession()->GetSecurity();
-            if ((itr->second->isGameMaster() || (itr_sec > SEC_PLAYER && itr_sec <= AccountTypes(sWorld->getIntConfig(CONFIG_GM_LEVEL_IN_GM_LIST)))) &&
+            if ((itr->second->isGameMaster() || (itr_sec > SEC_MODERATOR && itr_sec <= AccountTypes(sWorld->getIntConfig(CONFIG_GM_LEVEL_IN_GM_LIST)))) &&
                 (!handler->GetSession() || itr->second->IsVisibleGloballyFor(handler->GetSession()->GetPlayer())))
             {
                 if (first)
@@ -153,7 +153,7 @@ public:
     static bool HandleGMListFullCommand(ChatHandler* handler, const char* /*args*/)
     {
         ///- Get the accounts with GM Level >0
-        QueryResult result = LoginDatabase.Query("SELECT a.username,aa.gmlevel FROM account a, account_access aa WHERE a.id=aa.id AND aa.gmlevel > 0");
+        QueryResult result = LoginDatabase.Query("SELECT a.username,aa.gmlevel FROM account a, account_access aa WHERE a.id=aa.id AND aa.gmlevel > 1");
         if (result)
         {
             handler->SendSysMessage(LANG_GMLIST);
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 0dec843..16268ec 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -1,5 +1,7 @@
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/resetduel.cpp
+  Custom/guildmaster.cpp
 )
 
 message("  -> Prepared: Custom")
diff --git a/src/server/scripts/Custom/guildmaster.cpp b/src/server/scripts/Custom/guildmaster.cpp
new file mode 100644
index 0000000..4404254
--- /dev/null
+++ b/src/server/scripts/Custom/guildmaster.cpp
@@ -0,0 +1,339 @@
+#include "ScriptPCH.h"
+
+//extern DatabaseMysql SD2Database;
+
+extern WorldDatabaseWorkerPool WorldDatabase;
+
+#define MSG_GOSSIP_TELE          "Teleport to GuildHouse"
+#define MSG_GOSSIP_BUY           "Buy GuildHouse (1000 gold)"
+#define MSG_GOSSIP_SELL          "Sell GuildHouse (500 gold)"
+#define MSG_GOSSIP_NEXTPAGE      "Next -->"
+#define MSG_INCOMBAT             "You are in combat and cannot be teleported to your GuildHouse."
+#define MSG_NOGUILDHOUSE         "Your guild currently does not own a GuildHouse."
+#define MSG_NOFREEGH             "Unfortunately, all GuildHouses are in use."
+#define MSG_ALREADYHAVEGH        "Sorry, but you already own a GuildHouse (%s)."
+#define MSG_NOTENOUGHMONEY       "You do not have the %u gold required to purchase a GuildHouse."
+#define MSG_GHOCCUPIED           "This GuildHouse is unavailable for purchase as it is currently in use."
+#define MSG_CONGRATULATIONS      "Congratulations! You have successfully purchased a GuildHouse."
+#define MSG_SOLD                 "You have sold your GuildHouse and have received %u gold."
+#define MSG_NOTINGUILD           "You need to be in a guild before you can use a GuildHouse."
+
+#define CODE_SELL "SELL"
+#define MSG_CODEBOX_SELL "Type \"" CODE_SELL "\" into the field to confirm that you want to sell your GuildHouse."
+
+#define OFFSET_GH_ID_TO_ACTION 1500
+#define OFFSET_SHOWBUY_FROM 10000
+
+#define ACTION_TELE 1001
+#define ACTION_SHOW_BUYLIST 1002 //deprecated. Use (OFFSET_SHOWBUY_FROM + 0) instead
+#define ACTION_SELL_GUILDHOUSE 1003
+
+#define ICON_GOSSIP_BALOON 0
+#define ICON_GOSSIP_WING 2
+#define ICON_GOSSIP_BOOK 3
+#define ICON_GOSSIP_WHEEL1 4
+#define ICON_GOSSIP_WHEEL2 5
+#define ICON_GOSSIP_GOLD 6
+#define ICON_GOSSIP_BALOONDOTS 7
+#define ICON_GOSSIP_TABARD 8
+#define ICON_GOSSIP_XSWORDS 9
+
+#define COST_GH_BUY 10000000 //1000 g.
+#define COST_GH_SELL 5000000 //500 g.
+
+#define GOSSIP_COUNT_MAX 10
+
+bool isPlayerGuildLeader(Player *player)
+{
+ return (player->GetRank() == 0) && (player->GetGuildId() != 0);
+}
+
+bool getGuildHouseCoords(uint32 guildId, float &x, float &y, float &z, uint32 &map)
+{
+ if (guildId == 0)
+ {
+ //if player has no guild
+ return false;
+ }
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `x`, `y`, `z`, `map` FROM `guildhouses` WHERE `guildId` = %u", guildId);
+ if (result)
+ {
+ Field *fields = result->Fetch();
+ x = fields[0].GetFloat();
+ y = fields[1].GetFloat();
+ z = fields[2].GetFloat();
+ map = fields[3].GetUInt32();
+ return true;
+ }
+
+ return false;
+}
+
+void teleportPlayerToGuildHouse(Player *player, Creature *_creature)
+{
+ if (player->GetGuildId() == 0)
+ {
+ //if player has no guild
+ _creature->MonsterWhisper(MSG_NOTINGUILD, player->GetGUID());
+ return;
+ }
+
+ if (!player->getAttackers().empty())
+ {
+ //if player in combat
+ _creature->MonsterSay(MSG_INCOMBAT, LANG_UNIVERSAL, player->GetGUID());
+ return;
+ }
+
+ float x, y, z;
+ uint32 map;
+
+ if (getGuildHouseCoords(player->GetGuildId(), x, y, z, map))
+ {
+ //teleport player to the specified location
+ player->TeleportTo(map, x, y, z, 0.0f);
+ }
+ else
+ _creature->MonsterWhisper(MSG_NOGUILDHOUSE, player->GetGUID());
+}
+
+bool showBuyList(Player *player, Creature *_creature, uint32 showFromId = 0)
+{
+ //show not occupied guildhouses
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `id`, `comment` FROM `guildhouses` WHERE `guildId` = 0 AND `id` > %u ORDER BY `id` ASC LIMIT %u",
+ showFromId, GOSSIP_COUNT_MAX);
+
+ if (result)
+ {
+ uint32 guildhouseId = 0;
+ std::string comment = "";
+ do
+ {
+ Field *fields = result->Fetch();
+ guildhouseId = fields[0].GetInt32();
+ comment = fields[1].GetString();
+
+ //send comment as a gossip item
+ //transmit guildhouseId in Action variable
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_TABARD, comment, GOSSIP_SENDER_MAIN,
+ guildhouseId + OFFSET_GH_ID_TO_ACTION);
+ }
+ while (result->NextRow());
+
+ if (result->GetRowCount() == GOSSIP_COUNT_MAX)
+ {
+ //assume that we have additional page
+ //add link to next GOSSIP_COUNT_MAX items
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOONDOTS, MSG_GOSSIP_NEXTPAGE, GOSSIP_SENDER_MAIN,
+ guildhouseId + OFFSET_SHOWBUY_FROM);
+ }
+
+ player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //all guildhouses are occupied
+ _creature->MonsterWhisper(MSG_NOFREEGH, player->GetGUID());
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+ //this condition occurs when COUNT(guildhouses) % GOSSIP_COUNT_MAX == 0
+ //just show GHs from beginning
+ showBuyList(player, _creature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool isPlayerHasGuildhouse(Player *player, Creature *_creature, bool whisper = false)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `comment` FROM `guildhouses` WHERE `guildId` = %u",
+ player->GetGuildId());
+
+ if (result)
+ {
+ if (whisper)
+ {
+ //whisper to player "already have etc..."
+ Field *fields = result->Fetch();
+ char msg[100];
+ sprintf(msg, MSG_ALREADYHAVEGH, fields[0].GetString());
+ _creature->MonsterWhisper(msg, player->GetGUID());
+ }
+
+ return true;
+ }
+
+ return false;
+}
+
+void buyGuildhouse(Player *player, Creature *_creature, uint32 guildhouseId)
+{
+ if (player->GetMoney() < COST_GH_BUY)
+ {
+ //show how much money player need to buy GH (in gold)
+ char msg[100];
+ sprintf(msg, MSG_NOTENOUGHMONEY, COST_GH_BUY / 10000);
+ _creature->MonsterWhisper(msg, player->GetGUID());
+ return;
+ }
+
+ if (isPlayerHasGuildhouse(player, _creature, true))
+ {
+ //player already have GH
+ return;
+ }
+
+ QueryResult result;
+
+ //check if somebody already occupied this GH
+ result = WorldDatabase.PQuery("SELECT `id` FROM `guildhouses` WHERE `id` = %u AND `guildId` <> 0", guildhouseId);
+
+ if (result)
+ {
+ _creature->MonsterWhisper(MSG_GHOCCUPIED, player->GetGUID());
+ return;
+ }
+
+ //update DB
+ result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = %u WHERE `id` = %u",
+ player->GetGuildId(), guildhouseId);
+
+ if (result)
+ player->ModifyMoney(-COST_GH_BUY);
+ _creature->MonsterSay(MSG_CONGRATULATIONS, LANG_UNIVERSAL, player->GetGUID());
+}
+
+void sellGuildhouse(Player *player, Creature *_creature)
+{
+ if (isPlayerHasGuildhouse(player, _creature))
+ {
+ QueryResult result;
+ result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = 0 WHERE `guildId` = %u",
+ player->GetGuildId());
+
+ if (result)
+ player->ModifyMoney(COST_GH_SELL);
+
+ //display message e.g. "here your money etc."
+ char msg[100];
+ sprintf(msg, MSG_SOLD, COST_GH_SELL / 10000);
+ _creature->MonsterWhisper(msg, player->GetGUID());
+ }
+}
+
+class guildmaster : public CreatureScript
+{
+ public:
+ guildmaster() : CreatureScript("guildmaster") { }
+
+ bool GossipSelectWithCode(Player *player, Creature *_creature, uint32 sender, uint32 action, const char* sCode)
+ {
+ if (sender == GOSSIP_SENDER_MAIN)
+ {
+ if (action == ACTION_SELL_GUILDHOUSE)
+ {
+ int i = -1;
+ try
+ {
+ //compare code
+
+ if (strlen(sCode) + 1 == sizeof CODE_SELL)
+ i = strcmp(CODE_SELL, sCode);
+ }
+
+ catch(char *str) {sLog->outErrorDb(str);
+ }
+
+ if (i == 0)
+ {
+ //right code
+ sellGuildhouse(player, _creature);
+ }
+
+ player->CLOSE_GOSSIP_MENU();
+ return true;
+ }
+ }
+ return false;
+}
+
+ bool OnGossipSelect(Player *player, Creature *_creature, uint32 sender, uint32 action)
+ {
+ player->PlayerTalkClass->ClearMenus();
+ if (sender != GOSSIP_SENDER_MAIN)
+ return false;
+
+ switch (action)
+ {
+ case ACTION_TELE:
+ //teleport player to GH
+ player->CLOSE_GOSSIP_MENU();
+ teleportPlayerToGuildHouse(player, _creature);
+ break;
+ case ACTION_SHOW_BUYLIST:
+ //show list of GHs which currently not occupied
+ showBuyList(player, _creature);
+ break;
+ default:
+ if (action > OFFSET_SHOWBUY_FROM)
+ {
+ showBuyList(player, _creature, action - OFFSET_SHOWBUY_FROM);
+ }
+ else if (action > OFFSET_GH_ID_TO_ACTION)
+ {
+ //player clicked on buy list
+ player->CLOSE_GOSSIP_MENU();
+
+ //get guildhouseId from action
+ //guildhouseId = action - OFFSET_GH_ID_TO_ACTION
+ buyGuildhouse(player, _creature, action - OFFSET_GH_ID_TO_ACTION);
+ }
+ break;
+ }
+
+ return true;
+ }
+
+
+ bool OnGossipHello(Player *player, Creature *_creature)
+ {
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOON, MSG_GOSSIP_TELE,
+ GOSSIP_SENDER_MAIN, ACTION_TELE);
+
+ if (isPlayerGuildLeader(player))
+ {
+ if (isPlayerHasGuildhouse(player, _creature))
+ {
+ //and additional for guildhouse owner (Removed : 
+ player->PlayerTalkClass->GetGossipMenu().AddMenuItem(ICON_GOSSIP_GOLD, MSG_GOSSIP_SELL, GOSSIP_SENDER_MAIN, ACTION_SELL_GUILDHOUSE, MSG_CODEBOX_SELL, 0, true);
+ }
+ else
+ {
+ //show additional menu for guild leader
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_GOLD, MSG_GOSSIP_BUY,
+ GOSSIP_SENDER_MAIN, ACTION_SHOW_BUYLIST);
+ }
+ }
+
+ player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+ return true;
+ }
+
+
+};
+void AddSC_guildmaster()
+{
+ new guildmaster();
+}
diff --git a/src/server/scripts/Custom/npc_teleport.cpp b/src/server/scripts/Custom/npc_teleport.cpp
new file mode 100644
index 0000000..537d7b1
--- /dev/null
+++ b/src/server/scripts/Custom/npc_teleport.cpp
@@ -0,0 +1,222 @@
+/**
+ *
+ * @File : npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+#include <sstream>
+
+#define GOSSIP_SHOW_DEST        1000
+#define GOSSIP_TELEPORT         1001
+#define GOSSIP_NEXT_PAGEC       1002
+#define GOSSIP_PREV_PAGEC       1003
+#define GOSSIP_NEXT_PAGED       1004
+#define GOSSIP_PREV_PAGED       1005
+#define GOSSIP_MAIN_MENU        1006
+
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+#define SPELL_VISUAL_TELEPORT   35517
+
+#define NB_ITEM_PAGE            10
+#define MSG_CAT                 100000
+#define MSG_DEST                100001
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+
+using namespace nsNpcTel;
+
+
+namespace
+{
+    Page PageC, PageD;
+    Page Cat;
+
+    // Conversion function int->string
+    std::string ConvertStr(const int64 &val)
+    {
+        std::ostringstream ostr;
+        ostr << val;
+        return ostr.str();
+    }
+
+    // Conversion function intMoney->stringMoney
+    std::string ConvertMoney(const uint32 &Money)
+    {
+        std::string Str(ConvertStr(Money));
+        uint32 SizeStr = Str.length();
+
+        if (SizeStr > 4)
+            Str = Str.insert(Str.length()-4, "po");
+        if (SizeStr > 2)
+            Str = Str.insert(Str.length()-2, "pa");
+        Str += "pc";
+
+        return Str;
+    }
+
+    // Teleport Player
+    void Teleport(Player * const player, const uint16 &map,
+                  const float &X, const float &Y, const float &Z, const float &orient)
+    {
+        player->CastSpell(player, SPELL_VISUAL_TELEPORT, true);
+        player->TeleportTo(map, X, Y, Z, orient);
+    }
+
+    // Display categories
+    void AffichCat(Player * const player, Creature * const creature)
+    {
+        if (PageC[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGEC, 0);
+
+        VCatDest_t i (PageC[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest.size() && i < (NB_ITEM_PAGE * (PageC[player] + 1)); ++i)
+        {
+            if (TabCatDest[i].IsAllowedToTeleport(player))
+                player->ADD_GOSSIP_ITEM(7, TabCatDest[i].GetName(player->isGameMaster()).c_str(), GOSSIP_SHOW_DEST, i);
+        }
+
+        if (i < TabCatDest.size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGEC, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_CAT, creature->GetGUID());
+    }
+
+    // Display destination categories
+    void AffichDest(Player * const player, Creature * const creature)
+    {
+        if (PageD[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGED, 0);
+
+        CatDest::VDest_t i (PageD[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest[Cat[player]].size() && i < (NB_ITEM_PAGE * (PageD[player] + 1)); ++i)
+        {
+            player->ADD_GOSSIP_ITEM(5, TabCatDest[Cat[player]].GetDest(i).m_name.c_str(), GOSSIP_TELEPORT, i);
+        }
+
+        if (i < TabCatDest[Cat[player]].size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGED, 0);
+
+        if (CatDest::CountOfCategoryAllowedBy(player) > 1)
+            player->ADD_GOSSIP_ITEM(7, MAIN_MENU, GOSSIP_MAIN_MENU, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_DEST, creature->GetGUID());
+    }
+
+    // Verification before teleportation
+    void ActionTeleport(Player * const player, Creature * const creature, const uint32 &id)
+    {
+        Dest dest (TabCatDest[Cat[player]].GetDest(id));
+
+        if (player->getLevel() < dest.m_level && !player->isGameMaster())
+        {
+            std::string msg ("You do not have the required level. This destination requires level " + ConvertStr(dest.m_level) + ".");
+            creature->MonsterWhisper(msg.c_str(), player->GetGUID());
+            return;
+        }
+
+        if (player->GetMoney() < dest.m_cost && !player->isGameMaster())
+        {
+            std::string msg ("You do not have enough money. The price for teleportation is " + ConvertMoney(dest.m_cost) + ".");
+            creature->MonsterWhisper(msg.c_str(), player->GetGUID());
+            return;
+        }
+
+        if (!player->isGameMaster() && dest.m_cost)
+            player->ModifyMoney(-1 * dest.m_cost);
+
+        Teleport(player, dest.m_map, dest.m_X, dest.m_Y, dest.m_Z, dest.m_orient);
+    }
+}
+
+class npc_teleport : public CreatureScript
+{
+public:
+    npc_teleport() : CreatureScript("npc_teleport") {}
+
+bool OnGossipHello(Player *player, Creature *creature)
+{
+    PageC(player) = PageD(player) = Cat(player) = 0;
+
+    if(player->isInCombat())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->MonsterWhisper("You are in combat. Come back later", player->GetGUID());
+        return true;
+    }
+    AffichCat(player, creature);
+    return true;
+}
+
+bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 param)
+{
+    player->PlayerTalkClass->ClearMenus();
+    switch(sender)
+    {
+      // Display destinations
+      case GOSSIP_SHOW_DEST:
+        Cat(player) = param;
+        AffichDest(player, creature);
+        break;
+
+      // Previous categories page
+      case GOSSIP_PREV_PAGEC:
+        --PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Next page categories
+      case GOSSIP_NEXT_PAGEC:
+        ++PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Previous destinations page
+      case GOSSIP_PREV_PAGED:
+        --PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Next destination page
+      case GOSSIP_NEXT_PAGED:
+        ++PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Display main menu
+      case GOSSIP_MAIN_MENU:
+        OnGossipHello(player, creature);
+        break;
+
+      // Teleportation
+      case GOSSIP_TELEPORT:
+        player->CLOSE_GOSSIP_MENU();
+        if(player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0)) {
+            creature->CastSpell(player,38588,false); // Healing effect
+            player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+
+        ActionTeleport(player, creature, param);
+        break;
+    }
+    return true;
+}
+};
+
+void AddSC_npc_teleport()
+{
+    new npc_teleport;
+}
+
diff --git a/src/server/scripts/Custom/resetduel.cpp b/src/server/scripts/Custom/resetduel.cpp
new file mode 100644
index 0000000..25c8ea3
--- /dev/null
+++ b/src/server/scripts/Custom/resetduel.cpp
@@ -0,0 +1,26 @@
+#include "ScriptPCH.h"
+
+class Reset_OnDuelEnd : public PlayerScript
+{
+    public:
+        Reset_OnDuelEnd() : PlayerScript("Reset_OnDuelEnd") {}
+
+    void OnDuelEnd(Player *winner, Player *looser, DuelCompleteType type)
+    {
+        // reset cooldowns in zone 0, 41 and 616
+                if (winner->GetZoneId() == 0 || winner->GetZoneId() == 41 || winner->GetZoneId() == 616)
+                {
+                        winner->RemoveArenaSpellCooldowns();
+                        looser->RemoveArenaSpellCooldowns();
+                        winner->SetHealth(winner->GetMaxHealth());
+                        winner->SetPower(POWER_MANA, winner->GetMaxPower(POWER_MANA));
+                        looser->SetHealth(looser->GetMaxHealth());
+                        looser->SetPower(POWER_MANA, looser->GetMaxPower(POWER_MANA));
+                }
+    }
+};
+
+void AddSC_Reset()
+{
+    new Reset_OnDuelEnd;
+}
diff --git a/src/server/scripts/EasternKingdoms/silvermoon_city.cpp b/src/server/scripts/EasternKingdoms/silvermoon_city.cpp
index afb8bb1..17aa306 100644
--- a/src/server/scripts/EasternKingdoms/silvermoon_city.cpp
+++ b/src/server/scripts/EasternKingdoms/silvermoon_city.cpp
@@ -28,7 +28,7 @@ npc_blood_knight_stillblade
 EndContentData */
 
 #include "ScriptPCH.h"
-
+#define NPC_BLOOD_KNIGHT_STILLBLADE    17768
 /*#######
 # npc_blood_knight_stillblade
 #######*/
@@ -90,7 +90,7 @@ public:
             if ((Spellkind->Id == SPELL_SHIMMERING_VESSEL) && !spellHit &&
                 (Hitter->GetTypeId() == TYPEID_PLAYER) && (CAST_PLR(Hitter)->IsActiveQuest(QUEST_REDEEMING_THE_DEAD)))
             {
-                CAST_PLR(Hitter)->AreaExploredOrEventHappens(QUEST_REDEEMING_THE_DEAD);
+                CAST_PLR(Hitter)->KilledMonsterCredit(NPC_BLOOD_KNIGHT_STILLBLADE, 0);
                 DoCast(me, SPELL_REVIVE_SELF);
                 me->SetStandState(UNIT_STAND_STATE_STAND);
                 me->SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
index f1c80b1..67b247c 100644
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -172,6 +172,13 @@ set(scripts_STAT_SRCS
   Northrend/DraktharonKeep/drak_tharon_keep.h
   Northrend/DraktharonKeep/boss_tharon_ja.cpp
   Northrend/DraktharonKeep/boss_dred.cpp
+  Northrend/RubySanctum/boss_baltharus.cpp
+  Northrend/RubySanctum/boss_halion.cpp
+  Northrend/RubySanctum/boss_ragefire.cpp
+  Northrend/RubySanctum/boss_zarithrian.cpp
+  Northrend/RubySanctum/instance_ruby_sanctum.cpp
+  Northrend/RubySanctum/ruby_sanctum.h
+
 )
 
 message("  -> Prepared: Northrend")
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp b/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
new file mode 100644
index 0000000..96c9605
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_baltharus.cpp
@@ -0,0 +1,340 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eScriptTexts
+{
+    SAY_AGGRO           = -1752001,
+    SAY_SLAY1           = -1752002,
+	SAY_SLAY2           = -1752003,
+    SAY_DEATH           = -1752004,
+    SAY_SUMMON_CLONE    = -1752005,
+
+    SAY_XERESTRASZA_1  = -1752008,
+	SAY_XERESTRASZA_2  = -1752009,
+	SAY_XERESTRASZA_3  = -1752010,
+	SAY_XERESTRASZA_4  = -1752011,
+	SAY_XERESTRASZA_5  = -1752012,
+	SAY_XERESTRASZA_6  = -1752013,
+	SAY_XERESTRASZA_7  = -1752014,
+	SAY_XERESTRASZA_8  = -1752015,
+	SAY_XERESTRASZA_9  = -1752016
+};
+
+enum eSpells
+{
+    SPELL_CLEAVE            = 40504,
+    SPELL_REPELLING_WAVE    = 74509,
+    SPELL_ENERVATING_BRAND  = 74502,
+    SPELL_BLADE_TEMPEST     = 75125,
+    SPELL_SUMMON_CLONE      = 74511
+};
+
+enum eEvents
+{
+    EVENT_CAST_CLEAVE           = 1,
+    EVENT_CAST_REPELLING_WAVE   = 2,
+    EVENT_CAST_ENERVATING_BRAND = 3,
+    EVENT_CAST_BLADE_TEMPEST    = 4,
+    EVENT_CAST_SUMMON_CLONE     = 5,
+
+    ACTION_START_EVENT          = 6,
+    EVENT_XERESTRASZA_3         = 7,
+    EVENT_XERESTRASZA_4         = 8,
+    EVENT_XERESTRASZA_5         = 9,
+    EVENT_XERESTRASZA_6         = 10,
+    EVENT_XERESTRASZA_7         = 11,
+    EVENT_XERESTRASZA_8         = 12,
+    EVENT_XERESTRASZA_9         = 13
+};
+
+Creature* pXerestrasza;
+
+class boss_baltharus : public CreatureScript
+{
+    public:
+        boss_baltharus() : CreatureScript("boss_baltharus") { }
+
+        struct boss_baltharusAI : public BossAI
+        {
+            boss_baltharusAI(Creature* pCreature) : BossAI(pCreature, DATA_BALTHARUS)
+			{
+				ASSERT(instance);
+			}
+
+				void Reset()
+			{
+				instance->SetBossState(DATA_BALTHARUS, NOT_STARTED);
+				bClone = false;
+				events.Reset();
+				events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+				events.ScheduleEvent(EVENT_CAST_REPELLING_WAVE, urand(20000,30000));
+				events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+				events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(7000,7500));
+			}
+
+				void EnterCombat(Unit*)
+			{
+				instance->SetBossState(DATA_BALTHARUS, IN_PROGRESS);
+				DoScriptText(SAY_AGGRO, me);
+			}
+
+				void UpdateAI(const uint32 diff)
+			{
+				if (!UpdateVictim() || !CheckInRoom())
+					return;
+
+				if (me->HasUnitState(UNIT_STAT_CASTING))
+					return;
+
+				events.Update(diff);
+
+				while (uint32 eventId = events.ExecuteEvent())
+					{
+					switch (eventId)
+					{
+						case EVENT_CAST_CLEAVE:
+							DoCastVictim(SPELL_CLEAVE);
+							events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+							break;
+						case EVENT_CAST_REPELLING_WAVE:
+							DoCast(SPELL_REPELLING_WAVE);
+							events.ScheduleEvent(EVENT_CAST_REPELLING_WAVE, urand(20000,30000));
+							break;
+						case EVENT_CAST_ENERVATING_BRAND:
+							DoCastVictim(SPELL_ENERVATING_BRAND);
+							events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+							break;
+						case EVENT_CAST_BLADE_TEMPEST:
+							DoCast(SPELL_BLADE_TEMPEST);
+							events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(30000,45000));
+							break;
+					}
+				}
+
+				if(!bClone)
+				{
+						if(me->GetHealth() <= ((me->GetMaxHealth() / 100) * 50))
+					{
+						bClone = true;
+						DoCast(SPELL_SUMMON_CLONE);
+						DoScriptText(SAY_SUMMON_CLONE, me);
+					}
+				}
+
+				DoMeleeAttackIfReady();
+			}
+
+				void JustSummoned(Creature *summon)
+			{
+				summons.Summon(summon);
+			}
+
+				void KilledUnit(Unit *victim)
+			{
+				DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+			}
+
+				void JustReachedHome()
+			{
+				summons.DespawnAll();
+				instance->SetData(DATA_BALTHARUS, FAIL);
+			}
+
+				void JustDied(Unit*)
+			{
+				DoScriptText(SAY_DEATH, me);
+				pXerestrasza->AI()->DoAction(ACTION_START_EVENT);
+				_JustDied();
+			}
+
+			private:
+			bool bClone;
+		};
+
+			CreatureAI* GetAI(Creature *pCreature) const
+		{
+			return new boss_baltharusAI(pCreature);
+		}
+
+};
+
+class boss_baltharus_summon : public CreatureScript
+{
+    public:
+        boss_baltharus_summon() : CreatureScript("boss_baltharus_summon") { }
+
+        struct boss_baltharus_summonAI : public ScriptedAI
+        {
+            boss_baltharus_summonAI(Creature* pCreature) : ScriptedAI(pCreature)
+			{
+				pInstance = me->GetInstanceScript();
+			}
+
+				void Reset()
+			{
+				events.Reset();
+				events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+				events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+				events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(7000,7500));
+			}
+
+				void UpdateAI(const uint32 diff)
+			{
+				if (!UpdateVictim())
+					return;
+
+				if (me->HasUnitState(UNIT_STAT_CASTING))
+					return;
+
+				events.Update(diff);
+
+				while (uint32 eventId = events.ExecuteEvent())
+				{
+					switch (eventId)
+					{
+						case EVENT_CAST_CLEAVE:
+							DoCastVictim(SPELL_CLEAVE);
+							events.ScheduleEvent(EVENT_CAST_CLEAVE, urand(2000,3000));
+							break;
+						case EVENT_CAST_ENERVATING_BRAND:
+							DoCastVictim(SPELL_ENERVATING_BRAND);
+							events.ScheduleEvent(EVENT_CAST_ENERVATING_BRAND, urand(30000,45000));
+							break;
+						case EVENT_CAST_BLADE_TEMPEST:
+							DoCast(SPELL_BLADE_TEMPEST);
+							events.ScheduleEvent(EVENT_CAST_BLADE_TEMPEST, urand(30000,45000));
+							break;
+					}
+				}
+
+				DoMeleeAttackIfReady();
+			}
+
+		private:
+			EventMap events;
+			InstanceScript* pInstance;
+
+		};
+
+			CreatureAI* GetAI(Creature *pCreature) const
+		{
+			return new boss_baltharus_summonAI(pCreature);
+		}
+
+};
+
+class npc_xerestrasza : public CreatureScript
+{
+    public:
+        npc_xerestrasza() : CreatureScript("npc_xerestrasza") { }
+
+        struct npc_xerestraszaAI : public ScriptedAI
+        {
+			npc_xerestraszaAI(Creature *pCreature) : ScriptedAI(pCreature)
+			{
+				pInstance = me->GetInstanceScript();
+				pXerestrasza = me;
+			}
+
+			void Reset()
+			{
+				events.Reset();
+				bIntro = false;
+				pInstance->SetData(DATA_XERESTRASZA,NOT_STARTED);
+			}
+
+			void MoveInLineOfSight(Unit*)
+			{
+				if(!bIntro)
+				{
+					DoScriptText(SAY_XERESTRASZA_1, me);
+					pInstance->SetData(DATA_XERESTRASZA,NOT_STARTED);
+					bIntro = true;
+				}
+			}
+
+            void DoAction(const int32 action)
+            {
+                if (action == ACTION_START_EVENT)
+                {
+                    me->GetMotionMaster()->MovePoint(1, 3153.5490f, 385.53f, 86.33f);
+                    pInstance->SetData(DATA_XERESTRASZA,IN_PROGRESS);
+                    DoScriptText(SAY_XERESTRASZA_2, me);
+                    events.ScheduleEvent(EVENT_XERESTRASZA_3,9000);
+                    events.ScheduleEvent(EVENT_XERESTRASZA_4,20000);
+                    events.ScheduleEvent(EVENT_XERESTRASZA_5,31000);
+                    events.ScheduleEvent(EVENT_XERESTRASZA_6,42000);
+                    events.ScheduleEvent(EVENT_XERESTRASZA_7,53000);
+                    events.ScheduleEvent(EVENT_XERESTRASZA_8,64000);
+                    events.ScheduleEvent(EVENT_XERESTRASZA_9,75000);
+                }
+            }
+
+            void UpdateAI(const uint32 diff)
+            {
+                events.Update(diff);
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_XERESTRASZA_3:
+                            DoScriptText(SAY_XERESTRASZA_3, me);
+                            break;
+                        case EVENT_XERESTRASZA_4:
+                            DoScriptText(SAY_XERESTRASZA_4, me);
+                            break;
+                        case EVENT_XERESTRASZA_5:
+                            DoScriptText(SAY_XERESTRASZA_5, me);
+                            break;
+                        case EVENT_XERESTRASZA_6:
+                            DoScriptText(SAY_XERESTRASZA_6, me);
+                            break;
+                        case EVENT_XERESTRASZA_7:
+                            DoScriptText(SAY_XERESTRASZA_7, me);
+                            break;
+                        case EVENT_XERESTRASZA_8:
+                            DoScriptText(SAY_XERESTRASZA_8, me);
+                            break;
+                        case EVENT_XERESTRASZA_9:
+                            DoScriptText(SAY_XERESTRASZA_9, me);
+                            pInstance->SetData(DATA_XERESTRASZA,DONE);
+                            break;
+                    }
+                }
+            }
+
+			private:
+            bool bIntro;
+            EventMap events;
+            InstanceScript* pInstance;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+		{
+			return new npc_xerestraszaAI(pCreature);
+		}
+};
+
+
+void AddSC_boss_baltharus()
+{
+    new boss_baltharus;
+    new boss_baltharus_summon;
+    new npc_xerestrasza;
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp b/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
new file mode 100644
index 0000000..472097a
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_halion.cpp
@@ -0,0 +1,521 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eTexts
+{
+        SAY_SPAWN       = -1752027,
+        SAY_AGGRO       = -1752028,
+        SAY_SLAY1       = -1752029,
+        SAY_SLAY2       = -1752030,
+        SAY_DEATH       = -1752031,
+        SAY_BERSERK     = -1752032,
+        SAY_SPECIAL1    = -1752033,
+        SAY_SPECIAL2    = -1752034,
+        SAY_PHASE2      = -1752035,
+        SAY_PHASE3      = -1752036
+};
+
+enum eSpells
+{
+    //All
+    SPELL_TWILIGHT_PRECISION        = 78243,
+    SPELL_CLEAVE                    = 74524,
+    SPELL_TAIL_LASH                 = 74531,
+    SPELL_BERSEK                    = 26662,
+    SPELL_TWILIGHT_DIVISION         = 75063,
+    SPELL_SUMMON_TWILIGHT_PORTAL    = 74809,
+
+    //halion
+    SPELL_FLAME_BREATH_10_NORMAL    = 74525,
+    SPELL_FLAME_BREATH_25_NORMAL    = 74526,
+    SPELL_FLAME_BREATH_10_HEROIC    = 74527,
+    SPELL_FLAME_BREATH_25_HEROIC    = 74528,
+    SPELL_FIERY_COMBUSTION          = 74562,
+
+    //twilight halion
+    SPELL_DUSK_SHROUD               = 75476,
+    SPELL_SOUL_CONSUMPTION          = 74792,
+    SPELL_DARK_BREATH_10_NORMAL     = 74806,
+    SPELL_DARK_BREATH_25_NORMAL     = 75954,
+    SPELL_DARK_BREATH_10_HEROIC     = 75955,
+    SPELL_DARK_BREATH_25_HEROIC     = 75956,
+
+    SPELL_CORPOREALITY_EVEN         = 74826,
+    SPELL_CORPOREALITY_20I          = 74827,
+    SPELL_CORPOREALITY_40I          = 74828,
+    SPELL_CORPOREALITY_60I          = 74829,
+    SPELL_CORPOREALITY_80I          = 74830,
+    SPELL_CORPOREALITY_100I         = 74831,
+    SPELL_CORPOREALITY_20D          = 74832,
+    SPELL_CORPOREALITY_40D          = 74833,
+    SPELL_CORPOREALITY_60D          = 74834,
+    SPELL_CORPOREALITY_80D          = 74835,
+    SPELL_CORPOREALITY_100D         = 74836
+};
+
+enum eEvents
+{
+    EVENT_CAST_TWILIGHT_PRECISION   = 1,
+    EVENT_CAST_CLEAVE               = 2,
+    EVENT_CAST_FIERY_COMBUSTION     = 3,
+    EVENT_CAST_TAIL_LASH            = 4,
+    EVENT_CAST_FLAME_BREATH         = 5,
+    EVENT_CAST_DARK_BREATH          = 6,
+    EVENT_CAST_SOUL_CONSUMPTION     = 7,
+    EVENT_CAST_DUSK_SHROUD          = 8,
+    EVENT_FLAME_WALL                = 9,
+    EVENT_CAST_BERSEK               = 10,
+    EVENT_DPS                       = 11
+};
+
+enum ePhases
+{
+    PHASE_ALL = 0,
+    PHASE_1   = 1,
+    PHASE_2   = 2,
+    PHASE_3   = 3,
+
+    PHASE_1_MASK  = 1 << PHASE_1,
+    PHASE_2_MASK  = 1 << PHASE_2,
+    PHASE_3_MASK  = 1 << PHASE_3
+};
+
+Creature* pHalion;
+Creature* pTwilight;
+uint32 HalionDamage, TwilightDamage;
+static const Position SpawnPos = {3144.93f, 527.233f, 72.8887f, 0.110395f};
+
+class boss_halion : public CreatureScript
+{
+    public:
+        boss_halion() : CreatureScript("boss_halion") { }
+
+        struct boss_halionAI : public BossAI
+        {
+            boss_halionAI(Creature *pCreature) : BossAI(pCreature, DATA_HALION)
+                {
+                    ASSERT(instance);
+                    pHalion = me;
+                }
+
+            void Reset()
+			{
+                if (instance->GetData(DATA_TWILIGHT_HALION)==IN_PROGRESS)
+                {
+                    pHalion->SetHealth(pTwilight->GetHealth());
+                    return;
+                }
+                instance->SetBossState(DATA_HALION, NOT_STARTED);
+                events.Reset();
+                events.SetPhase(PHASE_1);
+                events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 1,PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000,PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000),PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(20000,25000),PHASE_ALL);
+                events.ScheduleEvent(EVENT_CAST_FIERY_COMBUSTION, 15000,PHASE_ALL);
+                events.ScheduleEvent(SPELL_BERSEK, 9999999,PHASE_ALL);
+                PercentDamage = 0;
+                HalionDamage = 0;
+		}
+
+			void EnterCombat(Unit*)
+			{
+                instance->SetBossState(DATA_HALION, IN_PROGRESS);
+
+                if(events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    pHalion->SetHealth(pTwilight->GetHealth());
+                    return;
+                }
+
+                events.ScheduleEvent(EVENT_FLAME_WALL, 1000,PHASE_1);
+                DoScriptText(SAY_AGGRO, me);
+			}
+
+			void UpdateAI(const uint32 diff)
+			{
+                if (!UpdateVictim() || !CheckInRoom())
+                    return;
+
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    if (instance->GetData(DATA_DAMAGE) != 0)
+                        me->SetHealth(instance->GetData(DATA_DAMAGE));
+                    else
+                        me->SetHealth(1);
+                }
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                GameObject* go_flame;
+
+                if ((events.GetPhaseMask() & PHASE_1_MASK) || (events.GetPhaseMask() & PHASE_3_MASK))
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_TWILIGHT_PRECISION:
+                                DoCast(me, SPELL_TWILIGHT_PRECISION);
+                                break;
+                            case EVENT_FLAME_WALL:
+                                go_flame = me->SummonGameObject(GO_FLAME_WALLS2, (float)3154.56, (float)535.418, (float)72.8889, (float)4.47206, 0, 0, (float)0.786772, (float)-0.617243, 300);
+                                go_flame->SetPhaseMask(0,true);
+                                break;
+                            case EVENT_CAST_TAIL_LASH:
+                                DoCast(me, SPELL_TAIL_LASH);
+                                events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000),PHASE_ALL);
+                                break;
+                            case EVENT_CAST_CLEAVE:
+                                DoCast(me, SPELL_CLEAVE);
+                                events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000,PHASE_ALL);
+                                break;
+                            case EVENT_CAST_FLAME_BREATH:
+                                DoCast(me, RAID_MODE(SPELL_FLAME_BREATH_10_NORMAL, SPELL_FLAME_BREATH_25_NORMAL, SPELL_FLAME_BREATH_10_HEROIC, SPELL_FLAME_BREATH_25_HEROIC));
+                                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(20000,25000),PHASE_ALL);break;
+                            case EVENT_DPS:
+                                CastCorporeality();
+                                events.ScheduleEvent(EVENT_DPS, 5000,PHASE_3);
+                                break;
+                            case EVENT_CAST_FIERY_COMBUSTION:
+                                Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0);
+								if (pTarget && !pTarget->HasAura(SPELL_FIERY_COMBUSTION))
+									DoCast(pTarget, SPELL_FIERY_COMBUSTION);
+                                events.ScheduleEvent(EVENT_CAST_FIERY_COMBUSTION, 15000,PHASE_ALL);
+                                break;
+                        }
+                    }
+                }
+
+				if ((events.GetPhaseMask() & PHASE_1_MASK) && ((me->GetHealth()*100) / me->GetMaxHealth() <= 75))
+				{
+					events.SetPhase(PHASE_2);
+					DoScriptText(SAY_PHASE2, me);
+					me->SetReactState(REACT_PASSIVE);
+					me->AttackStop();
+					me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+					DoCast(me, SPELL_SUMMON_TWILIGHT_PORTAL);
+					DoCast(me, SPELL_TWILIGHT_DIVISION);
+					me->SummonCreature(NPC_TWILIGHT_HALION,SpawnPos);
+					me->SetVisible(false);
+					instance->SetBossState(DATA_HALION, SPECIAL);
+				}
+					DoMeleeAttackIfReady();
+		}
+
+            void CastCorporeality()
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+                uint32 TotalDamage = HalionDamage+TwilightDamage;
+                if (TotalDamage > 0)
+                {
+                    PercentDamage = HalionDamage / TotalDamage * 100;
+                }
+                else
+                {
+                    PercentDamage=50;
+                }
+                HalionDamage = 0;
+                TwilightDamage = 0;
+
+                if (PercentDamage < 5)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_100I, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_100D, true);
+                }
+                else if (PercentDamage < 15)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_80I, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_80D, true);
+                }
+                else if (PercentDamage < 25)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_60I, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_60D, true);
+                }
+                else if (PercentDamage < 35)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_40I, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_40D, true);
+                }
+                else if (PercentDamage < 45)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_20I, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_20D, true);
+                }
+                else if (PercentDamage < 55)
+                {
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_EVEN, true);
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_EVEN, true);
+                }
+                else if (PercentDamage < 65)
+                {
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_20I, true);
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_20D, true);
+                }
+                else if (PercentDamage < 75)
+                {
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_40I, true);
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_40D, true);
+                }
+                else if (PercentDamage < 85)
+                {
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_60I, true);
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_60D, true);
+                }
+                else if (PercentDamage < 95)
+                {
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_80I, true);
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_80D, true);
+                }
+                else
+                {
+                    pHalion->CastSpell(pHalion, SPELL_CORPOREALITY_100I, true);
+                    pTwilight->CastSpell(pTwilight, SPELL_CORPOREALITY_100D, true);
+                }
+            }
+
+            void SetPhase3()
+            {
+                events.SetPhase(PHASE_3);
+                GameObject* portal = me->SummonGameObject(GO_TWILIGHT_PORTAL2, (float)3154.56, (float)535.418, (float)72.8889, (float)4.47206, 0, 0, (float)0.786772, (float)-0.617243, 300000);
+                portal->SetPhaseMask(32,true);
+                portal->SetRespawnTime(9999999);
+                events.ScheduleEvent(EVENT_DPS, 5000,PHASE_3);
+                pHalion->SetHealth(pTwilight->GetHealth());
+            }
+
+            void DamageTaken(Unit *who, uint32 &dmg)
+            {
+                if (!(events.GetPhaseMask() & PHASE_3_MASK))
+                        return;
+					HalionDamage += dmg;
+
+                instance->SetData(DATA_DAMAGE, me->GetHealth() >= dmg ? me->GetHealth() - dmg : 0);
+            }
+
+            void JustSummoned(Creature *summon)
+            {
+                if(summon->GetEntry()==NPC_TWILIGHT_HALION)
+                {
+                    summon->SetPhaseMask(32,true);
+                }
+                summons.Summon(summon);
+            }
+
+			void KilledUnit(Unit *victim)
+			{
+				DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+			}
+
+			void JustDied(Unit*)
+			{
+				_JustDied();
+				DoScriptText(SAY_DEATH, me);
+			}
+
+        private:
+            uint32 PercentDamage;
+        };
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+                return new boss_halionAI(pCreature);
+        }
+
+};
+
+class boss_twilight_halion : public CreatureScript
+{
+    public:
+        boss_twilight_halion() : CreatureScript("boss_twilight_halion") { }
+
+        struct boss_twilight_halionAI : public ScriptedAI
+        {
+            boss_twilight_halionAI(Creature *pCreature) : ScriptedAI(pCreature)
+                {
+                    pInstance = me->GetInstanceScript();
+                    pTwilight = me;
+                }
+
+				void Reset()
+			{
+				me->SetReactState(REACT_AGGRESSIVE);
+				me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+				events.Reset();
+				events.SetPhase(PHASE_2);
+				events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 1,PHASE_ALL);
+				events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000,PHASE_ALL);
+				events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000),PHASE_ALL);
+				events.ScheduleEvent(EVENT_CAST_DUSK_SHROUD, urand(15000,20000),PHASE_ALL);
+				events.ScheduleEvent(EVENT_CAST_DARK_BREATH, urand(20000,25000),PHASE_ALL);
+				events.ScheduleEvent(EVENT_CAST_SOUL_CONSUMPTION, urand(15000,25000),PHASE_ALL);
+				events.ScheduleEvent(EVENT_CAST_BERSEK, 9999999,PHASE_ALL);
+				me->SetMaxHealth(pHalion->GetMaxHealth());
+				TwilightDamage = 0;
+			}
+
+				void EnterCombat(Unit*)
+			{
+				me->SetHealth(pHalion->GetHealth());
+				pInstance->SetData(DATA_TWILIGHT_HALION,IN_PROGRESS);
+			}
+
+				void UpdateAI(const uint32 diff)
+			{
+				if (!UpdateVictim())
+					return;
+
+                if (events.GetPhaseMask() & PHASE_3_MASK)
+                {
+                    if (pInstance->GetData(DATA_DAMAGE) != 0)
+                        me->SetHealth(pInstance->GetData(DATA_DAMAGE));
+                    else
+                        me->SetHealth(1);
+                }
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_TWILIGHT_PRECISION:
+                            DoCast(me, SPELL_TWILIGHT_PRECISION);
+                            events.ScheduleEvent(EVENT_CAST_TWILIGHT_PRECISION, 10000,PHASE_ALL);
+                            break;
+                        case EVENT_CAST_TAIL_LASH:
+                            DoCast(me, SPELL_TAIL_LASH);
+                            events.ScheduleEvent(EVENT_CAST_TAIL_LASH, urand(10000,15000),PHASE_ALL);
+                            break;
+                        case EVENT_CAST_DARK_BREATH:
+                            DoCast(me, RAID_MODE(SPELL_DARK_BREATH_10_NORMAL, SPELL_DARK_BREATH_25_NORMAL, SPELL_DARK_BREATH_10_HEROIC, SPELL_DARK_BREATH_25_HEROIC));
+                            events.ScheduleEvent(EVENT_CAST_DARK_BREATH, urand(20000,25000),PHASE_ALL);break;
+                        case EVENT_CAST_CLEAVE:
+                            DoCast(me, SPELL_CLEAVE);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE, 15000,PHASE_ALL);
+                            break;
+                        case EVENT_CAST_DUSK_SHROUD:
+                            DoCast(me, SPELL_DUSK_SHROUD);
+                            events.ScheduleEvent(EVENT_CAST_DUSK_SHROUD, urand(15000,20000),PHASE_ALL);
+                            break;
+                        case EVENT_CAST_SOUL_CONSUMPTION:
+                            DoCast(me, SPELL_SOUL_CONSUMPTION);
+                            events.ScheduleEvent(EVENT_CAST_SOUL_CONSUMPTION, urand(15000,25000),PHASE_ALL);
+                            break;
+                        case EVENT_CAST_BERSEK:
+                            DoCast(me, SPELL_BERSEK);
+                            events.ScheduleEvent(EVENT_CAST_BERSEK, 9999999,PHASE_ALL);
+                            break;
+                        case EVENT_DPS:
+                            if (pInstance->GetBossState(DATA_HALION)==SPECIAL)
+                                CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->CastCorporeality();
+                            events.ScheduleEvent(EVENT_DPS, 5000,PHASE_3);
+                            break;
+                    }
+                }
+
+					if ((events.GetPhaseMask() & PHASE_2_MASK) && ((me->GetHealth()*100) / me->GetMaxHealth() <= 50))
+				{
+					events.SetPhase(PHASE_3);
+					DoScriptText(SAY_PHASE3, me);
+					pHalion->SetReactState(REACT_AGGRESSIVE);
+					pHalion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+					pHalion->SetVisible(true);
+					CAST_AI(boss_halion::boss_halionAI, pHalion->AI())->SetPhase3();
+					events.ScheduleEvent(EVENT_DPS, 5000,PHASE_3);
+				}
+
+					DoMeleeAttackIfReady();
+			}
+
+				void DamageTaken(Unit *who, uint32 &dmg)
+			{
+				if (!(events.GetPhaseMask() & PHASE_3_MASK))
+					return;
+				TwilightDamage += dmg;
+
+				pInstance->SetData(DATA_DAMAGE, me->GetHealth() >= dmg ? me->GetHealth() - dmg : 0);
+			}
+
+				void KilledUnit(Unit *victim)
+			{
+				DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+			}
+
+				void JustDied(Unit*)
+			{
+				DoScriptText(SAY_DEATH, me);
+
+				pInstance->SetData(DATA_TWILIGHT_HALION,DONE);
+			}
+
+			private:
+				EventMap events;
+				InstanceScript* pInstance;
+			};
+
+        CreatureAI* GetAI(Creature *pCreature) const
+        {
+                return new boss_twilight_halionAI(pCreature);
+        }
+
+};
+
+class spell_halion_portal : public SpellScriptLoader
+{
+    public:
+        spell_halion_portal() : SpellScriptLoader("spell_halion_portal") { }
+
+        class spell_halion_portal_SpellScript : public SpellScript
+        {
+			PrepareSpellScript(spell_halion_portal_SpellScript)
+            void HandleScript(SpellEffIndex /*effIndex*/)
+            {
+                //PreventHitDefaultEffect(EFFECT_0);
+                GetHitPlayer()->RemoveAurasDueToSpell(74807);
+                GetHitPlayer()->SetPhaseMask(1,true);
+            }
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_halion_portal_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_APPLY_AURA);
+            }
+        };
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_halion_portal_SpellScript();
+        }
+};
+
+
+void AddSC_boss_halion()
+{
+    new boss_halion;
+    new boss_twilight_halion;
+    new spell_halion_portal;
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp b/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
new file mode 100644
index 0000000..0dd0cb7
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_ragefire.cpp
@@ -0,0 +1,174 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eScriptTexts
+{
+    SAY_AGGRO           = -1752022,
+    SAY_SLAY1           = -1752023,
+	SAY_SLAY2           = -1752024,
+    SAY_DEATH           = -1752025
+};
+
+enum eSpells
+{
+	SPELL_CONFLAGRATION     = 74456,
+    SPELL_ENRAGE            = 78722,
+	SPELL_FLAME_BREATH_10   = 74403,
+	SPELL_FLAME_BREATH_25   = 74404,
+	SPELL_FLAME_BEACON      = 74453
+};
+
+enum eEvents
+{
+    EVENT_CAST_CONFLAGRATION      = 1,
+    EVENT_CAST_ENRAGE             = 2,
+    EVENT_CAST_FLAME_BREATH       = 3,
+    EVENT_CAST_FLAME_BEACON       = 4,
+    EVENT_CAST_CONFLAGRATION_FLY  = 5,
+    EVENT_CAST_CONFLAGRATION_CAST = 6
+};
+
+#define TARGETS_10 2
+#define TARGETS_25 5
+
+class boss_ragefire : public CreatureScript
+{
+    public:
+        boss_ragefire() : CreatureScript("boss_ragefire") { }
+
+        struct boss_ragefireAI : public BossAI
+        {
+			boss_ragefireAI(Creature *pCreature) : BossAI(pCreature, DATA_RAGEFIRE)
+			{
+				ASSERT(instance);
+				me->SetUnitMovementFlags(MOVEMENTFLAG_CAN_FLY);
+			}
+
+			void Reset()
+			{
+				instance->SetBossState(DATA_RAGEFIRE, NOT_STARTED);
+				playerList.clear();
+				bConflagration = false;
+				events.Reset();
+				events.ScheduleEvent(EVENT_CAST_CONFLAGRATION, urand(45000,55000));
+				events.ScheduleEvent(EVENT_CAST_ENRAGE, urand(25000,35000));
+				events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(10000,15000));
+			}
+
+				void UpdateAI(const uint32 diff)
+			{
+				if(!UpdateVictim() || !CheckInRoom())
+					return;
+
+				if (me->HasUnitState(UNIT_STAT_CASTING))
+					return;
+
+                events.Update(diff);
+
+                if (!bConflagration)
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_CONFLAGRATION:
+                                bConflagration = true;
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION_FLY, 1000);
+                                break;
+                            case EVENT_CAST_ENRAGE:
+                                DoCast(SPELL_ENRAGE);
+                                events.ScheduleEvent(EVENT_CAST_ENRAGE, urand(25000,35000));
+                                break;
+                            case EVENT_CAST_FLAME_BREATH:
+                                DoCast(RAID_MODE(SPELL_FLAME_BREATH_10,SPELL_FLAME_BREATH_25,SPELL_FLAME_BREATH_10,SPELL_FLAME_BREATH_25));
+                                events.ScheduleEvent(EVENT_CAST_FLAME_BREATH, urand(10000,15000));
+                                break;
+                        }
+                    }
+                }
+                else
+                {
+                    while (uint32 eventId = events.ExecuteEvent())
+                    {
+                        switch (eventId)
+                        {
+                            case EVENT_CAST_CONFLAGRATION_FLY:
+                                me->GetMotionMaster()->MovePoint(1, (float)3159.04, (float)676.08, (float)103.05);
+                                SelectTargetList(playerList, RAID_MODE(TARGETS_10,TARGETS_25,TARGETS_10,TARGETS_25), SELECT_TARGET_RANDOM, 0, true);
+                                for (std::list<Unit*>::const_iterator itr = playerList.begin(); itr != playerList.end(); ++itr)
+                                {
+                                    Unit *pTemp = (*itr);
+                                    me->CastSpell(pTemp, SPELL_FLAME_BEACON, true);
+                                }
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION_CAST, 5000);
+                                break;
+                            case EVENT_CAST_CONFLAGRATION_CAST:
+                                for (std::list<Unit*>::const_iterator itr = playerList.begin(); itr != playerList.end(); ++itr)
+                                {
+                                    Unit *pTemp = (*itr);
+                                    me->CastSpell(pTemp, SPELL_CONFLAGRATION, true);
+                                }
+                                playerList.clear();
+                                me->GetMotionMaster()->MoveTargetedHome();
+                                bConflagration = false;
+                                events.ScheduleEvent(EVENT_CAST_CONFLAGRATION, urand(45000,55000));
+                                break;
+                        }
+                    }
+                }
+
+				DoMeleeAttackIfReady();
+			}
+
+				void EnterCombat(Unit*)
+			{
+				instance->SetBossState(DATA_RAGEFIRE, IN_PROGRESS);
+				DoScriptText(SAY_AGGRO, me);
+			}
+
+				void KilledUnit(Unit *victim)
+			{
+				DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+			}
+
+				void JustDied(Unit*)
+			{
+				_JustDied();
+				DoScriptText(SAY_DEATH, me);
+				instance->SetBossState(DATA_RAGEFIRE, DONE);
+			}
+
+			private:
+			bool bConflagration;
+			std::list<Unit *> playerList;
+
+			};
+
+			CreatureAI* GetAI(Creature *pCreature) const
+			{
+			return new boss_ragefireAI(pCreature);
+			}
+
+};
+
+
+void AddSC_boss_ragefire()
+{
+    new boss_ragefire;
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp b/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
new file mode 100644
index 0000000..1cd0af3
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/boss_zarithrian.cpp
@@ -0,0 +1,116 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+enum eTexts
+{
+	SAY_AGGRO = -1752017,
+	SAY_SLAY1 = -1752018,
+	SAY_SLAY2 = -1752019,
+	SAY_DEATH = -1752020
+};
+
+enum eSpells
+{
+	SPELL_CLEAVE_ARMOR         = 74367,
+	SPELL_INTIMIDATING_ROAR    = 74384
+};
+
+enum eEvents
+{
+    EVENT_CAST_CLEAVE_ARMOR      = 1,
+    EVENT_CAST_INTIMIDATING_ROAR = 2
+};
+
+class boss_zarithrian : public CreatureScript
+{
+    public:
+        boss_zarithrian() : CreatureScript("boss_zarithrian") { }
+
+        struct boss_zarithrianAI : public BossAI
+        {
+            boss_zarithrianAI(Creature *pCreature) : BossAI(pCreature, DATA_ZARITHRIAN)
+			{
+				ASSERT(instance);
+			}
+
+				void Reset()
+			{
+				instance->SetBossState(DATA_ZARITHRIAN, NOT_STARTED);
+				events.Reset();
+				events.ScheduleEvent(EVENT_CAST_CLEAVE_ARMOR, urand(3500,4500));
+				events.ScheduleEvent(EVENT_CAST_INTIMIDATING_ROAR, urand(10000,11000));
+			}
+
+				void EnterCombat(Unit*)
+			{
+				instance->SetBossState(DATA_ZARITHRIAN, IN_PROGRESS);
+				DoScriptText(SAY_AGGRO, me);
+			}
+
+				void UpdateAI(const uint32 diff)
+			{
+				if(!UpdateVictim() || !CheckInRoom())
+					return;
+
+                if (me->HasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                events.Update(diff);
+
+                while (uint32 eventId = events.ExecuteEvent())
+                {
+                    switch (eventId)
+                    {
+                        case EVENT_CAST_CLEAVE_ARMOR:
+                            DoCastVictim(SPELL_CLEAVE_ARMOR);
+                            events.ScheduleEvent(EVENT_CAST_CLEAVE_ARMOR, urand(3500,4500));
+                            break;
+                        case EVENT_CAST_INTIMIDATING_ROAR:
+                            DoCast(SPELL_INTIMIDATING_ROAR);
+                            events.ScheduleEvent(EVENT_CAST_INTIMIDATING_ROAR, urand(10000,11000));
+                            break;
+                    }
+                }
+
+				DoMeleeAttackIfReady();
+			}
+
+				void KilledUnit(Unit *victim)
+			{
+				DoScriptText(RAND(SAY_SLAY1,SAY_SLAY2), me);
+			}
+
+				void JustDied(Unit*)
+			{
+				_JustDied();
+				DoScriptText(SAY_DEATH, me);
+			}
+		};
+
+			CreatureAI* GetAI(Creature *pCreature) const
+			{
+			return new boss_zarithrianAI(pCreature);
+			}
+
+};
+
+void AddSC_boss_zarithrian()
+{
+    new boss_zarithrian;
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp b/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
new file mode 100644
index 0000000..ef820f6
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/instance_ruby_sanctum.cpp
@@ -0,0 +1,234 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "ScriptPCH.h"
+#include "ruby_sanctum.h"
+
+static const DoorData doorData[8] =
+{
+    {GO_FIRE_FIELD,   DATA_BALTHARUS,       DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS,  DATA_BALTHARUS,       DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS,  DATA_RAGEFIRE,        DOOR_TYPE_PASSAGE, BOUNDARY_NONE},
+    {GO_FLAME_WALLS2, DATA_HALION,          DOOR_TYPE_ROOM,    BOUNDARY_NONE},
+    {GO_FLAME_WALLS2, DATA_TWILIGHT_HALION, DOOR_TYPE_ROOM,    BOUNDARY_NONE},
+    {0,               0,                    DOOR_TYPE_ROOM,    BOUNDARY_NONE}
+};
+
+class instance_ruby_sanctum : public InstanceMapScript
+{
+    public:
+        instance_ruby_sanctum() : InstanceMapScript("instance_ruby_sanctum", 724) { }
+
+        struct instance_ruby_sanctum_InstanceMapScript : public InstanceScript
+        {
+            instance_ruby_sanctum_InstanceMapScript(Map *pMap) : InstanceScript(pMap)
+            {
+                SetBossNumber(MAX_ENCOUNTER);
+                LoadDoorData(doorData);
+
+                m_uiDataDamage = 0;
+
+                m_uiXerestrasza = 0;
+                m_uiTwilightHalion = 0;
+
+                m_uiBaltharusGUID = 0;
+                m_uiZarithrianGUID = 0;
+                m_uiRagefireGUID = 0;
+                m_uiHalionGUID = 0;
+                m_uiXerestraszaGUID = 0;
+                m_uiTwilightHalionGUID = 0;
+            }
+
+            void OnCreatureCreate(Creature *pCreature, bool  /*add*/)
+            {
+                switch(pCreature->GetEntry())
+                {
+                    case NPC_BALTHARUS:     m_uiBaltharusGUID = pCreature->GetGUID();   break;
+                    case NPC_RAGEFIRE:      m_uiRagefireGUID = pCreature->GetGUID();    break;
+                    case NPC_XERESTRASZA:   m_uiXerestraszaGUID = pCreature->GetGUID(); break;
+                    case NPC_ZARITHRIAN:
+                        m_uiZarithrianGUID = pCreature->GetGUID();
+                        pCreature->SetReactState(REACT_PASSIVE);
+                        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        break;
+                    case NPC_HALION:
+                        m_uiHalionGUID = pCreature->GetGUID();
+                        pCreature->SetVisible(false);
+                        pCreature->SetReactState(REACT_PASSIVE);
+                        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        break;
+                    case NPC_TWILIGHT_HALION: m_uiTwilightHalionGUID = pCreature->GetGUID(); break;
+                }
+            }
+
+            void OnGameObjectCreate(GameObject* pGo, bool add)
+            {
+                switch (pGo->GetEntry())
+                {
+                    case GO_FIRE_FIELD:
+                    case GO_FLAME_WALLS:
+                    case GO_FLAME_WALLS2:
+                        AddDoor(pGo, add);
+                        break;
+                    case GO_TWILIGHT_PORTAL1: break;
+                    case GO_TWILIGHT_PORTAL2: break;
+                    default: break;
+                }
+            }
+
+            void SetData(uint32 uiType, uint32 uiData)
+            {
+					switch(uiType)
+				{
+					case DATA_XERESTRASZA:     m_uiXerestrasza    = uiData; break;
+					case DATA_TWILIGHT_HALION: m_uiTwilightHalion = uiData; break;
+					case DATA_DAMAGE:          m_uiDataDamage     = uiData; break;
+				}
+			}
+
+            uint32 GetData(uint32 uiType)
+			{
+				switch(uiType)
+				{
+					case DATA_XERESTRASZA:     return m_uiXerestrasza;    break;
+					case DATA_TWILIGHT_HALION: return m_uiTwilightHalion; break;
+					case DATA_DAMAGE:          return m_uiDataDamage;     break;
+				}
+				return 0;
+			}
+
+				void BossZarithrian()
+			{
+                if (Creature* Zarithrian = instance->GetCreature(GetData64(DATA_ZARITHRIAN)))
+                {
+                    Zarithrian->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    Zarithrian->SetReactState(REACT_AGGRESSIVE);
+                }
+            }
+
+            bool SetBossState(uint32 type, EncounterState state)
+            {
+                if (!InstanceScript::SetBossState(type, state))
+                    return false;
+
+                switch (type)
+                {
+                    case DATA_BALTHARUS:
+                        if(state==DONE)
+                        {
+                            if(GetBossState(DATA_RAGEFIRE)==DONE)
+                            {
+                                BossZarithrian();
+                            }
+                        }
+                        break;
+                    case DATA_RAGEFIRE:
+                        if(state==DONE)
+                        {
+                            if(GetBossState(DATA_BALTHARUS)==DONE)
+                            {
+                                BossZarithrian();
+                            }
+                        }
+                        break;
+                    case DATA_ZARITHRIAN:
+                        if(GetBossState(DATA_BALTHARUS)==DONE && GetBossState(DATA_RAGEFIRE)==DONE)
+                        {
+                            if(state==DONE)
+                            {
+                                if (Creature* halion = instance->GetCreature(GetData64(DATA_HALION)))
+                                {
+                                    halion->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                                    halion->SetVisible(true);
+                                    halion->SetReactState(REACT_AGGRESSIVE);
+                                }
+                            }
+                        }
+                        break;
+                    case DATA_HALION: break;
+                }
+
+                return true;
+            }
+
+				uint64 GetData64(uint32 uiData)
+			{
+				switch(uiData)
+				{
+					case DATA_BALTHARUS:       return m_uiBaltharusGUID;      break;
+					case DATA_ZARITHRIAN:      return m_uiZarithrianGUID;     break;
+					case DATA_RAGEFIRE:        return m_uiRagefireGUID;       break;
+					case DATA_HALION:          return m_uiHalionGUID;         break;
+					case DATA_TWILIGHT_HALION: return m_uiTwilightHalionGUID; break;
+					case DATA_XERESTRASZA:     return m_uiXerestraszaGUID;    break;
+					default: break;
+				}
+					return 0;
+			}
+
+            std::string GetSaveData()
+            {
+                std::ostringstream saveStream;
+                saveStream << GetBossSaveData() << " " << m_uiXerestrasza;
+                return saveStream.str();
+            }
+
+            void Load(const char* strIn)
+            {
+                if (!strIn)
+                {
+                    return;
+                }
+
+                std::istringstream loadStream(strIn);
+
+                uint32 tmpState;
+
+                for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+                {
+                    loadStream >> tmpState;
+                    if (tmpState == IN_PROGRESS || tmpState > SPECIAL)
+                        tmpState = NOT_STARTED;
+                    SetBossState(i, EncounterState(tmpState));
+                }
+
+                loadStream >> m_uiXerestrasza;
+            }
+
+            private:
+                uint32 m_uiXerestrasza;
+                uint32 m_uiTwilightHalion;
+                uint32 m_uiDataDamage;
+
+                uint64 m_uiBaltharusGUID;
+                uint64 m_uiZarithrianGUID;
+                uint64 m_uiRagefireGUID;
+                uint64 m_uiHalionGUID;
+                uint64 m_uiXerestraszaGUID;
+                uint64 m_uiTwilightHalionGUID;
+        };
+
+        InstanceScript* GetInstanceScript (InstanceMap *pMap) const
+        {
+            return new instance_ruby_sanctum_InstanceMapScript(pMap);
+        }
+};
+
+
+void AddSC_instance_ruby_sanctum()
+{
+    new instance_ruby_sanctum;
+}
diff --git a/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h b/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h
new file mode 100644
index 0000000..1739233
--- /dev/null
+++ b/src/server/scripts/Northrend/RubySanctum/ruby_sanctum.h
@@ -0,0 +1,130 @@
+/* Copyright (C) 2010 Easy for TrinityCore <http://trinity-core.ru/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/*
+DELETE FROM script_texts where `entry` <= -1752008 AND `entry` >= -1752016;
+DELETE FROM script_texts where `entry` <= -1752001 AND `entry` >= -1752006;
+DELETE FROM script_texts where `entry` <= -1752017 AND `entry` >= -1752036;
+
+INSERT INTO script_texts (`entry`, `content_default`, `npc_entry`, `content_loc3`, `sound`, `type`, `language`) VALUES
+('-1752008', 'Help! I am trapped within this tree! I require aid!', '0', '', '17490', '1', '0'),
+('-1752009', 'Thank you! I could not have held out for much longer.... A terrible thing has happened here.', '0', '', '17491', '1', '0'),
+('-1752010', 'We believed the Sanctum was well-fortified, but we were not prepared for the nature of this assault.', '0', '', '17492', '0', '0'),
+('-1752011', 'The Black dragonkin materialized from thin air, and set upon us before we could react.', '0', '', '17493', '0', '0'),
+('-1752012', 'We did not stand a chance. As my brethren perished around me, I managed to retreat here and bar the entrance.', '0', '', '17494', '0', '0'),
+('-1752013', 'They slaughtered us with cold efficiency, but the true focus of their interest seemed to be the eggs kept here in the Sanctum.', '0', '', '17495', '0', '0'),
+('-1752014', 'The commander of the forces on the ground here is a cruel brute named Zarithrian, but I fear there are greater powers at work.', '0', '', '17496', '0', '0'),
+('-1752015', 'In their initial assault, I caught a glimpse of their true leader, a fearsome full-grown twilight dragon.', '0', '', '17497', '0', '0'),
+('-1752016', 'I know not the extent of their plans, heroes, but I know this: They cannot be allowed to succeed!', '0', '', '17498', '0', '0'),
+
+( -1752001, "Ah, the entertainment has arrived.", 0, "", 17520, 1, 0),
+( -1752002, "Baltharus leaves no survivors!", 0, "", 17521, 1, 0),
+( -1752003, "This world has enough heroes.", 0, "", 17522, 1, 0),
+( -1752004, "I..Didn''t saw...that coming...", 0, "", 17523, 1, 0),
+( -1752005, "Twice the pain and half the fun.", 0, "", 17524, 1, 0),
+( -1752006, "Your power wanes, ancient one.... Soon you will join your friends.", 0, "", 17525, 1, 0),
+
+( -1752017, "Alexstrasza has chosen capable allies... A pity that I must END YOU!", 0, "", 17512, 1, 0),
+( -1752018, "You thought you stood a chance?", 0, "", 17513, 1, 0),
+( -1752019, "It''s for the best.", 0, "", 17514, 1, 0),
+( -1752020, "HALION! I...", 0, "", 17515, 1, 0),
+( -1752021, "Turn them to ashes, minions!", 0, "", 17516, 1, 0),
+
+( -1752022, "You will sssuffer for this intrusion!", 0, "", 17528, 1, 0),
+( -1752023, "As it should be...", 0, "", 17529, 1, 0),
+( -1752024, "Halion will be pleased", 0, "", 17530, 1, 0),
+( -1752025, "Hhrr...Grr..", 0, "", 17531, 1, 0),
+( -1752026, "Burn in the master's flame!", 0, "", 17532, 1, 0),
+
+(-1752027, 'Insects! You''re too late. The Ruby Sanctum is lost.',NULL,NULL,17499,0,0),
+(-1752028, 'Your world teeters on the brink of annihilation. You will ALL bear witness to the coming of a new age of DESTRUCTION!',NULL,NULL,17500,0,0),
+(-1752029, 'Another hero falls.',NULL,NULL,17501,0,0),
+(-1752030, 'Hahahahaha.',NULL,NULL,17502,0,0),
+(-1752031, 'Relish this victory, mortals, for it will be your last! This world will burn with the master''s return!',NULL,NULL,17503,0,0),
+(-1752032, 'Not good enough.',NULL,NULL,17504,0,0),
+(-1752033, 'The heavens burn!',NULL,NULL,17505,0,0),
+(-1752034, 'Beware the shadow!',NULL,NULL,17506,0,0),
+(-1752035, 'You will find only suffering within the realm of twilight! Enter if you dare!',NULL,NULL,17507,0,0),
+(-1752036, 'I am the light and the darkness! Cower, mortals, before the herald of Deathwing!',NULL,NULL,17508,0,0);
+
+UPDATE `instance_template` SET `script`='instance_ruby_sanctum' WHERE (`map`='724');
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus' WHERE `entry` = '39751';
+UPDATE `creature_template` SET `ScriptName` = 'boss_baltharus_summon' WHERE `entry` = '39899';
+UPDATE `creature_template` SET `ScriptName` = 'npc_xerestrasza' WHERE `entry` = '40429';
+UPDATE `creature_template` SET `ScriptName` = 'boss_zarithrian' WHERE `entry` = '39746';
+UPDATE `creature_template` SET `ScriptName` = 'boss_ragefire' WHERE `entry` = '39747';
+UPDATE `creature_template` SET `ScriptName` = 'boss_halion' WHERE `entry`= '39863';
+UPDATE `creature_template` SET `ScriptName` = 'boss_twilight_halion' WHERE `entry` = '40142';
+
+REPLACE `spell_script_names` SET `ScriptName` = 'spell_halion_portal', `spell_id`=74812;
+
+UPDATE `gameobject_template` SET `data10`=74807 WHERE `entry`=202794;
+UPDATE `gameobject_template` SET `data10`=74812 WHERE `entry`=202796;
+
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger`='-74562') AND (`spell_effect`='74610');
+DELETE FROM `spell_linked_spell` WHERE (`spell_trigger`='-74792') AND (`spell_effect`='74800');
+INSERT INTO spell_linked_spell VALUES (-74562, 74610, 0, 'Fiery Combustion removed -> Combustion');
+INSERT INTO spell_linked_spell VALUES (-74792, 74800, 0, 'Soul Consumption removed -> Consumption');
+
+DELETE FROM creature WHERE `id`=39863 and `map`=724;
+INSERT INTO creature VALUES (null,39863,724,15,1,0,0,3144.93,527.233,72.8887,0.110395,300,0,0,11156000,0,0,0);
+*/
+
+#ifndef DEF_RUBY_SANCTUM_H
+#define DEF_RUBY_SANCTUM_H
+
+enum eData
+{
+    DATA_BALTHARUS       = 0,
+    DATA_RAGEFIRE        = 1,
+    DATA_ZARITHRIAN      = 2,
+    DATA_HALION          = 3,
+    MAX_ENCOUNTER        = 4,
+    DATA_XERESTRASZA     = 5,
+    DATA_TWILIGHT_HALION = 6,
+    DATA_DAMAGE          = 7
+};
+
+enum eAchievementData
+{
+    TWILIGHT_DESTROYER_NORMAL_10    = 4817,
+    TWILIGHT_DESTROYER_NORMAL_25    = 4815,
+    TWILIGHT_DESTROYER_HEROIC_10    = 4818,
+    TWILIGHT_DESTROYER_HEROIC_25    = 4816
+};
+
+enum eCreature
+{
+	NPC_BALTHARUS        = 39751,
+    NPC_BALTHARUS_SUMMON = 39899,
+	NPC_ZARITHRIAN       = 39746,
+	NPC_RAGEFIRE         = 39747,
+	NPC_HALION           = 39863,
+    NPC_TWILIGHT_HALION  = 40142,
+	NPC_XERESTRASZA      = 40429
+};
+
+enum eGameObject
+{
+    GO_FIRE_FIELD       = 203005,
+    GO_FLAME_WALLS      = 203006,
+    GO_FLAME_WALLS2     = 203007,
+    GO_TWILIGHT_PORTAL1 = 202794,
+    GO_TWILIGHT_PORTAL2 = 202796
+};
+
+#endif
+
diff --git a/src/server/scripts/Northrend/grizzly_hills.cpp b/src/server/scripts/Northrend/grizzly_hills.cpp
index 67e0ad5..94dfc7e 100644
--- a/src/server/scripts/Northrend/grizzly_hills.cpp
+++ b/src/server/scripts/Northrend/grizzly_hills.cpp
@@ -29,6 +29,7 @@ EndContentData */
 
 #include "ScriptPCH.h"
 #include "ScriptedEscortAI.h"
+#include "ScriptedFollowerAI.h"
 
 #define GOSSIP_ITEM1 "You're free to go Orsonn, but first tell me what's wrong with the furbolg."
 #define GOSSIP_ITEM2 "What happened then?"
@@ -798,6 +799,217 @@ public:
     };
 };
 
+/*######
+## Quest 13666 & 13673:  Une lame digne d'un champion!
+######*/
+
+enum eLakeFrog
+{
+	SPELL_WARTSBGONE_LIP_BALM = 62574,
+	SPELL_FROG_LOVE = 62537,
+	SPELL_WARTS = 62581,
+	NPC_MAIDEN_OF_ASHWOOD_LAKE = 33220,
+	MAIDEN_SPAWN
+};
+
+//Script de la grenouille
+class npc_lake_frog : public CreatureScript
+{
+public:
+	npc_lake_frog(): CreatureScript("npc_lake_frog"){}
+
+	struct npc_lake_frogAI : public FollowerAI // FollowerAI:Permet au npc de suivre une cible
+	{
+		npc_lake_frogAI(Creature *c) : FollowerAI(c) {}
+
+		uint32 uiFollowTimer; //Temps de poursuite (15 sec)
+		bool following;	//Si la grenouille est en train de suivre le joueur
+
+		void Reset ()
+		{
+			following=false;
+			uiFollowTimer=15000; // 15 sec
+		}
+
+		void UpdateAI(const uint32 diff)
+		{
+			if(following)
+			{
+				if(uiFollowTimer <= diff)
+				{
+					SetFollowComplete();
+					me->DisappearAndDie();		//dÃ©pop
+					me->Respawn(true);
+					Reset();
+				}
+				else uiFollowTimer-=diff;
+			}
+		}
+
+		void ReceiveEmote(Player* pPlayer, uint32 emote)
+		{
+			if(following) //Si la grenouille a dÃ©ja recu un /bisou il ne se passe rien
+				return;
+
+			if(emote==TEXTEMOTE_KISS) // Si on fait /bisou
+			{
+				if(!pPlayer->HasAura(SPELL_WARTSBGONE_LIP_BALM))
+					pPlayer->AddAura(SPELL_WARTS,pPlayer);
+				else if(roll_chance_i(10)) // 10% de chance de trouver la grenouille
+				{
+					pPlayer->SummonCreature(NPC_MAIDEN_OF_ASHWOOD_LAKE,me->GetPositionX(),me->GetPositionY(),me->GetPositionZ(),0,TEMPSUMMON_TIMED_DESPAWN,30000);
+					me->DisappearAndDie();		//dÃ©pop
+					me->Respawn(true); //Repop 15 secondes plus tard
+				}
+				else
+				{
+					pPlayer->RemoveAura(SPELL_WARTSBGONE_LIP_BALM);	//On enleve le buff mis par l'objet de quete
+					me->AddAura(SPELL_FROG_LOVE,me); //On ajoute l'aura a la grenouille (les coeurs)
+					StartFollow(pPlayer, 35, NULL); //La grenouille suis le joueur
+					following=true;
+				}
+			}
+		}
+
+	};
+
+	CreatureAI* GetAI(Creature* pCreature) const
+	{
+		return new npc_lake_frogAI(pCreature);
+	}
+};
+
+//Script de la princesse
+#define MAIDEN_DEFAULT_TEXTID 14319
+#define MAIDEN_REWARD_TEXTID 14320
+#define GOSSIP_HELLO_MAIDEN "Delighted to have helped, ma'am. Were you once the guardian of a Send legendary. Would you know From where I could find it?"
+#define SPELL_SUMMON_ASHWOOD_BRAND 62554
+
+class npc_maiden_of_ashwood_lake : public CreatureScript
+{
+public:
+	npc_maiden_of_ashwood_lake(): CreatureScript("npc_maiden_of_ashwood_lake"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		if(!pPlayer->HasItemCount(44981,1,true))
+		{
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_MAIDEN, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+			pPlayer->SEND_GOSSIP_MENU(MAIDEN_DEFAULT_TEXTID, pCreature->GetGUID());
+			pCreature->ForcedDespawn(10000);
+			return true;
+		}
+
+		pPlayer->SEND_GOSSIP_MENU(MAIDEN_DEFAULT_TEXTID, pCreature->GetGUID());
+		return true;
+	}
+
+	bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+		switch(uiAction)
+		{
+			case GOSSIP_ACTION_INFO_DEF+1:
+				pPlayer->CastSpell(pPlayer,SPELL_SUMMON_ASHWOOD_BRAND,true);
+				pPlayer->SEND_GOSSIP_MENU(MAIDEN_REWARD_TEXTID, pCreature->GetGUID());
+				break;
+		}
+		return true;
+	}
+};
+
+//Quete : Une arme remarquable
+//Quand on utilise l'item:
+//Pop du gameobject 194239 <<NENUFAR
+//Pop du npc 33723
+
+//pop de gob 194238
+#define NPC_TEXTID_MAIDEN_OF_DRAK_MAR_01 -1850000
+#define NPC_TEXTID_MAIDEN_OF_DRAK_MAR_02 -1850001
+#define NPC_TEXTID_MAIDEN_OF_DRAK_MAR_03 -1850002
+#define NPC_TEXTID_MAIDEN_OF_DRAK_MAR_04 -1850003
+#define MAIDEN_OF_DRAK_MAR_TIMER_00 2000
+#define MAIDEN_OF_DRAK_MAR_TIMER_01 5000
+#define MAIDEN_OF_DRAK_MAR_TIMER_02 6000
+#define MAIDEN_OF_DRAK_MAR_TIMER_03 7000
+#define MAIDEN_OF_DRAK_MAR_TIMER_04 20000
+#define MAIDEN_OF_DRAK_MAR_GOB_01 194239
+#define MAIDEN_OF_DRAK_MAR_GOB_02 194238
+//Summon la dame :X: 4602.977 Y: -1600.141 Z: 156.7834 O: 0.7504916
+
+class npc_maiden_of_drak_mar : public CreatureScript
+{
+public:
+	npc_maiden_of_drak_mar(): CreatureScript("npc_maiden_of_drak_mar"){}
+
+	struct npc_maiden_of_drak_marAI : public ScriptedAI
+	{
+		uint32 phase;
+		uint32 uiPhaseTimer;
+		uint64 firstGobGuid;
+		uint64 secondGobGuid;
+
+		npc_maiden_of_drak_marAI(Creature *c) : ScriptedAI(c)
+		{
+			phase = 0;
+			uiPhaseTimer = MAIDEN_OF_DRAK_MAR_TIMER_00;
+			if(GameObject* go = me->SummonGameObject(MAIDEN_OF_DRAK_MAR_GOB_01,4602.977f,-1600.141f,156.7834f,0.7504916f,0,0,0,0,0))
+				firstGobGuid = go->GetGUID(); //Pop du nÃ©nuphar
+		}
+
+		void UpdateAI(const uint32 diff)
+		{
+			if(uiPhaseTimer <= diff)
+			{
+				phase++;
+					switch(phase)
+					{
+						case 1:
+							DoScriptText(NPC_TEXTID_MAIDEN_OF_DRAK_MAR_01, me);
+							uiPhaseTimer = MAIDEN_OF_DRAK_MAR_TIMER_01;
+							break;
+						case 2:
+							DoScriptText(NPC_TEXTID_MAIDEN_OF_DRAK_MAR_02, me);
+							uiPhaseTimer = MAIDEN_OF_DRAK_MAR_TIMER_02;
+							break;
+						case 3:
+							DoScriptText(NPC_TEXTID_MAIDEN_OF_DRAK_MAR_03, me);
+							uiPhaseTimer = MAIDEN_OF_DRAK_MAR_TIMER_03;
+							break;
+						case 4:
+							DoScriptText(NPC_TEXTID_MAIDEN_OF_DRAK_MAR_04, me);
+							if(GameObject* go = me->SummonGameObject(MAIDEN_OF_DRAK_MAR_GOB_02,4603.351f,-1599.288f,156.8822f,2.234018f,0,0,0,0,0))
+								secondGobGuid = go->GetGUID(); //Pop de la lame
+							uiPhaseTimer = MAIDEN_OF_DRAK_MAR_TIMER_04;
+							break;
+						case 5:
+							if(GameObject* go = GameObject::GetGameObject(*me,firstGobGuid))
+								go->RemoveFromWorld();// DÃ©pop du nÃ©nuphar
+							if(GameObject* go = GameObject::GetGameObject(*me,secondGobGuid))
+								go->RemoveFromWorld();// DÃ©pop de la lame
+							me->ForcedDespawn();// disparition du pnj
+							break;
+						default:// Ne devrait jamais arriver
+							if(GameObject* go = GameObject::GetGameObject(*me,firstGobGuid))
+								go->RemoveFromWorld();// DÃ©pop du nÃ©nuphar
+							if(GameObject* go = GameObject::GetGameObject(*me,secondGobGuid))
+								go->RemoveFromWorld();// DÃ©pop de la lame
+							me->ForcedDespawn();// disparition du pnj
+							break;
+					}
+			}
+			else
+			{
+				uiPhaseTimer -= diff;
+			}
+		}
+	};
+
+	CreatureAI* GetAI(Creature* pCreature) const
+	{
+		return new npc_maiden_of_drak_marAI(pCreature);
+	}
+};
+
 void AddSC_grizzly_hills()
 {
     new npc_orsonn_and_kodian;
@@ -809,4 +1021,7 @@ void AddSC_grizzly_hills()
     new npc_wounded_skirmisher;
     new npc_lightning_sentry();
     new npc_venture_co_straggler();
+    new npc_lake_frog;
+    new npc_maiden_of_ashwood_lake;
+    new npc_maiden_of_drak_mar;
 }
diff --git a/src/server/scripts/Northrend/icecrown.cpp b/src/server/scripts/Northrend/icecrown.cpp
index 808717a..53c18a1 100644
--- a/src/server/scripts/Northrend/icecrown.cpp
+++ b/src/server/scripts/Northrend/icecrown.cpp
@@ -157,7 +157,7 @@ enum eSquireDavid
 
     NPC_ARGENT_VALIANT                                  = 33448,
 
-    GOSSIP_TEXTID_SQUIRE                                = 14407
+    GOSSIP_TEXTID_SQUIRE_DAVID                                = 14407
 };
 
 #define GOSSIP_SQUIRE_ITEM_1 "I am ready to fight!"
@@ -177,19 +177,20 @@ public:
             pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_SQUIRE_ITEM_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
         }
 
-        pPlayer->SEND_GOSSIP_MENU(GOSSIP_TEXTID_SQUIRE, pCreature->GetGUID());
+        pPlayer->SEND_GOSSIP_MENU(GOSSIP_TEXTID_SQUIRE_DAVID, pCreature->GetGUID());
         return true;
     }
 
     bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
     {
-        pPlayer->PlayerTalkClass->ClearMenus();
-        if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
-        {
-            pPlayer->CLOSE_GOSSIP_MENU();
-            pCreature->SummonCreature(NPC_ARGENT_VALIANT,8575.451f,952.472f,547.554f,0.38f);
-        }
-        return true;
+	    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+	    {
+		pPlayer->CLOSE_GOSSIP_MENU();
+		pCreature->SummonCreature(NPC_ARGENT_VALIANT,8575.451,952.472,547.554,0.38);
+	    }
+	    //else
+		//pPlayer->SEND_GOSSIP_MENU(???, pCreature->GetGUID()); Missing text
+	    return true;
     }
 };
 
@@ -201,10 +202,25 @@ enum eArgentValiant
 {
     SPELL_CHARGE                = 63010,
     SPELL_SHIELD_BREAKER        = 65147,
+    SPELL_DEFEND		= 62719,
+    SPELL_THRUST		= 62544,
 
     NPC_ARGENT_VALIANT_CREDIT   = 24108
 };
 
+enum eValiantText
+{
+	NPC_FACTION_VAILIANT_TEXT_SAY_START_1 	= -1850004,//	Tenez-vous prÃªt !
+	NPC_FACTION_VAILIANT_TEXT_SAY_START_2 	= -1850005,//	Que le combat commence !
+	NPC_FACTION_VAILIANT_TEXT_SAY_START_3 	= -1850006,//	PrÃ©parez-vous !
+	NPC_ARGENT_VAILIANT_TEXT_SAY_START 		= -1850007,//	Vous pensez avoir la vaillance en vous ? Nous verrons.
+	NPC_ARGENT_VAILIANT_TEXT_SAY_WIN 		= -1850008,//	Impressionnante dÃ©monstration. Je pense que vous Ãªtes tout Ã  fait en mesure de rejoindre les rangs des vaillants.
+	NPC_ARGENT_VAILIANT_TEXT_SAY_LOOSE 		= -1850009,//	J'ai gagnÃ©. Vous aurez sans doute plus de chance la prochaine fois.
+	NPC_FACTION_VAILIANT_TEXT_SAY_WIN_1 	= -1850010,//	Je suis vaincue. Joli combat !
+	NPC_FACTION_VAILIANT_TEXT_SAY_WIN_2 	= -1850011,//	On dirait que j'ai sous-estimÃ© vos compÃ©tences. Bien jouÃ©.
+	NPC_FACTION_VAILIANT_TEXT_SAY_LOOSE 	= -1850012,//	J'ai gagnÃ©. Vous aurez sans doute plus de chance la prochaine fois.
+};
+
 class npc_argent_valiant : public CreatureScript
 {
 public:
@@ -214,17 +230,21 @@ public:
     {
         npc_argent_valiantAI(Creature* pCreature) : ScriptedAI(pCreature)
         {
+	    me->CastSpell(me, SPELL_DEFEND, true);
+	    me->CastSpell(me, SPELL_DEFEND, true);
             pCreature->GetMotionMaster()->MovePoint(0,8599.258f,963.951f,547.553f);
             pCreature->setFaction(35); //wrong faction in db?
         }
 
         uint32 uiChargeTimer;
         uint32 uiShieldBreakerTimer;
+	uint32 uiDefendTimer;
 
         void Reset()
         {
             uiChargeTimer = 7000;
             uiShieldBreakerTimer = 10000;
+	    uiDefendTimer = 10000;
         }
 
         void MovementInform(uint32 uiType, uint32 /*uiId*/)
@@ -237,15 +257,54 @@ public:
 
         void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
         {
-            if (uiDamage > me->GetHealth() && pDoneBy->GetTypeId() == TYPEID_PLAYER)
-            {
-                uiDamage = 0;
-                CAST_PLR(pDoneBy)->KilledMonsterCredit(NPC_ARGENT_VALIANT_CREDIT,0);
-                me->setFaction(35);
-                me->DespawnOrUnsummon(5000);
-                me->SetHomePosition(me->GetPositionX(),me->GetPositionY(),me->GetPositionZ(),me->GetOrientation());
-                EnterEvadeMode();
-            }
+		if(pDoneBy)
+		{
+			if (uiDamage > me->GetHealth() && (pDoneBy->GetTypeId() == TYPEID_PLAYER || pDoneBy->GetOwner()))
+			{
+				DoScriptText(NPC_ARGENT_VAILIANT_TEXT_SAY_WIN, me);
+				uiDamage = 0;
+
+				if(pDoneBy->GetOwner())
+					(pDoneBy->GetOwner())->ToPlayer()->KilledMonsterCredit(NPC_ARGENT_VALIANT_CREDIT,0);
+				if(pDoneBy->GetTypeId() == TYPEID_PLAYER)
+					pDoneBy->ToPlayer()->KilledMonsterCredit(NPC_ARGENT_VALIANT_CREDIT,0);
+
+				me->setFaction(35);
+				me->ForcedDespawn(5000);
+				me->SetHomePosition(me->GetPositionX(),me->GetPositionY(),me->GetPositionZ(),me->GetOrientation());
+				EnterEvadeMode();
+			}
+		}
+        }
+
+        void KilledUnit(Unit* /*victim*/)
+        {
+			me->setFaction(35);
+			me->ForcedDespawn(5000);
+			DoScriptText(NPC_ARGENT_VAILIANT_TEXT_SAY_LOOSE, me);
+			me->CombatStop(true);
+        }
+
+        void DoMeleeAttackIfReady()
+	{
+		if (me->HasUnitState(UNIT_STAT_CASTING))
+		    return;
+
+		//Make sure our attack is ready and we aren't currently casting before checking distance
+		if (me->isAttackReady())
+		{
+		    //If we are within range melee the target
+		    if (me->IsWithinMeleeRange(me->getVictim()))
+		    {
+		        DoCastVictim(SPELL_THRUST);
+		        me->resetAttackTimer();
+		    }
+		}
+	}
+
+	void EnterCombat(Unit* /*who*/)
+        {
+		DoScriptText(NPC_ARGENT_VAILIANT_TEXT_SAY_START, me);
         }
 
         void UpdateAI(const uint32 uiDiff)
@@ -265,6 +324,12 @@ public:
                 uiShieldBreakerTimer = 10000;
             } else uiShieldBreakerTimer -= uiDiff;
 
+            if (uiDefendTimer <= uiDiff)
+            {
+	        me->CastSpell(me, SPELL_DEFEND, true);
+	        uiDefendTimer = 10000;
+            } else uiDefendTimer -= uiDiff;
+
             DoMeleeAttackIfReady();
         }
     };
@@ -423,6 +488,943 @@ public:
     }
 };
 
+/*######
+## npc_vendor_argent_tournament
+######*/
+const uint32 ArgentTournamentVendor[10][4] =
+{
+	{33553,13726,2,14460}, // Orc
+	{33554,13726,8,14464}, // Troll
+	{33556,13728,6,14458}, // Tauren
+	{33555,13729,5,14459}, // Undead
+	{33557,13731,10,14465}, // Blood Elf
+	{33307,13699,1,14456}, // Human
+	{33310,13713,3,14457}, // Dwarf
+	{33653,13725,4,14463}, // Night Elf
+	{33650,13723,7,14462}, // Gnome
+	{33657,13724,11,14461} // Draenei
+};
+
+class npc_vendor_argent_tournament : public CreatureScript
+{
+public:
+	npc_vendor_argent_tournament(): CreatureScript("npc_vendor_argent_tournament"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		bool npcCheck = false;
+		bool questCheck = false;
+		bool raceCheck = false;
+		uint32 textId = 0;
+
+		for(int i = 0; (i < 10) && !npcCheck; i++)
+		{
+			if(pCreature->GetEntry() == ArgentTournamentVendor[i][0])
+			{
+				npcCheck = true;
+				questCheck = pPlayer->GetQuestStatus(ArgentTournamentVendor[i][1]) == QUEST_STATUS_COMPLETE;
+				raceCheck = pPlayer->getRace() == ArgentTournamentVendor[i][2];
+				textId = ArgentTournamentVendor[i][3];
+			}
+		}
+
+		if(questCheck || raceCheck)
+			pPlayer->SEND_VENDORLIST(pCreature->GetGUID());
+		else
+		    pPlayer->SEND_GOSSIP_MENU(textId, pCreature->GetGUID());
+		return true;
+	}
+
+};
+
+/*######
+* quest_givers_argent_tournament
+######*/
+
+class quest_givers_argent_tournament : public CreatureScript
+{
+public:
+	quest_givers_argent_tournament(): CreatureScript("quest_givers_argent_tournament"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		//uint64 const guid = pCreature->GetGUID();
+
+	        if (pCreature->isQuestGiver())
+		{
+			Object *pObject = (Object*)pCreature;
+			QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+			QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+			QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+			qm.ClearMenu();
+
+			for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+				if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+					qm.AddMenuItem(quest_id, 4);
+				else if (status == QUEST_STATUS_INCOMPLETE)
+					qm.AddMenuItem(quest_id, 4);
+				//else if (status == QUEST_STATUS_AVAILABLE)
+				//    qm.AddMenuItem(quest_id, 2);
+			}
+
+			bool EligibilityAlliance = pPlayer->GetQuestStatus(13686) == QUEST_STATUS_COMPLETE;
+			bool EligibilityHorde = pPlayer->GetQuestStatus(13687) == QUEST_STATUS_COMPLETE;
+
+			for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+				if (!pQuest) continue;
+
+				switch(quest_id)
+				{
+					case 13707: // Valiant Of Orgrimmar
+					case 13708: // Valiant Of Sen'jin
+					case 13709: // Valiant Of Thunder Bluff
+					case 13710: // Valiant Of Undercity
+					case 13711: // Valiant Of Silvermoon
+						if(!EligibilityHorde)
+						{
+							QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					case 13593: // Valiant Of Stormwind
+					case 13703: // Valiant Of Ironforge
+					case 13706: // Valiant Of Darnassus
+					case 13704: // Valiant Of Gnomeregan
+					case 13705: // Valiant Of The Exodar
+						if(!EligibilityAlliance)
+						{
+							QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					default:
+						QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+
+						if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 4);
+						else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 2);
+						break;
+				}
+			}
+		}
+	    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+	    return true;
+	}
+
+};
+
+/*######
+* npc_training_dummy_argent
+######*/
+#define SPELL_DEFEND_AURA 62719
+#define SPELL_DEFEND_AURA_1 64100
+#define SPELL_ARGENT_CHARGE 68321
+#define SPELL_ARGENT_BREAK_SHIELD 62626
+#define SPELL_ARGENT_MELEE 62544
+
+class npc_training_dummy_argent : public CreatureScript
+{
+public:
+	npc_training_dummy_argent(): CreatureScript("npc_training_dummy_argent"){}
+
+	struct npc_training_dummy_argentAI : Scripted_NoMovementAI
+	{
+	    npc_training_dummy_argentAI(Creature *c) : Scripted_NoMovementAI(c)
+	    {
+		m_Entry = c->GetEntry();
+	    }
+
+	    uint64 m_Entry;
+	    uint32 ResetTimer;
+	    uint32 DespawnTimer;
+		uint32 ShielTimer;
+	    void Reset()
+	    {
+		me->SetControlled(true,UNIT_STAT_STUNNED);//disable rotate
+		me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);//imune to knock aways like blast wave
+		me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_STUN, true);
+		ResetTimer = 10000;
+		DespawnTimer = 15000;
+			ShielTimer=0;
+	    }
+
+	    void EnterEvadeMode()
+	    {
+		if (!_EnterEvadeMode())
+		    return;
+
+		Reset();
+	    }
+
+	    void DamageTaken(Unit * /*done_by*/, uint32 &damage)
+	    {
+		ResetTimer = 10000;
+		damage = 0;
+	    }
+
+	    void EnterCombat(Unit * /*who*/)
+	    {
+		if (m_Entry != 2674 && m_Entry != 2673)
+		    return;
+	    }
+
+		void SpellHit(Unit* caster,const SpellEntry* spell)
+		{
+			if(caster->GetOwner())
+			{
+				if(m_Entry==33272)
+					if(spell->Id==SPELL_ARGENT_CHARGE)
+						if(!me->GetAura(SPELL_DEFEND_AURA))
+							caster->GetOwner()->ToPlayer()->KilledMonsterCredit(33340, 0);
+				if(m_Entry==33229){
+					if(spell->Id==SPELL_ARGENT_MELEE)
+					{
+						caster->GetOwner()->ToPlayer()->KilledMonsterCredit(33341, 0);
+						me->CastSpell(caster,62709,true);
+					}
+				}
+
+			}
+
+			if(m_Entry==33243)
+					if(spell->Id==SPELL_ARGENT_BREAK_SHIELD)
+						if(!me->GetAura(SPELL_DEFEND_AURA))
+							if(caster->GetTypeId()==TYPEID_PLAYER)
+								caster->ToPlayer()->KilledMonsterCredit(33339, 0);
+		}
+
+
+	    void UpdateAI(const uint32 diff)
+	    {
+			if (ShielTimer <= diff)
+			{
+				if(m_Entry==33243)
+					me->CastSpell(me,SPELL_DEFEND_AURA,true);
+
+				if(m_Entry==33272 && !me->GetAura(SPELL_DEFEND_AURA_1))
+						me->CastSpell(me,SPELL_DEFEND_AURA_1,true);
+				ShielTimer = 8000;
+			}
+			else
+				ShielTimer -= diff;
+
+		if (!UpdateVictim())
+		    return;
+		if (!me->HasUnitState(UNIT_STAT_STUNNED))
+		    me->SetControlled(true,UNIT_STAT_STUNNED);//disable rotate
+
+		if (m_Entry != 2674 && m_Entry != 2673)
+		{
+		    if (ResetTimer <= diff)
+		    {
+			EnterEvadeMode();
+			ResetTimer = 10000;
+		    }
+		    else
+			ResetTimer -= diff;
+		    return;
+		}
+		else
+		{
+		    if (DespawnTimer <= diff)
+			me->ForcedDespawn();
+		    else
+			DespawnTimer -= diff;
+		}
+	    }
+	    void MoveInLineOfSight(Unit * /*who*/){return;}
+	};
+
+	CreatureAI* GetAI(Creature* pCreature) const
+	{
+	    return new npc_training_dummy_argentAI(pCreature);
+	}
+
+};
+
+/*######
+* npc_quest_givers_for_crusaders
+######*/
+
+class npc_quest_givers_for_crusaders : public CreatureScript
+{
+public:
+	npc_quest_givers_for_crusaders(): CreatureScript("npc_quest_givers_for_crusaders"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		if (pPlayer->HasTitle(TITLE_CRUSADER))
+			if (pCreature->isQuestGiver())
+				pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+		pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+		return true;
+	}
+
+};
+
+/*######
+* npc_crusader_rhydalla
+######*/
+
+class npc_crusader_rhydalla : public CreatureScript
+{
+public:
+	npc_crusader_rhydalla(): CreatureScript("npc_crusader_rhydalla"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		// uint64 const guid = pCreature->GetGUID();
+
+		if (pCreature->isQuestGiver())
+		{
+			Object *pObject = (Object*)pCreature;
+			QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+			QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+			QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+			qm.ClearMenu();
+
+			for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+				if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+					qm.AddMenuItem(quest_id, 4);
+				else if (status == QUEST_STATUS_INCOMPLETE)
+					qm.AddMenuItem(quest_id, 4);
+				//else if (status == QUEST_STATUS_AVAILABLE)
+				//    qm.AddMenuItem(quest_id, 2);
+			}
+
+			for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+				if (!pQuest) continue;
+				QuestStatus status;
+				bool allowed=false;
+				switch(quest_id)
+				{
+					case 13664: // The Black Knigh's Fall
+						allowed = (pPlayer->GetQuestStatus(13700) == QUEST_STATUS_COMPLETE) || (pPlayer->GetQuestStatus(13701) == QUEST_STATUS_COMPLETE);
+						if(allowed)
+						{
+							status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					default:
+						status = pPlayer->GetQuestStatus(quest_id);
+
+						if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 4);
+						else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 2);
+						break;
+				}
+			}
+		}
+	    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+	    return true;
+	}
+
+};
+
+/*######
+* npc_eadric_the_pure
+######*/
+
+class npc_eadric_the_pure : public CreatureScript
+{
+public:
+	npc_eadric_the_pure(): CreatureScript("npc_eadric_the_pure"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		// uint64 const guid = pCreature->GetGUID();
+
+		if (pCreature->isQuestGiver())
+		{
+			Object *pObject = (Object*)pCreature;
+			QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+			QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+			QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+			qm.ClearMenu();
+
+			for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+				if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+					qm.AddMenuItem(quest_id, 4);
+				else if (status == QUEST_STATUS_INCOMPLETE)
+					qm.AddMenuItem(quest_id, 4);
+				//else if (status == QUEST_STATUS_AVAILABLE)
+				//    qm.AddMenuItem(quest_id, 2);
+			}
+
+			for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+				if (!pQuest) continue;
+				QuestStatus status;
+				bool allowed=false;
+				switch(quest_id)
+				{
+					case 13682: // Alliance Threat From Above
+					case 13809: // Horde Threat From Above
+						allowed = (pPlayer->GetQuestStatus(13664) == QUEST_STATUS_COMPLETE) && pPlayer->GetQuestRewardStatus(13664);
+						if(allowed)
+						{
+							status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					default:
+						status = pPlayer->GetQuestStatus(quest_id);
+
+						if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 4);
+						else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 2);
+						break;
+				}
+			}
+		}
+	    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+	    return true;
+	}
+
+};
+
+/*######
+* npc_justicar_mariel_trueheart
+######*/
+
+class npc_justicar_mariel_trueheart : public CreatureScript
+{
+public:
+	npc_justicar_mariel_trueheart(): CreatureScript("npc_justicar_mariel_trueheart"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		// uint64 const guid = pCreature->GetGUID();
+
+		if (pCreature->isQuestGiver())
+		{
+			Object *pObject = (Object*)pCreature;
+			QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+			QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+			QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+			qm.ClearMenu();
+
+			for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+				if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+					qm.AddMenuItem(quest_id, 4);
+				else if (status == QUEST_STATUS_INCOMPLETE)
+					qm.AddMenuItem(quest_id, 4);
+				//else if (status == QUEST_STATUS_AVAILABLE)
+				//    qm.AddMenuItem(quest_id, 2);
+			}
+
+			for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+				if (!pQuest) continue;
+				QuestStatus status;
+				bool allowed=false;
+				switch(quest_id)
+				{
+					case 13795: // The Scourgebane
+						allowed = (pPlayer->GetQuestStatus(13702) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13702)) || (pPlayer->GetQuestStatus(13732) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13732)) || (pPlayer->GetQuestStatus(13735) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13735)) || (pPlayer->GetQuestStatus(13733) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13733)) || (pPlayer->GetQuestStatus(13734) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13734)) || (pPlayer->GetQuestStatus(13736) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13736)) || (pPlayer->GetQuestStatus(13737) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13737)) || (pPlayer->GetQuestStatus(13738) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13738)) || (pPlayer->GetQuestStatus(13739) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13739)) || (pPlayer->GetQuestStatus(13740) == QUEST_STATUS_COMPLETE && pPlayer->GetQuestRewardStatus(13740)); // If the player has finished any of the "A Champion Rises" quests
+						if(allowed)
+						{
+							status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					default:
+						status = pPlayer->GetQuestStatus(quest_id);
+
+						if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 4);
+						else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 2);
+						break;
+				}
+			}
+		}
+	    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+	    return true;
+	}
+
+};
+
+/*######
+* npc_crok_scourgebane
+######*/
+
+class npc_crok_scourgebane : public CreatureScript
+{
+public:
+	npc_crok_scourgebane(): CreatureScript("npc_crok_scourgebane"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		// uint64 const guid = pCreature->GetGUID();
+
+		if (pCreature->isQuestGiver())
+		{
+			Object *pObject = (Object*)pCreature;
+			QuestRelations* pObjectQR = sObjectMgr->GetCreatureQuestRelationMap();
+			QuestRelations* pObjectQIR = sObjectMgr->GetCreatureQuestInvolvedRelation();
+
+			QuestMenu &qm = pPlayer->PlayerTalkClass->GetQuestMenu();
+			qm.ClearMenu();
+
+			for (QuestRelations::const_iterator i = pObjectQIR->lower_bound(pObject->GetEntry()); i != pObjectQIR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				QuestStatus status = pPlayer->GetQuestStatus(quest_id);
+				if (status == QUEST_STATUS_COMPLETE && !pPlayer->GetQuestRewardStatus(quest_id))
+					qm.AddMenuItem(quest_id, 4);
+				else if (status == QUEST_STATUS_INCOMPLETE)
+					qm.AddMenuItem(quest_id, 4);
+				//else if (status == QUEST_STATUS_AVAILABLE)
+				//    qm.AddMenuItem(quest_id, 2);
+			}
+
+			for (QuestRelations::const_iterator i = pObjectQR->lower_bound(pObject->GetEntry()); i != pObjectQR->upper_bound(pObject->GetEntry()); ++i)
+			{
+				uint32 quest_id = i->second;
+				Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+				if (!pQuest) continue;
+				QuestStatus status;
+				bool allowed=false;
+				switch(quest_id)
+				{
+					case 13788: // DK Threat From Above (Alliance)
+					case 13812: // DK Threat From Above (Horde)
+						allowed = (pPlayer->GetQuestStatus(13664) == QUEST_STATUS_COMPLETE) && pPlayer->GetQuestRewardStatus(13664);
+						if(allowed)
+						{
+							status = pPlayer->GetQuestStatus(quest_id);
+
+							if(pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 4);
+							else if(status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+								qm.AddMenuItem(quest_id, 2);
+						}
+						break;
+					default:
+						status = pPlayer->GetQuestStatus(quest_id);
+
+						if (pQuest->IsAutoComplete() && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 4);
+						else if (status == QUEST_STATUS_NONE && pPlayer->CanTakeQuest(pQuest, false))
+							qm.AddMenuItem(quest_id, 2);
+						break;
+				}
+			}
+		}
+	    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+	    return true;
+	}
+
+};
+
+/*
+* Npc Jeran Lockwood (33973)
+*/
+#define JERAN_DEFAULT_TEXTID 14453
+#define JERAN_QUEST_TEXTID 14431
+#define JERAN_RP_TEXTID 14434
+#define GOSSIP_HELLO_JERAN_1 "Montrez-moi comment m'entraÃÂ®ner sur une cible de mÃÂªlÃÂ©e."
+#define GOSSIP_HELLO_JERAN_2 "Parlez-moi de la dÃÂ©fense et du coup de lance."
+#define SPELL_CREDIT_JERAN 64113
+
+class npc_jeran_lockwood : public CreatureScript
+{
+public:
+	npc_jeran_lockwood(): CreatureScript("npc_jeran_lockwood"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		if((pPlayer->GetQuestStatus(13828) == QUEST_STATUS_INCOMPLETE) || (pPlayer->GetQuestStatus(13829) == QUEST_STATUS_INCOMPLETE))
+		{
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_JERAN_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_JERAN_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+		pPlayer->SEND_GOSSIP_MENU(JERAN_QUEST_TEXTID, pCreature->GetGUID());
+		}
+		else
+		{
+			pPlayer->SEND_GOSSIP_MENU(JERAN_DEFAULT_TEXTID, pCreature->GetGUID());
+		}
+		return true;
+	}
+
+	bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+		switch(uiAction)
+		{
+			case GOSSIP_ACTION_INFO_DEF+1:
+				pPlayer->CastSpell(pPlayer,SPELL_CREDIT_JERAN,true);
+				pPlayer->CLOSE_GOSSIP_MENU();
+				break;
+			case GOSSIP_ACTION_INFO_DEF+2:
+				pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_JERAN_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+				pPlayer->SEND_GOSSIP_MENU(JERAN_RP_TEXTID, pCreature->GetGUID());
+				break;
+		}
+		return true;
+	}
+
+};
+
+/*
+* Npc Rugan Steelbelly (33972)
+*/
+#define RUGAN_DEFAULT_TEXTID 14453
+#define RUGAN_QUEST_TEXTID 14436
+#define RUGAN_RP_TEXTID 14437
+#define GOSSIP_HELLO_RUGAN_1 "Montrez-moi comment m'entraÃÂ®ner sur une cible de charge."
+#define GOSSIP_HELLO_RUGAN_2 "Parlez-moi de la charge"
+#define SPELL_CREDIT_RUGAN 64114
+
+class npc_rugan_steelbelly : public CreatureScript
+{
+public:
+	npc_rugan_steelbelly(): CreatureScript("npc_rugan_steelbelly"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		if((pPlayer->GetQuestStatus(13837) == QUEST_STATUS_INCOMPLETE) || (pPlayer->GetQuestStatus(13839) == QUEST_STATUS_INCOMPLETE))
+		{
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_RUGAN_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_RUGAN_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+		pPlayer->SEND_GOSSIP_MENU(RUGAN_QUEST_TEXTID, pCreature->GetGUID());
+		}
+		else
+		{
+			pPlayer->SEND_GOSSIP_MENU(RUGAN_DEFAULT_TEXTID, pCreature->GetGUID());
+		}
+		return true;
+	}
+
+	bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+		switch(uiAction)
+		{
+			case GOSSIP_ACTION_INFO_DEF+1:
+				pPlayer->CastSpell(pPlayer,SPELL_CREDIT_RUGAN,true);
+				pPlayer->CLOSE_GOSSIP_MENU();
+				break;
+			case GOSSIP_ACTION_INFO_DEF+2:
+				pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_RUGAN_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+				pPlayer->SEND_GOSSIP_MENU(RUGAN_RP_TEXTID, pCreature->GetGUID());
+				break;
+		}
+		return true;
+	}
+
+};
+
+/*
+* Npc Valis Windchaser
+*/
+#define VALIS_DEFAULT_TEXTID 14453
+#define VALIS_QUEST_TEXTID 14438
+#define VALIS_RP_TEXTID 14439
+#define GOSSIP_HELLO_VALIS_1 "Montrez-moi comment m'entraÃÂ®ner sur une cible Ã distance."
+#define GOSSIP_HELLO_VALIS_2 "Expliquez-moi comment utiliser le brise-bouclier."
+#define SPELL_CREDIT_VALIS 64115
+class npc_valis_windchaser : public CreatureScript
+{
+public:
+	npc_valis_windchaser(): CreatureScript("npc_valis_windchaser"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+		//Si il a la quete
+		if((pPlayer->GetQuestStatus(13835) == QUEST_STATUS_INCOMPLETE) ||
+			(pPlayer->GetQuestStatus(13838) == QUEST_STATUS_INCOMPLETE))
+		{
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_VALIS_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+			pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_VALIS_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+		pPlayer->SEND_GOSSIP_MENU(VALIS_QUEST_TEXTID, pCreature->GetGUID());
+		}
+		//Sinon Texte par dÃ©faut
+		else
+			pPlayer->SEND_GOSSIP_MENU(VALIS_DEFAULT_TEXTID, pCreature->GetGUID());
+		return true;
+	}
+
+	bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+		switch (uiAction)
+		{
+			case GOSSIP_ACTION_INFO_DEF+1:
+				pPlayer->CastSpell(pPlayer,SPELL_CREDIT_VALIS,true);//Cast du sort de credit quest (valide l'objectif)
+				pPlayer->CLOSE_GOSSIP_MENU();//Ferme la fenetre du gossip cotÃ© client
+			break;
+			case GOSSIP_ACTION_INFO_DEF+2:
+				//Raconte un blabla
+				pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_VALIS_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+			pPlayer->SEND_GOSSIP_MENU(VALIS_RP_TEXTID, pCreature->GetGUID());
+			break;
+		}
+		return true;
+	}
+
+};
+
+/*######
+## npc_squire_danny
+######*/
+
+enum eSquireDanny
+{
+    QUEST_THE_VALIANT_S_CHALLENGE_0 = 13699,
+    QUEST_THE_VALIANT_S_CHALLENGE_1 = 13713,
+    QUEST_THE_VALIANT_S_CHALLENGE_2 = 13723,
+    QUEST_THE_VALIANT_S_CHALLENGE_3 = 13724,
+    QUEST_THE_VALIANT_S_CHALLENGE_4 = 13725,
+    QUEST_THE_VALIANT_S_CHALLENGE_5 = 13726,
+    QUEST_THE_VALIANT_S_CHALLENGE_6 = 13727,
+    QUEST_THE_VALIANT_S_CHALLENGE_7 = 13728,
+    QUEST_THE_VALIANT_S_CHALLENGE_8 = 13729,
+    QUEST_THE_VALIANT_S_CHALLENGE_9 = 13731,
+
+    NPC_ARGENT_CHAMPION = 33707,
+
+    GOSSIP_TEXTID_SQUIRE_DANNY = 14407
+};
+
+#define GOSSIP_SQUIRE_ITEM_1 "I am ready to fight!"
+#define GOSSIP_SQUIRE_ITEM_2 "How do the Argent Crusader raiders fight?"
+
+class npc_squire_danny : public CreatureScript
+{
+public:
+	npc_squire_danny(): CreatureScript("npc_squire_danny"){}
+
+	bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+	{
+	    if (pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_0) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_1) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_2) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_3) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_4) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_5) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_6) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_7) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_8) == QUEST_STATUS_INCOMPLETE ||
+		pPlayer->GetQuestStatus(QUEST_THE_VALIANT_S_CHALLENGE_9) == QUEST_STATUS_INCOMPLETE)
+	    {
+		pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_SQUIRE_ITEM_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+		pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_SQUIRE_ITEM_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+	    }
+
+	    pPlayer->SEND_GOSSIP_MENU(GOSSIP_TEXTID_SQUIRE_DANNY, pCreature->GetGUID());
+	    return true;
+	}
+
+	bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+	    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+	    {
+		pPlayer->CLOSE_GOSSIP_MENU();
+		pCreature->SummonCreature(NPC_ARGENT_CHAMPION,8562.836914,1099.153931,556.787598,5.026550); // TODO (RÃ©cupÃ©rer les coordonnÃ©es rÃ©elles)
+	    }
+	    //else
+		//pPlayer->SEND_GOSSIP_MENU(???, pCreature->GetGUID()); Missing text
+	    return true;
+	}
+
+};
+
+/*######
+## npc_argent_champion
+######*/
+
+enum eArgentChampion
+{
+    SPELL_CHARGE_CHAMPION                = 63010,
+    SPELL_SHIELD_BREAKER_CHAMPION        = 65147,
+    SPELL_DEFEND_CHAMPION		= 62719,
+    SPELL_THRUST_CHAMPION		= 62544,
+
+    NPC_ARGENT_CHAMPION_CREDIT   = 33708
+};
+
+enum eChampionText
+{
+	NPC_FACTION_CHAMPION_TEXT_SAY_START_1 	= -1850004,//	Tenez-vous prÃªt !
+	NPC_FACTION_CHAMPION_TEXT_SAY_START_2 	= -1850005,//	Que le combat commence !
+	NPC_FACTION_CHAMPION_TEXT_SAY_START_3 	= -1850006,//	PrÃ©parez-vous !
+	NPC_ARGENT_CHAMPION_TEXT_SAY_START 		= -1850007,//	Vous pensez avoir la vaillance en vous ? Nous verrons.
+	NPC_ARGENT_CHAMPION_TEXT_SAY_WIN 		= -1850008,//	Impressionnante dÃ©monstration. Je pense que vous Ãªtes tout Ã  fait en mesure de rejoindre les rangs des vaillants.
+	NPC_ARGENT_CHAMPION_TEXT_SAY_LOOSE 		= -1850009,//	J'ai gagnÃ©. Vous aurez sans doute plus de chance la prochaine fois.
+	NPC_FACTION_CHAMPION_TEXT_SAY_WIN_1 	= -1850010,//	Je suis vaincue. Joli combat !
+	NPC_FACTION_CHAMPION_TEXT_SAY_WIN_2 	= -1850011,//	On dirait que j'ai sous-estimÃ© vos compÃ©tences. Bien jouÃ©.
+	NPC_FACTION_CHAMPION_TEXT_SAY_LOOSE 	= -1850012,//	J'ai gagnÃ©. Vous aurez sans doute plus de chance la prochaine fois.
+};
+
+class npc_argent_champion : public CreatureScript
+{
+public:
+	npc_argent_champion(): CreatureScript("npc_argent_champion"){}
+
+	struct npc_argent_championAI : public ScriptedAI
+	{
+	    npc_argent_championAI(Creature* pCreature) : ScriptedAI(pCreature)
+	    {
+		me->CastSpell(me, SPELL_DEFEND_CHAMPION, true);
+		me->CastSpell(me, SPELL_DEFEND_CHAMPION, true);
+		pCreature->GetMotionMaster()->MovePoint(0,8552.469727,1124.128784,556.787598); // TODO (Trouver les coordonnÃ©es exactes)
+		pCreature->setFaction(35); //wrong faction in db?
+	    }
+
+	    uint32 uiChargeTimer;
+	    uint32 uiShieldBreakerTimer;
+	    uint32 uiDefendTimer;
+
+	    void Reset()
+	    {
+		uiChargeTimer = 7000;
+		uiShieldBreakerTimer = 10000;
+	    }
+
+	    void MovementInform(uint32 uiType, uint32 /*uiId*/)
+	    {
+		if (uiType != POINT_MOTION_TYPE)
+		    return;
+
+		me->setFaction(14);
+	    }
+
+	    void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+	    {
+			if(pDoneBy)
+			{
+				if (uiDamage > me->GetHealth() && (pDoneBy->GetTypeId() == TYPEID_PLAYER || pDoneBy->GetOwner()))
+				{
+					DoScriptText(NPC_ARGENT_CHAMPION_TEXT_SAY_WIN, me);
+					uiDamage = 0;
+
+					if(pDoneBy->GetOwner())
+						(pDoneBy->GetOwner())->ToPlayer()->KilledMonsterCredit(NPC_ARGENT_CHAMPION_CREDIT,0);
+					if(pDoneBy->GetTypeId() == TYPEID_PLAYER)
+						pDoneBy->ToPlayer()->KilledMonsterCredit(NPC_ARGENT_CHAMPION_CREDIT,0);
+
+					me->setFaction(35);
+					me->ForcedDespawn(5000);
+					me->SetHomePosition(me->GetPositionX(),me->GetPositionY(),me->GetPositionZ(),me->GetOrientation());
+					EnterEvadeMode();
+				}
+			}
+	    }
+
+	    void KilledUnit(Unit* /*victim*/)
+	    {
+		me->setFaction(35);
+		me->ForcedDespawn(5000);
+		DoScriptText(NPC_ARGENT_CHAMPION_TEXT_SAY_LOOSE, me);
+		me->CombatStop(true);
+	    }
+
+	    void DoMeleeAttackIfReady()
+		{
+			if (me->HasUnitState(UNIT_STAT_CASTING))
+			    return;
+
+			//Make sure our attack is ready and we aren't currently casting before checking distance
+			if (me->isAttackReady())
+			{
+			    //If we are within range melee the target
+			    if (me->IsWithinMeleeRange(me->getVictim()))
+			    {
+				DoCastVictim(SPELL_THRUST_CHAMPION);
+				me->resetAttackTimer();
+			    }
+			}
+		}
+
+	    void EnterCombat(Unit* /*who*/)
+	    {
+		DoScriptText(NPC_ARGENT_CHAMPION_TEXT_SAY_START, me);
+	    }
+
+	    void UpdateAI(const uint32 uiDiff)
+	    {
+		if (!UpdateVictim())
+		    return;
+
+		if (uiChargeTimer <= uiDiff)
+		{
+		    DoCastVictim(SPELL_CHARGE_CHAMPION);
+		    uiChargeTimer = 7000;
+		} else uiChargeTimer -= uiDiff;
+
+		if (uiShieldBreakerTimer <= uiDiff)
+		{
+		    DoCastVictim(SPELL_SHIELD_BREAKER_CHAMPION);
+		    uiShieldBreakerTimer = 10000;
+		} else uiShieldBreakerTimer -= uiDiff;
+
+		if (uiDefendTimer <= uiDiff)
+		{
+		    me->CastSpell(me, SPELL_DEFEND_CHAMPION, true);
+		    uiDefendTimer = 10000;
+		} else uiDefendTimer -= uiDiff;
+
+		DoMeleeAttackIfReady();
+	    }
+	};
+
+	CreatureAI* GetAI(Creature* pCreature) const
+	{
+	    return new npc_argent_championAI (pCreature);
+	}
+
+};
+
 void AddSC_icecrown()
 {
     new npc_arete;
@@ -432,4 +1434,17 @@ void AddSC_icecrown()
     new npc_argent_tournament_post;
     new npc_alorah_and_grimmin;
     new npc_guardian_pavilion;
+    new npc_vendor_argent_tournament;
+    new quest_givers_argent_tournament;
+    new npc_training_dummy_argent;
+    new npc_quest_givers_for_crusaders;
+    new npc_justicar_mariel_trueheart;
+    new npc_crusader_rhydalla;
+    new npc_eadric_the_pure;
+    new npc_crok_scourgebane;
+    new npc_valis_windchaser;
+    new npc_rugan_steelbelly;
+    new npc_jeran_lockwood;
+    new npc_squire_danny;
+    new npc_argent_champion;
 }
diff --git a/src/server/shared/Database/Implementation/LoginDatabase.h b/src/server/shared/Database/Implementation/LoginDatabase.h
index cd7c7cf..e6bf23d 100755
--- a/src/server/shared/Database/Implementation/LoginDatabase.h
+++ b/src/server/shared/Database/Implementation/LoginDatabase.h
@@ -62,6 +62,7 @@ enum LoginDatabaseStatements
     LOGIN_SET_IP_NOT_BANNED,
     LOGIN_SET_ACCOUNT_BANNED,
     LOGIN_SET_ACCOUNT_NOT_BANNED,
+	LOGIN_SET_ACCOUNT_PREMIUM,
 
     MAX_LOGINDATABASE_STATEMENTS,
 };
@@ -87,7 +88,8 @@ static const PreparedStatementTable LoginDatabasePreparedStatements[] =
     {LOGIN_SET_IP_BANNED, "INSERT INTO ip_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, ?, ?)", CONNECTION_ASYNC},
     {LOGIN_SET_IP_NOT_BANNED, "DELETE FROM ip_banned WHERE ip = ?", CONNECTION_ASYNC},
     {LOGIN_SET_ACCOUNT_BANNED, "INSERT INTO account_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, ?, ?, 1)", CONNECTION_ASYNC},
-    {LOGIN_SET_ACCOUNT_NOT_BANNED, "UPDATE account_banned SET active = 0 WHERE id = ? AND active != 0", CONNECTION_ASYNC}
+    {LOGIN_SET_ACCOUNT_NOT_BANNED, "UPDATE account_banned SET active = 0 WHERE id = ? AND active != 0", CONNECTION_ASYNC},
+	(LOGIN_SET_ACCOUNT_PREMIUM, "UPDATE account_premium SET active = 0 WHERE unsetdate<=UNIX_TIMESTAMP() AND unsetdate<>setdate", CONNECTION_ASYNC)
 };
 
 #endif
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 188d6d8..b0d5bc8 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2014,10 +2014,18 @@ Rate.Drop.Item.ReferencedAmount = 1
 #        Default:     1 - (Rate.XP.Kill)
 #                     1 - (Rate.XP.Quest)
 #                     1 - ( Rate.XP.Explore)
+#    Rate.XP.Kill.Premium
+#    Rate.XP.Quest.Premium
+#    Rate.XP.Explore.Premium
+#        XP rates Premium modifier
+#        Default: 1
 
 Rate.XP.Kill    = 1
 Rate.XP.Quest   = 1
 Rate.XP.Explore = 1
+Rate.XP.Kill.Premium    = 1
+Rate.XP.Quest.Premium   = 1
+Rate.XP.Explore.Premium = 1
 
 #
 #    Rate.RepairCost
@@ -2484,6 +2492,296 @@ Network.TcpNodelay = 1
 #
 ###################################################################################################
 
+ ###############################################################################
+# MOVEMENT ANTICHEAT
+#
+#    Anticheat.Movement.Enable
+#        Enable Movement Anticheat
+#        Default: 1 - on
+#                 0 - off
+#
+#    Anticheat.Movement.TeleportToPlaneAlarms
+#        maximum alarms before logging mode will be switched from debug to error (default 50, allowed 20 - 100)
+#
+#    Anticheat.Movement.MistimingDelta
+#        mistiming intelval between client and serverside (default 15000 ms, allowed 5000 - 50000 ms)
+#
+#    Anticheat.Movement.MistimingAlarms
+#        mistiming alarms before logging mode will be switched from debug to error (default 200, allowed 100 - 500)
+#
+###############################################################################
+
+Anticheat.Movement.Enable = 1
+Anticheat.Movement.TeleportToPlaneAlarms = 50
+Anticheat.Movement.MistimingDelta = 15000
+Anticheat.Movement.MistimingAlarms = 200
+
+###############################################################################
+# AUCTION HOUSE BOT SETTINGS
+#
+#    AuctionHouseBot.DEBUG
+#        Enable/Disable Debugging output
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.DEBUG_FILTERS
+#        Enable/Disable Debugging output from Filters
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableSeller
+#        Enable/Disable the part of AHBot that puts items up for auction
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableBuyer
+#        Enable/Disable the part of AHBot that buys items from players
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.UseBuyPriceForSeller
+#        Should the Seller use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    AuctionHouseBot.UseBuyPriceForBuyer
+#        Should the Buyer use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    Auction House Bot character data
+#        AuctionHouseBot.Account is the account number
+#         (in realmd->account table) of the player you want to run
+#         as the auction bot.
+#        AuctionHouseBot.GUID is the GUID (in characters->characters table)
+#         of the player you want to run as the auction bot.
+#    Default: 0 (Auction House Bot disabled)
+#
+#    AuctionHouseBot.ItemsPerCycle
+#        Number of Items to Add/Remove from the AH during mass operations
+#    Default 200
+#
+###############################################################################
+
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.DEBUG_FILTERS = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 1
+#
+#    AuctionHouseBot.VendorItems
+#        Include items that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.VendorTradeGoods
+#        Include Trade Goods that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.LootItems
+#        Include items that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.LootTradeGoods
+#        Include Trade Goods that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.OtherItems
+#        Include misc. items.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.OtherTradeGoods
+#        Include misc. Trade Goods.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.Bonding_types
+#        Indicates which bonding types to allow seller to put up for auction
+#            No_Bind
+#             Default 1 (True)
+#            Bind_When_Picked_Up
+#             Default 0 (False)
+#            Bind_When_Equipped
+#             Default 1 (True)
+#            Bind_When_Use
+#             Default 1 (True)
+#            Bind_Quest_Item
+#             Default 0 (False)
+#
+#    AuctionHouseBot.DisableBeta_PTR_Unused
+#        Disable certain items that are usually unavailable to Players
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisablePermEnchant
+#        Disable Items with a Permanent Enchantment
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableConjured
+#        Disable Conjured Items
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableGems
+#        Disable Gems
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoney
+#        Disable Items that are used as money
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoneyLoot
+#        Disable Items that have Money as a loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableLootable
+#        Disable Items that have other items as loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableKeys
+#        Disable Items that are keys
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableDuration
+#        Disable Items with a duration
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel
+#        Disable items that are BOP or Quest Item
+#        with a Required level that is less than the Item Level
+#        (This prevents a level 10 with a level 60 weapon or armor)
+#        (May need further refinement)
+#    Default 0 (False)
+#
+###############################################################################
+
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisableBeta_PTR_Unused = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 2
+#
+#     These Filters are boolean (0 or 1) and will disable items that are
+#     specifically meant for the Class named.
+#     (UnusedClass is Class 10, which was skipped for some reason)
+#     Default 0 (allowed)
+#
+###############################################################################
+
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 3
+#
+#    AuctionHouseBot.DisableItemsBelowLevel
+#        Prevent Seller from listing Items below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveLevel
+#        Prevent Seller from listing Items above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowLevel
+#        Prevent Seller from listing Trade Goods below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveLevel
+#        Prevent Seller from listing Trade Goods above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowGUID
+#        Prevent Seller from listing Items below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveGUID
+#        Prevent Seller from listing Items above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowGUID
+#        Prevent Seller from listing Trade Goods below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveGUID
+#        Prevent Seller from listing Trade Goods above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqLevel
+#        Prevent Seller from listing Items below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqLevel
+#        Prevent Seller from listing Items above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqLevel
+#        Prevent Seller from listing Trade Goods below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqLevel
+#        Prevent Seller from listing Trade Goods above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqSkillRank
+#        Prevent Seller from listing Items below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqSkillRank
+#        Prevent Seller from listing Items above this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqSkillRank
+#        Prevent Seller from listing Trade Goods below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqSkillRank
+#        Prevent Seller from listing Trade Goods above this Required Skill Rank
+#    Default 0 (Off)
+#
+###############################################################################
+
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
 ###################################################################################################
 # CONSOLE AND REMOTE ACCESS
 #
-- 
1.7.2.3

